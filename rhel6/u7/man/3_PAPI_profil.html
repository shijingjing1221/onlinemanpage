<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:25:23 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PAPI_profil(3) PAPI PAPI_profil(3)</p>

<p>NAME PAPI_profil - generate a histogram of hardware
counter overflows vs. PC addresses</p>

<p>SYNOPSIS C Interface #include &lt;papi.h&gt; int
PAPI_profil(void * buf, unsigned bufsiz, unsigned long
offset, unsigned scale, int EventSet, int EventCode, int
threshold, int flags);</p>

<p>Fortran Interface The profiling routines have no Fortran
interface.</p>

<p>DESCRIPTION PAPI_profil() provides hardware event
statistics by profiling the occurence of specified hardware
counter events. It is designed to mimic the UNIX SVR4 profil
call. The statistics are generated by creating a histogram
of hardware counter event overflows vs. program counter
addresses for the current process. The histogram is defined
for a spe- cific region of program code to be profiled, and
the identified region is logically broken up into a set of
equal size subdivisions, each of which corresponds to a
count in the histogram. With each hardware event overflow,
the current subdivision is identified and its corresponding
histogram count is incremented. These counts establish a
relative mea- sure of how many hardware counter events are
occuring in each code sub- division. The resulting histogram
counts for a profiled region can be used to identify those
program addresses that generate a disproportion- ately high
percentage of the event of interest.</p>

<p>Events to be profiled are specified with the EventSet
and EventCode parameters. More than one event can be
simultaneously profiled by call- ing PAPI_profil() several
times with different EventCode values. Pro- filing can be
turned off for a given event by calling PAPI_profil() with a
threshold value of 0.</p>

<p>ARGUMENTS *buf -- pointer to a buffer of bufsiz bytes in
which the histogram counts are stored in an array of
unsigned short, unsigned int, or unsigned long long values,
or buckets. The size of the buckets is determined by values
in the flags argument.</p>

<p>bufsiz -- the size of the histogram buffer in bytes. It
is computed from the length of the code region to be
profiled, the size of the buckets, and the scale factor as
discussed below.</p>

<p>offset -- the start address of the region to be
profiled.</p>

<p>scale -- broadly and historically speaking, a
contraction factor that indicates how much smaller the
histogram buffer is than the region to be profiled. More
precisely, scale is interpreted as an unsigned 16-bit
fixed-point fraction with the decimal point implied on the
left. Its value is the reciprocal of the number of addresses
in a subdivision, per counter of histogram buffer. Below is
a table of representative values for scale:</p>


<p>+--------------------------------------------------------------------------------------------+
| Representative values for the scale variable |
+--------+---------+-------------------------------------------------------------------------+
|HEX | DECIMAL | DEFININTION |
+--------+---------+-------------------------------------------------------------------------+
|0x20000 | 131072 | Maps precisely one instruction address
to a unique bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
|0x10000 | 65536 | Maps precisely two instruction addresses
to a unique bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
| 0xFFFF | 65535 | Maps approximately two instruction
addresses to a unique bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
| 0x8000 | 32768 | Maps every four instruction addresses to
a bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
| 0x4000 | 16384 | Maps every eight instruction addresses to
a bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
| 0x0002 | 2 | Maps all instruction addresses to the same
bucket in buf. |
+--------+---------+-------------------------------------------------------------------------+
| 0x0001 | 1 | Undefined. |
+--------+---------+-------------------------------------------------------------------------+
| 0x0000 | 0 | Undefined. |
+--------+---------+-------------------------------------------------------------------------+</p>

<p>Historically, the scale factor was introduced to allow
the allocation of buffers smaller than the code size to be
profiled. Data and instruc- tion sizes were assumed to be
multiples of 16-bits. These assumptions are no longer
necessarily true. PAPI_profil has preserved the tradi-
tional definition of scale where appropriate, but deprecated
the defi- nitions for 0 and 1 (disable scaling) and extended
the range of scale to include 65536 and 131072 to allow for
exactly two addresses and exactly one address per profiling
bucket.</p>

<p>The value of bufsiz is computed as follows:</p>

<p>bufsiz = (end - start)*(bucket_size/2)*(scale/65536)
where</p>

<p>bufsiz - the size of the buffer in bytes</p>

<p>end, start - the ending and starting addresses of the
profiled region</p>

<p>bucket_size - the size of each bucket in bytes; 2, 4, or
8 as defined in flags</p>

<p>scale - as defined above</p>

<p>EventSet -- The PAPI EventSet to profile. This EventSet
is marked as profiling-ready, but profiling doesn t actually
start until a PAPI_start() call is issued.</p>

<p>EventCode -- Code of the Event in the EventSet to
profile. This event must already be a member of the
EventSet.</p>

<p>threshold -- minimum number of events that must occur
before the PC is sampled. If hardware overflow is supported
for your substrate, this threshold will trigger an interrupt
when reached. Otherwise, the coun- ters will be sampled
periodically and the PC will be recorded for the first
sample that exceeds the threshold. If the value of threshold
is 0, profiling will be disabled for this event.</p>

<p>flags -- bit pattern to control profiling behavior.
Defined values are shown in the table below:</p>

<p>+---------------------------------------------------+ |
Defined bits for the flags variable |
+----------------------+----------------------------+
|PAPI_PROFIL_POSIX | Default type of profiling, | | |
similar to profil(3). |
+----------------------+----------------------------+
|PAPI_PROFIL_RANDOM | Drop a random 25% of the | | |
samples. |
+----------------------+----------------------------+
|PAPI_PROFIL_WEIGHTED | Weight the samples by | | | their
value. |
+----------------------+----------------------------+
|PAPI_PROFIL_COMPRESS | Ignore samples as values | | | in
the hash buckets get | | | big. |
+----------------------+----------------------------+
|PAPI_PROFIL_BUCKET_16 | Use unsigned short (16 | | | bit)
buckets, This is the | | | default bucket. |
+----------------------+----------------------------+
|PAPI_PROFIL_BUCKET_32 | Use unsigned int (32 bit) | | |
buckets. |
+----------------------+----------------------------+
|PAPI_PROFIL_BUCKET_64 | Use unsigned long long (64 | | |
bit) buckets. |
+----------------------+----------------------------+
|PAPI_PROFIL_FORCE_SW | Force software overflow in | | |
profiling. |
+----------------------+----------------------------+ | | |
+----------------------+----------------------------+</p>

<p>RETURN VALUES On success, this function returns PAPI_OK.
On error, a non-zero error code is returned.</p>

<p>ERRORS PAPI_EINVAL One or more of the arguments is
invalid.</p>

<p>PAPI_ENOMEM Insufficient memory to complete the
operation.</p>

<p>PAPI_ENOEVST The EventSet specified does not exist.</p>

<p>PAPI_EISRUN The EventSet is currently counting
events.</p>

<p>PAPI_ECNFLCT The underlying counter hardware can not
count this event and other events in the EventSet
simultaneously.</p>

<p>PAPI_ENOEVNT The PAPI preset is not available on the
underlying hardware.</p>

<p>EXAMPLES int retval; unsigned long length;
PAPI_exe_info_t *prginfo; unsigned short *profbuf;</p>

<p>if ((prginfo = PAPI_get_executable_info()) == NULL)
handle_error(1);</p>

<p>length = (unsigned long)(prginfo-&gt;text_end -
prginfo-&gt;text_start);</p>

<p>profbuf = (unsigned short *)malloc(length); if (profbuf
== NULL) handle_error(1); memset(profbuf,0x00,length); . . .
if ((retval = PAPI_profil(profbuf, length, start, 65536,
EventSet, PAPI_FP_INS, 1000000, PAPI_PROFIL_POSIX |
PAPI_PROFIL_BUCKET_16)) != PAPI_OK)
handle_error(retval);</p>

<p>BUGS If you call PAPI_profil, PAPI allocates buffer
space that will not be freed if you call PAPI_shutdown or
PAPI_cleanup_eventset. To clean all memory, you must call
PAPI_profil on the Events with a 0 threshold.</p>

<p>SEE ALSO PAPI_sprofil(3), PAPI_overflow(3),
PAPI_get_executable_info(3)</p>

<p>PAPI Programmer s Reference September, 2004
PAPI_profil(3)</p>
<hr>
</body>
</html>
