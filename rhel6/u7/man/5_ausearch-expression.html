<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:05:08 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>AUSEARCH-EXPRESSION(5) Linux Audit
AUSEARCH-EXPRESSION(5)</p>

<p>NAME ausearch-expression - audit search expression
format</p>

<p>OVERVIEW This man page describes the format of
&quot;ausearch expressions&quot;. Parsing and evaluation of
these expressions is provided by libauparse and is common to
applications that use this library.</p>

<p>LEXICAL STRUCTURE White space (ASCII space, tab and
new-line characters) between tokens is ignored. The
following tokens are recognized:</p>

<p>Punctuation ( )</p>

<p>Logical operators ! &amp;&amp; ||</p>

<p>Comparison operators &lt; &lt;= == &gt; &gt;= !== i= i!=
r= r!=</p>

<p>Unquoted strings Any non-empty sequence of ASCII
letters, digits, and the _ sym- bol.</p>

<p>Quoted strings A sequence of characters surrounded by
the &quot; quotes. The character starts an escape sequence.
The only defined escape sequences are \ and sequences is
undefined.</p>

<p>Regexps A sequence of characters surrounded by the /
characters. The character starts an escape sequence. The
only defined escape sequences are \ and/. The semantics of
other escape sequences is undefined.</p>

<p>Anywhere an unquoted string is valid, a quoted string is
valid as well, and vice versa. In particular, field names
may be specified using quoted strings, and field values may
be specified using unquoted strings.</p>

<p>EXPRESSION SYNTAX The primary expression has one of the
following forms:</p>

<p>field comparison-operator value</p>

<p>regexp string-or-regexp</p>

<p>field is either a string, which specifies the first
field with that name within the current audit record, or the
escape character followed by a string, which specifies a
virtual field with the speci- fied name (virtual fields are
defined in a later section).</p>

<p>field is a string. operator specifies the comparison to
perform</p>

<p>r= r!= Get the &quot;raw&quot; string of field, and
compare it to value. For fields in audit records, the
&quot;raw&quot; string is the exact string stored in the
audit record (with all escaping and unprintable character
encoding left alone); applications can read the
&quot;raw&quot; string using auparse_get_field_str(3). Each
virtual field may define a &quot;raw&quot; string. If field
is not present or does not define a &quot;raw&quot; string,
the result of the comparison is false (regardless of the
operator).</p>

<p>i= i!= Get the &quot;interpreted&quot; string of field,
and compare it to value. For fields in audit records, the
&quot;interpreted&quot; string is an
&quot;user-readable&quot; interpretation of the field value;
applications can read the &quot;interpreted&quot; string
using auparse_inter- pret_field(3). Each virtual field may
define an &quot;interpreted&quot; string. If field is not
present or does not define an &quot;inter- preted&quot;
string, the result of the comparison is false (regard- less
of the operator).</p>

<p>&lt; &lt;= == &gt; &gt;= !== Evaluate the
&quot;value&quot; of field, and compare it to value. A
&quot;value&quot; may be defined for any field or virtual
field, but no &quot;value&quot; is currently defined for any
audit record field. The rules of parsing value for comparing
it with the &quot;value&quot; of field are specific for each
field. If field is not present, the result of the comparison
is false (regardless of the operator). If field does not
define a &quot;value&quot;, an error is reported when
parsing the expression.</p>

<p>regexp regexp-or-string, the In the special case of
current audit record is taken as a string (without
interpreting field values), and matched against
regexp-or-string. regexp-or-string is an extended reg- ular
expression, using a string or regexp token (in other words,
delim- ited by &quot; or /).</p>

<p>If E1 and E2 are valid expressions, then ! E1, E1
&amp;&amp; E2, and E1 || E2 are valid expressions as well,
with the usual C semantics and evalua- tion priorities. Note
that ! field op value is interpreted as !(field op value),
not as (!field) op value.</p>

<p>VIRTUAL FIELDS The following virtual fields are
defined:</p>

<p>timestamp The value is the timestamp of the current
event. value must have the ts:seconds.milli format, where
seconds and milli are decimal numbers specifying the seconds
and milliseconds part of the timestamp, respectively.</p>

<p>record_type The value is the type of the current record.
value is either the record type name, or a decimal number
specifying the type.</p>

<p>SEMANTICS The expression as a whole applies to a single
record. The expression is true for a specified event if it
is true for any record associated with the event.</p>

<p>EXAMPLES As a demonstration of the semantics of handling
missing fields, the following expression is true if field is
present:</p>

<p>(field r= &quot;&quot;) || (field r!= &quot;&quot;)</p>

<p>and the same expression surrounded by !( and ) is true
if field is not present.</p>

<p>FUTURE DIRECTIONS New escape sequences for quoted
strings may be defined.</p>

<p>For currently defined virtual fields that do not define
a &quot;raw&quot; or &quot;interpreted&quot; string, the
definition may be added. Therefore, dont rely on the fact
that comparing the &quot;raw&quot; or
&quot;interpreted&quot; string of the field with any value
is false.</p>

<p>New formats of value constants for thtimestamp virtual
field may be added.</p>

<p>AUTHOR Miloslav Trmac</p>

<p>Red Hat Feb 2008 AUSEARCH-EXPRESSION(5)</p>
<hr>
</body>
</html>
