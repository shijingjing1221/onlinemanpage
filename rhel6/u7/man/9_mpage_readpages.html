<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:23:10 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MPAGE_READPAGES(9) The Linux VFS MPAGE_READPAGES(9)</p>

<p>NAME mpage_readpages - populate an address space with
some pages &amp; start reads against them</p>

<p>SYNOPSIS int mpage_readpages(struct address_space *
mapping, struct list_head * pages, unsigned nr_pages,
get_block_t get_block);</p>

<p>ARGUMENTS mapping the address_space</p>

<p>pages The address of a list_head which contains the
target pages. These pages have their -&gt;index populated
and are otherwise uninitialised. The page at pages-&gt;prev
has the lowest file offset, and reads should be issued in
pages-&gt;prev to pages-&gt;next order.</p>

<p>nr_pages The number of pages at *pages</p>

<p>get_block The filesystem&acute;s block mapper
function.</p>

<p>DESCRIPTION This function walks the pages and the blocks
within each page, building and emitting large BIOs.</p>

<p>If anything unusual happens, such as:</p>

<p>- encountering a page which has buffers - encountering a
page which has a non-hole after a hole - encountering a page
with non-contiguous blocks</p>

<p>then this code just gives up and calls the
buffer_head-based read function. It does handle a page which
has holes at the end - that is a common case: the
end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.</p>

<p>BH_BOUNDARY EXPLANATION There is a problem. The mpage
read code assembles several pages, gets all their disk
mappings, and then submits them all. That&acute;s fine, but
obtaining the disk mappings may require I/O. Reads of
indirect blocks, for example.</p>

<p>So an mpage read of the first 16 blocks of an ext2 file
will cause I/O to be</p>

<p>SUBMITTED IN THE FOLLOWING ORDER 12 0 1 2 3 4 5 6 7 8 9
10 11 13 14 15 16</p>

<p>because the indirect block has to be read to get the
mappings of blocks 13,14,15,16. Obviously, this impacts
performance.</p>

<p>So what we do it to allow the filesystem&acute;s
get_block function to set BH_Boundary when it maps block 11.
BH_Boundary says: mapping of the block after this one will
require I/O against a block which is probably close to this
one. So you should push what I/O you have currently
accumulated.</p>

<p>This all causes the disk requests to be issued in the
correct order.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
MPAGE_READPAGES(9)</p>
<hr>
</body>
</html>
