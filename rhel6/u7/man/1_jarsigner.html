<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:18 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>jarsigner(1) Security Tools jarsigner(1)</p>

<p>NAME jarsigner - Signs and verifies Java Archive (JAR)
files.</p>

<p>SYNOPSIS jarsigner [ options ] jar-file alias</p>

<p>jarsigner -verify [ options ] jar-file [alias ...]</p>

<p>options The command-line options. See Options.</p>

<p>-verify The -verify option can take zero or more
keystore alias names after the JAR file name. When the
-verify option is specified, the jarsigner command checks
that the certificate used to verify each signed entry in the
JAR file matches one of the keystore aliases. The aliases
are defined in the keystore specified by -keystore or the
default keystore.</p>

<p>If you also specified the -strict option, and the
jarsigner command detected severe warnings, the message,
&quot;jar verified, with signer errors&quot; is
displayed.</p>

<p>jar-file The JAR file to be signed.</p>

<p>If you also specified the -strict option, and the
jarsigner command detected severe warnings, the message,
&quot;jar signed, with signer errors&quot; is displayed.</p>

<p>alias The aliases are defined in the keystore specified
by -keystore or the default keystore.</p>

<p>DESCRIPTION The jarsigner tool has two purposes:</p>

<p>&middot; To sign Java Archive (JAR) files.</p>

<p>&middot; To verify the signatures and integrity of
signed JAR files.</p>

<p>The JAR feature enables the packaging of class files,
images, sounds, and other digital data in a single file for
faster and easier distribution. A tool named jar enables
developers to produce JAR files. (Technically, any zip file
can also be considered a JAR file, although when created by
the jar command or processed by the jarsigner command, JAR
files also contain a META-INF/MANIFEST.MF file.)</p>

<p>A digital signature is a string of bits that is computed
from some data (the data being signed) and the private key
of an entity (a person, company, and so on). Similar to a
handwritten signature, a digital signature has many useful
characteristics:</p>

<p>&middot; Its authenticity can be verified by a
computation that uses the public key corresponding to the
private key used to generate the signature.</p>

<p>&middot; It cannot be forged, assuming the private key
is kept secret.</p>

<p>&middot; It is a function of the data signed and thus
cannot be claimed to be the signature for other data as
well.</p>

<p>&middot; The signed data cannot be changed. If the data
is changed, then the signature cannot be verified as
authentic.</p>

<p>To generate an entitys signature for a file, the entity
must first have a public/private key pair associated with it
and one or more certificates that authenticate its public
key. A certificate is a digitally signed statement from one
entity that says that the public key of another entity has a
particular value.</p>

<p>The jarsigner command uses key and certificate
information from a keystore to generate digital signatures
for JAR files. A keystore is a database of private keys and
their associated X.509 certificate chains that authenticate
the corresponding public keys. The keytool command is used
to create and administer keystores.</p>

<p>The jarsigner command uses an entity s private key to
generate a signature. The signed JAR file contains, among
other things, a copy of the certificate from the keystore
for the public key corresponding to the private key used to
sign the file. The jarsigner command can verify the digital
signature of the signed JAR file using the certificate
inside it (in its signature block file).</p>

<p>The jarsigner command can generate signatures that
include a time stamp that lets a systems or deployer
(including Java Plug-in) to check whether the JAR file was
signed while the signing certificate was still valid. In
addition, APIs allow applications to obtain the timestamp
information.</p>

<p>At this time, the jarsigner command can only sign JAR
files created by the jar command or zip files. JAR files are
the same as zip files, except they also have a
META-INF/MANIFEST.MF file. A META- INF/MANIFEST.MF file is
created when the jarsigner command signs a zip file.</p>

<p>The default jarsigner command behavior is to sign a JAR
or zip file. Use the -verify option to verify a signed JAR
file.</p>

<p>The jarsigner command also attempts to validate the
signer s certificate after signing or verifying. If there is
a validation error or any other problem, the command
generates warning messages. If you specify the -strict
option, then the command treats severe warnings as errors.
See Errors and Warnings.</p>

<p>KEYSTORE ALIASES All keystore entities are accessed with
unique aliases.</p>

<p>When you use the jarsigner command to sign a JAR file,
you must specify the alias for the keystore entry that
contains the private key needed to generate the signature.
For example, the following command signs the JAR file named
MyJARFile.jar with the private key associated with the alias
duke in the keystore named mystore in the working directory.
Because no output file is specified, it overwrites
MyJARFile.jar with the signed JAR file.</p>

<p>jarsigner -keystore /working/mystore -storepass
&lt;keystore password&gt; -keypass &lt;private key
password&gt; MyJARFile.jar duke</p>

<p>Keystores are protected with a password, so the store
password must be specified. You are prompted for it when you
do not specify it on the command line. Similarly, private
keys are protected in a keystore with a password, so the
private key s password must be specified, and you are
prompted for the password when you do not specify it on the
command line and it is not the same as the store
password.</p>

<p>KEYSTORE LOCATION The jarsigner command has a -keystore
option for specifying the URL of the keystore to be used.
The keystore is by default stored in a file named .keystore
in the users home directory, as determined by the user.home
system property.</p>

<p>On Oracle Solaris systems, user.home defaults to the
users home directory.</p>

<p>The input stream from the -keystore option is passed to
the KeyStore.load method. If NONE is specified as the URL,
then a null stream is passed to the KeyStore.load method.
NONE should be specified when the KeyStore class is not file
based, for example, when it resides on a hardware token
device.</p>

<p>KEYSTORE IMPLEMENTATION The KeyStore class provided in
the java.security package supplies a number of well-defined
interfaces to access and modify the information in a
keystore. You can have multiple different concrete
implementations, where each implementation is for a
particular type of keystore.</p>

<p>Currently, there are two command-line tools that use
keystore implementations (keytool and jarsigner), and a
GUI-based tool named Policy Tool. Because the KeyStore class
is publicly available, JDK users can write additional
security applications that use it.</p>

<p>There is a built-in default implementation provided by
Oracle that implements the keystore as a file, that uses a
proprietary keystore type (format) named JKS. The built-in
implementation protects each private key with its individual
password and protects the integrity of the entire keystore
with a (possibly different) password.</p>

<p>Keystore implementations are provider-based, which means
the application interfaces supplied by the KeyStore class
are implemented in terms of a Service Provider Interface
(SPI). There is a corresponding abstract KeystoreSpi class,
also in the java.security package, that defines the Service
Provider Interface methods that providers must implement.
The term provider refers to a package or a set of packages
that supply a concrete implementation of a subset of
services that can be accessed by the Java Security API. To
provide a keystore implementation, clients must implement a
provider and supply a KeystoreSpi subclass implementation,
as described in How to Implement a Provider in the Java
Cryptography Architecture at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html</p>

<p>Applications can choose different types of keystore
implementations from different providers, with the
getInstance factory method in the KeyStore class. A keystore
type defines the storage and data format of the keystore
information and the algorithms used to protect private keys
in the keystore and the integrity of the keystore itself.
Keystore implementations of different types are not
compatible.</p>

<p>The jarsigner and policytool commands can read
file-based keystores from any location that can be specified
using a URL. In addition, these commands can read
non-file-based keystores such as those provided by MSCAPI on
Windows and PKCS11 on all platforms.</p>

<p>For the jarsigner and keytool commands, you can specify
a keystore type at the command line with the -storetype
option. For Policy Tool, you can specify a keystore type
with the Edit command in the KeyStore menu.</p>

<p>If you do not explicitly specify a keystore type, then
the tools choose a keystore implementation based on the
value of the keystore.type property specified in the
security properties file. The security properties file is
called java.security, and it resides in the JDK security
properties directory, java.home/lib/security, where
java.home is the runtime environments directory. The jre
directory in the JDK or the top-level directory of the Java
Runtime Environment (JRE).</p>

<p>Each tool gets the keystore.type value and then examines
all the installed providers until it finds one that
implements keystores of that type. It then uses the keystore
implementation from that provider.</p>

<p>The KeyStore class defines a static method named
getDefaultType that lets applications and applets retrieve
the value of the keystore.type property. The following line
of code creates an instance of the default keystore type as
specified in the keystore.type property:</p>

<p>KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p>The default keystore type is jks (the proprietary type
of the keystore implementation provided by Oracle). This is
specified by the following line in the security properties
file:</p>

<p>keystore.type=jks</p>

<p>Case does not matter in keystore type designations. For
example, JKS is the same as jks.</p>

<p>To have the tools use a keystore implementation other
than the default, change that line to specify a different
keystore type. For example, if you have a provider package
that supplies a keystore implementation for a keystore type
called pkcs12, then change the line to the following:</p>

<p>keystore.type=pkcs12</p>

<p>Note: If you use the PKCS 11 provider package, then see
&quot;KeyTool&quot; and &quot;JarSigner&quot; in Java PKCS
#11 Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html</p>

<p>SUPPORTED ALGORITHMS By default, the jarsigner command
signs a JAR file using one of the following algorithms:</p>

<p>&middot; Digital Signature Algorithm (DSA) with the SHA1
digest algorithm</p>

<p>&middot; RSA algorithm with the SHA256 digest
algorithm</p>

<p>&middot; Elliptic Curve (EC) cryptography algorithm with
the SHA256 with Elliptic Curve Digital Signature Algorithm
(ECDSA).</p>

<p>If the signers public and private keys are DSA keys,
then jarsigner signs the JAR file with the SHA1withDSA
algorithm. If the signers keys are RSA keys, then jarsigner
attempts to sign the JAR file with the SHA256withRSA
algorithm. If the signers keys are EC keys, then jarsigner
signs the JAR file with the SHA256withECDSA algorithm.</p>

<p>These default signature algorithms can be overridden
using the -sigalg option.</p>

<p>THE SIGNED JAR FILE When the jarsigner command is used
to sign a JAR file, the output signed JAR file is exactly
the same as the input JAR file, except that it has two
additional files placed in the META-INF directory:</p>

<p>&middot; A signature file with an .SF extension</p>

<p>&middot; A signature block file with a .DSA, .RSA, or
.EC extension</p>

<p>The base file names for these two files come from the
value of the -sigFile option. For example, when the option
is -sigFile MKSIGN, the files are named MKSIGN.SF and
MKSIGN.DSA</p>

<p>If no -sigfile option appears on the command line, then
the base file name for the .SF and .DSA files is the first 8
characters of the alias name specified on the command line,
all converted to uppercase. If the alias name has fewer than
8 characters, then the full alias name is used. If the alias
name contains any characters that are not allowed in a
signature file name, then each such character is converted
to an underscore (_) character in forming the file name.
Valid characters include letters, digits, underscores, and
hyphens.</p>

<p>Signature File</p>

<p>A signature file (.SF file) looks similar to the
manifest file that is always included in a JAR file when the
jarsigner command is used to sign the file. For each source
file included in the JAR file, the .SF file has three lines,
such as in the manifest file, that list the following:</p>

<p>&middot; File name</p>

<p>&middot; Name of the digest algorithm (SHA)</p>

<p>&middot; SHA digest value</p>

<p>In the manifest file, the SHA digest value for each
source file is the digest (hash) of the binary data in the
source file. In the .SF file, the digest value for a
specified source file is the hash of the three lines in the
manifest file for the source file.</p>

<p>The signature file, by default, includes a header with a
hash of the whole manifest file. The header also contains a
hash of the manifest header. The presence of the header
enables verification optimization. See JAR File
Verification.</p>

<p>Signature Block File</p>

<p>The .SF file is signed and the signature is placed in
the signature block file. This file also contains, encoded
inside it, the certificate or certificate chain from the
keystore that authenticates the public key corresponding to
the private key used for signing. The file has the extension
.DSA, .RSA, or .EC, depending on the digest algorithm
used.</p>

<p>SIGNATURE TIME STAMP The jarsigner command can generate
and store a signature time stamp when signing a JAR file. In
addition, jarsigner supports alternative signing mechanisms.
This behavior is optional and is controlled by the user at
the time of signing through these options. See Options.</p>

<p>-tsa url -tsacert alias -altsigner class -altsignerpath
classpathlist -tsapolicyid policyid</p>

<p>JAR FILE VERIFICATION A successful JAR file verification
occurs when the signatures are valid, and none of the files
that were in the JAR file when the signatures were generated
have changed since then. JAR file verification involves the
following steps:</p>

<p>1. Verify the signature of the .SF file.</p>

<p>The verification ensures that the signature stored in
each signature block (.DSA) file was generated using the
private key corresponding to the public key whose
certificate (or certificate chain) also appears in the .DSA
file. It also ensures that the signature is a valid
signature of the corresponding signature (.SF) file, and
thus the .SF file was not tampered with.</p>

<p>2. Verify the digest listed in each entry in the .SF
file with each corresponding section in the manifest.</p>

<p>The .SF file by default includes a header that contains
a hash of the entire manifest file. When the header is
present, the verification can check to see whether or not
the hash in the header matches the hash of the manifest
file. If there is a match, then verification proceeds to the
next step.</p>

<p>If there is no match, then a less optimized verification
is required to ensure that the hash in each source file
information section in the .SF file equals the hash of its
corresponding section in the manifest file. See Signature
File.</p>

<p>One reason the hash of the manifest file that is stored
in the .SF file header might not equal the hash of the
current manifest file is that one or more files were added
to the JAR file (with the jar tool) after the signature and
.SF file were generated. When the jar tool is used to add
files, the manifest file is changed by adding sections to it
for the new files, but the .SF file is not changed. A
verification is still considered successful when none of the
files that were in the JAR file when the signature was
generated have been changed since then. This happens when
the hashes in the non-header sections of the .SF file equal
the hashes of the corresponding sections in the manifest
file.</p>

<p>3. Read each file in the JAR file that has an entry in
the .SF file. While reading, compute the files digest and
compare the result with the digest for this file in the
manifest section. The digests should be the same or
verification fails.</p>

<p>If any serious verification failures occur during the
verification process, then the process is stopped and a
security exception is thrown. The jarsigner command catches
and displays the exception.</p>

<p>Note: You should read any addition warnings (or errors
if you specified the -strict option), as well as the content
of the certificate (by specifying the -verbose and -certs
options) to determine if the signature can be trusted.</p>

<p>MULTIPLE SIGNATURES FOR A JAR FILE A JAR file can be
signed by multiple people by running the jarsigner command
on the file multiple times and specifying the alias for a
different person each time, as follows:</p>

<p>jarsigner myBundle.jar susan jarsigner myBundle.jar
kevin</p>

<p>When a JAR file is signed multiple times, there are
multiple .SF and .DSA files in the resulting JAR file, one
pair for each signature. In the previous example, the output
JAR file includes files with the following names:</p>

<p>SUSAN.SF SUSAN.DSA KEVIN.SF KEVIN.DSA</p>

<p>Note: It is also possible for a JAR file to have mixed
signatures, some generated by the JDK 1.1 by the javakey
command and others by jarsigner. The jarsigner command can
be used to sign JAR files that are already signed with the
javakey command.</p>

<p>OPTIONS The following sections describe the various
jarsigner options. Be aware of the following standards:</p>

<p>&middot; All option names are preceded by a minus sign
(-).</p>

<p>&middot; The options can be provided in any order.</p>

<p>&middot; Items that are in italics or underlined (option
values) represent the actual values that must be
supplied.</p>

<p>&middot; The -storepass, -keypass, -sigfile, -sigalg,
-digestalg, -signedjar, and TSA-related options are only
relevant when signing a JAR file; they are not relevant when
verifying a signed JAR file. The -keystore option is
relevant for signing and verifying a JAR file. In addition,
aliases are specified when signing and verifying a JAR
file.</p>

<p>-keystore url Specifies the URL that tells the keystore
location. This defaults to the file .keystore in the user s
home directory, as determined by the user.home system
property.</p>

<p>A keystore is required when signing. You must explicitly
specify a keystore when the default keystore does not exist
or if you want to use one other than the default.</p>

<p>A keystore is not required when verifying, but if one is
specified or the default exists and the -verbose option was
also specified, then additional information is output
regarding whether or not any of the certificates used to
verify the JAR file are contained in that keystore.</p>

<p>The -keystore argument can be a file name and path
specification rather than a URL, in which case it is treated
the same as a file: URL, for example, the following are
equivalent:</p>

<p>-keystore filePathAndName -keystore
file:filePathAndName</p>

<p>If the Sun PKCS #11 provider was configured in the
java.security security properties file (located in the JREs
$JAVA_HOME/lib/security directory), then the keytool and
jarsigner tools can operate on the PKCS #11 token by
specifying these options:</p>

<p>-keystore NONE -storetype PKCS11</p>

<p>For example, the following command lists the contents of
the configured PKCS#11 token:</p>

<p>keytool -keystore NONE -storetype PKCS11 -list</p>

<p>-storetype storetype Specifies the type of keystore to
be instantiated. The default keystore type is the one that
is specified as the value of the keystore.type property in
the security properties file, which is returned by the
static getDefaultType method in java.security.KeyStore.</p>

<p>The PIN for a PCKS #11 token can also be specified with
the -storepass option. If none is specified, then the
keytool and jarsigner commands prompt for the token PIN. If
the token has a protected authentication path (such as a
dedicated PIN-pad or a biometric reader), then the
-protected option must be specified and no password options
can be specified.</p>

<p>-storepass[:env | :file] argument Specifies the password
that is required to access the keystore. This is only needed
when signing (not verifying) a JAR file. In that case, if a
-storepass option is not provided at the command line, then
the user is prompted for the password.</p>

<p>If the modifier env or file is not specified, then the
password has the value argument. Otherwise, the password is
retrieved as follows:</p>

<p>&middot; env: Retrieve the password from the environment
variable named argument.</p>

<p>&middot; file: Retrieve the password from the file named
argument.</p>

<p>Note: The password should not be specified on the
command line or in a script unless it is for testing
purposes, or you are on a secure system.</p>

<p>-keypass [:env | :file] argument Specifies the password
used to protect the private key of the keystore entry
addressed by the alias specified on the command line. The
password is required when using jarsigner to sign a JAR
file. If no password is provided on the command line, and
the required password is different from the store password,
then the user is prompted for it.</p>

<p>If the modifier env or file is not specified, then the
password has the value argument. Otherwise, the password is
retrieved as follows:</p>

<p>&middot; env: Retrieve the password from the environment
variable named argument.</p>

<p>&middot; file: Retrieve the password from the file named
argument.</p>

<p>Note: The password should not be specified on the
command line or in a script unless it is for testing
purposes, or you are on a secure system.</p>

<p>-sigfile file Specifies the base file name to be used
for the generated .SF and .DSA files. For example, if file
is DUKESIGN, then the generated .SF and .DSA files are named
DUKESIGN.SF and DUKESIGN.DSA, and placed in the META-INF
directory of the signed JAR file.</p>

<p>The characters in the file must come from the set
a-zA-Z0-9_-. Only letters, numbers, underscore, and hyphen
characters are allowed. All lowercase characters are
converted to uppercase for the .SF and .DSA file names.</p>

<p>If no -sigfile option appears on the command line, then
the base file name for the .SF and .DSA files is the first 8
characters of the alias name specified on the command line,
all converted to upper case. If the alias name has fewer
than 8 characters, then the full alias name is used. If the
alias name contains any characters that are not valid in a
signature file name, then each such character is converted
to an underscore (_) character to form the file name.</p>

<p>-sigalg algorithm Specifies the name of the signature
algorithm to use to sign the JAR file.</p>

<p>For a list of standard signature algorithm names, see
&quot;Appendix A: Standard Names&quot; in the Java
Cryptography Architecture (JCA) Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</p>

<p>This algorithm must be compatible with the private key
used to sign the JAR file. If this option is not specified,
then SHA1withDSA, SHA256withRSA, or SHA256withECDSA are used
depending on the type of private key. There must either be a
statically installed provider supplying an implementation of
the specified algorithm or the user must specify one with
the -providerClass option; otherwise, the command will not
succeed.</p>

<p>-digestalg algorithm Specifies the name of the message
digest algorithm to use when digesting the entries of a JAR
file.</p>

<p>For a list of standard message digest algorithm names,
see &quot;Appendix A: Standard Names&quot; in the Java
Cryptography Architecture (JCA) Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</p>

<p>If this option is not specified, then SHA256 is used.
There must either be a statically installed provider
supplying an implementation of the specified algorithm or
the user must specify one with the -providerClass option;
otherwise, the command will not succeed.</p>

<p>-certs If the -certs option appears on the command line
with the -verify and -verbose options, then the output
includes certificate information for each signer of the JAR
file. This information includes the name of the type of
certificate (stored in the .DSA file) that certifies the
signer s public key, and if the certificate is an X.509
certificate (an instance of the
java.security.cert.X509Certificate), then the distinguished
name of the signer.</p>

<p>The keystore is also examined. If no keystore value is
specified on the command line, then the default keystore
file (if any) is checked. If the public key certificate for
a signer matches an entry in the keystore, then the alias
name for the keystore entry for that signer is displayed in
parentheses. If the signer comes from a JDK 1.1 identity
database instead of from a keystore, then the alias name
displays in brackets instead of parentheses.</p>

<p>-certchain file Specifies the certificate chain to be
used when the certificate chain associated with the private
key of the keystore entry that is addressed by the alias
specified on the command line is not complete. This can
happen when the keystore is located on a hardware token
where there is not enough capacity to hold a complete
certificate chain. The file can be a sequence of
concatenated X.509 certificates, or a single PKCS#7
formatted data block, either in binary encoding format or in
printable encoding format (also known as Base64 encoding) as
defined by the Internet RFC 1421 standard. See the section
Internet RFC 1421 Certificate Encoding Standard in keytool
and http://tools.ietf.org/html/rfc1421.</p>

<p>-verbose When the -verbose option appears on the command
line, it indicates verbose mode, which causes jarsigner to
output extra information about the progress of the JAR
signing or verification.</p>

<p>-internalsf In the past, the .DSA (signature block) file
generated when a JAR file was signed included a complete
encoded copy of the .SF file (signature file) also
generated. This behavior has been changed. To reduce the
overall size of the output JAR file, the .DSA file by
default does not contain a copy of the .SF file anymore. If
-internalsf appears on the command line, then the old
behavior is utilized. This option is useful for testing. In
practice, do not use the -internalsf option because it
incurs higher overhead.</p>

<p>-sectionsonly If the -sectionsonly option appears on the
command line, then the .SF file (signature file) generated
when a JAR file is signed does not include a header that
contains a hash of the whole manifest file. It contains only
the information and hashes related to each individual source
file included in the JAR file. See Signature File.</p>

<p>By default, this header is added, as an optimization.
When the header is present, whenever the JAR file is
verified, the verification can first check to see whether
the hash in the header matches the hash of the whole
manifest file. When there is a match, verification proceeds
to the next step. When there is no match, it is necessary to
do a less optimized verification that the hash in each
source file information section in the .SF file equals the
hash of its corresponding section in the manifest file. See
JAR File Verification.</p>

<p>The -sectionsonly option is primarily used for testing.
It should not be used other than for testing because using
it incurs higher overhead.</p>

<p>-protected Values can be either true or false. Specify
true when a password must be specified through a protected
authentication path such as a dedicated PIN reader.</p>

<p>-providerClass provider-class-name Used to specify the
name of cryptographic service providers master class file
when the service provider is not listed in the java.security
security properties file.</p>

<p>Used with the -providerArg ConfigFilePath option, the
keytool and jarsigner tools install the provider dynamically
and use ConfigFilePath for the path to the token
configuration file. The following example shows a command to
list a PKCS #11 keystore when the Oracle PKCS #11 provider
was not configured in the security properties file.</p>

<p>jarsigner -keystore NONE -storetype PKCS11
-providerClass sun.security.pkcs11.SunPKCS11 -providerArg
/mydir1/mydir2/token.config -list</p>

<p>-providerName providerName If more than one provider was
configured in the java.security security properties file,
then you can use the -providerName option to target a
specific provider instance. The argument to this option is
the name of the provider.</p>

<p>For the Oracle PKCS #11 provider, providerName is of the
form SunPKCS11-TokenName, where TokenName is the name suffix
that the provider instance has been configured with, as
detailed in the configuration attributes table. For example,
the following command lists the contents of the PKCS #11
keystore provider instance with name suffix SmartCard:</p>

<p>jarsigner -keystore NONE -storetype PKCS11 -providerName
SunPKCS11-SmartCard -list</p>

<p>-Jjavaoption Passes through the specified javaoption
string directly to the Java interpreter. The jarsigner
command is a wrapper around the interpreter. This option
should not contain any spaces. It is useful for adjusting
the execution environment or memory usage. For a list of
possible interpreter options, type java -h or java -X at the
command line.</p>

<p>-tsa url If -tsa http://example.tsa.url appears on the
command line when signing a JAR file then a time stamp is
generated for the signature. The URL,
http://example.tsa.url, identifies the location of the Time
Stamping Authority (TSA) and overrides any URL found with
the -tsacert option. The -tsa option does not require the
TSA public key certificate to be present in the
keystore.</p>

<p>To generate the time stamp, jarsigner communicates with
the TSA with the Time-Stamp Protocol (TSP) defined in RFC
3161. When successful, the time stamp token returned by the
TSA is stored with the signature in the signature block
file.</p>

<p>-tsacert alias When -tsacert alias appears on the
command line when signing a JAR file, a time stamp is
generated for the signature. The alias identifies the TSA
public key certificate in the keystore that is in effect.
The entrys certificate is examined for a Subject Information
Access extension that contains a URL identifying the
location of the TSA.</p>

<p>The TSA public key certificate must be present in the
keystore when using the -tsacert option.</p>

<p>-tsapolicyid policyid Specifies the object identifier
(OID) that identifies the policy ID to be sent to the TSA
server. If this option is not specified, no policy ID is
sent and the TSA server will choose a default policy ID.</p>

<p>Object identifiers are defined by X.696, which is an ITU
Telecommunication Standardization Sector (ITU-T) standard.
These identifiers are typically period-separated sets of
non-negative digits like 1.2.3.4, for example.</p>

<p>-altsigner class This option specifies an alternative
signing mechanism. The fully qualified class name identifies
a class file that extends the
com.sun.jarsigner.ContentSigner abstract class. The path to
this class file is defined by the -altsignerpath option. If
the -altsigner option is used, then the jarsigner command
uses the signing mechanism provided by the specified class.
Otherwise, the jarsigner command uses its default signing
mechanism.</p>

<p>For example, to use the signing mechanism provided by a
class named com.sun.sun.jarsigner.AuthSigner, use the
jarsigner option -altsigner
com.sun.jarsigner.AuthSigner.</p>

<p>-altsignerpath classpathlist Specifies the path to the
class file and any JAR file it depends on. The class file
name is specified with the -altsigner option. If the class
file is in a JAR file, then this option specifies the path
to that JAR file.</p>

<p>An absolute path or a path relative to the current
directory can be specified. If classpathlist contains
multiple paths or JAR files, then they should be separated
with a colon (:) on Oracle Solaris and a semicolon (;) on
Windows. This option is not necessary when the class is
already in the search path.</p>

<p>The following example shows how to specify the path to a
JAR file that contains the class file. The JAR file name is
included.</p>

<p>-altsignerpath /home/user/lib/authsigner.jar</p>

<p>The following example shows how to specify the path to
the JAR file that contains the class file. The JAR file name
is omitted.</p>

<p>-altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</p>

<p>-strict During the signing or verifying process, the
command may issue warning messages. If you specify this
option, the exit code of the tool reflects the severe
warning messages that this command found. See Errors and
Warnings.</p>

<p>-verbose suboptions For the verifying process, the
-verbose option takes suboptions to determine how much
information is shown. If the -certs option is also
specified, then the default mode (or suboption all) displays
each entry as it is being processed, and after that, the
certificate information for each signer of the JAR file. If
the -certs and the -verbose:grouped suboptions are
specified, then entries with the same signer info are
grouped and displayed together with their certificate
information. If -certs and the -verbose:summary suboptions
are specified, then entries with the same signer information
are grouped and displayed together with their certificate
information. Details about each entry are summarized and
displayed as one entry (and more). See Examples.</p>

<p>ERRORS AND WARNINGS During the signing or verifying
process, the jarsigner command may issue various errors or
warnings.</p>

<p>If there is a failure, the jarsigner command exits with
code 1. If there is no failure, but there are one or more
severe warnings, the jarsigner command exits with code 0
when the -strict option is not specified, or exits with the
OR-value of the warning codes when the -strict is specified.
If there is only informational warnings or no warning at
all, the command always exits with code 0.</p>

<p>For example, if a certificate used to sign an entry is
expired and has a KeyUsage extension that does not allow it
to sign a file, the jarsigner command exits with code 12
(=4+8) when the -strict option is specified.</p>

<p>Note: Exit codes are reused because only the values from
0 to 255 are legal on Unix-based operating systems.</p>

<p>The following sections describes the names, codes, and
descriptions of the errors and warnings that the jarsigner
command can issue.</p>

<p>FAILURE Reasons why the jarsigner command fails include
(but are not limited to) a command line parsing error, the
inability to find a keypair to sign the JAR file, or the
verification of a signed JAR fails.</p>

<p>failure Code 1. The signing or verifying fails.</p>

<p>SEVERE WARNINGS Note: Severe warnings are reported as
errors if you specify the -strict option.</p>

<p>Reasons why the jarsigner command issues a severe
warning include the certificate used to sign the JAR file
has an error or the signed JAR file has other problems.</p>

<p>hasExpiredCert Code 4. This jar contains entries whose
signer certificate has expired.</p>

<p>notYetValidCert Code 4. This jar contains entries whose
signer certificate is not yet valid.</p>

<p>chainNotValidated Code 4. This jar contains entries
whose certificate chain cannot be correctly validated.</p>

<p>badKeyUsage Code 8. This jar contains entries whose
signer certificates KeyUsage extension doesnt allow code
signing.</p>

<p>badExtendedKeyUsage Code 8. This jar contains entries
whose signer certificates ExtendedKeyUsage extension doesn t
allow code signing.</p>

<p>badNetscapeCertType Code 8. This jar contains entries
whose signer certificates NetscapeCertType extension doesn t
allow code signing.</p>

<p>hasUnsignedEntry Code 16. This jar contains unsigned
entries which have not been integrity-checked.</p>

<p>notSignedByAlias Code 32. This jar contains signed
entries which are not signed by the specified alias(es).</p>

<p>aliasNotInStore Code 32. This jar contains signed
entries that are not signed by alias in this keystore.</p>

<p>INFORMATIONAL WARNINGS Informational warnings include
those that are not errors but regarded as bad practice. They
do not have a code.</p>

<p>hasExpiringCert This jar contains entries whose signer
certificate will expire within six months.</p>

<p>noTimestamp This jar contains signatures that does not
include a timestamp. Without a timestamp, users may not be
able to validate this JAR file after the signer certificates
expiration date (YYYY-MM-DD) or after any future revocation
date.</p>

<p>EXAMPLES SIGN A JAR FILE Use the following command to
sign bundle.jar with the private key of a user whose
keystore alias is jane in a keystore named mystore in the
working directory and name the signed JAR file
sbundle.jar:</p>

<p>jarsigner -keystore /working/mystore -storepass
&lt;keystore password&gt; -keypass &lt;private key
password&gt; -signedjar sbundle.jar bundle.jar jane</p>

<p>There is no -sigfile specified in the previous command
so the generated .SF and .DSA files to be placed in the
signed JAR file have default names based on the alias name.
They are named JANE.SF and JANE.DSA.</p>

<p>If you want to be prompted for the store password and
the private key password, then you could shorten the
previous command to the following:</p>

<p>jarsigner -keystore /working/mystore -signedjar
sbundle.jar bundle.jar jane</p>

<p>If the keystore is the default keystore (.keystore in
your home directory), then you do not need to specify a
keystore, as follows:</p>

<p>jarsigner -signedjar sbundle.jar bundle.jar jane</p>

<p>If you want the signed JAR file to overwrite the input
JAR file (bundle.jar), then you do not need to specify a
-signedjar option, as follows:</p>

<p>jarsigner bundle.jar jane</p>

<p>VERIFY A SIGNED JAR FILE To verify a signed JAR file to
ensure that the signature is valid and the JAR file was not
been tampered with, use a command such as the following:</p>

<p>jarsigner -verify sbundle.jar</p>

<p>When the verification is successful, jar verified is
displayed. Otherwise, an error message is displayed. You can
get more information when you use the -verbose option. A
sample use of jarsigner with the- verbose option
follows:</p>

<p>jarsigner -verify -verbose sbundle.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA smk 2752 Fri Sep
26 16:12:30 PDT 1997 AclEx.class smk 849 Fri Sep 26 16:12:46
PDT 1997 test.class</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>VERIFICATION WITH CERTIFICATE INFORMATION If you specify
the -certs option with the -verify and -verbose options,
then the output includes certificate information for each
signer of the JAR file. The information includes the
certificate type, the signer distinguished name information
(when it is an X.509 certificate), and in parentheses, the
keystore alias for the signer when the public key
certificate in the JAR file matches the one in a keystore
entry, for example:</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs myTest.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 208 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.SF 1087 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.DSA smk 2752 Fri Sep 26
16:12:30 PDT 1997 Tst.class</p>

<p>X.509, CN=Test Group, OU=Java Software, O=Oracle, L=CUP,
S=CA, C=US (javatest) X.509, CN=Jane Smith, OU=Java
Software, O=Oracle, L=cup, S=ca, C=us (jane)</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>If the certificate for a signer is not an X.509
certificate, then there is no distinguished name
information. In that case, just the certificate type and the
alias are shown. For example, if the certificate is a PGP
certificate, and the alias is bob, then you would get: PGP,
(bob).</p>

<p>VERIFICATION THAT INCLUDES IDENTITY DATABASE SIGNERS If
a JAR file was signed with the JDK 1.1 javakey tool, and the
signer is an alias in an identity database, then the
verification output includes an i. If the JAR file was
signed by both an alias in an identity database and an alias
in a keystore, then both k and i appear.</p>

<p>When the -certs option is used, any identity database
aliases are shown in brackets rather than the parentheses
used for keystore aliases, for example:</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs writeFile.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 199 Fri Sep 27
12:22:30 PDT 1997 META-INF/DUKE.SF 1013 Fri Sep 27 12:22:30
PDT 1997 META-INF/DUKE.DSA smki 2752 Fri Sep 26 16:12:30 PDT
1997 writeFile.html</p>

<p>X.509, CN=Jane Smith, OU=Java Software, O=Oracle, L=cup,
S=ca, C=us (jane) X.509, CN=Duke, OU=Java Software,
O=Oracle, L=cup, S=ca, C=us [duke]</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in keystore
i = at least one certificate was found in identity scope</p>

<p>jar verified.</p>

<p>Note: The alias duke is in brackets to denote that it is
an identity database alias, and not a keystore alias.</p>

<p>JDK 1.1 COMPATIBILITY The keytool and jarsigner tools
replace the javakey tool in JDK 1.1. These new tools provide
more features than javakey, including the ability to protect
the keystore and private keys with passwords, and the
ability to verify signatures in addition to generating
them.</p>

<p>The new keystore architecture replaces the identity
database that javakey created and managed. There is no
backward compatibility between the keystore format and the
database format used by javakey in JDK 1.1. However, be
aware of the following:</p>

<p>&middot; It is possible to import the information from
an identity database into a keystore through the keytool
-identitydb command.</p>

<p>&middot; The jarsigner command can sign JAR files that
were signed with the javakey command.</p>

<p>&middot; The jarsigner command can verify JAR files
signed with javakey. The jarsigner command recognizes and
can work with signer aliases that are from a JDK 1.1
identity database rather than a JDK keystore.</p>

<p>UNSIGNED JARS Unsigned JARs have the default privileges
that are granted to all code.</p>

<p>SIGNED JARS Signed JARs have the privilege
configurations based on their JDK 1.1.n identity and policy
file status as described. Only trusted identities can be
imported into the JDK keystore.</p>

<p>Default Privileges Granted to All Code</p>

<p>Identity in 1.1 database: No Trusted identity imported
into Java keystore from 1.1. database: No Policy file grants
privileges to identity/alias: No</p>

<p>Identity in 1.1 database: No Trusted identity imported
into Java keystore from 1.1. database: Yes Policy file
grants privileges to identity/alias: No</p>

<p>Identity in 1.1 database: Yes/Untrusted Trusted identity
imported into Java keystore from 1.1. database: No Policy
file grants privileges to identity/alias: No See 3 in Notes
Regarding Privileges of Signed JARs.</p>

<p>Identity in 1.1 database: Yes/Untrusted Trusted identity
imported into Java keystore from 1.1. database: No Policy
file grants privileges to identity/alias: Yes See 1 and 3 in
Notes Regarding Privileges of Signed JARs.</p>

<p>Default Privileges and Policy File Privileges
Granted</p>

<p>Identity in 1.1 database: No Trusted identity imported
into Java keystore from 1.1. database: Yes Policy file
grants privileges to identity/alias: Yes</p>

<p>Identity in 1.1 database: Yes/Trusted Trusted identity
imported into Java keystore from 1.1. database: Yes Policy
file grants privileges to identity/alias: Yes See 2 in Notes
Regarding Privileges of Signed JARs.</p>

<p>All Privileges Granted</p>

<p>Identity in 1.1 database: Yes/Trusted Trusted identity
imported into Java keystore from 1.1. database: No Policy
file grants privileges to identity/alias: No</p>

<p>Identity in 1.1 database: Yes/Trusted Trusted identity
imported into Java keystore from 1.1. database: Yes Policy
file grants privileges to identity/alias: No See 1 in Notes
Regarding Privileges of Signed JARs.</p>

<p>Identity in 1.1 database: Yes/Trusted Trusted identity
imported into Java keystore from 1.1. database: No Policy
file grants privileges to identity/alias: Yes See 1 in Notes
Regarding Privileges of Signed JARs.</p>

<p>Notes Regarding Privileges of Signed JARs</p>

<p>1. If an identity or alias is mentioned in the policy
file, then it must be imported into the keystore for the
policy file to have any effect on privileges granted.</p>

<p>2. The policy file/keystore combination has precedence
over a trusted identity in the identity database.</p>

<p>3. Untrusted identities are ignored in the Java
platform.</p>

<p>SEE ALSO &middot; jar</p>

<p>&middot; keytool</p>

<p>&middot; Trail: Security Features in Java SE at
http://docs.oracle.com/javase/tutorial/security/index.html</p>

<p>JDK 7 6 August 2013 jarsigner(1)</p>
<hr>
</body>
</html>
