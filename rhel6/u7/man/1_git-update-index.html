<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-UPDATE-INDEX(1) Git Manual GIT-UPDATE-INDEX(1)</p>

<p>NAME git-update-index - Register file contents in the
working tree to the index</p>

<p>SYNOPSIS git update-index [--add] [--remove |
--force-remove] [--replace] [--refresh] [-q] [--unmerged]
[--ignore-missing] [--cacheinfo &lt;mode&gt; &lt;object&gt;
&lt;file&gt;] [--chmod=(+|-)x] [--assume-unchanged |
--no-assume-unchanged] [--skip-worktree |
--no-skip-worktree] [--ignore-submodules] [--really-refresh]
[--unresolve] [--again | -g] [--info-only] [--index-info]
[-z] [--stdin] [--verbose] [--] [&lt;file&gt;]</p>

<p>DESCRIPTION Modifies the index or directory cache. Each
file mentioned is updated into the index and any unmerged or
needs updating state is cleared.</p>

<p>See also git-add(1) for a more user-friendly way to do
some of the most common operations on the index.</p>

<p>The way git update-index handles files it is told about
can be modified using the various options:</p>

<p>OPTIONS --add If a specified file isnt in the index
already then its added. Default behaviour is to ignore new
files.</p>

<p>--remove If a specified file is in the index but is
missing then its removed. Default behavior is to ignore
removed file.</p>

<p>--refresh Looks at the current index and checks to see
if merges or updates are needed by checking stat()
information.</p>

<p>-q Quiet. If --refresh finds that the index needs an
update, the default behavior is to error out. This option
makes git update-index continue anyway.</p>

<p>--ignore-submodules Do not try to update submodules.
This option is only respected when passed before
--refresh.</p>

<p>--unmerged If --refresh finds unmerged changes in the
index, the default behavior is to error out. This option
makes git update-index continue anyway.</p>

<p>--ignore-missing Ignores missing files during a
--refresh</p>

<p>--cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt;
Directly insert the specified info into the index.</p>

<p>--index-info Read index information from stdin.</p>

<p>--chmod=(+|-)x Set the execute permissions on the
updated files.</p>

<p>--assume-unchanged, --no-assume-unchanged When these
flags are specified, the object names recorded for the paths
are not updated. Instead, these options set and unset the
&quot;assume unchanged&quot; bit for the paths. When the
&quot;assume unchanged&quot; bit is on, git stops checking
the working tree files for possible modifications, so you
need to manually unset the bit to tell git when you change
the working tree file. This is sometimes helpful when
working with a big project on a filesystem that has very
slow lstat(2) system call (e.g. cifs).</p>

<p>This option can be also used as a coarse file-level
mechanism to ignore uncommitted changes in tracked files
(akin to what .gitignore does for untracked files). You
should remember that an explicit git add operation will
still cause the file to be refreshed from the working tree.
Git will fail (gracefully) in case it needs to modify this
file in the index e.g. when merging in a commit; thus, in
case the assumed-untracked file is changed upstream, you
will need to handle the situation manually.</p>

<p>--really-refresh Like --refresh, but checks stat
information unconditionally, without regard to the
&quot;assume unchanged&quot; setting.</p>

<p>--skip-worktree, --no-skip-worktree When one of these
flags is specified, the object name recorded for the paths
are not updated. Instead, these options set and unset the
&quot;skip-worktree&quot; bit for the paths. See section
&quot;Skip-worktree bit&quot; below for more
information.</p>

<p>-g, --again Runs git update-index itself on the paths
whose index entries are different from those from the HEAD
commit.</p>

<p>--unresolve Restores the unmerged or needs updating
state of a file during a merge if it was cleared by
accident.</p>

<p>--info-only Do not create objects in the object database
for all &lt;file&gt; arguments that follow this flag; just
insert their object IDs into the index.</p>

<p>--force-remove Remove the file from the index even when
the working directory still has such a file. (Implies
--remove.)</p>

<p>--replace By default, when a file path exists in the
index, git update-index refuses an attempt to add path/file.
Similarly if a file path/file exists, a file path cannot be
added. With --replace flag, existing entries that conflict
with the entry being added are automatically removed with
warning messages.</p>

<p>--stdin Instead of taking list of paths from the command
line, read list of paths from the standard input. Paths are
separated by LF (i.e. one path per line) by default.</p>

<p>--verbose Report what is being added and removed from
index.</p>

<p>-z Only meaningful with --stdin; paths are separated
with NUL character instead of LF.</p>

<p>-- Do not interpret any more arguments as options.</p>

<p>&lt;file&gt; Files to act on. Note that files beginning
with . are discarded. This includes ./file and dir/./file.
If you dont want this, then use cleaner names. The same
applies to directories ending / and paths with //</p>

<p>USING --REFRESH --refresh does not calculate a new sha1
file or bring the index up-to-date for mode/content changes.
But what it does do is to &quot;re-match&quot; the stat
information of a file with the index, so that you can
refresh the index for a file that hasnt been changed but
where the stat entry is out of date.</p>

<p>For example, youd want to do this after doing a git
read-tree, to link up the stat index details with the proper
files.</p>

<p>USING --CACHEINFO OR --INFO-ONLY --cacheinfo is used to
register a file that is not in the current working
directory. This is useful for minimum-checkout merging.</p>

<p>To pretend you have a file with mode and sha1 at path,
say:</p>

<p>$ git update-index --cacheinfo mode sha1 path</p>

<p>--info-only is used to register files without placing
them in the object database. This is useful for status-only
repositories.</p>

<p>Both --cacheinfo and --info-only behave similarly: the
index is updated but the object database isnt. --cacheinfo
is useful when the object is in the database but the file
isn t available locally. --info-only is useful when the file
is available, but you do not wish to update the object
database.</p>

<p>USING --INDEX-INFO --index-info is a more powerful
mechanism that lets you feed multiple entry definitions from
the standard input, and designed specifically for scripts.
It can take inputs of three formats:</p>

<p>1. mode SP sha1 TAB path</p>

<p>The first format is what &quot;git-apply
--index-info&quot; reports, and used to reconstruct a
partial tree that is used for phony merge base tree when
falling back on 3-way merge.</p>

<p>2. mode SP type SP sha1 TAB path</p>

<p>The second format is to stuff git ls-tree output into
the index file.</p>

<p>3. mode SP sha1 SP stage TAB path</p>

<p>This format is to put higher order stages into the index
file and matches git ls-files --stage output.</p>

<p>To place a higher stage entry to the index, the path
should first be removed by feeding a mode=0 entry for the
path, and then feeding necessary input lines in the third
format.</p>

<p>For example, starting with this index:</p>

<p>$ git ls-files -s 100644
8a1218a1024a212bb3db30becd860315f9f3ac52 0 frotz</p>

<p>you can feed the following input to --index-info:</p>

<p>$ git update-index --index-info 0
0000000000000000000000000000000000000000 frotz 100644
8a1218a1024a212bb3db30becd860315f9f3ac52 1 frotz 100755
8a1218a1024a212bb3db30becd860315f9f3ac52 2 frotz</p>

<p>The first line of the input feeds 0 as the mode to
remove the path; the SHA1 does not matter as long as it is
well formatted. Then the second and third line feeds stage 1
and stage 2 entries for that path. After the above, we would
end up with this:</p>

<p>$ git ls-files -s 100644
8a1218a1024a212bb3db30becd860315f9f3ac52 1 frotz 100755
8a1218a1024a212bb3db30becd860315f9f3ac52 2 frotz</p>

<p>USINGASSUME UNCHANGEDBIT Many operations in git depend
on your filesystem to have an efficient lstat(2)
implementation, so that st_mtime information for working
tree files can be cheaply checked to see if the file
contents have changed from the version recorded in the index
file. Unfortunately, some filesystems have inefficient
lstat(2). If your filesystem is one of them, you can set
&quot;assume unchanged&quot; bit to paths you have not
changed to cause git not to do this check. Note that setting
this bit on a path does not mean git will check the contents
of the file to see if it has changed it makes git to omit
any checking and assume it has not changed. When you make
changes to working tree files, you have to explicitly tell
git about it by dropping &quot;assume unchanged&quot; bit,
either before or after you modify them.</p>

<p>In order to set &quot;assume unchanged&quot; bit, use
--assume-unchanged option. To unset, use
--no-assume-unchanged.</p>

<p>The command looks at core.ignorestat configuration
variable. When this is true, paths updated with git
update-index paths... and paths updated with other git
commands that update both index and working tree (e.g. git
apply --index, git checkout-index -u, and git read-tree -u)
are automatically marked as &quot;assume unchanged&quot;.
Note that &quot;assume unchanged&quot; bit is not set if git
update-index --refresh finds the working tree file matches
the index (use git update-index --really-refresh if you want
to mark them as &quot;assume unchanged&quot;).</p>

<p>EXAMPLES To update and refresh only the files already
checked out:</p>

<p>$ git checkout-index -n -f -a &amp;&amp; git
update-index --ignore-missing --refresh</p>

<p>On an inefficient filesystem with core.ignorestat
set</p>

<p>$ git update-index --really-refresh (1) $ git
update-index --no-assume-unchanged foo.c (2) $ git diff
--name-only (3) $ edit foo.c $ git diff --name-only (4) M
foo.c $ git update-index foo.c (5) $ git diff --name-only
(6) $ edit foo.c $ git diff --name-only (7) $ git
update-index --no-assume-unchanged foo.c (8) $ git diff
--name-only (9) M foo.c</p>

<p>1. forces lstat(2) to set &quot;assume unchanged&quot;
bits for paths that match index. 2. mark the path to be
edited. 3. this does lstat(2) and finds index matches the
path. 4. this does lstat(2) and finds index does not match
the path. 5. registering the new version to index sets
&quot;assume unchanged&quot; bit. 6. and it is assumed
unchanged. 7. even after you edit it. 8. you can tell about
the change after the fact. 9. now it checks with lstat(2)
and finds it has been changed.</p>

<p>SKIP-WORKTREE BIT Skip-worktree bit can be defined in
one (long) sentence: When reading an entry, if it is marked
as skip-worktree, then Git pretends its working directory
version is up to date and read the index version
instead.</p>

<p>To elaborate, &quot;reading&quot; means checking for
file existence, reading file attributes or file content. The
working directory version may be present or absent. If
present, its content may match against the index version or
not. Writing is not affected by this bit, content safety is
still first priority. Note that Git can update working
directory file, that is marked skip-worktree, if it is safe
to do so (i.e. working directory version matches index
version)</p>

<p>Although this bit looks similar to assume-unchanged bit,
its goal is different from assume-unchanged bits.
Skip-worktree also takes precedence over assume-unchanged
bit when both are set.</p>

<p>CONFIGURATION The command honors core.filemode
configuration variable. If your repository is on a
filesystem whose executable bits are unreliable, this should
be set to false (see git-config(1)). This causes the command
to ignore differences in file modes recorded in the index
and the file mode on the filesystem if they differ only on
executable bit. On such an unfortunate filesystem, you may
need to use git update-index --chmod=.</p>

<p>Quite similarly, if core.symlinks configuration variable
is set to false (see git-config(1)), symbolic links are
checked out as plain files, and this command does not modify
a recorded file mode from symbolic link to regular file.</p>

<p>The command looks at core.ignorestat configuration
variable. See Using &quot;assume unchanged&quot; bit section
above.</p>

<p>The command also looks at core.trustctime configuration
variable. It can be useful when the inode change time is
regularly modified by something outside Git (file system
crawlers and backup systems use ctime for marking files
processed) (see git-config(1)).</p>

<p>SEE ALSO git-config(1), git-add(1)</p>

<p>AUTHOR Written by Linus Torvalds
&lt;torvalds@osdl.org[1]&gt;</p>

<p>DOCUMENTATION Documentation by David Greaves, Junio C
Hamano and the git-list &lt;git@vger.kernel.org[2]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. torvalds@osdl.org mailto:torvalds@osdl.org</p>

<p>2. git@vger.kernel.org mailto:git@vger.kernel.org</p>

<p>Git 1.7.1 02/26/2013 GIT-UPDATE-INDEX(1)</p>
<hr>
</body>
</html>
