<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:36 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-MERGE(1) Git Manual GIT-MERGE(1)</p>

<p>NAME git-merge - Join two or more development histories
together</p>

<p>SYNOPSIS git merge [-n] [--stat] [--no-commit]
[--squash] [-s &lt;strategy&gt;] [-X
&lt;strategy-option&gt;] [--[no-]rerere-autoupdate] [-m
&lt;msg&gt;] &lt;commit&gt;... git merge &lt;msg&gt; HEAD
&lt;commit&gt;...</p>

<p>DESCRIPTION Incorporates changes from the named commits
(since the time their histories diverged from the current
branch) into the current branch. This command is used by git
pull to incorporate changes from another repository and can
be used by hand to merge changes from one branch into
another.</p>

<p>Assume the following history exists and the current
branch is &quot;master&quot;:</p>

<p>A---B---C topic / D---E---F---G master</p>

<p>Then &quot;git merge topic&quot; will replay the changes
made on the topic branch since it diverged from master
(i.e., E) until its current commit (C) on top of master, and
record the result in a new commit along with the names of
the two parent commits and a log message from the user
describing the changes.</p>

<p>A---B---C topic / D---E---F---G---H master</p>

<p>The second syntax (&lt;msg&gt; HEAD &lt;commit&gt;...)
is supported for historical reasons. Do not use it from the
command line or in new scripts. It is the same as git merge
-m &lt;msg&gt; &lt;commit&gt;....</p>

<p>Warning: Running git merge with uncommitted changes is
discouraged: while possible, it leaves you in a state that
is hard to back out of in the case of a conflict.</p>

<p>OPTIONS --commit, --no-commit Perform the merge and
commit the result. This option can be used to override
--no-commit.</p>

<p>With --no-commit perform the merge but pretend the merge
failed and do not autocommit, to give the user a chance to
inspect and further tweak the merge result before
committing.</p>

<p>--ff, --no-ff Do not generate a merge commit if the
merge resolved as a fast-forward, only update the branch
pointer. This is the default behavior of git-merge.</p>

<p>With --no-ff Generate a merge commit even if the merge
resolved as a fast-forward.</p>

<p>--log, --no-log In addition to branch names, populate
the log message with one-line descriptions from the actual
commits that are being merged.</p>

<p>With --no-log do not list one-line descriptions from the
actual commits being merged.</p>

<p>--stat, -n, --no-stat Show a diffstat at the end of the
merge. The diffstat is also controlled by the configuration
option merge.stat.</p>

<p>With -n or --no-stat do not show a diffstat at the end
of the merge.</p>

<p>--squash, --no-squash Produce the working tree and index
state as if a real merge happened (except for the merge
information), but do not actually make a commit or move the
HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the next git
commit command to create a merge commit. This allows you to
create a single commit on top of the current branch whose
effect is the same as merging another branch (or more in
case of an octopus).</p>

<p>With --no-squash perform the merge and commit the
result. This option can be used to override --squash.</p>

<p>--ff-only Refuse to merge and exit with a non-zero
status unless the current HEAD is already up-to-date or the
merge can be resolved as a fast-forward.</p>

<p>-s &lt;strategy&gt;, --strategy=&lt;strategy&gt; Use the
given merge strategy; can be supplied more than once to
specify them in the order they should be tried. If there is
no -s option, a built-in list of strategies is used instead
(git merge-recursive when merging a single head, git
merge-octopus otherwise).</p>

<p>-X &lt;option&gt;, --strategy-option=&lt;option&gt; Pass
merge strategy specific option through to the merge
strategy.</p>

<p>--summary, --no-summary Synonyms to --stat and
--no-stat; these are deprecated and will be removed in the
future.</p>

<p>-q, --quiet Operate quietly.</p>

<p>-v, --verbose Be verbose.</p>

<p>-m &lt;msg&gt; Set the commit message to be used for the
merge commit (in case one is created). The git fmt-merge-msg
command can be used to give a good default for automated git
merge invocations.</p>

<p>--rerere-autoupdate, --no-rerere-autoupdate Allow the
rerere mechanism to update the index with the result of
auto-conflict resolution if possible.</p>

<p>&lt;commit&gt;... Commits, usually other branch heads,
to merge into our branch. You need at least one
&lt;commit&gt;. Specifying more than one &lt;commit&gt;
obviously means you are trying an Octopus.</p>

<p>PRE-MERGE CHECKS Before applying outside changes, you
should get your own work in good shape and committed
locally, so it will not be clobbered if there are conflicts.
See also git-stash(1). git pull and git merge will stop
without doing anything when local uncommitted changes
overlap with files that git pull/git merge may need to
update.</p>

<p>To avoid recording unrelated changes in the merge
commit, git pull and git merge will also abort if there are
any changes registered in the index relative to the HEAD
commit. (One exception is when the changed index entries are
in the state that would result from the merge already.)</p>

<p>If all named commits are already ancestors of HEAD, git
merge will exit early with the message &quot;Already
up-to-date.&quot;</p>

<p>FAST-FORWARD MERGE Often the current branch head is an
ancestor of the named commit. This is the most common case
especially when invoked from git pull: you are tracking an
upstream repository, you have committed no local changes,
and now you want to update to a newer upstream revision. In
this case, a new commit is not needed to store the combined
history; instead, the HEAD (along with the index) is updated
to point at the named commit, without creating an extra
merge commit.</p>

<p>This behavior can be suppressed with the --no-ff
option.</p>

<p>TRUE MERGE Except in a fast-forward merge (see above),
the branches to be merged must be tied together by a merge
commit that has both of them as its parents.</p>

<p>A merged version reconciling the changes from all
branches to be merged is committed, and your HEAD, index,
and working tree are updated to it. It is possible to have
modifications in the working tree as long as they do not
overlap; the update will preserve them.</p>

<p>When it is not obvious how to reconcile the changes, the
following happens:</p>

<p>1. The HEAD pointer stays the same.</p>

<p>2. The MERGE_HEAD ref is set to point to the other
branch head.</p>

<p>3. Paths that merged cleanly are updated both in the
index file and in your working tree.</p>

<p>4. For conflicting paths, the index file records up to
three versions: stage 1 stores the version from the common
ancestor, stage 2 from HEAD, and stage 3 from MERGE_HEAD
(you can inspect the stages with git ls-files -u). The
working tree files contain the result of the
&quot;merge&quot; program; i.e. 3-way merge results with
familiar conflict markers &lt;&lt;&lt; === &gt;&gt;&gt;.</p>

<p>5. No other changes are made. In particular, the local
modifications you had before you started merge will stay the
same and the index entries for them stay as they were, i.e.
matching HEAD.</p>

<p>If you tried a merge which resulted in complex conflicts
and want to start over, you can recover with git reset
--merge.</p>

<p>HOW CONFLICTS ARE PRESENTED During a merge, the working
tree files are updated to reflect the result of the merge.
Among the changes made to the common ancestors version,
non-overlapping ones (that is, you changed an area of the
file while the other side left that area intact, or vice
versa) are incorporated in the final result verbatim. When
both sides made changes to the same area, however, git
cannot randomly pick one side over the other, and asks you
to resolve it by leaving what both sides did to that
area.</p>

<p>By default, git uses the same style as that is used by
&quot;merge&quot; program from the RCS suite to present such
a conflicted hunk, like this:</p>

<p>Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt Conflict
resolution is hard; let&acute;s go shopping. ======= Git
makes conflict resolution easy. &gt;&gt;&gt;&gt;&gt;&gt;&gt;
theirs:sample.txt And here is another line that is cleanly
resolved or unmodified.</p>

<p>The area where a pair of conflicting changes happened is
marked with markers &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======,
and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. The part before the
======= is typically your side, and the part afterwards is
typically their side.</p>

<p>The default format does not show what the original said
in the conflicting area. You cannot tell how many lines are
deleted and replaced with Barbies remark on your side. The
only thing you can tell is that your side wants to say it is
hard and youd prefer to go shopping, while the other side
wants to claim it is easy.</p>

<p>An alternative style can be used by setting the
&quot;merge.conflictstyle&quot; configuration variable to
&quot;diff3&quot;. In &quot;diff3&quot; style, the above
conflict may look like this:</p>

<p>Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt Conflict
resolution is hard; let&acute;s go shopping. |||||||
Conflict resolution is hard. ======= Git makes conflict
resolution easy. &gt;&gt;&gt;&gt;&gt;&gt;&gt;
theirs:sample.txt And here is another line that is cleanly
resolved or unmodified.</p>

<p>In addition to the &lt;&lt;&lt;&lt;&lt;&lt;&lt;,
=======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers, it uses
another ||||||| marker that is followed by the original
text. You can tell that the original just stated a fact, and
your side simply gave in to that statement and gave up,
while the other side tried to have a more positive attitude.
You can sometimes come up with a better resolution by
viewing the original.</p>

<p>HOW TO RESOLVE CONFLICTS After seeing a conflict, you
can do two things:</p>

<p>&middot; Decide not to merge. The only clean-ups you
need are to reset the index file to the HEAD commit to
reverse 2. and to clean up working tree changes made by 2.
and 3.; git-reset --hard can be used for this.</p>

<p>&middot; Resolve the conflicts. Git will mark the
conflicts in the working tree. Edit the files into shape and
git add them to the index. Use git commit to seal the
deal.</p>

<p>You can work through the conflict with a number of
tools:</p>

<p>&middot; Use a mergetool. git mergetool to launch a
graphical mergetool which will work you through the
merge.</p>

<p>&middot; Look at the diffs. git diff will show a
three-way diff, highlighting changes from both the HEAD and
MERGE_HEAD versions.</p>

<p>&middot; Look at the diffs from each branch. git log
--merge -p &lt;path&gt; will show diffs first for the HEAD
version and then the MERGE_HEAD version.</p>

<p>&middot; Look at the originals. git show :1:filename
shows the common ancestor, git show :2:filename shows the
HEAD version, and git show :3:filename shows the MERGE_HEAD
version.</p>

<p>EXAMPLES &middot; Merge branches fixes and enhancements
on top of the current branch, making an octopus merge:</p>

<p>$ git merge fixes enhancements</p>

<p>&middot; Merge branch obsolete into the current branch,
using ours merge strategy:</p>

<p>$ git merge -s ours obsolete</p>

<p>&middot; Merge branch maint into the current branch, but
do not make a new commit automatically:</p>

<p>$ git merge --no-commit maint</p>

<p>This can be used when you want to include further
changes to the merge, or want to write your own merge commit
message.</p>

<p>You should refrain from abusing this option to sneak
substantial changes into a merge commit. Small fixups like
bumping release/version name would be acceptable.</p>

<p>MERGE STRATEGIES The merge mechanism (git-merge and
git-pull commands) allows the backend merge strategies to be
chosen with -s option. Some strategies can also take their
own options, which can be passed by giving -X&lt;option&gt;
arguments to git-merge and/or git-pull.</p>

<p>resolve This can only resolve two heads (i.e. the
current branch and another branch you pulled from) using a
3-way merge algorithm. It tries to carefully detect
criss-cross merge ambiguities and is considered generally
safe and fast.</p>

<p>recursive This can only resolve two heads using a 3-way
merge algorithm. When there is more than one common ancestor
that can be used for 3-way merge, it creates a merged tree
of the common ancestors and uses that as the reference tree
for the 3-way merge. This has been reported to result in
fewer merge conflicts without causing mis-merges by tests
done on actual merge commits taken from Linux 2.6 kernel
development history. Additionally this can detect and handle
merges involving renames. This is the default merge strategy
when pulling or merging one branch.</p>

<p>The recursive strategy can take the following
options:</p>

<p>ours This option forces conflicting hunks to be
auto-resolved cleanly by favoring our version. Changes from
the other tree that do not conflict with our side are
reflected to the merge result.</p>

<p>This should not be confused with the ours merge
strategy, which does not even look at what the other tree
contains at all. It discards everything the other tree did,
declaring our history contains all that happened in it.</p>

<p>theirs This is opposite of ours.</p>

<p>subtree[=path] This option is a more advanced form of
subtree strategy, where the strategy makes a guess on how
two trees must be shifted to match with each other when
merging. Instead, the specified path is prefixed (or
stripped from the beginning) to make the shape of two trees
to match.</p>

<p>octopus This resolves cases with more than two heads,
but refuses to do a complex merge that needs manual
resolution. It is primarily meant to be used for bundling
topic branch heads together. This is the default merge
strategy when pulling or merging more than one branch.</p>

<p>ours This resolves any number of heads, but the
resulting tree of the merge is always that of the current
branch head, effectively ignoring all changes from all other
branches. It is meant to be used to supersede old
development history of side branches. Note that this is
different from the -Xours option to the recursive merge
strategy.</p>

<p>subtree This is a modified recursive strategy. When
merging trees A and B, if B corresponds to a subtree of A, B
is first adjusted to match the tree structure of A, instead
of reading the trees at the same level. This adjustment is
also done to the common ancestor tree.</p>

<p>CONFIGURATION merge.conflictstyle Specify the style in
which conflicted hunks are written out to working tree files
upon merge. The default is &quot;merge&quot;, which shows a
&lt;&lt;&lt;&lt;&lt;&lt;&lt; conflict marker, changes made
by one side, a ======= marker, changes made by the other
side, and then a &gt;&gt;&gt;&gt;&gt;&gt;&gt; marker. An
alternate style, &quot;diff3&quot;, adds a ||||||| marker
and the original text before the ======= marker.</p>

<p>merge.log Whether to include summaries of merged commits
in newly created merge commit messages. False by
default.</p>

<p>merge.renameLimit The number of files to consider when
performing rename detection during a merge; if not
specified, defaults to the value of diff.renameLimit.</p>

<p>merge.stat Whether to print the diffstat between
ORIG_HEAD and the merge result at the end of the merge. True
by default.</p>

<p>merge.tool Controls which merge resolution program is
used by git- mergetool(1). Valid built-in values are:
&quot;kdiff3&quot;, &quot;tkdiff&quot;, &quot;meld&quot;,
&quot;xxdiff&quot;, &quot;emerge&quot;, &quot;vimdiff&quot;,
&quot;gvimdiff&quot;, &quot;diffuse&quot;,
&quot;ecmerge&quot;, &quot;tortoisemerge&quot;,
&quot;p4merge&quot;, &quot;araxis&quot; and
&quot;opendiff&quot;. Any other value is treated is custom
merge tool and there must be a corresponding
mergetool.&lt;tool&gt;.cmd option.</p>

<p>merge.verbosity Controls the amount of output shown by
the recursive merge strategy. Level 0 outputs nothing except
a final error message if conflicts were detected. Level 1
outputs only conflicts, 2 outputs conflicts and file
changes. Level 5 and above outputs debugging information.
The default is level 2. Can be overridden by the
GIT_MERGE_VERBOSITY environment variable.</p>

<p>merge.&lt;driver&gt;.name Defines a human-readable name
for a custom low-level merge driver. See gitattributes(5)
for details.</p>

<p>merge.&lt;driver&gt;.driver Defines the command that
implements a custom low-level merge driver. See
gitattributes(5) for details.</p>

<p>merge.&lt;driver&gt;.recursive Names a low-level merge
driver to be used when performing an internal merge between
common ancestors. See gitattributes(5) for details.</p>

<p>branch.&lt;name&gt;.mergeoptions Sets default options
for merging into branch &lt;name&gt;. The syntax and
supported options are the same as those of git merge, but
option values containing whitespace characters are currently
not supported.</p>

<p>SEE ALSO git-fmt-merge-msg(1), git-pull(1),
gitattributes(5), git-reset(1), git- diff(1),
git-ls-files(1), git-add(1), git-rm(1), git-mergetool(1)</p>

<p>AUTHOR Written by Junio C Hamano
&lt;gitster@pobox.com[1]&gt;</p>

<p>DOCUMENTATION Documentation by Junio C Hamano and the
git-list &lt;git@vger.kernel.org[2]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. gitster@pobox.com mailto:gitster@pobox.com</p>

<p>2. git@vger.kernel.org mailto:git@vger.kernel.org</p>

<p>Git 1.7.1 02/26/2013 GIT-MERGE(1)</p>
<hr>
</body>
</html>
