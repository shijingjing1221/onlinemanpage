<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:26:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERF-STAT(1) perf Manual PERF-STAT(1)</p>

<p>NAME perf-stat - Run a command and gather performance
counter statistics</p>

<p>SYNOPSIS perf stat [-e &lt;EVENT&gt; | --event=EVENT]
[-a] &lt;command&gt; perf stat [-e &lt;EVENT&gt; |
--event=EVENT] [-a] &lt;command&gt; [&lt;options&gt;]</p>

<p>DESCRIPTION This command runs a command and gathers
performance counter statistics from it.</p>

<p>OPTIONS &lt;command&gt;... Any command you can specify
in a shell.</p>

<p>-e, --event= Select the PMU event. Selection can be a
symbolic event name (use perf list to list all events) or a
raw PMU event (eventsel+umask) in the form of rNNN where NNN
is a hexadecimal event descriptor.</p>

<p>-i, --no-inherit child tasks do not inherit counters</p>

<p>-p, --pid=&lt;pid&gt; stat events on existing process id
(comma separated list)</p>

<p>-t, --tid=&lt;tid&gt; stat events on existing thread id
(comma separated list)</p>

<p>-a, --all-cpus system-wide collection from all CPUs</p>

<p>-c, --scale scale/normalize counter values</p>

<p>-r, --repeat=&lt;n&gt; repeat command and print average
+ stddev (max: 100). 0 means forever.</p>

<p>-B, --big-num print large numbers with thousands&acute;
separators according to locale</p>

<p>-C, --cpu= Count only on the list of CPUs provided.
Multiple CPUs can be provided as a comma-separated list with
no space: 0,1. Ranges of CPUs are specified with -: 0-2. In
per-thread mode, this option is ignored. The -a option is
still necessary to activate system-wide monitoring. Default
is to count on all CPUs.</p>

<p>-A, --no-aggr Do not aggregate counts across all
monitored CPUs in system-wide mode (-a). This option is only
valid in system-wide mode.</p>

<p>-n, --null null run - dont start any counters</p>

<p>-v, --verbose be more verbose (show counter open errors,
etc)</p>

<p>-x SEP, --field-separator SEP print counts using a
CSV-style output to make it easy to import directly into
spreadsheets. Columns are separated by the string specified
in SEP.</p>

<p>-G name, --cgroup name monitor only in the container
(cgroup) called &quot;name&quot;. This option is available
only in per-cpu mode. The cgroup filesystem must be mounted.
All threads belonging to container &quot;name&quot; are
monitored when they run on the monitored CPUs. Multiple
cgroups can be provided. Each cgroup is applied to the
corresponding event, i.e., first cgroup to first event,
second cgroup to second event and so on. It is possible to
provide an empty cgroup (monitor all the time) using, e.g.,
-G foo,,bar. Cgroups must have corresponding events, i.e.,
they always refer to events defined earlier on the command
line.</p>

<p>-o file, --output file Print the output into the
designated file.</p>

<p>--append Append to the output file designated with the
-o option. Ignored if -o is not specified.</p>

<p>--log-fd Log output to fd, instead of stderr.
Complementary to --output, and mutually exclusive with it.
--append may be used here. Examples: 3&gt;results perf stat
--log-fd 3 $cmd 3&gt;&gt;results perf stat --log-fd 3
--append $cmd</p>

<p>--pre, --post Pre and post measurement hooks, e.g.:</p>

<p>perf stat --repeat 10 --null --sync --pre make -s
O=defconfig-build/clean make -s -j64 O=defconfig-build/
bzImage</p>

<p>-I msecs, --interval-print msecs Print count deltas
every N milliseconds (minimum: 100ms) example: perf stat -I
1000 -e cycles -a sleep 5</p>

<p>--per-socket Aggregate counts per processor socket for
system-wide mode measurements. This is a useful mode to
detect imbalance between sockets. To enable this mode, use
--per-socket in addition to -a. (system-wide). The output
includes the socket number and the number of online
processors on that socket. This is useful to gauge the
amount of aggregation.</p>

<p>--per-core Aggregate counts per physical processor for
system-wide mode measurements. This is a useful mode to
detect imbalance between physical cores. To enable this
mode, use --per-core in addition to -a. (system-wide). The
output includes the core number and the number of online
logical processors on that physical processor.</p>

<p>-D msecs, --delay msecs After starting the program, wait
msecs before measuring. This is useful to filter out the
startup phase of the program, which is often very
different.</p>

<p>-T, --transaction Print statistics of transactional
execution if supported.</p>

<p>EXAMPLES $ perf stat make -j</p>

<p>Performance counter stats for &acute;make -j&acute;:</p>

<p>8117.370256 task clock ticks # 11.281 CPU utilization
factor 678 context switches # 0.000 M/sec 133 CPU migrations
# 0.000 M/sec 235724 pagefaults # 0.029 M/sec 24821162526
CPU cycles # 3057.784 M/sec 18687303457 instructions #
2302.138 M/sec 172158895 cache references # 21.209 M/sec
27075259 cache misses # 3.335 M/sec</p>

<p>Wall-clock time elapsed: 719.554352 msecs</p>

<p>SEE ALSO perf-top(1), perf-list(1)</p>

<p>perf 07/01/2015 PERF-STAT(1)</p>
<hr>
</body>
</html>
