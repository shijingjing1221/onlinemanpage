<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:07:39 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CLOSE(2) Linux Programmer s Manual CLOSE(2)</p>

<p>NAME close - close a file descriptor</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int close(int fd);</p>

<p>DESCRIPTION close() closes a file descriptor, so that it
no longer refers to any file and may be reused. Any record
locks (see fcntl(2)) held on the file it was associated
with, and owned by the process, are removed (regardless of
the file descriptor that was used to obtain the lock).</p>

<p>If fd is the last file descriptor referring to the
underlying open file description (see open(2)), the
resources associated with the open file description are
freed; if the descriptor was the last reference to a file
which has been removed using unlink(2) the file is
deleted.</p>

<p>RETURN VALUE close() returns zero on success. On error,
-1 is returned, and errno is set appropriately.</p>

<p>ERRORS EBADF fd isnt a valid open file descriptor.</p>

<p>EINTR The close() call was interrupted by a signal; see
signal(7).</p>

<p>EIO An I/O error occurred.</p>

<p>CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001.</p>

<p>NOTES Not checking the return value of close() is a
common but nevertheless serious programming error. It is
quite possible that errors on a pre- vious write(2)
operation are first reported at the final close(). Not
checking the return value when closing the file may lead to
silent loss of data. This can especially be observed with
NFS and with disk quota.</p>

<p>A successful close does not guarantee that the data has
been success- fully saved to disk, as the kernel defers
writes. It is not common for a file system to flush the
buffers when the stream is closed. If you need to be sure
that the data is physically stored use fsync(2). (It will
depend on the disk hardware at this point.)</p>

<p>It is probably unwise to close file descriptors while
they may be in use by system calls in other threads in the
same process. Since a file descriptor may be re-used, there
are some obscure race conditions that may cause unintended
side effects.</p>

<p>When dealing with sockets, you have to be sure that
there is no recv(2) still blocking on it on another thread,
otherwise it might block for- ever, since no more messages
will be sent via the socket. Be sure to use shutdown(2) to
shut down all parts the connection before closing the
socket.</p>

<p>SEE ALSO fcntl(2), fsync(2), open(2), shutdown(2),
unlink(2), fclose(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2007-12-28 CLOSE(2)</p>
<hr>
</body>
</html>
