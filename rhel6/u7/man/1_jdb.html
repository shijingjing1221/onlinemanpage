<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:20 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>jdb(1) jdb(1)</p>

<p>Name jdb - The Java Debugger</p>

<p>jdb helps you find and fix bugs in Java language
programs.</p>

<p>SYNOPSIS jdb [ options ] [ class ] [ arguments ]</p>

<p>options Command-line options, as specified below.</p>

<p>class Name of the class to begin debugging.</p>

<p>arguments Arguments passed to the main() method of
class.</p>

<p>DESCRIPTION The Java Debugger, jdb, is a simple
command-line debugger for Java classes. It is a
demonstration of the Java Platform Debugger Architec- ture @
http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html
that provides inspection and debugging of a local or remote
Java Vir- tual Machine.</p>

<p>Starting a jdb Session There are many ways to start a
jdb session. The most frequently used way is to have jdb
launch a new Java Virtual Machine (VM) with the main class
of the application to be debugged. This is done by
substituting the command jdb for java in the command line.
For example, if your application s main class is MyClass,
you use the following command to debug it under JDB:</p>

<p>% jdb MyClass</p>

<p>When started this way, jdb invokes a second Java VM with
any specified parameters, loads the specified class, and
stops the VM before execut- ing that classs first
instruction.</p>

<p>Another way to use jdb is by attaching it to a Java VM
that is already running. Syntax for Starting a VM to which
jdb will attach when the VM is running is as follows. This
loads in-process debugging libraries and specifies the kind
of connection to be made.</p>


<p>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n</p>

<p>For example, the following command will run the MyClass
application, and allow jdb to connect to it at a later
time.</p>

<p>% java
-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n
MyClass</p>

<p>You can then attach jdb to the VM with the following
commmand:</p>

<p>% jdb -attach 8000</p>

<p>Note that &quot;MyClass&quot; is not specified in the
jdb command line in this case because jdb is connecting to
an existing VM instead of launching a new one.</p>

<p>There are many other ways to connect the debugger to a
VM, and all of them are supported by jdb. The Java Platform
Debugger Architecture has additional documentation @
http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html
on these connection options. For information on starting a
J2SE 1.4.2 or early VM for use with jdb see the 1.4.2
documentation @
http://java.sun.com/j2se/1.4.2/docs/guide/jpda/conninv.html</p>

<p>Basic jdb Commands The following is a list of the basic
jdb commands. The Java debugger supports other commands
which you can list using jdbs help command.</p>

<p>help, or ? The most important jdb command, help displays
the list of recog- nized commands with a brief
description.</p>

<p>run After starting jdb, and setting any necessary
breakpoints, you can use this command to start the execution
the debugged applica- tion. This command is available only
when jdb launches the debugged application (as opposed to
attaching to an existing VM).</p>

<p>cont Continues execution of the debugged application
after a break- point, exception, or step.</p>

<p>print Displays Java objects and primitive values. For
variables or fields of primitive types, the actual value is
printed. For objects, a short description is printed. See
the dump command below for getting more information about an
object. NOTE: To display local variables, the containing
class must have been compiled with the javac(1) -g option.
print supports many simple Java expressions including those
with method invocations, for example:</p>

<p>o print MyClass.myStaticField</p>

<p>o print myObj.myInstanceField</p>

<p>o print i + j + k (i, j, k are primities and either
fields or local variables)</p>

<p>o print myObj.myMethod() (if myMethod returns a
non-null)</p>

<p>o print new
java.lang.String(&quot;Hello&quot;).length()</p>

<p>dump For primitive values, this command is identical to
print. For objects, it prints the current value of each
field defined in the object. Static and instance fields are
included. The dump command supports the same set of
expressions as the print command.</p>

<p>threads List the threads that are currently running. For
each thread, its name and current status are printed, as
well as an index that can be used for other commands, for
example:</p>

<p>4. (java.lang.Thread)0x1 main running</p>

<p>In this example, the thread index is 4, the thread is an
instance of java.lang.Thread, the thread name is
&quot;main&quot;, and it is cur- rently running,</p>

<p>thread Select a thread to be the current thread. Many
jdb commands are based on the setting of the current thread.
The thread is speci- fied with the thread index described in
the threads command above.</p>

<p>where where with no arguments dumps the stack of the
current thread. where all dumps the stack of all threads in
the current thread group. where threadindex dumps the stack
of the specified thread. If the current thread is suspended
(either through an event such as a breakpoint or through the
suspend command), local variables and fields can be
displayed with the print and dump commands. The up and down
commands select which stack frame is current.</p>

<p>Breakpoints Breakpoints can be set in jdb at line
numbers or at the first instruc- tion of a method, for
example:</p>

<p>o stop at MyClass:22 (sets a breakpoint at the first
instruction for line 22 of the source file containing
MyClass)</p>

<p>o stop in java.lang.String.length (sets a breakpoint at
the beginnig of the method java.lang.String.length)</p>

<p>o stop in MyClass.&lt;init&gt; (&lt;init&gt; identifies
the MyClass constructor)</p>

<p>o stop in MyClass.&lt;clinit&gt; (&lt;clinit&gt;
identifies the static initial- ization code for MyClass)</p>

<p>If a method is overloaded, you must also specify its
argument types so that the proper method can be selected for
a breakpoint. For example,
&quot;MyClass.myMethod(int,java.lang.String)&quot;, or
&quot;MyClass.myMethod()&quot;.</p>

<p>The clear command removes breakpoints using a syntax as
in &quot;clear MyClass:45&quot;. Using the clear or command
with no argument dis- plays a list of all breakpoints
currently set. The cont command continues execution.</p>

<p>Stepping The step commands advances execution to the
next line whether it is in the current stack frame or a
called method. The next command advances execution to the
next line in the current stack frame.</p>

<p>Exceptions When an exception occurs for which there isnt
a catch statement any- where in the throwing threads call
stack, the VM normally prints an exception trace and exits.
When running under jdb, however, control returns to jdb at
the offending throw. You can then use jdb to diagnose the
cause of the exception.</p>

<p>Use the catch command to cause the debugged application
to stop at other thrown exceptions, for example: &quot;catch
java.io.FileNotFoundExcep- tion&quot; or &quot;catch
mypackage.BigTroubleException. Any exception which is an
instance of the specifield class (or of a subclass) will
stop the application at the point where it is thrown.</p>

<p>The ignore command negates the effect of a previous
catch command.</p>

<p>NOTE: The ignore command does not cause the debugged VM
to ignore spe- cific exceptions, only the debugger.</p>

<p>Command Line Options When you use jdb in place of the
Java application launcher on the com- mand line, jdb accepts
many of the same options as the java command, including -D,
-classpath, and -X&lt;option&gt;.</p>

<p>The following additional options are accepted by
jdb:</p>

<p>-help Displays a help message.</p>

<p>-sourcepath &lt;dir1:dir2:...&gt; Uses the given path in
searching for source files in the speci- fied path. If this
option is not specified, the default path of &quot;.&quot;
is used.</p>

<p>-attach &lt;address&gt; Attaches the debugger to
previously running VM using the default connection
mechanism.</p>

<p>-listen &lt;address&gt; Waits for a running VM to
connect at the specified address using standard
connector.</p>

<p>-listenany Waits for a running VM to connect at any
available address using standard connector.</p>

<p>-launch Launches the debugged application immediately
upon startup of jdb. This option removes the need for using
the run command. The debuged application is launched and
then stopped just before the initial application class is
loaded. At that point you can set any necessary breakpoints
and use the cont to continue execution.</p>

<p>-listconnectors List the connectors available in this
VM</p>

<p>-connect
&lt;connector-name&gt;:&lt;name1&gt;=&lt;value1&gt;,...
Connects to target VM using named connector with listed
argument values.</p>

<p>-dbgtrace [flags] Prints info for debugging jdb.</p>

<p>-tclient Runs the application in the Java HotSpot(tm) VM
(Client).</p>

<p>-tserver Runs the application in the Java HotSpot(tm) VM
(Server).</p>

<p>-Joption Pass option to the Java virtual machine used to
run jdb. (Options for the application Java virtual machine
are passed to the run command.) For example, -J-Xms48m sets
the startup memory to 48 megabytes.</p>

<p>Other options are supported for alternate mechanisms for
connecting the debugger and the VM it is to debug. The Java
Platform Debugger Archi- tecture has additional
documentation @
http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html
on these connection alternatives.</p>

<p>Options Forwarded to Debuggee Process -v
-verbose[:class|gc|jni] Turns on verbose mode.</p>

<p>-D&lt;name&gt;=&lt;value&gt; Sets a system property.</p>

<p>-classpath &lt;directories separated by
&quot;:&quot;&gt; Lists directories in which to look for
classes.</p>

<p>-X&lt;option&gt; Non-standard target VM option</p>

<p>SEE ALSO javac(1), java(1), javah(1), javap(1),
javadoc(1).</p>

<p>16 Mar 2012 jdb(1)</p>
<hr>
</body>
</html>
