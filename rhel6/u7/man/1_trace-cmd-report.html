<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:42:34 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TRACE-CMD-REPORT(1) [FIXME: manual]
TRACE-CMD-REPORT(1)</p>

<p>NAME trace-cmd-report - show in ASCII a trace created by
trace-cmd record</p>

<p>SYNOPSIS trace-cmd report [OPTIONS] [input-file]</p>

<p>DESCRIPTION The trace-cmd(1) report command will output
a human readable report of a trace created by trace-cmd
record.</p>

<p>OPTIONS -i input-file By default, trace-cmd report will
read the file trace.dat. But the -i option open up the given
input-file instead. Note, the input file may also be
specified as the last item on the command line.</p>

<p>-e This outputs the endianess of the file. trace-cmd
report is smart enough to be able to read big endian files
on little endian machines, and vise versa.</p>

<p>-f This outputs the list of functions that have been
recorded in the file.</p>

<p>-P This outputs the list of &quot;trace_printk()&quot;
data. The raw trace data points to static pointers in the
kernel. This must be stored in the trace.dat file.</p>

<p>-E This lists the possible events in the file (but this
list is not necessarily the list of events in the file).</p>

<p>--events This will list the event formats that are
stored in the trace.dat file.</p>

<p>-F filter Add a filter to limit what events are
displayed. The format of the filter is:</p>

<p>&lt;events&gt; &acute;:&acute; &lt;filter&gt;
&lt;events&gt; = SYSTEM&acute;/&acute;EVENT | SYSTEM | EVENT
| &lt;events&gt; &acute;,&acute; &lt;events&gt;
&lt;filter&gt; = EVENT_FIELD &lt;op&gt; &lt;value&gt; |
&lt;filter&gt; &acute;&amp;&amp;&acute; &lt;filter&gt; |
&lt;filter&gt; &acute;||&acute; &lt;filter&gt; |
&acute;(&acute; &lt;filter&gt; &acute;)&acute; |
&acute;!&acute; &lt;filter&gt; &lt;op&gt; = &acute;==&acute;
| &acute;!=&acute; | &acute;&gt;=&acute; |
&acute;&lt;=&acute; | &acute;&gt;&acute; |
&acute;&lt;&acute; | &acute;&amp;&acute; | &acute;|&acute; |
&acute;^&acute; | &acute;+&acute; | &acute;-&acute; |
&acute;*&acute; | &acute;/&acute; | &acute;%&acute;
&lt;value&gt; = NUM | STRING | EVENT_FIELD</p>

<p>SYSTEM is the name of the system to filter on. If the
EVENT is left out, then it applies to all events under the
SYSTEM. If only one string is used without the
&acute;/&acute; to deliminate between SYSTEM and EVENT, then
the filter will be applied to all systems and events that
match the given string.</p>

<p>Whitespace is ignored, such that
&quot;sched:next_pid==123&quot; is equivalent to &quot;sched
: next_pid == 123&quot;.</p>

<p>STRING is defined with single or double quotes (single
quote must end with single quote, and double with double).
Whitespace within quotes are not ignored.</p>

<p>The representation of a SYSTEM or EVENT may also be a
regular expression as defined by
&acute;regcomp(3)&acute;.</p>

<p>The EVENT_FIELD is the name of the field of an event
that is being filtered. If the event does not contain the
EVENT_FIELD, that part of the equation will be considered
false.</p>

<p>-F &acute;sched : bogus == 1 || common_pid ==
2&acute;</p>

<p>The &quot;bogus == 1&quot; will always evaluate to FALSE
because no event has a field called &quot;bogus&quot;, but
the &quot;common_pid == 2&quot; will still be evaluated
since all events have the field &quot;common_pid&quot;. Any
&quot;sched&quot; event that was traced by the process with
the PID of 2 will be shown.</p>

<p>Note, the EVENT_FIELD is the field name as shown by an
events format (as displayed with *--events*), and not what
is found in the output. If the output shows
&quot;ID:foo&quot; but the field that &quot;foo&quot;
belongs to was called &quot;name&quot; in the event format,
then &quot;name&quot; must be used in the filter. The same
is true about values. If the value that is displayed is
converted by to a string symbol, the filter checks the
original value and not the value displayed. For example, to
filter on all tasks that were in the running state at a
context switch:</p>

<p>-F &acute;sched/sched_switch : prev_state==0&acute;</p>

<p>Although the output displays &acute;R&acute;, having
&acute;prev_stat==&quot;R&quot;&acute; will not work.</p>

<p>-v This causes the following filters of -F to filter out
the matching events.</p>

<p>-v -F &acute;sched/sched_switch : prev_state ==
0&acute;</p>

<p>Will not display any sched_switch events that have a
prev_state of 0. Removing the *-v* will only print out those
events.</p>

<p>-V Show the plugins that are loaded.</p>

<p>-L This will not load system wide plugins. It loads
&quot;local only&quot;. That is what it finds in the
~/.trace-cmd/plugins directory.</p>

<p>-N This will not load any plugins.</p>

<p>-r This will show the events in &quot;raw&quot; format.
That is, it will ignore the event s print formatting and
just print the contents of each field.</p>

<p>-l This adds a &quot;latency output&quot; format.
Information about interrupts being disabled, soft irq being
disabled, the &quot;need_resched&quot; flag being set,
preempt count, and big kernel lock are all being recorded
with every event. But the default display does not show this
information. This option will set display this information
with 6 characters. When one of the fields is zero or N/A a
&acute;.&acute; is shown.</p>

<p>&lt;idle&gt;-0 0d.h1. 106467.859747: function: ktime_get
&lt;-- tick_check_idle</p>

<p>The 0d.h1. denotes this information. The first character
is never a &acute;.&acute; and represents what CPU the trace
was recorded on (CPU 0). The &acute;d&acute; denotes that
interrupts were disabled. The &acute;h&acute; means that
this was called inside an interrupt handler. The
&acute;1&acute; is the preemption disabled (preempt_count)
was set to one. The two &acute;.&acute;s are
&quot;need_resched&quot; flag and kernel lock counter. If
the &quot;need_resched&quot; flag is set, then that
character would be a &acute;N&acute;.</p>

<p>-w If both the sched_switch and sched_wakeup events are
enabled, then this option will report the latency between
the time the task was first woken, and the time it was
scheduled in.</p>

<p>-q Quiet non critical warnings.</p>

<p>EXAMPLES Using a trace.dat file that was created
with:</p>

<p># trace-cmd record -p function -e all sleep 5</p>

<p>The default report shows:</p>

<p># trace-cmd report trace-cmd-16129 [002] 158126.498411:
function: __mutex_unlock_slowpath &lt;-- mutex_unlock
trace-cmd-16131 [000] 158126.498411: kmem_cache_alloc:
call_site=811223c5 ptr=0xffff88003ecf2b40 bytes_req=272
bytes_alloc=320 gfp_flags=GFP_KERNEL|GFP_ZERO
trace-cmd-16130 [003] 158126.498411: function: do_splice_to
&lt;-- sys_splice sleep-16133 [001] 158126.498412: function:
inotify_inode_queue_event &lt;-- vfs_write trace-cmd-16129
[002] 158126.498420: lock_release: 0xffff88003f1fa4f8
&amp;sb-&gt;s_type-&gt;i_mutex_key trace-cmd-16131 [000]
158126.498421: function: security_file_alloc &lt;--
get_empty_filp sleep-16133 [001] 158126.498422: function:
__fsnotify_parent &lt;-- vfs_write trace-cmd-16130 [003]
158126.498422: function: rw_verify_area &lt;-- do_splice_to
trace-cmd-16131 [000] 158126.498424: function:
cap_file_alloc_security &lt;-- security_file_alloc
trace-cmd-16129 [002] 158126.498425: function:
syscall_trace_leave &lt;-- int_check_syscall_exit_work
sleep-16133 [001] 158126.498426: function:
inotify_dentry_parent_queue_event &lt;-- vfs_write
trace-cmd-16130 [003] 158126.498426: function:
security_file_permission &lt;-- rw_verify_area
trace-cmd-16129 [002] 158126.498428: function:
audit_syscall_exit &lt;-- syscall_trace_leave [...]</p>

<p>To see everything but the function traces:</p>

<p># trace-cmd report -v -F &acute;function&acute;
trace-cmd-16131 [000] 158126.498411: kmem_cache_alloc:
call_site=811223c5 ptr=0xffff88003ecf2b40 bytes_req=272
bytes_alloc=320 gfp_flags=GFP_KERNEL|GFP_ZERO
trace-cmd-16129 [002] 158126.498420: lock_release:
0xffff88003f1fa4f8 &amp;sb-&gt;s_type-&gt;i_mutex_key
trace-cmd-16130 [003] 158126.498436: lock_acquire:
0xffffffff8166bf78 read all_cpu_access_lock trace-cmd-16131
[000] 158126.498438: lock_acquire: 0xffff88003df5b520 read
&amp;fs-&gt;lock trace-cmd-16129 [002] 158126.498446: kfree:
call_site=810a7abb ptr=0x0 trace-cmd-16130 [003]
158126.498448: lock_acquire: 0xffff880002250a80
&amp;per_cpu(cpu_access_lock, cpu) trace-cmd-16129 [002]
158126.498450: sys_exit_splice: 0xfffffff5 trace-cmd-16131
[000] 158126.498454: lock_release: 0xffff88003df5b520
&amp;fs-&gt;lock sleep-16133 [001] 158126.498456: kfree:
call_site=810a7abb ptr=0x0 sleep-16133 [001] 158126.498460:
sys_exit_write: 0x1 trace-cmd-16130 [003] 158126.498462:
kmalloc: call_site=810bf95b ptr=0xffff88003dedc040
bytes_req=24 bytes_alloc=32
gfp_flags=GFP_KERNEL|GFP_ZERO</p>

<p>To see only the kmalloc calls that were greater than
1000 bytes:</p>

<p>#trace-cmd report -F &acute;kmalloc: bytes_req &gt;
1000&acute; &lt;idle&gt;-0 [000] 158128.126641: kmalloc:
call_site=81330635 ptr=0xffff88003c2fd000 bytes_req=2096
bytes_alloc=4096 gfp_flags=GFP_ATOMIC</p>

<p>To see wakeups and sched switches that left the previous
task in the running state:</p>

<p># trace-cmd report -F &acute;sched: prev_state == 0 ||
(success == 1)&acute; trace-cmd-16132 [002] 158126.499951:
sched_wakeup: comm=trace-cmd pid=16129 prio=120 success=1
target_cpu=002 trace-cmd-16132 [002] 158126.500401:
sched_switch: prev_comm=trace-cmd prev_pid=16132
prev_prio=120 prev_state=R ==&gt; next_comm=trace-cmd
next_pid=16129 next_prio=120 &lt;idle&gt;-0 [003]
158126.500585: sched_wakeup: comm=trace-cmd pid=16130
prio=120 success=1 target_cpu=003 &lt;idle&gt;-0 [003]
158126.501241: sched_switch: prev_comm=swapper prev_pid=0
prev_prio=120 prev_state=R ==&gt; next_comm=trace-cmd
next_pid=16130 next_prio=120 trace-cmd-16132 [000]
158126.502475: sched_wakeup: comm=trace-cmd pid=16131
prio=120 success=1 target_cpu=000 trace-cmd-16131 [002]
158126.506516: sched_wakeup: comm=trace-cmd pid=16129
prio=120 success=1 target_cpu=002 &lt;idle&gt;-0 [003]
158126.550110: sched_switch: prev_comm=swapper prev_pid=0
prev_prio=120 prev_state=R ==&gt; next_comm=trace-cmd
next_pid=16130 next_prio=120 trace-cmd-16131 [003]
158126.570243: sched_wakeup: comm=trace-cmd pid=16129
prio=120 success=1 target_cpu=003 trace-cmd-16130 [002]
158126.618202: sched_switch: prev_comm=trace-cmd
prev_pid=16130 prev_prio=120 prev_state=R ==&gt;
next_comm=yum-updatesd next_pid=3088 next_prio=1 20
trace-cmd-16129 [003] 158126.622379: sched_wakeup:
comm=trace-cmd pid=16131 prio=120 success=1 target_cpu=003
trace-cmd-16129 [000] 158126.649287: sched_wakeup:
comm=trace-cmd pid=16131 prio=120 success=1
target_cpu=000</p>

<p>The above needs a little explanation. The filter
specifies the &quot;sched&quot; subsystem, which includes
both sched_switch and sched_wakeup events. Any event that
does not have the format field &quot;prev_state&quot; or
&quot;success&quot;, will evaluate those expressions as
FALSE, and will not produce a match. Using &quot;||&quot;
will have the &quot;prev_state&quot; test happen for the
&quot;sched_switch&quot; event and the &quot;success&quot;
test happen for the &quot;sched_wakeup&quot; event.</p>

<p># trace-cmd report -w -F &acute;sched_switch,
sched_wakeup.*&acute; [...] trace-cmd-16130 [003]
158131.580616: sched_wakeup: comm=trace-cmd pid=16131
prio=120 success=1 target_cpu=003 trace-cmd-16129 [000]
158131.581502: sched_switch: prev_comm=trace-cmd
prev_pid=16129 prev_prio=120 prev_state=S ==&gt;
next_comm=trace-cmd next_pid=16131 next_prio=120 Latency:
885.901 usecs trace-cmd-16131 [000] 158131.582414:
sched_wakeup: comm=trace-cmd pid=16129 prio=120 success=1
target_cpu=000 trace-cmd-16132 [001] 158131.583219:
sched_switch: prev_comm=trace-cmd prev_pid=16132
prev_prio=120 prev_state=S ==&gt; next_comm=trace-cmd
next_pid=16129 next_prio=120 Latency: 804.809 usecs
sleep-16133 [002] 158131.584121: sched_wakeup:
comm=trace-cmd pid=16120 prio=120 success=1 target_cpu=002
trace-cmd-16129 [001] 158131.584128: sched_wakeup:
comm=trace-cmd pid=16132 prio=120 success=1 target_cpu=001
sleep-16133 [002] 158131.584275: sched_switch:
prev_comm=sleep prev_pid=16133 prev_prio=120 prev_state=R
==&gt; next_comm=trace-cmd next_pid=16120 next_prio=120
Latency: 153.915 usecs trace-cmd-16130 [003] 158131.585284:
sched_switch: prev_comm=trace-cmd prev_pid=16130
prev_prio=120 prev_state=S ==&gt; next_comm=trace-cmd
next_pid=16132 next_prio=120 Latency: 1155.677 usecs</p>

<p>Average wakeup latency: 26626.656 usecs</p>

<p>The above trace produces the wakeup latencies of the
tasks. The &quot;sched_switch&quot; event reports each
individual latency after writing the event information. At
the end of the report, the average wakeup latency is
reported.</p>

<p># trace-cmd report -w -F &acute;sched_switch,
sched_wakeup.*: prio &lt; 100 || next_prio &lt; 100&acute;
&lt;idle&gt;-0 [003] 158131.516753: sched_wakeup:
comm=ksoftirqd/3 pid=13 prio=49 success=1 target_cpu=003
&lt;idle&gt;-0 [003] 158131.516855: sched_switch:
prev_comm=swapper prev_pid=0 prev_prio=120 prev_state=R
==&gt; next_comm=ksoftirqd/3 next_pid=13 next_prio=49
Latency: 101.244 usecs &lt;idle&gt;-0 [003] 158131.533781:
sched_wakeup: comm=ksoftirqd/3 pid=13 prio=49 success=1
target_cpu=003 &lt;idle&gt;-0 [003] 158131.533897:
sched_switch: prev_comm=swapper prev_pid=0 prev_prio=120
prev_state=R ==&gt; next_comm=ksoftirqd/3 next_pid=13
next_prio=49 Latency: 115.608 usecs &lt;idle&gt;-0 [003]
158131.569730: sched_wakeup: comm=ksoftirqd/3 pid=13 prio=49
success=1 target_cpu=003 &lt;idle&gt;-0 [003] 158131.569851:
sched_switch: prev_comm=swapper prev_pid=0 prev_prio=120
prev_state=R ==&gt; next_comm=ksoftirqd/3 next_pid=13
next_prio=49 Latency: 121.024 usecs</p>

<p>Average wakeup latency: 110.021 usecs</p>

<p>The above version will only show the wakeups and context
switches of Real Time tasks. The prio used inside the kernel
starts at 0 for highest priority. That is prio 0 is
equivalent to user space real time priority 99, and priority
98 is equivalent to user space real time priority 1. Prios
less than 100 represent Real Time tasks.</p>

<p>SEE ALSO trace-cmd(1), trace-cmd-record(1),
trace-cmd-start(1), trace-cmd-stop(1), trace-cmd-extract(1),
trace-cmd-reset(1), trace-cmd-split(1), trace-cmd-list(1),
trace-cmd-listen(1)</p>

<p>AUTHOR Written by Steven Rostedt,
&lt;rostedt@goodmis.org[1]&gt;</p>

<p>RESOURCES
git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git</p>

<p>COPYING Copyright (C) 2010 Red Hat, Inc. Free use of
this software is granted under the terms of the GNU Public
License (GPL).</p>

<p>NOTES 1. rostedt@goodmis.org
mailto:rostedt@goodmis.org</p>

<p>[FIXME: source] 03/27/2014 TRACE-CMD-REPORT(1)</p>
<hr>
</body>
</html>
