<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:18:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ICONV(3) Linux Programmer s Manual ICONV(3)</p>

<p>NAME iconv - perform character set conversion</p>

<p>SYNOPSIS #include &lt;iconv.h&gt;</p>

<p>size_t iconv(iconv_t cd, char **inbuf, size_t
*inbytesleft, char **outbuf, size_t *outbytesleft);</p>

<p>DESCRIPTION The argument cd must be a conversion
descriptor created using the func- tion iconv_open(3).</p>

<p>The main case is when inbuf is not NULL and *inbuf is
not NULL. In this case, the iconv() function converts the
multibyte sequence start- ing at *inbuf to a multibyte
sequence starting at *outbuf. At most *inbytesleft bytes,
starting at *inbuf, will be read. At most *out- bytesleft
bytes, starting at *outbuf, will be written.</p>

<p>The iconv() function converts one multibyte character at
a time, and for each character conversion it increments
*inbuf and decrements *inbytesleft by the number of
converted input bytes, it increments *outbuf and decrements
*outbytesleft by the number of converted output bytes, and
it updates the conversion state contained in cd. If the
character encoding of the input is stateful, the iconv()
function can also convert a sequence of input bytes to an
update to the conversion state without producing any output
bytes; such input is called a shift sequence. The conversion
can stop for four reasons:</p>

<p>1. An invalid multibyte sequence is encountered in the
input. In this case it sets errno to EILSEQ and returns
(size_t) -1. *inbuf is left pointing to the beginning of the
invalid multibyte sequence.</p>

<p>2. The input byte sequence has been entirely converted,
that is, *inbytesleft has gone down to 0. In this case
iconv() returns the num- ber of non-reversible conversions
performed during this call.</p>

<p>3. An incomplete multibyte sequence is encountered in
the input, and the input byte sequence terminates after it.
In this case it sets errno to EINVAL and returns (size_t)
-1. *inbuf is left pointing to the beginning of the
incomplete multibyte sequence.</p>

<p>4. The output buffer has no more room for the next
converted character. In this case it sets errno to E2BIG and
returns (size_t) -1.</p>

<p>A different case is when inbuf is NULL or *inbuf is
NULL, but outbuf is not NULL and *outbuf is not NULL. In
this case, the iconv() function attempts to set cds
conversion state to the initial state and store a
corresponding shift sequence at *outbuf. At most
*outbytesleft bytes, starting at *outbuf, will be written.
If the output buffer has no more room for this reset
sequence, it sets errno to E2BIG and returns (size_t) -1.
Otherwise it increments *outbuf and decrements *out-
bytesleft by the number of bytes written.</p>

<p>A third case is when inbuf is NULL or *inbuf is NULL,
and outbuf is NULL or *outbuf is NULL. In this case, the
iconv() function sets cds conversion state to the initial
state.</p>

<p>RETURN VALUE The iconv() function returns the number of
characters converted in a non-reversible way during this
call; reversible conversions are not counted. In case of
error, it sets errno and returns (size_t) -1.</p>

<p>ERRORS The following errors can occur, among others:</p>

<p>E2BIG There is not sufficient room at *outbuf.</p>

<p>EILSEQ An invalid multibyte sequence has been
encountered in the input.</p>

<p>EINVAL An incomplete multibyte sequence has been
encountered in the input.</p>

<p>VERSIONS This function is available in glibc since
version 2.1.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>SEE ALSO iconv_close(3), iconv_open(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>GNU 2008-09-08 ICONV(3)</p>
<hr>
</body>
</html>
