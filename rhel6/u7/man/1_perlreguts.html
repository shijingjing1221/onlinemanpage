<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLREGUTS(1) Perl Programmers Reference Guide
PERLREGUTS(1)</p>

<p>NAME perlreguts - Description of the Perl regular
expression engine.</p>

<p>DESCRIPTION This document is an attempt to shine some
light on the guts of the regex engine and how it works. The
regex engine represents a significant chunk of the perl
codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is
derived from the authors experience, comments in the source
code, other papers on the regex engine, feedback on the
perl5-porters mail list, and no doubt other places as
well.</p>

<p>NOTICE! It should be clearly understood that the
behavior and structures discussed in this represents the
state of the engine as the author understood it at the time
of writing. It is NOT an API definition, it is purely an
internals guide for those who want to hack the regex engine,
or understand how the regex engine works. Readers of this
document are expected to understand perls regex syntax and
its usage in detail. If you want to learn about the basics
of Perls regular expressions, see perlre. And if you want to
replace the regex engine with your own see see
perlreapi.</p>

<p>OVERVIEW A quick note on terms There is some debate as
to whether to say &quot;regexp&quot; or &quot;regex&quot;.
In this document we will use the term &quot;regex&quot;
unless there is a special reason not to, in which case we
will explain why.</p>

<p>When speaking about regexes we need to distinguish
between their source code form and their internal form. In
this document we will use the term &quot;pattern&quot; when
we speak of their textual, source code form, and the term
&quot;program&quot; when we speak of their internal
representation. These correspond to the terms S-regex and
B-regex that Mark Jason Dominus employs in his paper on
&quot;Rx&quot; ([1] in &quot;REFERENCES&quot;).</p>

<p>What is a regular expression engine? A regular
expression engine is a program that takes a set of
constraints specified in a mini-language, and then applies
those constraints to a target string, and determines whether
or not the string satisfies the constraints. See perlre for
a full definition of the language.</p>

<p>In less grandiose terms, the first part of the job is to
turn a pattern into something the computer can efficiently
use to find the matching point in the string, and the second
part is performing the search itself.</p>

<p>To do this we need to produce a program by parsing the
text. We then need to execute the program to find the point
in the string that matches. And we need to do the whole
thing efficiently.</p>

<p>Structure of a Regexp Program High Level</p>

<p>Although it is a bit confusing and some people object to
the terminology, it is worth taking a look at a comment that
has been in regexp.h for years:</p>

<p>This is essentially a linear encoding of a
nondeterministic finite- state machine (aka syntax charts or
&quot;railroad normal form&quot; in parsing technology).</p>

<p>The term &quot;railroad normal form&quot; is a bit
esoteric, with &quot;syntax diagram/charts&quot;, or
&quot;railroad diagram/charts&quot; being more common terms.
Nevertheless it provides a useful mental image of a regex
program: each node can be thought of as a unit of track,
with a single entry and in most cases a single exit point
(there are pieces of track that fork, but statistically not
many), and the whole forms a layout with a single entry and
single exit point. The matching process can be thought of as
a car that moves along the track, with the particular route
through the system being determined by the character read at
each possible connector point. A car can fall off the track
at any point but it may only proceed as long as it matches
the track.</p>

<p>Thus the pattern &quot;/foo(?:24|bar/&quot; can be
thought of as the following chart:</p>

<p>[start] | &lt;foo&gt; | +-----+-----+ | | | &lt;72&gt;
&lt; | | | +-----+-----+ | &lt;bar&gt; | [end]</p>

<p>The truth of the matter is that perls regular
expressions these days are much more complex than this kind
of structure, but visualising it this way can help when
trying to get your bearings, and it matches the current
implementation pretty closely.</p>

<p>To be more precise, we will say that a regex program is
an encoding of a graph. Each node in the graph corresponds
to part of the original regex pattern, such as a literal
string or a branch, and has a pointer to the nodes
representing the next component to be matched. Since
&quot;node&quot; and &quot;opcode&quot; already have other
meanings in the perl source, we will call the nodes in a
regex program &quot;regops&quot;.</p>

<p>The program is represented by an array of
&quot;regnode&quot; structures, one or more of which
represent a single regop of the program. Struct
&quot;regnode&quot; is the smallest struct needed, and has a
field structure which is shared with all the other larger
structures.</p>

<p>The &quot;next&quot; pointers of all regops except
&quot;BRANCH&quot; implement concatenation; a
&quot;next&quot; pointer with a &quot;BRANCH&quot; on both
ends of it is connecting two alternatives. [Here we have one
of the subtle syntax dependencies: an individual
&quot;BRANCH&quot; (as opposed to a collection of them) is
never concatenated with anything because of operator
precedence.]</p>

<p>The operand of some types of regop is a literal string;
for others, it is a regop leading into a sub-program. In
particular, the operand of a &quot;BRANCH&quot; node is the
first regop of the branch.</p>

<p>NOTE: As the railroad metaphor suggests, this is not a
tree structure: the tail of the branch connects to the thing
following the set of &quot;BRANCH&quot;es. It is a like a
single line of railway track that splits as it goes into a
station or railway yard and rejoins as it comes out the
other side.</p>

<p>Regops</p>

<p>The base structure of a regop is defined in regexp.h as
follows:</p>

<p>struct regnode { U8 flags; /* Various purposes,
sometimes overridden */ U8 type; /* Opcode value as
specified by regnodes.h */ U16 next_off; /* Offset in size
regnode */ };</p>

<p>Other larger &quot;regnode&quot;-like structures are
defined in regcomp.h. They are almost like subclasses in
that they have the same fields as &quot;regnode&quot;, with
possibly additional fields following in the structure, and
in some cases the specific meaning (and name) of some of
base fields are overridden. The following is a more complete
description.</p>

<p>&quot;regnode_1&quot; &quot;regnode_2&quot;
&quot;regnode_1&quot; structures have the same header,
followed by a single four-byte argument;
&quot;regnode_2&quot; structures contain two two-byte
arguments instead:</p>

<p>regnode_1 U32 arg1; regnode_2 U16 arg1; U16 arg2;</p>

<p>&quot;regnode_string&quot; &quot;regnode_string&quot;
structures, used for literal strings, follow the header with
a one-byte length and then the string data. Strings are
padded on the end with zero bytes so that the total length
of the node is a multiple of four bytes:</p>

<p>regnode_string char string[1]; U8 str_len; /* overrides
flags */</p>

<p>&quot;regnode_charclass&quot; Character classes are
represented by &quot;regnode_charclass&quot; structures,
which have a four-byte argument and then a 32-byte (256-bit)
bitmap indicating which characters are included in the
class.</p>

<p>regnode_charclass U32 arg1; char
bitmap[ANYOF_BITMAP_SIZE];</p>

<p>&quot;regnode_charclass_class&quot; There is also a
larger form of a char class structure used to represent
POSIX char classes called
&quot;regnode_charclass_class&quot; which has an additional
4-byte (32-bit) bitmap indicating which POSIX char classes
have been included.</p>

<p>regnode_charclass_class U32 arg1; char
bitmap[ANYOF_BITMAP_SIZE]; char
classflags[ANYOF_CLASSBITMAP_SIZE];</p>

<p>regnodes.h defines an array called
&quot;regarglen[]&quot; which gives the size of each opcode
in units of &quot;size regnode&quot; (4-byte). A macro is
used to calculate the size of an &quot;EXACT&quot; node
based on its &quot;str_len&quot; field.</p>

<p>The regops are defined in regnodes.h which is generated
from regcomp.sym by regcomp.pl. Currently the maximum
possible number of distinct regops is restricted to 256,
with about a quarter already used.</p>

<p>A set of macros makes accessing the fields easier and
more consistent. These include &quot;OP()&quot;, which is
used to determine the type of a &quot;regnode&quot;-like
structure; &quot;NEXT_OFF()&quot;, which is the offset to
the next node (more on this later); &quot;ARG()&quot;,
&quot;ARG1()&quot;, &quot;ARG2()&quot;,
&quot;ARG_SET()&quot;, and equivalents for reading and
setting the arguments; and &quot;STR_LEN()&quot;,
&quot;STRING()&quot; and &quot;OPERAND()&quot; for
manipulating strings and regop bearing types.</p>

<p>What regop is next?</p>

<p>There are three distinct concepts of &quot;next&quot; in
the regex engine, and it is important to keep them
clear.</p>

<p>&middot; There is the &quot;next regnode&quot; from a
given regnode, a value which is rarely useful except that
sometimes it matches up in terms of value with one of the
others, and that sometimes the code assumes this to always
be so.</p>

<p>&middot; There is the &quot;next regop&quot; from a
given regop/regnode. This is the regop physically located
after the the current one, as determined by the size of the
current regop. This is often useful, such as when dumping
the structure we use this order to traverse. Sometimes the
code assumes that the &quot;next regnode&quot; is the same
as the &quot;next regop&quot;, or in other words assumes
that the sizeof a given regop type is always going to be one
regnode large.</p>

<p>&middot; There is the &quot;regnext&quot; from a given
regop. This is the regop which is reached by jumping forward
by the value of &quot;NEXT_OFF()&quot;, or in a few cases
for longer jumps by the &quot;arg1&quot; field of the
&quot;regnode_1&quot; structure. The subroutine
&quot;regnext()&quot; handles this transparently. This is
the logical successor of the node, which in some cases, like
that of the &quot;BRANCH&quot; regop, has special
meaning.</p>

<p>Process Overview Broadly speaking, performing a match of
a string against a pattern involves the following steps:</p>

<p>A. Compilation 1. Parsing for size 2. Parsing for
construction 3. Peep-hole optimisation and analysis B.
Execution 4. Start position and no-match optimisations 5.
Program execution</p>

<p>Where these steps occur in the actual execution of a
perl program is determined by whether the pattern involves
interpolating any string variables. If interpolation occurs,
then compilation happens at run time. If it does not, then
compilation is performed at compile time. (The
&quot;/o&quot; modifier changes this, as does
&quot;qr//&quot; to a certain extent.) The engine doesnt
really care that much.</p>

<p>Compilation This code resides primarily in regcomp.c,
along with the header files regcomp.h, regexp.h and
regnodes.h.</p>

<p>Compilation starts with &quot;pregcomp()&quot;, which is
mostly an initialisation wrapper which farms work out to two
other routines for the heavy lifting: the first is
&quot;reg()&quot;, which is the start point for parsing; the
second, &quot;study_chunk()&quot;, is responsible for
optimisation.</p>

<p>Initialisation in &quot;pregcomp()&quot; mostly involves
the creation and data- filling of a special structure,
&quot;RExC_state_t&quot; (defined in regcomp.c). Almost all
internally-used routines in regcomp.h take a pointer to one
of these structures as their first argument, with the name
&quot;pRExC_state&quot;. This structure is used to store the
compilation state and contains many fields. Likewise there
are many macros which operate on this variable: anything
that looks like &quot;RExC_xxxx&quot; is a macro that
operates on this pointer/structure.</p>

<p>Parsing for size</p>

<p>In this pass the input pattern is parsed in order to
calculate how much space is needed for each regop we would
need to emit. The size is also used to determine whether
long jumps will be required in the program.</p>

<p>This stage is controlled by the macro
&quot;SIZE_ONLY&quot; being set.</p>

<p>The parse proceeds pretty much exactly as it does during
the construction phase, except that most routines are
short-circuited to change the size field
&quot;RExC_size&quot; and not do anything else.</p>

<p>Parsing for construction</p>

<p>Once the size of the program has been determined, the
pattern is parsed again, but this time for real. Now
&quot;SIZE_ONLY&quot; will be false, and the actual
construction can occur.</p>

<p>&quot;reg()&quot; is the start of the parse process. It
is responsible for parsing an arbitrary chunk of pattern up
to either the end of the string, or the first closing
parenthesis it encounters in the pattern. This means it can
be used to parse the top-level regex, or any section inside
of a grouping parenthesis. It also handles the &quot;special
parens&quot; that perl s regexes have. For instance when
parsing &quot;/x(?:foo)y/&quot; &quot;reg()&quot; will at
one point be called to parse from the &quot;?&quot; symbol
up to and including the &quot;)&quot;.</p>

<p>Additionally, &quot;reg()&quot; is responsible for
parsing the one or more branches from the pattern, and for
&quot;finishing them off&quot; by correctly setting their
next pointers. In order to do the parsing, it repeatedly
calls out to &quot;regbranch()&quot;, which is responsible
for handling up to the first &quot;|&quot; symbol it
sees.</p>

<p>&quot;regbranch()&quot; in turn calls
&quot;regpiece()&quot; which handles &quot;things&quot;
followed by a quantifier. In order to parse the
&quot;things&quot;, &quot;regatom()&quot; is called. This is
the lowest level routine, which parses out constant strings,
character classes, and the various special symbols like
&quot;$&quot;. If &quot;regatom()&quot; encounters a
&quot;(&quot; character it in turn calls
&quot;reg()&quot;.</p>

<p>The routine &quot;regtail()&quot; is called by both
&quot;reg()&quot; and &quot;regbranch()&quot; in order to
&quot;set the tail pointer&quot; correctly. When executing
and we get to the end of a branch, we need to go to the node
following the grouping parens. When parsing, however, we
dont know where the end will be until we get there, so when
we do we must go back and update the offsets as appropriate.
&quot;regtail&quot; is used to make this easier.</p>

<p>A subtlety of the parsing process means that a regex
like &quot;/foo/&quot; is originally parsed into an
alternation with a single branch. It is only afterwards that
the optimiser converts single branch alternations into the
simpler form.</p>

<p>Parse Call Graph and a Grammar</p>

<p>The call graph looks like this:</p>

<p>reg() # parse a top level regex, or inside of parens
regbranch() # parse a single branch of an alternation
regpiece() # parse a pattern followed by a quantifier
regatom() # parse a simple pattern regclass() # used to
handle a class reg() # used to handle a parenthesised
subpattern .... ... regtail() # finish off the branch ...
regtail() # finish off the branch sequence. Tie each #
branch&rsquo;s tail to the tail of the sequence # (NEW) In
Debug mode this is # regtail_study().</p>

<p>A grammar form might be something like this:</p>

<p>atom : constant | class quant : &rsquo;*&rsquo; |
&rsquo;+&rsquo; | &rsquo;?&rsquo; | &rsquo;{min,max}&rsquo;
_branch: piece | piece _branch | nothing branch: _branch |
_branch &rsquo;|&rsquo; branch group : &rsquo;(&rsquo;
branch &rsquo;)&rsquo; _piece: atom | group piece : _piece |
_piece quant</p>

<p>Debug Output</p>

<p>In the 5.9.x development version of perl you can
&quot;use re Debug =&gt; &rsquo;PARSE&rsquo;&quot; to see
some trace information about the parse process. We will
start with some simple patterns and build up to more complex
patterns.</p>

<p>So when we parse &quot;/foo/&quot; we see something like
the following table. The left shows what is being parsed,
and the number indicates where the next regop would go. The
stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the
screen. tsdy is a special form of &quot;regtail()&quot;
which does some extra analysis.</p>

<p>&gt;foo&lt; 1 reg brnc piec atom &gt;&lt; 4 tsdy~ EXACT
&lt;foo&gt; (EXACT) (1) ~ attach to END (3) offset to 2</p>

<p>The resulting program then looks like:</p>

<p>1: EXACT &lt;foo&gt;(3) 3: END(0)</p>

<p>As you can see, even though we parsed out a branch and a
piece, it was ultimately only an atom. The final program
shows us how things work. We have an &quot;EXACT&quot;
regop, followed by an &quot;END&quot; regop. The number in
parens indicates where the &quot;regnext&quot; of the node
goes. The &quot;regnext&quot; of an &quot;END&quot; regop is
unused, as &quot;END&quot; regops mean we have successfully
matched. The number on the left indicates the position of
the regop in the regnode array.</p>

<p>Now lets try a harder pattern. We will add a quantifier,
so now we have the pattern &quot;/foo+/&quot;. We will see
that &quot;regbranch()&quot; calls &quot;regpiece()&quot;
twice.</p>

<p>&gt;foo+&lt; 1 reg brnc piec atom &gt;o+&lt; 3 piec atom
&gt;&lt; 6 tail~ EXACT &lt;fo&gt; (1) 7 tsdy~ EXACT
&lt;fo&gt; (EXACT) (1) ~ PLUS (END) (3) ~ attach to END (6)
offset to 3</p>

<p>And we end up with the program:</p>

<p>1: EXACT &lt;fo&gt;(3) 3: PLUS(6) 4: EXACT &lt;o&gt;(0)
6: END(0)</p>

<p>Now we have a special case. The &quot;EXACT&quot; regop
has a &quot;regnext&quot; of 0. This is because if it
matches it should try to match itself again. The
&quot;PLUS&quot; regop handles the actual failure of the
&quot;EXACT&quot; regop and acts appropriately (going to
regnode 6 if the &quot;EXACT&quot; matched at least once, or
failing if it didnt).</p>

<p>Now for something much more complex:
&quot;/x(?:foo*|b[a][rR])(foo|bar)$/&quot;</p>

<p>&gt;x(?:foo*|b... 1 reg brnc piec atom &gt;(?:foo*|b[...
3 piec atom &gt;?:foo*|b[a... reg &gt;foo*|b[a][... brnc
piec atom &gt;o*|b[a][rR... 5 piec atom &gt;|b[a][rR])... 8
tail~ EXACT &lt;fo&gt; (3) &gt;b[a][rR])(... 9 brnc 10 piec
atom &gt;[a][rR])(f... 12 piec atom &gt;a][rR])(fo... clas
&gt;[rR])(foo|... 14 tail~ EXACT &lt;b&gt; (10) piec atom
&gt;rR])(foo|b... clas &gt;)(foo|bar)... 25 tail~ EXACT
&lt;a&gt; (12) tail~ BRANCH (3) 26 tsdy~ BRANCH (END) (9) ~
attach to TAIL (25) offset to 16 tsdy~ EXACT &lt;fo&gt;
(EXACT) (4) ~ STAR (END) (6) ~ attach to TAIL (25) offset to
19 tsdy~ EXACT &lt;b&gt; (EXACT) (10) ~ EXACT &lt;a&gt;
(EXACT) (12) ~ ANYOF[Rr] (END) (14) ~ attach to TAIL (25)
offset to 11 &gt;(foo|bar)$&lt; tail~ EXACT &lt;x&gt; (1)
piec atom &gt;foo|bar)$&lt; reg 28 brnc piec atom
&gt;|bar)$&lt; 31 tail~ OPEN1 (26) &gt;bar)$&lt; brnc 32
piec atom &gt;)$&lt; 34 tail~ BRANCH (28) 36 tsdy~ BRANCH
(END) (31) ~ attach to CLOSE1 (34) offset to 3 tsdy~ EXACT
&lt;foo&gt; (EXACT) (29) ~ attach to CLOSE1 (34) offset to 5
tsdy~ EXACT &lt;bar&gt; (EXACT) (32) ~ attach to CLOSE1 (34)
offset to 2 &gt;$&lt; tail~ BRANCH (3) ~ BRANCH (9) ~ TAIL
(25) piec atom &gt;&lt; 37 tail~ OPEN1 (26) ~ BRANCH (28) ~
BRANCH (31) ~ CLOSE1 (34) 38 tsdy~ EXACT &lt;x&gt; (EXACT)
(1) ~ BRANCH (END) (3) ~ BRANCH (END) (9) ~ TAIL (END) (25)
~ OPEN1 (END) (26) ~ BRANCH (END) (28) ~ BRANCH (END) (31) ~
CLOSE1 (END) (34) ~ EOL (END) (36) ~ attach to END (37)
offset to 1</p>

<p>Resulting in the program</p>

<p>1: EXACT &lt;x&gt;(3) 3: BRANCH(9) 4: EXACT
&lt;fo&gt;(6) 6: STAR(26) 7: EXACT &lt;o&gt;(0) 9:
BRANCH(25) 10: EXACT &lt;ba&gt;(14) 12: OPTIMIZED (2 nodes)
14: ANYOF[Rr](26) 25: TAIL(26) 26: OPEN1(28) 28:
TRIE-EXACT(34) [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3
Stcls:bf] &lt;foo&gt; &lt;bar&gt; 30: OPTIMIZED (4 nodes)
34: CLOSE1(36) 36: EOL(37) 37: END(0)</p>

<p>Here we can see a much more complex program, with
various optimisations in play. At regnode 10 we see an
example where a character class with only one character in
it was turned into an &quot;EXACT&quot; node. We can also
see where an entire alternation was turned into a
&quot;TRIE-EXACT&quot; node. As a consequence, some of the
regnodes have been marked as optimised away. We can see that
the &quot;$&quot; symbol has been converted into an
&quot;EOL&quot; regop, a special piece of code that looks
for &quot;0 or the end of the string.</p>

<p>The next pointer for &quot;BRANCH&quot;es is interesting
in that it points at where execution should go if the branch
fails. When executing, if the engine tries to traverse from
a branch to a &quot;regnext&quot; that isnt a branch then
the engine will know that the entire set of branches has
failed.</p>

<p>Peep-hole Optimisation and Analysis</p>

<p>The regular expression engine can be a weighty tool to
wield. On long strings and complex patterns it can end up
having to do a lot of work to find a match, and even more to
decide that no match is possible. Consider a situation like
the following pattern.</p>

<p>&rsquo;ababababababababababab&rsquo; =~ /(a|b)*z/</p>

<p>The &quot;(a|b)*&quot; part can match at every char in
the string, and then fail every time because there is no
&quot;z&quot; in the string. So obviously we can avoid using
the regex engine unless there is a &quot;z&quot; in the
string. Likewise in a pattern like:</p>

<p>/foo(120</p>

<p>In this case we know that the string must contain a
&quot;foo&quot; which must be followed by &quot;bar&quot;.
We can use Fast Boyer-Moore matching as implemented in
&quot;fbm_instr()&quot; to find the location of these
strings. If they dont exist then we don t need to resort to
the much more expensive regex engine. Even better, if they
do exist then we can use their positions to reduce the
search space that the regex engine needs to cover to
determine if the entire pattern matches.</p>

<p>There are various aspects of the pattern that can be
used to facilitate optimisations along these lines:</p>

<p>&middot; anchored fixed strings</p>

<p>&middot; floating fixed strings</p>

<p>&middot; minimum and maximum length requirements</p>

<p>&middot; start class</p>

<p>&middot; Beginning/End of line positions</p>

<p>Another form of optimisation that can occur is the
post-parse &quot;peep- hole&quot; optimisation, where
inefficient constructs are replaced by more efficient
constructs. The &quot;TAIL&quot; regops which are used
during parsing to mark the end of branches and the end of
groups are examples of this. These regops are used as
place-holders during construction and &quot;always
match&quot; so they can be &quot;optimised away&quot; by
making the things that point to the &quot;TAIL&quot; point
to the thing that &quot;TAIL&quot; points to, thus
&quot;skipping&quot; the node.</p>

<p>Another optimisation that can occur is that of
&quot;&quot;EXACT&quot; merging&quot; which is where two
consecutive &quot;EXACT&quot; nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form &quot;EXACT BRANCH ... EXACT&quot; can
be converted into a &quot;TRIE-EXACT&quot; regop.</p>

<p>All of this occurs in the routine
&quot;study_chunk()&quot; which uses a special structure
&quot;scan_data_t&quot; to store the analysis that it has
performed, and does the &quot;peep-hole&quot; optimisations
as it goes.</p>

<p>The code involved in &quot;study_chunk()&quot; is
extremely cryptic. Be careful. :-)</p>

<p>Execution Execution of a regex generally involves two
phases, the first being finding the start point in the
string where we should match from, and the second being
running the regop interpreter.</p>

<p>If we can tell that there is no valid start point then
we dont bother running interpreter at all. Likewise, if we
know from the analysis phase that we cannot detect a
short-cut to the start position, we go straight to the
interpreter.</p>

<p>The two entry points are &quot;re_intuit_start()&quot;
and &quot;pregexec()&quot;. These routines have a somewhat
incestuous relationship with overlap between their
functions, and &quot;pregexec()&quot; may even call
&quot;re_intuit_start()&quot; on its own. Nevertheless other
parts of the the perl source code may call into either, or
both.</p>

<p>Execution of the interpreter itself used to be
recursive, but thanks to the efforts of Dave Mitchell in the
5.9.x development track, that has changed: now an internal
stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite
conservative about what state it stores, with the result
that that two consecutive lines in the code can actually be
running in totally different contexts due to the simulated
recursion.</p>

<p>Start position and no-match optimisations</p>

<p>&quot;re_intuit_start()&quot; is responsible for
handling start points and no- match optimisations as
determined by the results of the analysis done by
&quot;study_chunk()&quot; (and described in &quot;Peep-hole
Optimisation and Analysis&quot;).</p>

<p>The basic structure of this routine is to try to find
the start- and/or end-points of where the pattern could
match, and to ensure that the string is long enough to match
the pattern. It tries to use more efficient methods over
less efficient methods and may involve considerable
cross-checking of constraints to find the place in the
string that matches. For instance it may try to determine
that a given fixed string must be not only present but a
certain number of chars before the end of the string, or
whatever.</p>

<p>It calls several other routines, such as
&quot;fbm_instr()&quot; which does Fast Boyer Moore matching
and &quot;find_byclass()&quot; which is responsible for
finding the start using the first mandatory regop in the
program.</p>

<p>When the optimisation criteria have been satisfied,
&quot;reg_try()&quot; is called to perform the match.</p>

<p>Program execution</p>

<p>&quot;pregexec()&quot; is the main entry point for
running a regex. It contains support for initialising the
regex interpreter s state, running
&quot;re_intuit_start()&quot; if needed, and running the
interpreter on the string from various start positions as
needed. When it is necessary to use the regex interpreter
&quot;pregexec()&quot; calls &quot;regtry()&quot;.</p>

<p>&quot;regtry()&quot; is the entry point into the regex
interpreter. It expects as arguments a pointer to a
&quot;regmatch_info&quot; structure and a pointer to a
string. It returns an integer 1 for success and a 0 for
failure. It is basically a set-up wrapper around
&quot;regmatch()&quot;.</p>

<p>&quot;regmatch&quot; is the main &quot;recursive
loop&quot; of the interpreter. It is basically a giant
switch statement that implements a state machine, where the
possible states are the regops themselves, plus a number of
additional intermediate and failure states. A few of the
states are implemented as subroutines but the bulk are
inline code.</p>

<p>MISCELLANEOUS Unicode and Localisation Support When
dealing with strings containing characters that cannot be
represented using an eight-bit character set, perl uses an
internal representation that is a permissive version of
Unicode s UTF-8 encoding[2]. This uses single bytes to
represent characters from the ASCII character set, and
sequences of two or more bytes for all other characters.
(See perlunitut for more information about the relationship
between UTF-8 and perls encoding, utf8 -- the difference
isnt important for this discussion.)</p>

<p>No matter how you look at it, Unicode support is going
to be a pain in a regex engine. Tricks that might be fine
when you have 256 possible characters often won t scale to
handle the size of the UTF-8 character set. Things you can
take for granted with ASCII may not be true with Unicode.
For instance, in ASCII, it is safe to assume that
&quot;sizeof(char1) == sizeof(char2)&quot;, but in UTF-8 it
isn t. Unicode case folding is vastly more complex than the
simple rules of ASCII, and even when not using Unicode but
only localised single byte encodings, things can get tricky
(for example, LATIN SMALL LETTER SHARP S (U+00DF, ss) should
match SS in localised case-insensitive matching).</p>

<p>Making things worse is that UTF-8 support was a later
addition to the regex engine (as it was to perl) and this
necessarily made things a lot more complicated. Obviously it
is easier to design a regex engine with Unicode support in
mind from the beginning than it is to retrofit it to one
that wasnt.</p>

<p>Nearly all regops that involve looking at the input
string have two cases, one for UTF-8, and one not. In fact,
its often more complex than that, as the pattern may be
UTF-8 as well.</p>

<p>Care must be taken when making changes to make sure that
you handle UTF-8 properly, both at compile time and at
execution time, including when the string and pattern are
mismatched.</p>

<p>The following comment in regcomp.h gives an example of
exactly how tricky this can be:</p>

<p>Two problematic code points in Unicode casefolding of
EXACT nodes:</p>

<p>U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND
TONOS U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND
TONOS</p>

<p>which casefold to</p>

<p>Unicode UTF-8</p>

<p>U+03B9 U+0308 U+0301 0xCE 0xB9 0xCC 0x88 0xCC 0x81
U+03C5 U+0308 U+0301 0xCF 0x85 0xCC 0x88 0xCC 0x81</p>

<p>This means that in case-insensitive matching (or
&quot;loose matching&quot;, as Unicode calls it), an EXACTF
of length six (the UTF-8 encoded byte length of the above
casefolded versions) can match a target string of length two
(the byte length of UTF-8 encoded U+0390 or U+03B0). This
would rather mess up the minimum length computation.</p>

<p>What we&rsquo;ll do is to look for the tail four bytes,
and then peek at the preceding two bytes to see whether we
need to decrease the minimum length by four (six minus
two).</p>

<p>Thanks to the design of UTF-8, there cannot be false
matches: A sequence of valid UTF-8 bytes cannot be a
subsequence of another valid sequence of UTF-8 bytes.</p>

<p>Base Structures The &quot;regexp&quot; structure
described in perlreapi is common to all regex engines. Two
of its fields that are intended for the private use of the
regex engine that compiled the pattern. These are the
&quot;intflags&quot; and pprivate members. The
&quot;pprivate&quot; is a void pointer to an arbitrary
structure whose use and management is the responsibility of
the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure
pointed to by &quot;pprivate&quot; is called
&quot;regexp_internal&quot;.</p>

<p>Its &quot;pprivate&quot; and &quot;intflags&quot; fields
contain data specific to each engine.</p>

<p>There are two structures used to store a compiled
regular expression. One, the &quot;regexp&quot; structure
described in perlreapi is populated by the engine currently
being. used and some of its fields read by perl to implement
things such as the stringification of &quot;qr//&quot;.</p>

<p>The other structure is pointed to be the
&quot;regexp&quot; struct s &quot;pprivate&quot; and is in
addition to &quot;intflags&quot; in the same struct
considered to be the property of the regex engine which
compiled the regular expression;</p>

<p>The regexp structure contains all the data that perl
needs to be aware of to properly work with the regular
expression. It includes data about optimisations that perl
can use to determine if the regex engine should really be
used, and various other control info that is needed to
properly execute patterns in various contexts such as is the
pattern anchored in some way, or what flags were used during
the compile, or whether the program contains special
constructs that perl needs to be aware of.</p>

<p>In addition it contains two fields that are intended for
the private use of the regex engine that compiled the
pattern. These are the &quot;intflags&quot; and pprivate
members. The &quot;pprivate&quot; is a void pointer to an
arbitrary structure whose use and management is the
responsibility of the compiling engine. perl will never
modify either of these values.</p>

<p>As mentioned earlier, in the case of the default
engines, the &quot;pprivate&quot; will be a pointer to a
regexp_internal structure which holds the compiled program
and any additional data that is private to the regex engine
implementation.</p>

<p>Perls &quot;pprivate&quot; structure</p>

<p>The following structure is used as the
&quot;pprivate&quot; struct by perls regex engine. Since it
is specific to perl it is only of curiosity value to other
engine implementations.</p>

<p>typedef struct regexp_internal { regexp_paren_ofs *swap;
/* Swap copy of *startp / *endp */ U32 *offsets; /* offset
annotations 20001228 MJD data about mapping the program to
the string*/ regnode *regstclass; /* Optional startclass as
identified or constructed by the optimiser */ struct
reg_data *data; /* Additional miscellaneous data used by the
program. Used to make it easier to clone and free arbitrary
data that the regops need. Often the ARG field of a regop is
an index into this structure */ regnode program[1]; /*
Unwarranted chumminess with compiler. */ }
regexp_internal;</p>

<p>&quot;swap&quot; &quot;swap&quot; formerly was an extra
set of startp/endp stored in a &quot;regexp_paren_ofs&quot;
struct. This was used when the last successful match was
from the same pattern as the current pattern, so that a
partial match didn t overwrite the previous matchs results,
but it caused a problem with re-entrant code such as trying
to build the UTF-8 swashes. Currently unused and left for
backward compatibility with 5.10.0.</p>

<p>&quot;offsets&quot; Offsets holds a mapping of offset in
the &quot;program&quot; to offset in the &quot;precomp&quot;
string. This is only used by ActiveStates visual regex
debugger.</p>

<p>&quot;regstclass&quot; Special regop that is used by
&quot;re_intuit_start()&quot; to check if a pattern can
match at a certain position. For instance if the regex
engine knows that the pattern must start with a Z then it
can scan the string until it finds one and then launch the
regex engine from there. The routine that handles this is
called &quot;find_by_class()&quot;. Sometimes this field
points at a regop embedded in the program, and sometimes it
points at an independent synthetic regop that has been
constructed by the optimiser.</p>

<p>&quot;data&quot; This field points at a reg_data
structure, which is defined as follows</p>

<p>struct reg_data { U32 count; U8 *what; void* data[1];
};</p>

<p>This structure is used for handling data structures that
the regex engine needs to handle specially during a clone or
free operation on the compiled product. Each element in the
data array has a corresponding element in the what array.
During compilation regops that need special structures
stored will add an element to each array using the
add_data() routine and then store the index in the
regop.</p>

<p>&quot;program&quot; Compiled program. Inlined into the
structure so the entire struct can be treated as a single
blob.</p>

<p>SEE ALSO perlreapi</p>

<p>perlre</p>

<p>perlunitut</p>

<p>AUTHOR by Yves Orton, 2006.</p>

<p>With excerpts from Perl, and contributions and
suggestions from Ronald J. Kimball, Dave Mitchell, Dominic
Dunlop, Mark Jason Dominus, Stephen McCamant, and David
Landgren.</p>

<p>LICENCE Same terms as Perl.</p>

<p>REFERENCES [1]
&lt;http://perl.plover.com/Rx/paper/&gt;</p>

<p>[2] &lt;http://www.unicode.org&gt;</p>

<p>perl v5.10.1 2015-03-13 PERLREGUTS(1)</p>
<hr>
</body>
</html>
