<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:37:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT IRQ_DESC(9) Structures STRUCT IRQ_DESC(9)</p>

<p>NAME struct_irq_desc - interrupt descriptor</p>

<p>SYNOPSIS struct irq_desc { unsigned int irq; struct
timer_rand_state * timer_rand_state; unsigned int *
kstat_irqs; #ifdef CONFIG_INTR_REMAP struct irq_2_iommu *
irq_2_iommu; #endif irq_flow_handler_t handle_irq; struct
irq_chip * chip; struct msi_desc * msi_desc; void *
handler_data; void * chip_data; struct irqaction * action;
unsigned int status; unsigned int depth; unsigned int
wake_depth; unsigned int irq_count; unsigned long
last_unhandled; unsigned int irqs_unhandled; spinlock_t
lock; #ifdef CONFIG_SMP cpumask_var_t affinity; struct
irq_affinity_notify * affinity_notify; unsigned int node;
#ifdef CONFIG_GENERIC_PENDING_IRQ cpumask_var_t
pending_mask; #endif #endif atomic_t threads_active;
wait_queue_head_t wait_for_threads; #ifdef CONFIG_PROC_FS
struct proc_dir_entry * dir; #endif const char * name;
};</p>

<p>MEMBERS irq interrupt number for this descriptor</p>

<p>timer_rand_state pointer to timer rand state struct</p>

<p>kstat_irqs irq stats per cpu</p>

<p>irq_2_iommu iommu with this irq</p>

<p>handle_irq highlevel irq-events handler [if NULL,
__do_IRQ]</p>

<p>chip low level interrupt hardware access</p>

<p>msi_desc MSI descriptor</p>

<p>handler_data per-IRQ data for the irq_chip methods</p>

<p>chip_data platform-specific per-chip private data for
the chip methods, to allow shared chip implementations</p>

<p>action the irq action chain</p>

<p>status status information</p>

<p>depth disable-depth, for nested irq_disable calls</p>

<p>wake_depth enable depth, for multiple set_irq_wake
callers</p>

<p>irq_count stats field to detect stalled irqs</p>

<p>last_unhandled aging timer for unhandled count</p>

<p>irqs_unhandled stats field for spurious unhandled
interrupts</p>

<p>lock locking for SMP</p>

<p>affinity IRQ affinity on SMP</p>

<p>affinity_notify context for notification of affinity
changes</p>

<p>node node index useful for balancing</p>

<p>pending_mask pending rebalanced interrupts</p>

<p>threads_active number of irqaction threads currently
running</p>

<p>wait_for_threads wait queue for sync_irq to wait for
threaded handlers</p>

<p>dir /proc/irq/ procfs entry</p>

<p>name flow handler name for /proc/interrupts output</p>

<p>AUTHORS Thomas Gleixner &lt;tglx@linutronix.de&gt;
Author.</p>

<p>Ingo Molnar &lt;mingo@elte.hu&gt; Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015 STRUCT
IRQ_DESC(9)</p>
<hr>
</body>
</html>
