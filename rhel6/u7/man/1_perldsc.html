<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:08 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLDSC(1) Perl Programmers Reference Guide
PERLDSC(1)</p>

<p>NAME perldsc - Perl Data Structures Cookbook</p>

<p>DESCRIPTION The single feature most sorely lacking in
the Perl programming language prior to its 5.0 release was
complex data structures. Even without direct language
support, some valiant programmers did manage to emulate
them, but it was hard work and not for the faint of heart.
You could occasionally get away with the $m{$AoA,$b}
notation borrowed from awk in which the keys are actually
more like a single concatenated string &quot;$AoA$b&quot;,
but traversal and sorting were difficult. More desperate
programmers even hacked Perl s internal symbol table
directly, a strategy that proved hard to develop and
maintain--to put it mildly.</p>

<p>The 5.0 release of Perl let us have complex data
structures. You may now write something like this and all of
a sudden, you d have an array with three dimensions!</p>

<p>for $x (1 .. 10) { for $y (1 .. 10) { for $z (1 .. 10) {
$AoA[$x][$y][$z] = $x ** $y + $z; } } }</p>

<p>Alas, however simple this may appear, underneath its a
much more elaborate construct than meets the eye!</p>

<p>How do you print it out? Why cant you say just
&quot;print @AoA&quot;? How do you sort it? How can you pass
it to a function or get one of these back from a function?
Is it an object? Can you save it to disk to read back later?
How do you access whole rows or columns of that matrix? Do
all the values have to be numeric?</p>

<p>As you see, its quite easy to become confused. While
some small portion of the blame for this can be attributed
to the reference-based implementation, its really more due
to a lack of existing documentation with examples designed
for the beginner.</p>

<p>This document is meant to be a detailed but
understandable treatment of the many different sorts of data
structures you might want to develop. It should also serve
as a cookbook of examples. That way, when you need to create
one of these complex data structures, you can just pinch,
pilfer, or purloin a drop-in example from here.</p>

<p>Lets look at each of these possible constructs in
detail. There are separate sections on each of the
following:</p>

<p>&middot; arrays of arrays</p>

<p>&middot; hashes of arrays</p>

<p>&middot; arrays of hashes</p>

<p>&middot; hashes of hashes</p>

<p>&middot; more elaborate constructs</p>

<p>But for now, let s look at general issues common to all
these types of data structures.</p>

<p>REFERENCES The most important thing to understand about
all data structures in Perl--including multidimensional
arrays--is that even though they might appear otherwise,
Perl @ARRAYs and %HASHes are all internally one-
dimensional. They can hold only scalar values (meaning a
string, number, or a reference). They cannot directly
contain other arrays or hashes, but instead contain
references to other arrays or hashes.</p>

<p>You cant use a reference to an array or hash in quite
the same way that you would a real array or hash. For C or
C++ programmers unused to distinguishing between arrays and
pointers to the same, this can be confusing. If so, just
think of it as the difference between a structure and a
pointer to a structure.</p>

<p>You can (and should) read more about references in the
perlref(1) man page. Briefly, references are rather like
pointers that know what they point to. (Objects are also a
kind of reference, but we wont be needing them right
away--if ever.) This means that when you have something
which looks to you like an access to a two-or-more-
dimensional array and/or hash, whats really going on is that
the base type is merely a one-dimensional entity that
contains references to the next level. It s just that you
can use it as though it were a two- dimensional one. This is
actually the way almost all C multidimensional arrays work
as well.</p>

<p>$array[7][12] # array of arrays $array[7]{string} #
array of hashes $hash{string}[7] # hash of arrays
$hash{string}{&rsquo;another string&rsquo;} # hash of
hashes</p>

<p>Now, because the top level contains only references, if
you try to print out your array in with a simple print()
function, youll get something that doesnt look very nice,
like this:</p>

<p>@AoA = ( [2, 3], [4, 5, 7], [0] ); print $AoA[1][2]; 7
print @AoA; ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)</p>

<p>Thats because Perl doesnt (ever) implicitly dereference
your variables. If you want to get at the thing a reference
is referring to, then you have to do this yourself using
either prefix typing indicators, like &quot;${$blah}&quot;,
&quot;@{$blah}&quot;, &quot;@{$blah[$i]}&quot;, or else
postfix pointer arrows, like &quot;$a-&gt;[3]&quot;,
&quot;$h-&gt;{fred}&quot;, or even
&quot;$ob-&gt;method()-&gt;[3]&quot;.</p>

<p>COMMON MISTAKES The two most common mistakes made in
constructing something like an array of arrays is either
accidentally counting the number of elements or else taking
a reference to the same memory location repeatedly. Heres
the case where you just get the count instead of a nested
array:</p>

<p>for $i (1..10) { @array = somefunc($i); $AoA[$i] =
@array; # WRONG! }</p>

<p>That s just the simple case of assigning an array to a
scalar and getting its element count. If thats what you
really and truly want, then you might do well to consider
being a tad more explicit about it, like this:</p>

<p>for $i (1..10) { @array = somefunc($i); $counts[$i] =
scalar @array; }</p>

<p>Heres the case of taking a reference to the same memory
location again and again:</p>

<p>for $i (1..10) { @array = somefunc($i); $AoA[$i] =
@array; # WRONG! }</p>

<p>So, what s the big problem with that? It looks right,
doesnt it? After all, I just told you that you need an array
of references, so by golly, youve made me one!</p>

<p>Unfortunately, while this is true, its still broken. All
the references in @AoA refer to the very same place, and
they will therefore all hold whatever was last in @array!
Its similar to the problem demonstrated in the following C
program:</p>

<p>#include &lt;pwd.h&gt; main() { struct passwd
*getpwnam(), *rp, *dp; rp = getpwnam(&quot;root&quot;); dp =
getpwnam(&quot;daemon&quot;);</p>

<p>printf(&quot;daemon name is %s0oot name is %s0,
dp-&gt;pw_name, rp-&gt;pw_name); }</p>

<p>Which will print</p>

<p>daemon name is daemon root name is daemon</p>

<p>The problem is that both &quot;rp&quot; and
&quot;dp&quot; are pointers to the same location in memory!
In C, you d have to remember to malloc() yourself some new
memory. In Perl, youll want to use the array constructor
&quot;[]&quot; or the hash constructor &quot;{}&quot;
instead. Heres the right way to do the preceding broken code
fragments:</p>

<p>for $i (1..10) { @array = somefunc($i); $AoA[$i] = [
@array ]; }</p>

<p>The square brackets make a reference to a new array with
a copy of what s in @array at the time of the assignment.
This is what you want.</p>

<p>Note that this will produce something similar, but it s
much harder to read:</p>

<p>for $i (1..10) { @array = 0 .. $i; @{$AoA[$i]} = @array;
}</p>

<p>Is it the same? Well, maybe so--and maybe not. The
subtle difference is that when you assign something in
square brackets, you know for sure it s always a brand new
reference with a new copy of the data. Something else could
be going on in this new case with the
&quot;@{$AoA[$i]}&quot; dereference on the left-hand-side of
the assignment. It all depends on whether $AoA[$i] had been
undefined to start with, or whether it already contained a
reference. If you had already populated @AoA with
references, as in</p>

<p>$AoA[3] = @another_array;</p>

<p>Then the assignment with the indirection on the
left-hand-side would use the existing reference that was
already there:</p>

<p>@{$AoA[3]} = @array;</p>

<p>Of course, this would have the &quot;interesting&quot;
effect of clobbering @another_array. (Have you ever noticed
how when a programmer says something is
&quot;interesting&quot;, that rather than meaning
&quot;intriguing&quot;, theyre disturbingly more apt to mean
that its &quot;annoying&quot;, &quot;difficult&quot;, or
both? :-)</p>

<p>So just remember always to use the array or hash
constructors with &quot;[]&quot; or &quot;{}&quot;, and you
ll be fine, although its not always optimally efficient.</p>

<p>Surprisingly, the following dangerous-looking construct
will actually work out fine:</p>

<p>for $i (1..10) { my @array = somefunc($i); $AoA[$i] =
@array; }</p>

<p>Thats because my() is more of a run-time statement than
it is a compile-time declaration per se. This means that the
my() variable is remade afresh each time through the loop.
So even though it looks as though you stored the same
variable reference each time, you actually did not! This is
a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of
programmers. So I usually advise against teaching it to
beginners. In fact, except for passing arguments to
functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code. Instead, I
advise beginners that they (and most of the rest of us)
should try to use the much more easily understood
constructors &quot;[]&quot; and &quot;{}&quot; instead of
relying upon lexical (or dynamic) scoping and hidden
reference-counting to do the right thing behind the
scenes.</p>

<p>In summary:</p>

<p>$AoA[$i] = [ @array ]; # usually best $AoA[$i] = @array;
# perilous; just how my() was that array? @{ $AoA[$i] } =
@array; # way too tricky for most programmers</p>

<p>CAVEAT ON PRECEDENCE Speaking of things like
&quot;@{$AoA[$i]}&quot;, the following are actually the same
thing:</p>

<p>$aref-&gt;[2][2] # clear $$aref[2][2] # confusing</p>

<p>That s because Perls precedence rules on its five prefix
dereferencers (which look like someone swearing: &quot;$ @ *
% &amp;&quot;) make them bind more tightly than the postfix
subscripting brackets or braces! This will no doubt come as
a great shock to the C or C++ programmer, who is quite
accustomed to using *a[i] to mean whats pointed to by the
ith element of &quot;a&quot;. That is, they first take the
subscript, and only then dereference the thing at that
subscript. Thats fine in C, but this isnt C.</p>

<p>The seemingly equivalent construct in Perl, $$aref[$i]
first does the deref of $aref, making it take $aref as a
reference to an array, and then dereference that, and
finally tell you the ith value of the array pointed to by
$AoA. If you wanted the C notion, youd have to write
&quot;${$AoA[$i]}&quot; to force the $AoA[$i] to get
evaluated first before the leading &quot;$&quot;
dereferencer.</p>

<p>WHY YOU SHOULD ALWAYS &quot;use strict&quot; If this is
starting to sound scarier than its worth, relax. Perl has
some features to help you avoid its most common pitfalls.
The best way to avoid getting confused is to start every
program like this:</p>

<p>#!/usr/bin/perl -w use strict;</p>

<p>This way, youll be forced to declare all your variables
with my() and also disallow accidental &quot;symbolic
dereferencing&quot;. Therefore if youd done this:</p>

<p>my $aref = [ [ &quot;fred&quot;, &quot;barney&quot;,
&quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;,
], [ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;,
&quot;maggie&quot;, ], [ &quot;george&quot;,
&quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],
];</p>

<p>print $aref[2][2];</p>

<p>The compiler would immediately flag that as an error at
compile time, because you were accidentally accessing @aref,
an undeclared variable, and it would thereby remind you to
write instead:</p>

<p>print $aref-&gt;[2][2]</p>

<p>DEBUGGING Before version 5.002, the standard Perl
debugger didnt do a very nice job of printing out complex
data structures. With 5.002 or above, the debugger includes
several new features, including command line editing as well
as the &quot;x&quot; command to dump out complex data
structures. For example, given the assignment to $AoA above,
heres the debugger output:</p>

<p>DB&lt;1&gt; x $AoA $AoA = ARRAY(0x13b5a0) 0
ARRAY(0x1f0a24) 0 &rsquo;fred&rsquo; 1 &rsquo;barney&rsquo;
2 &rsquo;pebbles&rsquo; 3 &rsquo;bambam&rsquo; 4
&rsquo;dino&rsquo; 1 ARRAY(0x13b558) 0 &rsquo;homer&rsquo; 1
&rsquo;bart&rsquo; 2 &rsquo;marge&rsquo; 3
&rsquo;maggie&rsquo; 2 ARRAY(0x13b540) 0
&rsquo;george&rsquo; 1 &rsquo;jane&rsquo; 2
&rsquo;elroy&rsquo; 3 &rsquo;judy&rsquo;</p>

<p>CODE EXAMPLES Presented with little comment (these will
get their own manpages someday) here are short code examples
illustrating access of various types of data structures.</p>

<p>ARRAYS OF ARRAYS Declaration of an ARRAY OF ARRAYS @AoA
= ( [ &quot;fred&quot;, &quot;barney&quot; ], [
&quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ], [
&quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],
);</p>

<p>Generation of an ARRAY OF ARRAYS # reading from file
while ( &lt;&gt; ) { push @AoA, [ split ]; }</p>

<p># calling a function for $i ( 1 .. 10 ) { $AoA[$i] = [
somefunc($i) ]; }</p>

<p># using temp vars for $i ( 1 .. 10 ) { @tmp =
somefunc($i); $AoA[$i] = [ @tmp ]; }</p>

<p># add to an existing row push @{ $AoA[0] },
&quot;wilma&quot;, &quot;betty&quot;;</p>

<p>Access and Printing of an ARRAY OF ARRAYS # one element
$AoA[0][0] = &quot;Fred&quot;;</p>

<p># another element $AoA[1][1] =~ s/(120</p>

<p># print the whole thing with refs for $aref ( @AoA ) {
print &quot; [ @$aref ],0; }</p>

<p># print the whole thing with indices for $i ( 0 .. $#AoA
) { print &quot; [ @{$AoA[$i]} ],0; }</p>

<p># print the whole thing one at a time for $i ( 0 ..
$#AoA ) { for $j ( 0 .. $#{ $AoA[$i] } ) { print &quot;elt
$i $j is $AoA[$i][$j]0; } }</p>

<p>HASHES OF ARRAYS Declaration of a HASH OF ARRAYS %HoA =
( flintstones =&gt; [ &quot;fred&quot;, &quot;barney&quot;
], jetsons =&gt; [ &quot;george&quot;, &quot;jane&quot;,
&quot;elroy&quot; ], simpsons =&gt; [ &quot;homer&quot;,
&quot;marge&quot;, &quot;bart&quot; ], );</p>

<p>Generation of a HASH OF ARRAYS # reading from file #
flintstones: fred barney wilma dino while ( &lt;&gt; ) {
next unless s/^(.*?)://; $HoA{$1} = [ split ]; }</p>

<p># reading from file; more temps # flintstones: fred
barney wilma dino while ( $line = &lt;&gt; ) { ($who, $rest)
= split /:/, $line, 2; @fields = split &rsquo; &rsquo;,
$rest; $HoA{$who} = [ @fields ]; }</p>

<p># calling a function that returns a list for $group (
&quot;simpsons&quot;, &quot;jetsons&quot;,
&quot;flintstones&quot; ) { $HoA{$group} = [
get_family($group) ]; }</p>

<p># likewise, but using temps for $group (
&quot;simpsons&quot;, &quot;jetsons&quot;,
&quot;flintstones&quot; ) { @members = get_family($group);
$HoA{$group} = [ @members ]; }</p>

<p># append new members to an existing family push @{
$HoA{&quot;flintstones&quot;} }, &quot;wilma&quot;,
&quot;betty&quot;;</p>

<p>Access and Printing of a HASH OF ARRAYS # one element
$HoA{flintstones}[0] = &quot;Fred&quot;;</p>

<p># another element $HoA{simpsons}[1] =~ s/(120</p>

<p># print the whole thing foreach $family ( keys %HoA ) {
print &quot;$family: @{ $HoA{$family} }0 }</p>

<p># print the whole thing with indices foreach $family (
keys %HoA ) { print &quot;family: &quot;; foreach $i ( 0 ..
$#{ $HoA{$family} } ) { print &quot; $i =
$HoA{$family}[$i]&quot;; } print &quot;0; }</p>

<p># print the whole thing sorted by number of members
foreach $family ( sort { @{$HoA{$b}} &lt;=&gt; @{$HoA{$a}} }
keys %HoA ) { print &quot;$family: @{ $HoA{$family} }0 }</p>

<p># print the whole thing sorted by number of members and
name foreach $family ( sort { @{$HoA{$b}} &lt;=&gt;
@{$HoA{$a}} || $a cmp $b } keys %HoA ) { print
&quot;$family: &quot;, join(&quot;, &quot;, sort @{
$HoA{$family} }), &quot;0; }</p>

<p>ARRAYS OF HASHES Declaration of an ARRAY OF HASHES @AoH
= ( { Lead =&gt; &quot;fred&quot;, Friend =&gt;
&quot;barney&quot;, }, { Lead =&gt; &quot;george&quot;, Wife
=&gt; &quot;jane&quot;, Son =&gt; &quot;elroy&quot;, }, {
Lead =&gt; &quot;homer&quot;, Wife =&gt; &quot;marge&quot;,
Son =&gt; &quot;bart&quot;, } );</p>

<p>Generation of an ARRAY OF HASHES # reading from file #
format: LEAD=fred FRIEND=barney while ( &lt;&gt; ) { $rec =
{}; for $field ( split ) { ($key, $value) = split /=/,
$field; $rec-&gt;{$key} = $value; } push @AoH, $rec; }</p>

<p># reading from file # format: LEAD=fred FRIEND=barney #
no temp while ( &lt;&gt; ) { push @AoH, { split /[]/ };
}</p>

<p># calling a function that returns a key/value pair list,
like #
&quot;lead&quot;,&quot;fred&quot;,&quot;daughter&quot;,&quot;pebbles&quot;
while ( %fields = getnextpairset() ) { push @AoH, { %fields
}; }</p>

<p># likewise, but using no temp vars while (&lt;&gt;) {
push @AoH, { parsepairs($_) }; }</p>

<p># add key/value to an element $AoH[0]{pet} =
&quot;dino&quot;; $AoH[2]{pet} = &quot;santa&rsquo;s little
helper&quot;;</p>

<p>Access and Printing of an ARRAY OF HASHES # one element
$AoH[0]{lead} = &quot;fred&quot;;</p>

<p># another element $AoH[1]{lead} =~ s/(120</p>

<p># print the whole thing with refs for $href ( @AoH ) {
print &quot;{ &quot;; for $role ( keys %$href ) { print
&quot;$role=$href-&gt;{$role} &quot;; } print &quot;}0;
}</p>

<p># print the whole thing with indices for $i ( 0 .. $#AoH
) { print &quot;$i is { &quot;; for $role ( keys %{ $AoH[$i]
} ) { print &quot;$role=$AoH[$i]{$role} &quot;; } print
&quot;}0; }</p>

<p># print the whole thing one at a time for $i ( 0 ..
$#AoH ) { for $role ( keys %{ $AoH[$i] } ) { print &quot;elt
$i $role is $AoH[$i]{$role}0; } }</p>

<p>HASHES OF HASHES Declaration of a HASH OF HASHES %HoH =
( flintstones =&gt; { lead =&gt; &quot;fred&quot;, pal =&gt;
&quot;barney&quot;, }, jetsons =&gt; { lead =&gt;
&quot;george&quot;, wife =&gt; &quot;jane&quot;, &quot;his
boy&quot; =&gt; &quot;elroy&quot;, }, simpsons =&gt; { lead
=&gt; &quot;homer&quot;, wife =&gt; &quot;marge&quot;, kid
=&gt; &quot;bart&quot;, }, );</p>

<p>Generation of a HASH OF HASHES # reading from file #
flintstones: lead=fred pal=barney wife=wilma pet=dino while
( &lt;&gt; ) { next unless s/^(.*?)://; $who = $1; for
$field ( split ) { ($key, $value) = split /=/, $field;
$HoH{$who}{$key} = $value; }</p>

<p># reading from file; more temps while ( &lt;&gt; ) {
next unless s/^(.*?)://; $who = $1; $rec = {}; $HoH{$who} =
$rec; for $field ( split ) { ($key, $value) = split /=/,
$field; $rec-&gt;{$key} = $value; } }</p>

<p># calling a function that returns a key,value hash for
$group ( &quot;simpsons&quot;, &quot;jetsons&quot;,
&quot;flintstones&quot; ) { $HoH{$group} = {
get_family($group) }; }</p>

<p># likewise, but using temps for $group (
&quot;simpsons&quot;, &quot;jetsons&quot;,
&quot;flintstones&quot; ) { %members = get_family($group);
$HoH{$group} = { %members }; }</p>

<p># append new members to an existing family %new_folks =
( wife =&gt; &quot;wilma&quot;, pet =&gt; &quot;dino&quot;,
);</p>

<p>for $what (keys %new_folks) { $HoH{flintstones}{$what} =
$new_folks{$what}; }</p>

<p>Access and Printing of a HASH OF HASHES # one element
$HoH{flintstones}{wife} = &quot;wilma&quot;;</p>

<p># another element $HoH{simpsons}{lead} =~ s/(120</p>

<p># print the whole thing foreach $family ( keys %HoH ) {
print &quot;$family: { &quot;; for $role ( keys %{
$HoH{$family} } ) { print &quot;$role=$HoH{$family}{$role}
&quot;; } print &quot;}0; }</p>

<p># print the whole thing somewhat sorted foreach $family
( sort keys %HoH ) { print &quot;$family: { &quot;; for
$role ( sort keys %{ $HoH{$family} } ) { print
&quot;$role=$HoH{$family}{$role} &quot;; } print &quot;}0;
}</p>

<p># print the whole thing sorted by number of members
foreach $family ( sort { keys %{$HoH{$b}} &lt;=&gt; keys
%{$HoH{$a}} } keys %HoH ) { print &quot;$family: { &quot;;
for $role ( sort keys %{ $HoH{$family} } ) { print
&quot;$role=$HoH{$family}{$role} &quot;; } print &quot;}0;
}</p>

<p># establish a sort order (rank) for each role $i = 0;
for ( qw(lead wife son daughter pal pet) ) { $rank{$_} =
++$i }</p>

<p># now print the whole thing sorted by number of members
foreach $family ( sort { keys %{ $HoH{$b} } &lt;=&gt; keys
%{ $HoH{$a} } } keys %HoH ) { print &quot;$family: { &quot;;
# and print these according to rank order for $role ( sort {
$rank{$a} &lt;=&gt; $rank{$b} } keys %{ $HoH{$family} } ) {
print &quot;$role=$HoH{$family}{$role} &quot;; } print
&quot;}0; }</p>

<p>MORE ELABORATE RECORDS Declaration of MORE ELABORATE
RECORDS Heres a sample showing how to create and use a
record whose fields are of many different sorts:</p>

<p>$rec = { TEXT =&gt; $string, SEQUENCE =&gt; [
@old_values ], LOOKUP =&gt; { %some_table }, THATCODE =&gt;
some_function, THISCODE =&gt; sub { $_[0] ** $_[1] }, HANDLE
=&gt; TDOUT, };</p>

<p>print $rec-&gt;{TEXT};</p>

<p>print $rec-&gt;{SEQUENCE}[0]; $last = pop @ {
$rec-&gt;{SEQUENCE} };</p>

<p>print $rec-&gt;{LOOKUP}{&quot;key&quot;}; ($first_k,
$first_v) = each %{ $rec-&gt;{LOOKUP} };</p>

<p>$answer = $rec-&gt;{THATCODE}-&gt;($arg); $answer =
$rec-&gt;{THISCODE}-&gt;($arg1, $arg2);</p>

<p># careful of extra block braces on fh ref print {
$rec-&gt;{HANDLE} } &quot;a string0;</p>

<p>use FileHandle; $rec-&gt;{HANDLE}-&gt;autoflush(1);
$rec-&gt;{HANDLE}-&gt;print(&quot; a string0);</p>

<p>Declaration of a HASH OF COMPLEX RECORDS %TV = (
flintstones =&gt; { series =&gt; &quot;flintstones&quot;,
nights =&gt; [ qw(monday thursday friday) ], members =&gt; [
{ name =&gt; &quot;fred&quot;, role =&gt; &quot;lead&quot;,
age =&gt; 36, }, { name =&gt; &quot;wilma&quot;, role =&gt;
&quot;wife&quot;, age =&gt; 31, }, { name =&gt;
&quot;pebbles&quot;, role =&gt; &quot;kid&quot;, age =&gt;
4, }, ], },</p>

<p>jetsons =&gt; { series =&gt; &quot;jetsons&quot;, nights
=&gt; [ qw(wednesday saturday) ], members =&gt; [ { name
=&gt; &quot;george&quot;, role =&gt; &quot;lead&quot;, age
=&gt; 41, }, { name =&gt; &quot;jane&quot;, role =&gt;
&quot;wife&quot;, age =&gt; 39, }, { name =&gt;
&quot;elroy&quot;, role =&gt; &quot;kid&quot;, age =&gt; 9,
}, ], },</p>

<p>simpsons =&gt; { series =&gt; &quot;simpsons&quot;,
nights =&gt; [ qw(monday) ], members =&gt; [ { name =&gt;
&quot;homer&quot;, role =&gt; &quot;lead&quot;, age =&gt;
34, }, { name =&gt; &quot;marge&quot;, role =&gt;
&quot;wife&quot;, age =&gt; 37, }, { name =&gt;
&quot;bart&quot;, role =&gt; &quot;kid&quot;, age =&gt; 11,
}, ], }, );</p>

<p>Generation of a HASH OF COMPLEX RECORDS # reading from
file # this is most easily done by having the file itself be
# in the raw data format as shown above. perl is happy # to
parse complex data structures if declared as data, so #
sometimes it&rsquo;s easiest to do that</p>

<p># here&rsquo;s a piece by piece build up $rec = {};
$rec-&gt;{series} = &quot;flintstones&quot;;
$rec-&gt;{nights} = [ find_days() ];</p>

<p>@members = (); # assume this file in field=value syntax
while (&lt;&gt;) { %fields = split /[]+/; push @members, {
%fields }; } $rec-&gt;{members} = [ @members ];</p>

<p># now remember the whole thing $TV{ $rec-&gt;{series} }
= $rec;</p>


<p>###########################################################
# now, you might want to make interesting extra fields that
# include pointers back into the same data structure so if #
change one piece, it changes everywhere, like for example #
if you wanted a {kids} field that was a reference # to an
array of the kids&rsquo; records without having duplicate #
records and thus update problems.
###########################################################
foreach $family (keys %TV) { $rec = $TV{$family}; # temp
pointer @kids = (); for $person ( @{ $rec-&gt;{members} } )
{ if ($person-&gt;{role} =~ /kid|son|daughter/) { push
@kids, $person; } } # REMEMBER: $rec and $TV{$family} point
to same data!! $rec-&gt;{kids} = [ @kids ]; }</p>

<p># you copied the array, but the array itself contains
pointers # to uncopied objects. this means that if you make
bart get # older via</p>

<p>$TV{simpsons}{kids}[0]{age}++;</p>

<p># then this would also change in print
$TV{simpsons}{members}[2]{age};</p>

<p># because $TV{simpsons}{kids}[0] and
$TV{simpsons}{members}[2] # both point to the same
underlying anonymous hash table</p>

<p># print the whole thing foreach $family ( keys %TV ) {
print &quot;the $family&quot;; print &quot; is on during @{
$TV{$family}{nights} }0; print &quot;its members are:0; for
$who ( @{ $TV{$family}{members} } ) { print &quot;
$who-&gt;{name} ($who-&gt;{role}), age $who-&gt;{age}0; }
print &quot;it turns out that $TV{$family}{lead} has &quot;;
print scalar ( @{ $TV{$family}{kids} } ), &quot; kids named
&quot;; print join (&quot;, &quot;, map { $_-&gt;{name} } @{
$TV{$family}{kids} } ); print &quot;0; }</p>

<p>Database Ties You cannot easily tie a multilevel data
structure (such as a hash of hashes) to a dbm file. The
first problem is that all but GDBM and Berkeley DB have size
limitations, but beyond that, you also have problems with
how references are to be represented on disk. One
experimental module that does partially attempt to address
this need is the MLDBM module. Check your nearest CPAN site
as described in perlmodlib for source code to MLDBM.</p>

<p>SEE ALSO perlref(1), perllol(1), perldata(1),
perlobj(1)</p>

<p>AUTHOR Tom Christiansen &lt;tchrist@perl.com&gt;</p>

<p>Last update: Wed Oct 23 04:57:50 MET DST 1996</p>

<p>perl v5.10.1 2009-04-11 PERLDSC(1)</p>
<hr>
</body>
</html>
