<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IP(8) Linux IP(8)</p>

<p>NAME ip - show / manipulate routing, devices, policy
routing and tunnels</p>

<p>SYNOPSIS ip [ OPTIONS ] OBJECT { COMMAND | help }</p>

<p>OBJECT := { link | addr | addrlabel | route | rule |
neigh | tunnel | maddr | mroute | monitor }</p>

<p>OPTIONS := { -V[ersion] | -s[tatistics] | -r[esolve] |
-f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline]
}</p>

<p>ip link set DEVICE { up | down | arp { on | off } |
promisc { on | off } | allmulticast { on | off } | dynamic {
on | off } | multicast { on | off } | txqueuelen PACKETS |
name NEWNAME | address LLADDR | broadcast LLADDR | mtu MTU |
netns PID | alias NAME | vf NUM [ mac LLADDR ] [ vlan VLANID
[ qos VLAN-QOS ] ] [ rate TXRATE ] [ spoofchk { on | off } ]
| }</p>

<p>ip link show [ DEVICE ]</p>

<p>ip addr { add | del } IFADDR dev STRING</p>

<p>ip addr { show | flush } [ dev STRING ] [ scope SCOPE-ID
] [ to PREFIX ] [ FLAG-LIST ] [ label PATTERN ]</p>

<p>IFADDR := PREFIX | ADDR peer PREFIX [ broadcast ADDR ] [
anycast ADDR ] [ label STRING ] [ scope SCOPE-ID ]</p>

<p>SCOPE-ID := [ host | link | global | NUMBER ]</p>

<p>FLAG-LIST := [ FLAG-LIST ] FLAG</p>

<p>FLAG := [ permanent | dynamic | secondary | primary |
tentative | dep- recated ]</p>

<p>ip addrlabel { add | del } prefix PREFIX [ dev DEV ] [
label NUMBER ]</p>

<p>ip addrlabel { list | flush }</p>

<p>ip route { list | flush } SELECTOR</p>

<p>ip route get ADDRESS [ from ADDRESS iif STRING ] [ oif
STRING ] [ tos TOS ]</p>

<p>ip route { add | del | change | append | replace |
monitor } ROUTE</p>

<p>SELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact
PREFIX ] [ table TABLE_ID ] [ proto RTPROTO ] [ type TYPE ]
[ scope SCOPE ]</p>

<p>ROUTE := NODE_SPEC [ INFO_SPEC ]</p>

<p>NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table
TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC
]</p>

<p>INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ] ...</p>

<p>NH := [ via ADDRESS ] [ dev STRING ] [ weight NUMBER ]
NHFLAGS</p>

<p>OPTIONS := FLAGS [ mtu NUMBER ] [ advmss NUMBER ] [ rtt
TIME ] [ rttvar TIME ] [ window NUMBER ] [ cwnd NUMBER ] [
initcwnd NUMBER ] [ ssthresh REALM ] [ realms REALM ] [
rto_min TIME ] [ initrwnd NUMBER ]</p>

<p>TYPE := [ unicast | local | broadcast | multicast |
throw | unreachable | prohibit | blackhole | nat ]</p>

<p>TABLE_ID := [ local| main | default | all | NUMBER ]</p>

<p>SCOPE := [ host | link | global | NUMBER ]</p>

<p>FLAGS := [ equalize ]</p>

<p>NHFLAGS := [ onlink | pervasive ]</p>

<p>RTPROTO := [ kernel | boot | static | NUMBER ]</p>

<p>ip rule [ list | add | del | flush ] SELECTOR ACTION</p>

<p>SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [
fwmark FWMARK[/MASK] ] [ dev STRING ] [ pref NUMBER ]</p>

<p>ACTION := [ table TABLE_ID ] [ nat ADDRESS ] [ prohibit
| reject | unreachable ] [ realms [SRCREALM/]DSTREALM ]</p>

<p>TABLE_ID := [ local | main | default | NUMBER ]</p>

<p>ip neigh { add | del | change | replace } { ADDR [
lladdr LLADDR ] [ nud { permanent | noarp | stale |
reachable } ] | proxy ADDR } [ dev DEV ]</p>

<p>ip neigh { show | flush } [ to PREFIX ] [ dev DEV ] [
nud STATE ]</p>

<p>ip tunnel { add | change | del | show | prl } [ NAME ] [
mode MODE ] [ remote ADDR ] [ local ADDR ] [ [i|o]seq ] [
[i|o]key KEY ] [ [i|o]csum ] ] [ encaplimit ELIM ] [ ttl TTL
] [ tos TOS ] [ flowlabel FLOWLABEL ] [ prl-default ADDR ] [
prl-nodefault ADDR ] [ prl-delete ADDR ] [ [no]pmtudisc ] [
dev PHYS_DEV ] [ dscp inherit ]</p>

<p>MODE := { ipip | gre | sit | isatap | ip6ip6 | ipip6 |
any }</p>

<p>ADDR := { IP_ADDRESS | any }</p>

<p>TOS := { NUMBER | inherit }</p>

<p>ELIM := { none | 0..255 }</p>

<p>TTL := { 1..255 | inherit }</p>

<p>KEY := { DOTTED_QUAD | NUMBER }</p>

<p>TIME := NUMBER[s|ms]</p>

<p>ip maddr [ add | del ] MULTIADDR dev STRING</p>

<p>ip maddr show [ dev STRING ]</p>

<p>ip mroute show [ PREFIX ] [ from PREFIX ] [ iif DEVICE
]</p>

<p>ip monitor [ all | LISTofOBJECTS ]</p>

<p>ip xfrm XFRM_OBJECT { COMMAND }</p>

<p>XFRM_OBJECT := { state | policy | monitor }</p>

<p>ip xfrm state { add | update } ID [ XFRM_OPT ] [ mode
MODE ] [ reqid REQID ] [ seq SEQ ] [ replay-window SIZE ] [
flag FLAG-LIST ] [ encap ENCAP ] [ sel SELECTOR ] [
LIMIT-LIST ]</p>

<p>ip xfrm state allocspi ID [ mode MODE ] [ reqid REQID ]
[ seq SEQ ] [ min SPI max SPI ]</p>

<p>ip xfrm state { delete | get } ID</p>

<p>ip xfrm state { deleteall | list } [ ID ] [ mode MODE ]
[ reqid REQID ] [ flag FLAG_LIST ]</p>

<p>ip xfrm state flush [ proto XFRM_PROTO ]</p>

<p>ip xfrm state count</p>

<p>ID := [ src ADDR ] [ dst ADDR ] [ proto XFRM_PROTO ] [
spi SPI ]</p>

<p>XFRM_PROTO := [ esp | ah | comp | route2 | hao ]</p>

<p>MODE := [ transport | tunnel | ro | beet ]
(default=transport)</p>

<p>FLAG-LIST := [ FLAG-LIST ] FLAG</p>

<p>FLAG := [ noecn | decap-dscp | wildrecv ]</p>

<p>ENCAP := ENCAP-TYPE SPORT DPORT OADDR</p>

<p>ENCAP-TYPE := espinudp | espinudp-nonike</p>

<p>ALGO-LIST := [ ALGO-LIST ] | [ ALGO ]</p>

<p>ALGO := ALGO_TYPE ALGO_NAME ALGO_KEY</p>

<p>ALGO_TYPE := [ enc | auth | comp ]</p>

<p>SELECTOR := src ADDR[/PLEN] dst ADDR[/PLEN] [ UPSPEC ] [
dev DEV ]</p>

<p>UPSPEC := proto PROTO [[ sport PORT ] [ dport PORT ] | [
type NUMBER ] [ code NUMBER ]]</p>

<p>LIMIT-LIST := [ LIMIT-LIST ] | [ limit LIMIT ]</p>

<p>LIMIT := [
[time-soft|time-hard|time-use-soft|time-use-hard] SECONDS ]
| [ [byte-soft|byte-hard] SIZE ] | [
[packet-soft|packet-hard] COUNT ]</p>

<p>ip xfrm policy { add | update } dir DIR SELECTOR [ index
INDEX ] [ ptype PTYPE ] [ action ACTION ] [ priority
PRIORITY ] [ LIMIT-LIST ] [ TMPL-LIST ]</p>

<p>ip xfrm policy { delete | get } dir DIR [ SELECTOR |
index INDEX ] [ ptype PTYPE ]</p>

<p>ip xfrm policy { deleteall | list } [ dir DIR ] [
SELECTOR ] [ index INDEX ] [ action ACTION ] [ priority
PRIORITY ]</p>

<p>ip xfrm policy flush [ ptype PTYPE ]</p>

<p>ip xfrm count</p>

<p>PTYPE := [ main | sub ] (default=main)</p>

<p>DIR := [ in | out | fwd ]</p>

<p>SELECTOR := src ADDR[/PLEN] dst ADDR[/PLEN] [ UPSPEC ] [
dev DEV ]</p>

<p>UPSPEC := proto PROTO [ [ sport PORT ] [ dport PORT ] |
[ type NUMBER ] [ code NUMBER ] ]</p>

<p>ACTION := [ allow | block ] (default=allow)</p>

<p>LIMIT-LIST := [ LIMIT-LIST ] | [ limit LIMIT ]</p>

<p>LIMIT := [
[time-soft|time-hard|time-use-soft|time-use-hard] SECONDS ]
| [ [byte-soft|byte-hard] SIZE ] | [packet-soft|packet-hard]
NUMBER ]</p>

<p>TMPL-LIST := [ TMPL-LIST ] | [ tmpl TMPL ]</p>

<p>TMPL := ID [ mode MODE ] [ reqid REQID ] [ level LEVEL
]</p>

<p>ID := [ src ADDR ] [ dst ADDR ] [ proto XFRM_PROTO ] [
spi SPI ]</p>

<p>XFRM_PROTO := [ esp | ah | comp | route2 | hao ]</p>

<p>MODE := [ transport | tunnel | beet ]
(default=transport)</p>

<p>LEVEL := [ required | use ] (default=required)</p>

<p>ip xfrm monitor [ all | LISTofOBJECTS ]</p>

<p>ip token { COMMAND | help }</p>

<p>ip token { set } TOKEN dev DEV</p>

<p>ip token { get } dev DEV</p>

<p>ip token { list }</p>

<p>OPTIONS -V, -Version print the version of the ip utility
and exit.</p>

<p>-s, -stats, -statistics output more information. If the
option appears twice or more, the amount of information
increases. As a rule, the information is statistics or some
time values.</p>

<p>-h, -human, -human-readable output statistics with human
readable values number followed by suffix</p>

<p>-iec print human readable rates in IEC units (ie. 1K =
1024).</p>

<p>-f, -family followed by protocol family identifier:
inet, inet6 or link ,enforce the pro- tocol family to use.
If the option is not present, the protocol family is guessed
from other arguments. If the rest of the command line does
not give enough information to guess the family, ip falls
back to the default one, usu- ally inet or any. link is a
special family identifier meaning that no net- working
protocol is involved.</p>

<p>-4 shortcut for -family inet.</p>

<p>-6 shortcut for -family inet6.</p>

<p>-0 shortcut for -family link.</p>

<p>-o, -oneline output each record on a single line,
replacing line feeds with th&acute; charac- ter. This is
convenient when you want to count records with wc(1) or to
grep(1) the output.</p>

<p>-r, -resolve use the systems name resolver to print DNS
names instead of host addresses.</p>

<p>IP - COMMAND SYNTAX OBJECT link - network device.</p>

<p>address - protocol (IP or IPv6) address on a device.</p>

<p>addrlabel - label configuration for protocol address
selection.</p>

<p>neighbour - ARP or NDISC cache entry.</p>

<p>route - routing table entry.</p>

<p>rule - rule in routing policy database.</p>

<p>maddress - multicast address.</p>

<p>mroute - multicast routing cache entry.</p>

<p>tunnel - tunnel over IP.</p>

<p>xfrm - framework for IPsec protocol.</p>

<p>The names of all objects may be written in full or
abbreviated form, f.e. address is abbreviated as addr or
just a.</p>

<p>COMMAND Specifies the action to perform on the object.
The set of possible actions depends on the object type. As a
rule, it is possible to add, delete and show (or list )
objects, but some objects do not allow all of these
operations or have some additional commands. The help
command is available for all objects. It prints out a list
of available com- mands and argument syntax conventions.</p>

<p>If no command is given, some default command is assumed.
Usually it is list or, if the objects of this class cannot
be listed, help.</p>

<p>ip link - network device configuration link is a network
device and the corresponding commands display and change the
state of devices.</p>

<p>ip link set - change device attributes dev NAME
(default) NAME specifies network device to operate on. When
configuring SR-IOV Virtual Fuction (VF) devices, this
keyword should specify the associated Physical Function (PF)
device.</p>

<p>up and down change the state of the device to UP or
DOWN.</p>

<p>arp on or arp off change the NOARP flag on the
device.</p>

<p>multicast on or multicast off change the MULTICAST flag
on the device.</p>

<p>dynamic on or dynamic off change the DYNAMIC flag on the
device.</p>

<p>name NAME change the name of the device. This operation
is not recom- mended if the device is running or has some
addresses already configured.</p>

<p>txqueuelen NUMBER</p>

<p>txqlen NUMBER change the transmit queue length of the
device.</p>

<p>mtu NUMBER change the MTU of the device.</p>

<p>address LLADDRESS change the station address of the
interface.</p>

<p>broadcast LLADDRESS</p>

<p>brd LLADDRESS</p>

<p>peer LLADDRESS change the link layer broadcast address
or the peer address when the interface is POINTOPOINT.</p>

<p>netns PID move the device to the network namespace
associated with the process PID.</p>

<p>alias NAME give the device a symbolic name for easy
reference.</p>

<p>vf NUM specify a Virtual Function device to be
configured. The associ- ated PF device must be specified
using the dev parameter.</p>

<p>mac LLADDRESS - change the station address for the spec-
ified VF. The vf parameter must be specified.</p>

<p>vlan VLANID - change the assigned VLAN for the specified
VF. When specified, all traffic sent from the VF will be
tagged with the specified VLAN ID. Incoming traffic will be
filtered for the specified VLAN ID, and will have all VLAN
tags stripped before being passed to the VF. Set- ting this
parameter to 0 disables VLAN tagging and fil- tering. The vf
parameter must be specified.</p>

<p>qos VLAN-QOS - assign VLAN QOS (priority) bits for the
VLAN tag. When specified, all VLAN tags transmitted by the
VF will include the specified priority bits in the VLAN tag.
If not specified, the value is assumed to be 0. Both the vf
and vlan parameters must be specified. Setting both vlan and
qos as 0 disables VLAN tagging and filtering for the VF.</p>

<p>rate TXRATE - change the allowed transmit bandwidth, in
Mbps, for the specified VF. Setting this parameter to 0
disables rate limiting. The vf parameter must be speci-
fied.</p>

<p>spoofchk on|off - turn packet spoof checking on or off
for the specified VF.</p>

<p>Warning: If multiple parameter changes are requested, ip
aborts immedi- ately after any of the changes have failed.
This is the only case when ip can move the system to an
unpredictable state. The solution is to avoid changing
several parameters with one ip link set call.</p>

<p>ip link show - display device attributes dev NAME
(default) NAME specifies the network device to show. If this
argument is omitted all devices are listed.</p>

<p>up only display running interfaces.</p>

<p>ip address - protocol address management. The address is
a protocol (IP or IPv6) address attached to a network
device. Each device must have at least one address to use
the corre- sponding protocol. It is possible to have several
different addresses attached to one device. These addresses
are not discriminated, so that the term alias is not quite
appropriate for them and we do not use it in this
document.</p>

<p>The ip addr command displays addresses and their
properties, adds new addresses and deletes old ones.</p>

<p>ip address add - add new protocol address. dev NAME the
name of the device to add the address to.</p>

<p>local ADDRESS (default) the address of the interface.
The format of the address depends on the protocol. It is a
dotted quad for IP and a sequence of hexadecimal halfwords
separated by colons for IPv6. The ADDRESS may be followed by
a slash and a decimal number which encodes the network
prefix length.</p>

<p>peer ADDRESS the address of the remote endpoint for
pointopoint interfaces. Again, the ADDRESS may be followed
by a slash and a decimal num- ber, encoding the network
prefix length. If a peer address is specified, the local
address cannot have a prefix length. The network prefix is
associated with the peer rather than with the local
address.</p>

<p>broadcast ADDRESS the broadcast address on the
interface.</p>

<p>It is possible to use the special symbols+and- instead
of the broadcast address. In this case, the broadcast
address is derived by setting/resetting the host bits of the
interface pre- fix.</p>

<p>label NAME Each address may be tagged with a label
string. In order to preserve compatibility with Linux-2.0
net aliases, this string must coincide with the name of the
device or must be prefixed with the device name followed by
colon.</p>

<p>scope SCOPE_VALUE the scope of the area where this
address is valid. The avail- able scopes are listed in file
/etc/iproute2/rt_scopes. Prede- fined scope values are:</p>

<p>global - the address is globally valid.</p>

<p>site - (IPv6 only) the address is site local, i.e. it is
valid inside this site.</p>

<p>link - the address is link local, i.e. it is valid only
on this device.</p>

<p>host - the address is valid only inside this host.</p>

<p>ip address delete - delete protocol address Arguments:
coincide with the arguments of ip addr add. The device name
is a required argument. The rest are optional. If no
arguments are given, the first address is deleted.</p>

<p>ip address show - look at protocol addresses dev NAME
(default) name of device.</p>

<p>scope SCOPE_VAL only list addresses with this scope.</p>

<p>to PREFIX only list addresses matching this prefix.</p>

<p>label PATTERN only list addresses with labels matching
the PATTERN. PATTERN is a usual shell style pattern.</p>

<p>dynamic and permanent (IPv6 only) only list addresses
installed due to stateless address configuration or only
list permanent (not dynamic) addresses.</p>

<p>tentative (IPv6 only) only list addresses which did not
pass duplicate address detection.</p>

<p>deprecated (IPv6 only) only list deprecated
addresses.</p>

<p>primary and secondary only list primary (or secondary)
addresses.</p>

<p>ip address flush - flush protocol addresses This command
flushes the protocol addresses selected by some
criteria.</p>

<p>This command has the same arguments as show. The
difference is that it does not run when no arguments are
given.</p>

<p>Warning: This command (and other flush commands
described below) is pretty dangerous. If you make a mistake,
it will not forgive it, but will cruelly purge all the
addresses.</p>

<p>With the -statistics option, the command becomes
verbose. It prints out the number of deleted addresses and
the number of rounds made to flush the address list. If this
option is given twice, ip addr flush also dumps all the
deleted addresses in the format described in the previous
subsection.</p>

<p>ip addrlabel - protocol address label management. IPv6
address label is used for address selection described in RFC
3484. Precedence is managed by userspace, and only label is
stored in kernel.</p>

<p>ip addrlabel add - add an address label the command adds
an address label entry to the kernel.</p>

<p>prefix PREFIX</p>

<p>dev DEV the outgoing interface.</p>

<p>label NUMBER the label for the prefix. 0xffffffff is
reserved.</p>

<p>ip addrlabel del - delete an address label the command
deletes an address label entry in the kernel. Arguments:
coincide with the arguments of ip addrlabel add but label is
not required.</p>

<p>ip addrlabel list - list address labels the command show
contents of address labels.</p>

<p>ip addrlabel flush - flush address labels the command
flushes the contents of address labels and it does not
restore default settings.</p>

<p>ip neighbour - neighbour/arp tables management.
neighbour objects establish bindings between protocol
addresses and link layer addresses for hosts sharing the
same link. Neighbour entries are organized into tables. The
IPv4 neighbour table is known by another name - the ARP
table.</p>

<p>The corresponding commands display neighbour bindings
and their proper- ties, add new neighbour entries and delete
old ones.</p>

<p>ip neighbour add - add a new neighbour entry ip
neighbour change - change an existing entry ip neighbour
replace - add a new entry or change an existing one These
commands create new neighbour records or update existing
ones.</p>

<p>to ADDRESS (default) the protocol address of the
neighbour. It is either an IPv4 or IPv6 address.</p>

<p>dev NAME the interface to which this neighbour is
attached.</p>

<p>lladdr LLADDRESS the link layer address of the
neighbour. LLADDRESS can also be null.</p>

<p>nud NUD_STATE the state of the neighbour entry. nud is
an abbreviation for Neigh bour Unreachability Detection. The
state can take one of the following values:</p>

<p>permanent - the neighbour entry is valid forever and can
be only be removed administratively.</p>

<p>noarp - the neighbour entry is valid. No attempts to
validate this entry will be made but it can be removed when
its lifetime expires.</p>

<p>reachable - the neighbour entry is valid until the
reachability timeout expires.</p>

<p>stale - the neighbour entry is valid but suspicious.
This option to ip neigh does not change the neighbour state
if it was valid and the address is not changed by this
command.</p>

<p>ip neighbour delete - delete a neighbour entry This
command invalidates a neighbour entry.</p>

<p>The arguments are the same as with ip neigh add, except
that lladdr and nud are ignored.</p>

<p>Warning: Attempts to delete or manually change a noarp
entry created by the kernel may result in unpredictable
behaviour. Particularly, the kernel may try to resolve this
address even on a NOARP interface or if the address is
multicast or broadcast.</p>

<p>ip neighbour show - list neighbour entries This commands
displays neighbour tables.</p>

<p>to ADDRESS (default) the prefix selecting the neighbours
to list.</p>

<p>dev NAME only list the neighbours attached to this
device.</p>

<p>unused only list neighbours which are not currently in
use.</p>

<p>nud NUD_STATE only list neighbour entries in this state.
NUD_STATE takes val- ues listed below or the special value
all which means all states. This option may occur more than
once. If this option is absent, ip lists all entries except
for none and noarp.</p>

<p>ip neighbour flush - flush neighbour entries This
command flushes neighbour tables, selecting entries to flush
by some criteria.</p>

<p>This command has the same arguments as show. The
differences are that it does not run when no arguments are
given, and that the default neighbour states to be flushed
do not include permanent and noarp.</p>

<p>With the -statistics option, the command becomes
verbose. It prints out the number of deleted neighbours and
the number of rounds made to flush the neighbour table. If
the option is given twice, ip neigh flush also dumps all the
deleted neighbours.</p>

<p>ip route - routing table management Manipulate route
entries in the kernel routing tables keep information about
paths to other networked nodes.</p>

<p>Route types:</p>

<p>unicast - the route entry describes real paths to the
destina- tions covered by the route prefix.</p>

<p>unreachable - these destinations are unreachable.
Packets are discarded and the ICMP message host unreachable
is generated. The local senders get an EHOSTUNREACH
error.</p>

<p>blackhole - these destinations are unreachable. Packets
are discarded silently. The local senders get an EINVAL
error.</p>

<p>prohibit - these destinations are unreachable. Packets
are discarded and the ICMP message communication
administratively prohibited is generated. The local senders
get an EACCES error.</p>

<p>local - the destinations are assigned to this host. The
pack- ets are looped back and delivered locally.</p>

<p>broadcast - the destinations are broadcast addresses.
The packets are sent as link broadcasts.</p>

<p>throw - a special control route used together with
policy rules. If such a route is selected, lookup in this
table is terminated pretending that no route was found.
Without policy routing it is equivalent to the absence of
the route in the routing table. The packets are dropped and
the ICMP message net unreachable is generated. The local
senders get an ENETUN- REACH error.</p>

<p>nat - a special NAT route. Destinations covered by the
prefix are considered to be dummy (or external) addresses
which require translation to real (or internal) ones before
forward- ing. The addresses to translate to are selected
with the attribute Warning: Route NAT is no longer supported
in Linux 2.6.</p>

<p>via.</p>

<p>anycast - not implemented the destinations are anycast
addresses assigned to this host. They are mainly equivalent
to local with one difference: such addresses are invalid
when used as the source address of any packet.</p>

<p>multicast - a special type used for multicast routing.
It is not present in normal routing tables.</p>

<p>Route tables: Linux-2.x can pack routes into several
routing tables identified by a number in the range from 1 to
255 or by name from the file /etc/iproute2/rt_tables By
default all normal routes are inserted into the main table
(ID 254) and the kernel only uses this table when
calculating routes.</p>

<p>Actually, one other table always exists, which is
invisible but even more important. It is the local table (ID
255). This table consists of routes for local and broadcast
addresses. The kernel maintains this table automatically and
the administrator usually need not modify it or even look at
it.</p>

<p>The multiple routing tables enter the game when policy
routing is used.</p>

<p>ip route add - add new route ip route change - change
route ip route replace - change or add new one to TYPE
PREFIX (default) the destination prefix of the route. If
TYPE is omitted, ip assumes type unicast. Other values of
TYPE are listed above. PREFIX is an IP or IPv6 address
optionally followed by a slash and the prefix length. If the
length of the prefix is missing, ip assumes a full-length
host route. There is also a special PREFIX default - which
is equivalent to IP 0/0 or to IPv6 ::/0.</p>

<p>tos TOS</p>

<p>dsfield TOS the Type Of Service (TOS) key. This key has
no associated mask and the longest match is understood as:
First, compare the TOS of the route and of the packet. If
they are not equal, then the packet may still match a route
with a zero TOS. TOS is either an 8 bit hexadecimal number
or an identifier from /etc/iproute2/rt_dsfield.</p>

<p>metric NUMBER</p>

<p>preference NUMBER the preference value of the route.
NUMBER is an arbitrary 32bit number.</p>

<p>table TABLEID the table to add this route to. TABLEID
may be a number or a string from the file
/etc/iproute2/rt_tables. If this parameter is omitted, ip
assumes the main table, with the exception of local ,
broadcast and nat routes, which are put into the local table
by default.</p>

<p>dev NAME the output device name.</p>

<p>via ADDRESS the address of the nexthop router. Actually,
the sense of this field depends on the route type. For
normal unicast routes it is either the true next hop router
or, if it is a direct route installed in BSD compatibility
mode, it can be a local address of the interface. For NAT
routes it is the first address of the block of translated IP
destinations.</p>

<p>src ADDRESS the source address to prefer when sending to
the destinations covered by the route prefix.</p>

<p>realm REALMID the realm to which this route is assigned.
REALMID may be a number or a string from the file
/etc/iproute2/rt_realms.</p>

<p>mtu MTU</p>

<p>mtu lock MTU the MTU along the path to the destination.
If the modifier lock is not used, the MTU may be updated by
the kernel due to Path MTU Discovery. If the modifier lock
is used, no path MTU dis- covery will be tried, all packets
will be sent without the DF bit in IPv4 case or fragmented
to MTU for IPv6.</p>

<p>window NUMBER the maximal window for TCP to advertise to
these destinations, measured in bytes. It limits maximal
data bursts that our TCP peers are allowed to send to
us.</p>

<p>rtt TIME the initial RTT (Round Trip Time) estimate. If
no suffix is specified the units are raw values passed
directly to the rout- ing code to maintain compatability
with previous releases. Oth- erwise if a suffix of s, sec or
secs is used to specify seconds and ms, msec or msecs to
specify milliseconds.</p>

<p>rttvar TIME (2.3.15+ only) the initial RTT variance
estimate. Values are specified as with rtt above.</p>

<p>rto_min TIME (2.6.23+ only) the minimum TCP
Retransmission TimeOut to use when communicating with this
destination. Values are specified as with rtt above.</p>

<p>ssthresh NUMBER (2.3.15+ only) an estimate for the
initial slow start threshold.</p>

<p>cwnd NUMBER (2.3.15+ only) the clamp for congestion
window. It is ignored if the lock flag is not used.</p>

<p>initcwnd NUMBER the maximum initial congestion window
(cwnd) size in MSS of a TCP connection.</p>

<p>initrwnd NUMBER (2.6.33+ only) the initial receive
window size for connections to this destina- tion. Actual
window size is this value multiplied by the MSS of the
connection. The default value is zero, meaning to use Slow
Start value.</p>

<p>advmss NUMBER (2.3.15+ only) the MSS ( Maximal Segment
Size) to advertise to these destina- tions when establishing
TCP connections. If it is not given, Linux uses a default
value calculated from the first hop device MTU. (If the path
to these destination is asymmetric, this guess may be
wrong.)</p>

<p>reordering NUMBER (2.3.15+ only) Maximal reordering on
the path to this destination. If it is not given, Linux uses
the value selected with sysctl variable
net/ipv4/tcp_reordering.</p>

<p>nexthop NEXTHOP the nexthop of a multipath route.
NEXTHOP is a complex value with its own syntax similar to
the top level argument lists:</p>

<p>via ADDRESS - is the nexthop router.</p>

<p>dev NAME - is the output device.</p>

<p>weight NUMBER - is a weight for this element of a multi-
path route reflecting its relative bandwidth or quality.</p>

<p>scope SCOPE_VAL the scope of the destinations covered by
the route prefix. SCOPE_VAL may be a number or a string from
the file /etc/iproute2/rt_scopes. If this parameter is
omitted, ip assumes scope global for all gatewayed unicast
routes, scope link for direct unicast and broadcast routes
and scope host for local routes.</p>

<p>protocol RTPROTO the routing protocol identifier of this
route. RTPROTO may be a number or a string from the file
/etc/iproute2/rt_protos. If the routing protocol ID is not
given, ip assumes protocol boot (i.e. it assumes the route
was added by someone who doesnt understand what they are
doing). Several protocol values have a fixed interpretation.
Namely:</p>

<p>redirect - the route was installed due to an ICMP redi-
rect.</p>

<p>kernel - the route was installed by the kernel during
autoconfiguration.</p>

<p>boot - the route was installed during the bootup
sequence. If a routing daemon starts, it will purge all of
them.</p>

<p>static - the route was installed by the administrator to
override dynamic routing. Routing daemon will respect them
and, probably, even advertise them to its peers.</p>

<p>ra - the route was installed by Router Discovery proto-
col.</p>

<p>The rest of the values are not reserved and the
administrator is free to assign (or not to assign) protocol
tags.</p>

<p>onlink pretend that the nexthop is directly attached to
this link, even if it does not match any interface
prefix.</p>

<p>equalize allow packet by packet randomization on
multipath routes. With- out this modifier, the route will be
frozen to one selected nex- thop, so that load splitting
will only occur on per-flow base. equalize only works if the
kernel is patched.</p>

<p>ip route delete - delete route ip route del has the same
arguments as ip route add, but their seman- tics are a bit
different.</p>

<p>Key values (to, tos, preference and table) select the
route to delete. If optional attributes are present, ip
verifies that they coincide with the attributes of the route
to delete. If no route with the given key and attributes was
found, ip route del fails.</p>

<p>ip route show - list routes the command displays the
contents of the routing tables or the route(s) selected by
some criteria.</p>

<p>to SELECTOR (default) only select routes from the given
range of destinations. SELEC- TOR consists of an optional
modifier (root, match or exact) and a prefix. root PREFIX
selects routes with prefixes not shorter than PREFIX. F.e.
root 0/0 selects the entire routing table. match PREFIX
selects routes with prefixes not longer than PRE- FIX. F.e.
match 10.0/16 selects 10.0/16, 10/8 and 0/0, but it does not
select 10.1/16 and 10.0.0/24. And exact PREFIX (or just
PREFIX) selects routes with this exact prefix. If neither of
these options are present, ip assumes root 0/0 i.e. it lists
the entire table.</p>

<p>tos TOS dsfield TOS only select routes with the given
TOS.</p>

<p>table TABLEID show the routes from this table(s). The
default setting is to show tablemain. TABLEID may either be
the ID of a real table or one of the special values:</p>

<p>all - list all of the tables.</p>

<p>cache - dump the routing cache.</p>

<p>cloned</p>

<p>cached list cloned routes i.e. routes which were
dynamically forked from other routes because some route
attribute (f.e. MTU) was updated. Actually, it is equivalent
to table cache.</p>

<p>from SELECTOR the same syntax as for to, but it binds
the source address range rather than destinations. Note that
the from option only works with cloned routes.</p>

<p>protocol RTPROTO only list routes of this protocol.</p>

<p>scope SCOPE_VAL only list routes with this scope.</p>

<p>type TYPE only list routes of this type.</p>

<p>dev NAME only list routes going via this device.</p>

<p>via PREFIX only list routes going via the nexthop
routers selected by PRE- FIX.</p>

<p>src PREFIX only list routes with preferred source
addresses selected by PREFIX.</p>

<p>realm REALMID</p>

<p>realms FROMREALM/TOREALM only list routes with these
realms.</p>

<p>ip route flush - flush routing tables this command
flushes routes selected by some criteria.</p>

<p>The arguments have the same syntax and semantics as the
arguments of ip route show, but routing tables are not
listed but purged. The only difference is the default
action: show dumps all the IP main routing table but flush
prints the helper page.</p>

<p>With the -statistics option, the command becomes
verbose. It prints out the number of deleted routes and the
number of rounds made to flush the routing table. If the
option is given twice, ip route flush also dumps all the
deleted routes in the format described in the previous
subsec- tion.</p>

<p>ip route get - get a single route this command gets a
single route to a destination and prints its con- tents
exactly as the kernel sees it.</p>

<p>to ADDRESS (default) the destination address.</p>

<p>from ADDRESS the source address.</p>

<p>tos TOS</p>

<p>dsfield TOS the Type Of Service.</p>

<p>iif NAME the device from which this packet is expected
to arrive.</p>

<p>oif NAME force the output device on which this packet
will be routed.</p>

<p>connected if no source address (option from) was given,
relookup the route with the source set to the preferred
address received from the first lookup. If policy routing is
used, it may be a different route.</p>

<p>Note that this operation is not equivalent to ip route
show. show shows existing routes. get resolves them and
creates new clones if necessary. Essentially, get is
equivalent to sending a packet along this path. If the iif
argument is not given, the kernel creates a route to output
packets towards the requested destination. This is
equivalent to pinging the destination with a subsequent ip
route ls cache, however, no packets are actually sent. With
the iif argument, the kernel pretends that a packet arrived
from this interface and searches for a path to forward the
packet.</p>

<p>ip rule - routing policy database management Rules in
the routing policy database control the route selection
algo- rithm.</p>

<p>Classic routing algorithms used in the Internet make
routing decisions based only on the destination address of
packets (and in theory, but not in practice, on the TOS
field).</p>

<p>In some circumstances we want to route packets
differently depending not only on destination addresses, but
also on other packet fields: source address, IP protocol,
transport protocol ports or even packet payload. This task
is called policy routing.</p>

<p>To solve this task, the conventional destination based
routing table, ordered according to the longest match rule,
is replaced with a rout- ing policy database (or RPDB),
which selects routes by executing some set of rules.</p>

<p>Each policy routing rule consists of a selector and an
action predi- cate. The RPDB is scanned in the order of
increasing priority. The selector of each rule is applied to
{source address, destination address, incoming interface,
tos, fwmark} and, if the selector matches the packet, the
action is performed. The action predicate may return with
success. In this case, it will either give a route or
failure indication and the RPDB lookup is terminated.
Otherwise, the RPDB pro- gram continues on the next
rule.</p>

<p>Semantically, natural action is to select the nexthop
and the output device.</p>

<p>At startup time the kernel configures the default RPDB
consisting of three rules:</p>

<p>1. Priority: 0, Selector: match anything, Action: lookup
routing table local (ID 255). The local table is a special
routing ta- ble containing high priority control routes for
local and broad- cast addresses.</p>

<p>Rule 0 is special. It cannot be deleted or
overridden.</p>

<p>2. Priority: 32766, Selector: match anything, Action:
lookup rout- ing table main (ID 254). The main table is the
normal routing table containing all non-policy routes. This
rule may be deleted and/or overridden with other ones by the
administrator.</p>

<p>3. Priority: 32767, Selector: match anything, Action:
lookup rout- ing table default (ID 253). The default table
is empty. It is reserved for some post-processing if no
previous default rules selected the packet. This rule may
also be deleted.</p>

<p>Each RPDB entry has additional attributes. F.e. each
rule has a pointer to some routing table. NAT and
masquerading rules have an attribute to select new IP
address to translate/masquerade. Besides that, rules have
some optional attributes, which routes have, namely realms.
These values do not override those contained in the routing
tables. They are only used if the route did not select any
attributes.</p>

<p>The RPDB may contain rules of the following types:</p>

<p>unicast - the rule prescribes to return the route found
in the routing table referenced by the rule.</p>

<p>blackhole - the rule prescribes to silently drop the
packet.</p>

<p>unreachable - the rule prescribes to generate a Network
is unreachable error.</p>

<p>prohibit - the rule prescribes to generate Communication
is administratively prohibited error.</p>

<p>nat - the rule prescribes to translate the source
address of the IP packet into some other value.</p>

<p>ip rule add - insert a new rule ip rule delete - delete
a rule type TYPE (default) the type of this rule. The list
of valid types was given in the previous subsection.</p>

<p>from PREFIX select the source prefix to match.</p>

<p>to PREFIX select the destination prefix to match.</p>

<p>iif NAME select the incoming device to match. If the
interface is loop- back, the rule only matches packets
originating from this host. This means that you may create
separate routing tables for for- warded and local packets
and, hence, completely segregate them.</p>

<p>tos TOS</p>

<p>dsfield TOS select the TOS value to match.</p>

<p>fwmark MARK select the fwmark value to match.</p>

<p>priority PREFERENCE the priority of this rule. Each rule
should have an explicitly set unique priority value. The
options preference and order are synonyms with priority.</p>

<p>table TABLEID the routing table identifier to lookup if
the rule selector matches. It is also possible to use lookup
instead of table.</p>

<p>realms FROM/TO Realms to select if the rule matched and
the routing table lookup succeeded. Realm TO is only used if
the route did not select any realm.</p>

<p>nat ADDRESS The base of the IP address block to
translate (for source addresses). The ADDRESS may be either
the start of the block of NAT addresses (selected by NAT
routes) or a local host address (or even zero). In the last
case the router does not translate the packets, but
masquerades them to this address. Using map-to instead of
nat means the same thing.</p>

<p>Warning: Changes to the RPDB made with these commands do
not become active immediately. It is assumed that after a
script finishes a batch of updates, it flushes the routing
cache with ip route flush cache.</p>

<p>ip rule flush - also dumps all the deleted rules. This
command has no arguments.</p>

<p>ip rule show - list rules This command has no arguments.
The options list or lst are synonyms with show.</p>

<p>ip maddress - multicast addresses management maddress
objects are multicast addresses.</p>

<p>ip maddress show - list multicast addresses dev NAME
(default) the device name.</p>

<p>ip maddress add - add a multicast address ip maddress
delete - delete a multicast address these commands
attach/detach a static link layer multicast address to
listen on the interface. Note that it is impossible to join
protocol multicast groups statically. This command only
manages link layer addresses.</p>

<p>address LLADDRESS (default) the link layer multicast
address.</p>

<p>dev NAME the device to join/leave this multicast
address.</p>

<p>ip mroute - multicast routing cache management mroute
objects are multicast routing cache entries created by a
user level mrouting daemon (f.e. pimd or mrouted ).</p>

<p>Due to the limitations of the current interface to the
multicast rout- ing engine, it is impossible to change
mroute objects administratively, so we may only display
them. This limitation will be removed in the future.</p>

<p>ip mroute show - list mroute cache entries to PREFIX
(default) the prefix selecting the destination multicast
addresses to list.</p>

<p>iif NAME the interface on which multicast packets are
received.</p>

<p>from PREFIX the prefix selecting the IP source addresses
of the multicast route.</p>

<p>ip tunnel - tunnel configuration tunnel objects are
tunnels, encapsulating packets in IP packets and then
sending them over the IP infrastructure. The encapulating
(or outer) address family is specified by the -f option. The
default is IPv4.</p>

<p>ip tunnel add - add a new tunnel ip tunnel change -
change an existing tunnel ip tunnel delete - destroy a
tunnel name NAME (default) select the tunnel device
name.</p>

<p>mode MODE set the tunnel mode. Available modes depend on
the encapsulating address family. Modes for IPv4
encapsulation available: ipip, sit, isatap and gre. Modes
for IPv6 encapsulation available: ip6ip6, ipip6 and any.</p>

<p>remote ADDRESS set the remote endpoint of the
tunnel.</p>

<p>local ADDRESS set the fixed local address for tunneled
packets. It must be an address on another interface of this
host.</p>

<p>ttl N set a fixed TTL N on tunneled packets. N is a
number in the range 1--255. 0 is a special value meaning
that packets inherit the TTL value. The default value for
IPv4 tunnels is: inherit. The default value for IPv6 tunnels
is: 64.</p>

<p>tos T</p>

<p>dsfield T</p>

<p>tclass T set a fixed TOS (or traffic class in IPv6) T on
tunneled pack- ets. The default value is: inherit.</p>

<p>dev NAME bind the tunnel to the device NAME so that
tunneled packets will only be routed via this device and
will not be able to escape to another device when the route
to endpoint changes.</p>

<p>nopmtudisc disable Path MTU Discovery on this tunnel. It
is enabled by default. Note that a fixed ttl is incompatible
with this option: tunnelling with a fixed ttl always makes
pmtu discovery.</p>

<p>key K</p>

<p>ikey K</p>

<p>okey K ( only GRE tunnels ) use keyed GRE with key K. K
is either a number or an IP address-like dotted quad. The
key parameter sets the key to use in both directions. The
ikey and okey parameters set different keys for input and
output.</p>

<p>csum, icsum, ocsum ( only GRE tunnels ) generate/require
checksums for tunneled packets. The ocsum flag calculates
checksums for outgoing packets. The icsum flag requires that
all input packets have the correct checksum. The csum flag
is equivalent to the combi- nation icsum ocsum.</p>

<p>seq, iseq, oseq ( only GRE tunnels ) serialize packets.
The oseq flag enables sequencing of outgoing packets. The
iseq flag requires that all input packets are serialized.
The seq flag is equivalent to the combination iseq oseq. It
ist work. Dot use it.</p>

<p>dscp inherit ( only IPv6 tunnels ) Inherit DS field
between inner and outer header.</p>

<p>encaplim ELIM ( only IPv6 tunnels ) set a fixed
encapsulation limit. Default is 4.</p>

<p>flowlabel FLOWLABEL ( only IPv6 tunnels ) set a fixed
flowlabel.</p>

<p>ip tunnel prl - potential router list (ISATAP only) dev
NAME mandatory device name.</p>

<p>prl-default ADDR</p>

<p>prl-nodefault ADDR</p>

<p>prl-delete ADDR Add or delete ADDR as a potential router
or default router.</p>

<p>ip tunnel show - list tunnels This command has no
arguments.</p>

<p>ip monitor and rtmon - state monitoring The ip utility
can monitor the state of devices, addresses and routes
continuously. This option has a slightly different format.
Namely, the monitor command is the first in the command line
and then the object list follows:</p>

<p>ip monitor [ all | LISTofOBJECTS ]</p>

<p>OBJECT-LIST is the list of object types that we want to
monitor. It may contain link, address and route. If no file
argument is given, ip opens RTNETLINK, listens on it and
dumps state changes in the format described in previous
sections.</p>

<p>If a file name is given, it does not listen on
RTNETLINK, but opens the file containing RTNETLINK messages
saved in binary format and dumps them. Such a history file
can be generated with the rtmon utility. This utility has a
command line syntax similar to ip monitor. Ideally, rtmon
should be started before the first network configuration
command is issued. F.e. if you insert:</p>

<p>rtmon file /var/log/rtmon.log</p>

<p>in a startup script, you will be able to view the full
history later.</p>

<p>Certainly, it is possible to start rtmon at any time. It
prepends the history with the state snapshot dumped at the
moment of starting.</p>

<p>ip xfrm - setting xfrm xfrm is an IP framework, which
can transform format of the datagrams, i.e. encrypt the
packets with some algorithm. xfrm policy and xfrm state are
associated through templates TMPL_LIST. This framework is
used as a part of IPsec protocol.</p>

<p>ip xfrm state add - add new state into xfrm ip xfrm
state update - update existing xfrm state ip xfrm state
allocspi - allocate SPI value MODE is set as default to
transport, but it could be set to tunnel,ro or beet.</p>

<p>FLAG-LIST contains one or more flags.</p>

<p>FLAG could be set to noecn, decap-dscp or wildrecv.</p>

<p>ENCAP encapsulation is set to encapsulation type
ENCAP-TYPE, source port SPORT, destination port DPORT and
OADDR.</p>

<p>ENCAP-TYPE could be set to espinudp or
espinudp-nonike.</p>

<p>ALGO-LIST contains one or more algorithms ALGO which
depend on the type of algorithm set by ALGO_TYPE. It can be
used these algoritms enc, auth or comp.</p>

<p>ip xfrm policy add - add a new policy ip xfrm policy
update - update an existing policy ip xfrm policy delete -
delete existing policy ip xfrm policy get - get existing
policy ip xfrm policy deleteall - delete all existing xfrm
policy ip xfrm policy list - print out the list of xfrm
policy ip xfrm policy flush - flush policies It can be flush
all policies or only those specified with ptype.</p>

<p>dir DIR directory could be one of these: inp, out or
fwd.</p>

<p>SELECTOR selects for which addresses will be set up the
policy. The selector is defined by source and destination
address.</p>

<p>UPSPEC is defined by source port sport, destination port
dport, type as number and code also number.</p>

<p>dev DEV specify network device.</p>

<p>index INDEX the number of indexed policy.</p>

<p>ptype PTYPE type is set as default on main, could be
switch on sub.</p>

<p>action ACTION is set as default on allow. It could be
switch on block.</p>

<p>priority PRIORITY priority is a number. Default priority
is set on zero.</p>

<p>LIMIT-LIST limits are set in seconds, bytes or numbers
of packets.</p>

<p>TMPL-LIST template list is based on ID, mode, reqid and
level.</p>

<p>ID is specified by source address, destination address,
proto and value of spi.</p>

<p>XFRM_PROTO values: esp, ah, comp, route2 or hao.</p>

<p>MODE is set as default on transport, but it could be set
on tunnel or beet.</p>

<p>LEVEL is set as default on required and the other choice
is use.</p>

<p>UPSPEC is specified by sport, dport, type and code
(NUMBER).</p>

<p>ip xfrm monitor - is used for listing all objects or
defined group of them. The xfrm monitor can monitor the
policies for all objects or defined group of them.</p>

<p>ip token IPv6 tokenized interface identifer support is
used for assigning well- known host-part addresses to nodes
whilst still obtaining a global net- work prefix from Router
advertisements. The primary target for tok- enized
identifiers are server platforms where addresses are usually
manually configured, rather than using DHCPv6 or SLAAC. By
using tok- enized identifiers, hosts can still determine
their network prefix by use of SLAAC, but more readily be
automatically renumbered should their network prefix change
[1]. Tokenized IPv6 Identifiers are described in the draft
[1]:
&lt;draft-chown-6man-tokenised-ipv6-identifiers-02&gt;.</p>

<p>ip token set - set an interface token set the interface
token to the kernel. Once a token is set, it cannot be
removed from the interface, only overwritten.</p>

<p>TOKEN the interface identifer token address.</p>

<p>dev DEV the networking interface.</p>

<p>ip token get - get the interface token from the kernel
show a tokenized interface identifer of a particular
networking device. Arguments: coincide with the arguments of
ip token set but the TOKEN must be left out.</p>

<p>ip token list - list all interface tokens list all
tokenized interface identifers for the networking interfaces
from the kernel.</p>

<p>HISTORY ip was written by Alexey N. Kuznetsov and added
in Linux 2.2.</p>

<p>SEE ALSO tc(8) IP Command reference ip-cref.ps IP
tunnels ip-cref.ps User documentation at http://lartc.org/,
but please direct bugreports and patches to:
&lt;netdev@vger.kernel.org&gt;</p>

<p>AUTHOR Original Manpage by Michail Litvak
&lt;mci@owl.openwall.com&gt;</p>

<p>iproute2 17 January 2002 IP(8)</p>
<hr>
</body>
</html>
