<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:23:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MODULE(1) Modules package MODULE(1)</p>

<p>NAME module - command interface to the Modules
package</p>

<p>SYNOPSIS module [ switches ] [ sub-command ] [
sub-command-args ]</p>

<p>DESCRIPTION module is a user interface to the Modules
package. The Modules package provides for the dynamic
modification of the users environment via modulefiles.</p>

<p>Each modulefile contains the information needed to
configure the shell for an application. Once the Modules
package is initialized, the environment can be modified on a
per-module basis using the module command which interprets
modulefiles. Typically modulefiles instruct the module
command to alter or set shell environment variables such as
PATH, MANPATH, etc. modulefiles may be shared by many users
on a system and users may have their own collection to
supplement or replace the shared modulefiles.</p>

<p>The modulefiles are added to and removed from the
current environment by the user. The environment changes
contained in a modulefile can be summarized through the
module command as well. If no arguments are given, a summary
of the module usage and sub-commands are shown.</p>

<p>The action for the module command to take is described
by the sub- command and its associated arguments.</p>

<p>Package Initialization The Modules package and the
module command are initialized when a shell-specific
initialization script is sourced into the shell. The script
creates the module command, either as an alias or shell
function, creates Modules environment variables, and if
enabled to do so, a snapshot of the environment is saved as
either (if BEGINENV=1) $HOME/.modulesbeginenv or (if
BEGINENV=99) whatever $MODULESBEGINENV points to.</p>

<p>The module alias or function executes the modulecmd
program and has the shell evaluate the commands output. The
first argument to modulecmd specifies the type of shell.</p>

<p>The initialization scripts are kept in
$MODULESHOME/init/&lt;shell&gt; where &lt;shell&gt; is the
name of the sourcing shell. The sh, csh, tcsh, bash, ksh,
and zsh shells are supported by modulecmd. In addition,
python, perl, and cmake &quot;shells&quot; are supported,
which writes the environment changes to stdout as python,
perl, or cmake code.</p>

<p>The perl module command is set up with:</p>

<p>use lib $ENV{MODULESHOME}.&quot;/init&quot;; use
perl;</p>

<p>And the python module command is defined with:</p>

<p>import os; if os.environ.has_key(PYTHONPATH):
os.environ[PYTHONPATH] += : +os.environ[ MODULESHOME
]+&quot;/init&quot;; else: os.environ[ PYTHONPATH ] =
os.environ[ MODULESHOME ]+&quot;/init&quot;;</p>

<p>from python import module;</p>

<p>Modulecmd startup Upon invocation modulecmd sources rc
files which contain global, user and modulefile specific
setups. These files are interpreted as modulefiles. See
modulefile(4) for detailed information.</p>

<p>Upon invocation of modulecmd module RC files are sourced
in the following order:</p>

<p>Global RC file as specified by ${MODULERCFILE} or
${MODULESHOME}/etc/rc</p>

<p>User specific module RC file ${HOME}/.modulerc</p>

<p>All .modulerc and .version files found during modulefile
seeking.</p>

<p>Command line switches The module command accepts command
line switches as its first parameter. These may be used to
control output format of all information displayed and the
module behavior in case of locating and interpreting module
files.</p>

<p>All switches may be entered either in short or long
notation. The following switches are accepted:</p>

<p>--help, -H Give some helpful usage information, and
terminates the command.</p>

<p>--version, -V Lists the current version of the module
command, and some configured option values. The command then
terminates without further processing.</p>

<p>--force, -f Force active dependency resolution. This
will result in modules found on a prereq command inside a
module file being load automatically. Unloading module files
using this switch will result in all required modules which
have been loaded automatically using the -f switch being
unload. This switch is experimental at the moment.</p>

<p>--terse, -t Display avail and list output in short
format.</p>

<p>--long, -l Display avail and list output in long
format.</p>

<p>--human, -h Display short output of the avail and list
commands in human readable format.</p>

<p>--verbose, -v Enable verbose messages during module
command execution.</p>

<p>--silent, -s Disable verbose messages. Redirect stderr
to /dev/null if stderr is found not to be a tty. This is a
useful option for module commands being written into .cshrc,
.login or .profile files, because some remote shells (as
rsh(1)) and remote execution commands (like rdist) get
confused if there is output on stderr.</p>

<p>--create, -c Create caches for module avail and module
apropos. You must be granted write access to the
${MODULEHOME}/modulefiles/ directory if you try to invoke
module with the -c option.</p>

<p>--icase, -i Case insensitive module parameter
evaluation. Currently only implemented for the module
apropos command.</p>

<p>--userlvl &lt;lvl&gt;, -u &lt;lvl&gt; Set the user level
to the specified value. The argument of this option may be
one of:</p>

<p>novice, nov Novice</p>

<p>expert, exp Experienced module user</p>

<p>advanced, adv Advanced module user</p>

<p>Module Sub-Commands help [modulefile...] Print the usage
of each sub-command. If an argument is given, print the
Module-specific help information for the modulefile(s).</p>

<p>add modulefile... load modulefile... Load modulefile(s)
into the shell environment.</p>

<p>rm modulefile... unload modulefile... Remove
modulefile(s) from the shell environment.</p>

<p>swap [modulefile1] modulefile2 switch [modulefile1]
modulefile2 Switch loaded modulefile1 with modulefile2. If
modulefile1 is not specified, then it is assumed to be the
currently loaded module with the same root name as
modulefile2.</p>

<p>show modulefile... display modulefile... Display
information about one or more modulefiles. The display
sub-command will list the full path of the modulefile(s) and
all (or most) of the environment changes the modulefile(s)
will make if loaded. (It will not display any environment
changes found within conditional statements.)</p>

<p>list List loaded modules.</p>

<p>avail [path...] List all available modulefiles in the
current MODULEPATH, where the sorting order is given by the
LC_COLLATE locale environment variable.</p>

<p>All directories in the MODULEPATH are recursively
searched for files containing the modulefile magic
cookie.</p>

<p>If an argument is given, then each directory in the
MODULEPATH is searched for modulefiles whose pathname match
the argument.</p>

<p>Multiple versions of an application can be supported by
creating a subdirectory for the application containing
modulefiles for each version.</p>

<p>use [-a|--append] directory... Prepend one or more
directories to the MODULEPATH environment variable. The
--append flag will append the directory to MODULEPATH.</p>

<p>unuse directory... Remove one or more directories from
the MODULEPATH environment variable.</p>

<p>update Attempt to reload all loaded modulefiles. The
environment will be reconfigured to match the environment
saved in ${HOME}/.modulesbeginenv (if BEGINENV=1) or the
file pointed at by $MODULESBEGINEV (if BEGINENV=99) and the
modulefiles will be reloaded. This is only valid if modules
was configured with --enable-beginenv (which defines
BEGINENV), otherwise this will cause a warning. update will
only change the environment variables that the modulefiles
set.</p>

<p>clear Force the Modules package to believe that no
modules are currently loaded.</p>

<p>purge Unload all loaded modulefiles.</p>

<p>refresh Force a refresh of all non-persistent components
of currently loaded modules. This should be used on derived
shells where aliases need to be reinitialized but the
environment variables have already been set by the currently
loaded modules.</p>

<p>whatis [modulefile...] Display the information set up by
the module- whatis commands inside the specified
modulefile(s). If no modulefile is specified, all whatis
lines will be shown.</p>

<p>apropos string keyword string Seeks through the whatis
informations of all modulefiles for the specified string.
All module-whatis informations matching the string will be
displayed.</p>

<p>initadd modulefile... Add modulefile(s) to the shell s
initialization file in the users home directory. The startup
files checked (in order) are: csh - .modules, .cshrc(.ext),
.csh_variables, and .login(.ext) tcsh - .modules, .tcshrc,
.cshrc(.ext), .csh_variables, and .login(.ext) sh and ksh -
.modules, .profile(.ext), and .kshenv(.ext) bash - .modules,
.bash_profile, .bash_login, .profile(.ext), and
.bashrc(.ext) zsh - .modules, .zcshrc(.ext), .zshenv(.ext),
and .zlogin(.ext)</p>

<p>If a module load line is found in any of these files,
the modulefile(s) is(are) appended to any existing list of
modulefiles. The module load line must be located in at
least one of the files listed above for any of the init
sub-commands to work properly. If the module load line is
found in multiple shell initialization files, all of the
lines are changed.</p>

<p>initprepend modulefile [modulefile...] Does the same as
initadd but prepends the given modules to the beginning of
the list.</p>

<p>initrm modulefile... Remove modulefile(s) from the
shells initialization files.</p>

<p>initswitch modulefile1 modulefile2 Switch modulefile1
with modulefile2 in the shells initialization files.</p>

<p>initlist List all of the modulefiles loaded from the
shells initialization file.</p>

<p>initclear Clear all of the modulefiles from the shells
initialization files.</p>

<p>Modulefiles modulefiles are written in the Tool Command
Language (Tcl) and are interpreted by modulecmd. modulefiles
can use conditional statements. Thus the effect a modulefile
will have on the environment may change depending upon the
current state of the environment.</p>

<p>Environment variables are unset when unloading a
modulefile. Thus, it is possible to load a modulefile and
then unload it without having the environment variables
return to their prior state.</p>

<p>ENVIRONMENT MODULESHOME The location of the master
Modules package file directory containing module command
initialization scripts, the executable program modulecmd,
and a directory containing a collection of master
modulefiles.</p>

<p>MODULEPATH The path that the module command searches
when looking for modulefiles. Typically, it is set to a
default value by the bootstrap procedure. MODULEPATH can be
set using module use or by the module initialization script
to search group or personal modulefile directories before or
after the master modulefile directory.</p>

<p>LOADEDMODULES A colon separated list of all loaded
modulefiles.</p>

<p>_LMFILES_ A colon separated list of the full pathname
for all loaded modulefiles.</p>

<p>MODULESBEGINENV If modules has been configured
(BEGINENV=99) to test for this environment variable, then if
it exists, it is the name of the file to store the the
initial shell environment. This environment variable will
have embedded environment variables unrolled to one level.
The contents of this variable is only used the first time
modules is invoked.</p>

<p>_MODULESBEGINENV_ The filename of the file containing
the initialization environment snapshot.</p>

<p>FILES /usr/share/Modules The MODULESHOME directory.</p>

<p>${MODULESHOME}/etc/rc The system-wide modules rc file.
The location of this file can be changed using the
MODULERCFILE environment variable as described above.</p>

<p>${HOME}/.modulerc The user specific modules rc file.</p>

<p>${MODULESHOME}/modulefiles The directory for system-wide
modulefiles. The location of the directory can be changed
using the MODULEPATH environment variable as described
above.</p>

<p>${MODULESHOME}/bin/modulecmd The modulefile interpreter
that gets executed upon each invocation of module.</p>

<p>${MODULESHOME}/init/&lt;shell&gt; The Modules package
initialization file sourced into the users environment.</p>

<p>${MODULEPATH}/.moduleavailcache File containing the
cached list of all modulefiles for each directory in the
MODULEPATH (only when the avail cache is enabled via the
configure option --enable-cache which sets CACHE_AVAIL).</p>

<p>${MODULEPATH}/.moduleavailcachedir File containing the
names and modification times for all sub- directories with
an avail cache (see above).</p>

<p>${HOME}/.modulesbeginenv A snapshot of the users
environment taken at Module initialization. This information
is used by the module update sub-command (if BEGINENV=1),
else</p>

<p>$MODULESBEGINENV If this defines a valid filename, it
serves the same purpose as above (if BEGINENV=99).</p>

<p>VERSION 3.2.10</p>

<p>SEE ALSO modulefile(4)</p>

<p>Modules version 3.2.10 July 2009 MODULE(1)</p>
<hr>
</body>
</html>
