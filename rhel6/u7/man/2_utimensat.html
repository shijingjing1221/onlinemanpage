<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:43:48 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>UTIMENSAT(2) Linux Programmer s Manual UTIMENSAT(2)</p>

<p>NAME utimensat, futimens - change file timestamps with
nanosecond precision</p>

<p>SYNOPSIS #include &lt;sys/stat.h&gt;</p>

<p>int utimensat(int dirfd, const char *pathname, const
struct timespec times[2], int flags);</p>

<p>int futimens(int fd, const struct timespec
times[2]);</p>

<p>Feature Test Macro Requirements for glibc (see
feature_test_macros(7)):</p>

<p>utimensat(): _ATFILE_SOURCE futimens(): _GNU_SOURCE /*
Will likely change after POSIX.1-2008 changes are
incorporated into glibc */</p>

<p>DESCRIPTION utimensat() and futimens() update the
timestamps of a file with nanosecond precision. This
contrasts with the historical utime(2) and utimes(2), which
permit only second and microsecond precision, respec-
tively, when setting file timestamps.</p>

<p>With utimensat() the file is specified via the pathname
given in path- name. With futimens() the file whose
timestamps are to be updated is specified via an open file
descriptor, fd.</p>

<p>For both calls, the new file timestamps are specified in
the array times: times[0] specifies the new &quot;last
access time&quot; (atime); times[1] specifies the new
&quot;last modification time&quot; (mtime). Each of the ele-
ments of times specifies a time in seconds and nanoseconds
since the Epoch (00:00:00, 1 Jan 1970, UTC), in a structure
of the following form:</p>

<p>struct timespec { time_t tv_sec; /* seconds */ long
tv_nsec; /* nanoseconds */ };</p>

<p>Updated file timestamps are set to the greatest value
supported by the file system that is not greater than the
specified time.</p>

<p>If the tv_nsec field of one of the timespec structures
has the special value UTIME_NOW, then the corresponding file
timestamp is set to the current time. If the tv_nsec field
of one of the timespec structures has the special value
UTIME_OMIT, then the corresponding file timestamp is left
unchanged. In both of these cases, the value of the corre-
sponding tv_sec field is ignored.</p>

<p>If times is NULL, then both timestamps are set to the
current time.</p>

<p>Permissions requirements To set both file timestamps to
the current time (i.e., times is NULL, or both tv_nsec
fields specify UTIME_NOW), either:</p>

<p>1. the caller must have write access to the file;</p>

<p>2. the callers effective user ID must match the owner of
the file; or</p>

<p>3. the caller must have appropriate privileges.</p>

<p>To make any change other than setting both timestamps to
the current time (i.e., times is not NULL, and both tv_nsec
fields are not UTIME_NOW and both tv_nsec fields are not
UTIME_OMIT), either condition 2 or 3 above must apply.</p>

<p>If both tv_nsec fields are specified as UTIME_OMIT, then
no file owner- ship or permission checks are performed, and
the file timestamps are not modified, but other error
conditions may still be detected.</p>

<p>utimensat() specifics If pathname is relative, then by
default it is interpreted relative to the directory referred
to by the open file descriptor, dirfd (rather than relative
to the current working directory of the calling process, as
is done by utimes(2) for a relative pathname). See openat(2)
for an explanation of why this can be useful.</p>

<p>If pathname is relative and dirfd is the special value
AT_FDCWD, then pathname is interpreted relative to the
current working directory of the calling process (like
utimes(2)).</p>

<p>If pathname is absolute, then dirfd is ignored.</p>

<p>The flags field is a bit mask that may be 0, or include
the following constant, defined in &lt;fcntl.h&gt;:</p>

<p>AT_SYMLINK_NOFOLLOW If pathname specifies a symbolic
link, then update the times- tamps of the link, rather than
the file to which it refers.</p>

<p>RETURN VALUE On success, utimensat() and futimens()
return 0. On error, -1 is returned and errno is set to
indicate the error.</p>

<p>ERRORS EACCES times is NULL, or both tv_nsec values are
UTIME_NOW, and: * the effective user ID of the caller does
not match the owner of the file, the caller does not have
write access to the file, and the caller is not privileged
(Linux: does not have either the CAP_FOWNER or the
CAP_DAC_OVERRIDE capability); or, * the file is marked
immutable (see chattr(1)).</p>

<p>EBADF (futimens()) fd is not a valid file
descriptor.</p>

<p>EBADF (utimensat()) pathname is a relative pathname, but
dirfd is nei- ther AT_FDCWD nor a valid file descriptor.</p>

<p>EFAULT times pointed to an invalid address; or, dirfd
was AT_FDCWD, and pathname is NULL or an invalid
address.</p>

<p>EINVAL Invalid value in flags.</p>

<p>EINVAL Invalid value in one of the tv_nsec fields (value
outside range 0 to 999,999,999, and not UTIME_NOW or
UTIME_OMIT); or an invalid value in one of the tv_sec
fields.</p>

<p>EINVAL pathname is NULL, dirfd is not AT_FDCWD, and
flags contains AT_SYMLINK_NOFOLLOW.</p>

<p>ELOOP (utimensat()) Too many symbolic links were
encountered in resolving pathname.</p>

<p>ENAMETOOLONG (utimensat()) pathname is too long.</p>

<p>ENOENT (utimensat()) A component of pathname does not
refer to an existing directory or file, or pathname is an
empty string.</p>

<p>ENOTDIR (utimensat()) pathname is a relative pathname,
but dirfd is nei- ther AT_FDCWD nor a file descriptor
referring to a directory; or, one of the prefix components
of pathname is not a directory.</p>

<p>EPERM The caller attempted to change one or both
timestamps to a value other than the current time, or to
change one of the timestamps to the current time while
leaving the other timestamp unchanged, (i.e., times is not
NULL, both tv_nsec fields are not UTIME_NOW, and both
tv_nsec fields are not UTIME_OMIT) and: * the callers
effective user ID does not match the owner of file, and the
caller is not privileged (Linux: does not have the
CAP_FOWNER capability); or, * the file is marked append-only
or immutable (see chattr(1)).</p>

<p>EROFS The file is on a read-only file system.</p>

<p>ESRCH (utimensat()) Search permission is denied for one
of the prefix components of pathname.</p>

<p>VERSIONS utimensat() was added to Linux in kernel
2.6.22; glibc support was added with version 2.6.</p>

<p>Support for futimens() first appeared in glibc 2.6.</p>

<p>CONFORMING TO futimens() and utimensat() are specified
in POSIX.1-2008.</p>

<p>NOTES utimensat() obsoletes futimesat(2).</p>

<p>On Linux, timestamps cannot be changed for a file marked
immutable, and the only change permitted for files marked
append-only is to set the timestamps to the current time.
(This is consistent with the histori- cal behavior of
utime(2) and utimes(2) on Linux.)</p>

<p>On Linux, futimens() is a library function implemented
on top of the utimensat() system call. To support this, the
Linux utimensat() system call implements a non-standard
feature: if pathname is NULL, then the call modifies the
timestamps of the file referred to by the file descriptor
dirfd (which may refer to any type of file). Using this
feature, the call futimens(fd, times) is implemented as:</p>

<p>utimensat(fd, NULL, times, 0);</p>

<p>BUGS Several bugs afflict utimensat() and futimens() on
kernels before 2.6.26. These bugs are either
non-conformances with the POSIX.1 draft specification or
inconsistencies with historical Linux behavior.</p>

<p>* POSIX.1 specifies that if one of the tv_nsec fields
has the value UTIME_NOW or UTIME_OMIT, then the value of the
corresponding tv_sec field should be ignored. Instead, the
value of the tv_sec field is required to be 0 (or the error
EINVAL results).</p>

<p>* Various bugs mean that for the purposes of permission
checking, the case where both tv_nsec fields are set to
UTIME_NOW isnt always treated the same as specifying times
as NULL, and the case where one tv_nsec value is UTIME_NOW
and the other is UTIME_OMIT isnt treated the same as
specifying times as a pointer to an array of structures
containing arbitrary time values. As a result, in some
cases: a) file timestamps can be updated by a process that
shouldn t have per- mission to perform updates; b) file
timestamps cant be updated by a process that should have
permission to perform updates; and c) the wrong errno value
is returned in case of an error.</p>

<p>* POSIX.1 says that a process that has write access to
the file can make a call with times as NULL, or with times
pointing to an array of structures in which both tv_nsec
fields are UTIME_NOW, in order to update both timestamps to
the current time. However, futimens() instead checks whether
the access mode of the file descriptor allows writing.</p>

<p>SEE ALSO chattr(1), futimesat(2), openat(2), stat(2),
utimes(2), futimes(3), path_resolution(7), symlink(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-09-29 UTIMENSAT(2)</p>
<hr>
</body>
</html>
