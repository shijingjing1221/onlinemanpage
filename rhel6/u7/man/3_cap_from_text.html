<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:06:46 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CAP_FROM_TEXT(3) Linux Programmer s Manual
CAP_FROM_TEXT(3)</p>

<p>NAME cap_from_text, cap_to_text, cap_to_name,
cap_from_name - capability state textual representation
translation</p>

<p>SYNOPSIS #include &lt;sys/capability.h&gt;</p>

<p>cap_t cap_from_text(const char *buf_p);</p>

<p>char *cap_to_text(cap_t caps, ssize_t *length_p);</p>

<p>int cap_from_name(const char *name, cap_value_t
*cap_p);</p>

<p>char *cap_to_name(cap_value_t cap);</p>

<p>Link with -lcap.</p>

<p>DESCRIPTION These functions translate a capability state
between an internal repre- sentation and a textual one. The
internal representation is managed by the capability
functions in working storage. The textual representation is
a structured, human-readable string suitable for
display.</p>

<p>cap_from_text() allocates and initializes a capability
state in working storage. It then sets the contents of this
newly created capability state to the state represented by a
human-readable, nul-terminated character string pointed to
by buf_p. It returns a pointer to the newly created
capability state. When the capability state in working
storage is no longer required, the caller should free any
releasable memory by calling cap_free() with cap_t as an
argument. The function returns an error if it cannot parse
the contents of the string pointed to by buf_p or does not
recognize any capability_name or flag character as valid.
The function also returns an error if any flag is both set
and cleared within a single clause.</p>

<p>cap_to_text() converts the capability state in working
storage identi- fied by cap_p into a nul-terminated
human-readable string. This func- tion allocates any memory
necessary to contain the string, and returns a pointer to
the string. If the pointer len_p is not NULL, the func- tion
shall also return the full length of the string (not
including the nul terminator) in the location pointed to by
len_p. The capability state in working storage, identified
by cap_p, is completely repre- sented in the character
string. When the capability state in working storage is no
longer required, the caller should free any releasable
memory by calling cap_free() with the returned string
pointer as an argument.</p>

<p>cap_from_name() converts a text representation of a
capability, such as &quot;cap_chown&quot;, to its numerical
representation (CAP_CHOWN=0), writing the decoded value into
*cap_p. If cap_p is NULL no result is written, but the
return code of the function indicates whether or not the
specified capability can be represented by the library.</p>

<p>cap_to_name() converts a capability index value, cap, to
a libcap-allo- cated textual string. This string should be
deallocated with cap_free().</p>

<p>TEXTUAL REPRESENTATION A textual representation of
capability sets consists of one or more whitespace-separated
clauses. Each clause specifies some operations on a
capability set; the set starts out with all capabilities
lowered, and the meaning of the string is the state of the
capability set after all the clauses have been applied in
order.</p>

<p>Each clause consists of a list of comma-separated
capability names (or the word all ), followed by an
action-list. An action-list consists of a sequence of
operator flag pairs. Legal operators are: =, +, and -. Legal
flags are: e, i, and p. These flags are case- sensitive and
specify the Effective, Inheritable and Permitted sets
respectively.</p>

<p>In the capability name lists, all names are
case-insensitive. The spe- cial name all specifies all
capabilities; it is equivalent to a list naming every
capability individually.</p>

<p>Unnamed capabilities can also be specified by number.
This feature ensures that libcap can support capabilities
that were not allocated at the time libcap was compiled.
However, generally upgrading libcap will add names for
recently allocated capabilities.</p>

<p>The = operator indicates that the listed capabilities
are first reset in all three capability sets. The subsequent
flags (which are optional when associated with this
operator) indicate that the listed capabili- ties for the
corresponding set are to be raised. For example:
&quot;all=p&quot; means lower every capability in the
Effective and Inheritable sets but raise all of the
Permitted capabilities; or, &quot;cap_fowner=ep&quot; means
raise the Effective and Permitted override-file-ownership
capability, while lowering this Inheritable capability.</p>

<p>In the case that the leading operator is =, and no list
of capabili- ties is provided, the action-list is assumed to
refer to all capabil- ities. For example, the following
three clauses are equivalent to each other (and indicate a
completely empty capability set): &quot;all=&quot;;
&quot;=&quot;;
&quot;cap_chown,&lt;every-other-capability&gt;=&quot;.</p>

<p>The operators, + and - both require an explicit
preceding capabil- ity list and one or more explicit
trailing flags. The + operator will raise all of the listed
capabilities in the flagged capability sets. The - operator
will lower all of the listed capabilities in the flagged
capability sets. For example: &quot;all+p&quot; will raise
all of the Permitted capabilities;
&quot;cap_fowner+p-i&quot; will raise the override-
file-ownership capability in the Permitted capability set
and lower this Inheritable capability;
&quot;cap_fowner+pe-i&quot; and &quot;cap_fowner=+pe&quot;
are equivalent.</p>

<p>RETURN VALUE cap_from_text(), cap_to_text() and
cap_to_text() return a non-NULL value on success, and NULL
on failure. cap_from_text() returns 0 for success, and -1 on
failure (unknown capability).</p>

<p>On failure, errno is set to EINVAL, or ENOMEM.</p>

<p>CONFORMING TO cap_from_text() and cap_to_text() are
specified by the withdrawn POSIX.1e draft specification.
cap_from_name() and cap_to_name() are Linux extensions.</p>

<p>EXAMPLE The example program below demonstrates the use
of cap_from_text() and cap_to_text(). The following shell
session shows a some example runs:</p>

<p>$ ./a.out &quot;cap_chown=p cap_chown+e&quot;
caps_to_text() returned &quot;= cap_chown+ep&quot; $ ./a.out
&quot;all=pe cap_chown-e cap_kill-pe&quot; caps_to_text()
returned &quot;=ep cap_chown-e cap_kill-ep&quot;</p>

<p>The source code of the program is as follows:</p>

<p>#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;
#include &lt;sys/capability.h&gt;</p>

<p>#define handle_error(msg) do { perror(msg);
exit(EXIT_FAILURE); } while (0)</p>

<p>int main(int argc, char *argv[]) { cap_t caps; char
*txt_caps;</p>

<p>if (argc != 2) { fprintf(stderr, &quot;%s
&lt;textual-cap-set&gt;0, argv[0]); exit(EXIT_FAILURE);
}</p>

<p>caps = cap_from_text(argv[1]); if (caps == NULL)
handle_error(&quot;cap_from_text&quot;);</p>

<p>txt_caps = cap_to_text(caps, NULL); if (txt_caps ==
NULL) handle_error(&quot;cap_to_text&quot;);</p>

<p>printf(&quot;caps_to_text() returned</p>

<p>if (cap_free(txt_caps) != 0 || cap_free(caps) != 0)
handle_error(&quot;cap_free&quot;);</p>

<p>exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO libcap(3), cap_clear(3), cap_compare(3),
cap_copy_ext(3), cap_get_file(3), cap_get_proc(3),
cap_init(3), capabilities(7)</p>

<p>2008-05-10 CAP_FROM_TEXT(3)</p>
<hr>
</body>
</html>
