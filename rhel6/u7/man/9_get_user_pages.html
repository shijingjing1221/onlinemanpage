<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GET_USER_PAGES(9) Memory Management in Linux
GET_USER_PAGES(9)</p>

<p>NAME get_user_pages - pin user pages in memory</p>

<p>SYNOPSIS int get_user_pages(struct task_struct * tsk,
struct mm_struct * mm, unsigned long start, int nr_pages,
int write, int force, struct page ** pages, struct
vm_area_struct ** vmas);</p>

<p>ARGUMENTS tsk the task_struct to use for page fault
accounting, or NULL if faults are not to be recorded.</p>

<p>mm mm_struct of target mm</p>

<p>start starting user address</p>

<p>nr_pages number of pages from start to pin</p>

<p>write whether pages will be written to by the caller</p>

<p>force whether to force write access even if user mapping
is readonly. This will result in the page being COWed even
in MAP_SHARED mappings. You do not want this.</p>

<p>pages array that receives pointers to the pages pinned.
Should be at least nr_pages long. Or NULL, if caller only
intends to ensure the pages are faulted in.</p>

<p>vmas array of pointers to vmas corresponding to each
page. Or NULL if the caller does not require them.</p>

<p>DESCRIPTION Returns number of pages pinned. This may be
fewer than the number requested. If nr_pages is 0 or
negative, returns 0. If no pages were pinned, returns
-errno. Each page returned must be released with a put_page
call when it is finished with. vmas will only remain valid
while mmap_sem is held.</p>

<p>Must be called with mmap_sem held for read or write.</p>

<p>get_user_pages walks a process&acute;s page tables and
takes a reference to each struct page that each user address
corresponds to at a given instant. That is, it takes the
page that would be accessed if a user thread accesses the
given user virtual address at that instant.</p>

<p>This does not guarantee that the page exists in the user
mappings when get_user_pages returns, and there may even be
a completely different page there in some cases (eg. if
mmapped pagecache has been invalidated and subsequently re
faulted). However it does guarantee that the page
won&acute;t be freed completely. And mostly callers simply
care that the page contains data that was valid *at some
point in time*. Typically, an IO or similar operation cannot
guarantee anything stronger anyway because locks can&acute;t
be held over the syscall boundary.</p>

<p>If write=0, the page must not be written to. If the page
is written to, set_page_dirty (or set_page_dirty_lock, as
appropriate) must be called after the page is finished with,
and before put_page is called.</p>

<p>get_user_pages is typically used for fewer-copy IO
operations, to get a handle on the memory by some means
other than accesses via the user virtual addresses. The
pages may be submitted for DMA to devices or accessed via
their kernel linear mapping (via the kmap APIs). Care should
be taken to use the correct cache flushing APIs.</p>

<p>See also get_user_pages_fast, for performance critical
applications.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
GET_USER_PAGES(9)</p>
<hr>
</body>
</html>
