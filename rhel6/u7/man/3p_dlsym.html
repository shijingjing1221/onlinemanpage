<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:10:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>DLSYM(3P) POSIX Programmer s Manual DLSYM(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME dlsym - obtain the address of a symbol from a
dlopen object</p>

<p>SYNOPSIS #include &lt;dlfcn.h&gt;</p>

<p>void *dlsym(void *restrict handle, const char *restrict
name);</p>

<p>DESCRIPTION The dlsym() function shall obtain the
address of a symbol defined within an object made accessible
through a dlopen() call. The handle argument is the value
returned from a call to dlopen() (and which has not since
been released via a call to dlclose()), and name is the sym-
bols name as a character string.</p>

<p>The dlsym() function shall search for the named symbol
in all objects loaded automatically as a result of loading
the object referenced by handle (see dlopen()). Load
ordering is used in dlsym() operations upon the global
symbol object. The symbol resolution algorithm used shall be
dependency order as described in dlopen().</p>

<p>The RTLD_DEFAULT and RTLD_NEXT flags are reserved for
future use.</p>

<p>RETURN VALUE If handle does not refer to a valid object
opened by dlopen(), or if the named symbol cannot be found
within any of the objects associated with handle, dlsym()
shall return NULL. More detailed diagnostic infor- mation
shall be available through dlerror() .</p>

<p>ERRORS No errors are defined.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES The following example shows how dlopen() and
dlsym() can be used to access either function or data
objects. For simplicity, error checking has been
omitted.</p>

<p>void *handle; int *iptr, (*fptr)(int);</p>

<p>/* open the needed object */ handle =
dlopen(&quot;/usr/home/me/libfoo.so&quot;, RTLD_LOCAL |
RTLD_LAZY);</p>

<p>/* find the address of function and data objects */
*(void **)(&amp;fptr) = dlsym(handle,
&quot;my_function&quot;); iptr = (int *)dlsym(handle,
&quot;my_object&quot;);</p>

<p>/* invoke function, passing value of integer as a
parameter */ (*fptr)(*iptr);</p>

<p>APPLICATION USAGE Special purpose values for handle are
reserved for future use. These values and their meanings
are:</p>

<p>RTLD_DEFAULT The symbol lookup happens in the normal
global scope; that is, a search for a symbol using this
handle would find the same defi- nition as a direct use of
this symbol in the program code.</p>

<p>RTLD_NEXT Specifies the next object after this one that
defines name. This one refers to the object containing the
invocation of dlsym(). The next object is the one found upon
the application of a load order symbol resolution algorithm
(see dlopen()). The next object is either one of global
scope (because it was intro- duced as part of the original
process image or because it was added with a dlopen()
operation including the RTLD_GLOBAL flag), or is an object
that was included in the same dlopen() operation that loaded
this one.</p>

<p>The RTLD_NEXT flag is useful to navigate an
intentionally created hier- archy of multiply-defined
symbols created through interposition. For example, if a
program wished to create an implementation of malloc() that
embedded some statistics gathering about memory allocations,
such an implementation could use the real malloc()
definition to perform the memory allocation-and itself only
embed the necessary logic to imple- ment the statistics
gathering function.</p>

<p>RATIONALE The ISO C standard does not require that
pointers to functions can be cast back and forth to pointers
to data. Indeed, the ISO C standard does not require that an
object of type void * can hold a pointer to a function.
Implementations supporting the XSI extension, however, do
require that an object of type void * can hold a pointer to
a function. The result of converting a pointer to a function
into a pointer to another data type (except void *) is still
undefined, however. Note that compilers conforming to the
ISO C standard are required to gener- ate a warning if a
conversion from a void * pointer to a function pointer is
attempted as in:</p>

<p>fptr = (int (*)(int))dlsym(handle,
&quot;my_function&quot;);</p>

<p>Due to the problem noted here, a future version may
either add a new function to return function pointers, or
the current interface may be deprecated in favor of two new
functions: one that returns data point- ers and the other
that returns function pointers.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO dlclose(), dlerror(), dlopen(), the Base
Definitions volume of IEEE Std 1003.1-2001,
&lt;dlfcn.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 DLSYM(3P)</p>
<hr>
</body>
</html>
