<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:23 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLRETUT(1) Perl Programmers Reference Guide
PERLRETUT(1)</p>

<p>NAME perlretut - Perl regular expressions tutorial</p>

<p>DESCRIPTION This page provides a basic tutorial on
understanding, creating and using regular expressions in
Perl. It serves as a complement to the reference page on
regular expressions perlre. Regular expressions are an
integral part of the &quot;m//&quot;, &quot;s///&quot;,
&quot;qr//&quot; and &quot;split&quot; operators and so this
tutorial also overlaps with &quot;Regexp Quote-Like
Operators&quot; in perlop and &quot;split&quot; in
perlfunc.</p>

<p>Perl is widely renowned for excellence in text
processing, and regular expressions are one of the big
factors behind this fame. Perl regular expressions display
an efficiency and flexibility unknown in most other computer
languages. Mastering even the basics of regular expressions
will allow you to manipulate text with surprising ease.</p>

<p>What is a regular expression? A regular expression is
simply a string that describes a pattern. Patterns are in
common use these days; examples are the patterns typed into
a search engine to find web pages and the patterns used to
list files in a directory, e.g., &quot;ls *.txt&quot; or
&quot;dir *.*&quot;. In Perl, the patterns described by
regular expressions are used to search strings, extract
desired parts of strings, and to do search and replace
operations.</p>

<p>Regular expressions have the undeserved reputation of
being abstract and difficult to understand. Regular
expressions are constructed using simple concepts like
conditionals and loops and are no more difficult to
understand than the corresponding &quot;if&quot;
conditionals and &quot;while&quot; loops in the Perl
language itself. In fact, the main challenge in learning
regular expressions is just getting used to the terse
notation used to express these concepts.</p>

<p>This tutorial flattens the learning curve by discussing
regular expression concepts, along with their notation, one
at a time and with many examples. The first part of the
tutorial will progress from the simplest word searches to
the basic regular expression concepts. If you master the
first part, you will have all the tools needed to solve
about 98% of your needs. The second part of the tutorial is
for those comfortable with the basics and hungry for more
power tools. It discusses the more advanced regular
expression operators and introduces the latest cutting edge
innovations in 5.6.0.</p>

<p>A note: to save time, regular expression is often
abbreviated as regexp or regex. Regexp is a more natural
abbreviation than regex, but is harder to pronounce. The
Perl pod documentation is evenly split on regexp vs regex;
in Perl, there is more than one way to abbreviate it. Well
use regexp in this tutorial.</p>

<p>Part 1: The basics Simple word matching The simplest
regexp is simply a word, or more generally, a string of
characters. A regexp consisting of a word matches any string
that contains that word:</p>

<p>&quot;Hello World&quot; =~ /World/; # matches</p>

<p>What is this Perl statement all about? &quot;Hello
World&quot; is a simple double quoted string.
&quot;World&quot; is the regular expression and the
&quot;//&quot; enclosing &quot;/World/&quot; tells Perl to
search a string for a match. The operator &quot;=~&quot;
associates the string with the regexp match and produces a
true value if the regexp matched, or false if the regexp did
not match. In our case, &quot;World&quot; matches the second
word in &quot;Hello World&quot;, so the expression is true.
Expressions like this are useful in conditionals:</p>

<p>if (&quot;Hello World&quot; =~ /World/) { print &quot;It
matches0; } else { print &quot;It doesn&rsquo;t match0;
}</p>

<p>There are useful variations on this theme. The sense of
the match can be reversed by using the &quot;!~&quot;
operator:</p>

<p>if (&quot;Hello World&quot; !~ /World/) { print &quot;It
doesn&rsquo;t match0; } else { print &quot;It matches0;
}</p>

<p>The literal string in the regexp can be replaced by a
variable:</p>

<p>$greeting = &quot;World&quot;; if (&quot;Hello
World&quot; =~ /$greeting/) { print &quot;It matches0; }
else { print &quot;It doesn&rsquo;t match0; }</p>

<p>If youre matching against the special default variable
$_, the &quot;$_ =~&quot; part can be omitted:</p>

<p>$_ = &quot;Hello World&quot;; if (/World/) { print
&quot;It matches0; } else { print &quot;It doesn&rsquo;t
match0; }</p>

<p>And finally, the &quot;//&quot; default delimiters for a
match can be changed to arbitrary delimiters by putting an
&rsquo;m&rsquo; out front:</p>

<p>&quot;Hello World&quot; =~ m!World!; # matches,
delimited by &rsquo;!&rsquo; &quot;Hello World&quot; =~
m{World}; # matches, note the matching &rsquo;{}&rsquo;
&quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches
after &rsquo;/usr/bin&rsquo;, # &rsquo;/&rsquo; becomes an
ordinary char</p>

<p>&quot;/World/&quot;, &quot;m!World!&quot;, and
&quot;m{World}&quot; all represent the same thing. When,
e.g., the quote (&quot;&quot;&quot;) is used as a delimiter,
the forward slash &rsquo;/&rsquo; becomes an ordinary
character and can be used in this regexp without
trouble.</p>

<p>Let s consider how different regexps would match
&quot;Hello World&quot;:</p>

<p>&quot;Hello World&quot; =~ /world/; # doesn&rsquo;t
match &quot;Hello World&quot; =~ /o W/; # matches
&quot;Hello World&quot; =~ /oW/; # doesn&rsquo;t match
&quot;Hello World&quot; =~ /World /; # doesn&rsquo;t
match</p>

<p>The first regexp &quot;world&quot; doesnt match because
regexps are case- sensitive. The second regexp matches
because the substring &rsquo;o W&rsquo; occurs in the string
&quot;Hello World&quot;. The space character is treated like
any other character in a regexp and is needed to match in
this case. The lack of a space character is the reason the
third regexp &rsquo;oW&rsquo; doesn t match. The fourth
regexp &rsquo;World &rsquo; doesnt match because there is a
space at the end of the regexp, but not at the end of the
string. The lesson here is that regexps must match a part of
the string exactly in order for the statement to be
true.</p>

<p>If a regexp matches in more than one place in the
string, Perl will always match at the earliest possible
point in the string:</p>

<p>&quot;Hello World&quot; =~ /o/; # matches
&rsquo;o&rsquo; in &rsquo;Hello&rsquo; &quot;That hat is
red&quot; =~ /hat/; # matches &rsquo;hat&rsquo; in
&rsquo;That&rsquo;</p>

<p>With respect to character matching, there are a few more
points you need to know about. First of all, not all
characters can be used as is in a match. Some characters,
called metacharacters, are reserved for use in regexp
notation. The metacharacters are</p>

<p>{}[]()^$.|*+? The significance of each of these will be
explained in the rest of the tutorial, but for now, it is
important only to know that a metacharacter can be matched
by putting a backslash before it:</p>

<p>&quot;2+2=4&quot; =~ /2+2/; # doesn&rsquo;t match, + is
a metacharacter &quot;2+2=4&quot; =~ /2+2/; # matches, + is
treated like an ordinary + &quot;The interval is
[0,1).&quot; =~ /[0,1)./ # is a syntax error! &quot;The
interval is [0,1).&quot; =~ / # matches
&quot;#!/usr/bin/perl&quot; =~ /#!usrbinperl/; # matches</p>

<p>In the last regexp, the forward slash &rsquo;/&rsquo; is
also backslashed, because it is used to delimit the regexp.
This can lead to LTS (leaning toothpick syndrome), however,
and it is often more readable to change delimiters.</p>

<p>&quot;#!/usr/bin/perl&quot; =~ m!#/usr/bin/perl!; #
easier to read</p>

<p>The backslash character &rsquo;&acute; is a
metacharacter itself and needs to be backslashed:</p>

<p>&rsquo;C:WIN32&rsquo; =~ /C:\WIN/; # matches</p>

<p>In addition to the metacharacters, there are some ASCII
characters which don t have printable character equivalents
and are instead represented by escape sequences. Common
examples are &quot;&quot; for a tab, &quot; for a carriage
return and &quot;&quot; for a &quot;0 for a newline, &quot;
bell. If your string is better thought of as a sequence of
arbitrary bytes, the octal escape sequence, e.g., &quot;
33&quot;, or hexadecimal escape sequence, e.g.,
&quot;B&quot; may be a more natural representation for your
bytes. Here are some examples of escapes:</p>

<p>&quot;10002000&quot; =~ m(02) # matches
&quot;10000000&quot; =~ /000/ # matches &quot;10002000&quot;
=~ / 002/ # doesn&rsquo;t match, &quot;0&quot; ne &quot;
00&quot; &quot;cat&quot; =~ /14314/ # matches, but a weird
way to spell cat</p>

<p>If youve been around Perl a while, all this talk of
escape sequences may seem familiar. Similar escape sequences
are used in double-quoted strings and in fact the regexps in
Perl are mostly treated as double- quoted strings. This
means that variables can be used in regexps as well. Just
like double-quoted strings, the values of the variables in
the regexp will be substituted in before the regexp is
evaluated for matching purposes. So we have:</p>

<p>$foo = &rsquo;house&rsquo;; &rsquo;housecat&rsquo; =~
/$foo/; # matches &rsquo;cathouse&rsquo; =~ /cat$foo/; #
matches &rsquo;housecat&rsquo; =~ /${foo}cat/; # matches</p>

<p>So far, so good. With the knowledge above you can
already perform searches with just about any literal string
regexp you can dream up. Here is a very simple emulation of
the Unix grep program:</p>

<p>% cat &gt; simple_grep #!/usr/bin/perl $regexp = shift;
while (&lt;&gt;) { print if /$regexp/; } ^D</p>

<p>% chmod +x simple_grep</p>

<p>% simple_grep abba /usr/dict/words Babbage cabbage
cabbages sabbath Sabbathize Sabbathizes sabbatical scabbard
scabbards</p>

<p>This program is easy to understand.
&quot;#!/usr/bin/perl&quot; is the standard way to invoke a
perl program from the shell. &quot;$regexp = shift;&quot;
saves the first command line argument as the regexp to be
used, leaving the rest of the command line arguments to be
treated as files. &quot;while (&lt;&gt;)&quot; loops over
all the lines in all the files. For each line, &quot;print
if /$regexp/;&quot; prints the line if the regexp matches
the line. In this line, both &quot;print&quot; and
&quot;/$regexp/&quot; use the default variable $_
implicitly.</p>

<p>With all of the regexps above, if the regexp matched
anywhere in the string, it was considered a match.
Sometimes, however, we d like to specify where in the string
the regexp should try to match. To do this, we would use the
anchor metacharacters &quot;^&quot; and &quot;$&quot;. The
anchor &quot;^&quot; means match at the beginning of the
string and the anchor &quot;$&quot; means match at the end
of the string, or before a newline at the end of the string.
Here is how they are used:</p>

<p>&quot;housekeeper&quot; =~ /keeper/; # matches
&quot;housekeeper&quot; =~ /^keeper/; # doesn&rsquo;t match
&quot;housekeeper&quot; =~ /keeper$/; # matches
&quot;housekeeper0 =~ /keeper$/; # matches</p>

<p>The second regexp doesn t match because &quot;^&quot;
constrains &quot;keeper&quot; to match only at the beginning
of the string, but &quot;housekeeper&quot; has keeper
starting in the middle. The third regexp does match, since
the &quot;$&quot; constrains &quot;keeper&quot; to match
only at the end of the string.</p>

<p>When both &quot;^&quot; and &quot;$&quot; are used at
the same time, the regexp has to match both the beginning
and the end of the string, i.e., the regexp matches the
whole string. Consider</p>

<p>&quot;keeper&quot; =~ /^keep$/; # doesn&rsquo;t match
&quot;keeper&quot; =~ /^keeper$/; # matches &quot;&quot; =~
/^$/; # ^$ matches an empty string</p>

<p>The first regexp doesnt match because the string has
more to it than &quot;keep&quot;. Since the second regexp is
exactly the string, it matches. Using both &quot;^&quot; and
&quot;$&quot; in a regexp forces the complete string to
match, so it gives you complete control over which strings
match and which dont. Suppose you are looking for a fellow
named bert, off in a string by himself:</p>

<p>&quot;dogbert&quot; =~ /bert/; # matches, but not what
you want</p>

<p>&quot;dilbert&quot; =~ /^bert/; # doesn&rsquo;t match,
but .. &quot;bertram&quot; =~ /^bert/; # matches, so still
not good enough</p>

<p>&quot;bertram&quot; =~ /^bert$/; # doesn&rsquo;t match,
good &quot;dilbert&quot; =~ /^bert$/; # doesn&rsquo;t match,
good &quot;bert&quot; =~ /^bert$/; # matches, perfect</p>

<p>Of course, in the case of a literal string, one could
just as easily use the string comparison &quot;$string eq
&rsquo;bert&rsquo;&quot; and it would be more efficient. The
&quot;^...$&quot; regexp really becomes useful when we add
in the more powerful regexp tools below.</p>

<p>Using character classes Although one can already do
quite a lot with the literal string regexps above, we ve
only scratched the surface of regular expression technology.
In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will
allow a regexp to not just represent a single character
sequence, but a whole class of them.</p>

<p>One such concept is that of a character class. A
character class allows a set of possible characters, rather
than just a single character, to match at a particular point
in a regexp. Character classes are denoted by brackets
&quot;[...]&quot;, with the set of characters to be possibly
matched inside. Here are some examples:</p>

<p>/cat/; # matches &rsquo;cat&rsquo; /[bcr]at/; # matches
&rsquo;bat, &rsquo;cat&rsquo;, or &rsquo;rat&rsquo;
/item[0123456789]/; # matches &rsquo;item0&rsquo; or ... or
&rsquo;item9&rsquo; &quot;abc&quot; =~ /[cab]/; # matches
&rsquo;a&rsquo;</p>

<p>In the last statement, even though &rsquo;c&rsquo; is
the first character in the class, &rsquo;a&rsquo; matches
because the first character position in the string is the
earliest point at which the regexp can match.</p>

<p>/[yY][eE][sS]/; # match &rsquo;yes&rsquo; in a
case-insensitive way # &rsquo;yes&rsquo;, &rsquo;Yes&rsquo;,
&rsquo;YES&rsquo;, etc.</p>

<p>This regexp displays a common task: perform a
case-insensitive match. Perl provides a way of avoiding all
those brackets by simply appending an &rsquo;i&rsquo; to the
end of the match. Then &quot;/[yY][eE][sS]/;&quot; can be
rewritten as &quot;/yes/i;&quot;. The &rsquo;i&rsquo; stands
for case-insensitive and is an example of a modifier of the
matching operation. We will meet other modifiers later in
the tutorial.</p>

<p>We saw in the section above that there were ordinary
characters, which represented themselves, and special
characters, which needed a backslash &quot; class, but the
sets of ordinary and special characters inside a character
class are different than those outside a character class.
The special characters for a character class are
&quot;-]$&quot; (and the pattern delimiter, whatever it is).
&quot;]&quot; is special because it denotes the end of a
character class. &quot;$&quot; is special because it denotes
a scalar variable. &quot; sequences, just like above. Here
is how the special characters &quot;]$ are handled:</p>

<p>/[]c]def/; # matches &rsquo;]def&rsquo; or
&rsquo;cdef&rsquo; $x = &rsquo;bcr&rsquo;; /[$x]at/; #
matches &rsquo;bat&rsquo;, &rsquo;cat&rsquo;, or
&rsquo;rat&rsquo; /[]at/; # matches &rsquo;$at&rsquo; or
&rsquo;xat&rsquo; /[\$x]at/; # matches &rsquo;t&rsquo;,
&rsquo;bat, &rsquo;cat&rsquo;, or &rsquo;rat&rsquo;</p>

<p>The last two are a little tricky. In &quot;[]&quot;, the
backslash protects the dollar sign, so the character class
has two members &quot;$&quot; and &quot;x&quot;. In
&quot;[\$x]&quot;, the backslash is protected, so $x is
treated as a variable and substituted in double quote
fashion.</p>

<p>The special character &rsquo;-&rsquo; acts as a range
operator within character classes, so that a contiguous set
of characters can be written as a range. With ranges, the
unwieldy &quot;[0123456789]&quot; and
&quot;[abc...xyz]&quot; become the svelte &quot;[0-9]&quot;
and &quot;[a-z]&quot;. Some examples are</p>

<p>/item[0-9]/; # matches &rsquo;item0&rsquo; or ... or
&rsquo;item9&rsquo; /[0-9bx-z]aa/; # matches
&rsquo;0aa&rsquo;, ..., &rsquo;9aa&rsquo;, #
&rsquo;baa&rsquo;, &rsquo;xaa&rsquo;, &rsquo;yaa&rsquo;, or
&rsquo;zaa&rsquo; /[0-9a-fA-F]/; # matches a hexadecimal
digit /[0-9a-zA-Z_]/; # matches a &quot;word&quot;
character, # like those in a Perl variable name</p>

<p>If &rsquo;-&rsquo; is the first or last character in a
character class, it is treated as an ordinary character;
&quot;[-ab]&quot;, &quot;[ab-]&quot; and
&quot;[a&minus;b]&quot; are all equivalent.</p>

<p>The special character &quot;^&quot; in the first
position of a character class denotes a negated character
class, which matches any character but those in the
brackets. Both &quot;[...]&quot; and &quot;[^...]&quot; must
match a character, or the match fails. Then</p>

<p>/[^a]at/; # doesn&rsquo;t match &rsquo;aat&rsquo; or
&rsquo;at&rsquo;, but matches # all other &rsquo;bat&rsquo;,
&rsquo;cat, &rsquo;0at&rsquo;, &rsquo;%at&rsquo;, etc.
/[^0-9]/; # matches a non-numeric character /[a^]at/; #
matches &rsquo;aat&rsquo; or &rsquo;^at&rsquo;; here
&rsquo;^&rsquo; is ordinary</p>

<p>Now, even &quot;[0-9]&quot; can be a bother to write
multiple times, so in the interest of saving keystrokes and
making regexps more readable, Perl has several abbreviations
for common character classes, as shown below. Since the
introduction of Unicode, these character classes match more
than just a few characters in the ISO 8859-1 range.</p>

<p>&middot; matches a digit, not just [0-9] but also digits
from non-roman scripts</p>

<p>0f] and &middot; matches a whitespace character, the set
[ others</p>

<p>&middot; 168a word character (alphanumeric or _), not
just [0-9a-zA-Z_] but also digits and characters from
non-roman scripts</p>

<p>&middot; a negated ; it represents any other character
than a digit, or [^]</p>

<p>&middot; is a negated t represents any non-whitespace
character [^ &middot; W is a negated 984</p>

<p>&middot; The period . matches any character but &quot;0
(unless the modifier &quot;//s&quot; is in effect, as
explained below).</p>

<p>The &quot; <small>88 character classes. Here are some in
use:</small></p>

<p><small>/::/; # matches a hh:mm:ss time format /[ #
matches any digit or whitespace character /96 # non-word
char, followed by a word char /..rt/; # matches any two
chars, followed by &rsquo;rt&rsquo; /end./; # matches
&rsquo;end.&rsquo; /end[.]/; # same thing, matches
&rsquo;end.&rsquo;</small></p>

<p><small>Because a period is a metacharacter, it needs to
be escaped to match as an ordinary period. Because, for
example, &quot;&quot; and &quot;288 characters, it is
incorrect to think of &quot;[^480 DeMorgans
laws.</small></p>

<p><small>. T An anchor useful in basic regexps is the _
word anchor &quot;h i s matches a boundary between a word
character and a non-word character &quot;14424</small></p>

<p><small>$x = &quot;Housecat catenates house and
cat&quot;; $x =~ /cat/; # matches cat in
&rsquo;housecat&rsquo; a t / ; $x =~ /# hes cat in
&rsquo;catenates&rsquo; m a t ; # m a t c h e s c a t $x =~
/cati n &rsquo; h o u s e c a t &rsquo; a $x =~
/t</small></p>

<p><small>Note in the last example, the end of the string
is considered a word boundary.</small></p>

<p><small>You might wonder why &rsquo;.&rsquo; matches
everything but &quot;0 - why not every character? The reason
is that often one is matching against lines and would like
to ignore the newline characters. For instance, while the
string &quot;0 represents one line, we would like to think
of it as empty. Then</small></p>

<p><small>&quot;&quot; =~ /^$/; # matches &quot;0 =~ /^$/;
# matches, $ anchors before &quot;0</small></p>

<p><small>&quot;&quot; =~ /./; # doesn&rsquo;t match; it
needs a char &quot;&quot; =~ /^.$/; # doesn&rsquo;t match;
it needs a char &quot;0 =~ /^.$/; # doesn&rsquo;t match; it
needs a char other than &quot;0 &quot;a&quot; =~ /^.$/; #
matches &quot;a0 =~ /^.$/; # matches, $ anchors before
&quot;0</small></p>

<p><small>This behavior is convenient, because we usually
want to ignore newlines when we count and match characters
in a line. Sometimes, however, we want to keep track of
newlines. We might even want &quot;^&quot; and &quot;$&quot;
to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the
string. Perl allows us to choose between ignoring and paying
attention to newlines by using the &quot;//s&quot; and
&quot;//m&quot; modifiers. &quot;//s&quot; and
&quot;//m&quot; stand for single line and multi- line and
they determine whether a string is to be treated as one
continuous string, or as a set of lines. The two modifiers
affect two aspects of how the regexp is interpreted: 1) how
the &rsquo;.&rsquo; character class is defined, and 2) where
the anchors &quot;^&quot; and &quot;$&quot; are able to
match. Here are the four possible combinations:</small></p>

<p><small>&middot; no modifiers (//): Default behavior.
&rsquo;.&rsquo; matches any character except &quot;0.
&quot;^&quot; matches only at the beginning of the string
and &quot;$&quot; matches only at the end or before a
newline at the end.</small></p>

<p><small>&middot; s modifier (//s): Treat string as a
single long line. &rsquo;.&rsquo; matches any character,
even &quot;0. &quot;^&quot; matches only at the beginning of
the string and &quot;$&quot; matches only at the end or
before a newline at the end.</small></p>

<p><small>&middot; m modifier (//m): Treat string as a set
of multiple lines. &rsquo;.&rsquo; matches any character
except &quot;0. &quot;^&quot; and &quot;$&quot; are able to
match at the start or end of _ any line within the
string.</small></p>

<p><small>&middot; both s and m modifiers (//sm): Treat
string as a single long line, but detect multiple lines.
&rsquo;.&rsquo; matches any character, even &quot;0.
&quot;^&quot; and &quot;$&quot;, however, are able to match
at the start or end of _any line within the
string.</small></p>

<p><small>Here are examples of &quot;//s&quot; and
&quot;//m&quot; in action:</small></p>

<p><small>$x = &quot;There once was a girl0ho programmed in
Perl0;</small></p>

<p><small>$x =~ /^Who/; # doesn&rsquo;t match,
&quot;Who&quot; not at start of string $x =~ /^Who/s; #
doesn&rsquo;t match, &quot;Who&quot; not at start of string
$x =~ /^Who/m; # matches, &quot;Who&quot; at start of second
line $x =~ /^Who/sm; # matches, &quot;Who&quot; at start of
second line</small></p>

<p><small>$x =~ /girl.Who/; # doesn&rsquo;t match,
&quot;.&quot; doesn&rsquo;t match &quot;0 $x =~ /girl.Who/s;
# matches, &quot;.&quot; matches &quot;0 $x =~ /girl.Who/m;
# doesn&rsquo;t match, &quot;.&quot; doesn&rsquo;t match
&quot;0 $x =~ /girl.Who/sm; # matches, &quot;.&quot; matches
&quot;0</small></p>

<p><small>Most of the time, the default behavior is what is
wanted, but &quot;//s&quot; and &quot;//m&quot; are
occasionally very useful. If &quot;//m&quot; is being used,
the start of the string can still be matched with &quot;0
can still be matched with the anchors &quot; (matches both
the newlineend anthe before, like &quot;$&quot;), and
&quot;&quot;(matches only the end):</small></p>

<p><small>$x =~ /^Who/m; # matches, &quot;Who&quot; at
start of second line $x =~ /0ho&quot; is not at start of
string</small></p>

<p><small>$x =~ /girl$/m; # matches, &quot;girl&quot; at
end of first line $x =~ /girlm; # doesn&rsquo;t match,
&quot;girl&quot; is not at end of string $x =~ /Perlm; #
matches, &quot;Perl&quot;=~ is/Perlm;at newline#
doesn&rsquo;tbefore en$x match, &quot;Perl&quot; is not at
end of string</small></p>

<p><small>We now know how to create choices among classes
of characters in a regexp. What about choices among words or
character strings? Such choices are described in the next
section.</small></p>

<p><small>Matching this or that Sometimes we would like our
regexp to be able to match different possible words or
character strings. This is accomplished by using the
alternation metacharacter &quot;|&quot;. To match
&quot;dog&quot; or &quot;cat&quot;, we form the regexp
&quot;dog|cat&quot;. As before, Perl will try to match the
regexp at the earliest possible point in the string. At each
character position, Perl will first try to match the first
alternative, &quot;dog&quot;. If &quot;dog&quot; doesn t
match, Perl will then try the next alternative,
&quot;cat&quot;. If &quot;cat&quot; doesnt match either,
then the match fails and Perl moves to the next position in
the string. Some examples:</small></p>

<p><small>&quot;cats and dogs&quot; =~ /cat|dog|bird/; #
matches &quot;cat&quot; &quot;cats and dogs&quot; =~
/dog|cat|bird/; # matches &quot;cat&quot;</small></p>

<p><small>Even though &quot;dog&quot; is the first
alternative in the second regexp, &quot;cat&quot; is able to
match earlier in the string.</small></p>

<p><small>&quot;cats&quot; =~ /c|ca|cat|cats/; # matches
&quot;c&quot; &quot;cats&quot; =~ /cats|cat|ca|c/; # matches
&quot;cats&quot;</small></p>

<p><small>Here, all the alternatives match at the first
string position, so the first alternative is the one that
matches. If some of the alternatives are truncations of the
others, put the longest ones first to give them a chance to
match.</small></p>

<p><small>&quot;cab&quot; =~ /a|b|c/ # matches
&quot;c&quot; # /a|b|c/ == /[abc]/</small></p>

<p><small>The last example points out that character
classes are like alternations of characters. At a given
character position, the first alternative that allows the
regexp match to succeed will be the one that
matches.</small></p>

<p><small>Grouping things and hierarchical matching
Alternation allows a regexp to choose among alternatives,
but by itself it is unsatisfying. The reason is that each
alternative is a whole regexp, but sometime we want
alternatives for just part of a regexp. For instance,
suppose we want to search for housecats or housekeepers. The
regexp &quot;housecat|housekeeper&quot; fits the bill, but
is inefficient because we had to type &quot;house&quot;
twice. It would be nice to have parts of the regexp be
constant, like &quot;house&quot;, and some parts have
alternatives, like &quot;cat|keeper&quot;.</small></p>

<p><small>The _grouping metacharacters &quot;()&quot; solve
this problem. Grouping allows parts of a regexp to be
treated as a single unit. Parts of a regexp are grouped by
enclosing them in parentheses. Thus we could solve the
&quot;housecat|housekeeper&quot; by forming the regexp as
&quot;house(cat|keeper)&quot;. The regexp
&quot;house(cat|keeper)&quot; means match &quot;house&quot;
followed by either &quot;cat&quot; or &quot;keeper&quot;.
Some more examples are</small></p>

<p><small>/(a|b)b/; # matches &rsquo;ab&rsquo; or
&rsquo;bb&rsquo; /(ac|b)b/; # matches &rsquo;acb&rsquo; or
&rsquo;bb&rsquo; /(^a|b)c/; # matches &rsquo;ac&rsquo; at
start of string or &rsquo;bc&rsquo; anywhere /(a|[bc])d/; #
matches &rsquo;ad&rsquo;, &rsquo;bd&rsquo;, or
&rsquo;cd&rsquo;</small></p>

<p><small>/house(cat|)/; # matches either
&rsquo;housecat&rsquo; or &rsquo;house&rsquo;
/house(cat(s|)|)/; # matches either &rsquo;housecats&rsquo;
or &rsquo;housecat&rsquo; or # &rsquo;house&rsquo;. Note
groups can be nested.</small></p>

<p><small>/(19|20|)/; # match years 19xx, 20xx, or the Y2K
problem, xx &quot;20&quot; =~ /(19|20|)/; # matches the null
alternative &rsquo;()&rsquo;, # because &rsquo;20&rsquo;
can&rsquo;t match</small></p>

<p><small>Alternations behave the same way in groups as out
of them: at a given string position, the leftmost
alternative that allows the regexp to match is taken. So in
the last example at the first string position,
&quot;20&quot; matches the second alternative, but there is
nothing left over to match the next two digits &quot;&quot;.
So Perl moves on to the next alternative, which is the null
alternative and that works, since &quot;20&quot; is two
digits.</small></p>

<p><small>The process of trying one alternative, seeing if
it matches, and moving on to the next alternative, while
going back in the string from where the previous alternative
was tried, if it doesn t, is called backtracking. The term
backtracking comes from the idea that matching a regexp is
like a walk in the woods. Successfully matching a regexp is
like arriving at a destination. There are many possible
trailheads, one for each string position, and each one is
tried in order, left to right. From each trailhead there may
be many paths, some of which get you there, and some which
are dead ends. When you walk along a trail and hit a dead
end, you have to backtrack along the trail to an earlier
point to try another trail. If you hit your destination, you
stop immediately and forget about trying all the other
trails. You are persistent, and only if you have tried all
the trails from all the trailheads and not arrived at your
destination, do you declare failure. To be concrete, here is
a step-by-step analysis of what Perl does when it tries to
match the regexp</small></p>

<p><small>&quot;abcde&quot; =~
/(abd|abc)(df|d|de)/;</small></p>

<p><small>0 Start with the first letter in the string
a.</small></p>

<p><small>1 Try the first alternative in the first group
abd.</small></p>

<p><small>2 Match a followed by b. So far so
good.</small></p>

<p><small>3 d in the regexp doesnt match c in the string -
a dead end. So backtrack two characters and pick the second
alternative in the first group abc.</small></p>

<p><small>4 Match a followed by b followed by c. We are on
a roll and have satisfied the first group. Set $1 to
abc.</small></p>

<p><small>5 Move on to the second group and pick the first
alternative df.</small></p>

<p><small>6 Match the d.</small></p>

<p><small>7 f in the regexp doesnt match e in the string,
so a dead end. Backtrack one character and pick the second
alternative in the second group d.</small></p>

<p><small>8 d matches. The second grouping is satisfied, so
set $2 to d.</small></p>

<p><small>9 We are at the end of the regexp, so we are
done! We have matched abcd out of the string
&quot;abcde&quot;.</small></p>

<p><small>There are a couple of things to note about this
analysis. First, the third alternative in the second group
de also allows a match, but we stopped before we got to it -
at a given character position, leftmost wins. Second, we
were able to get a match at the first character position of
the string a. If there were no matches at the first
position, Perl would move to the second character position b
and attempt the match all over again. Only when all possible
paths at all possible character positions have been
exhausted does Perl give up and declare &quot;$string =~
/(abd|abc)(df|d|de)/;&quot; to be false.</small></p>

<p><small>Even with all this work, regexp matching happens
remarkably fast. To speed things up, Perl compiles the
regexp into a compact sequence of opcodes that can often fit
inside a processor cache. When the code is executed, these
opcodes can then run at full throttle and search very
quickly.</small></p>

<p><small>Extracting matches The grouping metacharacters
&quot;()&quot; also serve another completely different
function: they allow the extraction of the parts of a string
that matched. This is very useful to find out what matched
and for text processing in general. For each grouping, the
part that matched inside goes into the special variables $1,
$2, etc. They can be used just as ordinary
variables:</small></p>

<p><small># extract hours, minutes, seconds if ($time =~
/():():()/) { # match hh:mm:ss format $hours = $1; $minutes
= $2; $seconds = $3; }</small></p>

<p><small>Now, we know that in scalar context, &quot;$time
=~ /():():()/&quot; returns a true or false value. In list
context, however, it returns the list of matched values
&quot;($1,$2,$3)&quot;. So we could write the code more
compactly as</small></p>

<p><small># extract hours, minutes, seconds ($hours,
$minutes, $second) = ($time =~ /():():()/);</small></p>

<p><small>If the groupings in a regexp are nested, $1 gets
the group with the leftmost opening parenthesis, $2 the next
opening parenthesis, etc. Here is a regexp with nested
groups:</small></p>

<p><small>/(ab(cd|ef)((gi)|j))/; 1 2 34</small></p>

<p><small>If this regexp matches, $1 contains a string
starting with &rsquo;ab&rsquo;, $2 is either set to
&rsquo;cd&rsquo; or &rsquo;ef&rsquo;, $3 equals either
&rsquo;gi&rsquo; or &rsquo;j&rsquo;, and $4 is either set to
&rsquo;gi&rsquo;, just like $3, or it remains
undefined.</small></p>

<p><small>For convenience, Perl sets $+ to the string held
by the highest numbered $1, $2,... that got assigned (and,
somewhat related, $^N to the value of the $1, $2,...
most-recently assigned; i.e. the $1, $2,... associated with
the rightmost closing parenthesis used in the
match).</small></p>

<p><small>Backreferences Closely associated with the
matching variables $1, $2, ... are the backreferences
&quot;1&quot;, &quot;2&quot;,... Backreferences are simply
matching variables that can be used _ inside a regexp. This
is a really nice feature -- what matches later in a regexp
is made to depend on what matched earlier in the regexp.
Suppose we wanted to look for doubled words in a text, like
the the. The following regexp finds all 3-letter doubles
with a space in between:</small></p>

<p><small>/0</small></p>

<p><small>The grouping assigns a value to 1, so that the
same 3 letter sequence is used for both parts.</small></p>

<p><small>A similar task is to find words consisting of two
identical parts:</small></p>

<p><small>% simple_grep &rsquo;^(24 beriberi booboo coco
mama murmur papa</small></p>

<p><small>The regexp has a single grouping which considers
4-letter combinations, then 3-letter combinations, etc., and
uses &quot;1&quot; to look for a repeat. Although $1 and
&quot;1&quot; represent the same thing, care should be taken
to use matched variables $1, $2,... only _ outside a regexp
and backreferences &quot;1&quot;, &quot;2&quot;,... only _
inside a regexp; not doing so may lead to surprising and
unsatisfactory results.</small></p>

<p><small>Relative backreferences Counting the opening
parentheses to get the correct number for a backreference is
errorprone as soon as there is more than one capturing
group. A more convenient technique became available with
Perl 5.10: relative backreferences. To refer to the
immediately preceding capture group one now may write
&quot;-1}&quot;, the next but last is available via
&quot;-2}&quot;, and so on.</small></p>

<p><small>Another good reason in addition to readability
and maintainability for using relative backreferences is
illustrated by the following example, where a simple pattern
for matching peculiar strings is used:</small></p>

<p><small>$a99a = &rsquo;([a-z])()21&rsquo;; # matches
a11a, g22g, x33x, etc.</small></p>

<p><small>Now that we have this pattern stored as a handy
string, we might feel tempted to use it as a part of some
other pattern:</small></p>

<p><small>$line = &quot;code=e99e&quot;; if ($line =~
/^(864 print &quot;$1 is valid0; } else { print &quot;bad
line: &rsquo;$line&rsquo;0; }</small></p>

<p><small>But this doesn t match -- at least not the way
one might expect. Only after inserting the interpolated
$a99a and looking at the resulting full text of the regexp
is it obvious that the backreferences have backfired -- the
subexpression &quot;(672 demoted the groups in $a99a by one
rank. This can be avoided by using relative
backreferences:</small></p>

<p><small>$a99a = &rsquo;([a-z])()-1}-2}&rsquo;; # safe for
being interpolated</small></p>

<p><small>Named backreferences Perl 5.10 also introduced
named capture buffers and named backreferences. To attach a
name to a capturing group, you write either
&quot;(?&lt;name&gt;...)&quot; or
&quot;(?&rsquo;name&rsquo;...)&quot;. The backreference may
then be written as &quot;name}&quot;. It is permissible to
attach the same name to more than one group, but then only
the leftmost one of the eponymous set can be referenced.
Outside of the pattern a named capture buffer is accessible
through the &quot;%+&quot; hash.</small></p>

<p><small>Assuming that we have to match calendar dates
which may be given in one of the three formats yyyy-mm-dd,
mm/dd/yyyy or dd.mm.yyyy, we can write three suitable
patterns where we use d , m and y respectively as the names
of the buffers capturing the pertaining components of a
date. The matching operation combines the three patterns as
alternatives:</small></p>

<p><small>$fmt1 =
&rsquo;(?&lt;y&gt;)-(?&lt;m&gt;)-(?&lt;d&gt;)&rsquo;; $fmt2
= &rsquo;(?&lt;m&gt;)/(?&lt;d&gt;)/(?&lt;y&gt;)&rsquo;;
$fmt3 =
&rsquo;(?&lt;d&gt;).(?&lt;m&gt;).(?&lt;y&gt;)&rsquo;; for my
$d qw( 2006-10-21 15.01.2007 10/31/2005 ){ if ( $d =~
m{$fmt1|$fmt2|$fmt3} ){ print &quot;day=$+{d} month=$+{m}
year=$+{y}0; } }</small></p>

<p><small>If any of the alternatives matches, the hash
&quot;%+&quot; is bound to contain the three key-value
pairs.</small></p>

<p><small>Alternative capture group numbering Yet another
capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set
of alternatives. Consider a pattern for matching a time of
the day, civil or military style:</small></p>

<p><small>if ( $time =~ /(|):()|()()/ ){ # process hour and
minute }</small></p>

<p><small>Processing the results requires an additional if
statement to determine whether $1 and $2 or $3 and $4
contain the goodies. It would be easier if we could use
buffer numbers 1 and 2 in second alternative as well, and
this is exactly what the parenthesized construct
&quot;(?|...)&quot;, set around an alternative achieves.
Here is an extended version of the previous
pattern:</small></p>

<p><small>if ( $time =~ /(?|(|):()|()())A-Z][A-Z][A-Z])/ ){
print &quot;hour=$1 minute=$2 zone=$30; }</small></p>

<p><small>Within the alternative numbering group, buffer
numbers start at the same position for each alternative.
After the group, numbering continues with one higher than
the maximum reached across all the alternatives.</small></p>

<p><small>Position information In addition to what was
matched, Perl (since 5.6.0) also provides the positions of
what was matched as contents of the &quot;@-&quot; and
&quot;@+&quot; arrays. &quot;$-[0]&quot; is the position of
the start of the entire match and $+[0] is the position of
the end. Similarly, &quot;$-[n]&quot; is the position of the
start of the $n match and $+[n] is the position of the end.
If $n is undefined, so are &quot;$-[n]&quot; and $+[n]. Then
this code</small></p>

<p><small>$x = &quot;Mmm...donut, thought Homer&quot;; $x
=~ /^(Mmm|Yech)...(donut|peas)/; # matches foreach $expr
(1..$#-) { print &quot;Match $expr: &rsquo;${$expr}&rsquo;
at position ($-[$expr],$+[$expr])0; }</small></p>

<p><small>prints</small></p>

<p><small>Match 1: &rsquo;Mmm&rsquo; at position (0,3)
Match 2: &rsquo;donut&rsquo; at position (6,11)</small></p>

<p><small>Even if there are no groupings in a regexp, it is
still possible to find out what exactly matched in a string.
If you use them, Perl will set &quot;$&lsquo;&quot; to the
part of the string before the match, will set $&amp; to the
part of the string that matched, and will set
&quot;$&rsquo;&quot; to the part of the string after the
match. An example:</small></p>

<p><small>$x = &quot;the cat caught the mouse&quot;; $x =~
/cat/; # $&lsquo; = &rsquo;the &rsquo;, $&amp; =
&rsquo;cat&rsquo;, $&rsquo; = &rsquo; caught the
mouse&rsquo; $x =~ /the/; # $&lsquo; = &rsquo;&rsquo;,
$&amp; = &rsquo;the&rsquo;, $&rsquo; = &rsquo; cat caught
the mouse&rsquo;</small></p>

<p><small>In the second match, &quot;$&lsquo;&quot; equals
&rsquo;&rsquo; because the regexp matched at the first
character position in the string and stopped; it never saw
the second the. It is important to note that using
&quot;$&lsquo;&quot; and &quot;$&rsquo;&quot; slows down
regexp matching quite a bit, while $&amp; slows it down to a
lesser extent, because if they are used in one regexp in a
program, they are generated for _ all regexps in the
program. So if raw performance is a goal of your
application, they should be avoided. If you need to extract
the corresponding substrings, use &quot;@-&quot; and
&quot;@+&quot; instead:</small></p>

<p><small>$&lsquo; is the same as substr( $x, 0, $-[0] )
$&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] )
$&rsquo; is the same as substr( $x, $+[0] )</small></p>

<p><small>Non-capturing groupings A group that is required
to bundle a set of alternatives may or may not be useful as
a capturing group. If it isnt, it just creates a superfluous
addition to the set of available capture buffer values,
inside as well as outside the regexp. Non-capturing
groupings, denoted by &quot;(?:regexp)&quot;, still allow
the regexp to be treated as a single unit, but don t
establish a capturing buffer at the same time. Both
capturing and non-capturing groupings are allowed to
co-exist in the same regexp. Because there is no extraction,
non-capturing groupings are faster than capturing groupings.
Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching
variables:</small></p>

<p><small># match a number, $1-$4 are set, but we only want
$1 /([+-]? *(+(.*)?|.+)([eE][+-]?+)?)/;</small></p>

<p><small># match a number faster , only $1 is set /([+-]?
*(?:+(?:.*)?|.+)(?:[eE][+-]?+)?)/;</small></p>

<p><small># match a number, get $1 = whole number, $2 =
exponent /([+-]?
*(?:+(?:.*)?|.+)(?:[eE]([+-]?+))?)/;</small></p>

<p><small>Non-capturing groupings are also useful for
removing nuisance elements gathered from a split operation
where parentheses are required for some reason:</small></p>

<p><small>$x = &rsquo;12aba34ba5&rsquo;; @num = split
/(a|b)+/, $x; # @num =
(&rsquo;12&rsquo;,&rsquo;a&rsquo;,&rsquo;34&rsquo;,&rsquo;b&rsquo;,&rsquo;5&rsquo;)
@num = split /(?:a|b)+/, $x; # @num =
(&rsquo;12&rsquo;,&rsquo;34&rsquo;,&rsquo;5&rsquo;)</small></p>

<p><small>Matching repetitions The examples in the previous
section display an annoying weakness. We were only matching
3-letter words, or chunks of words of 4 letters or less. We
d like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
&quot;24</small></p>

<p><small>This is exactly the problem the _ quantifier
metacharacters &quot;?&quot;, &quot;*&quot;, &quot;+&quot;,
and &quot;{}&quot; were created for. They allow us to
delimit the number of repeats for a portion of a regexp we
consider to be a match. Quantifiers are put immediately
after the character, character class, or grouping that we
want to specify. They have the following
meanings:</small></p>

<p><small>&middot; &quot;a?&quot; means: match a 1 or 0
times</small></p>

<p><small>&middot; &quot;a*&quot; means: match a 0 or more
times, i.e., any number of times</small></p>

<p><small>&middot; &quot;a+&quot; means: match a 1 or more
times, i.e., at least once</small></p>

<p><small>&middot; &quot;a{n,m}&quot; means: match at least
&quot;n&quot; times, but not more than &quot;m&quot;
times.</small></p>

<p><small>&middot; &quot;a{n,}&quot; means: match at least
&quot;n&quot; or more times</small></p>

<p><small>&middot; &quot;a{n}&quot; means: match exactly
&quot;n&quot; times</small></p>

<p><small>Here are some examples:</small></p>

<p><small>/[a-z]+*/; # match a lowercase word, at least one
space, and # any number of digits /(1152 /y(es)?/i; #
matches &rsquo;y&rsquo;, &rsquo;Y&rsquo;, or a
case-insensitive &rsquo;yes&rsquo; $year =~ /{2,4}/; # make
sure year is at least 2 but not more # than 4 digits $year
=~ /{4}|{2}/; # better match; throw out 3 digit dates $year
=~ /{2}({2})?/; # same thing written differently. However, #
this produces $1 and the other does not.</small></p>

<p><small>% simple_grep &rsquo;^(1032 beriberi booboo coco
mama murmur papa</small></p>

<p><small>For all of these quantifiers, Perl will try to
match as much of the string as possible, while still
allowing the regexp to succeed. Thus with
&quot;/a?.../&quot;, Perl will first try to match the regexp
with the &quot;a&quot; present; if that fails, Perl will try
to match the regexp without the &quot;a&quot; present. For
the quantifier &quot;*&quot;, we get the
following:</small></p>

<p><small>$x = &quot;the cat in the hat&quot;; $x =~
/^(.*)(cat)(.*)$/; # matches, # $1 = &rsquo;the &rsquo; # $2
= &rsquo;cat&rsquo; # $3 = &rsquo; in the
hat&rsquo;</small></p>

<p><small>Which is what we might expect, the match finds
the only &quot;cat&quot; in the string and locks onto it.
Consider, however, this regexp:</small></p>

<p><small>$x =~ /^(.*)(at)(.*)$/; # matches, # $1 =
&rsquo;the cat in the h&rsquo; # $2 = &rsquo;at&rsquo; # $3
= &rsquo;&rsquo; (0 characters match)</small></p>

<p><small>One might initially guess that Perl would find
the &quot;at&quot; in &quot;cat&quot; and stop there, but
that wouldnt give the longest possible string to the first
quantifier &quot;.*&quot;. Instead, the first quantifier
&quot;.*&quot; grabs as much of the string as possible while
still having the regexp match. In this example, that means
having the &quot;at&quot; sequence with the final
&quot;at&quot; in the string. The other important principle
illustrated here is that when there are two or more elements
in a regexp, the leftmost quantifier, if there is one, gets
to grab as much the string as possible, leaving the rest of
the regexp to fight over scraps. Thus in our example, the
first quantifier &quot;.*&quot; grabs most of the string,
while the second quantifier &quot;.*&quot; gets the empty
string. Quantifiers that grab as much of the string as
possible are called _ maximal match or greedy
quantifiers.</small></p>

<p><small>When a regexp can match a string in several
different ways, we can use the principles above to predict
which way the regexp will match:</small></p>

<p><small>&middot; Principle 0: Taken as a whole, any
regexp will be matched at the earliest possible position in
the string.</small></p>

<p><small>&middot; Principle 1: In an alternation
&quot;a|b|c...&quot;, the leftmost alternative that allows a
match for the whole regexp will be the one used.</small></p>

<p><small>&middot; Principle 2: The maximal matching
quantifiers &quot;?&quot;, &quot;*&quot;, &quot;+&quot; and
&quot;{n,m}&quot; will in general match as much of the
string as possible while still allowing the whole regexp to
match.</small></p>

<p><small>&middot; Principle 3: If there are two or more
elements in a regexp, the leftmost greedy quantifier, if
any, will match as much of the string as possible while
still allowing the whole regexp to match. The next leftmost
greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still
allowing the whole regexp to match. And so on, until all the
regexp elements are satisfied.</small></p>

<p><small>As we have seen above, Principle 0 overrides the
others -- the regexp will be matched as early as possible,
with the other principles determining how the regexp matches
at that earliest character position.</small></p>

<p><small>Here is an example of these principles in
action:</small></p>

<p><small>$x = &quot;The programming republic of
Perl&quot;; $x =~ /^(.+)(e|r)(.*)$/; # matches, # $1 =
&rsquo;The programming republic of Pe&rsquo; # $2 =
&rsquo;r&rsquo; # $3 = &rsquo;l&rsquo;</small></p>

<p><small>This regexp matches at the earliest string
position, &rsquo;T&rsquo;. One might think that
&quot;e&quot;, being leftmost in the alternation, would be
matched, but &quot;r&quot; produces the longest string in
the first quantifier.</small></p>

<p><small>$x =~ /(m{1,2})(.*)$/; # matches, # $1 =
&rsquo;mm&rsquo; # $2 = &rsquo;ing republic of
Perl&rsquo;</small></p>

<p><small>Here, The earliest possible match is at the first
&rsquo;m&rsquo; in &quot;programming&quot;.
&quot;m{1,2}&quot; is the first quantifier, so it gets to
match a maximal &quot;mm&quot;.</small></p>

<p><small>$x =~ /.*(m{1,2})(.*)$/; # matches, # $1 =
&rsquo;m&rsquo; # $2 = &rsquo;ing republic of
Perl&rsquo;</small></p>

<p><small>Here, the regexp matches at the start of the
string. The first quantifier &quot;.*&quot; grabs as much as
possible, leaving just a single &rsquo;m&rsquo; for the
second quantifier &quot;m{1,2}&quot;.</small></p>

<p><small>$x =~ /(.?)(m{1,2})(.*)$/; # matches, # $1 =
&rsquo;a&rsquo; # $2 = &rsquo;mm&rsquo; # $3 = &rsquo;ing
republic of Perl&rsquo;</small></p>

<p><small>Here, &quot;.?&quot; eats its maximal one
character at the earliest possible position in the string,
&rsquo;a&rsquo; in &quot;programming&quot;, leaving
&quot;m{1,2}&quot; the opportunity to match both
&quot;m&quot;s. Finally,</small></p>

<p><small>&quot;aXXXb&quot; =~ /(X*)/; # matches with $1 =
&rsquo;&rsquo;</small></p>

<p><small>because it can match zero copies of
&rsquo;X&rsquo; at the beginning of the string. If you
definitely want to match at least one &rsquo;X&rsquo;, use
&quot;X+&quot;, not &quot;X*&quot;.</small></p>

<p><small>Sometimes greed is not good. At times, we would
like quantifiers to match a _minimal piece of string, rather
than a maximal piece. For this purpose, Larry Wall created
the _ minimal match or non-greedy quantifiers
&quot;??&quot;, &quot;*?&quot;, &quot;+?&quot;, and
&quot;{}?&quot;. These are the usual quantifiers with a
&quot;?&quot; appended to them. They have the following
meanings:</small></p>

<p><small>&middot; &quot;a??&quot; means: match a 0 or 1
times. Try 0 first, then 1.</small></p>

<p><small>&middot; &quot;a*?&quot; means: match a 0 or more
times, i.e., any number of times, but as few times as
possible</small></p>

<p><small>&middot; &quot;a+?&quot; means: match a 1 or more
times, i.e., at least once, but as few times as
possible</small></p>

<p><small>&middot; &quot;a{n,m}?&quot; means: match at
least &quot;n&quot; times, not more than &quot;m&quot;
times, as few times as possible</small></p>

<p><small>&middot; &quot;a{n,}?&quot; means: match at least
&quot;n&quot; times, but as few times as
possible</small></p>

<p><small>&middot; &quot;a{n}?&quot; means: match exactly
&quot;n&quot; times. Because we match exactly &quot;n&quot;
times, &quot;a{n}?&quot; is equivalent to &quot;a{n}&quot;
and is just there for notational consistency.</small></p>

<p><small>Let s look at the example above, but with minimal
quantifiers:</small></p>

<p><small>$x = &quot;The programming republic of
Perl&quot;; $x =~ /^(.+?)(e|r)(.*)$/; # matches, # $1 =
&rsquo;Th&rsquo; # $2 = &rsquo;e&rsquo; # $3 = &rsquo;
programming republic of Perl&rsquo;</small></p>

<p><small>The minimal string that will allow both the start
of the string &quot;^&quot; and the alternation to match is
&quot;Th&quot;, with the alternation &quot;e|r&quot;
matching &quot;e&quot;. The second quantifier &quot;.*&quot;
is free to gobble up the rest of the string.</small></p>

<p><small>$x =~ /(m{1,2}?)(.*?)$/; # matches, # $1 =
&rsquo;m&rsquo; # $2 = &rsquo;ming republic of
Perl&rsquo;</small></p>

<p><small>The first string position that this regexp can
match is at the first &rsquo;m&rsquo; in
&quot;programming&quot;. At this position, the minimal
&quot;m{1,2}?&quot; matches just one &rsquo;m&rsquo;.
Although the second quantifier &quot;.*?&quot; would prefer
to match no characters, it is constrained by the
end-of-string anchor &quot;$&quot; to match the rest of the
string.</small></p>

<p><small>$x =~ /(.*?)(m{1,2}?)(.*)$/; # matches, # $1 =
&rsquo;The progra&rsquo; # $2 = &rsquo;m&rsquo; # $3 =
&rsquo;ming republic of Perl&rsquo;</small></p>

<p><small>In this regexp, you might expect the first
minimal quantifier &quot;.*?&quot; to match the empty
string, because it is not constrained by a &quot;^&quot;
anchor to match the beginning of the word. Principle 0
applies here, however. Because it is possible for the whole
regexp to match at the start of the string, it _ will match
at the start of the string. Thus the first quantifier has to
match everything up to the first &quot;m&quot;. The second
minimal quantifier matches just one &quot;m&quot; and the
third quantifier matches the rest of the string.</small></p>

<p><small>$x =~ /(.??)(m{1,2})(.*)$/; # matches, # $1 =
&rsquo;a&rsquo; # $2 = &rsquo;mm&rsquo; # $3 = &rsquo;ing
republic of Perl&rsquo;</small></p>

<p><small>Just as in the previous regexp, the first
quantifier &quot;.??&quot; can match earliest at position
&rsquo;a&rsquo;, so it does. The second quantifier is
greedy, so it matches &quot;mm&quot;, and the third matches
the rest of the string.</small></p>

<p><small>We can modify principle 3 above to take into
account non-greedy quantifiers:</small></p>

<p><small>&middot; Principle 3: If there are two or more
elements in a regexp, the leftmost greedy (non-greedy)
quantifier, if any, will match as much (little) of the
string as possible while still allowing the whole regexp to
match. The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string
remaining available to it as possible, while still allowing
the whole regexp to match. And so on, until all the regexp
elements are satisfied.</small></p>

<p><small>Just like alternation, quantifiers are also
susceptible to backtracking. Here is a step-by-step analysis
of the example</small></p>

<p><small>$x = &quot;the cat in the hat&quot;; $x =~
/^(.*)(at)(.*)$/; # matches, # $1 = &rsquo;the cat in the
h&rsquo; # $2 = &rsquo;at&rsquo; # $3 = &rsquo;&rsquo; (0
matches)</small></p>

<p><small>0 Start with the first letter in the string
t.</small></p>

<p><small>1 The first quantifier .* starts out by matching
the whole string the cat in the hat.</small></p>

<p><small>2 a in the regexp element at doesnt match the end
of the string. Backtrack one character.</small></p>

<p><small>3 a in the regexp element at still doesnt match
the last letter of the string t, so backtrack one more
character.</small></p>

<p><small>4 Now we can match the a and the t.</small></p>

<p><small>5 Move on to the third element .*. Since we are
at the end of the string and .* can match 0 times, assign it
the empty string.</small></p>

<p><small>6 We are done!</small></p>

<p><small>Most of the time, all this moving forward and
backtracking happens quickly and searching is fast. There
are some pathological regexps, however, whose execution time
exponentially grows with the size of the string. A typical
structure that blows up in your face is of the
form</small></p>

<p><small>/(a|b+)*/;</small></p>

<p><small>The problem is the nested indeterminate
quantifiers. There are many different ways of partitioning a
string of length n between the &quot;+&quot; and
&quot;*&quot;: one repetition with &quot;b+&quot; of length
n, two repetitions with the first &quot;b+&quot; length k
and the second with length n-k, m repetitions whose bits add
up to length n, etc. In fact there are an exponential number
of ways to partition a string as a function of its length. A
regexp may get lucky and match early in the process, but if
there is no match, Perl will try _ every possibility before
giving up. So be careful with nested &quot;*&quot; s,
&quot;{n,m}&quot; s, and &quot;+&quot;s. The book _
Mastering Regular Expressions by Jeffrey Friedl gives a
wonderful discussion of this and other efficiency
issues.</small></p>

<p><small>Possessive quantifiers Backtracking during the
relentless search for a match may be a waste of time,
particularly when the match is bound to fail. Consider the
simple pattern</small></p>

<p><small>/^48</small></p>

<p><small>Whenever this is applied to a string which doesnt
quite meet the patterns expectations such as &quot;abc
&quot; or &quot;abc def &quot;, the regex engine will
backtrack, approximately once for each character in the
string. But we know that there is no way around taking _ all
of the initial word characters to match the first
repetition, that _ all spaces must be eaten by the middle
part, and the same goes for the second word.</small></p>

<p><small>With the introduction of the _ possessive
quantifiers in Perl 5.10, we have a way of instructing the
regex engine not to backtrack, with the usual quantifiers
with a &quot;+&quot; appended to them. This makes them
greedy as well as stingy; once they succeed they won t give
anything back to permit another solution. They have the
following meanings:</small></p>

<p><small>&middot; &quot;a{n,m}+&quot; means: match at
least &quot;n&quot; times, not more than &quot;m&quot;
times, as many times as possible, and dont give anything up.
&quot;a?+&quot; is short for &quot;a{0,1}+&quot;</small></p>

<p><small>&middot; &quot;a{n,}+&quot; means: match at least
&quot;n&quot; times, but as many times as possible, and don
t give anything up. &quot;a*+&quot; is short for
&quot;a{0,}+&quot; and &quot;a++&quot; is short for
&quot;a{1,}+&quot;.</small></p>

<p><small>&middot; &quot;a{n}+&quot; means: match exactly
&quot;n&quot; times. It is just there for notational
consistency.</small></p>

<p><small>These possessive quantifiers represent a special
case of a more general concept, the _ independent
subexpression, see below.</small></p>

<p><small>As an example where a possessive quantifier is
suitable we consider matching a quoted string, as it appears
in several programming languages. The backslash is used as
an escape character that indicates that the next character
is to be taken literally, as another character for the
string. Therefore, after the opening quote, we expect a
(possibly empty) sequence of alternatives: either some
character except an unescaped quote or backslash or an
escaped character.</small></p>

<p><small>/&quot;(?:[^&quot;\]++|\.)*+&quot;/;</small></p>

<p><small>Building a regexp At this point, we have all the
basic regexp concepts covered, so lets give a more involved
example of a regular expression. We will build a regexp that
matches numbers.</small></p>

<p><small>The first task in building a regexp is to decide
what we want to match and what we want to exclude. In our
case, we want to match both integers and floating point
numbers and we want to reject any string that isnt a
number.</small></p>

<p><small>The next task is to break the problem down into
smaller problems that are easily converted into a
regexp.</small></p>

<p><small>The simplest case is integers. These consist of a
sequence of digits, with an optional sign in front. The
digits we can represent with &quot;+&quot; and the sign can
be matched with &quot;[+-]&quot;. Thus the integer regexp
is</small></p>

<p><small>/[+-]?+/; # matches integers</small></p>

<p><small>A floating point number potentially has a sign,
an integral part, a decimal point, a fractional part, and an
exponent. One or more of these parts is optional, so we need
to check out the different possibilities. Floating point
numbers which are in proper form include 123., 0.345, .34,
-1e6, and 25.4E-72. As with integers, the sign out front is
completely optional and can be matched by &quot;[+-]?&quot;.
We can see that if there is no exponent, floating point
numbers must have a decimal point, otherwise they are
integers. We might be tempted to model these with
&quot;*.*&quot;, but this would also match just a single
decimal point, which is not a number. So the three cases of
floating point number without exponent are</small></p>

<p><small>/[+-]?+./; # 1., 321., etc. /[+-]?.+/; # .1,
.234, etc. /[+-]?+.+/; # 1.0, 30.56, etc.</small></p>

<p><small>These can be combined into a single regexp with a
three-way alternation:</small></p>

<p><small>/[+-]?(+.+|+.|.+)/; # floating point, no
exponent</small></p>

<p><small>In this alternation, it is important to put
&rsquo;+.+&rsquo; before &rsquo;+.&rsquo;. If
&rsquo;+.&rsquo; were first, the regexp would happily match
that and ignore the fractional part of the
number.</small></p>

<p><small>Now consider floating point numbers with
exponents. The key observation here is that _ both integers
and numbers with decimal points are allowed in front of an
exponent. Then exponents, like the overall sign, are
independent of whether we are matching numbers with or
without decimal points, and can be decoupled from the
mantissa. The overall form of the regexp now becomes
clear:</small></p>

<p><small>/^(optional sign)(integer | f.p.
mantissa)(optional exponent)$/;</small></p>

<p><small>The exponent is an &quot;e&quot; or
&quot;E&quot;, followed by an integer. So the exponent
regexp is</small></p>

<p><small>/[eE][+-]?+/; # exponent</small></p>

<p><small>Putting all the parts together, we get a regexp
that matches numbers:</small></p>

<p><small>/^[+-]?(+.+|+.|.+|+)([eE][+-]?+)?$/; # Ta
da!</small></p>

<p><small>Long regexps like this may impress your friends,
but can be hard to decipher. In complex situations like
this, the &quot;//x&quot; modifier for a match is
invaluable. It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.
Using it, we can rewrite our extended regexp in the more
pleasing form</small></p>

<p><small>/^ [+-]? # first, match an optional sign ( # then
match integers or f.p. mantissas: +.+ # mantissa of the form
a.b |+. # mantissa of the form a. |.+ # mantissa of the form
.b |+ # integer of the form a ) ([eE][+-]?+)? # finally,
optionally match an exponent $/x;</small></p>

<p><small>If whitespace is mostly irrelevant, how does one
include space characters in an extended regexp? The answer
is to backslash it &rsquo; &rsquo; or put it in a character
class &quot;[ ]&quot;. The same thing goes for pound signs,
use &quot; the sign and the mantissa or integer, and we
could add this to our regexp as follows:</small></p>

<p><small>/^ [+-]? * # first, match an optional sign *and
space* ( # then match integers or f.p. mantissas: +.+ #
mantissa of the form a.b |+. # mantissa of the form a. |.+ #
mantissa of the form .b |+ # integer of the form a )
([eE][+-]?+)? # finally, optionally match an exponent
$/x;</small></p>

<p><small>In this form, it is easier to see a way to
simplify the alternation. Alternatives 1, 2, and 4 all start
with &quot;+&quot;, so it could be factored out:</small></p>

<p><small>/^ [+-]? * # first, match an optional sign ( #
then match integers or f.p. mantissas: + # start out with a
... ( .* # mantissa of the form a.b or a. )? # ? takes care
of integers of the form a |.+ # mantissa of the form .b )
([eE][+-]?+)? # finally, optionally match an exponent
$/x;</small></p>

<p><small>or written in the compact form,</small></p>

<p><small>/^[+-]? *(+(.*)?|.+)([eE][+-]?+)?$/;</small></p>

<p><small>This is our final regexp. To recap, we built a
regexp by</small></p>

<p><small>&middot; specifying the task in
detail,</small></p>

<p><small>&middot; breaking down the problem into smaller
parts,</small></p>

<p><small>&middot; translating the small parts into
regexps,</small></p>

<p><small>&middot; combining the regexps,</small></p>

<p><small>&middot; and optimizing the final combined
regexp.</small></p>

<p><small>These are also the typical steps involved in
writing a computer program. This makes perfect sense,
because regular expressions are essentially programs written
in a little computer language that specifies
patterns.</small></p>

<p><small>Using regular expressions in Perl The last topic
of Part 1 briefly covers how regexps are used in Perl
programs. Where do they fit into Perl syntax?</small></p>

<p><small>We have already introduced the matching operator
in its default &quot;/regexp/&quot; and arbitrary delimiter
&quot;m!regexp!&quot; forms. We have used the binding
operator &quot;=~&quot; and its negation &quot;!~&quot; to
test for string matches. Associated with the matching
operator, we have discussed the single line &quot;//s&quot;,
multi-line &quot;//m&quot;, case-insensitive &quot;//i&quot;
and extended &quot;//x&quot; modifiers. There are a few more
things you might want to know about matching
operators.</small></p>

<p><small>Optimizing pattern evaluation</small></p>

<p><small>We pointed out earlier that variables in regexps
are substituted before the regexp is evaluated:</small></p>

<p><small>$pattern = &rsquo;Seuss&rsquo;; while (&lt;&gt;)
{ print if /$pattern/; }</small></p>

<p><small>This will print any lines containing the word
&quot;Seuss&quot;. It is not as efficient as it could be,
however, because Perl has to re-evaluate (or compile)
$pattern each time through the loop. If $pattern wont be
changing over the lifetime of the script, we can add the
&quot;//o&quot; modifier, which directs Perl to only perform
variable substitutions once:</small></p>

<p><small>#!/usr/bin/perl # Improved simple_grep $regexp =
shift; while (&lt;&gt;) { print if /$regexp/o; # a good deal
faster }</small></p>

<p><small>Prohibiting substitution</small></p>

<p><small>If you change $pattern after the first
substitution happens, Perl will ignore it. If you dont want
any substitutions at all, use the special delimiter
&quot;m&rsquo;&rsquo;&quot;:</small></p>

<p><small>@pattern = (&rsquo;Seuss&rsquo;); while
(&lt;&gt;) { print if m&rsquo;@pattern&rsquo;; # matches
literal &rsquo;@pattern&rsquo;, not &rsquo;Seuss&rsquo;
}</small></p>

<p><small>Similar to strings, &quot;m&rsquo;&rsquo;&quot;
acts like apostrophes on a regexp; all other &quot;m&quot;
delimiters act like quotes. If the regexp evaluates to the
empty string, the regexp in the _ last successful match is
used instead. So we have</small></p>

<p><small>&quot;dog&quot; =~ /d/; # &rsquo;d&rsquo; matches
&quot;dogbert =~ //; # this matches the &rsquo;d&rsquo;
regexp used before</small></p>

<p><small>Global matching</small></p>

<p><small>The final two modifiers &quot;//g&quot; and
&quot;//c&quot; concern multiple matches. The modifier
&quot;//g&quot; stands for global matching and allows the
matching operator to match within a string as many times as
possible. In scalar context, successive invocations against
a string will have &quot;//g&quot; jump from match to match,
keeping track of position in the string as it goes along.
You can get or set the position with the &quot;pos()&quot;
function.</small></p>

<p><small>The use of &quot;//g&quot; is shown in the
following example. Suppose we have a string that consists of
words separated by spaces. If we know how many words there
are in advance, we could extract the words using
groupings:</small></p>

<p><small>$x = &quot;cat dog house&quot;; # 3 words $x =~
/^(24 # $1 = &rsquo;cat&rsquo; # $2 = &rsquo;dog&rsquo; # $3
= &rsquo;house&rsquo;</small></p>

<p><small>But what if we had an indeterminate number of
words? This is the sort of task &quot;//g&quot; was made
for. To extract all words, form the simple regexp
&quot;(960</small></p>

<p><small>while ($x =~ /(144 print &quot;Word is $1, ends
at position &quot;, pos $x, &quot;0; }</small></p>

<p><small>prints</small></p>

<p><small>Word is cat, ends at position 3 Word is dog, ends
at position 7 Word is house, ends at position 13</small></p>

<p><small>A failed match or changing the target string
resets the position. If you don t want the position reset
after failure to match, add the &quot;//c&quot;, as in
&quot;/regexp/gc&quot;. The current position in the string
is associated with the string, not the regexp. This means
that different strings have different positions and their
respective positions can be set or read
independently.</small></p>

<p><small>In list context, &quot;//g&quot; returns a list
of matched groupings, or if there are no groupings, a list
of matches to the whole regexp. So if we wanted just the
words, we could use</small></p>

<p><small>@words = ($x =~ /(408 # $word[0] =
&rsquo;cat&rsquo; # $word[1] = &rsquo;dog&rsquo; # $word[2]
= &rsquo;house&rsquo;</small></p>

<p><small>Closely associated with the &quot;//g&quot;
modifier is the &quot;G&quot; anchor. The &quot;G&quot;
anchor matches at the point where the previous
&quot;//g&quot; match left off. &quot;G&quot; allows us to
easily do context-sensitive matching:</small></p>

<p><small>$metric = 1; # use metric units ... $x =
&lt;FILE&gt;; # read in measurement $x =~ /^([+-]?+)/g; #
get magnitude $weight = $1; if ($metric) { # error checking
print &quot;Units error!&quot; unless $x =~ /Gkg./g; } else
{ print &quot;Units error!&quot; unless $x =~ /Glbs./g; } $x
=~ /Gidget|sprocket)/g; # continue processing</small></p>

<p><small>The combination of &quot;//g&quot; and
&quot;G&quot; allows us to process the string a bit at a
time and use arbitrary Perl logic to decide what to do next.
Currently, the &quot;G&quot; anchor is only fully supported
when used to anchor to the start of the pattern.</small></p>

<p><small>&quot;G&quot; is also invaluable in processing
fixed length records with regexps. Suppose we have a snippet
of coding region DNA, encoded as base pair letters
&quot;ATCGTTGAAT...&quot; and we want to find all the stop
codons &quot;TGA&quot;. In a coding region, codons are
3-letter sequences, so we can think of the DNA snippet as a
sequence of 3-letter records. The naive regexp</small></p>

<p><small># expanded, this is &quot;ATC GTT GAA TGC AAA TGA
CAT GAC&quot; $dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;;
$dna =~ /TGA/;</small></p>

<p><small>doesnt work; it may match a &quot;TGA&quot;, but
there is no guarantee that the match is aligned with codon
boundaries, e.g., the substring &quot;GTT GAA&quot; gives a
match. A better solution is</small></p>

<p><small>while ($dna =~ /(48 print &quot;Got a TGA stop
codon at position &quot;, pos $dna, &quot;0; }</small></p>

<p><small>which prints</small></p>

<p><small>Got a TGA stop codon at position 18 Got a TGA
stop codon at position 23</small></p>

<p><small>Position 18 is good, but position 23 is bogus.
What happened?</small></p>

<p><small>The answer is that our regexp works well until we
get past the last real match. Then the regexp will fail to
match a synchronized &quot;TGA&quot; and start stepping
ahead one character position at a time, not what we want.
The solution is to use &quot;G&quot; to anchor the match to
the codon alignment:</small></p>

<p><small>while ($dna =~ /G(24 print &quot;Got a TGA stop
codon at position &quot;, pos $dna, &quot;0; }</small></p>

<p><small>This prints</small></p>

<p><small>Got a TGA stop codon at position 18</small></p>

<p><small>which is the correct answer. This example
illustrates that it is important not only to match what is
desired, but to reject what is not desired.</small></p>

<p><small>Search and replace</small></p>

<p><small>Regular expressions also play a big role in _
search and replace operations in Perl. Search and replace is
accomplished with the &quot;s///&quot; operator. The general
form is &quot;s/regexp/replacement/modifiers&quot;, with
everything we know about regexps and modifiers applying in
this case as well. The &quot;replacement&quot; is a Perl
double quoted string that replaces in the string whatever is
matched with the &quot;regexp&quot;. The operator
&quot;=~&quot; is also used here to associate a string with
&quot;s///&quot;. If matching against $_, the &quot;$_
=~&quot; can be dropped. If there is a match,
&quot;s///&quot; returns the number of substitutions made,
otherwise it returns false. Here are a few
examples:</small></p>

<p><small>$x = &quot;Time to feed the cat!&quot;; $x =~
s/cat/hacker/; # $x contains &quot;Time to feed the
hacker!&quot; if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
$more_insistent = 1; } $y = &quot;&rsquo;quoted
words&rsquo;&quot;; $y =~ s/^&rsquo;(.*)&rsquo;$/$1/; #
strip single quotes, # $y contains &quot;quoted
words&quot;</small></p>

<p><small>In the last example, the whole string was
matched, but only the part inside the single quotes was
grouped. With the &quot;s///&quot; operator, the matched
variables $1, $2, etc. are immediately available for use in
the replacement expression, so we use $1 to replace the
quoted string with just what was quoted. With the global
modifier, &quot;s///g&quot; will search and replace all
occurrences of the regexp in the string:</small></p>

<p><small>$x = &quot;I batted 4 for 4&quot;; $x =~
s/4/four/; # doesn&rsquo;t do it all: # $x contains &quot;I
batted four for 4&quot; $x = &quot;I batted 4 for 4&quot;;
$x =~ s/4/four/g; # does it all: # $x contains &quot;I
batted four for four&quot;</small></p>

<p><small>If you prefer regex over regexp in this tutorial,
you could use the following program to replace
it:</small></p>

<p><small>% cat &gt; simple_replace #!/usr/bin/perl $regexp
= shift; $replacement = shift; while (&lt;&gt;) {
s/$regexp/$replacement/go; print; } ^D</small></p>

<p><small>% simple_replace regexp regex
perlretut.pod</small></p>

<p><small>In &quot;simple_replace&quot; we used the
&quot;s///g&quot; modifier to replace all occurrences of the
regexp on each line and the &quot;s///o&quot; modifier to
compile the regexp only once. As with
&quot;simple_grep&quot;, both the &quot;print&quot; and the
&quot;s/$regexp/$replacement/go&quot; use $_
implicitly.</small></p>

<p><small>A modifier available specifically to search and
replace is the &quot;s///e&quot; evaluation modifier.
&quot;s///e&quot; wraps an &quot;eval{...}&quot; around the
replacement string and the evaluated result is substituted
for the matched substring. &quot;s///e&quot; is useful if
you need to do a bit of computation in the process of
replacing text. This example counts character frequencies in
a line:</small></p>

<p><small>$x = &quot;Bill the cat&quot;; $x =~
s/(.)/$chars{$1}++;$1/eg; # final $1 replaces char with
itself print &quot;frequency of &rsquo;$_&rsquo; is
$chars{$_}0 foreach (sort {$chars{$b} &lt;=&gt; $chars{$a}}
keys %chars);</small></p>

<p><small>This prints</small></p>

<p><small>frequency of &rsquo; &rsquo; is 2 frequency of
&rsquo;t&rsquo; is 2 frequency of &rsquo;l&rsquo; is 2
frequency of &rsquo;B&rsquo; is 1 frequency of
&rsquo;c&rsquo; is 1 frequency of &rsquo;e&rsquo; is 1
frequency of &rsquo;h&rsquo; is 1 frequency of
&rsquo;i&rsquo; is 1 frequency of &rsquo;a&rsquo; is
1</small></p>

<p><small>As with the match &quot;m//&quot; operator,
&quot;s///&quot; can use other delimiters, such as
&quot;s!!!&quot; and &quot;s{}{}&quot;, and even
&quot;s{}//&quot;. If single quotes are used
&quot;s&rsquo;&rsquo;&rsquo;&quot;, then the regexp and
replacement are treated as single quoted strings and there
are no substitutions. &quot;s///&quot; in list context
returns the same thing as in scalar context, i.e., the
number of matches.</small></p>

<p><small>The split function</small></p>

<p><small>The &quot;split()&quot; function is another place
where a regexp is used. &quot;split /regexp/, string,
limit&quot; separates the &quot;string&quot; operand into a
list of substrings and returns that list. The regexp must be
designed to match whatever constitutes the separators for
the desired substrings. The &quot;limit&quot;, if present,
constrains splitting into no more than &quot;limit&quot;
number of strings. For example, to split a string into
words, use</small></p>

<p><small>$x = &quot;Calvin and Hobbes&quot;; @words =
split /, $x; # $word[0] = &rsquo;Calvin&rsquo; # $word[1] =
&rsquo;and&rsquo; # $word[2] =
&rsquo;Hobbes&rsquo;</small></p>

<p><small>If the empty regexp &quot;//&quot; is used, the
regexp always matches and the string is split into
individual characters. If the regexp has groupings, then the
resulting list contains the matched substrings from the
groupings as well. For instance,</small></p>

<p><small>$x = &quot;/usr/bin/perl&quot;; @dirs = split
m!/!, $x; # $dirs[0] = &rsquo;&rsquo; # $dirs[1] =
&rsquo;usr&rsquo; # $dirs[2] = &rsquo;bin&rsquo; # $dirs[3]
= &rsquo;perl&rsquo; @parts = split m!(/)!, $x; # $parts[0]
= &rsquo;&rsquo; # $parts[1] = &rsquo;/&rsquo; # $parts[2] =
&rsquo;usr&rsquo; # $parts[3] = &rsquo;/&rsquo; # $parts[4]
= &rsquo;bin&rsquo; # $parts[5] = &rsquo;/&rsquo; #
$parts[6] = &rsquo;perl&rsquo;</small></p>

<p><small>Since the first character of $x matched the
regexp, &quot;split&quot; prepended an empty initial element
to the list.</small></p>

<p><small>If you have read this far, congratulations! You
now have all the basic tools needed to use regular
expressions to solve a wide range of text processing
problems. If this is your first time through the tutorial,
why not stop here and play around with regexps a while...
Part 2 concerns the more esoteric aspects of regular
expressions and those concepts certainly arent needed right
at the start.</small></p>

<p><small>Part 2: Power tools OK, you know the basics of
regexps and you want to know more. If matching regular
expressions is analogous to a walk in the woods, then the
tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time. Most of the tools
in part 2 are analogous to flare guns and satellite phones.
They aren t used too often on a hike, but when we are stuck,
they can be invaluable.</small></p>

<p><small>What follows are the more advanced, less used, or
sometimes esoteric capabilities of Perl regexps. In Part 2,
we will assume you are comfortable with the basics and
concentrate on the new features.</small></p>

<p><small>More on characters, strings, and character
classes There are a number of escape sequences and character
classes that we havent covered yet.</small></p>

<p><small>There are several escape sequences that convert
characters or strings between upper and lower case, and they
are also available within patterns. &quot;nd &quot;&quot;
convert the next character to lower or upper case,
respectively:</small></p>

<p><small>$x = &quot;perl&quot;; $string =~ /$x/; # matches
&rsquo;Perl&rsquo; in $string $x = &quot;M(rs?|s)\.&quot;; #
note the double backslash $string =~ //; # matches
&rsquo;mr.&rsquo;, &rsquo;mrs.&rsquo;, and
&rsquo;ms.&rsquo;,</small></p>

<p><small>A &quot;r &quot;U&quot; indicates a lasting
conversion of case, until terminated by &quot;</small></p>

<p><small>$x = &quot;This word is in lower case:SHOUT $x =~
/shout/; # matches $x = &quot;I STILL KEYPUNCH CARDS FOR MY
360&quot; $x =~ /Ukeypunch/; # matches punch card
string</small></p>

<p><small>If there is no &quot; regexps &quot;$word&quot;
or &quot;ord&quot; convert the first character of $word to
uppercase and the rest of the characters to
lowercase.</small></p>

<p><small>Control characters can be escaped with &quot;
character would be matched with &quot; quotes, or protects
most non-alphabetic characters. For instance,</small></p>

<p><small>$x = &quot;QThat !^*&amp;%~&amp; cat!&quot;; $x
=~ /Q!^*&amp;%~&amp;; # check for rough language</small></p>

<p><small>It does not protect &quot;$&quot; or
&quot;@&quot;, so that variables can still be
substituted.</small></p>

<p><small>With the advent of 5.6.0, Perl regexps can handle
more than just the standard ASCII character set. Perl now
supports _ Unicode, a standard for representing the
alphabets from virtually all of the worlds written
languages, and a host of symbols. Perl s text strings are
Unicode strings, so they can contain characters with a value
(codepoint or character number) higher than 255</small></p>

<p><small>What does this mean for regexps? Well, regexp
users don t need to know much about Perls internal
representation of strings. But they do need to know 1) how
to represent Unicode characters in a regexp and 2) that a
matching operation will treat the string to be searched as a
sequence of characters, not bytes. The answer to 1) is that
Unicode characters greater than &quot;chr(255)&quot; are
represented using the &quot;ex}&quot; notation, because the
octal and hex (without curly braces) dont go further than
255.</small></p>

<p><small>/}/; # match a Unicode smiley face :)</small></p>

<p><small>NOTE: In Perl 5.6.0 it used to be that one needed
to say &quot;use utf8&quot; to use any Unicode features.
This is no more the case: for almost all Unicode processing,
the explicit &quot;utf8&quot; pragma is not needed. (The
only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit &quot;use
utf8&quot; is needed.)</small></p>

<p><small>Figuring out the hexadecimal sequence of a
Unicode character you want or deciphering someone elses
hexadecimal Unicode regexp is about as much fun as
programming in machine code. So another way to specify
Unicode characters is to use the _ named character&gt;
escape sequence &quot;ame}&quot;. &quot;name&quot; is a name
for the Unicode character, as specified in the Unicode
standard. For instance, if we wanted to represent or match
the astrological sign for the planet Mercury, we could
use</small></p>

<p><small>use charnames &quot;:full&quot;; # use named
chars with Unicode full names $x =
&quot;abcERCURY}def&quot;; $x =~ /ERCURY}/; #
matches</small></p>

<p><small>One can also use short names or restrict names to
a certain alphabet:</small></p>

<p><small>use charnames &rsquo;:full&rsquo;; print
&quot;REEK SMALL LETTER SIGMA} is called
sigma.0;</small></p>

<p><small>use charnames &quot;:short&quot;; print
&quot;reek:Sigma} is an upper-case sigma.0;</small></p>

<p><small>use charnames qw(greek); print &quot;igma} is
Greek sigma0;</small></p>

<p><small>A list of full names is found in the file
NamesList.txt in the lib/perl5/X.X.X/unicore directory
(where X.X.X is the perl version number as it is installed
on your system).</small></p>

<p><small>The answer to requirement 2), as of 5.6.0, is
that a regexp uses Unicode characters. Internally, this is
encoded to bytes using either UTF-8 or a native 8 bit
encoding, depending on the history of the string, but
conceptually it is a sequence of characters, not bytes. See
perlunitut for a tutorial about that.</small></p>

<p><small>Let us now discuss Unicode character classes.
Just as with Unicode characters, there are named Unicode
character classes represented by the &quot;{name}&quot;
escape sequence. Closely associated is the
&quot;P{name}&quot; character class, which is the negation
of the &quot;{name}&quot; class. For example, to match lower
and uppercase characters,</small></p>

<p><small>use charnames &quot;:full&quot;; # use named
chars with Unicode full names $x = &quot;BOB&quot;; $x =~
/^{IsUpper}/; # matches, uppercase char class $x =~
/^P{IsUpper}/; # doesn&rsquo;t match, char class sans
uppercase $x =~ /^{IsLower}/; # doesn&rsquo;t match,
lowercase char class $x =~ /^P{IsLower}/; # matches, char
class sans lowercase</small></p>

<p><small>Here is the association between some Perl named
classes and the traditional Unicode classes:</small></p>

<p><small>Perl class name Unicode class name or regular
expression</small></p>

<p><small>IsAlpha /^[LM]/ IsAlnum /^[LMN]/ IsASCII $code
&lt;= 127 IsCntrl /^C/ IsBlank $code =~ /^(0020|0009)$/ ||
/^Z[^lp]/ IsDigit Nd IsGraph /^([LMNPS]|Co)/ IsLower Ll
IsPrint /^([LMNPS]|Co|Zs)/ IsPunct /^P/ IsSpace /^Z/ ||
($code =~ /^(0009|000A|000B|000C|000D)$/ IsSpacePerl /^Z/ ||
($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/ IsUpper
/^L[ut]/ IsWord /^[LMN]/ || $code eq &quot;005F&quot;
IsXDigit $code =~ /^00(3[0-9]|[46][1-6])$/</small></p>

<p><small>You can also use the official Unicode class names
with the &quot;&quot; and &quot;P&quot;, like
&quot;{L}&quot; for Unicode letters , or &quot;{Lu}&quot;
for uppercase letters, or &quot;P{Nd}&quot; for non-digits.
If a &quot;name&quot; is just one letter, the braces can be
dropped. For instance, &quot;M&quot; is the character class
of Unicode marks, for example accent marks. For the full
list see perlunicode.</small></p>

<p><small>The Unicode has also been separated into various
sets of characters which you can test with &quot;{...}&quot;
(in) and &quot;P{...}&quot; (not in). To test whether a
character is (or is not) an element of a script you would
use the script name, for example &quot;{Latin}&quot;,
&quot;{Greek}&quot;, or &quot;P{Katakana}&quot;. Other sets
are the Unicode blocks, the names of which begin with
&quot;In&quot;. One such block is dedicated to mathematical
operators, and its pattern formula is
&lt;C{InMathematicalOperators&gt;}&gt;. For the full list
see perlunicode.</small></p>

<p><small>&quot; Unicode _combining character sequences. A
combining character sequence is a base character followed by
any number of diacritics, i.e., signs like accents used to
indicate different sounds of a letter. Using the Unicode
full names, e.g., &quot;A + COMBINING RING&quot; is a
combining character sequence with base character
&quot;A&quot; and combining character &quot;COMBINING
RING&quot;, which translates in Danish to A with the circle
atop it, as in the word Angstrom. &quot;PMM*}&quot;, i.e., a
non-mark followed by one or more marks.</small></p>

<p><small>For the full and latest information about Unicode
see the latest Unicode standard, or the Unicode Consortiums
website http://www.unicode.org/</small></p>

<p><small>As if all those classes werent enough, Perl also
defines POSIX style character classes. These have the form
&quot;[:name:]&quot;, with &quot;name&quot; the name of the
POSIX class. The POSIX classes are &quot;alpha&quot;,
&quot;alnum&quot;, &quot;ascii&quot;, &quot;cntrl&quot;,
&quot;digit&quot;, &quot;graph&quot;, &quot;lower&quot;,
&quot;print&quot;, &quot;punct&quot;, &quot;space&quot;,
&quot;upper&quot;, and &quot;xdigit&quot;, and two
extensions, &quot;word&quot; (a Perl extension to match
&quot;168blank&quot; (a GNU extension). If &quot;utf8&quot;
is being used, then these classes are defined the same as
their corresponding Perl Unicode classes:
&quot;[:upper:]&quot; is the same as &quot;{IsUpper}&quot;,
etc. The POSIX character classes, however, don t require
using &quot;utf8&quot;. The &quot;[:digit:]&quot;,
&quot;[:word:]&quot;, and &quot;[:space:]&quot; correspond
to the familiar &quot;&quot;, &quot;144haracter classes. To
negate a POSIX class, put a &quot;^&quot; in front of the
name, so that, e.g., &quot;[:^digit:]&quot; corresponds to
&quot;utf8&quot;, &quot;P{IsDigit}&quot;. The Unicode and
POSIX character classes can be used just like &quot;&quot;,
with the exception that POSIX character classes can only be
used inside of a character class:</small></p>

<p><small>/bc[:digit:]xyz]/; # match a,b,c,x,y,z, or a
digit /^=item:digit:]]/; # match &rsquo;=item&rsquo;, #
followed by a space and a digit use charnames
&quot;:full&quot;; /bc{IsDigit}xyz]; # match a,b,c,x,y,z, or
a digit /^=itemIsDigit}/; # match &rsquo;=item&rsquo;, #
followed by a space and a digit</small></p>

<p><small>Whew! That is all the rest of the characters and
character classes.</small></p>

<p><small>Compiling and saving regular expressions In Part
1 we discussed the &quot;//o&quot; modifier, which compiles
a regexp just once. This suggests that a compiled regexp is
some data structure that can be stored once and used again
and again. The regexp quote &quot;qr//&quot; does exactly
that: &quot;qr/string/&quot; compiles the &quot;string&quot;
as a regexp and transforms the result into a form that can
be assigned to a variable:</small></p>

<p><small>$reg = qr/foo+bar?/; # reg contains a compiled
regexp</small></p>

<p><small>Then $reg can be used as a regexp:</small></p>

<p><small>$x = &quot;fooooba&quot;; $x =~ $reg; # matches,
just like /foo+bar?/ $x =~ /$reg/; # same thing, alternate
form</small></p>

<p><small>$reg can also be interpolated into a larger
regexp:</small></p>

<p><small>$x =~ /(abc)?$reg/; # still matches</small></p>

<p><small>As with the matching operator, the regexp quote
can use different delimiters, e.g., &quot;qr!!&quot;,
&quot;qr{}&quot; or &quot;qr~~&quot;. Apostrophes as
delimiters (&quot;qr&rsquo;&rsquo;&quot;) inhibit any
interpolation.</small></p>

<p><small>Pre-compiled regexps are useful for creating
dynamic matches that dont need to be recompiled each time
they are encountered. Using pre- compiled regexps, we write
a &quot;grep_step&quot; program which greps for a sequence
of patterns, advancing to the next pattern as soon as one
has been satisfied.</small></p>

<p><small>% cat &gt; grep_step #!/usr/bin/perl # grep_step
- match &lt;number&gt; regexps, one after the other # usage:
multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2
...</small></p>

<p><small>$number = shift; $regexp[$_] = shift foreach
(0..$number-1); @compiled = map qr/$_/, @regexp; while
($line = &lt;&gt;) { if ($line =~ /$compiled[0]/) { print
$line; shift @compiled; last unless @compiled; } }
^D</small></p>

<p><small>% grep_step 3 shift print last grep_step $number
= shift; print $line; last unless @compiled;</small></p>

<p><small>Storing pre-compiled regexps in an array
@compiled allows us to simply loop through the regexps
without any recompilation, thus gaining flexibility without
sacrificing speed.</small></p>

<p><small>Composing regular expressions at runtime
Backtracking is more efficient than repeated tries with
different regular expressions. If there are several regular
expressions and a match with any of them is acceptable, then
it is possible to combine them into a set of alternatives.
If the individual expressions are input data, this can be
done by programming a join operation. Well exploit this idea
in an improved version of the &quot;simple_grep&quot;
program: a program that matches multiple
patterns:</small></p>

<p><small>% cat &gt; multi_grep #!/usr/bin/perl #
multi_grep - match any of &lt;number&gt; regexps # usage:
multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2
...</small></p>

<p><small>$number = shift; $regexp[$_] = shift foreach
(0..$number-1); $pattern = join &rsquo;|&rsquo;,
@regexp;</small></p>

<p><small>while ($line = &lt;&gt;) { print $line if $line
=~ /$pattern/o; } ^D</small></p>

<p><small>% multi_grep 2 shift for multi_grep $number =
shift; $regexp[$_] = shift foreach
(0..$number-1);</small></p>

<p><small>Sometimes it is advantageous to construct a
pattern from the _input that is to be analyzed and use the
permissible values on the left hand side of the matching
operations. As an example for this somewhat paradoxical
situation, lets assume that our input contains a command
verb which should match one out of a set of available
command verbs, with the additional twist that commands may
be abbreviated as long as the given string is unique. The
program below demonstrates the basic algorithm.</small></p>

<p><small>% cat &gt; keymatch #!/usr/bin/perl $kwds =
&rsquo;copy compare list print&rsquo;; while( $command =
&lt;&gt; ){ $command =~ s/^; # trim leading and trailing
spaces c o m m a if( ( @matches = $kwds =~ /n d 2 8 8 print
&quot;command: &rsquo;@matches&rsquo;0; } elsif( @matches ==
0 ){ print &quot;no such command: &rsquo;$command&rsquo;0; }
else { print &quot;not unique: &rsquo;$command&rsquo; (could
be one of: @matches)0; } } ^D</small></p>

<p><small>% keymatch li command: &rsquo;list&rsquo; co not
unique: &rsquo;co&rsquo; (could be one of: copy compare)
printer no such command: &rsquo;printer&rsquo;</small></p>

<p><small>Rather than trying to match the input against the
keywords, we match the combined set of keywords against the
input. The pattern matching $ c o m m operation &quot;$kwds
=~ /a n d 8 6 4 time. It makes sure that the given command
begins where a keyword ) . I t t o l e r a t e s a b b r e v
begins (&quot;i 120 a t i o n s d u e t o t h e a d d e d
tells us the number of matches (&quot;scalar @matches&quot;)
and all the keywords that were actually matched. You could
hardly ask for more.</small></p>

<p><small>Embedding comments and modifiers in a regular
expression Starting with this section, we will be discussing
Perls set of extended patterns. These are extensions to the
traditional regular expression syntax that provide powerful
new tools for pattern matching. We have already seen
extensions in the form of the minimal matching constructs
&quot;??&quot;, &quot;*?&quot;, &quot;+?&quot;,
&quot;{n,m}?&quot;, and &quot;{n,}?&quot;. The rest of the
extensions below have the form &quot;(?char...)&quot;, where
the &quot;char&quot; is a character that determines the type
of extension.</small></p>

<p><small>The first extension is an embedded comment
&quot;(?#text)&quot;. This embeds a comment into the regular
expression without affecting its meaning. The comment should
not have any closing parentheses in the text. An example
is</small></p>

<p><small>/(?# Match an integer:)[+-]?+/;</small></p>

<p><small>This style of commenting has been largely
superseded by the raw, freeform commenting that is allowed
with the &quot;//x&quot; modifier.</small></p>

<p><small>The modifiers &quot;//i&quot;, &quot;//m&quot;,
&quot;//s&quot; and &quot;//x&quot; (or any combination
thereof) can also be embedded in a regexp using
&quot;(?i)&quot;, &quot;(?m)&quot;, &quot;(?s)&quot;, and
&quot;(?x)&quot;. For instance,</small></p>

<p><small>/(?i)yes/; # match &rsquo;yes&rsquo; case
insensitively /yes/i; # same thing /(?x)( # freeform version
of an integer regexp [+-]? # match an optional sign + #
match a sequence of digits ) /x;</small></p>

<p><small>Embedded modifiers can have two important
advantages over the usual modifiers. Embedded modifiers
allow a custom set of modifiers to _ each regexp pattern.
This is great for matching an array of regexps that must
have different modifiers:</small></p>

<p><small>$pattern[0] = &rsquo;(?i)doctor&rsquo;;
$pattern[1] = &rsquo;Johnson&rsquo;; ... while (&lt;&gt;) {
foreach $patt (@pattern) { print if /$patt/; } }</small></p>

<p><small>The second advantage is that embedded modifiers
(except &quot;//p&quot;, which modifies the entire regexp)
only affect the regexp inside the group the embedded
modifier is contained in. So grouping can be used to
localize the modifiers effects:</small></p>

<p><small>/Answer: ((?i)yes)/; # matches &rsquo;Answer:
yes&rsquo;, &rsquo;Answer: YES&rsquo;, etc.</small></p>

<p><small>Embedded modifiers can also turn off any
modifiers already present by using, e.g., &quot;(?-i)&quot;.
Modifiers can also be combined into a single expression,
e.g., &quot;(?s-i)&quot; turns on single line mode and turns
off case insensitivity.</small></p>

<p><small>Embedded modifiers may also be added to a
non-capturing grouping. &quot;(?i-m:regexp)&quot; is a
non-capturing grouping that matches &quot;regexp&quot; case
insensitively and turns off multi-line mode.</small></p>

<p><small>Looking ahead and looking behind This section
concerns the lookahead and lookbehind assertions. First, a
little background.</small></p>

<p><small>In Perl regular expressions, most regexp elements
eat up a certain amount of string when they match. For
instance, the regexp element &quot;[abc}]&quot; eats up one
character of the string when it matches, in the sense that
Perl moves to the next character position in the string
after the match. There are some elements, however, that dont
eat up characters (advance the character position) if they
match. The examples we have seen so far are the anchors. The
anchor &quot;^&quot; matches the beginning of the line, but
doesnt eat any characters. Similarly, m a t c h e s w h e r
e v e r a the word boundary anchor &quot;c h a r a c t e r m
a t c h i n g &quot;1464 characters itself. Anchors are
examples of _ zero-width assertions. Zero-width, because
they consume no characters, and assertions, because they
test some property of the string. In the context of our walk
in the woods analogy to regexp matching, most regexp
elements move us along a trail, but anchors have us stop a
moment and check our surroundings. If the local environment
checks out, we can proceed forward. But if the local
environment doesnt satisfy us, we must
backtrack.</small></p>

<p><small>Checking the environment entails either looking
ahead on the trail, looking behind, or both. &quot;^&quot;
looks behind, to see that there are no characters before.
&quot;$&quot; looks ahead, to see that there are no l o o k
s b o t h a h e a d a n d characters after. &quot;b e h i n
d , t o s e e i f t h e characters on either side differ in
their &quot;word-ness&quot;.</small></p>

<p><small>The lookahead and lookbehind assertions are
generalizations of the anchor concept. Lookahead and
lookbehind are zero-width assertions that let us specify
which characters we want to test for. The lookahead
assertion is denoted by &quot;(?=regexp)&quot; and the
lookbehind assertion is denoted by
&quot;(?&lt;=fixed-regexp)&quot;. Some examples
are</small></p>

<p><small>$x = &quot;I catch the housecat
&rsquo;Tom-cat&rsquo; with catnip&quot;; $x =~ /cat(?=/; #
matches &rsquo;cat&rsquo; in &rsquo;housecat&rsquo;
@catwords = ($x =~ /(?&lt;=cat384 # $catwords[0] =
&rsquo;catch&rsquo; # $catwords[1] = &rsquo;catnip&rsquo; a
$x =~ /t $x =~ /(?&lt;=cat(?=/; # doesn&rsquo;t match; no
isolated &rsquo;cat&rsquo; in # middle of $x</small></p>

<p><small>Note that the parentheses in
&quot;(?=regexp)&quot; and &quot;(?&lt;=regexp)&quot; are
non- capturing, since these are zero-width assertions. Thus
in the second regexp, the substrings captured are those of
the whole regexp itself. Lookahead &quot;(?=regexp)&quot;
can match arbitrary regexps, but lookbehind
&quot;(?&lt;=fixed-regexp)&quot; only works for regexps of
fixed width, i.e., a fixed number of characters long. Thus
&quot;(?&lt;=(ab|bc))&quot; is fine, but
&quot;(?&lt;=(ab)*)&quot; is not. The negated versions of
the lookahead and lookbehind assertions are denoted by
&quot;(?!regexp)&quot; and &quot;(?&lt;!fixed-regexp)&quot;
respectively. They evaluate true if the regexps do not
match:</small></p>

<p><small>$x = &quot;foobar&quot;; $x =~ /foo(?!bar)/; #
doesn&rsquo;t match, &rsquo;bar&rsquo; follows
&rsquo;foo&rsquo; $x =~ /foo(?!baz)/; # matches,
&rsquo;baz&rsquo; doesn&rsquo;t follow &rsquo;foo&rsquo; $x
=~ /(?&lt;!foo/; # matches, there is no before
&rsquo;foo&rsquo;</small></p>

<p><small>The &quot;is unsupported in lookbehind, because
the already treacherous definition of &quot;would become
even more so when going backwards.</small></p>

<p><small>Here is an example where a string containing
blank-separated words, numbers and single dashes is to be
split into its components. Using &quot;/&quot; alone wont
work, because spaces are not required between dashes, or a
word or a dash. Additional places for a split are
established by looking ahead and behind:</small></p>

<p><small>$str = &quot;one two - --6-8&quot;; @toks = split
/ # a run of spaces | (?&lt;= (?=-) # any non-space followed
by &rsquo;-&rsquo; | (?&lt;=-) (?= # a &rsquo;-&rsquo;
followed by any non-space /x, $str; # @toks = qw(one two - -
- 6 - 8)</small></p>

<p><small>Using independent subexpressions to prevent
backtracking Independent subexpressions are regular
expressions, in the context of a larger regular expression,
that function independently of the larger regular
expression. That is, they consume as much or as little of
the string as they wish without regard for the ability of
the larger regexp to match. Independent subexpressions are
represented by &quot;(?&gt;regexp)&quot;. We can illustrate
their behavior by first considering an ordinary
regexp:</small></p>

<p><small>$x = &quot;ab&quot;; $x =~ /a*ab/; #
matches</small></p>

<p><small>This obviously matches, but in the process of
matching, the subexpression &quot;a*&quot; first grabbed the
&quot;a&quot;. Doing so, however, wouldnt allow the whole
regexp to match, so after backtracking, &quot;a*&quot;
eventually gave back the &quot;a&quot; and matched the empty
string. Here, what &quot;a*&quot; matched was _ dependent on
what the rest of the regexp matched.</small></p>

<p><small>Contrast that with an independent
subexpression:</small></p>

<p><small>$x =~ /(?&gt;a*)ab/; # doesn&rsquo;t
match!</small></p>

<p><small>The independent subexpression
&quot;(?&gt;a*)&quot; doesnt care about the rest of the
regexp, so it sees an &quot;a&quot; and grabs it. Then the
rest of the regexp &quot;ab&quot; cannot match. Because
&quot;(?&gt;a*)&quot; is independent, there is no
backtracking and the independent subexpression does not give
up its &quot;a&quot;. Thus the match of the regexp as a
whole fails. A similar behavior occurs with completely
independent regexps:</small></p>

<p><small>$x = &quot;ab&quot;; $x =~ /a*/g; # matches, eats
an &rsquo;a&rsquo; $x =~ /Gab/g; # doesn&rsquo;t match, no
&rsquo;a&rsquo; available</small></p>

<p><small>Here &quot;//g&quot; and &quot;G&quot; create a
tag team handoff of the string from one regexp to the other.
Regexps with an independent subexpression are much like
this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the
enclosing regexp.</small></p>

<p><small>The ability of an independent subexpression to
prevent backtracking can be quite useful. Suppose we want to
match a non-empty string enclosed in parentheses up to two
levels deep. Then the following regexp matches:</small></p>

<p><small>$x = &quot;abc(de(fg)h&quot;; # unbalanced
parentheses $x =~ /( [^()]+ | ()]* )+ /x;</small></p>

<p><small>The regexp matches an open parenthesis, one or
more copies of an alternation, and a close parenthesis. The
alternation is two-way, with the first alternative
&quot;[^()]+&quot; matching a substring with no parentheses
and the second alternative &quot;()]*&quot; matching a
substring delimited by parentheses. The problem with this
regexp is that it is pathological: it has nested
indeterminate quantifiers of the form &quot;(a+|b)+&quot;.
We discussed in Part 1 how nested quantifiers like this
could take an exponentially long time to execute if there
was no match possible. To prevent the exponential blowup, we
need to prevent useless backtracking at some point. This can
be done by enclosing the inner quantifier as an independent
subexpression:</small></p>

<p><small>$x =~ /( (?&gt;[^()]+) | ()]* )+ /x;</small></p>

<p><small>Here, &quot;(?&gt;[^()]+)&quot; breaks the
degeneracy of string partitioning by gobbling up as much of
the string as possible and keeping it. Then match failures
fail much more quickly.</small></p>

<p><small>Conditional expressions A conditional expression
is a form of if-then-else statement that allows one to
choose which patterns are to be matched, based on some
condition. There are two types of conditional expression:
&quot;(?(condition)yes-regexp)&quot; and
&quot;(?(condition)yes-regexp|no-regexp)&quot;.
&quot;(?(condition)yes-regexp)&quot; is like an &rsquo;if ()
{}&rsquo; statement in Perl. If the &quot;condition&quot; is
true, the &quot;yes-regexp&quot; will be matched. If the
&quot;condition&quot; is false, the &quot;yes-regexp&quot;
will be skipped and Perl will move onto the next regexp
element. The second form is like an &rsquo;if () {} else
{}&rsquo; statement in Perl. If the &quot;condition&quot; is
true, the &quot;yes-regexp&quot; will be matched, otherwise
the &quot;no-regexp&quot; will be matched.</small></p>

<p><small>The &quot;condition&quot; can have several forms.
The first form is simply an integer in parentheses
&quot;(integer)&quot;. It is true if the corresponding
backreference &quot;integer&quot; matched earlier in the
regexp. The same thing can be done with a name associated
with a capture buffer, written as &quot;(&lt;name&gt;)&quot;
or &quot;(&rsquo;name&rsquo;)&quot;. The second form is a
bare zero width assertion &quot;(?...)&quot;, either a
lookahead, a lookbehind, or a code assertion (discussed in
the next section). The third set of forms provides tests
that return true if the expression is executed within a
recursion (&quot;(R)&quot;) or is being called from some
capturing group, referenced either by number
(&quot;(R1)&quot;, &quot;(R2)&quot;,...) or by name
(&quot;(R&amp;name)&quot;).</small></p>

<p><small>The integer or name form of the
&quot;condition&quot; allows us to choose, with more
flexibility, what to match based on what matched earlier in
the regexp. This searches for words of the form
&quot;$x$x&quot; or &quot;$x$y$y$x&quot;:</small></p>

<p><small>% simple_grep &rsquo;^(120 beriberi coco couscous
deed ... toot toto tutu</small></p>

<p><small>The lookbehind &quot;condition&quot; allows,
along with backreferences, an earlier part of the match to
influence a later part of the match. For
instance,</small></p>

<p><small>/[ATGC]+(?(?&lt;=AA)G|C)$/;</small></p>

<p><small>matches a DNA sequence such that it either ends
in &quot;AAG&quot;, or some other base pair combination and
&quot;C&quot;. Note that the form is
&quot;(?(?&lt;=AA)G|C)&quot; and not
&quot;(?((?&lt;=AA))G|C)&quot;; for the lookahead,
lookbehind or code assertions, the parentheses around the
conditional are not needed.</small></p>

<p><small>Defining named patterns Some regular expressions
use identical subpatterns in several places. Starting with
Perl 5.10, it is possible to define named subpatterns in a
section of the pattern so that they can be called up by name
anywhere in the pattern. This syntactic pattern for this
definition group is
&quot;(?(DEFINE)(?&lt;name&gt;pattern)...)&quot;. An
insertion of a named pattern is written as
&quot;(?&amp;name)&quot;.</small></p>

<p><small>The example below illustrates this feature using
the pattern for floating point numbers that was presented
earlier on. The three subpatterns that are used more than
once are the optional sign, the digit sequence for an
integer and the decimal fraction. The DEFINE group at the
end of the pattern contains their definition. Notice that
the decimal fraction pattern is the first place where we can
reuse the integer pattern.</small></p>

<p><small>/^ (?&amp;osg) * ( (?&amp;int)(?&amp;dec)? |
(?&amp;dec) ) (?: [eE](?&amp;osg)(?&amp;int) )? $ (?(DEFINE)
(?&lt;osg&gt;[-+]?) # optional sign (?&lt;int&gt;++) #
integer (?&lt;dec&gt;.(?&amp;int)) # decimal fraction
)/x</small></p>

<p><small>Recursive patterns This feature (introduced in
Perl 5.10) significantly extends the power of Perl s pattern
matching. By referring to some other capture group anywhere
in the pattern with the construct &quot;(?group-ref)&quot;,
the _pattern within the referenced group is used as an
independent subpattern in place of the group reference
itself. Because the group reference may be contained _
within the group it refers to, it is now possible to apply
pattern matching to tasks that hitherto required a recursive
parser.</small></p>

<p><small>To illustrate this feature, well design a pattern
that matches if a string contains a palindrome. (This is a
word or a sentence that, while ignoring spaces,
interpunctuation and case, reads the same backwards as
forwards. We begin by observing that the empty string or a
string containing just one word character is a palindrome.
Otherwise it must have a word character up front and the
same at its end, with another palindrome in
between.</small></p>

<p><small>/(?: (696 -1} | 96</small></p>

<p><small>Adding &quot;W*&quot; at either end to eliminate
what is to be ignored, we already have the full
pattern:</small></p>

<p><small>my $pp = qr/^(W* (?: (96 -1} | 264 for $s (
&quot;saippuakauppias&quot;, &quot;A man, a plan, a canal:
Panama!&quot; ){ print &quot;&rsquo;$s&rsquo; is a
palindrome0 if $s =~ /$pp/; }</small></p>

<p><small>In &quot;(?...)&quot; both absolute and relative
backreferences may be used. The entire pattern can be
reinserted with &quot;(?R)&quot; or &quot;(?0)&quot;. If you
prefer to name your buffers, you can use
&quot;(?&amp;name)&quot; to recurse into that
buffer.</small></p>

<p><small>A bit of magic: executing Perl code in a regular
expression Normally, regexps are a part of Perl expressions.
_ Code evaluation expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp. A code
evaluation expression is denoted &quot;(?{code})&quot;, with
_code a string of Perl statements.</small></p>

<p><small>Be warned that this feature is considered
experimental, and may be changed without notice.</small></p>

<p><small>Code expressions are zero-width assertions, and
the value they return depends on their environment. There
are two possibilities: either the code expression is used as
a conditional in a conditional expression
&quot;(?(condition)...)&quot;, or it is not. If the code
expression is a conditional, the code is evaluated and the
result (i.e., the result of the last statement) is used to
determine truth or falsehood. If the code expression is not
used as a conditional, the assertion always evaluates true
and the result is put into the special variable $^R. The
variable $^R can then be used in code expressions later in
the regexp. Here are some silly examples:</small></p>

<p><small>$x = &quot;abcdef&quot;; $x =~ /abc(?{print
&quot;Hi Mom!&quot;;})def/; # matches, # prints &rsquo;Hi
Mom!&rsquo; $x =~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; #
doesn&rsquo;t match, # no &rsquo;Hi Mom!&rsquo;</small></p>

<p><small>Pay careful attention to the next
example:</small></p>

<p><small>$x =~ /abc(?{print &quot;Hi Mom!&quot;;})ddd/; #
doesn&rsquo;t match, # no &rsquo;Hi Mom!&rsquo; # but why
not?</small></p>

<p><small>At first glance, you d think that it shouldn t
print, because obviously the &quot;ddd&quot; isnt going to
match the target string. But look at this
example:</small></p>

<p><small>$x =~ /abc(?{print &quot;Hi Mom!&quot;;})[d]dd/;
# doesn&rsquo;t match, # but _does_ print</small></p>

<p><small>Hmm. What happened here? If youve been following
along, you know that the above pattern should be effectively
the same as the last one -- enclosing the d in a character
class isnt going to change what it matches. So why does the
first not print while the second one does?</small></p>

<p><small>The answer lies in the optimizations the regex
engine makes. In the first case, all the engine sees are
plain old characters (aside from the &quot;?{}&quot;
construct). Its smart enough to realize that the string ddd
doesn t occur in our target string before actually running
the pattern through. But in the second case, weve tricked it
into thinking that our pattern is more complicated than it
is. It takes a look, sees our character class, and decides
that it will have to actually run the pattern to determine
whether or not it matches, and in the process of running it
hits the print statement before it discovers that we dont
have a match.</small></p>

<p><small>To take a closer look at how the engine does
optimizations, see the section &quot;Pragmas and
debugging&quot; below.</small></p>

<p><small>More fun with &quot;?{}&quot;:</small></p>

<p><small>$x =~ /(?{print &quot;Hi Mom!&quot;;})/; #
matches, # prints &rsquo;Hi Mom!&rsquo; $x =~ /(?{$c =
1;})(?{print &quot;$c&quot;;})/; # matches, # prints
&rsquo;1&rsquo; $x =~ /(?{$c = 1;})(?{print
&quot;$^R&quot;;})/; # matches, # prints
&rsquo;1&rsquo;</small></p>

<p><small>The bit of magic mentioned in the section title
occurs when the regexp backtracks in the process of
searching for a match. If the regexp backtracks over a code
expression and if the variables used within are localized
using &quot;local&quot;, the changes in the variables
produced by the code expression are undone! Thus, if we
wanted to count how many times a character got matched
inside a group, we could use, e.g.,</small></p>

<p><small>$x = &quot;aaaa&quot;; $count = 0; # initialize
&rsquo;a&rsquo; count $c = &quot;bob&quot;; # test if $c
gets clobbered $x =~ /(?{local $c = 0;}) # initialize count
( a # match &rsquo;a&rsquo; (?{local $c = $c + 1;}) #
increment count )* # do this any number of times, aa # but
match &rsquo;aa&rsquo; at the end (?{$count = $c;}) # copy
local $c var into $count /x; print &quot;&rsquo;a&rsquo;
count is $count, variable is &rsquo;$c&rsquo;0;</small></p>

<p><small>This prints</small></p>

<p><small>&rsquo;a&rsquo; count is 2, $c variable is
&rsquo;bob&rsquo;</small></p>

<p><small>If we replace the &quot; (?{local $c = $c +
1;})&quot; with &quot; (?{$c = $c + 1;})&quot;, the variable
changes are _ not undone during backtracking, and we
get</small></p>

<p><small>&rsquo;a&rsquo; count is 4, $c variable is
&rsquo;bob&rsquo;</small></p>

<p><small>Note that only localized variable changes are
undone. Other side effects of code expression execution are
permanent. Thus</small></p>

<p><small>$x = &quot;aaaa&quot;; $x =~ /(a(?{print
&quot;Yow0;}))*aa/;</small></p>

<p><small>produces</small></p>

<p><small>Yow Yow Yow Yow</small></p>

<p><small>The result $^R is automatically localized, so
that it will behave properly in the presence of
backtracking.</small></p>

<p><small>This example uses a code expression in a
conditional to match a definite article, either the in
English or der|die|das in German:</small></p>

<p><small>$lang = &rsquo;DE&rsquo;; # use German ... $text
= &quot;das&quot;; print &quot;matched0 if $text =~ /(?(?{
$lang eq &rsquo;EN&rsquo;; # is the language English? }) the
| # if so, then match &rsquo;the&rsquo; (der|die|das) #
else, match &rsquo;der|die|das&rsquo; ) /xi;</small></p>

<p><small>Note that the syntax here is
&quot;(?(?{...})yes-regexp|no-regexp)&quot;, not
&quot;(?((?{...}))yes-regexp|no-regexp)&quot;. In other
words, in the case of a code expression, we dont need the
extra parentheses around the conditional.</small></p>

<p><small>If you try to use code expressions with
interpolating variables, Perl may surprise you:</small></p>

<p><small>$bar = 5; $pat = &rsquo;(?{ 1 })&rsquo;; /foo(?{
$bar })bar/; # compiles ok, $bar not interpolated /foo(?{ 1
})$bar/; # compile error! /foo${pat}bar/; # compile
error!</small></p>

<p><small>$pat = qr/(?{ $foo = 1 })/; # precompile code
regexp /foo${pat}bar/; # compiles ok</small></p>

<p><small>If a regexp has (1) code expressions and
interpolating variables, or (2) a variable that interpolates
a code expression, Perl treats the regexp as an error. If
the code expression is precompiled into a variable, however,
interpolating is ok. The question is, why is this an
error?</small></p>

<p><small>The reason is that variable interpolation and
code expressions together pose a security risk. The
combination is dangerous because many programmers who write
search engines often take user input and plug it directly
into a regexp:</small></p>

<p><small>$regexp = &lt;&gt;; # read user-supplied regexp
$chomp $regexp; # get rid of possible newline $text =~
/$regexp/; # search $text for the $regexp</small></p>

<p><small>If the $regexp variable contains a code
expression, the user could then execute arbitrary Perl code.
For instance, some joker could search for
&quot;system(&rsquo;rm -rf *&rsquo;);&quot; to erase your
files. In this sense, the combination of interpolation and
code expressions _ taints your regexp. So by default, using
both interpolation and code expressions in the same regexp
is not allowed. If youre not concerned about malicious
users, it is possible to bypass this security check by
invoking &quot;use re &rsquo;eval&rsquo;&quot;:</small></p>

<p><small>use re &rsquo;eval&rsquo;; # throw caution out
the door $bar = 5; $pat = &rsquo;(?{ 1 })&rsquo;; /foo(?{ 1
})$bar/; # compiles ok /foo${pat}bar/; # compiles
ok</small></p>

<p><small>Another form of code expression is the _ pattern
code expression. The pattern code expression is like a
regular code expression, except that the result of the code
evaluation is treated as a regular expression and matched
immediately. A simple example is</small></p>

<p><small>$length = 5; $char = &rsquo;a&rsquo;; $x =
&rsquo;aaaaabb&rsquo;; $x =~ /(??{$char x $length})/x; #
matches, there are 5 of &rsquo;a&rsquo;</small></p>

<p><small>This final example contains both ordinary and
pattern code expressions. It detects whether a binary string
1101010010001... has a Fibonacci spacing 0,1,1,2,3,5,... of
the 1s:</small></p>

<p><small>$x = &quot;1101010010001000001&quot;; $z0 =
&rsquo;&rsquo;; $z1 = &rsquo;0&rsquo;; # initial conditions
print &quot;It is a Fibonacci sequence0 if $x =~ /^1 # match
an initial &rsquo;1&rsquo; (?: ((??{ $z0 })) # match some
&rsquo;0&rsquo; 1 # and then a &rsquo;1&rsquo; (?{ $z0 =
$z1; $z1 .= $^N; }) )+ # repeat as needed $ # that is all
there is /x; printf &quot;Largest sequence matched was %d0,
length($z1)-length($z0);</small></p>

<p><small>Remember that $^N is set to whatever was matched
by the last completed capture group. This prints</small></p>

<p><small>It is a Fibonacci sequence Largest sequence
matched was 5</small></p>

<p><small>Ha! Try that with your garden variety regexp
package...</small></p>

<p><small>Note that the variables $z0 and $z1 are not
substituted when the regexp is compiled, as happens for
ordinary variables outside a code expression. Rather, the
code expressions are evaluated when Perl encounters them
during the search for a match.</small></p>

<p><small>The regexp without the &quot;//x&quot; modifier
is</small></p>

<p><small>/^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N;
}))+$/</small></p>

<p><small>which shows that spaces are still possible in the
code parts. Nevertheless, when working with code and
conditional expressions, the extended form of regexps is
almost necessary in creating and debugging
regexps.</small></p>

<p><small>Backtracking control verbs Perl 5.10 introduced a
number of control verbs intended to provide detailed control
over the backtracking process, by directly influencing the
regexp engine and by providing monitoring techniques. As all
the features in this group are experimental and subject to
change or removal in a future version of Perl, the
interested reader is referred to &quot;Special Backtracking
Control Verbs&quot; in perlre for a detailed
description.</small></p>

<p><small>Below is just one example, illustrating the
control verb &quot;(*FAIL)&quot;, which may be abbreviated
as &quot;(*F)&quot;. If this is inserted in a regexp it will
cause to fail, just like at some mismatch between the
pattern and the string. Processing of the regexp continues
like after any &quot;normal&quot; failure, so that, for
instance, the next position in the string or another
alternative will be tried. As failing to match doesnt
preserve capture buffers or produce results, it may be
necessary to use this in combination with embedded
code.</small></p>

<p><small>%count = ();
&quot;supercalifragilisticexpialidoceous&quot; =~
/([aeiou])(?{ $count{$1}++; })(*FAIL)/oi; printf &quot;%3d
&rsquo;%s&rsquo;0, $count{$_}, $_ for (sort keys
%count);</small></p>

<p><small>The pattern begins with a class matching a subset
of letters. Whenever this matches, a statement like
&quot;$count{&rsquo;a&rsquo;}++;&quot; is executed,
incrementing the letters counter. Then &quot;(*FAIL)&quot;
does what it says, and the regexp engine proceeds according
to the book: as long as the end of the string hasnt been
reached, the position is advanced before looking for another
vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the the entire string has been
inspected. (It s remarkable that an alternative solution
using something like</small></p>

<p><small>$count{lc($_)}++ for split(&rsquo;&rsquo;,
&quot;supercalifragilisticexpialidoceous&quot;); printf
&quot;%3d &rsquo;%s&rsquo;0, $count2{$_}, $_ for ( qw{ a e i
o u } );</small></p>

<p><small>is considerably slower.)</small></p>

<p><small>Pragmas and debugging Speaking of debugging,
there are several pragmas available to control and debug
regexps in Perl. We have already encountered one pragma in
the previous section, &quot;use re
&rsquo;eval&rsquo;;&quot;, that allows variable
interpolation and code expressions to coexist in a regexp.
The other pragmas are</small></p>

<p><small>use re &rsquo;taint&rsquo;; $tainted = &lt;&gt;;
@parts = ($tainted =~ /(72</small></p>

<p><small>The &quot;taint&quot; pragma causes any
substrings from a match with a tainted variable to be
tainted as well. This is not normally the case, as regexps
are often used to extract the safe bits from a tainted
variable. Use &quot;taint&quot; when you are not extracting
safe bits, but are performing some other processing. Both
&quot;taint&quot; and &quot;eval&quot; pragmas are lexically
scoped, which means they are in effect only until the end of
the block enclosing the pragmas.</small></p>

<p><small>use re &rsquo;debug&rsquo;; /^(.*)$/s; # output
debugging info</small></p>

<p><small>use re &rsquo;debugcolor&rsquo;; /^(.*)$/s; #
output debugging info in living color</small></p>

<p><small>The global &quot;debug&quot; and
&quot;debugcolor&quot; pragmas allow one to get detailed
debugging info about regexp compilation and execution.
&quot;debugcolor&quot; is the same as debug, except the
debugging information is displayed in color on terminals
that can display termcap color sequences. Here is example
output:</small></p>

<p><small>% perl -e &rsquo;use re &quot;debug&quot;;
&quot;abc&quot; =~ /a*b+c/;&rsquo; Compiling REx
&lsquo;a*b+c&rsquo; size 9 first at 1 1: STAR(4) 2: EXACT
&lt;a&gt;(0) 4: PLUS(7) 5: EXACT &lt;b&gt;(0) 7: EXACT
&lt;c&gt;(9) 9: END(0) floating &lsquo;bc&rsquo; at
0..2147483647 (checking floating) minlen 2 Guessing start of
match, REx &lsquo;a*b+c&rsquo; against &lsquo;abc&rsquo;...
Found floating substr &lsquo;bc&rsquo; at offset 1...
Guessed: match at offset 0 Matching REx &lsquo;a*b+c&rsquo;
against &lsquo;abc&rsquo; Setting an EVAL scope, savestack=3
0 &lt;&gt; &lt;abc&gt; | 1: STAR EXACT &lt;a&gt; can match 1
times out of 32767... Setting an EVAL scope, savestack=3 1
&lt;a&gt; &lt;bc&gt; | 4: PLUS EXACT &lt;b&gt; can match 1
times out of 32767... Setting an EVAL scope, savestack=3 2
&lt;ab&gt; &lt;c&gt; | 7: EXACT &lt;c&gt; 3 &lt;abc&gt;
&lt;&gt; | 9: END Match successful! Freeing REx:
&lsquo;a*b+c&rsquo;</small></p>

<p><small>If you have gotten this far into the tutorial,
you can probably guess what the different parts of the
debugging output tell you. The first part</small></p>

<p><small>Compiling REx &lsquo;a*b+c&rsquo; size 9 first at
1 1: STAR(4) 2: EXACT &lt;a&gt;(0) 4: PLUS(7) 5: EXACT
&lt;b&gt;(0) 7: EXACT &lt;c&gt;(9) 9: END(0)</small></p>

<p><small>describes the compilation stage. STAR(4) means
that there is a starred object, in this case
&rsquo;a&rsquo;, and if it matches, goto line 4, i.e.,
PLUS(7). The middle lines describe some heuristics and
optimizations performed before a match:</small></p>

<p><small>floating &lsquo;bc&rsquo; at 0..2147483647
(checking floating) minlen 2 Guessing start of match, REx
&lsquo;a*b+c&rsquo; against &lsquo;abc&rsquo;... Found
floating substr &lsquo;bc&rsquo; at offset 1... Guessed:
match at offset 0</small></p>

<p><small>Then the match is executed and the remaining
lines describe the process:</small></p>

<p><small>Matching REx &lsquo;a*b+c&rsquo; against
&lsquo;abc&rsquo; Setting an EVAL scope, savestack=3 0
&lt;&gt; &lt;abc&gt; | 1: STAR EXACT &lt;a&gt; can match 1
times out of 32767... Setting an EVAL scope, savestack=3 1
&lt;a&gt; &lt;bc&gt; | 4: PLUS EXACT &lt;b&gt; can match 1
times out of 32767... Setting an EVAL scope, savestack=3 2
&lt;ab&gt; &lt;c&gt; | 7: EXACT &lt;c&gt; 3 &lt;abc&gt;
&lt;&gt; | 9: END Match successful! Freeing REx:
&lsquo;a*b+c&rsquo;</small></p>

<p><small>Each step is of the form &quot;n &lt;x&gt;
&lt;y&gt;&quot;, with &quot;&lt;x&gt;&quot; the part of the
string matched and &quot;&lt;y&gt;&quot; the part not yet
matched. The &quot;| 1: STAR&quot; says that Perl is at line
number 1 n the compilation list above. See &quot;Debugging
regular expressions&quot; in perldebguts for much more
detail.</small></p>

<p><small>An alternative method of debugging regexps is to
embed &quot;print&quot; statements within the regexp. This
provides a blow-by-blow account of the backtracking in an
alternation:</small></p>

<p><small>&quot;that this&quot; =~ m@(?{print &quot;Start
at position &quot;, pos, &quot;0;}) t(?{print &quot;t10;})
h(?{print &quot;h10;}) i(?{print &quot;i10;}) s(?{print
&quot;s10;}) | t(?{print &quot;t20;}) h(?{print &quot;h20;})
a(?{print &quot;a20;}) t(?{print &quot;t20;}) (?{print
&quot;Done at position &quot;, pos, &quot;0;})
@x;</small></p>

<p><small>prints</small></p>

<p><small>Start at position 0 t1 h1 t2 h2 a2 t2 Done at
position 4</small></p>

<p><small>BUGS Code expressions, conditional expressions,
and independent expressions are _experimental. Dont use them
in production code. Yet.</small></p>

<p><small>SEE ALSO This is just a tutorial. For the full
story on Perl regular expressions, see the perlre regular
expressions reference page.</small></p>

<p><small>For more information on the matching
&quot;m//&quot; and substitution &quot;s///&quot; operators,
see &quot;Regexp Quote-Like Operators&quot; in perlop. For
information on the &quot;split&quot; operation, see
&quot;split&quot; in perlfunc.</small></p>

<p><small>For an excellent all-around resource on the care
and feeding of regular expressions, see the book _ Mastering
Regular Expressions by Jeffrey Friedl (published by OReilly,
ISBN 1556592-257-3).</small></p>

<p><small>AUTHOR AND COPYRIGHT Copyright (c) 2000 Mark
Kvale All rights reserved.</small></p>

<p><small>This document may be distributed under the same
terms as Perl itself.</small></p>

<p><small>Acknowledgments The inspiration for the stop
codon DNA example came from the ZIP code example in chapter
7 of _ Mastering Regular Expressions.</small></p>

<p><small>The author would like to thank Jeff Pinyan,
Andrew Johnson, Peter Haworth, Ronald J Kimball, and Joe
Smith for all their helpful comments.</small></p>

<p><small>perl v5.10.1 2009-06-12 PERLRETUT(1)</small></p>
<hr>
</body>
</html>
