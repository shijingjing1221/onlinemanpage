<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLOBJ(1) Perl Programmers Reference Guide
PERLOBJ(1)</p>

<p>NAME perlobj - Perl objects</p>

<p>DESCRIPTION First you need to understand what references
are in Perl. See perlref for that. Second, if you still find
the following reference work too complicated, a tutorial on
object-oriented programming in Perl can be found in perltoot
and perltooc.</p>

<p>If you re still with us, then here are three very simple
definitions that you should find reassuring.</p>

<p>1. An object is simply a reference that happens to know
which class it belongs to.</p>

<p>2. A class is simply a package that happens to provide
methods to deal with object references.</p>

<p>3. A method is simply a subroutine that expects an
object reference (or a package name, for class methods) as
the first argument.</p>

<p>Well cover these points now in more depth.</p>

<p>An Object is Simply a Reference Unlike say C++, Perl
doesnt provide any special syntax for constructors. A
constructor is merely a subroutine that returns a reference
to something &quot;blessed&quot; into a class, generally the
class that the subroutine is defined in. Here is a typical
constructor:</p>

<p>package Critter; sub new { bless {} }</p>

<p>That word &quot;new&quot; isnt special. You could have
written a construct this way, too:</p>

<p>package Critter; sub spawn { bless {} }</p>

<p>This might even be preferable, because the C++
programmers wont be tricked into thinking that
&quot;new&quot; works in Perl as it does in C++. It doesn t.
We recommend that you name your constructors whatever makes
sense in the context of the problem you re solving. For
example, constructors in the Tk extension to Perl are named
after the widgets they create.</p>

<p>One thing thats different about Perl constructors
compared with those in C++ is that in Perl, they have to
allocate their own memory. (The other things is that they
don t automatically call overridden base- class
constructors.) The &quot;{}&quot; allocates an anonymous
hash containing no key/value pairs, and returns it The
bless() takes that reference and tells the object it
references that its now a Critter, and returns the
reference. This is for convenience, because the referenced
object itself knows that it has been blessed, and the
reference to it could have been returned directly, like
this:</p>

<p>sub new { my $self = {}; bless $self; return $self;
}</p>

<p>You often see such a thing in more complicated
constructors that wish to call methods in the class as part
of the construction:</p>

<p>sub new { my $self = {}; bless $self;
$self-&gt;initialize(); return $self; }</p>

<p>If you care about inheritance (and you should; see
&quot;Modules: Creation, Use, and Abuse&quot; in
perlmodlib), then you want to use the two-arg form of bless
so that your constructors may be inherited:</p>

<p>sub new { my $class = shift; my $self = {}; bless $self,
$class; $self-&gt;initialize(); return $self; }</p>

<p>Or if you expect people to call not just
&quot;CLASS-&gt;new()&quot; but also
&quot;$obj-&gt;new()&quot;, then use something like the
following. (Note that using this to call new() on an
instance does not automatically perform any copying. If you
want a shallow or deep copy of an object, youll have to
specifically allow for that.) The initialize() method used
will be of whatever $class we blessed the object into:</p>

<p>sub new { my $this = shift; my $class = ref($this) ||
$this; my $self = {}; bless $self, $class;
$self-&gt;initialize(); return $self; }</p>

<p>Within the class package, the methods will typically
deal with the reference as an ordinary reference. Outside
the class package, the reference is generally treated as an
opaque value that may be accessed only through the classs
methods.</p>

<p>Although a constructor can in theory re-bless a
referenced object currently belonging to another class, this
is almost certainly going to get you into trouble. The new
class is responsible for all cleanup later. The previous
blessing is forgotten, as an object may belong to only one
class at a time. (Although of course its free to inherit
methods from many classes.) If you find yourself having to
do this, the parent class is probably misbehaving,
though.</p>

<p>A clarification: Perl objects are blessed. References
are not. Objects know which package they belong to.
References do not. The bless() function uses the reference
to find the object. Consider the following example:</p>

<p>$a = {}; $b = $a; bless $a, BLAH; print &quot; is a
&quot;, ref($b), &quot;0;</p>

<p>This reports $b as being a BLAH, so obviously bless()
operated on the object and not on the reference.</p>

<p>A Class is Simply a Package Unlike say C++, Perl doesnt
provide any special syntax for class definitions. You use a
package as a class by putting method definitions into the
class.</p>

<p>There is a special array within each package called
@ISA, which says where else to look for a method if you cant
find it in the current package. This is how Perl implements
inheritance. Each element of the @ISA array is just the name
of another package that happens to be a class package. The
classes are searched for missing methods in depth- first,
left-to-right order by default (see mro for alternative
search order and other in-depth information). The classes
accessible through @ISA are known as base classes of the
current class.</p>

<p>All classes implicitly inherit from class
&quot;UNIVERSAL&quot; as their last base class. Several
commonly used methods are automatically supplied in the
UNIVERSAL class; see &quot;Default UNIVERSAL methods&quot;
or UNIVERSAL for more details.</p>

<p>If a missing method is found in a base class, it is
cached in the current class for efficiency. Changing @ISA or
defining new subroutines invalidates the cache and causes
Perl to do the lookup again.</p>

<p>If neither the current class, its named base classes,
nor the UNIVERSAL class contains the requested method, these
three places are searched all over again, this time looking
for a method named AUTOLOAD(). If an AUTOLOAD is found, this
method is called on behalf of the missing method, setting
the package global $AUTOLOAD to be the fully qualified name
of the method that was intended to be called.</p>

<p>If none of that works, Perl finally gives up and
complains.</p>

<p>If you want to stop the AUTOLOAD inheritance say
simply</p>

<p>sub AUTOLOAD;</p>

<p>and the call will die using the name of the sub being
called.</p>

<p>Perl classes do method inheritance only. Data
inheritance is left up to the class itself. By and large,
this is not a problem in Perl, because most classes model
the attributes of their object using an anonymous hash,
which serves as its own little namespace to be carved up by
the various classes that might want to do something with the
object. The only problem with this is that you cant sure
that you arent using a piece of the hash that isnt already
used. A reasonable workaround is to prepend your fieldname
in the hash with the package name.</p>

<p>sub bump { my $self = shift; $self-&gt;{ __PACKAGE__ .
&quot;.count&quot;}++; }</p>

<p>A Method is Simply a Subroutine Unlike say C++, Perl
doesnt provide any special syntax for method definition. (It
does provide a little syntax for method invocation though.
More on that later.) A method expects its first argument to
be the object (reference) or package (string) it is being
invoked on. There are two ways of calling methods, which
well call class methods and instance methods.</p>

<p>A class method expects a class name as the first
argument. It provides functionality for the class as a
whole, not for any individual object belonging to the class.
Constructors are often class methods, but see perltoot and
perltooc for alternatives. Many class methods simply ignore
their first argument, because they already know what package
they re in and dont care what package they were invoked via.
(These arent necessarily the same, because class methods
follow the inheritance tree just like ordinary instance
methods.) Another typical use for class methods is to look
up an object by name:</p>

<p>sub find { my ($class, $name) = @_; $objtable{$name};
}</p>

<p>An instance method expects an object reference as its
first argument. Typically it shifts the first argument into
a &quot;self&quot; or &quot;this&quot; variable, and then
uses that as an ordinary reference.</p>

<p>sub display { my $self = shift; my @keys = @_ ? @_ :
sort keys %$self; foreach $key (@keys) { print &quot;$key
=&gt; $self-&gt;{$key}0; } }</p>

<p>Method Invocation For various historical and other
reasons, Perl offers two equivalent ways to write a method
call. The simpler and more common way is to use the arrow
notation:</p>

<p>my $fred = Critter-&gt;find(&quot;Fred&quot;);
$fred-&gt;display(&quot;Height&quot;,
&quot;Weight&quot;);</p>

<p>You should already be familiar with the use of the
&quot;-&gt;&quot; operator with references. In fact, since
$fred above is a reference to an object, you could think of
the method call as just another form of dereferencing.</p>

<p>Whatever is on the left side of the arrow, whether a
reference or a class name, is passed to the method
subroutine as its first argument. So the above code is
mostly equivalent to:</p>

<p>my $fred = Critter::find(&quot;Critter&quot;,
&quot;Fred&quot;); Critter::display($fred,
&quot;Height&quot;, &quot;Weight&quot;);</p>

<p>How does Perl know which package the subroutine is in?
By looking at the left side of the arrow, which must be
either a package name or a reference to an object, i.e.
something that has been blessed to a package. Either way,
thats the package where Perl starts looking. If that package
has no subroutine with that name, Perl starts looking for it
in any base classes of that package, and so on.</p>

<p>If you need to, you can force Perl to start looking in
some other package:</p>

<p>my $barney =
MyCritter-&gt;Critter::find(&quot;Barney&quot;);
$barney-&gt;Critter::display(&quot;Height&quot;,
&quot;Weight&quot;);</p>

<p>Here &quot;MyCritter&quot; is presumably a subclass of
&quot;Critter&quot; that defines its own versions of find()
and display(). We havent specified what those methods do,
but that doesnt matter above since weve forced Perl to start
looking for the subroutines in &quot;Critter&quot;.</p>

<p>As a special case of the above, you may use the
&quot;SUPER&quot; pseudo-class to tell Perl to start looking
for the method in the packages named in the current classs
@ISA list.</p>

<p>package MyCritter; use base &rsquo;Critter&rsquo;; #
sets @MyCritter::ISA = (&rsquo;Critter&rsquo;);</p>

<p>sub display { my ($self, @args) = @_;
$self-&gt;SUPER::display(&quot;Name&quot;, @args); }</p>

<p>It is important to note that &quot;SUPER&quot; refers to
the superclass(es) of the current package and not to the
superclass(es) of the object. Also, the &quot;SUPER&quot;
pseudo-class can only currently be used as a modifier to a
method name, but not in any of the other ways that class
names are normally used, eg:</p>

<p>something-&gt;SUPER::method(...); # OK
SUPER::method(...); # WRONG SUPER-&gt;method(...); #
WRONG</p>

<p>Instead of a class name or an object reference, you can
also use any expression that returns either of those on the
left side of the arrow. So the following statement is
valid:</p>


<p>Critter-&gt;find(&quot;Fred&quot;)-&gt;display(&quot;Height&quot;,
&quot;Weight&quot;);</p>

<p>and so is the following:</p>

<p>my $fred = (reverse
&quot;rettirC&quot;)-&gt;find(reverse &quot;derF&quot;);</p>

<p>The right side of the arrow typically is the method
name, but a simple scalar variable containing either the
method name or a subroutine reference can also be used.</p>

<p>If the right side of the arrow is a scalar containing a
reference to a subroutine, then this is equivalent to
calling the referenced subroutine directly with the class
name or object on the left side of the arrow as its first
argument. No lookup is done and there is no requirement that
the subroutine be defined in any package related to the
class name or object on the left side of the arrow.</p>

<p>For example, the following calls to $display are
equivalent:</p>

<p>my $display = sub { my $self = shift; ... };
$fred-&gt;$display(&quot;Height&quot;, &quot;Weight&quot;);
$display-&gt;($fred, &quot;Height&quot;,
&quot;Weight&quot;);</p>

<p>Indirect Object Syntax The other way to invoke a method
is by using the so-called &quot;indirect object&quot;
notation. This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles
like this:</p>

<p>print STDERR &quot;help!!!0;</p>

<p>The same syntax can be used to call either object or
class methods.</p>

<p>my $fred = find Critter &quot;Fred&quot;; display $fred
&quot;Height&quot;, &quot;Weight&quot;;</p>

<p>Notice that there is no comma between the object or
class name and the parameters. This is how Perl can tell you
want an indirect method call instead of an ordinary
subroutine call.</p>

<p>But what if there are no arguments? In that case, Perl
must guess what you want. Even worse, it must make that
guess at compile time. Usually Perl gets it right, but when
it doesnt you get a function call compiled as a method, or
vice versa. This can introduce subtle bugs that are hard to
detect.</p>

<p>For example, a call to a method &quot;new&quot; in
indirect notation -- as C++ programmers are wont to make --
can be miscompiled into a subroutine call if there s already
a &quot;new&quot; function in scope. Youd end up calling the
current packages &quot;new&quot; as a subroutine, rather
than the desired class s method. The compiler tries to cheat
by remembering bareword &quot;require&quot;s, but the grief
when it messes up just isnt worth the years of debugging it
will take you to track down such subtle bugs.</p>

<p>There is another problem with this syntax: the indirect
object is limited to a name, a scalar variable, or a block,
because it would have to do too much lookahead otherwise,
just like any other postfix dereference in the language.
(These are the same quirky rules as are used for the
filehandle slot in functions like &quot;print&quot; and
&quot;printf&quot;.) This can lead to horribly confusing
precedence problems, as in these next two lines:</p>

<p>move $obj-&gt;{FIELD}; # probably wrong! move $ary[$i];
# probably wrong!</p>

<p>Those actually parse as the very surprising:</p>

<p>$obj-&gt;move-&gt;{FIELD}; # Well, lookee here
$ary-&gt;move([$i]); # Didn&rsquo;t expect this one, eh?</p>

<p>Rather than what you might have expected:</p>

<p>$obj-&gt;{FIELD}-&gt;move(); # You should be so lucky.
$ary[$i]-&gt;move; # Yeah, sure.</p>

<p>To get the correct behavior with indirect object syntax,
you would have to use a block around the indirect
object:</p>

<p>move {$obj-&gt;{FIELD}}; move {$ary[$i]};</p>

<p>Even then, you still have the same potential problem if
there happens to be a function named &quot;move&quot; in the
current package. The &quot;-&gt;&quot; notation suffers from
neither of these disturbing ambiguities, so we recommend you
use it exclusively. However, you may still end up having to
read code using the indirect object notation, so it s
important to be familiar with it.</p>

<p>Default UNIVERSAL methods The &quot;UNIVERSAL&quot;
package automatically contains the following methods that
are inherited by all other classes:</p>

<p>isa(CLASS) &quot;isa&quot; returns true if its object is
blessed into a subclass of &quot;CLASS&quot;</p>

<p>DOES(ROLE) &quot;DOES&quot; returns true if its object
claims to perform the role &quot;ROLE&quot;. By default,
this is equivalent to &quot;isa&quot;.</p>

<p>can(METHOD) &quot;can&quot; checks to see if its object
has a method called &quot;METHOD&quot;, if it does then a
reference to the sub is returned, if it does not then
&quot;undef&quot; is returned.</p>

<p>VERSION( [NEED] ) &quot;VERSION&quot; returns the
version number of the class (package). If the NEED argument
is given then it will check that the current version (as
defined by the $VERSION variable in the given package) not
less than NEED; it will die if this is not the case. This
method is called automatically by the &quot;VERSION&quot;
form of &quot;use&quot;.</p>

<p>use Package 1.2 qw(some imported subs); # implies:
Package-&gt;VERSION(1.2);</p>

<p>Destructors When the last reference to an object goes
away, the object is automatically destroyed. (This may even
be after you exit, if youve stored references in global
variables.) If you want to capture control just before the
object is freed, you may define a DESTROY method in your
class. It will automatically be called at the appropriate
moment, and you can do any extra cleanup you need to do.
Perl passes a reference to the object under destruction as
the first (and only) argument. Beware that the reference is
a read-only value, and cannot be modified by manipulating
$_[0] within the destructor. The object itself (i.e. the
thingy the reference points to, namely &quot;${$_[0]}&quot;,
&quot;@{$_[0]}&quot;, &quot;%{$_[0]}&quot; etc.) is not
similarly constrained.</p>

<p>Since DESTROY methods can be called at unpredictable
times, it is important that you localise any global
variables that the method may update. In particular,
localise $@ if you use &quot;eval {}&quot; and localise $?
if you use &quot;system&quot; or backticks.</p>

<p>If you arrange to re-bless the reference before the
destructor returns, perl will again call the DESTROY method
for the re-blessed object after the current one returns.
This can be used for clean delegation of object destruction,
or for ensuring that destructors in the base classes of your
choosing get called. Explicitly calling DESTROY is also
possible, but is usually never needed.</p>

<p>Do not confuse the previous discussion with how objects
CONTAINED in the current one are destroyed. Such objects
will be freed and destroyed automatically when the current
object is freed, provided no other references to them exist
elsewhere.</p>

<p>Summary That s about all there is to it. Now you need
just to go off and buy a book about object-oriented design
methodology, and bang your forehead with it for the next six
months or so.</p>

<p>Two-Phased Garbage Collection For most purposes, Perl
uses a fast and simple, reference-based garbage collection
system. That means theres an extra dereference going on at
some level, so if you havent built your Perl executable
using your C compilers &quot;-O&quot; flag, performance will
suffer. If you have built Perl with &quot;cc -O&quot;, then
this probably wont matter.</p>

<p>A more serious concern is that unreachable memory with a
non-zero reference count will not normally get freed.
Therefore, this is a bad idea:</p>

<p>{ my $a; $a = ; }</p>

<p>Even thought $a should go away, it cant. When building
recursive data structures, you ll have to break the
self-reference yourself explicitly if you don t care to
leak. For example, here s a self-referential node such as
one might use in a sophisticated tree structure:</p>

<p>sub new_node { my $class = shift; my $node = {};
$node-&gt;{LEFT} = $node-&gt;{RIGHT} = $node;
$node-&gt;{DATA} = [ @_ ]; return bless $node =&gt; $class;
}</p>

<p>If you create nodes like that, they (currently) won t go
away unless you break their self reference yourself. (In
other words, this is not to be construed as a feature, and
you shouldnt depend on it.)</p>

<p>Almost.</p>

<p>When an interpreter thread finally shuts down (usually
when your program exits), then a rather costly but complete
mark-and-sweep style of garbage collection is performed, and
everything allocated by that thread gets destroyed. This is
essential to support Perl as an embedded or a
multithreadable language. For example, this program
demonstrates Perls two-phased garbage collection:</p>

<p>#!/usr/bin/perl package Subtle;</p>

<p>sub new { my $test; $test = est; warn &quot;CREATING
&quot; . est; return bless est; }</p>

<p>sub DESTROY { my $self = shift; warn &quot;DESTROYING
$self&quot;; }</p>

<p>package main;</p>

<p>warn &quot;starting program&quot;; { my $a =
Subtle-&gt;new; my $b = Subtle-&gt;new; $$a = 0; # break
selfref warn &quot;leaving block&quot;; }</p>

<p>warn &quot;just exited block&quot;; warn &quot;time to
die...&quot;; exit;</p>

<p>When run as /foo/test, the following output is
produced:</p>

<p>starting program at /foo/test line 18. CREATING
SCALAR(0x8e5b8) at /foo/test line 7. CREATING
SCALAR(0x8e57c) at /foo/test line 7. leaving block at
/foo/test line 23. DESTROYING Subtle=SCALAR(0x8e5b8) at
/foo/test line 13. just exited block at /foo/test line 26.
time to die... at /foo/test line 27. DESTROYING
Subtle=SCALAR(0x8e57c) during global destruction.</p>

<p>Notice that &quot;global destruction&quot; bit there?
That s the thread garbage collector reaching the
unreachable.</p>

<p>Objects are always destructed, even when regular refs
aren t. Objects are destructed in a separate pass before
ordinary refs just to prevent object destructors from using
refs that have been themselves destructed. Plain refs are
only garbage-collected if the destruct level is greater than
0. You can test the higher levels of global destruction by
setting the PERL_DESTRUCT_LEVEL environment variable,
presuming &quot;-DDEBUGGING&quot; was enabled during perl
build time. See &quot;PERL_DESTRUCT_LEVEL&quot; in perlhack
for more information.</p>

<p>A more complete garbage collection strategy will be
implemented at a future date.</p>

<p>In the meantime, the best solution is to create a
non-recursive container class that holds a pointer to the
self-referential data structure. Define a DESTROY method for
the containing objects class that manually breaks the
circularities in the self-referential structure.</p>

<p>SEE ALSO A kinder, gentler tutorial on object-oriented
programming in Perl can be found in perltoot, perlboot and
perltooc. You should also check out perlbot for other object
tricks, traps, and tips, as well as perlmodlib for some
style guides on constructing both modules and classes.</p>

<p>perl v5.10.1 2009-04-14 PERLOBJ(1)</p>
<hr>
</body>
</html>
