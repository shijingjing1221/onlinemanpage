<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:28:26 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>POPEN(3P) POSIX Programmer s Manual POPEN(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME popen - initiate pipe streams to or from a
process</p>

<p>SYNOPSIS #include &lt;stdio.h&gt;</p>

<p>FILE *popen(const char *command, const char *mode);</p>

<p>DESCRIPTION The popen() function shall execute the
command specified by the string command. It shall create a
pipe between the calling program and the executed command,
and shall return a pointer to a stream that can be used to
either read from or write to the pipe.</p>

<p>The environment of the executed command shall be as if a
child process were created within the popen() call using the
fork() function, and the child invoked the sh utility using
the call:</p>

<p>execl(shell path, &quot;sh&quot;, &quot;-c&quot;,
command, (char *)0);</p>

<p>where shell path is an unspecified pathname for the sh
utility.</p>

<p>The popen() function shall ensure that any streams from
previous popen() calls that remain open in the parent
process are closed in the new child process.</p>

<p>The mode argument to popen() is a string that specifies
I/O mode:</p>

<p>1. If mode is r, when the child process is started, its
file descrip- tor STDOUT_FILENO shall be the writable end of
the pipe, and the file descriptor fileno(stream) in the
calling process, where stream is the stream pointer returned
by popen(), shall be the readable end of the pipe.</p>

<p>2. If mode is w, when the child process is started its
file descriptor STDIN_FILENO shall be the readable end of
the pipe, and the file descriptor fileno(stream) in the
calling process, where stream is the stream pointer returned
by popen(), shall be the writable end of the pipe.</p>

<p>3. If mode is any other value, the result is
undefined.</p>

<p>After popen(), both the parent and the child process
shall be capable of executing independently before either
terminates.</p>

<p>Pipe streams are byte-oriented.</p>

<p>RETURN VALUE Upon successful completion, popen() shall
return a pointer to an open stream that can be used to read
or write to the pipe. Otherwise, it shall return a null
pointer and may set errno to indicate the error.</p>

<p>ERRORS The popen() function may fail if:</p>

<p>EMFILE {FOPEN_MAX} or {STREAM_MAX} streams are currently
open in the calling process.</p>

<p>EINVAL The mode argument is invalid.</p>

<p>The popen() function may also set errno values as
described by fork() or pipe().</p>

<p>The following sections are informative.</p>

<p>EXAMPLES None.</p>

<p>APPLICATION USAGE Since open files are shared, a mode r
command can be used as an input filter and a mode w command
as an output filter.</p>

<p>Buffered reading before opening an input filter may
leave the standard input of that filter mispositioned.
Similar problems with an output filter may be prevented by
careful buffer flushing; for example, with fflush().</p>

<p>A stream opened by popen() should be closed by
pclose().</p>

<p>The behavior of popen() is specified for values of mode
of r and w. Other modes such as rb and wb might be supported
by specific implemen- tations, but these would not be
portable features. Note that historical implementations of
popen() only check to see if the first character of mode is
r. Thus, a mode of robert the robot would be treated as mode
r, and a mode of anything else would be treated as mode
w.</p>

<p>If the application calls waitpid() or waitid() with a
pid argument greater than 0, and it still has a stream that
was called with popen() open, it must ensure that pid does
not refer to the process started by popen().</p>

<p>To determine whether or not the environment specified in
the Shell and Utilities volume of IEEE Std 1003.1-2001 is
present, use the function call:</p>

<p>sysconf(_SC_2_VERSION)</p>

<p>(See sysconf()).</p>

<p>RATIONALE The popen() function should not be used by
programs that have set user (or group) ID privileges. The
fork() and exec family of functions (except execlp() and
execvp()), should be used instead. This prevents any
unforeseen manipulation of the environment of the user that
could cause execution of commands not anticipated by the
calling program.</p>

<p>If the original and popen()ed processes both intend to
read or write or read and write a common file, and either
will be using FILE-type C functions ( fread(), fwrite(), and
so on), the rules for sharing file handles must be observed
(see Interaction of File Descriptors and Stan- dard I/O
Streams ).</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO pclose(), pipe(), sysconf(), system(), the Base
Definitions volume of IEEE Std 1003.1-2001, &lt;stdio.h&gt;,
the Shell and Utilities volume of IEEE Std 1003.1-2001,
sh</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 POPEN(3P)</p>
<hr>
</body>
</html>
