<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:46:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>XkbAllocDeviceLedInfo(3) XKB FUNCTIONS
XkbAllocDeviceLedInfo(3)</p>

<p>NAME XkbAllocDeviceLedInfo - Obtain an
XkbDeviceLedInfoRec structure</p>

<p>SYNOPSIS Status XkbAllocDeviceLedInfo (XkbDeviceInfoPtr
device_info, int num_needed);</p>

<p>ARGUMENTS - device_info structure in which to allocate
LED space</p>

<p>- num_needed number of indicators to allocate space
for</p>

<p>DESCRIPTION XkbAllocDeviceLedInfo allocates space for an
XkbDeviceLedInfoRec and places it in device_info. If
num_needed is nonzero, num_needed XkbIndicatorMapRec
structures are also allocated and linked into the
XkbDeviceLedInfoRec structure. If you request
XkbIndicatorMapRec struc- tures be allocated using this
request, you must initialize them explic- itly. All other
fields are initialized to zero.</p>

<p>To initialize an XkbDeviceLedInfoRec structure, use
XkbAddDeviceLed- Info.</p>

<p>STRUCTURES Information about X Input Extension devices
is transferred between a client program and the Xkb
extension in an XkbDeviceInfoRec structure:</p>

<p>typedef struct { char * name; / name for device */ Atom
type; / name for class of devices */ unsigned short
device_spec; / device of interest */ Bool has_own_state; /
True=&gt;this device has its own state */ unsigned short
supported; / bits indicating supported capabilities */
unsigned short unsupported; / bits indicating unsupported
capabilities */ unsigned short num_btns; / number of entries
in btn_acts */ XkbAction * btn_acts; / button actions */
unsigned short sz_leds; / total number of entries in LEDs
vector */ unsigned short num_leds; / number of valid entries
in LEDs vector */ unsigned short dflt_kbd_fb; / input
extension ID of default (core kbd) indicator */ unsigned
short dflt_led_fb; / input extension ID of default indicator
feedback */ XkbDeviceLedInfoPtr leds; / LED descriptions */
} XkbDeviceInfoRec, *XkbDeviceInfoPtr;</p>

<p>typedef struct { unsigned short led_class; / class for
this LED device*/ unsigned short led_id; / ID for this LED
device */ unsigned int phys_indicators; / bits for which
LEDs physically present */ unsigned int maps_present; / bits
for which LEDs have maps in maps */ unsigned int
names_present; / bits for which LEDs are in names */
unsigned int state; / 1 bit =&gt; corresponding LED is on */
Atom names[XkbNumIndicators]; / names for LEDs */
XkbIndicatorMapRec maps; / indicator maps for each LED */ }
XkbDeviceLedInfoRec, *XkbDeviceLedInfoPtr;</p>

<p>Each indicator has its own set of attributes that
specify whether clients can explicitly set its state and
whether it tracks the keyboard state. The attributes of each
indicator are held in the maps array, which is an array of
XkbIndicatorRec structures:</p>

<p>typedef struct { unsigned char flags; / how the
indicator can be changed */ unsigned char which_groups; /
match criteria for groups */ unsigned char groups; / which
keyboard groups the indicator watches */ unsigned char
which_mods; / match criteria for modifiers */ XkbModsRec
mods; / which modifiers the indicator watches */ unsigned
int ctrls; / which controls the indicator watches */ }
XkbIndicatorMapRec, *XkbIndicatorMapPtr;</p>

<p>This indicator map specifies for each indicator:</p>

<p>&middot; The conditions under which the keyboard
modifier state affects the indicator</p>

<p>&middot; The conditions under which the keyboard group
state affects the indicator</p>

<p>&middot; The conditions under which the state of the
boolean controls affects the indicator</p>

<p>&middot; The effect (if any) of attempts to explicitly
change the state of the indicator using the functions
XkbSetControls or XChangeKey- boardControl</p>

<p>SEE ALSO XkbAddDeviceLedInfo(3), XkbSetControls(3)</p>

<p>X Version 11 libX11 1.6.0 XkbAllocDeviceLedInfo(3)</p>
<hr>
</body>
</html>
