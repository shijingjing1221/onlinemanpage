<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:44:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>WRITE_CACHE_PAGES(9) Memory Management in Linux
WRITE_CACHE_PAGES(9)</p>

<p>NAME write_cache_pages - walk the list of dirty pages of
the given address space and write all of them.</p>

<p>SYNOPSIS int write_cache_pages(struct address_space *
mapping, struct writeback_control * wbc, writepage_t
writepage, void * data);</p>

<p>ARGUMENTS mapping address space structure to write</p>

<p>wbc subtract the number of written pages from
*wbc-&gt;nr_to_write</p>

<p>writepage function called for each page</p>

<p>data data passed to writepage function</p>

<p>DESCRIPTION If a page is already under I/O,
write_cache_pages skips it, even if it&acute;s dirty. This
is desirable behaviour for memory-cleaning writeback, but it
is INCORRECT for data-integrity system calls such as fsync.
fsync and msync need to guarantee that all the data which
was dirty at the time the call was made get new I/O started
against them. If wbc-&gt;sync_mode is WB_SYNC_ALL then we
were called for data integrity and we must wait for existing
IO to complete.</p>

<p>To avoid livelocks (when other process dirties new
pages), we first tag pages which should be written back with
TOWRITE tag and only then start writing them. For
data-integrity sync we have to be careful so that we do not
miss some pages (e.g., because some other process has
cleared TOWRITE tag we set). The rule we follow is that
TOWRITE tag can be cleared only by the process clearing the
DIRTY tag (and submitting the page for IO).</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
WRITE_CACHE_PAGES(9)</p>
<hr>
</body>
</html>
