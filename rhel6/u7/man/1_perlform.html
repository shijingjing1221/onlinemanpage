<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:11 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLFORM(1) Perl Programmers Reference Guide
PERLFORM(1)</p>

<p>NAME perlform - Perl formats</p>

<p>DESCRIPTION Perl has a mechanism to help you generate
simple reports and charts. To facilitate this, Perl helps
you code up your output page close to how it will look when
its printed. It can keep track of things like how many lines
are on a page, what page youre on, when to print page
headers, etc. Keywords are borrowed from FORTRAN: format()
to declare and write() to execute; see their entries in
perlfunc. Fortunately, the layout is much more legible, more
like BASIC s PRINT USING statement. Think of it as a poor
mans nroff(1).</p>

<p>Formats, like packages and subroutines, are declared
rather than executed, so they may occur at any point in your
program. (Usually it s best to keep them all together
though.) They have their own namespace apart from all the
other &quot;types&quot; in Perl. This means that if you have
a function named &quot;Foo&quot;, it is not the same thing
as having a format named &quot;Foo&quot;. However, the
default name for the format associated with a given
filehandle is the same as the name of the filehandle. Thus,
the default format for STDOUT is named &quot;STDOUT&quot;,
and the default format for filehandle TEMP is named
&quot;TEMP&quot;. They just look the same. They arent.</p>

<p>Output record formats are declared as follows:</p>

<p>format NAME = FORMLIST .</p>

<p>If the name is omitted, format &quot;STDOUT&quot; is
defined. A single &quot;.&quot; in column 1 is used to
terminate a format. FORMLIST consists of a sequence of
lines, each of which may be one of three types:</p>

<p>1. A comment, indicated by putting a # in the first
column.</p>

<p>2. A &quot;picture&quot; line giving the format for one
output line.</p>

<p>3. An argument line supplying values to plug into the
previous picture line.</p>

<p>Picture lines contain output field definitions,
intermingled with literal text. These lines do not undergo
any kind of variable interpolation. Field definitions are
made up from a set of characters, for starting and extending
a field to its desired width. This is the complete set of
characters for field definitions:</p>

<p>@ start of regular field ^ start of special field &lt;
pad character for left justification | pad character for
centering &gt; pad character for right justification # pad
character for a right justified numeric field 0 instead of
first #: pad number with leading zeroes . decimal point
within a numeric field ... terminate a text field, show
&quot;...&quot; as truncation evidence @* variable width
field for a multi-line value ^* variable width field for
next line of a multi-line value ~ suppress line with all
fields empty ~~ repeat line until all fields are
exhausted</p>

<p>Each field in a picture line starts with either
&quot;@&quot; (at) or &quot;^&quot; (caret), indicating what
we ll call, respectively, a &quot;regular&quot; or
&quot;special&quot; field. The choice of pad characters
determines whether a field is textual or numeric. The tilde
operators are not part of a field. Lets look at the various
possibilities in detail.</p>

<p>Text Fields The length of the field is supplied by
padding out the field with multiple &quot;&lt;&quot;,
&quot;&gt;&quot;, or &quot;|&quot; characters to specify a
non-numeric field with, respectively, left justification,
right justification, or centering. For a regular field, the
value (up to the first newline) is taken and printed
according to the selected justification, truncating excess
characters. If you terminate a text field with
&quot;...&quot;, three dots will be shown if the value is
truncated. A special text field may be used to do
rudimentary multi-line text block filling; see &quot;Using
Fill Mode&quot; for details.</p>

<p>Example: format STDOUT = @&lt;&lt;&lt;&lt;&lt;&lt;
@|||||| @&gt;&gt;&gt;&gt;&gt;&gt; &quot;left&quot;,
&quot;middle&quot;, &quot;right&quot; . Output: left middle
right</p>

<p>Numeric Fields Using &quot;#&quot; as a padding
character specifies a numeric field, with right
justification. An optional &quot;.&quot; defines the
position of the decimal point. With a &quot;0&quot; (zero)
instead of the first &quot;#&quot;, the formatted number
will be padded with leading zeroes if necessary. A special
numeric field is blanked out if the value is undefined. If
the resulting value would exceed the width specified the
field is filled with &quot;#&quot; as overflow evidence.</p>

<p>Example: format STDOUT = @### @.### @##.### @### @###
^#### 42, 3.1415, undef, 0, 10000, undef . Output: 42 3.142
0.000 0 ####</p>

<p>The Field @* for Variable Width Multi-Line Text The
field &quot;@*&quot; can be used for printing multi-line,
nontruncated values; it should (but need not) appear by
itself on a line. A final line feed is chomped off, but all
other characters are emitted verbatim.</p>

<p>The Field ^* for Variable Width One-line-at-a-time Text
Like &quot;@*&quot;, this is a variable width field. The
value supplied must be a scalar variable. Perl puts the
first line (up to the first &quot;0) of the text into the
field, and then chops off the front of the string so that
the next time the variable is referenced, more of the text
can be printed. The variable will not be restored.</p>

<p>Example: $text = &quot;line 10ine 20ine 3&quot;; format
STDOUT = Text: ^* $text ~~ ^* $text . Output: Text: line 1
line 2 line 3</p>

<p>Specifying Values The values are specified on the
following format line in the same order as the picture
fields. The expressions providing the values must be
separated by commas. They are all evaluated in a list
context before the line is processed, so a single list
expression could produce multiple list elements. The
expressions may be spread out to more than one line if
enclosed in braces. If so, the opening brace must be the
first token on the first line. If an expression evaluates to
a number with a decimal part, and if the corresponding
picture specifies that the decimal part should appear in the
output (that is, any picture except multiple &quot;#&quot;
characters without an embedded &quot;.&quot;), the character
used for the decimal point is always determined by the
current LC_NUMERIC locale. This means that, if, for example,
the run-time environment happens to specify a German locale,
&quot;,&quot; will be used instead of the default
&quot;.&quot;. See perllocale and &quot;WARNINGS&quot; for
more information.</p>

<p>Using Fill Mode On text fields the caret enables a kind
of fill mode. Instead of an arbitrary expression, the value
supplied must be a scalar variable that contains a text
string. Perl puts the next portion of the text into the
field, and then chops off the front of the string so that
the next time the variable is referenced, more of the text
can be printed. (Yes, this means that the variable itself is
altered during execution of the write() call, and is not
restored.) The next portion of text is determined by a crude
line breaking algorithm. You may use the carriage &quot;) to
force a line break. You can return character (&quot; change
which characters are legal to break on by changing the
variable $: (thats $FORMAT_LINE_BREAK_CHARACTERS if youre
using the English module) to a list of the desired
characters.</p>

<p>Normally you would use a sequence of fields in a
vertical stack associated with the same scalar variable to
print out a block of text. You might wish to end the final
field with the text &quot;...&quot;, which will appear in
the output if the text was too long to appear in its
entirety.</p>

<p>Suppressing Lines Where All Fields Are Void Using caret
fields can produce lines where all fields are blank. You can
suppress such lines by putting a &quot;~&quot; (tilde)
character anywhere in the line. The tilde will be translated
to a space upon output.</p>

<p>Repeating Format Lines If you put two contiguous tilde
characters &quot;~~&quot; anywhere into a line, the line
will be repeated until all the fields on the line are
exhausted, i.e. undefined. For special (caret) text fields
this will occur sooner or later, but if you use a text field
of the at variety, the expression you supply had better not
give the same value every time forever!
(&quot;shift(@f)&quot; is a simple example that would work.)
Dont use a regular (at) numeric field in such lines, because
it will never go blank.</p>

<p>Top of Form Processing Top-of-form processing is by
default handled by a format with the same name as the
current filehandle with &quot;_TOP&quot; concatenated to it.
Its triggered at the top of each page. See &quot;write&quot;
in perlfunc.</p>

<p>Examples:</p>

<p># a report on the /etc/passwd file format STDOUT_TOP =
Passwd File Name Login Office Uid Gid Home
------------------------------------------------------------------
. format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
@||||||| @&lt;&lt;&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt;
@&gt;&gt;&gt;&gt;
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$name, $login, $office,$uid,$gid, $home .</p>

<p># a report from a bug report form format STDOUT_TOP =
Bug Reports
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
@|||
@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
$system, $%, $date
------------------------------------------------------------------
. format STDOUT = Subject:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$subject Index:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$index, $description Priority:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Date:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$priority, $date, $description From:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$from, $description Assigned to:
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$programmer, $description ~
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$description ~
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$description ~
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$description ~
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$description ~
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;...
$description .</p>

<p>It is possible to intermix print()s with write()s on the
same output channel, but you ll have to handle
&quot;$-&quot; ($FORMAT_LINES_LEFT) yourself.</p>

<p>Format Variables The current format name is stored in
the variable $~ ($FORMAT_NAME), and the current top of form
format name is in $^ ($FORMAT_TOP_NAME). The current output
page number is stored in $% ($FORMAT_PAGE_NUMBER), and the
number of lines on the page is in $=
($FORMAT_LINES_PER_PAGE). Whether to autoflush output on
this handle is stored in $| ($OUTPUT_AUTOFLUSH). The string
output before each top of page (except the first) is stored
in $^L ($FORMAT_FORMFEED). These variables are set on a
per-filehandle basis, so youll need to select() into a
different one to affect them:</p>

<p>select((select(OUTF), $~ = &quot;My_Other_Format&quot;,
$^ = &quot;My_Top_Format&quot; )[0]);</p>

<p>Pretty ugly, eh? Its a common idiom though, so dont be
too surprised when you see it. You can at least use a
temporary variable to hold the previous filehandle: (this is
a much better approach in general, because not only does
legibility improve, you now have intermediary stage in the
expression to single-step the debugger through):</p>

<p>$ofh = select(OUTF); $~ = &quot;My_Other_Format&quot;;
$^ = &quot;My_Top_Format&quot;; select($ofh);</p>

<p>If you use the English module, you can even read the
variable names:</p>

<p>use English &rsquo;-no_match_vars&rsquo;; $ofh =
select(OUTF); $FORMAT_NAME = &quot;My_Other_Format&quot;;
$FORMAT_TOP_NAME = &quot;My_Top_Format&quot;;
select($ofh);</p>

<p>But you still have those funny select()s. So just use
the FileHandle module. Now, you can access these special
variables using lowercase method names instead:</p>

<p>use FileHandle; format_name OUTF
&quot;My_Other_Format&quot;; format_top_name OUTF
&quot;My_Top_Format&quot;;</p>

<p>Much better!</p>

<p>NOTES Because the values line may contain arbitrary
expressions (for at fields, not caret fields), you can farm
out more sophisticated processing to other functions, like
sprintf() or one of your own. For example:</p>

<p>format Ident =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
&amp;commify($n) .</p>

<p>To get a real at or caret into the field, do this:</p>

<p>format Ident = I have an @ here. &quot;@&quot; .</p>

<p>To center a whole line of text, do something like
this:</p>

<p>format Ident =
@||||||||||||||||||||||||||||||||||||||||||||||| &quot;Some
text line&quot; .</p>

<p>There is no builtin way to say &quot;float this to the
right hand side of the page, however wide it is.&quot; You
have to specify where it goes. The truly desperate can
generate their own format on the fly, based on the current
number of columns, and then eval() it:</p>

<p>$format = &quot;format STDOUT = 0 . &rsquo;^&rsquo; .
&rsquo;&lt;&rsquo; x $cols . &quot;0 . &rsquo;$entry&rsquo;
. &quot;0 . &quot;^&quot; . &quot;&lt;&quot; x ($cols-8) .
&quot;~~0 . &rsquo;$entry&rsquo; . &quot;0 . &quot;.0; print
$format if $Debugging; eval $format; die $@ if $@;</p>

<p>Which would generate a format looking something like
this:</p>

<p>format STDOUT =
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$entry
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;~~
$entry .</p>

<p>Heres a little program thats somewhat like fmt(1):</p>

<p>format =
^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
~~ $_</p>

<p>.</p>

<p>$/ = &rsquo;&rsquo;; while (&lt;&gt;) { s/0s*/ /g;
write; }</p>

<p>Footers While $FORMAT_TOP_NAME contains the name of the
current header format, there is no corresponding mechanism
to automatically do the same thing for a footer. Not knowing
how big a format is going to be until you evaluate it is one
of the major problems. Its on the TODO list.</p>

<p>Heres one strategy: If you have a fixed-size footer, you
can get footers by checking $FORMAT_LINES_LEFT before each
write() and print the footer yourself if necessary.</p>

<p>Heres another strategy: Open a pipe to yourself, using
&quot;open(MYSELF, &quot;|-&quot;)&quot; (see
&quot;open()&quot; in perlfunc) and always write() to MYSELF
instead of STDOUT. Have your child process massage its STDIN
to rearrange headers and footers however you like. Not very
convenient, but doable.</p>

<p>Accessing Formatting Internals For low-level access to
the formatting mechanism. you may use formline() and access
$^A (the $ACCUMULATOR variable) directly.</p>

<p>For example:</p>

<p>$str = formline &lt;&lt;&rsquo;END&rsquo;, 1,2,3;
@&lt;&lt;&lt; @||| @&gt;&gt;&gt; END</p>

<p>print &quot;Wow, I just stored &lsquo;$^A&rsquo; in the
accumulator!0;</p>

<p>Or to make an swrite() subroutine, which is to write()
what sprintf() is to printf(), do this:</p>

<p>use Carp; sub swrite { croak &quot;usage: swrite PICTURE
ARGS&quot; unless @_; my $format = shift; $^A =
&quot;&quot;; formline($format,@_); return $^A; }</p>

<p>$string = swrite(&lt;&lt;&rsquo;END&rsquo;, 1, 2, 3);
Check me out @&lt;&lt;&lt; @||| @&gt;&gt;&gt; END print
$string;</p>

<p>WARNINGS The lone dot that ends a format can also
prematurely end a mail message passing through a
misconfigured Internet mailer (and based on experience, such
misconfiguration is the rule, not the exception). So when
sending format code through mail, you should indent it so
that the format-ending dot is not on the left margin; this
will prevent SMTP cutoff.</p>

<p>Lexical variables (declared with &quot;my&quot;) are not
visible within a format unless the format is declared within
the scope of the lexical variable. (They werent visible at
all before version 5.001.)</p>

<p>Formats are the only part of Perl that unconditionally
use information from a program s locale; if a program s
environment specifies an LC_NUMERIC locale, it is always
used to specify the decimal point character in formatted
output. Perl ignores all other aspects of locale handling
unless the &quot;use locale&quot; pragma is in effect.
Formatted output cannot be controlled by &quot;use
locale&quot; because the pragma is tied to the block
structure of the program, and, for historical reasons,
formats exist outside that block structure. See perllocale
for further discussion of locale handling.</p>

<p>Within strings that are to be displayed in a fixed
length text field, each control character is substituted by
a space. (But remember the &quot; when using fill mode.)
This is done special meaning of &quot; to avoid misalignment
when control characters &quot;disappear&quot; on some output
media.</p>

<p>perl v5.10.1 2009-02-25 PERLFORM(1)</p>
<hr>
</body>
</html>
