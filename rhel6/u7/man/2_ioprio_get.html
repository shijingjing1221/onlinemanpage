<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:33 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IOPRIO_SET(2) Linux Programmer s Manual
IOPRIO_SET(2)</p>

<p>NAME ioprio_get, ioprio_set - get/set I/O scheduling
class and priority</p>

<p>SYNOPSIS int ioprio_get(int which, int who); int
ioprio_set(int which, int who, int ioprio);</p>

<p>DESCRIPTION The ioprio_get() and ioprio_set() system
calls respectively get and set the I/O scheduling class and
priority of one or more processes.</p>

<p>The which and who arguments identify the process(es) on
which the sys- tem calls operate. The which argument
determines how who is inter- preted, and has one of the
following values:</p>

<p>IOPRIO_WHO_PROCESS who is a process ID identifying a
single process.</p>

<p>IOPRIO_WHO_PGRP who is a process group ID identifying
all the members of a pro- cess group.</p>

<p>IOPRIO_WHO_USER who is a user ID identifying all of the
processes that have a matching real UID.</p>

<p>If which is specified as IOPRIO_WHO_PGRP or
IOPRIO_WHO_USER when call- ing ioprio_get(), and more than
one process matches who, then the returned priority will be
the highest one found among all of the match- ing processes.
One priority is said to be higher than another one if it
belongs to a higher priority class (IOPRIO_CLASS_RT is the
highest priority class; IOPRIO_CLASS_IDLE is the lowest) or
if it belongs to the same priority class as the other
process but has a higher priority level (a lower priority
number means a higher priority level).</p>

<p>The ioprio argument given to ioprio_set() is a bit mask
that specifies both the scheduling class and the priority to
be assigned to the target process(es). The following macros
are used for assembling and dissect- ing ioprio values:</p>

<p>IOPRIO_PRIO_VALUE(class, data) Given a scheduling class
and priority (data), this macro com- bines the two values to
produce an ioprio value, which is returned as the result of
the macro.</p>

<p>IOPRIO_PRIO_CLASS(mask) Given mask (an ioprio value),
this macro returns its I/O class component, that is, one of
the values IOPRIO_CLASS_RT, IOPRIO_CLASS_BE, or
IOPRIO_CLASS_IDLE.</p>

<p>IOPRIO_PRIO_DATA(mask) Given mask (an ioprio value),
this macro returns its priority (data) component.</p>

<p>See the NOTES section for more information on scheduling
classes and priorities.</p>

<p>I/O priorities are supported for reads and for
synchronous (O_DIRECT, O_SYNC) writes. I/O priorities are
not supported for asynchronous writes because they are
issued outside the context of the program dirtying the
memory, and thus program-specific priorities do not
apply.</p>

<p>RETURN VALUE On success, ioprio_get() returns the ioprio
value of the process with highest I/O priority of any of the
processes that match the criteria specified in which and
who. On error, -1 is returned, and errno is set to indicate
the error.</p>

<p>On success, ioprio_set() returns 0. On error, -1 is
returned, and errno is set to indicate the error.</p>

<p>ERRORS EINVAL Invalid value for which or ioprio. Refer
to the NOTES section for available scheduler classes and
priority levels for ioprio.</p>

<p>EPERM The calling process does not have the privilege
needed to assign this ioprio to the specified process(es).
See the NOTES section for more information on required
privileges for ioprio_set().</p>

<p>ESRCH No process(es) could be found that matched the
specification in which and who.</p>

<p>VERSIONS These system calls have been available on Linux
since kernel 2.6.13.</p>

<p>CONFORMING TO These system calls are Linux-specific.</p>

<p>NOTES Glibc does not provide wrapper for these system
calls; call them using syscall(2).</p>

<p>These system calls only have an effect when used in
conjunction with an I/O scheduler that supports I/O
priorities. As at kernel 2.6.17 the only such scheduler is
the Completely Fair Queuing (CFQ) I/O scheduler.</p>

<p>Selecting an I/O Scheduler I/O Schedulers are selected
on a per-device basis via the special file
/sys/block/&lt;device&gt;/queue/scheduler.</p>

<p>One can view the current I/O scheduler via the /sys file
system. For example, the following command displays a list
of all schedulers cur- rently loaded in the kernel:</p>

<p>$ cat /sys/block/hda/queue/scheduler noop anticipatory
deadline [cfq]</p>

<p>The scheduler surrounded by brackets is the one actually
in use for the device (hda in the example). Setting another
scheduler is done by writing the name of the new scheduler
to this file. For example, the following command will set
the scheduler for the hda device to cfq:</p>

<p>$ su Password: # echo cfq &gt;
/sys/block/hda/queue/scheduler</p>

<p>The Completely Fair Queuing (CFQ) I/O Scheduler Since v3
(aka CFQ Time Sliced) CFQ implements I/O nice levels similar
to those of CPU scheduling. These nice levels are grouped in
three scheduling classes each one containing one or more
priority levels:</p>

<p>IOPRIO_CLASS_RT (1) This is the real-time I/O class.
This scheduling class is given higher priority than any
other class: processes from this class are given first
access to the disk every time. Thus this I/O class needs to
be used with some care: one I/O real-time process can starve
the entire system. Within the real-time class, there are 8
levels of class data (priority) that determine exactly how
much time this process needs the disk for on each service.
The highest real-time priority level is 0; the lowest is 7.
In the future this might change to be more directly mappable
to perfor- mance, by passing in a desired data rate
instead.</p>

<p>IOPRIO_CLASS_BE (2) This is the best-effort scheduling
class, which is the default for any process that hasnt set a
specific I/O priority. The class data (priority) determines
how much I/O bandwidth the pro- cess will get. Best-effort
priority levels are analogous to CPU nice values (see
getpriority(2)). The priority level determines a priority
relative to other processes in the best-effort scheduling
class. Priority levels range from 0 (highest) to 7
(lowest).</p>

<p>IOPRIO_CLASS_IDLE (3) This is the idle scheduling class.
Processes running at this level only get I/O time when
no-one else needs the disk. The idle class has no class
data. Attention is required when assigning this priority
class to a process, since it may become starved if higher
priority processes are constantly accessing the disk.</p>

<p>Refer to Documentation/block/ioprio.txt for more
information on the CFQ I/O Scheduler and an example
program.</p>

<p>Required permissions to set I/O priorities Permission to
change a processs priority is granted or denied based on two
assertions:</p>

<p>Process ownership An unprivileged process may only set
the I/O priority of a pro- cess whose real UID matches the
real or effective UID of the calling process. A process
which has the CAP_SYS_NICE capabil- ity can change the
priority of any process.</p>

<p>What is the desired priority Attempts to set very high
priorities (IOPRIO_CLASS_RT) require the CAP_SYS_ADMIN
capability. Kernel versions up to 2.6.24 also required
CAP_SYS_ADMIN to set a very low priority
(IOPRIO_CLASS_IDLE), but since Linux 2.6.25, this is no
longer required.</p>

<p>A call to ioprio_set() must follow both rules, or the
call will fail with the error EPERM.</p>

<p>BUGS Glibc does not yet provide a suitable header file
defining the function prototypes and macros described on
this page. Suitable definitions can be found in
linux/ioprio.h.</p>

<p>SEE ALSO getpriority(2), open(2), capabilities(7)</p>

<p>Documentation/block/ioprio.txt in the kernel source
tree.</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-07-09 IOPRIO_SET(2)</p>
<hr>
</body>
</html>
