<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLGUTS(1) Perl Programmers Reference Guide
PERLGUTS(1)</p>

<p>NAME perlguts - Introduction to the Perl API</p>

<p>DESCRIPTION This document attempts to describe how to
use the Perl API, as well as to provide some info on the
basic workings of the Perl core. It is far from complete and
probably contains many errors. Please refer any questions or
comments to the author below.</p>

<p>Variables Datatypes Perl has three typedefs that handle
Perls three main data types:</p>

<p>SV Scalar Value AV Array Value HV Hash Value</p>

<p>Each typedef has specific routines that manipulate the
various data types.</p>

<p>What is an &quot;IV&quot;? Perl uses a special typedef
IV which is a simple signed integer type that is guaranteed
to be large enough to hold a pointer (as well as an
integer). Additionally, there is the UV, which is simply an
unsigned IV.</p>

<p>Perl also uses two special typedefs, I32 and I16, which
will always be at least 32-bits and 16-bits long,
respectively. (Again, there are U32 and U16, as well.) They
will usually be exactly 32 and 16 bits long, but on Crays
they will both be 64 bits.</p>

<p>Working with SVs An SV can be created and loaded with
one command. There are five types of values that can be
loaded: an integer value (IV), an unsigned integer value
(UV), a double (NV), a string (PV), and another scalar
(SV).</p>

<p>The seven routines are:</p>

<p>SV* newSViv(IV); SV* newSVuv(UV); SV* newSVnv(double);
SV* newSVpv(const char*, STRLEN); SV* newSVpvn(const char*,
STRLEN); SV* newSVpvf(const char*, ...); SV*
newSVsv(SV*);</p>

<p>&quot;STRLEN&quot; is an integer type (Size_t, usually
defined as size_t in config.h) guaranteed to be large enough
to represent the size of any string that perl can
handle.</p>

<p>In the unlikely case of a SV requiring more complex
initialisation, you can create an empty SV with newSV(len).
If &quot;len&quot; is 0 an empty SV of type NULL is
returned, else an SV of type PV is returned with len + 1
(for the NUL) bytes of storage allocated, accessible via
SvPVX. In both cases the SV has value undef.</p>

<p>SV *sv = newSV(0); /* no storage allocated */ SV *sv =
newSV(10); /* 10 (+1) bytes of uninitialised storage
allocated */</p>

<p>To change the value of an already-existing SV, there are
eight routines:</p>

<p>void sv_setiv(SV*, IV); void sv_setuv(SV*, UV); void
sv_setnv(SV*, double); void sv_setpv(SV*, const char*); void
sv_setpvn(SV*, const char*, STRLEN) void sv_setpvf(SV*,
const char*, ...); void sv_vsetpvfn(SV*, const char*,
STRLEN, va_list *, SV **, I32, bool *); void sv_setsv(SV*,
SV*);</p>

<p>Notice that you can choose to specify the length of the
string to be assigned by using &quot;sv_setpvn&quot;,
&quot;newSVpvn&quot;, or &quot;newSVpv&quot;, or you may
allow Perl to calculate the length by using
&quot;sv_setpv&quot; or by specifying 0 as the second
argument to &quot;newSVpv&quot;. Be warned, though, that
Perl will determine the strings length by using
&quot;strlen&quot;, which depends on the string terminating
with a NUL character.</p>

<p>The arguments of &quot;sv_setpvf&quot; are processed
like &quot;sprintf&quot;, and the formatted output becomes
the value.</p>

<p>&quot;sv_vsetpvfn&quot; is an analogue of
&quot;vsprintf&quot;, but it allows you to specify either a
pointer to a variable argument list or the address and
length of an array of SVs. The last argument points to a
boolean; on return, if that boolean is true, then
locale-specific information has been used to format the
string, and the strings contents are therefore untrustworthy
(see perlsec). This pointer may be NULL if that information
is not important. Note that this function requires you to
specify the length of the format.</p>

<p>The &quot;sv_set*()&quot; functions are not generic
enough to operate on values that have &quot;magic&quot;. See
&quot;Magic Virtual Tables&quot; later in this document.</p>

<p>All SVs that contain strings should be terminated with a
NUL character. If it is not NUL-terminated there is a risk
of core dumps and corruptions from code which passes the
string to C functions or system calls which expect a
NUL-terminated string. Perls own functions typically add a
trailing NUL for this reason. Nevertheless, you should be
very careful when you pass a string stored in an SV to a C
function or system call.</p>

<p>To access the actual value that an SV points to, you can
use the macros:</p>

<p>SvIV(SV*) SvUV(SV*) SvNV(SV*) SvPV(SV*, STRLEN len)
SvPV_nolen(SV*)</p>

<p>which will automatically coerce the actual scalar type
into an IV, UV, double, or string.</p>

<p>In the &quot;SvPV&quot; macro, the length of the string
returned is placed into the variable &quot;len&quot; (this
is a macro, so you do not use &amp;len). If you do not care
what the length of the data is, use the
&quot;SvPV_nolen&quot; macro. Historically the
&quot;SvPV&quot; macro with the global variable
&quot;PL_na&quot; has been used in this case. But that can
be quite inefficient because &quot;PL_na&quot; must be
accessed in thread-local storage in threaded Perl. In any
case, remember that Perl allows arbitrary strings of data
that may both contain NULs and might not be terminated by a
NUL.</p>

<p>Also remember that C doesn t allow you to safely say
&quot;foo(SvPV(s, len), len);&quot;. It might work with your
compiler, but it wont work for everyone. Break this sort of
statement up into separate assignments:</p>

<p>SV *s; STRLEN len; char * ptr; ptr = SvPV(s, len);
foo(ptr, len);</p>

<p>If you want to know if the scalar value is TRUE, you can
use:</p>

<p>SvTRUE(SV*)</p>

<p>Although Perl will automatically grow strings for you,
if you need to force Perl to allocate more memory for your
SV, you can use the macro</p>

<p>SvGROW(SV*, STRLEN newlen)</p>

<p>which will determine if more memory needs to be
allocated. If so, it will call the function
&quot;sv_grow&quot;. Note that &quot;SvGROW&quot; can only
increase, not decrease, the allocated memory of an SV and
that it does not automatically add a byte for the a trailing
NUL (perls own string functions typically do
&quot;SvGROW(sv, len + 1)&quot;).</p>

<p>If you have an SV and want to know what kind of data
Perl thinks is stored in it, you can use the following
macros to check the type of SV you have.</p>

<p>SvIOK(SV*) SvNOK(SV*) SvPOK(SV*)</p>

<p>You can get and set the current length of the string
stored in an SV with the following macros:</p>

<p>SvCUR(SV*) SvCUR_set(SV*, I32 val)</p>

<p>You can also get a pointer to the end of the string
stored in the SV with the macro:</p>

<p>SvEND(SV*)</p>

<p>But note that these last three macros are valid only if
&quot;SvPOK()&quot; is true.</p>

<p>If you want to append something to the end of string
stored in an &quot;SV*&quot;, you can use the following
functions:</p>

<p>void sv_catpv(SV*, const char*); void sv_catpvn(SV*,
const char*, STRLEN); void sv_catpvf(SV*, const char*, ...);
void sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **,
I32, bool); void sv_catsv(SV*, SV*);</p>

<p>The first function calculates the length of the string
to be appended by using &quot;strlen&quot;. In the second,
you specify the length of the string yourself. The third
function processes its arguments like &quot;sprintf&quot;
and appends the formatted output. The fourth function works
like &quot;vsprintf&quot;. You can specify the address and
length of an array of SVs instead of the va_list argument.
The fifth function extends the string stored in the first SV
with the string stored in the second SV. It also forces the
second SV to be interpreted as a string.</p>

<p>The &quot;sv_cat*()&quot; functions are not generic
enough to operate on values that have &quot;magic&quot;. See
&quot;Magic Virtual Tables&quot; later in this document.</p>

<p>If you know the name of a scalar variable, you can get a
pointer to its SV by using the following:</p>

<p>SV* get_sv(&quot;package::varname&quot;, 0);</p>

<p>This returns NULL if the variable does not exist.</p>

<p>If you want to know if this variable (or any other SV)
is actually &quot;defined&quot;, you can call:</p>

<p>SvOK(SV*)</p>

<p>The scalar &quot;undef&quot; value is stored in an SV
instance called &quot;PL_sv_undef&quot;.</p>

<p>Its address can be used whenever an &quot;SV*&quot; is
needed. Make sure that you don t try to compare a random sv
with &amp;PL_sv_undef. For example when interfacing Perl
code, itll work correctly for:</p>

<p>foo(undef);</p>

<p>But wont work when called as:</p>

<p>$x = undef; foo($x);</p>

<p>So to repeat always use SvOK() to check whether an sv is
defined.</p>

<p>Also you have to be careful when using &amp;PL_sv_undef
as a value in AVs or HVs (see &quot;AVs, HVs and undefined
values&quot;).</p>

<p>There are also the two values &quot;PL_sv_yes&quot; and
&quot;PL_sv_no&quot;, which contain boolean TRUE and FALSE
values, respectively. Like &quot;PL_sv_undef&quot;, their
addresses can be used whenever an &quot;SV*&quot; is
needed.</p>

<p>Do not be fooled into thinking that &quot;(SV *) 0&quot;
is the same as &amp;PL_sv_undef. Take this code:</p>

<p>SV* sv = (SV*) 0; if (I-am-to-return-a-real-value) { sv
= sv_2mortal(newSViv(42)); } sv_setsv(ST(0), sv);</p>

<p>This code tries to return a new SV (which contains the
value 42) if it should return a real value, or undef
otherwise. Instead it has returned a NULL pointer which,
somewhere down the line, will cause a segmentation
violation, bus error, or just weird results. Change the zero
to &amp;PL_sv_undef in the first line and all will be
well.</p>

<p>To free an SV that you ve created, call
&quot;SvREFCNT_dec(SV*)&quot;. Normally this call is not
necessary (see &quot;Reference Counts and
Mortality&quot;).</p>

<p>Offsets Perl provides the function &quot;sv_chop&quot;
to efficiently remove characters from the beginning of a
string; you give it an SV and a pointer to somewhere inside
the PV, and it discards everything before the pointer. The
efficiency comes by means of a little hack: instead of
actually removing the characters, &quot;sv_chop&quot; sets
the flag &quot;OOK&quot; (offset OK) to signal to other
functions that the offset hack is in effect, and it puts the
number of bytes chopped off into the IV field of the SV. It
then moves the PV pointer (called &quot;SvPVX&quot;) forward
that many bytes, and adjusts &quot;SvCUR&quot; and
&quot;SvLEN&quot;.</p>

<p>Hence, at this point, the start of the buffer that we
allocated lives at &quot;SvPVX(sv) - SvIV(sv)&quot; in
memory and the PV pointer is pointing into the middle of
this allocated storage.</p>

<p>This is best demonstrated by example:</p>

<p>% ./perl -Ilib -MDevel::Peek -le
&rsquo;$a=&quot;12345&quot;; $a=~s/.//; Dump($a)&rsquo; SV =
PVIV(0x8128450) at 0x81340f0 REFCNT = 1 FLAGS =
(POK,OOK,pPOK) IV = 1 (OFFSET) PV = 0x8135781 (
&quot;1&quot; . ) &quot;2345&quot; CUR = 4 LEN = 5</p>

<p>Here the number of bytes chopped off (1) is put into IV,
and &quot;Devel::Peek::Dump&quot; helpfully reminds us that
this is an offset. The portion of the string between the
&quot;real&quot; and the &quot;fake&quot; beginnings is
shown in parentheses, and the values of &quot;SvCUR&quot;
and &quot;SvLEN&quot; reflect the fake beginning, not the
real one.</p>

<p>Something similar to the offset hack is performed on AVs
to enable efficient shifting and splicing off the beginning
of the array; while &quot;AvARRAY&quot; points to the first
element in the array that is visible from Perl,
&quot;AvALLOC&quot; points to the real start of the C array.
These are usually the same, but a &quot;shift&quot;
operation can be carried out by increasing
&quot;AvARRAY&quot; by one and decreasing &quot;AvFILL&quot;
and &quot;AvLEN&quot;. Again, the location of the real start
of the C array only comes into play when freeing the array.
See &quot;av_shift&quot; in av.c.</p>

<p>Whas Really Stored in an SV? Recall that the usual
method of determining the type of scalar you have is to use
&quot;Sv*OK&quot; macros. Because a scalar can be both a
number and a string, usually these macros will always return
TRUE and calling the &quot;Sv*V&quot; macros will do the
appropriate conversion of string to integer/double or
integer/double to string.</p>

<p>If you really need to know if you have an integer,
double, or string pointer in an SV, you can use the
following three macros instead:</p>

<p>SvIOKp(SV*) SvNOKp(SV*) SvPOKp(SV*)</p>

<p>These will tell you if you truly have an integer,
double, or string pointer stored in your SV. The
&quot;p&quot; stands for private.</p>

<p>The are various ways in which the private and public
flags may differ. For example, a tied SV may have a valid
underlying value in the IV slot (so SvIOKp is true), but the
data should be accessed via the FETCH routine rather than
directly, so SvIOK is false. Another is when numeric
conversion has occurred and precision has been lost: only
the private flag is set on lossy values. So when an NV is
converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will
be set, while SvIOK wont be.</p>

<p>In general, though, its best to use the &quot;Sv*V&quot;
macros.</p>

<p>Working with AVs There are two ways to create and load
an AV. The first method creates an empty AV:</p>

<p>AV* newAV();</p>

<p>The second method both creates the AV and initially
populates it with SVs:</p>

<p>AV* av_make(I32 num, SV **ptr);</p>

<p>The second argument points to an array containing
&quot;num&quot; &quot;SV*&quot;s. Once the AV has been
created, the SVs can be destroyed, if so desired.</p>

<p>Once the AV has been created, the following operations
are possible on AVs:</p>

<p>void av_push(AV*, SV*); SV* av_pop(AV*); SV*
av_shift(AV*); void av_unshift(AV*, I32 num);</p>

<p>These should be familiar operations, with the exception
of &quot;av_unshift&quot;. This routine adds &quot;num&quot;
elements at the front of the array with the
&quot;undef&quot; value. You must then use
&quot;av_store&quot; (described below) to assign values to
these new elements.</p>

<p>Here are some other functions:</p>

<p>I32 av_len(AV*); SV** av_fetch(AV*, I32 key, I32 lval);
SV** av_store(AV*, I32 key, SV* val);</p>

<p>The &quot;av_len&quot; function returns the highest
index value in array (just like $#array in Perl). If the
array is empty, -1 is returned. The &quot;av_fetch&quot;
function returns the value at index &quot;key&quot;, but if
&quot;lval&quot; is non-zero, then &quot;av_fetch&quot; will
store an undef value at that index. The &quot;av_store&quot;
function stores the value &quot;val&quot; at index
&quot;key&quot;, and does not increment the reference count
of &quot;val&quot;. Thus the caller is responsible for
taking care of that, and if &quot;av_store&quot; returns
NULL, the caller will have to decrement the reference count
to avoid a memory leak. Note that &quot;av_fetch&quot; and
&quot;av_store&quot; both return &quot;SV**&quot; s, not
&quot;SV*&quot;s as their return value.</p>

<p>void av_clear(AV*); void av_undef(AV*); void
av_extend(AV*, I32 key);</p>

<p>The &quot;av_clear&quot; function deletes all the
elements in the AV* array, but does not actually delete the
array itself. The &quot;av_undef&quot; function will delete
all the elements in the array plus the array itself. The
&quot;av_extend&quot; function extends the array so that it
contains at least &quot;key+1&quot; elements. If
&quot;key+1&quot; is less than the currently allocated
length of the array, then nothing is done.</p>

<p>If you know the name of an array variable, you can get a
pointer to its AV by using the following:</p>

<p>AV* get_av(&quot;package::varname&quot;, 0);</p>

<p>This returns NULL if the variable does not exist.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; for more information on how to use the array
access functions on tied arrays.</p>

<p>Working with HVs To create an HV, you use the following
routine:</p>

<p>HV* newHV();</p>

<p>Once the HV has been created, the following operations
are possible on HVs:</p>

<p>SV** hv_store(HV*, const char* key, U32 klen, SV* val,
U32 hash); SV** hv_fetch(HV*, const char* key, U32 klen, I32
lval);</p>

<p>The &quot;klen&quot; parameter is the length of the key
being passed in (Note that you cannot pass 0 in as a value
of &quot;klen&quot; to tell Perl to measure the length of
the key). The &quot;val&quot; argument contains the SV
pointer to the scalar being stored, and &quot;hash&quot; is
the precomputed hash value (zero if you want
&quot;hv_store&quot; to calculate it for you). The
&quot;lval&quot; parameter indicates whether this fetch is
actually a part of a store operation, in which case a new
undefined value will be added to the HV with the supplied
key and &quot;hv_fetch&quot; will return as if the value had
already existed.</p>

<p>Remember that &quot;hv_store&quot; and
&quot;hv_fetch&quot; return &quot;SV**&quot;s and not just
&quot;SV*&quot;. To access the scalar value, you must first
dereference the return value. However, you should check to
make sure that the return value is not NULL before
dereferencing it.</p>

<p>These two functions check if a hash table entry exists,
and deletes it.</p>

<p>bool hv_exists(HV*, const char* key, U32 klen); SV*
hv_delete(HV*, const char* key, U32 klen, I32 flags);</p>

<p>If &quot;flags&quot; does not include the
&quot;G_DISCARD&quot; flag then &quot;hv_delete&quot; will
create and return a mortal copy of the deleted value.</p>

<p>And more miscellaneous functions:</p>

<p>void hv_clear(HV*); void hv_undef(HV*);</p>

<p>Like their AV counterparts, &quot;hv_clear&quot; deletes
all the entries in the hash table but does not actually
delete the hash table. The &quot;hv_undef&quot; deletes both
the entries and the hash table itself.</p>

<p>Perl keeps the actual data in linked list of structures
with a typedef of HE. These contain the actual key and value
pointers (plus extra administrative overhead). The key is a
string pointer; the value is an &quot;SV*&quot;. However,
once you have an &quot;HE*&quot;, to get the actual key and
value, use the routines specified below.</p>

<p>I32 hv_iterinit(HV*); /* Prepares starting point to
traverse hash table */ HE* hv_iternext(HV*); /* Get the next
entry, and return a pointer to a structure that has both the
key and value */ char* hv_iterkey(HE* entry, I32* retlen);
/* Get the key from an HE structure and also return the
length of the key string */ SV* hv_iterval(HV*, HE* entry);
/* Return an SV pointer to the value of the HE structure */
SV* hv_iternextsv(HV*, char** key, I32* retlen); /* This
convenience routine combines hv_iternext, hv_iterkey, and
hv_iterval. The key and retlen arguments are return values
for the key and its length. The value is returned in the SV*
argument */</p>

<p>If you know the name of a hash variable, you can get a
pointer to its HV by using the following:</p>

<p>HV* get_hv(&quot;package::varname&quot;, 0);</p>

<p>This returns NULL if the variable does not exist.</p>

<p>The hash algorithm is defined in the
&quot;PERL_HASH(hash, key, klen)&quot; macro:</p>

<p>hash = 0; while (klen--) hash = (hash * 33) + *key++;
hash = hash + (hash &gt;&gt; 5); /* after 5.6 */</p>

<p>The last step was added in version 5.6 to improve
distribution of lower bits in the resulting hash value.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; for more information on how to use the hash
access functions on tied hashes.</p>

<p>Hash API Extensions Beginning with version 5.004, the
following functions are also supported:</p>

<p>HE* hv_fetch_ent (HV* tb, SV* key, I32 lval, U32 hash);
HE* hv_store_ent (HV* tb, SV* key, SV* val, U32 hash);</p>

<p>bool hv_exists_ent (HV* tb, SV* key, U32 hash); SV*
hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);</p>

<p>SV* hv_iterkeysv (HE* entry);</p>

<p>Note that these functions take &quot;SV*&quot; keys,
which simplifies writing of extension code that deals with
hash structures. These functions also allow passing of
&quot;SV*&quot; keys to &quot;tie&quot; functions without
forcing you to stringify the keys (unlike the previous set
of functions).</p>

<p>They also return and accept whole hash entries
(&quot;HE*&quot;), making their use more efficient (since
the hash number for a particular string doesnt have to be
recomputed every time). See perlapi for detailed
descriptions.</p>

<p>The following macros must always be used to access the
contents of hash entries. Note that the arguments to these
macros must be simple variables, since they may get
evaluated more than once. See perlapi for detailed
descriptions of these macros.</p>

<p>HePV(HE* he, STRLEN len) HeVAL(HE* he) HeHASH(HE* he)
HeSVKEY(HE* he) HeSVKEY_force(HE* he) HeSVKEY_set(HE* he,
SV* sv)</p>

<p>These two lower level macros are defined, but must only
be used when dealing with keys that are not
&quot;SV*&quot;s:</p>

<p>HeKEY(HE* he) HeKLEN(HE* he)</p>

<p>Note that both &quot;hv_store&quot; and
&quot;hv_store_ent&quot; do not increment the reference
count of the stored &quot;val&quot;, which is the callers
responsibility. If these functions return a NULL value, the
caller will usually have to decrement the reference count of
&quot;val&quot; to avoid a memory leak.</p>

<p>AVs, HVs and undefined values Sometimes you have to
store undefined values in AVs or HVs. Although this may be a
rare case, it can be tricky. That s because youre used to
using &amp;PL_sv_undef if you need an undefined SV.</p>

<p>For example, intuition tells you that this XS code:</p>

<p>AV *av = newAV(); av_store( av, 0, &amp;PL_sv_undef
);</p>

<p>is equivalent to this Perl code:</p>

<p>my @av; $av[0] = undef;</p>

<p>Unfortunately, this isnt true. AVs use &amp;PL_sv_undef
as a marker for indicating that an array element has not yet
been initialized. Thus, &quot;exists $av[0]&quot; would be
true for the above Perl code, but false for the array
generated by the XS code.</p>

<p>Other problems can occur when storing &amp;PL_sv_undef
in HVs:</p>

<p>hv_store( hv, &quot;key&quot;, 3, &amp;PL_sv_undef, 0
);</p>

<p>This will indeed make the value &quot;undef&quot;, but
if you try to modify the value of &quot;key&quot;, youll get
the following error:</p>

<p>Modification of non-creatable hash value attempted</p>

<p>In perl 5.8.0, &amp;PL_sv_undef was also used to mark
placeholders in restricted hashes. This caused such hash
entries not to appear when iterating over the hash or when
checking for the keys with the &quot;hv_exists&quot;
function.</p>

<p>You can run into similar problems when you store
&amp;PL_sv_true or &amp;PL_sv_false into AVs or HVs. Trying
to modify such elements will give you the following
error:</p>

<p>Modification of a read-only value attempted</p>

<p>To make a long story short, you can use the special
variables &amp;PL_sv_undef, &amp;PL_sv_true and
&amp;PL_sv_false with AVs and HVs, but you have to make sure
you know what youre doing.</p>

<p>Generally, if you want to store an undefined value in an
AV or HV, you should not use &amp;PL_sv_undef, but rather
create a new undefined value using the &quot;newSV&quot;
function, for example:</p>

<p>av_store( av, 42, newSV(0) ); hv_store( hv,
&quot;foo&quot;, 3, newSV(0), 0 );</p>

<p>References References are a special type of scalar that
point to other data types (including references).</p>

<p>To create a reference, use either of the following
functions:</p>

<p>SV* newRV_inc((SV*) thing); SV* newRV_noinc((SV*)
thing);</p>

<p>The &quot;thing&quot; argument can be any of an
&quot;SV*&quot;, &quot;AV*&quot;, or &quot;HV*&quot;. The
functions are identical except that &quot;newRV_inc&quot;
increments the reference count of the &quot;thing&quot;,
while &quot;newRV_noinc&quot; does not. For historical
reasons, &quot;newRV&quot; is a synonym for
&quot;newRV_inc&quot;.</p>

<p>Once you have a reference, you can use the following
macro to dereference the reference:</p>

<p>SvRV(SV*)</p>

<p>then call the appropriate routines, casting the returned
&quot;SV*&quot; to either an &quot;AV*&quot; or
&quot;HV*&quot;, if required.</p>

<p>To determine if an SV is a reference, you can use the
following macro:</p>

<p>SvROK(SV*)</p>

<p>To discover what type of value the reference refers to,
use the following macro and then check the return value.</p>

<p>SvTYPE(SvRV(SV*))</p>

<p>The most useful types that will be returned are:</p>

<p>SVt_IV Scalar SVt_NV Scalar SVt_PV Scalar SVt_RV Scalar
SVt_PVAV Array SVt_PVHV Hash SVt_PVCV Code SVt_PVGV Glob
(possible a file handle) SVt_PVMG Blessed or Magical
Scalar</p>

<p>See the sv.h header file for more details.</p>

<p>Blessed References and Class Objects References are also
used to support object-oriented programming. In perls OO
lexicon, an object is simply a reference that has been
blessed into a package (or class). Once blessed, the
programmer may now use the reference to access the various
methods in the class.</p>

<p>A reference can be blessed into a package with the
following function:</p>

<p>SV* sv_bless(SV* sv, HV* stash);</p>

<p>The &quot;sv&quot; argument must be a reference value.
The &quot;stash&quot; argument specifies which class the
reference will belong to. See &quot;Stashes and Globs&quot;
for information on converting class names into stashes.</p>

<p>/* Still under construction */</p>

<p>Upgrades rv to reference if not already one. Creates new
SV for rv to point to. If &quot;classname&quot; is non-null,
the SV is blessed into the specified class. SV is
returned.</p>

<p>SV* newSVrv(SV* rv, const char* classname);</p>

<p>Copies integer, unsigned integer or double into an SV
whose reference is &quot;rv&quot;. SV is blessed if
&quot;classname&quot; is non-null.</p>

<p>SV* sv_setref_iv(SV* rv, const char* classname, IV iv);
SV* sv_setref_uv(SV* rv, const char* classname, UV uv); SV*
sv_setref_nv(SV* rv, const char* classname, NV iv);</p>

<p>Copies the pointer value (the address, not the string!)
into an SV whose reference is rv. SV is blessed if
&quot;classname&quot; is non-null.</p>

<p>SV* sv_setref_pv(SV* rv, const char* classname, PV
iv);</p>

<p>Copies string into an SV whose reference is
&quot;rv&quot;. Set length to 0 to let Perl calculate the
string length. SV is blessed if &quot;classname&quot; is
non-null.</p>

<p>SV* sv_setref_pvn(SV* rv, const char* classname, PV iv,
STRLEN length);</p>

<p>Tests whether the SV is blessed into the specified
class. It does not check inheritance relationships.</p>

<p>int sv_isa(SV* sv, const char* name);</p>

<p>Tests whether the SV is a reference to a blessed
object.</p>

<p>int sv_isobject(SV* sv);</p>

<p>Tests whether the SV is derived from the specified
class. SV can be either a reference to a blessed object or a
string containing a class name. This is the function
implementing the &quot;UNIVERSAL::isa&quot;
functionality.</p>

<p>bool sv_derived_from(SV* sv, const char* name);</p>

<p>To check if youve got an object derived from a specific
class you have to write:</p>

<p>if (sv_isobject(sv) &amp;&amp; sv_derived_from(sv,
class)) { ... }</p>

<p>Creating New Variables To create a new Perl variable
with an undef value which can be accessed from your Perl
script, use the following routines, depending on the
variable type.</p>

<p>SV* get_sv(&quot;package::varname&quot;, GV_ADD); AV*
get_av(&quot;package::varname&quot;, GV_ADD); HV*
get_hv(&quot;package::varname&quot;, GV_ADD);</p>

<p>Notice the use of TRUE as the second parameter. The new
variable can now be set, using the routines appropriate to
the data type.</p>

<p>There are additional macros whose values may be bitwise
OR ed with the &quot;TRUE&quot; argument to enable certain
extra features. Those bits are:</p>

<p>GV_ADDMULTI Marks the variable as multiply defined, thus
preventing the:</p>

<p>Name &lt;varname&gt; used only once: possible typo</p>

<p>warning.</p>

<p>GV_ADDWARN Issues the warning:</p>

<p>Had to create &lt;varname&gt; unexpectedly</p>

<p>if the variable did not exist before the function was
called.</p>

<p>If you do not specify a package name, the variable is
created in the current package.</p>

<p>Reference Counts and Mortality Perl uses a reference
count-driven garbage collection mechanism. SVs, AVs, or HVs
(xV for short in the following) start their life with a
reference count of 1. If the reference count of an xV ever
drops to 0, then it will be destroyed and its memory made
available for reuse.</p>

<p>This normally doesnt happen at the Perl level unless a
variable is undef ed or the last variable holding a
reference to it is changed or overwritten. At the internal
level, however, reference counts can be manipulated with the
following macros:</p>

<p>int SvREFCNT(SV* sv); SV* SvREFCNT_inc(SV* sv); void
SvREFCNT_dec(SV* sv);</p>

<p>However, there is one other function which manipulates
the reference count of its argument. The
&quot;newRV_inc&quot; function, you will recall, creates a
reference to the specified argument. As a side effect, it
increments the arguments reference count. If this is not
what you want, use &quot;newRV_noinc&quot; instead.</p>

<p>For example, imagine you want to return a reference from
an XSUB function. Inside the XSUB routine, you create an SV
which initially has a reference count of one. Then you call
&quot;newRV_inc&quot;, passing it the just-created SV. This
returns the reference as a new SV, but the reference count
of the SV you passed to &quot;newRV_inc&quot; has been
incremented to two. Now you return the reference from the
XSUB routine and forget about the SV. But Perl hasnt!
Whenever the returned reference is destroyed, the reference
count of the original SV is decreased to one and nothing
happens. The SV will hang around without any way to access
it until Perl itself terminates. This is a memory leak.</p>

<p>The correct procedure, then, is to use
&quot;newRV_noinc&quot; instead of &quot;newRV_inc&quot;.
Then, if and when the last reference is destroyed, the
reference count of the SV will go to zero and it will be
destroyed, stopping any memory leak.</p>

<p>There are some convenience functions available that can
help with the destruction of xVs. These functions introduce
the concept of &quot;mortality&quot;. An xV that is mortal
has had its reference count marked to be decremented, but
not actually decremented, until &quot;a short time
later&quot;. Generally the term &quot;short time later&quot;
means a single Perl statement, such as a call to an XSUB
function. The actual determinant for when mortal xVs have
their reference count decremented depends on two macros,
SAVETMPS and FREETMPS. See perlcall and perlxs for more
details on these macros.</p>

<p>&quot;Mortalization&quot; then is at its simplest a
deferred &quot;SvREFCNT_dec&quot;. However, if you mortalize
a variable twice, the reference count will later be
decremented twice.</p>

<p>&quot;Mortal&quot; SVs are mainly used for SVs that are
placed on perls stack. For example an SV which is created
just to pass a number to a called sub is made mortal to have
it cleaned up automatically when its popped off the stack.
Similarly, results returned by XSUBs (which are pushed on
the stack) are often made mortal.</p>

<p>To create a mortal variable, use the functions:</p>

<p>SV* sv_newmortal() SV* sv_2mortal(SV*) SV*
sv_mortalcopy(SV*)</p>

<p>The first call creates a mortal SV (with no value), the
second converts an existing SV to a mortal SV (and thus
defers a call to &quot;SvREFCNT_dec&quot;), and the third
creates a mortal copy of an existing SV. Because
&quot;sv_newmortal&quot; gives the new SV no value,it must
normally be given one via &quot;sv_setpv&quot;,
&quot;sv_setiv&quot;, etc. :</p>

<p>SV *tmp = sv_newmortal(); sv_setiv(tmp, an_integer);</p>

<p>As that is multiple C statements it is quite common so
see this idiom instead:</p>

<p>SV *tmp = sv_2mortal(newSViv(an_integer));</p>

<p>You should be careful about creating mortal variables.
Strange things can happen if you make the same value mortal
within multiple contexts, or if you make a variable mortal
multiple times. Thinking of &quot;Mortalization&quot; as
deferred &quot;SvREFCNT_dec&quot; should help to minimize
such problems. For example if you are passing an SV which
you know has high enough REFCNT to survive its use on the
stack you need not do any mortalization. If you are not sure
then doing an &quot;SvREFCNT_inc&quot; and
&quot;sv_2mortal&quot;, or making a
&quot;sv_mortalcopy&quot; is safer.</p>

<p>The mortal routines are not just for SVs -- AVs and HVs
can be made mortal by passing their address (type-casted to
&quot;SV*&quot;) to the &quot;sv_2mortal&quot; or
&quot;sv_mortalcopy&quot; routines.</p>

<p>Stashes and Globs A stash is a hash that contains all
variables that are defined within a package. Each key of the
stash is a symbol name (shared by all the different types of
objects that have the same name), and each value in the hash
table is a GV (Glob Value). This GV in turn contains
references to the various objects of that name, including
(but not limited to) the following:</p>

<p>Scalar Value Array Value Hash Value I/O Handle Format
Subroutine</p>

<p>There is a single stash called &quot;PL_defstash&quot;
that holds the items that exist in the &quot;main&quot;
package. To get at the items in other packages, append the
string &quot;::&quot; to the package name. The items in the
&quot;Foo&quot; package are in the stash &quot;Foo::&quot;
in PL_defstash. The items in the &quot;Bar::Baz&quot;
package are in the stash &quot;Baz::&quot; in
&quot;Bar::&quot; s stash.</p>

<p>To get the stash pointer for a particular package, use
the function:</p>

<p>HV* gv_stashpv(const char* name, I32 flags) HV*
gv_stashsv(SV*, I32 flags)</p>

<p>The first function takes a literal string, the second
uses the string stored in the SV. Remember that a stash is
just a hash table, so you get back an &quot;HV*&quot;. The
&quot;flags&quot; flag will create a new package if it is
set to GV_ADD.</p>

<p>The name that &quot;gv_stash*v&quot; wants is the name
of the package whose symbol table you want. The default
package is called &quot;main&quot;. If you have multiply
nested packages, pass their names to &quot;gv_stash*v&quot;,
separated by &quot;::&quot; as in the Perl language
itself.</p>

<p>Alternately, if you have an SV that is a blessed
reference, you can find out the stash pointer by using:</p>

<p>HV* SvSTASH(SvRV(SV*));</p>

<p>then use the following to get the package name
itself:</p>

<p>char* HvNAME(HV* stash);</p>

<p>If you need to bless or re-bless an object you can use
the following function:</p>

<p>SV* sv_bless(SV*, HV* stash)</p>

<p>where the first argument, an &quot;SV*&quot;, must be a
reference, and the second argument is a stash. The returned
&quot;SV*&quot; can now be used in the same way as any other
SV.</p>

<p>For more information on references and blessings,
consult perlref.</p>

<p>Double-Typed SVs Scalar variables normally contain only
one type of value, an integer, double, pointer, or
reference. Perl will automatically convert the actual scalar
data from the stored type into the requested type.</p>

<p>Some scalar variables contain more than one type of
scalar data. For example, the variable $! contains either
the numeric value of &quot;errno&quot; or its string
equivalent from either &quot;strerror&quot; or
&quot;sys_errlist[]&quot;.</p>

<p>To force multiple data values into an SV, you must do
two things: use the &quot;sv_set*v&quot; routines to add the
additional scalar type, then set a flag so that Perl will
believe it contains more than one type of data. The four
macros to set the flags are:</p>

<p>SvIOK_on SvNOK_on SvPOK_on SvROK_on</p>

<p>The particular macro you must use depends on which
&quot;sv_set*v&quot; routine you called first. This is
because every &quot;sv_set*v&quot; routine turns on only the
bit for the particular type of data being set, and turns off
all the rest.</p>

<p>For example, to create a new Perl variable called
&quot;dberror&quot; that contains both the numeric and
descriptive string error values, you could use the following
code:</p>

<p>extern int dberror; extern char *dberror_list;</p>

<p>SV* sv = get_sv(&quot;dberror&quot;, GV_ADD);
sv_setiv(sv, (IV) dberror); sv_setpv(sv,
dberror_list[dberror]); SvIOK_on(sv);</p>

<p>If the order of &quot;sv_setiv&quot; and
&quot;sv_setpv&quot; had been reversed, then the macro
&quot;SvPOK_on&quot; would need to be called instead of
&quot;SvIOK_on&quot;.</p>

<p>Magic Variables [This section still under construction.
Ignore everything here. Post no bills. Everything not
permitted is forbidden.]</p>

<p>Any SV may be magical, that is, it has special features
that a normal SV does not have. These features are stored in
the SV structure in a linked list of &quot;struct
magic&quot;s, typedefed to &quot;MAGIC&quot;.</p>

<p>struct magic { MAGIC* mg_moremagic; MGVTBL* mg_virtual;
U16 mg_private; char mg_type; U8 mg_flags; I32 mg_len; SV*
mg_obj; char* mg_ptr; };</p>

<p>Note this is current as of patchlevel 0, and could
change at any time.</p>

<p>Assigning Magic Perl adds magic to an SV using the
sv_magic function:</p>

<p>void sv_magic(SV* sv, SV* obj, int how, const char*
name, I32 namlen);</p>

<p>The &quot;sv&quot; argument is a pointer to the SV that
is to acquire a new magical feature.</p>

<p>If &quot;sv&quot; is not already magical, Perl uses the
&quot;SvUPGRADE&quot; macro to convert &quot;sv&quot; to
type &quot;SVt_PVMG&quot;. Perl then continues by adding new
magic to the beginning of the linked list of magical
features. Any prior entry of the same type of magic is
deleted. Note that this can be overridden, and multiple
instances of the same type of magic can be associated with
an SV.</p>

<p>The &quot;name&quot; and &quot;namlen&quot; arguments
are used to associate a string with the magic, typically the
name of a variable. &quot;namlen&quot; is stored in the
&quot;mg_len&quot; field and if &quot;name&quot; is non-null
then either a &quot;savepvn&quot; copy of &quot;name&quot;
or &quot;name&quot; itself is stored in the
&quot;mg_ptr&quot; field, depending on whether
&quot;namlen&quot; is greater than zero or equal to zero
respectively. As a special case, if &quot;(name &amp;&amp;
namlen == HEf_SVKEY)&quot; then &quot;name&quot; is assumed
to contain an &quot;SV*&quot; and is stored as-is with its
REFCNT incremented.</p>

<p>The sv_magic function uses &quot;how&quot; to determine
which, if any, predefined &quot;Magic Virtual Table&quot;
should be assigned to the &quot;mg_virtual&quot; field. See
the &quot;Magic Virtual Tables&quot; section below. The
&quot;how&quot; argument is also stored in the
&quot;mg_type&quot; field. The value of &quot;how&quot;
should be chosen from the set of macros
&quot;PERL_MAGIC_foo&quot; found in perl.h. Note that before
these macros were added, Perl internals used to directly use
character literals, so you may occasionally come across old
code or documentation referring to U magic rather than
&quot;PERL_MAGIC_uvar&quot; for example.</p>

<p>The &quot;obj&quot; argument is stored in the
&quot;mg_obj&quot; field of the &quot;MAGIC&quot; structure.
If it is not the same as the &quot;sv&quot; argument, the
reference count of the &quot;obj&quot; object is
incremented. If it is the same, or if the &quot;how&quot;
argument is &quot;PERL_MAGIC_arylen&quot;, or if it is a
NULL pointer, then &quot;obj&quot; is merely stored, without
the reference count being incremented.</p>

<p>See also &quot;sv_magicext&quot; in perlapi for a more
flexible way to add magic to an SV.</p>

<p>There is also a function to add magic to an
&quot;HV&quot;:</p>

<p>void hv_magic(HV *hv, GV *gv, int how);</p>

<p>This simply calls &quot;sv_magic&quot; and coerces the
&quot;gv&quot; argument into an &quot;SV&quot;.</p>

<p>To remove the magic from an SV, call the function
sv_unmagic:</p>

<p>void sv_unmagic(SV *sv, int type);</p>

<p>The &quot;type&quot; argument should be equal to the
&quot;how&quot; value when the &quot;SV&quot; was initially
made magical.</p>

<p>Magic Virtual Tables The &quot;mg_virtual&quot; field in
the &quot;MAGIC&quot; structure is a pointer to an
&quot;MGVTBL&quot;, which is a structure of function
pointers and stands for &quot;Magic Virtual Table&quot; to
handle the various operations that might be applied to that
variable.</p>

<p>The &quot;MGVTBL&quot; has five (or sometimes eight)
pointers to the following routine types:</p>

<p>int (*svt_get)(SV* sv, MAGIC* mg); int (*svt_set)(SV*
sv, MAGIC* mg); U32 (*svt_len)(SV* sv, MAGIC* mg); int
(*svt_clear)(SV* sv, MAGIC* mg); int (*svt_free)(SV* sv,
MAGIC* mg);</p>

<p>int (*svt_copy)(SV *sv, MAGIC* mg, SV *nsv, const char
*name, int namlen); int (*svt_dup)(MAGIC *mg, CLONE_PARAMS
*param); int (*svt_local)(SV *nsv, MAGIC *mg);</p>

<p>This MGVTBL structure is set at compile-time in perl.h
and there are currently 32 types. These different structures
contain pointers to various routines that perform additional
actions depending on which function is being called.</p>

<p>Function pointer Action taken ----------------
------------ svt_get Do something before the value of the SV
is retrieved. svt_set Do something after the SV is assigned
a value. svt_len Report on the SV&rsquo;s length. svt_clear
Clear something the SV represents. svt_free Free any extra
storage associated with the SV.</p>

<p>svt_copy copy tied variable magic to a tied element
svt_dup duplicate a magic structure during thread cloning
svt_local copy magic to local value during
&rsquo;local&rsquo;</p>

<p>For instance, the MGVTBL structure called
&quot;vtbl_sv&quot; (which corresponds to an
&quot;mg_type&quot; of &quot;PERL_MAGIC_sv&quot;)
contains:</p>

<p>{ magic_get, magic_set, magic_len, 0, 0 }</p>

<p>Thus, when an SV is determined to be magical and of type
&quot;PERL_MAGIC_sv&quot;, if a get operation is being
performed, the routine &quot;magic_get&quot; is called. All
the various routines for the various magical types begin
with &quot;magic_&quot;. NOTE: the magic routines are not
considered part of the Perl API, and may not be exported by
the Perl library.</p>

<p>The last three slots are a recent addition, and for
source code compatibility they are only checked for if one
of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in
mg_flags. This means that most code can continue declaring a
vtable as a 5-element value. These three are currently used
exclusively by the threading code, and are highly subject to
change.</p>

<p>The current kinds of Magic Virtual Tables are:</p>

<p>mg_type (old-style char and macro) MGVTBL Type of magic
-------------------------- ------ -------------
PERL_MAGIC_sv vtbl_sv Special scalar variable A
PERL_MAGIC_overload vtbl_amagic %OVERLOAD hash a
PERL_MAGIC_overload_elem vtbl_amagicelem %OVERLOAD hash
element c PERL_MAGIC_overload_table (none) Holds overload
table (AMT) on stash B PERL_MAGIC_bm vtbl_bm Boyer-Moore
(fast string search) D PERL_MAGIC_regdata vtbl_regdata Regex
match position data (@+ and @- vars) d PERL_MAGIC_regdatum
vtbl_regdatum Regex match position data element E
PERL_MAGIC_env vtbl_env %ENV hash e PERL_MAGIC_envelem
vtbl_envelem %ENV hash element f PERL_MAGIC_fm vtbl_fm
Formline (&rsquo;compiled&rsquo; format) g
PERL_MAGIC_regex_global vtbl_mglob m//g target / study()ed
string H PERL_MAGIC_hints vtbl_sig %^H hash h
PERL_MAGIC_hintselem vtbl_hintselem %^H hash element I
PERL_MAGIC_isa vtbl_isa @ISA array i PERL_MAGIC_isaelem
vtbl_isaelem @ISA array element k PERL_MAGIC_nkeys
vtbl_nkeys scalar(keys()) lvalue L PERL_MAGIC_dbfile (none)
Debugger %_&lt;filename l PERL_MAGIC_dbline vtbl_dbline
Debugger %_&lt;filename element o PERL_MAGIC_collxfrm
vtbl_collxfrm Locale collate transformation P
PERL_MAGIC_tied vtbl_pack Tied array or hash p
PERL_MAGIC_tiedelem vtbl_packelem Tied array or hash element
q PERL_MAGIC_tiedscalar vtbl_packelem Tied scalar or handle
r PERL_MAGIC_qr vtbl_qr precompiled qr// regex S
PERL_MAGIC_sig vtbl_sig %SIG hash s PERL_MAGIC_sigelem
vtbl_sigelem %SIG hash element t PERL_MAGIC_taint vtbl_taint
Taintedness U PERL_MAGIC_uvar vtbl_uvar Available for use by
extensions v PERL_MAGIC_vec vtbl_vec vec() lvalue V
PERL_MAGIC_vstring (none) v-string scalars w PERL_MAGIC_utf8
vtbl_utf8 UTF-8 length+offset cache x PERL_MAGIC_substr
vtbl_substr substr() lvalue y PERL_MAGIC_defelem
vtbl_defelem Shadow &quot;foreach&quot; iterator variable /
smart parameter vivification # PERL_MAGIC_arylen vtbl_arylen
Array length ($#ary) . PERL_MAGIC_pos vtbl_pos pos() lvalue
&lt; PERL_MAGIC_backref vtbl_backref back pointer to a weak
ref ~ PERL_MAGIC_ext (none) Available for use by extensions
: PERL_MAGIC_symtab (none) hash used as symbol table %
PERL_MAGIC_rhash (none) hash used as restricted hash @
PERL_MAGIC_arylen_p vtbl_arylen_p pointer to $#a from @a</p>

<p>When an uppercase and lowercase letter both exist in the
table, then the uppercase letter is typically used to
represent some kind of composite type (a list or a hash),
and the lowercase letter is used to represent an element of
that composite type. Some internals code makes use of this
case relationship. However, v and V (vec and v-string) are
in no way related.</p>

<p>The &quot;PERL_MAGIC_ext&quot; and
&quot;PERL_MAGIC_uvar&quot; magic types are defined
specifically for use by extensions and will not be used by
perl itself. Extensions can use &quot;PERL_MAGIC_ext&quot;
magic to attach private information to variables (typically
objects). This is especially useful because there is no way
for normal perl code to corrupt this private information
(unlike using extra elements of a hash object).</p>

<p>Similarly, &quot;PERL_MAGIC_uvar&quot; magic can be used
much like tie() to call a C function any time a scalars
value is used or changed. The &quot;MAGIC&quot;s
&quot;mg_ptr&quot; field points to a &quot;ufuncs&quot;
structure:</p>

<p>struct ufuncs { I32 (*uf_val)(pTHX_ IV, SV*); I32
(*uf_set)(pTHX_ IV, SV*); IV uf_index; };</p>

<p>When the SV is read from or written to, the
&quot;uf_val&quot; or &quot;uf_set&quot; function will be
called with &quot;uf_index&quot; as the first arg and a
pointer to the SV as the second. A simple example of how to
add &quot;PERL_MAGIC_uvar&quot; magic is shown below. Note
that the ufuncs structure is copied by sv_magic, so you can
safely allocate it on the stack.</p>

<p>void Umagic(sv) SV *sv; PREINIT: struct ufuncs uf; CODE:
uf.uf_val = &amp;my_get_fn; uf.uf_set = &amp;my_set_fn;
uf.uf_index = 0; sv_magic(sv, 0, PERL_MAGIC_uvar,
(char*)&amp;uf, sizeof(uf));</p>

<p>Attaching &quot;PERL_MAGIC_uvar&quot; to arrays is
permissible but has no effect.</p>

<p>For hashes there is a specialized hook that gives
control over hash keys (but not values). This hook calls
&quot;PERL_MAGIC_uvar&quot; get magic if the &quot;set&quot;
function in the &quot;ufuncs&quot; structure is NULL. The
hook is activated whenever the hash is accessed with a key
specified as an &quot;SV&quot; through the functions
&quot;hv_store_ent&quot;, &quot;hv_fetch_ent&quot;,
&quot;hv_delete_ent&quot;, and &quot;hv_exists_ent&quot;.
Accessing the key as a string through the functions without
the &quot;..._ent&quot; suffix circumvents the hook. See
&quot;Guts&quot; in Hash::Util::Fieldhash for a detailed
description.</p>

<p>Note that because multiple extensions may be using
&quot;PERL_MAGIC_ext&quot; or &quot;PERL_MAGIC_uvar&quot;
magic, it is important for extensions to take extra care to
avoid conflict. Typically only using the magic on objects
blessed into the same class as the extension is sufficient.
For &quot;PERL_MAGIC_ext&quot; magic, it may also be
appropriate to add an I32 signature at the top of the
private data area and check that.</p>

<p>Also note that the &quot;sv_set*()&quot; and
&quot;sv_cat*()&quot; functions described earlier do not
invoke set magic on their targets. This must be done by the
user either by calling the &quot;SvSETMAGIC()&quot; macro
after calling these functions, or by using one of the
&quot;sv_set*_mg()&quot; or &quot;sv_cat*_mg()&quot;
functions. Similarly, generic C code must call the
&quot;SvGETMAGIC()&quot; macro to invoke any get magic if
they use an SV obtained from external sources in functions
that don t handle magic. See perlapi for a description of
these functions. For example, calls to the
&quot;sv_cat*()&quot; functions typically need to be
followed by &quot;SvSETMAGIC()&quot;, but they dont need a
prior &quot;SvGETMAGIC()&quot; since their implementation
handles get magic.</p>

<p>Finding Magic MAGIC* mg_find(SV*, int type); /* Finds
the magic pointer of that type */</p>

<p>This routine returns a pointer to the &quot;MAGIC&quot;
structure stored in the SV. If the SV does not have that
magical feature, &quot;NULL&quot; is returned. Also, if the
SV is not of type SVt_PVMG, Perl may core dump.</p>

<p>int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN
klen);</p>

<p>This routine checks to see what types of magic
&quot;sv&quot; has. If the mg_type field is an uppercase
letter, then the mg_obj is copied to &quot;nsv&quot;, but
the mg_type field is changed to be the lowercase letter.</p>

<p>Understanding the Magic of Tied Hashes and Arrays Tied
hashes and arrays are magical beasts of the
&quot;PERL_MAGIC_tied&quot; magic type.</p>

<p>WARNING: As of the 5.004 release, proper usage of the
array and hash access functions requires understanding a few
caveats. Some of these caveats are actually considered bugs
in the API, to be fixed in later releases, and are bracketed
with [MAYCHANGE] below. If you find yourself actually
applying such information in this section, be aware that the
behavior may change in the future, umm, without warning.</p>

<p>The perl tie function associates a variable with an
object that implements the various GET, SET, etc methods. To
perform the equivalent of the perl tie function from an
XSUB, you must mimic this behaviour. The code below carries
out the necessary steps - firstly it creates a new hash, and
then creates a second hash which it blesses into the class
which will implement the tie methods. Lastly it ties the two
hashes together, and returns a reference to the new tied
hash. Note that the code below does NOT call the TIEHASH
method in the MyTie class - see &quot;Calling Perl Routines
from within C Programs&quot; for details on how to do
this.</p>

<p>SV* mytie() PREINIT: HV *hash; HV *stash; SV *tie; CODE:
hash = newHV(); tie = newRV_noinc((SV*)newHV()); stash =
gv_stashpv(&quot;MyTie&quot;, GV_ADD); sv_bless(tie, stash);
hv_magic(hash, (GV*)tie, PERL_MAGIC_tied); RETVAL =
newRV_noinc(hash); OUTPUT: RETVAL</p>

<p>The &quot;av_store&quot; function, when given a tied
array argument, merely copies the magic of the array onto
the value to be &quot;stored&quot;, using
&quot;mg_copy&quot;. It may also return NULL, indicating
that the value did not actually need to be stored in the
array. [MAYCHANGE] After a call to &quot;av_store&quot; on a
tied array, the caller will usually need to call
&quot;mg_set(val)&quot; to actually invoke the perl level
&quot;STORE&quot; method on the TIEARRAY object. If
&quot;av_store&quot; did return NULL, a call to
&quot;SvREFCNT_dec(val)&quot; will also be usually necessary
to avoid a memory leak. [/MAYCHANGE]</p>

<p>The previous paragraph is applicable verbatim to tied
hash access using the &quot;hv_store&quot; and
&quot;hv_store_ent&quot; functions as well.</p>

<p>&quot;av_fetch&quot; and the corresponding hash
functions &quot;hv_fetch&quot; and &quot;hv_fetch_ent&quot;
actually return an undefined mortal value whose magic has
been initialized using &quot;mg_copy&quot;. Note the value
so returned does not need to be deallocated, as it is
already mortal. [MAYCHANGE] But you will need to call
&quot;mg_get()&quot; on the returned value in order to
actually invoke the perl level &quot;FETCH&quot; method on
the underlying TIE object. Similarly, you may also call
&quot;mg_set()&quot; on the return value after possibly
assigning a suitable value to it using &quot;sv_setsv&quot;,
which will invoke the &quot;STORE&quot; method on the TIE
object. [/MAYCHANGE]</p>

<p>[MAYCHANGE] In other words, the array or hash
fetch/store functions don t really fetch and store actual
values in the case of tied arrays and hashes. They merely
call &quot;mg_copy&quot; to attach magic to the values that
were meant to be &quot;stored&quot; or &quot;fetched&quot;.
Later calls to &quot;mg_get&quot; and &quot;mg_set&quot;
actually do the job of invoking the TIE methods on the
underlying objects. Thus the magic mechanism currently
implements a kind of lazy access to arrays and hashes.</p>

<p>Currently (as of perl version 5.004), use of the hash
and array access functions requires the user to be aware of
whether they are operating on &quot;normal&quot; hashes and
arrays, or on their tied variants. The API may be changed to
provide more transparent access to both tied and normal data
types in future versions. [/MAYCHANGE]</p>

<p>You would do well to understand that the TIEARRAY and
TIEHASH interfaces are mere sugar to invoke some perl method
calls while using the uniform hash and array syntax. The use
of this sugar imposes some overhead (typically about two to
four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to invoke
the methods). This overhead will be comparatively small if
the TIE methods are themselves substantial, but if they are
only a few statements long, the overhead will not be
insignificant.</p>

<p>Localizing changes Perl has a very handy
construction</p>

<p>{ local $var = 2; ... }</p>

<p>This construction is approximately equivalent to</p>

<p>{ my $oldvar = $var; $var = 2; ... $var = $oldvar; }</p>

<p>The biggest difference is that the first construction
would reinstate the initial value of $var, irrespective of
how control exits the block: &quot;goto&quot;,
&quot;return&quot;, &quot;die&quot;/&quot;eval&quot;, etc.
It is a little bit more efficient as well.</p>

<p>There is a way to achieve a similar task from C via Perl
API: create a pseudo-block, and arrange for some changes to
be automatically undone at the end of it, either explicit,
or via a non-local exit (via die()). A block-like construct
is created by a pair of &quot;ENTER&quot;/&quot;LEAVE&quot;
macros (see &quot;Returning a Scalar&quot; in perlcall).
Such a construct may be created specially for some important
localized task, or an existing one (like boundaries of
enclosing Perl subroutine/block, or an existing pair for
freeing TMPs) may be used. (In the second case the overhead
of additional localization must be almost negligible.) Note
that any XSUB is automatically enclosed in an
&quot;ENTER&quot;/&quot;LEAVE&quot; pair.</p>

<p>Inside such a pseudo-block the following service is
available:</p>

<p>&quot;SAVEINT(int i)&quot; &quot;SAVEIV(IV i)&quot;
&quot;SAVEI32(I32 i)&quot; &quot;SAVELONG(long i)&quot;
These macros arrange things to restore the value of integer
variable &quot;i&quot; at the end of enclosing
pseudo-block.</p>

<p>SAVESPTR(s) SAVEPPTR(p) These macros arrange things to
restore the value of pointers &quot;s&quot; and
&quot;p&quot;. &quot;s&quot; must be a pointer of a type
which survives conversion to &quot;SV*&quot; and back,
&quot;p&quot; should be able to survive conversion to
&quot;char*&quot; and back.</p>

<p>&quot;SAVEFREESV(SV *sv)&quot; The refcount of
&quot;sv&quot; would be decremented at the end of pseudo-
block. This is similar to &quot;sv_2mortal&quot; in that it
is also a mechanism for doing a delayed
&quot;SvREFCNT_dec&quot;. However, while
&quot;sv_2mortal&quot; extends the lifetime of
&quot;sv&quot; until the beginning of the next statement,
&quot;SAVEFREESV&quot; extends it until the end of the
enclosing scope. These lifetimes can be wildly
different.</p>

<p>Also compare &quot;SAVEMORTALIZESV&quot;.</p>

<p>&quot;SAVEMORTALIZESV(SV *sv)&quot; Just like
&quot;SAVEFREESV&quot;, but mortalizes &quot;sv&quot; at the
end of the current scope instead of decrementing its
reference count. This usually has the effect of keeping
&quot;sv&quot; alive until the statement that called the
currently live scope has finished executing.</p>

<p>&quot;SAVEFREEOP(OP *op)&quot; The &quot;OP *&quot; is
op_free()ed at the end of pseudo-block.</p>

<p>SAVEFREEPV(p) The chunk of memory which is pointed to by
&quot;p&quot; is Safefree()ed at the end of
pseudo-block.</p>

<p>&quot;SAVECLEARSV(SV *sv)&quot; Clears a slot in the
current scratchpad which corresponds to &quot;sv&quot; at
the end of pseudo-block.</p>

<p>&quot;SAVEDELETE(HV *hv, char *key, I32 length)&quot;
The key &quot;key&quot; of &quot;hv&quot; is deleted at the
end of pseudo-block. The string pointed to by
&quot;key&quot; is Safefree()ed. If one has a key in
short-lived storage, the corresponding string may be
reallocated like this:</p>

<p>SAVEDELETE(PL_defstash, savepv(tmpbuf),
strlen(tmpbuf));</p>

<p>&quot;SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void
*p)&quot; At the end of pseudo-block the function
&quot;f&quot; is called with the only argument
&quot;p&quot;.</p>

<p>&quot;SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void
*p)&quot; At the end of pseudo-block the function
&quot;f&quot; is called with the implicit context argument
(if any), and &quot;p&quot;.</p>

<p>&quot;SAVESTACK_POS()&quot; The current offset on the
Perl internal stack (cf. &quot;SP&quot;) is restored at the
end of pseudo-block.</p>

<p>The following API list contains functions, thus one
needs to provide pointers to the modifiable data explicitly
(either C pointers, or Perlish &quot;GV *&quot;s). Where the
above macros take &quot;int&quot;, a similar function takes
&quot;int *&quot;.</p>

<p>&quot;SV* save_scalar(GV *gv)&quot; Equivalent to Perl
code &quot;local $gv&quot;.</p>

<p>&quot;AV* save_ary(GV *gv)&quot; &quot;HV* save_hash(GV
*gv)&quot; Similar to &quot;save_scalar&quot;, but localize
@gv and %gv.</p>

<p>&quot;void save_item(SV *item)&quot; Duplicates the
current value of &quot;SV&quot;, on the exit from the
current &quot;ENTER&quot;/&quot;LEAVE&quot; pseudo-block
will restore the value of &quot;SV&quot; using the stored
value. It doesn t handle magic. Use &quot;save_scalar&quot;
if magic is affected.</p>

<p>&quot;void save_list(SV **sarg, I32 maxsarg)&quot; A
variant of &quot;save_item&quot; which takes multiple
arguments via an array &quot;sarg&quot; of &quot;SV*&quot;
of length &quot;maxsarg&quot;.</p>

<p>&quot;SV* save_svref(SV **sptr)&quot; Similar to
&quot;save_scalar&quot;, but will reinstate an &quot;SV
*&quot;.</p>

<p>&quot;void save_aptr(AV **aptr)&quot; &quot;void
save_hptr(HV **hptr)&quot; Similar to
&quot;save_svref&quot;, but localize &quot;AV *&quot; and
&quot;HV *&quot;.</p>

<p>The &quot;Alias&quot; module implements localization of
the basic types within the caller_s scope. People who are
interested in how to localize things in the containing scope
should take a look there too.</p>

<p>Subroutines XSUBs and the Argument Stack The XSUB
mechanism is a simple way for Perl programs to access C
subroutines. An XSUB routine will have a stack that contains
the arguments from the Perl program, and a way to map from
the Perl data structures to a C equivalent.</p>

<p>The stack arguments are accessible through the ST(n)
macro, which returns the &quot;n&quot;th stack argument.
Argument 0 is the first argument passed in the Perl
subroutine call. These arguments are &quot;SV*&quot;, and
can be used anywhere an &quot;SV*&quot; is used.</p>

<p>Most of the time, output from the C routine can be
handled through use of the RETVAL and OUTPUT directives.
However, there are some cases where the argument stack is
not already long enough to handle all the return values. An
example is the POSIX tzname() call, which takes no
arguments, but returns two, the local time zones standard
and summer time abbreviations.</p>

<p>To handle this situation, the PPCODE directive is used
and the stack is extended using the macro:</p>

<p>EXTEND(SP, num);</p>

<p>where &quot;SP&quot; is the macro that represents the
local copy of the stack pointer, and &quot;num&quot; is the
number of elements the stack should be extended by.</p>

<p>Now that there is room on the stack, values can be
pushed on it using &quot;PUSHs&quot; macro. The pushed
values will often need to be &quot;mortal&quot; (See
&quot;Reference Counts and Mortality&quot;):</p>

<p>PUSHs(sv_2mortal(newSViv(an_integer)))
PUSHs(sv_2mortal(newSVuv(an_unsigned_integer)))
PUSHs(sv_2mortal(newSVnv(a_double)))
PUSHs(sv_2mortal(newSVpv(&quot;Some String&quot;,0)))</p>

<p>And now the Perl program calling &quot;tzname&quot;, the
two values will be assigned as in:</p>

<p>($standard_abbrev, $summer_abbrev) = POSIX::tzname;</p>

<p>An alternate (and possibly simpler) method to pushing
values on the stack is to use the macro:</p>

<p>XPUSHs(SV*)</p>

<p>This macro automatically adjust the stack for you, if
needed. Thus, you do not need to call &quot;EXTEND&quot; to
extend the stack.</p>

<p>Despite their suggestions in earlier versions of this
document the macros &quot;(X)PUSH[iunp]&quot; are not suited
to XSUBs which return multiple results. For that, either
stick to the &quot;(X)PUSHs&quot; macros shown above, or use
the new &quot;m(X)PUSH[iunp]&quot; macros instead; see
&quot;Putting a C value on Perl stack&quot;.</p>

<p>For more information, consult perlxs and perlxstut.</p>

<p>Calling Perl Routines from within C Programs There are
four routines that can be used to call a Perl subroutine
from within a C program. These four are:</p>

<p>I32 call_sv(SV*, I32); I32 call_pv(const char*, I32);
I32 call_method(const char*, I32); I32 call_argv(const
char*, I32, register char**);</p>

<p>The routine most often used is &quot;call_sv&quot;. The
&quot;SV*&quot; argument contains either the name of the
Perl subroutine to be called, or a reference to the
subroutine. The second argument consists of flags that
control the context in which the subroutine is called,
whether or not the subroutine is being passed arguments, how
errors should be trapped, and how to treat return
values.</p>

<p>All four routines return the number of arguments that
the subroutine returned on the Perl stack.</p>

<p>These routines used to be called
&quot;perl_call_sv&quot;, etc., before Perl v5.6.0, but
those names are now deprecated; macros of the same name are
provided for compatibility.</p>

<p>When using any of these routines (except
&quot;call_argv&quot;), the programmer must manipulate the
Perl stack. These include the following macros and
functions:</p>

<p>dSP SP PUSHMARK() PUTBACK SPAGAIN ENTER SAVETMPS
FREETMPS LEAVE XPUSH*() POP*()</p>

<p>For a detailed description of calling conventions from C
to Perl, consult perlcall.</p>

<p>Memory Allocation Allocation</p>

<p>All memory meant to be used with the Perl API functions
should be manipulated using the macros described in this
section. The macros provide the necessary transparency
between differences in the actual malloc implementation that
is used within perl.</p>

<p>It is suggested that you enable the version of malloc
that is distributed with Perl. It keeps pools of various
sizes of unallocated memory in order to satisfy allocation
requests more quickly. However, on some platforms, it may
cause spurious malloc or free errors.</p>

<p>The following three macros are used to initially
allocate memory :</p>

<p>Newx(pointer, number, type); Newxc(pointer, number,
type, cast); Newxz(pointer, number, type);</p>

<p>The first argument &quot;pointer&quot; should be the
name of a variable that will point to the newly allocated
memory.</p>

<p>The second and third arguments &quot;number&quot; and
&quot;type&quot; specify how many of the specified type of
data structure should be allocated. The argument
&quot;type&quot; is passed to &quot;sizeof&quot;. The final
argument to &quot;Newxc&quot;, &quot;cast&quot;, should be
used if the &quot;pointer&quot; argument is different from
the &quot;type&quot; argument.</p>

<p>Unlike the &quot;Newx&quot; and &quot;Newxc&quot;
macros, the &quot;Newxz&quot; macro calls
&quot;memzero&quot; to zero out all the newly allocated
memory.</p>

<p>Reallocation</p>

<p>Renew(pointer, number, type); Renewc(pointer, number,
type, cast); Safefree(pointer)</p>

<p>These three macros are used to change a memory buffer
size or to free a piece of memory no longer needed. The
arguments to &quot;Renew&quot; and &quot;Renewc&quot; match
those of &quot;New&quot; and &quot;Newc&quot; with the
exception of not needing the &quot;magic cookie&quot;
argument.</p>

<p>Moving</p>

<p>Move(source, dest, number, type); Copy(source, dest,
number, type); Zero(dest, number, type);</p>

<p>These three macros are used to move, copy, or zero out
previously allocated memory. The &quot;source&quot; and
&quot;dest&quot; arguments point to the source and
destination starting points. Perl will move, copy, or zero
out &quot;number&quot; instances of the size of the
&quot;type&quot; data structure (using the
&quot;sizeof&quot; function).</p>

<p>PerlIO The most recent development releases of Perl has
been experimenting with removing Perls dependency on the
&quot;normal&quot; standard I/O suite and allowing other
stdio implementations to be used. This involves creating a
new abstraction layer that then calls whichever
implementation of stdio Perl was compiled with. All XSUBs
should now use the functions in the PerlIO abstraction layer
and not make any assumptions about what kind of stdio is
being used.</p>

<p>For a complete description of the PerlIO abstraction,
consult perlapio.</p>

<p>Putting a C value on Perl stack A lot of opcodes (this
is an elementary operation in the internal perl stack
machine) put an SV* on the stack. However, as an
optimization the corresponding SV is (usually) not recreated
each time. The opcodes reuse specially assigned SVs
(targets) which are (as a corollary) not constantly
freed/created.</p>

<p>Each of the targets is created only once (but see
&quot;Scratchpads and recursion&quot; below), and when an
opcode needs to put an integer, a double, or a string on
stack, it just sets the corresponding parts of its target
and puts the target on stack.</p>

<p>The macro to put this target on stack is
&quot;PUSHTARG&quot;, and it is directly used in some
opcodes, as well as indirectly in zillions of others, which
use it via &quot;(X)PUSH[iunp]&quot;.</p>

<p>Because the target is reused, you must be careful when
pushing multiple values on the stack. The following code
will not do what you think:</p>

<p>XPUSHi(10); XPUSHi(20);</p>

<p>This translates as &quot;set &quot;TARG&quot; to 10,
push a pointer to &quot;TARG&quot; onto the stack; set
&quot;TARG&quot; to 20, push a pointer to &quot;TARG&quot;
onto the stack&quot;. At the end of the operation, the stack
does not contain the values 10 and 20, but actually contains
two pointers to &quot;TARG&quot;, which we have set to
20.</p>

<p>If you need to push multiple different values then you
should either use the &quot;(X)PUSHs&quot; macros, or else
use the new &quot;m(X)PUSH[iunp]&quot; macros, none of which
make use of &quot;TARG&quot;. The &quot;(X)PUSHs&quot;
macros simply push an SV* on the stack, which, as noted
under &quot;XSUBs and the Argument Stack&quot;, will often
need to be &quot;mortal&quot;. The new
&quot;m(X)PUSH[iunp]&quot; macros make this a little easier
to achieve by creating a new mortal for you (via
&quot;(X)PUSHmortal&quot;), pushing that onto the stack
(extending it if necessary in the case of the
&quot;mXPUSH[iunp]&quot; macros), and then setting its
value. Thus, instead of writing this to &quot;fix&quot; the
example above:</p>

<p>XPUSHs(sv_2mortal(newSViv(10)))
XPUSHs(sv_2mortal(newSViv(20)))</p>

<p>you can simply write:</p>

<p>mXPUSHi(10) mXPUSHi(20)</p>

<p>On a related note, if you do use
&quot;(X)PUSH[iunp]&quot;, then you re going to need a
&quot;dTARG&quot; in your variable declarations so that the
&quot;*PUSH*&quot; macros can make use of the local variable
&quot;TARG&quot;. See also &quot;dTARGET&quot; and
&quot;dXSTARG&quot;.</p>

<p>Scratchpads The question remains on when the SVs which
are targets for opcodes are created. The answer is that they
are created when the current unit -- a subroutine or a file
(for opcodes for statements outside of subroutines) -- is
compiled. During this time a special anonymous Perl array is
created, which is called a scratchpad for the current
unit.</p>

<p>A scratchpad keeps SVs which are lexicals for the
current unit and are targets for opcodes. One can deduce
that an SV lives on a scratchpad by looking on its flags:
lexicals have &quot;SVs_PADMY&quot; set, and targets have
&quot;SVs_PADTMP&quot; set.</p>

<p>The correspondence between OPs and targets is not
1-to-1. Different OPs in the compile tree of the unit can
use the same target, if this would not conflict with the
expected life of the temporary.</p>

<p>Scratchpads and recursion In fact it is not 100% true
that a compiled unit contains a pointer to the scratchpad
AV. In fact it contains a pointer to an AV of (initially)
one element, and this element is the scratchpad AV. Why do
we need an extra level of indirection?</p>

<p>The answer is recursion, and maybe threads. Both these
can create several execution pointers going into the same
subroutine. For the subroutine-child not write over the
temporaries for the subroutine- parent (lifespan of which
covers the call to the child), the parent and the child
should have different scratchpads. (And the lexicals should
be separate anyway!)</p>

<p>So each subroutine is born with an array of scratchpads
(of length 1). On each entry to the subroutine it is checked
that the current depth of the recursion is not more than the
length of this array, and if it is, new scratchpad is
created and pushed into the array.</p>

<p>The targets on this scratchpad are &quot;undef&quot;s,
but they are already marked with correct flags.</p>

<p>Compiled code Code tree Here we describe the internal
form your code is converted to by Perl. Start with a simple
example:</p>

<p>$a = $b + $c;</p>

<p>This is converted to a tree similar to this one:</p>

<p>assign-to / + $a / $b $c</p>

<p>(but slightly more complicated). This tree reflects the
way Perl parsed your code, but has nothing to do with the
execution order. There is an additional &quot;thread&quot;
going through the nodes of the tree which shows the order of
execution of the nodes. In our simplified example above it
looks like:</p>

<p>$b ---&gt; $c ---&gt; + ---&gt; $a ---&gt; assign-to</p>

<p>But with the actual compile tree for &quot;$a = $b +
$c&quot; it is different: some nodes optimized away. As a
corollary, though the actual tree contains more nodes than
our simplified example, the execution order is the same as
in our example.</p>

<p>Examining the tree If you have your perl compiled for
debugging (usually done with &quot;-DDEBUGGING&quot; on the
&quot;Configure&quot; command line), you may examine the
compiled tree by specifying &quot;-Dx&quot; on the Perl
command line. The output takes several lines per node, and
for &quot;$b+$c&quot; it looks like this:</p>

<p>5 TYPE = add ===&gt; 6 TARG = 1 FLAGS = (SCALAR,KIDS) {
TYPE = null ===&gt; (4) (was rv2sv) FLAGS = (SCALAR,KIDS) {
3 TYPE = gvsv ===&gt; 4 FLAGS = (SCALAR) GV = main::b } } {
TYPE = null ===&gt; (5) (was rv2sv) FLAGS = (SCALAR,KIDS) {
4 TYPE = gvsv ===&gt; 5 FLAGS = (SCALAR) GV = main::c }
}</p>

<p>This tree has 5 nodes (one per &quot;TYPE&quot;
specifier), only 3 of them are not optimized away (one per
number in the left column). The immediate children of the
given node correspond to &quot;{}&quot; pairs on the same
level of indentation, thus this listing corresponds to the
tree:</p>

<p>add / null null | | gvsv gvsv</p>

<p>The execution order is indicated by &quot;===&gt;&quot;
marks, thus it is &quot;3 4 5 6&quot; (node 6 is not
included into above listing), i.e., &quot;gvsv gvsv add
whatever&quot;.</p>

<p>Each of these nodes represents an op, a fundamental
operation inside the Perl core. The code which implements
each operation can be found in the pp*.c files; the function
which implements the op with type &quot;gvsv&quot; is
&quot;pp_gvsv&quot;, and so on. As the tree above shows,
different ops have different numbers of children:
&quot;add&quot; is a binary operator, as one would expect,
and so has two children. To accommodate the various
different numbers of children, there are various types of op
data structure, and they link together in different
ways.</p>

<p>The simplest type of op structure is &quot;OP&quot;:
this has no children. Unary operators, &quot;UNOP&quot;s,
have one child, and this is pointed to by the
&quot;op_first&quot; field. Binary operators
(&quot;BINOP&quot;s) have not only an &quot;op_first&quot;
field but also an &quot;op_last&quot; field. The most
complex type of op is a &quot;LISTOP&quot;, which has any
number of children. In this case, the first child is pointed
to by &quot;op_first&quot; and the last child by
&quot;op_last&quot;. The children in between can be found by
iteratively following the &quot;op_sibling&quot; pointer
from the first child to the last.</p>

<p>There are also two other op types: a &quot;PMOP&quot;
holds a regular expression, and has no children, and a
&quot;LOOP&quot; may or may not have children. If the
&quot;op_children&quot; field is non-zero, it behaves like a
&quot;LISTOP&quot;. To complicate matters, if a
&quot;UNOP&quot; is actually a &quot;null&quot; op after
optimization (see &quot;Compile pass 2: context
propagation&quot;) it will still have children in accordance
with its former type.</p>

<p>Another way to examine the tree is to use a compiler
back-end module, such as B::Concise.</p>

<p>Compile pass 1: check routines The tree is created by
the compiler while yacc code feeds it the constructions it
recognizes. Since yacc works bottom-up, so does the first
pass of perl compilation.</p>

<p>What makes this pass interesting for perl developers is
that some optimization may be performed on this pass. This
is optimization by so-called &quot;check routines&quot;. The
correspondence between node names and corresponding check
routines is described in opcode.pl (do not forget to run
&quot;make regen_headers&quot; if you modify this file).</p>

<p>A check routine is called when the node is fully
constructed except for the execution-order thread. Since at
this time there are no back-links to the currently
constructed node, one can do most any operation to the
top-level node, including freeing it and/or creating new
nodes above/below it.</p>

<p>The check routine returns the node which should be
inserted into the tree (if the top-level node was not
modified, check routine returns its argument).</p>

<p>By convention, check routines have names
&quot;ck_*&quot;. They are usually called from
&quot;new*OP&quot; subroutines (or &quot;convert&quot;)
(which in turn are called from perly.y).</p>

<p>Compile pass 1a: constant folding Immediately after the
check routine is called the returned node is checked for
being compile-time executable. If it is (the value is judged
to be constant) it is immediately executed, and a constant
node with the &quot;return value&quot; of the corresponding
subtree is substituted instead. The subtree is deleted.</p>

<p>If constant folding was not performed, the
execution-order thread is created.</p>

<p>Compile pass 2: context propagation When a context for a
part of compile tree is known, it is propagated down through
the tree. At this time the context can have 5 values
(instead of 2 for runtime context): void, boolean, scalar,
list, and lvalue. In contrast with the pass 1 this pass is
processed from top to bottom: a node s context determines
the context for its children.</p>

<p>Additional context-dependent optimizations are performed
at this time. Since at this moment the compile tree contains
back-references (via &quot;thread&quot; pointers), nodes
cannot be free()d now. To allow optimized- away nodes at
this stage, such nodes are null()ified instead of free()ing
(i.e. their type is changed to OP_NULL).</p>

<p>Compile pass 3: peephole optimization After the compile
tree for a subroutine (or for an &quot;eval&quot; or a file)
is created, an additional pass over the code is performed.
This pass is neither top-down or bottom-up, but in the
execution order (with additional complications for
conditionals). These optimizations are done in the
subroutine peep(). Optimizations performed at this stage are
subject to the same restrictions as in the pass 2.</p>

<p>Pluggable runops The compile tree is executed in a
runops function. There are two runops functions, in run.c
and in dump.c. &quot;Perl_runops_debug&quot; is used with
DEBUGGING and &quot;Perl_runops_standard&quot; is used
otherwise. For fine control over the execution of the
compile tree it is possible to provide your own runops
function.</p>

<p>It s probably best to copy one of the existing runops
functions and change it to suit your needs. Then, in the
BOOT section of your XS file, add the line:</p>

<p>PL_runops = my_runops;</p>

<p>This function should be as efficient as possible to keep
your programs running as fast as possible.</p>

<p>Examining internal data structures with the
&quot;dump&quot; functions To aid debugging, the source file
dump.c contains a number of functions which produce
formatted output of internal data structures.</p>

<p>The most commonly used of these functions is
&quot;Perl_sv_dump&quot;; its used for dumping SVs, AVs,
HVs, and CVs. The &quot;Devel::Peek&quot; module calls
&quot;sv_dump&quot; to produce debugging output from
Perl-space, so users of that module should already be
familiar with its format.</p>

<p>&quot;Perl_op_dump&quot; can be used to dump an
&quot;OP&quot; structure or any of its derivatives, and
produces output similar to &quot;perl -Dx&quot;; in fact,
&quot;Perl_dump_eval&quot; will dump the main root of the
code being evaluated, exactly like &quot;-Dx&quot;.</p>

<p>Other useful functions are &quot;Perl_dump_sub&quot;,
which turns a &quot;GV&quot; into an op tree,
&quot;Perl_dump_packsubs&quot; which calls
&quot;Perl_dump_sub&quot; on all the subroutines in a
package like so: (Thankfully, these are all xsubs, so there
is no op tree)</p>

<p>(gdb) print Perl_dump_packsubs(PL_defstash)</p>

<p>SUB attributes::bootstrap = (xsub 0x811fedc 0)</p>

<p>SUB UNIVERSAL::can = (xsub 0x811f50c 0)</p>

<p>SUB UNIVERSAL::isa = (xsub 0x811f304 0)</p>

<p>SUB UNIVERSAL::VERSION = (xsub 0x811f7ac 0)</p>

<p>SUB DynaLoader::boot_DynaLoader = (xsub 0x805b188 0)</p>

<p>and &quot;Perl_dump_all&quot;, which dumps all the
subroutines in the stash and the op tree of the main
root.</p>

<p>How multiple interpreters and concurrency are supported
Background and PERL_IMPLICIT_CONTEXT The Perl interpreter
can be regarded as a closed box: it has an API for feeding
it code or otherwise making it do things, but it also has
functions for its own use. This smells a lot like an object,
and there are ways for you to build Perl so that you can
have multiple interpreters, with one interpreter represented
either as a C structure, or inside a thread-specific
structure. These structures contain all the context, the
state of that interpreter.</p>

<p>One macro controls the major Perl build flavor:
MULTIPLICITY. The MULTIPLICITY build has a C structure that
packages all the interpreter state. With
multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also
normally defined, and enables the support for passing in a
&quot;hidden&quot; first argument that represents all three
data structures. MULTIPLICITY makes mutli-threaded perls
possible (with the ithreads threading model, related to the
macro USE_ITHREADS.)</p>

<p>Two other &quot;encapsulation&quot; macros are the
PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the
latter turns on the former, and the former turns on
MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the
internal variables of Perl to be wrapped inside a single
global struct, struct perl_vars, accessible as (globals)
&amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars().
The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there
is still a single struct (allocated in main() either from
heap or from stack) but there are no global data symbols
pointing to it. In either case the global struct should be
initialised as the very first thing in main() using
Perl_init_global_struct() and correspondingly tear it down
after perl_free() using Perl_free_global_struct(), please
see miniperlmain.c for usage details. You may also need to
use &quot;dVAR&quot; in your coding to &quot;declare the
global variables&quot; when you are using them. dTHX does
this for you automatically.</p>

<p>To see whether you have non-const data you can use a
BSD-compatible &quot;nm&quot;:</p>

<p>nm libperl.a | grep -v &rsquo; [TURtr] &rsquo;</p>

<p>If this displays any &quot;D&quot; or &quot;d&quot;
symbols, you have non-const data.</p>

<p>For backward compatibility reasons defining just
PERL_GLOBAL_STRUCT doesnt actually hide all symbols inside a
big global struct: some PerlIO_xxx vtables are left visible.
The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see
how the PERLIO_FUNCS_DECL is used).</p>

<p>All this obviously requires a way for the Perl internal
functions to be either subroutines taking some kind of
structure as the first argument, or subroutines taking
nothing as the first argument. To enable these two very
different ways of building the interpreter, the Perl source
(as it does in so many other situations) makes heavy use of
macros and subroutine naming conventions.</p>

<p>First problem: deciding which functions will be public
API functions and which will be private. All functions whose
names begin &quot;S_&quot; are private (think &quot;S&quot;
for &quot;secret&quot; or &quot;static&quot;). All other
functions begin with &quot;Perl_&quot;, but just because a
function begins with &quot;Perl_&quot; does not mean it is
part of the API. (See &quot;Internal Functions&quot;.) The
easiest way to be sure a function is part of the API is to
find its entry in perlapi. If it exists in perlapi, it s
part of the API. If it doesn t, and you think it should be
(i.e., you need it for your extension), send mail via
perlbug explaining why you think it should be.</p>

<p>Second problem: there must be a syntax so that the same
subroutine declarations and calls can pass a structure as
their first argument, or pass nothing. To solve this, the
subroutines are named and declared in a particular way.
Heres a typical start of a static function used within the
Perl guts:</p>

<p>STATIC void S_incline(pTHX_ char *s)</p>

<p>STATIC becomes &quot;static&quot; in C, and may be
#defined to nothing in some configurations in future.</p>

<p>A public function (i.e. part of the internal API, but
not necessarily sanctioned for use in extensions) begins
like this:</p>

<p>void Perl_sv_setiv(pTHX_ SV* dsv, IV num)</p>

<p>&quot;pTHX_&quot; is one of a number of macros (in
perl.h) that hide the details of the interpreters context.
THX stands for &quot;thread&quot;, &quot;this&quot;, or
&quot;thingy&quot;, as the case may be. (And no, George
Lucas is not involved. :-) The first character could be p
for a prototype, a for argument, or d for declaration, so we
have &quot;pTHX&quot;, &quot;aTHX&quot; and
&quot;dTHX&quot;, and their variants.</p>

<p>When Perl is built without options that set
PERL_IMPLICIT_CONTEXT, there is no first argument containing
the interpreters context. The trailing underscore in the
pTHX_ macro indicates that the macro expansion needs a comma
after the context argument because other arguments follow
it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be
ignored, and the subroutine is not prototyped to take the
extra argument. The form of the macro without the trailing
underscore is used when there are no additional explicit
arguments.</p>

<p>When a core function calls another, it must pass the
context. This is normally hidden via macros. Consider
&quot;sv_setiv&quot;. It expands into something like
this:</p>

<p>#ifdef PERL_IMPLICIT_CONTEXT #define sv_setiv(a,b)
Perl_sv_setiv(aTHX_ a, b) /* can&rsquo;t do this for vararg
functions, see below */ #else #define sv_setiv Perl_sv_setiv
#endif</p>

<p>This works well, and means that XS authors can gleefully
write:</p>

<p>sv_setiv(foo, bar);</p>

<p>and still have it work under all the modes Perl could
have been compiled with.</p>

<p>This doesnt work so cleanly for varargs functions,
though, as macros imply that the number of arguments is
known in advance. Instead we either need to spell them out
fully, passing &quot;aTHX_&quot; as the first argument (the
Perl core tends to do this with functions like Perl_warner),
or use a context-free version.</p>

<p>The context-free version of Perl_warner is called
Perl_warner_nocontext, and does not take the extra argument.
Instead it does dTHX; to get the context from thread-local
storage. We &quot;#define warner Perl_warner_nocontext&quot;
so that extensions get source compatibility at the expense
of performance. (Passing an arg is cheaper than grabbing it
from thread-local storage.)</p>

<p>You can ignore [pad]THXx when browsing the Perl
headers/sources. Those are strictly for use within the core.
Extensions and embedders need only be aware of [pad]THX.</p>

<p>So what happened to dTHR? &quot;dTHR&quot; was
introduced in perl 5.005 to support the older thread model.
The older thread model now uses the &quot;THX&quot;
mechanism to pass context pointers around, so
&quot;dTHR&quot; is not useful any more. Perl 5.6.0 and
later still have it for backward source compatibility, but
it is defined to be a no-op.</p>

<p>How do I use all this in extensions? When Perl is built
with PERL_IMPLICIT_CONTEXT, extensions that call any
functions in the Perl API will need to pass the initial
context argument somehow. The kicker is that you will need
to write it in such a way that the extension still compiles
when Perl hasnt been built with PERL_IMPLICIT_CONTEXT
enabled.</p>

<p>There are three ways to do this. First, the easy but
inefficient way, which is also the default, in order to
maintain source compatibility with extensions: whenever
XSUB.h is #included, it redefines the aTHX and aTHX_ macros
to call a function that will return the context. Thus,
something like:</p>

<p>sv_setiv(sv, num);</p>

<p>in your extension will translate to this when
PERL_IMPLICIT_CONTEXT is in effect:</p>

<p>Perl_sv_setiv(Perl_get_context(), sv, num);</p>

<p>or to this otherwise:</p>

<p>Perl_sv_setiv(sv, num);</p>

<p>You have to do nothing new in your extension to get
this; since the Perl library provides Perl_get_context(), it
will all just work.</p>

<p>The second, more efficient way is to use the following
template for your Foo.xs:</p>

<p>#define PERL_NO_GET_CONTEXT /* we want efficiency */
#include &quot;EXTERN.h&quot; #include &quot;perl.h&quot;
#include &quot;XSUB.h&quot;</p>

<p>STATIC void my_private_function(int arg1, int arg2);</p>

<p>STATIC void my_private_function(int arg1, int arg2) {
dTHX; /* fetch context */ ... call many Perl API functions
... }</p>

<p>[... etc ...]</p>

<p>MODULE = Foo PACKAGE = Foo</p>

<p>/* typical XSUB */</p>

<p>void my_xsub(arg) int arg CODE: my_private_function(arg,
10);</p>

<p>Note that the only two changes from the normal way of
writing an extension is the addition of a &quot;#define
PERL_NO_GET_CONTEXT&quot; before including the Perl headers,
followed by a &quot;dTHX;&quot; declaration at the start of
every function that will call the Perl API. (You ll know
which functions need this, because the C compiler will
complain that there s an undeclared identifier in those
functions.) No changes are needed for the XSUBs themselves,
because the XS() macro is correctly defined to pass in the
implicit context if needed.</p>

<p>The third, even more efficient way is to ape how it is
done within the Perl guts:</p>

<p>#define PERL_NO_GET_CONTEXT /* we want efficiency */
#include &quot;EXTERN.h&quot; #include &quot;perl.h&quot;
#include &quot;XSUB.h&quot;</p>

<p>/* pTHX_ only needed for functions that call Perl API */
STATIC void my_private_function(pTHX_ int arg1, int
arg2);</p>

<p>STATIC void my_private_function(pTHX_ int arg1, int
arg2) { /* dTHX; not needed here, because THX is an argument
*/ ... call Perl API functions ... }</p>

<p>[... etc ...]</p>

<p>MODULE = Foo PACKAGE = Foo</p>

<p>/* typical XSUB */</p>

<p>void my_xsub(arg) int arg CODE:
my_private_function(aTHX_ arg, 10);</p>

<p>This implementation never has to fetch the context using
a function call, since it is always passed as an extra
argument. Depending on your needs for simplicity or
efficiency, you may mix the previous two approaches
freely.</p>

<p>Never add a comma after &quot;pTHX&quot;
yourself--always use the form of the macro with the
underscore for functions that take explicit arguments, or
the form without the argument for functions with no explicit
arguments.</p>

<p>If one is compiling Perl with the
&quot;-DPERL_GLOBAL_STRUCT&quot; the &quot;dVAR&quot;
definition is needed if the Perl global variables (see
perlvars.h or globvar.sym) are accessed in the function and
&quot;dTHX&quot; is not used (the &quot;dTHX&quot; includes
the &quot;dVAR&quot; if necessary). One notices the need for
&quot;dVAR&quot; only with the said compile-time define,
because otherwise the Perl global variables are visible
as-is.</p>

<p>Should I do anything special if I call perl from
multiple threads? If you create interpreters in one thread
and then proceed to call them in another, you need to make
sure perls own Thread Local Storage (TLS) slot is
initialized correctly in each of those threads.</p>

<p>The &quot;perl_alloc&quot; and &quot;perl_clone&quot;
API functions will automatically set the TLS slot to the
interpreter they created, so that there is no need to do
anything special if the interpreter is always accessed in
the same thread that created it, and that thread did not
create or call any other interpreters afterwards. If that is
not the case, you have to set the TLS slot of the thread
before calling any functions in the Perl API on that
particular interpreter. This is done by calling the
&quot;PERL_SET_CONTEXT&quot; macro in that thread as the
first thing you do:</p>

<p>/* do this before doing anything else with some_perl */
PERL_SET_CONTEXT(some_perl);</p>

<p>... other Perl API calls on some_perl go here ...</p>

<p>Future Plans and PERL_IMPLICIT_SYS Just as
PERL_IMPLICIT_CONTEXT provides a way to bundle up everything
that the interpreter knows about itself and pass it around,
so too are there plans to allow the interpreter to bundle up
everything it knows about the environment it s running on.
This is enabled with the PERL_IMPLICIT_SYS macro. Currently
it only works with USE_ITHREADS on Windows.</p>

<p>This allows the ability to provide an extra pointer
(called the &quot;host&quot; environment) for all the system
calls. This makes it possible for all the system stuff to
maintain their own state, broken down into seven C
structures. These are thin wrappers around the usual system
calls (see win32/perllib.c) for the default perl executable,
but for a more ambitious host (like the one that would do
fork() emulation) all the extra work needed to pretend that
different interpreters are actually different
&quot;processes&quot;, would be done here.</p>

<p>The Perl engine/interpreter and the host are orthogonal
entities. There could be one or more interpreters in a
process, and one or more &quot;hosts&quot;, with free
association between them.</p>

<p>Internal Functions All of Perls internal functions which
will be exposed to the outside world are prefixed by
&quot;Perl_&quot; so that they will not conflict with XS
functions or functions used in a program in which Perl is
embedded. Similarly, all global variables begin with
&quot;PL_&quot;. (By convention, static functions start with
&quot;S_&quot;.)</p>

<p>Inside the Perl core, you can get at the functions
either with or without the &quot;Perl_&quot; prefix, thanks
to a bunch of defines that live in embed.h. This header file
is generated automatically from embed.pl and embed.fnc.
embed.pl also creates the prototyping header files for the
internal functions, generates the documentation and a lot of
other bits and pieces. Its important that when you add a new
function to the core or change an existing one, you change
the data in the table in embed.fnc as well. Heres a sample
entry from that table:</p>

<p>Apd |SV** |av_fetch |AV* ar|I32 key|I32 lval</p>

<p>The second column is the return type, the third column
the name. Columns after that are the arguments. The first
column is a set of flags:</p>

<p>A This function is a part of the public API. All such
functions should also have d, very few do not.</p>

<p>p This function has a &quot;Perl_&quot; prefix; i.e. it
is defined as &quot;Perl_av_fetch&quot;.</p>

<p>d This function has documentation using the
&quot;apidoc&quot; feature which well look at in a second.
Some functions have d but not A; docs are good.</p>

<p>Other available flags are:</p>

<p>s This is a static function and is defined as
&quot;STATIC S_whatever&quot;, and usually called within the
sources as &quot;whatever(...)&quot;.</p>

<p>n This does not need a interpreter context, so the
definition has no &quot;pTHX&quot;, and it follows that
callers dont use &quot;aTHX&quot;. (See &quot;Background and
PERL_IMPLICIT_CONTEXT&quot; in perlguts.)</p>

<p>r This function never returns; &quot;croak&quot;,
&quot;exit&quot; and friends.</p>

<p>f This function takes a variable number of arguments,
&quot;printf&quot; style. The argument list should end with
&quot;...&quot;, like this:</p>

<p>Afprd |void |croak |const char* pat|...</p>

<p>M This function is part of the experimental development
API, and may change or disappear without notice.</p>

<p>o This function should not have a compatibility macro to
define, say, &quot;Perl_parse&quot; to &quot;parse&quot;. It
must be called as &quot;Perl_parse&quot;.</p>

<p>x This function isnt exported out of the Perl core.</p>

<p>m This is implemented as a macro.</p>

<p>X This function is explicitly exported.</p>

<p>E This function is visible to extensions included in the
Perl core.</p>

<p>b Binary backward compatibility; this function is a
macro but also has a &quot;Perl_&quot; implementation (which
is exported).</p>

<p>others See the comments at the top of
&quot;embed.fnc&quot; for others.</p>

<p>If you edit embed.pl or embed.fnc, you will need to run
&quot;make regen_headers&quot; to force a rebuild of embed.h
and other auto-generated files.</p>

<p>Formatted Printing of IVs, UVs, and NVs If you are
printing IVs, UVs, or NVS instead of the stdio(3) style
formatting codes like %d, %ld, %f, you should use the
following macros for portability</p>

<p>IVdf IV in decimal UVuf UV in decimal UVof UV in octal
UVxf UV in hexadecimal NVef NV %e-like NVff NV %f-like NVgf
NV %g-like</p>

<p>These will take care of 64-bit integers and long
doubles. For example:</p>

<p>printf(&quot;IV is %&quot;IVdf&quot;0, iv);</p>

<p>The IVdf will expand to whatever is the correct format
for the IVs.</p>

<p>If you are printing addresses of pointers, use UVxf
combined with PTR2UV(), do not use %lx or %p.</p>

<p>Pointer-To-Integer and Integer-To-Pointer Because
pointer size does not necessarily equal integer size, use
the follow macros to do it right.</p>

<p>PTR2UV(pointer) PTR2IV(pointer) PTR2NV(pointer)
INT2PTR(pointertotype, integer)</p>

<p>For example:</p>

<p>IV iv = ...; SV *sv = INT2PTR(SV*, iv);</p>

<p>and</p>

<p>AV *av = ...; UV uv = PTR2UV(av);</p>

<p>Exception Handling There are a couple of macros to do
very basic exception handling in XS modules. You have to
define &quot;NO_XSLOCKS&quot; before including XSUB.h to be
able to use these macros:</p>

<p>#define NO_XSLOCKS #include &quot;XSUB.h&quot;</p>

<p>You can use these macros if you call code that may
croak, but you need to do some cleanup before giving control
back to Perl. For example:</p>

<p>dXCPT; /* set up necessary variables */</p>

<p>XCPT_TRY_START { code_that_may_croak(); }
XCPT_TRY_END</p>

<p>XCPT_CATCH { /* do cleanup here */ XCPT_RETHROW; }</p>

<p>Note that you always have to rethrow an exception that
has been caught. Using these macros, it is not possible to
just catch the exception and ignore it. If you have to
ignore the exception, you have to use the &quot;call_*&quot;
function.</p>

<p>The advantage of using the above macros is that you don
t have to setup an extra function for &quot;call_*&quot;,
and that using these macros is faster than using
&quot;call_*&quot;.</p>

<p>Source Documentation Theres an effort going on to
document the internal functions and automatically produce
reference manuals from them - perlapi is one such manual
which details all the functions which are available to XS
writers. perlintern is the autogenerated manual for the
functions which are not part of the API and are supposedly
for internal use only.</p>

<p>Source documentation is created by putting POD comments
into the C source, like this:</p>

<p>/* =for apidoc sv_setiv</p>

<p>Copies an integer into the given SV. Does not handle
&rsquo;set&rsquo; magic. See C&lt;sv_setiv_mg&gt;.</p>

<p>=cut */</p>

<p>Please try and supply some documentation if you add
functions to the Perl core.</p>

<p>Backwards compatibility The Perl API changes over time.
New functions are added or the interfaces of existing
functions are changed. The &quot;Devel::PPPort&quot; module
tries to provide compatibility code for some of these
changes, so XS writers don t have to code it themselves when
supporting multiple versions of Perl.</p>

<p>&quot;Devel::PPPort&quot; generates a C header file
ppport.h that can also be run as a Perl script. To generate
ppport.h, run:</p>

<p>perl -MDevel::PPPort -eDevel::PPPort::WriteFile</p>

<p>Besides checking existing XS code, the script can also
be used to retrieve compatibility information for various
API calls using the &quot;--api-info&quot; command line
switch. For example:</p>

<p>% perl ppport.h --api-info=sv_magicext</p>

<p>For details, see &quot;perldoc ppport.h&quot;.</p>

<p>Unicode Support Perl 5.6.0 introduced Unicode support.
Its important for porters and XS writers to understand this
support and make sure that the code they write does not
corrupt Unicode data.</p>

<p>What is Unicode, anyway? In the olden, less enlightened
times, we all used to use ASCII. Most of us did, anyway. The
big problem with ASCII is that it s American. Well, no,
thats not actually the problem; the problem is that it s not
particularly useful for people who don t use the Roman
alphabet. What used to happen was that particular languages
would stick their own alphabet in the upper range of the
sequence, between 128 and 255. Of course, we then ended up
with plenty of variants that werent quite ASCII, and the
whole point of it being a standard was lost.</p>

<p>Worse still, if you ve got a language like Chinese or
Japanese that has hundreds or thousands of characters, then
you really can t fit them into a mere 256, so they had to
forget about ASCII altogether, and build their own systems
using pairs of numbers to refer to one character.</p>

<p>To fix this, some people formed Unicode, Inc. and
produced a new character set containing all the characters
you can possibly think of and more. There are several ways
of representing these characters, and the one Perl uses is
called UTF-8. UTF-8 uses a variable number of bytes to
represent a character. You can learn more about Unicode and
Perls Unicode model in perlunicode.</p>

<p>How can I recognise a UTF-8 string? You cant. This is
because UTF-8 data is stored in bytes just like non-UTF-8
data. The Unicode character 200, (0xC8 for you hex types)
capital E with a grave accent, is represented by the two
bytes &quot;v196.172&quot;. Unfortunately, the non-Unicode
string &quot;chr(196).chr(172)&quot; has that byte sequence
as well. So you cant tell just by looking - this is what
makes Unicode input an interesting problem.</p>

<p>In general, you either have to know what youre dealing
with, or you have to guess. The API function
&quot;is_utf8_string&quot; can help; itll tell you if a
string contains only valid UTF-8 characters. However, it
cant do the work for you. On a character-by-character basis,
&quot;is_utf8_char&quot; will tell you whether the current
character in a string is valid UTF-8.</p>

<p>How does UTF-8 represent Unicode characters? As
mentioned above, UTF-8 uses a variable number of bytes to
store a character. Characters with values 0...127 are stored
in one byte, just like good ol ASCII. Character 128 is
stored as &quot;v194.128&quot;; this continues up to
character 191, which is &quot;v194.191&quot;. Now we ve run
out of bits (191 is binary 10111111) so we move on; 192 is
&quot;v195.128&quot;. And so it goes on, moving to three
bytes at character 2048.</p>

<p>Assuming you know youre dealing with a UTF-8 string, you
can find out how long the first character in it is with the
&quot;UTF8SKIP&quot; macro:</p>

<p>char *utf = &quot;305233340240201&quot;; I32 len;</p>

<p>len = UTF8SKIP(utf); /* len is 2 here */ utf += len; len
= UTF8SKIP(utf); /* len is 3 here */</p>

<p>Another way to skip over characters in a UTF-8 string is
to use &quot;utf8_hop&quot;, which takes a string and a
number of characters to skip over. Youre on your own about
bounds checking, though, so dont use it lightly.</p>

<p>All bytes in a multi-byte UTF-8 character will have the
high bit set, so you can test if you need to do something
special with this character like this (the
UTF8_IS_INVARIANT() is a macro that tests whether the byte
can be encoded as a single byte even in UTF-8):</p>

<p>U8 *utf; UV uv; /* Note: a UV, not a U8, not a char
*/</p>

<p>if (!UTF8_IS_INVARIANT(*utf)) /* Must treat this as
UTF-8 */ uv = utf8_to_uv(utf); else /* OK to treat this
character as a byte */ uv = *utf;</p>

<p>You can also see in that example that we use
&quot;utf8_to_uv&quot; to get the value of the character;
the inverse function &quot;uv_to_utf8&quot; is available for
putting a UV into UTF-8:</p>

<p>if (!UTF8_IS_INVARIANT(uv)) /* Must treat this as UTF8
*/ utf8 = uv_to_utf8(utf8, uv); else /* OK to treat this
character as a byte */ *utf8++ = uv;</p>

<p>You must convert characters to UVs using the above
functions if youre ever in a situation where you have to
match UTF-8 and non-UTF-8 characters. You may not skip over
UTF-8 characters in this case. If you do this, youll lose
the ability to match hi-bit non-UTF-8 characters; for
instance, if your UTF-8 string contains
&quot;v196.172&quot;, and you skip that character, you can
never match a &quot;chr(200)&quot; in a non-UTF-8 string. So
dont do that!</p>

<p>How does Perl store UTF-8 strings? Currently, Perl deals
with Unicode strings and non-Unicode strings slightly
differently. A flag in the SV, &quot;SVf_UTF8&quot;,
indicates that the string is internally encoded as UTF-8.
Without it, the byte value is the codepoint number and vice
versa (in other words, the string is encoded as iso-8859-1).
You can check and manipulate this flag with the following
macros:</p>

<p>SvUTF8(sv) SvUTF8_on(sv) SvUTF8_off(sv)</p>

<p>This flag has an important effect on Perl s treatment of
the string: if Unicode data is not properly distinguished,
regular expressions, &quot;length&quot;, &quot;substr&quot;
and other string handling operations will have undesirable
results.</p>

<p>The problem comes when you have, for instance, a string
that isnt flagged as UTF-8, and contains a byte sequence
that could be UTF-8 - especially when combining non-UTF-8
and UTF-8 strings.</p>

<p>Never forget that the &quot;SVf_UTF8&quot; flag is
separate to the PV value; you need be sure you dont
accidentally knock it off while you re manipulating SVs.
More specifically, you cannot expect to do this:</p>

<p>SV *sv; SV *nsv; STRLEN len; char *p;</p>

<p>p = SvPV(sv, len); frobnicate(p); nsv = newSVpvn(p,
len);</p>

<p>The &quot;char*&quot; string does not tell you the whole
story, and you cant copy or reconstruct an SV just by
copying the string value. Check if the old SV has the UTF8
flag set, and act accordingly:</p>

<p>p = SvPV(sv, len); frobnicate(p); nsv = newSVpvn(p,
len); if (SvUTF8(sv)) SvUTF8_on(nsv);</p>

<p>In fact, your &quot;frobnicate&quot; function should be
made aware of whether or not its dealing with UTF-8 data, so
that it can handle the string appropriately.</p>

<p>Since just passing an SV to an XS function and copying
the data of the SV is not enough to copy the UTF8 flags,
even less right is just passing a &quot;char *&quot; to an
XS function.</p>

<p>How do I convert a string to UTF-8? If you re mixing
UTF-8 and non-UTF-8 strings, it is necessary to upgrade one
of the strings to UTF-8. If youve got an SV, the easiest way
to do this is:</p>

<p>sv_utf8_upgrade(sv);</p>

<p>However, you must not do this, for example:</p>

<p>if (!SvUTF8(left)) sv_utf8_upgrade(left);</p>

<p>If you do this in a binary operator, you will actually
change one of the strings that came into the operator, and,
while it shouldnt be noticeable by the end user, it can
cause problems in deficient code.</p>

<p>Instead, &quot;bytes_to_utf8&quot; will give you a
UTF-8-encoded copy of its string argument. This is useful
for having the data available for comparisons and so on,
without harming the original SV. Theres also
&quot;utf8_to_bytes&quot; to go the other way, but
naturally, this will fail if the string contains any
characters above 255 that cant be represented in a single
byte.</p>

<p>Is there anything else I need to know? Not really. Just
remember these things:</p>

<p>&middot; Theres no way to tell if a string is UTF-8 or
not. You can tell if an SV is UTF-8 by looking at is
&quot;SvUTF8&quot; flag. Dont forget to set the flag if
something should be UTF-8. Treat the flag as part of the PV,
even though it s not - if you pass on the PV to somewhere,
pass on the flag too.</p>

<p>&middot; If a string is UTF-8, always use
&quot;utf8_to_uv&quot; to get at the value, unless
&quot;UTF8_IS_INVARIANT(*s)&quot; in which case you can use
*s.</p>

<p>&middot; When writing a character &quot;uv&quot; to a
UTF-8 string, always use &quot;uv_to_utf8&quot;, unless
&quot;UTF8_IS_INVARIANT(uv))&quot; in which case you can use
&quot;*s = uv&quot;.</p>

<p>&middot; Mixing UTF-8 and non-UTF-8 strings is tricky.
Use &quot;bytes_to_utf8&quot; to get a new string which is
UTF-8 encoded, and then combine them.</p>

<p>Custom Operators Custom operator support is a new
experimental feature that allows you to define your own ops.
This is primarily to allow the building of interpreters for
other languages in the Perl core, but it also allows
optimizations through the creation of &quot;macro-ops&quot;
(ops which perform the functions of multiple ops which are
usually executed together, such as &quot;gvsv, gvsv,
add&quot;.)</p>

<p>This feature is implemented as a new op type,
&quot;OP_CUSTOM&quot;. The Perl core does not
&quot;know&quot; anything special about this op type, and so
it will not be involved in any optimizations. This also
means that you can define your custom ops to be any op
structure - unary, binary, list and so on - you like.</p>

<p>It s important to know what custom operators wont do for
you. They wont let you add new syntax to Perl, directly.
They won t even let you add new keywords, directly. In fact,
they wont change the way Perl compiles a program at all. You
have to do those changes yourself, after Perl has compiled
the program. You do this either by manipulating the op tree
using a &quot;CHECK&quot; block and the
&quot;B::Generate&quot; module, or by adding a custom
peephole optimizer with the &quot;optimize&quot; module.</p>

<p>When you do this, you replace ordinary Perl ops with
custom ops by creating ops with the type
&quot;OP_CUSTOM&quot; and the &quot;pp_addr&quot; of your
own PP function. This should be defined in XS code, and
should look like the PP ops in &quot;pp_*.c&quot;. You are
responsible for ensuring that your op takes the appropriate
number of values from the stack, and you are responsible for
adding stack marks if necessary.</p>

<p>You should also &quot;register&quot; your op with the
Perl interpreter so that it can produce sensible error and
warning messages. Since it is possible to have multiple
custom ops within the one &quot;logical&quot; op type
&quot;OP_CUSTOM&quot;, Perl uses the value of
&quot;o-&gt;op_ppaddr&quot; as a key into the
&quot;PL_custom_op_descs&quot; and
&quot;PL_custom_op_names&quot; hashes. This means you need
to enter a name and description for your op at the
appropriate place in the &quot;PL_custom_op_names&quot; and
&quot;PL_custom_op_descs&quot; hashes.</p>

<p>Forthcoming versions of &quot;B::Generate&quot; (version
1.0 and above) should directly support the creation of
custom ops by name.</p>

<p>AUTHORS Until May 1997, this document was maintained by
Jeff Okamoto &lt;okamoto@corp.hp.com&gt;. It is now
maintained as part of Perl itself by the Perl 5 Porters
&lt;perl5-porters@perl.org&gt;.</p>

<p>With lots of help and suggestions from Dean Roehrich,
Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya
Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim
Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant,
and Gurusamy Sarathy.</p>

<p>SEE ALSO perlapi(1), perlintern(1), perlxs(1),
perlembed(1)</p>

<p>perl v5.10.1 2009-05-10 PERLGUTS(1)</p>
<hr>
</body>
</html>
