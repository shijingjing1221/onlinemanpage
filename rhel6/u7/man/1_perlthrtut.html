<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:24 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLTHRTUT(1) Perl Programmers Reference Guide
PERLTHRTUT(1)</p>

<p>NAME perlthrtut - Tutorial on threads in Perl</p>

<p>DESCRIPTION This tutorial describes the use of Perl
interpreter threads (sometimes referred to as ithreads) that
was first introduced in Perl 5.6.0. In this model, each
thread runs in its own Perl interpreter, and any data
sharing between threads must be explicit. The user-level
interface for ithreads uses the threads class.</p>

<p>NOTE: There was another older Perl threading flavor
called the 5.005 model that used the Threads class. This old
model was known to have problems, is deprecated, and was
removed for release 5.10. You are strongly encouraged to
migrate any existing 5.005 threads code to the new model as
soon as possible.</p>

<p>You can see which (or neither) threading flavour you
have by running &quot;perl -V&quot; and looking at the
&quot;Platform&quot; section. If you have
&quot;useithreads=define&quot; you have ithreads, if you
have &quot;use5005threads=define&quot; you have 5.005
threads. If you have neither, you don t have any thread
support built in. If you have both, you are in trouble.</p>

<p>The threads and threads::shared modules are included in
the core Perl distribution. Additionally, they are
maintained as a separate modules on CPAN, so you can check
there for any updates.</p>

<p>What Is A Thread Anyway? A thread is a flow of control
through a program with a single execution point.</p>

<p>Sounds an awful lot like a process, doesnt it? Well, it
should. Threads are one of the pieces of a process. Every
process has at least one thread and, up until now, every
process running Perl had only one thread. With 5.8, though,
you can create extra threads. Were going to show you how,
when, and why.</p>

<p>Threaded Program Models There are three basic ways that
you can structure a threaded program. Which model you choose
depends on what you need your program to do. For many
non-trivial threaded programs, youll need to choose
different models for different pieces of your program.</p>

<p>Boss/Worker The boss/worker model usually has one boss
thread and one or more worker threads. The boss thread
gathers or generates tasks that need to be done, then
parcels those tasks out to the appropriate worker
thread.</p>

<p>This model is common in GUI and server programs, where a
main thread waits for some event and then passes that event
to the appropriate worker threads for processing. Once the
event has been passed on, the boss thread goes back to
waiting for another event.</p>

<p>The boss thread does relatively little work. While tasks
arent necessarily performed faster than with any other
method, it tends to have the best user-response times.</p>

<p>Work Crew In the work crew model, several threads are
created that do essentially the same thing to different
pieces of data. It closely mirrors classical parallel
processing and vector processors, where a large array of
processors do the exact same thing to many pieces of
data.</p>

<p>This model is particularly useful if the system running
the program will distribute multiple threads across
different processors. It can also be useful in ray tracing
or rendering engines, where the individual threads can pass
on interim results to give the user visual feedback.</p>

<p>Pipeline The pipeline model divides up a task into a
series of steps, and passes the results of one step on to
the thread processing the next. Each thread does one thing
to each piece of data and passes the results to the next
thread in line.</p>

<p>This model makes the most sense if you have multiple
processors so two or more threads will be executing in
parallel, though it can often make sense in other contexts
as well. It tends to keep the individual tasks small and
simple, as well as allowing some parts of the pipeline to
block (on I/O or system calls, for example) while other
parts keep going. If youre running different parts of the
pipeline on different processors you may also take advantage
of the caches on each processor.</p>

<p>This model is also handy for a form of recursive
programming where, rather than having a subroutine call
itself, it instead creates another thread. Prime and
Fibonacci generators both map well to this form of the
pipeline model. (A version of a prime number generator is
presented later on.)</p>

<p>What kind of threads are Perl threads? If you have
experience with other thread implementations, you might find
that things arent quite what you expect. Its very important
to remember when dealing with Perl threads that Perl Threads
Are Not X Threads for all values of X. They arent POSIX
threads, or DecThreads, or Javas Green threads, or Win32
threads. There are similarities, and the broad concepts are
the same, but if you start looking for implementation
details you re going to be either disappointed or confused.
Possibly both.</p>

<p>This is not to say that Perl threads are completely
different from everything thats ever come before -- theyre
not. Perl s threading model owes a lot to other thread
models, especially POSIX. Just as Perl is not C, though,
Perl threads are not POSIX threads. So if you find yourself
looking for mutexes, or thread priorities, its time to step
back a bit and think about what you want to do and how Perl
can do it.</p>

<p>However, it is important to remember that Perl threads
cannot magically do things unless your operating systems
threads allow it. So if your system blocks the entire
process on &quot;sleep()&quot;, Perl usually will, as
well.</p>

<p>Perl Threads Are Different.</p>

<p>Thread-Safe Modules The addition of threads has changed
Perl s internals substantially. There are implications for
people who write modules with XS code or external libraries.
However, since Perl data is not shared among threads by
default, Perl modules stand a high chance of being thread-
safe or can be made thread-safe easily. Modules that are not
tagged as thread-safe should be tested or code reviewed
before being used in production code.</p>

<p>Not all modules that you might use are thread-safe, and
you should always assume a module is unsafe unless the
documentation says otherwise. This includes modules that are
distributed as part of the core. Threads are a relatively
new feature, and even some of the standard modules arent
thread-safe.</p>

<p>Even if a module is thread-safe, it doesnt mean that the
module is optimized to work well with threads. A module
could possibly be rewritten to utilize the new features in
threaded Perl to increase performance in a threaded
environment.</p>

<p>If you re using a module thats not thread-safe for some
reason, you can protect yourself by using it from one, and
only one thread at all. If you need multiple threads to
access such a module, you can use semaphores and lots of
programming discipline to control access to it. Semaphores
are covered in &quot;Basic semaphores&quot;.</p>

<p>See also &quot;Thread-Safety of System
Libraries&quot;.</p>

<p>Thread Basics The threads module provides the basic
functions you need to write threaded programs. In the
following sections, well cover the basics, showing you what
you need to do to create a threaded program. After that,
well go over some of the features of the threads module that
make threaded programming easier.</p>

<p>Basic Thread Support Thread support is a Perl
compile-time option -- its something thats turned on or off
when Perl is built at your site, rather than when your
programs are compiled. If your Perl wasnt compiled with
thread support enabled, then any attempt to use threads will
fail.</p>

<p>Your programs can use the Config module to check whether
threads are enabled. If your program cant run without them,
you can say something like:</p>

<p>use Config; $Config{useithreads} or die(&rsquo;Recompile
Perl with threads to run this program.&rsquo;);</p>

<p>A possibly-threaded program using a possibly-threaded
module might have code like this:</p>

<p>use Config; use MyMod;</p>

<p>BEGIN { if ($Config{useithreads}) { # We have threads
require MyMod_threaded; import MyMod_threaded; } else {
require MyMod_unthreaded; import MyMod_unthreaded; } }</p>

<p>Since code that runs both with and without threads is
usually pretty messy, its best to isolate the
thread-specific code in its own module. In our example
above, thats what &quot;MyMod_threaded&quot; is, and its
only imported if were running on a threaded Perl.</p>

<p>A Note about the Examples In a real situation, care
should be taken that all threads are finished executing
before the program exits. That care has not been taken in
these examples in the interest of simplicity. Running these
examples as is will produce error messages, usually caused
by the fact that there are still threads running when the
program exits. You should not be alarmed by this.</p>

<p>Creating Threads The threads module provides the tools
you need to create new threads. Like any other module, you
need to tell Perl that you want to use it; &quot;use
threads;&quot; imports all the pieces you need to create
basic threads.</p>

<p>The simplest, most straightforward way to create a
thread is with &quot;create()&quot;:</p>

<p>use threads;</p>

<p>my $thr = threads-&gt;create(sub1);</p>

<p>sub sub1 { print(&quot;In the thread0); }</p>

<p>The &quot;create()&quot; method takes a reference to a
subroutine and creates a new thread that starts executing in
the referenced subroutine. Control then passes both to the
subroutine and the caller.</p>

<p>If you need to, your program can pass parameters to the
subroutine as part of the thread startup. Just include the
list of parameters as part of the
&quot;threads-&gt;create()&quot; call, like this:</p>

<p>use threads;</p>

<p>my $Param3 = &rsquo;foo&rsquo;; my $thr1 =
threads-&gt;create(sub1, &rsquo;Param 1&rsquo;, &rsquo;Param
2&rsquo;, $Param3); my @ParamList = (42,
&rsquo;Hello&rsquo;, 3.14); my $thr2 =
threads-&gt;create(sub1, @ParamList); my $thr3 =
threads-&gt;create(sub1, qw(Param1 Param2 Param3));</p>

<p>sub sub1 { my @InboundParameters = @_; print(&quot;In
the thread0); print(&rsquo;Got parameters &gt;&rsquo;,
join(&rsquo;&lt;&gt;&rsquo;, @InboundParameters),
&quot;&lt;0); }</p>

<p>The last example illustrates another feature of threads.
You can spawn off several threads using the same subroutine.
Each thread executes the same subroutine, but in a separate
thread with a separate environment and potentially separate
arguments.</p>

<p>&quot;new()&quot; is a synonym for
&quot;create()&quot;.</p>

<p>Waiting For A Thread To Exit Since threads are also
subroutines, they can return values. To wait for a thread to
exit and extract any values it might return, you can use the
&quot;join()&quot; method:</p>

<p>use threads;</p>

<p>my ($thr) = threads-&gt;create(sub1);</p>

<p>my @ReturnData = $thr-&gt;join(); print(&rsquo;Thread
returned &rsquo;, join(&rsquo;, &rsquo;, @ReturnData),
&quot;0);</p>

<p>sub sub1 { return (&rsquo;Fifty-six&rsquo;,
&rsquo;foo&rsquo;, 2); }</p>

<p>In the example above, the &quot;join()&quot; method
returns as soon as the thread ends. In addition to waiting
for a thread to finish and gathering up any values that the
thread might have returned, &quot;join()&quot; also performs
any OS cleanup necessary for the thread. That cleanup might
be important, especially for long-running programs that
spawn lots of threads. If you dont want the return values
and dont want to wait for the thread to finish, you should
call the &quot;detach()&quot; method instead, as described
next.</p>

<p>NOTE: In the example above, the thread returns a list,
thus necessitating that the thread creation call be made in
list context (i.e., &quot;my ($thr)&quot;). See
&quot;&quot;$thr-&quot; in threadsjoin()&quot;&gt; and
&quot;THREAD CONTEXT&quot; in threads for more details on
thread context and return values.</p>

<p>Ignoring A Thread &quot;join()&quot; does three things:
it waits for a thread to exit, cleans up after it, and
returns any data the thread may have produced. But what if
youre not interested in the threads return values, and you
dont really care when the thread finishes? All you want is
for the thread to get cleaned up after when its done.</p>

<p>In this case, you use the &quot;detach()&quot; method.
Once a thread is detached, it ll run until its finished;
then Perl will clean up after it automatically.</p>

<p>use threads;</p>

<p>my $thr = threads-&gt;create(sub1); # Spawn the
thread</p>

<p>$thr-&gt;detach(); # Now we officially don&rsquo;t care
any more</p>

<p>sleep(15); # Let thread run for awhile</p>

<p>sub sub1 { $a = 0; while (1) { $a++; print(&quot; is
$a0); sleep(1); } }</p>

<p>Once a thread is detached, it may not be joined, and any
return data that it might have produced (if it was done and
waiting for a join) is lost.</p>

<p>&quot;detach()&quot; can also be called as a class
method to allow a thread to detach itself:</p>

<p>use threads;</p>

<p>my $thr = threads-&gt;create(sub1);</p>

<p>sub sub1 { threads-&gt;detach(); # Do more work }</p>

<p>Process and Thread Termination With threads one must be
careful to make sure they all have a chance to run to
completion, assuming that is what you want.</p>

<p>An action that terminates a process will terminate all
running threads. die() and exit() have this property, and
perl does an exit when the main thread exits, perhaps
implicitly by falling off the end of your code, even if
thats not what you want.</p>

<p>As an example of this case, this code prints the message
&quot;Perl exited with active threads: 2 running and
unjoined&quot;:</p>

<p>use threads; my $thr1 = threads-&gt;new(thrsub,
&quot;test1&quot;); my $thr2 = threads-&gt;new(thrsub,
&quot;test2&quot;); sub thrsub { my ($message) = @_; sleep
1; print &quot;thread $message0; }</p>

<p>But when the following lines are added at the end:</p>

<p>$thr1-&gt;join(); $thr2-&gt;join();</p>

<p>it prints two lines of output, a perhaps more useful
outcome.</p>

<p>Threads And Data Now that weve covered the basics of
threads, its time for our next topic: Data. Threading
introduces a couple of complications to data access that
non-threaded programs never need to worry about.</p>

<p>Shared And Unshared Data The biggest difference between
Perl ithreads and the old 5.005 style threading, or for that
matter, to most other threading systems out there, is that
by default, no data is shared. When a new Perl thread is
created, all the data associated with the current thread is
copied to the new thread, and is subsequently private to
that new thread! This is similar in feel to what happens
when a UNIX process forks, except that in this case, the
data is just copied to a different part of memory within the
same process rather than a real fork taking place.</p>

<p>To make use of threading, however, one usually wants the
threads to share at least some data between themselves. This
is done with the threads::shared module and the
&quot;:shared&quot; attribute:</p>

<p>use threads; use threads::shared;</p>

<p>my $foo :shared = 1; my $bar = 1; threads-&gt;create(sub
{ $foo++; $bar++; })-&gt;join();</p>

<p>print(&quot;$foo0); # Prints 2 since $foo is shared
print(&quot;$bar0); # Prints 1 since $bar is not shared</p>

<p>In the case of a shared array, all the arrays elements
are shared, and for a shared hash, all the keys and values
are shared. This places restrictions on what may be assigned
to shared array and hash elements: only simple values or
references to shared variables are allowed - this is so that
a private variable cant accidentally become shared. A bad
assignment will cause the thread to die. For example:</p>

<p>use threads; use threads::shared;</p>

<p>my $var = 1; my $svar :shared = 2; my %hash :shared;</p>

<p>... create some threads ...</p>

<p>$hash{a} = 1; # All threads see exists($hash{a}) and
$hash{a} == 1 $hash{a} = $var; # okay - copy-by-value: same
effect as previous $hash{a} = $svar; # okay - copy-by-value:
same effect as previous $hash{a} = var; # okay - a reference
to a shared variable $hash{a} = ar; # This will die
delete($hash{a}); # okay - all threads will see
!exists($hash{a})</p>

<p>Note that a shared variable guarantees that if two or
more threads try to modify it at the same time, the internal
state of the variable will not become corrupted. However,
there are no guarantees beyond this, as explained in the
next section.</p>

<p>Thread Pitfalls: Races While threads bring a new set of
useful tools, they also bring a number of pitfalls. One
pitfall is the race condition:</p>

<p>use threads; use threads::shared;</p>

<p>my $a :shared = 1; my $thr1 = threads-&gt;create(sub1);
my $thr2 = threads-&gt;create(sub2);</p>

<p>$thr1-&gt;join(); $thr2-&gt;join();
print(&quot;$a0);</p>

<p>sub sub1 { my $foo = $a; $a = $foo + 1; } sub sub2 { my
$bar = $a; $a = $bar + 1; }</p>

<p>What do you think $a will be? The answer, unfortunately,
is it depends. Both &quot;sub1()&quot; and
&quot;sub2()&quot; access the global variable $a, once to
read and once to write. Depending on factors ranging from
your thread implementations scheduling algorithm to the
phase of the moon, $a can be 2 or 3.</p>

<p>Race conditions are caused by unsynchronized access to
shared data. Without explicit synchronization, theres no way
to be sure that nothing has happened to the shared data
between the time you access it and the time you update it.
Even this simple code fragment has the possibility of
error:</p>

<p>use threads; my $a :shared = 2; my $b :shared; my $c
:shared; my $thr1 = threads-&gt;create(sub { $b = $a; $a =
$b + 1; }); my $thr2 = threads-&gt;create(sub { $c = $a; $a
= $c + 1; }); $thr1-&gt;join(); $thr2-&gt;join();</p>

<p>Two threads both access $a. Each thread can potentially
be interrupted at any point, or be executed in any order. At
the end, $a could be 3 or 4, and both $b and $c could be 2
or 3.</p>

<p>Even &quot;$a += 5&quot; or &quot;$a++&quot; are not
guaranteed to be atomic.</p>

<p>Whenever your program accesses data or resources that
can be accessed by other threads, you must take steps to
coordinate access or risk data inconsistency and race
conditions. Note that Perl will protect its internals from
your race conditions, but it wont protect you from you.</p>

<p>Synchronization and control Perl provides a number of
mechanisms to coordinate the interactions between themselves
and their data, to avoid race conditions and the like. Some
of these are designed to resemble the common techniques used
in thread libraries such as &quot;pthreads&quot;; others are
Perl-specific. Often, the standard techniques are clumsy and
difficult to get right (such as condition waits). Where
possible, it is usually easier to use Perlish techniques
such as queues, which remove some of the hard work
involved.</p>

<p>Controlling access: lock() The &quot;lock()&quot;
function takes a shared variable and puts a lock on it. No
other thread may lock the variable until the variable is
unlocked by the thread holding the lock. Unlocking happens
automatically when the locking thread exits the block that
contains the call to the &quot;lock()&quot; function. Using
&quot;lock()&quot; is straightforward: This example has
several threads doing some calculations in parallel, and
occasionally updating a running total:</p>

<p>use threads; use threads::shared;</p>

<p>my $total :shared = 0;</p>

<p>sub calc { while (1) { my $result; # (... do some
calculations and set $result ...) { lock($total); # Block
until we obtain the lock $total += $result; } # Lock
implicitly released at end of scope last if $result == 0; }
}</p>

<p>my $thr1 = threads-&gt;create(calc); my $thr2 =
threads-&gt;create(calc); my $thr3 =
threads-&gt;create(calc); $thr1-&gt;join();
$thr2-&gt;join(); $thr3-&gt;join();
print(&quot;total=$total0);</p>

<p>&quot;lock()&quot; blocks the thread until the variable
being locked is available. When &quot;lock()&quot; returns,
your thread can be sure that no other thread can lock that
variable until the block containing the lock exits.</p>

<p>Its important to note that locks dont prevent access to
the variable in question, only lock attempts. This is in
keeping with Perls longstanding tradition of courteous
programming, and the advisory file locking that
&quot;flock()&quot; gives you.</p>

<p>You may lock arrays and hashes as well as scalars.
Locking an array, though, will not block subsequent locks on
array elements, just lock attempts on the array itself.</p>

<p>Locks are recursive, which means its okay for a thread
to lock a variable more than once. The lock will last until
the outermost &quot;lock()&quot; on the variable goes out of
scope. For example:</p>

<p>my $x :shared; doit();</p>

<p>sub doit { { { lock($x); # Wait for lock lock($x); #
NOOP - we already have the lock { lock($x); # NOOP {
lock($x); # NOOP lockit_some_more(); } } } # *** Implicit
unlock here *** } }</p>

<p>sub lockit_some_more { lock($x); # NOOP } # Nothing
happens here</p>

<p>Note that there is no &quot;unlock()&quot; function -
the only way to unlock a variable is to allow it to go out
of scope.</p>

<p>A lock can either be used to guard the data contained
within the variable being locked, or it can be used to guard
something else, like a section of code. In this latter case,
the variable in question does not hold any useful data, and
exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic
semaphores of traditional thread libraries.</p>

<p>A Thread Pitfall: Deadlocks Locks are a handy tool to
synchronize access to data, and using them properly is the
key to safe shared data. Unfortunately, locks arent without
their dangers, especially when multiple locks are involved.
Consider the following code:</p>

<p>use threads;</p>

<p>my $a :shared = 4; my $b :shared = &rsquo;foo&rsquo;; my
$thr1 = threads-&gt;create(sub { lock($a); sleep(20);
lock($b); }); my $thr2 = threads-&gt;create(sub { lock($b);
sleep(20); lock($a); });</p>

<p>This program will probably hang until you kill it. The
only way it wont hang is if one of the two threads acquires
both locks first. A guaranteed-to-hang version is more
complicated, but the principle is the same.</p>

<p>The first thread will grab a lock on $a, then, after a
pause during which the second thread has probably had time
to do some work, try to grab a lock on $b. Meanwhile, the
second thread grabs a lock on $b, then later tries to grab a
lock on $a. The second lock attempt for both threads will
block, each waiting for the other to release its lock.</p>

<p>This condition is called a deadlock, and it occurs
whenever two or more threads are trying to get locks on
resources that the others own. Each thread will block,
waiting for the other to release a lock on a resource. That
never happens, though, since the thread with the resource is
itself waiting for a lock to be released.</p>

<p>There are a number of ways to handle this sort of
problem. The best way is to always have all threads acquire
locks in the exact same order. If, for example, you lock
variables $a, $b, and $c, always lock $a before $b, and $b
before $c. Its also best to hold on to locks for as short a
period of time to minimize the risks of deadlock.</p>

<p>The other synchronization primitives described below can
suffer from similar problems.</p>

<p>Queues: Passing Data Around A queue is a special
thread-safe object that lets you put data in one end and
take it out the other without having to worry about
synchronization issues. They re pretty straightforward, and
look like this:</p>

<p>use threads; use Thread::Queue;</p>

<p>my $DataQueue = Thread::Queue-&gt;new(); my $thr =
threads-&gt;create(sub { while (my $DataElement =
$DataQueue-&gt;dequeue()) { print(&quot;Popped $DataElement
off the queue0); } });</p>

<p>$DataQueue-&gt;enqueue(12);
$DataQueue-&gt;enqueue(&quot;A&quot;, &quot;B&quot;,
&quot;C&quot;); sleep(10); $DataQueue-&gt;enqueue(undef);
$thr-&gt;join();</p>

<p>You create the queue with
&quot;Thread::Queue-&gt;new()&quot;. Then you can add lists
of scalars onto the end with &quot;enqueue()&quot;, and pop
scalars off the front of it with &quot;dequeue()&quot;. A
queue has no fixed size, and can grow as needed to hold
everything pushed on to it.</p>

<p>If a queue is empty, &quot;dequeue()&quot; blocks until
another thread enqueues something. This makes queues ideal
for event loops and other communications between
threads.</p>

<p>Semaphores: Synchronizing Data Access Semaphores are a
kind of generic locking mechanism. In their most basic form,
they behave very much like lockable scalars, except that
they cant hold data, and that they must be explicitly
unlocked. In their advanced form, they act like a kind of
counter, and can allow multiple threads to have the lock at
any one time.</p>

<p>Basic semaphores Semaphores have two methods,
&quot;down()&quot; and &quot;up()&quot;: &quot;down()&quot;
decrements the resource count, while &quot;up()&quot;
increments it. Calls to &quot;down()&quot; will block if the
semaphore s current count would decrement below zero. This
program gives a quick demonstration:</p>

<p>use threads; use Thread::Semaphore;</p>

<p>my $semaphore = Thread::Semaphore-&gt;new(); my
$GlobalVariable :shared = 0;</p>

<p>$thr1 = threads-&gt;create(sample_sub, 1); $thr2 =
threads-&gt;create(sample_sub, 2); $thr3 =
threads-&gt;create(sample_sub, 3);</p>

<p>sub sample_sub { my $SubNumber = shift(@_); my $TryCount
= 10; my $LocalCopy; sleep(1); while ($TryCount--) {
$semaphore-&gt;down(); $LocalCopy = $GlobalVariable;
print(&quot;$TryCount tries left for sub $SubNumber
(lobalVariable is $GlobalVariable)0); sleep(2);
$LocalCopy++; $GlobalVariable = $LocalCopy;
$semaphore-&gt;up(); } }</p>

<p>$thr1-&gt;join(); $thr2-&gt;join();
$thr3-&gt;join();</p>

<p>The three invocations of the subroutine all operate in
sync. The semaphore, though, makes sure that only one thread
is accessing the global variable at once.</p>

<p>Advanced Semaphores By default, semaphores behave like
locks, letting only one thread &quot;down()&quot; them at a
time. However, there are other uses for semaphores.</p>

<p>Each semaphore has a counter attached to it. By default,
semaphores are created with the counter set to one,
&quot;down()&quot; decrements the counter by one, and
&quot;up()&quot; increments by one. However, we can override
any or all of these defaults simply by passing in different
values:</p>

<p>use threads; use Thread::Semaphore;</p>

<p>my $semaphore = Thread::Semaphore-&gt;new(5); # Creates
a semaphore with the counter set to five</p>

<p>my $thr1 = threads-&gt;create(sub1); my $thr2 =
threads-&gt;create(sub1);</p>

<p>sub sub1 { $semaphore-&gt;down(5); # Decrements the
counter by five # Do stuff here $semaphore-&gt;up(5); #
Increment the counter by five }</p>

<p>$thr1-&gt;detach(); $thr2-&gt;detach();</p>

<p>If &quot;down()&quot; attempts to decrement the counter
below zero, it blocks until the counter is large enough.
Note that while a semaphore can be created with a starting
count of zero, any &quot;up()&quot; or &quot;down()&quot;
always changes the counter by at least one, and so
&quot;$semaphore-&gt;down(0)&quot; is the same as
&quot;$semaphore-&gt;down(1)&quot;.</p>

<p>The question, of course, is why would you do something
like this? Why create a semaphore with a starting count
thats not one, or why decrement or increment it by more than
one? The answer is resource availability. Many resources
that you want to manage access for can be safely used by
more than one thread at once.</p>

<p>For example, let s take a GUI driven program. It has a
semaphore that it uses to synchronize access to the display,
so only one thread is ever drawing at once. Handy, but of
course you dont want any thread to start drawing until
things are properly set up. In this case, you can create a
semaphore with a counter set to zero, and up it when things
are ready for drawing.</p>

<p>Semaphores with counters greater than one are also
useful for establishing quotas. Say, for example, that you
have a number of threads that can do I/O at once. You dont
want all the threads reading or writing at once though,
since that can potentially swamp your I/O channels, or
deplete your process quota of filehandles. You can use a
semaphore initialized to the number of concurrent I/O
requests (or open files) that you want at any one time, and
have your threads quietly block and unblock themselves.</p>

<p>Larger increments or decrements are handy in those cases
where a thread needs to check out or return a number of
resources at once.</p>

<p>Waiting for a Condition The functions
&quot;cond_wait()&quot; and &quot;cond_signal()&quot; can be
used in conjunction with locks to notify co-operating
threads that a resource has become available. They are very
similar in use to the functions found in
&quot;pthreads&quot;. However for most purposes, queues are
simpler to use and more intuitive. See threads::shared for
more details.</p>

<p>Giving up control There are times when you may find it
useful to have a thread explicitly give up the CPU to
another thread. You may be doing something
processor-intensive and want to make sure that the
user-interface thread gets called frequently. Regardless,
there are times that you might want a thread to give up the
processor.</p>

<p>Perls threading package provides the &quot;yield()&quot;
function that does this. &quot;yield()&quot; is pretty
straightforward, and works like this:</p>

<p>use threads;</p>

<p>sub loop { my $thread = shift; my $foo = 50;
while($foo--) { print(&quot;In thread $thread0); }
threads-&gt;yield(); $foo = 50; while($foo--) {
print(&quot;In thread $thread0); } }</p>

<p>my $thr1 = threads-&gt;create(loop,
&rsquo;first&rsquo;); my $thr2 = threads-&gt;create(loop,
&rsquo;second&rsquo;); my $thr3 = threads-&gt;create(loop,
&rsquo;third&rsquo;);</p>

<p>It is important to remember that &quot;yield()&quot; is
only a hint to give up the CPU, it depends on your hardware,
OS and threading libraries what actually happens. On many
operating systems, yield() is a no-op. Therefore it is
important to note that one should not build the scheduling
of the threads around &quot;yield()&quot; calls. It might
work on your platform but it wont work on another
platform.</p>

<p>General Thread Utility Routines We ve covered the
workhorse parts of Perls threading package, and with these
tools you should be well on your way to writing threaded
code and packages. There are a few useful little pieces that
didnt really fit in anyplace else.</p>

<p>What Thread Am I In? The &quot;threads-&gt;self()&quot;
class method provides your program with a way to get an
object representing the thread its currently in. You can use
this object in the same way as the ones returned from thread
creation.</p>

<p>Thread IDs &quot;tid()&quot; is a thread object method
that returns the thread ID of the thread the object
represents. Thread IDs are integers, with the main thread in
a program being 0. Currently Perl assigns a unique TID to
every thread ever created in your program, assigning the
first thread to be created a TID of 1, and increasing the
TID by 1 for each new thread thats created. When used as a
class method, &quot;threads-&gt;tid()&quot; can be used by a
thread to get its own TID.</p>

<p>Are These Threads The Same? The &quot;equal()&quot;
method takes two thread objects and returns true if the
objects represent the same thread, and false if they
dont.</p>

<p>Thread objects also have an overloaded &quot;==&quot;
comparison so that you can do comparison on them as you
would with normal objects.</p>

<p>What Threads Are Running? &quot;threads-&gt;list()&quot;
returns a list of thread objects, one for each thread that s
currently running and not detached. Handy for a number of
things, including cleaning up at the end of your program
(from the main Perl thread, of course):</p>

<p># Loop through all the threads foreach my $thr
(threads-&gt;list()) { $thr-&gt;join(); }</p>

<p>If some threads have not finished running when the main
Perl thread ends, Perl will warn you about it and die, since
it is impossible for Perl to clean up itself while other
threads are running.</p>

<p>NOTE: The main Perl thread (thread 0) is in a detached
state, and so does not appear in the list returned by
&quot;threads-&gt;list()&quot;.</p>

<p>A Complete Example Confused yet? Its time for an example
program to show some of the things weve covered. This
program finds prime numbers using threads.</p>

<p>1 #!/usr/bin/perl 2 # prime-pthread, courtesy of Tom
Christiansen 3 4 use strict; 5 use warnings; 6 7 use
threads; 8 use Thread::Queue; 9 10 sub check_num { 11 my
($upstream, $cur_prime) = @_; 12 my $kid; 13 my $downstream
= Thread::Queue-&gt;new(); 14 while (my $num =
$upstream-&gt;dequeue()) { 15 next unless ($num %
$cur_prime); 16 if ($kid) { 17
$downstream-&gt;enqueue($num); 18 } else { 19
print(&quot;Found prime: $num0); 20 $kid =
threads-&gt;create(check_num, $downstream, $num); 21 if (!
$kid) { 22 warn(&quot;Sorry. Ran out of threads.0); 23 last;
24 } 25 } 26 } 27 if ($kid) { 28
$downstream-&gt;enqueue(undef); 29 $kid-&gt;join(); 30 } 31
} 32 33 my $stream = Thread::Queue-&gt;new(3..1000, undef);
34 check_num($stream, 2);</p>

<p>This program uses the pipeline model to generate prime
numbers. Each thread in the pipeline has an input queue that
feeds numbers to be checked, a prime number that its
responsible for, and an output queue into which it funnels
numbers that have failed the check. If the thread has a
number thats failed its check and theres no child thread,
then the thread must have found a new prime number. In that
case, a new child thread is created for that prime and stuck
on the end of the pipeline.</p>

<p>This probably sounds a bit more confusing than it really
is, so lets go through this program piece by piece and see
what it does. (For those of you who might be trying to
remember exactly what a prime number is, it s a number thats
only evenly divisible by itself and 1.)</p>

<p>The bulk of the work is done by the
&quot;check_num()&quot; subroutine, which takes a reference
to its input queue and a prime number that its responsible
for. After pulling in the input queue and the prime that the
subroutine is checking (line 11), we create a new queue
(line 13) and reserve a scalar for the thread that we re
likely to create later (line 12).</p>

<p>The while loop from line 14 to line 26 grabs a scalar
off the input queue and checks against the prime this thread
is responsible for. Line 15 checks to see if theres a
remainder when we divide the number to be checked by our
prime. If there is one, the number must not be evenly
divisible by our prime, so we need to either pass it on to
the next thread if weve created one (line 17) or create a
new thread if we havent.</p>

<p>The new thread creation is line 20. We pass on to it a
reference to the queue weve created, and the prime number we
ve found. In lines 21 through 24, we check to make sure that
our new thread got created, and if not, we stop checking any
remaining numbers in the queue.</p>

<p>Finally, once the loop terminates (because we got a 0 or
&quot;undef&quot; in the queue, which serves as a note to
terminate), we pass on the notice to our child, and wait for
it to exit if weve created a child (lines 27 and 30).</p>

<p>Meanwhile, back in the main thread, we first create a
queue (line 33) and queue up all the numbers from 3 to 1000
for checking, plus a termination notice. Then all we have to
do to get the ball rolling is pass the queue and the first
prime to the &quot;check_num()&quot; subroutine (line
34).</p>

<p>Thats how it works. Its pretty simple; as with many Perl
programs, the explanation is much longer than the
program.</p>

<p>Different implementations of threads Some background on
thread implementations from the operating system viewpoint.
There are three basic categories of threads: user-mode
threads, kernel threads, and multiprocessor kernel
threads.</p>

<p>User-mode threads are threads that live entirely within
a program and its libraries. In this model, the OS knows
nothing about threads. As far as its concerned, your process
is just a process.</p>

<p>This is the easiest way to implement threads, and the
way most OSes start. The big disadvantage is that, since the
OS knows nothing about threads, if one thread blocks they
all do. Typical blocking activities include most system
calls, most I/O, and things like &quot;sleep()&quot;.</p>

<p>Kernel threads are the next step in thread evolution.
The OS knows about kernel threads, and makes allowances for
them. The main difference between a kernel thread and a
user-mode thread is blocking. With kernel threads, things
that block a single thread don t block other threads. This
is not the case with user-mode threads, where the kernel
blocks at the process level and not the thread level.</p>

<p>This is a big step forward, and can give a threaded
program quite a performance boost over non-threaded
programs. Threads that block performing I/O, for example,
wont block threads that are doing other things. Each process
still has only one thread running at once, though,
regardless of how many CPUs a system might have.</p>

<p>Since kernel threading can interrupt a thread at any
time, they will uncover some of the implicit locking
assumptions you may make in your program. For example,
something as simple as &quot;$a = $a + 2&quot; can behave
unpredictably with kernel threads if $a is visible to other
threads, as another thread may have changed $a between the
time it was fetched on the right hand side and the time the
new value is stored.</p>

<p>Multiprocessor kernel threads are the final step in
thread support. With multiprocessor kernel threads on a
machine with multiple CPUs, the OS may schedule two or more
threads to run simultaneously on different CPUs.</p>

<p>This can give a serious performance boost to your
threaded program, since more than one thread will be
executing at the same time. As a tradeoff, though, any of
those nagging synchronization issues that might not have
shown with basic kernel threads will appear with a
vengeance.</p>

<p>In addition to the different levels of OS involvement in
threads, different OSes (and different thread
implementations for a particular OS) allocate CPU cycles to
threads in different ways.</p>

<p>Cooperative multitasking systems have running threads
give up control if one of two things happen. If a thread
calls a yield function, it gives up control. It also gives
up control if the thread does something that would cause it
to block, such as perform I/O. In a cooperative multitasking
implementation, one thread can starve all the others for CPU
time if it so chooses.</p>

<p>Preemptive multitasking systems interrupt threads at
regular intervals while the system decides which thread
should run next. In a preemptive multitasking system, one
thread usually won t monopolize the CPU.</p>

<p>On some systems, there can be cooperative and preemptive
threads running simultaneously. (Threads running with
realtime priorities often behave cooperatively, for example,
while threads running at normal priorities behave
preemptively.)</p>

<p>Most modern operating systems support preemptive
multitasking nowadays.</p>

<p>Performance considerations The main thing to bear in
mind when comparing Perls ithreads to other threading models
is the fact that for each new thread created, a complete
copy of all the variables and data of the parent thread has
to be taken. Thus, thread creation can be quite expensive,
both in terms of memory usage and time spent in creation.
The ideal way to reduce these costs is to have a relatively
short number of long-lived threads, all created fairly early
on -- before the base thread has accumulated too much data.
Of course, this may not always be possible, so compromises
have to be made. However, after a thread has been created,
its performance and extra memory usage should be little
different than ordinary code.</p>

<p>Also note that under the current implementation, shared
variables use a little more memory and are a little slower
than ordinary variables.</p>

<p>Process-scope Changes Note that while threads themselves
are separate execution threads and Perl data is
thread-private unless explicitly shared, the threads can
affect process-scope state, affecting all the threads.</p>

<p>The most common example of this is changing the current
working directory using &quot;chdir()&quot;. One thread
calls &quot;chdir()&quot;, and the working directory of all
the threads changes.</p>

<p>Even more drastic example of a process-scope change is
&quot;chroot()&quot;: the root directory of all the threads
changes, and no thread can undo it (as opposed to
&quot;chdir()&quot;).</p>

<p>Further examples of process-scope changes include
&quot;umask()&quot; and changing uids and gids.</p>

<p>Thinking of mixing &quot;fork()&quot; and threads?
Please lie down and wait until the feeling passes. Be aware
that the semantics of &quot;fork()&quot; vary between
platforms. For example, some UNIX systems copy all the
current threads into the child process, while others only
copy the thread that called &quot;fork()&quot;. You have
been warned!</p>

<p>Similarly, mixing signals and threads may be
problematic. Implementations are platform-dependent, and
even the POSIX semantics may not be what you expect (and
Perl doesnt even give you the full POSIX API). For example,
there is no way to guarantee that a signal sent to a
multi-threaded Perl application will get intercepted by any
particular thread. (However, a recently added feature does
provide the capability to send signals between threads. See
&quot;&quot;THREAD SIGNALLING&quot; in threads for more
details.)</p>

<p>Thread-Safety of System Libraries Whether various
library calls are thread-safe is outside the control of
Perl. Calls often suffering from not being thread-safe
include: &quot;localtime()&quot;, &quot;gmtime()&quot;,
functions fetching user, group and network information (such
as &quot;getgrent()&quot;, &quot;gethostent()&quot;,
&quot;getnetent()&quot; and so on), &quot;readdir()&quot;,
&quot;rand()&quot;, and &quot;srand()&quot; -- in general,
calls that depend on some global external state.</p>

<p>If the system Perl is compiled in has thread-safe
variants of such calls, they will be used. Beyond that, Perl
is at the mercy of the thread-safety or -unsafety of the
calls. Please consult your C library call documentation.</p>

<p>On some platforms the thread-safe library interfaces may
fail if the result buffer is too small (for example the user
group databases may be rather large, and the reentrant
interfaces may have to carry around a full snapshot of those
databases). Perl will start with a small buffer, but keep
retrying and growing the result buffer until the result
fits. If this limitless growing sounds bad for security or
memory consumption reasons you can recompile Perl with
&quot;PERL_REENTRANT_MAXSIZE&quot; defined to the maximum
number of bytes you will allow.</p>

<p>Conclusion A complete thread tutorial could fill a book
(and has, many times), but with what weve covered in this
introduction, you should be well on your way to becoming a
threaded Perl expert.</p>

<p>SEE ALSO Annotated POD for threads:
&lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads&gt;</p>

<p>Lastest version of threads on CPAN:
&lt;http://search.cpan.org/search?module=threads&gt;</p>

<p>Annotated POD for threads::shared:
&lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads%3A%3Ashared&gt;</p>

<p>Lastest version of threads::shared on CPAN:
&lt;http://search.cpan.org/search?module=threads%3A%3Ashared&gt;</p>

<p>Perl threads mailing list:
&lt;http://lists.cpan.org/showlist.cgi?name=iThreads&gt;</p>

<p>Bibliography Here s a short bibliography courtesy of
JA~Xrgen Christoffel:</p>

<p>Introductory Texts Birrell, Andrew D. An Introduction to
Programming with Threads. Digital Equipment Corporation,
1989, DEC-SRC Research Report #35 online as
http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-035.html
(highly recommended)</p>

<p>Robbins, Kay. A., and Steven Robbins. Practical Unix
Programming: A Guide to Concurrency, Communication, and
Multithreading. Prentice-Hall, 1996.</p>

<p>Lewis, Bill, and Daniel J. Berg. Multithreaded
Programming with Pthreads. Prentice Hall, 1997, ISBN
0-13-443698-9 (a well-written introduction to threads).</p>

<p>Nelson, Greg (editor). Systems Programming with
Modula-3. Prentice Hall, 1991, ISBN 0-13-590464-1.</p>

<p>Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx
Farrell. Pthreads Programming. O Reilly &amp; Associates,
1996, ISBN 156592-115-1 (covers POSIX threads).</p>

<p>OS-Related References Boykin, Joseph, David Kirschen,
Alan Langerman, and Susan LoVerso. Programming under Mach.
Addison-Wesley, 1994, ISBN 0-201-52739-1.</p>

<p>Tanenbaum, Andrew S. Distributed Operating Systems.
Prentice Hall, 1995, ISBN 0-13-219908-4 (great
textbook).</p>

<p>Silberschatz, Abraham, and Peter B. Galvin. Operating
System Concepts, 4th ed. Addison-Wesley, 1995, ISBN
0-201-59292-4</p>

<p>Other References Arnold, Ken and James Gosling. The Java
Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN
0-201-31006-6.</p>

<p>comp.programming.threads FAQ,
&lt;http://www.serpentine.com/~bos/threads-faq/&gt;</p>

<p>Le Sergent, T. and B. Berthomieu. &quot;Incremental
MultiThreaded Garbage Collection on Virtually Shared Memory
Architectures&quot; in Memory Management: Proc. of the
International Workshop IWMM 92, St. Malo, France, September
1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992,
ISBN 3540-55940-X (real-life thread applications).</p>

<p>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;,
June 11, 2002,
&lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt;</p>

<p>Acknowledgements Thanks (in no particular order) to
Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya
Zakharevich, Benjamin Sugars, JA~Xrgen Christoffel, Joshua
Pritikin, and Alan Burlison, for their help in
reality-checking and polishing this article. Big thanks to
Tom Christiansen for his rewrite of the prime number
generator.</p>

<p>AUTHOR Dan Sugalski &lt;dan@sidhe.org&lt;gt&gt;</p>

<p>Slightly modified by Arthur Bergman to fit the new
thread model/module.</p>

<p>Reworked slightly by JA~Xrg Walter
&lt;jwalt@cpan.org&lt;gt&gt; to be more concise about
thread-safety of Perl code.</p>

<p>Rearranged slightly by Elizabeth Mattijsen
&lt;liz@dijkmat.nl&lt;gt&gt; to put less emphasis on
yield().</p>

<p>Copyrights The original version of this article
originally appeared in The Perl Journal #10, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon
Orwant and The Perl Journal. This document may be
distributed under the same terms as Perl itself.</p>

<p>perl v5.10.1 2009-04-14 PERLTHRTUT(1)</p>
<hr>
</body>
</html>
