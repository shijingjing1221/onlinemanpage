<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:36 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>keytool(1) keytool(1)</p>

<p>Name keytool - Key and Certificate Management Tool</p>

<p>Manages a keystore (database) of cryptographic keys,
X.509 certificate chains, and trusted certificates.</p>

<p>SYNOPSIS keytool [ commands ]</p>

<p>The keytool command interface has changed in Java SE 6.
See the Changes Section for a detailed description. Note
that previously defined com- mands are still supported.</p>

<p>DESCRIPTION keytool is a key and certificate management
utility. It allows users to administer their own
public/private key pairs and associated certifi- cates for
use in self-authentication (where the user authenticates
him- self/herself to other users/services) or data integrity
and authentica- tion services, using digital signatures. It
also allows users to cache the public keys (in the form of
certificates) of their communicating peers.</p>

<p>A certificate is a digitally signed statement from one
entity (person, company, etc.), saying that the public key
(and some other information) of some other entity has a
particular value. (See Certificates.) When data is digitally
signed, the signature can be verified to check the data
integrity and authenticity. Integrity means that the data
has not been modified or tampered with, and authenticity
means the data indeed comes from whoever claims to have
created and signed it.</p>

<p>keytool also enables users to administer secret keys
used in symmetric encryption/decryption (e.g. DES).</p>

<p>keytool stores the keys and certificates in a
keystore.</p>

<p>COMMAND AND OPTION NOTES The various commands and their
options are listed and described below. Note:</p>

<p>o All command and option names are preceded by a minus
sign (-).</p>

<p>o The options for each command may be provided in any
order.</p>

<p>o All items not italicized or in braces or square
brackets are required to appear as is.</p>

<p>o Braces surrounding an option generally signify that a
default value will be used if the option is not specified on
the command line. Braces are also used around the -v, -rfc,
and -J options, which only have meaning if they appear on
the command line (that is, they dont have any
&quot;default&quot; values other than not existing).</p>

<p>o Brackets surrounding an option signify that the user
is prompted for the value(s) if the option is not specified
on the command line. (For a -keypass option, if you do not
specify the option on the command line, keytool will first
attempt to use the keystore password to recover the
private/secret key, and if this fails, will then prompt you
for the private/secret key password.)</p>

<p>o Items in italics (option values) represent the actual
values that must be supplied. For example, here is the
format of the -print- cert command:</p>

<p>keytool -printcert {-file cert_file} {-v}</p>

<p>When specifying a -printcert command, replace cert_file
with the actual file name, as in:</p>

<p>keytool -printcert -file VScert.cer</p>

<p>o Option values must be quoted if they contain a blank
(space).</p>

<p>o The -help command is the default. Thus, the command
line</p>

<p>keytool</p>

<p>is equivalent to</p>

<p>keytool -help</p>

<p>Option Defaults Below are the defaults for various
option values.</p>

<p>-alias &quot;mykey&quot;</p>

<p>-keyalg &quot;DSA&quot; (when using -genkeypair)
&quot;DES&quot; (when using -genseckey)</p>

<p>-keysize 2048 (when using -genkeypair and -keyalg is
&quot;RSA&quot;) 1024 (when using -genkeypair and -keyalg is
&quot;DSA&quot;) 256 (when using -genkeypair and -keyalg is
&quot;EC&quot;) 56 (when using -genseckey and -keyalg is
&quot;DES&quot;) 168 (when using -genseckey and -keyalg is
&quot;DESede&quot;)</p>

<p>-validity 90</p>

<p>-keystore the file named .keystore in the user s home
directory</p>

<p>-storetype the value of the &quot;keystore.type&quot;
property in the security properties file, which is returned
by the static getDefaultType method in
java.security.KeyStore</p>

<p>-file stdin if reading, stdout if writing</p>

<p>-protected false</p>

<p>In generating a public/private key pair, the signature
algorithm (-sigalg option) is derived from the algorithm of
the underlying private key:</p>

<p>o If the underlying private key is of type
&quot;DSA&quot;, the -sigalg option defaults to
&quot;SHA1withDSA&quot;</p>

<p>o If the underlying private key is of type
&quot;RSA&quot;, the -sigalg option defaults to
&quot;SHA256withRSA&quot;.</p>

<p>o If the underlying private key is of type
&quot;EC&quot;, the -sigalg option defaults to
&quot;SHA256withECDSA&quot;.</p>

<p>Please consult the Java Cryptography Architecture API
Specification &amp; Reference @
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/crypto/CryptoSpec.html#AppA for a full list of -keyalg
and -sigalg you can choose from.</p>

<p>Common Options The -v option can appear for all commands
except -help. If it appears, it signifies
&quot;verbose&quot; mode; more information will be provided
in the output.</p>

<p>There is also a -Jjavaoption option that may appear for
any command. If it appears, the specified javaoption string
is passed through directly to the Java interpreter. This
option should not contain any spaces. It is useful for
adjusting the execution environment or memory usage. For a
list of possible interpreter options, type java -h or java
-X at the command line.</p>

<p>These options may appear for all commands operating on a
keystore:</p>

<p>-storetype storetype</p>

<p>This qualifier specifies the type of keystore to be
instantiated.</p>

<p>-keystore keystore</p>

<p>The keystore location.</p>

<p>If the JKS storetype is used and a keystore file does
not yet exist, then certain keytool commands may result in a
new keystore file being created. For example, if keytool
-genkeypair is invoked and the -keystore option is not
specified, the default keystore file named .keystore in the
users home directory will be created if it does not already
exist. Similarly, if the -keystore ks_file option is
specified but ks_file does not exist, then it will be
created</p>

<p>Note that the input stream from the -keystore option is
passed to the KeyStore.load method. If NONE is specified as
the URL, then a null stream is passed to the KeyStore.load
method. NONE should be specified if the KeyStore is not
file-based (for example, if it resides on a hardware token
device).</p>

<p>-storepass[:env|:file] argument</p>

<p>The password which is used to protect the integrity of
the keystore.</p>

<p>If the modifier env or file is not specified, then the
password has the value argument, which must be at least 6
characters long. Other- wise, the password is retrieved as
follows:</p>

<p>o env: Retrieve the password from the environment
variable named argument</p>

<p>o file: Retrieve the password from the file named
argument</p>

<p>Note: All other options that require passwords, such as
-keypass, -srckeypass, -destkeypass -srcstorepass, and
-deststorepass, accept the env and file modifiers. (Remember
to separate the password option and the modifier with a
colon, (:).)</p>

<p>The password must be provided to all commands that
access the key- store contents. For such commands, if a
-storepass option is not provided at the command line, the
user is prompted for it.</p>

<p>When retrieving information from the keystore, the
password is optional; if no password is given, the integrity
of the retrieved information cannot be checked and a warning
is displayed.</p>

<p>-providerName provider_name</p>

<p>Used to identify a cryptographic service providers name
when listed in the security properties file.</p>

<p>-providerClass provider_class_name</p>

<p>Used to specify the name of cryptographic service
providers master class file when the service provider is not
listed in the security properties file.</p>

<p>-providerArg provider_arg</p>

<p>Used in conjunction with -providerClass. Represents an
optional string input argument for the constructor of
provider_class_name.</p>

<p>-protected</p>

<p>Either true or false. This value should be specified as
true if a password must be given via a protected
authentication path such as a dedicated PIN reader.</p>

<p>Note: Since there are two keystores involved in
-importkeystore com- mand, two options, namely,
-srcprotected and -destprotected are pro- vided for the
source keystore and the destination keystore respec-
tively.</p>

<p>-ext {name{:critical}{=value}}</p>

<p>Denotes an X.509 certificate extension. The option can
be used in -genkeypair and -gencert to embed extensions into
the certificate generated, or in -certreq to show what
extensions are requested in the certificate request. The
option can appear multiple times. name can be a supported
extension name (see below) or an arbitrary OID number.
value, if provided, denotes the parameter for the extension;
if omitted, denotes the default value (if defined) of the
extension or the extension requires no parameter. The
:critical modifier, if provided, means the extensions
isCritical attribute is true; other- wise, false. You may
use :c in place of :critical.</p>

<p>Currently keytool supports these named extensions
(case-insensitive):</p>

<p>For name as OID, value is the HEX dumped DER encoding of
the extnValue for the extension excluding the OCTET STRING
type and length bytes. Any extra character other than
standard HEX numbers (0-9, a-f, A-F) are ignored in the HEX
string. Therefore, both &quot;01:02:03:04&quot; and
&quot;01020304&quot; are accepted as identical values. If
there is no value, the extension has an empty value field
then.</p>

<p>A special name honored, used in -gencert only, denotes
how the exten- sions included in the certificate request
should be honored. The value for this name is a comma
separated list of &quot;all&quot; (all requested exten-
sions are honored),
&quot;name{:[critical|non-critical]}&quot; (the named exten-
sion is honored, but using a different isCritical attribute)
and &quot;-name&quot; (used with all, denotes an exception).
Requested extensions are not honored by default.</p>

<p>If, besides the -ext honored option, another named or
OID -ext option is provided, this extension will be added to
those already honored. However, if this name (or OID) also
appears in the honored value, its value and criticality
overrides the one in the request.</p>

<p>The subjectKeyIdentifier extension is always created.
For non self-signed certificates, the authorityKeyIdentifier
is always created.</p>

<p>Note: Users should be aware that some combinations of
extensions (and other certificate fields) may not conform to
the Internet standard. See Warning Regarding Certificate
Conformance for details.</p>

<p>COMMANDS Creating or Adding Data to the Keystore
-gencert {-rfc} {-infile infile} {-outfile outfile} {-alias
alias} {-sigalg sigalg} {-dname dname} {-startdate startdate
{-ext ext}* {-validity valDays} [-keypass keypass]
{-keystore keystore} [-storepass storepass] {-storetype
storetype} {-providername provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a certificate as a response to a certificate
request file (which can be created by the keytool -certreq
command). The command reads the request from infile (if
omitted, from the standard input), signs it using aliass
private key, and output the X.509 certificate into outfile
(if omitted, to the standard output). If -rfc is speci-
fied, output format is BASE64-encoded PEM; otherwise, a
binary DER is created.</p>

<p>sigalg specifies the algorithm that should be used to
sign the cer- tificate. startdate is the start time/date
that the certificate is valid. valDays tells the number of
days for which the certificate should be considered
valid.</p>

<p>If dname is provided, its used as the subject of the
generated cer- tificate. Otherwise, the one from the
certificate request is used.</p>

<p>ext shows what X.509 extensions will be embedded in the
certificate. Read Common Options for the grammar of
-ext.</p>

<p>The -gencert command enables you to create certificate
chains. The following example creates a certificate, e1,
that contains three certificates in its certificate
chain.</p>

<p>The following commands creates four key pairs named ca,
ca1, ca2, and e1:</p>

<p>keytool -alias ca -dname CN=CA -genkeypair keytool
-alias ca1 -dname CN=CA -genkeypair keytool -alias ca2
-dname CN=CA -genkeypair keytool -alias e1 -dname CN=E1
-genkeypair</p>

<p>The following two commands create a chain of signed
certificates; ca signs ca1 and ca1 signs ca2, all of which
are self-issued:</p>

<p>keytool -alias ca1 -certreq | keytool -alias ca -gencert
-ext san=dns:ca1 | keytool -alias ca1 -importcert keytool
-alias ca2 -certreq | $KT -alias ca1 -gencert -ext
san=dns:ca2 | $KT -alias ca2 -importcert</p>

<p>The following command creates the certificate e1 and
stores it in the file e1.cert, which is signed by ca2. As a
result, e1 should contain ca, ca1, and ca2 in its
certificate chain:</p>

<p>keytool -alias e1 -certreq | keytool -alias ca2 -gencert
&gt; e1.cert</p>

<p>-genkeypair {-alias alias} {-keyalg keyalg} {-keysize
keysize} {-sigalg sigalg} [-dname dname] [-keypass keypass]
{-startdate value} {-ext ext}* {-validity valDays}
{-storetype storetype} {-key- store keystore} [-storepass
storepass] {-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p>Generates a key pair (a public key and associated
private key). Wraps the public key into an X.509 v3
self-signed certificate, which is stored as a single-element
certificate chain. This certificate chain and the private
key are stored in a new keystore entry identi- fied by
alias.</p>

<p>keyalg specifies the algorithm to be used to generate
the key pair, and keysize specifies the size of each key to
be generated. sigalg specifies the algorithm that should be
used to sign the self-signed certificate; this algorithm
must be compatible with keyalg.</p>

<p>dname specifies the X.500 Distinguished Name to be
associated with alias, and is used as the issuer and subject
fields in the self-signed certificate. If no distinguished
name is provided at the command line, the user will be
prompted for one.</p>

<p>keypass is a password used to protect the private key of
the gener- ated key pair. If no password is provided, the
user is prompted for it. If you press RETURN at the prompt,
the key password is set to the same password as that used
for the keystore. keypass must be at least 6 characters
long.</p>

<p>startdate specifies the issue time of the certificate,
also known as the &quot;Not Before&quot; value of the X.509
certificate s Validity field.</p>

<p>The option value can be set in one of these two
forms:</p>

<p>1. ([+-]nnn[ymdHMS])+</p>

<p>2. [yyyy/mm/dd] [HH:MM:SS]</p>

<p>With the first form, the issue time is shifted by the
specified value from the current time. The value is a
concatenation of a sequence of sub values. Inside each sub
value, the plus sign (&quot;+&quot;) means shifting forward,
and the minus sign (&quot;-&quot;) means shifting backward.
The time to be shifted is nnn units of years, months, days,
hours, minutes, or seconds (denoted by a single character of
&quot;y&quot;, &quot;m&quot;, &quot;d&quot;, &quot;H&quot;,
&quot;M&quot;, or &quot;S&quot; respectively). The exact
value of the issue time is calculated using the
java.util.GregorianCalendar.add(int field, int amount)
method on each sub value, from left to right. For example,
by specifying &quot;-startdate -1y+1m-1d&quot;, the issue
time will be:</p>

<p>Calendar c = new GregorianCalendar();
c.add(Calendar.YEAR, -1); c.add(Calendar.MONTH, 1);
c.add(Calendar.DATE, -1); return c.getTime()</p>

<p>With the second form, the user sets the exact issue time
in two parts, year/month/day and hour:minute:second (using
the local time zone). The user may provide only one part,
which means the other part is the same as the current date
(or time). User must provide the exact number of digits as
shown in the format definition (padding with 0 if shorter).
When both the date and time are pro- vided, there is one
(and only one) space character between the two parts. The
hour should always be provided in 24 hour format.</p>

<p>When the option is not provided, the start date is the
current time. The option can be provided at most once.</p>

<p>valDays specifies the number of days (starting at the
date specified by -startdate, or the current date if
-startdate is not specified) for which the certificate
should be considered valid.</p>

<p>This command was named -genkey in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarity the new name,
-genkeypair, is preferred going forward.</p>

<p>-genseckey {-alias alias} {-keyalg keyalg} {-keysize
keysize} [-key- pass keypass] {-storetype storetype}
{-keystore keystore} [-storepass storepass] {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a secret key and stores it in a new
KeyStore.SecretKeyEn- try identified by alias.</p>

<p>keyalg specifies the algorithm to be used to generate
the secret key, and keysize specifies the size of the key to
be generated. key- pass is a password used to protect the
secret key. If no password is provided, the user is prompted
for it. If you press RETURN at the prompt, the key password
is set to the same password as that used for the keystore.
keypass must be at least 6 characters long.</p>

<p>-importcert {-alias alias} {-file cert_file} [-keypass
keypass] {-noprompt} {-trustcacerts} {-storetype storetype}
{-keystore key- store} [-storepass storepass] {-providerName
provider_name} {-pro- viderClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p>Reads the certificate or certificate chain (where the
latter is sup- plied in a PKCS#7 formatted reply or a
sequence of X.509 certifi- cates) from the file cert_file,
and stores it in the keystore entry identified by alias. If
no file is given, the certificate or cer- tificate chain is
read from stdin.</p>

<p>keytool can import X.509 v1, v2, and v3 certificates,
and PKCS#7 formatted certificate chains consisting of
certificates of that type. The data to be imported must be
provided either in binary encoding format, or in printable
encoding format (also known as Base64 encoding) as defined
by the Internet RFC 1421 standard. In the latter case, the
encoding must be bounded at the beginning by a string that
starts with &quot;-----BEGIN&quot;, and bounded at the end
by a string that starts with &quot;-----END&quot;.</p>

<p>You import a certificate for two reasons:</p>

<p>1. to add it to the list of trusted certificates, or</p>

<p>2. to import a certificate reply received from a CA as
the result of submitting a Certificate Signing Request (see
the -certreq command) to that CA.</p>

<p>Which type of import is intended is indicated by the
value of the -alias option:</p>

<p>1. If the alias does not point to a key entry, then
keytool assumes you are adding a trusted certificate entry.
In this case, the alias should not already exist in the
keystore. If the alias does already exist, then keytool
outputs an error, since there is already a trusted
certificate for that alias, and does not import the
certificate.</p>

<p>2. If the alias points to a key entry, then keytool
assumes you are importing a certificate reply. Importing a
New Trusted Certificate</p>

<p>Before adding the certificate to the keystore, keytool
tries to ver- ify it by attempting to construct a chain of
trust from that cer- tificate to a self-signed certificate
(belonging to a root CA), using trusted certificates that
are already available in the key- store.</p>

<p>If the -trustcacerts option has been specified,
additional certifi- cates are considered for the chain of
trust, namely the certificates in a file named
&quot;cacerts&quot;.</p>

<p>If keytool fails to establish a trust path from the
certificate to be imported up to a self-signed certificate
(either from the key- store or the &quot;cacerts&quot;
file), the certificate information is printed out, and the
user is prompted to verify it, e.g., by comparing the
displayed certificate fingerprints with the fingerprints
obtained from some other (trusted) source of information,
which might be the certificate owner himself/herself. Be
very careful to ensure the certificate is valid prior to
importing it as a &quot;trusted&quot; certifi- cate! -- see
WARNING Regarding Importing Trusted Certificates. The user
then has the option of aborting the import operation. If the
-noprompt option is given, however, there will be no
interaction with the user. Importing a Certificate Reply</p>

<p>When importing a certificate reply, the certificate
reply is vali- dated using trusted certificates from the
keystore, and optionally using the certificates configured
in the &quot;cacerts&quot; keystore file (if the
-trustcacerts option was specified).</p>

<p>The methods of determining whether the certificate reply
is trusted are described in the following:</p>

<p>o If the reply is a single X.509 certificate, keytool
attempts to establish a trust chain, starting at the
certificate reply and ending at a self-signed certificate
(belonging to a root CA). The certificate reply and the
hierarchy of certificates used to authenticate the
certificate reply form the new certificate chain of alias.
If a trust chain cannot be established, the certificate
reply is not imported. In this case, keytool does not print
out the certificate and prompt the user to verify it,
because it is very hard (if not impossible) for a user to
determine the authenticity of the certificate reply.</p>

<p>o If the reply is a PKCS#7 formatted certificate chain
or a sequence of X.509 certificates, the chain is ordered
with the user certificate first followed by zero or more CA
certifi- cates. If the chain ends with a self-signed root CA
certificate and -trustcacerts option was specified, keytool
will attempt to match it with any of the trusted
certificates in the keystore or the &quot;cacerts&quot;
keystore file. If the chain does not end with a self-signed
root CA certificate and the -trustcacerts option was
specified, keytool will try to find one from the trusted
certificates in the keystore or the &quot;cacerts&quot;
keystore file and add it to the end of the chain. If the
certificate is not found and -noprompt option is not
specified, the information of the last certificate in the
chain is printed out, and the user is prompted to verify
it.</p>

<p>If the public key in the certificate reply matches the
users public key already stored with under alias, the old
certificate chain is replaced with the new certificate chain
in the reply. The old chain can only be replaced if a valid
keypass, the password used to pro- tect the private key of
the entry, is supplied. If no password is provided, and the
private key password is different from the key- store
password, the user is prompted for it.</p>

<p>This command was named -import in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
-importcert, is preferred going forward.</p>

<p>-importkeystore -srckeystore srckeystore -destkeystore
destkeystore {-srcstoretype srcstoretype} {-deststoretype
deststoretype} [-src- storepass srcstorepass]
[-deststorepass deststorepass] {-srcpro- tected}
{-destprotected} {-srcalias srcalias {-destalias destalias}
[-srckeypass srckeypass] [-destkeypass destkeypass] }
{-noprompt} {-srcProviderName src_provider_name}
{-destProviderName dest_provider_name} {-providerClass
provider_class_name {-provider- Arg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Imports a single entry or all entries from a source
keystore to a destination keystore.</p>

<p>When the srcalias option is provided, the command
imports the single entry identified by the alias to the
destination keystore. If a des- tination alias is not
provided with destalias, then srcalias is used as the
destination alias. If the source entry is protected by a
password, srckeypass will be used to recover the entry. If
srckey- pass is not provided, then keytool will attempt to
use srcstorepass to recover the entry. If srcstorepass is
either not provided or is incorrect, the user will be
prompted for a password. The destination entry will be
protected using destkeypass. If destkeypass is not provided,
the destination entry will be protected with the source
entry password.</p>

<p>If the srcalias option is not provided, then all entries
in the source keystore are imported into the destination
keystore. Each destination entry will be stored under the
alias from the source entry. If the source entry is
protected by a password, srcstorepass will be used to
recover the entry. If srcstorepass is either not provided or
is incorrect, the user will be prompted for a password. If a
source keystore entry type is not supported in the
destination keystore, or if an error occurs while storing an
entry into the des- tination keystore, the user will be
prompted whether to skip the entry and continue, or to quit.
The destination entry will be pro- tected with the source
entry password.</p>

<p>If the destination alias already exists in the
destination keystore, the user is prompted to either
overwrite the entry, or to create a new entry under a
different alias name.</p>

<p>Note that if -noprompt is provided, the user will not be
prompted for a new destination alias. Existing entries will
automatically be overwritten with the destination alias
name. Finally, entries that can not be imported are
automatically skipped and a warning is out- put.</p>

<p>-printcertreq {-file file}</p>

<p>Prints the content of a PKCS #10 format certificate
request, which can be generated by the keytool -certreq
command. The command reads the request from file; if
omitted, from the standard input.</p>

<p>Exporting Data -certreq {-alias alias} {-dname dname}
{-sigalg sigalg} {-file certreq_file} [-keypass keypass]
{-storetype storetype} {-keystore keystore} [-storepass
storepass] {-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a Certificate Signing Request (CSR), using the
PKCS#10 format.</p>

<p>A CSR is intended to be sent to a certificate authority
(CA). The CA will authenticate the certificate requestor
(usually off-line) and will return a certificate or
certificate chain, used to replace the existing certificate
chain (which initially consists of a self-signed
certificate) in the keystore.</p>

<p>The private key associated with alias is used to create
the PKCS#10 certificate request. In order to access the
private key, the appro- priate password must be provided,
since private keys are protected in the keystore with a
password. If keypass is not provided at the command line,
and is different from the password used to protect the
integrity of the keystore, the user is prompted for it. If
dname is provided, it s used as the subject in the CSR.
Otherwise, the X.500 Distinguished Name associated with
alias is used.</p>

<p>sigalg specifies the algorithm that should be used to
sign the CSR.</p>

<p>The CSR is stored in the file certreq_file. If no file
is given, the CSR is output to stdout.</p>

<p>Use the importcert command to import the response from
the CA.</p>

<p>-exportcert {-alias alias} {-file cert_file} {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-rfc} {-v}
{-protected} {-Jjavaoption}</p>

<p>Reads (from the keystore) the certificate associated
with alias, and stores it in the file cert_file.</p>

<p>If no file is given, the certificate is output to
stdout.</p>

<p>The certificate is by default output in binary encoding,
but will instead be output in the printable encoding format,
as defined by the Internet RFC 1421 standard, if the -rfc
option is specified.</p>

<p>If alias refers to a trusted certificate, that
certificate is out- put. Otherwise, alias refers to a key
entry with an associated cer- tificate chain. In that case,
the first certificate in the chain is returned. This
certificate authenticates the public key of the entity
addressed by alias.</p>

<p>This command was named -export in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
-exportcert, is preferred going forward.</p>

<p>Displaying Data -list {-alias alias} {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v | -rfc}
{-pro- tected} {-Jjavaoption}</p>

<p>Prints (to stdout) the contents of the keystore entry
identified by alias. If no alias is specified, the contents
of the entire keystore are printed.</p>

<p>This command by default prints the SHA1 fingerprint of a
certifi- cate. If the -v option is specified, the
certificate is printed in human-readable format, with
additional information such as the owner, issuer, serial
number, and any extensions. If the -rfc option is specified,
certificate contents are printed using the printable
encoding format, as defined by the Internet RFC 1421
standard</p>

<p>You cannot specify both -v and -rfc.</p>

<p>-printcert {-file cert_file | -sslserver host[:port]}
{-jarfile JAR_file {-rfc} {-v} {-Jjavaoption}</p>

<p>Reads the certificate from the file cert_file, the SSL
server located at host:port, or the signed JAR file JAR_file
(with the option -jarfile and prints its contents in a
human-readable format. When no port is specified, the
standard HTTPS port 443 is assumed. Note that -sslserver and
-file options cannot be provided at the same time.
Otherwise, an error is reported. If neither option is given,
the certificate is read from stdin.</p>

<p>If -rfc is specified, keytool prints the certificate in
PEM mode as defined by the Internet RFC 1421 standard.</p>

<p>If the certificate is read from a file or stdin, it may
be either binary encoded or in printable encoding format, as
defined by the Internet RFC 1421 standard</p>

<p>If the SSL server is behind a firewall,
-J-Dhttps.proxyHost=proxy- host and
-J-Dhttps.proxyPort=proxyport can be specified on the com-
mand line for proxy tunneling. See the JSSE Reference Guide
@
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/jsse/JSSERefGuide.html for more information.</p>

<p>Note: This option can be used independently of a
keystore.</p>

<p>-printcrl -file crl_ {-v}</p>

<p>Reads the certificate revocation list (CRL) from the
file crl_file.</p>

<p>A Certificate Revocation List (CRL) is a list of digital
certifi- cates which have been revoked by the Certificate
Authority (CA) that issued them. The CA generates
crl_file.</p>

<p>Note: This option can be used independently of a
keystore.</p>

<p>Managing the Keystore -storepasswd [-new new_storepass]
{-storetype storetype} {-keystore keystore} [-storepass
storepass] {-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-Jjavaoption}</p>

<p>Changes the password used to protect the integrity of
the keystore contents. The new password is new_storepass,
which must be at least 6 characters long.</p>

<p>-keypasswd {-alias alias} [-keypass old_keypass] [-new
new_keypass] {-storetype storetype} {-keystore keystore}
[-storepass storepass] {-providerName provider_name}
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-Jjavaoption}</p>

<p>Changes the password under which the private/secret key
identified by alias is protected, from old_keypass to
new_keypass, which must be at least 6 characters long.</p>

<p>If the -keypass option is not provided at the command
line, and the key password is different from the keystore
password, the user is prompted for it.</p>

<p>If the -new option is not provided at the command line,
the user is prompted for it.</p>

<p>-delete [-alias alias] {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p>Deletes from the keystore the entry identified by alias.
The user is prompted for the alias, if no alias is provided
at the command line.</p>

<p>-changealias {-alias alias} [-destalias destalias]
[-keypass key- pass] {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p>Move an existing keystore entry from the specified alias
to a new alias, destalias. If no destination alias is
provided, the command will prompt for one. If the original
entry is protected with an entry password, the password can
be supplied via the &quot;-keypass&quot; option. If no key
password is provided, the storepass (if given) will be
attempted first. If that attempt fails, the user will be
prompted for a password.</p>

<p>Getting Help -help</p>

<p>Lists the basic commands and their options.</p>

<p>For more information about a specific command, enter the
following, where command_name is the name of the
command:</p>

<p>keytool -command_name -help</p>

<p>EXAMPLES Suppose you want to create a keystore for
managing your public/private key pair and certificates from
entities you trust.</p>

<p>Generating Your Key Pair The first thing you need to do
is create a keystore and generate the key pair. You could
use a command such as the following:</p>

<p>keytool -genkeypair -dname &quot;cn=Mark Jones, ou=Java,
o=Oracle, c=US&quot; -alias business -keypass &lt;new
password for private key&gt; -keystore /working/mykeystore
-storepass &lt;new password for keystore&gt; -validity
180</p>

<p>(Please note: This must be typed as a single line.
Multiple lines are used in the examples just for legibility
purposes.)</p>

<p>This command creates the keystore named
&quot;mykeystore&quot; in the &quot;working&quot; directory
(assuming it doesnt already exist), and assigns it the pass-
word specified by &lt;new password for keystore&gt;. It
generates a pub- lic/private key pair for the entity whose
&quot;distinguished name&quot; has a common name of
&quot;Mark Jones&quot;, organizational unit of
&quot;Java&quot;, organiza- tion of &quot;Oracle&quot; and
two-letter country code of &quot;US&quot;. It uses the
default &quot;DSA&quot; key generation algorithm to create
the keys, both 1024 bits long.</p>

<p>It creates a self-signed certificate (using the default
&quot;SHA1withDSA&quot; signature algorithm) that includes
the public key and the distinguished name information. This
certificate will be valid for 180 days, and is associated
with the private key in a keystore entry referred to by the
alias &quot;business&quot;. The private key is assigned the
password specified by &lt;new password for private
key&gt;.</p>

<p>The command could be significantly shorter if option
defaults were accepted. As a matter of fact, no options are
required; defaults are used for unspecified options that
have default values, and you are prompted for any required
values. Thus, you could simply have the fol- lowing:</p>

<p>keytool -genkeypair</p>

<p>In this case, a keystore entry with alias
&quot;mykey&quot; is created, with a newly-generated key
pair and a certificate that is valid for 90 days. This entry
is placed in the keystore named &quot;.keystore&quot; in
your home directory. (The keystore is created if it doesn t
already exist.) You will be prompted for the distinguished
name information, the keystore password, and the private key
password.</p>

<p>The rest of the examples assume you executed the
-genkeypair command without options specified, and that you
responded to the prompts with values equal to those given in
the first -genkeypair command, above (for example, a
distinguished name of &quot;cn=Mark Jones, ou=Java, o=Ora-
cle, c=US&quot;).</p>

<p>Requesting a Signed Certificate from a Certification
Authority So far all we ve got is a self-signed certificate.
A certificate is more likely to be trusted by others if it
is signed by a Certification Authority (CA). To get such a
signature, you first generate a Certifi- cate Signing
Request (CSR), via the following:</p>

<p>keytool -certreq -file MarkJ.csr</p>

<p>This creates a CSR (for the entity identified by the
default alias &quot;mykey&quot;) and puts the request in the
file named &quot;MarkJ.csr&quot;. Submit this file to a CA,
such as VeriSign, Inc. The CA will authenticate you, the
requestor (usually off-line), and then will return a
certificate, signed by them, authenticating your public key.
(In some cases, they will actually return a chain of
certificates, each one authenticating the public key of the
signer of the previous certificate in the chain.)</p>

<p>Importing a Certificate for the CA You need to replace
your self-signed certificate with a certificate chain, where
each certificate in the chain authenticates the public key
of the signer of the previous certificate in the chain, up
to a &quot;root&quot; CA.</p>

<p>Before you import the certificate reply from a CA, you
need one or more &quot;trusted certificates&quot; in your
keystore or in the cacerts keystore file (which is described
in importcert command):</p>

<p>o If the certificate reply is a certificate chain, you
just need the top certificate of the chain (that is, the
&quot;root&quot; CA certificate authenticating that CAs
public key).</p>

<p>o If the certificate reply is a single certificate, you
need a cer- tificate for the issuing CA (the one that signed
it), and if that certificate is not self-signed, you need a
certificate for its signer, and so on, up to a self-signed
&quot;root&quot; CA certificate.</p>

<p>The &quot;cacerts&quot; keystore file ships with several
VeriSign root CA cer- tificates, so you probably wont need
to import a VeriSign certificate as a trusted certificate in
your keystore. But if you request a signed certificate from
a different CA, and a certificate authenticating that CAs
public key hasnt been added to &quot;cacerts&quot;, you will
need to import a certificate from the CA as a &quot;trusted
certificate&quot;.</p>

<p>A certificate from a CA is usually either self-signed,
or signed by another CA (in which case you also need a
certificate authenticating that CAs public key). Suppose
company ABC, Inc., is a CA, and you obtain a file named
&quot;ABCCA.cer&quot; that is purportedly a self-signed cer-
tificate from ABC, authenticating that CAs public key.</p>

<p>Be very careful to ensure the certificate is valid prior
to importing it as a &quot;trusted&quot; certificate! View
it first (using the keytool -print- cert command, or the
keytool -importcert command without the -noprompt option),
and make sure that the displayed certificate fingerprint(s)
match the expected ones. You can call the person who sent
the certifi- cate, and compare the fingerprint(s) that you
see with the ones that they show (or that a secure public
key repository shows). Only if the fingerprints are equal is
it guaranteed that the certificate has not been replaced in
transit with somebody elses (for example, an attackers)
certificate. If such an attack took place, and you did not
check the certificate before you imported it, you would end
up trusting anything the attacker has signed.</p>

<p>If you trust that the certificate is valid, then you can
add it to your keystore via the following:</p>

<p>keytool -importcert -alias abc -file ABCCA.cer</p>

<p>This creates a &quot;trusted certificate&quot; entry in
the keystore, with the data from the file
&quot;ABCCA.cer&quot;, and assigns the alias &quot;abc&quot;
to the entry.</p>

<p>Importing the Certificate Reply from the CA Once you ve
imported a certificate authenticating the public key of the
CA you submitted your certificate signing request to (or
there is already such a certificate in the
&quot;cacerts&quot; file), you can import the certificate
reply and thereby replace your self-signed certificate with
a certificate chain. This chain is the one returned by the
CA in response to your request (if the CA reply is a chain),
or one con- structed (if the CA reply is a single
certificate) using the certifi- cate reply and trusted
certificates that are already available in the keystore
where you import the reply or in the &quot;cacerts&quot;
keystore file.</p>

<p>For example, suppose you sent your certificate signing
request to VeriSign. You can then import the reply via the
following, which assumes the returned certificate is named
&quot;VSMarkJ.cer&quot;:</p>

<p>keytool -importcert -trustcacerts -file VSMarkJ.cer</p>

<p>Exporting a Certificate Authenticating Your Public Key
Suppose you have used the jarsigner(1) tool to sign a Java
ARchive (JAR) file. Clients that want to use the file will
want to authenticate your signature.</p>

<p>One way they can do this is by first importing your
public key certifi- cate into their keystore as a
&quot;trusted&quot; entry. You can export the cer- tificate
and supply it to your clients. As an example, you can copy
your certificate to a file named MJ.cer via the following,
assuming the entry is aliased by &quot;mykey&quot;:</p>

<p>keytool -exportcert -alias mykey -file MJ.cer</p>

<p>Given that certificate, and the signed JAR file, a
client can use the jarsigner tool to authenticate your
signature.</p>

<p>Importing Keystore The command
&quot;importkeystore&quot; is used to import an entire
keystore into another keystore, which means all entries from
the source keystore, including keys and certificates, are
all imported to the destination keystore within a single
command. You can use this command to import entries from a
different type of keystore. During the import, all new
entries in the destination keystore will have the same alias
names and protection passwords (for secret keys and private
keys). If keytool has difficulties recover the private keys
or secret keys from the source keystore, it will prompt you
for a password. If it detects alias dupli- cation, it will
ask you for a new one, you can specify a new alias or simply
allow keytool to overwrite the existing one.</p>

<p>For example, to import entries from a normal JKS type
keystore key.jks into a PKCS #11 type hardware based
keystore, you can use the command:</p>

<p>keytool -importkeystore -srckeystore key.jks
-destkeystore NONE -srcstoretype JKS -deststoretype PKCS11
-srcstorepass &lt;source keystore password&gt;
-deststorepass &lt;destination keystore password&gt;</p>

<p>The importkeystore command can also be used to import a
single entry from a source keystore to a destination
keystore. In this case, besides the options you see in the
above example, you need to specify the alias you want to
import. With the srcalias option given, you can also spec-
ify the destination alias name in the command line, as well
as protec- tion password for a secret/private key and the
destination protection password you want. The following
command demonstrates this:</p>

<p>keytool -importkeystore -srckeystore key.jks
-destkeystore NONE -srcstoretype JKS -deststoretype PKCS11
-srcstorepass &lt;source keystore password&gt;
-deststorepass &lt;destination keystore password&gt;
-srcalias myprivatekey -destalias myoldprivatekey
-srckeypass &lt;source entry password&gt; -destkeypass
&lt;destination entry password&gt; -noprompt</p>

<p>Generating Certificates for a Typical SSL Server The
following are keytool commands to generate keypairs and
certifi- cates for three entities, namely, Root CA (root),
Intermediate CA (ca), and SSL server (server). Ensure that
you store all the certificates in the same keystore. In
these examples, it is recommended that you spec- ify RSA as
the key algorithm.</p>

<p>keytool -genkeypair -keystore root.jks -alias root -ext
bc:c keytool -genkeypair -keystore ca.jks -alias ca -ext
bc:c keytool -genkeypair -keystore server.jks -alias
server</p>

<p>keytool -keystore root.jks -alias root -exportcert -rfc
&gt; root.pem</p>

<p>keytool -storepass &lt;storepass&gt; -keystore ca.jks
-certreq -alias ca | keytool -storepass &lt;storepass&gt;
-keystore root.jks -gencert -alias root -ext BC=0 -rfc &gt;
ca.pem keytool -keystore ca.jks -importcert -alias ca -file
ca.pem</p>

<p>keytool -storepass &lt;storepass&gt; -keystore
server.jks -certreq -alias server | keytool -storepass
&lt;storepass&gt; -keystore ca.jks -gencert -alias ca -ext
ku:c=dig,kE -rfc &gt; server.pem cat root.pem ca.pem
server.pem | keytool -keystore server.jks -importcert -alias
server</p>

<p>TERMINOLOGY and WARNINGS KeyStore A keystore is a
storage facility for cryptographic keys and certifi-
cates.</p>

<p>o KeyStore Entries</p>

<p>Keystores may have different types of entries. The two
most applica- ble entry types for keytool include:</p>

<p>1. key entries - each holds very sensitive cryptographic
key information, which is stored in a protected format to
prevent unauthorized access. Typically, a key stored in this
type of entry is a secret key, or a private key accompanied
by the certificate &quot;chain&quot; for the corresponding
public key. The key- tool can handle both types of entries,
while the jarsigner tool only handle the latter type of
entry, that is private keys and their associated certificate
chains.</p>

<p>2. trusted certificate entries - each contains a single
public key certificate belonging to another party. It is
called a &quot;trusted certificate&quot; because the
keystore owner trusts that the public key in the certificate
indeed belongs to the iden- tity identified by the
&quot;subject&quot; (owner) of the certificate. The issuer
of the certificate vouches for this, by signing the
certificate.</p>

<p>o KeyStore Aliases</p>

<p>All keystore entries (key and trusted certificate
entries) are accessed via unique aliases.</p>

<p>An alias is specified when you add an entity to the
keystore using the -genseckey command to generate a secret
key, -genkeypair command to generate a key pair (public and
private key) or the -importcert command to add a certificate
or certificate chain to the list of trusted certificates.
Subsequent keytool commands must use this same alias to
refer to the entity.</p>

<p>For example, suppose you use the alias duke to generate
a new pub- lic/private key pair and wrap the public key into
a self-signed cer- tificate (see Certificate Chains) via the
following command:</p>

<p>keytool -genkeypair -alias duke -keypass
dukekeypasswd</p>

<p>This specifies an initial password of
&quot;dukekeypasswd&quot; required by subsequent commands to
access the private key associated with the alias duke. If
you later want to change duke s private key password, you
use a command like the following:</p>

<p>keytool -keypasswd -alias duke -keypass dukekeypasswd
-new newpass</p>

<p>This changes the password from &quot;dukekeypasswd&quot;
to &quot;newpass&quot;.</p>

<p>Please note: A password should not actually be specified
on a com- mand line or in a script unless it is for testing
purposes, or you are on a secure system. If you dont specify
a required password option on a command line, you will be
prompted for it.</p>

<p>o KeyStore Implementation</p>

<p>The KeyStore class provided in the java.security package
supplies well-defined interfaces to access and modify the
information in a keystore. It is possible for there to be
multiple different concrete implementations, where each
implementation is that for a particular type of
keystore.</p>

<p>Currently, two command-line tools (keytool and
jarsigner) and a GUI-based tool named Policy Tool make use
of keystore implementa- tions. Since KeyStore is publicly
available, users can write addi- tional security
applications that use it.</p>

<p>There is a built-in default implementation, provided by
Oracle. It implements the keystore as a file, utilizing a
proprietary keystore type (format) named &quot;JKS&quot;. It
protects each private key with its individual password, and
also protects the integrity of the entire keystore with a
(possibly different) password.</p>

<p>Keystore implementations are provider-based. More
specifically, the application interfaces supplied by
KeyStore are implemented in terms of a &quot;Service
Provider Interface&quot; (SPI). That is, there is a corre-
sponding abstract KeystoreSpi class, also in the
java.security pack- age, which defines the Service Provider
Interface methods that &quot;providers&quot; must implement.
(The term &quot;provider&quot; refers to a package or a set
of packages that supply a concrete implementation of a sub-
set of services that can be accessed by the Java Security
API.) Thus, to provide a keystore implementation, clients
must implement a &quot;provider&quot; and supply a
KeystoreSpi subclass implementation, as described in How to
Implement a Provider for the Java Cryptography Architecture
@
http://docs.oracle.com/javase/7/docs/technotes/guides/secu-
rity/crypto/HowToImplAProvider.html.</p>

<p>Applications can choose different types of keystore
implementations from different providers, using the
&quot;getInstance&quot; factory method supplied in the
KeyStore class. A keystore type defines the storage and data
format of the keystore information, and the algorithms used
to protect private/secret keys in the keystore and the
integrity of the keystore itself. Keystore implementations
of different types are not compatible.</p>

<p>keytool works on any file-based keystore implementation.
(It treats the keystore location that is passed to it at the
command line as a filename and converts it to a
FileInputStream, from which it loads the keystore
information.) The jarsigner and policytool tools, on the
other hand, can read a keystore from any location that can
be specified using a URL.</p>

<p>For keytool and jarsigner, you can specify a keystore
type at the command line, via the -storetype option. For
Policy Tool, you can specify a keystore type via the
&quot;Keystore&quot; menu.</p>

<p>If you don t explicitly specify a keystore type, the
tools choose a keystore implementation based simply on the
value of the key- store.type property specified in the
security properties file. The security properties file is
called java.security, and it resides in the security
properties directory, java.home/lib/security, where
java.home is the runtime environment s directory (the jre
directory in the SDK or the top-level directory of the Java
2 Runtime Environ- ment).</p>

<p>Each tool gets the keystore.type value and then examines
all the currently-installed providers until it finds one
that implements keystores of that type. It then uses the
keystore implementation from that provider.</p>

<p>The KeyStore class defines a static method named
getDefaultType that lets applications and applets retrieve
the value of the key- store.type property. The following
line of code creates an instance of the default keystore
type (as specified in the keystore.type property):</p>

<p>KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p>The default keystore type is &quot;jks&quot; (the
proprietary type of the key- store implementation provided
by Oracle). This is specified by the following line in the
security properties file:</p>

<p>keystore.type=jks</p>

<p>To have the tools utilize a keystore implementation
other than the default, you can change that line to specify
a different keystore type.</p>

<p>For example, if you have a provider package that
supplies a keystore implementation for a keystore type
called &quot;pkcs12&quot;, change the line to</p>

<p>keystore.type=pkcs12</p>

<p>Note: case doesnt matter in keystore type designations.
For exam- ple, &quot;JKS&quot; would be considered the same
as &quot;jks&quot;.</p>

<p>Certificate A certificate (also known as a public-key
certificate) is a digitally signed statement from one entity
(the issuer), saying that the public key (and some other
information) of another entity (the subject) has some
specific value.</p>

<p>o Certificate Terms</p>

<p>Public Keys</p>

<p>These are numbers associated with a particular entity,
and are intended to be known to everyone who needs to have
trusted inter- actions with that entity. Public keys are
used to verify signa- tures.</p>

<p>Digitally Signed</p>

<p>If some data is digitally signed it has been stored with
the &quot;identity&quot; of an entity, and a signature that
proves that entity knows about the data. The data is
rendered unforgeable by signing with the entitys private
key.</p>

<p>Identity</p>

<p>A known way of addressing an entity. In some systems the
identity is the public key, in others it can be anything
from a Unix UID to an Email address to an X.509
Distinguished Name.</p>

<p>Signature</p>

<p>A signature is computed over some data using the private
key of an entity (the signer, which in the case of a
certificate is also known as the issuer).</p>

<p>Private Keys</p>

<p>These are numbers, each of which is supposed to be known
only to the particular entity whose private key it is (that
is, its sup- posed to be kept secret). Private and public
keys exist in pairs in all public key cryptography systems
(also referred to as &quot;pub- lic key crypto
systems&quot;). In a typical public key crypto system, such
as DSA, a private key corresponds to exactly one public key.
Private keys are used to compute signatures.</p>

<p>Entity</p>

<p>An entity is a person, organization, program, computer,
business, bank, or something else you are trusting to some
degree.</p>

<p>Basically, public key cryptography requires access to
users public keys. In a large-scale networked environment it
is impossible to guarantee that prior relationships between
communicating entities have been established or that a
trusted repository exists with all used public keys.
Certificates were invented as a solution to this public key
distribution problem. Now a Certification Authority (CA) can
act as a trusted third party. CAs are entities (for example,
businesses) that are trusted to sign (issue) certificates
for other entities. It is assumed that CAs will only create
valid and reliable certificates, as they are bound by legal
agreements. There are many public Certification Authorities,
such as VeriSign @ http://www.verisign.com/, Thawte @
http://www.thawte.com/, Entrust @ http://www.entrust.com/,
and so on. You can also run your own Certi- fication
Authority using products such as Microsoft Certificate
Server or the Entrust CA product for your organization.</p>

<p>Using keytool, it is possible to display, import, and
export cer- tificates. It is also possible to generate
self-signed certificates.</p>

<p>keytool currently handles X.509 certificates.</p>

<p>o X.509 Certificates</p>

<p>The X.509 standard defines what information can go into
a certifi- cate, and describes how to write it down (the
data format). All the data in a certificate is encoded using
two related standards called ASN.1/DER. Abstract Syntax
Notation 1 describes data. The Definite Encoding Rules
describe a single way to store and transfer that data.</p>

<p>All X.509 certificates have the following data, in
addition to the signature:</p>

<p>Version</p>

<p>This identifies which version of the X.509 standard
applies to this certificate, which affects what information
can be specified in it. Thus far, three versions are
defined. keytool can import and export v1, v2, and v3
certificates. It generates v3 certifi- cates.</p>

<p>X.509 Version 1 has been available since 1988, is widely
deployed, and is the most generic.</p>

<p>X.509 Version 2 introduced the concept of subject and
issuer unique identifiers to handle the possibility of reuse
of subject and/or issuer names over time. Most certificate
profile documents strongly recommend that names not be
reused, and that certifi- cates should not make use of
unique identifiers. Version 2 cer- tificates are not widely
used.</p>

<p>X.509 Version 3 is the most recent (1996) and supports
the notion of extensions, whereby anyone can define an
extension and include it in the certificate. Some common
extensions in use today are: KeyUsage (limits the use of the
keys to particular purposes such as
&quot;signing-only&quot;) and AlternativeNames (allows other
identities to also be associated with this public key, e.g.
DNS names, Email addresses, IP addresses). Extensions can be
marked critical to indicate that the extension should be
checked and enforced/used. For example, if a certificate has
the KeyUsage extension marked critical and set to
&quot;keyCertSign&quot; then if this certificate is
presented during SSL communication, it should be rejected,
as the certificate extension indicates that the associated
private key should only be used for signing certificates and
not for SSL use.</p>

<p>Serial Number</p>

<p>The entity that created the certificate is responsible
for assigning it a serial number to distinguish it from
other cer- tificates it issues. This information is used in
numerous ways, for example when a certificate is revoked its
serial number is placed in a Certificate Revocation List
(CRL).</p>

<p>Signature Algorithm Identifier</p>

<p>This identifies the algorithm used by the CA to sign the
certifi- cate.</p>

<p>Issuer Name</p>

<p>The X.500 Distinguished Name of the entity that signed
the cer- tificate. This is normally a CA. Using this
certificate implies trusting the entity that signed this
certificate. (Note that in some cases, such as root or
top-level CA certificates, the issuer signs its own
certificate.)</p>

<p>Validity Period</p>

<p>Each certificate is valid only for a limited amount of
time. This period is described by a start date and time and
an end date and time, and can be as short as a few seconds
or almost as long as a century. The validity period chosen
depends on a number of fac- tors, such as the strength of
the private key used to sign the certificate or the amount
one is willing to pay for a certifi- cate. This is the
expected period that entities can rely on the public value,
if the associated private key has not been compro-
mised.</p>

<p>Subject Name</p>

<p>The name of the entity whose public key the certificate
identi- fies. This name uses the X.500 standard, so it is
intended to be unique across the Internet. This is the X.500
Distinguished Name (DN) of the entity, for example,</p>

<p>CN=Java Duke, OU=Java Software Division, O=Oracle
Corporation, C=US</p>

<p>(These refer to the subject s Common Name,
Organizational Unit, Organization, and Country.)</p>

<p>Subject Public Key Information</p>

<p>This is the public key of the entity being named,
together with an algorithm identifier which specifies which
public key crypto system this key belongs to and any
associated key parameters.</p>

<p>o Certificate Chains</p>

<p>keytool can create and manage keystore &quot;key&quot;
entries that each con- tain a private key and an associated
certificate &quot;chain&quot;. The first certificate in the
chain contains the public key corresponding to the private
key.</p>

<p>When keys are first generated (see the -genkeypair
command), the chain starts off containing a single element,
a self-signed certifi- cate. A self-signed certificate is
one for which the issuer (signer) is the same as the subject
(the entity whose public key is being authenticated by the
certificate). Whenever the -genkeypair command is called to
generate a new public/private key pair, it also wraps the
public key into a self-signed certificate.</p>

<p>Later, after a Certificate Signing Request (CSR) has
been generated (see the -certreq command) and sent to a
Certification Authority (CA), the response from the CA is
imported (see -importcert), and the self-signed certificate
is replaced by a chain of certificates. At the bottom of the
chain is the certificate (reply) issued by the CA
authenticating the subjects public key. The next certificate
in the chain is one that authenticates the CAs public
key.</p>

<p>In many cases, this is a self-signed certificate (that
is, a cer- tificate from the CA authenticating its own
public key) and the last certificate in the chain. In other
cases, the CA may return a chain of certificates. In this
case, the bottom certificate in the chain is the same (a
certificate signed by the CA, authenticating the pub- lic
key of the key entry), but the second certificate in the
chain is a certificate signed by a different CA,
authenticating the public key of the CA you sent the CSR to.
Then, the next certificate in the chain will be a
certificate authenticating the second CAs key, and so on,
until a self-signed &quot;root&quot; certificate is reached.
Each cer- tificate in the chain (after the first) thus
authenticates the pub- lic key of the signer of the previous
certificate in the chain.</p>

<p>Many CAs only return the issued certificate, with no
supporting chain, especially when there is a flat hierarchy
(no intermediates CAs). In this case, the certificate chain
must be established from trusted certificate information
already stored in the keystore.</p>

<p>A different reply format (defined by the PKCS#7
standard) also includes the supporting certificate chain, in
addition to the issued certificate. Both reply formats can
be handled by keytool.</p>

<p>The top-level (root) CA certificate is self-signed.
However, the trust into the roots public key does not come
from the root cer- tificate itself (anybody could generate a
self-signed certificate with the distinguished name of say,
the VeriSign root CA!), but from other sources like a
newspaper. The root CA public key is widely known. The only
reason it is stored in a certificate is because this is the
format understood by most tools, so the certificate in this
case is only used as a &quot;vehicle&quot; to transport the
root CAs public key. Before you add the root CA certificate
to your keystore, you should view it (using the -printcert
option) and compare the dis- played fingerprint with the
well-known fingerprint (obtained from a newspaper, the root
CAs Web page, etc.).</p>

<p>o The cacerts Certificates File</p>

<p>A certificates file named &quot;cacerts&quot; resides in
the security proper- ties directory, java.home/lib/security,
where java.home is the run- time environments directory (the
jre directory in the SDK or the top-level directory of the
Java 2 Runtime Environment).</p>

<p>The &quot;cacerts&quot; file represents a system-wide
keystore with CA cer- tificates. System administrators can
configure and manage that file using keytool, specifying
&quot;jks&quot; as the keystore type. The
&quot;cacerts&quot; keystore file ships with a default set
of root CA certificates; list them with the following
command:</p>

<p>keytool -list -keystore
java.home/lib/security/cacerts</p>

<p>The initial password of the &quot;cacerts&quot; keystore
file is &quot;changeit&quot;. System administrators should
change that password and the default access permission of
that file upon installing the SDK.</p>

<p>IMPORTANT: Verify Your cacerts File: Since you trust the
CAs in the cacerts file as entities for signing and issuing
certificates to other entities, you must manage the cacerts
file carefully. The cac- erts file should contain only
certificates of the CAs you trust. It is your responsibility
to verify the trusted root CA certificates bundled in the
cacerts file and make your own trust decisions. To remove an
untrusted CA certificate from the cacerts file, use the
delete option of the keytool command. You can find the
cacerts file in the JRE installation directory. Contact your
system administrator if you do not have permission to edit
this file.</p>

<p>o The Internet RFC 1421 Certificate Encoding
Standard</p>

<p>Certificates are often stored using the printable
encoding format defined by the Internet RFC 1421 standard,
instead of their binary encoding. This certificate format,
also known as &quot;Base 64 encoding&quot;, facilitates
exporting certificates to other applications by email or
through some other mechanism.</p>

<p>Certificates read by the -importcert and -printcert
commands can be in either this format or binary encoded.</p>

<p>The -exportcert command by default outputs a certificate
in binary encoding, but will instead output a certificate in
the printable encoding format, if the -rfc option is
specified.</p>

<p>The -list command by default prints the SHA1 fingerprint
of a cer- tificate. If the -v option is specified, the
certificate is printed in human-readable format, while if
the -rfc option is specified, the certificate is output in
the printable encoding format.</p>

<p>In its printable encoding format, the encoded
certificate is bounded at the beginning by</p>

<p>-----BEGIN CERTIFICATE-----</p>

<p>and at the end by</p>

<p>-----END CERTIFICATE-----</p>

<p>X.500 Distinguished Names X.500 Distinguished Names are
used to identify entities, such as those which are named by
the subject and issuer (signer) fields of X.509 cer-
tificates. keytool supports the following subparts:</p>

<p>o commonName - common name of a person, e.g.,
&quot;Susan Jones&quot;</p>

<p>o organizationUnit - small organization (e.g.,
department or divi- sion) name, e.g.,
&quot;Purchasing&quot;</p>

<p>o organizationName - large organization name, e.g.,
&quot;ABCSystems, Inc.&quot;</p>

<p>o localityName - locality (city) name, e.g., &quot;Palo
Alto&quot;</p>

<p>o stateName - state or province name, e.g.,
&quot;California&quot;</p>

<p>o country - two-letter country code, e.g.,
&quot;CH&quot;</p>

<p>When supplying a distinguished name string as the value
of a -dname option, as for the -genkeypair command, the
string must be in the fol- lowing format:</p>

<p>CN=cName, OU=orgUnit, O=org, L=city, S=state,
C=countryCode</p>

<p>where all the italicized items represent actual values
and the above keywords are abbreviations for the
following:</p>

<p>CN=commonName OU=organizationUnit O=organizationName
L=localityName S=stateName C=country</p>

<p>A sample distinguished name string is</p>

<p>CN=Mark Smith, OU=Java, O=Oracle, L=Cupertino,
S=California, C=US</p>

<p>and a sample command using such a string is</p>

<p>keytool -genkeypair -dname &quot;CN=Mark Smith, OU=Java,
O=Oracle, L=Cupertino, S=California, C=US&quot; -alias
mark</p>

<p>Case does not matter for the keyword abbreviations. For
example, &quot;CN&quot;, &quot;cn&quot;, and &quot;Cn&quot;
are all treated the same.</p>

<p>Order matters; each subcomponent must appear in the
designated order. However, it is not necessary to have all
the subcomponents. You may use a subset, for example:</p>

<p>CN=Steve Meier, OU=Java, O=Oracle, C=US</p>

<p>If a distinguished name string value contains a comma,
the comma must be escaped by a &quot; line, as in</p>

<p>cn=Peter Schuster, ou=Jav, Product Development,
o=Oracle, c=US</p>

<p>It is never necessary to specify a distinguished name
string on a com- mand line. If it is needed for a command,
but not supplied on the com- mand line, the user is prompted
for each of the subcomponents. In this case, a comma does
not need to be escaped by a &quot;</p>

<p>WARNING Regarding Importing Trusted Certificates
IMPORTANT: Be sure to check a certificate very carefully
before import- ing it as a trusted certificate!</p>

<p>View it first (using the -printcert command, or the
-importcert command without the -noprompt option), and make
sure that the displayed cer- tificate fingerprint(s) match
the expected ones. For example, suppose someone sends or
emails you a certificate, and you put it in a file named
/tmp/cert. Before you consider adding the certificate to
your list of trusted certificates, you can execute a
-printcert command to view its fingerprints, as in</p>

<p>keytool -printcert -file /tmp/cert Owner: CN=ll, OU=ll,
O=ll, L=ll, S=ll, C=ll Issuer: CN=ll, OU=ll, O=ll, L=ll,
S=ll, C=ll Serial Number: 59092b34 Valid from: Thu Sep 25
18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints: MD5:
11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F SHA1:
20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
SHA256: 90:7B:70:0A:EA:DC:16:79:92:99:41:FF:8A:FE:EB:90:
17:75:E0:90:B2:24:4D:3A:2A:16:A6:E4:11:0F:67:A4</p>

<p>Then call or otherwise contact the person who sent the
certificate, and compare the fingerprint(s) that you see
with the ones that they show. Only if the fingerprints are
equal is it guaranteed that the certifi- cate has not been
replaced in transit with somebody else s (for exam- ple, an
attacker s) certificate. If such an attack took place, and
you did not check the certificate before you imported it,
you would end up trusting anything the attacker has signed
(for example, a JAR file with malicious class files
inside).</p>

<p>Note: it is not required that you execute a -printcert
command prior to importing a certificate, since before
adding a certificate to the list of trusted certificates in
the keystore, the -importcert command prints out the
certificate information and prompts you to verify it. You
then have the option of aborting the import operation. Note,
however, this is only the case if you invoke the -importcert
command without the -noprompt option. If the -noprompt
option is given, there is no inter- action with the
user.</p>

<p>Warning Regarding Passwords Most commands operating on a
keystore require the store password. Some commands require a
private/secret key password.</p>

<p>Passwords can be specified on the command line (in the
-storepass and -keypass options, respectively). However, a
password should not be specified on a command line or in a
script unless it is for testing purposes, or you are on a
secure system.</p>

<p>If you don t specify a required password option on a
command line, you will be prompted for it.</p>

<p>Warning Regarding Certificate Conformance The Internet
standard RFC 5280 @ http://tools.ietf.org/rfc/rfc5280.txt
has defined a profile on conform- ing X.509 certificates,
which includes what values and value combina- tions are
valid for certificate fields and extensions. keytool has not
enforced all these rules so it can generate certificates
which do not conform to the standard, and these certificates
might be rejected by JRE or other applications. Users should
make sure that they provide the correct options for -dname,
-ext, etc.</p>

<p>SEE ALSO o jar(1) tool documentation</p>

<p>o jarsigner(1) tool documentation</p>

<p>o the Security @
http://docs.oracle.com/javase/tutorial/security/index.html
trail of the Java Tutorial @
http://docs.oracle.com/javase/tutorial/ for examples of the
use of keytool</p>

<p>CHANGES The command interface for keytool changed in
Java SE 6.</p>

<p>keytool no longer displays password input when entered
by users. Since password input can no longer be viewed when
entered, users will be prompted to re-enter passwords any
time a password is being set or changed (for example, when
setting the initial keystore password, or when changing a
key password).</p>

<p>Some commands have simply been renamed, and other
commands deemed obso- lete are no longer listed in this
document. All previous commands (both renamed and obsolete)
are still supported in this release and will con- tinue to
be supported in future releases. The following summarizes
all of the changes made to the keytool command
interface:</p>

<p>Renamed commands:</p>

<p>o -export, renamed to -exportcert</p>

<p>o -genkey, renamed to -genkeypair</p>

<p>o -import, renamed to -importcert</p>

<p>Commands deemed obsolete and no longer documented:</p>

<p>o -keyclone @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/key-
tool.html#keycloneCmd</p>

<p>o -identitydb @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/key-
tool.html#identitydbCmd</p>

<p>o -selfcert @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/key-
tool.html#selfcertCmd</p>

<p>16 Mar 2012 keytool(1)</p>
<hr>
</body>
</html>
