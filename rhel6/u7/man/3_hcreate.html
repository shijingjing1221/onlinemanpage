<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:18:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>HSEARCH(3) Linux Programmer s Manual HSEARCH(3)</p>

<p>NAME hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r,
hsearch_r - hash ta- ble management</p>

<p>SYNOPSIS #include &lt;search.h&gt;</p>

<p>int hcreate(size_t nel);</p>

<p>ENTRY *hsearch(ENTRY item, ACTION action);</p>

<p>void hdestroy(void);</p>

<p>#define _GNU_SOURCE #include &lt;search.h&gt;</p>

<p>int hcreate_r(size_t nel, struct hsearch_data
*htab);</p>

<p>int hsearch_r(ENTRY item, ACTION action, ENTRY **retval,
struct hsearch_data *htab);</p>

<p>void hdestroy_r(struct hsearch_data *htab);</p>

<p>DESCRIPTION The three functions hcreate(), hsearch(),
and hdestroy() allow the caller to create and manage a hash
search table containing entries con- sisting of a key (a
string) and associated data. Using these func- tions, only
one hash table can be used at a time.</p>

<p>The three functions hcreate_r(), hsearch_r(),
hdestroy_r() are reen- trant versions that allow a program
to use more than one hash search table at the same time. The
last argument, htab, points to a structure that describes
the table on which the function is to operate. The pro-
grammer should treat this structure as opaque (i.e., do not
attempt to directly access or modify the fields in this
structure).</p>

<p>First a hash table must be created using hcreate(). The
argument nel specifies the maximum number of entries in the
table. (This maximum cannot be changed later, so choose it
wisely.) The implementation may adjust this value upward to
improve the performance of the resulting hash table.</p>

<p>The hcreate_r() function performs the same task as
hcreate(), but for the table described by the structure
*htab. The structure pointed to by htab must be zeroed
before the first call to hcreate_r().</p>

<p>The function hdestroy() frees the memory occupied by the
hash table that was created by hcreate(). After calling
hdestroy() a new hash ta- ble can be created using
hcreate(). The hdestroy_r() function performs the analogous
task for a hash table described by *htab, which was pre-
viously created using hcreate_r().</p>

<p>The hsearch() function searches the hash table for an
item with the same key as item (where &quot;the same&quot;
is determined using strcmp(3)), and if successful returns a
pointer to it.</p>

<p>The argument item is of type ENTRY, which is defined in
&lt;search.h&gt; as follows:</p>

<p>typedef struct entry { char *key; void *data; }
ENTRY;</p>

<p>The field key points to a null-terminated string which
is the search key. The field data points to data that is
associated with that key.</p>

<p>The argument action determines what hsearch() does after
an unsuccess- ful search. This argument must either have the
value ENTER, meaning insert a copy of item (and return a
pointer to the new hash table entry as the function result),
or the value FIND, meaning that NULL should be returned. (If
action is FIND, then data is ignored.)</p>

<p>The hsearch_r() function is like hsearch() but operates
on the hash ta- ble described by *htab. The hsearch_r()
function differs from hsearch() in that a pointer to the
found item is returned in *retval, rather than as the
function result.</p>

<p>RETURN VALUE hcreate() and hcreate_r() return non-zero
on success. They return 0 on error.</p>

<p>On success, hsearch() returns a pointer to an entry in
the hash table. hsearch() returns NULL on error, that is, if
action is ENTER and the hash table is full, or action is
FIND and item cannot be found in the hash table. hsearch_r()
returns non-zero on success, and 0 on error.</p>

<p>ERRORS hcreate() and hcreate_r() can fail for the
following reasons:</p>

<p>EINVAL (hcreate_r()) htab is NULL.</p>

<p>ENOMEM Table full with action set to ENTER.</p>

<p>ESRCH The action argument is FIND and no corresponding
element is found in the table.</p>

<p>hsearch() and hsearch_r() can fail for the following
reasons:</p>

<p>ENOMEM action was ENTER, key was not found in the table,
and there was no room in the table to add a new entry.</p>

<p>ESRCH action was FIND, and key was not found in the
table.</p>

<p>POSIX.1-2001 only specifies the ENOMEM error.</p>

<p>CONFORMING TO The functions hcreate(), hsearch(), and
hdestroy() are from SVr4, and are described in POSIX.1-2001.
The functions hcreate_r(), hsearch_r(), and hdestroy_r() are
GNU extensions.</p>

<p>NOTES Hash table implementations are usually more
efficient when the table contains enough free space to
minimize collisions. Typically, this means that nel should
be at least 25% larger than the maximum number of elements
that the caller expects to store in the table.</p>

<p>The hdestroy() and hdestroy_r() functions do not free
the buffers pointed to by the key and data elements of the
hash table entries. (It can t do this because it doesnt know
whether these buffers were allo- cated dynamically.) If
these buffers need to be freed (perhaps because the program
is repeatedly creating and destroying hash tables, rather
than creating a single table whose lifetime matches that of
the pro- gram), then the program must maintain bookkeeping
data structures that allow it to free them.</p>

<p>BUGS SVr4 and POSIX.1-2001 specify that action is
significant only for unsuccessful searches, so that an ENTER
should not do anything for a successful search. In libc and
glibc (before version 2.3), the imple- mentation violates
the specification, updating the data for the given key in
this case.</p>

<p>Individual hash table entries can be added, but not
deleted.</p>

<p>EXAMPLE The following program inserts 24 items into a
hash table, then prints some of them.</p>

<p>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;
#include &lt;search.h&gt;</p>

<p>char *data[] = { &quot;alpha&quot;, &quot;bravo&quot;,
&quot;charlie&quot;, &quot;delta&quot;, &quot;echo&quot;,
&quot;foxtrot&quot;, &quot;golf&quot;, &quot;hotel&quot;,
&quot;india&quot;, &quot;juliet&quot;, &quot;kilo&quot;,
&quot;lima&quot;, &quot;mike&quot;, &quot;november&quot;,
&quot;oscar&quot;, &quot;papa&quot;, &quot;quebec&quot;,
&quot;romeo&quot;, &quot;sierra&quot;, &quot;tango&quot;,
&quot;uniform&quot;, &quot;victor&quot;, &quot;whisky&quot;,
&quot;x-ray&quot;, &quot;yankee&quot;, &quot;zulu&quot;
};</p>

<p>int main(void) { ENTRY e, *ep; int i;</p>

<p>hcreate(30);</p>

<p>for (i = 0; i &lt; 24; i++) { e.key = data[i]; /* data
is just an integer, instead of a pointer to something */
e.data = (void *) i; ep = hsearch(e, ENTER); /* there should
be no failures */ if (ep == NULL) { fprintf(stderr,
&quot;entry failed0); exit(EXIT_FAILURE); } }</p>

<p>for (i = 22; i &lt; 26; i++) { /* print two entries from
the table, and show that two are not in the table */ e.key =
data[i]; ep = hsearch(e, FIND); printf(&quot;%9.9s -&gt;
%9.9s:%d0, e.key, ep ? ep-&gt;key : &quot;NULL&quot;, ep ?
(int)(ep-&gt;data) : 0); } hdestroy(); exit(EXIT_SUCCESS);
}</p>

<p>SEE ALSO bsearch(3), lsearch(3), malloc(3), tsearch(3),
feature_test_macros(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>GNU 2008-10-06 HSEARCH(3)</p>
<hr>
</body>
</html>
