<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:43:30 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_CONTROL_MSG(9) USB Core APIs USB_CONTROL_MSG(9)</p>

<p>NAME usb_control_msg - Builds a control urb, sends it
off and waits for completion</p>

<p>SYNOPSIS int usb_control_msg(struct usb_device * dev,
unsigned int pipe, __u8 request, __u8 requesttype, __u16
value, __u16 index, void * data, __u16 size, int
timeout);</p>

<p>ARGUMENTS dev pointer to the usb device to send the
message to</p>

<p>pipe endpoint pipe to send the message to</p>

<p>request USB message request value</p>

<p>requesttype USB message request type value</p>

<p>value USB message value</p>

<p>index USB message index value</p>

<p>data pointer to the data to send</p>

<p>size length in bytes of the data to send</p>

<p>timeout time in msecs to wait for the message to
complete before timing out (if 0 the wait is forever)</p>

<p>CONTEXT !in_interrupt ()</p>

<p>DESCRIPTION This function sends a simple control message
to a specified endpoint and waits for the message to
complete, or timeout.</p>

<p>If successful, it returns the number of bytes
transferred, otherwise a negative error number.</p>

<p>Don&acute;t use this function from within an interrupt
context, like a bottom half handler. If you need an
asynchronous message, or need to send a message from within
interrupt context, use usb_submit_urb. If a thread in your
driver uses this call, make sure your disconnect method can
wait for it to complete. Since you don&acute;t have a handle
on the URB used, you can&acute;t cancel the request.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
USB_CONTROL_MSG(9)</p>
<hr>
</body>
</html>
