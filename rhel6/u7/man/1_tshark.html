<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:42:45 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TSHARK(1) The Wireshark Network Analyzer TSHARK(1)</p>

<p>NAME tshark - Dump and analyze network traffic</p>

<p>SYNOPSIS tshark [ -2 ] [ -a &lt;capture autostop
condition&gt; ] ... [ -b &lt;capture ring buffer option&gt;]
... [ -B &lt;capture buffer size&gt; ] [ -c &lt;capture
packet count&gt; ] [ -C &lt;configuration profile&gt; ] [ -d
&lt;layer type&gt;==&lt;selector&gt;,&lt;decode-as
protocol&gt; ] [ -D ] [ -e &lt;field&gt; ] [ -E &lt;field
print option&gt; ] [ -f &lt;capture filter&gt; ] [ -F
&lt;file format&gt; ] [ -h ] [ -H &lt;input hosts file&gt; ]
[ -i &lt;capture interface&gt;|- ] [ -I ] [ -K
&lt;keytab&gt; ] [ -l ] [ -L ] [ -n ] [ -N &lt;name
resolving flags&gt; ] [ -o &lt;preference setting&gt; ] ...
[ -O &lt;protocols&gt; ] [ -p ] [ -P ] [ -q ] [ -r
&lt;infile&gt; ] [ -R &lt;read (display) filter&gt; ] [ -s
&lt;capture snaplen&gt; ] [ -S &lt;separator&gt; ] [ -t
ad|a|r|d|dd|e ] [ -T pdml|psml|ps|text|fields ] [ -v ] [ -V
] [ -w &lt;outfile&gt;|- ] [ -W &lt;file format option&gt;]
[ -x ] [ -X &lt;eXtension option&gt;] [ -y &lt;capture link
type&gt; ] [ -z &lt;statistics&gt; ] [ &lt;capture
filter&gt; ]</p>

<p>tshark -G
[fields|fields2|fields3|protocols|values|decodes|defaultprefs|currentprefs]</p>

<p>DESCRIPTION TShark is a network protocol analyzer. It
lets you capture packet data from a live network, or read
packets from a previously saved capture file, either
printing a decoded form of those packets to the standard
output or writing the packets to a file. TSharks native
capture file format is libpcap format, which is also the
format used by tcpdump and various other tools.</p>

<p>Without any options set, TShark will work much like
tcpdump. It will use the pcap library to capture traffic
from the first available network interface and displays a
summary line on stdout for each received packet.</p>

<p>TShark is able to detect, read and write the same
capture files that are supported by Wireshark. The input
file doesnt need a specific filename extension; the file
format and an optional gzip compression will be
automatically detected. Near the beginning of the
DESCRIPTION section of wireshark(1) or
&lt;http://www.wireshark.org/docs/man-pages/wireshark.html&gt;
is a detailed description of the way Wireshark handles this,
which is the same way Tshark handles this.</p>

<p>Compressed file support uses (and therefore requires)
the zlib library. If the zlib library is not present, TShark
will compile, but will be unable to read compressed
files.</p>

<p>If the -w option is not specified, TShark writes to the
standard output the text of a decoded form of the packets it
captures or reads. If the -w option is specified, TShark
writes to the file specified by that option the raw data of
the packets, along with the packets time stamps.</p>

<p>When writing a decoded form of packets, TShark writes,
by default, a summary line containing the fields specified
by the preferences file (which are also the fields displayed
in the packet list pane in Wireshark), although if its
writing packets as it captures them, rather than writing
packets from a saved capture file, it wont show the
&quot;frame number&quot; field. If the -V option is
specified, it writes instead a view of the details of the
packet, showing all the fields of all protocols in the
packet. If the -O option is specified, it will only show the
full protocols specified. Use the output of &quot;tshark -G
protocols&quot; to find the abbreviations of the protocols
you can specify.</p>

<p>If you want to write the decoded form of packets to a
file, run TShark without the -w option, and redirect its
standard output to the file (do not use the -w option).</p>

<p>When writing packets to a file, TShark, by default,
writes the file in libpcap format, and writes all of the
packets it sees to the output file. The -F option can be
used to specify the format in which to write the file. This
list of available file formats is displayed by the -F flag
without a value. However, you cant specify a file format for
a live capture.</p>

<p>Read filters in TShark, which allow you to select which
packets are to be decoded or written to a file, are very
powerful; more fields are filterable in TShark than in other
protocol analyzers, and the syntax you can use to create
your filters is richer. As TShark progresses, expect more
and more protocol fields to be allowed in read filters.</p>

<p>Packet capturing is performed with the pcap library. The
capture filter syntax follows the rules of the pcap library.
This syntax is different from the read filter syntax. A read
filter can also be specified when capturing, and only
packets that pass the read filter will be displayed or saved
to the output file; note, however, that capture filters are
much more efficient than read filters, and it may be more
difficult for TShark to keep up with a busy network if a
read filter is specified for a live capture.</p>

<p>A capture or read filter can either be specified with
the -f or -R option, respectively, in which case the entire
filter expression must be specified as a single argument
(which means that if it contains spaces, it must be quoted),
or can be specified with command-line arguments after the
option arguments, in which case all the arguments after the
filter arguments are treated as a filter expression. Capture
filters are supported only when doing a live capture; read
filters are supported when doing a live capture and when
reading a capture file, but require TShark to do more work
when filtering, so you might be more likely to lose packets
under heavy load if youre using a read filter. If the filter
is specified with command-line arguments after the option
arguments, its a capture filter if a capture is being done
(i.e., if no -r option was specified) and a read filter if a
capture file is being read (i.e., if a -r option was
specified).</p>

<p>The -G option is a special mode that simply causes
Tshark to dump one of several types of internal glossaries
and then exit.</p>

<p>OPTIONS -2 Perform a two-pass analysis.</p>

<p>-a &lt;capture autostop condition&gt; Specify a
criterion that specifies when TShark is to stop writing to a
capture file. The criterion is of the form test:value, where
test is one of:</p>

<p>duration:value Stop writing to a capture file after
value seconds have elapsed.</p>

<p>filesize:value Stop writing to a capture file after it
reaches a size of value kilobytes (where a kilobyte is 1024
bytes). If this option is used together with the -b option,
TShark will stop writing to the current capture file and
switch to the next one if filesize is reached. When reading
a capture file, TShark will stop reading the file after the
number of bytes read exceeds this number (the complete
packet will be read, so more bytes than this number may be
read).</p>

<p>files:value Stop writing to capture files after value
number of files were written.</p>

<p>-b &lt;capture ring buffer option&gt; Cause TShark to
run in &quot;multiple files&quot; mode. In &quot;multiple
files&quot; mode, TShark will write to several capture
files. When the first capture file fills up, TShark will
switch writing to the next file and so on.</p>

<p>The created filenames are based on the filename given
with the -w option, the number of the file and on the
creation date and time, e.g.
outfile_00001_20050604120117.pcap,
outfile_00002_20050604120523.pcap, ...</p>

<p>With the files option it s also possible to form a
&quot;ring buffer&quot;. This will fill up new files until
the number of files specified, at which point TShark will
discard the data in the first file and start writing to that
file and so on. If the files option is not set, new files
filled up until one of the capture stop conditions match (or
until the disk is full).</p>

<p>The criterion is of the form key:value, where key is one
of:</p>

<p>duration:value switch to the next file after value
seconds have elapsed, even if the current file is not
completely filled up.</p>

<p>filesize:value switch to the next file after it reaches
a size of value kilobytes (where a kilobyte is 1024
bytes).</p>

<p>files:value begin again with the first file after value
number of files were written (form a ring buffer). This
value must be less than 100000. Caution should be used when
using large numbers of files: some filesystems do not handle
many files in a single directory well. The files criterion
requires either duration or filesize to be specified to
control when to go to the next file. It should be noted that
each -b parameter takes exactly one criterion; to specify
two criterion, each must be preceded by the -b option.</p>

<p>Example: -b filesize:1024 -b files:5 results in a ring
buffer of five files of size one megabyte.</p>

<p>-B &lt;capture buffer size&gt; Set capture buffer size
(in MB, default is 1MB). This is used by the the capture
driver to buffer packet data until that data can be written
to disk. If you encounter packet drops while capturing, try
to increase this size. Note that, while Tshark attempts to
set the buffer size to 1MB by default, and can be told to
set it to a larger value, the system or interface on which
you re capturing might silently limit the capture buffer
size to a lower value or raise it to a higher value.</p>

<p>This is available on UNIX systems with libpcap 1.0.0 or
later and on Windows. It is not available on UNIX systems
with earlier versions of libpcap.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, it sets the default
capture buffer size. If used after an -i option, it sets the
capture buffer size for the interface specified by the last
-i option occurring before this option. If the capture
buffer size is not set specifically, the default capture
buffer size is used if provided.</p>

<p>-c &lt;capture packet count&gt; Set the maximum number
of packets to read when capturing live data. If reading a
capture file, set the maximum number of packets to read.</p>

<p>-C &lt;configuration profile&gt; Run with the given
configuration profile.</p>

<p>-d &lt;layer type&gt;==&lt;selector&gt;,&lt;decode-as
protocol&gt; Like Wireshark s Decode As... feature, this
lets you specify how a layer type should be dissected. If
the layer type in question (for example, tcp.port or
udp.port for a TCP or UDP port number) has the specified
selector value, packets should be dissected as the specified
protocol.</p>

<p>Example: -d tcp.port==8888,http will decode any traffic
running over TCP port 8888 as HTTP.</p>

<p>Using an invalid selector or protocol will print out a
list of valid selectors and protocol names,
respectively.</p>

<p>Example: -d . is a quick way to get a list of valid
selectors.</p>

<p>Example: -d ethertype==0x0800. is a quick way to get a
list of protocols that can be selected with an
ethertype.</p>

<p>-D Print a list of the interfaces on which TShark can
capture, and exit. For each network interface, a number and
an interface name, possibly followed by a text description
of the interface, is printed. The interface name or the
number can be supplied to the -i option to specify an
interface on which to capture.</p>

<p>This can be useful on systems that dont have a command
to list them (e.g., Windows systems, or UNIX systems lacking
ifconfig -a); the number can be useful on Windows 2000 and
later systems, where the interface name is a somewhat
complex string.</p>

<p>Note that &quot;can capture&quot; means that TShark was
able to open that device to do a live capture. Depending on
your system you may need to run tshark from an account with
special privileges (for example, as root) to be able to
capture network traffic. If TShark -D is not run from such
an account, it will not list any interfaces.</p>

<p>-e &lt;field&gt; Add a field to the list of fields to
display if -T fields is selected. This option can be used
multiple times on the command line. At least one field must
be provided if the -T fields option is selected.</p>

<p>Example: -e frame.number -e ip.addr -e udp</p>

<p>Giving a protocol rather than a single field will print
multiple items of data about the protocol as a single field.
Fields are separated by tab characters by default. -E
controls the format of the printed fields.</p>

<p>-E &lt;field print option&gt; Set an option controlling
the printing of fields when -T fields is selected.</p>

<p>Options are:</p>

<p>header=y|n If y, print a list of the field names given
using -e as the first line of the output; the field name
will be separated using the same character as the field
values. Defaults to n.</p>

<p>separator=/t|/s|&lt;character&gt; Set the separator
character to use for fields. If /t tab will be used (this is
the default), if /s, a single space will be used. Otherwise
any character that can be accepted by the command line as
part of the option may be used.</p>

<p>occurrence=f|l|a Select which occurrence to use for
fields that have multiple occurrences. If f the first
occurrence will be used, if l the last occurrence will be
used and if a all occurrences will be used (this is the
default).</p>

<p>aggregator=,|/s|&lt;character&gt; Set the aggregator
character to use for fields that have multiple occurrences.
If , a comma will be used (this is the default), if /s, a
single space will be used. Otherwise any character that can
be accepted by the command line as part of the option may be
used.</p>

<p>quote=d|s|n Set the quote character to use to surround
fields. d uses double-quotes, s single-quotes, n no quotes
(the default).</p>

<p>-f &lt;capture filter&gt; Set the capture filter
expression.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, it sets the default
capture filter expression. If used after an -i option, it
sets the capture filter expression for the interface
specified by the last -i option occurring before this
option. If the capture filter expression is not set
specifically, the default capture filter expression is used
if provided.</p>

<p>-F &lt;file format&gt; Set the file format of the output
capture file written using the -w option. The output written
with the -w option is raw packet data, not text, so there is
no -F option to request text output. The option -F without a
value will list the available formats.</p>

<p>-G
[fields|fields2|fields3|protocols|values|decodes|defaultprefs|currentprefs]
The -G option will cause Tshark to dump one of several types
of glossaries and then exit. If no specific glossary type is
specified, then the fields report will be generated by
default.</p>

<p>The available report types include:</p>

<p>fields Dumps the contents of the registration database
to stdout. An independent program can take this output and
format it into nice tables or HTML or whatever. There is one
record per line. Each record is either a protocol or a
header field, differentiated by the first field. The fields
are tab-delimited.</p>

<p>* Protocols * --------- * Field 1 = &rsquo;P&rsquo; *
Field 2 = descriptive protocol name * Field 3 = protocol
abbreviation * * Header Fields * ------------- * Field 1 =
&rsquo;F&rsquo; * Field 2 = descriptive field name * Field 3
= field abbreviation * Field 4 = type ( textual
representation of the ftenum type ) * Field 5 = parent
protocol abbreviation * Field 6 = blurb describing field</p>

<p>fields2 Same as the fields report but includes two
additional columns.</p>

<p>* Field 7 = base for display (for integer types);
&quot;parent bitfield width&quot; for FT_BOOLEAN * Field 8 =
blurb describing field (yes, apparently we repeated this
accidentally)</p>

<p>fields3 Same as the fields report but includes two
additional columns.</p>

<p>* Field 7 = base for display (for integer types);
&quot;parent bitfield width&quot; for FT_BOOLEAN * Field 8 =
bitmask: format: hex: 0x....</p>

<p>protocols Dumps the protocols in the registration
database to stdout. An independent program can take this
output and format it into nice tables or HTML or whatever.
There is one record per line. The fields are
tab-delimited.</p>

<p>* Field 1 = protocol name * Field 2 = protocol short
name * Field 3 = protocol filter name</p>

<p>values Dumps the value_strings, range_strings or
true/false strings for fields that have them. There is one
record per line. Fields are tab-delimited. There are three
types of records: Value String, Range String and True/False
String. The first field, V, R or T, indicates the type of
record.</p>

<p>* Value Strings * ------------- * Field 1 =
&rsquo;V&rsquo; * Field 2 = field abbreviation to which this
value string corresponds * Field 3 = Integer value * Field 4
= String * * Range Strings * ------------- * Field 1 =
&rsquo;R&rsquo; * Field 2 = field abbreviation to which this
range string corresponds * Field 3 = Integer value: lower
bound * Field 4 = Integer value: upper bound * Field 5 =
String * * True/False Strings * ------------------ * Field 1
= &rsquo;T&rsquo; * Field 2 = field abbreviation to which
this true/false string corresponds * Field 3 = True String *
Field 4 = False String</p>

<p>decodes Dumps the &quot;layer type&quot;/&quot;decode
as&quot; associations to stdout. There is one record per
line. The fields are tab-delimited.</p>

<p>* Field 1 = layer type, e.g. &quot;tcp.port&quot; *
Field 2 = selector in decimal * Field 3 = &quot;decode
as&quot; name, e.g. &quot;http&quot;</p>

<p>defaultprefs Dumps a default preferences file to
stdout.</p>

<p>currentprefs Dumps a copy of the current preferences
file to stdout.</p>

<p>-h Print the version and options and exits.</p>

<p>-H &lt;input hosts file&gt; Read a list of entries from
a &quot;hosts&quot; file, which will then be written to a
capture file. Implies -W n.</p>

<p>The &quot;hosts&quot; file format is documented at
&lt;http://en.wikipedia.org/wiki/Hosts_(file)&gt;.</p>

<p>-i &lt;capture interface&gt; | - Set the name of the
network interface or pipe to use for live packet
capture.</p>

<p>Network interface names should match one of the names
listed in &quot;tshark -D&quot; (described above); a number,
as reported by &quot;tshark -D&quot;, can also be used. If
youre using UNIX, &quot;netstat -i&quot; or &quot;ifconfig
-a&quot; might also work to list interface names, although
not all versions of UNIX support the -a option to
ifconfig.</p>

<p>If no interface is specified, TShark searches the list
of interfaces, choosing the first non-loopback interface if
there are any non-loopback interfaces, and choosing the
first loopback interface if there are no non-loopback
interfaces. If there are no interfaces at all, TShark
reports an error and doesn t start the capture.</p>

<p>Pipe names should be either the name of a FIFO (named
pipe) or - to read data from the standard input. Data read
from pipes must be in standard libpcap format.</p>

<p>This option can occur multiple times. When capturing
from multiple interfaces, the capture file will be saved in
pcap-ng format.</p>

<p>Note: the Win32 version of TShark doesnt support
capturing from pipes!</p>

<p>-I Put the interface in &quot;monitor mode&quot;; this
is supported only on IEEE 802.11 Wi-Fi interfaces, and
supported only on some operating systems.</p>

<p>Note that in monitor mode the adapter might disassociate
from the network with which its associated, so that you will
not be able to use any wireless networks with that adapter.
This could prevent accessing files on a network server, or
resolving host names or network addresses, if you are
capturing in monitor mode and are not connected to another
network with another adapter.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, it enables the monitor
mode for all interfaces. If used after an -i option, it
enables the monitor mode for the interface specified by the
last -i option occurring before this option.</p>

<p>-K &lt;keytab&gt; Load kerberos crypto keys from the
specified keytab file. This option can be used multiple
times to load keys from several files.</p>

<p>Example: -K krb5.keytab</p>

<p>-l Flush the standard output after the information for
each packet is printed. (This is not, strictly speaking,
line-buffered if -V was specified; however, it is the same
as line-buffered if -V wasnt specified, as only one line is
printed for each packet, and, as -l is normally used when
piping a live capture to a program or script, so that output
for a packet shows up as soon as the packet is seen and
dissected, it should work just as well as true
line-buffering. We do this as a workaround for a deficiency
in the Microsoft Visual C++ C library.)</p>

<p>This may be useful when piping the output of TShark to
another program, as it means that the program to which the
output is piped will see the dissected data for a packet as
soon as TShark sees the packet and generates that output,
rather than seeing it only when the standard output buffer
containing that data fills up.</p>

<p>-L List the data link types supported by the interface
and exit. The reported link types can be used for the -y
option.</p>

<p>-n Disable network object name resolution (such as
hostname, TCP and UDP port names); the -N flag might
override this one.</p>

<p>-N &lt;name resolving flags&gt; Turn on name resolving
only for particular types of addresses and port numbers,
with name resolving for other types of addresses and port
numbers turned off. This flag overrides -n if both -N and -n
are present. If both -N and -n flags are not present, all
name resolutions are turned on.</p>

<p>The argument is a string that may contain the
letters:</p>

<p>m to enable MAC address resolution</p>

<p>n to enable network address resolution</p>

<p>t to enable transport-layer port number resolution</p>

<p>C to enable concurrent (asynchronous) DNS lookups</p>

<p>-o &lt;preference&gt;:&lt;value&gt; Set a preference
value, overriding the default value and any value read from
a preference file. The argument to the option is a string of
the form prefname:value, where prefname is the name of the
preference (which is the same name that would appear in the
preference file), and value is the value to which it should
be set.</p>

<p>-O &lt;protocols&gt; Similar to the -V option, but
causes TShark to only show a detailed view of the
comma-separated list of protocols specified, rather than a
detailed view of all protocols. Use the output of
&quot;tshark -G protocols&quot; to find the abbreviations of
the protocols you can specify.</p>

<p>-p Don_t put the interface into promiscuous mode. Note
that the interface might be in promiscuous mode for some
other reason; hence, -p cannot be used to ensure that the
only traffic that is captured is traffic sent to or from the
machine on which TShark is running, broadcast traffic, and
multicast traffic to addresses received by that machine.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, no interface will be put
into the promiscuous mode. If used after an -i option, the
interface specified by the last -i option occurring before
this option will not be put into the promiscuous mode.</p>

<p>-P Decode and display packets even while writing raw
packet data using the -w option.</p>

<p>-q When capturing packets, dont display the continuous
count of packets captured that is normally shown when saving
a capture to a file; instead, just display, at the end of
the capture, a count of packets captured. On systems that
support the SIGINFO signal, such as various BSDs, you can
cause the current count to be displayed by typing your
&quot;status&quot; character (typically control-T, although
it might be set to &quot;disabled&quot; by default on at
least some BSDs, so youd have to explicitly set it to use
it).</p>

<p>When reading a capture file, or when capturing and not
saving to a file, dont print packet information; this is
useful if youre using a -z option to calculate statistics
and don t want the packet information printed, just the
statistics.</p>

<p>-r &lt;infile&gt; Read packet data from infile, can be
any supported capture file format (including gzipped files).
Its not possible to use named pipes or stdin here!</p>

<p>-R &lt;read (display) filter&gt; Cause the specified
filter (which uses the syntax of read/display filters,
rather than that of capture filters) to be applied before
printing a decoded form of packets or writing packets to a
file; packets not matching the filter are discarded rather
than being printed or written.</p>

<p>-s &lt;capture snaplen&gt; Set the default snapshot
length to use when capturing live data. No more than snaplen
bytes of each network packet will be read into memory, or
saved to disk. A value of 0 specifies a snapshot length of
65535, so that the full packet is captured; this is the
default.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, it sets the default
snapshot length. If used after an -i option, it sets the
snapshot length for the interface specified by the last -i
option occurring before this option. If the snapshot length
is not set specifically, the default snapshot length is used
if provided.</p>

<p>-S &lt;separator&gt; Set the line separator to be
printed between packets.</p>

<p>-t ad|a|r|d|dd|e Set the format of the packet timestamp
printed in summary lines. The format can be one of:</p>

<p>ad absolute with date: The absolute date and time is the
actual time and date the packet was captured</p>

<p>a absolute: The absolute time is the actual time the
packet was captured, with no date displayed</p>

<p>r relative: The relative time is the time elapsed
between the first packet and the current packet</p>

<p>d delta: The delta time is the time since the previous
packet was captured</p>

<p>dd delta_displayed: The delta_displayed time is the time
since the previous displayed packet was captured</p>

<p>e epoch: The time in seconds since epoch (Jan 1, 1970
00:00:00)</p>

<p>The default format is relative.</p>

<p>-T pdml|psml|ps|text|fields Set the format of the output
when viewing decoded packet data. The options are one
of:</p>

<p>pdml Packet Details Markup Language, an XML-based format
for the details of a decoded packet. This information is
equivalent to the packet details printed with the -V
flag.</p>

<p>psml Packet Summary Markup Language, an XML-based format
for the summary information of a decoded packet. This
information is equivalent to the information shown in the
one-line summary printed by default.</p>

<p>ps PostScript for a human-readable one-line summary of
each of the packets, or a multi-line view of the details of
each of the packets, depending on whether the -V flag was
specified.</p>

<p>text Text of a human-readable one-line summary of each
of the packets, or a multi-line view of the details of each
of the packets, depending on whether the -V flag was
specified. This is the default.</p>

<p>fields The values of fields specified with the -e
option, in a form specified by the -E option. For
example,</p>

<p>-T fields -E separator=, -E quote=d</p>

<p>would generate comma-separated values (CSV) output
suitable for importing into your favorite spreadsheet
program.</p>

<p>-v Print the version and exit.</p>

<p>-V Cause TShark to print a view of the packet details
rather than a one-line summary of the packet.</p>

<p>-w &lt;outfile&gt; | - Write raw packet data to outfile
or to the standard output if outfile is -.</p>

<p>NOTE: -w provides raw packet data, not text. If you want
text output you need to redirect stdout (e.g. using &gt;),
don t use the -w option for this.</p>

<p>-W &lt;file format option&gt; Save extra information in
the file if the format supports it. For example,</p>

<p>-F pcapng -W n</p>

<p>will save host name resolution records along with
captured packets.</p>

<p>Future versions of Wireshark may automatically change
the capture format to pcapng as needed.</p>

<p>The argument is a string that may contain the following
letter:</p>

<p>n write network address resolution information (pcapng
only)</p>

<p>-x Cause TShark to print a hex and ASCII dump of the
packet data after printing the summary or details.</p>

<p>-X &lt;eXtension options&gt; Specify an option to be
passed to a TShark module. The eXtension option is in the
form extension_key:value, where extension_key can be:</p>

<p>lua_script:lua_script_filename tells Wireshark to load
the given script in addition to the default Lua scripts.</p>

<p>-y &lt;capture link type&gt; Set the data link type to
use while capturing packets. The values reported by -L are
the values that can be used.</p>

<p>This option can occur multiple times. If used before the
first occurrence of the -i option, it sets the default
capture link type. If used after an -i option, it sets the
capture link type for the interface specified by the last -i
option occurring before this option. If the capture link
type is not set specifically, the default capture link type
is used if provided.</p>

<p>-z &lt;statistics&gt; Get TShark to collect various
types of statistics and display the result after finishing
reading the capture file. Use the -q flag if you re reading
a capture file and only want the statistics printed, not any
per-packet information.</p>

<p>Note that the -z proto option is different - it doesnt
cause statistics to be gathered and printed when the capture
is complete, it modifies the regular packet summary output
to include the values of fields specified with the option.
Therefore you must not use the -q option, as that option
would suppress the printing of the regular packet summary
output, and must also not use the -V option, as that would
cause packet detail information rather than packet summary
information to be printed.</p>

<p>Currently implemented statistics are:</p>

<p>-z afp,srt[,filter] -z camel,srt -z conv,type[,filter]
Create a table that lists all conversations that could be
seen in the capture. type specifies the conversation
endpoint types for which we want to generate the statistics;
currently the supported ones are:</p>

<p>&quot;eth&quot; Ethernet addresses &quot;fc&quot; Fibre
Channel addresses &quot;fddi&quot; FDDI addresses
&quot;ip&quot; IPv4 addresses &quot;ipv6&quot; IPv6
addresses &quot;ipx&quot; IPX addresses &quot;tcp&quot;
TCP/IP socket pairs Both IPv4 and IPv6 are supported
&quot;tr&quot; Token Ring addresses &quot;udp&quot; UDP/IP
socket pairs Both IPv4 and IPv6 are supported</p>

<p>If the optional filter is specified, only those packets
that match the filter will be used in the calculations.</p>

<p>The table is presented with one line for each
conversation and displays the number of packets/bytes in
each direction as well as the total number of packets/bytes.
The table is sorted according to the total number of
frames.</p>

<p>-z dcerpc,srt,uuid,major.minor[,filter] Collect
call/reply SRT (Service Response Time) data for DCERPC
interface uuid, version major.minor. Data collected is the
number of calls for each procedure, MinSRT, MaxSRT and
AvgSRT.</p>

<p>Example: -z
dcerpc,srt,12345778-1234-abcd-ef00-0123456789ac,1.0 will
collect data for the CIFS SAMR Interface.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z
dcerpc,srt,12345778-1234-abcd-ef00-0123456789ac,1.0,ip.addr==1.2.3.4
will collect SAMR SRT statistics for a specific host.</p>

<p>-z diameter,avp[,cmd.code,field,field,...] This option
enables extraction of most important diameter fields from
large capture files. Exactly one text line for each diameter
message with matched diameter.cmd.code will be printed.</p>

<p>Empty diameter command code or * can be specified to
mach any diameter.cmd.code</p>

<p>Example: -z diameter,avp extract default field set from
diameter messages.</p>

<p>Example: -z diameter,avp,280 extract default field set
from diameter DWR messages.</p>

<p>Example: -z diameter,avp,272 extract default field set
from diameter CC messages.</p>

<p>Extract most important fields from diameter CC
messages:</p>

<p>tshark -r file.cap.gz -q -z
diameter,avp,272,CC-Request-Type,CC-Request-Number,Session-Id,Subscription-Id-Data,Rating-Group,Result-Code</p>

<p>Following fields will be printed out for each diameter
message:</p>

<p>&quot;frame&quot; Frame number. &quot;time&quot; Unix
time of the frame arrival. &quot;src&quot; Source address.
&quot;srcport&quot; Source port. &quot;dst&quot; Destination
address. &quot;dstport&quot; Destination port.
&quot;proto&quot; Constant string &rsquo;diameter&rsquo;,
which can be used for post processing of tshark output. E.g.
grep/sed/awk. &quot;msgnr&quot; seq. number of diameter
message within the frame. E.g. &rsquo;2&rsquo; for the third
diameter message in the same frame. &quot;is_request&quot;
&rsquo;0&rsquo; if message is a request, &rsquo;1&rsquo; if
message is an answer. &quot;cmd&quot; diameter.cmd_code,
E.g. &rsquo;272&rsquo; for credit control messages.
&quot;req_frame&quot; Number of frame where matched request
was found or &rsquo;0&rsquo;. &quot;ans_frame&quot; Number
of frame where matched answer was found or &rsquo;0&rsquo;.
&quot;resp_time&quot; response time in seconds,
&rsquo;0&rsquo; in case if matched Request/Answer is not
found in trace. E.g. in the begin or end of capture.</p>

<p>-z diameter,avp option is much faster than -V -T text or
-T pdml options.</p>

<p>-z diameter,avp option is more powerful than -T field
and -z proto,colinfo options.</p>

<p>Multiple diameter messages in one frame are
supported.</p>

<p>Several fields with same name within one diameter
message are supported, e.g. diameter.Subscription-Id-Data or
diameter.Rating-Group.</p>

<p>Note: tshark -q option is recommended to suppress
default tshark output.</p>

<p>-z expert[,error|,warn|,note|,chat][,filter] Collects
information about all expert info, and will display them in
order, grouped by severity.</p>

<p>Example: -z expert,sip will show expert items of all
severity for frames that match the sip protocol.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z &quot;expert,note,tcp&quot; will only
collect expert items for frames that include the tcp
protocol, with a severity of note or higher.</p>

<p>-z follow,prot,mode,filter[,range] Displays the contents
of a TCP or UDP stream between two nodes. The data sent by
the second node is prefixed with a tab to differentiate it
from the data sent by the first node.</p>

<p>prot specifies the transport protocol. It can be one of:
tcp TCP udp UDP</p>

<p>mode specifies the output mode. It can be one of: ascii
ASCII output with dots for non-printable characters hex
Hexadecimal and ASCII data with offsets raw Hexadecimal
data</p>

<p>Since the output in ascii mode may contain newlines, the
length of each section of output plus a newline precedes
each section of output.</p>

<p>filter specifies the stream to be displayed. UDP streams
are selected with IP address plus port pairs. TCP streams
are selected with either the stream index or IP address plus
port pairs. For example: ip-addr0:port0,ip-addr1:port1
tcp-stream-index</p>

<p>range optionally specifies which &quot;chunks&quot; of
the stream should be displayed.</p>

<p>Example: -z &quot;follow,tcp,hex,1&quot; will display
the contents of the first TCP stream in &quot;hex&quot;
format.</p>


<p>===================================================================
Follow: tcp,hex Filter: tcp.stream eq 1 Node 0:
200.57.7.197:32891 Node 1: 200.57.7.198:2906 00000000 00 00
00 22 00 00 00 07 00 0a 85 02 07 e9 00 02 ...&quot;....
........ 00000010 07 e9 06 0f 00 0d 00 04 00 00 00 01 00 03
00 06 ........ ........ 00000020 1f 00 06 04 00 00 ......
00000000 00 01 00 00 .... 00000026 00 02 00 00</p>

<p>Example: -z
&quot;follow,tcp,ascii,200.57.7.197:32891,200.57.7.198:2906&quot;
will display the contents of a TCP stream between
200.57.7.197 port 32891 and 200.57.7.98 port 2906.</p>


<p>===================================================================
Follow: tcp,ascii Filter: (ommitted for readability) Node 0:
200.57.7.197:32891 Node 1: 200.57.7.198:2906 38
...&quot;..... ................ 4 ....</p>

<p>-z h225,counter[,filter] Count ITU-T H.225 messages and
their reasons. In the first column you get a list of H.225
messages and H.225 message reasons, which occur in the
current capture file. The number of occurrences of each
message or reason is displayed in the second column.</p>

<p>Example: -z h225,counter.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.
Example: use -z &quot;h225,counter,ip.addr==1.2.3.4&quot; to
only collect stats for H.225 packets exchanged by the host
at IP address 1.2.3.4 .</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z h225,srt[,filter] Collect requests/response SRT
(Service Response Time) data for ITU-T H.225 RAS. Data
collected is number of calls of each ITU-T H.225 RAS Message
Type, Minimum SRT, Maximum SRT, Average SRT, Minimum in
Packet, and Maximum in Packet. You will also get the number
of Open Requests (Unresponded Requests), Discarded Responses
(Responses without matching request) and Duplicate
Messages.</p>

<p>Example: -z h225,srt</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z &quot;h225,srt,ip.addr==1.2.3.4&quot; will
only collect stats for ITU-T H.225 RAS packets exchanged by
the host at IP address 1.2.3.4 .</p>

<p>-z hosts[,ipv4][,ipv6] Dump any collected IPv4 and/or
IPv6 addresses in &quot;hosts&quot; format. Both IPv4 and
IPv6 addresses are dumped by default.</p>

<p>Addresses are collected from a number of sources,
including standard &quot;hosts&quot; files and captured
traffic.</p>

<p>-z http,stat, Calculate the HTTP statistics
distribution. Displayed values are the HTTP status codes and
the HTTP request methods.</p>

<p>-z icmp,srt[,filter] Compute total ICMP echo requests,
replies, loss, and percent loss, as well as minimum,
maximum, mean, median and sample standard deviation SRT
statistics typical of what ping provides.</p>

<p>Example: -z icmp,srt,ip.src==1.2.3.4 will collect ICMP
SRT statistics for ICMP echo request packets originating
from a specific host.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z icmpv6,srt[,filter] Compute total ICMPv6 echo
requests, replies, loss, and percent loss, as well as
minimum, maximum, mean, median and sample standard deviation
SRT statistics typical of what ping provides.</p>

<p>Example: -z icmpv6,srt,ipv6.src==fe80::1 will collect
ICMPv6 SRT statistics for ICMPv6 echo request packets
originating from a specific host.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z io,phs[,filter] Create Protocol Hierarchy Statistics
listing both number of packets and bytes. If no filter is
specified the statistics will be calculated for all packets.
If a filter is specified statistics will be only calculated
for those packets that match the filter.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z io,stat,interval[,filter][,filter][,filter]...
Collect packet/bytes statistics for the capture in intervals
of interval seconds. Interval can be specified either as a
whole or fractional second and can be specified with
microsecond (us) resolution. If interval is 0, the
statistics will be calculated over all packets.</p>

<p>If no filter is specified the statistics will be
calculated for all packets. If one or more filters are
specified statistics will be calculated for all filters and
presented with one column of statistics for each filter.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>Example: -z io,stat,1,ip.addr==1.2.3.4 will generate 1
second statistics for all traffic to/from host 1.2.3.4.</p>

<p>Example: -z
&quot;io,stat,0.001,smb&amp;&amp;ip.addr==1.2.3.4&quot; will
generate 1ms statistics for all SMB packets to/from host
1.2.3.4.</p>

<p>The examples above all use the standard syntax for
generating statistics which only calculates the number of
packets and bytes in each interval.</p>

<p>io,stat can also do much more statistics and calculate
COUNT(), SUM(), MIN(), MAX(), AVG() and LOAD() using a
slightly different filter syntax:</p>

<p>-z
io,stat,interval,&quot;[COUNT|SUM|MIN|MAX|AVG|LOAD](field)field
[and filter]&quot; NOTE: One important thing to note here is
that the field that the calculation is based on MUST also be
part of the filter string or else the calculation will
fail.</p>

<p>So: -z io,stat,0.010,AVG(smb.time) does not work. Use -z
io,stat,0.010,AVG(smb.time)smb.time instead. Also be aware
that a field can exist multiple times inside the same packet
and will then be counted multiple times in those
packets.</p>

<p>NOTE: A second important thing to note is that the
system setting for decimal separator is set to
&quot;.&quot;! If it is set to &quot;,&quot; the statistics
will not be displayed per filter.</p>

<p>COUNT(field)field [and filter] - Calculates the number
of times that the field name (not its value) appears per
interval in the filtered packet list. field can be any
display filter name.</p>

<p>Example: -z
io,stat,0.010,&quot;COUNT(smb.sid)smb.sid&quot;</p>

<p>This will count the total number of SIDs seen in each
10ms interval.</p>

<p>SUM(field)field [and filter] - Unlike COUNT, the values
of the specified field are summed per time interval. field
can only be a named integer, float, double or relative time
field.</p>

<p>Example: -z
io,stat,0.010,&quot;SUM(frame.len)frame.len&quot;</p>

<p>Reports the total number of bytes that were transmitted
bidirectionally in all the packets within a 10 millisecond
interval.</p>

<p>MIN/MAX/AVG(field)field [and filter] - The minimum,
maximum, or average field value in each interval is
calculated. The specified field must be a named integer,
float, double or relative time field. For relative time
fields, the output is presented in seconds with six decimal
digits of precision rounded to the nearest microsecond.</p>

<p>In the following example, the time of the first
Read_AndX call, the last Read_AndX response values are
displayed and the minimum, maximum, and average Read
response times (SRTs) are calculated. NOTE: If the DOS
command shell line continuation character, ^ is used, each
line cannot end in a comma so it is placed at the beginning
of each continuation line:</p>

<p>tshark -o tcp.desegment_tcp_streams:FALSE -n -q -r
smb_reads.cap -z io,stat,0,
&quot;MIN(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==0&quot;,
&quot;MAX(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==1&quot;,
&quot;MIN(smb.time)smb.time and smb.cmd==0x2e&quot;,
&quot;MAX(smb.time)smb.time and smb.cmd==0x2e&quot;,
&quot;AVG(smb.time)smb.time and smb.cmd==0x2e&quot;</p>


<p>======================================================================================================
IO Statistics Column #0:
MIN(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==0 Column #1:
MAX(frame.time_relative)frame.time_relative and
smb.cmd==0x2e and smb.flags.response==1 Column #2:
MIN(smb.time)smb.time and smb.cmd==0x2e Column #3:
MAX(smb.time)smb.time and smb.cmd==0x2e Column #4:
AVG(smb.time)smb.time and smb.cmd==0x2e | Column #0 | Column
#1 | Column #2 | Column #3 | Column #4 | Time | MIN | MAX |
MIN | MAX | AVG | 000.000- 0.000000 7.704054 0.000072
0.005539 0.000295
======================================================================================================</p>

<p>The following command displays the average SMB Read
response PDU size, the total number of read PDU bytes, the
average SMB Write request PDU size, and the total number of
bytes transferred in SMB Write PDUs:</p>

<p>tshark -n -q -r smb_reads_writes.cap -z io,stat,0,
&quot;AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to&quot;,
&quot;SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2e and smb.response_to&quot;,
&quot;AVG(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to&quot;,
&quot;SUM(smb.file.rw.length)smb.file.rw.length and
smb.cmd==0x2f and not smb.response_to&quot;</p>


<p>=====================================================================================
IO Statistics Column #0:
AVG(smb.file.rw.length)smb.file.rw.length and smb.cmd==0x2e
and smb.response_to Column #1:
SUM(smb.file.rw.length)smb.file.rw.length and smb.cmd==0x2e
and smb.response_to Column #2:
AVG(smb.file.rw.length)smb.file.rw.length and smb.cmd==0x2f
and not smb.response_to Column #3:
SUM(smb.file.rw.length)smb.file.rw.length and smb.cmd==0x2f
and not smb.response_to | Column #0 | Column #1 | Column #2
| Column #3 | Time | AVG | SUM | AVG | SUM | 000.000- 30018
28067522 72 3240
=====================================================================================</p>

<p>LOAD(field)field [and filter] - The LOAD/Queue-Depth in
each interval is calculated. The specified field must be a
relative time field that represents a response time. For
example smb.time. For each interval the Queue-Depth for the
specified protocol is calculated.</p>

<p>The following command displays the average SMB LOAD. A
value of 1.0 represents one I/O in flight.</p>

<p>tshark -n -q -r smb_reads_writes.cap -z
&quot;io,stat,0.001,LOAD(smb.time)smb.time&quot;</p>


<p>============================================================================
IO Statistics Interval: 0.001000 secs Column #0:
LOAD(smb.time)smb.time | Column #0 | Time | LOAD |
0000.000000-0000.001000 1.000000 0000.001000-0000.002000
0.741000 0000.002000-0000.003000 0.000000
0000.003000-0000.004000 1.000000</p>

<p>FRAMES | BYTES[()filter] - Displays the total number of
frames or bytes. The filter field is optional but if
included it must be prepended with ().</p>

<p>The following command displays five columns: the total
number of frames and bytes (transferred bidirectionally)
using a single comma, the same two stats using the FRAMES
and BYTES subcommands, the total number of frames containing
at least one SMB Read response, and the total number of
bytes transmitted to the client (unidirectionally) at IP
address 10.1.0.64.</p>

<p>tshark -o tcp.desegment_tcp_streams:FALSE -n -q -r
smb_reads.cap -z io,stat,0,,FRAMES,BYTES,
&quot;FRAMES()smb.cmd==0x2e and
smb.response_to&quot;,&quot;BYTES()ip.dst==10.1.0.64&quot;</p>


<p>=======================================================================================================================
IO Statistics Column #0: Column #1: FRAMES Column #2: BYTES
Column #3: FRAMES()smb.cmd==0x2e and smb.response_to Column
#4: BYTES()ip.dst==10.1.0.64 | Column #0 | Column #1 |
Column #2 | Column #3 | Column #4 | Time | Frames | Bytes |
FRAMES | BYTES | FRAMES | BYTES | 000.000- 33576 29721685
33576 29721685 870 29004801
=======================================================================================================================</p>

<p>-z mac-lte,stat[,filter] This option will activate a
counter for LTE MAC messages. You will get information about
the maximum number of UEs/TTI, common messages and various
counters for each UE that appears in the log.</p>

<p>Example: -z mac-lte,stat.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated for those frames that match that filter.
Example: -z &quot;mac-lte,stat,mac-lte.rnti3000&quot;&gt;
will only collect stats for UEs with an assigned RNTI whose
value is more than 3000.</p>

<p>-z megaco,rtd[,filter] Collect requests/response RTD
(Response Time Delay) data for MEGACO. (This is similar to
-z smb,srt). Data collected is the number of calls for each
known MEGACO Type, MinRTD, MaxRTD and AvgRTD. Additionally
you get the number of duplicate requests/responses,
unresponded requests, responses, which don t match with any
request. Example: -z megaco,rtd.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.
Example: -z &quot;megaco,rtd,ip.addr==1.2.3.4&quot; will
only collect stats for MEGACO packets exchanged by the host
at IP address 1.2.3.4 .</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z mgcp,rtd[,filter] Collect requests/response RTD
(Response Time Delay) data for MGCP. (This is similar to -z
smb,srt). Data collected is the number of calls for each
known MGCP Type, MinRTD, MaxRTD and AvgRTD. Additionally you
get the number of duplicate requests/responses, unresponded
requests, responses, which don t match with any request.
Example: -z mgcp,rtd.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.
Example: -z &quot;mgcp,rtd,ip.addr==1.2.3.4&quot; will only
collect stats for MGCP packets exchanged by the host at IP
address 1.2.3.4 .</p>

<p>-z proto,colinfo,filter,field Append all field values
for the packet to the Info column of the one-line summary
output. This feature can be used to append arbitrary fields
to the Info column in addition to the normal content of that
column. field is the display-filter name of a field which
value should be placed in the Info column. filter is a
filter string that controls for which packets the field
value will be presented in the info column. field will only
be presented in the Info column for the packets which match
filter.</p>

<p>NOTE: In order for TShark to be able to extract the
field value from the packet, field MUST be part of the
filter string. If not, TShark will not be able to extract
its value.</p>

<p>For a simple example to add the &quot;nfs.fh.hash&quot;
field to the Info column for all packets containing the
&quot;nfs.fh.hash&quot; field, use</p>

<p>-z proto,colinfo,nfs.fh.hash,nfs.fh.hash</p>

<p>To put &quot;nfs.fh.hash&quot; in the Info column but
only for packets coming from host 1.2.3.4 use:</p>

<p>-z &quot;proto,colinfo,nfs.fh.hash &amp;&amp;
ip.src==1.2.3.4,nfs.fh.hash&quot;</p>

<p>This option can be used multiple times on the command
line.</p>

<p>-z rlc-lte,stat[,filter] This option will activate a
counter for LTE RLC messages. You will get information about
common messages and various counters for each UE that
appears in the log.</p>

<p>Example: -z rlc-lte,stat.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated for those frames that match that filter.
Example: -z &quot;rlc-lte,stat,rlc-lte.ueid3000&quot;&gt;
will only collect stats for UEs with a UEId of more than
3000.</p>

<p>-z rpc,programs Collect call/reply SRT data for all
known ONC-RPC programs/versions. Data collected is number of
calls for each protocol/version, MinSRT, MaxSRT and AvgSRT.
This option can only be used once on the command line.</p>

<p>-z rpc,srt,program,version[,filter] Collect call/reply
SRT (Service Response Time) data for program/version. Data
collected is number of calls for each procedure, MinSRT,
MaxSRT and AvgSRT.</p>

<p>Example: -z rpc,srt,100003,3 will collect data for NFS
v3.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z rpc,srt,100003,3,nfs.fh.hash==0x12345678
will collect NFS v3 SRT statistics for a specific file.</p>

<p>-z rtp,streams Collect statistics for all RTP streams
and calculate max. delta, max. and mean jitter and packet
loss percentages.</p>

<p>-z scsi,srt,cmdset[,filter] Collect call/reply SRT
(Service Response Time) data for SCSI commandset cmdset.</p>

<p>Commandsets are 0:SBC 1:SSC 5:MMC</p>

<p>Data collected is the number of calls for each
procedure, MinSRT, MaxSRT and AvgSRT.</p>

<p>Example: -z scsi,srt,0 will collect data for SCSI BLOCK
COMMANDS (SBC).</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z scsi,srt,0,ip.addr==1.2.3.4 will collect
SCSI SBC SRT statistics for a specific iscsi/ifcp/fcip
host.</p>

<p>-z sip,stat[,filter] This option will activate a counter
for SIP messages. You will get the number of occurrences of
each SIP Method and of each SIP Status-Code. Additionally
you also get the number of resent SIP Messages (only for SIP
over UDP).</p>

<p>Example: -z sip,stat.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.
Example: -z &quot;sip,stat,ip.addr==1.2.3.4&quot; will only
collect stats for SIP packets exchanged by the host at IP
address 1.2.3.4 .</p>

<p>-z smb,sids When this feature is used TShark will print
a report with all the discovered SID and account name
mappings. Only those SIDs where the account name is known
will be presented in the table.</p>

<p>For this feature to work you will need to either to
enable &quot;Edit/Preferences/Protocols/SMB/Snoop SID to
name mappings&quot; in the preferences or you can override
the preferences by specifying -o
&quot;smb.sid_name_snooping:TRUE&quot; on the TShark command
line.</p>

<p>The current method used by TShark to find the
SID-&gt;name mapping is relatively restricted with a hope of
future expansion.</p>

<p>-z smb,srt[,filter] Collect call/reply SRT (Service
Response Time) data for SMB. Data collected is number of
calls for each SMB command, MinSRT, MaxSRT and AvgSRT.</p>

<p>Example: -z smb,srt</p>

<p>The data will be presented as separate tables for all
normal SMB commands, all Transaction2 commands and all NT
Transaction commands. Only those commands that are seen in
the capture will have its stats displayed. Only the first
command in a xAndX command chain will be used in the
calculation. So for common SessionSetupAndX +
TreeConnectAndX chains, only the SessionSetupAndX call will
be used in the statistics. This is a flaw that might be
fixed in the future.</p>

<p>This option can be used multiple times on the command
line.</p>

<p>If the optional filter is provided, the stats will only
be calculated on those calls that match that filter.</p>

<p>Example: -z &quot;smb,srt,ip.addr==1.2.3.4&quot; will
only collect stats for SMB packets exchanged by the host at
IP address 1.2.3.4 .</p>

<p>CAPTURE FILTER SYNTAX See the manual page of
pcap-filter(7) or, if that doesn t exist, tcpdump(8), or, if
that doesnt exist,
&lt;http://wiki.wireshark.org/CaptureFilters&gt;.</p>

<p>READ FILTER SYNTAX For a complete table of protocol and
protocol fields that are filterable in TShark see the
wireshark-filter(4) manual page.</p>

<p>FILES These files contains various Wireshark
configuration values.</p>

<p>Preferences The preferences files contain global
(system-wide) and personal preference settings. If the
system-wide preference file exists, it is read first,
overriding the default settings. If the personal preferences
file exists, it is read next, overriding any previous
values. Note: If the command line option -o is used
(possibly more than once), it will in turn override values
from the preferences files.</p>

<p>The preferences settings are in the form prefname:value,
one per line, where prefname is the name of the preference
and value is the value to which it should be set; white
space is allowed between : and value. A preference setting
can be continued on subsequent lines by indenting the
continuation lines with white space. A # character starts a
comment that runs to the end of the line:</p>

<p># Capture in promiscuous mode? # TRUE or FALSE
(case-insensitive). capture.prom_mode: TRUE</p>

<p>The global preferences file is looked for in the
wireshark directory under the share subdirectory of the main
installation directory (for example,
/usr/local/share/wireshark/preferences) on UNIX-compatible
systems, and in the main installation directory (for
example, C:Program FilesWiresharkpreferences) on Windows
systems.</p>

<p>The personal preferences file is looked for in
$HOME/.wireshark/preferences on UNIX-compatible systems and
%APPDATA%Wiresharkpreferences (or, if %APPDATA% isn t
defined, %USERPROFILE%Application DataWiresharkpreferences)
on Windows systems.</p>

<p>Disabled (Enabled) Protocols The disabled_protos files
contain system-wide and personal lists of protocols that
have been disabled, so that their dissectors are never
called. The files contain protocol names, one per line,
where the protocol name is the same name that would be used
in a display filter for the protocol:</p>

<p>http tcp # a comment</p>

<p>The global disabled_protos file uses the same directory
as the global preferences file.</p>

<p>The personal disabled_protos file uses the same
directory as the personal preferences file.</p>

<p>Name Resolution (hosts) If the personal hosts file
exists, it is used to resolve IPv4 and IPv6 addresses before
any other attempts are made to resolve them. The file has
the standard hosts file syntax; each line contains one IP
address and name, separated by whitespace. The same
directory as for the personal preferences file is used.</p>

<p>Capture filter name resolution is handled by libpcap on
UNIX- compatible systems and WinPCAP on Windows. As such the
Wireshark personal hosts file will not be consulted for
capture filter name resolution.</p>

<p>Name Resolution (ethers) The ethers files are consulted
to correlate 6-byte hardware addresses to names. First the
personal ethers file is tried and if an address is not found
there the global ethers file is tried next.</p>

<p>Each line contains one hardware address and name,
separated by whitespace. The digits of the hardware address
are separated by colons (:), dashes (-) or periods (.). The
same separator character must be used consistently in an
address. The following three lines are valid lines of an
ethers file:</p>

<p>ff:ff:ff:ff:ff:ff Broadcast c0-00-ff-ff-ff-ff
TR_broadcast 00.00.00.00.00.00 Zero_broadcast</p>

<p>The global ethers file is looked for in the /etc
directory on UNIX- compatible systems, and in the main
installation directory (for example, C:Program
FilesWireshark) on Windows systems.</p>

<p>The personal ethers file is looked for in the same
directory as the personal preferences file.</p>

<p>Capture filter name resolution is handled by libpcap on
UNIX- compatible systems and WinPCAP on Windows. As such the
Wireshark personal ethers file will not be consulted for
capture filter name resolution.</p>

<p>Name Resolution (manuf) The manuf file is used to match
the 3-byte vendor portion of a 6-byte hardware address with
the manufacturer s name; it can also contain well-known MAC
addresses and address ranges specified with a netmask. The
format of the file is the same as the ethers files, except
that entries of the form:</p>

<p>00:00:0C Cisco</p>

<p>can be provided, with the 3-byte OUI and the name for a
vendor, and entries such as:</p>

<p>00-00-0C-07-AC/40 All-HSRP-routers</p>

<p>can be specified, with a MAC address and a mask
indicating how many bits of the address must match. The
above entry, for example, has 40 significant bits, or 5
bytes, and would match addresses from 00-00-0C-07-AC-00
through 00-00-0C-07-AC-FF. The mask need not be a multiple
of 8.</p>

<p>The manuf file is looked for in the same directory as
the global preferences file.</p>

<p>Name Resolution (ipxnets) The ipxnets files are used to
correlate 4-byte IPX network numbers to names. First the
global ipxnets file is tried and if that address is not
found there the personal one is tried next.</p>

<p>The format is the same as the ethers file, except that
each address is four bytes instead of six. Additionally, the
address can be represented as a single hexadecimal number,
as is more common in the IPX world, rather than four hex
octets. For example, these four lines are valid lines of an
ipxnets file:</p>

<p>C0.A8.2C.00 HR c0-a8-1c-00 CEO 00:00:BE:EF IT_Server1
110f FileServer3</p>

<p>The global ipxnets file is looked for in the /etc
directory on UNIX-compatible systems, and in the main
installation directory (for example, C:Program
FilesWireshark) on Windows systems.</p>

<p>The personal ipxnets file is looked for in the same
directory as the personal preferences file.</p>

<p>ENVIRONMENT VARIABLES WIRESHARK_DEBUG_EP_NO_CHUNKS
Normally per-packet memory is allocated in large
&quot;chunks.&quot; This behavior doesnt work well with
debugging tools such as Valgrind or ElectricFence. Export
this environment variable to force individual allocations.
Note: disabling chunks also disables canaries (see
below).</p>

<p>WIRESHARK_DEBUG_SE_NO_CHUNKS Normally per-file memory is
allocated in large &quot;chunks.&quot; This behavior doesnt
work well with debugging tools such as Valgrind or
ElectricFence. Export this environment variable to force
individual allocations. Note: disabling chunks also disables
canaries (see below).</p>

<p>WIRESHARK_DEBUG_EP_NO_CANARY Normally per-packet memory
allocations are separated by &quot;canaries&quot; which
allow detection of memory overruns. This comes at the
expense of some extra memory usage. Exporting this
environment variable disables these canaries.</p>

<p>WIRESHARK_DEBUG_SE_USE_CANARY Exporting this environment
variable causes per-file memory allocations to be protected
with &quot;canaries&quot; which allow for detection of
memory overruns. This comes at the expense of significant
extra memory usage.</p>

<p>WIRESHARK_DEBUG_SCRUB_MEMORY If this environment
variable is set, the contents of per-packet and per-file
memory is initialized to 0xBADDCAFE when the memory is
allocated and is reset to 0xDEADBEEF when the memory is
freed. This functionality is useful mainly to developers
looking for bugs in the way memory is handled.</p>

<p>WIRESHARK_RUN_FROM_BUILD_DIRECTORY This environment
variable causes the plugins and other data files to be
loaded from the build directory (where the program was
compiled) rather than from the standard locations. It has no
effect when the program in question is running with root (or
setuid) permissions on *NIX.</p>

<p>WIRESHARK_DATA_DIR This environment variable causes the
various data files to be loaded from a directory other than
the standard locations. It has no effect when the program in
question is running with root (or setuid) permissions on
*NIX.</p>

<p>WIRESHARK_PYTHON_DIR This environment variable points to
an alternate location for Python. It has no effect when the
program in question is running with root (or setuid)
permissions on *NIX.</p>

<p>ERF_RECORDS_TO_CHECK This environment variable controls
the number of ERF records checked when deciding if a file
really is in the ERF format. Setting this environment
variable a number higher than the default (20) would make
false positives less likely.</p>

<p>IPFIX_RECORDS_TO_CHECK This environment variable
controls the number of IPFIX records checked when deciding
if a file really is in the IPFIX format. Setting this
environment variable a number higher than the default (20)
would make false positives less likely.</p>

<p>WIRESHARK_ABORT_ON_DISSECTOR_BUG If this environment
variable is set, TShark will call abort(3) when a dissector
bug is encountered. abort(3) will cause the program to exit
abnormally; if you are running TShark in a debugger, it
should halt in the debugger and allow inspection of the
process, and, if you are not running it in a debugger, it
will, on some OSes, assuming your environment is configured
correctly, generate a core dump file. This can be useful to
developers attempting to troubleshoot a problem with a
protocol dissector.</p>

<p>WIRESHARK_EP_VERIFY_POINTERS This environment variable,
if present, causes certain uses of pointers to be audited to
ensure they do not point to memory that is deallocated after
each packet has been fully dissected. This can be useful to
developers writing or auditing code.</p>

<p>WIRESHARK_SE_VERIFY_POINTERS This environment variable,
if present, causes certain uses of pointers to be audited to
ensure they do not point to memory that is deallocated after
when a capture file is closed. This can be useful to
developers writing or auditing code.</p>

<p>WIRESHARK_ABORT_ON_OUT_OF_MEMORY This environment
variable, if present, causes abort(3) to be called if
certain out-of-memory conditions (which normally result in
an exception and an explanatory error message) are
experienced. This can be useful to developers debugging
out-of-memory conditions.</p>

<p>SEE ALSO wireshark-filter(4), wireshark(1), editcap(1),
pcap(3), dumpcap(1), text2pcap(1), mergecap(1),
pcap-filter(7) or tcpdump(8) if it doesnt exist.</p>

<p>NOTES TShark is part of the Wireshark distribution. The
latest version of Wireshark can be found at
&lt;http://www.wireshark.org&gt;.</p>

<p>HTML versions of the Wireshark project man pages are
available at:
&lt;http://www.wireshark.org/docs/man-pages&gt;.</p>

<p>AUTHORS TShark uses the same packet dissection code that
Wireshark does, as well as using many other modules from
Wireshark; see the list of authors in the Wireshark man page
for a list of authors of that code.</p>

<p>1.8.10 2013-02-19 TSHARK(1)</p>
<hr>
</body>
</html>
