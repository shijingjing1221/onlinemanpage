<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:37:10 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT WIMAX_DEV(9) Linux Networking STRUCT
WIMAX_DEV(9)</p>

<p>NAME struct_wimax_dev - Generic WiMAX device</p>

<p>SYNOPSIS struct wimax_dev { struct net_device * net_dev;
struct list_head id_table_node; struct mutex mutex; struct
mutex mutex_reset; enum wimax_st state; int (*
op_msg_from_user) (struct wimax_dev *wimax_dev,const char
*,const void *, size_t,const struct genl_info *info); int (*
op_rfkill_sw_toggle) (struct wimax_dev *wimax_dev,enum
wimax_rf_state); int (* op_reset) (struct wimax_dev
*wimax_dev); struct rfkill * rfkill; unsigned rf_hw;
unsigned rf_sw; char name[32]; struct dentry *
debugfs_dentry; };</p>

<p>MEMBERS net_dev [fill] Pointer to the struct net_device
this WiMAX device implements.</p>

<p>id_table_node [private] link to the list of wimax
devices kept by id-table.c. Protected by it&acute;s own
spinlock.</p>

<p>mutex [private] Serializes all concurrent access and
execution of operations.</p>

<p>mutex_reset [private] Serializes reset operations. Needs
to be a different mutex because as part of the reset
operation, the driver has to call back into the stack to do
things such as state change, that require
wimax_dev-&gt;mutex.</p>

<p>state [private] Current state of the WiMAX device.</p>

<p>op_msg_from_user [fill] Driver-specific operation to
handle a raw message from user space to the driver. The
driver can send messages to user space using with
wimax_msg_to_user.</p>

<p>op_rfkill_sw_toggle [fill] Driver-specific operation to
act on userspace (or any other agent) requesting the WiMAX
device to change the RF Kill software switch (WIMAX_RF_ON or
WIMAX_RF_OFF). If such hardware support is not present, it
is assumed the radio cannot be switched off and it is always
on (and the stack will error out when trying to switch it
off). In such case, this function pointer can be left as
NULL.</p>

<p>op_reset [fill] Driver specific operation to reset the
device. This operation should always attempt first a warm
reset that does not disconnect the device from the bus and
return 0. If that fails, it should resort to some sort of
cold or bus reset (even if it implies a bus disconnection
and device dissapearance). In that case, -ENODEV should be
returned to indicate the device is gone. This operation has
to be synchronous, and return only when the reset is
complete. In case of having had to resort to bus/cold reset
implying a device disconnection, the call is allowed to
return inmediately.</p>

<p>rfkill [private] integration into the RF-Kill
infrastructure.</p>

<p>rf_hw [private] State of the hardware radio switch
(OFF/ON)</p>

<p>rf_sw [private] State of the software radio switch
(OFF/ON)</p>

<p>name[32] [fill] A way to identify this device. We need
to register a name with many subsystems (rfkill, workqueue
creation, etc). We can&acute;t use the network device name
as that might change and in some instances we don&acute;t
know it yet (until we don&acute;t call register_netdev). So
we generate an unique one using the driver name and device
bus id, place it here and use it across the board.
Recommended naming: DRIVERNAME-BUSNAME:BUSID
(dev-&gt;bus-&gt;name, dev-&gt;bus_id).</p>

<p>debugfs_dentry [private] Used to hook up a debugfs
entry. This shows up in the debugfs root as
wimaxDEVICENAME.</p>

<p>NOTE wimax_dev-&gt;mutex is NOT locked when this op is
being called; however, wimax_dev-&gt;mutex_reset IS locked
to ensure serialization of calls to wimax_reset. See
wimax_reset&acute;s documentation.</p>

<p>DESCRIPTION This structure defines a common interface to
access all WiMAX devices from different vendors and provides
a common API as well as a free-form device-specific
messaging channel.</p>

<p>USAGE 1. Embed a struct wimax_dev at *the beginning* the
network device structure so that netdev_priv points to
it.</p>

<p>2. memset it to zero</p>

<p>3. Initialize with wimax_dev_init. This will leave the
WiMAX device in the __WIMAX_ST_NULL state.</p>

<p>4. Fill all the fields marked with [fill]; once called
wimax_dev_add, those fields CANNOT be modified.</p>

<p>5. Call wimax_dev_add *after* registering the network
device. This will leave the WiMAX device in the
WIMAX_ST_DOWN state. Protect the driver&acute;s
net_device-&gt;open against succeeding if the wimax device
state is lower than WIMAX_ST_DOWN.</p>

<p>6. Select when the device is going to be turned
on/initialized; for example, it could be initialized on
&acute;ifconfig up&acute; (when the netdev op
&acute;open&acute; is called on the driver).</p>

<p>When the device is initialized (at ifconfig up time, or
right after calling wimax_dev_add from _probe, make sure the
following steps are taken</p>

<p>a. Move the device to WIMAX_ST_UNINITIALIZED. This is
needed so some API calls that shouldn&acute;t work until the
device is ready can be blocked.</p>

<p>b. Initialize the device. Make sure to turn the SW radio
switch off and move the device to state WIMAX_ST_RADIO_OFF
when done. When just initialized, a device should be left in
RADIO OFF state until user space devices to turn it on.</p>

<p>c. Query the device for the state of the hardware rfkill
switch and call wimax_rfkill_report_hw and
wimax_rfkill_report_sw as needed. See below.</p>

<p>wimax_dev_rm undoes before unregistering the network
device. Once wimax_dev_add is called, the driver can get
called on the wimax_dev-&gt;op_* function pointers</p>

<p>CONCURRENCY The stack provides a mutex for each device
that will disallow API calls happening concurrently; thus,
op calls into the driver through the wimax_dev-&gt;op*()
function pointers will always be serialized and *never*
concurrent.</p>

<p>For locking, take wimax_dev-&gt;mutex is taken; (most)
operations in the API have to check for wimax_dev_is_ready
to return 0 before continuing (this is done internally).</p>

<p>REFERENCE COUNTING The WiMAX device is reference counted
by the associated network device. The only operation that
can be used to reference the device is
wimax_dev_get_by_genl_info, and the reference it acquires
has to be released with dev_put(wimax_dev-&gt;net_dev).</p>

<p>RFKILL At startup, both HW and SW radio switchess are
assumed to be off.</p>

<p>At initialization time [after calling wimax_dev_add],
have the driver query the device for the status of the
software and hardware RF kill switches and call
wimax_report_rfkill_hw and wimax_rfkill_report_sw to
indicate their state. If any is missing, just call it to
indicate it is ON (radio always on).</p>

<p>Whenever the driver detects a change in the state of the
RF kill switches, it should call wimax_report_rfkill_hw or
wimax_report_rfkill_sw to report it to the stack.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015 STRUCT
WIMAX_DEV(9)</p>
<hr>
</body>
</html>
