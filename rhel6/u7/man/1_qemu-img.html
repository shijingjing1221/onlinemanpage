<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:30:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>QEMU-IMG(1) QEMU-IMG(1)</p>

<p>NAME qemu-img - QEMU disk image utility</p>

<p>SYNOPSIS usage: qemu-img command [command options]</p>

<p>OPTIONS The following commands are supported:</p>

<p>check [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T
src_cache] filename create [-f fmt] [-o options] filename
[size] commit [-f fmt] [-t cache] filename compare [-f fmt]
[-F fmt] [-T src_cache] [-p] [-s] filename1 filename2
convert [-c] [-p] [-f fmt] [-t cache] [-T src_cache] [-O
output_fmt] [-o options] [-S sparse_size] filename
[filename2 [...]] output_filename info [-f fmt]
[--output=ofmt] filename map [-f fmt] [--output=ofmt]
filename snapshot [-l | -a snapshot | -c snapshot | -d
snapshot] filename rebase [-f fmt] [-t cache] [-T src_cache]
[-p] [-u] -b backing_file [-F backing_fmt] filename resize
filename [+ | -]size</p>

<p>Command parameters:</p>

<p>filename is a disk image filename</p>

<p>fmt is the disk image format. It is guessed
automatically in most cases. See below for a description of
the supported disk formats.</p>

<p>size is the disk image size in bytes. Optional suffixes
&quot;k&quot; or &quot;K&quot; (kilobyte, 1024)
&quot;M&quot; (megabyte, 1024k) and &quot;G&quot; (gigabyte,
1024M) and T (terabyte, 1024G) are supported. &quot;b&quot;
is ignored.</p>

<p>output_filename is the destination disk image
filename</p>

<p>output_fmt is the destination format</p>

<p>options is a comma separated list of format specific
options in a name=value format. Use &quot;-o ?&quot; for an
overview of the options supported by the used format or see
the format descriptions below for details.</p>

<p>-c indicates that target image must be compressed (qcow
format only)</p>

<p>-h with or without a command shows help and lists the
supported formats</p>

<p>-p display progress bar (compare, convert and rebase
commands only). If the -p option is not used for a command
that supports it, the progress is reported when the process
receives a &quot;SIGUSR1&quot; signal.</p>

<p>-S size indicates the consecutive number of bytes that
must contain only zeros for qemu-img to create a sparse
image during conversion. This value is rounded down to the
nearest 512 bytes. You may use the common size suffixes like
&quot;k&quot; for kilobytes.</p>

<p>-t cache specifies the cache mode that should be used
with the (destination) file. See the documentation of the
emulator s &quot;-drive cache=...&quot; option for allowed
values.</p>

<p>-T src_cache in contrast specifies the cache mode that
should be used with the source file(s).</p>

<p>Parameters to snapshot subcommand:</p>

<p>snapshot is the name of the snapshot to create, apply or
delete</p>

<p>-a applies a snapshot (revert disk to saved state)</p>

<p>-c creates a snapshot</p>

<p>-d deletes a snapshot</p>

<p>-l lists all snapshots in the given image</p>

<p>Parameters to compare subcommand:</p>

<p>-f First image format</p>

<p>-F Second image format</p>

<p>-s Strict mode - fail on on different image size or
sector allocation</p>

<p>Command description:</p>

<p>check [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T
src_cache] filename Perform a consistency check on the disk
image filename. The command can output in the format ofmt
which is either &quot;human&quot; or &quot;json&quot;.</p>

<p>If &quot;-r&quot; is specified, qemu-img tries to repair
any inconsistencies found during the check. &quot;-r
leaks&quot; repairs only cluster leaks, whereas &quot;-r
all&quot; fixes all kinds of errors, with a higher risk of
choosing the wrong fix or hiding corruption that has already
occured.</p>

<p>Only the formats &quot;qcow2&quot;, &quot;qed&quot; and
&quot;vdi&quot; support consistency checks.</p>

<p>In case the image does not have any inconsistencies,
check exits with 0. Other exit codes indicate the kind of
inconsistency found or if another error occurred. The
following table summarizes all exit codes of the check
subcommand:</p>

<p>0 Check completed, the image is (now) consistent</p>

<p>1 Check not completed because of internal errors</p>

<p>2 Check completed, image is corrupted</p>

<p>3 Check completed, image has leaked clusters, but is not
corrupted</p>

<p>63 Checks are not supported by the image format</p>

<p>If &quot;-r&quot; is specified, exit codes representing
the image state refer to the state after (the attempt at)
repairing it. That is, a successful &quot;-r all&quot; will
yield the exit code 0, independently of the image state
before.</p>

<p>create [-f fmt] [-o options] filename [size] Create the
new disk image filename of size size and format fmt.
Depending on the file format, you can add one or more
options that enable additional features of this format.</p>

<p>If the option backing_file is specified, then the image
will record only the differences from backing_file. No size
needs to be specified in this case. backing_file will never
be modified unless you use the &quot;commit&quot; monitor
command (or qemu-img commit).</p>

<p>The size can also be specified using the size option
with &quot;-o&quot;, it doesnt need to be specified
separately in this case.</p>

<p>commit [-f fmt] [-t cache] filename Commit the changes
recorded in filename in its base image.</p>

<p>compare [-f fmt] [-F fmt] [-T src_cache] [-p] [-s]
filename1 filename2 Check if two images have the same
content. You can compare images with different format or
settings.</p>

<p>The format is probed unless you specify it by -f (used
for filename1) and/or -F (used for filename2) option.</p>

<p>By default, images with different size are considered
identical if the larger image contains only unallocated
and/or zeroed sectors in the area after the end of the other
image. In addition, if any sector is not allocated in one
image and contains only zero bytes in the second one, it is
evaluated as equal. You can use Strict mode by specifying
the -s option. When compare runs in Strict mode, it fails in
case image size differs or a sector is allocated in one
image and is not allocated in the second one.</p>

<p>By default, compare prints out a result message. This
message displays information that both images are same or
the position of the first different byte. In addition,
result message can report different image size in case
Strict mode is used.</p>

<p>Compare exits with 0 in case the images are equal and
with 1 in case the images differ. Other exit codes mean an
error occurred during execution and standard error output
should contain an error message. The following table
sumarizes all exit codes of the compare subcommand:</p>

<p>0 Images are identical</p>

<p>1 Images differ</p>

<p>2 Error on opening an image</p>

<p>3 Error on checking a sector allocation</p>

<p>4 Error on reading data</p>

<p>convert [-c] [-p] [-f fmt] [-t cache] [-T src_cache] [-O
output_fmt] [-o options] [-S sparse_size] filename
[filename2 [...]] output_filename Convert the disk image
filename to disk image output_filename using format
output_fmt. It can be optionally compressed (&quot;-c&quot;
option) or use any format specific options like encryption
(&quot;-o&quot; option).</p>

<p>Only the formats &quot;qcow&quot; and &quot;qcow2&quot;
support compression. The compression is read-only. It means
that if a compressed sector is rewritten, then it is
rewritten as uncompressed data.</p>

<p>Image conversion is also useful to get smaller image
when using a growable format such as &quot;qcow&quot; or
&quot;cow&quot;: the empty sectors are detected and
suppressed from the destination image.</p>

<p>You can use the backing_file option to force the output
image to be created as a copy on write image of the
specified base image; the backing_file should have the same
content as the input s base image, however the path, image
format, etc may differ.</p>

<p>info [-f fmt] [--output=ofmt] filename Give information
about the disk image filename. Use it in particular to know
the size reserved on disk which can be different from the
displayed size. If VM snapshots are stored in the disk
image, they are displayed too. The command can output in the
format ofmt which is either &quot;human&quot; or
&quot;json&quot;.</p>

<p>map [-f fmt] [--output=ofmt] filename Dump the metadata
of image filename and its backing file chain. In particular,
this commands dumps the allocation state of every sector of
filename, together with the topmost file that allocates it
in the backing file chain.</p>

<p>Two option formats are possible. The default format
(&quot;human&quot;) only dumps known-nonzero areas of the
file. Known-zero parts of the file are omitted altogether,
and likewise for parts that are not allocated throughout the
chain. qemu-img output will identify a file from where the
data can be read, and the offset in the file. Each line will
include four fields, the first three of which are
hexadecimal numbers. For example the first line of:</p>

<p>Offset Length Mapped to File 0 0x20000 0x50000
/tmp/overlay.qcow2 0x100000 0x10000 0x95380000
/tmp/backing.qcow2</p>

<p>means that 0x20000 (131072) bytes starting at offset 0
in the image are available in /tmp/overlay.qcow2 (opened in
&quot;raw&quot; format) starting at offset 0x50000 (327680).
Data that is compressed, encrypted, or otherwise not
available in raw format will cause an error if
&quot;human&quot; format is in use. Note that file names can
include newlines, thus it is not safe to parse this output
format in scripts.</p>

<p>The alternative format &quot;json&quot; will return an
array of dictionaries in JSON format. It will include
similar information in the &quot;start&quot;,
&quot;length&quot;, &quot;offset&quot; fields; it will also
include other more specific information:</p>

<p>- whether the sectors contain actual data or not
(boolean field &quot;data&quot;; if false, the sectors are
either unallocated or stored as optimized all-zero
clusters);</p>

<p>- whether the data is known to read as zero (boolean
field &quot;zero&quot;);</p>

<p>- in order to make the output shorter, the target file
is expressed as a &quot;depth&quot;; for example, a depth of
2 refers to the backing file of the backing file of
filename.</p>

<p>In JSON format, the &quot;offset&quot; field is
optional; it is absent in cases where &quot;human&quot;
format would omit the entry or exit with an error. If
&quot;data&quot; is false and the &quot;offset&quot; field
is present, the corresponding sectors in the file are not
yet in use, but they are preallocated.</p>

<p>For more information, consult include/block/block.h in
QEMUs source code.</p>

<p>snapshot [-l | -a snapshot | -c snapshot | -d snapshot ]
filename List, apply, create or delete snapshots in image
filename.</p>

<p>rebase [-f fmt] [-t cache] [-T src_cache] [-p] [-u] -b
backing_file [-F backing_fmt] filename Changes the backing
file of an image. Only the formats &quot;qcow2&quot; and
&quot;qed&quot; support changing the backing file.</p>

<p>The backing file is changed to backing_file and (if the
image format of filename supports this) the backing file
format is changed to backing_fmt. If backing_file is
specified as &quot;&quot; (the empty string), then the image
is rebased onto no backing file (i.e. it will exist
independently of any backing file).</p>

<p>cache specifies the cache mode to be used for filename,
whereas src_cache specifies the cache mode for reading the
new backing file.</p>

<p>There are two different modes in which
&quot;rebase&quot; can operate:</p>

<p>Safe mode This is the default mode and performs a real
rebase operation. The new backing file may differ from the
old one and qemu-img rebase will take care of keeping the
guest-visible content of filename unchanged.</p>

<p>In order to achieve this, any clusters that differ
between backing_file and the old backing file of filename
are merged into filename before actually changing the
backing file.</p>

<p>Note that the safe mode is an expensive operation,
comparable to converting an image. It only works if the old
backing file still exists.</p>

<p>Unsafe mode qemu-img uses the unsafe mode if
&quot;-u&quot; is specified. In this mode, only the backing
file name and format of filename is changed without any
checks on the file contents. The user must take care of
specifying the correct new backing file, or the
guest-visible content of the image will be corrupted.</p>

<p>This mode is useful for renaming or moving the backing
file to somewhere else. It can be used without an accessible
old backing file, i.e. you can use it to fix an image whose
backing file has already been moved/renamed.</p>

<p>resize filename [+ | -]size Change the disk image as if
it had been created with size.</p>

<p>Before using this command to shrink a disk image, you
MUST use file system and partitioning tools inside the VM to
reduce allocated file systems and partition sizes
accordingly. Failure to do so will result in data loss!</p>

<p>After using this command to grow a disk image, you must
use file system and partitioning tools inside the VM to
actually begin using the new space on the device.</p>

<p>Supported image file formats:</p>

<p>raw Raw disk image format (default). This format has the
advantage of being simple and easily exportable to all other
emulators. If your file system supports holes (for example
in ext2 or ext3 on Linux or NTFS on Windows), then only the
written sectors will reserve space. Use &quot;qemu-img
info&quot; to know the real size used by the image or
&quot;ls -ls&quot; on Unix/Linux.</p>

<p>Supported options:</p>

<p>&quot;preallocation&quot; Preallocation mode (allowed
values: &quot;off&quot;, &quot;falloc&quot;,
&quot;full&quot;). &quot;falloc&quot; mode preallocates
space for image by calling posix_fallocate().
&quot;full&quot; mode preallocates space for image by
writing zeros to underlying storage.</p>

<p>qcow2 QEMU image format, the most versatile format. Use
it to have smaller images (useful if your filesystem does
not supports holes, for example on Windows), optional AES
encryption, zlib based compression and support of multiple
VM snapshots.</p>

<p>Supported options:</p>

<p>&quot;backing_file&quot; File name of a base image (see
create subcommand)</p>

<p>&quot;backing_fmt&quot; Image format of the base
image</p>

<p>&quot;encryption&quot; If this option is set to
&quot;on&quot;, the image is encrypted.</p>

<p>Encryption uses the AES format which is very secure (128
bit keys). Use a long password (16 characters) to get
maximum protection.</p>

<p>&quot;cluster_size&quot; Changes the qcow2 cluster size
(must be between 512 and 2M). Smaller cluster sizes can
improve the image file size whereas larger cluster sizes
generally provide better performance.</p>

<p>&quot;preallocation&quot; Preallocation mode (allowed
values: &quot;off&quot;, &quot;metadata&quot;,
&quot;falloc&quot;, &quot;full&quot;). An image with
preallocated metadata is initially larger but can improve
performance when the image needs to grow. &quot;falloc&quot;
and &quot;full&quot; preallocations are like the same
options of &quot;raw&quot; format, but sets up metadata
also.</p>

<p>qcow Old QEMU image format. Left for compatibility.</p>

<p>Supported options:</p>

<p>&quot;backing_file&quot; File name of a base image (see
create subcommand)</p>

<p>&quot;encryption&quot; If this option is set to
&quot;on&quot;, the image is encrypted.</p>

<p>cow User Mode Linux Copy On Write image format. Used to
be the only growable image format in QEMU. It is supported
only for compatibility with previous versions. It does not
work on win32.</p>

<p>vdi VirtualBox 1.1 compatible image format.</p>

<p>vmdk VMware 3 and 4 compatible image format.</p>

<p>Supported options:</p>

<p>&quot;backing_fmt&quot; Image format of the base
image</p>

<p>&quot;compat6&quot; Create a VMDK version 6 image
(instead of version 4)</p>

<p>vpc VirtualPC compatible image format (VHD).</p>

<p>vhdx Hyper-V compatible image format (VHDX).</p>

<p>cloop Linux Compressed Loop image, useful only to reuse
directly compressed CD-ROM images present for example in the
Knoppix CD- ROMs.</p>

<p>SEE ALSO The HTML documentation of QEMU for more precise
information and Linux user mode emulator invocation.</p>

<p>AUTHOR Fabrice Bellard</p>

<p>2015-06-22 QEMU-IMG(1)</p>
<hr>
</body>
</html>
