<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:27 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLTODO(1) Perl Programmers Reference Guide
PERLTODO(1)</p>

<p>NAME perltodo - Perl TO-DO List</p>

<p>DESCRIPTION This is a list of wishes for Perl. The most
up to date version of this file is at
http://perl5.git.perl.org/perl.git/blob_plain/HEAD:/pod/perltodo.pod</p>

<p>The tasks we think are smaller or easier are listed
first. Anyone is welcome to work on any of these, but its a
good idea to first contact perl5-porters@perl.org to avoid
duplication of effort, and to learn from any previous
attempts. By all means contact a pumpking privately first if
you prefer.</p>

<p>Whilst patches to make the list shorter are most
welcome, ideas to add to the list are also encouraged. Check
the perl5-porters archives for past ideas, and any
discussion about them. One set of archives may be found
at:</p>


<p>http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/</p>

<p>What can we offer you in return? Fame, fortune, and
everlasting glory? Maybe not, but if your patch is
incorporated, then well add your name to the AUTHORS file,
which ships in the official distribution. How many other
programming languages offer you 1 line of immortality?</p>

<p>Tasks that only need Perl knowledge Remove macperl
references from tests MacPerl is gone. The tests dont need
to be there.</p>

<p>Remove duplication of test setup. Schwern notes, that
theres duplication of code - lots and lots of tests have
some variation on the big block of $Is_Foo checks. We can
safely put this into a file, change it to build an %Is hash
and require it. Maybe just put it into test.pl. Throw in the
handy tainting subroutines.</p>

<p>POD -&gt; HTML conversion in the core still sucks Which
is crazy given just how simple POD purports to be, and how
simple HTML can be. It s not actually as simple as it
sounds, particularly with the flexibility POD allows for
&quot;=item&quot;, but it would be good to improve the
visual appeal of the HTML generated, and to avoid it having
any validation errors. See also &quot;make HTML install
work&quot;, as the layout of installation tree is needed to
improve the cross-linking.</p>

<p>The addition of &quot;Pod::Simple&quot; and its related
modules may make this task easier to complete.</p>

<p>Make ExtUtils::ParseXS use strict;
lib/ExtUtils/ParseXS.pm contains this line</p>

<p># use strict; # One of these days...</p>

<p>Simply uncomment it, and fix all the resulting issues
:-)</p>

<p>The more practical approach, to break the task down into
manageable chunks, is to work your way though the code from
bottom to top, or if necessary adding extra &quot;{ ...
}&quot; blocks, and turning on strict within them.</p>

<p>Parallel testing (This probably impacts much more than
the core: also the Test::Harness and TAP::* modules on
CPAN.)</p>

<p>All of the tests in t/ can now be run in parallel, if
$ENV{TEST_JOBS} is set. However, tests within each directory
in ext and lib are still run in series, with directories run
in parallel. This is an adequate heuristic, but it might be
possible to relax it further, and get more throughput.
Specifically, it would be good to audit all of lib/*.t, and
make them use &quot;File::Temp&quot;.</p>

<p>Make Schwern poorer We should have tests for everything.
When all the core s modules are tested, Schwern has promised
to donate to $500 to TPF. We may need volunteers to hold him
upside down and shake vigorously in order to actually
extract the cash.</p>

<p>Improve the coverage of the core tests Use Devel::Cover
to ascertain the core moduless test coverage, then add tests
that are currently missing.</p>

<p>test B A full test suite for the B module would be
nice.</p>

<p>A decent benchmark &quot;perlbench&quot; seems
impervious to any recent changes made to the perl core. It
would be useful to have a reasonable general benchmarking
suite that roughly represented what current perl programs
do, and measurably reported whether tweaks to the core
improve, degrade or dont really affect performance, to guide
people attempting to optimise the guts of perl. Gisle would
welcome new tests for perlbench.</p>

<p>fix tainting bugs Fix the bugs revealed by running the
test suite with the &quot;-t&quot; switch (via &quot;make
test.taintwarn&quot;).</p>

<p>Dual life everything As part of the &quot;dists&quot;
plan, anything that doesnt belong in the smallest perl
distribution needs to be dual lifed. Anything else can be
too. Figure out what changes would be needed to package that
module and its tests up for CPAN, and do so. Test it with
older perl releases, and fix the problems you find.</p>

<p>To make a minimal perl distribution, its useful to look
at t/lib/commonsense.t.</p>

<p>Bundle dual life modules in ext/ For maintenance (and
branch merging) reasons, it would be useful to move some
architecture-independent dual-life modules from lib/ to
ext/, if this has no negative impact on the build of perl
itself.</p>

<p>POSIX memory footprint Ilya observed that use POSIX;
eats memory like theres no tomorrow, and at various times
worked to cut it down. There is probably still fat to cut
out - for example POSIX passes Exporter some very memory
hungry data structures.</p>

<p>embed.pl/makedef.pl There is a script embed.pl that
generates several header files to prefix all of Perl s
symbols in a consistent way, to provide some semblance of
namespace support in &quot;C&quot;. Functions are declared
in embed.fnc, variables in interpvar.h. Quite a few of the
functions and variables are conditionally declared there,
using &quot;#ifdef&quot;. However, embed.pl doesn t
understand the C macros, so the rules about which symbols
are present when is duplicated in makedef.pl. Writing things
twice is bad, mkay. It would be good to teach
&quot;embed.pl&quot; to understand the conditional
compilation, and hence remove the duplication, and the
mistakes it has caused.</p>

<p>use strict; and AutoLoad Currently if you write</p>

<p>package Whack; use AutoLoader &rsquo;AUTOLOAD&rsquo;;
use strict; 1; __END__ sub bloop { print join (&rsquo;
&rsquo;, No, strict, here), &quot;!0; }</p>

<p>then &quot;use strict;&quot; isn t in force within the
autoloaded subroutines. It would be more consistent (and
less surprising) to arrange for all lexical pragmas in force
at the __END__ block to be in force within each autoloaded
subroutine.</p>

<p>Theres a similar problem with SelfLoader.</p>

<p>profile installman The installman script is slow. All it
is doing text processing, which we re told is something Perl
is good at. So it would be nice to know what it is doing
that is taking so much CPU, and where possible address
it.</p>

<p>Tasks that need a little sysadmin-type knowledge Or if
you prefer, tasks that you would learn from, and broaden
your skills base...</p>

<p>make HTML install work There is an
&quot;installhtml&quot; target in the Makefile. It s marked
as &quot;experimental&quot;. It would be good to get this
tested, make it work reliably, and remove the
&quot;experimental&quot; tag. This would include</p>

<p>1. Checking that cross linking between various parts of
the documentation works. In particular that links work
between the modules (files with POD in lib/) and the core
documentation (files in pod/)</p>

<p>2. Work out how to split &quot;perlfunc&quot; into
chunks, preferably one per function group, preferably with
general case code that could be used elsewhere. Challenges
here are correctly identifying the groups of functions that
go together, and making the right named external cross-links
point to the right page. Things to be aware of are
&quot;-X&quot;, groups such as &quot;getpwnam&quot; to
&quot;endservent&quot;, two or more &quot;=items&quot;
giving the different parameter lists, such as</p>

<p>=item substr EXPR,OFFSET,LENGTH,REPLACEMENT =item substr
EXPR,OFFSET,LENGTH =item substr EXPR,OFFSET</p>

<p>and different parameter lists having different meanings.
(eg &quot;select&quot;)</p>

<p>compressed man pages Be able to install them. This would
probably need a configure test to see how the system does
compressed man pages (same directory/different directory?
same filename/different filename), as well as tweaking the
installman script to compress as necessary.</p>

<p>Add a code coverage target to the Makefile Make it easy
for anyone to run Devel::Cover on the cores tests. The steps
to do this manually are roughly</p>

<p>&middot; do a normal &quot;Configure&quot;, but include
Devel::Cover as a module to install (see INSTALL for how to
do this)</p>

<p>&middot;</p>

<p>make perl</p>

<p>&middot;</p>

<p>cd t; HARNESS_PERL_SWITCHES=-MDevel::Cover ./perl
-I../lib harness</p>

<p>&middot; Process the resulting Devel::Cover database</p>

<p>This just give you the coverage of the .pms. To also get
the C level coverage you need to</p>

<p>&middot; Additionally tell &quot;Configure&quot; to use
the appropriate C compiler flags for &quot;gcov&quot;</p>

<p>&middot;</p>

<p>make perl.gcov</p>

<p>(instead of &quot;make perl&quot;)</p>

<p>&middot; After running the tests run &quot;gcov&quot; to
generate all the .gcov files. (Including down in the
subdirectories of ext/</p>

<p>&middot; (From the top level perl directory) run
&quot;gcov2perl&quot; on all the &quot;.gcov&quot; files to
get their stats into the cover_db directory.</p>

<p>&middot; Then process the Devel::Cover database</p>

<p>It would be good to add a single switch to
&quot;Configure&quot; to specify that you wanted to perform
perl level coverage, and another to specify C level
coverage, and have &quot;Configure&quot; and the Makefile do
all the right things automatically.</p>

<p>Make Config.pm cope with differences between built and
installed perl Quite often vendors ship a perl binary
compiled with their (pay-for) compilers. People install a
free compiler, such as gcc. To work out how to build
extensions, Perl interrogates %Config, so in this situation
%Config describes compilers that aren t there, and extension
building fails. This forces people into choosing between
re-compiling perl themselves using the compiler they have,
or only using modules that the vendor ships.</p>

<p>It would be good to find a way teach
&quot;Config.pm&quot; about the installation setup, possibly
involving probing at install time or later, so that the
%Config in a binary distribution better describes the
installed machine, when the installed machine differs from
the build machine in some significant way.</p>

<p>linker specification files Some platforms mandate that
you provide a list of a shared librarys external symbols to
the linker, so the core already has the infrastructure in
place to do this for generating shared perl libraries. My
understanding is that the GNU toolchain can accept an
optional linker specification file, and restrict visibility
just to symbols declared in that file. It would be good to
extend makedef.pl to support this format, and to provide a
means within &quot;Configure&quot; to enable it. This would
allow Unix users to test that the export list is correct,
and to build a perl that does not pollute the global
namespace with private symbols.</p>

<p>Cross-compile support Currently &quot;Configure&quot;
understands &quot;-Dusecrosscompile&quot; option. This
option arranges for building &quot;miniperl&quot; for TARGET
machine, so this &quot;miniperl&quot; is assumed then to be
copied to TARGET machine and used as a replacement of full
&quot;perl&quot; executable.</p>

<p>This could be done little differently. Namely
&quot;miniperl&quot; should be built for HOST and then full
&quot;perl&quot; with extensions should be compiled for
TARGET. This, however, might require extra trickery for
%Config: we have one config first for HOST and then another
for TARGET. Tools like MakeMaker will be mightily confused.
Having around two different types of executables and
libraries (HOST and TARGET) makes life interesting for
Makefiles and shell (and Perl) scripts. There is
$Config{run}, normally empty, which can be used as an
execution wrapper. Also note that in some
cross-compilation/execution environments the HOST and the
TARGET do not see the same filesystem(s), the $Config{run}
may need to do some file/directory copying back and
forth.</p>

<p>roffitall Make pod/roffitall be updated by
pod/buildtoc.</p>

<p>Split &quot;linker&quot; from &quot;compiler&quot; Right
now, Configure probes for two commands, and sets two
variables:</p>

<p>&middot; &quot;cc&quot; (in cc.U)</p>

<p>This variable holds the name of a command to execute a C
compiler which can resolve multiple global references that
happen to have the same name. Usual values are cc and gcc.
Fervent ANSI compilers may be called c89. AIX has xlc.</p>

<p>&middot; &quot;ld&quot; (in dlsrc.U)</p>

<p>This variable indicates the program to be used to link
libraries for dynamic loading. On some systems, it is ld. On
ELF systems, it should be $cc. Mostly, well try to respect
the hint file setting.</p>

<p>There is an implicit historical assumption from around
Perl5.000alpha something, that $cc is also the correct
command for linking object files together to make an
executable. This may be true on Unix, but its not true on
other platforms, and there are a maze of work arounds in
other places (such as Makefile.SH) to cope with this.</p>

<p>Ideally, we should create a new variable to hold the
name of the executable linker program, probe for it in
Configure, and centralise all the special case logic there
or in hints files.</p>

<p>A small bikeshed issue remains - what to call it, given
that $ld is already taken (arguably for the wrong thing now,
but on SunOS 4.1 it is the command for creating
dynamically-loadable modules) and $link could be confused
with the Unix command line executable of the same name,
which does something completely different. Andy Dougherty
makes the counter argument &quot;In parrot, I tried to call
the command used to link object files and libraries into an
executable link, since thats what my vaguely-remembered DOS
and VMS experience suggested. I dont think any real
confusion has ensued, so it s probably a reasonable name for
perl5 to use.&quot;</p>

<p>&quot;Alas, Ive always worried that introducing it would
make things worse, since now the module building utilities
would have to look for $Config{link} and institute a
fall-back plan if it weren t found.&quot; Although I can see
that as confusing, given that $Config{d_link} is true when
(hard) links are available.</p>

<p>Configure Windows using PowerShell Currently, Windows
uses hard-coded config files based to build the config.h for
compiling Perl. Makefiles are also hard-coded and need to be
hand edited prior to building Perl. While this makes it easy
to create a perl.exe that works across multiple Windows
versions, being able to accurately configure a perl.exe for
a specific Windows versions and VS C++ would be a nice
enhancement. With PowerShell available on Windows XP and up,
this may now be possible. Step 1 might be to investigate
whether this is possible and use this to clean up our
current makefile situation. Step 2 would be to see if there
would be a way to use our existing metaconfig units to
configure a Windows Perl or whether we go in a separate
direction and make it so. Of course, we all know what step 3
is.</p>

<p>decouple -g and -DDEBUGGING Currently Configure
automatically adds &quot;-DDEBUGGING&quot; to the C compiler
flags if it spots &quot;-g&quot; in the optimiser flags. The
pre-processor directive &quot;DEBUGGING&quot; enables perl s
command line &lt;-D&gt; options, but in the process makes
perl slower. It would be good to disentangle this logic, so
that C-level debugging with &quot;-g&quot; and Perl level
debugging with &quot;-D&quot; can easily be enabled
independently.</p>

<p>Tasks that need a little C knowledge These tasks would
need a little C knowledge, but dont need any specific
background or experience with XS, or how the Perl
interpreter works</p>

<p>Weed out needless PERL_UNUSED_ARG The C code uses the
macro &quot;PERL_UNUSED_ARG&quot; to stop compilers warning
about unused arguments. Often the arguments can t be
removed, as there is an external constraint that determines
the prototype of the function, so this approach is valid.
However, there are some cases where
&quot;PERL_UNUSED_ARG&quot; could be removed.
Specifically</p>

<p>&middot; The prototypes of (nearly all) static functions
can be changed</p>

<p>&middot; Unused arguments generated by short cut macros
are wasteful - the short cut macro used can be changed.</p>

<p>Modernize the order of directories in @INC The way @INC
is laid out by default, one cannot upgrade core (dual- life)
modules without overwriting files. This causes problems for
binary package builders. One possible proposal is laid out
in this message:
&lt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-04/msg02380.html&gt;.</p>

<p>-Duse32bit* Natively 64-bit systems need neither
-Duse64bitint nor -Duse64bitall. On these systems, it might
be the default compilation mode, and there is currently no
guarantee that passing no use64bitall option to the
Configure process will build a 32bit perl. Implementing
-Duse32bit* options would be nice for perl 5.12.</p>

<p>Profile Perl - am I hot or not? The Perl source code is
stable enough that it makes sense to profile it, identify
and optimise the hotspots. It would be good to measure the
performance of the Perl interpreter using free tools such as
cachegrind, gprof, and dtrace, and work to reduce the
bottlenecks they reveal.</p>

<p>As part of this, the idea of pp_hot.c is that it
contains the hot ops, the ops that are most commonly used.
The idea is that by grouping them, their object code will be
adjacent in the executable, so they have a greater chance of
already being in the CPU cache (or swapped in) due to being
near another op already in use.</p>

<p>Except that its not clear if these really are the most
commonly used ops. So as part of exercising your skills with
coverage and profiling tools you might want to determine
what ops really are the most commonly used. And in turn
suggest evictions and promotions to achieve a better
pp_hot.c.</p>

<p>One piece of Perl code that might make a good testbed is
installman.</p>

<p>Allocate OPs from arenas Currently all new OP structures
are individually malloc()ed and free()d. All
&quot;malloc&quot; implementations have space overheads, and
are now as fast as custom allocates so it would both use
less memory and less CPU to allocate the various OP
structures from arenas. The SV arena code can probably be
re-used for this.</p>

<p>Note that Configuring perl with
&quot;-Accflags=-DPL_OP_SLAB_ALLOC&quot; will use
Perl_Slab_alloc() to pack optrees into a contiguous block,
which is probably superior to the use of OP arenas, esp.
from a cache locality standpoint. See &quot;Profile Perl -
am I hot or not?&quot;.</p>

<p>Improve win32/wince.c Currently, numerous functions look
virtually, if not completely, identical in both
&quot;win32/wince.c&quot; and &quot;win32/win32.c&quot;
files, which cant be good.</p>

<p>Use secure CRT functions when building with VC8 on Win32
Visual C++ 2005 (VC++ 8.x) deprecated a number of CRT
functions on the basis that they were &quot;unsafe&quot; and
introduced differently named secure versions of them as
replacements, e.g. instead of writing</p>

<p>FILE* f = fopen(__FILE__, &quot;r&quot;);</p>

<p>one should now write</p>

<p>FILE* f; errno_t err = fopen_s(&amp;f, __FILE__,
&quot;r&quot;);</p>

<p>Currently, the warnings about these deprecations have
been disabled by adding -D_CRT_SECURE_NO_DEPRECATE to the
CFLAGS. It would be nice to remove that warning suppressant
and actually make use of the new secure CRT functions.</p>

<p>There is also a similar issue with POSIX CRT function
names like fileno having been deprecated in favour of ISO
C++ conformant names like _fileno. These warnings are also
currently suppressed by adding -D_CRT_NONSTDC_NO_DEPRECATE.
It might be nice to do as Microsoft suggest here too,
although, unlike the secure functions issue, there is
presumably little or no benefit in this case.</p>

<p>Fix POSIX::access() and chdir() on Win32 These functions
currently take no account of DACLs and therefore do not
behave correctly in situations where access is restricted by
DACLs (as opposed to the read-only attribute).</p>

<p>Furthermore, POSIX::access() behaves differently for
directories having the read-only attribute set depending on
what CRT library is being used. For example, the _access()
function in the VC6 and VC7 CRTs (wrongly) claim that such
directories are not writable, whereas in fact all
directories are writable unless access is denied by DACLs.
(In the case of directories, the read-only attribute
actually only means that the directory cannot be deleted.)
This CRT bug is fixed in the VC8 and VC9 CRTs (but, of
course, the directory may still not actually be writable if
access is indeed denied by DACLs).</p>

<p>For the chdir() issue, see ActiveState bug #74552:
http://bugs.activestate.com/show_bug.cgi?id=74552</p>

<p>Therefore, DACLs should be checked both for consistency
across CRTs and for the correct answer.</p>

<p>(Note that perl s -w operator should not be modified to
check DACLs. It has been written so that it reflects the
state of the read-only attribute, even for directories
(whatever CRT is being used), for symmetry with
chmod().)</p>

<p>strcat(), strcpy(), strncat(), strncpy(), sprintf(),
vsprintf() Maybe create a utility that checks after each
libperl.a creation that none of the above (nor sprintf(),
vsprintf(), or *SHUDDER* gets()) ever creep back to
libperl.a.</p>

<p>nm libperl.a | ./miniperl -alne &rsquo;$o = $F[0] if
/:$/; print &quot;$o $F[1]&quot; if $F[0] eq &quot;U&quot;
&amp;&amp; $F[1] =~
/^(?:strn?c(?:at|py)|v?sprintf|gets)$/&rsquo;</p>

<p>Note, of course, that this will only tell whether your
platform is using those naughty interfaces.</p>

<p>-D_FORTIFY_SOURCE=2, -fstack-protector Recent glibcs
support &quot;-D_FORTIFY_SOURCE=2&quot; and recent gcc (4.1
onwards?) supports &quot;-fstack-protector&quot;, both of
which give protection against various kinds of buffer
overflow problems. These should probably be used for
compiling Perl whenever available, Configure and/or hints
files should be adjusted to probe for the availability of
these features and enable them as appropriate.</p>

<p>Arenas for GPs? For MAGIC? &quot;struct gp&quot; and
&quot;struct magic&quot; are both currently allocated by
&quot;malloc&quot;. It might be a speed or memory saving to
change to using arenas. Or it might not. It would need some
suitable benchmarking first. In particular, &quot;GP&quot;s
can probably be changed with minimal compatibility impact
(probably nothing outside of the core, or even outside of
gv.c allocates them), but they probably arent
allocated/deallocated often enough for a speed saving.
Whereas &quot;MAGIC&quot; is allocated/deallocated more
often, but in turn, is also something more externally
visible, so changing the rules here may bite external
code.</p>

<p>Shared arenas Several SV body structs are now the same
size, notably PVMG and PVGV, PVAV and PVHV, and PVCV and
PVFM. It should be possible to allocate and return same
sized bodies from the same actual arena, rather than
maintaining one arena for each. This could save 4-6K per
thread, of memory no longer tied up in the not-yet-allocated
part of an arena.</p>

<p>Tasks that need a knowledge of XS These tasks would need
C knowledge, and roughly the level of knowledge of the perl
API that comes from writing modules that use XS to interface
to C.</p>

<p>Remove the use of SVs as temporaries in dump.c dump.c
contains debugging routines to dump out the contains of perl
data structures, such as &quot;SV&quot;s, &quot;AV&quot;s
and &quot;HV&quot;s. Currently, the dumping code uses
&quot;SV&quot;s for its temporary buffers, which was a
logical initial implementation choice, as they provide ready
made memory handling.</p>

<p>However, they also lead to a lot of confusion when it
happens that what you re trying to debug is seen by the code
in dump.c, correctly or incorrectly, as a temporary scalar
it can use for a temporary buffer. It s also not possible to
dump scalars before the interpreter is properly set up, such
as during ithreads cloning. It would be good to
progressively replace the use of scalars as string
accumulation buffers with something much simpler, directly
allocated by &quot;malloc&quot;. The dump.c code is (or
should be) only producing 7 bit US-ASCII, so output
character sets are not an issue.</p>

<p>Producing and proving an internal simple buffer
allocation would make it easier to re-write the internals of
the PerlIO subsystem to avoid using &quot;SV&quot;s for its
buffers, use of which can cause problems similar to those of
dump.c, at similar times.</p>

<p>safely supporting POSIX SA_SIGINFO Some years ago Jarkko
supplied patches to provide support for the POSIX SA_SIGINFO
feature in Perl, passing the extra data to the Perl signal
handler.</p>

<p>Unfortunately, it only works with &quot;unsafe&quot;
signals, because under safe signals, by the time Perl gets
to run the signal handler, the extra information has been
lost. Moreover, its not easy to store it somewhere, as you
cant call mutexs, or do anything else fancy, from inside a
signal handler.</p>

<p>So it strikes me that we could provide safe SA_SIGINFO
support</p>

<p>1. Provide global variables for two file descriptors</p>

<p>2. When the first request is made via
&quot;sigaction&quot; for &quot;SA_SIGINFO&quot;, create a
pipe, store the reader in one, the writer in the other</p>

<p>3. In the &quot;safe&quot; signal handler
(&quot;Perl_csighandler()&quot;/&quot;S_raise_signal()&quot;),
if the &quot;siginfo_t&quot; pointer non-&quot;NULL&quot;,
and the writer file handle is open,</p>

<p>1. serialise signal number, &quot;struct siginfo_t&quot;
(or at least the parts we care about) into a small auto char
buff</p>

<p>2. &quot;write()&quot; that (non-blocking) to the writer
fd</p>

<p>1. if it writes 100%, flag the signal in a counter of
&quot;signals on the pipe&quot; akin to the current
per-signal-number counts</p>

<p>2. if it writes 0%, assume the pipe is full. Flag the
data as lost?</p>

<p>3. if it writes partially, croak a panic, as your OS is
broken.</p>

<p>4. in the regular &quot;PERL_ASYNC_CHECK()&quot;
processing, if there are &quot;signals on the pipe&quot;,
read the data out, deserialise, build the Perl structures on
the stack (code in &quot;Perl_sighandler()&quot;, the
&quot;unsafe&quot; handler), and call as usual.</p>

<p>I think that this gets us decent &quot;SA_SIGINFO&quot;
support, without the current risk of running Perl code
inside the signal handler context. (With all the dangers of
things like &quot;malloc&quot; corruption that that
currently offers us)</p>

<p>For more information see the thread starting with this
message:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2008-03/msg00305.html</p>

<p>autovivification Make all autovivification consistent
w.r.t LVALUE/RVALUE and strict/no strict;</p>

<p>This task is incremental - even a little bit of work on
it will help.</p>

<p>Unicode in Filenames chdir, chmod, chown, chroot, exec,
glob, link, lstat, mkdir, open, opendir, qx, readdir,
readlink, rename, rmdir, stat, symlink, sysopen, system,
truncate, unlink, utime, -X. All these could potentially
accept Unicode filenames either as input or output (and in
the case of system and qx Unicode in general, as input or
output to/from the shell). Whether a filesystem - an
operating system pair understands Unicode in filenames
varies.</p>

<p>Known combinations that have some level of understanding
include Microsoft NTFS, Apple HFS+ (In Mac OS 9 and X) and
Apple UFS (in Mac OS X), NFS v4 is rumored to be Unicode,
and of course Plan 9. How to create Unicode filenames, what
forms of Unicode are accepted and used (UCS-2, UTF-16,
UTF-8), what (if any) is the normalization form used, and so
on, varies. Finding the right level of interfacing to Perl
requires some thought. Remember that an OS does not
implicate a filesystem.</p>

<p>(The Windows -C command flag &quot;wide API
support&quot; has been at least temporarily retired in
5.8.1, and the -C has been repurposed, see perlrun.)</p>

<p>Most probably the right way to do this would be this:
&quot;Virtualize operating system access&quot;.</p>

<p>Unicode in %ENV Currently the %ENV entries are always
byte strings. See &quot;Virtualize operating system
access&quot;.</p>

<p>Unicode and glob() Currently glob patterns and filenames
returned from File::Glob::glob() are always byte strings.
See &quot;Virtualize operating system access&quot;.</p>

<p>Unicode and lc/uc operators Some built-in operators
(&quot;lc&quot;, &quot;uc&quot;, etc.) behave differently,
based on what the internal encoding of their argument is.
That should not be the case. Maybe add a pragma to switch
behaviour.</p>

<p>use lessmemory Investigate trade offs to switch out perl
s choices on memory usage. Particularly perl should be able
to give memory back.</p>

<p>This task is incremental - even a little bit of work on
it will help.</p>

<p>Re-implement &quot;:unique&quot; in a way that is
actually thread-safe The old implementation made bad
assumptions on several levels. A good 90% solution might be
just to make &quot;:unique&quot; work to share the string
buffer of SvPVs. That way large constant strings can be
shared between ithreads, such as the configuration
information in Config.</p>

<p>Make tainting consistent Tainting would be easier to use
if it didn t take documented shortcuts and allow taint to
&quot;leak&quot; everywhere within an expression.</p>

<p>readpipe(LIST) system() accepts a LIST syntax (and a
PROGRAM LIST syntax) to avoid running a shell. readpipe()
(the function behind qx//) could be similarly extended.</p>

<p>Audit the code for destruction ordering assumptions
Change 25773 notes</p>

<p>/* Need to check SvMAGICAL, as during global destruction
it may be that AvARYLEN(av) has been freed before av, and
hence the SvANY() pointer is now part of the linked list of
SV heads, rather than pointing to the original body. */ /*
FIXME - audit the code for other bugs like this one. */</p>

<p>adding the &quot;SvMAGICAL&quot; check to</p>

<p>if (AvARYLEN(av) &amp;&amp; SvMAGICAL(AvARYLEN(av))) {
MAGIC *mg = mg_find (AvARYLEN(av), PERL_MAGIC_arylen);</p>

<p>Go through the core and look for similar assumptions
that SVs have particular types, as all bets are off during
global destruction.</p>

<p>Extend PerlIO and PerlIO::Scalar PerlIO::Scalar doesn t
know how to truncate(). Implementing this would require
extending the PerlIO vtable.</p>

<p>Similarly the PerlIO vtable doesn t know about formats
(write()), or about stat(), or chmod()/chown(), utime(), or
flock().</p>

<p>(For PerlIO::Scalar its hard to see what e.g. mode bits
or ownership would mean.)</p>

<p>PerlIO doesnt do directories or symlinks, either:
mkdir(), rmdir(), opendir(), closedir(), seekdir(),
rewinddir(), glob(); symlink(), readlink().</p>

<p>See also &quot;Virtualize operating system
access&quot;.</p>

<p>-C on the #! line It should be possible to make -C work
correctly if found on the #! line, given that all perl
command line options are strict ASCII, and -C changes only
the interpretation of non-ASCII characters, and not for the
script file handle. To make it work needs some investigation
of the ordering of function calls during startup, and (by
implication) a bit of tweaking of that order.</p>

<p>Duplicate logic in S_method_common() and
Perl_gv_fetchmethod_autoload() A comment in
&quot;S_method_common&quot; notes</p>

<p>/* This code tries to figure out just what went wrong
with gv_fetchmethod. It therefore needs to duplicate a lot
of the internals of that function. We can&rsquo;t move it
inside Perl_gv_fetchmethod_autoload(), however, since that
would cause
UNIVERSAL-&gt;can(&quot;NoSuchPackage::foo&quot;) to croak,
and we don&rsquo;t want that. */</p>

<p>If &quot;Perl_gv_fetchmethod_autoload&quot; gets
rewritten to take (more) flag bits, then it ought to be
possible to move the logic from &quot;S_method_common&quot;
to the &quot;right&quot; place. When making this change it
would probably be good to also pass in at least the method
name length, if not also pre-computed hash values when
known. (I m contemplating a plan to pre-compute hash values
for common fixed strings such as &quot;ISA&quot; and pass
them in to functions.)</p>

<p>Organize error messages Perls diagnostics (error
messages, see perldiag) could use reorganizing and
formalizing so that each error message has its stable-
for-all-eternity unique id, categorized by severity, type,
and subsystem. (The error messages would be listed in a
datafile outside of the Perl source code, and the source
code would only refer to the messages by the id.) This
clean-up and regularizing should apply for all croak()
messages.</p>

<p>This would enable all sorts of things: easier
translation/localization of the messages (though please do
keep in mind the caveats of Locale::Maketext about too
straightforward approaches to translation), filtering by
severity, and instead of grepping for a particular error
message one could look for a stable error id. (Of course,
changing the error messages by default would break all the
existing software depending on some particular error
message...)</p>

<p>This kind of functionality is known as message catalogs.
Look for inspiration for example in the catgets() system,
possibly even use it if available-- but only if available,
all platforms will not have catgets().</p>

<p>For the really pure at heart, consider extending this
item to cover also the warning messages (see perllexwarn,
&quot;warnings.pl&quot;).</p>

<p>Tasks that need a knowledge of the interpreter These
tasks would need C knowledge, and knowledge of how the
interpreter works, or a willingness to learn.</p>

<p>forbid labels with keyword names Currently &quot;goto
keyword&quot; &quot;computes&quot; the label value:</p>

<p>$ perl -e &rsquo;goto print&rsquo; Can&rsquo;t find
label 1 at -e line 1.</p>

<p>It would be nice to forbid labels with keyword names, to
avoid confusion.</p>

<p>truncate() prototype The prototype of truncate() is
currently $$. It should probably be &quot;*$&quot; instead.
(This is changed in opcode.pl)</p>

<p>decapsulation of smart match argument Currently
&quot;$foo ~~ $object&quot; will die with the message
&quot;Smart matching a non-overloaded object breaks
encapsulation&quot;. It would be nice to allow to bypass
this by using explictly the syntax &quot;$foo ~~
%$object&quot; or &quot;$foo ~~ @$object&quot;.</p>

<p>error reporting of [$a ; $b] Using &quot;;&quot; inside
brackets is a syntax error, and we dont propose to change
that by giving it any meaning. However, it s not reported
very helpfully:</p>

<p>$ perl -e &rsquo;$a = [$b; $c];&rsquo; syntax error at
-e line 1, near &quot;$b;&quot; syntax error at -e line 1,
near &quot;$c]&quot; Execution of -e aborted due to
compilation errors.</p>

<p>It should be possible to hook into the tokeniser or the
lexer, so that when a &quot;;&quot; is parsed where it is
not legal as a statement terminator (ie inside
&quot;{}&quot; used as a hashref, &quot;[]&quot; or
&quot;()&quot;) it issues an error something like ;_isnt
legal inside an expression - if you need multiple statements
use a do {...} block. See the thread starting at
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2008-09/msg00573.html</p>

<p>lexicals used only once This warns:</p>

<p>$ perl -we &rsquo;$pie = 42&rsquo; Name
&quot;main::pie&quot; used only once: possible typo at -e
line 1.</p>

<p>This does not:</p>

<p>$ perl -we &rsquo;my $pie = 42&rsquo;</p>

<p>Logically all lexicals used only once should warn, if
the user asks for warnings. An unworked RT ticket (#5087)
has been open for almost seven years for this
discrepancy.</p>

<p>UTF-8 revamp The handling of Unicode is unclean in many
places. For example, the regexp engine matches in Unicode
semantics whenever the string or the pattern is flagged as
UTF-8, but that should not be dependent on an internal
storage detail of the string. Likewise, case folding
behaviour is dependent on the UTF8 internal flag being on or
off.</p>

<p>Properly Unicode safe tokeniser and pads. The tokeniser
isnt actually very UTF-8 clean. &quot;use utf8;&quot; is a
hack - variable names are stored in stashes as raw bytes,
without the utf-8 flag set. The pad API only takes a
&quot;char *&quot; pointer, so thats all bytes too. The
tokeniser ignores the UTF-8-ness of &quot;PL_rsfp&quot;, or
any SVs returned from source filters. All this could be
fixed.</p>

<p>state variable initialization in list context Currently
this is illegal:</p>

<p>state ($a, $b) = foo();</p>

<p>In Perl 6, &quot;state ($a) = foo();&quot; and
&quot;(state $a) = foo();&quot; have different semantics,
which is tricky to implement in Perl 5 as currently they
produce the same opcode trees. The Perl 6 design is firm, so
it would be good to implement the necessary code in Perl 5.
There are comments in &quot;Perl_newASSIGNOP()&quot; that
show the code paths taken by various assignment
constructions involving state variables.</p>

<p>Implement $value ~~ 0 .. $range It would be nice to
extend the syntax of the &quot;~~&quot; operator to also
understand numeric (and maybe alphanumeric) ranges.</p>

<p>A does() built-in Like ref(), only useful. It would call
the &quot;DOES&quot; method on objects; it would also tell
whether something can be dereferenced as an array/hash/etc.,
or used as a regexp, etc.
&lt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2007-03/msg00481.html&gt;</p>

<p>Tied filehandles and write() dot mix There is no method
on tied filehandles to allow them to be called back by
formats.</p>

<p>Propagate compilation hints to the debugger Currently a
debugger started with -dE on the command-line doesnt see the
features enabled by -E. More generally hints ($^H and
&quot;%^H&quot;) arent propagated to the debugger. Probably
it would be a good thing to propagate hints from the
innermost non-&quot;DB::&quot; scope: this would make code
eval ed in the debugger see the features (and strictures,
etc.) currently in scope.</p>

<p>Attach/detach debugger from running program The old
perltodo notes &quot;With &quot;gdb&quot;, you can attach
the debugger to a running program if you pass the process
ID. It would be good to do this with the Perl debugger on a
running Perl program, although Im not sure how it would be
done.&quot; ssh and screen do this with named pipes in /tmp.
Maybe we can too.</p>

<p>LVALUE functions for lists The old perltodo notes that
lvalue functions dont work for list or hash slices. This
would be good to fix.</p>

<p>regexp optimiser optional The regexp optimiser is not
optional. It should configurable to be, to allow its
performance to be measured, and its bugs to be easily
demonstrated.</p>

<p>delete &amp;function Allow to delete functions. One can
already undef them, but theyre still in the stash.</p>

<p>&quot;/w&quot; regex modifier That flag would enable to
match whole words, and also to interpolate arrays as
alternations. With it, &quot;/P/w&quot; would be roughly
equivalent to:</p>

<p>? : do { local $&quot;=&rsquo;|&rsquo;; /P )</p>

<p>See
&lt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2007-01/msg00400.html&gt;
for the discussion.</p>

<p>optional optimizer Make the peephole optimizer optional.
Currently it performs two tasks as it walks the optree -
genuine peephole optimisations, and necessary fixups of ops.
It would be good to find an efficient way to switch out the
optimisations whilst keeping the fixups.</p>

<p>You WANT *how* many Currently contexts are void, scalar
and list. split has a special mechanism in place to pass in
the number of return values wanted. It would be useful to
have a general mechanism for this, backwards compatible and
little speed hit. This would allow proposals such as short
circuiting sort to be implemented as a module on CPAN.</p>

<p>lexical aliases Allow lexical aliases (maybe via the
syntax &quot;my lias = oo&quot;.</p>

<p>entersub XS vs Perl At the moment pp_entersub is huge,
and has code to deal with entering both perl and XS
subroutines. Subroutine implementations rarely change
between perl and XS at run time, so investigate using 2 ops
to enter subs (one for XS, one for perl) and swap between if
a sub is redefined.</p>

<p>Self-ties Self-ties are currently illegal because they
caused too many segfaults. Maybe the causes of these could
be tracked down and self-ties on all types reinstated.</p>

<p>Optimize away @_ The old perltodo notes &quot;Look at
the &quot;reification&quot; code in
&quot;av.c&quot;&quot;.</p>

<p>The yada yada yada operators Perl 6s Synopsis 3
says:</p>

<p>The ... operator is the &quot;yada, yada, yada&quot;
list operator, which is used as the body in function
prototypes. It complains bitterly (by calling fail) if it is
ever executed. Variant ??? calls warn, and !!! calls
die.</p>

<p>Those would be nice to add to Perl 5. That could be done
without new ops.</p>

<p>Virtualize operating system access Implement a set of
&quot;vtables&quot; that virtualizes operating system access
(open(), mkdir(), unlink(), readdir(), getenv(), etc.) At
the very least these interfaces should take SVs as
&quot;name&quot; arguments instead of bare char pointers;
probably the most flexible and extensible way would be for
the Perl-facing interfaces to accept HVs. The system needs
to be per-operating-system and per-file-system
hookable/filterable, preferably both from XS and Perl level
(&quot;Files and Filesystems&quot; in perlport is good
reading at this point, in fact, all of perlport is.)</p>

<p>This has actually already been implemented (but only for
Win32), take a look at iperlsys.h and win32/perlhost.h.
While all Win32 variants go through a set of
&quot;vtables&quot; for operating system access, non-Win32
systems currently go straight for the POSIX/UNIX-style
system/library call. Similar system as for Win32 should be
implemented for all platforms. The existing Win32
implementation probably does not need to survive alongside
this proposed new implementation, the approaches could be
merged.</p>

<p>What would this give us? One often-asked-for feature
this would enable is using Unicode for filenames, and other
&quot;names&quot; like %ENV, usernames, hostnames, and so
forth. (See &quot;When Unicode Does Not Happen&quot; in
perlunicode.)</p>

<p>But this kind of virtualization would also allow for
things like virtual filesystems, virtual networks, and
&quot;sandboxes&quot; (though as long as dynamic loading of
random object code is allowed, not very safe sandboxes since
external code of course know not of Perls vtables). An
example of a smaller &quot;sandbox&quot; is that this
feature can be used to implement per-thread working
directories: Win32 already does this.</p>

<p>See also &quot;Extend PerlIO and
PerlIO::Scalar&quot;.</p>

<p>Investigate PADTMP hash pessimisation The peephole
optimiser converts constants used for hash key lookups to
shared hash key scalars. Under ithreads, something is
undoing this work. See
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2007-09/msg00793.html</p>

<p>Store the current pad in the OP slab allocator Currently
we leak ops in various cases of parse failure. I suggested
that we could solve this by always using the op slab
allocator, and walking it to free ops. Dave comments that as
some ops are already freed during optree creation one would
have to mark which ops are freed, and not double free them
when walking the slab. He notes that one problem with this
is that for some ops you have to know which pad was current
at the time of allocation, which does change. I suggested
storing a pointer to the current pad in the memory allocated
for the slab, and swapping to a new slab each time the pad
changes. Dave thinks that this would work.</p>

<p>repack the optree Repacking the optree after execution
order is determined could allow removal of NULL ops, and
optimal ordering of OPs with respect to cache- line filling.
The slab allocator could be reused for this purpose. I think
that the best way to do this is to make it an optional step
just before the completed optree is attached to anything
else, and to use the slab allocator unchanged, so that
freeing ops is identical whether or not this step runs. Note
that the slab allocator allocates ops downwards in memory,
so one would have to actually &quot;allocate&quot; the ops
in reverse-execution order to get them contiguous in memory
in execution order.</p>

<p>See
http://www.nntp.perl.org/group/perl.perl5.porters/2007/12/msg131975.html</p>

<p>Note that running this copy, and then freeing all the
old location ops would cause their slabs to be freed, which
would eliminate possible memory wastage if the previous
suggestion is implemented, and we swap slabs more
frequently.</p>

<p>eliminate incorrect line numbers in warnings This
code</p>

<p>use warnings; my $undef;</p>

<p>if ($undef == 3) { } elsif ($undef == 0) { }</p>

<p>used to produce this output:</p>

<p>Use of uninitialized value in numeric eq (==) at
wrong.pl line 4. Use of uninitialized value in numeric eq
(==) at wrong.pl line 4.</p>

<p>where the line of the second warning was misreported -
it should be line 5. Rafael fixed this - the problem arose
because there was no nextstate OP between the execution of
the &quot;if&quot; and the &quot;elsif&quot;, hence
&quot;PL_curcop&quot; still reports that the currently
executing line is line 4. The solution was to inject a
nextstate OPs for each &quot;elsif&quot;, although it turned
out that the nextstate OP needed to be a nulled OP, rather
than a live nextstate OP, else other line numbers became
misreported. (Jenga!)</p>

<p>The problem is more general than &quot;elsif&quot;
(although the &quot;elsif&quot; case is the most common and
the most confusing). Ideally this code</p>

<p>use warnings; my $undef;</p>

<p>my $a = $undef + 1; my $b = $undef + 1;</p>

<p>would produce this output</p>

<p>Use of uninitialized value $undef in addition (+) at
wrong.pl line 4. Use of uninitialized value $undef in
addition (+) at wrong.pl line 7.</p>

<p>(rather than lines 4 and 5), but this would seem to
require every OP to carry (at least) line number
information.</p>

<p>What might work is to have an optional line number in
memory just before the BASEOP structure, with a flag bit in
the op to say whether it s present. Initially during compile
every OP would carry its line number. Then add a late pass
to the optimiser (potentially combined with &quot;repack the
optree&quot;) which looks at the two ops on every edge of
the graph of the execution path. If the line number changes,
flags the destination OP with this information. Once all
paths are traced, replace every op with the flag with a
nextstate-light op (that just updates
&quot;PL_curcop&quot;), which in turn then passes control on
to the true op. All ops would then be replaced by variants
that do not store the line number. (Which, logically, why it
would work best in conjunction with &quot;repack the
optree&quot;, as that is already copying/reallocating all
the OPs)</p>

<p>(Although I should note that were not certain that doing
this for the general case is worth it)</p>

<p>optimize tail-calls Tail-calls present an opportunity
for broadly applicable optimization; anywhere that
&quot;return foo(...)&quot; is called, the outer return can
be replaced by a goto, and foo will return directly to the
outer caller, saving (conservatively) 25% of perls
call&amp;return cost, which is relatively higher than in C.
The scheme language is known to do this heavily. B::Concise
provides good insight into where this optimization is
possible, ie anywhere entersub,leavesub op-sequence
occurs.</p>

<p>perl -MO=Concise,-exec,a,b,-main -e &rsquo;sub a{ 1 };
sub b {a()}; b(2)&rsquo;</p>

<p>Bottom line on this is probably a new pp_tailcall
function which combines the code in pp_entersub,
pp_leavesub. This should probably be done 1st in XS, and
using B::Generate to patch the new OP into the optrees.</p>

<p>&quot; It should be possible to add a &quot;egex
assertion, meaning &quot;every character except &quot;0AX
independently of the context. That would of course imply
that &quot;ouldnt be followed by an opening
&quot;{&quot;.</p>

<p>Big projects Tasks that will get your name mentioned in
the description of the &quot;Highlights of 5.12&quot;</p>

<p>make ithreads more robust Generally make ithreads more
robust. See also &quot;iCOW&quot;</p>

<p>This task is incremental - even a little bit of work on
it will help, and will be greatly appreciated.</p>

<p>One bit would be to write the missing code in
sv.c:Perl_dirp_dup.</p>

<p>Fix Perl_sv_dup, et al so that threads can return
objects.</p>

<p>iCOW Sarathy and Arthur have a proposal for an improved
Copy On Write which specifically will be able to COW new
ithreads. If this can be implemented it would be a good
thing.</p>

<p>(?{...}) closures in regexps Fix (or rewrite) the
implementation of the &quot;/(?{...})/&quot; closures.</p>

<p>A re-entrant regexp engine This will allow the use of a
regex from inside (?{ }), (??{ }) and (?(?{ })|)
constructs.</p>

<p>Add class set operations to regexp engine Apparently
these are quite useful. Anyway, Jeffery Friedl wants
them.</p>

<p>demerphq has this on his todo list, but right at the
bottom.</p>

<p>Tasks for microperl [ Each and every one of these may be
obsolete, but they were listed in the old Todo.micro
file]</p>

<p>make creating uconfig.sh automatic make creating
Makefile.micro automatic do away with fork/exec/wait?
(system, popen should be enough?)</p>

<p>some of the uconfig.sh really needs to be probed (using
cc) in buildtime: (uConfigure? :-) native datatype widths
and endianness come to mind</p>

<p>perl v5.10.1 2009-08-10 PERLTODO(1)</p>
<hr>
</body>
</html>
