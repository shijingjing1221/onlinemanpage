<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:17:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>guestfs-faq(1) Virtualization Support guestfs-faq(1)</p>

<p>NAME guestfs-faq - libguestfs Frequently Asked Questions
(FAQ)</p>

<p>ABOUT LIBGUESTFS What is libguestfs? libguestfs is a way
to create, access and modify disk images. You can look
inside disk images, modify the files they contain, create
them from scratch, resize them, and much more. Its
especially useful from scripts and programs and from the
command line.</p>

<p>libguestfs is a C library (hence &quot;lib-&quot;), and
a set of tools built on this library, and bindings for many
common programming languages.</p>

<p>For more information about what libguestfs can do read
the introduction on the home page
(http://libguestfs.org).</p>

<p>What are the virt tools? Virt tools (website:
http://virt-tools.org) are a whole set of virtualization
management tools aimed at system administrators. Some of
them come from libguestfs, some from libvirt and many others
from other open source projects. So virt tools is a superset
of libguestfs. However libguestfs comes with many important
tools. See http://libguestfs.org for a full list.</p>

<p>Does libguestfs need { libvirt / KVM / Red Hat / Fedora
}? No!</p>

<p>libvirt is not a requirement for libguestfs.</p>

<p>libguestfs works with any disk image, including ones
created in VMware, KVM, qemu, VirtualBox, Xen, and many
other hypervisors, and ones which you have created from
scratch.</p>

<p>RedHat sponsors (ie. pays for) development of libguestfs
and a huge number of other open source projects. But you can
run libguestfs and the virt tools on many different Linux
distros and Mac OS X. We try our best to support all Linux
distros as first-class citizens. Some virt tools have been
ported to Windows.</p>

<p>How does libguestfs compare to other tools? vs. kpartx
Libguestfs takes a different approach from kpartx. kpartx
needs root, and mounts filesystems on the host kernel (which
can be insecure - see &quot;SECURITY&quot; in guestfs(3)).
Libguestfs isolates your host kernel from guests, is more
flexible, scriptable, supports LVM, doesnt require root, is
isolated from other processes, and cleans up after itself.
Libguestfs is more than just file access because you can use
it to create images from scratch.</p>

<p>vs. vdfuse vdfuse is like kpartx but for VirtualBox
images. See the kpartx comparison above. You can use
libguestfs on the partition files exposed by vdfuse,
although its not necessary since libguestfs can access
VirtualBox images directly.</p>

<p>vs. qemu-nbd NBD (Network Block Device) is a protocol
for exporting block devices over the network. qemu-nbd is an
NBD server which can handle any disk format supported by
qemu (eg. raw, qcow2). You can use libguestfs and qemu-nbd
together to access block devices over the network, for
example: &quot;guestfish -a nbd://remote&quot;</p>

<p>vs. mounting filesystems in the host Mounting guest
filesystems in the host is insecure and should be avoided
completely for untrusted guests. Use libguestfs to provide a
layer of protection against filesystem exploits. See also
guestmount(1).</p>

<p>vs. parted Libguestfs supports LVM. Libguestfs uses
parted and provides most parted features through the
libguestfs API.</p>

<p>GETTING HELP AND REPORTING BUGS How do I know what
version m using? The simplest method is:</p>

<p>guestfish --version</p>

<p>Libguestfs development happens along an unstable branch
and we periodically create a stable branch which we backport
stable patches to. To find out more, read &quot;LIBGUESTFS
VERSION NUMBERS&quot; in guestfs(3).</p>

<p>How can I get help? What mailing lists or chat rooms are
available? If you are a RedHat customer using Red Hat
Enterprise Linux, please contact RedHatSupport:
http://redhat.com/support</p>

<p>There is a mailing list, mainly for development, but
users are also welcome to ask questions about libguestfs and
the virt tools:
https://www.redhat.com/mailman/listinfo/libguestfs</p>

<p>You can also talk to us on IRC channel
&quot;#libguestfs&quot; on FreeNode. We re not always
around, so please stay in the channel after asking your
question and someone will get back to you.</p>

<p>For other virt tools (not ones supplied with libguestfs)
there is a general virt tools mailing list:
https://www.redhat.com/mailman/listinfo/virt-tools-list</p>

<p>How do I report bugs? Please use the following link to
enter a bug in Bugzilla:</p>


<p>https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p>Include as much detail as you can and a way to reproduce
the problem.</p>

<p>Include the full output of libguestfs-test-tool(1).</p>

<p>COMMON PROBLEMS See also &quot;LIBGUESTFS GOTCHAS&quot;
in guestfs(3) for some &quot;gotchas&quot; with using the
libguestfs API.</p>

<p>&quot;Could not allocate dynamic translator buffer&quot;
This obscure error is in fact an SELinux failure. You have
to enable the following SELinux boolean:</p>

<p>setsebool -P virt_use_execmem=on</p>

<p>For more information see
https://bugzilla.redhat.com/show_bug.cgi?id=806106.</p>

<p>&quot;child process died unexpectedly&quot; This error
indicates that qemu failed or the host kernel could not
boot. To get further information about the failure, you have
to run:</p>

<p>libguestfs-test-tool</p>

<p>If, after using this, you still don t understand the
failure, contact us (see previous section).</p>

<p>libguestfs: error: cannot find any suitable libguestfs
supermin, fixed or old-style appliance on LIBGUESTFS_PATH If
you see this error on Debian/Ubuntu, you need to run the
following command as root:</p>

<p>update-guestfs-appliance</p>

<p>Non-ASCII characters dot appear on VFAT filesystems.
Typical symptoms of this problem:</p>

<p>&middot; You get an error when you create a file where
the filename contains non-ASCII characters, particularly non
8-bit characters from Asian languages (Chinese, Japanese,
etc). The filesystem is VFAT.</p>

<p>&middot; When you list a directory from a VFAT
filesystem, filenames appear as question marks.</p>

<p>This is a design flaw of the GNU/Linux system.</p>

<p>VFAT stores long filenames as UTF-16 characters. When
opening or returning filenames, the Linux kernel has to
translate these to some form of 8 bit string. UTF-8 would be
the obvious choice, except for Linux users who persist in
using non-UTF-8 locales (the users locale is not known to
the kernel because it s a function of libc).</p>

<p>Therefore you have to tell the kernel what translation
you want done when you mount the filesystem. The two methods
are the &quot;iocharset&quot; parameter (which is not
relevant to libguestfs) and the &quot;utf8&quot; flag.</p>

<p>So to use a VFAT filesystem you must add the
&quot;utf8&quot; flag when mounting. From guestfish,
use:</p>

<p>&gt;&lt;fs&gt; mount-options utf8 /dev/sda1 /</p>

<p>or on the guestfish command line:</p>

<p>guestfish [...] -m /dev/sda1:/:utf8</p>

<p>or from the API:</p>

<p>guestfs_mount_options (g, &quot;utf8&quot;,
&quot;/dev/sda1&quot;, &quot;/&quot;);</p>

<p>The kernel will then translate filenames to and from
UTF-8 strings.</p>

<p>We considered adding this mount option transparently,
but unfortunately there are several problems with doing
that:</p>

<p>&middot; On some Linux systems, the &quot;utf8&quot;
mount option doesnt work. We dont precisely understand what
systems or why, but this was reliably reported by one
user.</p>

<p>&middot; It would prevent you from using the
&quot;iocharset&quot; parameter because it is incompatible
with &quot;utf8&quot;. It is probably not a good idea to use
this parameter, but we dont want to prevent it.</p>

<p>Non-ASCII characters appear as underscore (_) on ISO9660
filesystems. The filesystem was not prepared correctly with
mkisofs or genisoimage. Make sure the filesystem was created
using Joliet and/or Rock Ridge extensions. libguestfs does
not require any special mount options to handle the
filesystem.</p>

<p>DOWNLOADING, INSTALLING, COMPILING LIBGUESTFS Where can
I get the latest binaries for ...? Fedora 11 Use:</p>

<p>yum install &rsquo;*guestf*&rsquo;</p>

<p>For the latest builds, see:
http://koji.fedoraproject.org/koji/packageinfo?packageID=8391</p>

<p>Red Hat Enterprise Linux RHEL 5 The version shipped in
official RHEL 5 is very old and should not be used except in
conjunction with virt-v2v. Use the up- to-date libguestfs
1.20 package in EPEL 5:
https://fedoraproject.org/wiki/EPEL</p>

<p>RHEL 6 It is part of the default install. On RHEL 6 and
7 (only) you have to install
&quot;libguestfs-winsupport&quot; to get Windows guest
support.</p>

<p>RHEL 6.5 There is a preview repository available for
people who want to see what packages will be in RHEL 6.5.
Follow the instructions here:</p>


<p>https://www.redhat.com/archives/libguestfs/2013-May/msg00100.html</p>

<p>RHEL 7 It will be part of the default install, and based
on libguestfs1.22. You will need to install
&quot;libguestfs-winsupport&quot; separately to get Windows
guest support.</p>

<p>Debian and Ubuntu Debian Squeeze (6) Hilko Bengen has
built libguestfs in squeeze backports:
http://packages.debian.org/search?keywords=guestfs&amp;searchon=names&amp;section=all&amp;suite=squeeze-backports</p>

<p>Debian Wheezy and later (7+) Hilko Bengen supports
libguestfs on Debian. Official Debian packages are
available:
http://packages.debian.org/search?keywords=libguestfs</p>

<p>Ubuntu We don t have a full time Ubuntu maintainer, and
the packages supplied by Canonical (which are outside our
control) are sometimes broken.</p>

<p>Canonical decided to change the permissions on the
kernel so that its not readable except by root. This is
completely stupid, but they wont change it
(https://bugs.launchpad.net/ubuntu/+source/linux/+bug/759725).
So every user should do this:</p>

<p>sudo chmod 0644 /boot/vmlinuz*</p>

<p>Ubuntu 12.04 libguestfs in this version of Ubuntu works,
but you need to update febootstrap and seabios to the latest
versions.</p>

<p>You need febootstrap 3.14-2 from:
http://packages.ubuntu.com/precise/febootstrap</p>

<p>After installing or updating febootstrap, rebuild the
appliance:</p>

<p>sudo update-guestfs-appliance</p>

<p>You need seabios 0.6.2-0ubuntu2.1 or 0.6.2-0ubuntu3
from: http://packages.ubuntu.com/precise-updates/seabios or
http://packages.ubuntu.com/quantal/seabios</p>

<p>Also you need to do (see above):</p>

<p>sudo chmod 0644 /boot/vmlinuz*</p>

<p>Gentoo Libguestfs was added to Gentoo in 2012-07 by
Andreis Vinogradovs (libguestfs) and Maxim Koltsov (mainly
hivex). Do:</p>

<p>emerge libguestfs</p>

<p>SuSE Libguestfs was added to SuSE in 2012 by Olaf
Hering.</p>

<p>ArchLinux Libguestfs was added to the AUR in 2010.</p>

<p>Other Linux distro Compile from source (next
section).</p>

<p>Other non-Linux distro Youll have to compile from
source, and port it.</p>

<p>How can I compile and install libguestfs from source? If
your Linux distro has a working port of supermin (that is,
Fedora, RedHatEnterpriseLinux6.3, Debian, Ubuntu and
ArchLinux) then you should just be able to compile from
source in the usual way. Download the latest tarball from
http://libguestfs.org/download, unpack it, and start by
reading the README file.</p>

<p>If you dont have supermin, you will need to use the
&quot;fixed appliance method&quot;. See:
http://libguestfs.org/download/binaries/appliance/</p>

<p>Patches to port supermin to more Linux distros are
welcome.</p>

<p>Why do I get an error when I try to rebuild from the
source RPMs supplied by Red Hat / Fedora? Note: This issue
is fixed in Fedora19 and RHEL6.5.</p>

<p>Because of the complexity of building the libguestfs
appliance, the source RPMs provided cannot be rebuilt
directly using &quot;rpmbuild&quot; or &quot;mock&quot;.</p>

<p>If you use Koji (which is open source software and may
be installed locally), then the SRPMs can be rebuilt in
Koji. https://fedoraproject.org/wiki/Koji</p>

<p>If you dont have or want to use Koji, then you have to
give libguestfs access to the network so it can download the
RPMs for building the appliance. You also need to set an RPM
macro to tell libguestfs to use the network. Put the
following line into a file called
&quot;$HOME/.rpmmacros&quot;:</p>

<p>%libguestfs_buildnet 1</p>

<p>If you are using mock, do:</p>

<p>mock -D &rsquo;%libguestfs_buildnet 1&rsquo; [etc]</p>

<p>How can I add support for sVirt? Note for Fedora/RHEL
users: This configuration is the default starting with
Fedora18 and RHEL7. If you find any problems, please let us
know or file a bug.</p>

<p>SVirt provides a hardened appliance using SELinux,
making it very hard for a rogue disk image to
&quot;escape&quot; from the confinement of libguestfs and
damage the host (its fair to say that even in standard
libguestfs this would be hard, but sVirt provides an extra
layer of protection for the host and more importantly
protects virtual machines on the same host from each
other).</p>

<p>Currently to enable sVirt you will need libvirt 0.10.2
(1.0 or later preferred), libguestfs 1.20, and the SELinux
policies from recent Fedora. If you are not running
Fedora18+, you will need to make changes to your SELinux
policy - contact us on the mailing list.</p>

<p>Once you have the requirements, do:</p>

<p>./configure --with-default-attach-method=libvirt
make</p>

<p>Set SELinux to Enforcing mode, and sVirt should be used
automatically.</p>

<p>All, or almost all, features of libguestfs should work
under sVirt. There is one known shortcoming: virt-rescue(1)
will not use libvirt (hence sVirt), but falls back to direct
launch of qemu. So you wont currently get the benefit of
sVirt protection when using virt-rescue.</p>

<p>You can check if sVirt is being used by enabling
libvirtd logging (see
&quot;/etc/libvirt/libvirtd.log&quot;), killing and
restarting libvirtd, and checking the log files for
&quot;SettingSELinuxcontexton...&quot; messages.</p>

<p>In theory sVirt should support AppArmor, but we have not
tried it. It will almost certainly require patching libvirt
and writing an AppArmor policy.</p>

<p>Libguestfs has a really long list of dependencies! Thats
because it does a lot of things.</p>

<p>Libguestfs -- as it is packaged for Fedora -- satisfies
the following conditions:</p>

<p>1. The Fedora package is full featured, that is, it
supports every possible feature of libguestfs (every
filesystem, every filesystem tool, etc.)</p>

<p>A common request is to split up libguestfs into separate
feature areas so you could, say, install XFS support and
NTFS support separately. This is not possible right now.</p>

<p>2. The download size of the libguestfs package is
relatively small (ie. not tens of megabytes as it would be
if it included a complete, &quot;statically linked&quot;
appliance).</p>

<p>3. The Fedora package automatically updates itself if
there is a security update. It doesnt include a huge static
blob that has to be rebuilt and users have to re-download if
there is an update.</p>

<p>4. Able to be installed without needing direct network
access. This is important when using closed networks,
privately mirrored repositories or RHN Satellite.</p>

<p>5. The Fedora package can be tested during the
build.</p>

<p>If you want to drop any one of those conditions, then
you can package libguestfs differently and make it have
fewer dependencies, fewer features or a faster start up
time:</p>

<p>1. (full featured) Take
&quot;appliance/packagelist.in&quot; in the source, and
comment out any features you dont actually care about. For
example if you never anticipate editing a Windows guest,
remove all the ntfs-related packages. You can get away with
fewer dependencies.</p>

<p>2. (download size) / 3. (updates) Use
libguestfs-make-fixed-appliance(1) to build a compressed
appliance. Bundle this with your package and set
$LIBGUESTFS_PATH to point to it. Users will have to download
this large appliance, but no dependencies are needed, and
supermin-helper(1) is not used.</p>

<p>4. (network access) Reconstruct and cache the appliance
once during package install. The Debian packaging currently
works like this, but requires network access during package
install.</p>

<p>5. (tests) Don t run any tests during the build. The
build will be much faster, but also less likely to work
correctly.</p>

<p>Note that running the tests in &quot;tests/qemu&quot; is
probably a good idea, since those are sanity tests. Also you
should do &quot;makequickcheck&quot; to ensure libguestfs is
basically working.</p>

<p>Errors during launch on Fedora 18, RHEL 7 In Fedora 18
and RHEL 7, libguestfs uses libvirt to manage the appliance.
Previously (and upstream) libguestfs runs qemu directly:</p>

<p>+----------------------------------+ | libguestfs |
+----------------+-----------------+ | direct backend |
libvirt backend | +----------------+-----------------+ | | v
v +-------+ +----------+ | qemu | | libvirtd | +-------+
+----------+ | v +-------+ | qemu | +-------+</p>

<p>upstream Fedora 18+ non-Fedora RHEL 7+ non-RHEL</p>

<p>The libvirt backend is more sophisticated, supporting
SELinux/sVirt (see above), hotplugging and more. It is,
however, more complex and so less robust.</p>

<p>If you have permissions problems using the libvirt
backend, you can switch to the direct backend by setting
this environment variable:</p>

<p>export LIBGUESTFS_BACKEND=direct</p>

<p>before running any libguestfs program or virt tool.</p>

<p>How can I switch to a fixed / prebuilt appliance? This
may improve the stability and performance of libguestfs on
Fedora and RHEL.</p>

<p>Any time after installing libguestfs, run the following
commands as root:</p>

<p>mkdir -p /usr/local/lib/guestfs/appliance
libguestfs-make-fixed-appliance
/usr/local/lib/guestfs/appliance ls -l
/usr/local/lib/guestfs/appliance</p>

<p>Now set the following environment variable before using
libguestfs or any virt tool:</p>

<p>export
LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance</p>

<p>Of course you can change the path to any directory you
want. You can share the appliance across machines that have
the same architecture (eg. all x86-64), but note that
libvirt will prevent you from sharing the appliance across
NFS because of permissions problems (so either switch to the
direct backend or dont use NFS).</p>

<p>How can I speed up libguestfs builds? By far the most
important thing you can do is to install and properly
configure Squid. Note that the default configuration that
ships with Squid is rubbish, so configuring it is not
optional.</p>

<p>A very good place to start with Squid configuration is
here:
https://fedoraproject.org/wiki/Extras/MockTricks#Using_Squid_to_Speed_Up_Mock_package_downloads</p>

<p>Make sure Squid is running, and that the environment
variables $http_proxy and $ftp_proxy are pointing to it.</p>

<p>With Squid running and correctly configured, appliance
builds should be reduced to a few minutes.</p>

<p>How can I speed up libguestfs builds (Debian)?</p>

<p>Hilko Bengen suggests using &quot;approx&quot; which is
a Debian archive proxy (http://packages.debian.org/approx).
This tool is documented on Debian in the approx(8) manual
page.</p>

<p>SPEED, DISK SPACE USED BY LIBGUESTFS Note: Most of the
information in this section has moved:
guestfs-performance(1).</p>

<p>Upload or write seem very slow. In libguestfs &lt;
1.13.16, the mount command (&quot;guestfs_mount&quot; in
guestfs(3)) enabled option &quot;-o sync&quot; implicitly.
This causes very poor write performance, and was one of the
main gotchas for new libguestfs users.</p>

<p>For libguestfs &lt; 1.13.16, replace mount with
&quot;mount-options&quot;, leaving the first parameter as an
empty string.</p>

<p>You can also do this with more recent versions of
libguestfs, but if you know that you are using libguestfs
1.13.16 then it s safe to use plain mount.</p>

<p>If the underlying disk is not fully allocated (eg.
sparse raw or qcow2) then writes can be slow because the
host operating system has to do costly disk allocations
while you are writing. The solution is to use a fully
allocated format instead, ie. non-sparse raw, or qcow2 with
the &quot;preallocation=metadata&quot; option.</p>

<p>Libguestfs uses too much disk space! libguestfs caches a
large-ish appliance in:</p>

<p>/var/tmp/.guestfs-&lt;UID&gt;</p>

<p>If the environment variable &quot;TMPDIR&quot; is
defined, then &quot;$TMPDIR/.guestfs-&lt;UID&gt;&quot; is
used instead.</p>

<p>It is safe to delete this directory when you are not
using libguestfs.</p>

<p>virt-sparsify seems to make the image grow to the full
size of the virtual disk If the input to virt-sparsify(1) is
raw, then the output will be raw sparse. Make sure you are
measuring the output with a tool which understands
sparseness such as &quot;du -sh&quot;. It can make a huge
difference:</p>

<p>$ ls -lh test1.img -rw-rw-r--. 1 rjones rjones 100M Aug
8 08:08 test1.img $ du -sh test1.img 3.6M test1.img</p>

<p>(Compare the apparent size 100M vs the actual size
3.6M)</p>

<p>If all this confuses you, use a non-sparse output format
by specifying the --convert option, eg:</p>

<p>virt-sparsify --convert qcow2 disk.raw disk.qcow2</p>

<p>Why doest virt-resize work on the disk image in-place?
Resizing a disk image is very tricky -- especially making
sure that you dont lose data or break the bootloader. The
current method effectively creates a new disk image and
copies the data plus bootloader from the old one. If
something goes wrong, you can always go back to the
original.</p>

<p>If we were to make virt-resize work in-place then there
would have to be limitations: for example, you wouldn t be
allowed to move existing partitions (because moving data
across the same disk is most likely to corrupt data in the
event of a power failure or crash), and LVM would be very
difficult to support (because of the almost arbitrary
mapping between LV content and underlying disk blocks).</p>

<p>Another method we have considered is to place a snapshot
over the original disk image, so that the original data is
untouched and only differences are recorded in the snapshot.
You can do this today using &quot;qemu-img create&quot; +
&quot;virt-resize&quot;, but qemu currently isnt smart
enough to recognize when the same block is written back to
the snapshot as already exists in the backing disk, so you
will find that this doesnt save you any space or time.</p>

<p>In summary, this is a hard problem, and what we have now
mostly works so we are reluctant to change it.</p>

<p>Why doest virt-sparsify work on the disk image in-place?
Eventually we plan to make virt-sparsify work on disk images
in-place, instead of copying the disk image. However it
requires several changes to both the Linux kernel and qemu
which are slowly making their way upstream (thanks to the
tireless efforts of Paolo Bonzini). Then we will have to
modify virt-sparsify to support this. Finally there will be
some integration work required to make sure all the pieces
work together.</p>

<p>Even with this implemented there may be some
limitations: For example, it requires completely different
steps (and is probably harder) to sparsify a disk image that
is stored on a SAN LUN, compared to one which is stored in a
local raw image file, so you can expect that different
storage and backing formats will become supported at
different times. Some backing filesystems / formats may
never support sparsification (eg. disk images stored on
VFAT, old-style non-thin LVs).</p>

<p>USING LIBGUESTFS IN YOUR OWN PROGRAMS The API has
hundreds of methods, where do I start? We recommend you
start by reading the API overview: &quot;API OVERVIEW&quot;
in guestfs(3).</p>

<p>Although the API overview covers the C API, it is still
worth reading even if you are going to use another
programming language, because the API is the same, just with
simple logical changes to the names of the calls:</p>

<p>C guestfs_ln_sf (g, target, linkname); Python g.ln_sf
(target, linkname); OCaml g#ln_sf target linkname; Perl
$g-&gt;ln_sf (target, linkname); Shell (guestfish) ln-sf
target linkname PHP guestfs_ln_sf ($g, $target,
$linkname);</p>

<p>Once youre familiar with the API overview, you should
look at this list of starting points for other language
bindings: &quot;USING LIBGUESTFS WITH OTHER PROGRAMMING
LANGUAGES&quot; in guestfs(3).</p>

<p>Can I use libguestfs in my proprietary / closed source /
commercial program? In general, yes. However this is not
legal advice - read the license that comes with libguestfs,
and if you have specific questions contact a lawyer.</p>

<p>In the source tree the license is in the file
&quot;COPYING.LIB&quot; (LGPLv2+ for the library and
bindings) and &quot;COPYING&quot; (GPLv2+ for the standalone
programs).</p>

<p>DEBUGGING LIBGUESTFS Help, is not working! Please supply
all the information in this checklist, in an email sent to
&quot;libguestfs&quot; @ &quot;redhat.com&quot;:</p>

<p>&middot; What are you trying to achieve?</p>

<p>&middot; What exact commands did you run?</p>

<p>&middot; What was the precise error / output of these
commands?</p>

<p>&middot; Enable debugging, run the commands again, and
capture the complete output. Do not edit the output.</p>

<p>export LIBGUESTFS_DEBUG=1 export LIBGUESTFS_TRACE=1</p>

<p>&middot; Include the version of libguestfs, the
operating system version, and how you installed libguestfs
(eg. from source, &quot;yum install&quot;, etc.)</p>

<p>&middot; If no libguestfs program seems to work at all,
run the program below and paste the complete, unedited
output into the email:</p>

<p>libguestfs-test-tool</p>

<p>How do I debug when using any libguestfs program or tool
(eg. virt-v2v or virt-df)? There are two
&quot;LIBGUESTFS_*&quot; environment variables you can set
in order to get more information from libguestfs.</p>

<p>&quot;LIBGUESTFS_TRACE&quot; Set this to 1 and
libguestfs will print out each command / API call in a
format which is similar to guestfish commands.</p>

<p>&quot;LIBGUESTFS_DEBUG&quot; Set this to 1 in order to
enable massive amounts of debug messages. If you think there
is some problem inside the libguestfs appliance, then you
should use this option.</p>

<p>To set these from the shell, do this before running the
program:</p>

<p>export LIBGUESTFS_TRACE=1 export LIBGUESTFS_DEBUG=1</p>

<p>For csh/tcsh the equivalent commands would be:</p>

<p>setenv LIBGUESTFS_TRACE 1 setenv LIBGUESTFS_DEBUG 1</p>

<p>For further information, see: &quot;ENVIRONMENT
VARIABLES&quot; in guestfs(3).</p>

<p>How do I debug when using guestfish? You can use the
same environment variables above. Alternatively use the
guestfish options -x (to trace commands) or -v (to get the
full debug output), or both.</p>

<p>For further information, see: guestfish(1).</p>

<p>How do I debug when using the API? Call
&quot;guestfs_set_trace&quot; in guestfs(3) to enable
command traces, and/or &quot;guestfs_set_verbose&quot; in
guestfs(3) to enable debug messages.</p>

<p>For best results, call these functions as early as
possible, just after creating the guestfs handle if you can,
and definitely before calling launch.</p>

<p>How do I capture debug output and put it into my logging
system? Use the event API. For examples, see: &quot;SETTING
CALLBACKS TO HANDLE EVENTS&quot; in guestfs(3) and the
&quot;examples/debug-logging.c&quot; program in the
libguestfs sources.</p>

<p>Digging deeper into the appliance boot process. Enable
debugging and then read this documentation on the appliance
boot process: &quot;INTERNALS&quot; in guestfs(3).</p>

<p>libguestfs hangs or fails during run/launch. Enable
debugging and look at the full output. If you cannot work
out what is going on, file a bug report, including the
complete output of libguestfs-test-tool(1).</p>

<p>DESIGN/INTERNALS OF LIBGUESTFS Why dot you do everything
through the FUSE / filesystem interface? We offer a command
called guestmount(1) which lets you mount guest filesystems
on the host. This is implemented as a FUSE module. Why don t
we just implement the whole of libguestfs using this
mechanism, instead of having the large and rather
complicated API?</p>

<p>The reasons are twofold. Firstly, libguestfs offers API
calls for doing things like creating and deleting partitions
and logical volumes, which dont fit into a filesystem model
very easily. Or rather, you could fit them in: for example,
creating a partition could be mapped to &quot;mkdir
/fs/hda1&quot; but then youd have to specify some method to
choose the size of the partition (maybe &quot;echo 100M &gt;
/fs/hda1/.size&quot;), and the partition type, start and end
sectors etc., but once youve done that the filesystem-based
API starts to look more complicated than the call- based API
we currently have.</p>

<p>The second reason is for efficiency. FUSE itself is
reasonably efficient, but it does make lots of small,
independent calls into the FUSE module. In guestmount these
have to be translated into messages to the libguestfs
appliance which has a big overhead (in time and round
trips). For example, reading a file in 64 KB chunks is
inefficient because each chunk would turn into a single
round trip. In the libguestfs API it is much more efficient
to download an entire file or directory through one of the
streaming calls like &quot;guestfs_download&quot; or
&quot;guestfs_tar_out&quot;.</p>

<p>Why dot you do everything through GVFS? The problems are
similar to the problems with FUSE.</p>

<p>GVFS is a better abstraction than POSIX/FUSE. There is
an FTP backend for GVFS, which is encouraging because FTP is
conceptually similar to the libguestfs API. However the GVFS
FTP backend makes multiple simultaneous connections in order
to keep interactivity, which we cant easily do with
libguestfs.</p>

<p>Why can I write to the disk, even though I added it
read-only? Why does &quot;--ro&quot; appear to have no
effect? When you add a disk read-only, libguestfs places a
writable overlay on top of the underlying disk. Writes go
into this overlay, and are discarded when the handle is
closed (or &quot;guestfish&quot; etc. exits).</p>

<p>There are two reasons for doing it this way: Firstly
read-only disks aren t possible in many cases (eg. IDE
simply doesnt support them, so you couldnt have an
IDE-emulated read-only disk, although this is not common in
real libguestfs installations).</p>

<p>Secondly and more importantly, even if read-only disks
were possible, you wouldnt want them. Mounting any
filesystem that has a journal, even &quot;mount -o ro&quot;,
causes writes to the filesystem because the journal has to
be replayed and metadata updated. If the disk was truly
read- only, you wouldnt be able to mount a dirty
filesystem.</p>

<p>To make it usable, we create the overlay as a place to
temporarily store these writes, and then we discard it
afterwards. This ensures that the underlying disk is always
untouched.</p>

<p>Note also that there is a regression test for this when
building libguestfs (in &quot;tests/qemu&quot;). This is one
reason why it s important for packagers to run the test
suite.</p>

<p>Does &quot;--ro&quot; make all disks read-only? No! The
&quot;--ro&quot; option only affects disks added on the
command line, ie. using &quot;-a&quot; and &quot;-d&quot;
options.</p>

<p>In guestfish, if you use the &quot;add&quot; command,
then disk is added read- write (unless you specify the
&quot;readonly:true&quot; flag explicitly with the
command).</p>

<p>Can I use &quot;guestfish --ro&quot; as a way to backup
my virtual machines? Usually this is not a good idea. The
question is answered in more detail in this mailing list
posting:
https://www.redhat.com/archives/libguestfs/2010-August/msg00024.html</p>

<p>See also the next question.</p>

<p>Why can t I run fsck on a live filesystem using
&quot;guestfish --ro&quot;? This command will usually not
work:</p>

<p>guestfish --ro -a /dev/vg/my_root_fs run : fsck
/dev/sda</p>

<p>The reason for this is that qemu creates a snapshot over
the original filesystem, but it doesnt create a strict
point-in-time snapshot. Blocks of data on the underlying
filesystem are read by qemu at different times as the fsck
operation progresses, with host writes in between. The
result is that fsck sees massive corruption (imaginary, not
real!) and fails.</p>

<p>What you have to do is to create a point-in-time
snapshot. If its a logical volume, use an LVM2 snapshot. If
the filesystem is located inside something like a btrfs/ZFS
file, use a btrfs/ZFS snapshot, and then run the fsck on the
snapshot. In practice you don t need to use libguestfs for
this -- just run &quot;/sbin/fsck&quot; directly.</p>

<p>Creating point-in-time snapshots of host devices and
files is outside the scope of libguestfs, although
libguestfs can operate on them once they are created.</p>

<p>Whas the difference between guestfish and virt-rescue? A
lot of people are confused by the two superficially similar
tools we provide:</p>

<p>$ guestfish --ro -a guest.img &gt;&lt;fs&gt; run
&gt;&lt;fs&gt; fsck /dev/sda1</p>

<p>$ virt-rescue --ro guest.img &gt;&lt;rescue&gt;
/sbin/fsck /dev/sda1</p>

<p>And the related question which then arises is why you
cant type in full shell commands with all the --options in
guestfish (but you can in virt-rescue(1)).</p>

<p>guestfish(1) is a program providing structured access to
the guestfs(3) API. It happens to be a nice interactive
shell too, but its primary purpose is structured access from
shell scripts. Think of it more like a language binding,
like Python and other bindings, but for shell. The key
differentiating factor of guestfish (and the libguestfs API
in general) is the ability to automate changes.</p>

<p>virt-rescue(1) is a free-for-all freeform way to boot
the libguestfs appliance and make arbitrary changes to your
VM. It s not structured, you cant automate it, but for
making quick ad-hoc fixes to your guests, it can be quite
useful.</p>

<p>But, libguestfs also has a &quot;backdoor&quot; into the
appliance allowing you to send arbitrary shell commands. Its
not as flexible as virt-rescue, because you cant interact
with the shell commands, but here it is anyway:</p>

<p>&gt;&lt;fs&gt; debug sh &quot;cmd arg1 arg2
...&quot;</p>

<p>Note that you should not rely on this. It could be
removed or changed in future. If your program needs some
operation, please add it to the libguestfs API instead.</p>

<p>Whas the deal with &quot;guestfish -i&quot;? Why does
virt-cat only work on a real VM image, but virt-df works on
any disk image? What does &quot;no root device found in this
operating system image&quot; mean? These questions are all
related at a fundamental level which may not be immediately
obvious.</p>

<p>At the guestfs(3) API level, a &quot;disk image&quot; is
just a pile of partitions and filesystems.</p>

<p>In contrast, when the virtual machine boots, it mounts
those filesystems into a consistent hierarchy such as:</p>

<p>/ (/dev/sda2) | +-- /boot (/dev/sda1) | +-- /home
(/dev/vg_external/Homes) | +-- /usr (/dev/vg_os/lv_usr) |
+-- /var (/dev/vg_os/lv_var)</p>

<p>(or drive letters on Windows).</p>

<p>The API first of all sees the disk image at the
&quot;pile of filesystems&quot; level. But it also has a way
to inspect the disk image to see if it contains an operating
system, and how the disks are mounted when the operating
system boots: &quot;INSPECTION&quot; in guestfs(3).</p>

<p>Users expect some tools (like virt-cat(1)) to work with
VM paths:</p>

<p>virt-cat fedora.img /var/log/messages</p>

<p>How does virt-cat know that &quot;/var&quot; is a
separate partition? The trick is that virt-cat performs
inspection on the disk image, and uses that to translate the
path correctly.</p>

<p>Some tools (including virt-cat(1), virt-edit(1),
virt-ls(1)) use inspection to map VM paths. Other tools,
such as virt-df(1) and virt-filesystems(1) operate entirely
at the raw &quot;big pile of filesystems&quot; level of the
libguestfs API, and dont use inspection.</p>

<p>guestfish(1) is in an interesting middle ground. If you
use the -a and -m command line options, then you have to
tell guestfish exactly how to add disk images and where to
mount partitions. This is the raw API level.</p>

<p>If you use the -i option, libguestfs performs inspection
and mounts the filesystems for you.</p>

<p>The error &quot;no root device found in this operating
system image&quot; is related to this. It means inspection
was unable to locate an operating system within the disk
image you gave it. You might see this from programs like
virt-cat if you try to run them on something which is just a
disk image, not a virtual machine disk image.</p>

<p>What do these &quot;debug*&quot; and
&quot;internal-*&quot; functions do? There are some
functions which are used for debugging and internal purposes
which are not part of the stable API.</p>

<p>The &quot;debug*&quot; (or &quot;guestfs_debug*&quot;)
functions, primarily &quot;guestfs_debug&quot; in guestfs(3)
and a handful of others, are used for debugging libguestfs.
Although they are not part of the stable API and thus may
change or be removed at any time, some programs may want to
call these while waiting for features to be added to
libguestfs.</p>

<p>The &quot;internal-*&quot; (or
&quot;guestfs_internal_*&quot;) functions are purely to be
used by libguestfs itself. There is no reason for programs
to call them, and programs should not try to use them. Using
them will often cause bad things to happen, as well as not
being part of the documented stable API.</p>

<p>DEVELOPERS Where do I send patches? Please send patches
to the libguestfs mailing list
https://www.redhat.com/mailman/listinfo/libguestfs. You dont
have to be subscribed, but there will be a delay until your
posting is manually approved.</p>

<p>Please don t use github pull requests - they will be
ignored. The reasons are (a) we want to discuss and dissect
patches on the mailing list, and (b) github pull requests
turn into merge commits but we prefer to have a linear
history.</p>

<p>How do I propose a feature? Large new features that you
intend to contribute should be discussed on the mailing list
first (https://www.redhat.com/mailman/listinfo/libguestfs).
This avoids disappointment and wasted work if we don t think
the feature would fit into the libguestfs project.</p>

<p>If you want to suggest a useful feature but dont want to
write the code, you can file a bug (see &quot;GETTING HELP
AND REPORTING BUGS&quot;) with &quot;RFE: &quot; at the
beginning of the Summary line.</p>

<p>Who can commit to libguestfs git? About 5 people have
commit access to github. Patches should be posted on the
list first and ACKed. The policy for ACKing and pushing
patches is outlined here:</p>


<p>https://www.redhat.com/archives/libguestfs/2012-January/msg00023.html</p>

<p>Can I fork libguestfs? Of course you can. Git makes it
easy to fork libguestfs. Github makes it even easier. Its
nice if you tell us on the mailing list about forks and the
reasons for them.</p>

<p>SEE ALSO guestfish(1), guestfs(3),
http://libguestfs.org/.</p>

<p>AUTHORS Richard W.M. Jones (&quot;rjones at redhat dot
com&quot;)</p>

<p>COPYRIGHT Copyright (C) 2012-2013 Red Hat Inc.</p>

<p>LICENSE This library is free software; you can
redistribute it and/or modify it under the terms of the GNU
Lesser General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at
your option) any later version.</p>

<p>This library is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU Lesser General Public License for more
details.</p>

<p>You should have received a copy of the GNU Lesser
General Public License along with this library; if not,
write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA 02110-1301 USA</p>

<p>BUGS To get a list of bugs against libguestfs, use this
link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p>To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p>When reporting a bug, please supply:</p>

<p>&middot; The version of libguestfs.</p>

<p>&middot; Where you got libguestfs (eg. which Linux
distro, compiled from source, etc)</p>

<p>&middot; Describe the bug accurately and give a way to
reproduce it.</p>

<p>&middot; Run libguestfs-test-tool(1) and paste the
complete, unedited output into the bug report.</p>

<p>libguestfs-1.20.11 2013-08-27 guestfs-faq(1)</p>
<hr>
</body>
</html>
