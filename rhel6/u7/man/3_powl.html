<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:28:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>POW(3) Linux Programmer s Manual POW(3)</p>

<p>NAME pow, powf, powl - power functions</p>

<p>SYNOPSIS #include &lt;math.h&gt;</p>

<p>double pow(double x, double y); float powf(float x,
float y); long double powl(long double x, long double
y);</p>

<p>Link with -lm.</p>

<p>Feature Test Macro Requirements for glibc (see
feature_test_macros(7)):</p>

<p>powf(), powl(): _BSD_SOURCE || _SVID_SOURCE ||
_XOPEN_SOURCE &gt;= 600 || _ISOC99_SOURCE; or cc
-std=c99</p>

<p>DESCRIPTION The pow() function returns the value of x
raised to the power of y.</p>

<p>RETURN VALUE On success, these functions return the
value of x to the power of y.</p>

<p>If x is a finite value less than 0, and y is a finite
non-integer, a domain error occurs, and a NaN is
returned.</p>

<p>If the result overflows, a range error occurs, and the
functions return HUGE_VAL, HUGE_VALF, or HUGE_VALL,
respectively, with the mathemati- cally correct sign.</p>

<p>If result underflows, and is not representable, a range
error occurs, and 0.0 is returned.</p>

<p>Except as specified below, if x or y is a NaN, the
result is a NaN.</p>

<p>If x is +1, the result is 1.0 (even if y is a NaN).</p>

<p>If y is 0, the result is 1.0 (even if x is a NaN).</p>

<p>If x is +0 (-0), and y is an odd integer greater than 0,
the result is +0 (-0).</p>

<p>If x is 0, and y greater than 0 and not an odd integer,
the result is +0.</p>

<p>If x is -1, and y is positive infinity or negative
infinity, the result is 1.0.</p>

<p>If the absolute value of x is less than 1, and y is
negative infinity, the result is positive infinity.</p>

<p>If the absolute value of x is greater than 1, and y is
negative infin- ity, the result is +0.</p>

<p>If the absolute value of x is less than 1, and y is
positive infinity, the result is +0.</p>

<p>If the absolute value of x is greater than 1, and y is
positive infin- ity, the result is positive infinity.</p>

<p>If x is negative infinity, and y is an odd integer less
than 0, the result is -0.</p>

<p>If x is negative infinity, and y less than 0 and not an
odd integer, the result is +0.</p>

<p>If x is negative infinity, and y is an odd integer
greater than 0, the result is negative infinity.</p>

<p>If x is negative infinity, and y greater than 0 and not
an odd integer, the result is positive infinity.</p>

<p>If x is positive infinity, and y less than 0, the result
is +0.</p>

<p>If x is positive infinity, and y greater than 0, the
result is positive infinity.</p>

<p>If x is +0 or -0, and y is an odd integer less than 0, a
pole error occurs and HUGE_VAL, HUGE_VALF, or HUGE_VALL, is
returned, with the same sign as x.</p>

<p>If x is +0 or -0, and y is less than 0 and not an odd
integer, a pole error occurs and +HUGE_VAL, +HUGE_VALF, or
+HUGE_VALL, is returned.</p>

<p>ERRORS See math_error(7) for information on how to
determine whether an error has occurred when calling these
functions.</p>

<p>The following errors can occur:</p>

<p>Domain error: x is negative, and y is a finite
non-integer errno is set to EDOM. An invalid floating-point
exception (FE_INVALID) is raised.</p>

<p>Pole error: x is zero, and y is negative errno is set to
ERANGE (but see BUGS). A divide-by-zero float- ing-point
exception (FE_DIVBYZERO) is raised.</p>

<p>Range error: the result overflows errno is set to
ERANGE. An overflow floating-point exception (FE_OVERFLOW)
is raised.</p>

<p>Range error: the result underflows errno is set to
ERANGE. An underflow floating-point exception (FE_UNDERFLOW)
is raised.</p>

<p>CONFORMING TO C99, POSIX.1-2001. The variant returning
double also conforms to SVr4, 4.3BSD, C89.</p>

<p>BUGS For a pole error, errno is set to EDOM; POSIX.1
says it should be set to ERANGE.</p>

<p>If x is negative, then large negative or positive y
values yield a NaN as the function result, with errno set to
EDOM, and an invalid (FE_INVALID) floating-point exception.
For example, with pow(), one sees this behavior when the
absolute value of y is greater than about 9.223373e18.</p>

<p>In version 2.3.2 and earlier, when an overflow or
underflow error occurs, glibc s pow() generates a bogus
invalid floating-point excep- tion (FE_INVALID) in addition
to the overflow or underflow exception.</p>

<p>SEE ALSO cbrt(3), cpow(3), sqrt(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>2008-08-10 POW(3)</p>
<hr>
</body>
</html>
