<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:15 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLMOD(1) Perl Programmers Reference Guide
PERLMOD(1)</p>

<p>NAME perlmod - Perl modules (packages and symbol
tables)</p>

<p>DESCRIPTION Packages Perl provides a mechanism for
alternative namespaces to protect packages from stomping on
each others variables. In fact, theres really no such thing
as a global variable in Perl. The package statement declares
the compilation unit as being in the given namespace. The
scope of the package declaration is from the declaration
itself through the end of the enclosing block,
&quot;eval&quot;, or file, whichever comes first (the same
scope as the my() and local() operators). Unqualified
dynamic identifiers will be in this namespace, except for
those few identifiers that if unqualified, default to the
main package instead of the current one as described below.
A package statement affects only dynamic
variables--including those youve used local() on--but not
lexical variables created with my(). Typically it would be
the first declaration in a file included by the
&quot;do&quot;, &quot;require&quot;, or &quot;use&quot;
operators. You can switch into a package in more than one
place; it merely influences which symbol table is used by
the compiler for the rest of that block. You can refer to
variables and filehandles in other packages by prefixing the
identifier with the package name and a double colon:
$Package::Variable. If the package name is null, the
&quot;main&quot; package is assumed. That is, $::sail is
equivalent to $main::sail.</p>

<p>The old package delimiter was a single quote, but double
colon is now the preferred delimiter, in part because its
more readable to humans, and in part because its more
readable to emacs macros. It also makes C++ programmers feel
like they know what s going on--as opposed to using the
single quote as separator, which was there to make Ada
programmers feel like they knew what was going on. Because
the old- fashioned syntax is still supported for backwards
compatibility, if you try to use a string like &quot;This is
$owner&rsquo;s house&quot;, you ll be accessing $owner::s;
that is, the $s variable in package &quot;owner&quot;, which
is probably not what you meant. Use braces to disambiguate,
as in &quot;This is ${owner}&rsquo;s house&quot;.</p>

<p>Packages may themselves contain package separators, as
in $OUTER::INNER::var. This implies nothing about the order
of name lookups, however. There are no relative packages:
all symbols are either local to the current package, or must
be fully qualified from the outer package name down. For
instance, there is nowhere within package &quot;OUTER&quot;
that $INNER::var refers to $OUTER::INNER::var.
&quot;INNER&quot; refers to a totally separate global
package.</p>

<p>Only identifiers starting with letters (or underscore)
are stored in a package s symbol table. All other symbols
are kept in package &quot;main&quot;, including all
punctuation variables, like $_. In addition, when
unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV,
ARGVOUT, ENV, INC, and SIG are forced to be in package
&quot;main&quot;, even when used for other purposes than
their built-in ones. If you have a package called
&quot;m&quot;, &quot;s&quot;, or &quot;y&quot;, then you
cant use the qualified form of an identifier because it
would be instead interpreted as a pattern match, a
substitution, or a transliteration.</p>

<p>Variables beginning with underscore used to be forced
into package main, but we decided it was more useful for
package writers to be able to use leading underscore to
indicate private variables and method names. However,
variables and functions named with a single &quot;_&quot;,
such as $_ and &quot;sub _&quot;, are still forced into the
package &quot;main&quot;. See also &quot;Technical Note on
the Syntax of Variable Names&quot; in perlvar.</p>

<p>&quot;eval&quot;ed strings are compiled in the package
in which the eval() was compiled. (Assignments to $SIG{},
however, assume the signal handler specified is in the
&quot;main&quot; package. Qualify the signal handler name if
you wish to have a signal handler in a package.) For an
example, examine perldb.pl in the Perl library. It initially
switches to the &quot;DB&quot; package so that the debugger
doesnt interfere with variables in the program you are
trying to debug. At various points, however, it temporarily
switches back to the &quot;main&quot; package to evaluate
various expressions in the context of the &quot;main&quot;
package (or wherever you came from). See perldebug.</p>

<p>The special symbol &quot;__PACKAGE__&quot; contains the
current package, but cannot (easily) be used to construct
variable names.</p>

<p>See perlsub for other scoping issues related to my() and
local(), and perlref regarding closures.</p>

<p>Symbol Tables The symbol table for a package happens to
be stored in the hash of that name with two colons appended.
The main symbol table s name is thus %main::, or %:: for
short. Likewise the symbol table for the nested package
mentioned earlier is named %OUTER::INNER::.</p>

<p>The value in each entry of the hash is what you are
referring to when you use the *name typeglob notation.</p>

<p>local *main::foo = *main::bar;</p>

<p>You can use this to print out all the variables in a
package, for instance. The standard but antiquated
dumpvar.pl library and the CPAN module Devel::Symdump make
use of this.</p>

<p>Assignment to a typeglob performs an aliasing operation,
i.e.,</p>

<p>*dick = *richard;</p>

<p>causes variables, subroutines, formats, and file and
directory handles accessible via the identifier
&quot;richard&quot; also to be accessible via the identifier
&quot;dick&quot;. If you want to alias only a particular
variable or subroutine, assign a reference instead:</p>

<p>*dick = ichard;</p>

<p>Which makes $richard and $dick the same variable, but
leaves @richard and @dick as separate arrays. Tricky,
eh?</p>

<p>There is one subtle difference between the following
statements:</p>

<p>*foo = *bar; *foo = ar;</p>

<p>&quot;*foo = *bar&quot; makes the typeglobs themselves
synonymous while &quot;*foo = ar&quot; makes the SCALAR
portions of two distinct typeglobs refer to the same scalar
value. This means that the following code:</p>

<p>$bar = 1; *foo = ar; # Make $foo an alias for $bar</p>

<p>{ local $bar = 2; # Restrict changes to block print
$foo; # Prints &rsquo;1&rsquo;! }</p>

<p>Would print 1 , because $foo holds a reference to the
original $bar -- the one that was stuffed away by
&quot;local()&quot; and which will be restored when the
block ends. Because variables are accessed through the
typeglob, you can use &quot;*foo = *bar&quot; to create an
alias which can be localized. (But be aware that this means
you cant have a separate @foo and @bar, etc.)</p>

<p>What makes all of this important is that the Exporter
module uses glob aliasing as the import/export mechanism.
Whether or not you can properly localize a variable that has
been exported from a module depends on how it was
exported:</p>

<p>@EXPORT = qw($FOO); # Usual form, can&rsquo;t be
localized @EXPORT = qw(*FOO); # Can be localized</p>

<p>You can work around the first case by using the fully
qualified name ($Package::FOO) where you need a local value,
or by overriding it by saying &quot;*FOO =
*Package::FOO&quot; in your script.</p>

<p>The &quot;*x = &quot; mechanism may be used to pass and
return cheap references into or from subroutines if you don
t want to copy the whole thing. It only works when assigning
to dynamic variables, not lexicals.</p>

<p>%some_hash = (); # can&rsquo;t be my() *some_hash = fn(
another_hash ); sub fn { local *hashsym = shift; # now use
%hashsym normally, and you # will affect the caller&rsquo;s
%another_hash my %nhash = (); # do what you want return
nhash; }</p>

<p>On return, the reference will overwrite the hash slot in
the symbol table specified by the *some_hash typeglob. This
is a somewhat tricky way of passing around references
cheaply when you don t want to have to remember to
dereference variables explicitly.</p>

<p>Another use of symbol tables is for making
&quot;constant&quot; scalars.</p>

<p>*PI = 3.14159265358979;</p>

<p>Now you cannot alter $PI, which is probably a good thing
all in all. This isn t the same as a constant subroutine,
which is subject to optimization at compile-time. A constant
subroutine is one prototyped to take no arguments and to
return a constant expression. See perlsub for details on
these. The &quot;use constant&quot; pragma is a convenient
shorthand for these.</p>

<p>You can say *foo{PACKAGE} and *foo{NAME} to find out
what name and package the *foo symbol table entry comes
from. This may be useful in a subroutine that gets passed
typeglobs as arguments:</p>

<p>sub identify_typeglob { my $glob = shift; print
&rsquo;You gave me &rsquo;, *{$glob}{PACKAGE},
&rsquo;::&rsquo;, *{$glob}{NAME}, &quot;0; }
identify_typeglob *foo; identify_typeglob *bar::baz;</p>

<p>This prints</p>

<p>You gave me main::foo You gave me bar::baz</p>

<p>The *foo{THING} notation can also be used to obtain
references to the individual elements of *foo. See
perlref.</p>

<p>Subroutine definitions (and declarations, for that
matter) need not necessarily be situated in the package
whose symbol table they occupy. You can define a subroutine
outside its package by explicitly qualifying the name of the
subroutine:</p>

<p>package main; sub Some_package::foo { ... } # &amp;foo
defined in Some_package</p>

<p>This is just a shorthand for a typeglob assignment at
compile time:</p>

<p>BEGIN { *Some_package::foo = sub { ... } }</p>

<p>and is not the same as writing:</p>

<p>{ package Some_package; sub foo { ... } }</p>

<p>In the first two versions, the body of the subroutine is
lexically in the main package, not in Some_package. So
something like this:</p>

<p>package main;</p>

<p>$Some_package::name = &quot;fred&quot;; $main::name =
&quot;barney&quot;;</p>

<p>sub Some_package::foo { print &quot;in &quot;,
__PACKAGE__, &quot;: ame is &rsquo;$name&rsquo;0; }</p>

<p>Some_package::foo();</p>

<p>prints:</p>

<p>in main: $name is &rsquo;barney&rsquo;</p>

<p>rather than:</p>

<p>in Some_package: $name is &rsquo;fred&rsquo;</p>

<p>This also has implications for the use of the SUPER::
qualifier (see perlobj).</p>

<p>BEGIN, UNITCHECK, CHECK, INIT and END Five specially
named code blocks are executed at the beginning and at the
end of a running Perl program. These are the
&quot;BEGIN&quot;, &quot;UNITCHECK&quot;, &quot;CHECK&quot;,
&quot;INIT&quot;, and &quot;END&quot; blocks.</p>

<p>These code blocks can be prefixed with &quot;sub&quot;
to give the appearance of a subroutine (although this is not
considered good style). One should note that these code
blocks dont really exist as named subroutines (despite their
appearance). The thing that gives this away is the fact that
you can have more than one of these code blocks in a
program, and they will get all executed at the appropriate
moment. So you cant execute any of these code blocks by
name.</p>

<p>A &quot;BEGIN&quot; code block is executed as soon as
possible, that is, the moment it is completely defined, even
before the rest of the containing file (or string) is
parsed. You may have multiple &quot;BEGIN&quot; blocks
within a file (or evaled string) -- they will execute in
order of definition. Because a &quot;BEGIN&quot; code block
executes immediately, it can pull in definitions of
subroutines and such from other files in time to be visible
to the rest of the compile and run time. Once a
&quot;BEGIN&quot; has run, it is immediately undefined and
any code it used is returned to Perls memory pool.</p>

<p>An &quot;END&quot; code block is executed as late as
possible, that is, after perl has finished running the
program and just before the interpreter is being exited,
even if it is exiting as a result of a die() function. (But
not if its morphing into another program via
&quot;exec&quot;, or being blown out of the water by a
signal--you have to trap that yourself (if you can).) You
may have multiple &quot;END&quot; blocks within a file--they
will execute in reverse order of definition; that is: last
in, first out (LIFO). &quot;END&quot; blocks are not
executed when you run perl with the &quot;-c&quot; switch,
or if compilation fails.</p>

<p>Note that &quot;END&quot; code blocks are not executed
at the end of a string &quot;eval()&quot;: if any
&quot;END&quot; code blocks are created in a string
&quot;eval()&quot;, they will be executed just as any other
&quot;END&quot; code block of that package in LIFO order
just before the interpreter is being exited.</p>

<p>Inside an &quot;END&quot; code block, $? contains the
value that the program is going to pass to
&quot;exit()&quot;. You can modify $? to change the exit
value of the program. Beware of changing $? by accident
(e.g. by running something via &quot;system&quot;).</p>

<p>&quot;UNITCHECK&quot;, &quot;CHECK&quot; and
&quot;INIT&quot; code blocks are useful to catch the
transition between the compilation phase and the execution
phase of the main program.</p>

<p>&quot;UNITCHECK&quot; blocks are run just after the unit
which defined them has been compiled. The main program file
and each module it loads are compilation units, as are
string &quot;eval&quot;s, code compiled using the &quot;(?{
})&quot; construct in a regex, calls to &quot;do FILE&quot;,
&quot;require FILE&quot;, and code after the &quot;-e&quot;
switch on the command line.</p>

<p>&quot;CHECK&quot; code blocks are run just after the
initial Perl compile phase ends and before the run time
begins, in LIFO order. &quot;CHECK&quot; code blocks are
used in the Perl compiler suite to save the compiled state
of the program.</p>

<p>&quot;INIT&quot; blocks are run just before the Perl
runtime begins execution, in &quot;first in, first out&quot;
(FIFO) order.</p>

<p>The &quot;CHECK&quot; and &quot;INIT&quot; code blocks
will not be executed inside a string eval(), if that eval()
happens after the end of the main compilation phase; that
can be a problem in mod_perl and other persistent
environments which use &quot;eval STRING&quot; to load code
at runtime.</p>

<p>When you use the -n and -p switches to Perl,
&quot;BEGIN&quot; and &quot;END&quot; work just as they do
in awk, as a degenerate case. Both &quot;BEGIN&quot; and
&quot;CHECK&quot; blocks are run when you use the -c switch
for a compile-only syntax check, although your main code is
not.</p>

<p>The begincheck program makes it all clear,
eventually:</p>

<p>#!/usr/bin/perl</p>

<p># begincheck</p>

<p>print &quot;10. Ordinary code runs at runtime.0;</p>

<p>END { print &quot;16. So this is the end of the tale.0 }
INIT { print &quot; 7. INIT blocks run FIFO just before
runtime.0 } UNITCHECK { print &quot; 4. And therefore before
any CHECK blocks.0 } CHECK { print &quot; 6. So this is the
sixth line.0 }</p>

<p>print &quot;11. It runs in order, of course.0;</p>

<p>BEGIN { print &quot; 1. BEGIN blocks run FIFO during
compilation.0 } END { print &quot;15. Read perlmod for the
rest of the story.0 } CHECK { print &quot; 5. CHECK blocks
run LIFO after all compilation.0 } INIT { print &quot; 8.
Run this again, using Perl&rsquo;s -c switch.0 }</p>

<p>print &quot;12. This is anti-obfuscated code.0;</p>

<p>END { print &quot;14. END blocks run LIFO at quitting
time.0 } BEGIN { print &quot; 2. So this line comes out
second.0 } UNITCHECK { print &quot; 3. UNITCHECK blocks run
LIFO after each file is compiled.0 } INIT { print &quot; 9.
You&rsquo;ll see the difference right away.0 }</p>

<p>print &quot;13. It merely _looks_ like it should be
confusing.0;</p>

<p>__END__</p>

<p>Perl Classes There is no special class syntax in Perl,
but a package may act as a class if it provides subroutines
to act as methods. Such a package may also derive some of
its methods from another class (package) by listing the
other package name(s) in its global @ISA array (which must
be a package global, not a lexical).</p>

<p>For more on this, see perltoot and perlobj.</p>

<p>Perl Modules A module is just a set of related functions
in a library file, i.e., a Perl package with the same name
as the file. It is specifically designed to be reusable by
other modules or programs. It may do this by providing a
mechanism for exporting some of its symbols into the symbol
table of any package using it, or it may function as a class
definition and make its semantics available implicitly
through method calls on the class and its objects, without
explicitly exporting anything. Or it can do a little of
both.</p>

<p>For example, to start a traditional, non-OO module
called Some::Module, create a file called Some/Module.pm and
start with this template:</p>

<p>package Some::Module; # assumes Some/Module.pm</p>

<p>use strict; use warnings;</p>

<p>BEGIN { use Exporter (); our ($VERSION, @ISA, @EXPORT,
@EXPORT_OK, %EXPORT_TAGS);</p>

<p># set the version for version checking $VERSION = 1.00;
# if using RCS/CVS, this may be preferred $VERSION = sprintf
&quot;%d.%03d&quot;, q$Revision: 1.1 $ =~ /(+)/g;</p>

<p>@ISA = qw(Exporter); @EXPORT = qw(&amp;func1 &amp;func2
&amp;func4); %EXPORT_TAGS = ( ); # eg: TAG =&gt; [ qw!name1
name2! ],</p>

<p># your exported package globals go here, # as well as
any optionally exported functions @EXPORT_OK = qw($Var1
%Hashit &amp;func3); } our @EXPORT_OK;</p>

<p># exported package globals go here our $Var1; our
%Hashit;</p>

<p># non-exported package globals go here our @more; our
$stuff;</p>

<p># initialize package globals, first exported ones $Var1
= &rsquo;&rsquo;; %Hashit = ();</p>

<p># then the others (which are still accessible as
$Some::Module::stuff) $stuff = &rsquo;&rsquo;; @more =
();</p>

<p># all file-scoped lexicals must be created before # the
functions below that use them.</p>

<p># file-private lexicals go here my $priv_var =
&rsquo;&rsquo;; my %secret_hash = ();</p>

<p># here&rsquo;s a file-private function as a closure, #
callable as &amp;$priv_func; it cannot be prototyped. my
$priv_func = sub { # stuff goes here. };</p>

<p># make all your functions, whether exported or not; #
remember to put something interesting in the {} stubs sub
func1 {} # no prototype sub func2() {} # proto&rsquo;d void
sub func3($$) {} # proto&rsquo;d to 2 scalars</p>

<p># this one isn&rsquo;t exported, but could be called!
sub func4() {} # proto&rsquo;d to 1 hash ref</p>

<p>END { } # module clean-up code here (global
destructor)</p>

<p>## YOUR CODE GOES HERE</p>

<p>1; # don&rsquo;t forget to return a true value from the
file</p>

<p>Then go on to declare and use your variables in
functions without any qualifications. See Exporter and the
perlmodlib for details on mechanics and style issues in
module creation.</p>

<p>Perl modules are included into your program by
saying</p>

<p>use Module;</p>

<p>or</p>

<p>use Module LIST;</p>

<p>This is exactly equivalent to</p>

<p>BEGIN { require Module; import Module; }</p>

<p>or</p>

<p>BEGIN { require Module; import Module LIST; }</p>

<p>As a special case</p>

<p>use Module ();</p>

<p>is exactly equivalent to</p>

<p>BEGIN { require Module; }</p>

<p>All Perl module files have the extension .pm. The
&quot;use&quot; operator assumes this so you dont have to
spell out &quot;Module.pm&quot; in quotes. This also helps
to differentiate new modules from old .pl and .ph files.
Module names are also capitalized unless they re functioning
as pragmas; pragmas are in effect compiler directives, and
are sometimes called &quot;pragmatic modules&quot; (or even
&quot;pragmata&quot; if youre a classicist).</p>

<p>The two statements:</p>

<p>require SomeModule; require
&quot;SomeModule.pm&quot;;</p>

<p>differ from each other in two ways. In the first case,
any double colons in the module name, such as
&quot;Some::Module&quot;, are translated into your system s
directory separator, usually &quot;/&quot;. The second case
does not, and would have to be specified literally. The
other difference is that seeing the first
&quot;require&quot; clues in the compiler that uses of
indirect object notation involving &quot;SomeModule&quot;,
as in &quot;$ob = purge SomeModule&quot;, are method calls,
not function calls. (Yes, this really can make a
difference.)</p>

<p>Because the &quot;use&quot; statement implies a
&quot;BEGIN&quot; block, the importing of semantics happens
as soon as the &quot;use&quot; statement is compiled, before
the rest of the file is compiled. This is how it is able to
function as a pragma mechanism, and also how modules are
able to declare subroutines that are then visible as list or
unary operators for the rest of the current file. This will
not work if you use &quot;require&quot; instead of
&quot;use&quot;. With &quot;require&quot; you can get into
this problem:</p>

<p>require Cwd; # make Cwd:: accessible $here =
Cwd::getcwd();</p>

<p>use Cwd; # import names from Cwd:: $here = getcwd();</p>

<p>require Cwd; # make Cwd:: accessible $here = getcwd(); #
oops! no main::getcwd()</p>

<p>In general, &quot;use Module ()&quot; is recommended
over &quot;require Module&quot;, because it determines
module availability at compile time, not in the middle of
your programs execution. An exception would be if two
modules each tried to &quot;use&quot; each other, and each
also called a function from that other module. In that case,
its easy to use &quot;require&quot; instead.</p>

<p>Perl packages may be nested inside other package names,
so we can have package names containing &quot;::&quot;. But
if we used that package name directly as a filename it would
make for unwieldy or impossible filenames on some systems.
Therefore, if a modules name is, say,
&quot;Text::Soundex&quot;, then its definition is actually
found in the library file Text/Soundex.pm.</p>

<p>Perl modules always have a .pm file, but there may also
be dynamically linked executables (often ending in .so) or
autoloaded subroutine definitions (often ending in .al)
associated with the module. If so, these will be entirely
transparent to the user of the module. It is the
responsibility of the .pm file to load (or arrange to
autoload) any additional functionality. For example,
although the POSIX module happens to do both dynamic loading
and autoloading, the user can say just &quot;use POSIX&quot;
to get it all.</p>

<p>Making your module threadsafe Since 5.6.0, Perl has had
support for a new type of threads called interpreter threads
(ithreads). These threads can be used explicitly and
implicitly.</p>

<p>Ithreads work by cloning the data tree so that no data
is shared between different threads. These threads can be
used by using the &quot;threads&quot; module or by doing
fork() on win32 (fake fork() support). When a thread is
cloned all Perl data is cloned, however non-Perl data cannot
be cloned automatically. Perl after 5.7.2 has support for
the &quot;CLONE&quot; special subroutine. In
&quot;CLONE&quot; you can do whatever you need to do, like
for example handle the cloning of non-Perl data, if
necessary. &quot;CLONE&quot; will be called once as a class
method for every package that has it defined (or inherits
it). It will be called in the context of the new thread, so
all modifications are made in the new area. Currently CLONE
is called with no parameters other than the invocant package
name, but code should not assume that this will remain
unchanged, as it is likely that in future extra parameters
will be passed in to give more information about the state
of cloning.</p>

<p>If you want to CLONE all objects you will need to keep
track of them per package. This is simply done using a hash
and Scalar::Util::weaken().</p>

<p>Perl after 5.8.7 has support for the
&quot;CLONE_SKIP&quot; special subroutine. Like
&quot;CLONE&quot;, &quot;CLONE_SKIP&quot; is called once per
package; however, it is called just before cloning starts,
and in the context of the parent thread. If it returns a
true value, then no objects of that class will be cloned; or
rather, they will be copied as unblessed, undef values. For
example: if in the parent there are two references to a
single blessed hash, then in the child there will be two
references to a single undefined scalar value instead. This
provides a simple mechanism for making a module threadsafe;
just add &quot;sub CLONE_SKIP { 1 }&quot; at the top of the
class, and &quot;DESTROY()&quot; will be now only be called
once per object. Of course, if the child thread needs to
make use of the objects, then a more sophisticated approach
is needed.</p>

<p>Like &quot;CLONE&quot;, &quot;CLONE_SKIP&quot; is
currently called with no parameters other than the invocant
package name, although that may change. Similarly, to allow
for future expansion, the return value should be a single 0
or 1 value.</p>

<p>SEE ALSO See perlmodlib for general style issues related
to building Perl modules and classes, as well as
descriptions of the standard library and CPAN, Exporter for
how Perl s standard import/export mechanism works, perltoot
and perltooc for an in-depth tutorial on creating classes,
perlobj for a hard-core reference document on objects,
perlsub for an explanation of functions and scoping, and
perlxstut and perlguts for more information on writing
extension modules.</p>

<p>perl v5.10.1 2009-07-24 PERLMOD(1)</p>
<hr>
</body>
</html>
