<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:35:25 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SPLAIN(1) Perl Programmers Reference Guide SPLAIN(1)</p>

<p>NAME diagnostics, splain - produce verbose warning
diagnostics</p>

<p>SYNOPSIS Using the &quot;diagnostics&quot; pragma:</p>

<p>use diagnostics; use diagnostics -verbose;</p>

<p>enable diagnostics; disable diagnostics;</p>

<p>Using the &quot;splain&quot; standalone filter
program:</p>

<p>perl program 2&gt;diag.out splain [-v] [-p] diag.out</p>

<p>Using diagnostics to get stack traces from a misbehaving
script:</p>

<p>perl -Mdiagnostics=-traceonly my_script.pl</p>

<p>DESCRIPTION The &quot;diagnostics&quot; Pragma This
module extends the terse diagnostics normally emitted by
both the perl compiler and the perl interpreter (from
running perl with a -w switch or &quot;use warnings&quot;),
augmenting them with the more explicative and endearing
descriptions found in perldiag. Like the other pragmata, it
affects the compilation phase of your program rather than
merely the execution phase.</p>

<p>To use in your program as a pragma, merely invoke</p>

<p>use diagnostics;</p>

<p>at the start (or near the start) of your program. (Note
that this does enable perl s -w flag.) Your whole
compilation will then be subject(ed :-) to the enhanced
diagnostics. These still go out STDERR.</p>

<p>Due to the interaction between runtime and compiletime
issues, and because its probably not a very good idea
anyway, you may not use &quot;no diagnostics&quot; to turn
them off at compiletime. However, you may control their
behaviour at runtime using the disable() and enable()
methods to turn them off and on respectively.</p>

<p>The -verbose flag first prints out the perldiag
introduction before any other diagnostics. The
$diagnostics::PRETTY variable can generate nicer escape
sequences for pagers.</p>

<p>Warnings dispatched from perl itself (or more
accurately, those that match descriptions found in perldiag)
are only displayed once (no duplicate descriptions). User
code generated warnings a la warn() are unaffected, allowing
duplicate user messages to be displayed.</p>

<p>This module also adds a stack trace to the error message
when perl dies. This is useful for pinpointing what caused
the death. The -traceonly (or just -t) flag turns off the
explanations of warning messages leaving just the stack
traces. So if your script is dieing, run it again with</p>

<p>perl -Mdiagnostics=-traceonly my_bad_script</p>

<p>to see the call stack at the time of death. By supplying
the -warntrace (or just -w) flag, any warnings emitted will
also come with a stack trace.</p>

<p>The splain Program While apparently a whole nuther
program, splain is actually nothing more than a link to the
(executable) diagnostics.pm module, as well as a link to the
diagnostics.pod documentation. The -v flag is like the
&quot;use diagnostics -verbose&quot; directive. The -p flag
is like the $diagnostics::PRETTY variable. Since you re
post-processing with splain, theres no sense in being able
to enable() or disable() processing.</p>

<p>Output from splain is directed to STDOUT, unlike the
pragma.</p>

<p>EXAMPLES The following file is certain to trigger a few
errors at both runtime and compiletime:</p>

<p>use diagnostics; print NOWHERE &quot;nothing0; print
STDERR &quot;This message should be unadorned.0; warn
&quot;This is a user warning&quot;; print &quot;0IAGNOSTIC
TESTER: Please enter a &lt;CR&gt; here: &quot;; my $a, $b =
scalar &lt;STDIN&gt;; print &quot;0; print $x/$y;</p>

<p>If you prefer to run your program first and look at its
problem afterwards, do this:</p>

<p>perl -w test.pl 2&gt;test.out ./splain &lt; test.out</p>

<p>Note that this is not in general possible in shells of
more dubious heritage, as the theoretical</p>

<p>(perl -w test.pl &gt;/dev/tty) &gt;&amp; test.out
./splain &lt; test.out</p>

<p>Because you just moved the existing stdout to somewhere
else.</p>

<p>If you don t want to modify your source code, but still
have on-the-fly warnings, do this:</p>

<p>exec 3&gt;&amp;1; perl -w test.pl 2&gt;&amp;1
1&gt;&amp;3 3&gt;&amp;- | splain 1&gt;&amp;2 3&gt;&amp;-</p>

<p>Nifty, eh?</p>

<p>If you want to control warnings on the fly, do something
like this. Make sure you do the &quot;use&quot; first, or
you wont be able to get at the enable() or disable()
methods.</p>

<p>use diagnostics; # checks entire compilation phase print
&quot;0ime for 1st bogus diags: SQUAWKINGS0; print BOGUS1
&rsquo;nada&rsquo;; print &quot;done with 1st bogus0;</p>

<p>disable diagnostics; # only turns off runtime warnings
print &quot;0ime for 2nd bogus: (squelched)0; print BOGUS2
&rsquo;nada&rsquo;; print &quot;done with 2nd bogus0;</p>

<p>enable diagnostics; # turns back on runtime warnings
print &quot;0ime for 3rd bogus: SQUAWKINGS0; print BOGUS3
&rsquo;nada&rsquo;; print &quot;done with 3rd bogus0;</p>

<p>disable diagnostics; print &quot;0ime for 4th bogus:
(squelched)0; print BOGUS4 &rsquo;nada&rsquo;; print
&quot;done with 4th bogus0;</p>

<p>INTERNALS Diagnostic messages derive from the
perldiag.pod file when available at runtime. Otherwise, they
may be embedded in the file itself when the splain package
is built. See the Makefile for details.</p>

<p>If an extant $SIG{__WARN__} handler is discovered, it
will continue to be honored, but only after the
diagnostics::splainthis() function (the modules
$SIG{__WARN__} interceptor) has had its way with your
warnings.</p>

<p>There is a $diagnostics::DEBUG variable you may set if
you re desperately curious what sorts of things are being
intercepted.</p>

<p>BEGIN { $diagnostics::DEBUG = 1 }</p>

<p>BUGS Not being able to say &quot;no diagnostics&quot; is
annoying, but may not be insurmountable.</p>

<p>The &quot;-pretty&quot; directive is called too late to
affect matters. You have to do this instead, and before you
load the module.</p>

<p>BEGIN { $diagnostics::PRETTY = 1 }</p>

<p>I could start up faster by delaying compilation until it
should be needed, but this gets a &quot;panic:
top_level&quot; when using the pragma form in Perl
5.001e.</p>

<p>While it s true that this documentation is somewhat
subserious, if you use a program named splain, you should
expect a bit of whimsy.</p>

<p>AUTHOR Tom Christiansen &lt;tchrist@mox.perl.com&gt;, 25
June 1995.</p>

<p>perl v5.10.1 2015-03-13 SPLAIN(1)</p>
<hr>
</body>
</html>
