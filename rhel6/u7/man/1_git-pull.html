<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:39 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-PULL(1) Git Manual GIT-PULL(1)</p>

<p>NAME git-pull - Fetch from and merge with another
repository or a local branch</p>

<p>SYNOPSIS git pull &lt;options&gt; &lt;repository&gt;
&lt;refspec&gt;...</p>

<p>DESCRIPTION Runs git fetch with the given parameters,
and calls git merge to merge the retrieved head(s) into the
current branch. With --rebase, calls git rebase instead of
git merge.</p>

<p>Note that you can use . (current directory) as the
&lt;repository&gt; to pull from the local repository this is
useful when merging local branches into the current
branch.</p>

<p>Also note that options meant for git pull itself and
underlying git merge must be given before the options meant
for git fetch.</p>

<p>Warning: Running git pull (actually, the underlying git
merge) with uncommitted changes is discouraged: while
possible, it leaves you in a state that is hard to back out
of in the case of a conflict.</p>

<p>OPTIONS -q, --quiet This is passed to both underlying
git-fetch to squelch reporting of during transfer, and
underlying git-merge to squelch output during merging.</p>

<p>-v, --verbose Pass --verbose to git-fetch and
git-merge.</p>

<p>Options related to merging --commit, --no-commit Perform
the merge and commit the result. This option can be used to
override --no-commit.</p>

<p>With --no-commit perform the merge but pretend the merge
failed and do not autocommit, to give the user a chance to
inspect and further tweak the merge result before
committing.</p>

<p>--ff, --no-ff Do not generate a merge commit if the
merge resolved as a fast-forward, only update the branch
pointer. This is the default behavior of git-merge.</p>

<p>With --no-ff Generate a merge commit even if the merge
resolved as a fast-forward.</p>

<p>--log, --no-log In addition to branch names, populate
the log message with one-line descriptions from the actual
commits that are being merged.</p>

<p>With --no-log do not list one-line descriptions from the
actual commits being merged.</p>

<p>--stat, -n, --no-stat Show a diffstat at the end of the
merge. The diffstat is also controlled by the configuration
option merge.stat.</p>

<p>With -n or --no-stat do not show a diffstat at the end
of the merge.</p>

<p>--squash, --no-squash Produce the working tree and index
state as if a real merge happened (except for the merge
information), but do not actually make a commit or move the
HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the next git
commit command to create a merge commit. This allows you to
create a single commit on top of the current branch whose
effect is the same as merging another branch (or more in
case of an octopus).</p>

<p>With --no-squash perform the merge and commit the
result. This option can be used to override --squash.</p>

<p>--ff-only Refuse to merge and exit with a non-zero
status unless the current HEAD is already up-to-date or the
merge can be resolved as a fast-forward.</p>

<p>-s &lt;strategy&gt;, --strategy=&lt;strategy&gt; Use the
given merge strategy; can be supplied more than once to
specify them in the order they should be tried. If there is
no -s option, a built-in list of strategies is used instead
(git merge-recursive when merging a single head, git
merge-octopus otherwise).</p>

<p>-X &lt;option&gt;, --strategy-option=&lt;option&gt; Pass
merge strategy specific option through to the merge
strategy.</p>

<p>--summary, --no-summary Synonyms to --stat and
--no-stat; these are deprecated and will be removed in the
future.</p>

<p>-q, --quiet Operate quietly.</p>

<p>-v, --verbose Be verbose.</p>

<p>--rebase Instead of a merge, perform a rebase after
fetching. If there is a remote ref for the upstream branch,
and this branch was rebased since last fetched, the rebase
uses that information to avoid rebasing non-local changes.
To make this the default for branch &lt;name&gt;, set
configuration branch.&lt;name&gt;.rebase to true.</p>

<p>Note This is a potentially dangerous mode of operation.
It rewrites history, which does not bode well when you
published that history already. Do not use this option
unless you have read git-rebase(1) carefully.</p>

<p>--no-rebase Override earlier --rebase.</p>

<p>Options related to fetching --all Fetch all remotes.</p>

<p>-a, --append Append ref names and object names of
fetched refs to the existing contents of .git/FETCH_HEAD.
Without this option old data in .git/FETCH_HEAD will be
overwritten.</p>

<p>--depth=&lt;depth&gt; Deepen the history of a shallow
repository created by git clone with --depth=&lt;depth&gt;
option (see git-clone(1)) by the specified number of
commits.</p>

<p>-f, --force When git fetch is used with
&lt;rbranch&gt;:&lt;lbranch&gt; refspec, it refuses to
update the local branch &lt;lbranch&gt; unless the remote
branch &lt;rbranch&gt; it fetches is a descendant of
&lt;lbranch&gt;. This option overrides that check.</p>

<p>-k, --keep Keep downloaded pack.</p>

<p>--no-tags By default, tags that point at objects that
are downloaded from the remote repository are fetched and
stored locally. This option disables this automatic tag
following.</p>

<p>-t, --tags Most of the tags are fetched automatically as
branch heads are downloaded, but tags that do not point at
objects reachable from the branch heads that are being
tracked will not be fetched by this mechanism. This flag
lets all tags and their associated objects be
downloaded.</p>

<p>-u, --update-head-ok By default git fetch refuses to
update the head which corresponds to the current branch.
This flag disables the check. This is purely for the
internal use for git pull to communicate with git fetch, and
unless you are implementing your own Porcelain you are not
supposed to use it.</p>

<p>--upload-pack &lt;upload-pack&gt; When given, and the
repository to fetch from is handled by git fetch-pack,
--exec=&lt;upload-pack&gt; is passed to the command to
specify non-default path for the command run on the other
end.</p>

<p>--progress Progress status is reported on the standard
error stream by default when it is attached to a terminal,
unless -q is specified. This flag forces progress status
even if the standard error stream is not directed to a
terminal.</p>

<p>&lt;repository&gt; The &quot;remote&quot; repository
that is the source of a fetch or pull operation. This
parameter can be either a URL (see the section GIT URLS
below) or the name of a remote (see the section REMOTES
below).</p>

<p>&lt;refspec&gt; The format of a &lt;refspec&gt;
parameter is an optional plus +, followed by the source ref
&lt;src&gt;, followed by a colon :, followed by the
destination ref &lt;dst&gt;.</p>

<p>The remote ref that matches &lt;src&gt; is fetched, and
if &lt;dst&gt; is not empty string, the local ref that
matches it is fast-forwarded using &lt;src&gt;. If the
optional plus + is used, the local ref is updated even if it
does not result in a fast-forward update.</p>

<p>Note If the remote branch from which you want to pull is
modified in non-linear ways such as being rewound and
rebased frequently, then a pull will attempt a merge with an
older version of itself, likely conflict, and fail. It is
under these conditions that you would want to use the + sign
to indicate non-fast-forward updates will be needed. There
is currently no easy way to determine or declare that a
branch will be made available in a repository with this
behavior; the pulling user simply must know this is the
expected usage pattern for a branch.</p>

<p>Note You never do your own development on branches that
appear on the right hand side of a &lt;refspec&gt; colon on
Pull: lines; they are to be updated by git fetch. If you
intend to do development derived from a remote branch B,
have a Pull: line to track it (i.e. Pull: B:remote-B), and
have a separate branch my-B to do your development on top of
it. The latter is created by git branch my-B remote-B (or
its equivalent git checkout -b my-B remote-B). Run git fetch
to keep track of the progress of the remote side, and when
you see something new on the remote branch, merge it into
your development branch with git pull . remote-B, while you
are on my-B branch.</p>

<p>Note There is a difference between listing multiple
&lt;refspec&gt; directly on git pull command line and having
multiple Pull: &lt;refspec&gt; lines for a
&lt;repository&gt; and running git pull command without any
explicit &lt;refspec&gt; parameters. &lt;refspec&gt; listed
explicitly on the command line are always merged into the
current branch after fetching. In other words, if you list
more than one remote refs, you would be making an Octopus.
While git pull run without any explicit &lt;refspec&gt;
parameter takes default &lt;refspec&gt;s from Pull: lines,
it merges only the first &lt;refspec&gt; found into the
current branch, after fetching all the remote refs. This is
because making an Octopus from remote refs is rarely done,
while keeping track of multiple remote heads in one-go by
fetching more than one is often useful. Some short-cut
notations are also supported.</p>

<p>&middot; tag &lt;tag&gt; means the same as
refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;; it requests
fetching everything up to the given tag.</p>

<p>&middot; A parameter &lt;ref&gt; without a colon is
equivalent to &lt;ref&gt;: when pulling/fetching, so it
merges &lt;ref&gt; into the current branch without storing
the remote branch anywhere locally</p>

<p>GIT URLS In general, URLs contain information about the
transport protocol, the address of the remote server, and
the path to the repository. Depending on the transport
protocol, some of this information may be absent.</p>

<p>Git natively supports ssh, git, http, https, ftp, ftps,
and rsync protocols. The following syntaxes may be used with
them:</p>

<p>&middot;
ssh://[user@]host.xz[:port]/path/to/repo.git/</p>

<p>&middot; git://host.xz[:port]/path/to/repo.git/</p>

<p>&middot; http[s]://host.xz[:port]/path/to/repo.git/</p>

<p>&middot; ftp[s]://host.xz[:port]/path/to/repo.git/</p>

<p>&middot; rsync://host.xz/path/to/repo.git/</p>

<p>An alternative scp-like syntax may also be used with the
ssh protocol:</p>

<p>&middot; [user@]host.xz:path/to/repo.git/</p>

<p>The ssh and git protocols additionally support ~username
expansion:</p>

<p>&middot;
ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/</p>

<p>&middot;
git://host.xz[:port]/~[user]/path/to/repo.git/</p>

<p>&middot; [user@]host.xz:/~[user]/path/to/repo.git/</p>

<p>For local respositories, also supported by git natively,
the following syntaxes may be used:</p>

<p>&middot; /path/to/repo.git/</p>

<p>&middot; file:///path/to/repo.git/</p>

<p>These two syntaxes are mostly equivalent, except when
cloning, when the former implies --local option. See
git-clone(1) for details.</p>

<p>When git doesnt know how to handle a certain transport
protocol, it attempts to use the remote-&lt;transport&gt;
remote helper, if one exists. To explicitly request a remote
helper, the following syntax may be used:</p>

<p>&middot; &lt;transport&gt;::&lt;address&gt;</p>

<p>where &lt;address&gt; may be a path, a server and path,
or an arbitrary URL-like string recognized by the specific
remote helper being invoked. See git-remote-helpers(1) for
details.</p>

<p>If there are a large number of similarly-named remote
repositories and you want to use a different format for them
(such that the URLs you use will be rewritten into URLs that
work), you can create a configuration section of the
form:</p>

<p>[url &quot;&lt;actual url base&gt;&quot;] insteadOf =
&lt;other url base&gt;</p>

<p>For example, with this:</p>

<p>[url &quot;git://git.host.xz/&quot;] insteadOf =
host.xz:/path/to/ insteadOf = work:</p>

<p>a URL like &quot;work:repo.git&quot; or like
&quot;host.xz:/path/to/repo.git&quot; will be rewritten in
any context that takes a URL to be
&quot;git://git.host.xz/repo.git&quot;.</p>

<p>If you want to rewrite URLs for push only, you can
create a configuration section of the form:</p>

<p>[url &quot;&lt;actual url base&gt;&quot;] pushInsteadOf
= &lt;other url base&gt;</p>

<p>For example, with this:</p>

<p>[url &quot;ssh://example.org/&quot;] pushInsteadOf =
git://example.org/</p>

<p>a URL like
&quot;git://example.org/path/to/repo.git&quot; will be
rewritten to &quot;ssh://example.org/path/to/repo.git&quot;
for pushes, but pulls will still use the original URL.</p>

<p>REMOTES The name of one of the following can be used
instead of a URL as &lt;repository&gt; argument:</p>

<p>&middot; a remote in the git configuration file:
$GIT_DIR/config,</p>

<p>&middot; a file in the $GIT_DIR/remotes directory,
or</p>

<p>&middot; a file in the $GIT_DIR/branches directory.</p>

<p>All of these also allow you to omit the refspec from the
command line because they each contain a refspec which git
will use by default.</p>

<p>Named remote in configuration file You can choose to
provide the name of a remote which you had previously
configured using git-remote(1), git-config(1) or even by a
manual edit to the $GIT_DIR/config file. The URL of this
remote will be used to access the repository. The refspec of
this remote will be used by default when you do not provide
a refspec on the command line. The entry in the config file
would appear like this:</p>

<p>[remote &quot;&lt;name&gt;&quot;] url = &lt;url&gt;
pushurl = &lt;pushurl&gt; push = &lt;refspec&gt; fetch =
&lt;refspec&gt;</p>

<p>The &lt;pushurl&gt; is used for pushes only. It is
optional and defaults to &lt;url&gt;.</p>

<p>Named file in $GIT_DIR/remotes You can choose to provide
the name of a file in $GIT_DIR/remotes. The URL in this file
will be used to access the repository. The refspec in this
file will be used as default when you do not provide a
refspec on the command line. This file should have the
following format:</p>

<p>URL: one of the above URL format Push: &lt;refspec&gt;
Pull: &lt;refspec&gt;</p>

<p>Push: lines are used by git push and Pull: lines are
used by git pull and git fetch. Multiple Push: and Pull:
lines may be specified for additional branch mappings.</p>

<p>Named file in $GIT_DIR/branches You can choose to
provide the name of a file in $GIT_DIR/branches. The URL in
this file will be used to access the repository. This file
should have the following format:</p>

<p>&lt;url&gt;#&lt;head&gt;</p>

<p>&lt;url&gt; is required; #&lt;head&gt; is optional.</p>

<p>Depending on the operation, git will use one of the
following refspecs, if you dont provide one on the command
line. &lt;branch&gt; is the name of this file in
$GIT_DIR/branches and &lt;head&gt; defaults to master.</p>

<p>git fetch uses:</p>

<p>refs/heads/&lt;head&gt;:refs/heads/&lt;branch&gt;</p>

<p>git push uses:</p>

<p>HEAD:refs/heads/&lt;head&gt;</p>

<p>MERGE STRATEGIES The merge mechanism (git-merge and
git-pull commands) allows the backend merge strategies to be
chosen with -s option. Some strategies can also take their
own options, which can be passed by giving -X&lt;option&gt;
arguments to git-merge and/or git-pull.</p>

<p>resolve This can only resolve two heads (i.e. the
current branch and another branch you pulled from) using a
3-way merge algorithm. It tries to carefully detect
criss-cross merge ambiguities and is considered generally
safe and fast.</p>

<p>recursive This can only resolve two heads using a 3-way
merge algorithm. When there is more than one common ancestor
that can be used for 3-way merge, it creates a merged tree
of the common ancestors and uses that as the reference tree
for the 3-way merge. This has been reported to result in
fewer merge conflicts without causing mis-merges by tests
done on actual merge commits taken from Linux 2.6 kernel
development history. Additionally this can detect and handle
merges involving renames. This is the default merge strategy
when pulling or merging one branch.</p>

<p>The recursive strategy can take the following
options:</p>

<p>ours This option forces conflicting hunks to be
auto-resolved cleanly by favoring our version. Changes from
the other tree that do not conflict with our side are
reflected to the merge result.</p>

<p>This should not be confused with the ours merge
strategy, which does not even look at what the other tree
contains at all. It discards everything the other tree did,
declaring our history contains all that happened in it.</p>

<p>theirs This is opposite of ours.</p>

<p>subtree[=path] This option is a more advanced form of
subtree strategy, where the strategy makes a guess on how
two trees must be shifted to match with each other when
merging. Instead, the specified path is prefixed (or
stripped from the beginning) to make the shape of two trees
to match.</p>

<p>octopus This resolves cases with more than two heads,
but refuses to do a complex merge that needs manual
resolution. It is primarily meant to be used for bundling
topic branch heads together. This is the default merge
strategy when pulling or merging more than one branch.</p>

<p>ours This resolves any number of heads, but the
resulting tree of the merge is always that of the current
branch head, effectively ignoring all changes from all other
branches. It is meant to be used to supersede old
development history of side branches. Note that this is
different from the -Xours option to the recursive merge
strategy.</p>

<p>subtree This is a modified recursive strategy. When
merging trees A and B, if B corresponds to a subtree of A, B
is first adjusted to match the tree structure of A, instead
of reading the trees at the same level. This adjustment is
also done to the common ancestor tree.</p>

<p>DEFAULT BEHAVIOUR Often people use git pull without
giving any parameter. Traditionally, this has been
equivalent to saying git pull origin. However, when
configuration branch.&lt;name&gt;.remote is present while on
branch &lt;name&gt;, that value is used instead of
origin.</p>

<p>In order to determine what URL to use to fetch from, the
value of the configuration remote.&lt;origin&gt;.url is
consulted and if there is not any such variable, the value
on URL: line in $GIT_DIR/remotes/&lt;origin&gt; file is
used.</p>

<p>In order to determine what remote branches to fetch (and
optionally store in the tracking branches) when the command
is run without any refspec parameters on the command line,
values of the configuration variable
remote.&lt;origin&gt;.fetch are consulted, and if there
arent any, $GIT_DIR/remotes/&lt;origin&gt; file is consulted
and its Pull: lines are used. In addition to the refspec
formats described in the OPTIONS section, you can have a
globbing refspec that looks like this:</p>

<p>refs/heads/*:refs/remotes/origin/*</p>

<p>A globbing refspec must have a non-empty RHS (i.e. must
store what were fetched in tracking branches), and its LHS
and RHS must end with /*. The above specifies that all
remote branches are tracked using tracking branches in
refs/remotes/origin/ hierarchy under the same name.</p>

<p>The rule to determine which remote branch to merge after
fetching is a bit involved, in order not to break backward
compatibility.</p>

<p>If explicit refspecs were given on the command line of
git pull, they are all merged.</p>

<p>When no refspec was given on the command line, then git
pull uses the refspec from the configuration or
$GIT_DIR/remotes/&lt;origin&gt;. In such cases, the
following rules apply:</p>

<p>1. If branch.&lt;name&gt;.merge configuration for the
current branch &lt;name&gt; exists, that is the name of the
branch at the remote site that is merged.</p>

<p>2. If the refspec is a globbing one, nothing is
merged.</p>

<p>3. Otherwise the remote branch of the first refspec is
merged.</p>

<p>EXAMPLES &middot; Update the remote-tracking branches
for the repository you cloned from, then merge one of them
into your current branch:</p>

<p>$ git pull, git pull origin</p>

<p>Normally the branch merged in is the HEAD of the remote
repository, but the choice is determined by the
branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge
options; see git-config(1) for details.</p>

<p>&middot; Merge into the current branch the remote branch
next:</p>

<p>$ git pull origin next</p>

<p>This leaves a copy of next temporarily in FETCH_HEAD,
but does not update any remote-tracking branches. Using
remote-tracking branches, the same can be done by invoking
fetch and merge:</p>

<p>$ git fetch origin $ git merge origin/next</p>

<p>If you tried a pull which resulted in a complex
conflicts and would want to start over, you can recover with
git reset.</p>

<p>SEE ALSO git-fetch(1), git-merge(1), git-config(1)</p>

<p>AUTHOR Written by Linus Torvalds
&lt;torvalds@osdl.org[1]&gt; and Junio C Hamano
&lt;gitster@pobox.com[2]&gt;</p>

<p>DOCUMENTATION Documentation by Jon Loeliger, David
Greaves, Junio C Hamano and the git-list
&lt;git@vger.kernel.org[3]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. torvalds@osdl.org mailto:torvalds@osdl.org</p>

<p>2. gitster@pobox.com mailto:gitster@pobox.com</p>

<p>3. git@vger.kernel.org mailto:git@vger.kernel.org</p>

<p>Git 1.7.1 02/26/2013 GIT-PULL(1)</p>
<hr>
</body>
</html>
