<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:22:14 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LVMTHIN(7) LVMTHIN(7)</p>

<p>NAME lvmthin LVM thin provisioning</p>

<p>DESCRIPTION Blocks in a standard logical volume are
allocated when the LV is cre- ated, but blocks in a thin
provisioned logical volume are allocated as they are
written. Because of this, a thin provisioned LV is given a
virtual size, and can then be much larger than physically
available storage. The amount of physical storage provided
for thin provisioned LVs can be increased later as the need
arises.</p>

<p>Blocks in a standard LV are allocated (during creation)
from the VG, but blocks in a thin LV are allocated (during
use) from a special &quot;thin pool LV&quot;. The thin pool
LV contains blocks of physical storage, and blocks in thin
LVs just reference blocks in the thin pool LV.</p>

<p>A thin pool LV must be created before thin LVs can be
created within it. A thin pool LV is created by combining
two standard LVs: a large data LV that will hold blocks for
thin LVs, and a metadata LV that will hold metadata. The
metadata tracks which data blocks belong to each thin
LV.</p>

<p>Snapshots of thin LVs are efficient because the data
blocks common to a thin LV and any of its snapshots are
shared. Snapshots may be taken of thin LVs or of other thin
snapshots. Blocks common to recursive snap- shots are also
shared in the thin pool. There is no limit to or degra-
dation from sequences of snapshots.</p>

<p>As thin LVs or snapshot LVs are written to, they consume
data blocks in the thin pool. As free data blocks in the
pool decrease, more free blocks may need to be supplied.
This is done by extending the thin pool data LV with
additional physical space from the VG. Removing thin LVs or
snapshots from the thin pool can also free blocks in the
thin pool. However, removing LVs is not always an effective
way of freeing space in a thin pool because the amount is
limited to the number of blocks not shared with other LVs in
the pool.</p>

<p>Incremental block allocation from thin pools can cause
thin LVs to become fragmented. Standard LVs generally avoid
this problem by allo- cating all the blocks at once during
creation.</p>

<p>Thin Terms ThinDataLV thin data LV large LV created in a
VG used by thin pool to store ThinLV blocks</p>

<p>ThinMetaLV thin metadata LV small LV created in a VG
used by thin pool to track data block usage</p>

<p>ThinPoolLV thin pool LV combination of ThinDataLV and
ThinMetaLV contains ThinLVs and SnapLVs</p>

<p>ThinLV thin LV created from ThinPoolLV appears blank
after creation</p>

<p>SnapLV snapshot LV created from ThinPoolLV appears as a
snapshot of another LV after creation</p>

<p>Thin Usage The primary method for using lvm thin
provisioning:</p>

<p>1. create ThinDataLV Create an LV that will hold thin
pool data.</p>

<p>lvcreate -n ThinDataLV -L LargeSize VG</p>

<p>Example # lvcreate -n pool0 -L 10G vg</p>

<p>2. create ThinMetaLV Create an LV that will hold thin
pool metadata.</p>

<p>lvcreate -n ThinMetaLV -L SmallSize VG</p>

<p>Example # lvcreate -n pool0meta -L 1G vg</p>

<p># lvs LV VG Attr LSize pool0 vg -wi-a----- 10.00g
pool0meta vg -wi-a----- 1.00g</p>

<p>3. create ThinPoolLV Combine the data and metadata LVs
into a thin pool LV. ThinDataLV is renamed to hidden
ThinPoolLV_tdata. ThinMetaLV is renamed to hidden
ThinPoolLV_tmeta. The new ThinPoolLV takes the previous name
of ThinDataLV.</p>

<p>lvconvert --type thin-pool --poolmetadata VG/ThinMetaLV
VG/ThinDataLV</p>

<p>Example # lvconvert --type thin-pool --poolmetadata
vg/pool0meta vg/pool0</p>

<p># lvs vg/pool0 LV VG Attr LSize Pool Origin Data% Meta%
pool0 vg twi-a-tz-- 10.00g 0.00 0.00</p>

<p># lvs -a LV VG Attr LSize pool0 vg twi-a-tz-- 10.00g
[pool0_tdata] vg Twi-ao---- 10.00g [pool0_tmeta] vg
ewi-ao---- 1.00g</p>

<p>4. create ThinLV Create a new thin LV from the thin pool
LV. The thin LV is created with a virtual size. Multiple new
thin LVs may be created in the thin pool. Thin LV names must
be unique in the VG. The --type thin option is inferred from
the virtual size option. The --thinpool argument specifies
which thin pool will contain the ThinLV.</p>

<p>lvcreate -n ThinLV -V VirtualSize --thinpool
VG/ThinPoolLV</p>

<p>Example Create a thin LV in a thin pool: # lvcreate -n
thin1 -V 1T --thinpool vg/pool0</p>

<p>Create another thin LV in the same thin pool: # lvcreate
-n thin2 -V 1T --thinpool vg/pool0</p>

<p># lvs vg/thin1 vg/thin2 LV VG Attr LSize Pool Origin
Data% thin1 vg Vwi-a-tz-- 1.00t pool0 0.00 thin2 vg
Vwi-a-tz-- 1.00t pool0 0.00</p>

<p>5. create SnapLV Create snapshots of an existing ThinLV
or SnapLV. Do not specify -L, --size when creating a thin
snapshot. A size argument will cause an old COW snapshot to
be created.</p>

<p>lvcreate -n SnapLV -s VG/ThinLV lvcreate -n SnapLV -s
VG/PrevSnapLV</p>

<p>Example Create first snapshot of an existing ThinLV: #
lvcreate -n thin1s1 -s vg/thin1</p>

<p>Create second snapshot of the same ThinLV: # lvcreate -n
thin1s2 -s vg/thin1</p>

<p>Create a snapshot of the first snapshot: # lvcreate -n
thin1s1s1 -s vg/thin1s1</p>

<p># lvs vg/thin1s1 vg/thin1s2 vg/thin1s1s1 LV VG Attr
LSize Pool Origin thin1s1 vg Vwi---tz-k 1.00t pool0 thin1
thin1s2 vg Vwi---tz-k 1.00t pool0 thin1 thin1s1s1 vg
Vwi---tz-k 1.00t pool0 thin1s1</p>

<p>6. activate SnapLV Thin snapshots are created with the
persistent &quot;activation skip&quot; flag, indicated by
the &quot;k&quot; attribute. Use -K with lvchange or
vgchange to activate thin snapshots with the &quot;k&quot;
attribute.</p>

<p>lvchange -ay -K VG/SnapLV</p>

<p>Example # lvchange -ay -K vg/thin1s1</p>

<p># lvs vg/thin1s1 LV VG Attr LSize Pool Origin thin1s1 vg
Vwi-a-tz-k 1.00t pool0 thin1</p>

<p>Thin Topics Alternate syntax for specifying type
thin-pool Automatic pool metadata LV Specify devices for
data and metadata LVs Tolerate device failures using raid
Spare metadata LV Metadata check and repair Activation of
thin snapshots Removing thin pool LVs, thin LVs and
snapshots Manually manage free data space of thin pool LV
Manually manage free metadata space of a thin pool LV Using
fstrim to increase free space in a thin pool LV
Automatically extend thin pool LV Data space exhaustion
Metadata space exhaustion Zeroing Discard Chunk size Size of
pool metadata LV Create a thin snapshot of an external, read
only LV Convert a standard LV to a thin LV with an external
origin Single step thin pool LV creation Single step thin
pool LV and thin LV creation Merge thin snapshots XFS on
snapshots</p>

<p>Alternate syntax for specifying type thin-pool</p>

<p>The fully specified syntax for creating a thin pool LV
shown above is:</p>

<p>lvconvert --type thin-pool --poolmetadata VG/ThinMetaLV
VG/ThinDataLV</p>

<p>An existing LV is converted to a thin pool by changing
its type to thin-pool. An alternate syntax may be used for
the same operation:</p>

<p>lvconvert --thinpool VG/ThinDataLV --poolmetadata
VG/ThinMetaLV</p>

<p>The thin-pool type is inferred by lvm; the --thinpool
option is not an alias for --type thin-pool. The use of the
--thinpool option here is different from the use of the
--thinpool option when creating a thin LV, where it
specifies the pool in which the thin LV is created.</p>

<p>Automatic pool metadata LV</p>

<p>A thin data LV can be converted to a thin pool LV
without specifying a thin pool metadata LV. LVM
automatically creates a metadata LV from the same VG.</p>

<p>lvcreate -n ThinDataLV -L LargeSize VG lvconvert --type
thin-pool VG/ThinDataLV</p>

<p>Example # lvcreate -n pool0 -L 10G vg # lvconvert --type
thin-pool vg/pool0</p>

<p># lvs -a pool0 vg twi-a-tz-- 10.00g [pool0_tdata] vg
Twi-ao---- 10.00g [pool0_tmeta] vg ewi-ao---- 16.00m</p>

<p>Specify devices for data and metadata LVs</p>

<p>The data and metadata LVs in a thin pool are best
created on separate physical devices. To do that, specify
the device name(s) at the end of the lvcreate line. It can
be especially helpful to use fast devices for the metadata
LV.</p>

<p>lvcreate -n ThinDataLV -L LargeSize VG LargePV lvcreate
-n ThinMetaLV -L SmallSize VG SmallPV lvconvert --type
thin-pool --poolmetadata VG/ThinMetaLV VG/ThinDataLV</p>

<p>Example # lvcreate -n pool0 -L 10G vg /dev/sdA #
lvcreate -n pool0meta -L 1G vg /dev/sdB # lvconvert --type
thin-pool --poolmetadata vg/pool0meta vg/pool0</p>

<p>lvm.conf(5) thin_pool_metadata_require_separate_pvs
controls the default PV usage for thin pool creation.</p>

<p>Tolerate device failures using raid</p>

<p>To tolerate device failures, use raid for the pool data
LV and pool metadata LV. This is especially recommended for
pool metadata LVs.</p>

<p>lvcreate --type raid1 -m 1 -n ThinMetaLV -L SmallSize VG
PVA PVB lvcreate --type raid1 -m 1 -n ThinDataLV -L
LargeSize VG PVC PVD lvconvert --type thin-pool
--poolmetadata VG/ThinMetaLV VG/ThinDataLV</p>

<p>Example # lvcreate --type raid1 -m 1 -n pool0 -L 10G vg
/dev/sdA /dev/sdB # lvcreate --type raid1 -m 1 -n pool0meta
-L 1G vg /dev/sdC /dev/sdD # lvconvert --type thin-pool
--poolmetadata vg/pool0meta vg/pool0</p>

<p>Spare metadata LV</p>

<p>The first time a thin pool LV is created, lvm will
create a spare meta- data LV in the VG. This behavior can be
controlled with the option --poolmetadataspare y|n. (Future
thin pool creations will also attempt to create the pmspare
LV if none exists.)</p>

<p>To create the pmspare (&quot;pool metadata spare&quot;)
LV, lvm first creates an LV with a default name, e.g. lvol0,
and then converts this LV to a hid- den LV with the _pmspare
suffix, e.g. lvol0_pmspare.</p>

<p>One pmspare LV is kept in a VG to be used for any thin
pool.</p>

<p>The pmspare LV cannot be created explicitly, but may be
removed explic- itly.</p>

<p>Example # lvcreate -n pool0 -L 10G vg # lvcreate -n
pool0meta -L 1G vg # lvconvert --type thin-pool
--poolmetadata vg/pool0meta vg/pool0</p>

<p># lvs -a [lvol0_pmspare] vg ewi------- pool0 vg
twi---tz-- [pool0_tdata] vg Twi------- [pool0_tmeta] vg
ewi-------</p>

<p>The &quot;Metadata check and repair&quot; section
describes the use of the pms- pare LV.</p>

<p>Metadata check and repair</p>

<p>If thin pool metadata is damaged, it may be repairable.
Checking and repairing thin pool metadata is analagous to
running fsck on a file system.</p>

<p>When a thin pool LV is activated, lvm runs the
thin_check command to check the correctness of the metadata
on the pool metadata LV.</p>

<p>lvm.conf(5) thin_check_executable can be set to an empty
string (&quot;&quot;) to disable the thin_check step. This
is not recommended.</p>

<p>lvm.conf(5) thin_check_options controls the command
options used for the thin_check command.</p>

<p>If the thin_check command finds a problem with the
metadata, the thin pool LV is not activated, and the thin
pool metadata needs to be repaired.</p>

<p>Simple repair commands are not always successful.
Advanced repair may require editing thin pool metadata and
lvm metadata. Newer versions of the kernel and lvm tools may
be more successful at repair. Report the details of damaged
thin metadata to get the best advice on recovery.</p>

<p>Command to repair a thin pool: lvconvert --repair
VG/ThinPoolLV</p>

<p>Repair performs the following steps:</p>

<p>1. Creates a new, repaired copy of the metadata.
lvconvert runs the thin_repair command to read damaged
metadata from the existing pool metadata LV, and writes a
new repaired copy to the VGs pmspare LV.</p>

<p>2. Replaces the thin pool metadata LV. If step 1 is
successful, the thin pool metadata LV is replaced with the
pmspare LV containing the corrected metadata. The previous
thin pool metadata LV, containing the damaged metadata,
becomes visible with the new name ThinPoolLV_tmetaN (where N
is 0,1,...).</p>

<p>If the repair works, the thin pool LV and its thin LVs
can be acti- vated, and the LV containing the damaged thin
pool metadata can be removed. It may be useful to move the
new metadata LV (previously pms- pare) to a better PV.</p>

<p>If the repair does not work, the thin pool LV and its
thin LVs are lost.</p>

<p>If metadata is manually restored with thin_repair
directly, the pool metadata LV can be manually swapped with
another LV containing new metadata:</p>

<p>lvconvert --thinpool VG/ThinPoolLV --poolmetadata
VG/NewThinMetaLV</p>

<p>Activation of thin snapshots</p>

<p>When a thin snapshot LV is created, it is by default
given the &quot;activa- tion skip&quot; flag. This flag is
indicated by the &quot;k&quot; attribute displayed by
lvs:</p>

<p># lvs vg/thin1s1 LV VG Attr LSize Pool Origin thin1s1 vg
Vwi---tz-k 1.00t pool0 thin1</p>

<p>This flag causes the snapshot LV to be skipped, i.e. not
activated, by normal activation commands. The skipping
behavior does not apply to deactivation commands.</p>

<p>A snapshot LV with the &quot;k&quot; attribute can be
activated using the -K (or --ignoreactivationskip) option in
addition to the standard -ay (or --activate y) option.</p>

<p>Command to activate a thin snapshot LV: lvchange -ay -K
VG/SnapLV</p>

<p>The persistent &quot;activation skip&quot; flag can be
turned off during lvcre- ate, or later with lvchange using
the -kn (or --setactivationskip n) option. It can be turned
on again with -ky (or --setactivationskip y).</p>

<p>When the &quot;activation skip&quot; flag is removed,
normal activation commands will activate the LV, and the -K
activation option is not needed.</p>

<p>Command to create snapshot LV without the activation
skip flag: lvcreate -kn -n SnapLV -s VG/ThinLV</p>

<p>Command to remove the activation skip flag from a
snapshot LV: lvchange -kn VG/SnapLV</p>

<p>lvm.conf(5) auto_set_activation_skip controls the
default activation skip setting used by lvcreate.</p>

<p>Removing thin pool LVs, thin LVs and snapshots</p>

<p>Removing a thin LV and its related snapshots returns the
blocks it used to the thin pool LV. These blocks will be
reused for other thin LVs and snapshots.</p>

<p>Removing a thin pool LV removes both the data LV and
metadata LV and returns the space to the VG.</p>

<p>lvremove of thin pool LVs, thin LVs and snapshots cannot
be reversed with vgcfgrestore.</p>

<p>vgcfgbackup does not back up thin pool metadata.</p>

<p>Manually manage free data space of thin pool LV</p>

<p>The available free space in a thin pool LV can be
displayed with the lvs command. Free space can be added by
extending the thin pool LV.</p>

<p>Command to extend thin pool data space: lvextend -L Size
VG/ThinPoolLV</p>

<p>Example 1. A thin pool LV is using 26.96% of its data
blocks. # lvs LV VG Attr LSize Pool Origin Data% pool0 vg
twi-a-tz-- 10.00g 26.96</p>

<p>2. Double the amount of physical space in the thin pool
LV. # lvextend -L+10G vg/pool0</p>

<p>3. The percentage of used data blocks is half the
previous value. # lvs LV VG Attr LSize Pool Origin Data%
pool0 vg twi-a-tz-- 20.00g 13.48</p>

<p>Other methods of increasing free data space in a thin
pool LV include removing a thin LV and its related snapsots,
or running fstrim on the file system using a thin LV.</p>

<p>Manually manage free metadata space of a thin pool
LV</p>

<p>The available metadata space in a thin pool LV can be
displayed with the lvs -o+metadata_percent command.</p>

<p>Command to extend thin pool metadata space: lvextend -L
Size VG/ThinPoolLV_tmeta</p>

<p>Example 1. A thin pool LV is using 12.40% of its
metadata blocks. # lvs
-oname,size,data_percent,metadata_percent vg/pool0 LV LSize
Data% Meta% pool0 20.00g 13.48 12.40</p>

<p>2. Display a thin pool LV with its component thin data
LV and thin metadata LV. # lvs -a -oname,attr,size vg LV
Attr LSize pool0 twi-a-tz-- 20.00g [pool0_tdata] Twi-ao----
20.00g [pool0_tmeta] ewi-ao---- 12.00m</p>

<p>3. Double the amount of physical space in the thin
metadata LV. # lvextend -L+12M vg/pool0_tmeta</p>

<p>4. The percentage of used metadata blocks is half the
previous value. # lvs -a
-oname,size,data_percent,metadata_percent vg LV LSize Data%
Meta% pool0 20.00g 13.48 6.20 [pool0_tdata] 20.00g
[pool0_tmeta] 24.00m</p>

<p>Using fstrim to increase free space in a thin pool
LV</p>

<p>Removing files in a file system on top of a thin LV does
not generally add free space back to the thin pool. Manually
running the fstrim com- mand can return space back to the
thin pool that had been used by removed files. fstrim uses
discards and will not work if the thin pool LV has discards
mode set to ignore.</p>

<p>Example A thin pool has 10G of physical data space, and
a thin LV has a virtual size of 100G. Writing a 1G file to
the file system reduces the free space in the thin pool by
10% and increases the virtual usage of the file system by
1%. Removing the 1G file restores the virtual 1% to the file
system, but does not restore the physical 10% to the thin
pool. The fstrim command restores the physical space to the
thin pool.</p>

<p># lvs -a
-oname,attr,size,pool_lv,origin,data_percent,metadata_percent
vg LV Attr LSize Pool Origin Data% Meta% pool0 twi-a-tz--
10.00g 47.01 21.03 thin1 Vwi-aotz-- 100.00g pool0 2.70</p>

<p># df -h /mnt/X Filesystem Size Used Avail Use% Mounted
on /dev/mapper/vg-thin1 99G 1.1G 93G 2% /mnt/X</p>

<p># dd if=/dev/zero of=/mnt/X/1Gfile bs=4096 count=262144;
sync</p>

<p># lvs pool0 vg twi-a-tz-- 10.00g 57.01 25.26 thin1 vg
Vwi-aotz-- 100.00g pool0 3.70</p>

<p># df -h /mnt/X /dev/mapper/vg-thin1 99G 2.1G 92G 3%
/mnt/X</p>

<p># rm /mnt/X/1Gfile</p>

<p># lvs pool0 vg twi-a-tz-- 10.00g 57.01 25.26 thin1 vg
Vwi-aotz-- 100.00g pool0 3.70</p>

<p># df -h /mnt/X /dev/mapper/vg-thin1 99G 1.1G 93G 2%
/mnt/X</p>

<p># fstrim -v /mnt/X</p>

<p># lvs pool0 vg twi-a-tz-- 10.00g 47.01 21.03 thin1 vg
Vwi-aotz-- 100.00g pool0 2.70</p>

<p>The &quot;Discard&quot; section covers an option for
automatically freeing data space in a thin pool.</p>

<p>Automatically extend thin pool LV</p>

<p>The lvm daemon dmeventd (lvm2-monitor) monitors the data
usage of thin pool LVs and extends them when the usage
reaches a certain level. The necessary free space must exist
in the VG to extend thin pool LVs. Monitoring and extension
of thin pool LVs are controlled independently.</p>

<p>monitoring</p>

<p>When a thin pool LV is activated, dmeventd will begin
monitoring it by default.</p>

<p>Command to start or stop dmeventd monitoring a thin pool
LV: lvchange --monitor {y|n} VG/ThinPoolLV</p>

<p>The current dmeventd monitoring status of a thin pool LV
can be dis- played with the command lvs -o+seg_monitor.</p>

<p>autoextend</p>

<p>dmeventd should be configured to extend thin pool LVs
before all data space is used. Warnings are emitted through
syslog when the use of a thin pool reaches 80%, 85%, 90% and
95%. (See the section &quot;Data space exhaustion&quot; for
the effects of not extending a thin pool LV.) The point at
which dmeventd extends thin pool LVs, and the amount are
con- trolled with two configuration settings:</p>

<p>lvm.conf(5) thin_pool_autoextend_threshold is a
percentage full value that defines when the thin pool LV
should be extended. Setting this to 100 disables automatic
extention. The mini- mum value is 50.</p>

<p>lvm.conf(5) thin_pool_autoextend_percent defines how
much extra data space should be added to the thin pool LV
from the VG, in percent of its current size.</p>

<p>disabling</p>

<p>There are multiple ways that extension of thin pools
could be pre- vented:</p>

<p>&middot; If the dmeventd daemon is not running, no
monitoring or automatic extension will occur.</p>

<p>&middot; Even when dmeventd is running, all monitoring
can be disabled with the lvm.conf monitoring setting.</p>

<p>&middot; To activate or create a thin pool LV without
interacting with dmeventd, the --ignoremonitoring option can
be used. With this option, the command will not ask dmeventd
to monitor the thin pool LV.</p>

<p>&middot; Setting thin_pool_autoextend_threshould to 100
disables automatic extension of thin pool LVs, even if they
are being monitored by dmeventd.</p>

<p>Example If thin_pool_autoextend_threshold is 70 and
thin_pool_autoextend_per- cent is 20, whenever a pool
exceeds 70% usage, it will be extended by another 20%. For a
1G pool, using 700M will trigger a resize to 1.2G. When the
usage exceeds 840M, the pool will be extended to 1.44G, and
so on.</p>

<p>Data space exhaustion</p>

<p>When properly managed, thin pool data space should be
extended before it is all used (see the section
&quot;Automatically extend thin pool LV&quot;). If thin pool
data space is already exhausted, it can still be extended
(see the section &quot;Manually manage free data space of
thin pool LV&quot;.)</p>

<p>The behavior of a full thin pool is configurable with
the --errorwhen- full y|n option to lvcreate or lvchange.
The errorwhenfull setting applies only to writes; reading
thin LVs can continue even when data space is exhausted.</p>

<p>Command to change the handling of a full thin pool:
lvchange --errorwhenfull {y|n} VG/ThinPoolLV</p>

<p>lvm.conf(5) error_when_full controls the default error
when full behavior.</p>

<p>The current setting of a thin pool LV can be displayed
with the com- mand: lvs -o+lv_when_full.</p>

<p>The errorwhenfull setting does not effect the monitoring
and autoextend settings, and the monitoring/autoextend
settings do not effect the errorwhenfull setting. It is only
when monitoring/autoextend are not effective that the thin
pool becomes full and the errorwhenfull setting is
applied.</p>

<p>errorwhenfull n</p>

<p>This is the default. Writes to thin LVs are accepted and
queued, with the expectation that pool data space will be
extended soon. Once data space is extended, the queued
writes will be processed, and the thin pool will return to
normal operation.</p>

<p>While waiting to be extended, the thin pool will queue
writes for up to 60 seconds (the default). If data space has
not been extended after this time, the queued writes will
return an error to the caller, e.g. the file system. This
can result in file system corruption for non- journaled file
systems that may require fsck. When a thin pool returns
errors for writes to a thin LV, any file system is subject
to losing unsynced user data.</p>

<p>The 60 second timeout can be changed or disabled with
the dm-thin-pool kernel module option no_space_timeout. This
option sets the number of seconds that thin pools will queue
writes. If set to 0, writes will not time out. Disabling
timeouts can result in the system running out of resources,
memory exhaustion, hung tasks, and deadlocks. (The time- out
applies to all thin pools on the system.)</p>

<p>errorwhenfull y</p>

<p>Writes to thin LVs immediately return an error, and no
writes are queued. In the case of a file system, this can
result in corruption that may require fsck (the specific
consequences depend on the thin LV user.)</p>

<p>data percent</p>

<p>When data space is exhausted, the lvs command displays
100 under Data% for the thin pool LV:</p>

<p># lvs vg/pool0 LV VG Attr LSize Pool Origin Data% pool0
vg twi-a-tz-- 512.00m 100.00</p>

<p>causes</p>

<p>A thin pool may run out of data space for any of the
following reasons:</p>

<p>&middot; Automatic extension of the thin pool is
disabled, and the thin pool is not manually extended.
(Disabling automatic extension is not rec- ommended.)</p>

<p>&middot; The dmeventd daemon is not running and the thin
pool is not manually extended. (Disabling dmeventd is not
recommended.)</p>

<p>&middot; Automatic extension of the thin pool is too
slow given the rate of writes to thin LVs in the pool. (This
can be addressed by tuning the
thin_pool_autoextend_threshold and
thin_pool_autoextend_percent.)</p>

<p>&middot; The VG does not have enough free blocks to
extend the thin pool.</p>

<p>Metadata space exhaustion</p>

<p>If thin pool metadata space is exhausted (or a thin pool
metadata operation fails), errors will be returned for IO
operations on thin LVs.</p>

<p>When metadata space is exhausted, the lvs command
displays 100 under Meta% for the thin pool LV:</p>

<p># lvs -o lv_name,size,data_percent,metadata_percent
vg/pool0 LV LSize Data% Meta% pool0 100.00</p>

<p>The same reasons for thin pool data space exhaustion
apply to thin pool metadata space.</p>

<p>Metadata space exhaustion can lead to inconsistent thin
pool metadata and inconsistent file systems, so the response
requires offline check- ing and repair.</p>

<p>1. Deactivate the thin pool LV, or reboot the system if
this is not possible.</p>

<p>2. Repair thin pool with lvconvert --repair. See
&quot;Metadata check and repair&quot;.</p>

<p>3. Extend pool metadata space with lvextend
VG/ThinPoolLV_tmeta. See &quot;Manually manage free metadata
space of a thin pool LV&quot;.</p>

<p>4. Check and repair file system with fsck.</p>

<p>Zeroing</p>

<p>When a thin pool provisions a new data block for a thin
LV, the new block is first overwritten with zeros. The
zeroing mode is indicated by the &quot;z&quot; attribute
displayed by lvs. The option -Z (or --zero) can be added to
commands to specify the zeroing mode.</p>

<p>Command to set the zeroing mode when creating a thin
pool LV: lvconvert --type thin-pool -Z{y|n} --poolmetadata
VG/ThinMetaLV VG/ThinDataLV</p>

<p>Command to change the zeroing mode of an existing thin
pool LV: lvchange -Z{y|n} VG/ThinPoolLV</p>

<p>If zeroing mode is changed from &quot;n&quot; to
&quot;y&quot;, previously provisioned blocks are not
zeroed.</p>

<p>Provisioning of large zeroed chunks impacts
performance.</p>

<p>lvm.conf(5) thin_pool_zero controls the default zeroing
mode used when creating a thin pool.</p>

<p>Discard</p>

<p>The discard behavior of a thin pool LV determines how
discard requests are handled. Enabling discard under a file
system may adversely affect the file system performance (see
the section on fstrim for an alterna- tive.) Possible
discard behaviors:</p>

<p>ignore: Ignore any discards that are received.</p>

<p>nopassdown: Process any discards in the thin pool itself
and allow the no longer needed extends to be overwritten by
new data.</p>

<p>passdown: Process discards in the thin pool (as with
nopassdown), and pass the discards down the the underlying
device. This is the default mode.</p>

<p>Command to display the current discard mode of a thin
pool LV: lvs -o+discards VG/ThinPoolLV</p>

<p>Command to set the discard mode when creating a thin
pool LV: lvconvert --discards {ignore|nopassdown|passdown}
--type thin-pool --poolmetadata VG/ThinMetaLV
VG/ThinDataLV</p>

<p>Command to change the discard mode of an existing thin
pool LV: lvchange --discards {ignore|nopassdown|passdown}
VG/ThinPoolLV</p>

<p>Example # lvs -o name,discards vg/pool0 pool0
passdown</p>

<p># lvchange --discards ignore vg/pool0</p>

<p>lvm.conf(5) thin_pool_discards controls the default
discards mode used when creating a thin pool.</p>

<p>Chunk size</p>

<p>The size of data blocks managed by a thin pool can be
specified with the --chunksize option when the thin pool LV
is created. The default unit is kilobytes and the default
value is 64KiB. The value must be a power of two between
4KiB and 1GiB.</p>

<p>When a thin pool is used primarily for the thin
provisioning feature, a larger value is optimal. To optimize
for a lot of snapshotting, a smaller value reduces copying
time and consumes less space.</p>

<p>Command to display the thin pool LV chunk size: lvs
-o+chunksize VG/ThinPoolLV</p>

<p>Example # lvs -o name,chunksize pool0 64.00k</p>

<p>lvm.conf(5) thin_pool_chunk_size controls the default
chunk size used when creating a thin pool.</p>

<p>Size of pool metadata LV</p>

<p>The amount of thin metadata depends on how many blocks
are shared between thin LVs (i.e. through snapshots). A thin
pool with many snap- shots may need a larger metadata
LV.</p>

<p>The range of supported metadata LV sizes is 2MiB to
16GiB. The default size is estimated with the formula:
ThinPoolLVSize / ThinPoolLVChunkSize * 64b.</p>

<p>When creating a thin metadata LV explicitly, the size is
specified in the lvcreate command. When a command
automatically creates a thin metadata LV, the
--poolmetadatasize option can be used specify a non- default
size. The default unit is megabytes.</p>

<p>Create a thin snapshot of an external, read only LV</p>

<p>Thin snapshots are typically taken of other thin LVs or
other thin snapshot LVs within the same thin pool. It is
also possible to take thin snapshots of external, read only
LVs. Writes to the snapshot are stored in the thin pool, and
the external LV is used to read unwritten parts of the thin
snapshot.</p>

<p>lvcreate -n SnapLV -s VG/ExternalOriginLV --thinpool
VG/ThinPoolLV</p>

<p>Example # lvchange -an vg/lve # lvchange --permission r
vg/lve # lvcreate -n snaplve -s vg/lve --thinpool
vg/pool0</p>

<p># lvs vg/lve vg/snaplve LV VG Attr LSize Pool Origin
Data% lve vg ori------- 10.00g snaplve vg Vwi-a-tz-- 10.00g
pool0 lve 0.00</p>

<p>Convert a standard LV to a thin LV with an external
origin</p>

<p>A new thin LV can be created and given the name of an
existing standard LV. At the same time, the existing LV is
converted to a read only external LV with a new name.
Unwritten portions of the thin LV are read from the external
LV. The new name given to the existing LV can be specified
with --originname, otherwise the existing LV will be given a
default name, e.g. lvol#.</p>

<p>Convert ExampleLV into a read only external LV with the
new name NewEx- ternalOriginLV, and create a new thin LV
that is given the previous name of ExampleLV.</p>

<p>lvconvert --type thin --thinpool VG/ThinPoolLV
--originname NewExternalOriginLV --thin VG/ExampleLV</p>

<p>Example # lvcreate -n lv_example -L 10G vg</p>

<p># lvs lv_example vg -wi-a----- 10.00g</p>

<p># lvconvert --type thin --thinpool vg/pool0 --originname
lv_external --thin vg/lv_example</p>

<p># lvs LV VG Attr LSize Pool Origin lv_example vg
Vwi-a-tz-- 10.00g pool0 lv_external lv_external vg
ori------- 10.00g</p>

<p>Single step thin pool LV creation</p>

<p>A thin pool LV can be created with a single lvcreate
command, rather than using lvconvert on existing LVs. This
one command creates a thin data LV, a thin metadata LV, and
combines the two into a thin pool LV.</p>

<p>lvcreate --type thin-pool -L LargeSize -n ThinPoolLV
VG</p>

<p>Example # lvcreate --type thin-pool -L8M -n pool0 vg</p>

<p># lvs vg/pool0 LV VG Attr LSize Pool Origin Data% pool0
vg twi-a-tz-- 8.00m 0.00</p>

<p># lvs -a pool0 vg twi-a-tz-- 8.00m [pool0_tdata] vg
Twi-ao---- 8.00m [pool0_tmeta] vg ewi-ao---- 8.00m</p>

<p>Single step thin pool LV and thin LV creation</p>

<p>A thin pool LV and a thin LV can be created with a
single lvcreate com- mand. This one command creates a thin
data LV, a thin metadata LV, combines the two into a thin
pool LV, and creates a thin LV in the new pool. -L LargeSize
specifies the physical size of the thin pool LV. -V
VirtualSize specifies the virtual size of the thin LV.</p>

<p>lvcreate -V VirtualSize -L LargeSize -n ThinLV
--thinpool VG/ThinPoolLV</p>

<p>Equivalent to: lvcreate --type thin-pool -L LargeSize
VG/ThinPoolLV lvcreate -n ThinLV -V VirtualSize --thinpool
VG/ThinPoolLV</p>

<p>Example # lvcreate -L8M -V2G -n thin1 --thinpool
vg/pool0</p>

<p># lvs -a pool0 vg twi-a-tz-- 8.00m [pool0_tdata] vg
Twi-ao---- 8.00m [pool0_tmeta] vg ewi-ao---- 8.00m thin1 vg
Vwi-a-tz-- 2.00g pool0</p>

<p>Merge thin snapshots</p>

<p>A thin snapshot can be merged into its origin thin LV
using the lvcon- vert --merge command. The result of a
snapshot merge is that the ori- gin thin LV takes the
content of the snapshot LV, and the snapshot LV is removed.
Any content that was unique to the origin thin LV is lost
after the merge.</p>

<p>Because a merge changes the content of an LV, it cannot
be done while the LVs are open, e.g. mounted. If a merge is
initiated while the LVs are open, the effect of the merge is
delayed until the origin thin LV is next activated.</p>

<p>lvconvert --merge VG/SnapLV</p>

<p>Example # lvs vg LV VG Attr LSize Pool Origin pool0 vg
twi-a-tz-- 10.00g thin1 vg Vwi-a-tz-- 100.00g pool0 thin1s1
vg Vwi-a-tz-k 100.00g pool0 thin1</p>

<p># lvconvert --merge vg/thin1s1</p>

<p># lvs vg LV VG Attr LSize Pool Origin pool0 vg
twi-a-tz-- 10.00g thin1 vg Vwi-a-tz-- 100.00g pool0</p>

<p>Example Delayed merging of open LVs.</p>

<p># lvs vg LV VG Attr LSize Pool Origin pool0 vg
twi-a-tz-- 10.00g thin1 vg Vwi-aotz-- 100.00g pool0 thin1s1
vg Vwi-aotz-k 100.00g pool0 thin1</p>

<p># df /dev/mapper/vg-thin1 100G 33M 100G 1% /mnt/X
/dev/mapper/vg-thin1s1 100G 33M 100G 1% /mnt/Xs</p>

<p># ls /mnt/X file1 file2 file3 # ls /mnt/Xs file3 file4
file5</p>

<p># lvconvert --merge vg/thin1s1 Logical volume vg/thin1s1
contains a filesystem in use. Delaying merge since snapshot
is open. Merging of thin snapshot thin1s1 will occur on next
activation.</p>

<p># umount /mnt/X # umount /mnt/Xs</p>

<p># lvs -a vg LV VG Attr LSize Pool Origin pool0 vg
twi-a-tz-- 10.00g [pool0_tdata] vg Twi-ao---- 10.00g
[pool0_tmeta] vg ewi-ao---- 1.00g thin1 vg Owi-a-tz--
100.00g pool0 [thin1s1] vg Swi-a-tz-k 100.00g pool0
thin1</p>

<p># lvchange -an vg/thin1 # lvchange -ay vg/thin1</p>

<p># mount /dev/vg/thin1 /mnt/X</p>

<p># ls /mnt/X file3 file4 file5</p>

<p>XFS on snapshots</p>

<p>Mounting an XFS file system on a new snapshot LV
requires attention to the file systems log state and uuid.
On the snapshot LV, the xfs log will contain a dummy
transaction, and the xfs uuid will match the uuid from the
file system on the origin LV.</p>

<p>If the snapshot LV is writable, mounting will recover
the log to clear the dummy transaction, but will require
skipping the uuid check:</p>

<p>mount /dev/VG/SnapLV /mnt -o nouuid</p>

<p>Or, the uuid can be changed on disk before mounting:</p>

<p>xfs_admin -U generate /dev/VG/SnapLV mount
/dev/VG/SnapLV /mnt</p>

<p>If the snapshot LV is readonly, the log recovery and
uuid check need to be skipped while mounting readonly:</p>

<p>mount /dev/VG/SnapLV /mnt -o ro,nouuid,norecovery</p>

<p>SEE ALSO lvm(8), lvm.conf(5), lvcreate(8), lvconvert(8),
lvchange(8), lvex- tend(8), lvremove(8), lvs(8),
thin_dump(8), thin_repair(8) thin_restore(8)</p>

<p>Red Hat, Inc LVM TOOLS 2.02.118(2)-RHEL6 (2015-04-15)
LVMTHIN(7)</p>
<hr>
</body>
</html>
