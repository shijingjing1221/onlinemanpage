<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:32:01 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RSHD(8) BSD System Manager s Manual RSHD(8)</p>

<p>NAME rshd - remote shell server</p>

<p>SYNOPSIS rshd [-ahlnL]</p>

<p>DESCRIPTION The rshd server is the server for the
rcmd(3) routine and, consequently, for the rsh(1) program.
The server provides remote execution facilities with
authentication based on privileged port numbers from trusted
hosts.</p>

<p>The rshd server listens for service requests at the port
indicated in the cmd service specification; see services(5).
When a service request is received the following protocol is
initiated:</p>

<p>1. The server checks the clients source port. If the
port is not in the range 512-1023, the server aborts the
connection.</p>

<p>2. The server reads characters from the socket up to a
null ( ) byte. The resultant string is interpreted as an
ASCII number, base 10.</p>

<p>3. If the number received in step 2 is non-zero, it is
interpreted as the port number of a secondary stream to be
used for the stderr. A second connection is then created to
the specified port on the client s machine. The source port
of this second connection is also in the range 512-1023.</p>

<p>4. The server checks the client s source address and
requests the cor- responding host name (see
gethostbyaddr(3), hosts(5) and named(8)). If the hostname
cannot be determined, the dot-notation representa- tion of
the host address is used. If the hostname is in the same
domain as the server (according to the last two components
of the domain name), or if the -a option is given, the
addresses for the hostname are requested, verifying that the
name and address corre- spond. If address verification
fails, the connection is aborted with the message, Host
address mismatch.</p>

<p>5. A null terminated user name of at most 16 characters
is retrieved on the initial socket. This user name is
interpreted as the user iden- tity on the clients
machine.</p>

<p>6. A null terminated user name of at most 16 characters
is retrieved on the initial socket. This user name is
interpreted as a user iden- tity to use on the servers
machine.</p>

<p>7. A null terminated command to be passed to a shell is
retrieved on the initial socket. The length of the command
is limited by the upper bound on the size of the systems
argument list.</p>

<p>8. Rshd then validates the user using ruserok(3), which
uses the file /etc/hosts.equiv and the .rhosts file found in
the user s home directory. The -l option prevents ruserok(3)
from doing any valida- tion based on the users .rhosts file
(unless the user is the superuser and the -h option is
used.) If the -h option is not used, superuser accounts may
not be accessed via this service at all.</p>

<p>The -l option should not be trusted without verifying
that it works as expected with the particular version of
libc installed on your system (and should be tested again
after any libc update) because some versions of libc may not
honor the flags used by rshd.</p>

<p>Also note that the design of the .rhosts system is
COMPLETELY INSE- CURE except on a carefully firewalled
private network. Under all other circumstances, rshd should
be disabled entirely.</p>

<p>9. A null byte is returned on the initial socket and the
command line is passed to the normal login shell of the
user. The shell inherits the network connections established
by rshd.</p>

<p>Transport-level keepalive messages are enabled unless
the -n option is present. The use of keepalive messages
allows sessions to be timed out if the client crashes or
becomes unreachable.</p>

<p>The -L option causes all successful accesses to be
logged to syslogd(8) as auth.info messages and all failed
accesses to be logged as auth.notice.</p>

<p>DIAGNOSTICS Except for the last one listed below, all
diagnostic messages are returned on the initial socket,
after which any network connections are closed. An error is
indicated by a leading byte with a value of 1 (0 is returned
in step 9 above upon successful completion of all the steps
prior to the execution of the login shell).</p>

<p>Locuser too long. The name of the user on the clients
machine is longer than 16 characters.</p>

<p>Ruser too long. The name of the user on the remote
machine is longer than 16 characters.</p>

<p>Command too long. The command line passed exceeds the
size of the argument list (as configured into the
system).</p>

<p>Remote directory. The chdir command to the home
directory failed.</p>

<p>Permission denied. The authentication procedure
described above failed, or the user requested did not exist.
(These conditions are intentionally con- flated.)</p>

<p>Cat make pipe. The pipe needed for the stderr, wasnt
created.</p>

<p>Cat fork; try again. A fork by the server failed.</p>

<p>&lt;shellname&gt;: ... The users login shell could not
be started. This message is returned on the connection
associated with the stderr, and is not preceded by a flag
byte.</p>

<p>SEE ALSO rsh(1), rcmd(3), ruserok(3)</p>

<p>BUGS The authentication procedure used here assumes the
integrity of each client machine and the connecting medium.
This is insecure, but is use- ful in an open
environment.</p>

<p>A facility to allow all data exchanges to be encrypted
should be present.</p>

<p>A more extensible protocol (such as Telnet) should be
used.</p>

<p>Linux NetKit (0.17) April 20, 1991 Linux NetKit
(0.17)</p>
<hr>
</body>
</html>
