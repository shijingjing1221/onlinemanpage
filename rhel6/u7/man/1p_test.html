<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:41:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TEST(1P) POSIX Programmer s Manual TEST(1P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME test - evaluate expression</p>

<p>SYNOPSIS test [expression]</p>

<p>[ [expression] ]</p>

<p>DESCRIPTION The test utility shall evaluate the
expression and indicate the result of the evaluation by its
exit status. An exit status of zero indicates that the
expression evaluated as true and an exit status of 1
indicates that the expression evaluated as false.</p>

<p>In the second form of the utility, which uses
&quot;[]&quot; rather than test, the application shall
ensure that the square brackets are separate arguments.</p>

<p>OPTIONS The test utility shall not recognize the
&quot;--&quot; argument in the manner specified by guideline
10 in the Base Definitions volume of IEEE Std 1003.1-2001,
Section 12.2, Utility Syntax Guidelines.</p>

<p>No options shall be supported.</p>

<p>OPERANDS The application shall ensure that all operators
and elements of pri- maries are presented as separate
arguments to the test utility.</p>

<p>The following primaries can be used to construct
expression:</p>

<p>-b file True if file exists and is a block special
file.</p>

<p>-c file True if file exists and is a character special
file.</p>

<p>-d file True if file exists and is a directory.</p>

<p>-e file True if file exists.</p>

<p>-f file True if file exists and is a regular file.</p>

<p>-g file True if file exists and its set-group-ID flag is
set.</p>

<p>-h file True if file exists and is a symbolic link.</p>

<p>-L file True if file exists and is a symbolic link.</p>

<p>-n string True if the length of string is non-zero.</p>

<p>-p file True if file is a FIFO.</p>

<p>-r file True if file exists and is readable. True shall
indicate that permission to read from file will be granted,
as defined in File Read, Write, and Creation .</p>

<p>-S file True if file exists and is a socket.</p>

<p>-s file True if file exists and has a size greater than
zero.</p>

<p>-t file_descriptor</p>

<p>True if the file whose file descriptor number is
file_descriptor is open and is associated with a
terminal.</p>

<p>-u file True if file exists and its set-user-ID flag is
set.</p>

<p>-w file True if file exists and is writable. True shall
indicate that permission to write from file will be granted,
as defined in File Read, Write, and Creation .</p>

<p>-x file True if file exists and is executable. True
shall indicate that permission to execute file will be
granted, as defined in File Read, Write, and Creation . If
file is a directory, true shall indicate that permission to
search file will be granted.</p>

<p>-z string True if the length of string string is
zero.</p>

<p>string True if the string string is not the null
string.</p>

<p>s1 = s2 True if the strings s1 and s2 are identical.</p>

<p>s1 != s2 True if the strings s1 and s2 are not
identical.</p>

<p>n1 -eq n2 True if the integers n1 and n2 are
algebraically equal.</p>

<p>n1 -ne n2 True if the integers n1 and n2 are not
algebraically equal.</p>

<p>n1 -gt n2 True if the integer n1 is algebraically
greater than the integer n2.</p>

<p>n1 -ge n2 True if the integer n1 is algebraically
greater than or equal to the integer n2.</p>

<p>n1 -lt n2 True if the integer n1 is algebraically less
than the integer n2.</p>

<p>n1 -le n2 True if the integer n1 is algebraically less
than or equal to the integer n2.</p>

<p>expression1 -a expression2</p>

<p>True if both expression1 and expression2 are true. The
-a binary primary is left associative. It has a higher
precedence than -o.</p>

<p>expression1 -o expression2</p>

<p>True if either expression1 or expression2 is true. The
-o binary primary is left associative.</p>

<p>With the exception of the -h file and -L file primaries,
if a file argument is a symbolic link, test shall evaluate
the expression by resolving the symbolic link and using the
file referenced by the link.</p>

<p>These primaries can be combined with the following
operators:</p>

<p>! expression True if expression is false.</p>

<p>( expression ) True if expression is true. The
parentheses can be used to alter the normal precedence and
associativity.</p>

<p>The primaries with two elements of the form:</p>

<p>-primary_operator primary_operand</p>

<p>are known as unary primaries. The primaries with three
elements in either of the two forms:</p>

<p>primary_operand -primary_operator primary_operand</p>

<p>primary_operand primary_operator primary_operand</p>

<p>are known as binary primaries. Additional
implementation-defined opera- tors and primary_operators may
be provided by implementations. They shall be of the form -
operator where the first character of operator is not a
digit.</p>

<p>The algorithm for determining the precedence of the
operators and the return value that shall be generated is
based on the number of argu- ments presented to test.
(However, when using the &quot;[...]&quot; form, the
right-bracket final argument shall not be counted in this
algorithm.)</p>

<p>In the following list, $1, $2, $3, and $4 represent the
arguments pre- sented to test:</p>

<p>0 arguments: Exit false (1).</p>

<p>1 argument: Exit true (0) if $1 is not null; otherwise,
exit false.</p>

<p>2 arguments:</p>

<p>* If $1 is , exit true if $2 is null, false if $2 is not
null.</p>

<p>* If $1 is a unary primary, exit true if the unary test
is true, false if the unary test is false.</p>

<p>* Otherwise, produce unspecified results.</p>

<p>3 arguments:</p>

<p>* If $2 is a binary primary, perform the binary test of
$1 and $3.</p>

<p>* If $1 is, negate the two-argument test of $2 and
$3.</p>

<p>* If $1 is(and $3 is, perform the unary test of $2.</p>

<p>* Otherwise, produce unspecified results.</p>

<p>4 arguments:</p>

<p>* If $1 is, negate the three-argument test of $2, $3,
and $4.</p>

<p>* If $1 is(and $4 is, perform the two-argument test of
$2 and $3.</p>

<p>* Otherwise, the results are unspecified.</p>

<p>&gt;4 arguments: The results are unspecified.</p>

<p>On XSI-conformant systems, combinations of primaries and
operators shall be evaluated using the precedence and
associativity rules described previously. In addition, the
string comparison binary pri- maries =and &quot;!=&quot;
shall have a higher precedence than any unary pri- mary.</p>

<p>STDIN Not used.</p>

<p>INPUT FILES None.</p>

<p>ENVIRONMENT VARIABLES The following environment
variables shall affect the execution of test:</p>

<p>LANG Provide a default value for the
internationalization variables that are unset or null. (See
the Base Definitions volume of IEEE Std 1003.1-2001, Section
8.2, Internationalization Vari- ables for the precedence of
internationalization variables used to determine the values
of locale categories.)</p>

<p>LC_ALL If set to a non-empty string value, override the
values of all the other internationalization variables.</p>

<p>LC_CTYPE Determine the locale for the interpretation of
sequences of bytes of text data as characters (for example,
single-byte as opposed to multi-byte characters in
arguments).</p>

<p>LC_MESSAGES Determine the locale that should be used to
affect the format and contents of diagnostic messages
written to standard error.</p>

<p>NLSPATH Determine the location of message catalogs for
the processing of LC_MESSAGES .</p>

<p>ASYNCHRONOUS EVENTS Default.</p>

<p>STDOUT Not used.</p>

<p>STDERR The standard error shall be used only for
diagnostic messages.</p>

<p>OUTPUT FILES None.</p>

<p>EXTENDED DESCRIPTION None.</p>

<p>EXIT STATUS The following exit values shall be
returned:</p>

<p>0 expression evaluated to true.</p>

<p>1 expression evaluated to false or expression was
missing.</p>

<p>&gt;1 An error occurred.</p>

<p>CONSEQUENCES OF ERRORS Default.</p>

<p>The following sections are informative.</p>

<p>APPLICATION USAGE Scripts should be careful when dealing
with user-supplied input that could be confused with
primaries and operators. Unless the application writer knows
all the cases that produce input to the script, invoca-
tions like:</p>

<p>test &quot;$1&quot; -a &quot;$2&quot;</p>

<p>should be written as:</p>

<p>test &quot;$1&quot; &amp;&amp; test &quot;$2&quot;</p>

<p>to avoid problems if a user supplied values such as $1
set to! and $2 set to the null string. That is, in cases
where maximal portability is of concern, replace:</p>

<p>test expr1 -a expr2</p>

<p>with:</p>

<p>test expr1 &amp;&amp; test expr2</p>

<p>and replace:</p>

<p>test expr1 -o expr2</p>

<p>with:</p>

<p>test expr1 || test expr2</p>

<p>but note that, in test, -a has higher precedence than -o
while &quot;&amp;&amp;&quot; and &quot;||&quot; have equal
precedence in the shell.</p>

<p>Parentheses or braces can be used in the shell command
language to effect grouping.</p>

<p>Parentheses must be escaped when using sh; for
example:</p>

<p>test( expr1 -a expr) -o expr3</p>

<p>This command is not always portable outside
XSI-conformant systems. The following form can be used
instead:</p>

<p>( test expr1 &amp;&amp; test expr2 ) || test expr3</p>

<p>The two commands:</p>

<p>test &quot;$1&quot; test ! &quot;$1&quot;</p>

<p>could not be used reliably on some historical systems.
Unexpected results would occur if such a string expression
were used and $1 expanded to,, or a known unary primary.
Better constructs are:</p>

<p>test -n &quot;$1&quot; test -z &quot;$1&quot;
respectively.</p>

<p>Historical systems have also been unreliable given the
common con- struct:</p>

<p>test &quot;$response&quot; = &quot;expected
string&quot;</p>

<p>One of the following is a more reliable form:</p>

<p>test &quot;X$response&quot; = &quot;Xexpected
string&quot; test &quot;expected string&quot; =
&quot;$response&quot;</p>

<p>Note that the second form assumes that expected string
could not be confused with any unary primary. If expected
string starts with, ( , !, or even, the first form should be
used instead. Using the preceding rules without the XSI
marked extensions, any of the three comparison forms is
reliable, given any input. (However, note that the strings
are quoted in all cases.)</p>

<p>Because the string comparison binary primaries, = and
&quot;!=&quot;, have a higher precedence than any unary
primary in the greater than 4 argument case, unexpected
results can occur if arguments are not properly pre- pared.
For example, in:</p>

<p>test -d $1 -o -d $2</p>

<p>If $1 evaluates to a possible directory name of, the
first three arguments are considered a string comparison,
which shall cause a syn- tax error when the second -d is
encountered. One of the following forms prevents this; the
second is preferred:</p>

<p>test( -d &quot;$1) -o( -d &quot;$2) test -d
&quot;$1&quot; || test -d &quot;$2&quot;</p>

<p>Also in the greater than 4 argument case:</p>

<p>test &quot;$1&quot; = &quot;bat&quot; -a &quot;$2&quot;
= &quot;ball&quot;</p>

<p>syntax errors occur if $1 evaluates to(or!. One of the
follow- ing forms prevents this; the third is preferred:</p>

<p>test &quot;X$1&quot; = &quot;Xbat&quot; -a
&quot;X$2&quot; = &quot;Xball&quot; test &quot;$1&quot; =
&quot;bat&quot; &amp;&amp; test &quot;$2&quot; =
&quot;ball&quot; test &quot;X$1&quot; = &quot;Xbat&quot;
&amp;&amp; test &quot;X$2&quot; = &quot;Xball&quot;</p>

<p>EXAMPLES 1. Exit if there are not two or three arguments
(two variations):</p>

<p>if [ $# -ne 2 -a $# -ne 3 ]; then exit 1; fi if [ $# -lt
2 -o $# -gt 3 ]; then exit 1; fi</p>

<p>2. Perform a mkdir if a directory does not exist:</p>

<p>test ! -d tempdir &amp;&amp; mkdir tempdir</p>

<p>3. Wait for a file to become non-readable:</p>

<p>while test -r thefile do sleep 30 done
echo&quot;thefile&quot; is no longer readable</p>

<p>4. Perform a command if the argument is one of three
strings (two variations):</p>

<p>if [ &quot;$1&quot; = &quot;pear&quot; ] || [
&quot;$1&quot; = &quot;grape&quot; ] || [ &quot;$1&quot; =
&quot;apple&quot; ] then command fi</p>

<p>case &quot;$1&quot; in pear|grape|apple) command ;;
esac</p>

<p>RATIONALE The KornShell-derived conditional command
(double bracket [[]]) was removed from the shell command
language description in an early pro- posal. Objections were
raised that the real problem is misuse of the test command (
[), and putting it into the shell is the wrong way to fix
the problem. Instead, proper documentation and a new shell
reserved word ( !) are sufficient.</p>

<p>Tests that require multiple test operations can be done
at the shell level using individual invocations of the test
command and shell logi- cals, rather than using the
error-prone -o flag of test.</p>

<p>XSI-conformant systems support more than four
arguments.</p>

<p>XSI-conformant systems support the combining of
primaries with the fol- lowing constructs:</p>

<p>expression1 -a expression2</p>

<p>True if both expression1 and expression2 are true.</p>

<p>expression1 -o expression2</p>

<p>True if at least one of expression1 and expression2 are
true.</p>

<p>( expression )</p>

<p>True if expression is true.</p>

<p>In evaluating these more complex combined expressions,
the following precedence rules are used:</p>

<p>* The unary primaries have higher precedence than the
algebraic binary primaries.</p>

<p>* The unary primaries have lower precedence than the
string binary primaries.</p>

<p>* The unary and binary primaries have higher precedence
than the unary string primary.</p>

<p>* The ! operator has higher precedence than the -a
operator, and the -a operator has higher precedence than the
-o operator.</p>

<p>* The -a and -o operators are left associative.</p>

<p>* The parentheses can be used to alter the normal
precedence and asso- ciativity.</p>

<p>The BSD and System V versions of -f are not the same.
The BSD defini- tion was:</p>

<p>-f file True if file exists and is not a directory.</p>

<p>The SVID version (true if the file exists and is a
regular file) was chosen for this volume of IEEE Std
1003.1-2001 because its use is con- sistent with the -b, -c,
-d, and -p operands ( file exists and is a specific file
type).</p>

<p>The -e primary, possessing similar functionality to that
provided by the C shell, was added because it provides the
only way for a shell script to find out if a file exists
without trying to open the file. Since implementations are
allowed to add additional file types, a portable script
cannot use:</p>

<p>test -b foo -o -c foo -o -d foo -o -f foo -o -p foo</p>

<p>to find out if foo is an existing file. On historical
BSD systems, the existence of a file could be determined
by:</p>

<p>test -f foo -o -d foo</p>

<p>but there was no easy way to determine that an existing
file was a reg- ular file. An early proposal used the
KornShell -a primary (with the same meaning), but this was
changed to -e because there were concerns about the high
probability of humans confusing the -a primary with the -a
binary operator.</p>

<p>The following options were not included in this volume
of IEEE Std 1003.1-2001, although they are provided by some
implementa- tions. These operands should not be used by new
implementations for other purposes:</p>

<p>-k file True if file exists and its sticky bit is
set.</p>

<p>-C file True if file is a contiguous file.</p>

<p>-V file True if file is a version file.</p>

<p>The following option was not included because it was
undocumented in most implementations, has been removed from
some implementations (including System V), and the
functionality is provided by the shell (see Parameter
Expansion .</p>

<p>-l string The length of the string string.</p>

<p>The -b, -c, -g, -p, -u, and -x operands are derived from
the SVID; his- torical BSD does not provide them. The -k
operand is derived from Sys- tem V; historical BSD does not
provide it.</p>

<p>On historical BSD systems, test -w directory always
returned false because test tried to open the directory for
writing, which always fails.</p>

<p>Some additional primaries newly invented or from the
KornShell appeared in an early proposal as part of the
conditional command ( [[]]): s1 &gt; s2, s1 &lt; s2, str =
pattern, str != pattern, f1 -nt f2, f1 -ot f2, and f1 -ef
f2. They were not carried forward into the test utility when
the conditional command was removed from the shell because
they have not been included in the test utility built into
historical implementations of the sh utility.</p>

<p>The -t file_descriptor primary is shown with a mandatory
argument because the grammar is ambiguous if it can be
omitted. Historical implementations have allowed it to be
omitted, providing a default of 1.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO File Read, Write, and Creation, find</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 TEST(1P)</p>
<hr>
</body>
</html>
