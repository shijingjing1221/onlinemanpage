<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:41:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TIFFReadRGBAImage(3TIFF) TIFFReadRGBAImage(3TIFF)</p>

<p>NAME TIFFReadRGBAImage, TIFFReadRGBAImageOriented - read
and decode an image into a fixed-format raster</p>

<p>SYNOPSIS #include &lt;tiffio.h&gt;</p>

<p>#define TIFFGetR(abgr) ((abgr) &amp; 0xff) #define
TIFFGetG(abgr) (((abgr) &gt;&gt; 8) &amp; 0xff) #define
TIFFGetB(abgr) (((abgr) &gt;&gt; 16) &amp; 0xff) #define
TIFFGetA(abgr) (((abgr) &gt;&gt; 24) &amp; 0xff)</p>

<p>int TIFFReadRGBAImage(TIFF *tif, uint32 width, uint32
height, uint32 *raster, int stopOnError) int
TIFFReadRGBAImageOriented(TIFF *tif, uint32 width, uint32
height, uint32 *raster, int orientation, int
stopOnError)</p>

<p>DESCRIPTION TIFFReadRGBAImage reads a strip- or
tile-based image into memory, stor- ing the result in the
user supplied raster. The raster is assumed to be an array
of width times height 32-bit entries, where width must be
less than or equal to the width of the image (height may be
any non- zero size). If the raster dimensions are smaller
than the image, the image data is cropped to the raster
bounds. If the raster height is greater than that of the
image, then the image data are placed in the lower part of
the raster. (Note that the raster is assume to be orga-
nized such that the pixel at location (x,y) is
raster[y*width+x]; with the raster origin in the lower-left
hand corner.)</p>

<p>TIFFReadRGBAImageOriented works like TIFFReadRGBAImage
with except of that user can specify the raster origin
position with the orientation parameter. Four orientations
supported:</p>

<p>ORIENTATION_TOPLEFT origin in top-left corner,</p>

<p>ORIENTATION_TOPRIGHT origin in top-right corner,</p>

<p>ORIENTATION_BOTLEFT origin in bottom-left corner and</p>

<p>ORIENTATION_BOTRIGHT origin in bottom-right corner.</p>

<p>If you choose ORIENTATION_BOTLEFT result will be the
same as returned by the TIFFReadRGBAImage.</p>

<p>Raster pixels are 8-bit packed red, green, blue, alpha
samples. The macros TIFFGetR, TIFFGetG, TIFFGetB, and
TIFFGetA should be used to access individual samples. Images
without Associated Alpha matting information have a constant
Alpha of 1.0 (255).</p>

<p>TIFFReadRGBAImage converts non-8-bit images by scaling
sample values. Palette, grayscale, bilevel, CMYK, and YCbCr
images are converted to RGB transparently. Raster pixels are
returned uncorrected by any col- orimetry information
present in the directory.</p>

<p>The paramater stopOnError specifies how to act if an
error is encoun- tered while reading the image. If
stopOnError is non-zero, then an error will terminate the
operation; otherwise TIFFReadRGBAImage will continue
processing data until all the possible data in the image
have been requested.</p>

<p>NOTES In C++ the stopOnError parameter defaults to
0.</p>

<p>Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric sam- ples/pixel must be either 1, 3, or 4 (i.e.
SamplesPerPixel minus ExtraSamples).</p>

<p>Palettte image colormaps that appear to be incorrectly
written as 8-bit values are automatically scaled to
16-bits.</p>

<p>TIFFReadRGBAImage is just a wrapper around the more
general TIFFRGBAIm- age(3TIFF) facilities.</p>

<p>RETURN VALUES 1 is returned if the image was
successfully read and converted. Other- wise, 0 is returned
if an error was encountered and stopOnError is zero.</p>

<p>DIAGNOSTICS All error messages are directed to the
TIFFError(3TIFF) routine.</p>

<p>Sorry, can not handle %d-bit pictures. The image had
BitsPerSample other than 1, 2, 4, 8, or 16.</p>

<p>Sorry, can not handle %d-channel images. The image had
SamplesPerPixel other than 1, 3, or 4.</p>

<p>Missing needed &quot;PhotometricInterpretation&quot;
tag. The image did not have a tag that describes how to
display the data.</p>

<p>No &quot;PhotometricInterpretation&quot; tag, assuming
RGB. The image was miss- ing a tag that describes how to
display it, but because it has 3 or 4 samples/pixel, it is
assumed to be RGB.</p>

<p>No &quot;PhotometricInterpretation&quot; tag, assuming
min-is-black. The image was missing a tag that describes how
to display it, but because it has 1 sample/pixel, it is
assumed to be a grayscale or bilevel image.</p>

<p>No space for photometric conversion table. There was
insufficient mem- ory for a table used to convert image
samples to 8-bit RGB.</p>

<p>Missing required &quot;Colormap&quot; tag. A Palette
image did not have a required Colormap tag.</p>

<p>No space for tile buffer. There was insufficient memory
to allocate an i/o buffer.</p>

<p>No space for strip buffer. There was insufficient memory
to allocate an i/o buffer.</p>

<p>Can not handle format. The image has a format
(combination of BitsPer- Sample, SamplesPerPixel, and
PhotometricInterpretation) that TIFFRead- RGBAImage can not
handle.</p>

<p>No space for B&amp;W mapping table. There was
insufficient memory to allo- cate a table used to map
grayscale data to RGB.</p>

<p>No space for Palette mapping table. There was
insufficient memory to allocate a table used to map data to
8-bit RGB.</p>

<p>SEE ALSO TIFFOpen(3TIFF), TIFFRGBAImage(3TIFF),
TIFFReadRGBAStrip(3TIFF), TIFF- ReadRGBATile(3TIFF),
libtiff(3TIFF)</p>

<p>Libtiff library home page:
http://www.remotesensing.org/libtiff/</p>

<p>libtiff October 13, 2006 TIFFReadRGBAImage(3TIFF)</p>
<hr>
</body>
</html>
