<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:06:01 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>BLK_QUEUE_DMA_DRAIN(9) Block Devices
BLK_QUEUE_DMA_DRAIN(9)</p>

<p>NAME blk_queue_dma_drain - Set up a drain buffer for
excess dma.</p>

<p>SYNOPSIS int blk_queue_dma_drain(struct request_queue *
q, dma_drain_needed_fn * dma_drain_needed, void * buf,
unsigned int size);</p>

<p>ARGUMENTS q the request queue for the device</p>

<p>dma_drain_needed fn which returns non-zero if drain is
necessary</p>

<p>buf physically contiguous buffer</p>

<p>size size of the buffer in bytes</p>

<p>DESCRIPTION Some devices have excess DMA problems and
can&acute;t simply discard (or zero fill) the unwanted piece
of the transfer. They have to have a real area of memory to
transfer it into. The use case for this is ATAPI devices in
DMA mode. If the packet command causes a transfer bigger
than the transfer size some HBAs will lock up if there
aren&acute;t DMA elements to contain the excess transfer.
What this API does is adjust the queue so that the buf is
always appended silently to the scatterlist.</p>

<p>NOTE This routine adjusts max_hw_segments to make room
for appending the drain buffer. If you call
blk_queue_max_segments after calling this routine, you must
set the limit to one fewer than your device can support
otherwise there won&acute;t be room for the drain
buffer.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
BLK_QUEUE_DMA_DRAIN(9)</p>
<hr>
</body>
</html>
