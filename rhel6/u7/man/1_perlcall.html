<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLCALL(1) Perl Programmers Reference Guide
PERLCALL(1)</p>

<p>NAME perlcall - Perl calling conventions from C</p>

<p>DESCRIPTION The purpose of this document is to show you
how to call Perl subroutines directly from C, i.e., how to
write callbacks.</p>

<p>Apart from discussing the C interface provided by Perl
for writing callbacks the document uses a series of examples
to show how the interface actually works in practice. In
addition some techniques for coding callbacks are
covered.</p>

<p>Examples where callbacks are necessary include</p>

<p>&middot; An Error Handler</p>

<p>You have created an XSUB interface to an applications C
API.</p>

<p>A fairly common feature in applications is to allow you
to define a C function that will be called whenever
something nasty occurs. What we would like is to be able to
specify a Perl subroutine that will be called instead.</p>

<p>&middot; An Event Driven Program</p>

<p>The classic example of where callbacks are used is when
writing an event driven program like for an X windows
application. In this case you register functions to be
called whenever specific events occur, e.g., a mouse button
is pressed, the cursor moves into a window or a menu item is
selected.</p>

<p>Although the techniques described here are applicable
when embedding Perl in a C program, this is not the primary
goal of this document. There are other details that must be
considered and are specific to embedding Perl. For details
on embedding Perl in C refer to perlembed.</p>

<p>Before you launch yourself head first into the rest of
this document, it would be a good idea to have read the
following two documents - perlxs and perlguts.</p>

<p>THE CALL_ FUNCTIONS Although this stuff is easier to
explain using examples, you first need be aware of a few
important definitions.</p>

<p>Perl has a number of C functions that allow you to call
Perl subroutines. They are</p>

<p>I32 call_sv(SV* sv, I32 flags); I32 call_pv(char
*subname, I32 flags); I32 call_method(char *methname, I32
flags); I32 call_argv(char *subname, I32 flags, register
char **argv);</p>

<p>The key function is call_sv. All the other functions are
fairly simple wrappers which make it easier to call Perl
subroutines in special cases. At the end of the day they
will all call call_sv to invoke the Perl subroutine.</p>

<p>All the call_* functions have a &quot;flags&quot;
parameter which is used to pass a bit mask of options to
Perl. This bit mask operates identically for each of the
functions. The settings available in the bit mask are
discussed in &quot;FLAG VALUES&quot;.</p>

<p>Each of the functions will now be discussed in turn.</p>

<p>call_sv call_sv takes two parameters, the first,
&quot;sv&quot;, is an SV*. This allows you to specify the
Perl subroutine to be called either as a C string (which has
first been converted to an SV) or a reference to a
subroutine. The section, Using call_sv, shows how you can
make use of call_sv.</p>

<p>call_pv The function, call_pv, is similar to call_sv
except it expects its first parameter to be a C char* which
identifies the Perl subroutine you want to call, e.g.,
&quot;call_pv(&quot;fred&quot;, 0)&quot;. If the subroutine
you want to call is in another package, just include the
package name in the string, e.g., &quot;pkg::fred&quot;.</p>

<p>call_method The function call_method is used to call a
method from a Perl class. The parameter &quot;methname&quot;
corresponds to the name of the method to be called. Note
that the class that the method belongs to is passed on the
Perl stack rather than in the parameter list. This class can
be either the name of the class (for a static method) or a
reference to an object (for a virtual method). See perlobj
for more information on static and virtual methods and
&quot;Using call_method&quot; for an example of using
call_method.</p>

<p>call_argv call_argv calls the Perl subroutine specified
by the C string stored in the &quot;subname&quot; parameter.
It also takes the usual &quot;flags&quot; parameter. The
final parameter, &quot;argv&quot;, consists of a NULL
terminated list of C strings to be passed as parameters to
the Perl subroutine. See Using call_argv.</p>

<p>All the functions return an integer. This is a count of
the number of items returned by the Perl subroutine. The
actual items returned by the subroutine are stored on the
Perl stack.</p>

<p>As a general rule you should always check the return
value from these functions. Even if you are expecting only a
particular number of values to be returned from the Perl
subroutine, there is nothing to stop someone from doing
something unexpected--dont say you havent been warned.</p>

<p>FLAG VALUES The &quot;flags&quot; parameter in all the
call_* functions is a bit mask which can consist of any
combination of the symbols defined below, ORed together.</p>

<p>G_VOID Calls the Perl subroutine in a void context.</p>

<p>This flag has 2 effects:</p>

<p>1. It indicates to the subroutine being called that it
is executing in a void context (if it executes wantarray the
result will be the undefined value).</p>

<p>2. It ensures that nothing is actually returned from the
subroutine.</p>

<p>The value returned by the call_* function indicates how
many items have been returned by the Perl subroutine - in
this case it will be 0.</p>

<p>G_SCALAR Calls the Perl subroutine in a scalar context.
This is the default context flag setting for all the call_*
functions.</p>

<p>This flag has 2 effects:</p>

<p>1. It indicates to the subroutine being called that it
is executing in a scalar context (if it executes wantarray
the result will be false).</p>

<p>2. It ensures that only a scalar is actually returned
from the subroutine. The subroutine can, of course, ignore
the wantarray and return a list anyway. If so, then only the
last element of the list will be returned.</p>

<p>The value returned by the call_* function indicates how
many items have been returned by the Perl subroutine - in
this case it will be either 0 or 1.</p>

<p>If 0, then you have specified the G_DISCARD flag.</p>

<p>If 1, then the item actually returned by the Perl
subroutine will be stored on the Perl stack - the section
Returning a Scalar shows how to access this value on the
stack. Remember that regardless of how many items the Perl
subroutine returns, only the last one will be accessible
from the stack - think of the case where only one value is
returned as being a list with only one element. Any other
items that were returned will not exist by the time control
returns from the call_* function. The section Returning a
list in a scalar context shows an example of this
behavior.</p>

<p>G_ARRAY Calls the Perl subroutine in a list context.</p>

<p>As with G_SCALAR, this flag has 2 effects:</p>

<p>1. It indicates to the subroutine being called that it
is executing in a list context (if it executes wantarray the
result will be true).</p>

<p>2. It ensures that all items returned from the
subroutine will be accessible when control returns from the
call_* function.</p>

<p>The value returned by the call_* function indicates how
many items have been returned by the Perl subroutine.</p>

<p>If 0, then you have specified the G_DISCARD flag.</p>

<p>If not 0, then it will be a count of the number of items
returned by the subroutine. These items will be stored on
the Perl stack. The section Returning a list of values gives
an example of using the G_ARRAY flag and the mechanics of
accessing the returned items from the Perl stack.</p>

<p>G_DISCARD By default, the call_* functions place the
items returned from by the Perl subroutine on the stack. If
you are not interested in these items, then setting this
flag will make Perl get rid of them automatically for you.
Note that it is still possible to indicate a context to the
Perl subroutine by using either G_SCALAR or G_ARRAY.</p>

<p>If you do not set this flag then it is very important
that you make sure that any temporaries (i.e., parameters
passed to the Perl subroutine and values returned from the
subroutine) are disposed of yourself. The section Returning
a Scalar gives details of how to dispose of these
temporaries explicitly and the section Using Perl to dispose
of temporaries discusses the specific circumstances where
you can ignore the problem and let Perl deal with it for
you.</p>

<p>G_NOARGS Whenever a Perl subroutine is called using one
of the call_* functions, it is assumed by default that
parameters are to be passed to the subroutine. If you are
not passing any parameters to the Perl subroutine, you can
save a bit of time by setting this flag. It has the effect
of not creating the @_ array for the Perl subroutine.</p>

<p>Although the functionality provided by this flag may
seem straightforward, it should be used only if there is a
good reason to do so. The reason for being cautious is that
even if you have specified the G_NOARGS flag, it is still
possible for the Perl subroutine that has been called to
think that you have passed it parameters.</p>

<p>In fact, what can happen is that the Perl subroutine you
have called can access the @_ array from a previous Perl
subroutine. This will occur when the code that is executing
the call_* function has itself been called from another Perl
subroutine. The code below illustrates this</p>

<p>sub fred { print &quot;@_0 }</p>

<p>sub joe { &amp;fred }</p>

<p>&amp;joe(1,2,3);</p>

<p>This will print</p>

<p>1 2 3</p>

<p>What has happened is that &quot;fred&quot; accesses the
@_ array which belongs to &quot;joe&quot;.</p>

<p>G_EVAL It is possible for the Perl subroutine you are
calling to terminate abnormally, e.g., by calling die
explicitly or by not actually existing. By default, when
either of these events occurs, the process will terminate
immediately. If you want to trap this type of event, specify
the G_EVAL flag. It will put an eval { } around the
subroutine call.</p>

<p>Whenever control returns from the call_* function you
need to check the $@ variable as you would in a normal Perl
script.</p>

<p>The value returned from the call_* function is dependent
on what other flags have been specified and whether an error
has occurred. Here are all the different cases that can
occur:</p>

<p>&middot; If the call_* function returns normally, then
the value returned is as specified in the previous
sections.</p>

<p>&middot; If G_DISCARD is specified, the return value
will always be 0.</p>

<p>&middot; If G_ARRAY is specified and an error has
occurred, the return value will always be 0.</p>

<p>&middot; If G_SCALAR is specified and an error has
occurred, the return value will be 1 and the value on the
top of the stack will be undef. This means that if you have
already detected the error by checking $@ and you want the
program to continue, you must remember to pop the undef from
the stack.</p>

<p>See Using G_EVAL for details on using G_EVAL.</p>

<p>G_KEEPERR You may have noticed that using the G_EVAL
flag described above will always clear the $@ variable and
set it to a string describing the error iff there was an
error in the called code. This unqualified resetting of $@
can be problematic in the reliable identification of errors
using the &quot;eval {}&quot; mechanism, because the
possibility exists that perl will call other code (end of
block processing code, for example) between the time the
error causes $@ to be set within &quot;eval {}&quot;, and
the subsequent statement which checks for the value of $@
gets executed in the users script.</p>

<p>This scenario will mostly be applicable to code that is
meant to be called from within destructors, asynchronous
callbacks, signal handlers, &quot;__DIE__&quot; or
&quot;__WARN__&quot; hooks, and &quot;tie&quot; functions.
In such situations, you will not want to clear $@ at all,
but simply to append any new errors to any existing value of
$@.</p>

<p>The G_KEEPERR flag is meant to be used in conjunction
with G_EVAL in call_* functions that are used to implement
such code. This flag has no effect when G_EVAL is not
used.</p>

<p>When G_KEEPERR is used, any errors in the called code
will be prefixed with the string &quot;(in cleanup)&quot;,
and appended to the current value of $@. an error will not
be appended if that same error string is already at the end
of $@.</p>

<p>In addition, a warning is generated using the appended
string. This can be disabled using &quot;no warnings
&rsquo;misc&rsquo;&quot;.</p>

<p>The G_KEEPERR flag was introduced in Perl version
5.002.</p>

<p>See Using G_KEEPERR for an example of a situation that
warrants the use of this flag.</p>

<p>Determining the Context As mentioned above, you can
determine the context of the currently executing subroutine
in Perl with wantarray. The equivalent test can be made in C
by using the &quot;GIMME_V&quot; macro, which returns
&quot;G_ARRAY&quot; if you have been called in a list
context, &quot;G_SCALAR&quot; if in a scalar context, or
&quot;G_VOID&quot; if in a void context (i.e. the return
value will not be used). An older version of this macro is
called &quot;GIMME&quot;; in a void context it returns
&quot;G_SCALAR&quot; instead of &quot;G_VOID&quot;. An
example of using the &quot;GIMME_V&quot; macro is shown in
section Using GIMME_V.</p>

<p>EXAMPLES Enough of the definition talk, lets have a few
examples.</p>

<p>Perl provides many macros to assist in accessing the
Perl stack. Wherever possible, these macros should always be
used when interfacing to Perl internals. We hope this should
make the code less vulnerable to any changes made to Perl in
the future.</p>

<p>Another point worth noting is that in the first series
of examples I have made use of only the call_pv function.
This has been done to keep the code simpler and ease you
into the topic. Wherever possible, if the choice is between
using call_pv and call_sv, you should always try to use
call_sv. See Using call_sv for details.</p>

<p>No Parameters, Nothing returned This first trivial
example will call a Perl subroutine, PrintUID, to print out
the UID of the process.</p>

<p>sub PrintUID { print &quot;UID is $&lt;0; }</p>

<p>and here is a C function to call it</p>

<p>static void call_PrintUID() { dSP;</p>

<p>PUSHMARK(SP); call_pv(&quot;PrintUID&quot;,
G_DISCARD|G_NOARGS); }</p>

<p>Simple, eh.</p>

<p>A few points to note about this example.</p>

<p>1. Ignore &quot;dSP&quot; and &quot;PUSHMARK(SP)&quot;
for now. They will be discussed in the next example.</p>

<p>2. We aren t passing any parameters to PrintUID so
G_NOARGS can be specified.</p>

<p>3. We aren t interested in anything returned from
PrintUID, so G_DISCARD is specified. Even if PrintUID was
changed to return some value(s), having specified G_DISCARD
will mean that they will be wiped by the time control
returns from call_pv.</p>

<p>4. As call_pv is being used, the Perl subroutine is
specified as a C string. In this case the subroutine name
has been hard-wired into the code.</p>

<p>5. Because we specified G_DISCARD, it is not necessary
to check the value returned from call_pv. It will always be
0.</p>

<p>Passing Parameters Now lets make a slightly more complex
example. This time we want to call a Perl subroutine,
&quot;LeftString&quot;, which will take 2 parameters--a
string ($s) and an integer ($n). The subroutine will simply
print the first $n characters of the string.</p>

<p>So the Perl subroutine would look like this</p>

<p>sub LeftString { my($s, $n) = @_; print substr($s, 0,
$n), &quot;0; }</p>

<p>The C function required to call LeftString would look
like this.</p>

<p>static void call_LeftString(a, b) char * a; int b; {
dSP;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSVpv(a, 0)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>call_pv(&quot;LeftString&quot;, G_DISCARD);</p>

<p>FREETMPS; LEAVE; }</p>

<p>Here are a few notes on the C function
call_LeftString.</p>

<p>1. Parameters are passed to the Perl subroutine using
the Perl stack. This is the purpose of the code beginning
with the line &quot;dSP&quot; and ending with the line
&quot;PUTBACK&quot;. The &quot;dSP&quot; declares a local
copy of the stack pointer. This local copy should always be
accessed as &quot;SP&quot;.</p>

<p>2. If you are going to put something onto the Perl
stack, you need to know where to put it. This is the purpose
of the macro &quot;dSP&quot;--it declares and initializes a
local copy of the Perl stack pointer.</p>

<p>All the other macros which will be used in this example
require you to have used this macro.</p>

<p>The exception to this rule is if you are calling a Perl
subroutine directly from an XSUB function. In this case it
is not necessary to use the &quot;dSP&quot; macro
explicitly--it will be declared for you automatically.</p>

<p>3. Any parameters to be pushed onto the stack should be
bracketed by the &quot;PUSHMARK&quot; and
&quot;PUTBACK&quot; macros. The purpose of these two macros,
in this context, is to count the number of parameters you
are pushing automatically. Then whenever Perl is creating
the @_ array for the subroutine, it knows how big to make
it.</p>

<p>The &quot;PUSHMARK&quot; macro tells Perl to make a
mental note of the current stack pointer. Even if you arent
passing any parameters (like the example shown in the
section No Parameters, Nothing returned) you must still call
the &quot;PUSHMARK&quot; macro before you can call any of
the call_* functions--Perl still needs to know that there
are no parameters.</p>

<p>The &quot;PUTBACK&quot; macro sets the global copy of
the stack pointer to be the same as our local copy. If we
didn t do this call_pv wouldn t know where the two
parameters we pushed were--remember that up to now all the
stack pointer manipulation we have done is with our local
copy, not the global copy.</p>

<p>4. Next, we come to XPUSHs. This is where the parameters
actually get pushed onto the stack. In this case we are
pushing a string and an integer.</p>

<p>See &quot;XSUBs and the Argument Stack&quot; in perlguts
for details on how the XPUSH macros work.</p>

<p>5. Because we created temporary values (by means of
sv_2mortal() calls) we will have to tidy up the Perl stack
and dispose of mortal SVs.</p>

<p>This is the purpose of</p>

<p>ENTER; SAVETMPS;</p>

<p>at the start of the function, and</p>

<p>FREETMPS; LEAVE;</p>

<p>at the end. The &quot;ENTER&quot;/&quot;SAVETMPS&quot;
pair creates a boundary for any temporaries we create. This
means that the temporaries we get rid of will be limited to
those which were created after these calls.</p>

<p>The &quot;FREETMPS&quot;/&quot;LEAVE&quot; pair will get
rid of any values returned by the Perl subroutine (see next
example), plus it will also dump the mortal SVs we have
created. Having &quot;ENTER&quot;/&quot;SAVETMPS&quot; at
the beginning of the code makes sure that no other mortals
are destroyed.</p>

<p>Think of these macros as working a bit like using
&quot;{&quot; and &quot;}&quot; in Perl to limit the scope
of local variables.</p>

<p>See the section Using Perl to dispose of temporaries for
details of an alternative to using these macros.</p>

<p>6. Finally, LeftString can now be called via the call_pv
function. The only flag specified this time is G_DISCARD.
Because we are passing 2 parameters to the Perl subroutine
this time, we have not specified G_NOARGS.</p>

<p>Returning a Scalar Now for an example of dealing with
the items returned from a Perl subroutine.</p>

<p>Here is a Perl subroutine, Adder, that takes 2 integer
parameters and simply returns their sum.</p>

<p>sub Adder { my($a, $b) = @_; $a + $b; }</p>

<p>Because we are now concerned with the return value from
Adder, the C function required to call it is now a bit more
complex.</p>

<p>static void call_Adder(a, b) int a; int b; { dSP; int
count;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>count = call_pv(&quot;Adder&quot;, G_SCALAR);</p>

<p>SPAGAIN;</p>

<p>if (count != 1) croak(&quot;Big trouble0);</p>

<p>printf (&quot;The sum of %d and %d is %d0, a, b,
POPi);</p>

<p>PUTBACK; FREETMPS; LEAVE; }</p>

<p>Points to note this time are</p>

<p>1. The only flag specified this time was G_SCALAR. That
means the @_ array will be created and that the value
returned by Adder will still exist after the call to
call_pv.</p>

<p>2. The purpose of the macro &quot;SPAGAIN&quot; is to
refresh the local copy of the stack pointer. This is
necessary because it is possible that the memory allocated
to the Perl stack has been reallocated whilst in the call_pv
call.</p>

<p>If you are making use of the Perl stack pointer in your
code you must always refresh the local copy using SPAGAIN
whenever you make use of the call_* functions or any other
Perl internal function.</p>

<p>3. Although only a single value was expected to be
returned from Adder, it is still good practice to check the
return code from call_pv anyway.</p>

<p>Expecting a single value is not quite the same as
knowing that there will be one. If someone modified Adder to
return a list and we didn t check for that possibility and
take appropriate action the Perl stack would end up in an
inconsistent state. That is something you really dont want
to happen ever.</p>

<p>4. The &quot;POPi&quot; macro is used here to pop the
return value from the stack. In this case we wanted an
integer, so &quot;POPi&quot; was used.</p>

<p>Here is the complete list of POP macros available, along
with the types they return.</p>

<p>POPs SV POPp pointer POPn double POPi integer POPl
long</p>

<p>5. The final &quot;PUTBACK&quot; is used to leave the
Perl stack in a consistent state before exiting the
function. This is necessary because when we popped the
return value from the stack with &quot;POPi&quot; it updated
only our local copy of the stack pointer. Remember,
&quot;PUTBACK&quot; sets the global stack pointer to be the
same as our local copy.</p>

<p>Returning a list of values Now, lets extend the previous
example to return both the sum of the parameters and the
difference.</p>

<p>Here is the Perl subroutine</p>

<p>sub AddSubtract { my($a, $b) = @_; ($a+$b, $a-$b); }</p>

<p>and this is the C function</p>

<p>static void call_AddSubtract(a, b) int a; int b; { dSP;
int count;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);</p>

<p>SPAGAIN;</p>

<p>if (count != 2) croak(&quot;Big trouble0);</p>

<p>printf (&quot;%d - %d = %d0, a, b, POPi); printf
(&quot;%d + %d = %d0, a, b, POPi);</p>

<p>PUTBACK; FREETMPS; LEAVE; }</p>

<p>If call_AddSubtract is called like this</p>

<p>call_AddSubtract(7, 4);</p>

<p>then here is the output</p>

<p>7 - 4 = 3 7 + 4 = 11</p>

<p>Notes</p>

<p>1. We wanted list context, so G_ARRAY was used.</p>

<p>2. Not surprisingly &quot;POPi&quot; is used twice this
time because we were retrieving 2 values from the stack. The
important thing to note is that when using the
&quot;POP*&quot; macros they come off the stack in reverse
order.</p>

<p>Returning a list in a scalar context Say the Perl
subroutine in the previous section was called in a scalar
context, like this</p>

<p>static void call_AddSubScalar(a, b) int a; int b; { dSP;
int count; int i;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>count = call_pv(&quot;AddSubtract&quot;, G_SCALAR);</p>

<p>SPAGAIN;</p>

<p>printf (&quot;Items Returned = %d0, count);</p>

<p>for (i = 1; i &lt;= count; ++i) printf (&quot;Value %d =
%d0, i, POPi);</p>

<p>PUTBACK; FREETMPS; LEAVE; }</p>

<p>The other modification made is that call_AddSubScalar
will print the number of items returned from the Perl
subroutine and their value (for simplicity it assumes that
they are integer). So if call_AddSubScalar is called</p>

<p>call_AddSubScalar(7, 4);</p>

<p>then the output will be</p>

<p>Items Returned = 1 Value 1 = 3</p>

<p>In this case the main point to note is that only the
last item in the list is returned from the subroutine,
AddSubtract actually made it back to call_AddSubScalar.</p>

<p>Returning Data from Perl via the parameter list It is
also possible to return values directly via the parameter
list - whether it is actually desirable to do it is another
matter entirely.</p>

<p>The Perl subroutine, Inc, below takes 2 parameters and
increments each directly.</p>

<p>sub Inc { ++ $_[0]; ++ $_[1]; }</p>

<p>and here is a C function to call it.</p>

<p>static void call_Inc(a, b) int a; int b; { dSP; int
count; SV * sva; SV * svb;</p>

<p>ENTER; SAVETMPS;</p>

<p>sva = sv_2mortal(newSViv(a)); svb =
sv_2mortal(newSViv(b));</p>

<p>PUSHMARK(SP); XPUSHs(sva); XPUSHs(svb); PUTBACK;</p>

<p>count = call_pv(&quot;Inc&quot;, G_DISCARD);</p>

<p>if (count != 0) croak (&quot;call_Inc: expected 0 values
from &rsquo;Inc&rsquo;, got %d0, count);</p>

<p>printf (&quot;%d + 1 = %d0, a, SvIV(sva)); printf
(&quot;%d + 1 = %d0, b, SvIV(svb));</p>

<p>FREETMPS; LEAVE; }</p>

<p>To be able to access the two parameters that were pushed
onto the stack after they return from call_pv it is
necessary to make a note of their addresses--thus the two
variables &quot;sva&quot; and &quot;svb&quot;.</p>

<p>The reason this is necessary is that the area of the
Perl stack which held them will very likely have been
overwritten by something else by the time control returns
from call_pv.</p>

<p>Using G_EVAL Now an example using G_EVAL. Below is a
Perl subroutine which computes the difference of its 2
parameters. If this would result in a negative result, the
subroutine calls die.</p>

<p>sub Subtract { my ($a, $b) = @_;</p>

<p>die &quot;death can be fatal0 if $a &lt; $b;</p>

<p>$a - $b; }</p>

<p>and some C to call it</p>

<p>static void call_Subtract(a, b) int a; int b; { dSP; int
count;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>count = call_pv(&quot;Subtract&quot;,
G_EVAL|G_SCALAR);</p>

<p>SPAGAIN;</p>

<p>/* Check the eval first */ if (SvTRUE(ERRSV)) { printf
(&quot;Uh oh - %s0, SvPV_nolen(ERRSV)); POPs; } else { if
(count != 1) croak(&quot;call_Subtract: wanted 1 value from
&rsquo;Subtract&rsquo;, got %d0, count);</p>

<p>printf (&quot;%d - %d = %d0, a, b, POPi); }</p>

<p>PUTBACK; FREETMPS; LEAVE; }</p>

<p>If call_Subtract is called thus</p>

<p>call_Subtract(4, 5)</p>

<p>the following will be printed</p>

<p>Uh oh - death can be fatal</p>

<p>Notes</p>

<p>1. We want to be able to catch the die so we have used
the G_EVAL flag. Not specifying this flag would mean that
the program would terminate immediately at the die statement
in the subroutine Subtract.</p>

<p>2. The code</p>

<p>if (SvTRUE(ERRSV)) { printf (&quot;Uh oh - %s0,
SvPV_nolen(ERRSV)); POPs; }</p>

<p>is the direct equivalent of this bit of Perl</p>

<p>print &quot;Uh oh - $@0 if $@;</p>

<p>&quot;PL_errgv&quot; is a perl global of type &quot;GV
*&quot; that points to the symbol table entry containing the
error. &quot;ERRSV&quot; therefore refers to the C
equivalent of $@.</p>

<p>3. Note that the stack is popped using &quot;POPs&quot;
in the block where &quot;SvTRUE(ERRSV)&quot; is true. This
is necessary because whenever a call_* function invoked with
G_EVAL|G_SCALAR returns an error, the top of the stack holds
the value undef. Because we want the program to continue
after detecting this error, it is essential that the stack
is tidied up by removing the undef.</p>

<p>Using G_KEEPERR Consider this rather facetious example,
where we have used an XS version of the call_Subtract
example above inside a destructor:</p>

<p>package Foo; sub new { bless {}, $_[0] } sub Subtract {
my($a,$b) = @_; die &quot;death can be fatal&quot; if $a
&lt; $b; $a - $b; } sub DESTROY { call_Subtract(5, 4); } sub
foo { die &quot;foo dies&quot;; }</p>

<p>package main; eval { Foo-&gt;new-&gt;foo }; print
&quot;Saw: $@&quot; if $@; # should be, but isn&rsquo;t</p>

<p>This example will fail to recognize that an error
occurred inside the &quot;eval {}&quot;. Heres why: the
call_Subtract code got executed while perl was cleaning up
temporaries when exiting the eval block, and because
call_Subtract is implemented with call_pv using the G_EVAL
flag, it promptly reset $@. This results in the failure of
the outermost test for $@, and thereby the failure of the
error trap.</p>

<p>Appending the G_KEEPERR flag, so that the call_pv call
in call_Subtract reads:</p>

<p>count = call_pv(&quot;Subtract&quot;,
G_EVAL|G_SCALAR|G_KEEPERR);</p>

<p>will preserve the error and restore reliable error
handling.</p>

<p>Using call_sv In all the previous examples I have
hard-wired the name of the Perl subroutine to be called from
C. Most of the time though, it is more convenient to be able
to specify the name of the Perl subroutine from within the
Perl script.</p>

<p>Consider the Perl code below</p>

<p>sub fred { print &quot;Hello there0; }</p>

<p>CallSubPV(&quot;fred&quot;);</p>

<p>Here is a snippet of XSUB which defines CallSubPV.</p>

<p>void CallSubPV(name) char * name CODE: PUSHMARK(SP);
call_pv(name, G_DISCARD|G_NOARGS);</p>

<p>That is fine as far as it goes. The thing is, the Perl
subroutine can be specified as only a string. For Perl 4
this was adequate, but Perl 5 allows references to
subroutines and anonymous subroutines. This is where call_sv
is useful.</p>

<p>The code below for CallSubSV is identical to CallSubPV
except that the &quot;name&quot; parameter is now defined as
an SV* and we use call_sv instead of call_pv.</p>

<p>void CallSubSV(name) SV * name CODE: PUSHMARK(SP);
call_sv(name, G_DISCARD|G_NOARGS);</p>

<p>Because we are using an SV to call fred the following
can all be used</p>

<p>CallSubSV(&quot;fred&quot;); CallSubSV(fred); $ref =
fred; CallSubSV($ref); CallSubSV( sub { print &quot;Hello
there0 } );</p>

<p>As you can see, call_sv gives you much greater
flexibility in how you can specify the Perl subroutine.</p>

<p>You should note that if it is necessary to store the SV
(&quot;name&quot; in the example above) which corresponds to
the Perl subroutine so that it can be used later in the
program, it not enough just to store a copy of the pointer
to the SV. Say the code above had been like this</p>

<p>static SV * rememberSub;</p>

<p>void SaveSub1(name) SV * name CODE: rememberSub =
name;</p>

<p>void CallSavedSub1() CODE: PUSHMARK(SP);
call_sv(rememberSub, G_DISCARD|G_NOARGS);</p>

<p>The reason this is wrong is that by the time you come to
use the pointer &quot;rememberSub&quot; in
&quot;CallSavedSub1&quot;, it may or may not still refer to
the Perl subroutine that was recorded in
&quot;SaveSub1&quot;. This is particularly true for these
cases</p>

<p>SaveSub1(fred); CallSavedSub1();</p>

<p>SaveSub1( sub { print &quot;Hello there0 } );
CallSavedSub1();</p>

<p>By the time each of the &quot;SaveSub1&quot; statements
above have been executed, the SV*s which corresponded to the
parameters will no longer exist. Expect an error message
from Perl of the form</p>

<p>Can&rsquo;t use an undefined value as a subroutine
reference at ...</p>

<p>for each of the &quot;CallSavedSub1&quot; lines.</p>

<p>Similarly, with this code</p>

<p>$ref = fred; SaveSub1($ref); $ref = 47;
CallSavedSub1();</p>

<p>you can expect one of these messages (which you actually
get is dependent on the version of Perl you are using)</p>

<p>Not a CODE reference at ... Undefined subroutine
&amp;main::47 called ...</p>

<p>The variable $ref may have referred to the subroutine
&quot;fred&quot; whenever the call to &quot;SaveSub1&quot;
was made but by the time &quot;CallSavedSub1&quot; gets
called it now holds the number 47. Because we saved only a
pointer to the original SV in &quot;SaveSub1&quot;, any
changes to $ref will be tracked by the pointer
&quot;rememberSub&quot;. This means that whenever
&quot;CallSavedSub1&quot; gets called, it will attempt to
execute the code which is referenced by the SV*
&quot;rememberSub&quot;. In this case though, it now refers
to the integer 47, so expect Perl to complain loudly.</p>

<p>A similar but more subtle problem is illustrated with
this code</p>

<p>$ref = fred; SaveSub1($ref); $ref = joe;
CallSavedSub1();</p>

<p>This time whenever &quot;CallSavedSub1&quot; get called
it will execute the Perl subroutine &quot;joe&quot;
(assuming it exists) rather than &quot;fred&quot; as was
originally requested in the call to
&quot;SaveSub1&quot;.</p>

<p>To get around these problems it is necessary to take a
full copy of the SV. The code below shows
&quot;SaveSub2&quot; modified to do that</p>

<p>static SV * keepSub = (SV*)NULL;</p>

<p>void SaveSub2(name) SV * name CODE: /* Take a copy of
the callback */ if (keepSub == (SV*)NULL) /* First time, so
create a new SV */ keepSub = newSVsv(name); else /* Been
here before, so overwrite */ SvSetSV(keepSub, name);</p>

<p>void CallSavedSub2() CODE: PUSHMARK(SP);
call_sv(keepSub, G_DISCARD|G_NOARGS);</p>

<p>To avoid creating a new SV every time
&quot;SaveSub2&quot; is called, the function first checks to
see if it has been called before. If not, then space for a
new SV is allocated and the reference to the Perl
subroutine, &quot;name&quot; is copied to the variable
&quot;keepSub&quot; in one operation using
&quot;newSVsv&quot;. Thereafter, whenever
&quot;SaveSub2&quot; is called the existing SV,
&quot;keepSub&quot;, is overwritten with the new value using
&quot;SvSetSV&quot;.</p>

<p>Using call_argv Here is a Perl subroutine which prints
whatever parameters are passed to it.</p>

<p>sub PrintList { my(@list) = @_;</p>

<p>foreach (@list) { print &quot;$_0 } }</p>

<p>and here is an example of call_argv which will call
PrintList.</p>

<p>static char * words[] = {&quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;,
NULL};</p>

<p>static void call_PrintList() { dSP;</p>

<p>call_argv(&quot;PrintList&quot;, G_DISCARD, words);
}</p>

<p>Note that it is not necessary to call
&quot;PUSHMARK&quot; in this instance. This is because
call_argv will do it for you.</p>

<p>Using call_method Consider the following Perl code</p>

<p>{ package Mine;</p>

<p>sub new { my($type) = shift; bless [@_] }</p>

<p>sub Display { my ($self, $index) = @_; print
&quot;$index: $$self[$index]0; }</p>

<p>sub PrintID { my($class) = @_; print &quot;This is Class
$class version 1.00; } }</p>

<p>It implements just a very simple class to manage an
array. Apart from the constructor, &quot;new&quot;, it
declares methods, one static and one virtual. The static
method, &quot;PrintID&quot;, prints out simply the class
name and a version number. The virtual method,
&quot;Display&quot;, prints out a single element of the
array. Here is an all Perl example of using it.</p>

<p>$a = Mine-&gt;new(&rsquo;red&rsquo;,
&rsquo;green&rsquo;, &rsquo;blue&rsquo;); $a-&gt;Display(1);
Mine-&gt;PrintID;</p>

<p>will print</p>

<p>1: green This is Class Mine version 1.0</p>

<p>Calling a Perl method from C is fairly straightforward.
The following things are required</p>

<p>&middot; a reference to the object for a virtual method
or the name of the class for a static method.</p>

<p>&middot; the name of the method.</p>

<p>&middot; any other parameters specific to the
method.</p>

<p>Here is a simple XSUB which illustrates the mechanics of
calling both the &quot;PrintID&quot; and &quot;Display&quot;
methods from C.</p>

<p>void call_Method(ref, method, index) SV * ref char *
method int index CODE: PUSHMARK(SP); XPUSHs(ref);
XPUSHs(sv_2mortal(newSViv(index))); PUTBACK;</p>

<p>call_method(method, G_DISCARD);</p>

<p>void call_PrintID(class, method) char * class char *
method CODE: PUSHMARK(SP); XPUSHs(sv_2mortal(newSVpv(class,
0))); PUTBACK;</p>

<p>call_method(method, G_DISCARD);</p>

<p>So the methods &quot;PrintID&quot; and
&quot;Display&quot; can be invoked like this</p>

<p>$a = Mine-&gt;new(&rsquo;red&rsquo;,
&rsquo;green&rsquo;, &rsquo;blue&rsquo;); call_Method($a,
&rsquo;Display&rsquo;, 1); call_PrintID(&rsquo;Mine&rsquo;,
&rsquo;PrintID&rsquo;);</p>

<p>The only thing to note is that in both the static and
virtual methods, the method name is not passed via the
stack--it is used as the first parameter to call_method.</p>

<p>Using GIMME_V Here is a trivial XSUB which prints the
context in which it is currently executing.</p>

<p>void PrintContext() CODE: I32 gimme = GIMME_V; if (gimme
== G_VOID) printf (&quot;Context is Void0); else if (gimme
== G_SCALAR) printf (&quot;Context is Scalar0); else printf
(&quot;Context is Array0);</p>

<p>and here is some Perl to test it</p>

<p>PrintContext; $a = PrintContext; @a = PrintContext;</p>

<p>The output from that will be</p>

<p>Context is Void Context is Scalar Context is Array</p>

<p>Using Perl to dispose of temporaries In the examples
given to date, any temporaries created in the callback
(i.e., parameters passed on the stack to the call_* function
or values returned via the stack) have been freed by one of
these methods</p>

<p>&middot; specifying the G_DISCARD flag with call_*.</p>

<p>&middot; explicitly disposed of using the
&quot;ENTER&quot;/&quot;SAVETMPS&quot; -
&quot;FREETMPS&quot;/&quot;LEAVE&quot; pairing.</p>

<p>There is another method which can be used, namely
letting Perl do it for you automatically whenever it regains
control after the callback has terminated. This is done by
simply not using the</p>

<p>ENTER; SAVETMPS; ... FREETMPS; LEAVE;</p>

<p>sequence in the callback (and not, of course, specifying
the G_DISCARD flag).</p>

<p>If you are going to use this method you have to be aware
of a possible memory leak which can arise under very
specific circumstances. To explain these circumstances you
need to know a bit about the flow of control between Perl
and the callback routine.</p>

<p>The examples given at the start of the document (an
error handler and an event driven program) are typical of
the two main sorts of flow control that you are likely to
encounter with callbacks. There is a very important
distinction between them, so pay attention.</p>

<p>In the first example, an error handler, the flow of
control could be as follows. You have created an interface
to an external library. Control can reach the external
library like this</p>

<p>perl --&gt; XSUB --&gt; external library</p>

<p>Whilst control is in the library, an error condition
occurs. You have previously set up a Perl callback to handle
this situation, so it will get executed. Once the callback
has finished, control will drop back to Perl again. Here is
what the flow of control will be like in that situation</p>

<p>perl --&gt; XSUB --&gt; external library ... error
occurs ... external library --&gt; call_* --&gt; perl | perl
&lt;-- XSUB &lt;-- external library &lt;-- call_*
&lt;----+</p>

<p>After processing of the error using call_* is completed,
control reverts back to Perl more or less immediately.</p>

<p>In the diagram, the further right you go the more deeply
nested the scope is. It is only when control is back with
perl on the extreme left of the diagram that you will have
dropped back to the enclosing scope and any temporaries you
have left hanging around will be freed.</p>

<p>In the second example, an event driven program, the flow
of control will be more like this</p>

<p>perl --&gt; XSUB --&gt; event handler ... event handler
--&gt; call_* --&gt; perl | event handler &lt;-- call_*
&lt;----+ ... event handler --&gt; call_* --&gt; perl |
event handler &lt;-- call_* &lt;----+ ... event handler
--&gt; call_* --&gt; perl | event handler &lt;-- call_*
&lt;----+</p>

<p>In this case the flow of control can consist of only the
repeated sequence</p>

<p>event handler --&gt; call_* --&gt; perl</p>

<p>for practically the complete duration of the program.
This means that control may never drop back to the
surrounding scope in Perl at the extreme left.</p>

<p>So what is the big problem? Well, if you are expecting
Perl to tidy up those temporaries for you, you might be in
for a long wait. For Perl to dispose of your temporaries,
control must drop back to the enclosing scope at some stage.
In the event driven scenario that may never happen. This
means that as time goes on, your program will create more
and more temporaries, none of which will ever be freed. As
each of these temporaries consumes some memory your program
will eventually consume all the available memory in your
system--kapow!</p>

<p>So here is the bottom line--if you are sure that control
will revert back to the enclosing Perl scope fairly quickly
after the end of your callback, then it isn t absolutely
necessary to dispose explicitly of any temporaries you may
have created. Mind you, if you are at all uncertain about
what to do, it doesnt do any harm to tidy up anyway.</p>

<p>Strategies for storing Callback Context Information
Potentially one of the trickiest problems to overcome when
designing a callback interface can be figuring out how to
store the mapping between the C callback function and the
Perl equivalent.</p>

<p>To help understand why this can be a real problem first
consider how a callback is set up in an all C environment.
Typically a C API will provide a function to register a
callback. This will expect a pointer to a function as one of
its parameters. Below is a call to a hypothetical function
&quot;register_fatal&quot; which registers the C function to
get called when a fatal error occurs.</p>

<p>register_fatal(cb1);</p>

<p>The single parameter &quot;cb1&quot; is a pointer to a
function, so you must have defined &quot;cb1&quot; in your
code, say something like this</p>

<p>static void cb1() { printf (&quot;Fatal Error0);
exit(1); }</p>

<p>Now change that to call a Perl subroutine instead</p>

<p>static SV * callback = (SV*)NULL;</p>

<p>static void cb1() { dSP;</p>

<p>PUSHMARK(SP);</p>

<p>/* Call the Perl sub to process the callback */
call_sv(callback, G_DISCARD); }</p>

<p>void register_fatal(fn) SV * fn CODE: /* Remember the
Perl sub */ if (callback == (SV*)NULL) callback =
newSVsv(fn); else SvSetSV(callback, fn);</p>

<p>/* register the callback with the external library */
register_fatal(cb1);</p>

<p>where the Perl equivalent of &quot;register_fatal&quot;
and the callback it registers, &quot;pcb1&quot;, might look
like this</p>

<p># Register the sub pcb1 register_fatal(pcb1);</p>

<p>sub pcb1 { die &quot;I&rsquo;m dying...0; }</p>

<p>The mapping between the C callback and the Perl
equivalent is stored in the global variable
&quot;callback&quot;.</p>

<p>This will be adequate if you ever need to have only one
callback registered at any time. An example could be an
error handler like the code sketched out above. Remember
though, repeated calls to &quot;register_fatal&quot; will
replace the previously registered callback function with the
new one.</p>

<p>Say for example you want to interface to a library which
allows asynchronous file i/o. In this case you may be able
to register a callback whenever a read operation has
completed. To be of any use we want to be able to call
separate Perl subroutines for each file that is opened. As
it stands, the error handler example above would not be
adequate as it allows only a single callback to be defined
at any time. What we require is a means of storing the
mapping between the opened file and the Perl subroutine we
want to be called for that file.</p>

<p>Say the i/o library has a function
&quot;asynch_read&quot; which associates a C function
&quot;ProcessRead&quot; with a file handle
&quot;fh&quot;--this assumes that it has also provided some
routine to open the file and so obtain the file handle.</p>

<p>asynch_read(fh, ProcessRead)</p>

<p>This may expect the C ProcessRead function of this
form</p>

<p>void ProcessRead(fh, buffer) int fh; char * buffer; {
... }</p>

<p>To provide a Perl interface to this library we need to
be able to map between the &quot;fh&quot; parameter and the
Perl subroutine we want called. A hash is a convenient
mechanism for storing this mapping. The code below shows a
possible implementation</p>

<p>static HV * Mapping = (HV*)NULL;</p>

<p>void asynch_read(fh, callback) int fh SV * callback
CODE: /* If the hash doesn&rsquo;t already exist, create it
*/ if (Mapping == (HV*)NULL) Mapping = newHV();</p>

<p>/* Save the fh -&gt; callback mapping */
hv_store(Mapping, (char*)&amp;fh, sizeof(fh),
newSVsv(callback), 0);</p>

<p>/* Register with the C Library */ asynch_read(fh,
asynch_read_if);</p>

<p>and &quot;asynch_read_if&quot; could look like this</p>

<p>static void asynch_read_if(fh, buffer) int fh; char *
buffer; { dSP; SV ** sv;</p>

<p>/* Get the callback associated with fh */ sv =
hv_fetch(Mapping, (char*)&amp;fh , sizeof(fh), FALSE); if
(sv == (SV**)NULL) croak(&quot;Internal error...0);</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(fh)));
XPUSHs(sv_2mortal(newSVpv(buffer, 0))); PUTBACK;</p>

<p>/* Call the Perl sub */ call_sv(*sv, G_DISCARD); }</p>

<p>For completeness, here is &quot;asynch_close&quot;. This
shows how to remove the entry from the hash
&quot;Mapping&quot;.</p>

<p>void asynch_close(fh) int fh CODE: /* Remove the entry
from the hash */ (void) hv_delete(Mapping, (char*)&amp;fh,
sizeof(fh), G_DISCARD);</p>

<p>/* Now call the real asynch_close */
asynch_close(fh);</p>

<p>So the Perl interface would look like this</p>

<p>sub callback1 { my($handle, $buffer) = @_; }</p>

<p># Register the Perl callback asynch_read($fh,
callback1);</p>

<p>asynch_close($fh);</p>

<p>The mapping between the C callback and Perl is stored in
the global hash &quot;Mapping&quot; this time. Using a hash
has the distinct advantage that it allows an unlimited
number of callbacks to be registered.</p>

<p>What if the interface provided by the C callback doesnt
contain a parameter which allows the file handle to Perl
subroutine mapping? Say in the asynchronous i/o package, the
callback function gets passed only the &quot;buffer&quot;
parameter like this</p>

<p>void ProcessRead(buffer) char * buffer; { ... }</p>

<p>Without the file handle there is no straightforward way
to map from the C callback to the Perl subroutine.</p>

<p>In this case a possible way around this problem is to
predefine a series of C functions to act as the interface to
Perl, thus</p>

<p>#define MAX_CB 3 #define NULL_HANDLE -1 typedef void
(*FnMap)();</p>

<p>struct MapStruct { FnMap Function; SV * PerlSub; int
Handle; };</p>

<p>static void fn1(); static void fn2(); static void
fn3();</p>

<p>static struct MapStruct Map [MAX_CB] = { { fn1, NULL,
NULL_HANDLE }, { fn2, NULL, NULL_HANDLE }, { fn3, NULL,
NULL_HANDLE } };</p>

<p>static void Pcb(index, buffer) int index; char * buffer;
{ dSP;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
PUTBACK;</p>

<p>/* Call the Perl sub */ call_sv(Map[index].PerlSub,
G_DISCARD); }</p>

<p>static void fn1(buffer) char * buffer; { Pcb(0, buffer);
}</p>

<p>static void fn2(buffer) char * buffer; { Pcb(1, buffer);
}</p>

<p>static void fn3(buffer) char * buffer; { Pcb(2, buffer);
}</p>

<p>void array_asynch_read(fh, callback) int fh SV *
callback CODE: int index; int null_index = MAX_CB;</p>

<p>/* Find the same handle or an empty entry */ for (index
= 0; index &lt; MAX_CB; ++index) { if (Map[index].Handle ==
fh) break;</p>

<p>if (Map[index].Handle == NULL_HANDLE) null_index =
index; }</p>

<p>if (index == MAX_CB &amp;&amp; null_index == MAX_CB)
croak (&quot;Too many callback functions registered0);</p>

<p>if (index == MAX_CB) index = null_index;</p>

<p>/* Save the file handle */ Map[index].Handle = fh;</p>

<p>/* Remember the Perl sub */ if (Map[index].PerlSub ==
(SV*)NULL) Map[index].PerlSub = newSVsv(callback); else
SvSetSV(Map[index].PerlSub, callback);</p>

<p>asynch_read(fh, Map[index].Function);</p>

<p>void array_asynch_close(fh) int fh CODE: int index;</p>

<p>/* Find the file handle */ for (index = 0; index &lt;
MAX_CB; ++ index) if (Map[index].Handle == fh) break;</p>

<p>if (index == MAX_CB) croak (&quot;could not close fh
%d0, fh);</p>

<p>Map[index].Handle = NULL_HANDLE;
SvREFCNT_dec(Map[index].PerlSub); Map[index].PerlSub =
(SV*)NULL;</p>

<p>asynch_close(fh);</p>

<p>In this case the functions &quot;fn1&quot;,
&quot;fn2&quot;, and &quot;fn3&quot; are used to remember
the Perl subroutine to be called. Each of the functions
holds a separate hard-wired index which is used in the
function &quot;Pcb&quot; to access the &quot;Map&quot; array
and actually call the Perl subroutine.</p>

<p>There are some obvious disadvantages with this
technique.</p>

<p>Firstly, the code is considerably more complex than with
the previous example.</p>

<p>Secondly, there is a hard-wired limit (in this case 3)
to the number of callbacks that can exist simultaneously.
The only way to increase the limit is by modifying the code
to add more functions and then recompiling. None the less,
as long as the number of functions is chosen with some care,
it is still a workable solution and in some cases is the
only one available.</p>

<p>To summarize, here are a number of possible methods for
you to consider for storing the mapping between C and the
Perl callback</p>

<p>1. Ignore the problem - Allow only 1 callback For a lot
of situations, like interfacing to an error handler, this
may be a perfectly adequate solution.</p>

<p>2. Create a sequence of callbacks - hard wired limit If
it is impossible to tell from the parameters passed back
from the C callback what the context is, then you may need
to create a sequence of C callback interface functions, and
store pointers to each in an array.</p>

<p>3. Use a parameter to map to the Perl callback A hash is
an ideal mechanism to store the mapping between C and
Perl.</p>

<p>Alternate Stack Manipulation Although I have made use of
only the &quot;POP*&quot; macros to access values returned
from Perl subroutines, it is also possible to bypass these
macros and read the stack using the &quot;ST&quot; macro
(See perlxs for a full description of the &quot;ST&quot;
macro).</p>

<p>Most of the time the &quot;POP*&quot; macros should be
adequate, the main problem with them is that they force you
to process the returned values in sequence. This may not be
the most suitable way to process the values in some cases.
What we want is to be able to access the stack in a random
order. The &quot;ST&quot; macro as used when coding an XSUB
is ideal for this purpose.</p>

<p>The code below is the example given in the section
Returning a list of values recoded to use &quot;ST&quot;
instead of &quot;POP*&quot;.</p>

<p>static void call_AddSubtract2(a, b) int a; int b; { dSP;
I32 ax; int count;</p>

<p>ENTER; SAVETMPS;</p>

<p>PUSHMARK(SP); XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b))); PUTBACK;</p>

<p>count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);</p>

<p>SPAGAIN; SP -= count; ax = (SP - PL_stack_base) + 1;</p>

<p>if (count != 2) croak(&quot;Big trouble0);</p>

<p>printf (&quot;%d + %d = %d0, a, b, SvIV(ST(0))); printf
(&quot;%d - %d = %d0, a, b, SvIV(ST(1)));</p>

<p>PUTBACK; FREETMPS; LEAVE; }</p>

<p>Notes</p>

<p>1. Notice that it was necessary to define the variable
&quot;ax&quot;. This is because the &quot;ST&quot; macro
expects it to exist. If we were in an XSUB it would not be
necessary to define &quot;ax&quot; as it is already defined
for you.</p>

<p>2. The code</p>

<p>SPAGAIN; SP -= count; ax = (SP - PL_stack_base) + 1;</p>

<p>sets the stack up so that we can use the &quot;ST&quot;
macro.</p>

<p>3. Unlike the original coding of this example, the
returned values are not accessed in reverse order. So ST(0)
refers to the first value returned by the Perl subroutine
and &quot;ST(count-1)&quot; refers to the last.</p>

<p>Creating and calling an anonymous subroutine in C As
weve already shown, &quot;call_sv&quot; can be used to
invoke an anonymous subroutine. However, our example showed
a Perl script invoking an XSUB to perform this operation.
Lets see how it can be done inside our C code:</p>

<p>...</p>

<p>SV *cvrv = eval_pv(&quot;sub { print &rsquo;You will not
find me cluttering any namespace!&rsquo; }&quot;, TRUE);</p>

<p>...</p>

<p>call_sv(cvrv, G_VOID|G_NOARGS);</p>

<p>&quot;eval_pv&quot; is used to compile the anonymous
subroutine, which will be the return value as well (read
more about &quot;eval_pv&quot; in &quot;eval_pv&quot; in
perlapi). Once this code reference is in hand, it can be
mixed in with all the previous examples weve shown.</p>

<p>LIGHTWEIGHT CALLBACKS Sometimes you need to invoke the
same subroutine repeatedly. This usually happens with a
function that acts on a list of values, such as Perl s
built-in sort(). You can pass a comparison function to
sort(), which will then be invoked for every pair of values
that needs to be compared. The first() and reduce()
functions from List::Util follow a similar pattern.</p>

<p>In this case it is possible to speed up the routine
(often quite substantially) by using the lightweight
callback API. The idea is that the calling context only
needs to be created and destroyed once, and the sub can be
called arbitrarily many times in between.</p>

<p>It is usual to pass parameters using global variables --
typically $_ for one parameter, or $a and $b for two
parameters -- rather than via @_. (It is possible to use the
@_ mechanism if you know what youre doing, though there is
as yet no supported API for it. Its also inherently
slower.)</p>

<p>The pattern of macro calls is like this:</p>

<p>dMULTICALL; /* Declare local variables */ I32 gimme =
G_SCALAR; /* context of the call: G_SCALAR, * G_LIST, or
G_VOID */</p>

<p>PUSH_MULTICALL(cv); /* Set up the context for calling
cv, and set local vars appropriately */</p>

<p>/* loop */ { /* set the value(s) af your parameter
variables */ MULTICALL; /* Make the actual call */ } /* end
of loop */</p>

<p>POP_MULTICALL; /* Tear down the calling context */</p>

<p>For some concrete examples, see the implementation of
the first() and reduce() functions of List::Util 1.18. There
you will also find a header file that emulates the multicall
API on older versions of perl.</p>

<p>SEE ALSO perlxs, perlguts, perlembed</p>

<p>AUTHOR Paul Marquess</p>

<p>Special thanks to the following people who assisted in
the creation of the document.</p>

<p>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem,
Gurusamy Sarathy and Larry Wall.</p>

<p>DATE Version 1.3, 14th Apr 1997</p>

<p>perl v5.10.1 2009-04-12 PERLCALL(1)</p>
<hr>
</body>
</html>
