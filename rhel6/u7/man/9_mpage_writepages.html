<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:23:10 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MPAGE_WRITEPAGES(9) The Linux VFS
MPAGE_WRITEPAGES(9)</p>

<p>NAME mpage_writepages - walk the list of dirty pages of
the given address space &amp; writepage all of them</p>

<p>SYNOPSIS int mpage_writepages(struct address_space *
mapping, struct writeback_control * wbc, get_block_t
get_block);</p>

<p>ARGUMENTS mapping address space structure to write</p>

<p>wbc subtract the number of written pages from
*wbc-&gt;nr_to_write</p>

<p>get_block the filesystem&acute;s block mapper function.
If this is NULL then use a_ops-&gt;writepage. Otherwise, go
direct-to-BIO.</p>

<p>DESCRIPTION This is a library function, which implements
the writepages address_space_operation.</p>

<p>If a page is already under I/O, generic_writepages skips
it, even if it&acute;s dirty. This is desirable behaviour
for memory-cleaning writeback, but it is INCORRECT for
data-integrity system calls such as fsync. fsync and msync
need to guarantee that all the data which was dirty at the
time the call was made get new I/O started against them. If
wbc-&gt;sync_mode is WB_SYNC_ALL then we were called for
data integrity and we must wait for existing IO to
complete.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
MPAGE_WRITEPAGES(9)</p>
<hr>
</body>
</html>
