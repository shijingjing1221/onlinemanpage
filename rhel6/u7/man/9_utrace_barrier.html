<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:43:49 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>UTRACE_BARRIER(9) utrace core API UTRACE_BARRIER(9)</p>

<p>NAME utrace_barrier - synchronize with simultaneous
tracing callbacks</p>

<p>SYNOPSIS int utrace_barrier(struct task_struct * target,
struct utrace_engine * engine);</p>

<p>ARGUMENTS target thread to affect</p>

<p>engine engine to affect (can be detached)</p>

<p>DESCRIPTION This blocks while target might be in the
midst of making a callback to engine. It can be interrupted
by signals and will return -ERESTARTSYS. A return value of
zero means no callback from target to engine was in
progress. Any effect of its return value (such as
UTRACE_STOP) has already been applied to engine.</p>

<p>It&acute;s not necessary to keep the target pointer
alive for this call. It&acute;s only necessary to hold a ref
on engine. This will return safely even if target has been
reaped and has no task refs.</p>

<p>A successful return from utrace_barrier guarantees its
ordering with respect to utrace_set_events and
utrace_control calls. If target was not properly stopped,
event callbacks just disabled might still be in progress;
utrace_barrier waits until there is no chance an unwanted
callback can be in progress.</p>

<p>Kernel Hackers Manual 2.6. July 2015
UTRACE_BARRIER(9)</p>
<hr>
</body>
</html>
