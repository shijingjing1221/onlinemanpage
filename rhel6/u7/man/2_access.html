<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:03:48 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ACCESS(2) Linux Programmer s Manual ACCESS(2)</p>

<p>NAME access - check real users permissions for a
file</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int access(const char *pathname, int mode);</p>

<p>DESCRIPTION access() checks whether the calling process
can access the file path- name. If pathname is a symbolic
link, it is dereferenced.</p>

<p>The mode specifies the accessibility check(s) to be
performed, and is either the value F_OK, or a mask
consisting of the bitwise OR of one or more of R_OK, W_OK,
and X_OK. F_OK tests for the existence of the file. R_OK,
W_OK, and X_OK test whether the file exists and grants read,
write, and execute permissions, respectively.</p>

<p>The check is done using the calling processs real UID
and GID, rather than the effective IDs as is done when
actually attempting an operation (e.g., open(2)) on the
file. This allows set-user-ID programs to eas- ily determine
the invoking users authority.</p>

<p>If the calling process is privileged (i.e., its real UID
is zero), then an X_OK check is successful for a regular
file if execute permission is enabled for any of the file
owner, group, or other.</p>

<p>RETURN VALUE On success (all requested permissions
granted), zero is returned. On error (at least one bit in
mode asked for a permission that is denied, or some other
error occurred), -1 is returned, and errno is set appro-
priately.</p>

<p>ERRORS access() shall fail if:</p>

<p>EACCES The requested access would be denied to the file,
or search per- mission is denied for one of the directories
in the path prefix of pathname. (See also
path_resolution(7).)</p>

<p>ELOOP Too many symbolic links were encountered in
resolving pathname.</p>

<p>ENAMETOOLONG pathname is too long.</p>

<p>ENOENT A component of pathname does not exist or is a
dangling symbolic link.</p>

<p>ENOTDIR A component used as a directory in pathname is
not, in fact, a directory.</p>

<p>EROFS Write permission was requested for a file on a
read-only file system.</p>

<p>access() may fail if:</p>

<p>EFAULT pathname points outside your accessible address
space.</p>

<p>EINVAL mode was incorrectly specified.</p>

<p>EIO An I/O error occurred.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ETXTBSY Write access was requested to an executable
which is being exe- cuted.</p>

<p>CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001.</p>

<p>NOTES Warning: Using access() to check if a user is
authorized to, for exam- ple, open a file before actually
doing so using open(2) creates a secu- rity hole, because
the user might exploit the short time interval between
checking and opening the file to manipulate it. For this
rea- son, the use of this system call should be avoided.</p>

<p>access() returns an error if any of the access types in
mode is denied, even if some of the other access types in
mode are permitted.</p>

<p>If the calling process has appropriate privileges (i.e.,
is superuser), POSIX.1-2001 permits implementation to
indicate success for an X_OK check even if none of the
execute file permission bits are set. Linux does not do
this.</p>

<p>A file is only accessible if the permissions on each of
the directories in the path prefix of pathname grant search
(i.e., execute) access. If any directory is inaccessible,
then the access() call will fail, regardless of the
permissions on the file itself.</p>

<p>Only access bits are checked, not the file type or
contents. There- fore, if a directory is found to be
writable, it probably means that files can be created in the
directory, and not that the directory can be written as a
file. Similarly, a DOS file may be found to be &quot;exe-
cutable,&quot; but the execve(2) call will still fail.</p>

<p>access() may not work correctly on NFS file systems with
UID mapping enabled, because UID mapping is done on the
server and hidden from the client, which checks
permissions.</p>

<p>BUGS In kernel 2.4 (and earlier) there is some
strangeness in the handling of X_OK tests for superuser. If
all categories of execute permission are disabled for a
non-directory file, then the only access() test that returns
-1 is when mode is specified as just X_OK; if R_OK or W_OK
is also specified in mode, then access() returns 0 for such
files. Early 2.6 kernels (up to and including 2.6.3) also
behaved in the same way as kernel 2.4.</p>

<p>In kernels before 2.6.20, access() ignored the effect of
the MS_NOEXEC flag if it was used to mount(2) the underlying
file system. Since ker- nel 2.6.20, access() honors this
flag.</p>

<p>SEE ALSO chmod(2), chown(2), faccessat(2), open(2),
setgid(2), setuid(2), stat(2), euidaccess(3),
credentials(7), path_resolution(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2007-07-10 ACCESS(2)</p>
<hr>
</body>
</html>
