<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:37:24 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SYSCTL(2) Linux Programmer s Manual SYSCTL(2)</p>

<p>NAME sysctl - read/write system parameters</p>

<p>SYNOPSIS #include &lt;unistd.h&gt; #include
&lt;linux/sysctl.h&gt;</p>

<p>int _sysctl(struct __sysctl_args *args);</p>

<p>DESCRIPTION Do not use this system call! See NOTES.</p>

<p>The _sysctl() call reads and/or writes kernel
parameters. For example, the hostname, or the maximum number
of open files. The argument has the form</p>

<p>struct __sysctl_args { int *name; /* integer vector
describing variable */ int nlen; /* length of this vector */
void *oldval; /* 0 or address where to store old value */
size_t *oldlenp; /* available room for old value,
overwritten by actual size of old value */ void *newval; /*
0 or address of new value */ size_t newlen; /* size of new
value */ };</p>

<p>This call does a search in a tree structure, possibly
resembling a directory tree under /proc/sys, and if the
requested item is found calls some appropriate routine to
read or modify the value.</p>

<p>RETURN VALUE Upon successful completion, _sysctl()
returns 0. Otherwise, a value of -1 is returned and errno is
set to indicate the error.</p>

<p>ERRORS EFAULT The invocation asked for the previous
value by setting oldval non-NULL, but allowed zero room in
oldlenp.</p>

<p>ENOTDIR name was not found.</p>

<p>EPERM No search permission for one of the encountered
&quot;directories&quot;, or no read permission where oldval
was non-zero, or no write permission where newval was
non-zero.</p>

<p>CONFORMING TO This call is Linux-specific, and should
not be used in programs intended to be portable. A sysctl()
call has been present in Linux since version 1.3.57. It
originated in 4.4BSD. Only Linux has the /proc/sys mirror,
and the object naming schemes differ between Linux and
4.4BSD, but the declaration of the sysctl() function is the
same in both.</p>

<p>NOTES Glibc does not provide a wrapper for this system
call; call it using syscall(2).</p>

<p>Or rather... dont call it: use of this system call has
long been dis- couraged, and it is so unloved that it is
likely to disappear in a future kernel version. Remove it
from your programs now; use the /proc/sys interface
instead.</p>

<p>BUGS The object names vary between kernel versions,
making this system call worthless for applications.</p>

<p>Not all available objects are properly documented.</p>

<p>It is not yet possible to change operating system by
writing to /proc/sys/kernel/ostype.</p>

<p>EXAMPLE #define _GNU_SOURCE #include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt; #include &lt;string.h&gt;
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include
&lt;linux/sysctl.h&gt;</p>

<p>int _sysctl(struct __sysctl_args *args );</p>

<p>#define OSNAMESZ 100</p>

<p>int main(void) { struct __sysctl_args args; char
osname[OSNAMESZ]; size_t osnamelth; int name[] = { CTL_KERN,
KERN_OSTYPE };</p>

<p>memset(&amp;args, 0, sizeof(struct __sysctl_args));
args.name = name; args.nlen = sizeof(name)/sizeof(name[0]);
args.oldval = osname; args.oldlenp = &amp;osnamelth;</p>

<p>osnamelth = sizeof(osname);</p>

<p>if (syscall(SYS__sysctl, &amp;args) == -1) {
perror(&quot;_sysctl&quot;); exit(EXIT_FAILURE); }
printf(&quot;This machine is running %*s0, osnamelth,
osname); exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO proc(5)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-11-20 SYSCTL(2)</p>
<hr>
</body>
</html>
