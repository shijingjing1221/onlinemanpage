<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLREAPI(1) Perl Programmers Reference Guide
PERLREAPI(1)</p>

<p>NAME perlreapi - perl regular expression plugin
interface</p>

<p>DESCRIPTION As of Perl 5.9.5 there is a new interface
for plugging and using other regular expression engines than
the default one.</p>

<p>Each engine is supposed to provide access to a constant
structure of the following format:</p>

<p>typedef struct regexp_engine { REGEXP* (*comp) (pTHX_
const SV * const pattern, const U32 flags); I32 (*exec)
(pTHX_ REGEXP * const rx, char* stringarg, char* strend,
char* strbeg, I32 minend, SV* screamer, void* data, U32
flags); char* (*intuit) (pTHX_ REGEXP * const rx, SV *sv,
char *strpos, char *strend, U32 flags, struct
re_scream_pos_data_s *data); SV* (*checkstr) (pTHX_ REGEXP *
const rx); void (*free) (pTHX_ REGEXP * const rx); void
(*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32
paren, SV * const sv); void (*numbered_buff_STORE) (pTHX_
REGEXP * const rx, const I32 paren, SV const * const value);
I32 (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const
SV * const sv, const I32 paren); SV* (*named_buff) (pTHX_
REGEXP * const rx, SV * const key, SV * const value, U32
flags); SV* (*named_buff_iter) (pTHX_ REGEXP * const rx,
const SV * const lastkey, const U32 flags); SV*
(*qr_package)(pTHX_ REGEXP * const rx); #ifdef USE_ITHREADS
void* (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS
*param); #endif</p>

<p>When a regexp is compiled, its &quot;engine&quot; field
is then set to point at the appropriate structure, so that
when it needs to be used Perl can find the right routines to
do so.</p>

<p>In order to install a new regexp handler, $^H{regcomp}
is set to an integer which (when casted appropriately)
resolves to one of these structures. When compiling, the
&quot;comp&quot; method is executed, and the resulting
regexp structures engine field is expected to point back at
the same structure.</p>

<p>The pTHX_ symbol in the definition is a macro used by
perl under threading to provide an extra argument to the
routine holding a pointer back to the interpreter that is
executing the regexp. So under threading all routines get an
extra argument.</p>

<p>Callbacks comp REGEXP* comp(pTHX_ const SV * const
pattern, const U32 flags);</p>

<p>Compile the pattern stored in &quot;pattern&quot; using
the given &quot;flags&quot; and return a pointer to a
prepared &quot;REGEXP&quot; structure that can perform the
match. See &quot;The REGEXP structure&quot; below for an
explanation of the individual fields in the REGEXP
struct.</p>

<p>The &quot;pattern&quot; parameter is the scalar that was
used as the pattern. previous versions of perl would pass
two &quot;char*&quot; indicating the start and end of the
stringified pattern, the following snippet can be used to
get the old parameters:</p>

<p>STRLEN plen; char* exp = SvPV(pattern, plen); char* xend
= exp + plen;</p>

<p>Since any scalar can be passed as a pattern its possible
to implement an engine that does something with an array
(&quot;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&quot;) or with
the non-stringified form of a compiled regular expression
(&quot;&quot;ook&quot; =~ qr/eek/&quot;). perl s own engine
will always stringify everything using the snippet above but
that doesnt mean other engines have to.</p>

<p>The &quot;flags&quot; parameter is a bitfield which
indicates which of the &quot;msixp&quot; flags the regex was
compiled with. It also contains additional info such as
whether &quot;use locale&quot; is in effect.</p>

<p>The &quot;eogc&quot; flags are stripped out before being
passed to the comp routine. The regex engine does not need
to know whether any of these are set as those flags should
only affect what perl does with the pattern and its match
variables, not how it gets compiled and executed.</p>

<p>By the time the comp callback is called, some of these
flags have already had effect (noted below where
applicable). However most of their effect occurs after the
comp callback has run in routines that read the
&quot;rx-&gt;extflags&quot; field which it populates.</p>

<p>In general the flags should be preserved in
&quot;rx-&gt;extflags&quot; after compilation, although the
regex engine might want to add or delete some of them to
invoke or disable some special behavior in perl. The flags
along with any special behavior they cause are documented
below:</p>

<p>The pattern modifiers:</p>

<p>&quot;/m&quot; - RXf_PMf_MULTILINE If this is in
&quot;rx-&gt;extflags&quot; it will be passed to
&quot;Perl_fbm_instr&quot; by &quot;pp_split&quot; which
will treat the subject string as a multi-line string.</p>

<p>&quot;/s&quot; - RXf_PMf_SINGLELINE &quot;/i&quot; -
RXf_PMf_FOLD &quot;/x&quot; - RXf_PMf_EXTENDED If present on
a regex &quot;#&quot; comments will be handled differently
by the tokenizer in some cases.</p>

<p>TODO: Document those cases.</p>

<p>&quot;/p&quot; - RXf_PMf_KEEPCOPY</p>

<p>Additional flags:</p>

<p>RXf_PMf_LOCALE Set if &quot;use locale&quot; is in
effect. If present in &quot;rx-&gt;extflags&quot;
&quot;split&quot; will use the locale dependent definition
of whitespace under when RXf_SKIPWHITE or RXf_WHITE are in
effect. Under ASCII whitespace is defined as per isSPACE,
and by the internal macros &quot;is_utf8_space&quot; under
UTF-8 and &quot;isSPACE_LC&quot; under &quot;use
locale&quot;.</p>

<p>RXf_UTF8 Set if the pattern is SvUTF8(), set by
Perl_pmruntime.</p>

<p>A regex engine may want to set or disable this flag
during compilation. The perl engine for instance may upgrade
non-UTF-8 strings to UTF-8 if the pattern includes
constructs such as &quot;.}&quot; that can only match
Unicode values.</p>

<p>RXf_SPLIT If &quot;split&quot; is invoked as &quot;split
&rsquo; &rsquo;&quot; or with no arguments (which really
means &quot;split(&rsquo; &rsquo;, $_)&quot;, see split),
perl will set this flag. The regex engine can then check for
it and set the SKIPWHITE and WHITE extflags. To do this the
perl engine does:</p>

<p>if (flags &amp; RXf_SPLIT &amp;&amp; r-&gt;prelen == 1
&amp;&amp; r-&gt;precomp[0] == &rsquo; &rsquo;)
r-&gt;extflags |= (RXf_SKIPWHITE|RXf_WHITE);</p>

<p>These flags can be set during compilation to enable
optimizations in the &quot;split&quot; operator.</p>

<p>RXf_SKIPWHITE If the flag is present in
&quot;rx-&gt;extflags&quot; &quot;split&quot; will delete
whitespace from the start of the subject string before its
operated on. What is considered whitespace depends on
whether the subject is a UTF-8 string and whether the
&quot;RXf_PMf_LOCALE&quot; flag is set.</p>

<p>If RXf_WHITE is set in addition to this flag
&quot;split&quot; will behave like &quot;split &quot;
&quot;&quot; under the perl engine.</p>

<p>RXf_START_ONLY Tells the split operator to split the
target string on newlines (&quot;0) without invoking the
regex engine.</p>

<p>Perls engine sets this if the pattern is &quot;/^/&quot;
(&quot;plen == 1 &amp;&amp; *exp == &rsquo;^&rsquo;&quot;),
even under &quot;/^/s&quot;, see split. Of course a
different regex engine might want to use the same
optimizations with a different syntax.</p>

<p>RXf_WHITE Tells the split operator to split the target
string on whitespace without invoking the regex engine. The
definition of whitespace varies depending on whether the
target string is a UTF-8 string and on whether
RXf_PMf_LOCALE is set.</p>

<p>Perls engine sets this flag if the pattern is &quot;
RXf_NULL Tells the split operator to split the target string
on characters. The definition of character varies depending
on whether the target string is a UTF-8 string.</p>

<p>Perls engine sets this flag on empty patterns, this
optimization makes &quot;split //&quot; much faster than it
would otherwise be. Its even faster than
&quot;unpack&quot;.</p>

<p>exec I32 exec(pTHX_ REGEXP * const rx, char *stringarg,
char* strend, char* strbeg, I32 minend, SV* screamer, void*
data, U32 flags);</p>

<p>Execute a regexp.</p>

<p>intuit char* intuit(pTHX_ REGEXP * const rx, SV *sv,
char *strpos, char *strend, const U32 flags, struct
re_scream_pos_data_s *data);</p>

<p>Find the start position where a regex match should be
attempted, or possibly whether the regex engine should not
be run because the pattern can t match. This is called as
appropriate by the core depending on the values of the
extflags member of the regexp structure.</p>

<p>checkstr SV* checkstr(pTHX_ REGEXP * const rx);</p>

<p>Return a SV containing a string that must appear in the
pattern. Used by &quot;split&quot; for optimising
matches.</p>

<p>free void free(pTHX_ REGEXP * const rx);</p>

<p>Called by perl when it is freeing a regexp pattern so
that the engine can release any resources pointed to by the
&quot;pprivate&quot; member of the regexp structure. This is
only responsible for freeing private data; perl will handle
releasing anything else contained in the regexp
structure.</p>

<p>Numbered capture callbacks Called to get/set the value
of &quot;$&lsquo;&quot;, &quot;$&rsquo;&quot;, $&amp; and
their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and
$^{MATCH}, as well as the numbered capture buffers ($1, $2,
...).</p>

<p>The &quot;paren&quot; parameter will be &quot;-2&quot;
for &quot;$&lsquo;&quot;, &quot;-1&quot; for
&quot;$&rsquo;&quot;, 0 for $&amp;, 1 for $1 and so
forth.</p>

<p>The names have been chosen by analogy with Tie::Scalar
methods names with an additional LENGTH callback for
efficiency. However named capture variables are currently
not tied internally but implemented via magic.</p>

<p>numbered_buff_FETCH</p>

<p>void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const
I32 paren, SV * const sv);</p>

<p>Fetch a specified numbered capture. &quot;sv&quot;
should be set to the scalar to return, the scalar is passed
as an argument rather than being returned from the function
because when its called perl already has a scalar to store
the value, creating another one would be redundant. The
scalar can be set with &quot;sv_setsv&quot;,
&quot;sv_setpvn&quot; and friends, see perlapi.</p>

<p>This callback is where perl untaints its own capture
variables under taint mode (see perlsec). See the
&quot;Perl_reg_numbered_buff_fetch&quot; function in
regcomp.c for how to untaint capture variables if thats
something youd like your engine to do as well.</p>

<p>numbered_buff_STORE</p>

<p>void (*numbered_buff_STORE) (pTHX_ REGEXP * const rx,
const I32 paren, SV const * const value);</p>

<p>Set the value of a numbered capture variable.
&quot;value&quot; is the scalar that is to be used as the
new value. Its up to the engine to make sure this is used as
the new value (or reject it).</p>

<p>Example:</p>

<p>if (&quot;ook&quot; =~ /(o*)/) { # &lsquo;paren&rsquo;
will be &lsquo;1&rsquo; and &lsquo;value&rsquo; will be
&lsquo;ee&rsquo; $1 =~ tr/o/e/; }</p>

<p>Perls own engine will croak on any attempt to modify the
capture variables, to do this in another engine use the
following callback (copied from
&quot;Perl_reg_numbered_buff_store&quot;):</p>

<p>void Example_reg_numbered_buff_store(pTHX_ REGEXP *
const rx, const I32 paren, SV const * const value) {
PERL_UNUSED_ARG(rx); PERL_UNUSED_ARG(paren);
PERL_UNUSED_ARG(value);</p>

<p>if (!PL_localizing) Perl_croak(aTHX_ PL_no_modify);
}</p>

<p>Actually perl will not always croak in a statement that
looks like it would modify a numbered capture variable. This
is because the STORE callback will not be called if perl can
determine that it doesnt have to modify the value. This is
exactly how tied variables behave in the same situation:</p>

<p>package CaptureVar; use base
&rsquo;Tie::Scalar&rsquo;;</p>

<p>sub TIESCALAR { bless [] } sub FETCH { undef } sub STORE
{ die &quot;This doesn&rsquo;t get called&quot; }</p>

<p>package main;</p>

<p>tie my $sv =&gt; &quot;CatptureVar&quot;; $sv =~
y/a/b/;</p>

<p>Because $sv is &quot;undef&quot; when the
&quot;y///&quot; operator is applied to it the
transliteration wont actually execute and the program wont
&quot;die&quot;. This is different to how 5.8 and earlier
versions behaved since the capture variables were READONLY
variables then, now theyll just die when assigned to in the
default engine.</p>

<p>numbered_buff_LENGTH</p>

<p>I32 numbered_buff_LENGTH (pTHX_ REGEXP * const rx, const
SV * const sv, const I32 paren);</p>

<p>Get the &quot;length&quot; of a capture variable. Theres
a special callback for this so that perl doesnt have to do a
FETCH and run &quot;length&quot; on the result, since the
length is (in perls case) known from an offset stored in
&quot;rx-&gt;offs&quot; this is much more efficient:</p>

<p>I32 s1 = rx-&gt;offs[paren].start; I32 s2 =
rx-&gt;offs[paren].end; I32 len = t1 - s1;</p>

<p>This is a little bit more complex in the case of UTF-8,
see what &quot;Perl_reg_numbered_buff_length&quot; does with
is_utf8_string_loclen.</p>

<p>Named capture callbacks Called to get/set the value of
&quot;%+&quot; and &quot;%-&quot; as well as by some utility
functions in re.</p>

<p>There are two callbacks, &quot;named_buff&quot; is
called in all the cases the FETCH, STORE, DELETE, CLEAR,
EXISTS and SCALAR Tie::Hash callbacks would be on changes to
&quot;%+&quot; and &quot;%-&quot; and
&quot;named_buff_iter&quot; in the same cases as FIRSTKEY
and NEXTKEY.</p>

<p>The &quot;flags&quot; parameter can be used to determine
which of these operations the callbacks should respond to,
the following flags are currently defined:</p>

<p>Which Tie::Hash operation is being performed from the
Perl level on &quot;%+&quot; or &quot;%+&quot;, if any:</p>

<p>RXapif_FETCH RXapif_STORE RXapif_DELETE RXapif_CLEAR
RXapif_EXISTS RXapif_SCALAR RXapif_FIRSTKEY
RXapif_NEXTKEY</p>

<p>Whether &quot;%+&quot; or &quot;%-&quot; is being
operated on, if any.</p>

<p>RXapif_ONE /* %+ */ RXapif_ALL /* %- */</p>

<p>Whether this is being called as &quot;re::regname&quot;,
&quot;re::regnames&quot; or &quot;re::regnames_count&quot;,
if any. The first two will be combined with
&quot;RXapif_ONE&quot; or &quot;RXapif_ALL&quot;.</p>

<p>RXapif_REGNAME RXapif_REGNAMES RXapif_REGNAMES_COUNT</p>

<p>Internally &quot;%+&quot; and &quot;%-&quot; are
implemented with a real tied interface via
Tie::Hash::NamedCapture. The methods in that package will
call back into these functions. However the usage of
Tie::Hash::NamedCapture for this purpose might change in
future releases. For instance this might be implemented by
magic instead (would need an extension to mgvtbl).</p>

<p>named_buff</p>

<p>SV* (*named_buff) (pTHX_ REGEXP * const rx, SV * const
key, SV * const value, U32 flags);</p>

<p>named_buff_iter</p>

<p>SV* (*named_buff_iter) (pTHX_ REGEXP * const rx, const
SV * const lastkey, const U32 flags);</p>

<p>qr_package SV* qr_package(pTHX_ REGEXP * const rx);</p>

<p>The package the qr// magic object is blessed into (as
seen by &quot;ref qr//&quot;). It is recommended that
engines change this to their package name for identification
regardless of whether they implement methods on the
object.</p>

<p>The package this method returns should also have the
internal &quot;Regexp&quot; package in its @ISA.
&quot;qr//-&quot;isa(&quot;Regexp&quot;)&gt; should always
be true regardless of what engine is being used.</p>

<p>Example implementation might be:</p>

<p>SV* Example_qr_package(pTHX_ REGEXP * const rx) {
PERL_UNUSED_ARG(rx); return
newSVpvs(&quot;re::engine::Example&quot;); }</p>

<p>Any method calls on an object created with
&quot;qr//&quot; will be dispatched to the package as a
normal object.</p>

<p>use re::engine::Example; my $re = qr//; $re-&gt;meth; #
dispatched to re::engine::Example::meth()</p>

<p>To retrieve the &quot;REGEXP&quot; object from the
scalar in an XS function use the &quot;SvRX&quot; macro, see
&quot;REGEXP Functions&quot; in perlapi.</p>

<p>void meth(SV * rv) PPCODE: REGEXP * re = SvRX(sv);</p>

<p>dupe void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS
*param);</p>

<p>On threaded builds a regexp may need to be duplicated so
that the pattern can be used by multiple threads. This
routine is expected to handle the duplication of any private
data pointed to by the &quot;pprivate&quot; member of the
regexp structure. It will be called with the preconstructed
new regexp structure as an argument, the
&quot;pprivate&quot; member will point at the old private
structure, and it is this routine s responsibility to
construct a copy and return a pointer to it (which perl will
then use to overwrite the field as passed to this
routine.)</p>

<p>This allows the engine to dupe its private data but also
if necessary modify the final structure if it really
must.</p>

<p>On unthreaded builds this field doesnt exist.</p>

<p>The REGEXP structure The REGEXP struct is defined in
regexp.h. All regex engines must be able to correctly build
such a structure in their &quot;comp&quot; routine.</p>

<p>The REGEXP structure contains all the data that perl
needs to be aware of to properly work with the regular
expression. It includes data about optimisations that perl
can use to determine if the regex engine should really be
used, and various other control info that is needed to
properly execute patterns in various contexts such as is the
pattern anchored in some way, or what flags were used during
the compile, or whether the program contains special
constructs that perl needs to be aware of.</p>

<p>In addition it contains two fields that are intended for
the private use of the regex engine that compiled the
pattern. These are the &quot;intflags&quot; and
&quot;pprivate&quot; members. &quot;pprivate&quot; is a void
pointer to an arbitrary structure whose use and management
is the responsibility of the compiling engine. perl will
never modify either of these values.</p>

<p>typedef struct regexp { /* what engine created this
regexp? */ const struct regexp_engine* engine;</p>

<p>/* what re is this a lightweight copy of? */ struct
regexp* mother_re;</p>

<p>/* Information about the match that the perl core uses
to manage things */ U32 extflags; /* Flags used both
externally and internally */ I32 minlen; /* mininum possible
length of string to match */ I32 minlenret; /* mininum
possible length of $&amp; */ U32 gofs; /* chars left of pos
that we search from */</p>

<p>/* substring data about strings that must appear in the
final match, used for optimisations */ struct
reg_substr_data *substrs;</p>

<p>U32 nparens; /* number of capture buffers */</p>

<p>/* private engine specific data */ U32 intflags; /*
Engine Specific Internal flags */ void *pprivate; /* Data
private to the regex engine which created this object.
*/</p>

<p>/* Data about the last/current match. These are modified
during matching*/ U32 lastparen; /* last open paren matched
*/ U32 lastcloseparen; /* last close paren matched */
regexp_paren_pair *swap; /* Swap copy of *offs */
regexp_paren_pair *offs; /* Array of offsets for (@-) and
(@+) */</p>

<p>char *subbeg; /* saved or original string so igit works
forever. */ SV_SAVED_COPY /* If non-NULL, SV which is COW
from original */ I32 sublen; /* Length of string pointed by
subbeg */</p>

<p>/* Information about the match that isn&rsquo;t often
used */ I32 prelen; /* length of precomp */ const char
*precomp; /* pre-compilation regular expression */</p>

<p>char *wrapped; /* wrapped version of the pattern */ I32
wraplen; /* length of wrapped */</p>

<p>I32 seen_evals; /* number of eval groups in the pattern
- for security checks */ HV *paren_names; /* Optional hash
of paren names */</p>

<p>/* Refcount of this regexp */ I32 refcnt; /* Refcount of
this regexp */ } regexp;</p>

<p>The fields are discussed in more detail below:</p>

<p>&quot;engine&quot; This field points at a regexp_engine
structure which contains pointers to the subroutines that
are to be used for performing a match. It is the compiling
routine s responsibility to populate this field before
returning the regexp object.</p>

<p>Internally this is set to &quot;NULL&quot; unless a
custom engine is specified in $^H{regcomp}, perl s own set
of callbacks can be accessed in the struct pointed to by
&quot;RE_ENGINE_PTR&quot;.</p>

<p>&quot;mother_re&quot; TODO, see
&lt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&gt;</p>

<p>&quot;extflags&quot; This will be used by perl to see
what flags the regexp was compiled with, this will normally
be set to the value of the flags parameter by the comp
callback. See the comp documentation for valid flags.</p>

<p>&quot;minlen&quot; &quot;minlenret&quot; The minimum
string length required for the pattern to match. This is
used to prune the search space by not bothering to match any
closer to the end of a string than would allow a match. For
instance there is no point in even starting the regex engine
if the minlen is 10 but the string is only 5 characters
long. There is no way that the pattern can match.</p>

<p>&quot;minlenret&quot; is the minimum length of the
string that would be found in $&amp; after a match.</p>

<p>The difference between &quot;minlen&quot; and
&quot;minlenret&quot; can be seen in the following
pattern:</p>

<p>/ns(?=)/</p>

<p>where the &quot;minlen&quot; would be 3 but
&quot;minlenret&quot; would only be 2 as the is required to
match but is not actually included in the matched content.
This distinction is particularly important as the
substitution logic uses the &quot;minlenret&quot; to tell
whether it can do in-place substitution which can result in
considerable speedup.</p>

<p>&quot;gofs&quot; Left offset from pos() to start match
at.</p>

<p>&quot;substrs&quot; Substring data about strings that
must appear in the final match. This is currently only used
internally by perls engine for but might be used in the
future for all engines for optimisations.</p>

<p>&quot;nparens&quot;, &quot;lasparen&quot;, and
&quot;lastcloseparen&quot; These fields are used to keep
track of how many paren groups could be matched in the
pattern, which was the last open paren to be entered, and
which was the last close paren to be entered.</p>

<p>&quot;intflags&quot; The engine s private copy of the
flags the pattern was compiled with. Usually this is the
same as &quot;extflags&quot; unless the engine chose to
modify one of them.</p>

<p>&quot;pprivate&quot; A void* pointing to an
engine-defined data structure. The perl engine uses the
&quot;regexp_internal&quot; structure (see &quot;Base
Structures&quot; in perlreguts) but a custom engine should
use something else.</p>

<p>&quot;swap&quot; Unused. Left in for compatibility with
perl 5.10.0.</p>

<p>&quot;offs&quot; A &quot;regexp_paren_pair&quot;
structure which defines offsets into the string being
matched which correspond to the $&amp; and $1, $2 etc.
captures, the &quot;regexp_paren_pair&quot; struct is
defined as follows:</p>

<p>typedef struct regexp_paren_pair { I32 start; I32 end; }
regexp_paren_pair;</p>

<p>If &quot;-&gt;offs[num].start&quot; or
&quot;-&gt;offs[num].end&quot; is &quot;-1&quot; then that
capture buffer did not match.
&quot;-&gt;offs[0].start/end&quot; represents $&amp; (or
&quot;${^MATCH&quot; under &quot;//p&quot;) and
&quot;-&gt;offs[paren].end&quot; matches $$paren where
$paren = 1&gt;.</p>

<p>&quot;precomp&quot; &quot;prelen&quot; Used for
optimisations. &quot;precomp&quot; holds a copy of the
pattern that was compiled and &quot;prelen&quot; its length.
When a new pattern is to be compiled (such as inside a loop)
the internal &quot;regcomp&quot; operator checks whether the
last compiled &quot;REGEXP&quot;s &quot;precomp&quot; and
&quot;prelen&quot; are equivalent to the new one, and if so
uses the old pattern instead of compiling a new one.</p>

<p>The relevant snippet from
&quot;Perl_pp_regcomp&quot;:</p>

<p>if (!re || !re-&gt;precomp || re-&gt;prelen != (I32)len
|| memNE(re-&gt;precomp, t, len)) /* Compile a new pattern
*/</p>

<p>&quot;paren_names&quot; This is a hash used internally
to track named capture buffers and their offsets. The keys
are the names of the buffers the values are dualvars, with
the IV slot holding the number of buffers with the given
name and the pv being an embedded array of I32. The values
may also be contained independently in the data array in
cases where named backreferences are used.</p>

<p>&quot;substrs&quot; Holds information on the longest
string that must occur at a fixed offset from the start of
the pattern, and the longest string that must occur at a
floating offset from the start of the pattern. Used to do
Fast-Boyer-Moore searches on the string to find out if its
worth using the regex engine at all, and if so where in the
string to search.</p>

<p>&quot;subbeg&quot; &quot;sublen&quot;
&quot;saved_copy&quot; Used during execution phase for
managing search and replace patterns.</p>

<p>&quot;wrapped&quot; &quot;wraplen&quot; Stores the
string &quot;qr//&quot; stringifies to. The perl engine for
example stores &quot;(?-xism:eek)&quot; in the case of
&quot;qr/eek/&quot;.</p>

<p>When using a custom engine that doesnt support the
&quot;(?:)&quot; construct for inline modifiers, its
probably best to have &quot;qr//&quot; stringify to the
supplied pattern, note that this will create undesired
patterns in cases such as:</p>

<p>my $x = qr/a|b/; # &quot;a|b&quot; my $y = qr/c/i; #
&quot;c&quot; my $z = qr/$x$y/; # &quot;a|bc&quot;</p>

<p>Theres no solution for this problem other than making
the custom engine understand a construct like
&quot;(?:)&quot;.</p>

<p>&quot;seen_evals&quot; This stores the number of eval
groups in the pattern. This is used for security purposes
when embedding compiled regexes into larger patterns with
&quot;qr//&quot;.</p>

<p>&quot;refcnt&quot; The number of times the structure is
referenced. When this falls to 0 the regexp is automatically
freed by a call to pregfree. This should be set to 1 in each
engines &quot;comp&quot; routine.</p>

<p>HISTORY Originally part of perlreguts.</p>

<p>AUTHORS Originally written by Yves Orton, expanded by
var Arnfjoer&lsquo; Bjarmason.</p>

<p>LICENSE Copyright 2006 Yves Orton and 2007 var
Arnfjoer&lsquo; Bjarmason.</p>

<p>This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>perl v5.10.1 2015-03-13 PERLREAPI(1)</p>
<hr>
</body>
</html>
