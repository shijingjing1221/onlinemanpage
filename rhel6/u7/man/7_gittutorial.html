<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GITTUTORIAL(7) Git Manual GITTUTORIAL(7)</p>

<p>NAME gittutorial - A tutorial introduction to git (for
version 1.5.1 or newer)</p>

<p>SYNOPSIS git *</p>

<p>DESCRIPTION This tutorial explains how to import a new
project into git, make changes to it, and share changes with
other developers.</p>

<p>If you are instead primarily interested in using git to
fetch a project, for example, to test the latest version,
you may prefer to start with the first two chapters of The
Git User s Manual[1].</p>

<p>First, note that you can get documentation for a command
such as git log --graph with:</p>

<p>$ man git-log</p>

<p>or:</p>

<p>$ git help log</p>

<p>With the latter, you can use the manual viewer of your
choice; see git- help(1) for more information.</p>

<p>It is a good idea to introduce yourself to git with your
name and public email address before doing any operation.
The easiest way to do so is:</p>

<p>$ git config --global user.name &quot;Your Name Comes
Here&quot; $ git config --global user.email
you@yourdomain.example.com</p>

<p>IMPORTING A NEW PROJECT Assume you have a tarball
project.tar.gz with your initial work. You can place it
under git revision control as follows.</p>

<p>$ tar xzf project.tar.gz $ cd project $ git init</p>

<p>Git will reply</p>

<p>Initialized empty Git repository in .git/</p>

<p>Youve now initialized the working directoryyou may
notice a new directory created, named &quot;.git&quot;.</p>

<p>Next, tell git to take a snapshot of the contents of all
files under the current directory (note the .), with git
add:</p>

<p>$ git add .</p>

<p>This snapshot is now stored in a temporary staging area
which git calls the &quot;index&quot;. You can permanently
store the contents of the index in the repository with git
commit:</p>

<p>$ git commit</p>

<p>This will prompt you for a commit message. You ve now
stored the first version of your project in git.</p>

<p>MAKING CHANGES Modify some files, then add their updated
contents to the index:</p>

<p>$ git add file1 file2 file3</p>

<p>You are now ready to commit. You can see what is about
to be committed using git diff with the --cached option:</p>

<p>$ git diff --cached</p>

<p>(Without --cached, git diff will show you any changes
that youve made but not yet added to the index.) You can
also get a brief summary of the situation with git
status:</p>

<p>$ git status # On branch master # Changes to be
committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot;
to unstage) # # modified: file1 # modified: file2 #
modified: file3 #</p>

<p>If you need to make any further adjustments, do so now,
and then add any newly modified content to the index.
Finally, commit your changes with:</p>

<p>$ git commit</p>

<p>This will again prompt you for a message describing the
change, and then record a new version of the project.</p>

<p>Alternatively, instead of running git add beforehand,
you can use</p>

<p>$ git commit -a</p>

<p>which will automatically notice any modified (but not
new) files, add them to the index, and commit, all in one
step.</p>

<p>A note on commit messages: Though not required, its a
good idea to begin the commit message with a single short
(less than 50 character) line summarizing the change,
followed by a blank line and then a more thorough
description. Tools that turn commits into email, for
example, use the first line on the Subject: line and the
rest of the commit in the body.</p>

<p>GIT TRACKS CONTENT NOT FILES Many revision control
systems provide an add command that tells the system to
start tracking changes to a new file. Git s add command does
something simpler and more powerful: git add is used both
for new and newly modified files, and in both cases it takes
a snapshot of the given files and stages that content in the
index, ready for inclusion in the next commit.</p>

<p>VIEWING PROJECT HISTORY At any point you can view the
history of your changes using</p>

<p>$ git log</p>

<p>If you also want to see complete diffs at each step,
use</p>

<p>$ git log -p</p>

<p>Often the overview of the change is useful to get a feel
of each step</p>

<p>$ git log --stat --summary</p>

<p>MANAGING BRANCHES A single git repository can maintain
multiple branches of development. To create a new branch
named &quot;experimental&quot;, use</p>

<p>$ git branch experimental</p>

<p>If you now run</p>

<p>$ git branch</p>

<p>youll get a list of all existing branches:</p>

<p>experimental * master</p>

<p>The &quot;experimental&quot; branch is the one you just
created, and the &quot;master&quot; branch is a default
branch that was created for you automatically. The asterisk
marks the branch you are currently on; type</p>

<p>$ git checkout experimental</p>

<p>to switch to the experimental branch. Now edit a file,
commit the change, and switch back to the master branch:</p>

<p>(edit file) $ git commit -a $ git checkout master</p>

<p>Check that the change you made is no longer visible,
since it was made on the experimental branch and youre back
on the master branch.</p>

<p>You can make a different change on the master
branch:</p>

<p>(edit file) $ git commit -a</p>

<p>at this point the two branches have diverged, with
different changes made in each. To merge the changes made in
experimental into master, run</p>

<p>$ git merge experimental</p>

<p>If the changes dont conflict, youre done. If there are
conflicts, markers will be left in the problematic files
showing the conflict;</p>

<p>$ git diff</p>

<p>will show this. Once youve edited the files to resolve
the conflicts,</p>

<p>$ git commit -a</p>

<p>will commit the result of the merge. Finally,</p>

<p>$ gitk</p>

<p>will show a nice graphical representation of the
resulting history.</p>

<p>At this point you could delete the experimental branch
with</p>

<p>$ git branch -d experimental</p>

<p>This command ensures that the changes in the
experimental branch are already in the current branch.</p>

<p>If you develop on a branch crazy-idea, then regret it,
you can always delete the branch with</p>

<p>$ git branch -D crazy-idea</p>

<p>Branches are cheap and easy, so this is a good way to
try something out.</p>

<p>USING GIT FOR COLLABORATION Suppose that Alice has
started a new project with a git repository in
/home/alice/project, and that Bob, who has a home directory
on the same machine, wants to contribute.</p>

<p>Bob begins with:</p>

<p>bob$ git clone /home/alice/project myrepo</p>

<p>This creates a new directory &quot;myrepo&quot;
containing a clone of Alices repository. The clone is on an
equal footing with the original project, possessing its own
copy of the original projects history.</p>

<p>Bob then makes some changes and commits them:</p>

<p>(edit files) bob$ git commit -a (repeat as
necessary)</p>

<p>When he s ready, he tells Alice to pull changes from the
repository at /home/bob/myrepo. She does this with:</p>

<p>alice$ cd /home/alice/project alice$ git pull
/home/bob/myrepo master</p>

<p>This merges the changes from Bob s &quot;master&quot;
branch into Alices current branch. If Alice has made her own
changes in the meantime, then she may need to manually fix
any conflicts.</p>

<p>The &quot;pull&quot; command thus performs two
operations: it fetches changes from a remote branch, then
merges them into the current branch.</p>

<p>Note that in general, Alice would want her local changes
committed before initiating this &quot;pull&quot;. If Bobs
work conflicts with what Alice did since their histories
forked, Alice will use her working tree and the index to
resolve conflicts, and existing local changes will interfere
with the conflict resolution process (git will still perform
the fetch but will refuse to merge --- Alice will have to
get rid of her local changes in some way and pull again when
this happens).</p>

<p>Alice can peek at what Bob did without merging first,
using the &quot;fetch&quot; command; this allows Alice to
inspect what Bob did, using a special symbol
&quot;FETCH_HEAD&quot;, in order to determine if he has
anything worth pulling, like this:</p>

<p>alice$ git fetch /home/bob/myrepo master alice$ git log
-p HEAD..FETCH_HEAD</p>

<p>This operation is safe even if Alice has uncommitted
local changes. The range notation
&quot;HEAD..FETCH_HEAD&quot; means &quot;show everything
that is reachable from the FETCH_HEAD but exclude anything
that is reachable from HEAD&quot;. Alice already knows
everything that leads to her current state (HEAD), and
reviews what Bob has in his state (FETCH_HEAD) that she has
not seen with this command.</p>

<p>If Alice wants to visualize what Bob did since their
histories forked she can issue the following command:</p>

<p>$ gitk HEAD..FETCH_HEAD</p>

<p>This uses the same two-dot range notation we saw earlier
with git log.</p>

<p>Alice may want to view what both of them did since they
forked. She can use three-dot form instead of the two-dot
form:</p>

<p>$ gitk HEAD...FETCH_HEAD</p>

<p>This means &quot;show everything that is reachable from
either one, but exclude anything that is reachable from both
of them&quot;.</p>

<p>Please note that these range notation can be used with
both gitk and &quot;git log&quot;.</p>

<p>After inspecting what Bob did, if there is nothing
urgent, Alice may decide to continue working without pulling
from Bob. If Bobs history does have something Alice would
immediately need, Alice may choose to stash her
work-in-progress first, do a &quot;pull&quot;, and then
finally unstash her work-in-progress on top of the resulting
history.</p>

<p>When you are working in a small closely knit group, it
is not unusual to interact with the same repository over and
over again. By defining remote repository shorthand, you can
make it easier:</p>

<p>alice$ git remote add bob /home/bob/myrepo</p>

<p>With this, Alice can perform the first part of the
&quot;pull&quot; operation alone using the git fetch command
without merging them with her own branch, using:</p>

<p>alice$ git fetch bob</p>

<p>Unlike the longhand form, when Alice fetches from Bob
using a remote repository shorthand set up with git remote,
what was fetched is stored in a remote tracking branch, in
this case bob/master. So after this:</p>

<p>alice$ git log -p master..bob/master</p>

<p>shows a list of all the changes that Bob made since he
branched from Alices master branch.</p>

<p>After examining those changes, Alice could merge the
changes into her master branch:</p>

<p>alice$ git merge bob/master</p>

<p>This merge can also be done by pulling from her own
remote tracking branch, like this:</p>

<p>alice$ git pull . remotes/bob/master</p>

<p>Note that git pull always merges into the current
branch, regardless of what else is given on the command
line.</p>

<p>Later, Bob can update his repo with Alices latest
changes using</p>

<p>bob$ git pull</p>

<p>Note that he doesnt need to give the path to Alice s
repository; when Bob cloned Alices repository, git stored
the location of her repository in the repository
configuration, and that location is used for pulls:</p>

<p>bob$ git config --get remote.origin.url
/home/alice/project</p>

<p>(The complete configuration created by git clone is
visible using git config -l, and the git-config(1) man page
explains the meaning of each option.)</p>

<p>Git also keeps a pristine copy of Alices master branch
under the name &quot;origin/master&quot;:</p>

<p>bob$ git branch -r origin/master</p>

<p>If Bob later decides to work from a different host, he
can still perform clones and pulls using the ssh
protocol:</p>

<p>bob$ git clone alice.org:/home/alice/project myrepo</p>

<p>Alternatively, git has a native protocol, or can use
rsync or http; see git-pull(1) for details.</p>

<p>Git can also be used in a CVS-like mode, with a central
repository that various users push changes to; see
git-push(1) and gitcvs-migration(7).</p>

<p>EXPLORING HISTORY Git history is represented as a series
of interrelated commits. We have already seen that the git
log command can list those commits. Note that first line of
each git log entry also gives a name for the commit:</p>

<p>$ git log commit
c82a22c39cbc32576f64f5c6b3f24b99ea8149c7 Author: Junio C
Hamano &lt;junkio@cox.net&gt; Date: Tue May 16 17:18:22 2006
-0700</p>

<p>merge-base: Clarify the comments on post processing.</p>

<p>We can give this name to git show to see the details
about this commit.</p>

<p>$ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7</p>

<p>But there are other ways to refer to commits. You can
use any initial part of the name that is long enough to
uniquely identify the commit:</p>

<p>$ git show c82a22c39c # the first few characters of the
name are # usually enough $ git show HEAD # the tip of the
current branch $ git show experimental # the tip of the
&quot;experimental&quot; branch</p>

<p>Every commit usually has one &quot;parent&quot; commit
which points to the previous state of the project:</p>

<p>$ git show HEAD^ # to see the parent of HEAD $ git show
HEAD^^ # to see the grandparent of HEAD $ git show HEAD~4 #
to see the great-great grandparent of HEAD</p>

<p>Note that merge commits may have more than one
parent:</p>

<p>$ git show HEAD^1 # show the first parent of HEAD (same
as HEAD^) $ git show HEAD^2 # show the second parent of
HEAD</p>

<p>You can also give commits names of your own; after
running</p>

<p>$ git tag v2.5 1b2e1d63ff</p>

<p>you can refer to 1b2e1d63ff by the name
&quot;v2.5&quot;. If you intend to share this name with
other people (for example, to identify a release version),
you should create a &quot;tag&quot; object, and perhaps sign
it; see git-tag(1) for details.</p>

<p>Any git command that needs to know a commit can take any
of these names. For example:</p>

<p>$ git diff v2.5 HEAD # compare the current HEAD to v2.5
$ git branch stable v2.5 # start a new branch named
&quot;stable&quot; based # at v2.5 $ git reset --hard HEAD^
# reset your current branch and working # directory to its
state at HEAD^</p>

<p>Be careful with that last command: in addition to losing
any changes in the working directory, it will also remove
all later commits from this branch. If this branch is the
only branch containing those commits, they will be lost.
Also, don t use git reset on a publicly-visible branch that
other developers pull from, as it will force needless merges
on other developers to clean up the history. If you need to
undo changes that you have pushed, use git revert
instead.</p>

<p>The git grep command can search for strings in any
version of your project, so</p>

<p>$ git grep &quot;hello&quot; v2.5</p>

<p>searches for all occurrences of &quot;hello&quot; in
v2.5.</p>

<p>If you leave out the commit name, git grep will search
any of the files it manages in your current directory.
So</p>

<p>$ git grep &quot;hello&quot;</p>

<p>is a quick way to search just the files that are tracked
by git.</p>

<p>Many git commands also take sets of commits, which can
be specified in a number of ways. Here are some examples
with git log:</p>

<p>$ git log v2.5..v2.6 # commits between v2.5 and v2.6 $
git log v2.5.. # commits since v2.5 $ git log
--since=&quot;2 weeks ago&quot; # commits from the last 2
weeks $ git log v2.5.. Makefile # commits since v2.5 which
modify # Makefile</p>

<p>You can also give git log a &quot;range&quot; of commits
where the first is not necessarily an ancestor of the
second; for example, if the tips of the branches
&quot;stable&quot; and &quot;master&quot; diverged from a
common commit some time ago, then</p>

<p>$ git log stable..master</p>

<p>will list commits made in the master branch but not in
the stable branch, while</p>

<p>$ git log master..stable</p>

<p>will show the list of commits made on the stable branch
but not the master branch.</p>

<p>The git log command has a weakness: it must present
commits in a list. When the history has lines of development
that diverged and then merged back together, the order in
which git log presents those commits is meaningless.</p>

<p>Most projects with multiple contributors (such as the
Linux kernel, or git itself) have frequent merges, and gitk
does a better job of visualizing their history. For
example,</p>

<p>$ gitk --since=&quot;2 weeks ago&quot; drivers/</p>

<p>allows you to browse any commits from the last 2 weeks
of commits that modified files under the &quot;drivers&quot;
directory. (Note: you can adjust gitks fonts by holding down
the control key while pressing &quot;-&quot; or
&quot;+&quot;.)</p>

<p>Finally, most commands that take filenames will
optionally allow you to precede any filename by a commit, to
specify a particular version of the file:</p>

<p>$ git diff v2.5:Makefile HEAD:Makefile.in</p>

<p>You can also use git show to see any such file:</p>

<p>$ git show v2.5:Makefile</p>

<p>NEXT STEPS This tutorial should be enough to perform
basic distributed revision control for your projects.
However, to fully understand the depth and power of git you
need to understand two simple ideas on which it is
based:</p>

<p>&middot; The object database is the rather elegant
system used to store the history of your project files,
directories, and commits.</p>

<p>&middot; The index file is a cache of the state of a
directory tree, used to create commits, check out working
directories, and hold the various trees involved in a
merge.</p>

<p>Part two of this tutorial explains the object database,
the index file, and a few other odds and ends that youll
need to make the most of git. You can find it at
gittutorial-2(7).</p>

<p>If you dont want to continue with that right away, a few
other digressions that may be interesting at this point
are:</p>

<p>&middot; git-format-patch(1), git-am(1): These convert
series of git commits into emailed patches, and vice versa,
useful for projects such as the Linux kernel which rely
heavily on emailed patches.</p>

<p>&middot; git-bisect(1): When there is a regression in
your project, one way to track down the bug is by searching
through the history to find the exact commit thats to blame.
Git bisect can help you perform a binary search for that
commit. It is smart enough to perform a close-to-optimal
search even in the case of complex non-linear history with
lots of merged branches.</p>

<p>&middot; gitworkflows(7): Gives an overview of
recommended workflows.</p>

<p>&middot; Everyday GIT with 20 Commands Or So[2]</p>

<p>&middot; gitcvs-migration(7): Git for CVS users.</p>

<p>SEE ALSO gittutorial-2(7), gitcvs-migration(7),
gitcore-tutorial(7), gitglossary(7), git-help(1),
gitworkflows(7), Everyday git[2], The Git Uses Manual[1]</p>

<p>GIT Part of the git(1) suite.</p>

<p>NOTES 1. The Git Users Manual
file:///usr/share/doc/git-1.7.1/user-manual.html</p>

<p>2. Everyday GIT with 20 Commands Or So
file:///usr/share/doc/git-1.7.1/everyday.html</p>

<p>Git 1.7.1 02/26/2013 GITTUTORIAL(7)</p>
<hr>
</body>
</html>
