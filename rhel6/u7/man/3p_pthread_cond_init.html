<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:30:11 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PTHREAD_COND_DESTROY(3P) POSIX Programmer s Manual
PTHREAD_COND_DESTROY(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME pthread_cond_destroy, pthread_cond_init - destroy
and initialize condi- tion variables</p>

<p>SYNOPSIS #include &lt;pthread.h&gt;</p>

<p>int pthread_cond_destroy(pthread_cond_t *cond); int
pthread_cond_init(pthread_cond_t *restrict cond, const
pthread_condattr_t *restrict attr); pthread_cond_t cond =
PTHREAD_COND_INITIALIZER;</p>

<p>DESCRIPTION The pthread_cond_destroy() function shall
destroy the given condition variable specified by cond; the
object becomes, in effect, uninitial- ized. An
implementation may cause pthread_cond_destroy() to set the
object referenced by cond to an invalid value. A destroyed
condition variable object can be reinitialized using
pthread_cond_init(); the results of otherwise referencing
the object after it has been destroyed are undefined.</p>

<p>It shall be safe to destroy an initialized condition
variable upon which no threads are currently blocked.
Attempting to destroy a condi- tion variable upon which
other threads are currently blocked results in undefined
behavior.</p>

<p>The pthread_cond_init() function shall initialize the
condition vari- able referenced by cond with attributes
referenced by attr. If attr is NULL, the default condition
variable attributes shall be used; the effect is the same as
passing the address of a default condition vari- able
attributes object. Upon successful initialization, the state
of the condition variable shall become initialized.</p>

<p>Only cond itself may be used for performing
synchronization. The result of referring to copies of cond
in calls to pthread_cond_wait(), pthread_cond_timedwait(),
pthread_cond_signal(), pthread_cond_broad- cast(), and
pthread_cond_destroy() is undefined.</p>

<p>Attempting to initialize an already initialized
condition variable results in undefined behavior.</p>

<p>In cases where default condition variable attributes are
appropriate, the macro PTHREAD_COND_INITIALIZER can be used
to initialize condition variables that are statically
allocated. The effect shall be equivalent to dynamic
initialization by a call to pthread_cond_init() with parame-
ter attr specified as NULL, except that no error checks are
performed.</p>

<p>RETURN VALUE If successful, the pthread_cond_destroy()
and pthread_cond_init() func- tions shall return zero;
otherwise, an error number shall be returned to indicate the
error.</p>

<p>The [EBUSY] and [EINVAL] error checks, if implemented,
shall act as if they were performed immediately at the
beginning of processing for the function and caused an error
return prior to modifying the state of the condition
variable specified by cond.</p>

<p>ERRORS The pthread_cond_destroy() function may fail
if:</p>

<p>EBUSY The implementation has detected an attempt to
destroy the object referenced by cond while it is referenced
(for example, while being used in a pthread_cond_wait() or
pthread_cond_timedwait()) by another thread.</p>

<p>EINVAL The value specified by cond is invalid.</p>

<p>The pthread_cond_init() function shall fail if:</p>

<p>EAGAIN The system lacked the necessary resources (other
than memory) to initialize another condition variable.</p>

<p>ENOMEM Insufficient memory exists to initialize the
condition variable.</p>

<p>The pthread_cond_init() function may fail if:</p>

<p>EBUSY The implementation has detected an attempt to
reinitialize the object referenced by cond, a previously
initialized, but not yet destroyed, condition variable.</p>

<p>EINVAL The value specified by attr is invalid.</p>

<p>These functions shall not return an error code of
[EINTR].</p>

<p>The following sections are informative.</p>

<p>EXAMPLES A condition variable can be destroyed
immediately after all the threads that are blocked on it are
awakened. For example, consider the follow- ing code:</p>

<p>struct list { pthread_mutex_t lm; ... }</p>

<p>struct elt { key k; int busy; pthread_cond_t notbusy;
... }</p>

<p>/* Find a list element and reserve it. */ struct elt *
list_find(struct list *lp, key k) { struct elt *ep;</p>

<p>pthread_mutex_lock(&amp;lp-&gt;lm); while ((ep =
find_elt(l, k) != NULL) &amp;&amp; ep-&gt;busy)
pthread_cond_wait(&amp;ep-&gt;notbusy, &amp;lp-&gt;lm); if
(ep != NULL) ep-&gt;busy = 1;
pthread_mutex_unlock(&amp;lp-&gt;lm); return(ep); }</p>

<p>delete_elt(struct list *lp, struct elt *ep) {
pthread_mutex_lock(&amp;lp-&gt;lm); assert(ep-&gt;busy); ...
remove ep from list ... ep-&gt;busy = 0; /* Paranoid. */ (A)
pthread_cond_broadcast(&amp;ep-&gt;notbusy);
pthread_mutex_unlock(&amp;lp-&gt;lm); (B)
pthread_cond_destroy(&amp;rp-&gt;notbusy); free(ep); }</p>

<p>In this example, the condition variable and its list
element may be freed (line B) immediately after all threads
waiting for it are awak- ened (line A), since the mutex and
the code ensure that no other thread can touch the element
to be deleted.</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE See pthread_mutex_init(); a similar rationale
applies to condition variables.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO pthread_cond_broadcast(),
pthread_cond_signal(), pthread_cond_timed- wait(), the Base
Definitions volume of IEEE Std 1003.1-2001,
&lt;pthread.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 PTHREAD_COND_DESTROY(3P)</p>
<hr>
</body>
</html>
