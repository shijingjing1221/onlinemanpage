<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:18:52 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IBV_GET_CQ_EVENT(3) Libibverbs Programmer s Manual
IBV_GET_CQ_EVENT(3)</p>

<p>NAME ibv_get_cq_event, ibv_ack_cq_events - get and
acknowledge completion queue (CQ) events</p>

<p>SYNOPSIS #include &lt;infiniband/verbs.h&gt;</p>

<p>int ibv_get_cq_event(struct ibv_comp_channel *channel,
struct ibv_cq **cq, void **cq_context);</p>

<p>void ibv_ack_cq_events(struct ibv_cq *cq, unsigned int
nevents);</p>

<p>DESCRIPTION ibv_get_cq_event() waits for the next
completion event in the comple- tion event channel channel.
Fills the arguments cq with the CQ that got the event and
cq_context with the CQs context.</p>

<p>ibv_ack_cq_events() acknowledges nevents events on the
CQ cq.</p>

<p>RETURN VALUE ibv_get_cq_event() returns 0 on success,
and -1 on error.</p>

<p>ibv_ack_cq_events() returns no value.</p>

<p>NOTES All completion events that ibv_get_cq_event()
returns must be acknowl- edged using ibv_ack_cq_events(). To
avoid races, destroying a CQ will wait for all completion
events to be acknowledged; this guarantees a one-to-one
correspondence between acks and successful gets.</p>

<p>Calling ibv_ack_cq_events() may be relatively expensive
in the datap- ath, since it must take a mutex. Therefore it
may be better to amor- tize this cost by keeping a count of
the number of events needing acknowledgement and acking
several completion events in one call to
ibv_ack_cq_events().</p>

<p>EXAMPLES The following code example demonstrates one
possible way to work with completion events. It performs the
following steps:</p>

<p>Stage I: Preparation 1. Creates a CQ 2. Requests for
notification upon a new (first) completion event</p>

<p>Stage II: Completion Handling Routine 3. Wait for the
completion event and ack it 4. Request for notification upon
the next completion event 5. Empty the CQ</p>

<p>Note that an extra event may be triggered without having
a correspond- ing completion entry in the CQ. This occurs if
a completion entry is added to the CQ between Step 4 and
Step 5, and the CQ is then emptied (polled) in Step 5.</p>

<p>cq = ibv_create_cq(ctx, 1, ev_ctx, channel, 0); if (!cq)
{ fprintf(stderr, &quot;Failed to create CQ0); return 1;
}</p>

<p>/* Request notification before any completion can be
created */ if (ibv_req_notify_cq(cq, 0)) { fprintf(stderr,
&quot;Couldn t request CQ notification0); return 1; }</p>

<p>. . .</p>

<p>/* Wait for the completion event */ if
(ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
fprintf(stderr, &quot;Failed to get cq_event0); return 1;
}</p>

<p>/* Ack the event */ ibv_ack_cq_events(ev_cq, 1);</p>

<p>/* Request notification upon the next completion event
*/ if (ibv_req_notify_cq(ev_cq, 0)) { fprintf(stderr,
&quot;Couldn t request CQ notification0); return 1; }</p>

<p>/* Empty the CQ: poll all of the completions from the CQ
(if any exist) */ do { ne = ibv_poll_cq(cq, 1, &amp;wc); if
(ne &lt; 0) { fprintf(stderr, &quot;Failed to poll
completions from the CQ0); return 1; }</p>

<p>/* there may be an extra event with no completion in the
CQ */ if (ne == 0) continue;</p>

<p>if (wc.status != IBV_WC_SUCCESS) { fprintf(stderr,
&quot;Completion with status 0x%x was found0, wc.status);
return 1; } } while (ne);</p>

<p>The following code example demonstrates one possible way
to work with completion events in non-blocking mode. It
performs the following steps:</p>

<p>1. Set the completion event channel to be non-blocked 2.
Poll the channel until there it has a completion event 3.
Get the completion event and ack it</p>

<p>/* change the blocking mode of the completion channel */
flags = fcntl(channel-&gt;fd, F_GETFL); rc =
fcntl(channel-&gt;fd, F_SETFL, flags | O_NONBLOCK); if (rc
&lt; 0) { fprintf(stderr, &quot;Failed to change file
descriptor of completion event channel0); return 1; }</p>

<p>/* * poll the channel until it has an event and sleep
ms_timeout * milliseconds between any iteration */
my_pollfd.fd = channel-&gt;fd; my_pollfd.events = POLLIN;
my_pollfd.revents = 0;</p>

<p>do { rc = poll(&amp;my_pollfd, 1, ms_timeout); } while
(rc == 0); if (rc &lt; 0) { fprintf(stderr, &quot;poll
failed0); return 1; } ev_cq = cq;</p>

<p>/* Wait for the completion event */ if
(ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
fprintf(stderr, &quot;Failed to get cq_event0); return 1;
}</p>

<p>/* Ack the event */ ibv_ack_cq_events(ev_cq, 1);</p>

<p>SEE ALSO ibv_create_comp_channel(3), ibv_create_cq(3),
ibv_req_notify_cq(3), ibv_poll_cq(3)</p>

<p>AUTHORS Dotan Barak &lt;dotanba@gmail.com&gt;</p>

<p>libibverbs 2006-10-31 IBV_GET_CQ_EVENT(3)</p>
<hr>
</body>
</html>
