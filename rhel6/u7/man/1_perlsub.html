<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:24 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLSUB(1) Perl Programmers Reference Guide
PERLSUB(1)</p>

<p>NAME perlsub - Perl subroutines</p>

<p>SYNOPSIS To declare subroutines:</p>

<p>sub NAME; # A &quot;forward&quot; declaration. sub
NAME(PROTO); # ditto, but with prototypes sub NAME : ATTRS;
# with attributes sub NAME(PROTO) : ATTRS; # with attributes
and prototypes</p>

<p>sub NAME BLOCK # A declaration and a definition. sub
NAME(PROTO) BLOCK # ditto, but with prototypes sub NAME :
ATTRS BLOCK # with attributes sub NAME(PROTO) : ATTRS BLOCK
# with prototypes and attributes</p>

<p>To define an anonymous subroutine at runtime:</p>

<p>$subref = sub BLOCK; # no proto $subref = sub (PROTO)
BLOCK; # with proto $subref = sub : ATTRS BLOCK; # with
attributes $subref = sub (PROTO) : ATTRS BLOCK; # with proto
and attributes</p>

<p>To import subroutines:</p>

<p>use MODULE qw(NAME1 NAME2 NAME3);</p>

<p>To call subroutines:</p>

<p>NAME(LIST); # &amp; is optional with parentheses. NAME
LIST; # Parentheses optional if predeclared/imported.
&amp;NAME(LIST); # Circumvent prototypes. &amp;NAME; # Makes
current @_ visible to called subroutine.</p>

<p>DESCRIPTION Like many languages, Perl provides for
user-defined subroutines. These may be located anywhere in
the main program, loaded in from other files via the
&quot;do&quot;, &quot;require&quot;, or &quot;use&quot;
keywords, or generated on the fly using &quot;eval&quot; or
anonymous subroutines. You can even call a function
indirectly using a variable containing its name or a CODE
reference.</p>

<p>The Perl model for function call and return values is
simple: all functions are passed as parameters one single
flat list of scalars, and all functions likewise return to
their caller one single flat list of scalars. Any arrays or
hashes in these call and return lists will collapse, losing
their identities--but you may always use pass-by- reference
instead to avoid this. Both call and return lists may
contain as many or as few scalar elements as youd like.
(Often a function without an explicit return statement is
called a subroutine, but theres really no difference from
Perls perspective.)</p>

<p>Any arguments passed in show up in the array @_.
Therefore, if you called a function with two arguments,
those would be stored in $_[0] and $_[1]. The array @_ is a
local array, but its elements are aliases for the actual
scalar parameters. In particular, if an element $_[0] is
updated, the corresponding argument is updated (or an error
occurs if it is not updatable). If an argument is an array
or hash element which did not exist when the function was
called, that element is created only when (and if) it is
modified or a reference to it is taken. (Some earlier
versions of Perl created the element whether or not the
element was assigned to.) Assigning to the whole array @_
removes that aliasing, and does not update any
arguments.</p>

<p>A &quot;return&quot; statement may be used to exit a
subroutine, optionally specifying the returned value, which
will be evaluated in the appropriate context (list, scalar,
or void) depending on the context of the subroutine call. If
you specify no return value, the subroutine returns an empty
list in list context, the undefined value in scalar context,
or nothing in void context. If you return one or more
aggregates (arrays and hashes), these will be flattened
together into one large indistinguishable list.</p>

<p>If no &quot;return&quot; is found and if the last
statement is an expression, its value is returned. If the
last statement is a loop control structure like a
&quot;foreach&quot; or a &quot;while&quot;, the returned
value is unspecified. The empty sub returns the empty
list.</p>

<p>Perl does not have named formal parameters. In practice
all you do is assign to a &quot;my()&quot; list of these.
Variables that arent declared to be private are global
variables. For gory details on creating private variables,
see &quot;Private Variables via my()&quot; and
&quot;Temporary Values via local()&quot;. To create
protected environments for a set of functions in a separate
package (and probably a separate file), see
&quot;Packages&quot; in perlmod.</p>

<p>Example:</p>

<p>sub max { my $max = shift(@_); foreach $foo (@_) { $max
= $foo if $max &lt; $foo; } return $max; } $bestday =
max($mon,$tue,$wed,$thu,$fri);</p>

<p>Example:</p>

<p># get a line, combining continuation lines # that start
with whitespace</p>

<p>sub get_line { $thisline = $lookahead; # global
variables! LINE: while (defined($lookahead = &lt;STDIN&gt;))
{ if ($lookahead =~ /^[ ]/) { $thisline .= $lookahead; }
else { last LINE; } } return $thisline; }</p>

<p>$lookahead = &lt;STDIN&gt;; # get first line while
(defined($line = get_line())) { ... }</p>

<p>Assigning to a list of private variables to name your
arguments:</p>

<p>sub maybeset { my($key, $value) = @_; $Foo{$key} =
$value unless $Foo{$key}; }</p>

<p>Because the assignment copies the values, this also has
the effect of turning call-by-reference into call-by-value.
Otherwise a function is free to do in-place modifications of
@_ and change its callers values.</p>

<p>upcase_in($v1, $v2); # this changes $v1 and $v2 sub
upcase_in { for (@_) { tr/a-z/A-Z/ } }</p>

<p>You arent allowed to modify constants in this way, of
course. If an argument were actually literal and you tried
to change it, youd take a (presumably fatal) exception. For
example, this won t work:</p>

<p>upcase_in(&quot;frederick&quot;);</p>

<p>It would be much safer if the &quot;upcase_in()&quot;
function were written to return a copy of its parameters
instead of changing them in place:</p>

<p>($v3, $v4) = upcase($v1, $v2); # this doesn&rsquo;t
change $v1 and $v2 sub upcase { return unless defined
wantarray; # void context, do nothing my @parms = @_; for
(@parms) { tr/a-z/A-Z/ } return wantarray ? @parms :
$parms[0]; }</p>

<p>Notice how this (unprototyped) function doesn t care
whether it was passed real scalars or arrays. Perl sees all
arguments as one big, long, flat parameter list in @_. This
is one area where Perls simple argument-passing style
shines. The &quot;upcase()&quot; function would work
perfectly well without changing the &quot;upcase()&quot;
definition even if we fed it things like this:</p>

<p>@newlist = upcase(@list1, @list2); @newlist = upcase(
split /:/, $var );</p>

<p>Do not, however, be tempted to do this:</p>

<p>(@a, @b) = upcase(@list1, @list2);</p>

<p>Like the flattened incoming parameter list, the return
list is also flattened on return. So all you have managed to
do here is stored everything in @a and made @b empty. See
&quot;Pass by Reference&quot; for alternatives.</p>

<p>A subroutine may be called using an explicit
&quot;&amp;&quot; prefix. The &quot;&amp;&quot; is optional
in modern Perl, as are parentheses if the subroutine has
been predeclared. The &quot;&amp;&quot; is not optional when
just naming the subroutine, such as when its used as an
argument to defined() or undef(). Nor is it optional when
you want to do an indirect subroutine call with a subroutine
name or reference using the &quot;&amp;$subref()&quot; or
&quot;&amp;{$subref}()&quot; constructs, although the
&quot;$subref-&gt;()&quot; notation solves that problem. See
perlref for more about all that.</p>

<p>Subroutines may be called recursively. If a subroutine
is called using the &quot;&amp;&quot; form, the argument
list is optional, and if omitted, no @_ array is set up for
the subroutine: the @_ array at the time of the call is
visible to subroutine instead. This is an efficiency
mechanism that new users may wish to avoid.</p>

<p>&amp;foo(1,2,3); # pass three arguments foo(1,2,3); #
the same</p>

<p>foo(); # pass a null list &amp;foo(); # the same</p>

<p>&amp;foo; # foo() get current args, like foo(@_) !! foo;
# like foo() IFF sub foo predeclared, else
&quot;foo&quot;</p>

<p>Not only does the &quot;&amp;&quot; form make the
argument list optional, it also disables any prototype
checking on arguments you do provide. This is partly for
historical reasons, and partly for having a convenient way
to cheat if you know what youre doing. See Prototypes
below.</p>

<p>Subroutines whose names are in all upper case are
reserved to the Perl core, as are modules whose names are in
all lower case. A subroutine in all capitals is a
loosely-held convention meaning it will be called indirectly
by the run-time system itself, usually due to a triggered
event. Subroutines that do special, pre-defined things
include &quot;AUTOLOAD&quot;, &quot;CLONE&quot;,
&quot;DESTROY&quot; plus all functions mentioned in perltie
and PerlIO::via.</p>

<p>The &quot;BEGIN&quot;, &quot;UNITCHECK&quot;,
&quot;CHECK&quot;, &quot;INIT&quot; and &quot;END&quot;
subroutines are not so much subroutines as named special
code blocks, of which you can have more than one in a
package, and which you can not call explicitly. See
&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in
perlmod</p>

<p>Private Variables via my() Synopsis:</p>

<p>my $foo; # declare $foo lexically local my (@wid, %get);
# declare list of variables local my $foo =
&quot;flurp&quot;; # declare $foo lexical, and init it my
@oof = @bar; # declare @oof lexical, and init it my $x : Foo
= $y; # similar, with an attribute applied</p>

<p>WARNING: The use of attribute lists on &quot;my&quot;
declarations is still evolving. The current semantics and
interface are subject to change. See attributes and
Attribute::Handlers.</p>

<p>The &quot;my&quot; operator declares the listed
variables to be lexically confined to the enclosing block,
conditional (&quot;if/unless/elsif/else&quot;), loop
(&quot;for/foreach/while/until/continue&quot;), subroutine,
&quot;eval&quot;, or &quot;do/require/use&quot;d file. If
more than one value is listed, the list must be placed in
parentheses. All listed elements must be legal lvalues. Only
alphanumeric identifiers may be lexically scoped--magical
built-ins like $/ must currently be &quot;local&quot;ized
with &quot;local&quot; instead.</p>

<p>Unlike dynamic variables created by the
&quot;local&quot; operator, lexical variables declared with
&quot;my&quot; are totally hidden from the outside world,
including any called subroutines. This is true if its the
same subroutine called from itself or elsewhere--every call
gets its own copy.</p>

<p>This doesnt mean that a &quot;my&quot; variable declared
in a statically enclosing lexical scope would be invisible.
Only dynamic scopes are cut off. For example, the
&quot;bumpx()&quot; function below has access to the lexical
$x variable because both the &quot;my&quot; and the
&quot;sub&quot; occurred at the same scope, presumably file
scope.</p>

<p>my $x = 10; sub bumpx { $x++ }</p>

<p>An &quot;eval()&quot;, however, can see lexical
variables of the scope it is being evaluated in, so long as
the names arent hidden by declarations within the
&quot;eval()&quot; itself. See perlref.</p>

<p>The parameter list to my() may be assigned to if
desired, which allows you to initialize your variables. (If
no initializer is given for a particular variable, it is
created with the undefined value.) Commonly this is used to
name input parameters to a subroutine. Examples:</p>

<p>$arg = &quot;fred&quot;; # &quot;global&quot; variable
$n = cube_root(27); print &quot;$arg thinks the root is $n0;
fred thinks the root is 3</p>

<p>sub cube_root { my $arg = shift; # name doesn&rsquo;t
matter $arg **= 1/3; return $arg; }</p>

<p>The &quot;my&quot; is simply a modifier on something you
might assign to. So when you do assign to variables in its
argument list, &quot;my&quot; doesnt change whether those
variables are viewed as a scalar or an array. So</p>

<p>my ($foo) = &lt;STDIN&gt;; # WRONG? my @FOO =
&lt;STDIN&gt;;</p>

<p>both supply a list context to the right-hand side,
while</p>

<p>my $foo = &lt;STDIN&gt;;</p>

<p>supplies a scalar context. But the following declares
only one variable:</p>

<p>my $foo, $bar = 1; # WRONG</p>

<p>That has the same effect as</p>

<p>my $foo; $bar = 1;</p>

<p>The declared variable is not introduced (is not visible)
until after the current statement. Thus,</p>

<p>my $x = $x;</p>

<p>can be used to initialize a new $x with the value of the
old $x, and the expression</p>

<p>my $x = 123 and $x == 123</p>

<p>is false unless the old $x happened to have the value
123.</p>

<p>Lexical scopes of control structures are not bounded
precisely by the braces that delimit their controlled
blocks; control expressions are part of that scope, too.
Thus in the loop</p>

<p>while (my $line = &lt;&gt;) { $line = lc $line; }
continue { print $line; }</p>

<p>the scope of $line extends from its declaration
throughout the rest of the loop construct (including the
&quot;continue&quot; clause), but not beyond it. Similarly,
in the conditional</p>

<p>if ((my $answer = &lt;STDIN&gt;) =~ /^yes$/i) {
user_agrees(); } elsif ($answer =~ /^no$/i) {
user_disagrees(); } else { chomp $answer; die
&quot;&rsquo;$answer&rsquo; is neither &rsquo;yes&rsquo; nor
&rsquo;no&rsquo;&quot;; }</p>

<p>the scope of $answer extends from its declaration
through the rest of that conditional, including any
&quot;elsif&quot; and &quot;else&quot; clauses, but not
beyond it. See &quot;Simple statements&quot; in perlsyn for
information on the scope of variables in statements with
modifiers.</p>

<p>The &quot;foreach&quot; loop defaults to scoping its
index variable dynamically in the manner of
&quot;local&quot;. However, if the index variable is
prefixed with the keyword &quot;my&quot;, or if there is
already a lexical by that name in scope, then a new lexical
is created instead. Thus in the loop</p>

<p>for my $i (1, 2, 3) { some_function(); }</p>

<p>the scope of $i extends to the end of the loop, but not
beyond it, rendering the value of $i inaccessible within
&quot;some_function()&quot;.</p>

<p>Some users may wish to encourage the use of lexically
scoped variables. As an aid to catching implicit uses to
package variables, which are always global, if you say</p>

<p>use strict &rsquo;vars&rsquo;;</p>

<p>then any variable mentioned from there to the end of the
enclosing block must either refer to a lexical variable, be
predeclared via &quot;our&quot; or &quot;use vars&quot;, or
else must be fully qualified with the package name. A
compilation error results otherwise. An inner block may
countermand this with &quot;no strict
&rsquo;vars&rsquo;&quot;.</p>

<p>A &quot;my&quot; has both a compile-time and a run-time
effect. At compile time, the compiler takes notice of it.
The principal usefulness of this is to quiet &quot;use
strict &rsquo;vars&rsquo;&quot;, but it is also essential
for generation of closures as detailed in perlref. Actual
initialization is delayed until run time, though, so it gets
executed at the appropriate time, such as each time through
a loop, for example.</p>

<p>Variables declared with &quot;my&quot; are not part of
any package and are therefore never fully qualified with the
package name. In particular, you re not allowed to try to
make a package variable (or other global) lexical:</p>

<p>my $pack::var; # ERROR! Illegal syntax</p>

<p>In fact, a dynamic variable (also known as package or
global variables) are still accessible using the fully
qualified &quot;::&quot; notation even while a lexical of
the same name is also visible:</p>

<p>package main; local $x = 10; my $x = 20; print &quot;$x
and $::x0;</p>

<p>That will print out 20 and 10.</p>

<p>You may declare &quot;my&quot; variables at the
outermost scope of a file to hide any such identifiers from
the world outside that file. This is similar in spirit to Cs
static variables when they are used at the file level. To do
this with a subroutine requires the use of a closure (an
anonymous function that accesses enclosing lexicals). If you
want to create a private subroutine that cannot be called
from outside that block, it can declare a lexical variable
containing an anonymous sub reference:</p>

<p>my $secret_version = &rsquo;1.001-beta&rsquo;; my
$secret_sub = sub { print $secret_version };
&amp;$secret_sub();</p>

<p>As long as the reference is never returned by any
function within the module, no outside module can see the
subroutine, because its name is not in any packages symbol
table. Remember that its not REALLY called
$some_pack::secret_version or anything; its just
$secret_version, unqualified and unqualifiable.</p>

<p>This does not work with object methods, however; all
object methods have to be in the symbol table of some
package to be found. See &quot;Function Templates&quot; in
perlref for something of a work-around to this.</p>

<p>Persistent Private Variables There are two ways to build
persistent private variables in Perl 5.10. First, you can
simply use the &quot;state&quot; feature. Or, you can use
closures, if you want to stay compatible with releases older
than 5.10.</p>

<p>Persistent variables via state()</p>

<p>Beginning with perl 5.9.4, you can declare variables
with the &quot;state&quot; keyword in place of
&quot;my&quot;. For that to work, though, you must have
enabled that feature beforehand, either by using the
&quot;feature&quot; pragma, or by using &quot;-E&quot; on
one-liners. (see feature)</p>

<p>For example, the following code maintains a private
counter, incremented each time the gimme_another() function
is called:</p>

<p>use feature &rsquo;state&rsquo;; sub gimme_another {
state $x; return ++$x }</p>

<p>Also, since $x is lexical, it cant be reached or
modified by any Perl code outside.</p>

<p>When combined with variable declaration, simple scalar
assignment to &quot;state&quot; variables (as in &quot;state
$x = 42&quot;) is executed only the first time. When such
statements are evaluated subsequent times, the assignment is
ignored. The behavior of this sort of assignment to non-
scalar variables is undefined.</p>

<p>Persistent variables with closures</p>

<p>Just because a lexical variable is lexically (also
called statically) scoped to its enclosing block,
&quot;eval&quot;, or &quot;do&quot; FILE, this doesnt mean
that within a function it works like a C static. It normally
works more like a C auto, but with implicit garbage
collection.</p>

<p>Unlike local variables in C or C++, Perl s lexical
variables dont necessarily get recycled just because their
scope has exited. If something more permanent is still aware
of the lexical, it will stick around. So long as something
else references a lexical, that lexical wont be freed--which
is as it should be. You wouldnt want memory being free until
you were done using it, or kept around once you were done.
Automatic garbage collection takes care of this for you.</p>

<p>This means that you can pass back or save away
references to lexical variables, whereas to return a pointer
to a C auto is a grave error. It also gives us a way to
simulate Cs function statics. Heres a mechanism for giving a
function private variables with both lexical scoping and a
static lifetime. If you do want to create something like Cs
static variables, just enclose the whole function in an
extra block, and put the static variable outside the
function but in the block.</p>

<p>{ my $secret_val = 0; sub gimme_another { return
++$secret_val; } } # $secret_val now becomes unreachable by
the outside # world, but retains its value between calls to
gimme_another</p>

<p>If this function is being sourced in from a separate
file via &quot;require&quot; or &quot;use&quot;, then this
is probably just fine. If its all in the main program, youll
need to arrange for the &quot;my&quot; to be executed early,
either by putting the whole block above your main program,
or more likely, placing merely a &quot;BEGIN&quot; code
block around it to make sure it gets executed before your
program starts to run:</p>

<p>BEGIN { my $secret_val = 0; sub gimme_another { return
++$secret_val; } }</p>

<p>See &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in
perlmod about the special triggered code blocks,
&quot;BEGIN&quot;, &quot;UNITCHECK&quot;, &quot;CHECK&quot;,
&quot;INIT&quot; and &quot;END&quot;.</p>

<p>If declared at the outermost scope (the file scope),
then lexicals work somewhat like Cs file statics. They are
available to all functions in that same file declared below
them, but are inaccessible from outside that file. This
strategy is sometimes used in modules to create private
variables that the whole module can see.</p>

<p>Temporary Values via local() WARNING: In general, you
should be using &quot;my&quot; instead of &quot;local&quot;,
because its faster and safer. Exceptions to this include the
global punctuation variables, global filehandles and
formats, and direct manipulation of the Perl symbol table
itself. &quot;local&quot; is mostly used when the current
value of a variable must be visible to called
subroutines.</p>

<p>Synopsis:</p>

<p># localization of values</p>

<p>local $foo; # make $foo dynamically local local (@wid,
%get); # make list of variables local local $foo =
&quot;flurp&quot;; # make $foo dynamic, and init it local
@oof = @bar; # make @oof dynamic, and init it</p>

<p>local $hash{key} = &quot;val&quot;; # sets a local value
for this hash entry local ($cond ? $v1 : $v2); # several
types of lvalues support # localization</p>

<p># localization of symbols</p>

<p>local *FH; # localize $FH, @FH, %FH, &amp;FH ... local
*merlyn = *randal; # now $merlyn is really $randal, plus #
@merlyn is really @randal, etc local *merlyn =
&rsquo;randal&rsquo;; # SAME THING: promote
&rsquo;randal&rsquo; to *randal local *merlyn = andal; #
just alias $merlyn, not @merlyn etc</p>

<p>A &quot;local&quot; modifies its listed variables to be
&quot;local&quot; to the enclosing block, &quot;eval&quot;,
or &quot;do FILE&quot;--and to any subroutine called from
within that block. A &quot;local&quot; just gives temporary
values to global (meaning package) variables. It does not
create a local variable. This is known as dynamic scoping.
Lexical scoping is done with &quot;my&quot;, which works
more like Cs auto declarations.</p>

<p>Some types of lvalues can be localized as well : hash
and array elements and slices, conditionals (provided that
their result is always localizable), and symbolic
references. As for simple variables, this creates new,
dynamically scoped values.</p>

<p>If more than one variable or expression is given to
&quot;local&quot;, they must be placed in parentheses. This
operator works by saving the current values of those
variables in its argument list on a hidden stack and
restoring them upon exiting the block, subroutine, or eval.
This means that called subroutines can also reference the
local variable, but not the global one. The argument list
may be assigned to if desired, which allows you to
initialize your local variables. (If no initializer is given
for a particular variable, it is created with an undefined
value.)</p>

<p>Because &quot;local&quot; is a run-time operator, it
gets executed each time through a loop. Consequently, it s
more efficient to localize your variables outside the
loop.</p>

<p>Grammatical note on local()</p>

<p>A &quot;local&quot; is simply a modifier on an lvalue
expression. When you assign to a &quot;local&quot;ized
variable, the &quot;local&quot; doesnt change whether its
list is viewed as a scalar or an array. So</p>

<p>local($foo) = &lt;STDIN&gt;; local @FOO =
&lt;STDIN&gt;;</p>

<p>both supply a list context to the right-hand side,
while</p>

<p>local $foo = &lt;STDIN&gt;;</p>

<p>supplies a scalar context.</p>

<p>Localization of special variables</p>

<p>If you localize a special variable, youll be giving a
new value to it, but its magic won t go away. That means
that all side-effects related to this magic still work with
the localized value.</p>

<p>This feature allows code like this to work :</p>

<p># Read the whole contents of FILE in $slurp { local $/ =
undef; $slurp = &lt;FILE&gt;; }</p>

<p>Note, however, that this restricts localization of some
values ; for example, the following statement dies, as of
perl 5.9.0, with an error Modification of a read-only value
attempted, because the $1 variable is magical and read-only
:</p>

<p>local $1 = 2;</p>

<p>Similarly, but in a way more difficult to spot, the
following snippet will die in perl 5.9.0 :</p>

<p>sub f { local $_ = &quot;foo&quot;; print } for ($1) { #
now $_ is aliased to $1, thus is magic and readonly f();
}</p>

<p>See next section for an alternative to this
situation.</p>

<p>WARNING: Localization of tied arrays and hashes does not
currently work as described. This will be fixed in a future
release of Perl; in the meantime, avoid code that relies on
any particular behaviour of localising tied arrays or hashes
(localising individual elements is still okay). See
&quot;Localising Tied Arrays and Hashes Is Broken&quot; in
perl58delta for more details.</p>

<p>Localization of globs</p>

<p>The construct</p>

<p>local *name;</p>

<p>creates a whole new symbol table entry for the glob
&quot;name&quot; in the current package. That means that all
variables in its glob slot ($name, @name, %name, &amp;name,
and the &quot;name&quot; filehandle) are dynamically
reset.</p>

<p>This implies, among other things, that any magic
eventually carried by those variables is locally lost. In
other words, saying &quot;local */&quot; will not have any
effect on the internal value of the input record
separator.</p>

<p>Notably, if you want to work with a brand new value of
the default scalar $_, and avoid the potential problem
listed above about $_ previously carrying a magic value, you
should use &quot;local *_&quot; instead of &quot;local
$_&quot;. As of perl 5.9.1, you can also use the lexical
form of $_ (declaring it with &quot;my $_&quot;), which
avoids completely this problem.</p>

<p>Localization of elements of composite types</p>

<p>It s also worth taking a moment to explain what happens
when you &quot;local&quot;ize a member of a composite type
(i.e. an array or hash element). In this case, the element
is &quot;local&quot;ized by name. This means that when the
scope of the &quot;local()&quot; ends, the saved value will
be restored to the hash element whose key was named in the
&quot;local()&quot;, or the array element whose index was
named in the &quot;local()&quot;. If that element was
deleted while the &quot;local()&quot; was in effect (e.g. by
a &quot;delete()&quot; from a hash or a &quot;shift()&quot;
of an array), it will spring back into existence, possibly
extending an array and filling in the skipped elements with
&quot;undef&quot;. For instance, if you say</p>

<p>%hash = ( &rsquo;This&rsquo; =&gt; &rsquo;is&rsquo;,
&rsquo;a&rsquo; =&gt; &rsquo;test&rsquo; ); @ary = ( 0..5 );
{ local($ary[5]) = 6; local($hash{&rsquo;a&rsquo;}) =
&rsquo;drill&rsquo;; while (my $e = pop(@ary)) { print
&quot;$e . . .0; last unless $e &gt; 3; } if (@ary) {
$hash{&rsquo;only a&rsquo;} = &rsquo;test&rsquo;; delete
$hash{&rsquo;a&rsquo;}; } } print join(&rsquo; &rsquo;, map
{ &quot;$_ $hash{$_}&quot; } sort keys %hash),&quot;.0;
print &quot;The array has &quot;,scalar(@ary),&quot;
elements: &quot;, join(&rsquo;, &rsquo;, map { defined $_ ?
$_ : &rsquo;undef&rsquo; } @ary),&quot;0;</p>

<p>Perl will print</p>

<p>6 . . . 4 . . . 3 . . . This is a test only a test. The
array has 6 elements: 0, 1, 2, undef, undef, 5</p>

<p>The behavior of local() on non-existent members of
composite types is subject to change in future.</p>

<p>Lvalue subroutines WARNING: Lvalue subroutines are still
experimental and the implementation may change in future
versions of Perl.</p>

<p>It is possible to return a modifiable value from a
subroutine. To do this, you have to declare the subroutine
to return an lvalue.</p>

<p>my $val; sub canmod : lvalue { # return $val; this
doesn&rsquo;t work, don&rsquo;t say &quot;return&quot; $val;
} sub nomod { $val; }</p>

<p>canmod() = 5; # assigns to $val nomod() = 5; # ERROR</p>

<p>The scalar/list context for the subroutine and for the
right-hand side of assignment is determined as if the
subroutine call is replaced by a scalar. For example,
consider:</p>

<p>data(2,3) = get_data(3,4);</p>

<p>Both subroutines here are called in a scalar context,
while in:</p>

<p>(data(2,3)) = get_data(3,4);</p>

<p>and in:</p>

<p>(data(2),data(3)) = get_data(3,4);</p>

<p>all the subroutines are called in a list context.</p>

<p>Lvalue subroutines are EXPERIMENTAL They appear to be
convenient, but there are several reasons to be
circumspect.</p>

<p>You cant use the return keyword, you must pass out the
value before falling out of subroutine scope. (see comment
in example above). This is usually not a problem, but it
disallows an explicit return out of a deeply nested loop,
which is sometimes a nice way out.</p>

<p>They violate encapsulation. A normal mutator can check
the supplied argument before setting the attribute it is
protecting, an lvalue subroutine never gets that chance.
Consider;</p>

<p>my $some_array_ref = []; # protected by mutators ??</p>

<p>sub set_arr { # normal mutator my $val = shift;
die(&quot;expected array, you supplied &quot;, ref $val)
unless ref $val eq &rsquo;ARRAY&rsquo;; $some_array_ref =
$val; } sub set_arr_lv : lvalue { # lvalue mutator
$some_array_ref; }</p>

<p># set_arr_lv cannot stop this ! set_arr_lv() = { a =&gt;
1 };</p>

<p>Passing Symbol Table Entries (typeglobs) WARNING: The
mechanism described in this section was originally the only
way to simulate pass-by-reference in older versions of Perl.
While it still works fine in modern versions, the new
reference mechanism is generally easier to work with. See
below.</p>

<p>Sometimes you dont want to pass the value of an array to
a subroutine but rather the name of it, so that the
subroutine can modify the global copy of it rather than
working with a local copy. In perl you can refer to all
objects of a particular name by prefixing the name with a
star: *foo. This is often known as a &quot;typeglob&quot;,
because the star on the front can be thought of as a
wildcard match for all the funny prefix characters on
variables and subroutines and such.</p>

<p>When evaluated, the typeglob produces a scalar value
that represents all the objects of that name, including any
filehandle, format, or subroutine. When assigned to, it
causes the name mentioned to refer to whatever &quot;*&quot;
value was assigned to it. Example:</p>

<p>sub doubleary { local(*someary) = @_; foreach $elem
(@someary) { $elem *= 2; } } doubleary(*foo);
doubleary(*bar);</p>

<p>Scalars are already passed by reference, so you can
modify scalar arguments without using this mechanism by
referring explicitly to $_[0] etc. You can modify all the
elements of an array by passing all the elements as scalars,
but you have to use the &quot;*&quot; mechanism (or the
equivalent reference mechanism) to &quot;push&quot;,
&quot;pop&quot;, or change the size of an array. It will
certainly be faster to pass the typeglob (or reference).</p>

<p>Even if you dont want to modify an array, this mechanism
is useful for passing multiple arrays in a single LIST,
because normally the LIST mechanism will merge all the array
values so that you cant extract out the individual arrays.
For more on typeglobs, see &quot;Typeglobs and
Filehandles&quot; in perldata.</p>

<p>When to Still Use local() Despite the existence of
&quot;my&quot;, there are still three places where the
&quot;local&quot; operator still shines. In fact, in these
three places, you must use &quot;local&quot; instead of
&quot;my&quot;.</p>

<p>1. You need to give a global variable a temporary value,
especially $_.</p>

<p>The global variables, like @ARGV or the punctuation
variables, must be &quot;local&quot;ized with
&quot;local()&quot;. This block reads in /etc/motd, and
splits it up into chunks separated by lines of equal signs,
which are placed in @Fields.</p>

<p>{ local @ARGV = (&quot;/etc/motd&quot;); local $/ =
undef; local $_ = &lt;&gt;; @Fields = split /^=+$/; }</p>

<p>It particular, its important to &quot;local&quot;ize $_
in any routine that assigns to it. Look out for implicit
assignments in &quot;while&quot; conditionals.</p>

<p>2. You need to create a local file or directory handle
or a local function.</p>

<p>A function that needs a filehandle of its own must use
&quot;local()&quot; on a complete typeglob. This can be used
to create new symbol table entries:</p>

<p>sub ioqueue { local (*READER, *WRITER); # not my! pipe
(READER, WRITER) or die &quot;pipe: $!&quot;; return
(*READER, *WRITER); } ($head, $tail) = ioqueue();</p>

<p>See the Symbol module for a way to create anonymous
symbol table entries.</p>

<p>Because assignment of a reference to a typeglob creates
an alias, this can be used to create what is effectively a
local function, or at least, a local alias.</p>

<p>{ local *grow = shrink; # only until this block exists
grow(); # really calls shrink() move(); # if move() grow()s,
it shrink()s too } grow(); # get the real grow() again</p>

<p>See &quot;Function Templates&quot; in perlref for more
about manipulating functions by name in this way.</p>

<p>3. You want to temporarily change just one element of an
array or hash.</p>

<p>You can &quot;local&quot;ize just one element of an
aggregate. Usually this is done on dynamics:</p>

<p>{ local $SIG{INT} = &rsquo;IGNORE&rsquo;; funct(); #
uninterruptible } # interruptibility automatically restored
here</p>

<p>But it also works on lexically declared aggregates.
Prior to 5.005, this operation could on occasion
misbehave.</p>

<p>Pass by Reference If you want to pass more than one
array or hash into a function--or return them from it--and
have them maintain their integrity, then you re going to
have to use an explicit pass-by-reference. Before you do
that, you need to understand references as detailed in
perlref. This section may not make much sense to you
otherwise.</p>

<p>Here are a few simple examples. First, lets pass in
several arrays to a function and have it &quot;pop&quot; all
of then, returning a new list of all their former last
elements:</p>

<p>@tailings = popmany ( @a, @b, @c, @d );</p>

<p>sub popmany { my $aref; my @retlist = (); foreach $aref
( @_ ) { push @retlist, pop @$aref; } return @retlist; }</p>

<p>Here s how you might write a function that returns a
list of keys occurring in all the hashes passed to it:</p>

<p>@common = inter( foo, bar, joe ); sub inter { my ($k,
$href, %seen); # locals foreach $href (@_) { while ( $k =
each %$href ) { $seen{$k}++; } } return grep { $seen{$_} ==
@_ } keys %seen; }</p>

<p>So far, were using just the normal list return
mechanism. What happens if you want to pass or return a
hash? Well, if youre using only one of them, or you don t
mind them concatenating, then the normal calling convention
is ok, although a little expensive.</p>

<p>Where people get into trouble is here:</p>

<p>(@a, @b) = func(@c, @d); or (%a, %b) = func(%c, %d);</p>

<p>That syntax simply wont work. It sets just @a or %a and
clears the @b or %b. Plus the function didn t get passed
into two separate arrays or hashes: it got one long list in
@_, as always.</p>

<p>If you can arrange for everyone to deal with this
through references, its cleaner code, although not so nice
to look at. Here s a function that takes two array
references as arguments, returning the two array elements in
order of how many elements they have in them:</p>

<p>($aref, $bref) = func(@c, @d); print &quot;@$aref has
more than @$bref0; sub func { my ($cref, $dref) = @_; if
(@$cref &gt; @$dref) { return ($cref, $dref); } else {
return ($dref, $cref); } }</p>

<p>It turns out that you can actually do this also:</p>

<p>(*a, *b) = func(@c, @d); print &quot;@a has more than
@b0; sub func { local (*c, *d) = @_; if (@c &gt; @d) {
return (@c, @d); } else { return (@d, @c); } }</p>

<p>Here were using the typeglobs to do symbol table
aliasing. Its a tad subtle, though, and also wont work if
youre using &quot;my&quot; variables, because only globals
(even in disguise as &quot;local&quot;s) are in the symbol
table.</p>

<p>If you re passing around filehandles, you could usually
just use the bare typeglob, like *STDOUT, but typeglobs
references work, too. For example:</p>

<p>splutter(TDOUT); sub splutter { my $fh = shift; print
$fh &quot;her um well a hmmm0; }</p>

<p>$rec = get_rec(TDIN); sub get_rec { my $fh = shift;
return scalar &lt;$fh&gt;; }</p>

<p>If youre planning on generating new filehandles, you
could do this. Notice to pass back just the bare *FH, not
its reference.</p>

<p>sub openit { my $path = shift; local *FH; return open
(FH, $path) ? *FH : undef; }</p>

<p>Prototypes Perl supports a very limited kind of
compile-time argument checking using function prototyping.
If you declare</p>

<p>sub mypush (@@)</p>

<p>then &quot;mypush()&quot; takes arguments exactly like
&quot;push()&quot; does. The function declaration must be
visible at compile time. The prototype affects only
interpretation of new-style calls to the function, where
new-style is defined as not using the &quot;&amp;&quot;
character. In other words, if you call it like a built-in
function, then it behaves like a built- in function. If you
call it like an old-fashioned subroutine, then it behaves
like an old-fashioned subroutine. It naturally falls out
from this rule that prototypes have no influence on
subroutine references like &quot;foo&quot; or on indirect
subroutine calls like &quot;&amp;{$subref}&quot; or
&quot;$subref-&gt;()&quot;.</p>

<p>Method calls are not influenced by prototypes either,
because the function to be called is indeterminate at
compile time, since the exact code called depends on
inheritance.</p>

<p>Because the intent of this feature is primarily to let
you define subroutines that work like built-in functions,
here are prototypes for some other functions that parse
almost exactly like the corresponding built-in.</p>

<p>Declared as Called as</p>

<p>sub mylink ($$) mylink $old, $new sub myvec ($$$) myvec
$var, $offset, 1 sub myindex ($$;$) myindex &amp;getstring,
&quot;substr&quot; sub mysyswrite ($$$;$) mysyswrite $buf,
0, length($buf) - $off, $off sub myreverse (@) myreverse $a,
$b, $c sub myjoin ($@) myjoin &quot;:&quot;, $a, $b, $c sub
mypop (@) mypop @array sub mysplice (@$$@) mysplice @array,
0, 2, @pushme sub mykeys () mykeys %{$hashref} sub myopen
(*;$) myopen HANDLE, $name sub mypipe (**) mypipe
READHANDLE, WRITEHANDLE sub mygrep (&amp;@) mygrep { /foo/ }
$a, $b, $c sub myrand (;$) myrand 42 sub mytime ()
mytime</p>

<p>Any backslashed prototype character represents an actual
argument that absolutely must start with that character. The
value passed as part of @_ will be a reference to the actual
argument given in the subroutine call, obtained by applying
&quot;</p>

<p>You can also backslash several argument types
simultaneously by using the &quot;&quot; notation:</p>

<p>sub myref ()</p>

<p>will allow calling myref() as</p>

<p>myref $var myref @array myref %hash myref &amp;sub myref
*glob</p>

<p>and the first argument of myref() will be a reference to
a scalar, an array, a hash, a code, or a glob.</p>

<p>Unbackslashed prototype characters have special
meanings. Any unbackslashed &quot;@&quot; or &quot;%&quot;
eats all remaining arguments, and forces list context. An
argument represented by &quot;$&quot; forces scalar context.
An &quot;&amp;&quot; requires an anonymous subroutine,
which, if passed as the first argument, does not require the
&quot;sub&quot; keyword or a subsequent comma.</p>

<p>A &quot;*&quot; allows the subroutine to accept a
bareword, constant, scalar expression, typeglob, or a
reference to a typeglob in that slot. The value will be
available to the subroutine either as a simple scalar, or
(in the latter two cases) as a reference to the typeglob. If
you wish to always convert such arguments to a typeglob
reference, use Symbol::qualify_to_ref() as follows:</p>

<p>use Symbol &rsquo;qualify_to_ref&rsquo;;</p>

<p>sub foo (*) { my $fh = qualify_to_ref(shift, caller);
... }</p>

<p>A semicolon (&quot;;&quot;) separates mandatory
arguments from optional arguments. It is redundant before
&quot;@&quot; or &quot;%&quot;, which gobble up everything
else.</p>

<p>As the last character of a prototype, or just before a
semicolon, you can use &quot;_&quot; in place of
&quot;$&quot;: if this argument is not provided, $_ will be
used instead.</p>

<p>Note how the last three examples in the table above are
treated specially by the parser. &quot;mygrep()&quot; is
parsed as a true list operator, &quot;myrand()&quot; is
parsed as a true unary operator with unary precedence the
same as &quot;rand()&quot;, and &quot;mytime()&quot; is
truly without arguments, just like &quot;time()&quot;. That
is, if you say</p>

<p>mytime +2;</p>

<p>youll get &quot;mytime() + 2&quot;, not mytime(2), which
is how it would be parsed without a prototype.</p>

<p>The interesting thing about &quot;&amp;&quot; is that
you can generate new syntax with it, provided its in the
initial position:</p>

<p>sub try (&amp;@) { my($try,$catch) = @_; eval {
&amp;$try }; if ($@) { local $_ = $@; &amp;$catch; } } sub
catch (&amp;) { $_[0] }</p>

<p>try { die &quot;phooey&quot;; } catch { /phooey/ and
print &quot;unphooey0; };</p>

<p>That prints &quot;unphooey&quot;. (Yes, there are still
unresolved issues having to do with visibility of @_. Im
ignoring that question for the moment. (But note that if we
make @_ lexically scoped, those anonymous subroutines can
act like closures... (Gee, is this sounding a little
Lispish? (Never mind.))))</p>

<p>And heres a reimplementation of the Perl
&quot;grep&quot; operator:</p>

<p>sub mygrep (&amp;@) { my $code = shift; my @result;
foreach $_ (@_) { push(@result, $_) if &amp;$code; }
@result; }</p>

<p>Some folks would prefer full alphanumeric prototypes.
Alphanumerics have been intentionally left out of prototypes
for the express purpose of someday in the future adding
named, formal parameters. The current mechanism s main goal
is to let module writers provide better diagnostics for
module users. Larry feels the notation quite understandable
to Perl programmers, and that it will not intrude greatly
upon the meat of the module, nor make it harder to read. The
line noise is visually encapsulated into a small pill that s
easy to swallow.</p>

<p>If you try to use an alphanumeric sequence in a
prototype you will generate an optional warning -
&quot;Illegal character in prototype...&quot;. Unfortunately
earlier versions of Perl allowed the prototype to be used as
long as its prefix was a valid prototype. The warning may be
upgraded to a fatal error in a future version of Perl once
the majority of offending code is fixed.</p>

<p>Its probably best to prototype new functions, not
retrofit prototyping into older ones. Thats because you must
be especially careful about silent impositions of differing
list versus scalar contexts. For example, if you decide that
a function should take just one parameter, like this:</p>

<p>sub func ($) { my $n = shift; print &quot;you gave me
$n0; }</p>

<p>and someone has been calling it with an array or
expression returning a list:</p>

<p>func(@foo); func( split /:/ );</p>

<p>Then youve just supplied an automatic &quot;scalar&quot;
in front of their argument, which can be more than a bit
surprising. The old @foo which used to hold one thing doesnt
get passed in. Instead, &quot;func()&quot; now gets passed
in a 1; that is, the number of elements in @foo. And the
&quot;split&quot; gets called in scalar context so it starts
scribbling on your @_ parameter list. Ouch!</p>

<p>This is all very powerful, of course, and should be used
only in moderation to make the world a better place.</p>

<p>Constant Functions Functions with a prototype of
&quot;()&quot; are potential candidates for inlining. If the
result after optimization and constant folding is either a
constant or a lexically-scoped scalar which has no other
references, then it will be used in place of function calls
made without &quot;&amp;&quot;. Calls made using
&quot;&amp;&quot; are never inlined. (See constant.pm for an
easy way to declare most constants.)</p>

<p>The following functions would all be inlined:</p>

<p>sub pi () { 3.14159 } # Not exact, but close. sub PI ()
{ 4 * atan2 1, 1 } # As good as it gets, # and it&rsquo;s
inlined, too! sub ST_DEV () { 0 } sub ST_INO () { 1 }</p>

<p>sub FLAG_FOO () { 1 &lt;&lt; 8 } sub FLAG_BAR () { 1
&lt;&lt; 9 } sub FLAG_MASK () { FLAG_FOO | FLAG_BAR }</p>

<p>sub OPT_BAZ () { not (0x1B58 &amp; FLAG_MASK) }</p>

<p>sub N () { int(OPT_BAZ) / 3 }</p>

<p>sub FOO_SET () { 1 if FLAG_MASK &amp; FLAG_FOO }</p>

<p>Be aware that these will not be inlined; as they contain
inner scopes, the constant folding doesn t reduce them to a
single constant:</p>

<p>sub foo_set () { if (FLAG_MASK &amp; FLAG_FOO) { 1 }
}</p>

<p>sub baz_val () { if (OPT_BAZ) { return 23; } else {
return 42; } }</p>

<p>If you redefine a subroutine that was eligible for
inlining, youll get a mandatory warning. (You can use this
warning to tell whether or not a particular subroutine is
considered constant.) The warning is considered severe
enough not to be optional because previously compiled
invocations of the function will still be using the old
value of the function. If you need to be able to redefine
the subroutine, you need to ensure that it isnt inlined,
either by dropping the &quot;()&quot; prototype (which
changes calling semantics, so beware) or by thwarting the
inlining mechanism in some other way, such as</p>

<p>sub not_inlined () { 23 if $]; }</p>

<p>Overriding Built-in Functions Many built-in functions
may be overridden, though this should be tried only
occasionally and for good reason. Typically this might be
done by a package attempting to emulate missing built-in
functionality on a non-Unix system.</p>

<p>Overriding may be done only by importing the name from a
module at compile time--ordinary predeclaration isn t good
enough. However, the &quot;use subs&quot; pragma lets you,
in effect, predeclare subs via the import syntax, and these
names may then override built-in ones:</p>

<p>use subs &rsquo;chdir&rsquo;, &rsquo;chroot&rsquo;,
&rsquo;chmod&rsquo;, &rsquo;chown&rsquo;; chdir $somewhere;
sub chdir { ... }</p>

<p>To unambiguously refer to the built-in form, precede the
built-in name with the special package qualifier
&quot;CORE::&quot;. For example, saying
&quot;CORE::open()&quot; always refers to the built-in
&quot;open()&quot;, even if the current package has imported
some other subroutine called &quot;&amp;open()&quot; from
elsewhere. Even though it looks like a regular function
call, it isn t: you can t take a reference to it, such as
the incorrect &quot;CORE::open&quot; might appear to
produce.</p>

<p>Library modules should not in general export built-in
names like &quot;open&quot; or &quot;chdir&quot; as part of
their default @EXPORT list, because these may sneak into
someone else s namespace and change the semantics
unexpectedly. Instead, if the module adds that name to
@EXPORT_OK, then it s possible for a user to import the name
explicitly, but not implicitly. That is, they could say</p>

<p>use Module &rsquo;open&rsquo;;</p>

<p>and it would import the &quot;open&quot; override. But
if they said</p>

<p>use Module;</p>

<p>they would get the default imports without
overrides.</p>

<p>The foregoing mechanism for overriding built-in is
restricted, quite deliberately, to the package that requests
the import. There is a second method that is sometimes
applicable when you wish to override a built-in everywhere,
without regard to namespace boundaries. This is achieved by
importing a sub into the special namespace
&quot;CORE::GLOBAL::&quot;. Here is an example that quite
brazenly replaces the &quot;glob&quot; operator with
something that understands regular expressions.</p>

<p>package REGlob; require Exporter; @ISA =
&rsquo;Exporter&rsquo;; @EXPORT_OK = &rsquo;glob&rsquo;;</p>

<p>sub import { my $pkg = shift; return unless @_; my $sym
= shift; my $where = ($sym =~ s/^GLOBAL_// ?
&rsquo;CORE::GLOBAL&rsquo; : caller(0));
$pkg-&gt;export($where, $sym, @_); }</p>

<p>sub glob { my $pat = shift; my @got; if (opendir my $d,
&rsquo;.&rsquo;) { @got = grep /$pat/, readdir $d; closedir
$d; } return @got; } 1;</p>

<p>And heres how it could be (ab)used:</p>

<p>#use REGlob &rsquo;GLOBAL_glob&rsquo;; # override glob()
in ALL namespaces package Foo; use REGlob
&rsquo;glob&rsquo;; # override glob() in Foo:: only print
for &lt;^[a-z_]+.pm; # show all pragmatic modules</p>

<p>The initial comment shows a contrived, even dangerous
example. By overriding &quot;glob&quot; globally, you would
be forcing the new (and subversive) behavior for the
&quot;glob&quot; operator for every namespace, without the
complete cognizance or cooperation of the modules that own
those namespaces. Naturally, this should be done with
extreme caution--if it must be done at all.</p>

<p>The &quot;REGlob&quot; example above does not implement
all the support needed to cleanly override perl s
&quot;glob&quot; operator. The built-in &quot;glob&quot; has
different behaviors depending on whether it appears in a
scalar or list context, but our &quot;REGlob&quot; doesn t.
Indeed, many perl built-in have such context sensitive
behaviors, and these must be adequately supported by a
properly written override. For a fully functional example of
overriding &quot;glob&quot;, study the implementation of
&quot;File::DosGlob&quot; in the standard library.</p>

<p>When you override a built-in, your replacement should be
consistent (if possible) with the built-in native syntax.
You can achieve this by using a suitable prototype. To get
the prototype of an overridable built-in, use the
&quot;prototype&quot; function with an argument of
&quot;CORE::builtin_name&quot; (see &quot;prototype&quot; in
perlfunc).</p>

<p>Note however that some built-ins cant have their syntax
expressed by a prototype (such as &quot;system&quot; or
&quot;chomp&quot;). If you override them you wont be able to
fully mimic their original syntax.</p>

<p>The built-ins &quot;do&quot;, &quot;require&quot; and
&quot;glob&quot; can also be overridden, but due to special
magic, their original syntax is preserved, and you dont have
to define a prototype for their replacements. (You cant
override the &quot;do BLOCK&quot; syntax, though).</p>

<p>&quot;require&quot; has special additional dark magic:
if you invoke your &quot;require&quot; replacement as
&quot;require Foo::Bar&quot;, it will actually receive the
argument &quot;Foo/Bar.pm&quot; in @_. See
&quot;require&quot; in perlfunc.</p>

<p>And, as youll have noticed from the previous example, if
you override &quot;glob&quot;, the &quot;&lt;*&gt;&quot;
glob operator is overridden as well.</p>

<p>In a similar fashion, overriding the
&quot;readline&quot; function also overrides the equivalent
I/O operator &quot;&lt;FILEHANDLE&gt;&quot;. Also,
overriding &quot;readpipe&quot; also overrides the operators
&quot;&lsquo;&lsquo;&quot; and &quot;qx//&quot;.</p>

<p>Finally, some built-ins (e.g. &quot;exists&quot; or
&quot;grep&quot;) cant be overridden.</p>

<p>Autoloading If you call a subroutine that is undefined,
you would ordinarily get an immediate, fatal error
complaining that the subroutine doesnt exist. (Likewise for
subroutines being used as methods, when the method doesnt
exist in any base class of the class s package.) However, if
an &quot;AUTOLOAD&quot; subroutine is defined in the package
or packages used to locate the original subroutine, then
that &quot;AUTOLOAD&quot; subroutine is called with the
arguments that would have been passed to the original
subroutine. The fully qualified name of the original
subroutine magically appears in the global $AUTOLOAD
variable of the same package as the &quot;AUTOLOAD&quot;
routine. The name is not passed as an ordinary argument
because, er, well, just because, thats why. (As an
exception, a method call to a nonexistent &quot;import&quot;
or &quot;unimport&quot; method is just skipped instead.)</p>

<p>Many &quot;AUTOLOAD&quot; routines load in a definition
for the requested subroutine using eval(), then execute that
subroutine using a special form of goto() that erases the
stack frame of the &quot;AUTOLOAD&quot; routine without a
trace. (See the source to the standard module documented in
AutoLoader, for example.) But an &quot;AUTOLOAD&quot;
routine can also just emulate the routine and never define
it. For example, lets pretend that a function that wasn t
defined should just invoke &quot;system&quot; with those
arguments. All youd do is:</p>

<p>sub AUTOLOAD { my $program = $AUTOLOAD; $program =~
s/.*:://; system($program, @_); } date();
who(&rsquo;am&rsquo;, &rsquo;i&rsquo;);
ls(&rsquo;-l&rsquo;);</p>

<p>In fact, if you predeclare functions you want to call
that way, you dont even need parentheses:</p>

<p>use subs qw(date who ls); date; who &quot;am&quot;,
&quot;i&quot;; ls &rsquo;-l&rsquo;;</p>

<p>A more complete example of this is the standard Shell
module, which can treat undefined subroutine calls as calls
to external programs.</p>

<p>Mechanisms are available to help modules writers split
their modules into autoloadable files. See the standard
AutoLoader module described in AutoLoader and in AutoSplit,
the standard SelfLoader modules in SelfLoader, and the
document on adding C functions to Perl code in perlxs.</p>

<p>Subroutine Attributes A subroutine declaration or
definition may have a list of attributes associated with it.
If such an attribute list is present, it is broken up at
space or colon boundaries and treated as though a &quot;use
attributes&quot; had been seen. See attributes for details
about what attributes are currently supported. Unlike the
limitation with the obsolescent &quot;use attrs&quot;, the
&quot;sub : ATTRLIST&quot; syntax works to associate the
attributes with a pre-declaration, and not just with a
subroutine definition.</p>

<p>The attributes must be valid as simple identifier names
(without any punctuation other than the _ character). They
may have a parameter list appended, which is only checked
for whether its parentheses ((,)) nest properly.</p>

<p>Examples of valid syntax (even though the attributes are
unknown):</p>

<p>sub fnord (&amp;) : switch(10,foo(7,3)) : expensive; sub
plugh () : Ugly(&rsquo; :Bad; sub xyzzy : _5x5 { ... }</p>

<p>Examples of invalid syntax:</p>

<p>sub fnord : switch(10,foo(); # ()-string not balanced
sub snoid : Ugly(&rsquo;(&rsquo;); # ()-string not balanced
sub xyzzy : 5x5; # &quot;5x5&quot; not a valid identifier
sub plugh : Y2::north; # &quot;Y2::north&quot; not a simple
identifier sub snurt : foo + bar; # &quot;+&quot; not a
colon or space</p>

<p>The attribute list is passed as a list of constant
strings to the code which associates them with the
subroutine. In particular, the second example of valid
syntax above currently looks like this in terms of how its
parsed and invoked:</p>

<p>use attributes __PACKAGE__, plugh, q[Ugly(&rsquo;],
&rsquo;Bad&rsquo;;</p>

<p>For further details on attribute lists and their
manipulation, see attributes and Attribute::Handlers.</p>

<p>SEE ALSO See &quot;Function Templates&quot; in perlref
for more about references and closures. See perlxs if youd
like to learn about calling C subroutines from Perl. See
perlembed if you d like to learn about calling Perl
subroutines from C. See perlmod to learn about bundling up
your functions in separate files. See perlmodlib to learn
what library modules come standard on your system. See
perltoot to learn how to make object method calls.</p>

<p>perl v5.10.1 2009-02-12 PERLSUB(1)</p>
<hr>
</body>
</html>
