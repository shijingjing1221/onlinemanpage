<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:36:09 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>std::bitset(3) std::bitset(3)</p>

<p>NAME std::bitset -</p>

<p>The bitset class represents a fixed-size sequence of
bits.</p>

<p>SYNOPSIS Inherits _Base_bitset&lt;((_Nb)&lt;
1?0:((_Nb)+(__CHAR_BIT__ *sizeof(unsigned
long))-1)/(__CHAR_BIT__ *sizeof(unsigned long)))&gt;.</p>

<p>Classes class reference</p>

<p>Public Member Functions size_t _Find_first () const
size_t _Find_next (size_t __prev) const template&lt;class
_CharT , class _Traits &gt; void _M_copy_from_ptr (const
_CharT *, size_t, size_t, size_t, _CharT, _CharT)
template&lt;class _CharT , class _Traits , class _Alloc &gt;
void _M_copy_from_string (const std::basic_string&lt;
_CharT, _Traits, _Alloc &gt; &amp;__s, size_t __pos, size_t
__n) template&lt;class _CharT , class _Traits , class _Alloc
&gt; void _M_copy_from_string (const std::basic_string&lt;
_CharT, _Traits, _Alloc &gt; &amp;__s, size_t __pos, size_t
__n, _CharT __zero, _CharT __one) template&lt;class _CharT ,
class _Traits , class _Alloc &gt; void _M_copy_to_string
(std::basic_string&lt; _CharT, _Traits, _Alloc &gt;
&amp;__s) const template&lt;class _CharT , class _Traits ,
class _Alloc &gt; void _M_copy_to_string
(std::basic_string&lt; _CharT, _Traits, _Alloc &gt; &amp;,
_CharT, _CharT) const bool all () const bool any () const
template&lt;class _CharT , class _Traits , class _Alloc &gt;
bitset (const std::basic_string&lt; _CharT, _Traits, _Alloc
&gt; &amp;__s, size_t __position, size_t __n, _CharT __zero,
_CharT __one=_CharT(1)) template&lt;class _CharT , class
_Traits , class _Alloc &gt; bitset (const
std::basic_string&lt; _CharT, _Traits, _Alloc &gt; &amp;__s,
size_t __position, size_t __n) template&lt;class _CharT ,
class _Traits , class _Alloc &gt; bitset (const
std::basic_string&lt; _CharT, _Traits, _Alloc &gt; &amp;__s,
size_t __position=0) bitset (unsigned long __val) bitset ()
size_t count () const bitset&lt; _Nb &gt; &amp; flip (size_t
__position) bitset&lt; _Nb &gt; &amp; flip () bool none ()
const bitset&lt; _Nb &gt; operator~ () const bitset&lt; _Nb
&gt; &amp; reset (size_t __position) bitset&lt; _Nb &gt;
&amp; reset () bitset&lt; _Nb &gt; &amp; set (size_t
__position, bool __val=true) bitset&lt; _Nb &gt; &amp; set
() size_t size () const bool test (size_t __position) const
std::basic_string&lt; char, std::char_traits&lt; char &gt;,
std::allocator&lt; char &gt; &gt; to_string (char __zero,
char __one= 1) const std::basic_string&lt; char,
std::char_traits&lt; char &gt;, std::allocator&lt; char &gt;
&gt; to_string () const template&lt;class _CharT &gt;
std::basic_string&lt; _CharT, std::char_traits&lt; _CharT
&gt;, std::allocator&lt; _CharT &gt; &gt; to_string (_CharT
__zero, _CharT __one=_CharT(1)) const template&lt;class
_CharT &gt; std::basic_string&lt; _CharT,
std::char_traits&lt; _CharT &gt;, std::allocator&lt; _CharT
&gt; &gt; to_string () const template&lt;class _CharT ,
class _Traits &gt; std::basic_string&lt; _CharT, _Traits,
std::allocator&lt; _CharT &gt; &gt; to_string (_CharT
__zero, _CharT __one=_CharT(1)) const template&lt;class
_CharT , class _Traits &gt; std::basic_string&lt; _CharT,
_Traits, std::allocator&lt; _CharT &gt; &gt; to_string ()
const template&lt;class _CharT , class _Traits , class
_Alloc &gt; std::basic_string&lt; _CharT, _Traits, _Alloc
&gt; to_string (_CharT __zero, _CharT __one=_CharT(1)) const
template&lt;class _CharT , class _Traits , class _Alloc &gt;
std::basic_string&lt; _CharT, _Traits, _Alloc &gt; to_string
() const unsigned long to_ulong () const</p>

<p>bitset&lt; _Nb &gt; &amp; _Unchecked_flip (size_t __pos)
bitset&lt; _Nb &gt; &amp; _Unchecked_reset (size_t __pos)
bitset&lt; _Nb &gt; &amp; _Unchecked_set (size_t __pos, int
__val) bitset&lt; _Nb &gt; &amp; _Unchecked_set (size_t
__pos) bool _Unchecked_test (size_t __pos) const bool
operator!= (const bitset&lt; _Nb &gt; &amp;__rhs) const
bitset&lt; _Nb &gt; &amp; operator&amp;= (const bitset&lt;
_Nb &gt; &amp;__rhs) bitset&lt; _Nb &gt; operator&lt;&lt;
(size_t __position) const bitset&lt; _Nb &gt; &amp;
operator&lt;&lt;= (size_t __position) bool operator== (const
bitset&lt; _Nb &gt; &amp;__rhs) const bitset&lt; _Nb &gt;
operator&gt;&gt; (size_t __position) const bitset&lt; _Nb
&gt; &amp; operator&gt;&gt;= (size_t __position) bool
operator[] (size_t __position) const reference operator[]
(size_t __position) bitset&lt; _Nb &gt; &amp; operator^=
(const bitset&lt; _Nb &gt; &amp;__rhs) bitset&lt; _Nb &gt;
&amp; operator|= (const bitset&lt; _Nb &gt; &amp;__rhs)</p>

<p>Private Types typedef unsigned long _WordT</p>

<p>Private Member Functions size_t _M_are_all_aux () const
void _M_do_and (const _Base_bitset&lt; _Nw &gt; &amp;__x)
size_t _M_do_count () const size_t _M_do_find_first (size_t
__not_found) const size_t _M_do_find_next (size_t __prev,
size_t __not_found) const void _M_do_flip () void
_M_do_left_shift (size_t __shift) void _M_do_or (const
_Base_bitset&lt; _Nw &gt; &amp;__x) void _M_do_reset () void
_M_do_right_shift (size_t __shift) void _M_do_set ()
unsigned long _M_do_to_ulong () const void _M_do_xor (const
_Base_bitset&lt; _Nw &gt; &amp;__x) _WordT _M_getword
(size_t __pos) const _WordT &amp; _M_getword (size_t __pos)
_WordT _M_hiword () const _WordT &amp; _M_hiword () bool
_M_is_any () const bool _M_is_equal (const _Base_bitset&lt;
_Nw &gt; &amp;__x) const</p>

<p>Static Private Member Functions static _WordT _S_maskbit
(size_t __pos) static size_t _S_whichbit (size_t __pos)
static size_t _S_whichbyte (size_t __pos) static size_t
_S_whichword (size_t __pos)</p>

<p>Private Attributes _WordT _M_w [_Nw]</p>

<p>Friends class reference</p>

<p>Detailed Description template&lt;size_t _Nb&gt; class
std::bitset&lt; _Nb &gt; The bitset class represents a
fixed-size sequence of bits.</p>

<p>(Note that bitset does not meet the formal requirements
of a container. Mainly, it lacks iterators.)</p>

<p>The template argument, Nb, may be any non-negative
number, specifying the number of bits (e.g., 0, 12,
1024*1024).</p>

<p>In the general unoptimized case, storage is allocated in
word-sized blocks. Let B be the number of bits in a word,
then (Nb+(B-1))/B words will be used for storage. B - NbB
bits are unused. (They are the high- order bits in the
highest word.) It is a class invariant that those unused
bits are always zero.</p>

<p>If you think of bitset as a simple array of bits, be
aware that your mental picture is reversed: a bitset behaves
the same way as bits in integers do, with the bit at index 0
in the least significant / right-hand position, and the bit
at index Nb-1 in the most significant / left-hand position.
Thus, unlike other containers, a bitsets index counts from
right to left, to put it very loosely.</p>

<p>This behavior is preserved when translating to and from
strings. For example, the first line of the following
program probably prints b(a) is 0001100001 on a modern ASCII
system.</p>

<p>#include &lt;bitset&gt; #include &lt;iostream&gt;
#include &lt;sstream&gt;</p>

<p>using namespace std;</p>

<p>int main() { long a = a; bitset&lt;10&gt; b(a);</p>

<p>cout &lt;&lt; b(a) is &lt;&lt; b &lt;&lt; endl;</p>

<p>ostringstream s; s &lt;&lt; b; string str = s.str();
cout &lt;&lt; index 3 in the string is &lt;&lt; str[3]
&lt;&lt; but0 &lt;&lt; index 3 in the bitset is &lt;&lt;
b[3] &lt;&lt; endl; }</p>

<p>Also see:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html
for a description of extensions.</p>

<p>Most of the actual code isnt contained in bitset&lt;&gt;
itself, but in the base class _Base_bitset. The base class
works with whole words, not with individual bits. This
allows us to specialize _Base_bitset for the important
special case where the bitset is only a single word.</p>

<p>Extra confusion can result due to the fact that the
storage for _Base_bitset is a regular array, and is indexed
as such. This is carefully encapsulated.</p>

<p>Definition at line 646 of file bitset.</p>

<p>Constructor &amp; Destructor Documentation
template&lt;size_t _Nb&gt; std::bitset&lt; _Nb &gt;::bitset
() [inline] All bits set to zero.</p>

<p>Definition at line 736 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; std::bitset&lt; _Nb
&gt;::bitset (unsigned long __val) [inline] Initial bits
bitwise-copied from a single word (others set to zero).</p>

<p>Definition at line 740 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; template&lt;class _CharT ,
class _Traits , class _Alloc &gt; std::bitset&lt; _Nb
&gt;::bitset (const std::basic_string&lt; _CharT, _Traits,
_Alloc &gt; &amp; __s, size_t __position = 0) [inline,
explicit] Use a subset of a string. Parameters: s A string
of 0 and 1 characters. position Index of the first character
in s to use; defaults to zero.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of s. std::invalid_argument If a character appears in the
string which is neither0nor.</p>

<p>Definition at line 755 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; template&lt;class _CharT ,
class _Traits , class _Alloc &gt; std::bitset&lt; _Nb
&gt;::bitset (const std::basic_string&lt; _CharT, _Traits,
_Alloc &gt; &amp; __s, size_t __position, size_t __n)
[inline] Use a subset of a string. Parameters: s A string of
0 and 1 characters. position Index of the first character in
s to use. n The number of characters to copy.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of s. std::invalid_argument If a character appears in the
string which is neither0nor.</p>

<p>Definition at line 777 of file bitset.</p>

<p>Member Function Documentation template&lt;size_t _Nb&gt;
bitset&lt;_Nb&gt;&amp; std::bitset&lt; _Nb
&gt;::_Unchecked_flip (size_t __pos) [inline] These versions
of single-bit set, reset, flip, and test are extensions from
the SGI version. They do no range checking. Definition at
line 896 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::_Unchecked_reset (size_t __pos)
[inline] These versions of single-bit set, reset, flip, and
test are extensions from the SGI version. They do no range
checking. Definition at line 889 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::_Unchecked_set (size_t __pos, int
__val) [inline] These versions of single-bit set, reset,
flip, and test are extensions from the SGI version. They do
no range checking. Definition at line 879 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::_Unchecked_test (size_t __pos) const [inline] These
versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range checking.
Definition at line 903 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::all () const [inline] Tests whether all the bits are
on. Returns: True if all the bits are set.</p>

<p>Definition at line 1170 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::any () const [inline] Tests whether any of the bits
are on. Returns: True if at least one bit is set.</p>

<p>Definition at line 1178 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; size_t std::bitset&lt; _Nb
&gt;::count () const [inline] Returns the number of bits
which are set.</p>

<p>Definition at line 1130 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::flip (size_t __position) [inline]
Toggles a given bit to its opposite value. Parameters:
position The index of the bit.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of the set.</p>

<p>Definition at line 976 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::flip () [inline] Toggles every bit
to its opposite value.</p>

<p>Definition at line 963 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::none () const [inline] Tests whether any of the bits
are on. Returns: True if none of the bits are set.</p>

<p>Definition at line 1186 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::operator!= (const bitset&lt; _Nb &gt; &amp; __rhs)
const [inline] These versions of single-bit set, reset,
flip, and test are extensions from the SGI version. They do
no range checking. Definition at line 1145 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::operator&amp;= (const bitset&lt;
_Nb &gt; &amp; __rhs) [inline] Operations on bitsets.
Parameters: rhs A same-sized bitset.</p>

<p>These should be self-explanatory.</p>

<p>Definition at line 810 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;
std::bitset&lt; _Nb &gt;::operator&lt;&lt; (size_t
__position) const [inline] Self-explanatory.</p>

<p>Definition at line 1192 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::operator&lt;&lt;= (size_t
__position) [inline] Operations on bitsets. Parameters:
position The number of places to shift.</p>

<p>These should be self-explanatory.</p>

<p>Definition at line 839 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::operator== (const bitset&lt; _Nb &gt; &amp; __rhs)
const [inline] These comparisons for equality/inequality
are, well, bitwise.</p>

<p>Definition at line 1141 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;
std::bitset&lt; _Nb &gt;::operator&gt;&gt; (size_t
__position) const [inline] These versions of single-bit set,
reset, flip, and test are extensions from the SGI version.
They do no range checking. Definition at line 1196 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::operator&gt;&gt;= (size_t
__position) [inline] These versions of single-bit set,
reset, flip, and test are extensions from the SGI version.
They do no range checking. Definition at line 852 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::operator[] (size_t __position) const [inline] These
versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range checking.
Definition at line 1008 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; reference std::bitset&lt; _Nb
&gt;::operator[] (size_t __position) [inline] Array-indexing
support. Parameters: position Index into the bitset.</p>

<p>Returns: A bool for a const bitset. For non-const
bitsets, an instance of the reference proxy class.</p>

<p>Note: These operators do no range checking and throw no
exceptions, as required by DR 11 to the standard.</p>

<p>_GLIBCXX_RESOLVE_LIB_DEFECTS Note that this
implementation already resolves DR 11 (items 1 and 2), but
does not do the range-checking required by that DRs
resolution. -pme The DR has since been changed:
range-checking is a precondition (users responsibility), and
these functions must not throw. -pme</p>

<p>Definition at line 1004 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::operator^= (const bitset&lt; _Nb
&gt; &amp; __rhs) [inline] These versions of single-bit set,
reset, flip, and test are extensions from the SGI version.
They do no range checking. Definition at line 824 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::operator|= (const bitset&lt; _Nb
&gt; &amp; __rhs) [inline] These versions of single-bit set,
reset, flip, and test are extensions from the SGI version.
They do no range checking. Definition at line 817 of file
bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;
std::bitset&lt; _Nb &gt;::operator~ () const [inline] See
the no-argument flip().</p>

<p>Definition at line 985 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::reset (size_t __position) [inline]
Sets a given bit to false. Parameters: position The index of
the bit.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of the set.</p>

<p>Same as writing set(pos,false).</p>

<p>Definition at line 952 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::reset () [inline] Sets every bit
to false.</p>

<p>Definition at line 938 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::set (size_t __position, bool __val
= true) [inline] Sets a given bit to a particular value.
Parameters: position The index of the bit. val Either true
or false, defaults to true.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of the set.</p>

<p>Definition at line 927 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bitset&lt;_Nb&gt;&amp;
std::bitset&lt; _Nb &gt;::set () [inline] Sets every bit to
true.</p>

<p>Definition at line 913 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; size_t std::bitset&lt; _Nb
&gt;::size () const [inline] Returns the total number of
bits.</p>

<p>Definition at line 1135 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; bool std::bitset&lt; _Nb
&gt;::test (size_t __position) const [inline] Tests the
value of a bit. Parameters: position The index of a bit.</p>

<p>Returns: The value at pos.</p>

<p>Exceptions: std::out_of_range If pos is bigger the size
of the set.</p>

<p>Definition at line 1156 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; template&lt;class _CharT ,
class _Traits , class _Alloc &gt;
std::basic_string&lt;_CharT, _Traits, _Alloc&gt;
std::bitset&lt; _Nb &gt;::to_string () const [inline]
Returns a character interpretation of the bitset. Returns:
The string equivalent of the bits.</p>

<p>Note the ordering of the bits: decreasing character
positions correspond to increasing bit positions (see the
main class notes for an example).</p>

<p>Definition at line 1032 of file bitset.</p>

<p>template&lt;size_t _Nb&gt; unsigned long std::bitset&lt;
_Nb &gt;::to_ulong () const [inline] Returns a numerical
interpretation of the bitset. Returns: The integral
equivalent of the bits.</p>

<p>Exceptions: std::overflow_error If there are too many
bits to be represented in an unsigned long.</p>

<p>Definition at line 1019 of file bitset.</p>

<p>Author Generated automatically by Doxygen for libstdc++
from the source code.</p>

<p>libstdc++ 1 Jun 2015 std::bitset(3)</p>
<hr>
</body>
</html>
