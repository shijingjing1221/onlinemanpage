<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:33:18 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>security_compute_av(3) SELinux API documentation
security_compute_av(3)</p>

<p>NAME security_compute_av, security_compute_av_flags,
security_compute_cre- ate, security_compute_relabel,
security_compute_member, security_com- pute_user,
security_get_initial_context - query the SELinux policy
database in the kernel.</p>

<p>SYNOPSIS #include &lt;selinux/selinux.h&gt;</p>

<p>#include &lt;selinux/flask.h&gt;</p>

<p>int security_compute_av(security_context_t scon,
security_context_t tcon, security_class_t tclass,
access_vector_t requested, struct av_decision *avd);</p>

<p>int security_compute_av_flags(security_context_t scon,
security_con- text_t tcon, security_class_t tclass,
access_vector_t requested, struct av_decision *avd);</p>

<p>int security_compute_create(security_context_t scon,
security_context_t tcon, security_class_t tclass,
security_context_t *newcon);</p>

<p>int security_compute_relabel(security_context_t scon,
security_con- text_t tcon, security_class_t tclass,
security_context_t *newcon);</p>

<p>int security_compute_member(security_context_t scon,
security_context_t tcon, security_class_t tclass,
security_context_t *newcon);</p>

<p>int security_compute_user(security_context_t scon, const
char *user- name, security_context_t **con);</p>

<p>int security_get_initial_context(const char *name,
security_context_t *con);</p>

<p>int selinux_check_passwd_access(access_vector_t
requested);</p>

<p>int checkPasswdAccess(access_vector_t requested);</p>

<p>DESCRIPTION security_compute_av queries whether the
policy permits the source con- text scon to access the
target context tcon via class tclass with the requested
access vector. The decision is returned in avd.</p>

<p>security_compute_av_flags is identical to
security_compute_av but addi- tionally sets the flags field
of avd. Currently one flag is supported:
SELINUX_AVD_FLAGS_PERMISSIVE, which indicates the decision
is computed on a permissive domain.</p>

<p>security_compute_create is used to compute a context to
use for label- ing a new object in a particular class based
on a SID pair.</p>

<p>security_compute_relabel is used to compute the new
context to use when relabeling an object, it is used in the
pam_selinux.so source and the newrole source to determine
the correct label for the tty at login time, but can be used
for other things.</p>

<p>security_compute_member is used to compute the context
to use when labeling a polyinstantiated object instance.</p>

<p>security_compute_user is used to determine the set of
user contexts that can be reached from a source context. It
is mainly used by get_ordered_context_list.</p>

<p>security_get_initial_context is used to get the context
of a kernel initial security identifier specified by
name</p>

<p>selinux_check_passwd_access is used to check for a
permission in the passwd class. selinux_check_passwd_access
uses getprevcon() for the source and target security
contexts.</p>

<p>checkPasswdAccess is a deprecated alias of the
selinux_check_passwd_access function.</p>

<p>RETURN VALUE Returns zero on success or -1 on error.</p>

<p>SEE ALSO selinux(8), getcon(3), getfilecon(3),
get_ordered_context_list(3)</p>

<p>russell@coker.com.au 1 January 2004
security_compute_av(3)</p>
<hr>
</body>
</html>
