<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:47:42 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>XmRedisplayWidget(library call)
XmRedisplayWidget(library call)</p>

<p>NAME XmRedisplayWidget Synchronously activates the
expose method of a wid- get to draw its content</p>

<p>SYNOPSIS #include &lt;Xm/Xm.h&gt; voidXmRedisplayWidget(
Widgetwidget);</p>

<p>DESCRIPTION This function is a convenience routine that
hides the details of the Xt internals to the application
programmer by calling the expose method of the given widget
with a well formed Expose event and Region correspond- ing
to the total area of the widget. If the widget doesnt have
an Expose method, the function does nothing.</p>

<p>This is primarily used in the context of X Printing if
the programming model chosen by the application is
synchronous; that is, it doesnt rely of X Print events for
the driving of page layout but wants to com- pletely control
the sequence of rendering requests.</p>

<p>XmRedisplayWidget doesnt clear the widget window prior
to calling the expose method, since this is handled by calls
to XpStartPage .</p>

<p>widget The widget to redisplay.</p>

<p>RETURN VALUE None.</p>

<p>ERRORS/WARNINGS Not applicable</p>

<p>EXAMPLES In the following, a simple application wants to
print the content of a multi-page text widget (similar to
dtpad).</p>

<p>PrintOKCallback(print_dialog...) /*-------------*/ {
pshell = XmPrintSetup (print_dialog, pbs-&gt;print_screen,
&quot;Print&quot;, NULL, 0);</p>

<p>XpStartJob(XtDisplay(pshell), XPSpool);</p>

<p>/**** here I realize the shell, get its size, create my
widget hierarchy: a bulletin board, and then a text widget,
that I stuff with the video text widget buffer */</p>

<p>/* get the total number of pages to print */
XtVaGetValues(ptext, XmNrows, &amp;prows, XmNtotalLines,
n_lines, NULL); n_pages = n_lines / prows;</p>

<p>/***** now print the pages in a loop */</p>

<p>for (cur_page=0; cur_page != n_pages; cur_page++) {</p>

<p>XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
XmRedisplayWidget(ptext); /* do the drawing */
XpEndPage(XtDisplay(pshell));</p>

<p>XmTextScroll(ptext, prows); /* get ready for next page
*/ }</p>

<p>/***** Im done */ XpEndJob(XtDisplay(pshell));</p>

<p>}</p>

<p>Of course, one could change the above code to include it
in a fork() branch so that the main program is not blocked
while printing is going on. Another way to achieve a
&quot;print-in-the-background&quot; effect is to use an Xt
workproc. Using the same sample application, that gives
us:</p>

<p>Boolean PrintOnePageWP(XtPointer npages) /* workproc */
/*-------------*/ { static int cur_page = 0; cur_page++;</p>

<p>XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
XmRedisplayWidget(ptext); /* do the drawing */
XpEndPage(XtDisplay(pshell));</p>

<p>XmTextScroll(ptext, prows); /* get ready for next page
*/</p>

<p>if (cur_page == n_pages) { /***** Im done */
XpEndJob(XtDisplay(pshell));</p>

<p>XtDestroyWidget(pshell);
XtCloseDisplay(XtDisplay(pshell)); }</p>

<p>return (cur_page == n_pages); }</p>

<p>PrintOKCallback(...) /*-------------*/ { pshell =
XmPrintSetup (widget, pbs-&gt;print_screen,
&quot;Print&quot;, NULL, 0);</p>

<p>XpStartJob(XtDisplay(pshell), XPSpool);</p>

<p>/**** here I get the size of the shell, create my widget
hierarchy: a bulletin board, and then a text widget, that I
stuff with the video text widget buffer */</p>

<p>/* get the total number of pages to print */ /* ... same
code as above example */</p>

<p>/***** print the pages in the background */
XtAppAddWorkProc(app_context, PrintOnePageWP, n_pages);
}</p>

<p>SEE ALSO XmPrintSetup(3), XmPrintShell(3)</p>

<p>XmRedisplayWidget(library call)</p>
<hr>
</body>
</html>
