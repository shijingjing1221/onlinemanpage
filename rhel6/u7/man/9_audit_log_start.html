<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:05:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>AUDIT_LOG_START(9) Audit Interfaces
AUDIT_LOG_START(9)</p>

<p>NAME audit_log_start - obtain an audit buffer</p>

<p>SYNOPSIS struct audit_buffer * audit_log_start(struct
audit_context * ctx, gfp_t gfp_mask, int type);</p>

<p>ARGUMENTS ctx audit_context (may be NULL)</p>

<p>gfp_mask type of allocation</p>

<p>type audit message type</p>

<p>DESCRIPTION Returns audit_buffer pointer on success or
NULL on error.</p>

<p>Obtain an audit buffer. This routine does locking to
obtain the audit buffer, but then no locking is required for
calls to audit_log_*format. If the task (ctx) is a task that
is currently in a syscall, then the syscall is marked as
auditable and an audit record will be written at syscall
exit. If there is no associated task, then task context
(ctx) should be NULL.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015
AUDIT_LOG_START(9)</p>
<hr>
</body>
</html>
