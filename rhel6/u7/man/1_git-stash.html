<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-STASH(1) Git Manual GIT-STASH(1)</p>

<p>NAME git-stash - Stash the changes in a dirty working
directory away</p>

<p>SYNOPSIS git stash list [&lt;options&gt;] git stash show
[&lt;stash&gt;] git stash drop [-q|--quiet] [&lt;stash&gt;]
git stash ( pop | apply ) [--index] [-q|--quiet]
[&lt;stash&gt;] git stash branch &lt;branchname&gt;
[&lt;stash&gt;] git stash [save [--patch]
[-k|--[no-]keep-index] [-q|--quiet] [&lt;message&gt;]] git
stash clear git stash create</p>

<p>DESCRIPTION Use git stash when you want to record the
current state of the working directory and the index, but
want to go back to a clean working directory. The command
saves your local modifications away and reverts the working
directory to match the HEAD commit.</p>

<p>The modifications stashed away by this command can be
listed with git stash list, inspected with git stash show,
and restored (potentially on top of a different commit) with
git stash apply. Calling git stash without any arguments is
equivalent to git stash save. A stash is by default listed
as &quot;WIP on branchname ...&quot;, but you can give a
more descriptive message on the command line when you create
one.</p>

<p>The latest stash you created is stored in refs/stash;
older stashes are found in the reflog of this reference and
can be named using the usual reflog syntax (e.g. stash@{0}
is the most recently created stash, stash@{1} is the one
before it, stash@{2.hours.ago} is also possible).</p>

<p>OPTIONS save [--patch] [--[no-]keep-index] [-q|--quiet]
[&lt;message&gt;] Save your local modifications to a new
stash, and run git reset --hard to revert them. The
&lt;message&gt; part is optional and gives the description
along with the stashed state. For quickly making a snapshot,
you can omit both &quot;save&quot; and &lt;message&gt;, but
giving only &lt;message&gt; does not trigger this action to
prevent a misspelled subcommand from making an unwanted
stash.</p>

<p>If the --keep-index option is used, all changes already
added to the index are left intact.</p>

<p>With --patch, you can interactively select hunks from in
the diff between HEAD and the working tree to be stashed.
The stash entry is constructed such that its index state is
the same as the index state of your repository, and its
worktree contains only the changes you selected
interactively. The selected changes are then rolled back
from your worktree.</p>

<p>The --patch option implies --keep-index. You can use
--no-keep-index to override this.</p>

<p>list [&lt;options&gt;] List the stashes that you
currently have. Each stash is listed with its name (e.g.
stash@{0} is the latest stash, stash@{1} is the one before,
etc.), the name of the branch that was current when the
stash was made, and a short description of the commit the
stash was based on.</p>

<p>stash@{0}: WIP on submit: 6ebd0e2... Update git-stash
documentation stash@{1}: On master: 9cc0589... Add
git-stash</p>

<p>The command takes options applicable to the git log
command to control what is shown and how. See
git-log(1).</p>

<p>show [&lt;stash&gt;] Show the changes recorded in the
stash as a diff between the stashed state and its original
parent. When no &lt;stash&gt; is given, shows the latest
one. By default, the command shows the diffstat, but it will
accept any format known to git diff (e.g., git stash show -p
stash@{1} to view the second most recent stash in patch
form).</p>

<p>pop [--index] [-q|--quiet] [&lt;stash&gt;] Remove a
single stashed state from the stash list and apply it on top
of the current working tree state, i.e., do the inverse
operation of git stash save. The working directory must
match the index.</p>

<p>Applying the state can fail with conflicts; in this
case, it is not removed from the stash list. You need to
resolve the conflicts by hand and call git stash drop
manually afterwards.</p>

<p>If the --index option is used, then tries to reinstate
not only the working tree s changes, but also the indexs
ones. However, this can fail, when you have conflicts (which
are stored in the index, where you therefore can no longer
apply the changes as they were originally).</p>

<p>When no &lt;stash&gt; is given, stash@{0} is
assumed.</p>

<p>apply [--index] [-q|--quiet] [&lt;stash&gt;] Like pop,
but do not remove the state from the stash list.</p>

<p>branch &lt;branchname&gt; [&lt;stash&gt;] Creates and
checks out a new branch named &lt;branchname&gt; starting
from the commit at which the &lt;stash&gt; was originally
created, applies the changes recorded in &lt;stash&gt; to
the new working tree and index, then drops the &lt;stash&gt;
if that completes successfully. When no &lt;stash&gt; is
given, applies the latest one.</p>

<p>This is useful if the branch on which you ran git stash
save has changed enough that git stash apply fails due to
conflicts. Since the stash is applied on top of the commit
that was HEAD at the time git stash was run, it restores the
originally stashed state with no conflicts.</p>

<p>clear Remove all the stashed states. Note that those
states will then be subject to pruning, and may be
impossible to recover (see Examples below for a possible
strategy).</p>

<p>drop [-q|--quiet] [&lt;stash&gt;] Remove a single
stashed state from the stash list. When no &lt;stash&gt; is
given, it removes the latest one. i.e. stash@{0}</p>

<p>create Create a stash (which is a regular commit object)
and return its object name, without storing it anywhere in
the ref namespace.</p>

<p>DISCUSSION A stash is represented as a commit whose tree
records the state of the working directory, and its first
parent is the commit at HEAD when the stash was created. The
tree of the second parent records the state of the index
when the stash is made, and it is made a child of the HEAD
commit. The ancestry graph looks like this:</p>

<p>.----W / / -----H----I</p>

<p>where H is the HEAD commit, I is a commit that records
the state of the index, and W is a commit that records the
state of the working tree.</p>

<p>EXAMPLES Pulling into a dirty tree When you are in the
middle of something, you learn that there are upstream
changes that are possibly relevant to what you are doing.
When your local changes do not conflict with the changes in
the upstream, a simple git pull will let you move
forward.</p>

<p>However, there are cases in which your local changes do
conflict with the upstream changes, and git pull refuses to
overwrite your changes. In such a case, you can stash your
changes away, perform a pull, and then unstash, like
this:</p>

<p>$ git pull ... file foobar not up to date, cannot merge.
$ git stash $ git pull $ git stash pop</p>

<p>Interrupted workflow When you are in the middle of
something, your boss comes in and demands that you fix
something immediately. Traditionally, you would make a
commit to a temporary branch to store your changes away, and
return to your original branch to make the emergency fix,
like this:</p>

<p># ... hack hack hack ... $ git checkout -b my_wip $ git
commit -a -m &quot;WIP&quot; $ git checkout master $ edit
emergency fix $ git commit -a -m &quot;Fix in a hurry&quot;
$ git checkout my_wip $ git reset --soft HEAD^ # ...
continue hacking ...</p>

<p>You can use git stash to simplify the above, like
this:</p>

<p># ... hack hack hack ... $ git stash $ edit emergency
fix $ git commit -a -m &quot;Fix in a hurry&quot; $ git
stash pop # ... continue hacking ...</p>

<p>Testing partial commits You can use git stash save
--keep-index when you want to make two or more commits out
of the changes in the work tree, and you want to test each
change before committing:</p>

<p># ... hack hack hack ... $ git add --patch foo # add
just first part to the index $ git stash save --keep-index #
save all other changes to the stash $ edit/build/test first
part $ git commit -m &acute;First part&acute; # commit fully
tested change $ git stash pop # prepare to work on all other
changes # ... repeat above five steps until one commit
remains ... $ edit/build/test remaining parts $ git commit
foo -m &acute;Remaining parts&acute;</p>

<p>Recovering stashes that were cleared/dropped erroneously
If you mistakenly drop or clear stashes, they cannot be
recovered through the normal safety mechanisms. However, you
can try the following incantation to get a list of stashes
that are still in your repository, but not reachable any
more:</p>

<p>git fsck --unreachable | grep commit | cut -d -f3 |
xargs git log --merges --no-walk --grep=WIP</p>

<p>SEE ALSO git-checkout(1), git-commit(1), git-reflog(1),
git-reset(1)</p>

<p>AUTHOR Written by Nanako Shiraishi
&lt;nanako3@bluebottle.com[1]&gt;</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. nanako3@bluebottle.com
mailto:nanako3@bluebottle.com</p>

<p>Git 1.7.1 02/26/2013 GIT-STASH(1)</p>
<hr>
</body>
</html>
