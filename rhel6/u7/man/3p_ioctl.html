<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IOCTL(3P) POSIX Programmer s Manual IOCTL(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME ioctl - control a STREAMS device (STREAMS)</p>

<p>SYNOPSIS #include &lt;stropts.h&gt;</p>

<p>int ioctl(int fildes, int request, ... /* arg */);</p>

<p>DESCRIPTION The ioctl() function shall perform a variety
of control functions on STREAMS devices. For non-STREAMS
devices, the functions performed by this call are
unspecified. The request argument and an optional third
argument (with varying type) shall be passed to and
interpreted by the appropriate part of the STREAM associated
with fildes.</p>

<p>The fildes argument is an open file descriptor that
refers to a device.</p>

<p>The request argument selects the control function to be
performed and shall depend on the STREAMS device being
addressed.</p>

<p>The arg argument represents additional information that
is needed by this specific STREAMS device to perform the
requested function. The type of arg depends upon the
particular control request, but it shall be either an
integer or a pointer to a device-specific data
structure.</p>

<p>The ioctl() commands applicable to STREAMS, their
arguments, and error conditions that apply to each
individual command are described below.</p>

<p>The following ioctl() commands, with error values
indicated, are appli- cable to all STREAMS files:</p>

<p>I_PUSH Pushes the module whose name is pointed to by arg
onto the top of the current STREAM, just below the STREAM
head. It then calls the open() function of the newly-pushed
module.</p>

<p>The ioctl() function with the I_PUSH command shall fail
if:</p>

<p>EINVAL Invalid module name.</p>

<p>ENXIO Open function of new module failed.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>I_POP Removes the module just below the STREAM head of
the STREAM pointed to by fildes. The arg argument should be
0 in an I_POP request.</p>

<p>The ioctl() function with the I_POP command shall fail
if:</p>

<p>EINVAL No module present in the STREAM.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>I_LOOK Retrieves the name of the module just below the
STREAM head of the STREAM pointed to by fildes, and places
it in a character string pointed to by arg. The buffer
pointed to by arg should be at least FMNAMESZ+1 bytes long,
where FMNAMESZ is defined in &lt;stropts.h&gt;.</p>

<p>The ioctl() function with the I_LOOK command shall fail
if:</p>

<p>EINVAL No module present in the STREAM.</p>

<p>I_FLUSH Flushes read and/or write queues, depending on
the value of arg. Valid arg values are:</p>

<p>FLUSHR Flush all read queues.</p>

<p>FLUSHW Flush all write queues.</p>

<p>FLUSHRW Flush all read and all write queues.</p>

<p>The ioctl() function with the I_FLUSH command shall fail
if:</p>

<p>EINVAL Invalid arg value.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate buffers for flush message.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>I_FLUSHBAND Flushes a particular band of messages. The
arg argument points to a bandinfo structure. The bi_flag
member may be one of FLUSHR, FLUSHW, or FLUSHRW as described
above. The bi_pri member determines the priority band to be
flushed.</p>

<p>I_SETSIG Requests that the STREAMS implementation send
the SIGPOLL signal to the calling process when a particular
event has occurred on the STREAM associated with fildes.
I_SETSIG supports an asyn- chronous processing capability in
STREAMS. The value of arg is a bitmask that specifies the
events for which the process should be signaled. It is the
bitwise-inclusive OR of any combination of the following
constants:</p>

<p>S_RDNORM A normal (priority band set to 0) message has
arrived at the head of a STREAM head read queue. A signal
shall be generated even if the message is of zero
length.</p>

<p>S_RDBAND A message with a non-zero priority band has
arrived at the head of a STREAM head read queue. A signal
shall be generated even if the message is of zero
length.</p>

<p>S_INPUT A message, other than a high-priority message,
has arrived at the head of a STREAM head read queue. A
signal shall be gener- ated even if the message is of zero
length.</p>

<p>S_HIPRI A high-priority message is present on a STREAM
head read queue. A signal shall be generated even if the
message is of zero length.</p>

<p>S_OUTPUT The write queue for normal data (priority band
0) just below the STREAM head is no longer full. This
notifies the process that there is room on the queue for
sending (or writing) normal data downstream.</p>

<p>S_WRNORM Equivalent to S_OUTPUT.</p>

<p>S_WRBAND The write queue for a non-zero priority band
just below the STREAM head is no longer full. This notifies
the process that there is room on the queue for sending (or
writing) priority data downstream.</p>

<p>S_MSG A STREAMS signal message that contains the SIGPOLL
signal has reached the front of the STREAM head read
queue.</p>

<p>S_ERROR Notification of an error condition has reached
the STREAM head.</p>

<p>S_HANGUP Notification of a hangup has reached the STREAM
head.</p>

<p>S_BANDURG When used in conjunction with S_RDBAND, SIGURG
is generated instead of SIGPOLL when a priority message
reaches the front of the STREAM head read queue.</p>

<p>If arg is 0, the calling process shall be unregistered
and shall not receive further SIGPOLL signals for the stream
associated with fildes.</p>

<p>Processes that wish to receive SIGPOLL signals shall
ensure that they explicitly register to receive them using
I_SETSIG. If several pro- cesses register to receive this
signal for the same event on the same STREAM, each process
shall be signaled when the event occurs.</p>

<p>The ioctl() function with the I_SETSIG command shall
fail if:</p>

<p>EINVAL The value of arg is invalid.</p>

<p>EINVAL The value of arg is 0 and the calling process is
not registered to receive the SIGPOLL signal.</p>

<p>EAGAIN There were insufficient resources to store the
signal request.</p>

<p>I_GETSIG Returns the events for which the calling
process is currently registered to be sent a SIGPOLL signal.
The events are returned as a bitmask in an int pointed to by
arg, where the events are those specified in the description
of I_SETSIG above.</p>

<p>The ioctl() function with the I_GETSIG command shall
fail if:</p>

<p>EINVAL Process is not registered to receive the SIGPOLL
signal.</p>

<p>I_FIND Compares the names of all modules currently
present in the STREAM to the name pointed to by arg, and
returns 1 if the named module is present in the STREAM, or
returns 0 if the named mod- ule is not present.</p>

<p>The ioctl() function with the I_FIND command shall fail
if:</p>

<p>EINVAL arg does not contain a valid module name.</p>

<p>I_PEEK Retrieves the information in the first message on
the STREAM head read queue without taking the message off
the queue. It is analogous to getmsg() except that this
command does not remove the message from the queue. The arg
argument points to a strpeek structure.</p>

<p>The application shall ensure that the maxlen member in
the ctlbuf and databuf strbuf structures is set to the
number of bytes of control information and/or data
information, respectively, to retrieve. The flags member may
be marked RS_HIPRI or 0, as described by getmsg(). If the
process sets flags to RS_HIPRI, for example, I_PEEK shall
only look for a high-priority message on the STREAM head
read queue.</p>

<p>I_PEEK returns 1 if a message was retrieved, and returns
0 if no mes- sage was found on the STREAM head read queue,
or if the RS_HIPRI flag was set in flags and a high-priority
message was not present on the STREAM head read queue. It
does not wait for a message to arrive. On return, ctlbuf
specifies information in the control buffer, databuf
specifies information in the data buffer, and flags contains
the value RS_HIPRI or 0.</p>

<p>I_SRDOPT Sets the read mode using the value of the
argument arg. Read modes are described in read(). Valid arg
flags are:</p>

<p>RNORM Byte-stream mode, the default.</p>

<p>RMSGD Message-discard mode.</p>

<p>RMSGN Message-nondiscard mode.</p>

<p>The bitwise-inclusive OR of RMSGD and RMSGN shall return
[EINVAL]. The bitwise-inclusive OR of RNORM and either RMSGD
or RMSGN shall result in the other flag overriding RNORM
which is the default.</p>

<p>In addition, treatment of control messages by the STREAM
head may be changed by setting any of the following flags in
arg:</p>

<p>RPROTNORM Fail read() with [EBADMSG] if a message
containing a control part is at the front of the STREAM head
read queue.</p>

<p>RPROTDAT Deliver the control part of a message as data
when a process issues a read().</p>

<p>RPROTDIS Discard the control part of a message,
delivering any data por- tion, when a process issues a
read().</p>

<p>The ioctl() function with the I_SRDOPT command shall
fail if:</p>

<p>EINVAL The arg argument is not valid.</p>

<p>I_GRDOPT Returns the current read mode setting, as
described above, in an int pointed to by the argument arg.
Read modes are described in read().</p>

<p>I_NREAD Counts the number of data bytes in the data part
of the first message on the STREAM head read queue and
places this value in the int pointed to by arg. The return
value for the command shall be the number of messages on the
STREAM head read queue. For example, if 0 is returned in
arg, but the ioctl() return value is greater than 0, this
indicates that a zero-length mes- sage is next on the
queue.</p>

<p>I_FDINSERT Creates a message from specified buffer(s),
adds information about another STREAM, and sends the message
downstream. The mes- sage contains a control part and an
optional data part. The data and control parts to be sent
are distinguished by placement in separate buffers, as
described below. The arg argument points to a strfdinsert
structure.</p>

<p>The application shall ensure that the len member in the
ctlbuf strbuf structure is set to the size of a t_uscalar_t
plus the number of bytes of control information to be sent
with the message. The fildes member specifies the file
descriptor of the other STREAM, and the offset mem- ber,
which must be suitably aligned for use as a t_uscalar_t,
specifies the offset from the start of the control buffer
where I_FDINSERT shall store a t_uscalar_t whose
interpretation is specific to the STREAM end. The
application shall ensure that the len member in the databuf
strbuf structure is set to the number of bytes of data
information to be sent with the message, or to 0 if no data
part is to be sent.</p>

<p>The flags member specifies the type of message to be
created. A normal message is created if flags is set to 0,
and a high-priority message is created if flags is set to
RS_HIPRI. For non-priority messages, I_FDINSERT shall block
if the STREAM write queue is full due to inter- nal flow
control conditions. For priority messages, I_FDINSERT does
not block on this condition. For non-priority messages,
I_FDINSERT does not block when the write queue is full and
O_NONBLOCK is set. Instead, it fails and sets errno to
[EAGAIN].</p>

<p>I_FDINSERT also blocks, unless prevented by lack of
internal resources, waiting for the availability of message
blocks in the STREAM, regard- less of priority or whether
O_NONBLOCK has been specified. No partial message is
sent.</p>

<p>The ioctl() function with the I_FDINSERT command shall
fail if:</p>

<p>EAGAIN A non-priority message is specified, the
O_NONBLOCK flag is set, and the STREAM write queue is full
due to internal flow control conditions.</p>

<p>EAGAIN or ENOSR</p>

<p>Buffers cannot be allocated for the message that is to
be created.</p>

<p>EINVAL One of the following:</p>

<p>* The fildes member of the strfdinsert structure is not
a valid, open STREAM file descriptor.</p>

<p>* The size of a t_uscalar_t plus offset is greater than
the len member for the buffer specified through ctl-
buf.</p>

<p>* The offset member does not specify a properly-aligned
location in the data buffer.</p>

<p>* An undefined value is stored in flags.</p>

<p>ENXIO Hangup received on the STREAM identified by either
the fildes argument or the fildes member of the strfdinsert
structure.</p>

<p>ERANGE The len member for the buffer specified through
databuf does not fall within the range specified by the
maximum and minimum packet sizes of the topmost STREAM
module; or the len member for the buffer specified through
databuf is larger than the maximum configured size of the
data part of a message; or the len member for the buffer
specified through ctlbuf is larger than the maxi- mum
configured size of the control part of a message.</p>

<p>I_STR Constructs an internal STREAMS ioctl() message
from the data pointed to by arg, and sends that message
downstream.</p>

<p>This mechanism is provided to send ioctl() requests to
downstream mod- ules and drivers. It allows information to
be sent with ioctl(), and returns to the process any
information sent upstream by the downstream recipient. I_STR
shall block until the system responds with either a positive
or negative acknowledgement message, or until the request
times out after some period of time. If the request times
out, it shall fail with errno set to [ETIME].</p>

<p>At most, one I_STR can be active on a STREAM. Further
I_STR calls shall block until the active I_STR completes at
the STREAM head. The default timeout interval for these
requests is 15 seconds. The O_NONBLOCK flag has no effect on
this call.</p>

<p>To send requests downstream, the application shall
ensure that arg points to a strioctl structure.</p>

<p>The ic_cmd member is the internal ioctl() command
intended for a down- stream module or driver and ic_timout
is the number of seconds (-1=infinite, 0=use
implementation-defined timeout interval, &gt;0=as specified)
an I_STR request shall wait for acknowledgement before tim-
ing out. ic_len is the number of bytes in the data argument,
and ic_dp is a pointer to the data argument. The ic_len
member has two uses: on input, it contains the length of the
data argument passed in, and on return from the command, it
contains the number of bytes being returned to the process
(the buffer pointed to by ic_dp should be large enough to
contain the maximum amount of data that any module or the
driver in the STREAM can return).</p>

<p>The STREAM head shall convert the information pointed to
by the stri- octl structure to an internal ioctl() command
message and send it down- stream.</p>

<p>The ioctl() function with the I_STR command shall fail
if:</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate buffers for the ioctl() message.</p>

<p>EINVAL The ic_len member is less than 0 or larger than
the maximum con- figured size of the data part of a message,
or ic_timout is less than -1.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>ETIME A downstream ioctl() timed out before
acknowledgement was received.</p>

<p>An I_STR can also fail while waiting for an
acknowledgement if a mes- sage indicating an error or a
hangup is received at the STREAM head. In addition, an error
code can be returned in the positive or negative
acknowledgement message, in the event the ioctl() command
sent down- stream fails. For these cases, I_STR shall fail
with errno set to the value in the message.</p>

<p>I_SWROPT Sets the write mode using the value of the
argument arg. Valid bit settings for arg are:</p>

<p>SNDZERO Send a zero-length message downstream when a
write() of 0 bytes occurs. To not send a zero-length message
when a write() of 0 bytes occurs, the application shall
ensure that this bit is not set in arg (for example, arg
would be set to 0).</p>

<p>The ioctl() function with the I_SWROPT command shall
fail if:</p>

<p>EINVAL arg is not the above value.</p>

<p>I_GWROPT Returns the current write mode setting, as
described above, in the int that is pointed to by the
argument arg.</p>

<p>I_SENDFD Creates a new reference to the open file
description associated with the file descriptor arg, and
writes a message on the STREAMS-based pipe fildes containing
this reference, together with the user ID and group ID of
the calling process.</p>

<p>The ioctl() function with the I_SENDFD command shall
fail if:</p>

<p>EAGAIN The sending STREAM is unable to allocate a
message block to con- tain the file pointer; or the read
queue of the receiving STREAM head is full and cannot accept
the message sent by I_SENDFD.</p>

<p>EBADF The arg argument is not a valid, open file
descriptor.</p>

<p>EINVAL The fildes argument is not connected to a STREAM
pipe.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>I_RECVFD Retrieves the reference to an open file
description from a mes- sage written to a STREAMS-based pipe
using the I_SENDFD command, and allocates a new file
descriptor in the calling process that refers to this open
file description. The arg argument is a pointer to a
strrecvfd data structure as defined in
&lt;stropts.h&gt;.</p>

<p>The fd member is a file descriptor. The uid and gid
members are the effective user ID and effective group ID,
respectively, of the sending process.</p>

<p>If O_NONBLOCK is not set, I_RECVFD shall block until a
message is present at the STREAM head. If O_NONBLOCK is set,
I_RECVFD shall fail with errno set to [EAGAIN] if no message
is present at the STREAM head.</p>

<p>If the message at the STREAM head is a message sent by
an I_SENDFD, a new file descriptor shall be allocated for
the open file descriptor referenced in the message. The new
file descriptor is placed in the fd member of the strrecvfd
structure pointed to by arg.</p>

<p>The ioctl() function with the I_RECVFD command shall
fail if:</p>

<p>EAGAIN A message is not present at the STREAM head read
queue and the O_NONBLOCK flag is set.</p>

<p>EBADMSG The message at the STREAM head read queue is not
a message con- taining a passed file descriptor.</p>

<p>EMFILE The process has the maximum number of file
descriptors currently open that it is allowed.</p>

<p>ENXIO Hangup received on fildes.</p>

<p>I_LIST Allows the process to list all the module names
on the STREAM, up to and including the topmost driver name.
If arg is a null pointer, the return value shall be the
number of modules, including the driver, that are on the
STREAM pointed to by fildes. This lets the process allocate
enough space for the mod- ule names. Otherwise, it should
point to a str_list structure.</p>

<p>The sl_nmods member indicates the number of entries the
process has allocated in the array. Upon return, the
sl_modlist member of the str_list structure shall contain
the list of module names, and the num- ber of entries that
have been filled into the sl_modlist array is found in the
sl_nmods member (the number includes the number of modules
including the driver). The return value from ioctl() shall
be 0. The entries are filled in starting at the top of the
STREAM and continuing downstream until either the end of the
STREAM is reached, or the number of requested modules (
sl_nmods) is satisfied.</p>

<p>The ioctl() function with the I_LIST command shall fail
if:</p>

<p>EINVAL The sl_nmods member is less than 1.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate buffers.</p>

<p>I_ATMARK Allows the process to see if the message at the
head of the STREAM head read queue is marked by some module
downstream. The arg argument determines how the checking is
done when there may be multiple marked messages on the
STREAM head read queue. It may take on the following
values:</p>

<p>ANYMARK Check if the message is marked.</p>

<p>LASTMARK Check if the message is the last one marked on
the queue.</p>

<p>The bitwise-inclusive OR of the flags ANYMARK and
LASTMARK is permit- ted.</p>

<p>The return value shall be 1 if the mark condition is
satisfied; other- wise, the value shall be 0.</p>

<p>The ioctl() function with the I_ATMARK command shall
fail if:</p>

<p>EINVAL Invalid arg value.</p>

<p>I_CKBAND Checks if the message of a given priority band
exists on the STREAM head read queue. This shall return 1 if
a message of the given priority exists, 0 if no such message
exists, or -1 on error. arg should be of type int.</p>

<p>The ioctl() function with the I_CKBAND command shall
fail if:</p>

<p>EINVAL Invalid arg value.</p>

<p>I_GETBAND Returns the priority band of the first message
on the STREAM head read queue in the integer referenced by
arg.</p>

<p>The ioctl() function with the I_GETBAND command shall
fail if:</p>

<p>ENODATA No message on the STREAM head read queue.</p>

<p>I_CANPUT Checks if a certain band is writable. arg is
set to the priority band in question. The return value shall
be 0 if the band is flow-controlled, 1 if the band is
writable, or -1 on error.</p>

<p>The ioctl() function with the I_CANPUT command shall
fail if:</p>

<p>EINVAL Invalid arg value.</p>

<p>I_SETCLTIME This request allows the process to set the
time the STREAM head shall delay when a STREAM is closing
and there is data on the write queues. Before closing each
module or driver, if there is data on its write queue, the
STREAM head shall delay for the specified amount of time to
allow the data to drain. If, after the delay, data is still
present, it shall be flushed. The arg argument is a pointer
to an integer specifying the number of milliseconds to
delay, rounded up to the nearest valid value. If I_SETCLTIME
is not performed on a STREAM, an implementation- defined
default timeout interval is used.</p>

<p>The ioctl() function with the I_SETCLTIME command shall
fail if:</p>

<p>EINVAL Invalid arg value.</p>

<p>I_GETCLTIME Returns the close time delay in the integer
pointed to by arg.</p>

<p>Multiplexed STREAMS Configurations The following
commands are used for connecting and disconnecting multi-
plexed STREAMS configurations. These commands use an
implementation- defined default timeout interval.</p>

<p>I_LINK Connects two STREAMs, where fildes is the file
descriptor of the STREAM connected to the multiplexing
driver, and arg is the file descriptor of the STREAM
connected to another driver. The STREAM designated by arg is
connected below the multiplexing driver. I_LINK requires the
multiplexing driver to send an acknowledge- ment message to
the STREAM head regarding the connection. This call shall
return a multiplexer ID number (an identifier used to
disconnect the multiplexer; see I_UNLINK) on success, and -1
on failure.</p>

<p>The ioctl() function with the I_LINK command shall fail
if:</p>

<p>ENXIO Hangup received on fildes.</p>

<p>ETIME Timeout before acknowledgement message was
received at STREAM head.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate STREAMS storage to perform the
I_LINK.</p>

<p>EBADF The arg argument is not a valid, open file
descriptor.</p>

<p>EINVAL The fildes argument does not support
multiplexing; or arg is not a STREAM or is already connected
downstream from a multiplexer; or the specified I_LINK
operation would connect the STREAM head in more than one
place in the multiplexed STREAM.</p>

<p>An I_LINK can also fail while waiting for the
multiplexing driver to acknowledge the request, if a message
indicating an error or a hangup is received at the STREAM
head of fildes. In addition, an error code can be returned
in the positive or negative acknowledgement message. For
these cases, I_LINK fails with errno set to the value in the
mes- sage.</p>

<p>I_UNLINK Disconnects the two STREAMs specified by fildes
and arg. fildes is the file descriptor of the STREAM
connected to the multiplex- ing driver. The arg argument is
the multiplexer ID number that was returned by the I_LINK
ioctl() command when a STREAM was connected downstream from
the multiplexing driver. If arg is MUXID_ALL, then all
STREAMs that were connected to fildes shall be disconnected.
As in I_LINK, this command requires acknowl- edgement.</p>

<p>The ioctl() function with the I_UNLINK command shall
fail if:</p>

<p>ENXIO Hangup received on fildes.</p>

<p>ETIME Timeout before acknowledgement message was
received at STREAM head.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate buffers for the acknowledgement
message.</p>

<p>EINVAL Invalid multiplexer ID number.</p>

<p>An I_UNLINK can also fail while waiting for the
multiplexing driver to acknowledge the request if a message
indicating an error or a hangup is received at the STREAM
head of fildes. In addition, an error code can be returned
in the positive or negative acknowledgement message. For
these cases, I_UNLINK shall fail with errno set to the value
in the message.</p>

<p>I_PLINK Creates a persistent connection between two
STREAMs, where fildes is the file descriptor of the STREAM
connected to the multiplexing driver, and arg is the file
descriptor of the STREAM connected to another driver. This
call shall create a persistent connection which can exist
even if the file descrip- tor fildes associated with the
upper STREAM to the multiplexing driver is closed. The
STREAM designated by arg gets connected via a persistent
connection below the multiplexing driver. I_PLINK requires
the multiplexing driver to send an acknowledge- ment message
to the STREAM head. This call shall return a multi- plexer
ID number (an identifier that may be used to disconnect the
multiplexer; see I_PUNLINK) on success, and -1 on
failure.</p>

<p>The ioctl() function with the I_PLINK command shall fail
if:</p>

<p>ENXIO Hangup received on fildes.</p>

<p>ETIME Timeout before acknowledgement message was
received at STREAM head.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate STREAMS storage to perform the
I_PLINK.</p>

<p>EBADF The arg argument is not a valid, open file
descriptor.</p>

<p>EINVAL The fildes argument does not support
multiplexing; or arg is not a STREAM or is already connected
downstream from a multiplexer; or the specified I_PLINK
operation would connect the STREAM head in more than one
place in the multiplexed STREAM.</p>

<p>An I_PLINK can also fail while waiting for the
multiplexing driver to acknowledge the request, if a message
indicating an error or a hangup is received at the STREAM
head of fildes. In addition, an error code can be returned
in the positive or negative acknowledgement message. For
these cases, I_PLINK shall fail with errno set to the value
in the message.</p>

<p>I_PUNLINK Disconnects the two STREAMs specified by
fildes and arg from a persistent connection. The fildes
argument is the file descrip- tor of the STREAM connected to
the multiplexing driver. The arg argument is the multiplexer
ID number that was returned by the I_PLINK ioctl() command
when a STREAM was connected downstream from the multiplexing
driver. If arg is MUXID_ALL, then all STREAMs which are
persistent connections to fildes shall be dis- connected. As
in I_PLINK, this command requires the multiplexing driver to
acknowledge the request.</p>

<p>The ioctl() function with the I_PUNLINK command shall
fail if:</p>

<p>ENXIO Hangup received on fildes.</p>

<p>ETIME Timeout before acknowledgement message was
received at STREAM head.</p>

<p>EAGAIN or ENOSR</p>

<p>Unable to allocate buffers for the acknowledgement
message.</p>

<p>EINVAL Invalid multiplexer ID number.</p>

<p>An I_PUNLINK can also fail while waiting for the
multiplexing driver to acknowledge the request if a message
indicating an error or a hangup is received at the STREAM
head of fildes. In addition, an error code can be returned
in the positive or negative acknowledgement message. For
these cases, I_PUNLINK shall fail with errno set to the
value in the message.</p>

<p>RETURN VALUE Upon successful completion, ioctl() shall
return a value other than -1 that depends upon the STREAMS
device control function. Otherwise, it shall return -1 and
set errno to indicate the error.</p>

<p>ERRORS Under the following general conditions, ioctl()
shall fail if:</p>

<p>EBADF The fildes argument is not a valid open file
descriptor.</p>

<p>EINTR A signal was caught during the ioctl()
operation.</p>

<p>EINVAL The STREAM or multiplexer referenced by fildes is
linked (directly or indirectly) downstream from a
multiplexer.</p>

<p>If an underlying device driver detects an error, then
ioctl() shall fail if:</p>

<p>EINVAL The request or arg argument is not valid for this
device.</p>

<p>EIO Some physical I/O error has occurred.</p>

<p>ENOTTY The fildes argument is not associated with a
STREAMS device that accepts control functions.</p>

<p>ENXIO The request and arg arguments are valid for this
device driver, but the service requested cannot be performed
on this particular sub-device.</p>

<p>ENODEV The fildes argument refers to a valid STREAMS
device, but the corresponding device driver does not support
the ioctl() func- tion.</p>

<p>If a STREAM is connected downstream from a multiplexer,
any ioctl() command except I_UNLINK and I_PUNLINK shall set
errno to [EINVAL].</p>

<p>The following sections are informative.</p>

<p>EXAMPLES None.</p>

<p>APPLICATION USAGE The implementation-defined timeout
interval for STREAMS has histori- cally been 15 seconds.</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO STREAMS, close(), fcntl(), getmsg(), open(),
pipe(), poll(), putmsg(), read(), sigaction(), write(), the
Base Definitions volume of IEEE Std 1003.1-2001,
&lt;stropts.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 IOCTL(3P)</p>
<hr>
</body>
</html>
