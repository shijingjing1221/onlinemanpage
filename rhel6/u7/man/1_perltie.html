<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:25 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLTIE(1) Perl Programmers Reference Guide
PERLTIE(1)</p>

<p>NAME perltie - how to hide an object class in a simple
variable</p>

<p>SYNOPSIS tie VARIABLE, CLASSNAME, LIST</p>

<p>$object = tied VARIABLE</p>

<p>untie VARIABLE</p>

<p>DESCRIPTION Prior to release 5.0 of Perl, a programmer
could use dbmopen() to connect an on-disk database in the
standard Unix dbm(3x) format magically to a %HASH in their
program. However, their Perl was either built with one
particular dbm library or another, but not both, and you
couldn t extend this mechanism to other packages or types of
variables.</p>

<p>Now you can.</p>

<p>The tie() function binds a variable to a class (package)
that will provide the implementation for access methods for
that variable. Once this magic has been performed, accessing
a tied variable automatically triggers method calls in the
proper class. The complexity of the class is hidden behind
magic methods calls. The method names are in ALL CAPS, which
is a convention that Perl uses to indicate that theyre
called implicitly rather than explicitly--just like the
BEGIN() and END() functions.</p>

<p>In the tie() call, &quot;VARIABLE&quot; is the name of
the variable to be enchanted. &quot;CLASSNAME&quot; is the
name of a class implementing objects of the correct type.
Any additional arguments in the &quot;LIST&quot; are passed
to the appropriate constructor method for that
class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or
TIEHANDLE(). (Typically these are arguments such as might be
passed to the dbminit() function of C.) The object returned
by the &quot;new&quot; method is also returned by the tie()
function, which would be useful if you wanted to access
other methods in &quot;CLASSNAME&quot;. (You dont actually
have to return a reference to a right &quot;type&quot;
(e.g., HASH or &quot;CLASSNAME&quot;) so long as it s a
properly blessed object.) You can also retrieve a reference
to the underlying object using the tied() function.</p>

<p>Unlike dbmopen(), the tie() function will not
&quot;use&quot; or &quot;require&quot; a module for you--you
need to do that explicitly yourself.</p>

<p>Tying Scalars A class implementing a tied scalar should
define the following methods: TIESCALAR, FETCH, STORE, and
possibly UNTIE and/or DESTROY.</p>

<p>Lets look at each in turn, using as an example a tie
class for scalars that allows the user to do something
like:</p>

<p>tie $his_speed, &rsquo;Nice&rsquo;, getppid(); tie
$my_speed, &rsquo;Nice&rsquo;, $$;</p>

<p>And now whenever either of those variables is accessed,
its current system priority is retrieved and returned. If
those variables are set, then the processs priority is
changed!</p>

<p>Well use Jarkko Hietaniemi &lt;jhi@iki.fi&gt; s
BSD::Resource class (not included) to access the
PRIO_PROCESS, PRIO_MIN, and PRIO_MAX constants from your
system, as well as the getpriority() and setpriority()
system calls. Heres the preamble of the class.</p>

<p>package Nice; use Carp; use BSD::Resource; use strict;
$Nice::DEBUG = 0 unless defined $Nice::DEBUG;</p>

<p>TIESCALAR classname, LIST This is the constructor for
the class. That means it is expected to return a blessed
reference to a new scalar (probably anonymous) that its
creating. For example:</p>

<p>sub TIESCALAR { my $class = shift; my $pid = shift ||
$$; # 0 means me</p>

<p>if ($pid !~ /^+$/) { carp &quot;Nice::Tie::Scalar got
non-numeric pid $pid&quot; if $^W; return undef; }</p>

<p>unless (kill 0, $pid) { # EPERM or ERSCH, no doubt carp
&quot;Nice::Tie::Scalar got bad pid $pid: $!&quot; if $^W;
return undef; }</p>

<p>return bless id, $class; }</p>

<p>This tie class has chosen to return an error rather than
raising an exception if its constructor should fail. While
this is how dbmopen() works, other classes may well not wish
to be so forgiving. It checks the global variable $^W to see
whether to emit a bit of noise anyway.</p>

<p>FETCH this This method will be triggered every time the
tied variable is accessed (read). It takes no arguments
beyond its self reference, which is the object representing
the scalar we re dealing with. Because in this case were
using just a SCALAR ref for the tied scalar object, a simple
$$self allows the method to get at the real value stored
there. In our example below, that real value is the process
ID to which weve tied our variable.</p>

<p>sub FETCH { my $self = shift; confess &quot;wrong
type&quot; unless ref $self; croak &quot;usage error&quot;
if @_; my $nicety; local($!) = 0; $nicety =
getpriority(PRIO_PROCESS, $$self); if ($!) { croak
&quot;getpriority failed: $!&quot; } return $nicety; }</p>

<p>This time weve decided to blow up (raise an exception)
if the renice fails--there s no place for us to return an
error otherwise, and its probably the right thing to do.</p>

<p>STORE this, value This method will be triggered every
time the tied variable is set (assigned). Beyond its self
reference, it also expects one (and only one) argument--the
new value the user is trying to assign. Don t worry about
returning a value from STORE -- the semantic of assignment
returning the assigned value is implemented with FETCH.</p>

<p>sub STORE { my $self = shift; confess &quot;wrong
type&quot; unless ref $self; my $new_nicety = shift; croak
&quot;usage error&quot; if @_;</p>

<p>if ($new_nicety &lt; PRIO_MIN) { carp sprintf
&quot;WARNING: priority %d less than minimum system priority
%d&quot;, $new_nicety, PRIO_MIN if $^W; $new_nicety =
PRIO_MIN; }</p>

<p>if ($new_nicety &gt; PRIO_MAX) { carp sprintf
&quot;WARNING: priority %d greater than maximum system
priority %d&quot;, $new_nicety, PRIO_MAX if $^W; $new_nicety
= PRIO_MAX; }</p>

<p>unless (defined setpriority(PRIO_PROCESS, $$self,
$new_nicety)) { confess &quot;setpriority failed: $!&quot;;
} }</p>

<p>UNTIE this This method will be triggered when the
&quot;untie&quot; occurs. This can be useful if the class
needs to know when no further calls will be made. (Except
DESTROY of course.) See &quot;The &quot;untie&quot;
Gotcha&quot; below for more details.</p>

<p>DESTROY this This method will be triggered when the tied
variable needs to be destructed. As with other object
classes, such a method is seldom necessary, because Perl
deallocates its moribund objects memory for you
automatically--this isnt C++, you know. We ll use a DESTROY
method here for debugging purposes only.</p>

<p>sub DESTROY { my $self = shift; confess &quot;wrong
type&quot; unless ref $self; carp &quot;[ Nice::DESTROY pid
$$self ]&quot; if $Nice::DEBUG; }</p>

<p>Thats about all there is to it. Actually, its more than
all there is to it, because weve done a few nice things here
for the sake of completeness, robustness, and general
aesthetics. Simpler TIESCALAR classes are certainly
possible.</p>

<p>Tying Arrays A class implementing a tied ordinary array
should define the following methods: TIEARRAY, FETCH, STORE,
FETCHSIZE, STORESIZE and perhaps UNTIE and/or DESTROY.</p>

<p>FETCHSIZE and STORESIZE are used to provide $#array and
equivalent &quot;scalar(@array)&quot; access.</p>

<p>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE,
and EXISTS are required if the perl operator with the
corresponding (but lowercase) name is to operate on the tied
array. The Tie::Array class can be used as a base class to
implement the first five of these in terms of the basic
methods above. The default implementations of DELETE and
EXISTS in Tie::Array simply &quot;croak&quot;.</p>

<p>In addition EXTEND will be called when perl would have
pre-extended allocation in a real array.</p>

<p>For this discussion, we ll implement an array whose
elements are a fixed size at creation. If you try to create
an element larger than the fixed size, youll take an
exception. For example:</p>

<p>use FixedElem_Array; tie @array,
&rsquo;FixedElem_Array&rsquo;, 3; $array[0] =
&rsquo;cat&rsquo;; # ok. $array[1] = &rsquo;dogs&rsquo;; #
exception, length(&rsquo;dogs&rsquo;) &gt; 3.</p>

<p>The preamble code for the class is as follows:</p>

<p>package FixedElem_Array; use Carp; use strict;</p>

<p>TIEARRAY classname, LIST This is the constructor for the
class. That means it is expected to return a blessed
reference through which the new array (probably an anonymous
ARRAY ref) will be accessed.</p>

<p>In our example, just to show you that you dont really
have to return an ARRAY reference, we ll choose a HASH
reference to represent our object. A HASH works out well as
a generic record type: the &quot;{ELEMSIZE}&quot; field will
store the maximum element size allowed, and the
&quot;{ARRAY}&quot; field will hold the true ARRAY ref. If
someone outside the class tries to dereference the object
returned (doubtless thinking it an ARRAY ref), theyll blow
up. This just goes to show you that you should respect an
objects privacy.</p>

<p>sub TIEARRAY { my $class = shift; my $elemsize = shift;
if ( @_ || $elemsize =~ / croak &quot;usage: tie ARRAY,
&rsquo;&quot; . __PACKAGE__ . &quot;&rsquo;,
elem_size&quot;; } return bless { ELEMSIZE =&gt; $elemsize,
ARRAY =&gt; [], }, $class; }</p>

<p>FETCH this, index This method will be triggered every
time an individual element the tied array is accessed
(read). It takes one argument beyond its self reference: the
index whose value were trying to fetch.</p>

<p>sub FETCH { my $self = shift; my $index = shift; return
$self-&gt;{ARRAY}-&gt;[$index]; }</p>

<p>If a negative array index is used to read from an array,
the index will be translated to a positive one internally by
calling FETCHSIZE before being passed to FETCH. You may
disable this feature by assigning a true value to the
variable $NEGATIVE_INDICES in the tied array class.</p>

<p>As you may have noticed, the name of the FETCH method
(et al.) is the same for all accesses, even though the
constructors differ in names (TIESCALAR vs TIEARRAY). While
in theory you could have the same class servicing several
tied types, in practice this becomes cumbersome, and its
easiest to keep them at simply one tie type per class.</p>

<p>STORE this, index, value This method will be triggered
every time an element in the tied array is set (written). It
takes two arguments beyond its self reference: the index at
which were trying to store something and the value were
trying to put there.</p>

<p>In our example, &quot;undef&quot; is really
&quot;$self-&gt;{ELEMSIZE}&quot; number of spaces so we have
a little more work to do here:</p>

<p>sub STORE { my $self = shift; my( $index, $value ) = @_;
if ( length $value &gt; $self-&gt;{ELEMSIZE} ) { croak
&quot;length of $value is greater than
$self-&gt;{ELEMSIZE}&quot;; } # fill in the blanks
$self-&gt;EXTEND( $index ) if $index &gt;
$self-&gt;FETCHSIZE(); # right justify to keep element size
for smaller elements $self-&gt;{ARRAY}-&gt;[$index] =
sprintf &quot;%$self-&gt;{ELEMSIZE}s&quot;, $value; }</p>

<p>Negative indexes are treated the same as with FETCH.</p>

<p>FETCHSIZE this Returns the total number of items in the
tied array associated with object this. (Equivalent to
&quot;scalar(@array)&quot;). For example:</p>

<p>sub FETCHSIZE { my $self = shift; return scalar
@{$self-&gt;{ARRAY}}; }</p>

<p>STORESIZE this, count Sets the total number of items in
the tied array associated with object this to be count. If
this makes the array larger then class s mapping of
&quot;undef&quot; should be returned for new positions. If
the array becomes smaller then entries beyond count should
be deleted.</p>

<p>In our example, undef is really an element containing
&quot;$self-&gt;{ELEMSIZE}&quot; number of spaces.
Observe:</p>

<p>sub STORESIZE { my $self = shift; my $count = shift; if
( $count &gt; $self-&gt;FETCHSIZE() ) { foreach ( $count -
$self-&gt;FETCHSIZE() .. $count ) { $self-&gt;STORE( $_,
&rsquo;&rsquo; ); } } elsif ( $count &lt;
$self-&gt;FETCHSIZE() ) { foreach ( 0 ..
$self-&gt;FETCHSIZE() - $count - 2 ) { $self-&gt;POP(); } }
}</p>

<p>EXTEND this, count Informative call that array is likely
to grow to have count entries. Can be used to optimize
allocation. This method need do nothing.</p>

<p>In our example, we want to make sure there are no blank
(&quot;undef&quot;) entries, so &quot;EXTEND&quot; will make
use of &quot;STORESIZE&quot; to fill elements as needed:</p>

<p>sub EXTEND { my $self = shift; my $count = shift;
$self-&gt;STORESIZE( $count ); }</p>

<p>EXISTS this, key Verify that the element at index key
exists in the tied array this.</p>

<p>In our example, we will determine that if an element
consists of &quot;$self-&gt;{ELEMSIZE}&quot; spaces only, it
does not exist:</p>

<p>sub EXISTS { my $self = shift; my $index = shift; return
0 if ! defined $self-&gt;{ARRAY}-&gt;[$index] ||
$self-&gt;{ARRAY}-&gt;[$index] eq &rsquo; &rsquo; x
$self-&gt;{ELEMSIZE}; return 1; }</p>

<p>DELETE this, key Delete the element at index key from
the tied array this.</p>

<p>In our example, a deleted item is
&quot;$self-&gt;{ELEMSIZE}&quot; spaces:</p>

<p>sub DELETE { my $self = shift; my $index = shift; return
$self-&gt;STORE( $index, &rsquo;&rsquo; ); }</p>

<p>CLEAR this Clear (remove, delete, ...) all values from
the tied array associated with object this. For example:</p>

<p>sub CLEAR { my $self = shift; return $self-&gt;{ARRAY} =
[]; }</p>

<p>PUSH this, LIST Append elements of LIST to the array.
For example:</p>

<p>sub PUSH { my $self = shift; my @list = @_; my $last =
$self-&gt;FETCHSIZE(); $self-&gt;STORE( $last + $_,
$list[$_] ) foreach 0 .. $#list; return
$self-&gt;FETCHSIZE(); }</p>

<p>POP this Remove last element of the array and return it.
For example:</p>

<p>sub POP { my $self = shift; return pop
@{$self-&gt;{ARRAY}}; }</p>

<p>SHIFT this Remove the first element of the array
(shifting other elements down) and return it. For
example:</p>

<p>sub SHIFT { my $self = shift; return shift
@{$self-&gt;{ARRAY}}; }</p>

<p>UNSHIFT this, LIST Insert LIST elements at the beginning
of the array, moving existing elements up to make room. For
example:</p>

<p>sub UNSHIFT { my $self = shift; my @list = @_; my $size
= scalar( @list ); # make room for our list
@{$self-&gt;{ARRAY}}[ $size .. $#{$self-&gt;{ARRAY}} + $size
] = @{$self-&gt;{ARRAY}}; $self-&gt;STORE( $_, $list[$_] )
foreach 0 .. $#list; }</p>

<p>SPLICE this, offset, length, LIST Perform the equivalent
of &quot;splice&quot; on the array.</p>

<p>offset is optional and defaults to zero, negative values
count back from the end of the array.</p>

<p>length is optional and defaults to rest of the
array.</p>

<p>LIST may be empty.</p>

<p>Returns a list of the original length elements at
offset.</p>

<p>In our example, well use a little shortcut if there is a
LIST:</p>

<p>sub SPLICE { my $self = shift; my $offset = shift || 0;
my $length = shift || $self-&gt;FETCHSIZE() - $offset; my
@list = (); if ( @_ ) { tie @list, __PACKAGE__,
$self-&gt;{ELEMSIZE}; @list = @_; } return splice
@{$self-&gt;{ARRAY}}, $offset, $length, @list; }</p>

<p>UNTIE this Will be called when &quot;untie&quot;
happens. (See &quot;The &quot;untie&quot; Gotcha&quot;
below.)</p>

<p>DESTROY this This method will be triggered when the tied
variable needs to be destructed. As with the scalar tie
class, this is almost never needed in a language that does
its own garbage collection, so this time well just leave it
out.</p>

<p>Tying Hashes Hashes were the first Perl data type to be
tied (see dbmopen()). A class implementing a tied hash
should define the following methods: TIEHASH is the
constructor. FETCH and STORE access the key and value pairs.
EXISTS reports whether a key is present in the hash, and
DELETE deletes one. CLEAR empties the hash by deleting all
the key and value pairs. FIRSTKEY and NEXTKEY implement the
keys() and each() functions to iterate over all the keys.
SCALAR is triggered when the tied hash is evaluated in
scalar context. UNTIE is called when &quot;untie&quot;
happens, and DESTROY is called when the tied variable is
garbage collected.</p>

<p>If this seems like a lot, then feel free to inherit from
merely the standard Tie::StdHash module for most of your
methods, redefining only the interesting ones. See Tie::Hash
for details.</p>

<p>Remember that Perl distinguishes between a key not
existing in the hash, and the key existing in the hash but
having a corresponding value of &quot;undef&quot;. The two
possibilities can be tested with the &quot;exists()&quot;
and &quot;defined()&quot; functions.</p>

<p>Heres an example of a somewhat interesting tied hash
class: it gives you a hash representing a particular users
dot files. You index into the hash with the name of the file
(minus the dot) and you get back that dot files contents.
For example:</p>

<p>use DotFiles; tie %dot, &rsquo;DotFiles&rsquo;; if (
$dot{profile} =~ /MANPATH/ || $dot{login} =~ /MANPATH/ ||
$dot{cshrc} =~ /MANPATH/ ) { print &quot;you seem to set
your MANPATH0; }</p>

<p>Or heres another sample of using our tied class:</p>

<p>tie %him, &rsquo;DotFiles&rsquo;, &rsquo;daemon&rsquo;;
foreach $f ( keys %him ) { printf &quot;daemon dot file %s
is size %d0, $f, length $him{$f}; }</p>

<p>In our tied hash DotFiles example, we use a regular hash
for the object containing several important fields, of which
only the &quot;{LIST}&quot; field will be what the user
thinks of as the real hash.</p>

<p>USER whose dot files this object represents</p>

<p>HOME where those dot files live</p>

<p>CLOBBER whether we should try to change or remove those
dot files</p>

<p>LIST the hash of dot file names and content mappings</p>

<p>Heres the start of Dotfiles.pm:</p>

<p>package DotFiles; use Carp; sub whowasi { (caller(1))[3]
. &rsquo;()&rsquo; } my $DEBUG = 0; sub debug { $DEBUG = @_
? shift : 1 }</p>

<p>For our example, we want to be able to emit debugging
info to help in tracing during development. We keep also one
convenience function around internally to help print out
warnings; whowasi() returns the function name that calls
it.</p>

<p>Here are the methods for the DotFiles tied hash.</p>

<p>TIEHASH classname, LIST This is the constructor for the
class. That means it is expected to return a blessed
reference through which the new object (probably but not
necessarily an anonymous hash) will be accessed.</p>

<p>Heres the constructor:</p>

<p>sub TIEHASH { my $self = shift; my $user = shift ||
$&gt;; my $dotdir = shift || &rsquo;&rsquo;; croak
&quot;usage: @{[&amp;whowasi]} [USER [DOTDIR]]&quot; if @_;
$user = getpwuid($user) if $user =~ /^+$/; my $dir =
(getpwnam($user))[7] || croak &quot;@{[&amp;whowasi]}: no
user $user&quot;; $dir .= &quot;/$dotdir&quot; if
$dotdir;</p>

<p>my $node = { USER =&gt; $user, HOME =&gt; $dir, LIST
=&gt; {}, CLOBBER =&gt; 0, };</p>

<p>opendir(DIR, $dir) || croak &quot;@{[&amp;whowasi]}:
can&rsquo;t opendir $dir: $!&quot;; foreach $dot ( grep /^./
&amp;&amp; -f &quot;$dir/$_&quot;, readdir(DIR)) { $dot =~
s/^.//; $node-&gt;{LIST}{$dot} = undef; } closedir DIR;
return bless $node, $self; }</p>

<p>Its probably worth mentioning that if youre going to
filetest the return values out of a readdir, youd better
prepend the directory in question. Otherwise, because we
didn t chdir() there, it would have been testing the wrong
file.</p>

<p>FETCH this, key This method will be triggered every time
an element in the tied hash is accessed (read). It takes one
argument beyond its self reference: the key whose value were
trying to fetch.</p>

<p>Heres the fetch for our DotFiles example.</p>

<p>sub FETCH { carp &amp;whowasi if $DEBUG; my $self =
shift; my $dot = shift; my $dir = $self-&gt;{HOME}; my $file
= &quot;$dir/.$dot&quot;;</p>

<p>unless (exists $self-&gt;{LIST}-&gt;{$dot} || -f $file)
{ carp &quot;@{[&amp;whowasi]}: no $dot file&quot; if
$DEBUG; return undef; }</p>

<p>if (defined $self-&gt;{LIST}-&gt;{$dot}) { return
$self-&gt;{LIST}-&gt;{$dot}; } else { return
$self-&gt;{LIST}-&gt;{$dot} = &lsquo;cat $dir/.$dot&lsquo;;
} }</p>

<p>It was easy to write by having it call the Unix cat(1)
command, but it would probably be more portable to open the
file manually (and somewhat more efficient). Of course,
because dot files are a Unixy concept, were not that
concerned.</p>

<p>STORE this, key, value This method will be triggered
every time an element in the tied hash is set (written). It
takes two arguments beyond its self reference: the index at
which were trying to store something, and the value were
trying to put there.</p>

<p>Here in our DotFiles example, well be careful not to let
them try to overwrite the file unless they ve called the
clobber() method on the original object reference returned
by tie().</p>

<p>sub STORE { carp &amp;whowasi if $DEBUG; my $self =
shift; my $dot = shift; my $value = shift; my $file =
$self-&gt;{HOME} . &quot;/.$dot&quot;; my $user =
$self-&gt;{USER};</p>

<p>croak &quot;@{[&amp;whowasi]}: $file not
clobberable&quot; unless $self-&gt;{CLOBBER};</p>

<p>open(F, &quot;&gt; $file&quot;) || croak
&quot;can&rsquo;t open $file: $!&quot;; print F $value;
close(F); }</p>

<p>If they wanted to clobber something, they might say:</p>

<p>$ob = tie %daemon_dots, &rsquo;daemon&rsquo;;
$ob-&gt;clobber(1); $daemon_dots{signature} = &quot;A true
daemon0;</p>

<p>Another way to lay hands on a reference to the
underlying object is to use the tied() function, so they
might alternately have set clobber using:</p>

<p>tie %daemon_dots, &rsquo;daemon&rsquo;;
tied(%daemon_dots)-&gt;clobber(1);</p>

<p>The clobber method is simply:</p>

<p>sub clobber { my $self = shift; $self-&gt;{CLOBBER} = @_
? shift : 1; }</p>

<p>DELETE this, key This method is triggered when we remove
an element from the hash, typically by using the delete()
function. Again, well be careful to check whether they
really want to clobber files.</p>

<p>sub DELETE { carp &amp;whowasi if $DEBUG;</p>

<p>my $self = shift; my $dot = shift; my $file =
$self-&gt;{HOME} . &quot;/.$dot&quot;; croak
&quot;@{[&amp;whowasi]}: won&rsquo;t remove file $file&quot;
unless $self-&gt;{CLOBBER}; delete
$self-&gt;{LIST}-&gt;{$dot}; my $success = unlink($file);
carp &quot;@{[&amp;whowasi]}: can&rsquo;t unlink $file:
$!&quot; unless $success; $success; }</p>

<p>The value returned by DELETE becomes the return value of
the call to delete(). If you want to emulate the normal
behavior of delete(), you should return whatever FETCH would
have returned for this key. In this example, we have chosen
instead to return a value which tells the caller whether the
file was successfully deleted.</p>

<p>CLEAR this This method is triggered when the whole hash
is to be cleared, usually by assigning the empty list to
it.</p>

<p>In our example, that would remove all the users dot
files! Its such a dangerous thing that theyll have to set
CLOBBER to something higher than 1 to make it happen.</p>

<p>sub CLEAR { carp &amp;whowasi if $DEBUG; my $self =
shift; croak &quot;@{[&amp;whowasi]}: won&rsquo;t remove all
dot files for $self-&gt;{USER}&quot; unless
$self-&gt;{CLOBBER} &gt; 1; my $dot; foreach $dot ( keys
%{$self-&gt;{LIST}}) { $self-&gt;DELETE($dot); } }</p>

<p>EXISTS this, key This method is triggered when the user
uses the exists() function on a particular hash. In our
example, well look at the &quot;{LIST}&quot; hash element
for this:</p>

<p>sub EXISTS { carp &amp;whowasi if $DEBUG; my $self =
shift; my $dot = shift; return exists
$self-&gt;{LIST}-&gt;{$dot}; }</p>

<p>FIRSTKEY this This method will be triggered when the
user is going to iterate through the hash, such as via a
keys() or each() call.</p>

<p>sub FIRSTKEY { carp &amp;whowasi if $DEBUG; my $self =
shift; my $a = keys %{$self-&gt;{LIST}}; # reset each()
iterator each %{$self-&gt;{LIST}} }</p>

<p>NEXTKEY this, lastkey This method gets triggered during
a keys() or each() iteration. It has a second argument which
is the last key that had been accessed. This is useful if
youre carrying about ordering or calling the iterator from
more than one sequence, or not really storing things in a
hash anywhere.</p>

<p>For our example, we re using a real hash so well do just
the simple thing, but well have to go through the LIST field
indirectly.</p>

<p>sub NEXTKEY { carp &amp;whowasi if $DEBUG; my $self =
shift; return each %{ $self-&gt;{LIST} } }</p>

<p>SCALAR this This is called when the hash is evaluated in
scalar context. In order to mimic the behaviour of untied
hashes, this method should return a false value when the
tied hash is considered empty. If this method does not
exist, perl will make some educated guesses and return true
when the hash is inside an iteration. If this isnt the case,
FIRSTKEY is called, and the result will be a false value if
FIRSTKEY returns the empty list, true otherwise.</p>

<p>However, you should not blindly rely on perl always
doing the right thing. Particularly, perl will mistakenly
return true when you clear the hash by repeatedly calling
DELETE until it is empty. You are therefore advised to
supply your own SCALAR method when you want to be absolutely
sure that your hash behaves nicely in scalar context.</p>

<p>In our example we can just call &quot;scalar&quot; on
the underlying hash referenced by
&quot;$self-&gt;{LIST}&quot;:</p>

<p>sub SCALAR { carp &amp;whowasi if $DEBUG; my $self =
shift; return scalar %{ $self-&gt;{LIST} } }</p>

<p>UNTIE this This is called when &quot;untie&quot; occurs.
See &quot;The &quot;untie&quot; Gotcha&quot; below.</p>

<p>DESTROY this This method is triggered when a tied hash
is about to go out of scope. You dont really need it unless
youre trying to add debugging or have auxiliary state to
clean up. Here s a very simple function:</p>

<p>sub DESTROY { carp &amp;whowasi if $DEBUG; }</p>

<p>Note that functions such as keys() and values() may
return huge lists when used on large objects, like DBM
files. You may prefer to use the each() function to iterate
over such. Example:</p>

<p># print out history file offsets use NDBM_File;
tie(%HIST, &rsquo;NDBM_File&rsquo;,
&rsquo;/usr/lib/news/history&rsquo;, 1, 0); while
(($key,$val) = each %HIST) { print $key, &rsquo; = &rsquo;,
unpack(&rsquo;L&rsquo;,$val), &quot;0; } untie(%HIST);</p>

<p>Tying FileHandles This is partially implemented now.</p>

<p>A class implementing a tied filehandle should define the
following methods: TIEHANDLE, at least one of PRINT, PRINTF,
WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and
DESTROY. The class can also provide: BINMODE, OPEN, EOF,
FILENO, SEEK, TELL - if the corresponding perl operators are
used on the handle.</p>

<p>When STDERR is tied, its PRINT method will be called to
issue warnings and error messages. This feature is
temporarily disabled during the call, which means you can
use &quot;warn()&quot; inside PRINT without starting a
recursive loop. And just like &quot;__WARN__&quot; and
&quot;__DIE__&quot; handlers, STDERRs PRINT method may be
called to report parser errors, so the caveats mentioned
under &quot;%SIG&quot; in perlvar apply.</p>

<p>All of this is especially useful when perl is embedded
in some other program, where output to STDOUT and STDERR may
have to be redirected in some special way. See nvi and the
Apache module for examples.</p>

<p>In our example were going to create a shouting
handle.</p>

<p>package Shout;</p>

<p>TIEHANDLE classname, LIST This is the constructor for
the class. That means it is expected to return a blessed
reference of some sort. The reference can be used to hold
some internal information.</p>

<p>sub TIEHANDLE { print &quot;&lt;shout&gt;0; my $i; bless
, shift }</p>

<p>WRITE this, LIST This method will be called when the
handle is written to via the &quot;syswrite&quot;
function.</p>

<p>sub WRITE { $r = shift; my($buf,$len,$offset) = @_;
print &quot;WRITE called, uf=$buf, en=$len,
ffset=$offset&quot;; }</p>

<p>PRINT this, LIST This method will be triggered every
time the tied handle is printed to with the
&quot;print()&quot; or &quot;say()&quot; functions. Beyond
its self reference it also expects the list that was passed
to the print function.</p>

<p>sub PRINT { $r = shift; $$r++; print
join($,,map(uc($_),@_)),$ }</p>

<p>&quot;say()&quot; acts just like &quot;print()&quot;
except $ will be localized to &quot;0 so you need do nothing
special to handle &quot;say()&quot; in
&quot;PRINT()&quot;.</p>

<p>PRINTF this, LIST This method will be triggered every
time the tied handle is printed to with the
&quot;printf()&quot; function. Beyond its self reference it
also expects the format and list that was passed to the
printf function.</p>

<p>sub PRINTF { shift; my $fmt = shift; print sprintf($fmt,
@_); }</p>

<p>READ this, LIST This method will be called when the
handle is read from via the &quot;read&quot; or
&quot;sysread&quot; functions.</p>

<p>sub READ { my $self = shift; my $bufref = [0];
my(undef,$len,$offset) = @_; print &quot;READ called,
uf=$bufref, en=$len, ffset=$offset&quot;; # add to $$bufref,
set $len to number of characters read $len; }</p>

<p>READLINE this This method will be called when the handle
is read from via &lt;HANDLE&gt;. The method should return
undef when there is no more data.</p>

<p>sub READLINE { $r = shift; &quot;READLINE called $$r
times0; }</p>

<p>GETC this This method will be called when the
&quot;getc&quot; function is called.</p>

<p>sub GETC { print &quot;Don&rsquo;t GETC, Get Perl&quot;;
return &quot;a&quot;; }</p>

<p>CLOSE this This method will be called when the handle is
closed via the &quot;close&quot; function.</p>

<p>sub CLOSE { print &quot;CLOSE called.0 }</p>

<p>UNTIE this As with the other types of ties, this method
will be called when &quot;untie&quot; happens. It may be
appropriate to &quot;auto CLOSE&quot; when this occurs. See
&quot;The &quot;untie&quot; Gotcha&quot; below.</p>

<p>DESTROY this As with the other types of ties, this
method will be called when the tied handle is about to be
destroyed. This is useful for debugging and possibly
cleaning up.</p>

<p>sub DESTROY { print &quot;&lt;/shout&gt;0 }</p>

<p>Heres how to use our little example:</p>

<p>tie(*FOO,&rsquo;Shout&rsquo;); print FOO &quot;hello0;
$a = 4; $b = 6; print FOO $a, &quot; plus &quot;, $b, &quot;
equals &quot;, $a + $b, &quot;0; print &lt;FOO&gt;;</p>

<p>UNTIE this You can define for all tie types an UNTIE
method that will be called at untie(). See &quot;The
&quot;untie&quot; Gotcha&quot; below.</p>

<p>The &quot;untie&quot; Gotcha If you intend making use of
the object returned from either tie() or tied(), and if the
ties target class defines a destructor, there is a subtle
gotcha you must guard against.</p>

<p>As setup, consider this (admittedly rather contrived)
example of a tie; all it does is use a file to keep a log of
the values assigned to a scalar.</p>

<p>package Remember;</p>

<p>use strict; use warnings; use IO::File;</p>

<p>sub TIESCALAR { my $class = shift; my $filename = shift;
my $handle = IO::File-&gt;new( &quot;&gt; $filename&quot; )
or die &quot;Cannot open $filename: $!0;</p>

<p>print $handle &quot;The Start0; bless {FH =&gt; $handle,
Value =&gt; 0}, $class; }</p>

<p>sub FETCH { my $self = shift; return $self-&gt;{Value};
}</p>

<p>sub STORE { my $self = shift; my $value = shift; my
$handle = $self-&gt;{FH}; print $handle &quot;$value0;
$self-&gt;{Value} = $value; }</p>

<p>sub DESTROY { my $self = shift; my $handle =
$self-&gt;{FH}; print $handle &quot;The End0; close $handle;
}</p>

<p>1;</p>

<p>Here is an example that makes use of this tie:</p>

<p>use strict; use Remember;</p>

<p>my $fred; tie $fred, &rsquo;Remember&rsquo;,
&rsquo;myfile.txt&rsquo;; $fred = 1; $fred = 4; $fred = 5;
untie $fred; system &quot;cat myfile.txt&quot;;</p>

<p>This is the output when it is executed:</p>

<p>The Start 1 4 5 The End</p>

<p>So far so good. Those of you who have been paying
attention will have spotted that the tied object hasnt been
used so far. So lets add an extra method to the Remember
class to allow comments to be included in the file -- say,
something like this:</p>

<p>sub comment { my $self = shift; my $text = shift; my
$handle = $self-&gt;{FH}; print $handle $text, &quot;0;
}</p>

<p>And here is the previous example modified to use the
&quot;comment&quot; method (which requires the tied
object):</p>

<p>use strict; use Remember;</p>

<p>my ($fred, $x); $x = tie $fred, &rsquo;Remember&rsquo;,
&rsquo;myfile.txt&rsquo;; $fred = 1; $fred = 4; comment $x
&quot;changing...&quot;; $fred = 5; untie $fred; system
&quot;cat myfile.txt&quot;;</p>

<p>When this code is executed there is no output. Heres
why:</p>

<p>When a variable is tied, it is associated with the
object which is the return value of the TIESCALAR, TIEARRAY,
or TIEHASH function. This object normally has only one
reference, namely, the implicit reference from the tied
variable. When untie() is called, that reference is
destroyed. Then, as in the first example above, the objects
destructor (DESTROY) is called, which is normal for objects
that have no more valid references; and thus the file is
closed.</p>

<p>In the second example, however, we have stored another
reference to the tied object in $x. That means that when
untie() gets called there will still be a valid reference to
the object in existence, so the destructor is not called at
that time, and thus the file is not closed. The reason there
is no output is because the file buffers have not been
flushed to disk.</p>

<p>Now that you know what the problem is, what can you do
to avoid it? Prior to the introduction of the optional UNTIE
method the only way was the good old &quot;-w&quot; flag.
Which will spot any instances where you call untie() and
there are still valid references to the tied object. If the
second script above this near the top &quot;use warnings
&rsquo;untie&rsquo;&quot; or was run with the &quot;-w&quot;
flag, Perl prints this warning message:</p>

<p>untie attempted while 1 inner references still exist</p>

<p>To get the script to work properly and silence the
warning make sure there are no valid references to the tied
object before untie() is called:</p>

<p>undef $x; untie $fred;</p>

<p>Now that UNTIE exists the class designer can decide
which parts of the class functionality are really associated
with &quot;untie&quot; and which with the object being
destroyed. What makes sense for a given class depends on
whether the inner references are being kept so that
non-tie-related methods can be called on the object. But in
most cases it probably makes sense to move the functionality
that would have been in DESTROY to the UNTIE method.</p>

<p>If the UNTIE method exists then the warning above does
not occur. Instead the UNTIE method is passed the count of
&quot;extra&quot; references and can issue its own warning
if appropriate. e.g. to replicate the no UNTIE case this
method can be used:</p>

<p>sub UNTIE { my ($obj,$count) = @_; carp &quot;untie
attempted while $count inner references still exist&quot; if
$count; }</p>

<p>SEE ALSO See DB_File or Config for some interesting
tie() implementations. A good starting point for many tie()
implementations is with one of the modules Tie::Scalar,
Tie::Array, Tie::Hash, or Tie::Handle.</p>

<p>BUGS The bucket usage information provided by
&quot;scalar(%hash)&quot; is not available. What this means
is that using %tied_hash in boolean context doesn t work
right (currently this always tests false, regardless of
whether the hash is empty or hash elements).</p>

<p>Localizing tied arrays or hashes does not work. After
exiting the scope the arrays or the hashes are not
restored.</p>

<p>Counting the number of entries in a hash via
&quot;scalar(keys(%hash))&quot; or
&quot;scalar(values(%hash)&quot;) is inefficient since it
needs to iterate through all the entries with
FIRSTKEY/NEXTKEY.</p>

<p>Tied hash/array slices cause multiple FETCH/STORE pairs,
there are no tie methods for slice operations.</p>

<p>You cannot easily tie a multilevel data structure (such
as a hash of hashes) to a dbm file. The first problem is
that all but GDBM and Berkeley DB have size limitations, but
beyond that, you also have problems with how references are
to be represented on disk. One module that does attempt to
address this need is DBM::Deep. Check your nearest CPAN site
as described in perlmodlib for source code. Note that
despite its name, DBM::Deep does not use dbm. Another
earlier attempt at solving the problem is MLDBM, which is
also available on the CPAN, but which has some fairly
serious limitations.</p>

<p>Tied filehandles are still incomplete. sysopen(),
truncate(), flock(), fcntl(), stat() and -X cant currently
be trapped.</p>

<p>AUTHOR Tom Christiansen</p>

<p>TIEHANDLE by Sven Verdoolaege
&lt;skimo@dns.ufsia.ac.be&gt; and Doug MacEachern
&lt;dougm@osf.org&gt;</p>

<p>UNTIE by Nick Ing-Simmons
&lt;nick@ing-simmons.net&gt;</p>

<p>SCALAR by Tassilo von Parseval
&lt;tassilo.von.parseval@rwth-aachen.de&gt;</p>

<p>Tying Arrays by Casey West
&lt;casey@geeknest.com&gt;</p>

<p>perl v5.10.1 2009-05-06 PERLTIE(1)</p>
<hr>
</body>
</html>
