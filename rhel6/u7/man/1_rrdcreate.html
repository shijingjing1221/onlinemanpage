<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:31:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RRDCREATE(1) rrdtool RRDCREATE(1)</p>

<p>NAME rrdcreate - Set up a new Round Robin Database</p>

<p>SYNOPSIS rrdtool create filename [--start|-b start time]
[--step|-s step] [DS:ds-name:DST:dst arguments] [RRA:CF:cf
arguments]</p>

<p>DESCRIPTION The create function of RRDtool lets you set
up new Round Robin Database (RRD) files. The file is created
at its final, full size and filled with *UNKNOWN* data.</p>

<p>filename The name of the RRD you want to create. RRD
files should end with the extension .rrd. However, RRDtool
will accept any filename.</p>

<p>--start|-b start time (default: now - 10s) Specifies the
time in seconds since 1970-01-01 UTC when the first value
should be added to the RRD. RRDtool will not accept any data
timed before or at the time specified.</p>

<p>See also AT-STYLE TIME SPECIFICATION section in the
rrdfetch documentation for other ways to specify time.</p>

<p>--step|-s step (default: 300 seconds) Specifies the base
interval in seconds with which data will be fed into the
RRD.</p>

<p>DS:ds-name:DST:dst arguments A single RRD can accept
input from several data sources (DS), for example incoming
and outgoing traffic on a specific communication line. With
the DS configuration option you must define some basic
properties of each data source you want to store in the
RRD.</p>

<p>ds-name is the name you will use to reference this
particular data source from an RRD. A ds-name must be 1 to
19 characters long in the characters [a-zA-Z0-9_].</p>

<p>DST defines the Data Source Type. The remaining
arguments of a data source entry depend on the data source
type. For GAUGE, COUNTER, DERIVE, and ABSOLUTE the format
for a data source entry is:</p>

<p>DS:ds-name:GAUGE | COUNTER | DERIVE |
ABSOLUTE:heartbeat:min:max</p>

<p>For COMPUTE data sources, the format is:</p>

<p>DS:ds-name:COMPUTE:rpn-expression</p>

<p>In order to decide which data source type to use, review
the definitions that follow. Also consult the section on
&quot;HOW TO MEASURE&quot; for further insight.</p>

<p>GAUGE is for things like temperatures or number of
people in a room or the value of a RedHat share.</p>

<p>COUNTER is for continuous incrementing counters like the
ifInOctets counter in a router. The COUNTER data source
assumes that the counter never decreases, except when a
counter overflows. The update function takes the overflow
into account. The counter is stored as a per- second rate.
When the counter overflows, RRDtool checks if the overflow
happened at the 32bit or 64bit border and acts accordingly
by adding an appropriate value to the result.</p>

<p>DERIVE will store the derivative of the line going from
the last to the current value of the data source. This can
be useful for gauges, for example, to measure the rate of
people entering or leaving a room. Internally, derive works
exactly like COUNTER but without overflow checks. So if your
counter does not reset at 32 or 64 bit you might want to use
DERIVE and combine it with a MIN value of 0.</p>

<p>NOTE on COUNTER vs DERIVE</p>

<p>by Don Baarda &lt;don.baarda@baesystems.com&gt;</p>

<p>If you cannot tolerate ever mistaking the occasional
counter reset for a legitimate counter wrap, and would
prefer &quot;Unknowns&quot; for all legitimate counter wraps
and resets, always use DERIVE with min=0. Otherwise, using
COUNTER with a suitable max will return correct values for
all legitimate counter wraps, mark some counter resets as
&quot;Unknown&quot;, but can mistake some counter resets for
a legitimate counter wrap.</p>

<p>For a 5 minute step and 32-bit counter, the probability
of mistaking a counter reset for a legitimate wrap is
arguably about 0.8% per 1Mbps of maximum bandwidth. Note
that this equates to 80% for 100Mbps interfaces, so for high
bandwidth interfaces and a 32bit counter, DERIVE with min=0
is probably preferable. If you are using a 64bit counter,
just about any max setting will eliminate the possibility of
mistaking a reset for a counter wrap.</p>

<p>ABSOLUTE is for counters which get reset upon reading.
This is used for fast counters which tend to overflow. So
instead of reading them normally you reset them after every
read to make sure you have a maximum time available before
the next overflow. Another usage is for things you count
like number of messages since the last update.</p>

<p>COMPUTE is for storing the result of a formula applied
to other data sources in the RRD. This data source is not
supplied a value on update, but rather its Primary Data
Points (PDPs) are computed from the PDPs of the data sources
according to the rpn-expression that defines the formula.
Consolidation functions are then applied normally to the
PDPs of the COMPUTE data source (that is the rpn- expression
is only applied to generate PDPs). In database software,
such data sets are referred to as &quot;virtual&quot; or
&quot;computed&quot; columns.</p>

<p>heartbeat defines the maximum number of seconds that may
pass between two updates of this data source before the
value of the data source is assumed to be *UNKNOWN*.</p>

<p>min and max define the expected range values for data
supplied by a data source. If min and/or max any value
outside the defined range will be regarded as *UNKNOWN*. If
you do not know or care about min and max, set them to U for
unknown. Note that min and max always refer to the processed
values of the DS. For a traffic-COUNTER type DS this would
be the maximum and minimum data-rate expected from the
device.</p>

<p>If information on minimal/maximal expected values is
available, always set the min and/or max properties. This
will help RRDtool in doing a simple sanity check on the data
supplied when running update.</p>

<p>rpn-expression defines the formula used to compute the
PDPs of a COMPUTE data source from other data sources in the
same &lt;RRD&gt;. It is similar to defining a CDEF argument
for the graph command. Please refer to that manual page for
a list and description of RPN operations supported. For
COMPUTE data sources, the following RPN operations are not
supported: COUNT, PREV, TIME, and LTIME. In addition, in
defining the RPN expression, the COMPUTE data source may
only refer to the names of data source listed previously in
the create command. This is similar to the restriction that
CDEFs must refer only to DEFs and CDEFs previously defined
in the same graph command.</p>

<p>RRA:CF:cf arguments The purpose of an RRD is to store
data in the round robin archives (RRA). An archive consists
of a number of data values or statistics for each of the
defined data-sources (DS) and is defined with an RRA
line.</p>

<p>When data is entered into an RRD, it is first fit into
time slots of the length defined with the -s option, thus
becoming a primary data point.</p>

<p>The data is also processed with the consolidation
function (CF) of the archive. There are several
consolidation functions that consolidate primary data points
via an aggregate function: AVERAGE, MIN, MAX, LAST.</p>

<p>AVERAGE the average of the data points is stored.</p>

<p>MIN the smallest of the data points is stored.</p>

<p>MAX the largest of the data points is stored.</p>

<p>LAST the last data points is used.</p>

<p>Note that data aggregation inevitably leads to loss of
precision and information. The trick is to pick the
aggregate function such that the interesting properties of
your data is kept across the aggregation process.</p>

<p>The format of RRA line for these consolidation functions
is:</p>

<p>RRA:AVERAGE | MIN | MAX | LAST:xff:steps:rows</p>

<p>xff The xfiles factor defines what part of a
consolidation interval may be made up from *UNKNOWN* data
while the consolidated value is still regarded as known. It
is given as the ratio of allowed *UNKNOWN* PDPs to the
number of PDPs in the interval. Thus, it ranges from 0 to 1
(exclusive).</p>

<p>steps defines how many of these primary data points are
used to build a consolidated data point which then goes into
the archive.</p>

<p>rows defines how many generations of data values are
kept in an RRA. Obviously, this has to be greater than
zero.</p>

<p>Aberrant Behavior Detection with Holt-Winters
Forecasting In addition to the aggregate functions, there
are a set of specialized functions that enable RRDtool to
provide data smoothing (via the Holt- Winters forecasting
algorithm), confidence bands, and the flagging aberrant
behavior in the data source time series:</p>

<p>&middot; RRA:HWPREDICT:rows:alpha:beta:seasonal
period[:rra-num]</p>

<p>&middot; RRA:MHWPREDICT:rows:alpha:beta:seasonal
period[:rra-num]</p>

<p>&middot; RRA:SEASONAL:seasonal period:gamma:rra-
num[:smoothing-window=fraction]</p>

<p>&middot; RRA:DEVSEASONAL:seasonal period:gamma:rra-
num[:smoothing-window=fraction]</p>

<p>&middot; RRA:DEVPREDICT:rows:rra-num</p>

<p>&middot; RRA:FAILURES:rows:threshold:window
length:rra-num</p>

<p>These RRAs differ from the true consolidation functions
in several ways. First, each of the RRAs is updated once for
every primary data point. Second, these RRAs are
interdependent. To generate real-time confidence bounds, a
matched set of SEASONAL, DEVSEASONAL, DEVPREDICT, and either
HWPREDICT or MHWPREDICT must exist. Generating smoothed
values of the primary data points requires a SEASONAL RRA
and either an HWPREDICT or MHWPREDICT RRA. Aberrant behavior
detection requires FAILURES, DEVSEASONAL, SEASONAL, and
either HWPREDICT or MHWPREDICT.</p>

<p>The predicted, or smoothed, values are stored in the
HWPREDICT or MHWPREDICT RRA. HWPREDICT and MHWPREDICT are
actually two variations on the Holt-Winters method. They are
interchangeable. Both attempt to decompose data into three
components: a baseline, a trend, and a seasonal coefficient.
HWPREDICT adds its seasonal coefficient to the baseline to
form a prediction, whereas MHWPREDICT multiplies its
seasonal coefficient by the baseline to form a prediction.
The difference is noticeable when the baseline changes
significantly in the course of a season; HWPREDICT will
predict the seasonality to stay constant as the baseline
changes, but MHWPREDICT will predict the seasonality to grow
or shrink in proportion to the baseline. The proper choice
of method depends on the thing being modeled. For
simplicity, the rest of this discussion will refer to
HWPREDICT, but MHWPREDICT may be substituted in its
place.</p>

<p>The predicted deviations are stored in DEVPREDICT (think
a standard deviation which can be scaled to yield a
confidence band). The FAILURES RRA stores binary indicators.
A 1 marks the indexed observation as failure; that is, the
number of confidence bounds violations in the preceding
window of observations met or exceeded a specified
threshold. An example of using these RRAs to graph
confidence bounds and failures appears in rrdgraph.</p>

<p>The SEASONAL and DEVSEASONAL RRAs store the seasonal
coefficients for the Holt-Winters forecasting algorithm and
the seasonal deviations, respectively. There is one entry
per observation time point in the seasonal cycle. For
example, if primary data points are generated every five
minutes and the seasonal cycle is 1 day, both SEASONAL and
DEVSEASONAL will have 288 rows.</p>

<p>In order to simplify the creation for the novice user,
in addition to supporting explicit creation of the
HWPREDICT, SEASONAL, DEVPREDICT, DEVSEASONAL, and FAILURES
RRAs, the RRDtool create command supports implicit creation
of the other four when HWPREDICT is specified alone and the
final argument rra-num is omitted.</p>

<p>rows specifies the length of the RRA prior to wrap
around. Remember that there is a one-to-one correspondence
between primary data points and entries in these RRAs. For
the HWPREDICT CF, rows should be larger than the seasonal
period. If the DEVPREDICT RRA is implicitly created, the
default number of rows is the same as the HWPREDICT rows
argument. If the FAILURES RRA is implicitly created, rows
will be set to the seasonal period argument of the HWPREDICT
RRA. Of course, the RRDtool resize command is available if
these defaults are not sufficient and the creator wishes to
avoid explicit creations of the other specialized function
RRAs.</p>

<p>seasonal period specifies the number of primary data
points in a seasonal cycle. If SEASONAL and DEVSEASONAL are
implicitly created, this argument for those RRAs is set
automatically to the value specified by HWPREDICT. If they
are explicitly created, the creator should verify that all
three seasonal period arguments agree.</p>

<p>alpha is the adaption parameter of the intercept (or
baseline) coefficient in the Holt-Winters forecasting
algorithm. See rrdtool for a description of this algorithm.
alpha must lie between 0 and 1. A value closer to 1 means
that more recent observations carry greater weight in
predicting the baseline component of the forecast. A value
closer to 0 means that past history carries greater weight
in predicting the baseline component.</p>

<p>beta is the adaption parameter of the slope (or linear
trend) coefficient in the Holt-Winters forecasting
algorithm. beta must lie between 0 and 1 and plays the same
role as alpha with respect to the predicted linear
trend.</p>

<p>gamma is the adaption parameter of the seasonal
coefficients in the Holt-Winters forecasting algorithm
(HWPREDICT) or the adaption parameter in the exponential
smoothing update of the seasonal deviations. It must lie
between 0 and 1. If the SEASONAL and DEVSEASONAL RRAs are
created implicitly, they will both have the same value for
gamma: the value specified for the HWPREDICT alpha argument.
Note that because there is one seasonal coefficient (or
deviation) for each time point during the seasonal cycle,
the adaptation rate is much slower than the baseline. Each
seasonal coefficient is only updated (or adapts) when the
observed value occurs at the offset in the seasonal cycle
corresponding to that coefficient.</p>

<p>If SEASONAL and DEVSEASONAL RRAs are created explicitly,
gamma need not be the same for both. Note that gamma can
also be changed via the RRDtool tune command.</p>

<p>smoothing-window specifies the fraction of a season that
should be averaged around each point. By default, the value
of smoothing-window is 0.05, which means each value in
SEASONAL and DEVSEASONAL will be occasionally replaced by
averaging it with its (seasonal period*0.05) nearest
neighbors. Setting smoothing-window to zero will disable the
running-average smoother altogether.</p>

<p>rra-num provides the links between related RRAs. If
HWPREDICT is specified alone and the other RRAs are created
implicitly, then there is no need to worry about this
argument. If RRAs are created explicitly, then carefully pay
attention to this argument. For each RRA which includes this
argument, there is a dependency between that RRA and another
RRA. The rra-num argument is the 1-based index in the order
of RRA creation (that is, the order they appear in the
create command). The dependent RRA for each RRA requiring
the rra-num argument is listed here:</p>

<p>&middot; HWPREDICT rra-num is the index of the SEASONAL
RRA.</p>

<p>&middot; SEASONAL rra-num is the index of the HWPREDICT
RRA.</p>

<p>&middot; DEVPREDICT rra-num is the index of the
DEVSEASONAL RRA.</p>

<p>&middot; DEVSEASONAL rra-num is the index of the
HWPREDICT RRA.</p>

<p>&middot; FAILURES rra-num is the index of the
DEVSEASONAL RRA.</p>

<p>threshold is the minimum number of violations (observed
values outside the confidence bounds) within a window that
constitutes a failure. If the FAILURES RRA is implicitly
created, the default value is 7.</p>

<p>window length is the number of time points in the
window. Specify an integer greater than or equal to the
threshold and less than or equal to 28. The time interval
this window represents depends on the interval between
primary data points. If the FAILURES RRA is implicitly
created, the default value is 9.</p>

<p>The HEARTBEAT and the STEP Here is an explanation by Don
Baarda on the inner workings of RRDtool. It may help you to
sort out why all this *UNKNOWN* data is popping up in your
databases:</p>

<p>RRDtool gets fed samples/updates at arbitrary times.
From these it builds Primary Data Points (PDPs) on every
&quot;step&quot; interval. The PDPs are then accumulated
into the RRAs.</p>

<p>The &quot;heartbeat&quot; defines the maximum acceptable
interval between samples/updates. If the interval between
samples is less than &quot;heartbeat&quot;, then an average
rate is calculated and applied for that interval. If the
interval between samples is longer than
&quot;heartbeat&quot;, then that entire interval is
considered &quot;unknown&quot;. Note that there are other
things that can make a sample interval &quot;unknown&quot;,
such as the rate exceeding limits, or a sample that was
explicitly marked as unknown.</p>

<p>The known rates during a PDPs &quot;step&quot; interval
are used to calculate an average rate for that PDP. If the
total &quot;unknown&quot; time accounts for more than half
the &quot;step&quot;, the entire PDP is marked as
&quot;unknown&quot;. This means that a mixture of known and
&quot;unknown&quot; sample times in a single PDP
&quot;step&quot; may or may not add up to enough
&quot;known&quot; time to warrent for a known PDP.</p>

<p>The &quot;heartbeat&quot; can be short (unusual) or long
(typical) relative to the &quot;step&quot; interval between
PDPs. A short &quot;heartbeat&quot; means you require
multiple samples per PDP, and if you dont get them mark the
PDP unknown. A long heartbeat can span multiple
&quot;steps&quot;, which means it is acceptable to have
multiple PDPs calculated from a single sample. An extreme
example of this might be a &quot;step&quot; of 5 minutes and
a &quot;heartbeat&quot; of one day, in which case a single
sample every day will result in all the PDPs for that entire
day period being set to the same average rate. -- Don Baarda
&lt;don.baarda@baesystems.com&gt;</p>

<p>time| axis| begin__|00| |01| u|02|----* sample1, restart
&quot;hb&quot;-timer u|03| / u|04| / u|05| / u|06|/
&quot;hbt&quot; expired u|07| |08|----* sample2, restart
&quot;hb&quot; |09| / |10| / u|11|----* sample3, restart
&quot;hb&quot; u|12| / u|13| / step1_u|14| / u|15|/
&quot;swt&quot; expired u|16| |17|----* sample4, restart
&quot;hb&quot;, create &quot;pdp&quot; for step1 = |18| / =
unknown due to 10 &quot;u&quot; labled secs &gt; 0.5 * step
|19| / |20| / |21|----* sample5, restart &quot;hb&quot; |22|
/ |23| / |24|----* sample6, restart &quot;hb&quot; |25| /
|26| / |27|----* sample7, restart &quot;hb&quot; step2__|28|
/ |22| / |23|----* sample8, restart &quot;hb&quot;, create
&quot;pdp&quot; for step1, create &quot;cdp&quot; |24| /
|25| /</p>

<p>graphics by vladimir.lavrov@desy.de.</p>

<p>HOW TO MEASURE Here are a few hints on how to
measure:</p>

<p>Temperature Usually you have some type of meter you can
read to get the temperature. The temperature is not really
connected with a time. The only connection is that the
temperature reading happened at a certain time. You can use
the GAUGE data source type for this. RRDtool will then
record your reading together with the time.</p>

<p>Mail Messages Assume you have a method to count the
number of messages transported by your mailserver in a
certain amount of time, giving you data like 5 messages in
the last 65 seconds. If you look at the count of 5 like an
ABSOLUTE data type you can simply update the RRD with the
number 5 and the end time of your monitoring period. RRDtool
will then record the number of messages per second. If at
some later stage you want to know the number of messages
transported in a day, you can get the average messages per
second from RRDtool for the day in question and multiply
this number with the number of seconds in a day. Because all
math is run with Doubles, the precision should be
acceptable.</p>

<p>Its always a Rate RRDtool stores rates in amount/second
for COUNTER, DERIVE and ABSOLUTE data. When you plot the
data, you will get on the y axis amount/second which you
might be tempted to convert to an absolute amount by
multiplying by the delta-time between the points. RRDtool
plots continuous data, and as such is not appropriate for
plotting absolute amounts as for example &quot;total
bytes&quot; sent and received in a router. What you probably
want is plot rates that you can scale to bytes/hour, for
example, or plot absolute amounts with another tool that
draws bar-plots, where the delta-time is clear on the plot
for each point (such that when you read the graph you see
for example GB on the y axis, days on the x axis and one bar
for each day).</p>

<p>EXAMPLE rrdtool create temperature.rrd --step 300
DS:temp:GAUGE:600:-273:5000 RRA:AVERAGE:0.5:1:1200
RRA:MIN:0.5:12:2400 RRA:MAX:0.5:12:2400
RRA:AVERAGE:0.5:12:2400</p>

<p>This sets up an RRD called temperature.rrd which accepts
one temperature value every 300 seconds. If no new data is
supplied for more than 600 seconds, the temperature becomes
*UNKNOWN*. The minimum acceptable value is -273 and the
maximum is 5000.</p>

<p>A few archive areas are also defined. The first stores
the temperatures supplied for 100 hours (1200 * 300 seconds
= 100 hours). The second RRA stores the minimum temperature
recorded over every hour (12 * 300 seconds = 1 hour), for
100 days (2400 hours). The third and the fourth RRAs do the
same for the maximum and average temperature,
respectively.</p>

<p>EXAMPLE 2 rrdtool create monitor.rrd --step 300
DS:ifOutOctets:COUNTER:1800:0:4294967295
RRA:AVERAGE:0.5:1:2016 RRA:HWPREDICT:1440:0.1:0.0035:288</p>

<p>This example is a monitor of a router interface. The
first RRA tracks the traffic flow in octets; the second RRA
generates the specialized functions RRAs for aberrant
behavior detection. Note that the rra-num argument of
HWPREDICT is missing, so the other RRAs will implicitly be
created with default parameter values. In this example, the
forecasting algorithm baseline adapts quickly; in fact the
most recent one hour of observations (each at 5 minute
intervals) accounts for 75% of the baseline prediction. The
linear trend forecast adapts much more slowly. Observations
made during the last day (at 288 observations per day)
account for only 65% of the predicted linear trend. Note:
these computations rely on an exponential smoothing formula
described in the LISA 2000 paper.</p>

<p>The seasonal cycle is one day (288 data points at 300
second intervals), and the seasonal adaption parameter will
be set to 0.1. The RRD file will store 5 days (1440 data
points) of forecasts and deviation predictions before wrap
around. The file will store 1 day (a seasonal cycle) of 0-1
indicators in the FAILURES RRA.</p>

<p>The same RRD file and RRAs are created with the
following command, which explicitly creates all specialized
function RRAs.</p>

<p>rrdtool create monitor.rrd --step 300
DS:ifOutOctets:COUNTER:1800:0:4294967295
RRA:AVERAGE:0.5:1:2016 RRA:HWPREDICT:1440:0.1:0.0035:288:3
RRA:SEASONAL:288:0.1:2 RRA:DEVPREDICT:1440:5
RRA:DEVSEASONAL:288:0.1:2 RRA:FAILURES:288:7:9:5</p>

<p>Of course, explicit creation need not replicate implicit
create, a number of arguments could be changed.</p>

<p>EXAMPLE 3 rrdtool create proxy.rrd --step 300
DS:Total:DERIVE:1800:0:U DS:Duration:DERIVE:1800:0:U
DS:AvgReqDur:COMPUTE:Duration,Requests,0,EQ,1,Requests,IF,/
RRA:AVERAGE:0.5:1:2016</p>

<p>This example is monitoring the average request duration
during each 300 sec interval for requests processed by a web
proxy during the interval. In this case, the proxy exposes
two counters, the number of requests processed since boot
and the total cumulative duration of all processed requests.
Clearly these counters both have some rollover point, but
using the DERIVE data source also handles the reset that
occurs when the web proxy is stopped and restarted.</p>

<p>In the RRD, the first data source stores the requests
per second rate during the interval. The second data source
stores the total duration of all requests processed during
the interval divided by 300. The COMPUTE data source divides
each PDP of the AccumDuration by the corresponding PDP of
TotalRequests and stores the average request duration. The
remainder of the RPN expression handles the divide by zero
case.</p>

<p>AUTHOR Tobias Oetiker &lt;tobi@oetiker.ch&gt;</p>

<p>1.3.8 2008-06-11 RRDCREATE(1)</p>
<hr>
</body>
</html>
