<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:14 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLINTERN(1) Perl Programmers Reference Guide
PERLINTERN(1)</p>

<p>NAME perlintern - autogenerated documentation of purely
internal Perl functions</p>

<p>DESCRIPTION This file is the autogenerated documentation
of functions in the Perl interpreter that are documented
using Perl s internal documentation format but are not
marked as part of the Perl API. In other words, they are not
for use in extensions!</p>

<p>CV reference counts and CvOUTSIDE CvWEAKOUTSIDE Each CV
has a pointer, &quot;CvOUTSIDE()&quot;, to its lexically
enclosing CV (if any). Because pointers to anonymous sub
prototypes are stored in &quot;&amp;&quot; pad slots, it is
a possible to get a circular reference, with the parent
pointing to the child and vice-versa. To avoid the ensuing
memory leak, we do not increment the reference count of the
CV pointed to by &quot;CvOUTSIDE&quot; in the one specific
instance that the parent has a &quot;&amp;&quot; pad slot
pointing back to us. In this case, we set the
&quot;CvWEAKOUTSIDE&quot; flag in the child. This allows us
to determine under what circumstances we should decrement
the refcount of the parent when freeing the child.</p>

<p>There is a further complication with non-closure
anonymous subs (i.e. those that do not refer to any lexicals
outside that sub). In this case, the anonymous prototype is
shared rather than being cloned. This has the consequence
that the parent may be freed while there are still active
children, eg</p>

<p>BEGIN { $a = sub { eval &rsquo;$x&rsquo; } }</p>

<p>In this case, the BEGIN is freed immediately after
execution since there are no active references to it: the
anon sub prototype has &quot;CvWEAKOUTSIDE&quot; set since
its not a closure, and $a points to the same CV, so it
doesnt contribute to BEGINs refcount either. When $a is
executed, the &quot;eval &rsquo;$x&rsquo;&quot; causes the
chain of &quot;CvOUTSIDE&quot;s to be followed, and the
freed BEGIN is accessed.</p>

<p>To avoid this, whenever a CV and its associated pad is
freed, any &quot;&amp;&quot; entries in the pad are
explicitly removed from the pad, and if the refcount of the
pointed-to anon sub is still positive, then that childs
&quot;CvOUTSIDE&quot; is set to point to its grandparent.
This will only occur in the single specific case of a
non-closure anon prototype having one or more active
references (such as $a above).</p>

<p>One other thing to consider is that a CV may be merely
undefined rather than freed, eg &quot;undef &amp;foo&quot;.
In this case, its refcount may not have reached zero, but we
still delete its pad and its &quot;CvROOT&quot; etc. Since
various children may still have their &quot;CvOUTSIDE&quot;
pointing at this undefined CV, we keep its own
&quot;CvOUTSIDE&quot; for the time being, so that the chain
of lexical scopes is unbroken. For example, the following
should print 123:</p>

<p>my $x = 123; sub tmp { sub { eval &rsquo;$x&rsquo; } }
my $a = tmp(); undef &amp;tmp; print $a-&gt;();</p>

<p>bool CvWEAKOUTSIDE(CV *cv)</p>

<p>Functions in file pad.h CX_CURPAD_SAVE Save the current
pad in the given context block structure.</p>

<p>void CX_CURPAD_SAVE(struct context)</p>

<p>CX_CURPAD_SV Access the SV at offset po in the saved
current pad in the given context block structure (can be
used as an lvalue).</p>

<p>SV * CX_CURPAD_SV(struct context, PADOFFSET po)</p>

<p>PAD_BASE_SV Get the value from slot &quot;po&quot; in
the base (DEPTH=1) pad of a padlist</p>

<p>SV * PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</p>

<p>PAD_CLONE_VARS Clone the state variables associated with
running and compiling pads.</p>

<p>void PAD_CLONE_VARS(PerlInterpreter *proto_perl,
CLONE_PARAMS* param)</p>

<p>PAD_COMPNAME_FLAGS Return the flags for the current
compiling pad name at offset &quot;po&quot;. Assumes a valid
slot entry.</p>

<p>U32 PAD_COMPNAME_FLAGS(PADOFFSET po)</p>

<p>PAD_COMPNAME_GEN The generation number of the name at
offset &quot;po&quot; in the current compiling pad (lvalue).
Note that &quot;SvUVX&quot; is hijacked for this
purpose.</p>

<p>STRLEN PAD_COMPNAME_GEN(PADOFFSET po)</p>

<p>PAD_COMPNAME_GEN_set Sets the generation number of the
name at offset &quot;po&quot; in the current ling pad
(lvalue) to &quot;gen&quot;. Note that &quot;SvUV_set&quot;
is hijacked for this purpose.</p>

<p>STRLEN PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p>

<p>PAD_COMPNAME_OURSTASH Return the stash associated with
an &quot;our&quot; variable. Assumes the slot entry is a
valid &quot;our&quot; lexical.</p>

<p>HV * PAD_COMPNAME_OURSTASH(PADOFFSET po)</p>

<p>PAD_COMPNAME_PV Return the name of the current compiling
pad name at offset &quot;po&quot;. Assumes a valid slot
entry.</p>

<p>char * PAD_COMPNAME_PV(PADOFFSET po)</p>

<p>PAD_COMPNAME_TYPE Return the type (stash) of the current
compiling pad name at offset &quot;po&quot;. Must be a valid
name. Returns null if not typed.</p>

<p>HV * PAD_COMPNAME_TYPE(PADOFFSET po)</p>

<p>PAD_DUP Clone a padlist.</p>

<p>void PAD_DUP(PADLIST dstpad, PADLIST srcpad,
CLONE_PARAMS* param)</p>

<p>PAD_RESTORE_LOCAL Restore the old pad saved into the
local variable opad by PAD_SAVE_LOCAL()</p>

<p>void PAD_RESTORE_LOCAL(PAD *opad)</p>

<p>PAD_SAVE_LOCAL Save the current pad to the local
variable opad, then make the current pad equal to npad</p>

<p>void PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</p>

<p>PAD_SAVE_SETNULLPAD Save the current pad then set it to
null.</p>

<p>void PAD_SAVE_SETNULLPAD()</p>

<p>PAD_SETSV Set the slot at offset &quot;po&quot; in the
current pad to &quot;sv&quot;</p>

<p>SV * PAD_SETSV(PADOFFSET po, SV* sv)</p>

<p>PAD_SET_CUR Set the current pad to be pad &quot;n&quot;
in the padlist, saving the previous current pad. NB
currently this macro expands to a string too long for some
compilers, so its best to replace it with</p>

<p>SAVECOMPPAD(); PAD_SET_CUR_NOSAVE(padlist,n);</p>

<p>void PAD_SET_CUR(PADLIST padlist, I32 n)</p>

<p>PAD_SET_CUR_NOSAVE like PAD_SET_CUR, but without the
save</p>

<p>void PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</p>

<p>PAD_SV Get the value at offset &quot;po&quot; in the
current pad</p>

<p>void PAD_SV(PADOFFSET po)</p>

<p>PAD_SVl Lightweight and lvalue version of
&quot;PAD_SV&quot;. Get or set the value at offset
&quot;po&quot; in the current pad. Unlike
&quot;PAD_SV&quot;, does not print diagnostics with -DX. For
internal use only.</p>

<p>SV * PAD_SVl(PADOFFSET po)</p>

<p>SAVECLEARSV Clear the pointed to pad value on scope
exit. (i.e. the runtime action of my)</p>

<p>void SAVECLEARSV(SV **svp)</p>

<p>SAVECOMPPAD save PL_comppad and PL_curpad</p>

<p>void SAVECOMPPAD()</p>

<p>SAVEPADSV Save a pad slot (used to restore after an
iteration)</p>

<p>XXX DAPM it would make more sense to make the arg a
PADOFFSET void SAVEPADSV(PADOFFSET po)</p>

<p>GV Functions is_gv_magical Returns &quot;TRUE&quot; if
given the name of a magical GV.</p>

<p>Currently only useful internally when determining if a
GV should be created even in rvalue contexts.</p>

<p>&quot;flags&quot; is not used at present but available
for future extension to allow selecting particular classes
of magical variable.</p>

<p>Currently assumes that &quot;name&quot; is NUL
terminated (as well as len being valid). This assumption is
met by all callers within the perl core, which all pass
pointers returned by SvPV.</p>

<p>bool is_gv_magical(const char *name, STRLEN len, U32
flags)</p>

<p>is_gv_magical_sv Returns &quot;TRUE&quot; if given the
name of a magical GV. Calls is_gv_magical.</p>

<p>bool is_gv_magical_sv(SV *name, U32 flags)</p>

<p>Hash Manipulation Functions refcounted_he_chain_2hv
Generates and returns a &quot;HV *&quot; by walking up the
tree starting at the passed in &quot;struct refcounted_he
*&quot;.</p>

<p>HV * refcounted_he_chain_2hv(const struct refcounted_he
*c)</p>

<p>refcounted_he_free Decrements the reference count of the
passed in &quot;struct refcounted_he *&quot; by one. If the
reference count reaches zero the structure s memory is
freed, and &quot;refcounted_he_free&quot; iterates onto the
parent node.</p>

<p>void refcounted_he_free(struct refcounted_he *he)</p>

<p>refcounted_he_new Creates a new &quot;struct
refcounted_he&quot;. As key is copied, and value is stored
in a compact form, all references remain the property of the
caller. The &quot;struct refcounted_he&quot; is returned
with a reference count of 1.</p>

<p>struct refcounted_he * refcounted_he_new(struct
refcounted_he *const parent, SV *const key, SV *const
value)</p>

<p>IO Functions start_glob Function called by
&quot;do_readline&quot; to spawn a glob (or do the glob
inside perl on VMS). This code used to be inline, but now
perl uses &quot;File::Glob&quot; this glob starter is only
used by miniperl during the build process. Moving it away
shrinks pp_hot.c; shrinking pp_hot.c helps speed perl
up.</p>

<p>PerlIO* start_glob(SV *tmpglob, IO *io)</p>

<p>Magical Functions magic_clearhint Triggered by a delete
from %^H, records the key to
&quot;PL_compiling.cop_hints_hash&quot;.</p>

<p>int magic_clearhint(SV* sv, MAGIC* mg)</p>

<p>magic_sethint Triggered by a store to %^H, records the
key/value pair to &quot;PL_compiling.cop_hints_hash&quot;.
It is assumed that hints arent storing anything that would
need a deep copy. Maybe we should warn if we find a
reference.</p>

<p>int magic_sethint(SV* sv, MAGIC* mg)</p>

<p>mg_localize Copy some of the magic from an existing SV
to new localized version of that SV. Container magic (eg
%ENV, $1, tie) gets copied, value magic doesnt (eg taint,
pos).</p>

<p>void mg_localize(SV* sv, SV* nsv)</p>

<p>MRO Functions mro_get_linear_isa_dfs Returns the
Depth-First Search linearization of @ISA the given stash.
The return value is a read-only AV*. &quot;level&quot;
should be 0 (it is used internally in this function s
recursion).</p>

<p>You are responsible for &quot;SvREFCNT_inc()&quot; on
the return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted out from
under you the next time the cache is invalidated).</p>

<p>AV* mro_get_linear_isa_dfs(HV* stash, U32 level)</p>

<p>mro_isa_changed_in Takes the necessary steps (cache
invalidations, mostly) when the @ISA of the given package
has changed. Invoked by the &quot;setisa&quot; magic, should
not need to invoke directly.</p>

<p>void mro_isa_changed_in(HV* stash)</p>

<p>Pad Data Structures CvPADLIST CVs can have CvPADLIST(cv)
set to point to an AV.</p>

<p>For these purposes &quot;forms&quot; are a kind-of CV,
eval&quot;&quot;s are too (except theyre not callable at
will and are always thrown away after the eval&quot;&quot;
is done executing). Required files are simply evals without
any outer lexical scope.</p>

<p>XSUBs dont have CvPADLIST set - dXSTARG fetches values
from PL_curpad, but that is really the callers pad (a slot
of which is allocated by every entersub).</p>

<p>The CvPADLIST AV has does not have AvREAL set, so REFCNT
of component items is managed &quot;manual&quot; (mostly in
pad.c) rather than normal av.c rules. The items in the AV
are not SVs as for a normal AV, but other AVs:</p>

<p>0 th Entry of the CvPADLIST is an AV which represents
the &quot;names&quot; or rather the &quot;static type
information&quot; for lexicals.</p>

<p>The CvDEPTHth entry of CvPADLIST AV is an AV which is
the stack frame at that depth of recursion into the CV. The
0th slot of a frame AV is an AV which is @_. other entries
are storage for variables and op targets.</p>

<p>During compilation: &quot;PL_comppad_name&quot; is set
to the names AV. &quot;PL_comppad&quot; is set to the frame
AV for the frame CvDEPTH == 1. &quot;PL_curpad&quot; is set
to the body of the frame AV (i.e. AvARRAY(PL_comppad)).</p>

<p>During execution, &quot;PL_comppad&quot; and
&quot;PL_curpad&quot; refer to the live frame of the
currently executing sub.</p>

<p>Iterating over the names AV iterates over all possible
pad items. Pad slots that are SVs_PADTMP
(targets/GVs/constants) end up having &amp;PL_sv_undef
&quot;names&quot; (see pad_alloc()).</p>

<p>Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get
valid names. The rest are op targets/GVs/constants which are
statically allocated or resolved at compile time. These dont
have names by which they can be looked up from Perl code at
run time through eval&quot;&quot; like my/our variables can
be. Since they cant be looked up by &quot;name&quot; but
only by their index allocated at compile time (which is
usually in PL_op-&gt;op_targ), wasting a name SV for them
doesnt make sense.</p>

<p>The SVs in the names AV have their PV being the name of
the variable. xlow+1..xhigh inclusive in the NV union is a
range of cop_seq numbers for which the name is valid. For
typed lexicals name SV is SVt_PVMG and SvSTASH points at the
type. For &quot;our&quot; lexicals, the type is also
SVt_PVMG, with the SvOURSTASH slot pointing at the stash of
the associated global (so that duplicate &quot;our&quot;
declarations in the same package can be detected). SvUVX is
sometimes hijacked to store the generation number during
compilation.</p>

<p>If SvFAKE is set on the name SV, then that slot in the
frame AV is a REFCNT ed reference to a lexical from
&quot;outside&quot;. In this case, the name SV does not use
xlow and xhigh to store a cop_seq range, since it is in
scope throughout. Instead xhigh stores some flags containing
info about the real lexical (is it declared in an anon, and
is it capable of being instantiated multiple times?), and
for fake ANONs, xlow contains the index within the parents
pad where the lexicals value is stored, to make cloning
quicker.</p>

<p>If the name is &amp; the corresponding entry in frame AV
is a CV representing a possible closure. (SvFAKE and name of
&amp; is not a meaningful combination currently but could
become so if &quot;my sub foo {}&quot; is implemented.)</p>

<p>Note that formats are treated as anon subs, and are
cloned each time write is called (if necessary).</p>

<p>The flag SVf_PADSTALE is cleared on lexicals each time
the my() is executed, and set on scope exit. This allows the
Variable $x is not available warning to be generated in
evals, such as</p>

<p>{ my $x = 1; sub f { eval &rsquo;$x&rsquo;} } f();</p>

<p>For state vars, SVf_PADSTALE is overloaded to mean not
yet initialised</p>

<p>AV * CvPADLIST(CV *cv)</p>

<p>cv_clone Clone a CV: make a new CV which points to the
same code etc, but which has a newly-created pad built by
copying the prototype pad and capturing any outer
lexicals.</p>

<p>CV* cv_clone(CV* proto)</p>

<p>cv_dump dump the contents of a CV</p>

<p>void cv_dump(const CV *cv, const char *title)</p>

<p>do_dump_pad Dump the contents of a padlist</p>

<p>void do_dump_pad(I32 level, PerlIO *file, PADLIST
*padlist, int full)</p>

<p>intro_my &quot;Introduce&quot; my variables to visible
status.</p>

<p>U32 intro_my()</p>

<p>pad_add_anon Add an anon code entry to the current
compiling pad</p>

<p>PADOFFSET pad_add_anon(SV* sv, OPCODE op_type)</p>

<p>pad_add_name Create a new name and associated PADMY SV
in the current pad; return the offset. If
&quot;typestash&quot; is valid, the name is for a typed
lexical; set the names stash to that value. If
&quot;ourstash&quot; is valid, its an our lexical, set the
names SvOURSTASH to that value</p>

<p>If fake, it means were cloning an existing entry</p>

<p>PADOFFSET pad_add_name(const char *name, HV* typestash,
HV* ourstash, bool clone, bool state)</p>

<p>pad_alloc Allocate a new my or tmp pad entry. For a my,
simply push a null SV onto the end of PL_comppad, but for a
tmp, scan the pad from PL_padix upwards for a slot which has
no name and no active value.</p>

<p>PADOFFSET pad_alloc(I32 optype, U32 tmptype)</p>

<p>pad_block_start Update the pad compilation state
variables on entry to a new block</p>

<p>void pad_block_start(int full)</p>

<p>pad_check_dup Check for duplicate declarations: report
any of: * a my in the current scope with the same name; * an
our (anywhere in the pad) with the same name and the same
stash as &quot;ourstash&quot; &quot;is_our&quot; indicates
that the name to check is an our declaration</p>

<p>void pad_check_dup(const char* name, bool is_our, const
HV* ourstash)</p>

<p>pad_findlex Find a named lexical anywhere in a chain of
nested pads. Add fake entries in the inner pads if its found
in an outer one.</p>

<p>Returns the offset in the bottom pad of the lex or the
fake lex. cv is the CV in which to start the search, and seq
is the current cop_seq to match against. If warn is true,
print appropriate warnings. The out_* vars return values,
and so are pointers to where the returned values should be
stored. out_capture, if non-null, requests that the
innermost instance of the lexical is captured; out_name_sv
is set to the innermost matched namesv or fake namesv;
out_flags returns the flags normally associated with the IVX
field of a fake namesv.</p>

<p>Note that pad_findlex() is recursive; it recurses up the
chain of CVs, then comes back down, adding fake entries as
it goes. It has to be this way because fake namesvs in anon
protoypes have to store in xlow the index into the parent
pad.</p>

<p>PADOFFSET pad_findlex(const char *name, const CV* cv,
U32 seq, int warn, SV** out_capture, SV** out_name_sv, int
*out_flags)</p>

<p>pad_findmy Given a lexical name, try to find its offset,
first in the current pad, or failing that, in the pads of
any lexically enclosing subs (including the complications
introduced by eval). If the name is found in an outer pad,
then a fake entry is added to the current pad. Returns the
offset in the current pad, or NOT_IN_PAD on failure.</p>

<p>PADOFFSET pad_findmy(const char* name)</p>

<p>pad_fixup_inner_anons For any anon CVs in the pad,
change CvOUTSIDE of that CV from old_cv to new_cv if
necessary. Needed when a newly-compiled CV has to be moved
to a pre-existing CV struct.</p>

<p>void pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv,
CV *new_cv)</p>

<p>pad_free Free the SV at offset po in the current
pad.</p>

<p>void pad_free(PADOFFSET po)</p>

<p>pad_leavemy Cleanup at end of scope during compilation:
set the max seq number for lexicals in this scope and warn
of any lexicals that never got introduced.</p>

<p>void pad_leavemy()</p>

<p>pad_new Create a new compiling padlist, saving and
updating the various global vars at the same time as
creating the pad itself. The following flags can be ORed
together:</p>

<p>padnew_CLONE this pad is for a cloned CV padnew_SAVE
save old globals padnew_SAVESUB also save extra stuff for
start of sub</p>

<p>PADLIST* pad_new(int flags)</p>

<p>pad_push Push a new pad frame onto the padlist, unless
theres already a pad at this depth, in which case dont
bother creating a new one. Then give the new pad an @_ in
slot zero.</p>

<p>void pad_push(PADLIST *padlist, int depth)</p>

<p>pad_reset Mark all the current temporaries for reuse</p>

<p>void pad_reset()</p>

<p>pad_setsv Set the entry at offset po in the current pad
to sv. Use the macro PAD_SETSV() rather than calling this
function directly.</p>

<p>void pad_setsv(PADOFFSET po, SV* sv)</p>

<p>pad_swipe Abandon the tmp in the current pad at offset
po and replace with a new one.</p>

<p>void pad_swipe(PADOFFSET po, bool refadjust)</p>

<p>pad_tidy Tidy up a pad after weve finished compiling it:
* remove most stuff from the pads of anonsub prototypes; *
give it a @_; * mark tmps as such.</p>

<p>void pad_tidy(padtidy_type type)</p>

<p>pad_undef Free the padlist associated with a CV. If
parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we dont have any dangling
references left. We also repoint the CvOUTSIDE of any
about-to-be-orphaned inner subs to the outer of this cv.</p>

<p>(This function should really be called pad_free, but the
name was already taken)</p>

<p>void pad_undef(CV* cv)</p>

<p>Per-Interpreter Variables PL_DBsingle When Perl is run
in debugging mode, with the -d switch, this SV is a boolean
which indicates whether subs are being single- stepped.
Single-stepping is automatically turned on after every step.
This is the C variable which corresponds to Perls
$DB::single variable. See &quot;PL_DBsub&quot;.</p>

<p>SV * PL_DBsingle</p>

<p>PL_DBsub When Perl is run in debugging mode, with the -d
switch, this GV contains the SV which holds the name of the
sub being debugged. This is the C variable which corresponds
to Perls $DB::sub variable. See &quot;PL_DBsingle&quot;.</p>

<p>GV * PL_DBsub</p>

<p>PL_DBtrace Trace variable used when Perl is run in
debugging mode, with the -d switch. This is the C variable
which corresponds to Perls $DB::trace variable. See
&quot;PL_DBsingle&quot;.</p>

<p>SV * PL_DBtrace</p>

<p>PL_dowarn The C variable which corresponds to Perl s $^W
warning variable.</p>

<p>bool PL_dowarn</p>

<p>PL_last_in_gv The GV which was last used for a
filehandle input operation. (&quot;&lt;FH&gt;&quot;)</p>

<p>GV* PL_last_in_gv</p>

<p>PL_ofs_sv The output field separator - $, in Perl
space.</p>

<p>SV* PL_ofs_sv</p>

<p>PL_rs The input record separator - $/ in Perl space.</p>

<p>SV* PL_rs</p>

<p>Stack Manipulation Macros djSP Declare Just
&quot;SP&quot;. This is actually identical to
&quot;dSP&quot;, and declares a local copy of perls stack
pointer, available via the &quot;SP&quot; macro. See
&quot;SP&quot;. (Available for backward source code
compatibility with the old (Perl 5.005) thread model.)</p>

<p>djSP;</p>

<p>LVRET True if this op will be the return value of an
lvalue subroutine</p>

<p>SV Manipulation Functions sv_add_arena Given a chunk of
memory, link it to the head of the list of arenas, and split
it into a list of free SVs.</p>

<p>void sv_add_arena(char* ptr, U32 size, U32 flags)</p>

<p>sv_clean_all Decrement the refcnt of each remaining SV,
possibly triggering a cleanup. This function may have to be
called multiple times to free SVs which are in complex
self-referential hierarchies.</p>

<p>I32 sv_clean_all()</p>

<p>sv_clean_objs Attempt to destroy all objects not yet
freed</p>

<p>void sv_clean_objs()</p>

<p>sv_free_arenas Deallocate the memory used by all arenas.
Note that all the individual SV heads and bodies within the
arenas must already have been freed.</p>

<p>void sv_free_arenas()</p>

<p>SV-Body Allocation sv_2num Return an SV with the numeric
value of the source SV, doing any necessary reference or
overload conversion. You must use the &quot;SvNUM(sv)&quot;
macro to access this function.</p>

<p>SV* sv_2num(SV* sv)</p>

<p>Unicode Support find_uninit_var Find the name of the
undefined variable (if any) that caused the operator o to
issue a &quot;Use of uninitialized value&quot; warning. If
match is true, only return a name if its value matches
uninit_sv. So roughly speaking, if a unary operator (such as
OP_COS) generates a warning, then following the direct child
of the op may yield an OP_PADSV or OP_GV that gives the name
of the undefined variable. On the other hand, with OP_ADD
there are two branches to follow, so we only print the
variable name if we get an exact match.</p>

<p>The name is returned as a mortal SV.</p>

<p>Assumes that PL_op is the op that originally triggered
the error, and that PL_comppad/PL_curpad points to the
currently executing pad.</p>

<p>SV* find_uninit_var(OP* obase, SV* uninit_sv, bool
top)</p>

<p>report_uninit Print appropriate &quot;Use of
uninitialized variable&quot; warning</p>

<p>void report_uninit(SV* uninit_sv)</p>

<p>AUTHORS The autodocumentation system was originally
added to the Perl core by Benjamin Stuhl. Documentation is
by whoever was kind enough to document their functions.</p>

<p>SEE ALSO perlguts(1), perlapi(1)</p>

<p>perl v5.10.1 2015-03-13 PERLINTERN(1)</p>
<hr>
</body>
</html>
