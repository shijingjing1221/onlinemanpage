<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:37:08 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT USB_INTERFACE(9) Host-Side Data Types and Macro
STRUCT USB_INTERFACE(9)</p>

<p>NAME struct_usb_interface - what usb device drivers talk
to</p>

<p>SYNOPSIS struct usb_interface { struct
usb_host_interface * altsetting; struct usb_host_interface *
cur_altsetting; unsigned num_altsetting; struct
usb_interface_assoc_descriptor * intf_assoc; int minor; enum
usb_interface_condition condition; unsigned is_active:1;
unsigned sysfs_files_created:1; unsigned ep_devs_created:1;
unsigned unregistering:1; unsigned needs_remote_wakeup:1;
unsigned needs_altsetting0:1; unsigned needs_binding:1;
unsigned reset_running:1; struct device dev; struct device *
usb_dev; atomic_t pm_usage_cnt; struct work_struct reset_ws;
};</p>

<p>MEMBERS altsetting array of interface structures, one
for each alternate setting that may be selected. Each one
includes a set of endpoint configurations. They will be in
no particular order.</p>

<p>cur_altsetting the current altsetting.</p>

<p>num_altsetting number of altsettings defined.</p>

<p>intf_assoc interface association descriptor</p>

<p>minor the minor number assigned to this interface, if
this interface is bound to a driver that uses the USB major
number. If this interface does not use the USB major, this
field should be unused. The driver should set this value in
the probe function of the driver, after it has been assigned
a minor number from the USB core by calling
usb_register_dev.</p>

<p>condition binding state of the interface: not bound,
binding (in probe), bound to a driver, or unbinding (in
disconnect)</p>

<p>is_active flag set when the interface is bound and not
suspended.</p>

<p>sysfs_files_created sysfs attributes exist</p>

<p>ep_devs_created endpoint child pseudo-devices exist</p>

<p>unregistering flag set when the interface is being
unregistered</p>

<p>needs_remote_wakeup flag set when the driver requires
remote-wakeup capability during autosuspend.</p>

<p>needs_altsetting0 flag set when a set-interface request
for altsetting 0 has been deferred.</p>

<p>needs_binding flag set when the driver should be
re-probed or unbound following a reset or suspend operation
it doesn&acute;t support.</p>

<p>reset_running set to 1 if the interface is currently
running a queued reset so that usb_cancel_queued_reset
doesn&acute;t try to remove from the workqueue when running
inside the worker thread. See __usb_queue_reset_device.</p>

<p>dev driver model&acute;s view of this device</p>

<p>usb_dev if an interface is bound to the USB major, this
will point to the sysfs representation for that device.</p>

<p>pm_usage_cnt PM usage counter for this interface;
autosuspend is not allowed unless the counter is 0.</p>

<p>reset_ws Used for scheduling resets from atomic
context.</p>

<p>DESCRIPTION USB device drivers attach to interfaces on a
physical device. Each interface encapsulates a single high
level function, such as feeding an audio stream to a speaker
or reporting a change in a volume control. Many USB devices
only have one interface. The protocol used to talk to an
interface&acute;s endpoints can be defined in a usb class
specification, or by a product&acute;s vendor. The (default)
control endpoint is part of every interface, but is never
listed among the interface&acute;s descriptors.</p>

<p>The driver that is bound to the interface can use
standard driver model calls such as dev_get_drvdata on the
dev member of this structure.</p>

<p>Each interface may have alternate settings. The initial
configuration of a device sets altsetting 0, but the device
driver can change that setting using usb_set_interface.
Alternate settings are often used to control the use of
periodic endpoints, such as by having different endpoints
use different amounts of reserved USB bandwidth. All
standards-conformant USB devices that use isochronous
endpoints will use them in non-default settings.</p>

<p>The USB specification says that alternate setting
numbers must run from 0 to one less than the total number of
alternate settings. But some devices manage to mess this up,
and the structures aren&acute;t necessarily stored in
numerical order anyhow. Use usb_altnum_to_altsetting to look
up an alternate setting in the altsetting array based on its
number.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. July 2015 STRUCT
USB_INTERFACE(9)</p>
<hr>
</body>
</html>
