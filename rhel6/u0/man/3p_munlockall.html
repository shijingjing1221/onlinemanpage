<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:07:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MLOCKALL(3P) POSIX Programmer s Manual MLOCKALL(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME mlockall, munlockall - lock/unlock the address
space of a process (REALTIME)</p>

<p>SYNOPSIS #include &lt;sys/mman.h&gt;</p>

<p>int mlockall(int flags); int munlockall(void);</p>

<p>DESCRIPTION The mlockall() function shall cause all of
the pages mapped by the address space of a process to be
memory-resident until unlocked or until the process exits or
execs another process image. The flags argu- ment determines
whether the pages to be locked are those currently mapped by
the address space of the process, those that are mapped in
the future, or both. The flags argument is constructed from
the bit- wise-inclusive OR of one or more of the following
symbolic constants, defined in &lt;sys/mman.h&gt;:</p>

<p>MCL_CURRENT Lock all of the pages currently mapped into
the address space of the process.</p>

<p>MCL_FUTURE Lock all of the pages that become mapped into
the address space of the process in the future, when those
mappings are estab- lished.</p>

<p>If MCL_FUTURE is specified, and the automatic locking of
future map- pings eventually causes the amount of locked
memory to exceed the amount of available physical memory or
any other implementation-defined limit, the behavior is
implementation-defined. The manner in which the
implementation informs the application of these situations
is also implementation-defined.</p>

<p>The munlockall() function shall unlock all currently
mapped pages of the address space of the process. Any pages
that become mapped into the address space of the process
after a call to munlockall() shall not be locked, unless
there is an intervening call to mlockall() specifying
MCL_FUTURE or a subsequent call to mlockall() specifying
MCL_CURRENT. If pages mapped into the address space of the
process are also mapped into the address spaces of other
processes and are locked by those pro- cesses, the locks
established by the other processes shall be unaf- fected by
a call by this process to munlockall().</p>

<p>Upon successful return from the mlockall() function that
specifies MCL_CURRENT, all currently mapped pages of the
process address space shall be memory-resident and locked.
Upon return from the munlockall() function, all currently
mapped pages of the process address space shall be unlocked
with respect to the process address space. The mem- ory
residency of unlocked pages is unspecified.</p>

<p>The appropriate privilege is required to lock process
memory with mlockall().</p>

<p>RETURN VALUE Upon successful completion, the mlockall()
function shall return a value of zero. Otherwise, no
additional memory shall be locked, and the function shall
return a value of -1 and set errno to indicate the error.
The effect of failure of mlockall() on previously existing
locks in the address space is unspecified.</p>

<p>If it is supported by the implementation, the
munlockall() function shall always return a value of zero.
Otherwise, the function shall return a value of -1 and set
errno to indicate the error.</p>

<p>ERRORS The mlockall() function shall fail if:</p>

<p>EAGAIN Some or all of the memory identified by the
operation could not be locked when the call was made.</p>

<p>EINVAL The flags argument is zero, or includes
unimplemented flags.</p>

<p>The mlockall() function may fail if:</p>

<p>ENOMEM Locking all of the pages currently mapped into
the address space of the process would exceed an
implementation-defined limit on the amount of memory that
the process may lock.</p>

<p>EPERM The calling process does not have the appropriate
privilege to perform the requested operation.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES None.</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO exec(), exit(), fork(), mlock(), munmap(), the
Base Definitions volume of IEEE Std 1003.1-2001,
&lt;sys/mman.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 MLOCKALL(3P)</p>
<hr>
</body>
</html>
