<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:16:51 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SPU_RUN(2) Linux Programmer s Manual SPU_RUN(2)</p>

<p>NAME spu_run - execute an spu context</p>

<p>SYNOPSIS #include &lt;sys/spu.h&gt;</p>

<p>int spu_run(int fd, unsigned int *npc, unsigned int
*event);</p>

<p>DESCRIPTION The spu_run system call is used on PowerPC
machines that implement the Cell Broadband Engine
Architecture in order to access Synergistic Pro- cessor
Units (SPUs). It uses the fd that was returned from spu_cre-
ate(2) to address a specific SPU context. When the context
gets sched- uled to a physical SPU, it starts execution at
the instruction pointer passed in npc.</p>

<p>Execution of SPU code happens synchronously, meaning
that spu_run does not return while the SPU is still running.
If there is a need to exe- cute SPU code in parallel with
other code on either the main CPU or other SPUs, you need to
create a new thread of execution first, e.g. using the
pthread_create(3) call.</p>

<p>When spu_run returns, the current value of the SPU
instruction pointer is written back to npc, so you can call
spu_run again without updating the pointers.</p>

<p>event can be a NULL pointer or point to an extended
status code that gets filled when spu_run returns. It can be
one of the following con- stants:</p>

<p>SPE_EVENT_DMA_ALIGNMENT A DMA alignment error</p>

<p>SPE_EVENT_SPE_DATA_SEGMENT A DMA segmentation error</p>

<p>SPE_EVENT_SPE_DATA_STORAGE A DMA storage error</p>

<p>If NULL is passed as the event argument, these errors
will result in a signal delivered to the calling
process.</p>

<p>RETURN VALUE spu_run returns the value of the spu_status
register or -1 to indicate an error and set errno to one of
the error codes listed below. The spu_status register value
contains a bit mask of status codes and optionally a 14 bit
code returned from the stop-and-signal instruction on the
SPU. The bit masks for the status codes are:</p>

<p>0x02 SPU was stopped by stop-and-signal.</p>

<p>0x04 SPU was stopped by halt.</p>

<p>0x08 SPU is waiting for a channel.</p>

<p>0x10 SPU is in single-step mode.</p>

<p>0x20 SPU has tried to execute an invalid
instruction.</p>

<p>0x40 SPU has tried to access an invalid channel.</p>

<p>0x3fff0000 The bits masked with this value contain the
code returned from stop-and-signal.</p>

<p>There are always one or more of the lower eight bits set
or an error code is returned from spu_run.</p>

<p>ERRORS EAGAIN or EWOULDBLOCK fd is in non-blocking mode
and spu_run would block.</p>

<p>EBADF fd is not a valid file descriptor.</p>

<p>EFAULT npc is not a valid pointer or status is neither
NULL nor a valid pointer.</p>

<p>EINTR A signal occured while spu_run was in progress.
The npc value has been updated to the new program counter
value if necessary.</p>

<p>EINVAL fd is not a file descriptor returned from
spu_create(2).</p>

<p>ENOMEM Insufficient memory was available to handle a
page fault result- ing from an MFC direct memory access.</p>

<p>ENOSYS the functionality is not provided by the current
system, because either the hardware does not provide SPUs or
the spufs module is not loaded.</p>

<p>NOTES spu_run is meant to be used from libraries that
implement a more abstract interface to SPUs, not to be used
from regular applications. See
http://www.bsc.es/projects/deepcomputing/linuxoncell/ for
the rec- ommended libraries.</p>

<p>CONFORMING TO This call is Linux specific and only
implemented by the ppc64 architec- ture. Programs using this
system call are not portable.</p>

<p>BUGS The code does not yet fully implement all features
lined out here.</p>

<p>AUTHOR Arnd Bergmann &lt;arndb@de.ibm.com&gt;</p>

<p>SEE ALSO capabilities(7), close(2), spu_create(2),
spufs(7)</p>

<p>Linux 2005-09-28 SPU_RUN(2)</p>
<hr>
</body>
</html>
