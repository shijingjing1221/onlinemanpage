<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 21:58:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>eval(n) Tcl Built-In Commands eval(n)</p>


<p>______________________________________________________________________________</p>

<p>NAME eval - Evaluate a Tcl script</p>

<p>SYNOPSIS eval arg ?arg ...?
_________________________________________________________________</p>

<p>DESCRIPTION Eval takes one or more arguments, which
together comprise a Tcl script containing one or more
commands. Eval concatenates all its arguments in the same
fashion as the concat command, passes the concatenated
string to the Tcl interpreter recursively, and returns the
result of that evaluation (or any error generated by it).
Note that the list command quotes sequences of words in such
a way that they are not fur- ther expanded by the eval
command.</p>

<p>EXAMPLES Often, it is useful to store a fragment of a
script in a variable and execute it later on with extra
values appended. This technique is used in a number of
places throughout the Tcl core (e.g. in fcopy, lsort and
trace command callbacks). This example shows how to do this
using core Tcl commands: set script { puts &quot;logging
now&quot; lappend $myCurrentLogVar } set myCurrentLogVar
log1 # Set up a switch of logging variable part way through!
after 20000 set myCurrentLogVar log2</p>

<p>for {set i 0} {$i&lt;10} {incr i} { # Introduce a random
delay after [expr {int(5000 * rand())}] update ;# Check for
the asynch log switch eval $script $i [clock clicks] }</p>

<p>Note that in the most common case (where the script
fragment is actu- ally just a list of words forming a
command prefix), it is better to use {*}$script when doing
this sort of invocation pattern. It is less general than the
eval command, and hence easier to make robust in prac- tice.
The following procedure acts in a way that is analogous to
the lappend command, except it inserts the argument values
at the start of the list in the variable: proc lprepend
{varName args} { upvar 1 $varName var # Ensure that the
variable exists and contains a list lappend var # Now we
insert all the arguments in one go set var [eval [list
linsert $var 0] $args] } However, the last line would now
normally be written without eval, like this: set var
[linsert $var 0 {*}$args]</p>

<p>SEE ALSO catch(n), concat(n), error(n), interp(n),
list(n), namespace(n), subst(n), tclvars(n), uplevel(n)</p>

<p>KEYWORDS concatenate, evaluate, script</p>

<p>Tcl eval(n)</p>
<hr>
</body>
</html>
