<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:58 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>POLL(3P) POSIX Programmer s Manual POLL(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME poll - input/output multiplexing</p>

<p>SYNOPSIS #include &lt;poll.h&gt;</p>

<p>int poll(struct pollfd fds[], nfds_t nfds, int
timeout);</p>

<p>DESCRIPTION The poll() function provides applications
with a mechanism for multi- plexing input/output over a set
of file descriptors. For each member of the array pointed to
by fds, poll() shall examine the given file descriptor for
the event(s) specified in events. The number of pollfd
structures in the fds array is specified by nfds. The poll()
function shall identify those file descriptors on which an
application can read or write data, or on which certain
events have occurred.</p>

<p>The fds argument specifies the file descriptors to be
examined and the events of interest for each file
descriptor. It is a pointer to an array with one member for
each open file descriptor of interest. The arrays members
are pollfd structures within which fd specifies an open file
descriptor and events and revents are bitmasks constructed
by ORing a combination of the following event flags:</p>

<p>POLLIN Data other than high-priority data may be read
without blocking.</p>

<p>For STREAMS, this flag is set in revents even if the
message is of zero length. This flag shall be equivalent to
POLLRDNORM | POLLRDBAND.</p>

<p>POLLRDNORM Normal data may be read without blocking.</p>

<p>For STREAMS, data on priority band 0 may be read without
blocking. This flag is set in revents even if the message is
of zero length.</p>

<p>POLLRDBAND Priority data may be read without
blocking.</p>

<p>For STREAMS, data on priority bands greater than 0 may
be read without blocking. This flag is set in revents even
if the message is of zero length.</p>

<p>POLLPRI High-priority data may be read without
blocking.</p>

<p>For STREAMS, this flag is set in revents even if the
message is of zero length.</p>

<p>POLLOUT Normal data may be written without blocking.</p>

<p>For STREAMS, data on priority band 0 may be written
without blocking.</p>

<p>POLLWRNORM Equivalent to POLLOUT.</p>

<p>POLLWRBAND Priority data may be written.</p>

<p>For STREAMS, data on priority bands greater than 0 may
be written with- out blocking. If any priority band has been
written to on this STREAM, this event only examines bands
that have been written to at least once.</p>

<p>POLLERR An error has occurred on the device or stream.
This flag is only valid in the revents bitmask; it shall be
ignored in the events member.</p>

<p>POLLHUP The device has been disconnected. This event and
POLLOUT are mutually-exclusive; a stream can never be
writable if a hangup has occurred. However, this event and
POLLIN, POLLRDNORM, POLL- RDBAND, or POLLPRI are not
mutually-exclusive. This flag is only valid in the revents
bitmask; it shall be ignored in the events member.</p>

<p>POLLNVAL The specified fd value is invalid. This flag is
only valid in the revents member; it shall ignored in the
events member.</p>

<p>The significance and semantics of normal, priority, and
high-priority data are file and device-specific.</p>

<p>If the value of fd is less than 0, events shall be
ignored, and revents shall be set to 0 in that entry on
return from poll().</p>

<p>In each pollfd structure, poll() shall clear the revents
member, except that where the application requested a report
on a condition by setting one of the bits of events listed
above, poll() shall set the corre- sponding bit in revents
if the requested condition is true. In addi- tion, poll()
shall set the POLLHUP, POLLERR, and POLLNVAL flag in revents
if the condition is true, even if the application did not
set the corresponding bit in events.</p>

<p>If none of the defined events have occurred on any
selected file descriptor, poll() shall wait at least timeout
milliseconds for an event to occur on any of the selected
file descriptors. If the value of timeout is 0, poll() shall
return immediately. If the value of time- out is -1, poll()
shall block until a requested event occurs or until the call
is interrupted.</p>

<p>Implementations may place limitations on the granularity
of timeout intervals. If the requested timeout interval
requires a finer granular- ity than the implementation
supports, the actual timeout interval shall be rounded up to
the next supported value.</p>

<p>The poll() function shall not be affected by the
O_NONBLOCK flag.</p>

<p>The poll() function shall support regular files,
terminal and pseudo- terminal devices, FIFOs, pipes, sockets
and STREAMS-based files. The behavior of poll() on elements
of fds that refer to other types of file is unspecified.</p>

<p>Regular files shall always poll TRUE for reading and
writing.</p>

<p>A file descriptor for a socket that is listening for
connections shall indicate that it is ready for reading,
once connections are available. A file descriptor for a
socket that is connecting asynchronously shall indicate that
it is ready for writing, once a connection has been
established.</p>

<p>RETURN VALUE Upon successful completion, poll() shall
return a non-negative value. A positive value indicates the
total number of file descriptors that have been selected
(that is, file descriptors for which the revents member is
non-zero). A value of 0 indicates that the call timed out
and no file descriptors have been selected. Upon failure,
poll() shall return -1 and set errno to indicate the
error.</p>

<p>ERRORS The poll() function shall fail if:</p>

<p>EAGAIN The allocation of internal data structures failed
but a subse- quent request may succeed.</p>

<p>EINTR A signal was caught during poll().</p>

<p>EINVAL The nfds argument is greater than {OPEN_MAX}, or
one of the fd members refers to a STREAM or multiplexer that
is linked (directly or indirectly) downstream from a
multiplexer.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES Checking for Events on a Stream The following
example opens a pair of STREAMS devices and then waits for
either one to become writable. This example proceeds as
follows:</p>

<p>1. Sets the timeout parameter to 500 milliseconds.</p>

<p>2. Opens the STREAMS devices /dev/dev0 and /dev/dev1,
and then polls them, specifying POLLOUT and POLLWRBAND as
the events of interest.</p>

<p>The STREAMS device names /dev/dev0 and /dev/dev1 are
only examples of how STREAMS devices can be named; STREAMS
naming conventions may vary among systems conforming to the
IEEE Std 1003.1-2001.</p>

<p>3. Uses the ret variable to determine whether an event
has occurred on either of the two STREAMS. The poll()
function is given 500 mil- liseconds to wait for an event to
occur (if it has not occurred prior to the poll() call).</p>

<p>4. Checks the returned value of ret. If a positive value
is returned, one of the following can be done:</p>

<p>a. Priority data can be written to the open STREAM on
priority bands greater than 0, because the POLLWRBAND event
occurred on the open STREAM ( fds[0] or fds[1]).</p>

<p>b. Data can be written to the open STREAM on
priority-band 0, because the POLLOUT event occurred on the
open STREAM ( fds[0] or fds[1]).</p>

<p>5. If the returned value is not a positive value,
permission to write data to the open STREAM (on any priority
band) is denied.</p>

<p>6. If the POLLHUP event occurs on the open STREAM (
fds[0] or fds[1]), the device on the open STREAM has
disconnected.</p>

<p>#include &lt;stropts.h&gt; #include &lt;poll.h&gt; ...
struct pollfd fds[2]; int timeout_msecs = 500; int ret; int
i;</p>

<p>/* Open STREAMS device. */ fds[0].fd =
open(&quot;/dev/dev0&quot;, ...); fds[1].fd =
open(&quot;/dev/dev1&quot;, ...); fds[0].events = POLLOUT |
POLLWRBAND; fds[1].events = POLLOUT | POLLWRBAND;</p>

<p>ret = poll(fds, 2, timeout_msecs);</p>

<p>if (ret &gt; 0) { /* An event on one of the fds has
occurred. */ for (i=0; i&lt;2; i++) { if (fds[i].revents
&amp; POLLWRBAND) { /* Priority data may be written on
device number i. */ ... } if (fds[i].revents &amp; POLLOUT)
{ /* Data may be written on device number i. */ ... } if
(fds[i].revents &amp; POLLHUP) { /* A hangup has occurred on
device number i. */ ... } } }</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO STREAMS, getmsg(), putmsg(), read(), select(),
write(), the Base Defi- nitions volume of IEEE Std
1003.1-2001, &lt;poll.h&gt;, &lt;stropts.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 POLL(3P)</p>
<hr>
</body>
</html>
