<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:16 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLREQUICK(1) Perl Programmers Reference Guide
PERLREQUICK(1)</p>

<p>NAME perlrequick - Perl regular expressions quick
start</p>

<p>DESCRIPTION This page covers the very basics of
understanding, creating and using regular expressions
(regexes) in Perl.</p>

<p>The Guide Simple word matching The simplest regex is
simply a word, or more generally, a string of characters. A
regex consisting of a word matches any string that contains
that word:</p>

<p>&quot;Hello World&quot; =~ /World/; # matches</p>

<p>In this statement, &quot;World&quot; is a regex and the
&quot;//&quot; enclosing &quot;/World/&quot; tells perl to
search a string for a match. The operator &quot;=~&quot;
associates the string with the regex match and produces a
true value if the regex matched, or false if the regex did
not match. In our case, &quot;World&quot; matches the second
word in &quot;Hello World&quot;, so the expression is true.
This idea has several variations.</p>

<p>Expressions like this are useful in conditionals:</p>

<p>print &quot;It matches0 if &quot;Hello World&quot; =~
/World/;</p>

<p>The sense of the match can be reversed by using
&quot;!~&quot; operator:</p>

<p>print &quot;It doesn&rsquo;t match0 if &quot;Hello
World&quot; !~ /World/;</p>

<p>The literal string in the regex can be replaced by a
variable:</p>

<p>$greeting = &quot;World&quot;; print &quot;It matches0
if &quot;Hello World&quot; =~ /$greeting/;</p>

<p>If youre matching against $_, the &quot;$_ =~&quot; part
can be omitted:</p>

<p>$_ = &quot;Hello World&quot;; print &quot;It matches0 if
/World/;</p>

<p>Finally, the &quot;//&quot; default delimiters for a
match can be changed to arbitrary delimiters by putting an
&rsquo;m&rsquo; out front:</p>

<p>&quot;Hello World&quot; =~ m!World!; # matches,
delimited by &rsquo;!&rsquo; &quot;Hello World&quot; =~
m{World}; # matches, note the matching &rsquo;{}&rsquo;
&quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches
after &rsquo;/usr/bin&rsquo;, # &rsquo;/&rsquo; becomes an
ordinary char</p>

<p>Regexes must match a part of the string exactly in order
for the statement to be true:</p>

<p>&quot;Hello World&quot; =~ /world/; # doesn&rsquo;t
match, case sensitive &quot;Hello World&quot; =~ /o W/; #
matches, &rsquo; &rsquo; is an ordinary char &quot;Hello
World&quot; =~ /World /; # doesn&rsquo;t match, no &rsquo;
&rsquo; at end</p>

<p>perl will always match at the earliest possible point in
the string:</p>

<p>&quot;Hello World&quot; =~ /o/; # matches
&rsquo;o&rsquo; in &rsquo;Hello&rsquo; &quot;That hat is
red&quot; =~ /hat/; # matches &rsquo;hat&rsquo; in
&rsquo;That&rsquo;</p>

<p>Not all characters can be used as is in a match. Some
characters, called metacharacters, are reserved for use in
regex notation. The metacharacters are</p>

<p>{}[]()^$.|*+? A metacharacter can be matched by putting
a backslash before it:</p>

<p>&quot;2+2=4&quot; =~ /2+2/; # doesn&rsquo;t match, + is
a metacharacter &quot;2+2=4&quot; =~ /2+2/; # matches, + is
treated like an ordinary + &rsquo;C:WIN32&rsquo; =~
/C:\WIN/; # matches &quot;/usr/bin/perl&quot; =~
/usrbinperl/; # matches</p>

<p>In the last regex, the forward slash &rsquo;/&rsquo; is
also backslashed, because it is used to delimit the
regex.</p>

<p>Non-printable ASCII characters are represented by escape
sequences. &quot; Common examples are &quot;&quot; for a
tab, &quot;0 for a newline, and &quot; for a carriage
return. Arbitrary bytes are represented by octal escape
sequences, e.g., &quot; 33&quot;, or hexadecimal escape
sequences, e.g., &quot;B&quot;:</p>

<p>&quot;10002000&quot; =~ m(02) # matches &quot;cat&quot;
=~ /14314/ # matches, but a weird way to spell cat</p>

<p>Regexes are treated mostly as double quoted strings, so
variable substitution works:</p>

<p>$foo = &rsquo;house&rsquo;; &rsquo;cathouse&rsquo; =~
/cat$foo/; # matches &rsquo;housecat&rsquo; =~ /${foo}cat/;
# matches</p>

<p>With all of the regexes above, if the regex matched
anywhere in the string, it was considered a match. To
specify where it should match, we would use the anchor
metacharacters &quot;^&quot; and &quot;$&quot;. The anchor
&quot;^&quot; means match at the beginning of the string and
the anchor &quot;$&quot; means match at the end of the
string, or before a newline at the end of the string. Some
examples:</p>

<p>&quot;housekeeper&quot; =~ /keeper/; # matches
&quot;housekeeper&quot; =~ /^keeper/; # doesn&rsquo;t match
&quot;housekeeper&quot; =~ /keeper$/; # matches
&quot;housekeeper0 =~ /keeper$/; # matches
&quot;housekeeper&quot; =~ /^housekeeper$/; # matches</p>

<p>Using character classes A character class allows a set
of possible characters, rather than just a single character,
to match at a particular point in a regex. Character classes
are denoted by brackets &quot;[...]&quot;, with the set of
characters to be possibly matched inside. Here are some
examples:</p>

<p>/cat/; # matches &rsquo;cat&rsquo; /[bcr]at/; # matches
&rsquo;bat&rsquo;, &rsquo;cat&rsquo;, or &rsquo;rat&rsquo;
&quot;abc&quot; =~ /[cab]/; # matches &rsquo;a&rsquo;</p>

<p>In the last statement, even though &rsquo;c&rsquo; is
the first character in the class, the earliest point at
which the regex can match is &rsquo;a&rsquo;.</p>

<p>/[yY][eE][sS]/; # match &rsquo;yes&rsquo; in a
case-insensitive way # &rsquo;yes&rsquo;, &rsquo;Yes&rsquo;,
&rsquo;YES&rsquo;, etc. /yes/i; # also match
&rsquo;yes&rsquo; in a case-insensitive way</p>

<p>The last example shows a match with an &rsquo;i&rsquo;
modifier, which makes the match case-insensitive.</p>

<p>Character classes also have ordinary and special
characters, but the sets of ordinary and special characters
inside a character class are different than those outside a
character class. The special characters for a character
class are &quot;-]$&quot; and are matched using an
escape:</p>

<p>/[]c]def/; # matches &rsquo;]def&rsquo; or
&rsquo;cdef&rsquo; $x = &rsquo;bcr&rsquo;; /[$x]at/; #
matches &rsquo;bat, &rsquo;cat&rsquo;, or &rsquo;rat&rsquo;
/[]at/; # matches &rsquo;$at&rsquo; or &rsquo;xat&rsquo;
/[\$x]at/; # matches &rsquo;t&rsquo;, &rsquo;bat,
&rsquo;cat&rsquo;, or &rsquo;rat&rsquo;</p>

<p>The special character &rsquo;-&rsquo; acts as a range
operator within character classes, so that the unwieldy
&quot;[0123456789]&quot; and &quot;[abc...xyz]&quot; become
the svelte &quot;[0-9]&quot; and &quot;[a-z]&quot;:</p>

<p>/item[0-9]/; # matches &rsquo;item0&rsquo; or ... or
&rsquo;item9&rsquo; /[0-9a-fA-F]/; # matches a hexadecimal
digit</p>

<p>If &rsquo;-&rsquo; is the first or last character in a
character class, it is treated as an ordinary character.</p>

<p>The special character &quot;^&quot; in the first
position of a character class denotes a negated character
class, which matches any character but those in the
brackets. Both &quot;[...]&quot; and &quot;[^...]&quot; must
match a character, or the match fails. Then</p>

<p>/[^a]at/; # doesn&rsquo;t match &rsquo;aat&rsquo; or
&rsquo;at&rsquo;, but matches # all other &rsquo;bat&rsquo;,
&rsquo;cat, &rsquo;0at&rsquo;, &rsquo;%at&rsquo;, etc.
/[^0-9]/; # matches a non-numeric character /[a^]at/; #
matches &rsquo;aat&rsquo; or &rsquo;^at&rsquo;; here
&rsquo;^&rsquo; is ordinary</p>

<p>Perl has several abbreviations for common character
classes:</p>

<p>&middot; is a digit and represents</p>

<p>[0-9]</p>

<p>&middot; is a whitespace character and represents</p>

<p>0f] [</p>

<p>&middot; 48a word character (alphanumeric or _) and
represents</p>

<p>[0-9a-zA-Z_]</p>

<p>&middot; a negated ; it represents any character but a
digit</p>

<p>[^0-9]</p>

<p>&middot; is a negated t represents any non-whitespace
character</p>

<p>[^ &middot; W is a negated 888</p>

<p>[^0</p>

<p>&middot; The period . matches any character but
&quot;0</p>

<p>The &quot; <small>88 character classes. Here are some in
use:</small></p>

<p><small>/::/; # matches a hh:mm:ss time format /[ #
matches any digit or whitespace character /96 # non-word
char, followed by a word char /..rt/; # matches any two
chars, followed by &rsquo;rt&rsquo; /end./; # matches
&rsquo;end.&rsquo; /end[.]/; # same thing, matches
&rsquo;end.&rsquo;</small></p>

<p><small>m a t c h e s a b o u n d a r y b e t w The wword
anchor &quot;e e n a w o r d c h a r a c t e r a n d a
non-word character &quot;14424</small></p>

<p><small>$x = &quot;Housecat catenates house and
cat&quot;; a t / ; $x =~ /# hes cat in
&rsquo;catenates&rsquo; m a t ; # m a t c h e s c a t $x =~
/cati n &rsquo; h o u s e c a t &rsquo; a $x =~
/t</small></p>

<p><small>In the last example, the end of the string is
considered a word boundary.</small></p>

<p><small>Matching this or that We can match different
character strings with the alternation metacharacter
&rsquo;|&rsquo;. To match &quot;dog&quot; or
&quot;cat&quot;, we form the regex &quot;dog|cat&quot;. As
before, perl will try to match the regex at the earliest
possible point in the string. At each character position,
perl will first try to match the first alternative,
&quot;dog&quot;. If &quot;dog&quot; doesnt match, perl will
then try the next alternative, &quot;cat&quot;. If
&quot;cat&quot; doesnt match either, then the match fails
and perl moves to the next position in the string. Some
examples:</small></p>

<p><small>&quot;cats and dogs&quot; =~ /cat|dog|bird/; #
matches &quot;cat&quot; &quot;cats and dogs&quot; =~
/dog|cat|bird/; # matches &quot;cat&quot;</small></p>

<p><small>Even though &quot;dog&quot; is the first
alternative in the second regex, &quot;cat&quot; is able to
match earlier in the string.</small></p>

<p><small>&quot;cats&quot; =~ /c|ca|cat|cats/; # matches
&quot;c&quot; &quot;cats&quot; =~ /cats|cat|ca|c/; # matches
&quot;cats&quot;</small></p>

<p><small>At a given character position, the first
alternative that allows the regex match to succeed will be
the one that matches. Here, all the alternatives match at
the first string position, so the first matches.</small></p>

<p><small>Grouping things and hierarchical matching The
ggrouping metacharacters &quot;()&quot; allow a part of a
regex to be treated as a single unit. Parts of a regex are
grouped by enclosing them in parentheses. The regex
&quot;house(cat|keeper)&quot; means match &quot;house&quot;
followed by either &quot;cat&quot; or &quot;keeper&quot;.
Some more examples are</small></p>

<p><small>/(a|b)b/; # matches &rsquo;ab&rsquo; or
&rsquo;bb&rsquo; /(^a|b)c/; # matches &rsquo;ac&rsquo; at
start of string or &rsquo;bc&rsquo; anywhere</small></p>

<p><small>/house(cat|)/; # matches either
&rsquo;housecat&rsquo; or &rsquo;house&rsquo;
/house(cat(s|)|)/; # matches either &rsquo;housecats&rsquo;
or &rsquo;housecat&rsquo; or # &rsquo;house&rsquo;. Note
groups can be nested.</small></p>

<p><small>&quot;20&quot; =~ /(19|20|)/; # matches the null
alternative &rsquo;()&rsquo;, # because &rsquo;20&rsquo;
can&rsquo;t match</small></p>

<p><small>Extracting matches The grouping metacharacters
&quot;()&quot; also allow the extraction of the parts of a
string that matched. For each grouping, the part that
matched inside goes into the special variables $1, $2, etc.
They can be used just as ordinary variables:</small></p>

<p><small># extract hours, minutes, seconds $time =~
/():():()/; # match hh:mm:ss format $hours = $1; $minutes =
$2; $seconds = $3;</small></p>

<p><small>In list context, a match &quot;/regex/&quot; with
groupings will return the list of matched values
&quot;($1,$2,...)&quot;. So we could rewrite it
as</small></p>

<p><small>($hours, $minutes, $second) = ($time =~
/():():()/);</small></p>

<p><small>If the groupings in a regex are nested, $1 gets
the group with the leftmost opening parenthesis, $2 the next
opening parenthesis, etc. For example, here is a complex
regex and the matching variables indicated below
it:</small></p>

<p><small>/(ab(cd|ef)((gi)|j))/; 1 2 34</small></p>

<p><small>Associated with the matching variables $1, $2,
... are the backreferences &quot;1&quot;, &quot;2&quot;, ...
Backreferences are matching variables that can be used _
inside a regex:</small></p>

<p><small>/(24</small></p>

<p><small>$1, $2, ... should only be used outside of a
regex, and &quot;1&quot;, &quot;2&quot;, ... only inside a
regex.</small></p>

<p><small>Matching repetitions The qquantifier
metacharacters &quot;?&quot;, &quot;*&quot;, &quot;+&quot;,
and &quot;{}&quot; allow us to determine the number of
repeats of a portion of a regex we consider to be a match.
Quantifiers are put immediately after the character,
character class, or grouping that we want to specify. They
have the following meanings:</small></p>

<p><small>&middot; &quot;a?&quot; = match a 1 or 0
times</small></p>

<p><small>&middot; &quot;a*&quot; = match a 0 or more
times, i.e., any number of times</small></p>

<p><small>&middot; &quot;a+&quot; = match a 1 or more
times, i.e., at least once</small></p>

<p><small>&middot; &quot;a{n,m}&quot; = match at least
&quot;n&quot; times, but not more than &quot;m&quot;
times.</small></p>

<p><small>&middot; &quot;a{n,}&quot; = match at least
&quot;n&quot; or more times</small></p>

<p><small>&middot; &quot;a{n}&quot; = match exactly
&quot;n&quot; times</small></p>

<p><small>Here are some examples:</small></p>

<p><small>/[a-z]+*/; # match a lowercase word, at least
some space, and # any number of digits /(1152 $year =~
/{2,4}/; # make sure year is at least 2 but not more # than
4 digits $year =~ /{4}|{2}/; # better match; throw out 3
digit dates</small></p>

<p><small>These quantifiers will try to match as much of
the string as possible, while still allowing the regex to
match. So we have</small></p>

<p><small>$x = &rsquo;the cat in the hat&rsquo;; $x =~
/^(.*)(at)(.*)$/; # matches, # $1 = &rsquo;the cat in the
h&rsquo; # $2 = &rsquo;at&rsquo; # $3 = &rsquo;&rsquo; (0
matches)</small></p>

<p><small>The first quantifier &quot;.*&quot; grabs as much
of the string as possible while still having the regex
match. The second quantifier &quot;.*&quot; has no string
left to it, so it matches 0 times.</small></p>

<p><small>More matching There are a few more things you
might want to know about matching operators. In the
code</small></p>

<p><small>$pattern = &rsquo;Seuss&rsquo;; while (&lt;&gt;)
{ print if /$pattern/; }</small></p>

<p><small>perl has to re-evaluate $pattern each time
through the loop. If $pattern wont be changing, use the
&quot;//o&quot; modifier, to only perform variable
substitutions once. If you don t want any substitutions at
all, use the special delimiter
&quot;m&rsquo;&rsquo;&quot;:</small></p>

<p><small>@pattern = (&rsquo;Seuss&rsquo;); m/@pattern/; #
matches &rsquo;Seuss&rsquo; m&rsquo;@pattern&rsquo;; #
matches the literal string
&rsquo;@pattern&rsquo;</small></p>

<p><small>The global modifier &quot;//g&quot; allows the
matching operator to match within a string as many times as
possible. In scalar context, successive matches against a
string will have &quot;//g&quot; jump from match to match,
keeping track of position in the string as it goes along.
You can get or set the position with the &quot;pos()&quot;
function. For example,</small></p>

<p><small>$x = &quot;cat dog house&quot;; # 3 words while
($x =~ /(144 print &quot;Word is $1, ends at position
&quot;, pos $x, &quot;0; }</small></p>

<p><small>prints</small></p>

<p><small>Word is cat, ends at position 3 Word is dog, ends
at position 7 Word is house, ends at position 13</small></p>

<p><small>A failed match or changing the target string
resets the position. If you dont want the position reset
after failure to match, add the &quot;//c&quot;, as in
&quot;/regex/gc&quot;.</small></p>

<p><small>In list context, &quot;//g&quot; returns a list
of matched groupings, or if there are no groupings, a list
of matches to the whole regex. So</small></p>

<p><small>@words = ($x =~ /(408 # $word[0] =
&rsquo;cat&rsquo; # $word[1] = &rsquo;dog&rsquo; # $word[2]
= &rsquo;house&rsquo;</small></p>

<p><small>Search and replace Search and replace is
performed using &quot;s/regex/replacement/modifiers&quot;.
The &quot;replacement&quot; is a Perl double quoted string
that replaces in the string whatever is matched with the
&quot;regex&quot;. The operator &quot;=~&quot; is also used
here to associate a string with &quot;s///&quot;. If
matching against $_, the &quot;$_ =~&quot; can be dropped.
If there is a match, &quot;s///&quot; returns the number of
substitutions made, otherwise it returns false. Here are a
few examples:</small></p>

<p><small>$x = &quot;Time to feed the cat!&quot;; $x =~
s/cat/hacker/; # $x contains &quot;Time to feed the
hacker!&quot; $y = &quot;&rsquo;quoted words&rsquo;&quot;;
$y =~ s/^&rsquo;(.*)&rsquo;$/$1/; # strip single quotes, #
$y contains &quot;quoted words&quot;</small></p>

<p><small>With the &quot;s///&quot; operator, the matched
variables $1, $2, etc. are immediately available for use in
the replacement expression. With the global modifier,
&quot;s///g&quot; will search and replace all occurrences of
the regex in the string:</small></p>

<p><small>$x = &quot;I batted 4 for 4&quot;; $x =~
s/4/four/; # $x contains &quot;I batted four for 4&quot; $x
= &quot;I batted 4 for 4&quot;; $x =~ s/4/four/g; # $x
contains &quot;I batted four for four&quot;</small></p>

<p><small>The evaluation modifier &quot;s///e&quot; wraps
an &quot;eval{...}&quot; around the replacement string and
the evaluated result is substituted for the matched
substring. Some examples:</small></p>

<p><small># reverse all the words in a string $x =
&quot;the cat in the hat&quot;; $x =~ s/(1272</small></p>

<p><small># convert percentage to decimal $x = &quot;A 39%
hit rate&quot;; $x =~ s!(+)%!$1/100!e; # $x contains &quot;A
0.39 hit rate&quot;</small></p>

<p><small>The last example shows that &quot;s///&quot; can
use other delimiters, such as &quot;s!!!&quot; and
&quot;s{}{}&quot;, and even &quot;s{}//&quot;. If single
quotes are used &quot;s&rsquo;&rsquo;&rsquo;&quot;, then the
regex and replacement are treated as single quoted
strings.</small></p>

<p><small>The split operator &quot;split /regex/,
string&quot; splits &quot;string&quot; into a list of
substrings and returns that list. The regex determines the
character sequence that &quot;string&quot; is split with
respect to. For example, to split a string into words,
use</small></p>

<p><small>$x = &quot;Calvin and Hobbes&quot;; @word = split
/, $x; # $word[0] = &rsquo;Calvin&rsquo; # $word[1] =
&rsquo;and&rsquo; # $word[2] =
&rsquo;Hobbes&rsquo;</small></p>

<p><small>To extract a comma-delimited list of numbers,
use</small></p>

<p><small>$x = &quot;1.618,2.718, 3.142&quot;; @const =
split /,/, $x; # $const[0] = &rsquo;1.618&rsquo; # $const[1]
= &rsquo;2.718&rsquo; # $const[2] =
&rsquo;3.142&rsquo;</small></p>

<p><small>If the empty regex &quot;//&quot; is used, the
string is split into individual characters. If the regex has
groupings, then the list produced contains the matched
substrings from the groupings as well:</small></p>

<p><small>$x = &quot;/usr/bin&quot;; @parts = split m!(/)!,
$x; # $parts[0] = &rsquo;&rsquo; # $parts[1] =
&rsquo;/&rsquo; # $parts[2] = &rsquo;usr&rsquo; # $parts[3]
= &rsquo;/&rsquo; # $parts[4] =
&rsquo;bin&rsquo;</small></p>

<p><small>Since the first character of $x matched the
regex, &quot;split&quot; prepended an empty initial element
to the list.</small></p>

<p><small>BUGS None.</small></p>

<p><small>SEE ALSO This is just a quick start guide. For a
more in-depth tutorial on regexes, see perlretut and for the
reference page, see perlre.</small></p>

<p><small>AUTHOR AND COPYRIGHT Copyright (c) 2000 Mark
Kvale All rights reserved.</small></p>

<p><small>This document may be distributed under the same
terms as Perl itself.</small></p>

<p><small>Acknowledgments The author would like to thank
Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad
Hughes, and Mike Giroux for all their helpful
comments.</small></p>

<p><small>perl v5.10.1 2009-02-12
PERLREQUICK(1)</small></p>
<hr>
</body>
</html>
