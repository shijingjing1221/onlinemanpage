<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:05:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>javac(1) javac(1)</p>

<p>NAME javac - Java programming language compiler</p>

<p>SYNOPSIS javac [ options ] [ sourcefiles ] [ @argfiles
]</p>

<p>Arguments may be in any order.</p>

<p>options Command-line options.</p>

<p>sourcefiles One or more source files to be compiled
(such as MyClass.java).</p>

<p>@argfiles One or more files that lists options and
source files. The -J options are not allowed in these
files.</p>

<p>DESCRIPTION The javac tool reads class and interface
definitions, written in the Java programming language, and
compiles them into bytecode class files.</p>

<p>There are two ways to pass source code filenames to
javac:</p>

<p>o For a small number of source files, simply list the
file names on the command line.</p>

<p>o For a large number of source files, list the file
names in a file, separated by blanks or line breaks. Then
use the list file name on the javac command line, preceded
by an @ character.</p>

<p>Source code file names must have .java suffixes, class
file names must have .class suffixes, and both source and
class files must have root names that identify the class.
For example, a class called MyClass would be written in a
source file called MyClass.java and compiled into a bytecode
class file called MyClass.class.</p>

<p>Inner class definitions produce additional class files.
These class files have names combining the inner and outer
class names, such as MyClass$MyInnerClass.class.</p>

<p>You should arrange source files in a directory tree that
reflects their package tree. For example, if you keep all
your source files in /workspace, the source code for
com.mysoft.mypack.MyClass should be in
/workspace/com/mysoft/mypack/MyClass.java.</p>

<p>By default, the compiler puts each class file in the
same directory as its source file. You can specify a
separate destination directory with -d (see Options,
below).</p>

<p>SEARCHING FOR TYPES When compiling a source file, the
compiler often needs information about a type whose
definition did not appear in the source files given on the
command line. The compiler needs type information for every
class or interface used, extended, or implemented in the
source file. This includes classes and interfaces not
explicitly mentioned in the source file but which provide
information through inheritance.</p>

<p>For example, when you subclass java.applet.Applet, you
are also using Applet s ancestor classes: java.awt.Panel,
java.awt.Container, java.awt.Component, and
java.lang.Object.</p>

<p>When the compiler needs type information, it looks for a
source file or class file which defines the type. The
compiler searches for class files first in the bootstrap and
extension classes, then in the user class path (which by
default is the current directory). The user class path is
defined by setting the CLASSPATH environment variable or by
using the -classpath command line option. (For details, see
Setting the Class Path).</p>

<p>If you set the -sourcepath option, the compiler searches
the indicated path for source files; otherwise the compiler
searches the user class path for both class files and source
files.</p>

<p>You can specify different bootstrap or extension classes
with the -bootclasspath and -extdirs options; see
Cross-Compilation Options below.</p>

<p>A successful type search may produce a class file, a
source file, or both. Here is how javac handles each
situation:</p>

<p>o Search produces a class file but no source file: javac
uses the class file.</p>

<p>o Search produces a source file but no class file: javac
compiles the source file and uses the resulting class
file.</p>

<p>o Search produces both a source file and a class file:
javac deter- mines whether the class file is out of date. If
the class file is out of date, javac recompiles the source
file and uses the updated class file. Otherwise, javac just
uses the class file.</p>

<p>javac considers a class file out of date only if it is
older than the source file.</p>

<p>Note: javac can silently compile source files not
mentioned on the command line. Use the -verbose option to
trace automatic compilation.</p>

<p>OPTIONS The compiler has a set of standard options that
are supported on the current development environment and
will be supported in future releases. An additional set of
non-standard options are specific to the current virtual
machine and compiler implementations and are subject to
change in the future. Non-standard options begin with
-X.</p>

<p>Standard Options -classpath classpath Set the user class
path, overriding the user class path in the CLASSPATH
environment variable. If neither CLASSPATH or -classpath is
specified, the user class path consists of the current
directory. See Setting the Class Path for more details.</p>

<p>If the -sourcepath option is not specified, the user
class path is searched for both source files and class
files.</p>

<p>As a special convenience, a class path element
containing a base- name of * is considered equivalent to
specifying a list of all the files in the directory with the
extension .jar or .JAR (a java program cannot tell the
difference between the two invoca- tions). For example, if
directory foo contains a.jar and b.JAR, then the class path
element foo/* is expanded to a A.jar:b.JAR, except that the
order of jar files is unspecified. All jar files in the
specified directory, even hidden ones, are included in the
list. A classpath entry consisting simply of * expands to a
list of all the jar files in the current directory. The
CLASSPATH environment variable, where defined, will be
similarly expanded. Any class- path wildcard expansion
occurs before the Java virtual machine is started -- no Java
program will ever see unexpanded wildcards except by
querying the environment. For example; by invoking Sys-
tem.getenv(&quot;CLASSPATH&quot;).</p>

<p>-Djava.ext.dirs=directories Override the location of
installed extensions.</p>

<p>-Djava.endorsed.dirs=directories Override the location
of endorsed standards path.</p>

<p>-d directory Set the destination directory for class
files. The destination directory must already exist; javac
will not create the desti- nation directory. If a class is
part of a package, javac puts the class file in a
subdirectory reflecting the package name, creating
directories as needed. For example, if you specify -d
/home/myclasses and the class is called
com.mypackage.MyClass, then the class file is called
/home/myclasses/com/mypack- age/MyClass.class.</p>

<p>If -d is not specified, javac puts the class file in the
same directory as the source file.</p>

<p>Note: The directory specified by -d is not automatically
added to your user class path.</p>

<p>-deprecation Show a description of each use or override
of a deprecated member or class. Without -deprecation, javac
shows the names of source files that use or override
deprecated members or classes. -deprecation is shorthand for
-Xlint:deprecation.</p>

<p>-encoding encoding Set the source file encoding name,
such as EUC-JP and UTF-8.. If -encoding is not specified,
the platform default converter is used.</p>

<p>-g Generate all debugging information, including local
variables. By default, only line number and source file
information is generated.</p>

<p>-g:none Do not generate any debugging information.</p>

<p>-g:{keyword list} Generate only some kinds of debugging
information, specified by a comma separated list of
keywords. Valid keywords are:</p>

<p>source Source file debugging information</p>

<p>lines Line number debugging information</p>

<p>vars Local variable debugging information</p>

<p>-help Print a synopsis of standard options.</p>

<p>-nowarn Disable warning messages. This has the same
meaning as -Xlint:none.</p>

<p>-source release Specifies the version of source code
accepted. The following values for release are allowed:</p>

<p>1.3 The compiler does not support assertions, generics,
or other language features introduced after JDK 1.3.</p>

<p>1.4 The compiler accepts code containing assertions,
which were introduced in JDK 1.4.</p>

<p>1.5 The compiler accepts code containing generics and
other language features introduced in JDK 5. This is the
default.</p>

<p>5 Synonym for 1.5 Note: No language changes were
introduced in JDK 6, so the values 1.6 and 6 are not
valid.</p>

<p>-sourcepath sourcepath Specify the source code path to
search for class or interface definitions. As with the user
class path, source path entries are separated by colons (:)
and can be directories, JAR archives, or ZIP archives. If
packages are used, the local path name within the directory
or archive must reflect the package name.</p>

<p>Note: Classes found through the classpath are subject to
auto- matic recompilation if their sources are found.</p>

<p>-verbose Verbose output. This includes information about
each class loaded and each source file compiled.</p>

<p>-X Display information about non-standard options and
exit.</p>

<p>Cross-Compilation Options By default, classes are
compiled against the bootstrap and extension classes of the
platform that javac shipped with. But javac also supports
cross-compiling, where classes are compiled against a boot-
strap and extension classes of a different Java platform
implementa- tion. It is important to use -bootclasspath and
-extdirs when cross-compiling; see Cross-Compilation Example
below.</p>

<p>-target version Generate class files that target a
specified version of the VM. Class files will run on the
specified target and on later versions, but not on earlier
versions of the VM. Valid targets are 1.1 1.2 1.3 1.4 1.5
(also 5) and 1.6 (also 6).</p>

<p>The default for -target depends on the value of
-source:</p>

<p>o If -source is not specified, the value of -target is
1.6</p>

<p>o If -source is 1.3, the value of -target is 1.1</p>

<p>o For all other values of -source, the value of -target
is the value of -source.</p>

<p>-bootclasspath bootclasspath Cross-compile against the
specified set of boot classes. As with the user class path,
boot class path entries are sepa- rated by colons (:) and
can be directories, JAR archives, or ZIP archives.</p>

<p>-extdirs directories Cross-compile against the specified
extension directories. Directories is a colon-separated list
of directories. Each JAR archive in the specified
directories is searched for class files.</p>

<p>Non-Standard Options -Xbootclasspath/p:path Prepend to
the bootstrap class path.</p>

<p>-Xbootclasspath/a:path Append to the bootstrap class
path.</p>

<p>-Xbootclasspath/:path Override location of bootstrap
class files.</p>

<p>-Xlint Enable all recommended warnings. In this release,
all avail- able warnings are recommended.</p>

<p>-Xlint:none Disable all warnings not mandated by the
Java Language Speci- fication.</p>

<p>-Xlint:-xxx Disable warning xxx, where xxx is one of the
warning names supported for -Xlint:xxx, below</p>

<p>-Xlint:unchecked Give more detail for unchecked
conversion warnings that are mandated by the Java Language
Specification.</p>

<p>-Xlint:path Warn about nonexistent path (classpath,
sourcepath, etc) directories.</p>

<p>-Xlint:serial Warn about missing serialVersionUID
definitions on serializ- able classes.</p>

<p>-Xlint:finally Warn about finally clauses that cannot
complete normally.</p>

<p>-Xlint:fallthrough Check switch blocks for fall-through
cases and provide a warn- ing message for any that are
found. Fall-through cases are cases in a switch block, other
than the last case in the block, whose code does not include
a break statement, allowing code execution to &quot;fall
through&quot; from that case to the next case. For example,
the code following the case 1 label in this switch block
does not contain a break statement:</p>

<p>switch (x) { case 1: System.out.println(&quot;1&quot;);
// No break; statement here. case 2:
System.out.println(&quot;2&quot;); }</p>

<p>If the -Xlint:fallthrough flag were used when compiling
this code, the compiler would emit a warning about
&quot;possible fall-through into case,&quot; along with the
line number of the case in question.</p>

<p>-Xmaxerrors number Set the maximum number of errors to
print.</p>

<p>-Xmaxwarns number Set the maximum number of warnings to
print.</p>

<p>-Xstdout filename Send compiler messages to the named
file. By default, compiler messages go to System.err.</p>

<p>The -J Option -Joption Pass option to the java launcher
called by javac. For example, -J-Xms48m sets the startup
memory to 48 megabytes. Although it does not begin with -X,
it is not a standard option of javac. It is a common
convention for -J to pass options to the underlying VM
executing applications written in Java.</p>

<p>Note: CLASSPATH, -classpath, -bootclasspath, and
-extdirs do not specify the classes used to run javac.
Fiddling with the implementation of the compiler in this way
is usually pointless and always risky. If you do need to do
this, use the -J option to pass through options to the
underlying java launcher.</p>

<p>COMMAND LINE ARGUMENT FILES To shorten or simplify the
javac command line, you can specify one or more files that
themselves contain arguments to the javac command (except -J
options). This enables you to create javac commands of any
length on any operating system.</p>

<p>An argument file can include javac options and source
filenames in any combination. The arguments within a file
can be space-separated or new- line-separated. If a filename
contains embedded spaces, put the whole filename in double
quotes.</p>

<p>Filenames within an argument file are relative to the
current direc- tory, not the location of the argument file.
Wildcards (*) are not allowed in these lists (such as for
specifying *.java). Use of the @ character to recursively
interpret files is not supported. The -J options are not
supported because they are passed to the launcher, which
does not support argument files.</p>

<p>When executing javac, pass in the path and name of each
argument file with the @ leading character. When javac
encounters an argument beginning with the character @, it
expands the contents of that file into the argument
list.</p>

<p>Example - Single Arg File You could use a single
argument file named &quot;argfile&quot; to hold all javac
arguments:</p>

<p>C:&gt; javac @argfile</p>

<p>This argument file could contain the contents of both
files shown in the next example.</p>

<p>Example - Two Arg Files You can create two argument
files -- one for the javac options and the other for the
source filenames: (Notice the following lists have no
line-continuation characters.)</p>

<p>Create a file named &quot;options&quot; containing:</p>

<p>-d classes -g -sourcepath javpub481.rhare</p>

<p>Create a file named &quot;classes&quot; containing:</p>

<p>MyClass1.java MyClass2.java MyClass3.java</p>

<p>You would then run javac with:</p>

<p>% javac @options @classes</p>

<p>Example - Arg Files with Paths The argument files can
have paths, but any filenames inside the files are relative
to the current working directory (not path1 or path2):</p>

<p>% javac @path1/options @path2/classes</p>

<p>PROGRAMMATIC INTERFACE The com.sun.tools.javac.Main
class provides two static methods to invoke the compiler
from a program:</p>

<p>public static int compile(String[] args); public static
int compile(String[] args, PrintWriter out);</p>

<p>The args parameter represents any of the command line
arguments that would normally be passed to the javac program
and are outlined in the above Synopsis section.</p>

<p>The out parameter indicates where the compiler s
diagnostic output is directed.</p>

<p>The return value is equivalent to the exit value from
javac.</p>

<p>Note that all other classes and methods found in a
package whose name starts with com.sun.tools.javac
(informally known as sub-packages of com.sun.tools.javac)
are strictly internal and subject to change at any time.</p>

<p>EXAMPLES Compiling a Simple Program One source file,
Hello.java, defines a class called greetings.Hello. The
greetings directory is the package directory both for the
source file and the class file and is off the current
directory. This allows us to use the default user class
path. It also makes it unnecessary to specify a separate
destination directory with -d.</p>

<p>% ls greetings/ % ls greetings Hello.java % cat
greetings/Hello.java package greetings;</p>

<p>public class Hello { public static void main(String[]
args) { for (int i=0; i &lt; args.length; i++) {
System.out.println(&quot;Hello &quot; + args[i]); } } } %
javac greetings/Hello.java % ls greetings Hello.class
Hello.java % java greetings.Hello World Universe Everyone
Hello World Hello Universe Hello Everyone</p>

<p>Compiling Multiple Source Files This example compiles
all the source files in the package greetings.</p>

<p>% ls greetings/ % ls greetings Aloha.java GutenTag.java
Hello.java Hi.java % javac greetings/*.java % ls greetings
Aloha.class GutenTag.class Hello.class Hi.class Aloha.java
GutenTag.java Hello.java Hi.java</p>

<p>Specifying a User Class Path Having changed one of the
source files in the previous example, we recompile it:</p>

<p>% pwd /examples % javac greetings/Hi.java</p>

<p>Since greetings.Hi refers to other classes in the
greetings package, the compiler needs to find these other
classes. The example above works, because our default user
class path happens to be the direc- tory containing the
package directory. But suppose we want to recom- pile this
file and not worry about which directory were in? Then we
need to add /examples to the user class path. We can do this
by set- ting CLASSPATH, but here we ll use the -classpath
option.</p>

<p>% javac -classpath /examples
/examples/greetings/Hi.java</p>

<p>If we change greetings.Hi again, to use a banner
utility, that util- ity also needs to be accessible through
the user class path.</p>

<p>% javac -classpath /examples:/lib/Banners.jar
/examples/greetings/Hi.java</p>

<p>To execute a class in greetings, we need access both to
greetings and to the classes it uses.</p>

<p>% java -classpath /examples:/lib/Banners.jar
greetings.Hi</p>

<p>Separating Source Files and Class Files It often makes
sense to keep source files and class files in sepa- rate
directories, especially on large projects. We use -d to
indi- cate the separate class file destination. Since the
source files are not in the user class path, we use
-sourcepath to help the compiler find them.</p>

<p>% ls classes/ lib/ src/ % ls src farewells/ % ls
src/farewells Base.java GoodBye.java % ls lib Banners.jar %
ls classes % javac -sourcepath src -classpath
classes:lib/Banners.jar src/farewells/GoodBye.java -d
classes % ls classes farewells/ % ls classes/farewells
Base.class GoodBye.class</p>

<p>Note: The compiler compiled src/farewells/Base.java,
even though we didnt specify it on the command line. To
trace automatic com- piles, use the -verbose option.</p>

<p>Cross-Compilation Example Here we use javac to compile
code that will run on a 1.4 VM.</p>

<p>% javac -target 1.4 -bootclasspath
jdk1.4.2/lib/classes.zip -extdirs &quot;&quot;
OldCode.java</p>

<p>The -target 1.4 option ensures that the generated class
files will be compatible with 1.4 VMs. By default, javac
compiles for JDK 6.</p>

<p>The Java Platform JDKs javac would also by default
compile against its own bootstrap classes, so we need to
tell javac to compile against JDK 1.4 bootstrap classes
instead. We do this with -boot- classpath and -extdirs.
Failing to do this might allow compilation against a Java
Platform API that would not be present on a 1.4 VM and would
fail at runtime.</p>

<p>SEE ALSO o java - the Java Application Launcher</p>

<p>o jdb - Java Application Debugger</p>

<p>o javah - C Header and Stub File Generator</p>

<p>o javap - Class File Disassembler</p>

<p>o javadoc - API Documentation Generator</p>

<p>o jar - JAR Archive Tool</p>

<p>o The Java Extensions Framework @
http://java.sun.com/javase/6/docs/technotes/guides/exten-
sions/index.html</p>

<p>07 Aug 2006 javac(1)</p>
<hr>
</body>
</html>
