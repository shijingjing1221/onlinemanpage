<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:01 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLDBMFILTER(1) Perl Programmers Reference Guide
PERLDBMFILTER(1)</p>

<p>NAME perldbmfilter - Perl DBM Filters</p>

<p>SYNOPSIS $db = tie %hash, &rsquo;DBM&rsquo;, ...</p>

<p>$old_filter = $db-&gt;filter_store_key ( sub { ... } );
$old_filter = $db-&gt;filter_store_value( sub { ... } );
$old_filter = $db-&gt;filter_fetch_key ( sub { ... } );
$old_filter = $db-&gt;filter_fetch_value( sub { ... } );</p>

<p>DESCRIPTION The four &quot;filter_*&quot; methods shown
above are available in all the DBM modules that ship with
Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and
SDBM_File.</p>

<p>Each of the methods work identically, and are used to
install (or uninstall) a single DBM Filter. The only
difference between them is the place that the filter is
installed.</p>

<p>To summarise:</p>

<p>filter_store_key If a filter has been installed with
this method, it will be invoked every time you write a key
to a DBM database.</p>

<p>filter_store_value If a filter has been installed with
this method, it will be invoked every time you write a value
to a DBM database.</p>

<p>filter_fetch_key If a filter has been installed with
this method, it will be invoked every time you read a key
from a DBM database.</p>

<p>filter_fetch_value If a filter has been installed with
this method, it will be invoked every time you read a value
from a DBM database.</p>

<p>You can use any combination of the methods from none to
all four.</p>

<p>All filter methods return the existing filter, if
present, or &quot;undef&quot; in not.</p>

<p>To delete a filter pass &quot;undef&quot; to it.</p>

<p>The Filter When each filter is called by Perl, a local
copy of $_ will contain the key or value to be filtered.
Filtering is achieved by modifying the contents of $_. The
return code from the filter is ignored.</p>

<p>An Example -- the NULL termination problem. DBM Filters
are useful for a class of problems where you always want to
make the same transformation to all keys, all values or
both.</p>

<p>For example, consider the following scenario. You have a
DBM database that you need to share with a third-party C
application. The C application assumes that all keys and
values are NULL terminated. Unfortunately when Perl writes
to DBM databases it doesn t use NULL termination, so your
Perl application will have to manage NULL termination
itself. When you write to the database you will have to use
something like this:</p>

<p>$hash{&quot;$key &quot;} = &quot;$value &quot;;</p>

<p>Similarly the NULL needs to be taken into account when
you are considering the length of existing keys/values.</p>

<p>It would be much better if you could ignore the NULL
terminations issue in the main application code and have a
mechanism that automatically added the terminating NULL to
all keys and values whenever you write to the database and
have them removed when you read from the database. As Im
sure you have already guessed, this is a problem that DBM
Filters can fix very easily.</p>

<p>use strict; use warnings; use SDBM_File; use Fcntl;</p>

<p>my %hash; my $filename = &quot;filt&quot;; unlink
$filename;</p>

<p>my $db = tie(%hash, &rsquo;SDBM_File&rsquo;, $filename,
O_RDWR|O_CREAT, 0640) or die &quot;Cannot open $filename:
$!0;</p>

<p># Install DBM Filters $db-&gt;filter_fetch_key ( sub {
s/ $// } ); $db-&gt;filter_store_key ( sub { $_ .= &quot;
&quot; } ); $db-&gt;filter_fetch_value( sub { no warnings
&rsquo;uninitialized&rsquo;; s/ $// } );
$db-&gt;filter_store_value( sub { $_ .= &quot; &quot; }
);</p>

<p>$hash{&quot;abc&quot;} = &quot;def&quot;; my $a =
$hash{&quot;ABC&quot;}; # ... undef $db; untie %hash;</p>

<p>The code above uses SDBM_File, but it will work with any
of the DBM modules.</p>

<p>Hopefully the contents of each of the filters should be
self- explanatory. Both &quot;fetch&quot; filters remove the
terminating NULL, and both &quot;store&quot; filters add a
terminating NULL.</p>

<p>Another Example -- Key is a C int. Here is another
real-life example. By default, whenever Perl writes to a DBM
database it always writes the key and value as strings. So
when you use this:</p>

<p>$hash{12345} = &quot;something&quot;;</p>

<p>the key 12345 will get stored in the DBM database as the
5 byte string &quot;12345&quot;. If you actually want the
key to be stored in the DBM database as a C int, you will
have to use &quot;pack&quot; when writing, and
&quot;unpack&quot; when reading.</p>

<p>Here is a DBM Filter that does it:</p>

<p>use strict; use warnings; use DB_File; my %hash; my
$filename = &quot;filt&quot;; unlink $filename;</p>

<p>my $db = tie %hash, &rsquo;DB_File&rsquo;, $filename,
O_CREAT|O_RDWR, 0666, $DB_HASH or die &quot;Cannot open
$filename: $!0;</p>

<p>$db-&gt;filter_fetch_key ( sub { $_ =
unpack(&quot;i&quot;, $_) } ); $db-&gt;filter_store_key (
sub { $_ = pack (&quot;i&quot;, $_) } ); $hash{123} =
&quot;def&quot;; # ... undef $db; untie %hash;</p>

<p>The code above uses DB_File, but again it will work with
any of the DBM modules.</p>

<p>This time only two filters have been used -- we only
need to manipulate the contents of the key, so it wasnt
necessary to install any value filters.</p>

<p>SEE ALSO DB_File, GDBM_File, NDBM_File, ODBM_File and
SDBM_File.</p>

<p>AUTHOR Paul Marquess</p>

<p>perl v5.10.1 2009-02-12 PERLDBMFILTER(1)</p>
<hr>
</body>
</html>
