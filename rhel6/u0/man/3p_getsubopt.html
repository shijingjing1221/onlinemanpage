<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GETSUBOPT(3P) POSIX Programmer s Manual
GETSUBOPT(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME getsubopt - parse suboption arguments from a
string</p>

<p>SYNOPSIS #include &lt;stdlib.h&gt;</p>

<p>int getsubopt(char **optionp, char * const *keylistp,
char **valuep);</p>

<p>DESCRIPTION The getsubopt() function shall parse
suboption arguments in a flag argument. Such options often
result from the use of getopt().</p>

<p>The getsubopt() argument optionp is a pointer to a
pointer to the option argument string. The suboption
arguments shall be separated by commas and each may consist
of either a single token, or a token-value pair separated by
an equal sign.</p>

<p>The keylistp argument shall be a pointer to a vector of
strings. The end of the vector is identified by a null
pointer. Each entry in the vector is one of the possible
tokens that might be found in *optionp. Since commas delimit
suboption arguments in optionp, they should not appear in
any of the strings pointed to by keylistp. Similarly,
because an equal sign separates a token from its value, the
application should not include an equal sign in any of the
strings pointed to by keylistp.</p>

<p>The valuep argument is the address of a value string
pointer.</p>

<p>If a comma appears in optionp, it shall be interpreted
as a suboption separator. After commas have been processed,
if there are one or more equal signs in a suboption string,
the first equal sign in any subop- tion string shall be
interpreted as a separator between a token and a value.
Subsequent equal signs in a suboption string shall be inter-
preted as part of the value.</p>

<p>If the string at *optionp contains only one suboption
argument (equiva- lently, no commas), getsubopt() shall
update *optionp to point to the null character at the end of
the string. Otherwise, it shall isolate the suboption
argument by replacing the comma separator with a null
character, and shall update *optionp to point to the start
of the next suboption argument. If the suboption argument
has an associated value (equivalently, contains an equal
sign), getsubopt() shall update *val- uep to point to the
values first character. Otherwise, it shall set *valuep to a
null pointer. The calling application may use this infor-
mation to determine whether the presence or absence of a
value for the suboption is an error.</p>

<p>Additionally, when getsubopt() fails to match the
suboption argument with a token in the keylistp array, the
calling application should decide if this is an error, or if
the unrecognized option should be processed in another
way.</p>

<p>RETURN VALUE The getsubopt() function shall return the
index of the matched token string, or -1 if no token strings
were matched.</p>

<p>ERRORS No errors are defined.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES #include &lt;stdio.h&gt; #include
&lt;stdlib.h&gt;</p>

<p>int do_all; const char *type; int read_size; int
write_size; int read_only;</p>

<p>enum { RO_OPTION = 0, RW_OPTION, READ_SIZE_OPTION,
WRITE_SIZE_OPTION };</p>

<p>const char *mount_opts[] = { [RO_OPTION] =
&quot;ro&quot;, [RW_OPTION] = &quot;rw&quot;,
[READ_SIZE_OPTION] = &quot;rsize&quot;, [WRITE_SIZE_OPTION]
= &quot;wsize&quot;, NULL };</p>

<p>int main(int argc, char *argv[]) { char *subopts,
*value; int opt;</p>

<p>while ((opt = getopt(argc, argv, &quot;at:o:&quot;)) !=
-1) switch(opt) { case: do_all = 1; break; case: type =
optarg; break; case: subopts = optarg; while (*subopts !)
switch(getsubopt(&amp;subopts, mount_opts, &amp;value)) {
case RO_OPTION: read_only = 1; break; case RW_OPTION:
read_only = 0; break; case READ_SIZE_OPTION: if (value ==
NULL) abort(); read_size = atoi(value); break; case
WRITE_SIZE_OPTION: if (value == NULL) abort(); write_size =
atoi(value); break; default: /* Unknown suboption. */
printf(&quot;Unknown suboption %sn&quot;, value); break; }
break; default: abort(); }</p>

<p>/* Do the real work. */</p>

<p>return 0; }</p>

<p>Parsing Suboptions The following example uses the
getsubopt() function to parse a value argument in the optarg
external variable returned by a call to getopt().</p>

<p>#include &lt;stdlib.h&gt; ... char *tokens[] =
{&quot;HOME&quot;, &quot;PATH&quot;, &quot;LOGNAME&quot;,
(char *) NULL }; char *value; int opt, index;</p>

<p>while ((opt = getopt(argc, argv, &quot;e:&quot;)) != -1)
{ switch(opt) { casee: while ((index =
getsubopt(&amp;optarg, tokens, &amp;value)) != -1) {
switch(index) { ... } break; ... } } ...</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO getopt(), the Base Definitions volume of IEEE
Std 1003.1-2001, &lt;stdlib.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 GETSUBOPT(3P)</p>
<hr>
</body>
</html>
