<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:16:40 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SOCKET(2) Linux Programmer s Manual SOCKET(2)</p>

<p>NAME socket - create an endpoint for communication</p>

<p>SYNOPSIS #include &lt;sys/types.h&gt; /* See NOTES */
#include &lt;sys/socket.h&gt;</p>

<p>int socket(int domain, int type, int protocol);</p>

<p>DESCRIPTION socket() creates an endpoint for
communication and returns a descrip- tor.</p>

<p>The domain argument specifies a communication domain;
this selects the protocol family which will be used for
communication. These families are defined in
&lt;sys/socket.h&gt;. The currently understood formats
include:</p>

<p>Name Purpose Man page AF_UNIX, AF_LOCAL Local
communication unix(7) AF_INET IPv4 Internet protocols ip(7)
AF_INET6 IPv6 Internet protocols ipv6(7) AF_IPX IPX - Novell
protocols AF_NETLINK Kernel user interface device netlink(7)
AF_X25 ITU-T X.25 / ISO-8208 protocol x25(7) AF_AX25 Amateur
radio AX.25 protocol AF_ATMPVC Access to raw ATM PVCs
AF_APPLETALK Appletalk ddp(7) AF_PACKET Low level packet
interface packet(7)</p>

<p>The socket has the indicated type, which specifies the
communication semantics. Currently defined types are:</p>

<p>SOCK_STREAM Provides sequenced, reliable, two-way,
connection-based byte streams. An out-of-band data
transmission mecha- nism may be supported.</p>

<p>SOCK_DGRAM Supports datagrams (connectionless,
unreliable messages of a fixed maximum length).</p>

<p>SOCK_SEQPACKET Provides a sequenced, reliable, two-way
connection- based data transmission path for datagrams of
fixed maximum length; a consumer is required to read an
entire packet with each input system call.</p>

<p>SOCK_RAW Provides raw network protocol access.</p>

<p>SOCK_RDM Provides a reliable datagram layer that does
not guar- antee ordering.</p>

<p>SOCK_PACKET Obsolete and should not be used in new
programs; see packet(7).</p>

<p>Some socket types may not be implemented by all protocol
families; for example, SOCK_SEQPACKET is not implemented for
AF_INET.</p>

<p>Since Linux 2.6.27, the type argument serves a second
purpose: in addi- tion to specifying a socket type, it may
include the bitwise OR of any of the following values, to
modify the behavior of socket():</p>

<p>SOCK_NONBLOCK Set the O_NONBLOCK file status flag on the
new open file description. Using this flag saves extra calls
to fcntl(2) to achieve the same result.</p>

<p>SOCK_CLOEXEC Set the close-on-exec (FD_CLOEXEC) flag on
the new file descriptor. See the description of the
O_CLOEXEC flag in open(2) for reasons why this may be
useful.</p>

<p>The protocol specifies a particular protocol to be used
with the socket. Normally only a single protocol exists to
support a particular socket type within a given protocol
family, in which case protocol can be specified as 0.
However, it is possible that many protocols may exist, in
which case a particular protocol must be specified in this
manner. The protocol number to use is specific to the
communication domain in which communication is to take
place; see protocols(5). See getprotoent(3) on how to map
protocol name strings to protocol numbers.</p>

<p>Sockets of type SOCK_STREAM are full-duplex byte
streams, similar to pipes. They do not preserve record
boundaries. A stream socket must be in a connected state
before any data may be sent or received on it. A connection
to another socket is created with a connect(2) call. Once
connected, data may be transferred using read(2) and
write(2) calls or some variant of the send(2) and recv(2)
calls. When a session has been completed a close(2) may be
performed. Out-of-band data may also be transmitted as
described in send(2) and received as described in
recv(2).</p>

<p>The communications protocols which implement a
SOCK_STREAM ensure that data is not lost or duplicated. If a
piece of data for which the peer protocol has buffer space
cannot be successfully transmitted within a reasonable
length of time, then the connection is considered to be
dead. When SO_KEEPALIVE is enabled on the socket the
protocol checks in a protocol-specific manner if the other
end is still alive. A SIG- PIPE signal is raised if a
process sends or receives on a broken stream; this causes
naive processes, which do not handle the signal, to exit.
SOCK_SEQPACKET sockets employ the same system calls as
SOCK_STREAM sockets. The only difference is that read(2)
calls will return only the amount of data requested, and any
data remaining in the arriving packet will be discarded.
Also all message boundaries in incoming datagrams are
preserved.</p>

<p>SOCK_DGRAM and SOCK_RAW sockets allow sending of
datagrams to corre- spondents named in sendto(2) calls.
Datagrams are generally received with recvfrom(2), which
returns the next datagram along with the address of its
sender.</p>

<p>SOCK_PACKET is an obsolete socket type to receive raw
packets directly from the device driver. Use packet(7)
instead.</p>

<p>An fcntl(2) F_SETOWN operation can be used to specify a
process or pro- cess group to receive a SIGURG signal when
the out-of-band data arrives or SIGPIPE signal when a
SOCK_STREAM connection breaks unexpectedly. This operation
may also be used to set the process or process group that
receives the I/O and asynchronous notification of I/O events
via SIGIO. Using F_SETOWN is equivalent to an ioctl(2) call
with the FIOSETOWN or SIOCSPGRP argument.</p>

<p>When the network signals an error condition to the
protocol module (e.g., using a ICMP message for IP) the
pending error flag is set for the socket. The next operation
on this socket will return the error code of the pending
error. For some protocols it is possible to enable a
per-socket error queue to retrieve detailed information
about the error; see IP_RECVERR in ip(7).</p>

<p>The operation of sockets is controlled by socket level
options. These options are defined in &lt;sys/socket.h&gt;.
The functions setsockopt(2) and getsockopt(2) are used to
set and get options, respectively.</p>

<p>RETURN VALUE On success, a file descriptor for the new
socket is returned. On error, -1 is returned, and errno is
set appropriately.</p>

<p>ERRORS EACCES Permission to create a socket of the
specified type and/or pro- tocol is denied.</p>

<p>EAFNOSUPPORT The implementation does not support the
specified address fam- ily.</p>

<p>EINVAL Unknown protocol, or protocol family not
available.</p>

<p>EINVAL Invalid flags in type.</p>

<p>EMFILE Process file table overflow.</p>

<p>ENFILE The system limit on the total number of open
files has been reached.</p>

<p>ENOBUFS or ENOMEM Insufficient memory is available. The
socket cannot be created until sufficient resources are
freed.</p>

<p>EPROTONOSUPPORT The protocol type or the specified
protocol is not supported within this domain.</p>

<p>Other errors may be generated by the underlying protocol
modules.</p>

<p>CONFORMING TO 4.4BSD, POSIX.1-2001.</p>

<p>The SOCK_NONBLOCK and SOCK_CLOEXEC flags are
Linux-specific.</p>

<p>socket() appeared in 4.2BSD. It is generally portable
to/from non-BSD systems supporting clones of the BSD socket
layer (including System V variants).</p>

<p>NOTES POSIX.1-2001 does not require the inclusion of
&lt;sys/types.h&gt;, and this header file is not required on
Linux. However, some historical (BSD) implementations
required this header file, and portable applications are
probably wise to include it.</p>

<p>The manifest constants used under 4.x BSD for protocol
families are PF_UNIX, PF_INET, etc., while AF_UNIX etc. are
used for address fami- lies. However, already the BSD man
page promises: &quot;The protocol family generally is the
same as the address family&quot;, and subsequent standards
use AF_* everywhere.</p>

<p>EXAMPLE An example of the use of socket() is shown in
getaddrinfo(3).</p>

<p>SEE ALSO accept(2), bind(2), connect(2), fcntl(2),
getpeername(2), getsock- name(2), getsockopt(2), ioctl(2),
listen(2), read(2), recv(2), select(2), send(2),
shutdown(2), socketpair(2), write(2), getpro- toent(3),
ip(7), socket(7), tcp(7), udp(7), unix(7)</p>

<p>An Introductory 4.3BSD Interprocess Communication
Tutorial is reprinted in UNIX Programmer_s Supplementary
Documents Volume 1.</p>

<p>BSD Interprocess Communication Tutorial is reprinted in
UNIX Program- mers Supplementary Documents Volume 1.</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2009-01-19 SOCKET(2)</p>
<hr>
</body>
</html>
