<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:09:59 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLBOOT(1) Perl Programmers Reference Guide
PERLBOOT(1)</p>

<p>NAME perlboot - Beginners Object-Oriented Tutorial</p>

<p>DESCRIPTION If youre not familiar with objects from
other languages, some of the other Perl object documentation
may be a little daunting, such as perlobj, a basic reference
in using objects, and perltoot, which introduces readers to
the peculiarities of Perls object system in a tutorial
way.</p>

<p>So, lets take a different approach, presuming no prior
object experience. It helps if you know about subroutines
(perlsub), references (perlref et. seq.), and packages
(perlmod), so become familiar with those first if you havent
already.</p>

<p>If we could talk to the animals... Lets let the animals
talk for a moment:</p>

<p>sub Cow::speak { print &quot;a Cow goes moooo!0; } sub
Horse::speak { print &quot;a Horse goes neigh!0; } sub
Sheep::speak { print &quot;a Sheep goes baaaah!0; }</p>

<p>Cow::speak; Horse::speak; Sheep::speak;</p>

<p>This results in:</p>

<p>a Cow goes moooo! a Horse goes neigh! a Sheep goes
baaaah!</p>

<p>Nothing spectacular here. Simple subroutines, albeit
from separate packages, and called using the full package
name. So lets create an entire pasture:</p>

<p># Cow::speak, Horse::speak, Sheep::speak as before
@pasture = qw(Cow Cow Horse Sheep Sheep); foreach $animal
(@pasture) { &amp;{$animal.&quot;::speak&quot;}; }</p>

<p>This results in:</p>

<p>a Cow goes moooo! a Cow goes moooo! a Horse goes neigh!
a Sheep goes baaaah! a Sheep goes baaaah!</p>

<p>Wow. That symbolic coderef de-referencing there is
pretty nasty. Were counting on &quot;no strict refs&quot;
mode, certainly not recommended for larger programs. And why
was that necessary? Because the name of the package seems to
be inseparable from the name of the subroutine we want to
invoke within that package.</p>

<p>Or is it?</p>

<p>Introducing the method invocation arrow For now, lets
say that &quot;Class-&gt;method&quot; invokes subroutine
&quot;method&quot; in package &quot;Class&quot;. (Here,
&quot;Class&quot; is used in its &quot;category&quot;
meaning, not its &quot;scholastic&quot; meaning.) Thats not
completely accurate, but well do this one step at a time.
Now lets use it like so:</p>

<p># Cow::speak, Horse::speak, Sheep::speak as before
Cow-&gt;speak; Horse-&gt;speak; Sheep-&gt;speak;</p>

<p>And once again, this results in:</p>

<p>a Cow goes moooo! a Horse goes neigh! a Sheep goes
baaaah!</p>

<p>Thats not fun yet. Same number of characters, all
constant, no variables. But yet, the parts are separable
now. Watch:</p>

<p>$a = &quot;Cow&quot;; $a-&gt;speak; # invokes
Cow-&gt;speak</p>

<p>Ahh! Now that the package name has been parted from the
subroutine name, we can use a variable package name. And
this time, weve got something that works even when &quot;use
strict refs&quot; is enabled.</p>

<p>Invoking a barnyard Lets take that new arrow invocation
and put it back in the barnyard example:</p>

<p>sub Cow::speak { print &quot;a Cow goes moooo!0; } sub
Horse::speak { print &quot;a Horse goes neigh!0; } sub
Sheep::speak { print &quot;a Sheep goes baaaah!0; }</p>

<p>@pasture = qw(Cow Cow Horse Sheep Sheep); foreach
$animal (@pasture) { $animal-&gt;speak; }</p>

<p>There! Now we have the animals all talking, and safely
at that, without the use of symbolic coderefs.</p>

<p>But look at all that common code. Each of the
&quot;speak&quot; routines has a similar structure: a
&quot;print&quot; operator and a string that contains common
text, except for two of the words. It d be nice if we could
factor out the commonality, in case we decide later to
change it all to &quot;says&quot; instead of
&quot;goes&quot;.</p>

<p>And we actually have a way of doing that without much
fuss, but we have to hear a bit more about what the method
invocation arrow is actually doing for us.</p>

<p>The extra parameter of method invocation The invocation
of:</p>

<p>Class-&gt;method(@args)</p>

<p>attempts to invoke subroutine &quot;Class::method&quot;
as:</p>

<p>Class::method(&quot;Class&quot;, @args);</p>

<p>(If the subroutine cant be found,
&quot;inheritance&quot; kicks in, but well get to that
later.) This means that we get the class name as the first
parameter (the only parameter, if no arguments are given).
So we can rewrite the &quot;Sheep&quot; speaking subroutine
as:</p>

<p>sub Sheep::speak { my $class = shift; print &quot;a
$class goes baaaah!0; }</p>

<p>And the other two animals come out similarly:</p>

<p>sub Cow::speak { my $class = shift; print &quot;a $class
goes moooo!0; } sub Horse::speak { my $class = shift; print
&quot;a $class goes neigh!0; }</p>

<p>In each case, $class will get the value appropriate for
that subroutine. But once again, we have a lot of similar
structure. Can we factor that out even further? Yes, by
calling another method in the same class.</p>

<p>Calling a second method to simplify things Lets call out
from &quot;speak&quot; to a helper method called
&quot;sound&quot;. This method provides the constant text
for the sound itself.</p>

<p>{ package Cow; sub sound { &quot;moooo&quot; } sub speak
{ my $class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0; } }</p>

<p>Now, when we call &quot;Cow-&gt;speak&quot;, we get a
$class of &quot;Cow&quot; in &quot;speak&quot;. This in turn
selects the &quot;Cow-&gt;sound&quot; method, which returns
&quot;moooo&quot;. But how different would this be for the
&quot;Horse&quot;?</p>

<p>{ package Horse; sub sound { &quot;neigh&quot; } sub
speak { my $class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0; } }</p>

<p>Only the name of the package and the specific sound
change. So can we somehow share the definition for
&quot;speak&quot; between the Cow and the Horse? Yes, with
inheritance!</p>

<p>Inheriting the windpipes We ll define a common
subroutine package called &quot;Animal&quot;, with the
definition for &quot;speak&quot;:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0; }
}</p>

<p>Then, for each animal, we say it &quot;inherits&quot;
from &quot;Animal&quot;, along with the animal-specific
sound:</p>

<p>{ package Cow; @ISA = qw(Animal); sub sound {
&quot;moooo&quot; } }</p>

<p>Note the added @ISA array (pronounced &quot;is a&quot;).
Well get to that in a minute.</p>

<p>But what happens when we invoke
&quot;Cow-&gt;speak&quot; now?</p>

<p>First, Perl constructs the argument list. In this case,
its just &quot;Cow&quot;. Then Perl looks for
&quot;Cow::speak&quot;. But thats not there, so Perl checks
for the inheritance array @Cow::ISA. It s there, and
contains the single name &quot;Animal&quot;.</p>

<p>Perl next checks for &quot;speak&quot; inside
&quot;Animal&quot; instead, as in &quot;Animal::speak&quot;.
And thats found, so Perl invokes that subroutine with the
already frozen argument list.</p>

<p>Inside the &quot;Animal::speak&quot; subroutine, $class
becomes &quot;Cow&quot; (the first argument). So when we get
to the step of invoking &quot;$class-&gt;sound&quot;, it ll
be looking for &quot;Cow-&gt;sound&quot;, which gets it on
the first try without looking at @ISA. Success!</p>

<p>A few notes about @ISA This magical @ISA variable has
declared that &quot;Cow&quot; &quot;is a&quot;
&quot;Animal&quot;. Note that its an array, not a simple
single value, because on rare occasions, it makes sense to
have more than one parent class searched for the missing
methods.</p>

<p>If &quot;Animal&quot; also had an @ISA, then wed check
there too. The search is recursive, depth-first,
left-to-right in each @ISA by default (see mro for
alternatives). Typically, each @ISA has only one element
(multiple elements means multiple inheritance and multiple
headaches), so we get a nice tree of inheritance.</p>

<p>When we turn on &quot;use strict&quot;, well get
complaints on @ISA, since its not a variable containing an
explicit package name, nor is it a lexical (&quot;my&quot;)
variable. We can t make it a lexical variable though (it has
to belong to the package to be found by the inheritance
mechanism), so theres a couple of straightforward ways to
handle that.</p>

<p>The easiest is to just spell the package name out:</p>

<p>@Cow::ISA = qw(Animal);</p>

<p>Or declare it as package global variable:</p>

<p>package Cow; our @ISA = qw(Animal);</p>

<p>Or allow it as an implicitly named package variable:</p>

<p>package Cow; use vars qw(@ISA); @ISA = qw(Animal);</p>

<p>If the &quot;Animal&quot; class comes from another
(object-oriented) module, then just employ &quot;use
base&quot; to specify that &quot;Animal&quot; should serve
as the basis for the &quot;Cow&quot; class:</p>

<p>package Cow; use base qw(Animal);</p>

<p>Now thats pretty darn simple!</p>

<p>Overriding the methods Lets add a mouse, which can
barely be heard:</p>

<p># Animal package from before { package Mouse; @ISA =
qw(Animal); sub sound { &quot;squeak&quot; } sub speak { my
$class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0; print &quot;[but you can barely
hear it!]0; } }</p>

<p>Mouse-&gt;speak;</p>

<p>which results in:</p>

<p>a Mouse goes squeak! [but you can barely hear it!]</p>

<p>Here, &quot;Mouse&quot; has its own speaking routine, so
&quot;Mouse-&gt;speak&quot; doesnt immediately invoke
&quot;Animal-&gt;speak&quot;. This is known as
&quot;overriding&quot;. In fact, we don t even need to say
that a &quot;Mouse&quot; is an &quot;Animal&quot; at all,
because all of the methods needed for &quot;speak&quot; are
completely defined for &quot;Mouse&quot;; this is known as
&quot;duck typing&quot;: &quot;If it walks like a duck and
quacks like a duck, I would call it a duck&quot; (James
Whitcomb). However, it would probably be beneficial to allow
a closer examination to conclude that a &quot;Mouse&quot; is
indeed an &quot;Animal&quot;, so it is actually better to
define &quot;Mouse&quot; with &quot;Animal&quot; as its base
(that is, it is better to &quot;derive &quot;Mouse&quot;
from &quot;Animal&quot;&quot;).</p>

<p>Moreover, this duplication of code could become a
maintenance headache (though code-reuse is not actually a
good reason for inheritance; good design practices dictate
that a derived class should be usable wherever its base
class is usable, which might not be the outcome if
code-reuse is the sole criterion for inheritance. Just
remember that a &quot;Mouse&quot; should always act like an
&quot;Animal&quot;).</p>

<p>So, lets make &quot;Mouse&quot; an
&quot;Animal&quot;!</p>

<p>The obvious solution is to invoke
&quot;Animal::speak&quot; directly:</p>

<p># Animal package from before { package Mouse; @ISA =
qw(Animal); sub sound { &quot;squeak&quot; } sub speak { my
$class = shift; Animal::speak($class); print &quot;[but you
can barely hear it!]0; } }</p>

<p>Note that were using &quot;Animal::speak&quot;. If we
were to invoke &quot;Animal-&gt;speak&quot; instead, the
first parameter to &quot;Animal::speak&quot; would
automatically be &quot;Animal&quot; rather than
&quot;Mouse&quot;, so that the call to
&quot;$class-&gt;sound&quot; in &quot;Animal::speak&quot;
would become &quot;Animal-&gt;sound&quot; rather than
&quot;Mouse-&gt;sound&quot;.</p>

<p>Also, without the method arrow &quot;-&gt;&quot;, it
becomes necessary to specify the first parameter to
&quot;Animal::speak&quot; ourselves, which is why $class is
explicitly passed: &quot;Animal::speak($class)&quot;.</p>

<p>However, invoking &quot;Animal::speak&quot; directly is
a mess: Firstly, it assumes that the &quot;speak&quot;
method is a member of the &quot;Animal&quot; class; what if
&quot;Animal&quot; actually inherits &quot;speak&quot; from
its own base? Because we are no longer using
&quot;-&gt;&quot; to access &quot;speak&quot;, the special
method look up mechanism wouldnt be used, so
&quot;speak&quot; wouldn t even be found!</p>

<p>The second problem is more subtle: &quot;Animal&quot; is
now hardwired into the subroutine selection. Let s assume
that &quot;Animal::speak&quot; does exist. What happens
when, at a later time, someone expands the class hierarchy
by having &quot;Mouse&quot; inherit from &quot;Mus&quot;
instead of &quot;Animal&quot;. Unless the invocation of
&quot;Animal::speak&quot; is also changed to an invocation
of &quot;Mus::speak&quot;, centuries worth of taxonomical
classification could be obliterated!</p>

<p>What we have here is a fragile or leaky abstraction; it
is the beginning of a maintenance nightmare. What we need is
the ability to search for the right method wih as few
assumptions as possible.</p>

<p>Starting the search from a different place A better
solution is to tell Perl where in the inheritance chain to
begin searching for &quot;speak&quot;. This can be achieved
with a modified version of the method arrow
&quot;-&gt;&quot;:</p>

<p>ClassName-&gt;FirstPlaceToLook::method</p>

<p>So, the improved &quot;Mouse&quot; class is:</p>

<p># same Animal as before { package Mouse; # same @ISA,
&amp;sound as before sub speak { my $class = shift;
$class-&gt;Animal::speak; print &quot;[but you can barely
hear it!]0; } }</p>

<p>Using this syntax, we start with &quot;Animal&quot; to
find &quot;speak&quot;, and then use all of
&quot;Animal&quot; s inheritance chain if it is not found
immediately. As usual, the first parameter to
&quot;speak&quot; would be $class, so we no longer need to
pass $class explicitly to &quot;speak&quot;.</p>

<p>But what about the second problem? Were still hardwiring
&quot;Animal&quot; into the method lookup.</p>

<p>The SUPER way of doing things If &quot;Animal&quot; is
replaced with the special placeholder &quot;SUPER&quot; in
that invocation, then the contents of &quot;Mouse&quot;s
@ISA are used for the search, beginning with $ISA[0]. So,
all of the problems can be fixed as follows:</p>

<p># same Animal as before { package Mouse; # same @ISA,
&amp;sound as before sub speak { my $class = shift;
$class-&gt;SUPER::speak; print &quot;[but you can barely
hear it!]0; } }</p>

<p>In general, &quot;SUPER::speak&quot; means look in the
current packages @ISA for a class that implements
&quot;speak&quot;, and invoke the first one found. The
placeholder is called &quot;SUPER&quot;, because many other
languages refer to base classes as &quot;superclasses&quot;,
and Perl likes to be eclectic.</p>

<p>Note that a call such as</p>

<p>$class-&gt;SUPER::method;</p>

<p>does not look in the @ISA of $class unless $class
happens to be the current package.</p>

<p>Les review... So far, weve seen the method arrow
syntax:</p>

<p>Class-&gt;method(@args);</p>

<p>or the equivalent:</p>

<p>$a = &quot;Class&quot;; $a-&gt;method(@args);</p>

<p>which constructs an argument list of:</p>

<p>(&quot;Class&quot;, @args)</p>

<p>and attempts to invoke:</p>

<p>Class::method(&quot;Class&quot;, @args);</p>

<p>However, if &quot;Class::method&quot; is not found, then
@Class::ISA is examined (recursively) to locate a class (a
package) that does indeed contain &quot;method&quot;, and
that subroutine is invoked instead.</p>

<p>Using this simple syntax, we have class methods,
(multiple) inheritance, overriding, and extending. Using
just what we ve seen so far, weve been able to factor out
common code (though that s never a good reason for
inheritance!), and provide a nice way to reuse
implementations with variations.</p>

<p>Now, what about data?</p>

<p>A horse is a horse, of course of course -- or is it?
Lets start with the code for the &quot;Animal&quot; class
and the &quot;Horse&quot; class:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0; } }
{ package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } }</p>

<p>This lets us invoke &quot;Horse-&gt;speak&quot; to
ripple upward to &quot;Animal::speak&quot;, calling back to
&quot;Horse::sound&quot; to get the specific sound, and the
output of:</p>

<p>a Horse goes neigh!</p>

<p>But all of our Horse objects would have to be absolutely
identical. If we add a subroutine, all horses automatically
share it. Thats great for making horses the same, but how do
we capture the distinctions of an individual horse? For
example, suppose we want to give our first horse a name.
There s got to be a way to keep its name separate from the
other horses.</p>

<p>That is to say, we want particular instances of
&quot;Horse&quot; to have different names.</p>

<p>In Perl, any reference can be an &quot;instance&quot;,
so lets start with the simplest reference that can hold a
horses name: a scalar reference.</p>

<p>my $name = &quot;Mr. Ed&quot;; my $horse = ame;</p>

<p>So, now $horse is a reference to what will be the
instance-specific data (the name). The final step is to turn
this reference into a real instance of a &quot;Horse&quot;
by using the special operator &quot;bless&quot;:</p>

<p>bless $horse, Horse;</p>

<p>This operator stores information about the package named
&quot;Horse&quot; into the thing pointed at by the
reference. At this point, we say $horse is an instance of
&quot;Horse&quot;. That is, its a specific horse. The
reference is otherwise unchanged, and can still be used with
traditional dereferencing operators.</p>

<p>Invoking an instance method The method arrow can be used
on instances, as well as classes (the names of packages).
So, lets get the sound that $horse makes:</p>

<p>my $noise = $horse-&gt;sound(&quot;some&quot;,
&quot;unnecessary&quot;, &quot;args&quot;);</p>

<p>To invoke &quot;sound&quot;, Perl first notes that
$horse is a blessed reference (and thus an instance). It
then constructs an argument list, as per usual.</p>

<p>Now for the fun part: Perl takes the class in which the
instance was blessed, in this case &quot;Horse&quot;, and
uses that class to locate the subroutine. In this case,
&quot;Horse::sound&quot; is found directly (without using
inheritance). In the end, it is as though our initial line
were written as follows:</p>

<p>my $noise = Horse::sound($horse, &quot;some&quot;,
&quot;unnecessary&quot;, &quot;args&quot;);</p>

<p>Note that the first parameter here is still the
instance, not the name of the class as before. Well get
&quot;neigh&quot; as the return value, and thatll end up as
the $noise variable above.</p>

<p>If Horse::sound had not been found, wed be wandering up
the @Horse::ISA array, trying to find the method in one of
the superclasses. The only difference between a class method
and an instance method is whether the first parameter is an
instance (a blessed reference) or a class name (a
string).</p>

<p>Accessing the instance data Because we get the instance
as the first parameter, we can now access the
instance-specific data. In this case, lets add a way to get
at the name:</p>

<p>{ package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } sub name { my $self = shift; $$self; }
}</p>

<p>Inside &quot;Horse::name&quot;, the @_ array
contains:</p>

<p>($horse, &quot;some&quot;, &quot;unnecessary&quot;,
&quot;args&quot;)</p>

<p>so the &quot;shift&quot; stores $horse into $self. Then,
$self gets de-referenced with $$self as normal, yielding
&quot;Mr. Ed&quot;.</p>

<p>It s traditional to &quot;shift&quot; the first
parameter into a variable named $self for instance methods
and into a variable named $class for class methods.</p>

<p>Then, the following line:</p>

<p>print $horse-&gt;name, &quot; says &quot;,
$horse-&gt;sound, &quot;0;</p>

<p>outputs:</p>

<p>Mr. Ed says neigh.</p>

<p>How to build a horse Of course, if we constructed all of
our horses by hand, we d most likely make mistakes from time
to time. We re also violating one of the properties of
object-oriented programming, in that the &quot;inside
guts&quot; of a Horse are visible. That s good if you re a
veterinarian, but not if you just like to own horses. So,
lets have the Horse class handle the details inside a class
method:</p>

<p>{ package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } sub name { my $self = shift; # instance
method, so use $self $$self; } sub named { my $class =
shift; # class method, so use $class my $name = shift; bless
ame, $class; } }</p>

<p>Now with the new &quot;named&quot; method, we can build
a horse as follows:</p>

<p>my $horse = Horse-&gt;named(&quot;Mr. Ed&quot;);</p>

<p>Notice were back to a class method, so the two arguments
to &quot;Horse::named&quot; are &quot;Horse&quot; and
&quot;Mr. Ed&quot;. The &quot;bless&quot; operator not only
blesses &quot;ame&quot;, it also returns that reference.</p>

<p>This &quot;Horse::named&quot; method is called a
&quot;constructor&quot;.</p>

<p>Weve called the constructor &quot;named&quot; here, so
that it quickly denotes the constructors argument as the
name for this particular &quot;Horse&quot;. You can use
different constructors with different names for different
ways of &quot;giving birth&quot; to the object (like maybe
recording its pedigree or date of birth). However, youll
find that most people coming to Perl from more limited
languages use a single constructor named &quot;new&quot;,
with various ways of interpreting the arguments to
&quot;new&quot;. Either style is fine, as long as you
document your particular way of giving birth to an object.
(And you were going to do that, right?)</p>

<p>Inheriting the constructor But was there anything
specific to &quot;Horse&quot; in that method? No. Therefore,
its also the same recipe for building anything else that
inherited from &quot;Animal&quot;, so lets put
&quot;name&quot; and &quot;named&quot; there:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0; }
sub name { my $self = shift; $$self; } sub named { my $class
= shift; my $name = shift; bless ame, $class; } } { package
Horse; @ISA = qw(Animal); sub sound { &quot;neigh&quot; }
}</p>

<p>Ahh, but what happens if we invoke &quot;speak&quot; on
an instance?</p>

<p>my $horse = Horse-&gt;named(&quot;Mr. Ed&quot;);
$horse-&gt;speak;</p>

<p>We get a debugging value:</p>

<p>a Horse=SCALAR(0xaca42ac) goes neigh!</p>

<p>Why? Because the &quot;Animal::speak&quot; routine is
expecting a classname as its first parameter, not an
instance. When the instance is passed in, well end up using
a blessed scalar reference as a string, and that shows up as
we saw it just now.</p>

<p>Making a method work with either classes or instances
All we need is for a method to detect if it is being called
on a class or called on an instance. The most
straightforward way is with the &quot;ref&quot; operator.
This returns a string (the classname) when used on a blessed
reference, and an empty string when used on a string (like a
classname). Lets modify the &quot;name&quot; method first to
notice the change:</p>

<p>sub name { my $either = shift; ref $either ? $$either :
&quot;Any $either&quot;; }</p>

<p>Here, the &quot;?:&quot; operator comes in handy to
select either the dereference or a derived string. Now we
can use this with either an instance or a class. Note that
Ive changed the first parameter holder to $either to show
that this is intended:</p>

<p>my $horse = Horse-&gt;named(&quot;Mr. Ed&quot;); print
Horse-&gt;name, &quot;0; # prints &quot;Any Horse0 print
$horse-&gt;name, &quot;0; # prints &quot;Mr Ed.0</p>

<p>and now well fix &quot;speak&quot; to use this:</p>

<p>sub speak { my $either = shift; print $either-&gt;name,
&quot; goes &quot;, $either-&gt;sound, &quot;0; }</p>

<p>And since &quot;sound&quot; already worked with either a
class or an instance, were done!</p>

<p>Adding parameters to a method Lets train our animals to
eat:</p>

<p>{ package Animal; sub named { my $class = shift; my
$name = shift; bless ame, $class; } sub name { my $either =
shift; ref $either ? $$either : &quot;Any $either&quot;; }
sub speak { my $either = shift; print $either-&gt;name,
&quot; goes &quot;, $either-&gt;sound, &quot;0; } sub eat {
my $either = shift; my $food = shift; print
$either-&gt;name, &quot; eats $food.0; } } { package Horse;
@ISA = qw(Animal); sub sound { &quot;neigh&quot; } } {
package Sheep; @ISA = qw(Animal); sub sound {
&quot;baaaah&quot; } }</p>

<p>And now try it out:</p>

<p>my $horse = Horse-&gt;named(&quot;Mr. Ed&quot;);
$horse-&gt;eat(&quot;hay&quot;);
Sheep-&gt;eat(&quot;grass&quot;);</p>

<p>which prints:</p>

<p>Mr. Ed eats hay. Any Sheep eats grass.</p>

<p>An instance method with parameters gets invoked with the
instance, and then the list of parameters. So that first
invocation is like:</p>

<p>Animal::eat($horse, &quot;hay&quot;);</p>

<p>More interesting instances What if an instance needs
more data? Most interesting instances are made of many
items, each of which can in turn be a reference or even
another object. The easiest way to store these is often in a
hash. The keys of the hash serve as the names of parts of
the object (often called &quot;instance variables&quot; or
&quot;member variables&quot;), and the corresponding values
are, well, the values.</p>

<p>But how do we turn the horse into a hash? Recall that an
object was any blessed reference. We can just as easily make
it a blessed hash reference as a blessed scalar reference,
as long as everything that looks at the reference is changed
accordingly.</p>

<p>Lets make a sheep that has a name and a color:</p>

<p>my $bad = bless { Name =&gt; &quot;Evil&quot;, Color
=&gt; &quot;black&quot; }, Sheep;</p>

<p>so &quot;$bad-&gt;{Name}&quot; has &quot;Evil&quot;, and
&quot;$bad-&gt;{Color}&quot; has &quot;black&quot;. But we
want to make &quot;$bad-&gt;name&quot; access the name, and
that s now messed up because it s expecting a scalar
reference. Not to worry, because thats pretty easy to fix
up.</p>

<p>One solution is to override &quot;Animal::name&quot; and
&quot;Animal::named&quot; by defining them anew in
&quot;Sheep&quot;, but then any methods added later to
&quot;Animal&quot; might still mess up, and wed have to
override all of those too. Therefore, its never a good idea
to define the data layout in a way thats different from the
data layout of the base classes. In fact, it s a good idea
to use blessed hash references in all cases. Also, this is
why its important to have constructors do the low-level
work. So, lets redefine &quot;Animal&quot;:</p>

<p>## in Animal sub name { my $either = shift; ref $either
? $either-&gt;{Name} : &quot;Any $either&quot;; } sub named
{ my $class = shift; my $name = shift; my $self = { Name
=&gt; $name }; bless $self, $class; }</p>

<p>Of course, we still need to override &quot;named&quot;
in order to handle constructing a &quot;Sheep&quot; with a
certain color:</p>

<p>## in Sheep sub named { my ($class, $name) = @_; my
$self = $class-&gt;SUPER::named(@_); $$self{Color} =
$class-&gt;default_color; $self }</p>

<p>(Note that @_ contains the parameters to
&quot;named&quot;.)</p>

<p>Whats this &quot;default_color&quot;? Well, if
&quot;named&quot; has only the name, we still need to set a
color, so well have a class-specific default color. For a
sheep, we might define it as white:</p>

<p>## in Sheep sub default_color { &quot;white&quot; }</p>

<p>Now:</p>

<p>my $sheep = Sheep-&gt;named(&quot;Bad&quot;); print
$sheep-&gt;{Color}, &quot;0;</p>

<p>outputs:</p>

<p>white</p>

<p>Now, theres nothing particularly specific to
&quot;Sheep&quot; when it comes to color, so let s remove
&quot;Sheep::named&quot; and implement
&quot;Animal::named&quot; to handle color instead:</p>

<p>## in Animal sub named { my ($class, $name) = @_; my
$self = { Name =&gt; $name, Color =&gt;
$class-&gt;default_color }; bless $self, $class; }</p>

<p>And then to keep from having to define
&quot;default_color&quot; for each additional class, well
define a method that serves as the &quot;default
default&quot; directly in &quot;Animal&quot;:</p>

<p>## in Animal sub default_color { &quot;brown&quot; }</p>

<p>Of course, because &quot;name&quot; and
&quot;named&quot; were the only methods that referenced the
&quot;structure&quot; of the object, the rest of the methods
can remain the same, so &quot;speak&quot; still works as
before.</p>

<p>A horse of a different color But having all our horses
be brown would be boring. So lets add a method or two to get
and set the color.</p>

<p>## in Animal sub color { $_[0]-&gt;{Color} } sub
set_color { $_[0]-&gt;{Color} = $_[1]; }</p>

<p>Note the alternate way of accessing the arguments: $_[0]
is used in- place, rather than with a &quot;shift&quot;.
(This saves us a bit of time for something that may be
invoked frequently.) And now we can fix that color for Mr.
Ed:</p>

<p>my $horse = Horse-&gt;named(&quot;Mr. Ed&quot;);
$horse-&gt;set_color(&quot;black-and-white&quot;); print
$horse-&gt;name, &quot; is colored &quot;, $horse-&gt;color,
&quot;0;</p>

<p>which results in:</p>

<p>Mr. Ed is colored black-and-white</p>

<p>Summary So, now we have class methods, constructors,
instance methods, instance data, and even accessors. But
that s still just the beginning of what Perl has to offer.
We havent even begun to talk about accessors that double as
getters and setters, destructors, indirect object notation,
overloading, &quot;isa&quot; and &quot;can&quot; tests, the
&quot;UNIVERSAL&quot; class, and so on. Thats for the rest
of the Perl documentation to cover. Hopefully, this gets you
started, though.</p>

<p>SEE ALSO For more information, see perlobj (for all the
gritty details about Perl objects, now that youve seen the
basics), perltoot (the tutorial for those who already know
objects), perltooc (dealing with class data), perlbot (for
some more tricks), and books such as Damian Conways
excellent Object Oriented Perl.</p>

<p>Some modules which might prove interesting are
Class::Accessor, Class::Class, Class::Contract,
Class::Data::Inheritable, Class::MethodMaker and
Tie::SecureHash</p>

<p>COPYRIGHT Copyright (c) 1999, 2000 by Randal L. Schwartz
and Stonehenge Consulting Services, Inc.</p>

<p>Copyright (c) 2009 by Michael F. Witten.</p>

<p>Permission is hereby granted to distribute this document
intact with the Perl distribution, and in accordance with
the licenses of the Perl distribution; derived documents
must include this copyright notice intact.</p>

<p>Portions of this text have been derived from Perl
Training materials originally appearing in the Packages,
References, Objects, and Modules course taught by
instructors for Stonehenge Consulting Services, Inc. and
used with permission.</p>

<p>Portions of this text have been derived from materials
originally appearing in Linux Magazine and used with
permission.</p>

<p>perl v5.10.1 2009-05-14 PERLBOOT(1)</p>
<hr>
</body>
</html>
