<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLUNITUT(1) Perl Programmers Reference Guide
PERLUNITUT(1)</p>

<p>NAME perlunitut - Perl Unicode Tutorial</p>

<p>DESCRIPTION The days of just flinging strings around are
over. It s well established that modern programs need to be
capable of communicating funny accented letters, and things
like euro symbols. This means that programmers need new
habits. Its easy to program Unicode capable software, but it
does require discipline to do it right.</p>

<p>Theres a lot to know about character sets, and text
encodings. Its probably best to spend a full day learning
all this, but the basics can be learned in minutes.</p>

<p>These are not the very basics, though. It is assumed
that you already know the difference between bytes and
characters, and realise (and accept!) that there are many
different character sets and encodings, and that your
program has to be explicit about them. Recommended reading
is &quot;The Absolute Minimum Every Software Developer
Absolutely, Positively Must Know About Unicode and Character
Sets (No Excuses!)&quot; by Joel Spolsky, at
&lt;http://joelonsoftware.com/articles/Unicode.html&gt;.</p>

<p>This tutorial speaks in rather absolute terms, and
provides only a limited view of the wealth of character
string related features that Perl has to offer. For most
projects, this information will probably suffice.</p>

<p>Definitions Its important to set a few things straight
first. This is the most important part of this tutorial.
This view may conflict with other information that you may
have found on the web, but that s mostly because many
sources are wrong.</p>

<p>You may have to re-read this entire section a few
times...</p>

<p>Unicode</p>

<p>Unicode is a character set with room for lots of
characters. The ordinal value of a character is called a
code point.</p>

<p>There are many, many code points, but computers work
with bytes, and a byte can have only 256 values. Unicode has
many more characters, so you need a method to make these
accessible.</p>

<p>Unicode is encoded using several competing encodings, of
which UTF-8 is the most used. In a Unicode encoding,
multiple subsequent bytes can be used to store a single code
point, or simply: character.</p>

<p>UTF-8</p>

<p>UTF-8 is a Unicode encoding. Many people think that
Unicode and UTF-8 are the same thing, but theyre not. There
are more Unicode encodings, but much of the world has
standardized on UTF-8.</p>

<p>UTF-8 treats the first 128 codepoints, 0..127, the same
as ASCII. They take only one byte per character. All other
characters are encoded as two or more (up to six) bytes
using a complex scheme. Fortunately, Perl handles this for
us, so we dont have to worry about this.</p>

<p>Text strings (character strings)</p>

<p>Text strings, or character strings are made of
characters. Bytes are irrelevant here, and so are encodings.
Each character is just that: the character.</p>

<p>Text strings are also called Unicode strings, because in
Perl, every text string is a Unicode string.</p>

<p>On a text string, you would do things like:</p>

<p>$text =~ s/foo/bar/; if ($string =~ /^+$/) { ... } $text
= ucfirst $text; my $character_count = length $text;</p>

<p>The value of a character (&quot;ord&quot;,
&quot;chr&quot;) is the corresponding Unicode code
point.</p>

<p>Binary strings (byte strings)</p>

<p>Binary strings, or byte strings are made of bytes. Here,
you dont have characters, just bytes. All communication with
the outside world (anything outside of your current Perl
process) is done in binary.</p>

<p>On a binary string, you would do things like:</p>

<p>my (@length_content) = unpack &quot;(V/a)*&quot;,
$binary; $binary =~ s/0F/ # for the brave :) print {$fh}
$binary; my $byte_count = length $binary;</p>

<p>Encoding</p>

<p>Encoding (as a verb) is the conversion from text to
binary. To encode, you have to supply the target encoding,
for example &quot;iso-8859-1&quot; or &quot;UTF-8&quot;.
Some encodings, like the &quot;iso-8859&quot;
(&quot;latin&quot;) range, do not support the full Unicode
standard; characters that cant be represented are lost in
the conversion.</p>

<p>Decoding</p>

<p>Decoding is the conversion from binary to text. To
decode, you have to know what encoding was used during the
encoding phase. And most of all, it must be something
decodable. It doesnt make much sense to decode a PNG image
into a text string.</p>

<p>Internal format</p>

<p>Perl has an internal format, an encoding that it uses to
encode text strings so it can store them in memory. All text
strings are in this internal format. In fact, text strings
are never in any other format!</p>

<p>You shouldnt worry about what this format is, because
conversion is automatically done when you decode or
encode.</p>

<p>Your new toolkit Add to your standard heading the
following line:</p>

<p>use Encode qw(encode decode);</p>

<p>Or, if youre lazy, just:</p>

<p>use Encode;</p>

<p>I/O flow (the actual 5 minute tutorial) The typical
input/output flow of a program is:</p>

<p>1. Receive and decode 2. Process 3. Encode and
output</p>

<p>If your input is binary, and is supposed to remain
binary, you shouldnt decode it to a text string, of course.
But in all other cases, you should decode it.</p>

<p>Decoding can t happen reliably if you dont know how the
data was encoded. If you get to choose, it s a good idea to
standardize on UTF-8.</p>

<p>my $foo = decode(&rsquo;UTF-8&rsquo;, get
&rsquo;http://example.com/&rsquo;); my $bar =
decode(&rsquo;ISO-8859-1&rsquo;, readline STDIN); my $xyzzy
= decode(&rsquo;Windows-1251&rsquo;,
$cgi-&gt;param(&rsquo;foo&rsquo;));</p>

<p>Processing happens as you knew before. The only
difference is that youre now using characters instead of
bytes. That s very useful if you use things like
&quot;substr&quot;, or &quot;length&quot;.</p>

<p>Its important to realize that there are no bytes in a
text string. Of course, Perl has its internal encoding to
store the string in memory, but ignore that. If you have to
do anything with the number of bytes, its probably best to
move that part to step 3, just after youve encoded the
string. Then you know exactly how many bytes it will be in
the destination string.</p>

<p>The syntax for encoding text strings to binary strings
is as simple as decoding:</p>

<p>$body = encode(&rsquo;UTF-8&rsquo;, $body);</p>

<p>If you needed to know the length of the string in bytes,
nows the perfect time for that. Because $body is now a byte
string, &quot;length&quot; will report the number of bytes,
instead of the number of characters. The number of
characters is no longer known, because characters only exist
in text strings.</p>

<p>my $byte_count = length $body;</p>

<p>And if the protocol youre using supports a way of
letting the recipient know which character encoding you
used, please help the receiving end by using that feature!
For example, E-mail and HTTP support MIME headers, so you
can use the &quot;Content-Type&quot; header. They can also
have &quot;Content-Length&quot; to indicate the number of
bytes, which is always a good idea to supply if the number
is known.</p>

<p>&quot;Content-Type: text/plain; charset=UTF-8&quot;,
&quot;Content-Length: $byte_count&quot;</p>

<p>SUMMARY Decode everything you receive, encode everything
you send out. (If its text data.)</p>

<p>Q and A (or FAQ) After reading this document, you ought
to read perlunifaq too.</p>

<p>ACKNOWLEDGEMENTS Thanks to Johan Vromans from Squirrel
Consultancy. His UTF-8 rants during the Amsterdam Perl
Mongers meetings got me interested and determined to find
out how to use character encodings in Perl in ways that dont
break easily.</p>

<p>Thanks to Gerard Goossen from TTY. His presentation
&quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006)
inspired me to publish my thoughts and write this
tutorial.</p>

<p>Thanks to the people who asked about this kind of stuff
in several Perl IRC channels, and have constantly reminded
me that a simpler explanation was needed.</p>

<p>Thanks to the people who reviewed this document for me,
before it went public. They are: Benjamin Smith, Jan-Pieter
Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</p>

<p>AUTHOR Juerd Waalboer &lt;#####@juerd.nl&gt;</p>

<p>SEE ALSO perlunifaq, perlunicode, perluniintro,
Encode</p>

<p>perl v5.10.1 2009-02-12 PERLUNITUT(1)</p>
<hr>
</body>
</html>
