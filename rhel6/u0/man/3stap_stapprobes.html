<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:17:03 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STAPPROBES(3stap) STAPPROBES(3stap)</p>

<p>NAME stapprobes - systemtap probe points</p>

<p>DESCRIPTION The following sections enumerate the variety
of probe points supported by the systemtap translator, and
additional aliases defined by standard tapset scripts.</p>

<p>The general probe point syntax is a dotted-symbol
sequence. This allows a breakdown of the event namespace
into parts, somewhat like the Domain Name System does on the
Internet. Each component identifier may be parametrized by a
string or number literal, with a syntax like a function
call. A component may include a &quot;*&quot; character, to
expand to a set of matching probe points. Probe aliases
likewise expand to other probe points. Each and every
resulting probe point is normally resolved to some low-level
system instrumentation facility (e.g., a kprobe address,
marker, or a timer configuration), otherwise the elabo-
ration phase will fail.</p>

<p>However, a probe point may be followed by a
&quot;?&quot; character, to indicate that it is optional,
and that no error should result if it fails to resolve.
Optionalness passes down through all levels of
alias/wildcard expansion. Alternately, a probe point may be
followed by a &quot;!&quot; charac- ter, to indicate that it
is both optional and sufficient. (Think vaguely of the
Prolog cut operator.) If it does resolve, then no fur- ther
probe points in the same comma-separated list will be
resolved. Therefore, the &quot;!&quot; sufficiency mark only
makes sense in a list of probe point alternatives.</p>

<p>Additionally, a probe point may be followed by a
&quot;if (expr)&quot; statement, in order to enable/disable
the probe point on-the-fly. With the &quot;if&quot;
statement, if the &quot;expr&quot; is false when the probe
point is hit, the whole probe body including aliass body is
skipped. The condition is stacked up through all levels of
alias/wildcard expansion. So the final condition becomes the
logical-and of conditions of all expanded
alias/wildcard.</p>

<p>These are all syntactically valid probe points. (They
are generally semantically invalid, depending on the
contents of the tapsets, and the versions of kernel/user
software installed.)</p>

<p>kernel.function(&quot;foo&quot;).return
process(&quot;/bin/vi&quot;).statement(0x2222) end syscall.*
kernel.function(&quot;no_such_function&quot;) ?
module(&quot;awol&quot;).function(&quot;no_such_function&quot;)
! signal.*? if (switch) kprobe.function(&quot;foo&quot;)</p>

<p>Probes may be broadly classified into
&quot;synchronous&quot; and &quot;asynchronous&quot;. A
&quot;synchronous&quot; event is deemed to occur when any
processor executes an instruction matched by the
specification. This gives these probes a reference point
(instruction address) from which more contextual data may be
available. Other families of probe points refer to
&quot;asyn- chronous&quot; events such as timers/counters
rolling over, where there is no fixed reference point that
is related. Each probe point specifica- tion may match
multiple locations (for example, using wildcards or
aliases), and all them are then probed. A probe declaration
may also contain several comma-separated specifications, all
of which are probed.</p>

<p>BEGIN/END/ERROR The probe points begin and end are
defined by the translator to refer to the time of session
startup and shutdown. All &quot;begin&quot; probe han- dlers
are run, in some sequence, during the startup of the
session. All global variables will have been initialized
prior to this point. All &quot;end&quot; probes are run, in
some sequence, during the normal shutdown of a session, such
as in the aftermath of an exit () function call, or an
interruption from the user. In the case of an
error-triggered shut- down, &quot;end&quot; probes are not
run. There are no target variables avail- able in either
context.</p>

<p>If the order of execution among &quot;begin&quot; or
&quot;end&quot; probes is significant, then an optional
sequence number may be provided:</p>

<p>begin(N) end(N)</p>

<p>The number N may be positive or negative. The probe
handlers are run in increasing order, and the order between
handlers with the same se- quence number is unspecified.
When &quot;begin&quot; or &quot;end&quot; are given without
a sequence, they are effectively sequence zero.</p>

<p>The error probe point is similar to the end probe,
except that each such probe handler run when the session
ends after errors have oc- curred. In such cases,
&quot;end&quot; probes are skipped, but each
&quot;error&quot; probe is still attempted. This kind of
probe can be used to clean up or emit a &quot;final
gasp&quot;. It may also be numerically parametrized to set a
sequence.</p>

<p>NEVER The probe point never is specially defined by the
translator to mean &quot;never&quot;. Its probe handler is
never run, though its statements are an- alyzed for symbol /
type correctness as usual. This probe point may be useful in
conjunction with optional probes.</p>

<p>SYSCALL The syscall.* aliases define several hundred
probes, too many to sum- marize here. They are:</p>

<p>syscall.NAME syscall.NAME.return</p>

<p>Generally, two probes are defined for each normal system
call as listed in the syscalls(2) manual page, one for entry
and one for return. Those system calls that never return do
not have a corresponding .re- turn probe.</p>

<p>Each probe alias defines a variety of variables. Looking
at the tapset source code is the most reliable way.
Generally, each variable listed in the standard manual page
is made available as a script-level vari- able, so
syscall.open exposes filename, flags, and mode. In addition,
a standard suite of variables is available at most
aliases:</p>

<p>argstr A pretty-printed form of the entire argument
list, without parentheses.</p>

<p>name The name of the system call.</p>

<p>retstr For return probes, a pretty-printed form of the
system-call re- sult.</p>

<p>Not all probe aliases obey all of these general
guidelines. Please re- port any bothersome ones you
encounter as a bug.</p>

<p>TIMERS Intervals defined by the standard kernel
&quot;jiffies&quot; timer may be used to trigger probe
handlers asynchronously. Two probe point variants are
supported by the translator:</p>

<p>timer.jiffies(N) timer.jiffies(N).randomize(M)</p>

<p>The probe handler is run every N jiffies (a
kernel-defined unit of time, typically between 1 and 60 ms).
If the &quot;randomize&quot; component is given, a linearly
distributed random value in the range [-M..+M] is added to N
every time the handler is run. N is restricted to a reason-
able range (1 to around a million), and M is restricted to
be smaller than N. There are no target variables provided in
either context. It is possible for such probes to be run
concurrently on a multi-processor computer.</p>

<p>Alternatively, intervals may be specified in units of
time. There are two probe point variants similar to the
jiffies timer:</p>

<p>timer.ms(N) timer.ms(N).randomize(M)</p>

<p>Here, N and M are specified in milliseconds, but the
full options for units are seconds (s/sec), milliseconds
(ms/msec), microseconds (us/usec), nanoseconds (ns/nsec),
and hertz (hz). Randomization is not supported for hertz
timers.</p>

<p>The actual resolution of the timers depends on the
target kernel. For kernels prior to 2.6.17, timers are
limited to jiffies resolution, so intervals are rounded up
to the nearest jiffies interval. After 2.6.17, the
implementation uses hrtimers for tighter precision, though
the actual resolution will be arch-dependent. In either
case, if the &quot;randomize&quot; component is given, then
the random value will be added to the interval before any
rounding occurs.</p>

<p>Profiling timers are also available to provide probes
that execute on all CPUs at the rate of the system tick
(CONFIG_HZ). This probe takes no parameters.</p>

<p>timer.profile</p>

<p>Full context information of the interrupted process is
available, mak- ing this probe suitable for a time-based
sampling profiler.</p>

<p>DWARF This family of probe points uses symbolic
debugging information for the target kernel/module/program,
as may be found in unstripped executa- bles, or the separate
debuginfo packages. They allow placement of probes logically
into the execution path of the target program, by specifying
a set of points in the source or object code. When a match-
ing statement executes on any processor, the probe handler
is run in that context.</p>

<p>Points in a kernel, which are identified by module,
source file, line number, function name, or some combination
of these.</p>

<p>Here is a list of probe point families currently
supported. The .func- tion variant places a probe near the
beginning of the named function, so that parameters are
available as context variables. The .return variant places a
probe at the moment after the return from the named
function, so the return value is available as the
&quot;$return&quot; context variable. The .inline modifier
for .function filters the results to include only instances
of inlined functions. The .call modifier se- lects the
opposite subset. Inline functions do not have an identifi-
able return point, so .return is not supported on .inline
probes. The .statement variant places a probe at the exact
spot, exposing those lo- cal variables that are visible
there.</p>

<p>kernel.function(PATTERN) kernel.function(PATTERN).call
kernel.function(PATTERN).return
kernel.function(PATTERN).inline
kernel.function(PATTERN).label(LPATTERN)
module(MPATTERN).function(PATTERN)
module(MPATTERN).function(PATTERN).call
module(MPATTERN).function(PATTERN).return
module(MPATTERN).function(PATTERN).inline
kernel.statement(PATTERN) kernel.statement(ADDRESS).absolute
module(MPATTERN).statement(PATTERN)</p>

<p>In the above list, MPATTERN stands for a string literal
that aims to identify the loaded kernel module of interest
and LPATTERN stands for a source program label. Both
MPATTERN and LPATTERN may include the &quot;*&quot;
&quot;[]&quot;, and &quot;?&quot; wildcards. PATTERN stands
for a string literal that aims to identify a point in the
program. It is made up of three parts:</p>

<p>&middot; The first part is the name of a function, as
would appear in the nm programs output. This part may use
the &quot;*&quot; and &quot;?&quot; wildcarding operators to
match multiple names.</p>

<p>&middot; The second part is optional and begins with the
&quot;@&quot; character. It is followed by the path to the
source file containing the function, which may include a
wildcard pattern, such as mm/slab*. If it does not match as
is, an implicit &quot;*/&quot; is optionally added before
the pattern, so that a script need only name the last few
components of a possibly long source directory path.</p>

<p>&middot; Finally, the third part is optional if the file
name part was giv- en, and identifies the line number in the
source file preceded by a &quot;:&quot; or a &quot;+&quot;.
The line number is assumed to be an absolute line number if
preceded by a &quot;:&quot;, or relative to the entry of the
func- tion if preceded by a &quot;+&quot;. All the lines in
the function can be matched with &quot;:*&quot;. A range of
lines x through y can be matched with &quot;:x-y&quot;.</p>

<p>As an alternative, PATTERN may be a numeric constant,
indicating an ad- dress. Such an address may be found from
symbol tables of the appro- priate kernel / module object
file. It is verified against known statement code
boundaries, and will be relocated for use at run time.</p>

<p>In guru mode only, absolute kernel-space addresses may
be specified with the &quot;.absolute&quot; suffix. Such an
address is considered already re- located, as if it came
from /proc/kallsyms, so it cannot be checked against
statement/instruction boundaries.</p>

<p>Some of the source-level context variables, such as
function parame- ters, locals, globals visible in the
compilation unit, may be visible to probe handlers. They may
refer to these variables by prefixing their name with
&quot;$&quot; within the scripts. In addition, a special
syntax allows limited traversal of structures, pointers, and
arrays.</p>

<p>$var refers to an in-scope variable &quot;var&quot;. If
its an integer-like type, it will be cast to a 64-bit int
for systemtap script use. String-like pointers (char *) may
be copied to systemtap string values using the kernel_string
or user_string functions.</p>

<p>$var-&gt;field traversal via a structure s or a pointers
field. This generalized indirection operator may be repeated
to follow more levels. Note that the . operator is not used
for plain struc- ture members, only -&gt; for both purposes.
(This is because &quot;.&quot; is reserved for string
concatenation.)</p>

<p>$return is available in return probes only for functions
that are de- clared with a return value.</p>

<p>$var[N] indexes into an array. The index is given with a
literal number.</p>

<p>$$vars expands to a character string that is equivalent
to sprintf(&quot;parm1=%x ... parmN=%x var1=%x ...
varN=%x&quot;, parm1, ..., parmN, var1, ..., varN)</p>

<p>$$locals expands to a subset of $$vars for only local
variables.</p>

<p>$$parms expands to a subset of $$vars for only function
parame- ters.</p>

<p>$$return is available in return probes only. It expands
to a string that is equivalent to
sprintf(&quot;return=%x&quot;, $re- turn) if the probed
function has a return value, or else an empty string.</p>

<p>For &quot;.return&quot; probes, context variables other
than the &quot;$return&quot; value itself are only available
for the function call parame- ters. The expressions evaluate
to the entry-time values of those variables, since that is
when a snapshot is taken. Other local variables are not
generally accessible, since by the time a
&quot;.return&quot; probe hits, the probed function will
have already returned.</p>

<p>DWARFLESS In absence of debugging information, entry
&amp; exit points of ker- nel &amp; module functions can be
probed using the &quot;kprobe&quot; family of probes.
However, these do not permit looking up the argu- ments /
local variables of the function. Following constructs are
supported : kprobe.function(FUNCTION)
kprobe.function(FUNCTION).return
kprobe.module(NAME).function(FUNCTION)
kprobe.module(NAME).function(FUNCTION).return
kprobe.statement.(ADDRESS).absolute</p>

<p>Probes of type function are recommended for kernel
functions, whereas probes of type module are recommended for
probing func- tions of the specified module. In case the
absolute address of a kernel or module function is known,
statement probes can be utilized.</p>

<p>Note that FUNCTION and MODULE names must not contain
wildcards, or the probe will not be registered. Also,
statement probes must be run under guru-mode only.</p>

<p>USER-SPACE Support for user-space probing is available
for kernels that are configured with the utrace extensions.
See http://people.redhat.com/roland/utrace/</p>

<p>There are several forms. First, a non-symbolic probe
point: process(PID).statement(ADDRESS).absolute is analogous
to kernel.statement(ADDRESS).absolute in that both use raw
(unverified) virtual addresses and provide no $vari- ables.
The target PID parameter must identify a running pro- cess,
and ADDRESS should identify a valid instruction address. All
threads of that process will be probed.</p>

<p>Second, non-symbolic user-kernel interface events
handled by utrace may be probed: process(PID).begin
process(&quot;PATH&quot;).begin process.begin
process(PID).thread.begin
process(&quot;PATH&quot;).thread.begin process.thread.begin
process(PID).end process(&quot;PATH&quot;).end process.end
process(PID).thread.end process(&quot;PATH&quot;).thread.end
process.thread.end process(PID).syscall
process(&quot;PATH&quot;).syscall process.syscall
process(PID).syscall.return
process(&quot;PATH&quot;).syscall.return
process.syscall.return process(PID).insn
process(&quot;PATH&quot;).insn process(PID).insn.block
process(&quot;PATH&quot;).insn.block</p>

<p>A .begin probe gets called when new process described by
PID or PATH gets created. A .thread.begin probe gets called
when a new thread described by PID or PATH gets created. A
.end probe gets called when process described by PID or PATH
dies. A .thread.end probe gets called when a thread
described by PID or PATH dies. A .syscall probe gets called
when a thread described by PID or PATH makes a system call.
The system call number is available in the $syscall context
variable, and the first 6 ar- guments of the system call are
available in the $argN (ex. $arg1, $arg2, ...) context
variable. A .syscall.return probe gets called when a thread
described by PID or PATH returns from a system call. The
system call number is available in the $syscall context
variable, and the return value of the system call is
available in the $return context variable. A .insn probe
gets called for every single-stepped instruction of the
process described by PID or PATH. A .insn.block probe gets
called for every block-stepped instruction of the process
de- scribed by PID or PATH.</p>

<p>Third, symbolic static instrumentation compiled into
programs and shared libraries may be probed:
process(&quot;PATH&quot;).mark(&quot;LABEL&quot;)</p>

<p>A .mark probe gets called via a static probe which is
defined in the application by
STAP_PROBE1(handle,LABEL,arg1), which is de- fined in sdt.h.
The handle is an application handle, LABEL cor- responds to
the .mark argument, and arg1 is the argument. STAP_PROBE1 is
used for probes with 1 argument, STAP_PROBE2 is used for
probes with 2 arguments, and so on. The arguments of the
probe are available in the context variables $arg1, $arg2,
... An alternative to using the STAP_PROBE macros is to use
the dtrace script to create custom macros.</p>

<p>Finally, full symbolic source-level probes in user-space
pro- grams and shared libraries are supported. These are
exactly analogous to the symbolic DWARF-based kernel/module
probes de- scribed above, and expose similar contextual
$-variables.
process(&quot;PATH&quot;).function(&quot;NAME&quot;)
process(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
process(&quot;PATH&quot;).function(&quot;*&quot;).return
process(&quot;PATH&quot;).function(&quot;myfun&quot;).label(&quot;foo&quot;)</p>

<p>Note that for all process probes, PATH names refer to
executa- bles that are searched the same way shells do:
relative to the working directory if they contain a
&quot;/&quot; character, otherwise in $PATH. If a process
probe is specified without a PID or PATH, all user threads
are probed. PATH may sometimes name a shared library in
which case all processes that map that shared library may be
probed. However, if systemtap was invoked with the -c or -x
options, then process probes are restricted to the process
hierarchy associated with the target process.</p>

<p>PROCFS These probe points allow procfs &quot;files&quot;
in /proc/systemtap/MOD- NAME to be created, read and written
(MODNAME is the name of the systemtap module). The proc
filesystem is a pseudo-filesystem which is used an an
interface to kernel data structures. There are several probe
point variants supported by the translator:</p>

<p>procfs(&quot;PATH&quot;).read
procfs(&quot;PATH&quot;).read.maxsize(MAXSIZE)
procfs(&quot;PATH&quot;).write procfs.read
procfs.read.maxsize(MAXSIZE) procfs.write</p>

<p>PATH is the file name (relative to
/proc/systemtap/MODNAME) to be created. If no PATH is
specified (as in the last two vari- ants above), PATH
defaults to &quot;command&quot;.</p>

<p>When a user reads /proc/systemtap/MODNAME/PATH, the
correspond- ing procfs read probe is triggered. The string
data to be read should be assigned to a variable named
$value, like this:</p>

<p>procfs(&quot;PATH&quot;).read { $value = &quot;1000
}</p>

<p>When a user writes into /proc/systemtap/MODNAME/PATH,
the corre- sponding procfs write probe is triggered. The
data the user wrote is available in the string variable
named $value, like this:</p>

<p>procfs(&quot;PATH&quot;).write { printf(&quot;user
wrote: %s&quot;, $value) }</p>

<p>MAXSIZE is the size of the procfs read buffer.
Specifying MAX- SIZE allows larger procfs output. If no
MAXSIZE is specified, the procfs read buffer defaults to
STP_PROCFS_BUFSIZE (which de- faults to MAXSTRINGLEN, the
maximum length of a string). If setting the procfs read
buffers for more than one file is need- ed, it may be
easiest to override the STP_PROCFS_BUFSIZE defini- tion.
Heres an example of using MAXSIZE:</p>

<p>procfs.read.maxsize(1024) { $value = &quot;long
string...&quot; $value .= &quot;another long string...&quot;
$value .= &quot;another long string...&quot; $value .=
&quot;another long string...&quot; }</p>

<p>MARKERS This family of probe points hooks up to static
probing markers inserted into the kernel or modules. These
markers are special macro calls inserted by kernel
developers to make probing faster and more reliable than
with DWARF-based probes. Further, DWARF debugging
information is not required to probe markers.</p>

<p>Marker probe points begin with kernel. The next part
names the marker itself: mark(&quot;name&quot;). The marker
name string, which may contain the usual wildcard
characters, is matched against the names given to the marker
macros when the kernel and/or module was compiled.
Optionally, you can specify format(&quot;format&quot;).
Specifying the marker format string allows differentiation
be- tween two markers with the same name but different
marker format strings.</p>

<p>The handler associated with a marker-based probe may
read the optional parameters specified at the macro call
site. These are named $arg1 through $argNN, where NN is the
number of parameters supplied by the macro. Number and
string parameters are passed in a type-safe manner.</p>

<p>The marker format string associated with a marker is
available in $format. And also the marker name string is
available in $name.</p>

<p>TRACEPOINTS This family of probe points hooks up to
static probing trace- points inserted into the kernel or
modules. As with markers, these tracepoints are special
macro calls inserted by kernel de- velopers to make probing
faster and more reliable than with DWARF-based probes, and
DWARF debugging information is not re- quired to probe
tracepoints. Tracepoints have an extra advan- tage of more
strongly-typed parameters than markers.</p>

<p>Tracepoint probes begin with kernel. The next part names
the tracepoint itself: trace(&quot;name&quot;). The
tracepoint name string, which may contain the usual wildcard
characters, is matched against the names defined by the
kernel developers in the trace- point header files.</p>

<p>The handler associated with a tracepoint-based probe may
read the optional parameters specified at the macro call
site. These are named according to the declaration by the
tracepoint author. For example, the tracepoint probe
kernel.trace(&quot;sched_switch&quot;) provides the
parameters $rq, $prev, and $next. If the parameter is a
complex type, as in a struct pointer, then a script can ac-
cess fields with the same syntax as DWARF $target variables.
Also, tracepoint parameters cannot be modified, but in
guru-mode a script may modify fields of parameters.</p>

<p>The name of the tracepoint is available in $$name, and a
string of name=value pairs for all parameters of the
tracepoint is available in $$vars or $$parms.</p>

<p>HARDWARE BREAKPOINTS This family of probes is used to
set hardware watchpoints for a given (global) kernel symbol.
The probes take three components as in- puts :</p>

<p>1. The virtualaddress/name of the kernel symbol to be
traced is supplied as argument to this class of probes. (
Probes for only data segment variables are supported.
Probing local variables of a function cannot be done.)</p>

<p>2. Nature of access to be probed : a. .write probe gets
trig- gered when a write happens at the specified
address/symbol name. b. rw probe is triggered when either a
read or write happens.</p>

<p>3. .length (optional) Users have the option of
specifying the address interval to be probed using
&quot;length&quot; constructs. The us- er-specified length
gets approximated to the closest possible address length
that the architecture can support. If the speci- fied length
exceeds the limits imposed by architecture, an error message
is flagged and probe registration fails. Wherever length is
not specified, the translator requests a hardware breakpoint
probe of length 1. It should be noted that the
&quot;length&quot; construct is not valid with symbol
names.</p>

<p>Following constructs are supported : probe
kernel.data(ADDRESS).write probe kernel.data(ADDRESS).rw
probe kernel.data(ADDRESS).length(LEN).write probe
kernel.data(ADDRESS).length(LEN).rw probe
kernel.data(&quot;SYMBOL_NAME&quot;).write probe
kernel.data(&quot;SYMBOL_NAME&quot;).rw</p>

<p>This set of probes make use of the debug registers of
the pro- cessor, which is a scarce resource. (4 on x86 , 1
on powerpc ) The script translation flags a warning if a
user requests more hardware breakpoint probes than the
limits set by architecture. For example,a pass-2 warning is
flashed when an input script re- quests 5 hardware
breakpoint probes on an x86 system while x86 architecture
supports a maximum of 4 breakpoints. Users are cautioned to
set probes judiciously.</p>

<p>EXAMPLES Here are some example probe points, defining
the associated events.</p>

<p>begin, end, end refers to the startup and normal
shutdown of the session. In this case, the handler would run
once during startup and twice during shutdown.</p>

<p>timer.jiffies(1000).randomize(200) refers to a periodic
interrupt, every 1000 +/- 200 jiffies.</p>

<p>kernel.function(&quot;*init*&quot;),
kernel.function(&quot;*exit*&quot;) refers to all kernel
functions with &quot;init&quot; or &quot;exit&quot; in the
name.</p>

<p>kernel.function(&quot;*@kernel/sched.c:240&quot;) refers
to any functions within the &quot;kernel/sched.c&quot; file
that span line 240.</p>

<p>kernel.mark(&quot;getuid&quot;) refers to an
STAP_MARK(getuid, ...) macro call in the kernel.</p>


<p>module(&quot;usb*&quot;).function(&quot;*sync*&quot;).return
refers to the moment of return from all functions with
&quot;sync&quot; in the name in any of the USB drivers.</p>

<p>kernel.statement(0xc0044852) refers to the first byte of
the statement whose compiled instructions include the given
address in the kernel.</p>

<p>kernel.statement(&quot;*@kernel/sched.c:2917&quot;)
refers to the statement of line 2917 within &quot;ker-
nel/sched.c&quot;.</p>

<p>kernel.statement(&quot;bio_init@fs/bio.c+3&quot;) refers
to the statement at line bio_init+3 within
&quot;fs/bio.c&quot;.</p>

<p>kernel.data(&quot;pid_max&quot;).write refers to a
hardware preakpoint of type &quot;write&quot; set on
pid_max</p>

<p>syscall.*.return refers to the group of probe aliases
with any name in the third position</p>

<p>PERF This prototype family of probe points interfaces to
the kernel &quot;perf event&quot; infrasture for controlling
hardware performance counters. The events being attached to
are described by the &quot;type&quot;, &quot;config&quot;
fields of the perf_event_attr structure, and are sampled at
an interval governed by the &quot;sample_period&quot;
field.</p>

<p>These fields are made available to systemtap scripts
using the following syntax: probe
perf.type(NN).config(MM).sample(XX) probe
perf.type(NN).config(MM) The range of valid type/config is
described by the perf_event_open(2) system call, and/or the
linux/perf_event.h file. Invalid combinations or exhausted
hardware counter re- sources result in errors during
systemtap script startup. Sys- temtap does not sanity-check
the values: it merely passes them through to the kernel for
error- and safety-checking.</p>

<p>SEE ALSO stap(1), tapset::iosched(3stap),
tapset::netdev(3stap), tapset::nfs(3stap),
tapset::nfsd(3stap), tapset::page- fault(3stap),
tapset::process(3stap), tapset::rpc(3stap),
tapset::scsi(3stap), tapset::signal(3stap), tapset::sock-
et(3stap), tapset::tcp(3stap), tapset::udp(3stap),
proc(3stap)</p>

<p>Red Hat 2010-06-29 STAPPROBES(3stap)</p>
<hr>
</body>
</html>
