<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLFAQ4(1) Perl Programmers Reference Guide
PERLFAQ4(1)</p>

<p>NAME perlfaq4 - Data Manipulation</p>

<p>DESCRIPTION This section of the FAQ answers questions
related to manipulating numbers, dates, strings, arrays,
hashes, and miscellaneous data issues.</p>

<p>Data: Numbers Why am I getting long decimals (eg,
19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)? Internally, your computer represents
floating-point numbers in binary. Digital (as in powers of
two) computers cannot store all numbers exactly. Some real
numbers lose precision in the process. This is a problem
with how computers store numbers and affects all computer
languages, not just Perl.</p>

<p>perlnumber shows the gory details of number
representations and conversions.</p>

<p>To limit the number of decimal places in your numbers,
you can use the printf or sprintf function. See the
&quot;Floating Point Arithmetic&quot; for more details.</p>

<p>printf &quot;%.2f&quot;, 10/3;</p>

<p>my $number = sprintf &quot;%.2f&quot;, 10/3;</p>

<p>Why is int() broken? Your &quot;int()&quot; is most
probably working just fine. Its the numbers that arent quite
what you think.</p>

<p>First, see the answer to &quot;Why am I getting long
decimals (eg, 19.9499999999999) instead of the numbers I
should be getting (eg, 19.95)?&quot;.</p>

<p>For example, this</p>

<p>print int(0.6/0.2-2), &quot;0;</p>

<p>will in most computers print 0, not 1, because even such
simple numbers as 0.6 and 0.2 cannot be presented exactly by
floating-point numbers. What you think in the above as three
is really more like 2.9999999999999995559.</p>

<p>Why ist my octal data interpreted correctly?
(contributed by brian d foy)</p>

<p>You re probably trying to convert a string to a number,
which Perl only converts as a decimal number. When Perl
converts a string to a number, it ignores leading spaces and
zeroes, then assumes the rest of the digits are in base
10:</p>

<p>my $string = &rsquo;0644&rsquo;;</p>

<p>print $string + 0; # prints 644</p>

<p>print $string + 44; # prints 688, certainly not
octal!</p>

<p>This problem usually involves one of the Perl built-ins
that has the same name a unix command that uses octal
numbers as arguments on the command line. In this example,
&quot;chmod&quot; on the command line knows that its first
argument is octal because thats what it does:</p>

<p>%prompt&gt; chmod 644 file</p>

<p>If you want to use the same literal digits (644) in
Perl, you have to tell Perl to treat them as octal numbers
either by prefixing the digits with a 0 or using
&quot;oct&quot;:</p>

<p>chmod( 0644, $file); # right, has leading zero chmod(
oct(644), $file ); # also correct</p>

<p>The problem comes in when you take your numbers from
something that Perl thinks is a string, such as a command
line argument in @ARGV:</p>

<p>chmod( $ARGV[0], $file); # wrong, even if
&quot;0644&quot;</p>

<p>chmod( oct($ARGV[0]), $file ); # correct, treat string
as octal</p>

<p>You can always check the value youre using by printing
it in octal notation to ensure it matches what you think it
should be. Print it in octal and decimal format:</p>

<p>printf &quot;0%o %d&quot;, $number, $number;</p>

<p>Does Perl have a round() function? What about ceil() and
floor()? Trig functions? Remember that &quot;int()&quot;
merely truncates toward 0. For rounding to a certain number
of digits, &quot;sprintf()&quot; or &quot;printf()&quot; is
usually the easiest route.</p>

<p>printf(&quot;%.3f&quot;, 3.1415926535); # prints
3.142</p>

<p>The &quot;POSIX&quot; module (part of the standard Perl
distribution) implements &quot;ceil()&quot;,
&quot;floor()&quot;, and a number of other mathematical and
trigonometric functions.</p>

<p>use POSIX; $ceil = ceil(3.5); # 4 $floor = floor(3.5); #
3</p>

<p>In 5.000 to 5.003 perls, trigonometry was done in the
&quot;Math::Complex&quot; module. With 5.004, the
&quot;Math::Trig&quot; module (part of the standard Perl
distribution) implements the trigonometric functions.
Internally it uses the &quot;Math::Complex&quot; module and
some functions can break out from the real axis into the
complex plane, for example the inverse sine of 2.</p>

<p>Rounding in financial applications can have serious
implications, and the rounding method used should be
specified precisely. In these cases, it probably pays not to
trust whichever system rounding is being used by Perl, but
to instead implement the rounding function you need
yourself.</p>

<p>To see why, notice how you ll still have an issue on
half-way-point alternation:</p>

<p>for ($i = 0; $i &lt; 1.01; $i += 0.05) { printf
&quot;%.1f &quot;,$i}</p>

<p>0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7
0.7 0.8 0.8 0.9 0.9 1.0 1.0</p>

<p>Dont blame Perl. Its the same as in C. IEEE says we have
to do this. Perl numbers whose absolute values are integers
under 2**31 (on 32 bit machines) will work pretty much like
mathematical integers. Other numbers are not guaranteed.</p>

<p>How do I convert between numeric
representations/bases/radixes? As always with Perl there is
more than one way to do it. Below are a few examples of
approaches to making common conversions between number
representations. This is intended to be representational
rather than exhaustive.</p>

<p>Some of the examples later in perlfaq4 use the
&quot;Bit::Vector&quot; module from CPAN. The reason you
might choose &quot;Bit::Vector&quot; over the perl built in
functions is that it works with numbers of ANY size, that it
is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.</p>

<p>How do I convert hexadecimal into decimal Using perls
built in conversion of &quot;0x&quot; notation:</p>

<p>$dec = 0xDEADBEEF;</p>

<p>Using the &quot;hex&quot; function:</p>

<p>$dec = hex(&quot;DEADBEEF&quot;);</p>

<p>Using &quot;pack&quot;:</p>

<p>$dec = unpack(&quot;N&quot;, pack(&quot;H8&quot;,
substr(&quot;0&quot; x 8 . &quot;DEADBEEF&quot;, -8)));</p>

<p>Using the CPAN module &quot;Bit::Vector&quot;:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new_Hex(32,
&quot;DEADBEEF&quot;); $dec = $vec-&gt;to_Dec();</p>

<p>How do I convert from decimal to hexadecimal Using
&quot;sprintf&quot;:</p>

<p>$hex = sprintf(&quot;%X&quot;, 3735928559); # upper case
A-F $hex = sprintf(&quot;%x&quot;, 3735928559); # lower case
a-f</p>

<p>Using &quot;unpack&quot;:</p>

<p>$hex = unpack(&quot;H*&quot;, pack(&quot;N&quot;,
3735928559));</p>

<p>Using &quot;Bit::Vector&quot;:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new_Dec(32,
-559038737); $hex = $vec-&gt;to_Hex();</p>

<p>And &quot;Bit::Vector&quot; supports odd bit counts:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new_Dec(33,
3735928559); $vec-&gt;Resize(32); # suppress leading 0 if
unwanted $hex = $vec-&gt;to_Hex();</p>

<p>How do I convert from octal to decimal Using Perl s
built in conversion of numbers with leading zeros:</p>

<p>$dec = 033653337357; # note the leading 0!</p>

<p>Using the &quot;oct&quot; function:</p>

<p>$dec = oct(&quot;33653337357&quot;);</p>

<p>Using &quot;Bit::Vector&quot;:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new(32);
$vec-&gt;Chunk_List_Store(3, split(//, reverse
&quot;33653337357&quot;)); $dec = $vec-&gt;to_Dec();</p>

<p>How do I convert from decimal to octal Using
&quot;sprintf&quot;:</p>

<p>$oct = sprintf(&quot;%o&quot;, 3735928559);</p>

<p>Using &quot;Bit::Vector&quot;:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new_Dec(32,
-559038737); $oct = reverse join(&rsquo;&rsquo;,
$vec-&gt;Chunk_List_Read(3));</p>

<p>How do I convert from binary to decimal Perl 5.6 lets
you write binary numbers directly with the &quot;0b&quot;
notation:</p>

<p>$number = 0b10110110;</p>

<p>Using &quot;oct&quot;:</p>

<p>my $input = &quot;10110110&quot;; $decimal = oct(
&quot;0b$input&quot; );</p>

<p>Using &quot;pack&quot; and &quot;ord&quot;:</p>

<p>$decimal = ord(pack(&rsquo;B8&rsquo;,
&rsquo;10110110&rsquo;));</p>

<p>Using &quot;pack&quot; and &quot;unpack&quot; for larger
strings:</p>

<p>$int = unpack(&quot;N&quot;, pack(&quot;B32&quot;,
substr(&quot;0&quot; x 32 .
&quot;11110101011011011111011101111&quot;, -32))); $dec =
sprintf(&quot;%d&quot;, $int);</p>

<p># substr() is used to left pad a 32 character string
with zeros.</p>

<p>Using &quot;Bit::Vector&quot;:</p>

<p>$vec = Bit::Vector-&gt;new_Bin(32,
&quot;11011110101011011011111011101111&quot;); $dec =
$vec-&gt;to_Dec();</p>

<p>How do I convert from decimal to binary Using
&quot;sprintf&quot; (perl 5.6+):</p>

<p>$bin = sprintf(&quot;%b&quot;, 3735928559);</p>

<p>Using &quot;unpack&quot;:</p>

<p>$bin = unpack(&quot;B*&quot;, pack(&quot;N&quot;,
3735928559));</p>

<p>Using &quot;Bit::Vector&quot;:</p>

<p>use Bit::Vector; $vec = Bit::Vector-&gt;new_Dec(32,
-559038737); $bin = $vec-&gt;to_Bin();</p>

<p>The remaining transformations (e.g. hex -&gt; oct, bin
-&gt; hex, etc.) are left as an exercise to the inclined
reader.</p>

<p>Why doest &amp; work the way I want it to? The behavior
of binary arithmetic operators depends on whether theyre
used on numbers or strings. The operators treat a string as
a series of bits and work with that (the string
&quot;3&quot; is the bit pattern 00110011). The operators
work with the binary form of a number (the number 3 is
treated as the bit pattern 00000011).</p>

<p>So, saying &quot;11 &amp; 3&quot; performs the
&quot;and&quot; operation on numbers (yielding 3). Saying
&quot;11&quot; &amp; &quot;3&quot; performs the
&quot;and&quot; operation on strings (yielding
&quot;1&quot;).</p>

<p>Most problems with &quot;&amp;&quot; and &quot;|&quot;
arise because the programmer thinks they have a number but
really its a string. The rest arise because the programmer
says:</p>

<p>if (&quot; 20 20&quot; &amp; &quot;101101&quot;) { # ...
}</p>

<p>but a string consisting of two null bytes (the result of
&quot; 20 20&quot; &amp; &quot;101101&quot;) is not a false
value in Perl. You need:</p>

<p>if ( (&quot; 20 20&quot; &amp; &quot;101101&quot;) !~
/[^ 00]/) { # ... }</p>

<p>How do I multiply matrices? Use the Math::Matrix or
Math::MatrixReal modules (available from CPAN) or the PDL
extension (also available from CPAN).</p>

<p>How do I perform an operation on a series of integers?
To call a function on each element in an array, and collect
the results, use:</p>

<p>@results = map { my_func($_) } @array;</p>

<p>For example:</p>

<p>@triple = map { 3 * $_ } @single;</p>

<p>To call a function on each element of an array, but
ignore the results:</p>

<p>foreach $iterator (@array) { some_func($iterator); }</p>

<p>To call a function on each integer in a (small) range,
you can use:</p>

<p>@results = map { some_func($_) } (5 .. 25);</p>

<p>but you should be aware that the &quot;..&quot; operator
creates an array of all integers in the range. This can take
a lot of memory for large ranges. Instead use:</p>

<p>@results = (); for ($i=5; $i &lt; 500_005; $i++) {
push(@results, some_func($i)); }</p>

<p>This situation has been fixed in Perl5.005. Use of
&quot;..&quot; in a &quot;for&quot; loop will iterate over
the range, without creating the entire range.</p>

<p>for my $i (5 .. 500_005) { push(@results,
some_func($i)); }</p>

<p>will not create a list of 500,000 integers.</p>

<p>How can I output Roman numerals? Get the
http://www.cpan.org/modules/by-module/Roman module.</p>

<p>Why aret my random numbers random? If you re using a
version of Perl before 5.004, you must call
&quot;srand&quot; once at the start of your program to seed
the random number generator.</p>

<p>BEGIN { srand() if $] &lt; 5.004 }</p>

<p>5.004 and later automatically call &quot;srand&quot; at
the beginning. Dont call &quot;srand&quot; more than
once--you make your numbers less random, rather than
more.</p>

<p>Computers are good at being predictable and bad at being
random (despite appearances caused by bugs in your programs
:-). see the random article in the &quot;Far More Than You
Ever Wanted To Know&quot; collection in
http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy of
Tom Phoenix, talks more about this. John von Neumann said,
&quot;Anyone who attempts to generate random numbers by
deterministic means is, of course, living in a state of
sin.&quot;</p>

<p>If you want numbers that are more random than
&quot;rand&quot; with &quot;srand&quot; provides, you should
also check out the &quot;Math::TrulyRandom&quot; module from
CPAN. It uses the imperfections in your systems timer to
generate random numbers, but this takes quite a while. If
you want a better pseudorandom generator than comes with
your operating system, look at &quot;Numerical Recipes in
C&quot; at http://www.nr.com/ .</p>

<p>How do I get a random number between X and Y? To get a
random number between two values, you can use the
&quot;rand()&quot; built-in to get a random number between 0
and 1. From there, you shift that into the range that you
want.</p>

<p>&quot;rand($x)&quot; returns a number such that &quot;0
&lt;= rand($x) &lt; $x&quot;. Thus what you want to have
perl figure out is a random number in the range from 0 to
the difference between your X and Y.</p>

<p>That is, to get a number between 10 and 15, inclusive,
you want a random number between 0 and 5 that you can then
add to 10.</p>

<p>my $number = 10 + int rand( 15-10+1 ); # (
10,11,12,13,14, or 15 )</p>

<p>Hence you derive the following simple function to
abstract that. It selects a random integer between the two
given integers (inclusive), For example:
&quot;random_int_between(50,120)&quot;.</p>

<p>sub random_int_between { my($min, $max) = @_; # Assumes
that the two arguments are integers themselves! return $min
if $min == $max; ($min, $max) = ($max, $min) if $min &gt;
$max; return $min + int rand(1 + $max - $min); }</p>

<p>Data: Dates How do I find the day or week of the year?
The localtime function returns the day of the year. Without
an argument localtime uses the current time.</p>

<p>$day_of_year = (localtime)[7];</p>

<p>The &quot;POSIX&quot; module can also format a date as
the day of the year or week of the year.</p>

<p>use POSIX qw/strftime/; my $day_of_year = strftime
&quot;%j&quot;, localtime; my $week_of_year = strftime
&quot;%W&quot;, localtime;</p>

<p>To get the day of year for any date, use
&quot;POSIX&quot;s &quot;mktime&quot; to get a time in epoch
seconds for the argument to localtime.</p>

<p>use POSIX qw/mktime strftime/; my $week_of_year =
strftime &quot;%W&quot;, localtime( mktime( 0, 0, 0, 18, 11,
87 ) );</p>

<p>The &quot;Date::Calc&quot; module provides two functions
to calculate these.</p>

<p>use Date::Calc; my $day_of_year = Day_of_Year( 1987, 12,
18 ); my $week_of_year = Week_of_Year( 1987, 12, 18 );</p>

<p>How do I find the current century or millennium? Use the
following simple functions:</p>

<p>sub get_century { return int((((localtime(shift ||
time))[5] + 1999))/100); }</p>

<p>sub get_millennium { return 1+int((((localtime(shift ||
time))[5] + 1899))/1000); }</p>

<p>On some systems, the &quot;POSIX&quot; modules
&quot;strftime()&quot; function has been extended in a
non-standard way to use a %C format, which they sometimes
claim is the &quot;century&quot;. It isn t, because on most
such systems, this is only the first two digits of the
four-digit year, and thus cannot be used to reliably
determine the current century or millennium.</p>

<p>How can I compare two dates and find the difference?
(contributed by brian d foy)</p>

<p>You could just store all your dates as a number and then
subtract. Life isnt always that simple though. If you want
to work with formatted dates, the &quot;Date::Manip&quot;,
&quot;Date::Calc&quot;, or &quot;DateTime&quot; modules can
help you.</p>

<p>How can I take a string and turn it into epoch seconds?
If its a regular enough string that it always has the same
format, you can split it up and pass the parts to
&quot;timelocal&quot; in the standard
&quot;Time::Local&quot; module. Otherwise, you should look
into the &quot;Date::Calc&quot; and &quot;Date::Manip&quot;
modules from CPAN.</p>

<p>How can I find the Julian Day? (contributed by brian d
foy and Dave Cross)</p>

<p>You can use the &quot;Time::JulianDay&quot; module
available on CPAN. Ensure that you really want to find a
Julian day, though, as many people have different ideas
about Julian days. See
http://www.hermetic.ch/cal_stud/jdn.htm for instance.</p>

<p>You can also try the &quot;DateTime&quot; module, which
can convert a date/time to a Julian Day.</p>

<p>$ perl -MDateTime -le&rsquo;print
DateTime-&gt;today-&gt;jd&rsquo; 2453401.5</p>

<p>Or the modified Julian Day</p>

<p>$ perl -MDateTime -le&rsquo;print
DateTime-&gt;today-&gt;mjd&rsquo; 53401</p>

<p>Or even the day of the year (which is what some people
think of as a Julian day)</p>

<p>$ perl -MDateTime -le&rsquo;print
DateTime-&gt;today-&gt;doy&rsquo; 31</p>

<p>How do I find yesterdas date? (contributed by brian d
foy)</p>

<p>Use one of the Date modules. The &quot;DateTime&quot;
module makes it simple, and give you the same time of day,
only the day before.</p>

<p>use DateTime;</p>

<p>my $yesterday = DateTime-&gt;now-&gt;subtract( days
=&gt; 1 );</p>

<p>print &quot;Yesterday was $yesterday0;</p>

<p>You can also use the &quot;Date::Calc&quot; module using
its &quot;Today_and_Now&quot; function.</p>

<p>use Date::Calc qw( Today_and_Now Add_Delta_DHMS );</p>

<p>my @date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0,
0, 0 );</p>

<p>print &quot;@date_time0;</p>

<p>Most people try to use the time rather than the calendar
to figure out dates, but that assumes that days are
twenty-four hours each. For most people, there are two days
a year when they aren t: the switch to and from summer time
throws this off. Let the modules do the work.</p>

<p>If you absolutely must do it yourself (or cant use one
of the modules), here s a solution using
&quot;Time::Local&quot;, which comes with Perl:</p>

<p># contributed by Gunnar Hjalmarsson use Time::Local; my
$today = timelocal 0, 0, 12, ( localtime )[3..5]; my ($d,
$m, $y) = ( localtime $today-86400 )[3..5]; printf
&quot;Yesterday: %d-%02d-%02d0, $y+1900, $m+1, $d;</p>

<p>In this case, you measure the day starting at noon, and
subtract 24 hours. Even if the length of the calendar day is
23 or 25 hours, youll still end up on the previous calendar
day, although not at noon. Since you dont care about the
time, the one hour difference doesnt matter and you end up
with the previous date.</p>

<p>Does Perl have a Year 2000 problem? Is Perl Y2K
compliant? Short answer: No, Perl does not have a Year 2000
problem. Yes, Perl is Y2K compliant (whatever that means).
The programmers youve hired to use it, however, probably are
not.</p>

<p>Long answer: The question belies a true understanding of
the issue. Perl is just as Y2K compliant as your pencil--no
more, and no less. Can you use your pencil to write a
non-Y2K-compliant memo? Of course you can. Is that the
pencils fault? Of course it isnt.</p>

<p>The date and time functions supplied with Perl (gmtime
and localtime) supply adequate information to determine the
year well beyond 2000 (2038 is when trouble strikes for
32-bit machines). The year returned by these functions when
used in a list context is the year minus 1900. For years
between 1910 and 1999 this happens to be a 2-digit decimal
number. To avoid the year 2000 problem simply do not treat
the year as a 2-digit number. It isnt.</p>

<p>When gmtime() and localtime() are used in scalar context
they return a timestamp string that contains a
fully-expanded year. For example, &quot;$timestamp =
gmtime(1005613200)&quot; sets $timestamp to &quot;Tue Nov 13
01:00:00 2001&quot;. Theres no year 2000 problem here.</p>

<p>That doesnt mean that Perl cant be used to create
non-Y2K compliant programs. It can. But so can your pencil.
Its the fault of the user, not the language. At the risk of
inflaming the NRA: &quot;Perl doesn t break Y2K, people
do.&quot; See http://www.perl.org/about/y2k.html for a
longer exposition.</p>

<p>Data: Strings How do I validate input? (contributed by
brian d foy)</p>

<p>There are many ways to ensure that values are what you
expect or want to accept. Besides the specific examples that
we cover in the perlfaq, you can also look at the modules
with &quot;Assert&quot; and &quot;Validate&quot; in their
names, along with other modules such as
&quot;Regexp::Common&quot;.</p>

<p>Some modules have validation for particular types of
input, such as &quot;Business::ISBN&quot;,
&quot;Business::CreditCard&quot;, &quot;Email::Valid&quot;,
and &quot;Data::Validate::IP&quot;.</p>

<p>How do I unescape a string? It depends just what you
mean by &quot;escape&quot;. URL escapes are dealt with in
perlfaq9. Shell escapes with the backslash (&quot; removed
with</p>

<p>s/\(.)/$1/g;</p>

<p>This wont expand &quot;0 or &quot;&quot; or any other
special escapes.</p>

<p>How do I remove consecutive pairs of characters?
(contributed by brian d foy)</p>

<p>You can use the substitution operator to find pairs of
characters (or runs of characters) and replace them with a
single instance. In this substitution, we find a character
in &quot;(.)&quot;. The memory parentheses store the matched
character in the back-reference &quot;1&quot; and we use
that to require that the same thing immediately follow it.
We replace that part of the string with the character in
$1.</p>

<p>s/(.)1/$1/g;</p>

<p>We can also use the transliteration operator,
&quot;tr///&quot;. In this example, the search list side of
our &quot;tr///&quot; contains nothing, but the
&quot;c&quot; option complements that so it contains
everything. The replacement list also contains nothing, so
the transliteration is almost a no-op since it wont do any
replacements (or more exactly, replace the character with
itself). However, the &quot;s&quot; option squashes
duplicated and consecutive characters in the string so a
character does not show up next to itself</p>

<p>my $str = &rsquo;Haarlem&rsquo;; # in the Netherlands
$str =~ tr///cs; # Now Harlem, like in New York</p>

<p>How do I expand function calls in a string? (contributed
by brian d foy)</p>

<p>This is documented in perlref, and although its not the
easiest thing to read, it does work. In each of these
examples, we call the function inside the braces used to
dereference a reference. If we have more than one return
value, we can construct and dereference an anonymous array.
In this case, we call the function in list context.</p>

<p>print &quot;The time values are @{ [localtime] }.0;</p>

<p>If we want to call the function in scalar context, we
have to do a bit more work. We can really have any code we
like inside the braces, so we simply have to end with the
scalar reference, although how you do that is up to you, and
you can use code inside the braces. Note that the use of
parens creates a list context, so we need &quot;scalar&quot;
to force the scalar context on the function:</p>

<p>print &quot;The time is ${&sect;alar localtime)}.0</p>

<p>print &quot;The time is ${ my $x = localtime; }.0;</p>

<p>If your function already returns a reference, you don t
need to create the reference yourself.</p>

<p>sub timestamp { my $t = localtime; }</p>

<p>print &quot;The time is ${ timestamp() }.0;</p>

<p>The &quot;Interpolation&quot; module can also do a lot
of magic for you. You can specify a variable name, in this
case &quot;E&quot;, to set up a tied hash that does the
interpolation for you. It has several other methods to do
this as well.</p>

<p>use Interpolation E =&gt; &rsquo;eval&rsquo;; print
&quot;The time values are $E{localtime()}.0;</p>

<p>In most cases, it is probably easier to simply use
string concatenation, which also forces scalar context.</p>

<p>print &quot;The time is &quot; . localtime() .
&quot;.0;</p>

<p>How do I find matching/nesting anything? This isnt
something that can be done in one regular expression, no
matter how complicated. To find something between two single
characters, a pattern like &quot;/x([^x]*)x/&quot; will get
the intervening bits in $1. For multiple ones, then
something more like &quot;/alpha(.*?)omega/&quot; would be
needed. But none of these deals with nested patterns. For
balanced expressions using &quot;(&quot;, &quot;{&quot;,
&quot;[&quot; or &quot;&lt;&quot; as delimiters, use the
CPAN module Regexp::Common, or see &quot;(??{ code })&quot;
in perlre. For other cases, youll have to write a
parser.</p>

<p>If you are serious about writing a parser, there are a
number of modules or oddities that will make your life a lot
easier. There are the CPAN modules
&quot;Parse::RecDescent&quot;, &quot;Parse::Yapp&quot;, and
&quot;Text::Balanced&quot;; and the &quot;byacc&quot;
program. Starting from perl 5.8 the
&quot;Text::Balanced&quot; is part of the standard
distribution.</p>

<p>One simple destructive, inside-out approach that you
might try is to pull out the smallest nesting parts one at a
time:</p>

<p>while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) { # do
something with $1 }</p>

<p>A more complicated and sneaky approach is to make Perls
regular expression engine do it for you. This is courtesy
Dean Inada, and rather has the nature of an Obfuscated Perl
Contest entry, but it really does work:</p>

<p># $_ contains the string to parse # BEGIN and END are
the opening and closing markers for the # nested text.</p>

<p>@( = (&rsquo;(&rsquo;,&rsquo;&rsquo;); @) =
(&rsquo;)&rsquo;,&rsquo;&rsquo;);
($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]Q$1$2]/gs; @$ =
(eval{/$re/},$@!~/unmatched/i); print
join(&quot;0,@$[0..$#$]) if( $$[-1] );</p>

<p>How do I reverse a string? Use &quot;reverse()&quot; in
scalar context, as documented in &quot;reverse&quot; in
perlfunc.</p>

<p>$reversed = reverse $string;</p>

<p>How do I expand tabs in a string? You can do it
yourself:</p>

<p>1 while $string =~ s/+/&rsquo; &rsquo; x (length($&amp;)
* 8 - length($&lsquo;) % 8)/e;</p>

<p>Or you can just use the &quot;Text::Tabs&quot; module
(part of the standard Perl distribution).</p>

<p>use Text::Tabs; @expanded_lines =
expand(@lines_with_tabs);</p>

<p>How do I reformat a paragraph? Use
&quot;Text::Wrap&quot; (part of the standard Perl
distribution):</p>

<p>use Text::Wrap; print wrap(&quot;&quot;, &rsquo;
&rsquo;, @paragraphs);</p>

<p>The paragraphs you give to &quot;Text::Wrap&quot; should
not contain embedded newlines. &quot;Text::Wrap&quot; doesn
t justify the lines (flush-right).</p>

<p>Or use the CPAN module &quot;Text::Autoformat&quot;.
Formatting files can be easily done by making a shell alias,
like so:</p>

<p>alias fmt=&quot;perl -i -MText::Autoformat -n0777 -e
&rsquo;print autoformat $_, {all=&gt;1}&rsquo; $*&quot;</p>

<p>See the documentation for &quot;Text::Autoformat&quot;
to appreciate its many capabilities.</p>

<p>How can I access or change N characters of a string? You
can access the first characters of a string with substr().
To get the first character, for example, start at position 0
and grab the string of length 1.</p>

<p>$string = &quot;Just another Perl Hacker&quot;;
$first_char = substr( $string, 0, 1 ); # &rsquo;J&rsquo;</p>

<p>To change part of a string, you can use the optional
fourth argument which is the replacement string.</p>

<p>substr( $string, 13, 4, &quot;Perl 5.8.0&quot; );</p>

<p>You can also use substr() as an lvalue.</p>

<p>substr( $string, 13, 4 ) = &quot;Perl 5.8.0&quot;;</p>

<p>How do I change the Nth occurrence of something? You
have to keep track of N yourself. For example, lets say you
want to change the fifth occurrence of &quot;whoever&quot;
or &quot;whomever&quot; into &quot;whosoever&quot; or
&quot;whomsoever&quot;, case insensitively. These all assume
that $_ contains the string to be altered.</p>

<p>$count = 0; s{((whom?)ever)}{ ++$count == 5 # is it the
5th? ? &quot;${2}soever&quot; # yes, swap : $1 # renege and
leave it there }ige;</p>

<p>In the more general case, you can use the &quot;/g&quot;
modifier in a &quot;while&quot; loop, keeping count of
matches.</p>

<p>$WANT = 3; $count = 0; $_ = &quot;One fish two fish red
fish blue fish&quot;; while (/(96 if (++$count == $WANT) {
print &quot;The third fish is a $1 one.0; } }</p>

<p>That prints out: &quot;The third fish is a red
one.&quot; You can also use a repetition count and repeated
pattern like this:</p>

<p>/(?:216</p>

<p>How can I count the number of occurrences of a substring
within a string? There are a number of ways, with varying
efficiency. If you want a count of a certain single
character (X) within a string, you can use the
&quot;tr///&quot; function like so:</p>

<p>$string =
&quot;ThisXlineXhasXsomeXx&rsquo;sXinXit&quot;; $count =
($string =~ tr/X//); print &quot;There are $count X
characters in the string&quot;;</p>

<p>This is fine if you are just looking for a single
character. However, if you are trying to count multiple
character substrings within a larger string,
&quot;tr///&quot; wont work. What you can do is wrap a
while() loop around a global pattern match. For example, let
s count negative integers:</p>

<p>$string = &quot;-9 55 48 -2 23 -76 4 14 -44&quot;; while
($string =~ /-+/g) { $count++ } print &quot;There are $count
negative numbers in the string&quot;;</p>

<p>Another version uses a global match in list context,
then assigns the result to a scalar, producing a count of
the number of matches.</p>

<p>$count = () = $string =~ /-+/g;</p>

<p>Does Perl have a Year 2038 problem? No, all of Perls
built in date and time functions and modules will work to
about 2 billion years before and after 1970.</p>

<p>Many systems cannot count time past the year 2038. Older
versions of Perl were dependent on the system to do date
calculation and thus shared their 2038 bug.</p>

<p>How do I capitalize all the words on one line?
(contributed by brian d foy)</p>

<p>Damian Conway s Text::Autoformat handles all of the
thinking for you.</p>

<p>use Text::Autoformat; my $x = &quot;Dr. Strangelove or:
How I Learned to Stop &quot;. &quot;Worrying and Love the
Bomb&quot;;</p>

<p>print $x, &quot;0; for my $style (qw( sentence title
highlight )) { print autoformat($x, { case =&gt; $style }),
&quot;0; }</p>

<p>How do you want to capitalize those words?</p>

<p>FRED AND BARNEY&rsquo;S LODGE # all uppercase Fred And
Barney&rsquo;s Lodge # title case Fred and Barney&rsquo;s
Lodge # highlight case</p>

<p>Its not as easy a problem as it looks. How many words do
you think are in there? Wait for it... wait for it.... If
you answered 5 youre right. Perl words are groups of
&quot;792 capitalize. How is Perl supposed to know not to
capitalize that &quot;s&quot; after the apostrophe? You
could try a regular expression:</p>

<p>$string =~ s/ ( (^792 | # or ( <small><small>24 )
/U$1/xg;</small></small></p>

<p><small><small>$string =~ s/([120</small></small></p>

<p><small><small>Now, what if you dont want to capitalize
that &quot;and&quot;? Just use Text::Autoformat and get on
with the next problem. :)</small></small></p>

<p><small><small>Hoow ccannIIsspllittaa[[chharraccteer]]
ddellimmittedd sstrrinng eexcceppt wwheen innsiidee
[cchaaraactterr]?? Several modules can handle this sort of
parsing--&quot;Text::Balanced&quot;, &quot;Text::CSV&quot;,
&quot;Text::CSV_XS&quot;, and &quot;Text::ParseWords&quot;,
among others.</small></small></p>

<p><small><small>Take the example case of trying to split a
string that is comma- separated into its different fields.
You can t use &quot;split(/,/)&quot; because you shouldn t
split if the comma is inside quotes. For example, take a
data line like this:</small></small></p>

<p><small><small>SAR001,&quot;&quot;,&quot;Cimetrix,
Inc&quot;,&quot;Bob
Smith&quot;,&quot;CAM&quot;,N,8,1,0,7,&quot;Error, Core
Dumped&quot;</small></small></p>

<p><small><small>Due to the restriction of the quotes, this
is a fairly complex problem. Thankfully, we have Jeffrey
Friedl, author of _ M_as_te_ri_ng R_eg_ul_ar
E_xp_re_ss_io_ns, to handle these for us. He suggests
(assuming your string is contained in
$text):</small></small></p>

<p><small><small>@new = (); push(@new, $+) while $text =~
m{ &quot;([^ | ([^,]+),? | , }gx; push(@new, undef) if
substr($text,-1,1) eq &rsquo;,&rsquo;;</small></small></p>

<p><small><small>If you want to represent quotation marks
inside a quotation-mark- delimited field, escape them with
backslashes (eg, &quot;like</small></small></p>

<p><small><small>Alternatively, the
&quot;Text::ParseWords&quot; module (part of the standard
Perl distribution) lets you say:</small></small></p>

<p><small><small>use Text::ParseWords; @new =
quotewords(&quot;,&quot;, 0, $text);</small></small></p>

<p><small><small>Hoow ddo IIsstrrippbblaankksspaaceeffroom
ttheebbegginnniingg/eenddoof aasstrrinng?? (contributed by
brian d foy)</small></small></p>

<p><small><small>A substitution can do this for you. For a
single line, you want to replace all the leading or trailing
whitespace with nothing. You can do that with a pair of
substitutions.</small></small></p>

<p><small><small>s/^/; s/;</small></small></p>

<p><small><small>You can also write that as a single
substitution, although it turns out the combined statement
is slower than the separate ones. That might not matter to
you, though.</small></small></p>

<p><small><small>s/^;</small></small></p>

<p><small><small>In this regular expression, the
alternation matches either at the beginning or the end of
the string since the anchors have a lower precedence than
the alternation. With the &quot;/g&quot; flag, the
substitution makes all possible matches, so it gets both.
Remember, the trailing newline matches the &quot; and the
&quot;$&quot; anchor can match to the physical end of the
string, so the newline disappears too. Just add the newline
to the output, which has the added benefit of preserving
&quot;blank&quot; (consisting entirely of whitespace) lines
which the &quot;^ would remove all by
itself.</small></small></p>

<p><small><small>while( &lt;&gt; ) { s/^; print &quot;$_0;
}</small></small></p>

<p><small><small>For a multi-line string, you can apply the
regular expression to each logical line in the string by
adding the &quot;/m&quot; flag (for &quot;multi-line&quot;).
With the &quot;/m&quot; flag, the &quot;$&quot; matches _
b_ef_or_ean embedded newline, so it doesnt remove it. It
still removes the newline at the end of the
string.</small></small></p>

<p><small><small>$string =~ s/^m;</small></small></p>

<p><small><small>Remember that lines consisting entirely of
whitespace will disappear, since the first part of the
alternation can match the entire string and replace it with
nothing. If need to keep embedded blank lines, you have to
do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other
whitespace.</small></small></p>

<p><small><small>$string =~
s/^[]+|[]+$//mg;</small></small></p>

<p><small><small>Hoow ddo IIppaddaasstrrinng wwitth
bblaankks oor ppaddaannummbeer wwitth zzerroees?? In the
following examples, $pad_len is the length to which you wish
to pad the string, $text or $num contains the string to be
padded, and $pad_char contains the padding character. You
can use a single character string constant instead of the
$pad_char variable if you know what it is in advance. And in
the same way you can use an integer in place of $pad_len if
you know the pad length in advance.</small></small></p>

<p><small><small>The simplest method uses the
&quot;sprintf&quot; function. It can pad on the left or
right with blanks and on the left with zeroes and it will
not truncate the result. The &quot;pack&quot; function can
only pad strings on the right with blanks and it will
truncate the result to a maximum length of
$pad_len.</small></small></p>

<p><small><small># Left padding a string with blanks (no
truncation): $padded = sprintf(&quot;%${pad_len}s&quot;,
$text); $padded = sprintf(&quot;%*s&quot;, $pad_len, $text);
# same thing</small></small></p>

<p><small><small># Right padding a string with blanks (no
truncation): $padded = sprintf(&quot;%-${pad_len}s&quot;,
$text); $padded = sprintf(&quot;%-*s&quot;, $pad_len,
$text); # same thing</small></small></p>

<p><small><small># Left padding a number with 0 (no
truncation): $padded = sprintf(&quot;%0${pad_len}d&quot;,
$num); $padded = sprintf(&quot;%0*d&quot;, $pad_len, $num);
# same thing</small></small></p>

<p><small><small># Right padding a string with blanks using
pack (will truncate): $padded =
pack(&quot;A$pad_len&quot;,$text);</small></small></p>

<p><small><small>If you need to pad with a character other
than blank or zero you can use one of the following methods.
They all generate a pad string with the &quot;x&quot;
operator and combine that with $text. These methods do not
truncate $text.</small></small></p>

<p><small><small>Left and right padding with any character,
creating a new string:</small></small></p>

<p><small><small>$padded = $pad_char x ( $pad_len - length(
$text ) ) . $text; $padded = $text . $pad_char x ( $pad_len
- length( $text ) );</small></small></p>

<p><small><small>Left and right padding with any character,
modifying $text directly:</small></small></p>

<p><small><small>substr( $text, 0, 0 ) = $pad_char x (
$pad_len - length( $text ) ); $text .= $pad_char x (
$pad_len - length( $text ) );</small></small></p>

<p><small><small>Hoow ddo IIeexttraacttsselleccteed
ccollummnssffroom aasstrrinng?? (contributed by brian d
foy)</small></small></p>

<p><small><small>If you know where the columns that contain
the data, you can use &quot;substr&quot; to extract a single
column.</small></small></p>

<p><small><small>my $column = substr( $line, $start_column,
$length );</small></small></p>

<p><small><small>You can use &quot;split&quot; if the
columns are separated by whitespace or some other delimiter,
as long as whitespace or the delimiter cannot appear as part
of the data.</small></small></p>

<p><small><small>my $line = &rsquo; fred barney betty
&rsquo;; my @columns = split /, $line; # ( &rsquo;&rsquo;,
&rsquo;fred&rsquo;, &rsquo;barney&rsquo;,
&rsquo;betty&rsquo; );</small></small></p>

<p><small><small>my $line =
&rsquo;fred||barney||betty&rsquo;; my @columns = split //,
$line; # ( &rsquo;fred&rsquo;, &rsquo;&rsquo;,
&rsquo;barney&rsquo;, &rsquo;&rsquo;, &rsquo;betty&rsquo;
);</small></small></p>

<p><small><small>If you want to work with comma-separated
values, dont do this since that format is a bit more
complicated. Use one of the modules that handle that format,
such as &quot;Text::CSV&quot;, &quot;Text::CSV_XS&quot;, or
&quot;Text::CSV_PP&quot;.</small></small></p>

<p><small><small>If you want to break apart an entire line
of fixed columns, you can use &quot;unpack&quot; with the A
(ASCII) format. by using a number after the format
specifier, you can denote the column width. See the
&quot;pack&quot; and &quot;unpack&quot; entries in perlfunc
for more details.</small></small></p>

<p><small><small>my @fields = unpack( $line, &quot;A8 A8 A8
A16 A4&quot; );</small></small></p>

<p><small><small>Note that spaces in the format argument to
&quot;unpack&quot; do not denote literal spaces. If you have
space separated data, you may want &quot;split&quot;
instead.</small></small></p>

<p><small><small>Hoow ddo IIffinnd
ttheessouunddexxvvallueeoof aasstrrinng?? (contributed by
brian d foy)</small></small></p>

<p><small><small>You can use the Text::Soundex module. If
you want to do fuzzy or close matching, you might also try
the &quot;String::Approx&quot;, and
&quot;Text::Metaphone&quot;, and
&quot;Text::DoubleMetaphone&quot;
modules.</small></small></p>

<p><small><small>Hoow ccannIIeexppannd vvarriaabllessiin
ttexxt sstrrinngss? (contributed by brian d
foy)</small></small></p>

<p><small><small>If you can avoid it, dont, or if you can
use a templating system, such as &quot;Text::Template&quot;
or &quot;Template&quot; Toolkit, do that instead. You might
even be able to get the job done with &quot;sprintf&quot; or
&quot;printf&quot;:</small></small></p>

<p><small><small>my $string = sprintf &rsquo;Say hello to
%s and %s&rsquo;, $foo, $bar;</small></small></p>

<p><small><small>However, for the one-off simple case where
I dont want to pull out a full templating system, Ill use a
string that has two Perl scalar variables in it. In this
example, I want to expand $foo and $bar to their variables
values:</small></small></p>

<p><small><small>my $foo = &rsquo;Fred&rsquo;; my $bar =
&rsquo;Barney&rsquo;; $string = &rsquo;Say hello to $foo and
$bar&rsquo;;</small></small></p>

<p><small><small>One way I can do this involves the
substitution operator and a double &quot;/e&quot; flag. The
first &quot;/e&quot; evaluates $1 on the replacement side
and turns it into $foo. The second /e starts with $foo and
replaces it with its value. $foo, then, turns into Fred, and
thats finally whats left in the string:</small></small></p>

<p><small><small>$string =~ s/(w+)/$1/eeg; # &rsquo;Say
hello to Fred and Barney&rsquo;</small></small></p>

<p><small><small>The &quot;/e&quot; will also silently
ignore violations of strict, replacing undefined variable
names with the empty string. Since Im using the
&quot;/e&quot; flag (twice even!), I have all of the same
security problems I have with &quot;eval&quot; in its string
form. If theres something odd in $foo, perhaps something
like &quot;@{[ system &quot;rm -rf /&quot; ]}&quot;, then I
could get myself in trouble.</small></small></p>

<p><small><small>To get around the security problem, I
could also pull the values from a hash instead of evaluating
variable names. Using a single &quot;/e&quot;, I can check
the hash to ensure the value exists, and if it doesn t, I
can replace the missing value with a marker, in this case
&quot;???&quot; to signal that I missed
something:</small></small></p>

<p><small><small>my $string = &rsquo;This has $foo and
$bar&rsquo;;</small></small></p>

<p><small><small>my %Replacements = ( foo =&gt;
&rsquo;Fred&rsquo;, );</small></small></p>

<p><small><small># $string =~ s/+)/$Replacements{$1}/g;
$string =~ s/+)/ exists $Replacements{$1} ?
$Replacements{$1} : &rsquo;???&rsquo;
/eg;</small></small></p>

<p><small><small>print $string;</small></small></p>

<p><small><small>Whhats wwroonggwwitth aalwwayys
qquootiingg&quot;&quot;$vvarrs&quot;&quot;? The problem is
that those double-quotes force stringification--coercing
numbers and references into strings--even when you dont want
them to be strings. Think of it this way: double-quote
expansion is used to produce new strings. If you already
have a string, why do you need more?</small></small></p>

<p><small><small>If you get used to writing odd things like
these:</small></small></p>

<p><small><small>print &quot;$var&quot;; # BAD $new =
&quot;$old&quot;; # BAD somefunc(&quot;$var&quot;); #
BAD</small></small></p>

<p><small><small>Youll be in trouble. Those should (in
99.8% of the cases) be the simpler and more
direct:</small></small></p>

<p><small><small>print $var; $new = $old;
somefunc($var);</small></small></p>

<p><small><small>Otherwise, besides slowing you down, youre
going to break code when the thing in the scalar is actually
neither a string nor a number, but a
reference:</small></small></p>

<p><small><small>func(@array); sub func { my $aref = shift;
my $oref = &quot;$aref&quot;; # WRONG }</small></small></p>

<p><small><small>You can also get into subtle problems on
those few operations in Perl that actually do care about the
difference between a string and a number, such as the
magical &quot;++&quot; autoincrement operator or the
s_ys_ca_ll_() function.</small></small></p>

<p><small><small>Stringification also destroys
arrays.</small></small></p>

<p><small><small>@lines = &lsquo;command&lsquo;; print
&quot;@lines&quot;; # WRONG - extra blanks print @lines; #
right</small></small></p>

<p><small><small>Whhy ddont mmy &lt;&lt;&lt;HHERRE
ddoccummenntsswworrk?? Check for these three
things:</small></small></p>

<p><small><small>There must be no space after the &lt;&lt;
part. There (probably) should be a semicolon at the end. You
cant (easily) have any space in front of the
tag.</small></small></p>

<p><small><small>If you want to indent the text in the here
document, you can do this:</small></small></p>

<p><small><small># all in one ($VAR = &lt;&lt;HERE_TARGET)
=~ s/^/gm; your text goes here
HERE_TARGET</small></small></p>

<p><small><small>But the HERE_TARGET must still be flush
against the margin. If you want that indented also, you ll
have to quote in the indentation.</small></small></p>

<p><small><small>($quote = &lt;&lt;&rsquo; FINIS&rsquo;) =~
s/^/gm; ...we will have peace, when you and all your works
have perished--and the works of your dark master to whom you
would deliver us. You are a liar, Saruman, and a corrupter
of men&rsquo;s hearts. --Theoden in /usr/src/perl/taint.c
FINIS $quote =~ s/-/0/;</small></small></p>

<p><small><small>A nice general-purpose fixer-upper
function for indented here documents follows. It expects to
be called with a here document as its argument. It looks to
see whether each line begins with a common substring, and if
so, strips that substring off. Otherwise, it takes the
amount of leading whitespace found on the first line and
removes that much off each subsequent
line.</small></small></p>

<p><small><small>sub fix { local $_ = shift; my ($white,
$leader); # common whitespace and common leading string if
(/^(?:([^96?:12?.*0+$/) { ($white, $leader) = ($2,
quotemeta($1)); } else { ($white, $leader) = (/^(/,
&rsquo;&rsquo;); } s/^?$leader(?:$white)?//gm; return $_;
}</small></small></p>

<p><small><small>This works with leading special strings,
dynamically determined:</small></small></p>

<p><small><small>$remember_the_main = fix&lt;&lt;&rsquo;
MAIN_INTERPRETER_LOOP&rsquo;; @@@ int @@@ runops() { @@@
SAVEI32(runlevel); @@@ runlevel++; @@@ while ( op =
(*op-&gt;op_ppaddr)() ); @@@ TAINT_NOT; @@@ return 0; @@@ }
MAIN_INTERPRETER_LOOP</small></small></p>

<p><small><small>Or with a fixed amount of leading
whitespace, with remaining indentation correctly
preserved:</small></small></p>

<p><small><small>$poem = fix&lt;&lt;EVER_ON_AND_ON; Now far
ahead the Road has gone, And I must follow, if I can,
Pursuing it with eager feet, Until it joins some larger way
Where many paths and errands meet. And whither then? I
cannot say. --Bilbo in /usr/src/perl/pp_ctl.c
EVER_ON_AND_ON</small></small></p>

<p><small><small>Daataa: AArrrayys Whhattiis
ttheeddifffeereencce bbettweeennaallisst aanddaan aarrrayy?
An array has a changeable length. A list does not. An array
is something you can push or pop, while a list is a set of
values. Some people make the distinction that a list is a
value while an array is a variable. Subroutines are passed
and return lists, you put things into list context, you
initialize arrays with lists, and you &quot;foreach()&quot;
across a list. &quot;@&quot; variables are arrays, anonymous
arrays are arrays, arrays in scalar context behave like the
number of elements in them, subroutines access their
arguments through the array @_, and
&quot;push&quot;/&quot;pop&quot;/&quot;shift&quot; only work
on arrays.</small></small></p>

<p><small><small>As a side note, theres no such thing as a
list in scalar context. When you say</small></small></p>

<p><small><small>$scalar = (2, 5, 7,
9);</small></small></p>

<p><small><small>you re using the comma operator in scalar
context, so it uses the scalar comma operator. There never
was a list there at all! This causes the last value to be
returned: 9.</small></small></p>

<p><small><small>Whhattiis ttheeddifffeereencce
bbettweeenn$$arrraay[[1]]aandd@@arrraay[[1]]? The former is
a scalar value; the latter an array slice, making it a list
with one (scalar) value. You should use $ when you want a
scalar value (most of the time) and @ when you want a list
with one scalar value in it (very, very rarely; nearly
never, in fact).</small></small></p>

<p><small><small>Sometimes it doesnt make a difference, but
sometimes it does. For example, compare:</small></small></p>

<p><small><small>$good[0] = &lsquo;some program that
outputs several lines&lsquo;;</small></small></p>

<p><small><small>with</small></small></p>

<p><small><small>@bad[0] = &lsquo;same program that outputs
several lines&lsquo;;</small></small></p>

<p><small><small>The &quot;use warnings&quot; pragma and
the - -wwflag will warn you about these
matters.</small></small></p>

<p><small><small>Hoow ccannIIrremmovve
dduppliicaateeeeleemeentts ffroom aallisst oor aarrrayy?
(contributed by brian d foy)</small></small></p>

<p><small><small>Use a hash. When you think the words
&quot;unique&quot; or &quot;duplicated&quot;, think
&quot;hash keys&quot;.</small></small></p>

<p><small><small>If you don t care about the order of the
elements, you could just create the hash then extract the
keys. Its not important how you create that hash: just that
you use &quot;keys&quot; to get the unique
elements.</small></small></p>

<p><small><small>my %hash = map { $_, 1 } @array; # or a
hash slice: @hash{ @array } = (); # or a foreach: $hash{$_}
= 1 foreach ( @array );</small></small></p>

<p><small><small>my @unique = keys
%hash;</small></small></p>

<p><small><small>If you want to use a module, try the
&quot;uniq&quot; function from &quot;List::MoreUtils&quot;.
In list context it returns the unique elements, preserving
their order in the list. In scalar context, it returns the
number of unique elements.</small></small></p>

<p><small><small>use List::MoreUtils
qw(uniq);</small></small></p>

<p><small><small>my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5,
7 ); # 1,2,3,4,5,6,7 my $unique = uniq( 1, 2, 3, 4, 4, 5, 6,
5, 7 ); # 7</small></small></p>

<p><small><small>You can also go through each element and
skip the ones you ve seen before. Use a hash to keep track.
The first time the loop sees an element, that element has no
key in %Seen. The &quot;next&quot; statement creates the key
and immediately uses its value, which is &quot;undef&quot;,
so the loop continues to the &quot;push&quot; and increments
the value for that key. The next time the loop sees that
same element, its key exists in the hash _ a_nd the value
for that key is true (since it s not 0 or
&quot;undef&quot;), so the next skips that iteration and the
loop goes to the next element.</small></small></p>

<p><small><small>my @unique = (); my %seen =
();</small></small></p>

<p><small><small>foreach my $elem ( @array ) { next if
$seen{ $elem }++; push @unique, $elem; }</small></small></p>

<p><small><small>You can write this more briefly using a
grep, which does the same thing.</small></small></p>

<p><small><small>my %seen = (); my @unique = grep { !
$seen{ $_ }++ } @array;</small></small></p>

<p><small><small>Hoow ccann II ttelll
wwheethherraaccerrtaainneeleemeenttiis cconntaainneddiin aa
liisttoor aarrrayy? (portions of this answer contributed by
Anno Siegel and brian d foy)</small></small></p>

<p><small><small>Hearing the word &quot;in&quot; is an _
i_ndicationthat you probably should have used a hash, not a
list or array, to store your data. Hashes are designed to
answer this question quickly and efficiently. Arrays
arent.</small></small></p>

<p><small><small>That being said, there are several ways to
approach this. In Perl 5.10 and later, you can use the smart
match operator to check that an item is contained in an
array or a hash:</small></small></p>

<p><small><small>use 5.010;</small></small></p>

<p><small><small>if( $item ~~ @array ) { say &quot;The
array contains $item&quot; }</small></small></p>

<p><small><small>if( $item ~~ %hash ) { say &quot;The hash
contains $item&quot; }</small></small></p>

<p><small><small>With earlier versions of Perl, you have to
do a bit more work. If you are going to make this query many
times over arbitrary string values, the fastest way is
probably to invert the original array and maintain a hash
whose keys are the first arrays values:</small></small></p>

<p><small><small>@blues = qw/azure cerulean teal turquoise
lapis-lazuli/; %is_blue = (); for (@blues) { $is_blue{$_} =
1 }</small></small></p>

<p><small><small>Now you can check whether
$is_blue{$some_color}. It might have been a good idea to
keep the blues all in a hash in the first
place.</small></small></p>

<p><small><small>If the values are all small integers, you
could use a simple indexed array. This kind of an array will
take up less space:</small></small></p>

<p><small><small>@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23,
29, 31); @is_tiny_prime = (); for (@primes) {
$is_tiny_prime[$_] = 1 } # or simply @istiny_prime[@primes]
= (1) x @primes;</small></small></p>

<p><small><small>Now you check whether
$is_tiny_prime[$some_number].</small></small></p>

<p><small><small>If the values in question are integers
instead of strings, you can save quite a lot of space by
using bit strings instead:</small></small></p>

<p><small><small>@articles = ( 1..10, 150..2000, 2017 );
undef $read; for (@articles) { vec($read,$_,1) = 1
}</small></small></p>

<p><small><small>Now check whether
&quot;vec($read,$n,1)&quot; is true for some
$n.</small></small></p>

<p><small><small>These methods guarantee fast individual
tests but require a re- organization of the original list or
array. They only pay off if you have to test multiple values
against the same array.</small></small></p>

<p><small><small>If you are testing only once, the standard
module &quot;List::Util&quot; exports the function
&quot;first&quot; for this purpose. It works by stopping
once it finds the element. Its written in C for speed, and
its Perl equivalent looks like this
subroutine:</small></small></p>

<p><small><small>sub first (&amp;@) { my $code = shift;
foreach (@_) { return $_ if &amp;{$code}(); } undef;
}</small></small></p>

<p><small><small>If speed is of little concern, the common
idiom uses grep in scalar context (which returns the number
of items that passed its condition) to traverse the entire
list. This does have the benefit of telling you how many
matches it found, though.</small></small></p>

<p><small><small>my $is_there = grep $_ eq $whatever,
@array;</small></small></p>

<p><small><small>If you want to actually extract the
matching elements, simply use grep in list
context.</small></small></p>

<p><small><small>my @matches = grep $_ eq $whatever,
@array;</small></small></p>

<p><small><small>Hoow ddo II ccommpuutee tthee
ddifffeereencce oof ttwooaarrrayys?? HHowwddo II coompputte
tthee innteerssecctiionnoof ttwooaarrrayys?? Use a hash.
Heres code to do both and more. It assumes that each element
is unique in a given array:</small></small></p>

<p><small><small>@union = @intersection = @difference = ();
%count = (); foreach $element (@array1, @array2) {
$count{$element}++ } foreach $element (keys %count) { push
@union, $element; push @{ $count{$element} &gt; 1 ?
@intersection : @difference }, $element;
}</small></small></p>

<p><small><small>Note that this is the _ s_ym_me_tr_ic
_di_ff_er_en_ce, that is, all elements in either A or in B
but not in both. Think of it as an xor
operation.</small></small></p>

<p><small><small>Hoow ddo IIttesst
wwheethherrttwooaarrrayys oor hhasshees aareeeequuall? With
Perl 5.10 and later, the smart match operator can give you
the answer with the least amount of
work:</small></small></p>

<p><small><small>use 5.010;</small></small></p>

<p><small><small>if( @array1 ~~ @array2 ) { say &quot;The
arrays are the same&quot;; }</small></small></p>

<p><small><small>if( %hash1 ~~ %hash2 ) # doesn&rsquo;t
check values! { say &quot;The hash keys are the same&quot;;
}</small></small></p>

<p><small><small>The following code works for single-level
arrays. It uses a stringwise comparison, and does not
distinguish defined versus undefined empty strings. Modify
if you have other needs.</small></small></p>

<p><small><small>$are_equal = compare_arrays(@frogs,
@toads);</small></small></p>

<p><small><small>sub compare_arrays { my ($first, $second)
= @_; no warnings; # silence spurious -w undef complaints
return 0 unless @$first == @$second; for (my $i = 0; $i &lt;
@$first; $i++) { return 0 if $first-&gt;[$i] ne
$second-&gt;[$i]; } return 1; }</small></small></p>

<p><small><small>For multilevel structures, you may wish to
use an approach more like this one. It uses the CPAN module
&quot;FreezeThaw&quot;:</small></small></p>

<p><small><small>use FreezeThaw qw(cmpStr); @a = @b = (
&quot;this&quot;, &quot;that&quot;, [ &quot;more&quot;,
&quot;stuff&quot; ] );</small></small></p>

<p><small><small>printf &quot;a and b contain %s arrays0,
cmpStr(@a, @b) == 0 ? &quot;the same&quot; :
&quot;different&quot;;</small></small></p>

<p><small><small>This approach also works for comparing
hashes. Here we ll demonstrate two different
answers:</small></small></p>

<p><small><small>use FreezeThaw qw(cmpStr
cmpStrHard);</small></small></p>

<p><small><small>%a = %b = ( &quot;this&quot; =&gt;
&quot;that&quot;, &quot;extra&quot; =&gt; [
&quot;more&quot;, &quot;stuff&quot; ] ); $a{EXTRA} = b;
$b{EXTRA} = a;</small></small></p>

<p><small><small>printf &quot;a and b contain %s hashes0,
cmpStr(a, b) == 0 ? &quot;the same&quot; :
&quot;different&quot;;</small></small></p>

<p><small><small>printf &quot;a and b contain %s hashes0,
cmpStrHard(a, b) == 0 ? &quot;the same&quot; :
&quot;different&quot;;</small></small></p>

<p><small><small>The first reports that both those the
hashes contain the same data, while the second reports that
they do not. Which you prefer is left as an exercise to the
reader.</small></small></p>

<p><small><small>Hoow ddo IIffinnd
ttheeffirrsttaarrrayyeeleemeenttfforrwwhiichhaacconndiitiionniis
trruee? To find the first array element which satisfies a
condition, you can use the &quot;first()&quot; function in
the &quot;List::Util&quot; module, which comes with Perl
5.8. This example finds the first element that contains
&quot;Perl&quot;.</small></small></p>

<p><small><small>use List::Util
qw(first);</small></small></p>

<p><small><small>my $element = first { /Perl/ }
@array;</small></small></p>

<p><small><small>If you cannot use &quot;List::Util&quot;,
you can make your own loop to do the same thing. Once you
find the element, you stop the loop with
last.</small></small></p>

<p><small><small>my $found; foreach ( @array ) { if( /Perl/
) { $found = $_; last } }</small></small></p>

<p><small><small>If you want the array index, you can
iterate through the indices and check the array element at
each index until you find one that satisfies the
condition.</small></small></p>

<p><small><small>my( $found, $index ) = ( undef, -1 ); for(
$i = 0; $i &lt; @array; $i++ ) { if( $array[$i] =~ /Perl/ )
{ $found = $array[$i]; $index = $i; last; }
}</small></small></p>

<p><small><small>Hoow ddo IIhhanndlle llinnkeed llisstss?
In general, you usually dont need a linked list in Perl,
since with regular arrays, you can push and pop or shift and
unshift at either end, or you can use splice to add and/or
remove arbitrary number of elements at arbitrary points.
Both pop and shift are O(1) operations on Perls dynamic
arrays. In the absence of shifts and pops, push in general
needs to reallocate on the order every log(N) times, and
unshift will need to copy pointers each
time.</small></small></p>

<p><small><small>If you really, really wanted, you could
use structures as described in perldsc or perltoot and do
just what the algorithm book tells you to do. For example,
imagine a list node like this:</small></small></p>

<p><small><small>$node = { VALUE =&gt; 42, LINK =&gt;
undef, };</small></small></p>

<p><small><small>You could walk the list this
way:</small></small></p>

<p><small><small>print &quot;List: &quot;; for ($node =
$head; $node; $node = $node-&gt;{LINK}) { print
$node-&gt;{VALUE}, &quot; &quot;; } print
&quot;0;</small></small></p>

<p><small><small>You could add to the list this
way:</small></small></p>

<p><small><small>my ($head, $tail); $tail = append($head,
1); # grow a new head for $value ( 2 .. 10 ) { $tail =
append($tail, $value); }</small></small></p>

<p><small><small>sub append { my($list, $value) = @_; my
$node = { VALUE =&gt; $value }; if ($list) {
$node-&gt;{LINK} = $list-&gt;{LINK}; $list-&gt;{LINK} =
$node; } else { $_[0] = $node; # replace caller&rsquo;s
version } return $node; }</small></small></p>

<p><small><small>But again, Perl s built-in are virtually
always good enough.</small></small></p>

<p><small><small>Hoow ddo IIhhanndlle ccirrcuulaar
llisstss? (contributed by brian d foy)</small></small></p>

<p><small><small>If you want to cycle through an array
endlessy, you can increment the index modulo the number of
elements in the array:</small></small></p>

<p><small><small>my @array = qw( a b c ); my $i =
0;</small></small></p>

<p><small><small>while( 1 ) { print $array[ $i++ % @array
], &quot;0; last if $i &gt; 20; }</small></small></p>

<p><small><small>You can also use &quot;Tie::Cycle&quot; to
use a scalar that always has the next element of the
circular array:</small></small></p>

<p><small><small>use Tie::Cycle;</small></small></p>

<p><small><small>tie my $cycle, &rsquo;Tie::Cycle&rsquo;, [
qw( FFFFFF 000000 FFFF00 ) ];</small></small></p>

<p><small><small>print $cycle; # FFFFFF print $cycle; #
000000 print $cycle; # FFFF00</small></small></p>

<p><small><small>The &quot;Array::Iterator::Circular&quot;
creates an iterator object for circular
arrays:</small></small></p>

<p><small><small>use
Array::Iterator::Circular;</small></small></p>

<p><small><small>my $color_iterator =
Array::Iterator::Circular-&gt;new( qw(red green blue orange)
);</small></small></p>

<p><small><small>foreach ( 1 .. 20 ) { print
$color_iterator-&gt;next, &quot;0; }</small></small></p>

<p><small><small>Hoow ddo IIsshuufffleeaan
aarrrayyrranndoomlly?? If you either have Perl 5.8.0 or
later installed, or if you have Scalar-List-Utils 1.03 or
later installed, you can say:</small></small></p>

<p><small><small>use List::Util
&rsquo;shuffle&rsquo;;</small></small></p>

<p><small><small>@shuffled =
shuffle(@list);</small></small></p>

<p><small><small>If not, you can use a Fisher-Yates
shuffle.</small></small></p>

<p><small><small>sub fisher_yates_shuffle { my $deck =
shift; # $deck is a reference to an array return unless
@$deck; # must not be empty!</small></small></p>

<p><small><small>my $i = @$deck; while (--$i) { my $j = int
rand ($i+1); @$deck[$i,$j] = @$deck[$j,$i]; }
}</small></small></p>

<p><small><small># shuffle my mpeg collection # my @mpeg =
&lt;audio/*/*.mp3&gt;; fisher_yates_shuffle( @mpeg ); #
randomize @mpeg in place print @mpeg;</small></small></p>

<p><small><small>Note that the above implementation
shuffles an array in place, unlike the
&quot;List::Util::shuffle()&quot; which takes a list and
returns a new shuffled list.</small></small></p>

<p><small><small>Youve probably seen shuffling algorithms
that work using splice, randomly picking another element to
swap the current element with</small></small></p>

<p><small><small>srand; @new = (); @old = 1 .. 10; # just a
demo while (@old) { push(@new, splice(@old, rand @old, 1));
}</small></small></p>

<p><small><small>This is bad because splice is already
O(N), and since you do it N times, you just invented a
quadratic algorithm; that is, O(N**2). This does not scale,
although Perl is so efficient that you probably wont notice
this until you have rather largish
arrays.</small></small></p>

<p><small><small>Hoow ddo IIpprooceesss/mmoddiffy eeacch
eeleemeenttoof aan aarrrayy? Use
&quot;for&quot;/&quot;foreach&quot;:</small></small></p>

<p><small><small>for (@lines) { s/foo/bar/; # change that
word tr/XZ/ZX/; # swap those letters }</small></small></p>

<p><small><small>Heres another; lets compute spherical
volumes:</small></small></p>

<p><small><small>for (@volumes = @radii) { # @volumes has
changed parts $_ **= 3; $_ *= (4/3) * 3.14159; # this will
be constant folded }</small></small></p>

<p><small><small>which can also be done with
&quot;map()&quot; which is made to transform one list into
another:</small></small></p>

<p><small><small>@volumes = map {$_ ** 3 * (4/3) * 3.14159}
@radii;</small></small></p>

<p><small><small>If you want to do the same thing to modify
the values of the hash, you can use the &quot;values&quot;
function. As of Perl 5.6 the values are not copied, so if
you modify $orbit (in this case), you modify the
value.</small></small></p>

<p><small><small>for $orbit ( values %orbits ) { ($orbit
**= 3) *= (4/3) * 3.14159; }</small></small></p>

<p><small><small>Prior to perl 5.6 &quot;values&quot;
returned copies of the values, so older perl code often
contains constructions such as @orbits{keys %orbits} instead
of &quot;values %orbits&quot; where the hash is to be
modified.</small></small></p>

<p><small><small>Hoow ddo IIssellecct aarranndoom
eeleemeenttffroom aan aarrrayy? Use the &quot;rand()&quot;
function (see &quot;rand&quot; in
perlfunc):</small></small></p>

<p><small><small>$index = rand @array; $element =
$array[$index];</small></small></p>

<p><small><small>Or, simply:</small></small></p>

<p><small><small>my $element = $array[ rand @array
];</small></small></p>

<p><small><small>Hoow ddo IIpperrmuuteeNNeeleemeentts oof
aallisst?? Use the &quot;List::Permutor&quot; module on
CPAN. If the list is actually an array, try the
&quot;Algorithm::Permute&quot; module (also on CPAN). Its
written in XS code and is very
efficient:</small></small></p>

<p><small><small>use
Algorithm::Permute;</small></small></p>

<p><small><small>my @array =
&rsquo;a&rsquo;..&rsquo;d&rsquo;; my $p_iterator =
Algorithm::Permute-&gt;new ( @array );</small></small></p>

<p><small><small>while (my @perm = $p_iterator-&gt;next) {
print &quot;next permutation: (@perm)0;
}</small></small></p>

<p><small><small>For even faster execution, you could
do:</small></small></p>

<p><small><small>use
Algorithm::Permute;</small></small></p>

<p><small><small>my @array =
&rsquo;a&rsquo;..&rsquo;d&rsquo;;</small></small></p>

<p><small><small>Algorithm::Permute::permute { print
&quot;next permutation: (@array)0; }
@array;</small></small></p>

<p><small><small>Here s a little program that generates all
permutations of all the words on each line of input. The
algorithm embodied in the &quot;permute()&quot; function is
discussed in Volume 4 (still unpublished) of Knuths _ T_he
A_rt _of _Co_mp_ut_er _Pr_og_ra_mm_in_gand will work on any
list:</small></small></p>

<p><small><small>#!/usr/bin/perl -n # Fischer-Krause
ordered permutation generator</small></small></p>

<p><small><small>sub permute (&amp;@) { my $code = shift;
my @idx = 0..$#_; while ( $code-&gt;(@_[@idx]) ) { my $p =
$#idx; --$p while $idx[$p-1] &gt; $idx[$p]; my $q = $p or
return; push @idx, reverse splice @idx, $p; ++$q while
$idx[$p-1] &gt; $idx[$q]; @idx[$p-1,$q]=@idx[$q,$p-1]; }
}</small></small></p>

<p><small><small>permute { print &quot;@_0 }
split;</small></small></p>

<p><small><small>The &quot;Algorithm::Loops&quot; module
also provides the &quot;NextPermute&quot; and
&quot;NextPermuteNum&quot; functions which efficiently find
all unique permutations of an array, even if it contains
duplicate values, modifying it in-place: if its elements are
in reverse-sorted order then the array is reversed, making
it sorted, and it returns false; otherwise the next
permutation is returned.</small></small></p>

<p><small><small>&quot;NextPermute&quot; uses string order
and &quot;NextPermuteNum&quot; numeric order, so you can
enumerate all the permutations of 0..9 like
this:</small></small></p>

<p><small><small>use Algorithm::Loops
qw(NextPermuteNum);</small></small></p>

<p><small><small>my @list= 0..9; do { print &quot;@list0 }
while NextPermuteNum @list;</small></small></p>

<p><small><small>Hoow ddo IIssorrt aan aarrrayybby
((annytthiingg)?? Supply a comparison function to _
s_or_t(_) (described in &quot;sort&quot; in
perlfunc):</small></small></p>

<p><small><small>@list = sort { $a &lt;=&gt; $b }
@list;</small></small></p>

<p><small><small>The default sort function is cmp, string
comparison, which would sort &quot;(1, 2, 10)&quot; into
&quot;(1, 10, 2)&quot;. &quot;&lt;=&gt;&quot;, used above,
is the numerical comparison operator.</small></small></p>

<p><small><small>If you have a complicated function needed
to pull out the part you want to sort on, then don t do it
inside the sort function. Pull it out first, because the
sort BLOCK can be called many times for the same element.
Here s an example of how to pull out the first word after
the first number on each item, and then sort those words
case- insensitively.</small></small></p>

<p><small><small>@idx = (); for (@data) { ($item) = /+()/;
push @idx, uc($item); } @sorted = @data[ sort { $idx[$a] cmp
$idx[$b] } 0 .. $#idx ];</small></small></p>

<p><small><small>which could also be written this way,
using a trick that s come to be known as the Schwartzian
Transform:</small></small></p>

<p><small><small>@sorted = map { $_-&gt;[0] } sort {
$a-&gt;[1] cmp $b-&gt;[1] } map { [ $_, uc( (/+()/)[0]) ] }
@data;</small></small></p>

<p><small><small>If you need to sort on several fields, the
following paradigm is useful.</small></small></p>

<p><small><small>@sorted = sort { field1($a) &lt;=&gt;
field1($b) || field2($a) cmp field2($b) || field3($a) cmp
field3($b) } @data;</small></small></p>

<p><small><small>This can be conveniently combined with
precalculation of keys as given above.</small></small></p>

<p><small><small>See the _ s_or_tarticle in the &quot;Far
More Than You Ever Wanted To Know&quot; collection in
http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for more about
this approach.</small></small></p>

<p><small><small>See also the question later in perlfaq4 on
sorting hashes.</small></small></p>

<p><small><small>Hoow ddo IImmannippullatte aarrrayys oof
bbitts?? Use &quot;pack()&quot; and &quot;unpack()&quot;, or
else &quot;vec()&quot; and the bitwise
operations.</small></small></p>

<p><small><small>For example, you dont have to store
individual bits in an array (which would mean that youre
wasting a lot of space). To convert an array of bits to a
string, use &quot;vec()&quot; to set the right bits. This
sets $vec to have bit N set only if $ints[N] was
set:</small></small></p>

<p><small><small>@ints = (...); # array of bits, e.g. ( 1,
0, 0, 1, 1, 0 ... ) $vec = &rsquo;&rsquo;; foreach( 0 ..
$#ints ) { vec($vec,$_,1) = 1 if $ints[$_];
}</small></small></p>

<p><small><small>The string $vec only takes up as many bits
as it needs. For instance, if you had 16 entries in @ints,
$vec only needs two bytes to store them (not counting the
scalar variable overhead).</small></small></p>

<p><small><small>Here s how, given a vector in $vec, you
can get those bits into your @ints
array:</small></small></p>

<p><small><small>sub bitvec_to_list { my $vec = shift; my
@ints; # Find null-byte density then select best algorithm
if ($vec =~ tr/ // / length $vec &gt; 0.95) { use integer;
my $i;</small></small></p>

<p><small><small># This method is faster with mostly
null-bytes while($vec =~ /[^ ]/g ) { $i = -9 + 8 * pos $vec;
push @ints, $i if vec($vec, ++$i, 1); push @ints, $i if
vec($vec, ++$i, 1); push @ints, $i if vec($vec, ++$i, 1);
push @ints, $i if vec($vec, ++$i, 1); push @ints, $i if
vec($vec, ++$i, 1); push @ints, $i if vec($vec, ++$i, 1);
push @ints, $i if vec($vec, ++$i, 1); push @ints, $i if
vec($vec, ++$i, 1); } } else { # This method is a fast
general algorithm use integer; my $bits = unpack
&quot;b*&quot;, $vec; push @ints, 0 if $bits =~ s/^()//
&amp;&amp; $1; push @ints, pos $bits while($bits =~ /1/g);
}</small></small></p>

<p><small><small>return @ints; }</small></small></p>

<p><small><small>This method gets faster the more sparse
the bit vector is. (Courtesy of Tim Bunce and Winfried
Koenig.)</small></small></p>

<p><small><small>You can make the while loop a lot shorter
with this suggestion from Benjamin
Goldberg:</small></small></p>

<p><small><small>while($vec =~ /[^ ]+/g ) { push @ints,
grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
}</small></small></p>

<p><small><small>Or use the CPAN module
&quot;Bit::Vector&quot;:</small></small></p>

<p><small><small>$vector =
Bit::Vector-&gt;new($num_of_bits);
$vector-&gt;Index_List_Store(@ints); @ints =
$vector-&gt;Index_List_Read();</small></small></p>

<p><small><small>&quot;Bit::Vector&quot; provides efficient
methods for bit vector, sets of small integers and &quot;big
int&quot; math.</small></small></p>

<p><small><small>Heres a more extensive illustration using
_ v_ec_():</small></small></p>

<p><small><small># vec demo $vector = &quot;f&quot;; print
&quot;Ilya&rsquo;s string \xff\x0f\xef\xfe represents the
number &quot;, unpack(&quot;N&quot;, $vector), &quot;0;
$is_set = vec($vector, 23, 1); print &quot;Its 23rd bit is
&quot;, $is_set ? &quot;set&quot; : &quot;clear&quot;,
&quot;.0; pvec($vector);</small></small></p>

<p><small><small>set_vec(1,1,1); set_vec(3,1,1);
set_vec(23,1,1);</small></small></p>

<p><small><small>set_vec(3,1,3); set_vec(3,2,3);
set_vec(3,4,3); set_vec(3,4,7); set_vec(3,8,3);
set_vec(3,8,7);</small></small></p>

<p><small><small>set_vec(0,32,17);
set_vec(1,32,17);</small></small></p>

<p><small><small>sub set_vec { my ($offset, $width, $value)
= @_; my $vector = &rsquo;&rsquo;; vec($vector, $offset,
$width) = $value; print &quot;offset=$offset width=$width
value=$value0; pvec($vector); }</small></small></p>

<p><small><small>sub pvec { my $vector = shift; my $bits =
unpack(&quot;b*&quot;, $vector); my $i = 0; my $BASE =
8;</small></small></p>

<p><small><small>print &quot;vector length in bytes:
&quot;, length($vector), &quot;0; @bytes =
unpack(&quot;A8&quot; x length($vector), $bits); print
&quot;bits are: @bytes0; }</small></small></p>

<p><small><small>Whhy ddoees _de_fi_ne_d(_)rretturrn ttruue
oon eempptyyaarrrayys aanddhhasshees?? The short story is
that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes). See
&quot;defined&quot; in perlfunc in the 5.004 release or
later of Perl for more detail.</small></small></p>

<p><small><small>Daataa: HHasshees ((Asssoociiattivve
AArrrayys)) Hoow ddo IIpprooceesssaan eenttirre hhassh??
(contributed by brian d foy)</small></small></p>

<p><small><small>There are a couple of ways that you can
process an entire hash. You can get a list of keys, then go
through each key, or grab a one key-value pair at a
time.</small></small></p>

<p><small><small>To go through all of the keys, use the
&quot;keys&quot; function. This extracts all of the keys of
the hash and gives them back to you as a list. You can then
get the value through the particular key you re
processing:</small></small></p>

<p><small><small>foreach my $key ( keys %hash ) { my $value
= $hash{$key} ... }</small></small></p>

<p><small><small>Once you have the list of keys, you can
process that list before you process the hash elements. For
instance, you can sort the keys so you can process them in
lexical order:</small></small></p>

<p><small><small>foreach my $key ( sort keys %hash ) { my
$value = $hash{$key} ... }</small></small></p>

<p><small><small>Or, you might want to only process some of
the items. If you only want to deal with the keys that start
with &quot;text:&quot;, you can select just those using
&quot;grep&quot;:</small></small></p>

<p><small><small>foreach my $key ( grep /^text:/, keys
%hash ) { my $value = $hash{$key} ... }</small></small></p>

<p><small><small>If the hash is very large, you might not
want to create a long list of keys. To save some memory, you
can grab one key-value pair at a time using
&quot;each()&quot;, which returns a pair you havent seen
yet:</small></small></p>

<p><small><small>while( my( $key, $value ) = each( %hash )
) { ... }</small></small></p>

<p><small><small>The &quot;each&quot; operator returns the
pairs in apparently random order, so if ordering matters to
you, youll have to stick with the &quot;keys&quot;
method.</small></small></p>

<p><small><small>The &quot;each()&quot; operator can be a
bit tricky though. You cant add or delete keys of the hash
while you re using it without possibly skipping or
re-processing some pairs after Perl internally rehashes all
of the elements. Additionally, a hash has only one iterator,
so if you use &quot;keys&quot;, &quot;values&quot;, or
&quot;each&quot; on the same hash, you can reset the
iterator and mess up your processing. See the
&quot;each&quot; entry in perlfunc for more
details.</small></small></p>

<p><small><small>Hoow ddo IImmerrgeettwoohhasshees??
(contributed by brian d foy)</small></small></p>

<p><small><small>Before you decide to merge two hashes, you
have to decide what to do if both hashes contain keys that
are the same and if you want to leave the original hashes as
they were.</small></small></p>

<p><small><small>If you want to preserve the original
hashes, copy one hash (%hash1) to a new hash (%new_hash),
then add the keys from the other hash (%hash2 to the new
hash. Checking that the key already exists in %new_hash
gives you a chance to decide what to do with the
duplicates:</small></small></p>

<p><small><small>my %new_hash = %hash1; # make a copy;
leave %hash1 alone</small></small></p>

<p><small><small>foreach my $key2 ( keys %hash2 ) { if(
exists $new_hash{$key2} ) { warn &quot;Key [$key2] is in
both hashes!&quot;; # handle the duplicate (perhaps only
warning) ... next; } else { $new_hash{$key2} =
$hash2{$key2}; } }</small></small></p>

<p><small><small>If you dont want to create a new hash, you
can still use this looping technique; just change the
%new_hash to %hash1.</small></small></p>

<p><small><small>foreach my $key2 ( keys %hash2 ) { if(
exists $hash1{$key2} ) { warn &quot;Key [$key2] is in both
hashes!&quot;; # handle the duplicate (perhaps only warning)
... next; } else { $hash1{$key2} = $hash2{$key2}; }
}</small></small></p>

<p><small><small>If you dont care that one hash overwrites
keys and values from the other, you could just use a hash
slice to add one hash to another. In this case, values from
%hash2 replace values from %hash1 when they have keys in
common:</small></small></p>

<p><small><small>@hash1{ keys %hash2 } = values
%hash2;</small></small></p>

<p><small><small>Whhatthhapppeenssiif II aaddd oor
rremmovve kkeyys ffroom aa hhassh wwhiilee itterrattinng
ooveer iit?? (contributed by brian d
foy)</small></small></p>

<p><small><small>The easy answer is &quot;Dont do
that!&quot;</small></small></p>

<p><small><small>If you iterate through the hash with _
e_ac_h(_),you can delete the key most recently returned
without worrying about it. If you delete or add other keys,
the iterator may skip or double up on them since perl may
rearrange the hash table. See the entry for
&quot;each()&quot; in perlfunc.</small></small></p>

<p><small><small>Hoow ddo IIlloook uup aahhassh
eeleemeenttbby vvalluee? Create a reverse
hash:</small></small></p>

<p><small><small>%by_value = reverse %by_key; $key =
$by_value{$value};</small></small></p>

<p><small><small>That s not particularly efficient. It
would be more space-efficient to use:</small></small></p>

<p><small><small>while (($key, $value) = each %by_key) {
$by_value{$value} = $key; }</small></small></p>

<p><small><small>If your hash could have repeated values,
the methods above will only find one of the associated keys.
This may or may not worry you. If it does worry you, you can
always reverse the hash into a hash of arrays
instead:</small></small></p>

<p><small><small>while (($key, $value) = each %by_key) {
push @{$key_list_by_value{$value}}, $key;
}</small></small></p>

<p><small><small>Hoow ccannIIkknoow hhowwmmanny
eenttriiessaareeiin aahhassh?? (contributed by brian d
foy)</small></small></p>

<p><small><small>This is very similar to &quot;How do I
process an entire hash?&quot;, also in perlfaq4, but a bit
simpler in the common cases.</small></small></p>

<p><small><small>You can use the &quot;keys()&quot;
built-in function in scalar context to find out have many
entries you have in a hash:</small></small></p>

<p><small><small>my $key_count = keys %hash; # must be
scalar context!</small></small></p>

<p><small><small>If you want to find out how many entries
have a defined value, thats a bit different. You have to
check each value. A &quot;grep&quot; is
handy:</small></small></p>

<p><small><small>my $defined_value_count = grep { defined }
values %hash;</small></small></p>

<p><small><small>You can use that same structure to count
the entries any way that you like. If you want the count of
the keys with vowels in them, you just test for that
instead:</small></small></p>

<p><small><small>my $vowel_count = grep { /[aeiou]/ } keys
%hash;</small></small></p>

<p><small><small>The &quot;grep&quot; in scalar context
returns the count. If you want the list of matching items,
just use it in list context instead:</small></small></p>

<p><small><small>my @defined_values = grep { defined }
values %hash;</small></small></p>

<p><small><small>The &quot;keys()&quot; function also
resets the iterator, which means that you may see strange
results if you use this between uses of other hash operators
such as &quot;each()&quot;.</small></small></p>

<p><small><small>Hoow ddo IIssorrt aahhassh
((opptiionnalllyybby vvallueeiinssteeaddoof kkeyy)??
(contributed by brian d foy)</small></small></p>

<p><small><small>To sort a hash, start with the keys. In
this example, we give the list of keys to the sort function
which then compares them ASCIIbetically (which might be
affected by your locale settings). The output list has the
keys in ASCIIbetical order. Once we have the keys, we can go
through them to create a report which lists the keys in
ASCIIbetical order.</small></small></p>

<p><small><small>my @keys = sort { $a cmp $b } keys
%hash;</small></small></p>

<p><small><small>foreach my $key ( @keys ) { printf
&quot;%-20s %6d0, $key, $hash{$key}; }</small></small></p>

<p><small><small>We could get more fancy in the
&quot;sort()&quot; block though. Instead of comparing the
keys, we can compute a value with them and use that value as
the comparison.</small></small></p>

<p><small><small>For instance, to make our report order
case-insensitive, we use the &quot;equence in a
double-quoted string to make everything lowercase. The
&quot;sort()&quot; block then compares the lowercased values
to determine in which order to put the
keys.</small></small></p>

<p><small><small>my @keys = sort { &quot;&quot; cmp
&quot;&quot; } keys %hash;</small></small></p>

<p><small><small>Note: if the computation is expensive or
the hash has many elements, you may want to look at the
Schwartzian Transform to cache the computation
results.</small></small></p>

<p><small><small>If we want to sort by the hash value
instead, we use the hash key to look it up. We still get out
a list of keys, but this time they are ordered by their
value.</small></small></p>

<p><small><small>my @keys = sort { $hash{$a} &lt;=&gt;
$hash{$b} } keys %hash;</small></small></p>

<p><small><small>From there we can get more complex. If the
hash values are the same, we can provide a secondary sort on
the hash key.</small></small></p>

<p><small><small>my @keys = sort { $hash{$a} &lt;=&gt;
$hash{$b} or &quot;&quot; cmp &quot;&quot; } keys
%hash;</small></small></p>

<p><small><small>Hoow ccannIIaalwwayys kkeeep mmy hhassh
ssorrteed?? You can look into using the &quot;DB_File&quot;
module and &quot;tie()&quot; using the $DB_BTREE hash
bindings as documented in &quot;In Memory Databases&quot; in
DB_File. The &quot;Tie::IxHash&quot; module from CPAN might
also be instructive. Although this does keep your hash
sorted, you might not like the slow down you suffer from the
tie interface. Are you sure you need to do this?
:)</small></small></p>

<p><small><small>Whhatts ttheeddifffeereencce
bbettweeenn&quot;&quot;deeleetee&quot;
aandd&quot;&quot;unndeef&quot;&quot;wwitth hhasshees??
Hashes contain pairs of scalars: the first is the key, the
second is the value. The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference. If a key $key is present in %hash,
&quot;exists($hash{$key})&quot; will return true. The value
for a given key can be &quot;undef&quot;, in which case
$hash{$key} will be &quot;undef&quot; while &quot;exists
$hash{$key}&quot; will return true. This corresponds to
($key, &quot;undef&quot;) being in the
hash.</small></small></p>

<p><small><small>Pictures help... heres the %hash
table:</small></small></p>

<p><small><small>keys values +------+------+ | a | 3 | | x
| 7 | | d | 0 | | e | 2 |
+------+------+</small></small></p>

<p><small><small>And these conditions
hold</small></small></p>

<p><small><small>$hash{&rsquo;a&rsquo;} is true
$hash{&rsquo;d&rsquo;} is false defined
$hash{&rsquo;d&rsquo;} is true defined
$hash{&rsquo;a&rsquo;} is true exists $hash{&rsquo;a&rsquo;}
is true (Perl 5 only) grep ($_ eq &rsquo;a&rsquo;, keys
%hash) is true</small></small></p>

<p><small><small>If you now say</small></small></p>

<p><small><small>undef
$hash{&rsquo;a&rsquo;}</small></small></p>

<p><small><small>your table now reads:</small></small></p>

<p><small><small>keys values +------+------+ | a | undef| |
x | 7 | | d | 0 | | e | 2 |
+------+------+</small></small></p>

<p><small><small>and these conditions now hold; changes in
caps:</small></small></p>

<p><small><small>$hash{&rsquo;a&rsquo;} is FALSE
$hash{&rsquo;d&rsquo;} is false defined
$hash{&rsquo;d&rsquo;} is true defined
$hash{&rsquo;a&rsquo;} is FALSE exists
$hash{&rsquo;a&rsquo;} is true (Perl 5 only) grep ($_ eq
&rsquo;a&rsquo;, keys %hash) is true</small></small></p>

<p><small><small>Notice the last two: you have an undef
value, but a defined key!</small></small></p>

<p><small><small>Now, consider this:</small></small></p>

<p><small><small>delete
$hash{&rsquo;a&rsquo;}</small></small></p>

<p><small><small>your table now reads:</small></small></p>

<p><small><small>keys values +------+------+ | x | 7 | | d
| 0 | | e | 2 | +------+------+</small></small></p>

<p><small><small>and these conditions now hold; changes in
caps:</small></small></p>

<p><small><small>$hash{&rsquo;a&rsquo;} is false
$hash{&rsquo;d&rsquo;} is false defined
$hash{&rsquo;d&rsquo;} is true defined
$hash{&rsquo;a&rsquo;} is false exists
$hash{&rsquo;a&rsquo;} is FALSE (Perl 5 only) grep ($_ eq
&rsquo;a&rsquo;, keys %hash) is FALSE</small></small></p>

<p><small><small>See, the whole entry is
gone!</small></small></p>

<p><small><small>Whhy ddont mmy ttieed hhasshees mmakke
ttheeddeffinnedd/eexiistts ddisstiincctiionn? This depends
on the tied hashs implementation of _ E_XI_ST_S(_). For
example, there isnt the concept of undef with hashes that
are tied to DBM* files. It also means that _ e_xi_st_s(_)and
_ d_ef_in_ed_() do the same thing with a DBM* file, and what
they end up doing is not what they do with ordinary
hashes.</small></small></p>

<p><small><small>Hoow ddo IIrressettaan _ea_ch_()
oopeeraatiionnpparrt--waay tthrrouughh? (contributed by
brian d foy)</small></small></p>

<p><small><small>You can use the &quot;keys&quot; or
&quot;values&quot; functions to reset &quot;each&quot;. To
simply reset the iterator used by &quot;each&quot; without
doing anything else, use one of them in void
context:</small></small></p>

<p><small><small>keys %hash; # resets iterator, nothing
else. values %hash; # resets iterator, nothing
else.</small></small></p>

<p><small><small>See the documentation for &quot;each&quot;
in perlfunc.</small></small></p>

<p><small><small>Hoow ccannIIggettttheeuuniiquue kkeyys
ffroom ttwoohhasshees?? First you extract the keys from the
hashes into lists, then solve the &quot;removing
duplicates&quot; problem described above. For
example:</small></small></p>

<p><small><small>%seen = (); for $element (keys(%foo),
keys(%bar)) { $seen{$element}++; } @uniq = keys
%seen;</small></small></p>

<p><small><small>Or more succinctly:</small></small></p>

<p><small><small>@uniq = keys
%{{%foo,%bar}};</small></small></p>

<p><small><small>Or if you really want to save
space:</small></small></p>

<p><small><small>%seen = (); while (defined ($key = each
%foo)) { $seen{$key}++; } while (defined ($key = each %bar))
{ $seen{$key}++; } @uniq = keys %seen;</small></small></p>

<p><small><small>Hoow
ccannIIsstooreeaammulltiidiimeenssioonaal aarrrayyiin
aaDDBMMffille?? Either stringify the structure yourself (no
fun), or else get the MLDBM (which uses Data::Dumper) module
from CPAN and layer it on top of either DB_File or
GDBM_File.</small></small></p>

<p><small><small>Hoow ccannIImmakke mmy hhassh rremmemmbeer
ttheeoordderrIIpputteeleemeentts iintto itt? Use the
&quot;Tie::IxHash&quot; from CPAN.</small></small></p>

<p><small><small>use Tie::IxHash;</small></small></p>

<p><small><small>tie my %myhash,
&rsquo;Tie::IxHash&rsquo;;</small></small></p>

<p><small><small>for (my $i=0; $i&lt;20; $i++) {
$myhash{$i} = 2*$i; }</small></small></p>

<p><small><small>my @keys = keys %myhash; # @keys =
(0,1,2,3,...)</small></small></p>

<p><small><small>Whhy ddoees ppasssiinggaassubbroouttinne
aan uunddeffinneddeeleemeenttiin aahhassh crreaateeiit??
(contributed by brian d foy)</small></small></p>

<p><small><small>Are you using a really old version of
Perl?</small></small></p>

<p><small><small>Normally, accessing a hash keys value for
a nonexistent key will _ n_ot create the
key.</small></small></p>

<p><small><small>my %hash = (); my $value = $hash{
&rsquo;foo&rsquo; }; print &quot;This won&rsquo;t print0 if
exists $hash{ &rsquo;foo&rsquo; };</small></small></p>

<p><small><small>Passing $hash{ &rsquo;foo&rsquo; } to a
subroutine used to be a special case, though. Since you
could assign directly to $_[0], Perl had to be ready to make
that assignment so it created the hash key ahead of
time:</small></small></p>

<p><small><small>my_sub( $hash{ &rsquo;foo&rsquo; } );
print &quot;This will print before 5.0040 if exists $hash{
&rsquo;foo&rsquo; };</small></small></p>

<p><small><small>sub my_sub { # $_[0] = &rsquo;bar&rsquo;;
# create hash key in case you do this 1;
}</small></small></p>

<p><small><small>Since Perl 5.004, however, this situation
is a special case and Perl creates the hash key only when
you make the assignment:</small></small></p>

<p><small><small>my_sub( $hash{ &rsquo;foo&rsquo; } );
print &quot;This will print, even after 5.0040 if exists
$hash{ &rsquo;foo&rsquo; };</small></small></p>

<p><small><small>sub my_sub { $_[0] = &rsquo;bar&rsquo;;
}</small></small></p>

<p><small><small>However, if you want the old behavior (and
think carefully about that because its a weird side effect),
you can pass a hash slice instead. Perl 5.004 didnt make
this a special case:</small></small></p>

<p><small><small>my_sub( @hash{ qw/foo/ }
);</small></small></p>

<p><small><small>Hoow ccann II mmakke tthee PPerrl
eequuivvallennt oof aaCCsstrrucctuuree/CC+++
cllasss//haashhoor aarrrayy offhhasshees oor aarrrayys??
Usually a hash ref, perhaps like this:</small></small></p>

<p><small><small>$record = { NAME =&gt; &quot;Jason&quot;,
EMPNO =&gt; 132, TITLE =&gt; &quot;deputy peon&quot;, AGE
=&gt; 23, SALARY =&gt; 37_000, PALS =&gt; [
&quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],
};</small></small></p>

<p><small><small>References are documented in perlref and
the upcoming perlreftut. Examples of complex data structures
are given in perldsc and perllol. Examples of structures and
object-oriented classes are in perltoot.</small></small></p>

<p><small><small>Hoow ccannIIuuseeaarrefferrennceeaas
aahhassh kkeyy? (contributed by brian d foy and Ben
Morrow)</small></small></p>

<p><small><small>Hash keys are strings, so you cant really
use a reference as the key. When you try to do that, perl
turns the reference into its stringified form (for instance,
&quot;HASH(0xDEADBEEF)&quot;). From there you cant get back
the reference from the stringified form, at least without
doing some extra work on your own.</small></small></p>

<p><small><small>Remember that the entry in the hash will
still be there even if the referenced variable goes out of
scope, and that it is entirely possible for Perl to
subsequently allocate a different variable at the same
address. This will mean a new variable might accidentally be
associated with the value for an old.</small></small></p>

<p><small><small>If you have Perl 5.10 or later, and you
just want to store a value against the reference for lookup
later, you can use the core Hash::Util::Fieldhash module.
This will also handle renaming the keys if you use multiple
threads (which causes all variables to be reallocated at new
addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable
goes out of scope.</small></small></p>

<p><small><small>If you actually need to be able to get a
real reference back from each hash entry, you can use the
Tie::RefHash module, which does the required work for
you.</small></small></p>

<p><small><small>Daataa: MMissc Hoow ddo IIhhanndlle
bbinnarry ddatta ccorrreecttlyy? Perl is binary clean, so it
can handle binary data just fine. On Windows or DOS,
however, you have to use &quot;binmode&quot; for binary
files to avoid conversions for line endings. In general, you
should use &quot;binmode&quot; any time you want to work
with binary data.</small></small></p>

<p><small><small>Also see &quot;binmode&quot; in perlfunc
or perlopentut.</small></small></p>

<p><small><small>If you re concerned about 8-bit textual
data then see perllocale. If you want to deal with multibyte
characters, however, there are some gotchas. See the section
on Regular Expressions.</small></small></p>

<p><small><small>Hoow ddo II ddetterrmiinee wwheethherr aa
sscaalaar iis aa nuumbberr/wwhoolee/iintteggerr/fflooatt?
Assuming that you dont care about IEEE notations like
&quot;NaN&quot; or &quot;Infinity&quot;, you probably just
want to use a regular expression.</small></small></p>

<p><small><small>if (/ if (/^+$/) { print &quot;is a whole
number0 } if (/^-?+$/) { print &quot;is an integer0 } if
(/^[+-]?+$/) { print &quot;is a +/- integer0 } if
(/^-?+.?*$/) { print &quot;is a real number0 } if
(/^-?(?:+(?:.*)?|.+)$/) { print &quot;is a decimal number0 }
if (/^([+-]?)(?=|.)*(.*)?([Ee]([+-]?+))?$/) { print &quot;a
C float0 }</small></small></p>

<p><small><small>There are also some commonly used modules
for the task. Scalar::Util (distributed with 5.8) provides
access to perls internal function
&quot;looks_like_number&quot; for determining whether a
variable looks like a number. Data::Types exports functions
that validate data types using both the above and other
regular expressions. Thirdly, there is
&quot;Regexp::Common&quot; which has regular expressions to
match various types of numbers. Those three modules are
available from the CPAN.</small></small></p>

<p><small><small>If you re on a POSIX system, Perl supports
the &quot;POSIX::strtod&quot; function. Its semantics are
somewhat cumbersome, so heres a &quot;getnum&quot; wrapper
function for more convenient access. This function takes a
string and returns the number it found, or &quot;undef&quot;
for input that isnt a C float. The &quot;is_numeric&quot;
function is a front end to &quot;getnum&quot; if you just
want to say, &quot;Is this a
float?&quot;</small></small></p>

<p><small><small>sub getnum { use POSIX qw(strtod); my $str
= shift; $str =~ s/^/; $str =~ s/; $! = 0; my($num,
$unparsed) = strtod($str); if (($str eq &rsquo;&rsquo;) ||
($unparsed != 0) || $!) { return undef; } else { return
$num; } }</small></small></p>

<p><small><small>sub is_numeric { defined getnum($_[0])
}</small></small></p>

<p><small><small>Or you could check out the String::Scanf
module on the CPAN instead. The &quot;POSIX&quot; module
(part of the standard Perl distribution) provides the
&quot;strtod&quot; and &quot;strtol&quot; for converting
strings to double and longs,
respectively.</small></small></p>

<p><small><small>Hoow ddo IIkkeeep pperrsiisttennt ddatta
aacrrosss pproogrrammccalllss? For some specific
applications, you can use one of the DBM modules. See
AnyDBM_File. More generically, you should consult the
&quot;FreezeThaw&quot; or &quot;Storable&quot; modules from
CPAN. Starting from Perl 5.8 &quot;Storable&quot; is part of
the standard distribution. Heres one example using
&quot;Storable&quot;s &quot;store&quot; and
&quot;retrieve&quot; functions:</small></small></p>

<p><small><small>use Storable; store(hash,
&quot;filename&quot;);</small></small></p>

<p><small><small># later on... $href =
retrieve(&quot;filename&quot;); # by ref %hash = %{
retrieve(&quot;filename&quot;) }; # direct to
hash</small></small></p>

<p><small><small>Hoow ddo IIppriinttoouttoor ccoppy
aarreccurrsiiveeddatta sstrrucctuuree? The
&quot;Data::Dumper&quot; module on CPAN (or the 5.005
release of Perl) is great for printing out data structures.
The &quot;Storable&quot; module on CPAN (or the 5.8 release
of Perl), provides a function called &quot;dclone&quot; that
recursively copies its argument.</small></small></p>

<p><small><small>use Storable qw(dclone); $r2 =
dclone($r1);</small></small></p>

<p><small><small>Where $r1 can be a reference to any kind
of data structure youd like. It will be deeply copied.
Because &quot;dclone&quot; takes and returns references,
youd have to add extra punctuation if you had a hash of
arrays that you wanted to copy.</small></small></p>

<p><small><small>%newhash = %{ dclone(oldhash)
};</small></small></p>

<p><small><small>Hoow ddo IIddeffinne
mmetthoodssfforreeveeryycclaasss/oobjjecct?? (contributed by
Ben Morrow)</small></small></p>

<p><small><small>You can use the &quot;UNIVERSAL&quot;
class (see UNIVERSAL). However, please be very careful to
consider the consequences of doing this: adding methods to
every object is very likely to have unintended consequences.
If possible, it would be better to have all your object
inherit from some common base class, or to use an object
system like Moose that supports roles.</small></small></p>

<p><small><small>Hoow ddo IIvverriffy aaccreediit ccarrd
ccheeckksuum?? Get the &quot;Business::CreditCard&quot;
module from CPAN.</small></small></p>

<p><small><small>Hoow ddo IIppacck aarrrayys oof
ddouubllessoor fflooatts fforrXXS ccodde?? The
arrays.h/arrays.c code in the &quot;PGPLOT&quot; module on
CPAN does just this. If youre doing a lot of float or double
processing, consider using the &quot;PDL&quot; module from
CPAN instead--it makes number-crunching
easy.</small></small></p>

<p><small><small>See
&lt;http://search.cpan.org/dist/PGPLOT&gt; for the
code.</small></small></p>

<p><small><small>REEVIISIIONN Revision:
$Revision$</small></small></p>

<p><small><small>Date: $Date$</small></small></p>

<p><small><small>See perlfaq for source control details and
availability.</small></small></p>

<p><small><small>AUUTHHORRAANDDCCOPPYRRIGGHTT Copyright (c)
1997-2009 Tom Christiansen, Nathan Torkington, and other
authors as noted. All rights reserved.</small></small></p>

<p><small><small>This documentation is free; you can
redistribute it and/or modify it under the same terms as
Perl itself.</small></small></p>

<p><small><small>Irrespective of its distribution, all code
examples in this file are hereby placed into the public
domain. You are permitted and encouraged to use this code in
your own programs for fun or for profit as you see fit. A
simple comment in the code giving credit would be courteous
but is not required.</small></small></p>

<p><small><small>perl v5.10.1 2009-08-15
PERLFAQ4(1)</small></small></p>
<hr>
</body>
</html>
