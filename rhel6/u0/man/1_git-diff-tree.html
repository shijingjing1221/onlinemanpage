<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:33 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-DIFF-TREE(1) Git Manual GIT-DIFF-TREE(1)</p>

<p>NAME git-diff-tree - Compares the content and mode of
blobs found via two tree objects</p>

<p>SYNOPSIS git diff-tree [--stdin] [-m] [-s] [-v]
[--no-commit-id] [--pretty] [-t] [-r] [-c | --cc] [--root]
[&lt;common diff options&gt;] &lt;tree-ish&gt;
[&lt;tree-ish&gt;] [&lt;path&gt;...]</p>

<p>DESCRIPTION Compares the content and mode of the blobs
found via two tree objects.</p>

<p>If there is only one &lt;tree-ish&gt; given, the commit
is compared with its parents (see --stdin below).</p>

<p>Note that git diff-tree can use the tree encapsulated in
a commit object.</p>

<p>OPTIONS -p, -u Generate patch (see section on generating
patches).</p>

<p>-U&lt;n&gt;, --unified=&lt;n&gt; Generate diffs with
&lt;n&gt; lines of context instead of the usual three.
Implies -p.</p>

<p>--raw Generate the raw format. This is the default.</p>

<p>--patch-with-raw Synonym for -p --raw.</p>

<p>--patience Generate a diff using the &quot;patience
diff&quot; algorithm.</p>

<p>--stat[=width[,name-width]] Generate a diffstat. You can
override the default output width for 80-column terminal by
--stat=width. The width of the filename part can be
controlled by giving another width to it separated by a
comma.</p>

<p>--numstat Similar to --stat, but shows number of added
and deleted lines in decimal notation and pathname without
abbreviation, to make it more machine friendly. For binary
files, outputs two - instead of saying 0 0.</p>

<p>--shortstat Output only the last line of the --stat
format containing total number of modified files, as well as
number of added and deleted lines.</p>

<p>--dirstat[=limit] Output the distribution of relative
amount of changes (number of lines added or removed) for
each sub-directory. Directories with changes below a cut-off
percent (3% by default) are not shown. The cut-off percent
can be set with --dirstat=limit. Changes in a child
directory is not counted for the parent directory, unless
--cumulative is used.</p>

<p>--dirstat-by-file[=limit] Same as --dirstat, but counts
changed files instead of lines.</p>

<p>--summary Output a condensed summary of extended header
information such as creations, renames and mode changes.</p>

<p>--patch-with-stat Synonym for -p --stat.</p>

<p>-z When --raw, --numstat, --name-only or --name-status
has been given, do not munge pathnames and use NULs as
output field terminators.</p>

<p>Without this option, each pathname output will have TAB,
LF, double quotes, and backslash characters replaced with ,
0 respectively, and the pathname will be enclosed in double
quotes if any of those replacements occurred.</p>

<p>--name-only Show only names of changed files.</p>

<p>--name-status Show only names and status of changed
files. See the description of the --diff-filter option on
what the status letters mean.</p>

<p>--submodule[=&lt;format&gt;] Chose the output format for
submodule differences. &lt;format&gt; can be one of short
and log. short just shows pairs of commit names, this format
is used when this option is not given. log is the default
value for this option and lists the commits in that commit
range like the summary option of git-submodule(1) does.</p>

<p>--color[=&lt;when&gt;] Show colored diff. The value must
be always (the default), never, or auto.</p>

<p>--no-color Turn off colored diff, even when the
configuration file gives the default to color output. Same
as --color=never.</p>

<p>--color-words[=&lt;regex&gt;] Show colored word diff,
i.e., color words which have changed. By default, words are
separated by whitespace.</p>

<p>When a &lt;regex&gt; is specified, every non-overlapping
match of the &lt;regex&gt; is considered a word. Anything
between these matches is considered whitespace and
ignored(!) for the purposes of finding differences. You may
want to append |[^[:space:]] to your regular expression to
make sure that it matches all non-whitespace characters. A
match that contains a newline is silently truncated(!) at
the newline.</p>

<p>The regex can also be set via a diff driver or
configuration option, see gitattributes(1) or git-config(1).
Giving it explicitly overrides any diff driver or
configuration setting. Diff drivers override configuration
settings.</p>

<p>--no-renames Turn off rename detection, even when the
configuration file gives the default to do so.</p>

<p>--check Warn if changes introduce trailing whitespace or
an indent that uses a space before a tab. Exits with
non-zero status if problems are found. Not compatible with
--exit-code.</p>

<p>--full-index Instead of the first handful of characters,
show the full pre- and post-image blob object names on the
&quot;index&quot; line when generating patch format
output.</p>

<p>--binary In addition to --full-index, output a binary
diff that can be applied with git-apply.</p>

<p>--abbrev[=&lt;n&gt;] Instead of showing the full 40-byte
hexadecimal object name in diff-raw format output and
diff-tree header lines, show only a partial prefix. This is
independent of the --full-index option above, which controls
the diff-patch output format. Non default number of digits
can be specified with --abbrev=&lt;n&gt;.</p>

<p>-B Break complete rewrite changes into pairs of delete
and create.</p>

<p>-M Detect renames.</p>

<p>-C Detect copies as well as renames. See also
--find-copies-harder.</p>

<p>--diff-filter=[ACDMRTUXB*] Select only files that are
Added (A), Copied (C), Deleted (D), Modified (M), Renamed
(R), have their type (i.e. regular file, symlink, submodule,
...) changed (T), are Unmerged (U), are Unknown (X), or have
had their pairing Broken (B). Any combination of the filter
characters may be used. When * (All-or-none) is added to the
combination, all paths are selected if there is any file
that matches other criteria in the comparison; if there is
no file that matches other criteria, nothing is
selected.</p>

<p>--find-copies-harder For performance reasons, by
default, -C option finds copies only if the original file of
the copy was modified in the same changeset. This flag makes
the command inspect unmodified files as candidates for the
source of copy. This is a very expensive operation for large
projects, so use it with caution. Giving more than one -C
option has the same effect.</p>

<p>-l&lt;num&gt; The -M and -C options require O(n^2)
processing time where n is the number of potential
rename/copy targets. This option prevents rename/copy
detection from running if the number of rename/copy targets
exceeds the specified number.</p>

<p>-S&lt;string&gt; Look for differences that introduce or
remove an instance of &lt;string&gt;. Note that this is
different than the string simply appearing in diff output;
see the pickaxe entry in gitdiffcore(7) for more
details.</p>

<p>--pickaxe-all When -S finds a change, show all the
changes in that changeset, not just the files that contain
the change in &lt;string&gt;.</p>

<p>--pickaxe-regex Make the &lt;string&gt; not a plain
string but an extended POSIX regex to match.</p>

<p>-O&lt;orderfile&gt; Output the patch in the order
specified in the &lt;orderfile&gt;, which has one shell glob
pattern per line.</p>

<p>-R Swap two inputs; that is, show differences from index
or on-disk file to tree contents.</p>

<p>--relative[=&lt;path&gt;] When run from a subdirectory
of the project, it can be told to exclude changes outside
the directory and show pathnames relative to it with this
option. When you are not in a subdirectory (e.g. in a bare
repository), you can name which subdirectory to make the
output relative to by giving a &lt;path&gt; as an
argument.</p>

<p>-a, --text Treat all files as text.</p>

<p>--ignore-space-at-eol Ignore changes in whitespace at
EOL.</p>

<p>-b, --ignore-space-change Ignore changes in amount of
whitespace. This ignores whitespace at line end, and
considers all other sequences of one or more whitespace
characters to be equivalent.</p>

<p>-w, --ignore-all-space Ignore whitespace when comparing
lines. This ignores differences even if one line has
whitespace where the other line has none.</p>

<p>--inter-hunk-context=&lt;lines&gt; Show the context
between diff hunks, up to the specified number of lines,
thereby fusing hunks that are close to each other.</p>

<p>--exit-code Make the program exit with codes similar to
diff(1). That is, it exits with 1 if there were differences
and 0 means no differences.</p>

<p>--quiet Disable all output of the program. Implies
--exit-code.</p>

<p>--ext-diff Allow an external diff helper to be executed.
If you set an external diff driver with gitattributes(5),
you need to use this option with git-log(1) and friends.</p>

<p>--no-ext-diff Disallow external diff drivers.</p>

<p>--ignore-submodules Ignore changes to submodules in the
diff generation.</p>

<p>--src-prefix=&lt;prefix&gt; Show the given source prefix
instead of &quot;a/&quot;.</p>

<p>--dst-prefix=&lt;prefix&gt; Show the given destination
prefix instead of &quot;b/&quot;.</p>

<p>--no-prefix Do not show any source or destination
prefix.</p>

<p>For more detailed explanation on these common options,
see also gitdiffcore(7).</p>

<p>&lt;tree-ish&gt; The id of a tree object.</p>

<p>&lt;path&gt;... If provided, the results are limited to
a subset of files matching one of these prefix strings.
i.e., file matches /^&lt;pattern1&gt;|&lt;pattern2&gt;|.../
Note that this parameter does not provide any wildcard or
regexp features.</p>

<p>-r recurse into sub-trees</p>

<p>-t show tree entry itself as well as subtrees. Implies
-r.</p>

<p>--root When --root is specified the initial commit will
be shown as a big creation event. This is equivalent to a
diff against the NULL tree.</p>

<p>--stdin When --stdin is specified, the command does not
take &lt;tree-ish&gt; arguments from the command line.
Instead, it reads lines containing either two &lt;tree&gt;,
one &lt;commit&gt;, or a list of &lt;commit&gt; from its
standard input. (Use a single space as separator.)</p>

<p>When two trees are given, it compares the first tree
with the second. When a single commit is given, it compares
the commit with its parents. The remaining commits, when
given, are used as if they are parents of the first
commit.</p>

<p>When comparing two trees, the ID of both trees
(separated by a space and terminated by a newline) is
printed before the difference. When comparing commits, the
ID of the first (or only) commit, followed by a newline, is
printed.</p>

<p>The following flags further affect the behavior when
comparing commits (but not trees).</p>

<p>-m By default, git diff-tree --stdin does not show
differences for merge commits. With this flag, it shows
differences to that commit from all of its parents. See also
-c.</p>

<p>-s By default, git diff-tree --stdin shows differences,
either in machine-readable form (without -p) or in patch
form (with -p). This output can be suppressed. It is only
useful with -v flag.</p>

<p>-v This flag causes git diff-tree --stdin to also show
the commit message before the differences.</p>

<p>--pretty[=&lt;format&gt;], --format[=&lt;format&gt;]
Pretty-print the contents of the commit logs in a given
format, where &lt;format&gt; can be one of oneline, short,
medium, full, fuller, email, raw and format:&lt;string&gt;.
When omitted, the format defaults to medium.</p>

<p>Note: you can specify the default pretty format in the
repository configuration (see git-config(1)).</p>

<p>--abbrev-commit Instead of showing the full 40-byte
hexadecimal commit object name, show only a partial prefix.
Non default number of digits can be specified with
&quot;--abbrev=&lt;n&gt;&quot; (which also modifies diff
output, if it is displayed).</p>

<p>This should make &quot;--pretty=oneline&quot; a whole
lot more readable for people using 80-column terminals.</p>

<p>--oneline This is a shorthand for &quot;--pretty=oneline
--abbrev-commit&quot; used together.</p>

<p>--encoding[=&lt;encoding&gt;] The commit objects record
the encoding used for the log message in their encoding
header; this option can be used to tell the command to
re-code the commit log message in the encoding preferred by
the user. For non plumbing commands this defaults to
UTF-8.</p>

<p>--no-notes, --show-notes[=&lt;ref&gt;] Show the notes
(see git-notes(1)) that annotate the commit, when showing
the commit log message. This is the default for git log, git
show and git whatchanged commands when there is no --pretty,
--format nor --oneline option is given on the command
line.</p>

<p>With an optional argument, add this ref to the list of
notes. The ref is taken to be in refs/notes/ if it is not
qualified.</p>

<p>--[no-]standard-notes Enable or disable populating the
notes ref list from the core.notesRef and notes.displayRef
variables (or corresponding environment overrides). Enabled
by default. See git-config(1).</p>

<p>--no-commit-id</p>

<p>git diff-tree outputs a line with the commit ID when
applicable. This flag suppressed the commit ID output.</p>

<p>-c This flag changes the way a merge commit is displayed
(which means it is useful only when the command is given one
&lt;tree-ish&gt;, or --stdin). It shows the differences from
each of the parents to the merge result simultaneously
instead of showing pairwise diff between a parent and the
result one at a time (which is what the -m option does).
Furthermore, it lists only files which were modified from
all parents.</p>

<p>--cc This flag changes the way a merge commit patch is
displayed, in a similar way to the -c option. It implies the
-c and -p options and further compresses the patch output by
omitting uninteresting hunks whose the contents in the
parents have only two variants and the merge result picks
one of them without modification. When all hunks are
uninteresting, the commit itself and the commit log message
is not shown, just like in any other &quot;empty diff&quot;
case.</p>

<p>--always Show the commit itself and the commit log
message even if the diff itself is empty.</p>

<p>PRETTY FORMATS If the commit is a merge, and if the
pretty-format is not oneline, email or raw, an additional
line is inserted before the Author: line. This line begins
with &quot;Merge: &quot; and the sha1s of ancestral commits
are printed, separated by spaces. Note that the listed
commits may not necessarily be the list of the direct parent
commits if you have limited your view of history: for
example, if you are only interested in changes related to a
certain directory or file.</p>

<p>Here are some additional details for each format:</p>

<p>&middot; oneline</p>

<p>&lt;sha1&gt; &lt;title line&gt;</p>

<p>This is designed to be as compact as possible.</p>

<p>&middot; short</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt;</p>

<p>&lt;title line&gt;</p>

<p>&middot; medium</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; Date:
&lt;author date&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; full</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; Commit:
&lt;committer&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; fuller</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; AuthorDate:
&lt;author date&gt; Commit: &lt;committer&gt; CommitDate:
&lt;committer date&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; email</p>

<p>From &lt;sha1&gt; &lt;date&gt; From: &lt;author&gt;
Date: &lt;author date&gt; Subject: [PATCH] &lt;title
line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; raw</p>

<p>The raw format shows the entire commit exactly as stored
in the commit object. Notably, the SHA1s are displayed in
full, regardless of whether --abbrev or --no-abbrev are
used, and parents information show the true parent commits,
without taking grafts nor history simplification into
account.</p>

<p>&middot; format:</p>

<p>The format: format allows you to specify which
information you want to show. It works a little bit like
printf format, with the notable exception that you get a
newline with %n instead of n.</p>

<p>E.g, format:&quot;The author of %h was %an, %ar%nThe
title was &gt;&gt;%s&lt;&lt;%n&quot; would show something
like this:</p>

<p>The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was &gt;&gt;t4119: test autocomputing -p&lt;n&gt;
for traditional diff input.&lt;&lt;</p>

<p>The placeholders are:</p>

<p>&middot; %H: commit hash</p>

<p>&middot; %h: abbreviated commit hash</p>

<p>&middot; %T: tree hash</p>

<p>&middot; %t: abbreviated tree hash</p>

<p>&middot; %P: parent hashes</p>

<p>&middot; %p: abbreviated parent hashes</p>

<p>&middot; %an: author name</p>

<p>&middot; %aN: author name (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ae: author email</p>

<p>&middot; %aE: author email (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ad: author date (format respects --date=
option)</p>

<p>&middot; %aD: author date, RFC2822 style</p>

<p>&middot; %ar: author date, relative</p>

<p>&middot; %at: author date, UNIX timestamp</p>

<p>&middot; %ai: author date, ISO 8601 format</p>

<p>&middot; %cn: committer name</p>

<p>&middot; %cN: committer name (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ce: committer email</p>

<p>&middot; %cE: committer email (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %cd: committer date</p>

<p>&middot; %cD: committer date, RFC2822 style</p>

<p>&middot; %cr: committer date, relative</p>

<p>&middot; %ct: committer date, UNIX timestamp</p>

<p>&middot; %ci: committer date, ISO 8601 format</p>

<p>&middot; %d: ref names, like the --decorate option of
git-log(1)</p>

<p>&middot; %e: encoding</p>

<p>&middot; %s: subject</p>

<p>&middot; %f: sanitized subject line, suitable for a
filename</p>

<p>&middot; %b: body</p>

<p>&middot; %N: commit notes</p>

<p>&middot; %gD: reflog selector, e.g., refs/stash@{1}</p>

<p>&middot; %gd: shortened reflog selector, e.g.,
stash@{1}</p>

<p>&middot; %gs: reflog subject</p>

<p>&middot; %Cred: switch color to red</p>

<p>&middot; %Cgreen: switch color to green</p>

<p>&middot; %Cblue: switch color to blue</p>

<p>&middot; %Creset: reset color</p>

<p>&middot; %C(...): color specification, as described in
color.branch.* config option</p>

<p>&middot; %m: left, right or boundary mark</p>

<p>&middot; %n: newline</p>

<p>&middot; %%: a raw %</p>

<p>&middot; %x00: print a byte from a hex code</p>

<p>&middot; %w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]]):
switch line wrapping, like the -w option of
git-shortlog(1).</p>

<p>Note Some placeholders may depend on other options given
to the revision traversal engine. For example, the %g*
reflog options will insert an empty string unless we are
traversing reflog entries (e.g., by git log -g). The %d
placeholder will use the &quot;short&quot; decoration format
if --decorate was not already provided on the command
line.</p>

<p>If you add a + (plus sign) after % of a placeholder, a
line-feed is inserted immediately before the expansion if
and only if the placeholder expands to a non-empty
string.</p>

<p>If you add a - (minus sign) after % of a placeholder,
line-feeds that immediately precede the expansion are
deleted if and only if the placeholder expands to an empty
string.</p>

<p>&middot; tformat:</p>

<p>The tformat: format works exactly like format:, except
that it provides &quot;terminator&quot; semantics instead of
&quot;separator&quot; semantics. In other words, each commit
has the message terminator character (usually a newline)
appended, rather than a separator placed between entries.
This means that the final entry of a single-line format will
be properly terminated with a new line, just as the
&quot;oneline&quot; format does. For example:</p>

<p>$ git log -2 --pretty=format:%h 4da45bef | perl -pe
&acute;$_ .= &quot; -- NO NEWLINE0 unless /0&acute; 4da45be
7134973 -- NO NEWLINE</p>

<p>$ git log -2 --pretty=tformat:%h 4da45bef | perl -pe
&acute;$_ .= &quot; -- NO NEWLINE0 unless /0&acute; 4da45be
7134973</p>

<p>In addition, any unrecognized string that has a % in it
is interpreted as if it has tformat: in front of it. For
example, these two are equivalent:</p>

<p>$ git log -2 --pretty=tformat:%h 4da45bef $ git log -2
--pretty=%h 4da45bef</p>

<p>LIMITING OUTPUT If youre only interested in differences
in a subset of files, for example some architecture-specific
files, you might do:</p>

<p>git diff-tree -r &lt;tree-ish&gt; &lt;tree-ish&gt;
arch/ia64 include/asm-ia64</p>

<p>and it will only show you what changed in those two
directories.</p>

<p>Or if you are searching for what changed in just
kernel/sched.c, just do</p>

<p>git diff-tree -r &lt;tree-ish&gt; &lt;tree-ish&gt;
kernel/sched.c</p>

<p>and it will ignore all differences to other files.</p>

<p>The pattern is always the prefix, and is matched
exactly. There are no wildcards. Even stricter, it has to
match a complete path component. I.e. &quot;foo&quot; does
not pick up foobar.h. &quot;foo&quot; does match foo/bar.h
so it can be used to name subdirectories.</p>

<p>An example of normal usage is:</p>

<p>torvalds@ppc970:~/git&gt; git diff-tree 5319e4......
*100664-&gt;100664 blob ac348b.......-&gt;a01513.......
git-fsck-objects.c</p>

<p>which tells you that the last commit changed just one
file (its from this one:</p>

<p>commit 3c6f7ca19ad4043e9e72fa94106f352897e651a8 tree
5319e4d609cdd282069cc4dce33c1db559539b03 parent
b4e628ea30d5ab3606119d2ea5caeab141d38df7 author Linus
Torvalds &lt;torvalds@ppc970.osdl.org&gt; Sat Apr 9 12:02:30
2005 committer Linus Torvalds
&lt;torvalds@ppc970.osdl.org&gt; Sat Apr 9 12:02:30 2005</p>

<p>Make &quot;git-fsck-objects&quot; print out all the root
commits it finds.</p>

<p>Once I do the reference tracking, I&acute;ll also make
it print out all the HEAD commits it finds, which is even
more interesting.</p>

<p>in case you care).</p>

<p>RAW OUTPUT FORMAT The raw output format from
&quot;git-diff-index&quot;, &quot;git-diff-tree&quot;,
&quot;git-diff-files&quot; and &quot;git diff --raw&quot;
are very similar.</p>

<p>These commands all compare two sets of things; what is
compared differs:</p>

<p>git-diff-index &lt;tree-ish&gt; compares the
&lt;tree-ish&gt; and the files on the filesystem.</p>

<p>git-diff-index --cached &lt;tree-ish&gt; compares the
&lt;tree-ish&gt; and the index.</p>

<p>git-diff-tree [-r] &lt;tree-ish-1&gt; &lt;tree-ish-2&gt;
[&lt;pattern&gt;...] compares the trees named by the two
arguments.</p>

<p>git-diff-files [&lt;pattern&gt;...] compares the index
and the files on the filesystem.</p>

<p>The &quot;git-diff-tree&quot; command begins its output
by printing the hash of what is being compared. After that,
all the commands print one output line per changed file.</p>

<p>An output line is formatted this way:</p>

<p>in-place edit :100644 100644 bcd1234... 0123456... M
file0 copy-edit :100644 100644 abcd123... 1234567... C68
file1 file2 rename-edit :100644 100644 abcd123... 1234567...
R86 file1 file3 create :000000 100644 0000000... 1234567...
A file4 delete :100644 000000 1234567... 0000000... D file5
unmerged :000000 000000 0000000... 0000000... U file6</p>

<p>That is, from the left to the right:</p>

<p>1. a colon.</p>

<p>2. mode for &quot;src&quot;; 000000 if creation or
unmerged.</p>

<p>3. a space.</p>

<p>4. mode for &quot;dst&quot;; 000000 if deletion or
unmerged.</p>

<p>5. a space.</p>

<p>6. sha1 for &quot;src&quot;; 0{40} if creation or
unmerged.</p>

<p>7. a space.</p>

<p>8. sha1 for &quot;dst&quot;; 0{40} if creation, unmerged
or &quot;look at work tree&quot;.</p>

<p>9. a space.</p>

<p>10. status, followed by optional &quot;score&quot;
number.</p>

<p>11. a tab or a NUL when -z option is used.</p>

<p>12. path for &quot;src&quot;</p>

<p>13. a tab or a NUL when -z option is used; only exists
for C or R.</p>

<p>14. path for &quot;dst&quot;; only exists for C or
R.</p>

<p>15. an LF or a NUL when -z option is used, to terminate
the record.</p>

<p>Possible status letters are:</p>

<p>&middot; A: addition of a file</p>

<p>&middot; C: copy of a file into a new one</p>

<p>&middot; D: deletion of a file</p>

<p>&middot; M: modification of the contents or mode of a
file</p>

<p>&middot; R: renaming of a file</p>

<p>&middot; T: change in the type of the file</p>

<p>&middot; U: file is unmerged (you must complete the
merge before it can be committed)</p>

<p>&middot; X: &quot;unknown&quot; change type (most
probably a bug, please report it)</p>

<p>Status letters C and R are always followed by a score
(denoting the percentage of similarity between the source
and target of the move or copy), and are the only ones to be
so.</p>

<p>&lt;sha1&gt; is shown as all 0 s if a file is new on the
filesystem and it is out of sync with the index.</p>

<p>Example:</p>

<p>:100644 100644 5be4a4...... 000000...... M file.c</p>

<p>When -z option is not used, TAB, LF, and backslash
characters in pathnames are represented as , 0 and \,
respectively.</p>

<p>DIFF FORMAT FOR MERGES &quot;git-diff-tree&quot;,
&quot;git-diff-files&quot; and &quot;git-diff --raw&quot;
can take -c or --cc option to generate diff output also for
merge commits. The output differs from the format described
above in the following way:</p>

<p>1. there is a colon for each parent</p>

<p>2. there are more &quot;src&quot; modes and
&quot;src&quot; sha1</p>

<p>3. status is concatenated status characters for each
parent</p>

<p>4. no optional &quot;score&quot; number</p>

<p>5. single path, only for &quot;dst&quot;</p>

<p>Example:</p>

<p>::100644 100644 100644 fabadb8... cc95eb0... 4866510...
MM describe.c</p>

<p>Note that combined diff lists only files which were
modified from all parents.</p>

<p>GENERATING PATCHES WITH -P When
&quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, or
&quot;git-diff-files&quot; are run with a -p option,
&quot;git diff&quot; without the --raw option, or &quot;git
log&quot; with the &quot;-p&quot; option, they do not
produce the output described above; instead they produce a
patch file. You can customize the creation of such patches
via the GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment
variables.</p>

<p>What the -p option produces is slightly different from
the traditional diff format.</p>

<p>1. It is preceded with a &quot;git diff&quot; header,
that looks like this:</p>

<p>diff --git a/file1 b/file2</p>

<p>The a/ and b/ filenames are the same unless rename/copy
is involved. Especially, even for a creation or a deletion,
/dev/null is not used in place of a/ or b/ filenames.</p>

<p>When rename/copy is involved, file1 and file2 show the
name of the source file of the rename/copy and the name of
the file that rename/copy produces, respectively.</p>

<p>2. It is followed by one or more extended header
lines:</p>

<p>old mode &lt;mode&gt; new mode &lt;mode&gt; deleted file
mode &lt;mode&gt; new file mode &lt;mode&gt; copy from
&lt;path&gt; copy to &lt;path&gt; rename from &lt;path&gt;
rename to &lt;path&gt; similarity index &lt;number&gt;
dissimilarity index &lt;number&gt; index
&lt;hash&gt;..&lt;hash&gt; &lt;mode&gt;</p>

<p>3. TAB, LF, double quote and backslash characters in
pathnames are represented as , 0 for such substitution then
the whole pathname is put in double quotes.</p>

<p>The similarity index is the percentage of unchanged
lines, and the dissimilarity index is the percentage of
changed lines. It is a rounded down integer, followed by a
percent sign. The similarity index value of 100% is thus
reserved for two equal files, while 100% dissimilarity means
that no line from the old file made it into the new one.</p>

<p>COMBINED DIFF FORMAT &quot;git-diff-tree&quot;,
&quot;git-diff-files&quot; and &quot;git-diff&quot; can take
-c or --cc option to produce combined diff. For showing a
merge commit with &quot;git log -p&quot;, this is the
default format; you can force showing full diff with the -m
option. A combined diff format looks like this:</p>

<p>diff --combined describe.c index
fabadb8,cc95eb0..4866510 --- a/describe.c +++ b/describe.c
@@@ -98,20 -98,12 +98,20 @@@ return (a_date &gt; b_date) ?
-1 : (a_date == b_date) ? 0 : 1; }</p>

<p>- static void describe(char *arg) -static void
describe(struct commit *cmit, int last_one) ++static void
describe(char *arg, int last_one) { + unsigned char
sha1[20]; + struct commit *cmit; struct commit_list *list;
static int initialized = 0; struct commit_name *n;</p>

<p>+ if (get_sha1(arg, sha1) &lt; 0) +
usage(describe_usage); + cmit =
lookup_commit_reference(sha1); + if (!cmit) +
usage(describe_usage); + if (!initialized) { initialized =
1; for_each_ref(get_name);</p>

<p>1. It is preceded with a &quot;git diff&quot; header,
that looks like this (when -c option is used):</p>

<p>diff --combined file</p>

<p>or like this (when --cc option is used):</p>

<p>diff --cc file</p>

<p>2. It is followed by one or more extended header lines
(this example shows a merge with two parents):</p>

<p>index &lt;hash&gt;,&lt;hash&gt;..&lt;hash&gt; mode
&lt;mode&gt;,&lt;mode&gt;..&lt;mode&gt; new file mode
&lt;mode&gt; deleted file mode &lt;mode&gt;,&lt;mode&gt;</p>

<p>The mode &lt;mode&gt;,&lt;mode&gt;..&lt;mode&gt; line
appears only if at least one of the &lt;mode&gt; is
different from the rest. Extended headers with information
about detected contents movement (renames and copying
detection) are designed to work with diff of two
&lt;tree-ish&gt; and are not used by combined diff
format.</p>

<p>3. It is followed by two-line from-file/to-file
header</p>

<p>--- a/file +++ b/file</p>

<p>Similar to two-line header for traditional unified diff
format, /dev/null is used to signal created or deleted
files.</p>

<p>4. Chunk header format is modified to prevent people
from accidentally feeding it to patch -p1. Combined diff
format was created for review of merge commit changes, and
was not meant for apply. The change is similar to the change
in the extended index header:</p>

<p>@@@ &lt;from-file-range&gt; &lt;from-file-range&gt;
&lt;to-file-range&gt; @@@</p>

<p>There are (number of parents + 1) @ characters in the
chunk header for combined diff format.</p>

<p>Unlike the traditional unified diff format, which shows
two files A and B with a single column that has - (minus
appears in A but removed in B), + (plus missing in A but
added to B), or &quot; &quot; (space unchanged) prefix, this
format compares two or more files file1, file2,... with one
file X, and shows how X differs from each of fileN. One
column for each of fileN is prepended to the output line to
note how Xs line is different from it.</p>

<p>A - character in the column N means that the line
appears in fileN but it does not appear in the result. A +
character in the column N means that the line appears in the
result, and fileN does not have that line (in other words,
the line was added, from the point of view of that
parent).</p>

<p>In the above example output, the function signature was
changed from both files (hence two - removals from both
file1 and file2, plus ++ to mean one line that was added
does not appear in either file1 nor file2). Also eight other
lines are the same from file1 but do not appear in file2
(hence prefixed with +).</p>

<p>When shown by git diff-tree -c, it compares the parents
of a merge commit with the merge result (i.e. file1..fileN
are the parents). When shown by git diff-files -c, it
compares the two unresolved merge parents with the working
tree file (i.e. file1 is stage 2 aka &quot;our
version&quot;, file2 is stage 3 aka &quot;their
version&quot;).</p>

<p>OTHER DIFF FORMATS The --summary option describes newly
added, deleted, renamed and copied files. The --stat option
adds diffstat(1) graph to the output. These options can be
combined with other options, such as -p, and are meant for
human consumption.</p>

<p>When showing a change that involves a rename or a copy,
--stat output formats the pathnames compactly by combining
common prefix and suffix of the pathnames. For example, a
change that moves arch/i386/Makefile to arch/x86/Makefile
while modifying 4 lines will be shown like this:</p>

<p>arch/{i386 =&gt; x86}/Makefile | 4 +--</p>

<p>The --numstat option gives the diffstat(1) information
but is designed for easier machine consumption. An entry in
--numstat output looks like this:</p>

<p>1 2 README 3 1 arch/{i386 =&gt; x86}/Makefile</p>

<p>That is, from left to right:</p>

<p>1. the number of added lines;</p>

<p>2. a tab;</p>

<p>3. the number of deleted lines;</p>

<p>4. a tab;</p>

<p>5. pathname (possibly with rename/copy information);</p>

<p>6. a newline.</p>

<p>When -z output option is in effect, the output is
formatted this way:</p>

<p>1 2 README NUL 3 1 NUL arch/i386/Makefile NUL
arch/x86/Makefile NUL</p>

<p>That is:</p>

<p>1. the number of added lines;</p>

<p>2. a tab;</p>

<p>3. the number of deleted lines;</p>

<p>4. a tab;</p>

<p>5. a NUL (only exists if renamed/copied);</p>

<p>6. pathname in preimage;</p>

<p>7. a NUL (only exists if renamed/copied);</p>

<p>8. pathname in postimage (only exists if
renamed/copied);</p>

<p>9. a NUL.</p>

<p>The extra NUL before the preimage path in renamed case
is to allow scripts that read the output to tell if the
current record being read is a single-path record or a
rename/copy record without reading ahead. After reading
added and deleted lines, reading up to NUL would yield the
pathname, but if that is NUL, the record will show two
paths.</p>

<p>AUTHOR Written by Linus Torvalds
&lt;torvalds@osdl.org[1]&gt;</p>

<p>DOCUMENTATION Documentation by David Greaves, Junio C
Hamano and the git-list &lt;git@vger.kernel.org[2]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. torvalds@osdl.org mailto:torvalds@osdl.org</p>

<p>2. git@vger.kernel.org mailto:git@vger.kernel.org</p>

<p>Git 1.7.1 07/27/2010 GIT-DIFF-TREE(1)</p>
<hr>
</body>
</html>
