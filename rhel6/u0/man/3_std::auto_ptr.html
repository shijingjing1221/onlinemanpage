<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:17:07 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>std::auto_ptr(3) std::auto_ptr(3)</p>

<p>NAME std::auto_ptr -</p>

<p>A simple smart pointer providing strict ownership
semantics.</p>

<p>SYNOPSIS Public Types typedef _Tp element_type</p>

<p>Public Member Functions auto_ptr (auto_ptr_ref&lt;
element_type &gt; __ref) throw () template&lt;typename _Tp1
&gt; auto_ptr (auto_ptr&lt; _Tp1 &gt; &amp;__a) throw ()
auto_ptr (auto_ptr &amp;__a) throw () auto_ptr (element_type
*__p=0) throw () element_type * get () const throw ()
template&lt;typename _Tp1 &gt; operator auto_ptr&lt; _Tp1
&gt; () throw () template&lt;typename _Tp1 &gt; operator
auto_ptr_ref&lt; _Tp1 &gt; () throw () element_type &amp;
operator* () const throw () element_type * operator-&gt; ()
const throw () auto_ptr &amp; operator= (auto_ptr_ref&lt;
element_type &gt; __ref) throw () template&lt;typename _Tp1
&gt; auto_ptr &amp; operator= (auto_ptr&lt; _Tp1 &gt;
&amp;__a) throw () auto_ptr &amp; operator= (auto_ptr
&amp;__a) throw () element_type * release () throw () void
reset (element_type *__p=0) throw () ~auto_ptr ()</p>

<p>Detailed Description template&lt;typename _Tp&gt; class
std::auto_ptr&lt; _Tp &gt; A simple smart pointer providing
strict ownership semantics.</p>

<p>The Standard says:</p>

<p>An auto_ptr owns the object it holds a pointer to.
Copying an auto_ptr copies the pointer and transfers
ownership to the destination. If more than one auto_ptr owns
the same object at the same time the behavior of the program
is undefined.</p>

<p>The uses of auto_ptr include providing temporary
exception-safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and
returning dynamically allocated memory from a function.
auto_ptr does not meet the CopyConstructible and Assignable
requirements for Standard Library container elements and
thus instantiating a Standard Library container with an
auto_ptr results in undefined behavior.</p>

<p>Quoted from [20.4.5]/3.</p>

<p>Good examples of what can and cannot be done with
auto_ptr can be found in the libstdc++ testsuite.</p>

<p>_GLIBCXX_RESOLVE_LIB_DEFECTS 127. auto_ptr&lt;&gt;
conversion issues These resolutions have all been
incorporated.</p>

<p>Definition at line 85 of file auto_ptr.h.</p>

<p>Member Typedef Documentation template&lt;typename
_Tp&gt; typedef _Tp std::auto_ptr&lt; _Tp &gt;::element_type
The pointed-to type.</p>

<p>Definition at line 92 of file auto_ptr.h.</p>

<p>Constructor &amp; Destructor Documentation
template&lt;typename _Tp&gt; std::auto_ptr&lt; _Tp
&gt;::auto_ptr (element_type * __p = 0) throw () [inline,
explicit] An auto_ptr is usually constructed from a raw
pointer. Parameters: p A pointer (defaults to NULL).</p>

<p>This object now owns the object pointed to by p.</p>

<p>Definition at line 101 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; std::auto_ptr&lt; _Tp
&gt;::auto_ptr (auto_ptr&lt; _Tp &gt; &amp; __a) throw ()
[inline] An auto_ptr can be constructed from another
auto_ptr. Parameters: a Another auto_ptr of the same
type.</p>

<p>This object now owns the object previously owned by a,
which has given up ownership.</p>

<p>Definition at line 110 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; template&lt;typename _Tp1
&gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr (auto_ptr&lt; _Tp1
&gt; &amp; __a) throw () [inline] An auto_ptr can be
constructed from another auto_ptr. Parameters: a Another
auto_ptr of a different but related type.</p>

<p>A pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p>This object now owns the object previously owned by a,
which has given up ownership.</p>

<p>Definition at line 123 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; std::auto_ptr&lt; _Tp
&gt;::~auto_ptr () [inline] When the auto_ptr goes out of
scope, the object it owns is deleted. If it no longer owns
anything (i.e., get() is NULL), then this has no effect. The
C++ standard says there is supposed to be an empty throw
specification here, but omitting it is standard conforming.
Its presence can be detected only if _Tp::~_Tp() throws, but
this is prohibited. [17.4.3.6]/2</p>

<p>Definition at line 168 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; std::auto_ptr&lt; _Tp
&gt;::auto_ptr (auto_ptr_ref&lt; element_type &gt; __ref)
throw () [inline] Automatic conversions. These operations
convert an auto_ptr into and from an auto_ptr_ref
automatically as needed. This allows constructs such as</p>

<p>auto_ptr&lt;Derived&gt; func_returning_auto_ptr(.....);
... auto_ptr&lt;Base&gt; ptr =
func_returning_auto_ptr(.....);</p>

<p>Definition at line 258 of file auto_ptr.h.</p>

<p>Member Function Documentation template&lt;typename
_Tp&gt; element_type* std::auto_ptr&lt; _Tp &gt;::get (void)
const throw () [inline] Bypassing the smart pointer.
Returns: The raw pointer being managed.</p>

<p>You can get a copy of the pointer that this object owns,
for situations such as passing to a function which only
accepts a raw pointer.</p>

<p>Note: This auto_ptr still owns the memory.</p>

<p>Definition at line 209 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; element_type&amp;
std::auto_ptr&lt; _Tp &gt;::operator* () const throw ()
[inline] Smart pointer dereferencing. If this auto_ptr no
longer owns anything, then this operation will crash. (For a
smart pointer, no longer owns anything is the same as being
a null pointer, and you know what happens when you
dereference one of those...)</p>

<p>Definition at line 179 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; element_type*
std::auto_ptr&lt; _Tp &gt;::operator-&gt; () const throw ()
[inline] Smart pointer dereferencing. This returns the
pointer itself, which the language then will automatically
cause to be dereferenced.</p>

<p>Definition at line 192 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; template&lt;typename _Tp1
&gt; auto_ptr&amp; std::auto_ptr&lt; _Tp &gt;::operator=
(auto_ptr&lt; _Tp1 &gt; &amp; __a) throw () [inline]
auto_ptr assignment operator. Parameters: a Another auto_ptr
of a different but related type.</p>

<p>A pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p>This object now owns the object previously owned by a,
which has given up ownership. The object that this one used
to own and track has been deleted.</p>

<p>Definition at line 152 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; auto_ptr&amp;
std::auto_ptr&lt; _Tp &gt;::operator= (auto_ptr&lt; _Tp &gt;
&amp; __a) throw () [inline] auto_ptr assignment operator.
Parameters: a Another auto_ptr of the same type.</p>

<p>This object now owns the object previously owned by a,
which has given up ownership. The object that this one used
to own and track has been deleted.</p>

<p>Definition at line 134 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; element_type*
std::auto_ptr&lt; _Tp &gt;::release () throw () [inline]
Bypassing the smart pointer. Returns: The raw pointer being
managed.</p>

<p>You can get a copy of the pointer that this object owns,
for situations such as passing to a function which only
accepts a raw pointer.</p>

<p>Note: This auto_ptr no longer owns the memory. When this
object goes out of scope, nothing will happen.</p>

<p>Definition at line 223 of file auto_ptr.h.</p>

<p>template&lt;typename _Tp&gt; void std::auto_ptr&lt; _Tp
&gt;::reset (element_type * __p = 0) throw () [inline]
Forcibly deletes the managed object. Parameters: p A pointer
(defaults to NULL).</p>

<p>This object now owns the object pointed to by p. The
previous object has been deleted.</p>

<p>Definition at line 238 of file auto_ptr.h.</p>

<p>Author Generated automatically by Doxygen for libstdc++
from the source code.</p>

<p>libstdc++ 26 Jul 2010 std::auto_ptr(3)</p>
<hr>
</body>
</html>
