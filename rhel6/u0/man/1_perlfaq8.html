<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:05 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLFAQ8(1) Perl Programmers Reference Guide
PERLFAQ8(1)</p>

<p>NAME perlfaq8 - System Interaction</p>

<p>DESCRIPTION This section of the Perl FAQ covers
questions involving operating system interaction. Topics
include interprocess communication (IPC), control over the
user-interface (keyboard, screen and pointing devices), and
most anything else not related to data manipulation.</p>

<p>Read the FAQs and documentation specific to the port of
perl to your operating system (eg, perlvms, perlplan9, ...).
These should contain more detailed information on the
vagaries of your perl.</p>

<p>How do I find out which operating system m running
under? The $^O variable ($OSNAME if you use English)
contains an indication of the name of the operating system
(not its release number) that your perl binary was built
for.</p>

<p>How come exec() doest return? (contributed by brian d
foy)</p>

<p>The &quot;exec&quot; functions job is to turn your
process into another command and never to return. If thats
not what you want to do, don t use &quot;exec&quot;. :)</p>

<p>If you want to run an external command and still keep
your Perl process going, look at a piped &quot;open&quot;,
&quot;fork&quot;, or &quot;system&quot;.</p>

<p>How do I do fancy stuff with the keyboard/screen/mouse?
How you access/control keyboards, screens, and pointing
devices (&quot;mice&quot;) is system-dependent. Try the
following modules:</p>

<p>Keyboard Term::Cap Standard perl distribution
Term::ReadKey CPAN Term::ReadLine::Gnu CPAN
Term::ReadLine::Perl CPAN Term::Screen CPAN</p>

<p>Screen Term::Cap Standard perl distribution Curses CPAN
Term::ANSIColor CPAN</p>

<p>Mouse Tk CPAN</p>

<p>Some of these specific cases are shown as examples in
other answers in this section of the perlfaq.</p>

<p>How do I print something out in color? In general, you
dont, because you dont know whether the recipient has a
color-aware display device. If you know that they have an
ANSI terminal that understands color, you can use the
Term::ANSIColor module from CPAN:</p>

<p>use Term::ANSIColor; print color(&quot;red&quot;),
&quot;Stop!0, color(&quot;reset&quot;); print
color(&quot;green&quot;), &quot;Go!0,
color(&quot;reset&quot;);</p>

<p>Or like this:</p>

<p>use Term::ANSIColor qw(:constants); print RED,
&quot;Stop!0, RESET; print GREEN, &quot;Go!0, RESET;</p>

<p>How do I read just one key without waiting for a return
key? Controlling input buffering is a remarkably
system-dependent matter. On many systems, you can just use
the stty command as shown in &quot;getc&quot; in perlfunc,
but as you see, that s already getting you into portability
snags.</p>

<p>open(TTY, &quot;+&lt;/dev/tty&quot;) or die &quot;no
tty: $!&quot;; system &quot;stty cbreak &lt;/dev/tty
&gt;/dev/tty 2&gt;&amp;1&quot;; $key = getc(TTY); # perhaps
this works # OR ELSE sysread(TTY, $key, 1); # probably this
does system &quot;stty -cbreak &lt;/dev/tty &gt;/dev/tty
2&gt;&amp;1&quot;;</p>

<p>The Term::ReadKey module from CPAN offers an easy-to-use
interface that should be more efficient than shelling out to
stty for each key. It even includes limited support for
Windows.</p>

<p>use Term::ReadKey; ReadMode(&rsquo;cbreak&rsquo;); $key
= ReadKey(0); ReadMode(&rsquo;normal&rsquo;);</p>

<p>However, using the code requires that you have a working
C compiler and can use it to build and install a CPAN
module. Heres a solution using the standard POSIX module,
which is already on your systems (assuming your system
supports POSIX).</p>

<p>use HotKey; $key = readkey();</p>

<p>And here s the HotKey module, which hides the somewhat
mystifying calls to manipulate the POSIX termios
structures.</p>

<p># HotKey.pm package HotKey;</p>

<p>@ISA = qw(Exporter); @EXPORT = qw(cbreak cooked
readkey);</p>

<p>use strict; use POSIX qw(:termios_h); my ($term, $oterm,
$echo, $noecho, $fd_stdin);</p>

<p>$fd_stdin = fileno(STDIN); $term =
POSIX::Termios-&gt;new(); $term-&gt;getattr($fd_stdin);
$oterm = $term-&gt;getlflag();</p>

<p>$echo = ECHO | ECHOK | ICANON; $noecho = $oterm &amp;
~$echo;</p>

<p>sub cbreak { $term-&gt;setlflag($noecho); # ok, so i
don&rsquo;t want echo either $term-&gt;setcc(VTIME, 1);
$term-&gt;setattr($fd_stdin, TCSANOW); }</p>

<p>sub cooked { $term-&gt;setlflag($oterm);
$term-&gt;setcc(VTIME, 0); $term-&gt;setattr($fd_stdin,
TCSANOW); }</p>

<p>sub readkey { my $key = &rsquo;&rsquo;; cbreak();
sysread(STDIN, $key, 1); cooked(); return $key; }</p>

<p>END { cooked() }</p>

<p>1;</p>

<p>How do I check whether input is ready on the keyboard?
The easiest way to do this is to read a key in nonblocking
mode with the Term::ReadKey module from CPAN, passing it an
argument of -1 to indicate not to block:</p>

<p>use Term::ReadKey;</p>

<p>ReadMode(&rsquo;cbreak&rsquo;);</p>

<p>if (defined ($char = ReadKey(-1)) ) { # input was
waiting and it was $char } else { # no input was waiting
}</p>

<p>ReadMode(&rsquo;normal&rsquo;); # restore normal tty
settings</p>

<p>How do I clear the screen? (contributed by brian d
foy)</p>

<p>To clear the screen, you just have to print the special
sequence that tells the terminal to clear the screen. Once
you have that sequence, output it when you want to clear the
screen.</p>

<p>You can use the &quot;Term::ANSIScreen&quot; module to
get the special sequence. Import the &quot;cls&quot;
function (or the &quot;:screen&quot; tag):</p>

<p>use Term::ANSIScreen qw(cls); my $clear_screen =
cls();</p>

<p>print $clear_screen;</p>

<p>The &quot;Term::Cap&quot; module can also get the
special sequence if you want to deal with the low-level
details of terminal control. The &quot;Tputs&quot; method
returns the string for the given capability:</p>

<p>use Term::Cap;</p>

<p>$terminal = Term::Cap-&gt;Tgetent( { OSPEED =&gt; 9600 }
); $clear_string =
$terminal-&gt;Tputs(&rsquo;cl&rsquo;);</p>

<p>print $clear_screen;</p>

<p>On Windows, you can use the &quot;Win32::Console&quot;
module. After creating an object for the output filehandle
you want to affect, call the &quot;Cls&quot; method:</p>

<p>Win32::Console;</p>

<p>$OUT = Win32::Console-&gt;new(STD_OUTPUT_HANDLE); my
$clear_string = $OUT-&gt;Cls;</p>

<p>print $clear_screen;</p>

<p>If you have a command-line program that does the job,
you can call it in backticks to capture whatever it outputs
so you can use it later:</p>

<p>$clear_string = &lsquo;clear&lsquo;;</p>

<p>print $clear_string;</p>

<p>How do I get the screen size? If you have Term::ReadKey
module installed from CPAN, you can use it to fetch the
width and height in characters and in pixels:</p>

<p>use Term::ReadKey; ($wchar, $hchar, $wpixels, $hpixels)
= GetTerminalSize();</p>

<p>This is more portable than the raw &quot;ioctl&quot;,
but not as illustrative:</p>

<p>require &rsquo;sys/ioctl.ph&rsquo;; die &quot;no
TIOCGWINSZ &quot; unless defined &amp;TIOCGWINSZ; open(TTY,
&quot;+&lt;/dev/tty&quot;) or die &quot;No tty: $!&quot;;
unless (ioctl(TTY, &amp;TIOCGWINSZ,
$winsize=&rsquo;&rsquo;)) { die sprintf &quot;$0: ioctl
TIOCGWINSZ (%08x: $!)0, &amp;TIOCGWINSZ; } ($row, $col,
$xpixel, $ypixel) = unpack(&rsquo;S4&rsquo;, $winsize);
print &quot;(row,col) = ($row,$col)&quot;; print &quot;
(xpixel,ypixel) = ($xpixel,$ypixel)&quot; if $xpixel ||
$ypixel; print &quot;0;</p>

<p>How do I ask the user for a password? (This question has
nothing to do with the web. See a different FAQ for
that.)</p>

<p>Theres an example of this in &quot;crypt&quot; in
perlfunc). First, you put the terminal into &quot;no
echo&quot; mode, then just read the password normally. You
may do this with an old-style ioctl() function, POSIX
terminal control (see POSIX or its documentation the Camel
Book), or a call to the stty program, with varying degrees
of portability.</p>

<p>You can also do this for most systems using the
Term::ReadKey module from CPAN, which is easier to use and
in theory more portable.</p>

<p>use Term::ReadKey;</p>

<p>ReadMode(&rsquo;noecho&rsquo;); $password =
ReadLine(0);</p>

<p>How do I read and write the serial port? This depends on
which operating system your program is running on. In the
case of Unix, the serial ports will be accessible through
files in /dev; on other systems, device names will doubtless
differ. Several problem areas common to all device
interaction are the following:</p>

<p>lockfiles Your system may use lockfiles to control
multiple access. Make sure you follow the correct protocol.
Unpredictable behavior can result from multiple processes
reading from one device.</p>

<p>open mode If you expect to use both read and write
operations on the device, youll have to open it for update
(see &quot;open&quot; in perlfunc for details). You may wish
to open it without running the risk of blocking by using
sysopen() and &quot;O_RDWR|O_NDELAY|O_NOCTTY&quot; from the
Fcntl module (part of the standard perl distribution). See
&quot;sysopen&quot; in perlfunc for more on this
approach.</p>

<p>end of line &quot; at the end of each Some devices will
be expecting a &quot; line &quot; and &quot;0 rather than a
&quot;0. In some ports of perl, &quot; are different from
their usual (Unix) ASCII values of &quot; 12&quot; and
&quot; 15&quot;. You may have to give the numeric values you
want directly, using octal (&quot; 15&quot;), hex
(&quot;0x0D&quot;), or as a control-character specification
(&quot; print DEV &quot;atv1 12&quot;; # wrong, for some
devices print DEV &quot;atv1 15&quot;; # right, for some
devices</p>

<p>Even though with normal text files a &quot;0 will do the
trick, there is still no unified scheme for terminating a
line that is portable between Unix, DOS/Win, and Macintosh,
except to terminate ALL line ends with &quot; 15 12&quot;,
and strip what you dont need from the output. This applies
especially to socket I/O and autoflushing, discussed
next.</p>

<p>flushing output If you expect characters to get to your
device when you print() them, you ll want to autoflush that
filehandle. You can use select() and the $| variable to
control autoflushing (see &quot;$|&quot; in perlvar and
&quot;select&quot; in perlfunc, or perlfaq5, &quot;How do I
flush/unbuffer an output filehandle? Why must I do
this?&quot;):</p>

<p>$oldh = select(DEV); $| = 1; select($oldh);</p>

<p>Youll also see code that does this without a temporary
variable, as in</p>

<p>select((select(DEV), $| = 1)[0]);</p>

<p>Or if you dont mind pulling in a few thousand lines of
code just because youre afraid of a little $| variable:</p>

<p>use IO::Handle; DEV-&gt;autoflush(1);</p>

<p>As mentioned in the previous item, this still doesnt
work when using socket I/O between Unix and Macintosh. You
ll need to hard code your line terminators, in that
case.</p>

<p>non-blocking input If you are doing a blocking read() or
sysread(), youll have to arrange for an alarm handler to
provide a timeout (see &quot;alarm&quot; in perlfunc). If
you have a non-blocking open, youll likely have a
non-blocking read, which means you may have to use a 4-arg
select() to determine whether I/O is ready on that device
(see &quot;select&quot; in perlfunc.</p>

<p>While trying to read from his caller-id box, the
notorious Jamie Zawinski
&quot;&lt;jwz@netscape.com&gt;&quot;, after much gnashing of
teeth and fighting with sysread, sysopen, POSIXs tcgetattr
business, and various other functions that go bump in the
night, finally came up with this:</p>

<p>sub open_modem { use IPC::Open2; my $stty =
&lsquo;/bin/stty -g&lsquo;; open2( ODEM_IN, ODEM_OUT,
&quot;cu -l$modem_device -s2400 2&gt;&amp;1&quot;); #
starting cu hoses /dev/tty&rsquo;s stty settings, even when
it has # been opened on a pipe... system(&quot;/bin/stty
$stty&quot;); $_ = &lt;MODEM_IN&gt;; chomp; if (
!m/^Connected/ ) { print STDERR &quot;$0: cu printed
&lsquo;$_&rsquo; instead of &lsquo;Connected&rsquo;0; }
}</p>

<p>How do I decode encrypted password files? You spend lots
and lots of money on dedicated hardware, but this is bound
to get you talked about.</p>

<p>Seriously, you cant if they are Unix password files--the
Unix password system employs one-way encryption. Its more
like hashing than encryption. The best you can do is check
whether something else hashes to the same string. You cant
turn a hash back into the original string. Programs like
Crack can forcibly (and intelligently) try to guess
passwords, but dont (cant) guarantee quick success.</p>

<p>If youre worried about users selecting bad passwords,
you should proactively check when they try to change their
password (by modifying passwd(1), for example).</p>

<p>How do I start a process in the background? (contributed
by brian d foy)</p>

<p>Theres not a single way to run code in the background so
you dont have to wait for it to finish before your program
moves on to other tasks. Process management depends on your
particular operating system, and many of the techniques are
in perlipc.</p>

<p>Several CPAN modules may be able to help, including
IPC::Open2 or IPC::Open3, IPC::Run, Parallel::Jobs,
Parallel::ForkManager, POE, Proc::Background, and
Win32::Process. There are many other modules you might use,
so check those namespaces for other options too.</p>

<p>If you are on a unix-like system, you might be able to
get away with a system call where you put an
&quot;&amp;&quot; on the end of the command:</p>

<p>system(&quot;cmd &amp;&quot;)</p>

<p>You can also try using &quot;fork&quot;, as described in
perlfunc (although this is the same thing that many of the
modules will do for you).</p>

<p>STDIN, STDOUT, and STDERR are shared Both the main
process and the backgrounded one (the &quot;child&quot;
process) share the same STDIN, STDOUT and STDERR
filehandles. If both try to access them at once, strange
things can happen. You may want to close or reopen these for
the child. You can get around this with &quot;open&quot;ing
a pipe (see &quot;open&quot; in perlfunc) but on some
systems this means that the child process cannot outlive the
parent.</p>

<p>Signals You ll have to catch the SIGCHLD signal, and
possibly SIGPIPE too. SIGCHLD is sent when the backgrounded
process finishes. SIGPIPE is sent when you write to a
filehandle whose child process has closed (an untrapped
SIGPIPE can cause your program to silently die). This is not
an issue with &quot;system(&quot;cmd&amp;&quot;)&quot;.</p>

<p>Zombies You have to be prepared to &quot;reap&quot; the
child process when it finishes.</p>

<p>$SIG{CHLD} = sub { wait };</p>

<p>$SIG{CHLD} = &rsquo;IGNORE&rsquo;;</p>

<p>You can also use a double fork. You immediately wait()
for your first child, and the init daemon will wait() for
your grandchild once it exits.</p>

<p>unless ($pid = fork) { unless (fork) { exec &quot;what
you really wanna do&quot;; die &quot;exec failed!&quot;; }
exit 0; } waitpid($pid, 0);</p>

<p>See &quot;Signals&quot; in perlipc for other examples of
code to do this. Zombies are not an issue with
&quot;system(&quot;prog &amp;&quot;)&quot;.</p>

<p>How do I trap control characters/signals? You don t
actually &quot;trap&quot; a control character. Instead, that
character generates a signal which is sent to your terminal
s currently foregrounded process group, which you then trap
in your process. Signals are documented in
&quot;Signals&quot; in perlipc and the section on
&quot;Signals&quot; in the Camel.</p>

<p>You can set the values of the %SIG hash to be the
functions you want to handle the signal. After perl catches
the signal, it looks in %SIG for a key with the same name as
the signal, then calls the subroutine value for that
key.</p>

<p># as an anonymous subroutine</p>

<p>$SIG{INT} = sub { syswrite(STDERR, &quot;ouch0, 5 )
};</p>

<p># or a reference to a function</p>

<p>$SIG{INT} = ouch;</p>

<p># or the name of the function as a string</p>

<p>$SIG{INT} = &quot;ouch&quot;;</p>

<p>Perl versions before 5.8 had in its C source code signal
handlers which would catch the signal and possibly run a
Perl function that you had set in %SIG. This violated the
rules of signal handling at that level causing perl to dump
core. Since version 5.8.0, perl looks at %SIG *after* the
signal has been caught, rather than while it is being
caught. Previous versions of this answer were incorrect.</p>

<p>How do I modify the shadow password file on a Unix
system? If perl was installed correctly and your shadow
library was written properly, the getpw*() functions
described in perlfunc should in theory provide (read-only)
access to entries in the shadow password file. To change the
file, make a new shadow password file (the format varies
from system to system--see passwd for specifics) and use
pwd_mkdb(8) to install it (see pwd_mkdb for more
details).</p>

<p>How do I set the time and date? Assuming you re running
under sufficient permissions, you should be able to set the
system-wide date and time by running the date(1) program.
(There is no way to set the time and date on a per-process
basis.) This mechanism will work for Unix, MS-DOS, Windows,
and NT; the VMS equivalent is &quot;set time&quot;.</p>

<p>However, if all you want to do is change your time zone,
you can probably get away with setting an environment
variable:</p>

<p>$ENV{TZ} = &quot;MST7MDT&quot;; # unixish
$ENV{&rsquo;SYS$TIMEZONE_DIFFERENTIAL&rsquo;}=&quot;-5&quot;
# vms system &quot;trn comp.lang.perl.misc&quot;;</p>

<p>How can I sleep() or alarm() for under a second? If you
want finer granularity than the 1 second that the
&quot;sleep()&quot; function provides, the easiest way is to
use the &quot;select()&quot; function as documented in
&quot;select&quot; in perlfunc. Try the
&quot;Time::HiRes&quot; and the &quot;BSD::Itimer&quot;
modules (available from CPAN, and starting from Perl 5.8
&quot;Time::HiRes&quot; is part of the standard
distribution).</p>

<p>How can I measure time under a second? (contributed by
brian d foy)</p>

<p>The &quot;Time::HiRes&quot; module (part of the standard
distribution as of Perl 5.8) measures time with the
&quot;gettimeofday()&quot; system call, which returns the
time in microseconds since the epoch. If you can t install
&quot;Time::HiRes&quot; for older Perls and you are on a
Unixish system, you may be able to call gettimeofday(2)
directly. See &quot;syscall&quot; in perlfunc.</p>

<p>How can I do an atexit() or setjmp()/longjmp()?
(Exception handling) Release 5 of Perl added the END block,
which can be used to simulate atexit(). Each package s END
block is called when the program or thread ends (see perlmod
manpage for more details).</p>

<p>For example, you can use this to make sure your filter
program managed to finish its output without filling up the
disk:</p>

<p>END { close(STDOUT) || die &quot;stdout close failed:
$!&quot;; }</p>

<p>The END block isnt called when untrapped signals kill
the program, though, so if you use END blocks you should
also use</p>

<p>use sigtrap qw(die normal-signals);</p>

<p>Perls exception-handling mechanism is its eval()
operator. You can use eval() as setjmp and die() as longjmp.
For details of this, see the section on signals, especially
the time-out handler for a blocking flock() in
&quot;Signals&quot; in perlipc or the section on
&quot;Signals&quot; in the Camel Book.</p>

<p>If exception handling is all youre interested in, try
the exceptions.pl library (part of the standard perl
distribution).</p>

<p>If you want the atexit() syntax (and an rmexit() as
well), try the AtExit module available from CPAN.</p>

<p>Why doesn t my sockets program work under System V
(Solaris)? What does the error message &quot;Protocol not
supported&quot; mean? Some Sys-V based systems, notably
Solaris 2.X, redefined some of the standard socket
constants. Since these were constant across all
architectures, they were often hardwired into perl code. The
proper way to deal with this is to &quot;use Socket&quot; to
get the correct values.</p>

<p>Note that even though SunOS and Solaris are binary
compatible, these values are different. Go figure.</p>

<p>How can I call my systes unique C functions from Perl?
In most cases, you write an external module to do it--see
the answer to &quot;Where can I learn about linking C with
Perl? [h2xs, xsubpp]&quot;. However, if the function is a
system call, and your system supports syscall(), you can use
the syscall function (documented in perlfunc).</p>

<p>Remember to check the modules that came with your
distribution, and CPAN as well--someone may already have
written a module to do it. On Windows, try Win32::API. On
Macs, try Mac::Carbon. If no module has an interface to the
C function, you can inline a bit of C in your Perl source
with Inline::C.</p>

<p>Where do I get the include files to do ioctl() or
syscall()? Historically, these would be generated by the
h2ph tool, part of the standard perl distribution. This
program converts cpp(1) directives in C header files to
files containing subroutine definitions, like
&amp;SYS_getitimer, which you can use as arguments to your
functions. It doesnt work perfectly, but it usually gets
most of the job done. Simple files like errno.h, syscall.h,
and socket.h were fine, but the hard ones like ioctl.h
nearly always need to hand-edited. Heres how to install the
*.ph files:</p>

<p>1. become super-user 2. cd /usr/include 3. h2ph *.h
*/*.h</p>

<p>If your system supports dynamic loading, for reasons of
portability and sanity you probably ought to use h2xs (also
part of the standard perl distribution). This tool converts
C header files to Perl extensions. See perlxstut for how to
get started with h2xs.</p>

<p>If your system doesnt support dynamic loading, you still
probably ought to use h2xs. See perlxstut and
ExtUtils::MakeMaker for more information (in brief, just use
make perl instead of a plain make to rebuild perl with a new
static extension).</p>

<p>Why do setuid perl scripts complain about kernel
problems? Some operating systems have bugs in the kernel
that make setuid scripts inherently insecure. Perl gives you
a number of options (described in perlsec) to work around
such systems.</p>

<p>How can I open a pipe both to and from a command? The
IPC::Open2 module (part of the standard perl distribution)
is an easy-to-use approach that internally uses pipe(),
fork(), and exec() to do the job. Make sure you read the
deadlock warnings in its documentation, though (see
IPC::Open2). See &quot;Bidirectional Communication with
Another Process&quot; in perlipc and &quot;Bidirectional
Communication with Yourself&quot; in perlipc</p>

<p>You may also use the IPC::Open3 module (part of the
standard perl distribution), but be warned that it has a
different order of arguments from IPC::Open2 (see
IPC::Open3).</p>

<p>Why cat I get the output of a command with system()? You
re confusing the purpose of system() and backticks ().
system() runs a command and returns exit status information
(as a 16 bit value: the low 7 bits are the signal the
process died from, if any, and the high 8 bits are the
actual exit value). Backticks () run a command and return
what it sent to STDOUT.</p>

<p>$exit_status = system(&quot;mail-users&quot;);
$output_string = &lsquo;ls&lsquo;;</p>

<p>How can I capture STDERR from an external command? There
are three basic ways of running external commands:</p>

<p>system $cmd; # using system() $output =
&lsquo;$cmd&lsquo;; # using backticks (&lsquo;&lsquo;) open
(PIPE, &quot;cmd |&quot;); # using open()</p>

<p>With system(), both STDOUT and STDERR will go the same
place as the script s STDOUT and STDERR, unless the system()
command redirects them. Backticks and open() read only the
STDOUT of your command.</p>

<p>You can also use the open3() function from IPC::Open3.
Benjamin Goldberg provides some sample code:</p>

<p>To capture a programs STDOUT, but discard its
STDERR:</p>

<p>use IPC::Open3; use File::Spec; use Symbol qw(gensym);
open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull); my
$pid = open3(gensym, H, &quot;&gt;&amp;NULL&quot;,
&quot;cmd&quot;); while( &lt;PH&gt; ) { } waitpid($pid,
0);</p>

<p>To capture a programs STDERR, but discard its
STDOUT:</p>

<p>use IPC::Open3; use File::Spec; use Symbol qw(gensym);
open(NULL, &quot;&gt;&quot;, File::Spec-&gt;devnull); my
$pid = open3(gensym, &quot;&gt;&amp;NULL&quot;, H,
&quot;cmd&quot;); while( &lt;PH&gt; ) { } waitpid($pid,
0);</p>

<p>To capture a programs STDERR, and let its STDOUT go to
our own STDERR:</p>

<p>use IPC::Open3; use Symbol qw(gensym); my $pid =
open3(gensym, &quot;&gt;&amp;STDERR&quot;, H,
&quot;cmd&quot;); while( &lt;PH&gt; ) { } waitpid($pid,
0);</p>

<p>To read both a commands STDOUT and its STDERR
separately, you can redirect them to temp files, let the
command run, then read the temp files:</p>

<p>use IPC::Open3; use Symbol qw(gensym); use IO::File;
local *CATCHOUT = IO::File-&gt;new_tmpfile; local *CATCHERR
= IO::File-&gt;new_tmpfile; my $pid = open3(gensym,
&quot;&gt;&amp;CATCHOUT&quot;,
&quot;&gt;&amp;CATCHERR&quot;, &quot;cmd&quot;);
waitpid($pid, 0); seek $_, 0, 0 for ATCHOUT, ATCHERR; while(
&lt;CATCHOUT&gt; ) {} while( &lt;CATCHERR&gt; ) {}</p>

<p>But theres no real need for *both* to be tempfiles...
the following should work just as well, without
deadlocking:</p>

<p>use IPC::Open3; use Symbol qw(gensym); use IO::File;
local *CATCHERR = IO::File-&gt;new_tmpfile; my $pid =
open3(gensym, ATCHOUT, &quot;&gt;&amp;CATCHERR&quot;,
&quot;cmd&quot;); while( &lt;CATCHOUT&gt; ) {} waitpid($pid,
0); seek CATCHERR, 0, 0; while( &lt;CATCHERR&gt; ) {}</p>

<p>And itll be faster, too, since we can begin processing
the programs stdout immediately, rather than waiting for the
program to finish.</p>

<p>With any of these, you can change file descriptors
before the call:</p>

<p>open(STDOUT, &quot;&gt;logfile&quot;);
system(&quot;ls&quot;);</p>

<p>or you can use Bourne shell file-descriptor
redirection:</p>

<p>$output = &lsquo;$cmd 2&gt;some_file&lsquo;; open (PIPE,
&quot;cmd 2&gt;some_file |&quot;);</p>

<p>You can also use file-descriptor redirection to make
STDERR a duplicate of STDOUT:</p>

<p>$output = &lsquo;$cmd 2&gt;&amp;1&lsquo;; open (PIPE,
&quot;cmd 2&gt;&amp;1 |&quot;);</p>

<p>Note that you cannot simply open STDERR to be a dup of
STDOUT in your Perl program and avoid calling the shell to
do the redirection. This doesnt work:</p>

<p>open(STDERR, &quot;&gt;&amp;STDOUT&quot;); $alloutput =
&lsquo;cmd args&lsquo;; # stderr still escapes</p>

<p>This fails because the open() makes STDERR go to where
STDOUT was going at the time of the open(). The backticks
then make STDOUT go to a string, but dont change STDERR
(which still goes to the old STDOUT).</p>

<p>Note that you must use Bourne shell (sh(1)) redirection
syntax in backticks, not csh(1)! Details on why Perls
system() and backtick and pipe opens all use the Bourne
shell are in the versus/csh.whynot article in the &quot;Far
More Than You Ever Wanted To Know&quot; collection in
http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz . To capture a
commands STDERR and STDOUT together:</p>

<p>$output = &lsquo;cmd 2&gt;&amp;1&lsquo;; # either with
backticks $pid = open(PH, &quot;cmd 2&gt;&amp;1 |&quot;); #
or with an open pipe while (&lt;PH&gt;) { } # plus a
read</p>

<p>To capture a commands STDOUT but discard its STDERR:</p>

<p>$output = &lsquo;cmd 2&gt;/dev/null&lsquo;; # either
with backticks $pid = open(PH, &quot;cmd 2&gt;/dev/null
|&quot;); # or with an open pipe while (&lt;PH&gt;) { } #
plus a read</p>

<p>To capture a commands STDERR but discard its STDOUT:</p>

<p>$output = &lsquo;cmd 2&gt;&amp;1 1&gt;/dev/null&lsquo;;
# either with backticks $pid = open(PH, &quot;cmd
2&gt;&amp;1 1&gt;/dev/null |&quot;); # or with an open pipe
while (&lt;PH&gt;) { } # plus a read</p>

<p>To exchange a command s STDOUT and STDERR in order to
capture the STDERR but leave its STDOUT to come out our old
STDERR:</p>

<p>$output = &lsquo;cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3
3&gt;&amp;-&lsquo;; # either with backticks $pid = open(PH,
&quot;cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3
3&gt;&amp;-|&quot;);# or with an open pipe while
(&lt;PH&gt;) { } # plus a read</p>

<p>To read both a commands STDOUT and its STDERR
separately, its easiest to redirect them separately to
files, and then read from those files when the program is
done:</p>

<p>system(&quot;program args 1&gt;program.stdout
2&gt;program.stderr&quot;);</p>

<p>Ordering is important in all these examples. That s
because the shell processes file descriptor redirections in
strictly left to right order.</p>

<p>system(&quot;prog args 1&gt;tmpfile 2&gt;&amp;1&quot;);
system(&quot;prog args 2&gt;&amp;1 1&gt;tmpfile&quot;);</p>

<p>The first command sends both standard out and standard
error to the temporary file. The second command sends only
the old standard output there, and the old standard error
shows up on the old standard out.</p>

<p>Why doest open() return an error when a pipe open fails?
If the second argument to a piped open() contains shell
metacharacters, perl fork()s, then exec()s a shell to decode
the metacharacters and eventually run the desired program.
If the program couldn t be run, its the shell that gets the
message, not Perl. All your Perl program can find out is
whether the shell itself could be successfully started. You
can still capture the shells STDERR and check it for error
messages. See &quot;How can I capture STDERR from an
external command?&quot; elsewhere in this document, or use
the IPC::Open3 module.</p>

<p>If there are no shell metacharacters in the argument of
open(), Perl runs the command directly, without using the
shell, and can correctly report whether the command
started.</p>

<p>Whas wrong with using backticks in a void context?
Strictly speaking, nothing. Stylistically speaking, its not
a good way to write maintainable code. Perl has several
operators for running external commands. Backticks are one;
they collect the output from the command for use in your
program. The &quot;system&quot; function is another; it
doesnt do this.</p>

<p>Writing backticks in your program sends a clear message
to the readers of your code that you wanted to collect the
output of the command. Why send a clear message that isnt
true?</p>

<p>Consider this line:</p>

<p>&lsquo;cat /etc/termcap&lsquo;;</p>

<p>You forgot to check $? to see whether the program even
ran correctly. Even if you wrote</p>

<p>print &lsquo;cat /etc/termcap&lsquo;;</p>

<p>this code could and probably should be written as</p>

<p>system(&quot;cat /etc/termcap&quot;) == 0 or die
&quot;cat program failed!&quot;;</p>

<p>which will echo the cat command s output as it is
generated, instead of waiting until the program has
completed to print it out. It also checks the return
value.</p>

<p>&quot;system&quot; also provides direct control over
whether shell wildcard processing may take place, whereas
backticks do not.</p>

<p>How can I call backticks without shell processing? This
is a bit tricky. You cant simply write the command like
this:</p>

<p>@ok = &lsquo;grep @opts &rsquo;$search_string&rsquo;
@filenames&lsquo;;</p>

<p>As of Perl 5.8.0, you can use &quot;open()&quot; with
multiple arguments. Just like the list forms of
&quot;system()&quot; and &quot;exec()&quot;, no shell
escapes happen.</p>

<p>open( GREP, &quot;-|&quot;, &rsquo;grep&rsquo;, @opts,
$search_string, @filenames ); chomp(@ok = &lt;GREP&gt;);
close GREP;</p>

<p>You can also:</p>

<p>my @ok = (); if (open(GREP, &quot;-|&quot;)) { while
(&lt;GREP&gt;) { chomp; push(@ok, $_); } close GREP; } else
{ exec &rsquo;grep&rsquo;, @opts, $search_string,
@filenames; }</p>

<p>Just as with &quot;system()&quot;, no shell escapes
happen when you &quot;exec()&quot; a list. Further examples
of this can be found in &quot;Safe Pipe Opens&quot; in
perlipc.</p>

<p>Note that if youre using Windows, no solution to this
vexing issue is even possible. Even if Perl were to emulate
&quot;fork()&quot;, you d still be stuck, because Windows
does not have an argc/argv-style API.</p>

<p>Why cant my script read from STDIN after I gave it EOF
(^D on Unix, ^Z on MS-DOS)? Some stdios set error and eof
flags that need clearing. The POSIX module defines
clearerr() that you can use. That is the technically correct
way to do it. Here are some less reliable workarounds:</p>

<p>1. Try keeping around the seekpointer and go there, like
this:</p>

<p>$where = tell(LOG); seek(LOG, $where, 0);</p>

<p>2. If that doesnt work, try seeking to a different part
of the file and then back.</p>

<p>3. If that doesnt work, try seeking to a different part
of the file, reading something, and then seeking back.</p>

<p>4. If that doesnt work, give up on your stdio package
and use sysread.</p>

<p>How can I convert my shell script to perl? Learn Perl
and rewrite it. Seriously, theres no simple converter.
Things that are awkward to do in the shell are easy to do in
Perl, and this very awkwardness is what would make a
shell-&gt;perl converter nigh- on impossible to write. By
rewriting it, you ll think about what you re really trying
to do, and hopefully will escape the shells pipeline
datastream paradigm, which while convenient for some
matters, causes many inefficiencies.</p>

<p>Can I use perl to run a telnet or ftp session? Try the
Net::FTP, TCP::Client, and Net::Telnet modules (available
from CPAN).
http://www.cpan.org/scripts/netstuff/telnet.emul.shar will
also help for emulating the telnet protocol, but Net::Telnet
is quite probably easier to use..</p>

<p>If all you want to do is pretend to be telnet but don t
need the initial telnet handshaking, then the standard
dual-process approach will suffice:</p>

<p>use IO::Socket; # new in 5.004 $handle =
IO::Socket::INET-&gt;new(&rsquo;www.perl.com:80&rsquo;) or
die &quot;can&rsquo;t connect to port 80 on www.perl.com:
$!&quot;; $handle-&gt;autoflush(1); if (fork()) { # XXX:
undef means failure select($handle); print while
&lt;STDIN&gt;; # everything from stdin to socket } else {
print while &lt;$handle&gt;; # everything from socket to
stdout } close $handle; exit;</p>

<p>How can I write expect in Perl? Once upon a time, there
was a library called chat2.pl (part of the standard perl
distribution), which never really got finished. If you find
it somewhere, dont use it. These days, your best bet is to
look at the Expect module available from CPAN, which also
requires two other modules from CPAN, IO::Pty and
IO::Stty.</p>

<p>Is there a way to hide pers command line from programs
such as &quot;ps&quot;? First of all note that if youre
doing this for security reasons (to avoid people seeing
passwords, for example) then you should rewrite your program
so that critical information is never given as an argument.
Hiding the arguments wont make your program completely
secure.</p>

<p>To actually alter the visible command line, you can
assign to the variable $0 as documented in perlvar. This
wont work on all operating systems, though. Daemon programs
like sendmail place their state there, as in:</p>

<p>$0 = &quot;orcus [accepting connections]&quot;;</p>

<p>I {changed directory, modified my environment} in a perl
script. How come the change disappeared when I exited the
script? How do I get my changes to be visible? Unix In the
strictest sense, it cant be done--the script executes as a
different process from the shell it was started from.
Changes to a process are not reflected in its parent--only
in any children created after the change. There is shell
magic that may allow you to fake it by eval()ing the scripts
output in your shell; check out the comp.unix.questions FAQ
for details.</p>

<p>How do I close a process filehandle without waiting for
it to complete? Assuming your system supports such things,
just send an appropriate signal to the process (see
&quot;kill&quot; in perlfunc). It s common to first send a
TERM signal, wait a little bit, and then send a KILL signal
to finish it off.</p>

<p>How do I fork a daemon process? If by daemon process you
mean one that s detached (disassociated from its tty), then
the following process is reported to work on most Unixish
systems. Non-Unix users should check their Your_OS::Process
module for other solutions.</p>

<p>&middot; Open /dev/tty and use the TIOCNOTTY ioctl on
it. See tty for details. Or better yet, you can just use the
POSIX::setsid() function, so you don t have to worry about
process groups.</p>

<p>&middot; Change directory to /</p>

<p>&middot; Reopen STDIN, STDOUT, and STDERR so they re not
connected to the old tty.</p>

<p>&middot; Background yourself like this:</p>

<p>fork &amp;&amp; exit;</p>

<p>The Proc::Daemon module, available from CPAN, provides a
function to perform these actions for you.</p>

<p>How do I find out if m running interactively or not?
Good question. Sometimes &quot;-t STDIN&quot; and &quot;-t
STDOUT&quot; can give clues, sometimes not.</p>

<p>if (-t STDIN &amp;&amp; -t STDOUT) { print &quot;Now
what? &quot;; }</p>

<p>On POSIX systems, you can test whether your own process
group matches the current process group of your controlling
terminal as follows:</p>

<p>use POSIX qw/getpgrp tcgetpgrp/;</p>

<p># Some POSIX systems, such as Linux, can be # without a
/dev/tty at boot time. if (!open(TTY, &quot;/dev/tty&quot;))
{ print &quot;no tty0; } else { $tpgrp =
tcgetpgrp(fileno(*TTY)); $pgrp = getpgrp(); if ($tpgrp ==
$pgrp) { print &quot;foreground0; } else { print
&quot;background0; } }</p>

<p>How do I timeout a slow event? Use the alarm() function,
probably in conjunction with a signal handler, as documented
in &quot;Signals&quot; in perlipc and the section on
&quot;Signals&quot; in the Camel. You may instead use the
more flexible Sys::AlarmCall module available from CPAN.</p>

<p>The alarm() function is not implemented on all versions
of Windows. Check the documentation for your specific
version of Perl.</p>

<p>How do I set CPU limits? (contributed by Xho)</p>

<p>Use the &quot;BSD::Resource&quot; module from CPAN. As
an example:</p>

<p>use BSD::Resource; setrlimit(RLIMIT_CPU,10,20) or die
$!;</p>

<p>This sets the soft and hard limits to 10 and 20 seconds,
respectively. After 10 seconds of time spent running on the
CPU (not &quot;wall&quot; time), the process will be sent a
signal (XCPU on some systems) which, if not trapped, will
cause the process to terminate. If that signal is trapped,
then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.</p>

<p>See the &quot;BSD::Resource&quot; and your systems
documentation for the gory details.</p>

<p>How do I avoid zombies on a Unix system? Use the reaper
code from &quot;Signals&quot; in perlipc to call wait() when
a SIGCHLD is received, or else use the double-fork technique
described in &quot;How do I start a process in the
background?&quot; in perlfaq8.</p>

<p>How do I use an SQL database? The DBI module provides an
abstract interface to most database servers and types,
including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and
flat files. The DBI module accesses each database type
through a database driver, or DBD. You can see a complete
list of available drivers on CPAN:
http://www.cpan.org/modules/by-module/DBD/ . You can read
more about DBI on http://dbi.perl.org .</p>

<p>Other modules provide more specific access: Win32::ODBC,
Alzabo, iodbc, and others found on CPAN Search:
http://search.cpan.org .</p>

<p>How do I make a system() exit on control-C? You cant.
You need to imitate the system() call (see perlipc for
sample code) and then have a signal handler for the INT
signal that passes the signal on to the subprocess. Or you
can check for it:</p>

<p>$rc = system($cmd); if ($rc &amp; 127) { die
&quot;signal death&quot; }</p>

<p>How do I open a file without blocking? If you re lucky
enough to be using a system that supports non-blocking reads
(most Unixish systems do), you need only to use the O_NDELAY
or O_NONBLOCK flag from the Fcntl module in conjunction with
sysopen():</p>

<p>use Fcntl; sysopen(FH, &quot;/foo/somefile&quot;,
O_WRONLY|O_NDELAY|O_CREAT, 0644) or die &quot;can&rsquo;t
open /foo/somefile: $!&quot;:</p>

<p>How do I tell the difference between errors from the
shell and perl? (answer contributed by brian d foy)</p>

<p>When you run a Perl script, something else is running
the script for you, and that something else may output error
messages. The script might emit its own warnings and error
messages. Most of the time you cannot tell who said
what.</p>

<p>You probably cannot fix the thing that runs perl, but
you can change how perl outputs its warnings by defining a
custom warning and die functions.</p>

<p>Consider this script, which has an error you may not
notice immediately.</p>

<p>#!/usr/locl/bin/perl</p>

<p>print &quot;Hello World0;</p>

<p>I get an error when I run this from my shell (which
happens to be bash). That may look like perl forgot it has a
print() function, but my shebang line is not the path to
perl, so the shell runs the script, and I get the error.</p>

<p>$ ./test ./test: line 3: print: command not found</p>

<p>A quick and dirty fix involves a little bit of code, but
this may be all you need to figure out the problem.</p>

<p>#!/usr/bin/perl -w</p>

<p>BEGIN { $SIG{__WARN__} = sub{ print STDERR &quot;Perl:
&quot;, @_; }; $SIG{__DIE__} = sub{ print STDERR &quot;Perl:
&quot;, @_; exit 1}; }</p>

<p>$a = 1 + undef; $x / 0; __END__</p>

<p>The perl message comes out with &quot;Perl&quot; in
front. The BEGIN block works at compile time so all of the
compilation errors and warnings get the &quot;Perl:&quot;
prefix too.</p>

<p>Perl: Useless use of division (/) in void context at
./test line 9. Perl: Name &quot;main::a&quot; used only
once: possible typo at ./test line 8. Perl: Name
&quot;main::x&quot; used only once: possible typo at ./test
line 9. Perl: Use of uninitialized value in addition (+) at
./test line 8. Perl: Use of uninitialized value in division
(/) at ./test line 9. Perl: Illegal division by zero at
./test line 9. Perl: Illegal division by zero at -e line
3.</p>

<p>If I dont see that &quot;Perl:&quot;, its not from
perl.</p>

<p>You could also just know all the perl errors, and
although there are some people who may know all of them, you
probably don t. However, they all should be in the perldiag
manpage. If you dont find the error in there, it probably
isnt a perl error.</p>

<p>Looking up every message is not the easiest way, so let
perl to do it for you. Use the diagnostics pragma with turns
perls normal messages into longer discussions on the
topic.</p>

<p>use diagnostics;</p>

<p>If you dont get a paragraph or two of expanded
discussion, it might not be perls message.</p>

<p>How do I install a module from CPAN? The easiest way is
to have a module also named CPAN do it for you. This module
comes with perl version 5.004 and later.</p>

<p>$ perl -MCPAN -e shell</p>

<p>cpan shell -- CPAN exploration and modules installation
(v1.59_54) ReadLine support enabled</p>

<p>cpan&gt; install Some::Module</p>

<p>To manually install the CPAN module, or any well-behaved
CPAN module for that matter, follow these steps:</p>

<p>1. Unpack the source into a temporary area.</p>

<p>2. perl Makefile.PL</p>

<p>3. make</p>

<p>4. make test</p>

<p>5. make install</p>

<p>If your version of perl is compiled without dynamic
loading, then you just need to replace step 3 (make) with
make perl and you will get a new perl binary with your
extension linked in.</p>

<p>See ExtUtils::MakeMaker for more details on building
extensions. See also the next question, &quot;What s the
difference between require and use?&quot;.</p>

<p>Whas the difference between require and use?
(contributed by brian d foy)</p>

<p>Perl runs &quot;require&quot; statement at run-time.
Once Perl loads, compiles, and runs the file, it doesnt do
anything else. The &quot;use&quot; statement is the same as
a &quot;require&quot; run at compile-time, but Perl also
calls the &quot;import&quot; method for the loaded package.
These two are the same:</p>

<p>use MODULE qw(import list);</p>

<p>BEGIN { require MODULE; MODULE-&gt;import(import list);
}</p>

<p>However, you can suppress the &quot;import&quot; by
using an explicit, empty import list. Both of these still
happen at compile-time:</p>

<p>use MODULE ();</p>

<p>BEGIN { require MODULE; }</p>

<p>Since &quot;use&quot; will also call the
&quot;import&quot; method, the actual value for
&quot;MODULE&quot; must be a bareword. That is,
&quot;use&quot; cannot load files by name, although
&quot;require&quot; can:</p>

<p>require &quot;$ENV{HOME}/lib/Foo.pm&quot;; # no @INC
searching!</p>

<p>See the entry for &quot;use&quot; in perlfunc for more
details.</p>

<p>How do I keep my own module/library directory? When you
build modules, tell Perl where to install the modules.</p>

<p>For &quot;Makefile.PL&quot;-based distributions, use the
INSTALL_BASE option when generating Makefiles:</p>

<p>perl Makefile.PL INSTALL_BASE=/mydir/perl</p>

<p>You can set this in your CPAN.pm configuration so
modules automatically install in your private library
directory when you use the CPAN.pm shell:</p>

<p>% cpan cpan&gt; o conf makepl_arg
INSTALL_BASE=/mydir/perl cpan&gt; o conf commit</p>

<p>For &quot;Build.PL&quot;-based distributions, use the
--install_base option:</p>

<p>perl Build.PL --install_base /mydir/perl</p>

<p>You can configure CPAN.pm to automatically use this
option too:</p>

<p>% cpan cpan&gt; o conf mbuild_arg --install_base
/mydir/perl cpan&gt; o conf commit</p>

<p>INSTALL_BASE tells these tools to put your modules into
/mydir/perl/lib/perl5. See &quot;How do I add a directory to
my include path (@INC) at runtime?&quot; for details on how
to run your newly installed moudles.</p>

<p>There is one caveat with INSTALL_BASE, though, since it
acts differently than the PREFIX and LIB settings that older
versions of ExtUtils::MakeMaker advocated. INSTALL_BASE does
not support installing modules for multiple versions of Perl
or different architectures under the same directory. You
should consider if you really want that , and if you do, use
the older PREFIX and LIB settings. See the
ExtUtils::Makemaker documentation for more details.</p>

<p>How do I add the directory my program lives in to the
module/library search path? (contributed by brian d foy)</p>

<p>If you know the directory already, you can add it to
@INC as you would for any other directory. You might &lt;use
lib&gt; if you know the directory at compile time:</p>

<p>use lib $directory;</p>

<p>The trick in this task is to find the directory. Before
your script does anything else (such as a
&quot;chdir&quot;), you can get the current working
directory with the &quot;Cwd&quot; module, which comes with
Perl:</p>

<p>BEGIN { use Cwd; our $directory = cwd; }</p>

<p>use lib $directory;</p>

<p>You can do a similar thing with the value of $0, which
holds the script name. That might hold a relative path, but
&quot;rel2abs&quot; can turn it into an absolute path. Once
you have the</p>

<p>BEGIN { use File::Spec::Functions qw(rel2abs); use
File::Basename qw(dirname);</p>

<p>my $path = rel2abs( $0 ); our $directory = dirname(
$path ); }</p>

<p>use lib $directory;</p>

<p>The &quot;FindBin&quot; module, which comes with Perl,
might work. It finds the directory of the currently running
script and puts it in $Bin, which you can then use to
construct the right library path:</p>

<p>use FindBin qw($Bin);</p>

<p>How do I add a directory to my include path (@INC) at
runtime? Here are the suggested ways of modifying your
include path, including environment variables, run-time
switches, and in-code statements:</p>

<p>the PERLLIB environment variable $ export
PERLLIB=/path/to/my/dir $ perl program.pl</p>

<p>the PERL5LIB environment variable $ export
PERL5LIB=/path/to/my/dir $ perl program.pl</p>

<p>the perl -Idir command line flag $ perl
-I/path/to/my/dir program.pl</p>

<p>the use lib pragma: use lib
&quot;$ENV{HOME}/myown_perllib&quot;;</p>

<p>The last is particularly useful because it knows about
machine dependent architectures. The lib.pm pragmatic module
was first included with the 5.002 release of Perl.</p>

<p>What is socket.ph and where do I get it? Its a Perl 4
style file defining values for system networking constants.
Sometimes it is built using h2ph when Perl is installed, but
other times it is not. Modern programs &quot;use
Socket;&quot; instead.</p>

<p>REVISION Revision: $Revision$</p>

<p>Date: $Date$</p>

<p>See perlfaq for source control details and
availability.</p>

<p>AUTHOR AND COPYRIGHT Copyright (c) 1997-2009 Tom
Christiansen, Nathan Torkington, and other authors as noted.
All rights reserved.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
this file are hereby placed into the public domain. You are
permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>perl v5.10.1 2009-08-15 PERLFAQ8(1)</p>
<hr>
</body>
</html>
