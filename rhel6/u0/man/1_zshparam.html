<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:30:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ZSHPARAM(1) ZSHPARAM(1)</p>

<p>NAME zshparam - zsh parameters</p>

<p>DESCRIPTION A parameter has a name, a value, and a
number of attributes. A name may be any sequence of
alphanumeric characters and underscores, or the single
characters *, @, #, ?, -, $, or !. The value may be a scalar
(a string), an integer, an array (indexed numerically), or
an associative array (an unordered set of name-value pairs,
indexed by name). To declare the type of a parameter, or to
assign a scalar or integer value to a parameter, use the
typeset builtin.</p>

<p>The value of a scalar or integer parameter may also be
assigned by writing:</p>

<p>name=value</p>

<p>If the integer attribute, -i, is set for name, the value
is subject to arithmetic evaluation. Furthermore, by
replacing = with +=, a parameter can be added or appended
to. See the section Array Parame- ters for additional forms
of assignment.</p>

<p>To refer to the value of a parameter, write $name or
${name}. See Parameter Expansion in zshexpn(1) for complete
details.</p>

<p>In the parameter lists that follow, the mark &lt;S&gt;
indicates that the parameter is special. Special parameters
cannot have their type changed or their readonly attribute
turned off, and if a special param- eter is unset, then
later recreated, the special properties will be retained.
&lt;Z&gt; indicates that the parameter does not exist when
the shell initializes in sh or ksh emulation mode.</p>

<p>ARRAY PARAMETERS To assign an array value, write one
of:</p>

<p>set -A name value ... name=(value ...)</p>

<p>If no parameter name exists, an ordinary array parameter
is created. If the parameter name exists and is a scalar, it
is replaced by a new array. Ordinary array parameters may
also be explicitly declared with:</p>

<p>typeset -a name</p>

<p>Associative arrays must be declared before assignment,
by using:</p>

<p>typeset -A name</p>

<p>When name refers to an associative array, the list in an
assignment is interpreted as alternating keys and
values:</p>

<p>set -A name key value ... name=(key value ...)</p>

<p>Every key must have a value in this case. Note that this
assigns to the entire array, deleting any elements that do
not appear in the list.</p>

<p>To create an empty array (including associative arrays),
use one of:</p>

<p>set -A name name=()</p>

<p>Array Subscripts Individual elements of an array may be
selected using a subscript. A subscript of the form [exp]
selects the single element exp, where exp is an arithmetic
expression which will be subject to arithmetic expan- sion
as if it were surrounded by $((...)). The elements are
numbered beginning with 1, unless the KSH_ARRAYS option is
set in which case they are numbered from zero.</p>

<p>Subscripts may be used inside braces used to delimit a
parameter name, thus ${foo[2]} is equivalent to $foo[2] . If
the KSH_ARRAYS option is set, the braced form is the only
one that works, as bracketed expressions otherwise are not
treated as subscripts.</p>

<p>If the KSH_ARRAYS option is not set, then by default
accesses to an array element with a subscript that evaluates
to zero return an empty string, while an attempt to write
such an element is treated as an error. For backward
compatibility the KSH_ZERO_SUBSCRIPT option can be set to
cause subscript values 0 and 1 to be equivalent; see the
description of the option in zshoptions(1).</p>

<p>The same subscripting syntax is used for associative
arrays, except that no arithmetic expansion is applied to
exp. However, the parsing rules for arithmetic expressions
still apply, which affects the way that certain special
characters must be protected from interpretation. See
Subscript Parsing below for details.</p>

<p>A subscript of the form [*] or [@] evaluates to all
elements of an array; there is no difference between the two
except when they appear within double quotes.
&quot;$foo[*]&quot; evaluates to &quot;$foo[1] $foo[2]
...&quot; , whereas &quot;$foo[@]&quot; evaluates to
&quot;$foo[1]&quot; &quot;$foo[2]&quot; .... For associative
arrays, [*] or [@] evaluate to all the values, in no
particular order. Note that this does not substitute the
keys; see the documentation for the k flag under Parameter
Expansion Flags in zsh- expn(1) for complete details. When
an array parameter is referenced as $name (with no
subscript) it evaluates to $name[*] , unless the KSH_ARRAYS
option is set in which case it evaluates to ${name[0]} (for
an associative array, this means the value of the key 0,
which may not exist even if there are values for other
keys).</p>

<p>A subscript of the form [exp1,exp2] selects all elements
in the range exp1 to exp2, inclusive. (Associative arrays
are unordered, and so do not support ranges.) If one of the
subscripts evaluates to a negative number, say -n, then the
nth element from the end of the array is used. Thus $foo[-3]
is the third element from the end of the array foo, and
$foo[1,-1] is the same as $foo[*].</p>

<p>Subscripting may also be performed on non-array values,
in which case the subscripts specify a substring to be
extracted. For example, if FOO is set to foobar, then echo
$FOO[2,5] prints ooba.</p>

<p>Array Element Assignment A subscript may be used on the
left side of an assignment like so:</p>

<p>name[exp]=value</p>

<p>In this form of assignment the element or range
specified by exp is replaced by the expression on the right
side. An array (but not an associative array) may be created
by assignment to a range or element. Arrays do not nest, so
assigning a parenthesized list of values to an element or
range changes the number of elements in the array, shifting
the other elements to accommodate the new values. (This is
not sup- ported for associative arrays.)</p>

<p>This syntax also works as an argument to the typeset
command:</p>

<p>typeset &quot;name[exp]&quot;=value</p>

<p>The value may not be a parenthesized list in this case;
only sin- gle-element assignments may be made with typeset.
Note that quotes are necessary in this case to prevent the
brackets from being interpreted as filename generation
operators. The noglob precommand modifier could be used
instead.</p>

<p>To delete an element of an ordinary array, assign () to
that element. To delete an element of an associative array,
use the unset command:</p>

<p>unset &quot;name[exp]&quot;</p>

<p>Subscript Flags If the opening bracket, or the comma in
a range, in any subscript expression is directly followed by
an opening parenthesis, the string up to the matching
closing one is considered to be a list of flags, as in
name[(flags)exp].</p>

<p>The flags s, n and b take an argument; the delimiter is
shown below as :, but any character, or the matching pairs
(...), {...}, [...], or &lt;...&gt;, may be used.</p>

<p>The flags currently understood are:</p>

<p>w If the parameter subscripted is a scalar then this
flag makes subscripting work on words instead of characters.
The default word separator is whitespace. This flag may not
be used with the i or I flag.</p>

<p>s:string: This gives the string that separates words
(for use with the w flag). The delimiter character : is
arbitrary; see above.</p>

<p>p Recognize the same escape sequences as the print
builtin in the string argument of a subsequent s flag.</p>

<p>f If the parameter subscripted is a scalar then this
flag makes subscripting work on lines instead of characters,
i.e. with ele- ments separated by newlines. This is a
shorthand for pwsn:.</p>

<p>r Reverse subscripting: if this flag is given, the exp
is taken as a pattern and the result is the first matching
array element, substring or word (if the parameter is an
array, if it is a scalar, or if it is a scalar and the w
flag is given, respec- tively). The subscript used is the
number of the matching ele- ment, so that pairs of
subscripts such as $foo[(r)??,3] and $foo[(r)??,(r)f*] are
possible if the parameter is not an associative array. If
the parameter is an associative array, only the value part
of each pair is compared to the pattern, and the result is
that value.</p>

<p>If a search through an ordinary array failed, the search
sets the subscript to one past the end of the array, and
hence ${array[(r)pattern]} will substitute the empty string.
Thus the success of a search can be tested by using the (i)
flag, for example (assuming the option KSH_ARRAYS is not in
effect):</p>

<p>[[ ${array[(i)pattern]} -le ${#array} ]]</p>

<p>If KSH_ARRAYS is in effect, the -le should be replaced
by -lt.</p>

<p>R Like r, but gives the last match. For associative
arrays, gives all possible matches. May be used for
assigning to ordinary array elements, but not for assign-
ing to associative arrays. On failure, for normal arrays
this has the effect of returning the element correspond- ing
to subscript 0; this is empty unless one of the options
KSH_ARRAYS or KSH_ZERO_SUBSCRIPT is in effect.</p>

<p>Note that in subscripts with both r and R pattern
characters are active even if they were substituted for a
parameter (regardless of the setting of GLOB_SUBST which
controls this feature in normal pattern matching). The flag
e can be added to inhibit pattern matching. As this flag
does not inhibit other forms of substitution, care is still
required; using a parameter to hold the key has the desired
effect:</p>

<p>key2original key print ${array[(Re)$key2]}</p>

<p>i Like r, but gives the index of the match instead; this
may not be combined with a second argument. On the left side
of an assignment, behaves like r . For associative arrays,
the key part of each pair is compared to the pattern, and
the first matching key found is the result. On failure
substitutes the length of the array plus one, as discussed
under the description of r, or the empty string for an
associative array.</p>

<p>I Like i, but gives the index of the last match, or all
possible matching keys in an associative array. On failure
substitutes 0, or the empty string for an associative array.
This flag is best when testing for values or keys that do
not exist.</p>

<p>k If used in a subscript on an associative array, this
flag causes the keys to be interpreted as patterns, and
returns the value for the first key found where exp is
matched by the key. Note this could be any such key as no
ordering of associative arrays is defined. This flag does
not work on the left side of an assignment to an associative
array element. If used on another type of parameter, this
behaves like r.</p>

<p>K On an associative array this is like k but returns all
values where exp is matched by the keys. On other types of
parameters this has the same effect as R.</p>

<p>n:expr: If combined with r, R, i or I, makes them give
the nth or nth last match (if expr evaluates to n). This
flag is ignored when the array is associative. The delimiter
character : is arbitrary; see above.</p>

<p>b:expr: If combined with r, R, i or I, makes them begin
at the nth or nth last element, word, or character (if expr
evaluates to n). This flag is ignored when the array is
associative. The delimiter character : is arbitrary; see
above.</p>

<p>e This flag causes any pattern matching that would be
performed on the subscript to use plain string matching
instead. Hence ${array[(re)*]} matches only the array
element whose value is *. Note that other forms of
substitution such as parameter sub- stitution are not
inhibited.</p>

<p>This flag can also be used to force * or @ to be
interpreted as a single key rather than as a reference to
all values. It may be used for either purpose on the left
side of an assignment.</p>

<p>See Parameter Expansion Flags (zshexpn(1)) for
additional ways to manipulate the results of array
subscripting.</p>

<p>Subscript Parsing This discussion applies mainly to
associative array key strings and to patterns used for
reverse subscripting (the r, R, i, etc. flags), but it may
also affect parameter substitutions that appear as part of
an arithmetic expression in an ordinary subscript.</p>

<p>It is possible to avoid the use of subscripts in
assignments to asso- ciative array elements by using the
syntax:</p>

<p>aa+=key with &quot;*strange*&quot; charactervalue
strin)</p>

<p>This adds a new key/value pair if the key is not already
present, and replaces the value for the existing key if it
is.</p>

<p>The basic rule to remember when writing a subscript
expression is that all text between the opening [ and the
closing ] is interpreted as if it were in double quotes (see
zshmisc(1)). However, unlike double quotes which normally
cannot nest, subscript expressions may appear inside
double-quoted strings or inside other subscript expressions
(or both!), so the rules have two important differences.</p>

<p>The first difference is that brackets ( [ and ] ) must
appear as bal- anced pairs in a subscript expression unless
they are preceded by a backslash ). Therefore, within a
subscript expression (and unlike true double-quoting) the
sequence [ becomes [, and similarly] becomes ]. This applies
even in cases where a backslash is not nor- mally required;
for example, the pattern [^[] (to match any character other
than an open bracket) should be written [[] in a
reverse-sub- script pattern. However, note that[] and
even[^[] mean the same thing, because backslashes are always
stripped when they appear before brackets!</p>

<p>The same rule applies to parentheses (( and )) and
braces ({ and }): they must appear either in balanced pairs
or preceded by a back- slash, and backslashes that protect
parentheses or braces are removed during parsing. This is
because parameter expansions may be surrounded by balanced
braces, and subscript flags are introduced by balanced
parentheses.</p>

<p>The second difference is that a double-quote ( &quot; )
may appear as part of a subscript expression without being
preceded by a backslash, and therefore that the two
characters subscript (in true double-quoting, of the
standard shell quoting rules, any double-quotes that appear
must occur in balanced pairs unless preceded by a backslash.
This makes it more difficult to write a subscript expression
that contains an odd number of double-quote characters, but
the reason for this difference is so that when a subscript
expression appears inside true dou- ble-quotes, one can
still write</p>

<p>To use an odd number of double quotes as a key in an
assignment, use the typeset builtin and an enclosing pair of
double quotes; to refer to the value of that key, again use
double quotes:</p>

<p>typeset -A aa typeset &quot;aa[one print
&quot;$aa[one</p>

<p>It is important to note that the quoting rules do not
change when a parameter expansion with a subscript is nested
inside another subscript expression. That is, it is not
necessary to use additional backslashes within the inner
subscript expression; they are removed only once, from the
innermost subscript outwards. Parameters are also expanded
from the innermost subscript first, as each expansion is
encountered left to right in the outer expression.</p>

<p>A further complication arises from a way in which
subscript parsing is not different from double quote
parsing. As in true double-quoting, the sequences *, and@
remain as two characters when they appear in a subscript
expression. To use a literal * or @ as an associa- tive
array key, the e flag must be used:</p>

<p>typeset -A aa aa[(e)*]=star print $aa[(e)*]</p>

<p>A last detail must be considered when reverse
subscripting is per- formed. Parameters appearing in the
subscript expression are first expanded and then the
complete expression is interpreted as a pattern. This has
two effects: first, parameters behave as if GLOB_SUBST were
on (and it cannot be turned off); second, backslashes are
interpreted twice, once when parsing the array subscript and
again when parsing the pattern. In a reverse subscript, its
necessary to use four back- slashes to cause a single
backslash to match literally in the pattern. For complex
patterns, it is often easiest to assign the desired pattern
to a parameter and then refer to that parameter in the
subscript, because then the backslashes, brackets,
parentheses, etc., are seen only when the complete
expression is converted to a pattern. To match the value of
a parameter literally in a reverse subscript, rather than as
a pattern, use ${(q)name} (see zshexpn(1)) to quote the
expanded value.</p>

<p>Note that the k and K flags are reverse subscripting for
an ordi- nary array, but are not reverse subscripting for an
associative array! (For an associative array, the keys in
the array itself are interpreted as patterns by those flags;
the subscript is a plain string in that case.)</p>

<p>One final note, not directly related to subscripting:
the numeric names of positional parameters (described below)
are parsed specially, so for example $2foo is equivalent to
${2}foo. Therefore, to use sub- script syntax to extract a
substring from a positional parameter, the expansion must be
surrounded by braces; for example, ${2[3,5]} evalu- ates to
the third through fifth characters of the second positional
parameter, but $2[3,5] is the entire second parameter
concatenated with the filename generation pattern [3,5].</p>

<p>POSITIONAL PARAMETERS The positional parameters provide
access to the command-line arguments of a shell function,
shell script, or the shell itself; see the section
Invocation, and also the section Functions. The parameter n,
where n is a number, is the nth positional parameter. The
parameters *, @ and argv are arrays containing all the
positional parameters; thus $argv[n], etc., is equivalent to
simply $n.</p>

<p>Positional parameters may be changed after the shell or
function starts by using the set builtin, by assigning to
the argv array, or by direct assignment of the form n=value
where n is the number of the posi- tional parameter to be
changed. This also creates (with empty values) any of the
positions from 1 to n that do not already have values. Note
that, because the positional parameters form an array, an
array assign- ment of the form n=(value ...) is allowed, and
has the effect of shifting all the values at positions
greater than n by as many posi- tions as necessary to
accommodate the new values.</p>

<p>LOCAL PARAMETERS Shell function executions delimit
scopes for shell parameters. (Param- eters are dynamically
scoped.) The typeset builtin, and its alternative forms
declare, integer, local and readonly (but not export), can
be used to declare a parameter as being local to the
innermost scope.</p>

<p>When a parameter is read or assigned to, the innermost
existing parame- ter of that name is used. (That is, the
local parameter hides any less-local parameter.) However,
assigning to a non-existent parameter, or declaring a new
parameter with export, causes it to be created in the
outermost scope.</p>

<p>Local parameters disappear when their scope ends. unset
can be used to delete a parameter while it is still in
scope; any outer parameter of the same name remains
hidden.</p>

<p>Special parameters may also be made local; they retain
their special attributes unless either the existing or the
newly-created parameter has the -h (hide) attribute. This
may have unexpected effects: there is no default value, so
if there is no assignment at the point the variable is made
local, it will be set to an empty value (or zero in the case
of integers). The following:</p>

<p>typeset PATH=/new/directory:$PATH</p>

<p>is valid for temporarily allowing the shell or
programmes called from it to find the programs in
/new/directory inside a function.</p>

<p>Note that the restriction in older versions of zsh that
local parame- ters were never exported has been removed.</p>

<p>PARAMETERS SET BY THE SHELL The following parameters are
automatically set by the shell:</p>

<p>! &lt;S&gt; The process ID of the last command started
in the background with &amp;, or put into the background
with the bg builtin.</p>

<p># &lt;S&gt; The number of positional parameters in
decimal. Note that some confusion may occur with the syntax
$#param which substitutes the length of param. Use ${#} to
resolve ambiguities. In par- ticular, the sequence $#-... in
an arithmetic expression is interpreted as the length of the
parameter -, q.v.</p>

<p>ARGC &lt;S&gt; &lt;Z&gt; Same as #.</p>

<p>$ &lt;S&gt; The process ID of this shell. Note that this
indicates the original shell started by invoking zsh; all
processes forked from the shells without executing a new
program, such as sub- shells started by (...), substitute
the same value.</p>

<p>- &lt;S&gt; Flags supplied to the shell on invocation or
by the set or setopt commands.</p>

<p>* &lt;S&gt; An array containing the positional
parameters.</p>

<p>argv &lt;S&gt; &lt;Z&gt; Same as *. Assigning to argv
changes the local positional parameters, but argv is not
itself a local parameter. Deleting argv with unset in any
function deletes it everywhere, although only the innermost
positional parameter array is deleted (so * and @ in other
scopes are not affected).</p>

<p>@ &lt;S&gt; Same as argv[@], even when argv is not
set.</p>

<p>? &lt;S&gt; The exit status returned by the last
command.</p>

<p>0 &lt;S&gt; The name used to invoke the current shell.
If the FUNC- TION_ARGZERO option is set, this is set
temporarily within a shell function to the name of the
function, and within a sourced script to the name of the
script.</p>

<p>status &lt;S&gt; &lt;Z&gt; Same as ?.</p>

<p>pipestatus &lt;S&gt; &lt;Z&gt; An array containing the
exit statuses returned by all commands in the last
pipeline.</p>

<p>_ &lt;S&gt; The last argument of the previous command.
Also, this parameter is set in the environment of every
command executed to the full pathname of the command.</p>

<p>CPUTYPE The machine type (microprocessor class or
machine model), as determined at run time.</p>

<p>EGID &lt;S&gt; The effective group ID of the shell
process. If you have suffi- cient privileges, you may change
the effective group ID of the shell process by assigning to
this parameter. Also (assuming sufficient privileges), you
may start a single command with a different effective group
ID by (EGID=gid; command)</p>

<p>EUID &lt;S&gt; The effective user ID of the shell
process. If you have suffi- cient privileges, you may change
the effective user ID of the shell process by assigning to
this parameter. Also (assuming sufficient privileges), you
may start a single command with a different effective user
ID by (EUID=uid; command)</p>

<p>ERRNO &lt;S&gt; The value of errno (see errno(3)) as set
by the most recently failed system call. This value is
system dependent and is intended for debugging purposes. It
is also useful with the zsh/system module which allows the
number to be turned into a name or message.</p>

<p>GID &lt;S&gt; The real group ID of the shell process. If
you have sufficient privileges, you may change the group ID
of the shell process by assigning to this parameter. Also
(assuming sufficient privi- leges), you may start a single
command under a different group ID by (GID=gid; command)</p>

<p>HISTCMD The current history line number in an
interactive shell, in other words the line number for the
command that caused $HISTCMD to be read.</p>

<p>HOST The current hostname.</p>

<p>LINENO &lt;S&gt; The line number of the current line
within the current script, sourced file, or shell function
being executed, whichever was started most recently. Note
that in the case of shell functions the line number refers
to the function as it appeared in the original definition,
not necessarily as displayed by the func- tions builtin.</p>

<p>LOGNAME If the corresponding variable is not set in the
environment of the shell, it is initialized to the login
name corresponding to the current login session. This
parameter is exported by default but this can be disabled
using the typeset builtin.</p>

<p>MACHTYPE The machine type (microprocessor class or
machine model), as determined at compile time.</p>

<p>OLDPWD The previous working directory. This is set when
the shell ini- tializes and whenever the directory
changes.</p>

<p>OPTARG &lt;S&gt; The value of the last option argument
processed by the getopts command.</p>

<p>OPTIND &lt;S&gt; The index of the last option argument
processed by the getopts command.</p>

<p>OSTYPE The operating system, as determined at compile
time.</p>

<p>PPID &lt;S&gt; The process ID of the parent of the
shell. As for $$, the value indicates the parent of the
original shell and does not change in subshells.</p>

<p>PWD The present working directory. This is set when the
shell ini- tializes and whenever the directory changes.</p>

<p>RANDOM &lt;S&gt; A pseudo-random integer from 0 to
32767, newly generated each time this parameter is
referenced. The random number generator can be seeded by
assigning a numeric value to RANDOM.</p>

<p>The values of RANDOM form an intentionally-repeatable
pseudo-random sequence; subshells that reference RANDOM will
result in identical pseudo-random values unless the value of
RANDOM is referenced or seeded in the parent shell in
between subshell invocations.</p>

<p>SECONDS &lt;S&gt; The number of seconds since shell
invocation. If this parameter is assigned a value, then the
value returned upon reference will be the value that was
assigned plus the number of seconds since the
assignment.</p>

<p>Unlike other special parameters, the type of the SECONDS
parame- ter can be changed using the typeset command. Only
integer and one of the floating point types are allowed. For
example, typeset -F SECONDS causes the value to be reported
as a float- ing point number. The value is available to
microsecond accu- racy, although the shell may show more or
fewer digits depending on the use of typeset. See the
documentation for the builtin typeset in zshbuiltins(1) for
more details.</p>

<p>SHLVL &lt;S&gt; Incremented by one each time a new shell
is started.</p>

<p>signals An array containing the names of the
signals.</p>

<p>TRY_BLOCK_ERROR &lt;S&gt; In an always block, indicates
whether the preceding list of code caused an error. The
value is 1 to indicate an error, 0 other- wise. It may be
reset, clearing the error condition. See Com- plex Commands
in zshmisc(1)</p>

<p>TTY The name of the tty associated with the shell, if
any.</p>

<p>TTYIDLE &lt;S&gt; The idle time of the tty associated
with the shell in seconds or -1 if there is no such tty.</p>

<p>UID &lt;S&gt; The real user ID of the shell process. If
you have sufficient privileges, you may change the user ID
of the shell by assigning to this parameter. Also (assuming
sufficient privileges), you may start a single command under
a different user ID by (UID=uid; command)</p>

<p>USERNAME &lt;S&gt; The username corresponding to the
real user ID of the shell pro- cess. If you have sufficient
privileges, you may change the username (and also the user
ID and group ID) of the shell by assigning to this
parameter. Also (assuming sufficient privi- leges), you may
start a single command under a different user- name (and
user ID and group ID) by (USERNAME=username; com- mand)</p>

<p>VENDOR The vendor, as determined at compile time.</p>

<p>ZSH_NAME Expands to the basename of the command used to
invoke this instance of zsh.</p>

<p>ZSH_PATCHLEVEL The revision string for the version
number of the ChangeLog file in the zsh distribution. This
is most useful in order to keep track of versions of the
shell during development between releases; hence most users
should not use it and should instead rely on
$ZSH_VERSION.</p>

<p>zsh_scheduled_events See the section The zsh/sched
Module in zshmodules(1).</p>

<p>ZSH_SUBSHELL Readonly integer. Initially zero,
incremented each time the shell forks to create a subshell
for executing code. Hence (print $ZSH_SUBSHELL) and print
$(print $ZSH_SUBSHELL) out- put 1, while ( (print
$ZSH_SUBSHELL) ) outputs 2.</p>

<p>ZSH_VERSION The version number of the release of
zsh.</p>

<p>PARAMETERS USED BY THE SHELL The following parameters
are used by the shell.</p>

<p>In cases where there are two parameters with an upper-
and lowercase form of the same name, such as path and PATH,
the lowercase form is an array and the uppercase form is a
scalar with the elements of the array joined together by
colons. These are similar to tied parameters cre- ated via
typeset -T . The normal use for the colon-separated form is
for exporting to the environment, while the array form is
easier to manipulate within the shell. Note that unsetting
either of the pair will unset the other; they retain their
special properties when recre- ated, and recreating one of
the pair will recreate the other.</p>

<p>ARGV0 If exported, its value is used as the argv[0] of
external com- mands. Usually used in constructs like
ARGV0=emacs nethack.</p>

<p>BAUD The rate in bits per second at which data reaches
the terminal. The line editor will use this value in order
to compensate for a slow terminal by delaying updates to the
display until neces- sary. If the parameter is unset or the
value is zero the com- pensation mechanism is turned off.
The parameter is not set by default.</p>

<p>This parameter may be profitably set in some
circumstances, e.g. for slow modems dialing into a
communications server, or on a slow wide area network. It
should be set to the baud rate of the slowest part of the
link for best performance.</p>

<p>cdpath &lt;S&gt; &lt;Z&gt; (CDPATH &lt;S&gt;) An array
(colon-separated list) of directories specifying the search
path for the cd command.</p>

<p>COLUMNS &lt;S&gt; The number of columns for this
terminal session. Used for printing select lists and for the
line editor.</p>

<p>CORRECT_IGNORE If set, is treated as a pattern during
spelling correction. Any potential correction that matches
the pattern is ignored. For example, if the value is _* then
completion functions (which, by convention, have names
beginning with _ ) will never be offered as spelling
corrections. The pattern does not apply the correction of
file names, as applied by the CORRECT_ALL option (so with
the example just given files beginning with _ in the current
directory would still be completed).</p>

<p>DIRSTACKSIZE The maximum size of the directory stack. If
the stack gets larger than this, it will be truncated
automatically. This is useful with the AUTO_PUSHD
option.</p>

<p>ENV If the ENV environment variable is set when zsh is
invoked as sh or ksh, $ENV is sourced after the profile
scripts. The value of ENV is subjected to parameter
expansion, command substitution, and arithmetic expansion
before being interpreted as a pathname. Note that ENV is not
used unless zsh is emulating sh or ksh.</p>

<p>FCEDIT The default editor for the fc builtin. If FCEDIT
is not set, the parameter EDITOR is used; if that is not set
either, a builtin default, usually vi, is used.</p>

<p>fignore &lt;S&gt; &lt;Z&gt; (FIGNORE &lt;S&gt;) An array
(colon separated list) containing the suffixes of files to
be ignored during filename completion. However, if comple-
tion only generates files with suffixes in this list, then
these files are completed anyway.</p>

<p>fpath &lt;S&gt; &lt;Z&gt; (FPATH &lt;S&gt;) An array
(colon separated list) of directories specifying the search
path for function definitions. This path is searched when a
function with the -u attribute is referenced. If an exe-
cutable file is found, then it is read and executed in the
cur- rent environment.</p>

<p>histchars &lt;S&gt; Three characters used by the shell s
history and lexical analy- sis mechanism. The first
character signals the start of a his- tory expansion
(default !). The second character signals the start of a
quick history substitution (default ^). The third character
is the comment character (default #).</p>

<p>The characters must be in the ASCII character set; any
attempt to set histchars to characters with a
locale-dependent meaning will be rejected with an error
message.</p>

<p>HISTCHARS &lt;S&gt; &lt;Z&gt; Same as histchars.
(Deprecated.)</p>

<p>HISTFILE The file to save the history in when an
interactive shell exits. If unset, the history is not
saved.</p>

<p>HISTSIZE &lt;S&gt; The maximum number of events stored
in the internal history list. If you use the
HIST_EXPIRE_DUPS_FIRST option, setting this value larger
than the SAVEHIST size will give you the dif- ference as a
cushion for saving duplicated history events.</p>

<p>HOME &lt;S&gt; The default argument for the cd command.
This is not set auto- matically by the shell in sh, ksh or
csh emulation, but it is typically present in the
environment anyway, and if it becomes set it has its usual
special behaviour.</p>

<p>IFS &lt;S&gt; Internal field separators (by default
space, tab, newline and NUL), that are used to separate
words which result from command or parameter expansion and
words read by the read builtin. Any characters from the set
space, tab and newline that appear in the IFS are called IFS
white space. One or more IFS white space characters or one
non-IFS white space character together with any adjacent IFS
white space character delimit a field. If an IFS white space
character appears twice consecutively in the IFS, this
character is treated as if it were not an IFS white space
character.</p>

<p>If the parameter is unset, the default is used. Note
this has a different effect from setting the parameter to an
empty string.</p>

<p>KEYTIMEOUT The time the shell waits, in hundredths of
seconds, for another key to be pressed when reading bound
multi-character sequences.</p>

<p>LANG &lt;S&gt; This variable determines the locale
category for any category not specifically selected via a
variable starting with LC_.</p>

<p>LC_ALL &lt;S&gt; This variable overrides the value of
the LANG variable and the value of any of the other
variables starting with LC_.</p>

<p>LC_COLLATE &lt;S&gt; This variable determines the locale
category for character col- lation information within ranges
in glob brackets and for sort- ing.</p>

<p>LC_CTYPE &lt;S&gt; This variable determines the locale
category for character han- dling functions. If the
MULTIBYTE option is in effect this variable or LANG should
contain a value that reflects the char- acter set in use,
even if it is a single-byte character set, unless only the
7-bit subset (ASCII) is used. For example, if the character
set is ISO-8859-1, a suitable value might be en_US.iso88591
(certain Linux distributions) or en_US.ISO8859-1
(MacOS).</p>

<p>LC_MESSAGES &lt;S&gt; This variable determines the
language in which messages should be written. Note that zsh
does not use message catalogs.</p>

<p>LC_NUMERIC &lt;S&gt; This variable affects the decimal
point character and thousands separator character for the
formatted input/output functions and string conversion
functions. Note that zsh ignores this setting when parsing
floating point mathematical expressions.</p>

<p>LC_TIME &lt;S&gt; This variable determines the locale
category for date and time formatting in prompt escape
sequences.</p>

<p>LINES &lt;S&gt; The number of lines for this terminal
session. Used for print- ing select lists and for the line
editor.</p>

<p>LISTMAX In the line editor, the number of matches to
list without asking first. If the value is negative, the
list will be shown if it spans at most as many lines as
given by the absolute value. If set to zero, the shell asks
only if the top of the listing would scroll off the
screen.</p>

<p>LOGCHECK The interval in seconds between checks for
login/logout activity using the watch parameter.</p>

<p>MAIL If this parameter is set and mailpath is not set,
the shell looks for mail in the specified file.</p>

<p>MAILCHECK The interval in seconds between checks for new
mail.</p>

<p>mailpath &lt;S&gt; &lt;Z&gt; (MAILPATH &lt;S&gt;) An
array (colon-separated list) of filenames to check for new
mail. Each filename can be followed by a ? and a message
that will be printed. The message will undergo parameter
expansion, command substitution and arithmetic expansion
with the variable $_ defined as the name of the file that
has changed. The default message is You have new mail . If
an element is a directory instead of a file the shell will
recursively check every file in every subdirectory of the
element.</p>

<p>manpath &lt;S&gt; &lt;Z&gt; (MANPATH &lt;S&gt;
&lt;Z&gt;) An array (colon-separated list) whose value is
not used by the shell. The manpath array can be useful,
however, since setting it also sets MANPATH, and vice
versa.</p>

<p>module_path &lt;S&gt; &lt;Z&gt; (MODULE_PATH &lt;S&gt;)
An array (colon-separated list) of directories that zmodload
searches for dynamically loadable modules. This is
initialized to a standard pathname, usually
/usr/local/lib/zsh/$ZSH_VER- SION . (The /usr/local/lib part
varies from installation to installation.) For security
reasons, any value set in the envi- ronment when the shell
is started will be ignored.</p>

<p>These parameters only exist if the installation supports
dynamic module loading.</p>

<p>NULLCMD &lt;S&gt; The command name to assume if a
redirection is specified with no command. Defaults to cat.
For sh/ksh behavior, change this to :. For csh-like
behavior, unset this parameter; the shell will print an
error message if null commands are entered.</p>

<p>path &lt;S&gt; &lt;Z&gt; (PATH &lt;S&gt;) An array
(colon-separated list) of directories to search for
commands. When this parameter is set, each directory is
scanned and all files found are put in a hash table.</p>

<p>POSTEDIT &lt;S&gt; This string is output whenever the
line editor exits. It usu- ally contains termcap strings to
reset the terminal.</p>

<p>PROMPT &lt;S&gt; &lt;Z&gt; PROMPT2 &lt;S&gt; &lt;Z&gt;
PROMPT3 &lt;S&gt; &lt;Z&gt; PROMPT4 &lt;S&gt; &lt;Z&gt; Same
as PS1, PS2, PS3 and PS4, respectively.</p>

<p>prompt &lt;S&gt; &lt;Z&gt; Same as PS1.</p>

<p>PROMPT_EOL_MARK When the PROMPT_CR and PROMPT_SP options
are set, the PROMPT_EOL_MARK parameter can be used to
customize how the end of partial lines are shown. This
parameter undergoes prompt expansion, with the
PROMPT_PERCENT option set. If not set or empty, the default
behavior is equivalent to the value %B%S%#%s%b.</p>

<p>PS1 &lt;S&gt; The primary prompt string, printed before
a command is read. It undergoes a special form of expansion
before being displayed; see EXPANSION OF PROMPT SEQUENCES in
zshmisc(1). The default is %m%# .</p>

<p>PS2 &lt;S&gt; The secondary prompt, printed when the
shell needs more informa- tion to complete a command. It is
expanded in the same way as PS1. The default is %_&gt; ,
which displays any shell constructs or quotation marks which
are currently being processed.</p>

<p>PS3 &lt;S&gt; Selection prompt used within a select
loop. It is expanded in the same way as PS1. The default is
?# .</p>

<p>PS4 &lt;S&gt; The execution trace prompt. Default is
+%N:%i&gt; , which dis- plays the name of the current shell
structure and the line num- ber within it. In sh or ksh
emulation, the default is + .</p>

<p>psvar &lt;S&gt; &lt;Z&gt; (PSVAR &lt;S&gt;) An array
(colon-separated list) whose first nine values can be used
in PROMPT strings. Setting psvar also sets PSVAR, and vice
versa.</p>

<p>READNULLCMD &lt;S&gt; The command name to assume if a
single input redirection is specified with no command.
Defaults to more.</p>

<p>REPORTTIME If nonnegative, commands whose combined user
and system execu- tion times (measured in seconds) are
greater than this value have timing statistics printed for
them.</p>

<p>REPLY This parameter is reserved by convention to pass
string values between shell scripts and shell builtins in
situations where a function call or redirection are
impossible or undesirable. The read builtin and the select
complex command may set REPLY, and filename generation both
sets and examines its value when evalu- ating certain
expressions. Some modules also employ REPLY for similar
purposes.</p>

<p>reply As REPLY, but for array values rather than
strings.</p>

<p>RPROMPT &lt;S&gt; RPS1 &lt;S&gt; This prompt is
displayed on the right-hand side of the screen when the
primary prompt is being displayed on the left. This does not
work if the SINGLELINEZLE option is set. It is expanded in
the same way as PS1.</p>

<p>RPROMPT2 &lt;S&gt; RPS2 &lt;S&gt; This prompt is
displayed on the right-hand side of the screen when the
secondary prompt is being displayed on the left. This does
not work if the SINGLELINEZLE option is set. It is expanded
in the same way as PS2.</p>

<p>SAVEHIST The maximum number of history events to save in
the history file.</p>

<p>SPROMPT &lt;S&gt; The prompt used for spelling
correction. The sequence %R expands to the string which
presumably needs spelling correc- tion, and %r expands to
the proposed correction. All other prompt escapes are also
allowed.</p>

<p>STTY If this parameter is set in a command s
environment, the shell runs the stty command with the value
of this parameter as argu- ments in order to set up the
terminal before executing the com- mand. The modes apply
only to the command, and are reset when it finishes or is
suspended. If the command is suspended and con- tinued later
with the fg or wait builtins it will see the modes specified
by STTY, as if it were not suspended. This (inten- tionally)
does not apply if the command is continued via kill -CONT .
STTY is ignored if the command is run in the back- ground,
or if it is in the environment of the shell but not
explicitly assigned to in the input line. This avoids
running stty at every external command by accidentally
exporting it. Also note that STTY should not be used for
window size specifi- cations; these will not be local to the
command.</p>

<p>TERM &lt;S&gt; The type of terminal in use. This is used
when looking up term- cap sequences. An assignment to TERM
causes zsh to re-initial- ize the terminal, even if the
value does not change (e.g., TERM=$TERM ). It is necessary
to make such an assignment upon any change to the terminal
definition database or terminal type in order for the new
settings to take effect.</p>

<p>TIMEFMT The format of process time reports with the time
keyword. The default is %E real %U user %S system %P %J .
Recognizes the following escape sequences, although not all
may be available on all systems, and some that are available
may not be useful:</p>

<p>%% A %. %U CPU seconds spent in user mode. %S CPU
seconds spent in kernel mode. %E Elapsed time in seconds. %P
The CPU percentage, computed as (100*%U+%S)/%E. %W Number of
times the process was swapped. %X The average amount in
(shared) text space used in Kbytes. %D The average amount in
(unshared) data/stack space used in Kbytes. %K The total
space used (%X+%D) in Kbytes. %M The maximum memory the
process had in use at any time in Kbytes. %F The number of
major page faults (page needed to be brought from disk). %R
The number of minor page faults. %I The number of input
operations. %O The number of output operations. %r The
number of socket messages received. %s The number of socket
messages sent. %k The number of signals received. %w Number
of voluntary context switches (waits). %c Number of
involuntary context switches. %J The name of this job.</p>

<p>A star may be inserted between the percent sign and
flags print- ing time. This cause the time to be printed in
hh:mm:ss.ttt format (hours and minutes are only printed if
they are not zero).</p>

<p>TMOUT If this parameter is nonzero, the shell will
receive an ALRM signal if a command is not entered within
the specified number of seconds after issuing a prompt. If
there is a trap on SIGALRM, it will be executed and a new
alarm is scheduled using the value of the TMOUT parameter
after executing the trap. If no trap is set, and the idle
time of the terminal is not less than the value of the TMOUT
parameter, zsh terminates. Other- wise a new alarm is
scheduled to TMOUT seconds after the last keypress.</p>

<p>TMPPREFIX A pathname prefix which the shell will use for
all temporary files. Note that this should include an
initial part for the file name as well as any directory
names. The default is /tmp/zsh.</p>

<p>watch &lt;S&gt; &lt;Z&gt; (WATCH &lt;S&gt;) An array
(colon-separated list) of login/logout events to report. If
it contains the single word all, then all login/logout
events are reported. If it contains the single word notme,
then all events are reported as with all except $USERNAME.
An entry in this list may consist of a username, an @
followed by a remote hostname, and a % followed by a line
(tty). Any or all of these components may be present in an
entry; if a login/logout event matches all of them, it is
reported.</p>

<p>WATCHFMT The format of login/logout reports if the watch
parameter is set. Default is %n has %a %l from %m.
Recognizes the follow- ing escape sequences:</p>

<p>%n The name of the user that logged in/out.</p>

<p>%a The observed action, i.e. &quot;logged on&quot; or
&quot;logged off&quot;.</p>

<p>%l The line (tty) the user is logged in on.</p>

<p>%M The full hostname of the remote host.</p>

<p>%m The hostname up to the first .. If only the IP
address is available or the utmp field contains the name of
an X-windows display, the whole name is printed.</p>

<p>NOTE: The %m and %M escapes will work only if there is a
host name field in the utmp on your machine. Other- wise
they are treated as ordinary strings.</p>

<p>%S (%s) Start (stop) standout mode.</p>

<p>%U (%u) Start (stop) underline mode.</p>

<p>%B (%b) Start (stop) boldface mode.</p>

<p>%t %@ The time, in 12-hour, am/pm format.</p>

<p>%T The time, in 24-hour format.</p>

<p>%w The date in day-dd format.</p>

<p>%W The date in mm/dd/yy format.</p>

<p>%D The date in yy-mm-dd format.</p>

<p>%(x:true-text:false-text) Specifies a ternary
expression. The character following the x is arbitrary; the
same character is used to sepa- rate the text for the
&quot;true&quot; result from that for the &quot;false&quot;
result. Both the separator and the right paren- thesis may
be escaped with a backslash. Ternary expres- sions may be
nested.</p>

<p>The test character x may be any one of l , n, m or M ,
which indicate a true result if the corresponding escape
sequence would return a non-empty value; or it may be a,
which indicates a true result if the watched user has logged
in, or false if he has logged out. Other characters evaluate
to neither true nor false; the entire expression is omitted
in this case.</p>

<p>If the result is true, then the true-text is formatted
according to the rules above and printed, and the false-text
is skipped. If false , the true-text is skipped and the
false-text is formatted and printed. Either or both of the
branches may be empty, but both separators must be present
in any case.</p>

<p>WORDCHARS &lt;S&gt; A list of non-alphanumeric
characters considered part of a word by the line editor.</p>

<p>ZBEEP If set, this gives a string of characters, which
can use all the same codes as the bindkey command as
described in the zsh/zle module entry in zshmodules(1), that
will be output to the termi- nal instead of beeping. This
may have a visible instead of an audible effect; for
example, the string e[?5e[?5l on a vt100 or xterm will have
the effect of flashing reverse video on and off (if you
usually use reverse video, you should use the string
e[?5e[?5h instead). This takes precedence over the NOBEEP
option.</p>

<p>ZDOTDIR The directory to search for shell startup files
(.zshrc, etc), if not $HOME.</p>

<p>ZLE_REMOVE_SUFFIX_CHARS ZLE_SPACE_SUFFIX_CHARS These
parameters are used by the line editor. In certain cir-
cumstances suffixes (typically space or slash) added by the
completion system will be removed automatically, either
because the next editing command was not an insertable
character, or because the character was marked as requiring
the suffix to be removed.</p>

<p>These variables can contain the sets of characters that
will cause the suffix to be removed. If
ZLE_REMOVE_SUFFIX_CHARS is set, those characters will cause
the suffix to be removed; if ZLE_SPACE_SUFFIX_CHARS is set,
those characters will cause the suffix to be removed and
replaced by a space.</p>

<p>If ZLE_REMOVE_SUFFIX_CHARS is not set, the default
behaviour is equivalent to:</p>

<p>ZLE_REMOVE_SUFFIX_CHARS=n;&amp;|</p>

<p>If ZLE_REMOVE_SUFFIX_CHARS is set but is empty, no
characters have this behaviour. ZLE_SPACE_SUFFIX_CHARS takes
precedence, so that the following:</p>

<p>ZLE_SPACE_SUFFIX_CHARS=&amp;|</p>

<p>causes the characters &amp; and | to remove the suffix
but to replace it with a space.</p>

<p>To illustrate the difference, suppose that the option
AUTO_REMOVE_SLASH is in effect and the directory DIR has
just been completed, with an appended /, following which the
user types &amp; . The default result is DIR&amp;. With
ZLE_REMOVE_SUF- FIX_CHARS set but without including &amp;
the result is DIR/&amp;. With ZLE_SPACE_SUFFIX_CHARS set to
include &amp; the result is DIR &amp;.</p>

<p>Note that certain completions may provide their own
suffix removal or replacement behaviour which overrides the
values described here. See the completion system
documentation in zsh- compsys(1).</p>

<p>zsh 4.3.10 June 1, 2009 ZSHPARAM(1)</p>
<hr>
</body>
</html>
