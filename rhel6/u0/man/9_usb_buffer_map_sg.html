<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:24:18 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_BUFFER_MAP_SG(9) USB Core APIs
USB_BUFFER_MAP_SG(9)</p>

<p>NAME usb_buffer_map_sg - create scatterlist DMA
mapping(s) for an endpoint</p>

<p>SYNOPSIS int usb_buffer_map_sg(const struct usb_device *
dev, int is_in, struct scatterlist * sg, int nents);</p>

<p>ARGUMENTS dev device to which the scatterlist will be
mapped</p>

<p>is_in mapping transfer direction</p>

<p>sg the scatterlist to map</p>

<p>nents the number of entries in the scatterlist</p>

<p>DESCRIPTION Return value is either &lt; 0 (indicating no
buffers could be mapped), or the number of DMA mapping array
entries in the scatterlist.</p>

<p>The caller is responsible for placing the resulting DMA
addresses from the scatterlist into URB transfer buffer
pointers, and for setting the URB_NO_TRANSFER_DMA_MAP
transfer flag in each of those URBs.</p>

<p>Top I/O rates come from queuing URBs, instead of waiting
for each one to complete before starting the next I/O. This
is particularly easy to do with scatterlists. Just allocate
and submit one URB for each DMA mapping entry returned,
stopping on the first error or when all succeed. Better yet,
use the usb_sg_*() calls, which do that (and more) for
you.</p>

<p>This call would normally be used when translating
scatterlist requests, rather than usb_buffer_map, since on
some hardware (with IOMMUs) it may be able to coalesce
mappings for improved I/O efficiency.</p>

<p>Reverse the effect of this call with
usb_buffer_unmap_sg.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
USB_BUFFER_MAP_SG(9)</p>
<hr>
</body>
</html>
