<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:24:54 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>VI(1P) POSIX Programmer s Manual VI(1P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME vi - screen-oriented (visual) display editor</p>

<p>SYNOPSIS vi [-rR][-c command][-t tagstring][-w
size][file ...]</p>

<p>DESCRIPTION This utility shall be provided on systems
that both support the User Portability Utilities option and
define the POSIX2_CHAR_TERM symbol. On other systems it is
optional.</p>

<p>The vi (visual) utility is a screen-oriented text
editor. Only the open and visual modes of the editor are
described in IEEE Std 1003.1-2001; see the line editor ex
for additional editing capabilities used in vi. The user can
switch back and forth between vi and ex and execute ex
commands from within vi.</p>

<p>This reference page uses the term edit buffer to
describe the current working text. No specific
implementation is implied by this term. All editing changes
are performed on the edit buffer, and no changes to it shall
affect any file until an editor command writes the file.</p>

<p>When using vi, the terminal screen acts as a window into
the editing buffer. Changes made to the editing buffer shall
be reflected in the screen display; the position of the
cursor on the screen shall indicate the position within the
editing buffer.</p>

<p>Certain terminals do not have all the capabilities
necessary to support the complete vi definition. When these
commands cannot be supported on such terminals, this
condition shall not produce an error message such as
&quot;not an editor command&quot; or report a syntax error.
The implementation may either accept the commands and
produce results on the screen that are the result of an
unsuccessful attempt to meet the requirements of this volume
of IEEE Std 1003.1-2001 or report an error describing the
terminal-related deficiency.</p>

<p>OPTIONS The vi utility shall conform to the Base
Definitions volume of IEEE Std 1003.1-2001, Section 12.2,
Utility Syntax Guidelines.</p>

<p>The following options shall be supported:</p>

<p>-c command See the ex command description of the -c
option.</p>

<p>-r See the ex command description of the -r option.</p>

<p>-R See the ex command description of the -R option.</p>

<p>-t tagstring See the ex command description of the -t
option.</p>

<p>-w size See the ex command description of the -w
option.</p>

<p>OPERANDS See the OPERANDS section of the ex command for
a description of the operands supported by the vi
command.</p>

<p>STDIN If standard input is not a terminal device, the
results are undefined. The standard input consists of a
series of commands and input text, as described in the
EXTENDED DESCRIPTION section.</p>

<p>If a read from the standard input returns an error, or
if the editor detects an end-of-file condition from the
standard input, it shall be equivalent to a SIGHUP
asynchronous event.</p>

<p>INPUT FILES See the INPUT FILES section of the ex
command for a description of the input files supported by
the vi command.</p>

<p>ENVIRONMENT VARIABLES See the ENVIRONMENT VARIABLES
section of the ex command for the envi- ronment variables
that affect the execution of the vi command.</p>

<p>ASYNCHRONOUS EVENTS See the ASYNCHRONOUS EVENTS section
of the ex for the asynchronous events that affect the
execution of the vi command.</p>

<p>STDOUT If standard output is not a terminal device,
undefined results occur.</p>

<p>Standard output may be used for writing prompts to the
user, for infor- mational messages, and for writing lines
from the file.</p>

<p>STDERR If standard output is not a terminal device,
undefined results occur.</p>

<p>The standard error shall be used only for diagnostic
messages.</p>

<p>OUTPUT FILES See the OUTPUT FILES section of the ex
command for a description of the output files supported by
the vi command.</p>

<p>EXTENDED DESCRIPTION If the terminal does not have the
capabilities necessary to support an unspecified portion of
the vi definition, implementations shall start initially in
ex mode or open mode. Otherwise, after initialization, vi
shall be in command mode; text input mode can be entered by
one of sev- eral commands used to insert or change text. In
text input mode, &lt;ESC&gt; can be used to return to
command mode; other uses of &lt;ESC&gt; are described later
in this section; see Terminate Command or Input Mode .</p>

<p>Initialization in ex and vi See Initialization in ex and
vi for a description of ex and vi initial- ization for the
vi utility.</p>

<p>Command Descriptions in vi The following symbols are
used in this reference page to represent arguments to
commands.</p>

<p>buffer See the description of buffer in the EXTENDED
DESCRIPTION sec- tion of the ex utility; see Command
Descriptions in ex .</p>

<p>In open and visual mode, when a command synopsis shows
both [ buffer] and [ count] preceding the command name, they
can be specified in either order.</p>

<p>count A positive integer used as an optional argument to
most com- mands, either to give a repeat count or as a size.
This argument is optional and shall default to 1 unless
otherwise specified.</p>

<p>The Synopsis lines for the vi commands
&lt;control&gt;-G, &lt;control&gt;-L, &lt;con- trol&gt;-R,
&lt;control&gt;-], %, &amp;, ^, D, m, M, Q, u, U, and ZZ do
not have count as an optional argument. Regardless, it shall
not be an error to specify a count to these commands, and
any specified count shall be ignored.</p>

<p>motion An optional trailing argument used by the !,
&lt;, &gt;, c, d, and y commands, which is used to indicate
the region of text that shall be affected by the command.
The motion can be either one of the command characters
repeated or one of several other vi commands (listed in the
following table). Each of the applicable commands specifies
the region of text matched by repeating the command; each
command that can be used as a motion command spec- ifies the
region of text it affects.</p>

<p>Commands that take motion arguments operate on either
lines or charac- ters, depending on the circumstances. When
operating on lines, all lines that fall partially or wholly
within the text region specified for the command shall be
affected. When operating on characters, only the exact
characters in the specified text region shall be affected.
Each motion command specifies this individually.</p>

<p>When commands that may be motion commands are not used
as motion com- mands, they shall set the current position to
the current line and col- umn as specified.</p>

<p>The following commands shall be valid cursor motion
commands:</p>

<p>&lt;apostrophe&gt; ( - j H &lt;carriage-return&gt; ) $ k
L &lt;comma&gt; [[ % l M &lt;control&gt;-H ]] _ n N
&lt;control&gt;-N { ; t T &lt;control&gt;-P } ? w W
&lt;grave accent&gt; ^ b B &lt;newline&gt; + e E
&lt;space&gt; | f F &lt;zero&gt; / h G</p>

<p>Any count that is specified to a command that has an
associated motion command shall be applied to the motion
command. If a count is applied to both the command and its
associated motion command, the effect shall be
multiplicative.</p>

<p>The following symbols are used in this section to
specify locations in the edit buffer:</p>

<p>current character</p>

<p>The character that is currently indicated by the
cursor.</p>

<p>end of a line</p>

<p>The point located between the last non- &lt;newline&gt;
(if any) and the terminating &lt;newline&gt; of a line. For
an empty line, this location coincides with the beginning of
the line.</p>

<p>end of the edit buffer</p>

<p>The location corresponding to the end of the last line
in the edit buffer.</p>

<p>The following symbols are used in this section to
specify command actions:</p>

<p>bigword In the POSIX locale, vi shall recognize four
kinds of bigwords:</p>

<p>1. A maximal sequence of non- &lt;blank&gt;s preceded
and followed by &lt;blank&gt;s or the beginning or end of a
line or the edit buffer</p>

<p>2. One or more sequential blank lines</p>

<p>3. The first character in the edit buffer</p>

<p>4. The last non- &lt;newline&gt; in the edit buffer</p>

<p>word In the POSIX locale, vi shall recognize five kinds
of words:</p>

<p>1. A maximal sequence of letters, digits, and
underscores, delimited at both ends by:</p>

<p>* Characters other than letters, digits, or
underscores</p>

<p>* The beginning or end of a line</p>

<p>* The beginning or end of the edit buffer</p>

<p>2. A maximal sequence of characters other than letters,
digits, underscores, or &lt;blank&gt;s, delimited at both
ends by:</p>

<p>* A letter, digit, underscore</p>

<p>* &lt;blank&gt;s</p>

<p>* The beginning or end of a line</p>

<p>* The beginning or end of the edit buffer</p>

<p>3. One or more sequential blank lines</p>

<p>4. The first character in the edit buffer</p>

<p>5. The last non- &lt;newline&gt; in the edit buffer</p>

<p>section boundary</p>

<p>A section boundary is one of the following:</p>

<p>1. A line whose first character is a
&lt;form-feed&gt;</p>

<p>2. A line whose first character is an open curly brace
({)</p>

<p>3. A line whose first character is a period and whose
second and third characters match a two-character pair in
the sec- tions edit option (see ed)</p>

<p>4. A line whose first character is a period and whose
only other character matches the first character of a
two-charac- ter pair in the sections edit option, where the
second char- acter of the two-character pair is a
&lt;space&gt;</p>

<p>5. The first line of the edit buffer</p>

<p>6. The last line of the edit buffer if the last line of
the edit buffer is empty or if it is a ]] or } command;
other- wise, the last non- &lt;newline&gt; of the last line
of the edit buffer</p>

<p>paragraph boundary</p>

<p>A paragraph boundary is one of the following:</p>

<p>1. A section boundary</p>

<p>2. A line whose first character is a period and whose
second and third characters match a two-character pair in
the para- graphs edit option (see ed)</p>

<p>3. A line whose first character is a period and whose
only other character matches the first character of a
two-charac- ter pair in the paragraphs edit option, where
the second character of the two-character pair is a
&lt;space&gt;</p>

<p>4. One or more sequential blank lines</p>

<p>remembered search direction</p>

<p>See the description of remembered search direction in
ed.</p>

<p>sentence boundary</p>

<p>A sentence boundary is one of the following:</p>

<p>1. A paragraph boundary</p>

<p>2. The first non- &lt;blank&gt; that occurs after a
paragraph bound- ary</p>

<p>3. The first non- &lt;blank&gt; that occurs after a
period ( . ), exclamation mark (!), or question mark ( ? ),
followed by two &lt;space&gt;s or the end of a line; any
number of closing parenthesis ()), closing brackets (]),
double quote ( ),or single quote (&quot; ) characters can
appear between the punctuation mark and the two
&lt;space&gt;s or end-of-line</p>

<p>In the remainder of the description of the vi utility,
the term &quot;buffer line&quot; refers to a line in the
edit buffer and the term &quot;display line&quot; refers to
the line or lines on the display screen used to display one
buffer line. The term &quot;current line&quot; refers to a
specific &quot;buffer line&quot;.</p>

<p>If there are display lines on the screen for which there
are no corre- sponding buffer lines because they correspond
to lines that would be after the end of the file, they shall
be displayed as a single tilde ( ~) character, plus the
terminating &lt;newline&gt;.</p>

<p>The last line of the screen shall be used to report
errors or display informational messages. It shall also be
used to display the input for &quot;line-oriented
commands&quot; ( /, ?, :, and !). When a line-oriented com-
mand is executed, the editor shall enter text input mode on
the last line on the screen, using the respective command
characters as prompt characters. (In the case of the !
command, the associated motion shall be entered by the user
before the editor enters text input mode.) The line entered
by the user shall be terminated by a &lt;newline&gt;, a non-
&lt;control&gt;-V-escaped &lt;carriage-return&gt;, or
unescaped &lt;ESC&gt;. It is unspecified if more characters
than require a display width minus one column number of
screen columns can be entered.</p>

<p>If any command is executed that overwrites a portion of
the screen other than the last line of the screen (for
example, the ex suspend or ! commands), other than the ex
shell command, the user shall be prompted for a character
before the screen is refreshed and the edit session
continued.</p>

<p>&lt;tab&gt;s shall take up the number of columns on the
screen set by the tabstop edit option (see ed), unless there
are less than that number of columns before the display
margin that will cause the displayed line to be folded; in
this case, they shall only take up the number of columns up
to that boundary.</p>

<p>The cursor shall be placed on the current line and
relative to the cur- rent column as specified by each
command described in the following sections.</p>

<p>In open mode, if the current line is not already
displayed, then it shall be displayed.</p>

<p>In visual mode, if the current line is not displayed,
then the lines that are displayed shall be expanded,
scrolled, or redrawn to cause an unspecified portion of the
current line to be displayed. If the screen is redrawn, no
more than the number of display lines specified by the value
of the window edit option shall be displayed (unless the
current line cannot be completely displayed in the number of
display lines specified by the window edit option) and the
current line shall be positioned as close to the center of
the displayed lines as possible (within the constraints
imposed by the distance of the line from the beginning or
end of the edit buffer). If the current line is before the
first line in the display and the screen is scrolled, an
unspecified portion of the current line shall be placed on
the first line of the display. If the current line is after
the last line in the display and the screen is scrolled, an
unspecified portion of the current line shall be placed on
the last line of the display.</p>

<p>In visual mode, if a line from the edit buffer (other
than the current line) does not entirely fit into the lines
at the bottom of the display that are available for its
presentation, the editor may choose not to display any
portion of the line. The lines of the display that do not
contain text from the edit buffer for this reason shall each
consist of a single@character.</p>

<p>In visual mode, the editor may choose for unspecified
reasons to not update lines in the display to correspond to
the underlying edit buffer text. The lines of the display
that do not correctly correspond to text from the edit
buffer for this reason shall consist of a single@ character
(plus the terminating &lt;newline&gt;), and the
&lt;control&gt;-R command shall cause the editor to update
the screen to correctly represent the edit buffer.</p>

<p>Open and visual mode commands that set the current
column set it to a column position in the display, and not a
character position in the line. In this case, however, the
column position in the display shall be calculated for an
infinite width display; for example, the column related to a
character that is part of a line that has been folded onto
additional screen lines will be offset from the display line
column where the buffer line begins, not from the beginning
of a particular display line.</p>

<p>The display cursor column in the display is based on the
value of the current column, as follows, with each rule
applied in turn:</p>

<p>1. If the current column is after the last display line
column used by the displayed line, the display cursor column
shall be set to the last display line column occupied by the
last non- &lt;newline&gt; in the current line; otherwise,
the display cursor column shall be set to the current
column.</p>

<p>2. If the character of which some portion is displayed
in the display line column specified by the display cursor
column requires more than a single display line column:</p>

<p>a. If in text input mode, the display cursor column
shall be adjusted to the first display line column in which
any portion of that character is displayed.</p>

<p>b. Otherwise, the display cursor column shall be
adjusted to the last display line column in which any
portion of that character is displayed.</p>

<p>The current column shall not be changed by these
adjustments to the display cursor column.</p>

<p>If an error occurs during the parsing or execution of a
vi command:</p>

<p>* The terminal shall be alerted. Execution of the vi
command shall stop, and the cursor (for example, the current
line and column) shall not be further modified.</p>

<p>* Unless otherwise specified by the following command
sections, it is unspecified whether an informational message
shall be displayed.</p>

<p>* Any partially entered vi command shall be
discarded.</p>

<p>* If the vi command resulted from a map expansion, all
characters from that map expansion shall be discarded,
except as otherwise specified by the map command (see
ed).</p>

<p>* If the vi command resulted from the execution of a
buffer, no fur- ther commands caused by the execution of the
buffer shall be exe- cuted.</p>

<p>Page Backwards Synopsis:</p>

<p>[count] &lt;control&gt;-B</p>

<p>If in open mode, the &lt;control&gt;-B command shall
behave identically to the z command. Otherwise, if the
current line is the first line of the edit buffer, it shall
be an error.</p>

<p>If the window edit option is less than 3, display a
screen where the last line of the display shall be some
portion of:</p>

<p>(current first line) -1</p>

<p>otherwise, display a screen where the first line of the
display shall be some portion of:</p>

<p>(current first line) - count x ((window edit option)
-2)</p>

<p>If this calculation would result in a line that is
before the first line of the edit buffer, the first line of
the display shall display some portion of the first line of
the edit buffer.</p>

<p>Current line: If no lines from the previous display
remain on the screen, set to the last line of the display;
otherwise, set to ( line - the number of new lines displayed
on this screen).</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Scroll Forward Synopsis:</p>

<p>[count] &lt;control&gt;-D</p>

<p>If the current line is the last line of the edit buffer,
it shall be an error.</p>

<p>If no count is specified, count shall default to the
count associated with the previous &lt;control&gt;-D or
&lt;control&gt;-U command. If there was no previous
&lt;control&gt;-D or &lt;control&gt;-U command, count shall
default to the value of the scroll edit option.</p>

<p>If in open mode, write lines starting with the line
after the current line, until count lines or the last line
of the file have been written.</p>

<p>Current line: If the current line + count is past the
last line of the edit buffer, set to the last line of the
edit buffer; otherwise, set to the current line + count.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Scroll Forward by Line Synopsis:</p>

<p>[count] &lt;control&gt;-E</p>

<p>Display the line count lines after the last line
currently displayed.</p>

<p>If the last line of the edit buffer is displayed, it
shall be an error. If there is no line count lines after the
last line currently dis- played, the last line of the
display shall display some portion of the last line of the
edit buffer.</p>

<p>Current line: Unchanged if the previous current
character is displayed; otherwise, set to the first line
displayed.</p>

<p>Current column: Unchanged.</p>

<p>Page Forward Synopsis:</p>

<p>[count] &lt;control&gt;-F</p>

<p>If in open mode, the &lt;control&gt;-F command shall
behave identically to the z command. Otherwise, if the
current line is the last line of the edit buffer, it shall
be an error.</p>

<p>If the window edit option is less than 3, display a
screen where the first line of the display shall be some
portion of:</p>

<p>(current last line) +1</p>

<p>otherwise, display a screen where the first line of the
display shall be some portion of:</p>

<p>(current first line) + count x ((window edit option)
-2)</p>

<p>If this calculation would result in a line that is after
the last line of the edit buffer, the last line of the
display shall display some portion of the last line of the
edit buffer.</p>

<p>Current line: If no lines from the previous display
remain on the screen, set to the first line of the display;
otherwise, set to ( line + the number of new lines displayed
on this screen).</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Display Information Synopsis:</p>

<p>&lt;control&gt;-G</p>

<p>This command shall be equivalent to the ex file
command.</p>

<p>Move Cursor Backwards Synopsis:</p>

<p>[count] &lt;control&gt;-H</p>

<p>[count] h</p>

<p>the current erase character (see stty)</p>

<p>If there are no characters before the current character
on the current line, it shall be an error. If there are less
than count previous char- acters on the current line, count
shall be adjusted to the number of previous characters on
the line.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the character before
the starting cursor up to and including the countth
character before the start- ing cursor.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to ( column - the number of columns
occupied by count characters ending with the previous
current column).</p>

<p>Move Down Synopsis:</p>

<p>[count] &lt;newline&gt;</p>

<p>[count] &lt;control&gt;-J</p>

<p>[count] &lt;control&gt;-M</p>

<p>[count] &lt;control&gt;-N</p>

<p>[count] j</p>

<p>[count] &lt;carriage-return&gt;</p>

<p>[count] +</p>

<p>If there are less than count lines after the current
line in the edit buffer, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall include the starting line and
the next count - 1 lines.</p>

<p>2. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to current line+ count.</p>

<p>Current column: Set to non- &lt;blank&gt; for the
&lt;carriage-return&gt;, &lt;con- trol&gt;-M, and +
commands; otherwise, unchanged.</p>

<p>Clear and Redisplay Synopsis:</p>

<p>&lt;control&gt;-L</p>

<p>If in open mode, clear the screen and redisplay the
current line. Oth- erwise, clear and redisplay the
screen.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>Move Up Synopsis:</p>

<p>[count] &lt;control&gt;-P</p>

<p>[count] k</p>

<p>[count] -</p>

<p>If there are less than count lines before the current
line in the edit buffer, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall include the starting line and
the previous count lines.</p>

<p>2. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to current line - count.</p>

<p>Current column: Set to non- &lt;blank&gt; for the -
command; otherwise, unchanged.</p>

<p>Redraw Screen Synopsis:</p>

<p>&lt;control&gt;-R</p>

<p>If any lines have been deleted from the display screen
and flagged as deleted on the terminal using the @
convention (see the beginning of the EXTENDED DESCRIPTION
section), they shall be redisplayed to match the contents of
the edit buffer.</p>

<p>It is unspecified whether lines flagged with @ because
they do not fit on the terminal display shall be
affected.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>Scroll Backward Synopsis:</p>

<p>[count] &lt;control&gt;-U</p>

<p>If the current line is the first line of the edit
buffer, it shall be an error.</p>

<p>If no count is specified, count shall default to the
count associated with the previous &lt;control&gt;-D or
&lt;control&gt;-U command. If there was no previous
&lt;control&gt;-D or &lt;control&gt;-U command, count shall
default to the value of the scroll edit option.</p>

<p>Current line: If count is greater than the current line,
set to 1; oth- erwise, set to the current line - count.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Scroll Backward by Line Synopsis:</p>

<p>[count] &lt;control&gt;-Y</p>

<p>Display the line count lines before the first line
currently displayed.</p>

<p>If the current line is the first line of the edit
buffer, it shall be an error. If this calculation would
result in a line that is before the first line of the edit
buffer, the first line of the display shall dis- play some
portion of the first line of the edit buffer.</p>

<p>Current line: Unchanged if the previous current
character is displayed; otherwise, set to the first line
displayed.</p>

<p>Current column: Unchanged.</p>

<p>Edit the Alternate File Synopsis:</p>

<p>&lt;control&gt;-^</p>

<p>This command shall be equivalent to the ex edit command,
with the alternate pathname as its argument.</p>

<p>Terminate Command or Input Mode Synopsis:</p>

<p>&lt;ESC&gt;</p>

<p>If a partial vi command (as defined by at least one,
non- count charac- ter) has been entered, discard the count
and the command character(s).</p>

<p>Otherwise, if no command characters have been entered,
and the &lt;ESC&gt; was the result of a map expansion, the
terminal shall be alerted and the &lt;ESC&gt; character
shall be discarded, but it shall not be an error.</p>

<p>Otherwise, it shall be an error.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>Search for tagstring Synopsis:</p>

<p>&lt;control&gt;-]</p>

<p>If the current character is not a word or &lt;blank&gt;,
it shall be an error.</p>

<p>This command shall be equivalent to the ex tag command,
with the argu- ment to that command defined as follows.</p>

<p>If the current character is a &lt;blank&gt;:</p>

<p>1. Skip all &lt;blank&gt;s after the cursor up to the
end of the line.</p>

<p>2. If the end of the line is reached, it shall be an
error.</p>

<p>Then, the argument to the ex tag command shall be the
current character and all subsequent characters, up to the
first non-word character or the end of the line.</p>

<p>Move Cursor Forward Synopsis:</p>

<p>[count] &lt;space&gt;</p>

<p>[count] l (ell)</p>

<p>If there are less than count non- &lt;newline&gt;s after
the cursor on the current line, count shall be adjusted to
the number of non- &lt;newline&gt;s after the cursor on the
line.</p>

<p>If used as a motion command:</p>

<p>1. If the current or countth character after the cursor
is the last non- &lt;newline&gt; in the line, the text
region shall be comprised of the current character up to and
including the last non- &lt;newline&gt; in the line.
Otherwise, the text region shall be from the current
character up to, but not including, the countth character
after the cursor.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>If there are no non- &lt;newline&gt;s after the current
character on the cur- rent line, it shall be an error.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column that displays any
portion of the countth character after the current
character.</p>

<p>Replace Text with Results from Shell Command
Synopsis:</p>

<p>[count] ! motion shell-commands &lt;newline&gt;</p>

<p>If the motion command is the ! command repeated:</p>

<p>1. If the edit buffer is empty and no count was
supplied, the command shall be the equivalent of the ex
:read ! command, with the text input, and no text shall be
copied to any buffer.</p>

<p>2. Otherwise:</p>

<p>a. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>b. The text region shall be from the current line up to
and including the next count -1 lines.</p>

<p>Otherwise, the text region shall be the lines in which
any character of the text region specified by the motion
command appear.</p>

<p>Any text copied to a buffer shall be in line mode.</p>

<p>This command shall be equivalent to the ex ! command for
the specified lines.</p>

<p>Move Cursor to End-of-Line Synopsis:</p>

<p>[count] $</p>

<p>It shall be an error if there are less than ( count -1)
lines after the current line in the edit buffer.</p>

<p>If used as a motion command:</p>

<p>1. If count is 1:</p>

<p>a. It shall be an error if the line is empty.</p>

<p>b. Otherwise, the text region shall consist of all
characters from the starting cursor to the last non-
&lt;newline&gt; in the line, inclusive, and any text copied
to a buffer shall be in charac- ter mode.</p>

<p>2. Otherwise, if the starting cursor position is at or
before the first non- &lt;blank&gt; in the line, the text
region shall consist of the current and the next count -1
lines, and any text saved to a buffer shall be in line
mode.</p>

<p>3. Otherwise, the text region shall consist of all
characters from the starting cursor to the last non-
&lt;newline&gt; in the line that is count -1 lines forward
from the current line, and any text copied to a buffer shall
be in character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the current line + count-1.</p>

<p>Current column: The current column is set to the last
display line col- umn of the last non- &lt;newline&gt; in
the line, or column position 1 if the line is empty.</p>

<p>The current column shall be adjusted to be on the last
display line column of the last non- &lt;newline&gt; of the
current line as subsequent commands change the current line,
until a command changes the current column.</p>

<p>Move to Matching Character Synopsis:</p>

<p>%</p>

<p>If the character at the current position is not a
parenthesis, bracket, or curly brace, search forward in the
line to the first one of those characters. If no such
character is found, it shall be an error.</p>

<p>The matching character shall be the parenthesis,
bracket, or curly brace matching the parenthesis, bracket,
or curly brace, respectively, that was at the current
position or that was found on the current line.</p>

<p>Matching shall be determined as follows, for an open
parenthesis:</p>

<p>1. Set a counter to 1.</p>

<p>2. Search forwards until a parenthesis is found or the
end of the edit buffer is reached.</p>

<p>3. If the end of the edit buffer is reached, it shall be
an error.</p>

<p>4. If an open parenthesis is found, increment the
counter by 1.</p>

<p>5. If a close parenthesis is found, decrement the
counter by 1.</p>

<p>6. If the counter is zero, the current character is the
matching char- acter.</p>

<p>Matching for a close parenthesis shall be equivalent,
except that the search shall be backwards, from the starting
character to the beginning of the buffer, a close
parenthesis shall increment the counter by 1, and an open
parenthesis shall decrement the counter by 1.</p>

<p>Matching for brackets and curly braces shall be
equivalent, except that searching shall be done for open and
close brackets or open and close curly braces. It is
implementation-defined whether other characters are searched
for and matched as well.</p>

<p>If used as a motion command:</p>

<p>1. If the matching cursor was after the starting cursor
in the edit buffer, and the starting cursor position was at
or before the first non- &lt;blank&gt; non- &lt;newline&gt;
in the starting line, and the matching cursor position was
at or after the last non- &lt;blank&gt; non- &lt;new-
line&gt; in the matching line, the text region shall consist
of the current line to the matching line, inclusive, and any
text copied to a buffer shall be in line mode.</p>

<p>2. If the matching cursor was before the starting cursor
in the edit buffer, and the starting cursor position was at
or after the last non- &lt;blank&gt; non- &lt;newline&gt; in
the starting line, and the matching cursor position was at
or before the first non- &lt;blank&gt; non- &lt;new-
line&gt; in the matching line, the text region shall consist
of the current line to the matching line, inclusive, and any
text copied to a buffer shall be in line mode.</p>

<p>3. Otherwise, the text region shall consist of the
starting character to the matching character, inclusive, and
any text copied to a buffer shall be in character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line where the matching
character is located.</p>

<p>Current column: Set to the last column where any portion
of the match- ing character is displayed.</p>

<p>Repeat Substitution Synopsis:</p>

<p>&amp;</p>

<p>Repeat the previous substitution command. This command
shall be equiva- lent to the ex &amp; command with the
current line as its addresses, and without options, count,
or flags.</p>

<p>Return to Previous Context at Beginning of Line
Synopsis:</p>

<p>character</p>

<p>It shall be an error if there is no line in the edit
buffer marked by character.</p>

<p>If used as a motion command:</p>

<p>1. If the starting cursor is after the marked cursor,
then the loca- tions of the starting cursor and the marked
cursor in the edit buffer shall be logically swapped.</p>

<p>2. The text region shall consist of the starting line up
to and including the marked line, and any text copied to a
buffer shall be in line mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line referenced by the
mark.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Return to Previous Context Synopsis:</p>

<p>character</p>

<p>It shall be an error if the marked line is no longer in
the edit buffer. If the marked line no longer contains a
character in the saved numbered character position, it shall
be as if the marked position is the first non-
&lt;blank&gt;.</p>

<p>If used as a motion command:</p>

<p>1. It shall be an error if the marked cursor references
the same char- acter in the edit buffer as the starting
cursor.</p>

<p>2. If the starting cursor is after the marked cursor,
then the loca- tions of the starting cursor and the marked
cursor in the edit buffer shall be logically swapped.</p>

<p>3. If the starting line is empty or the starting cursor
is at or before the first non- &lt;blank&gt; non-
&lt;newline&gt; of the starting line, and the marked cursor
line is empty or the marked cursor references the first
character of the marked cursor line, the text region shall
consist of all lines containing characters from the starting
cursor to the line before the marked cursor line, inclusive,
and any text copied to a buffer shall be in line mode.</p>

<p>4. Otherwise, if the marked cursor line is empty or the
marked cursor references a character at or before the first
non- &lt;blank&gt; non- &lt;newline&gt; of the marked cursor
line, the region of text shall be from the starting cursor
to the last non- &lt;newline&gt; of the line before the
marked cursor line, inclusive, and any text copied to a
buffer shall be in character mode.</p>

<p>5. Otherwise, the region of text shall be from the
starting cursor (inclusive), to the marked cursor
(exclusive), and any text copied to a buffer shall be in
character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line referenced by the
mark.</p>

<p>Current column: Set to the last column in which any
portion of the character referenced by the mark is
displayed.</p>

<p>Return to Previous Section Synopsis:</p>

<p>[count] [[</p>

<p>Move the cursor backward through the edit buffer to the
first character of the previous section boundary, count
times.</p>

<p>If used as a motion command:</p>

<p>1. If the starting cursor was at the first character of
the starting line or the starting line was empty, and the
first character of the boundary was the first character of
the boundary line, the text region shall consist of the
current line up to and including the line where the countth
next boundary starts, and any text copied to a buffer shall
be in line mode.</p>

<p>2. If the boundary was the last line of the edit buffer
or the last non- &lt;newline&gt; of the last line of the
edit buffer, the text region shall consist of the last
character in the edit buffer up to and including the
starting character, and any text saved to a buffer shall be
in character mode.</p>

<p>3. Otherwise, the text region shall consist of the
starting character up to but not including the first
character in the countth next boundary, and any text copied
to a buffer shall be in character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line where the countth next
boundary in the edit buffer starts.</p>

<p>Current column: Set to the last column in which any
portion of the first character of the countth next boundary
is displayed, or column position 1 if the line is empty.</p>

<p>Move to Next Section Synopsis:</p>

<p>[count] ]]</p>

<p>Move the cursor forward through the edit buffer to the
first character of the next section boundary, count
times.</p>

<p>If used as a motion command:</p>

<p>1. If the starting cursor was at the first character of
the starting line or the starting line was empty, and the
first character of the boundary was the first character of
the boundary line, the text region shall consist of the
current line up to and including the line where the countth
previous boundary starts, and any text copied to a buffer
shall be in line mode.</p>

<p>2. If the boundary was the first line of the edit
buffer, the text region shall consist of the first character
in the edit buffer up to but not including the starting
character, and any text copied to a buffer shall be in
character mode.</p>

<p>3. Otherwise, the text region shall consist of the first
character in the countth previous section boundary up to but
not including the starting character, and any text copied to
a buffer shall be in character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line where the countth previous
boundary in the edit buffer starts.</p>

<p>Current column: Set to the last column in which any
portion of the first character of the countth previous
boundary is displayed, or col- umn position 1 if the line is
empty.</p>

<p>Move to First Non-&lt;blank&gt; Position on Current Line
Synopsis:</p>

<p>^</p>

<p>If used as a motion command:</p>

<p>1. If the line has no non- &lt;blank&gt; non-
&lt;newline&gt;s, or if the cursor is at the first non-
&lt;blank&gt; non- &lt;newline&gt; of the line, it shall be
an error.</p>

<p>2. If the cursor is before the first non- &lt;blank&gt;
non- &lt;newline&gt; of the line, the text region shall be
comprised of the current charac- ter, up to, but not
including, the first non- &lt;blank&gt; non- &lt;new-
line&gt; of the line.</p>

<p>3. If the cursor is after the first non- &lt;blank&gt;
non- &lt;newline&gt; of the line, the text region shall be
from the character before the start- ing cursor up to and
including the first non- &lt;blank&gt; non- &lt;new-
line&gt; of the line.</p>

<p>4. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Current and Line Above Synopsis:</p>

<p>[count] _</p>

<p>If there are less than count -1 lines after the current
line in the edit buffer, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. If count is less than 2, the text region shall be the
current line.</p>

<p>2. Otherwise, the text region shall include the starting
line and the next count -1 lines.</p>

<p>3. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to current line + count -1.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Move Back to Beginning of Sentence Synopsis:</p>

<p>[count] (</p>

<p>Move backward to the beginning of a sentence. This
command shall be equivalent to the [[ command, with the
exception that sentence bound- aries shall be used instead
of section boundaries.</p>

<p>Move Forward to Beginning of Sentence Synopsis:</p>

<p>[count] )</p>

<p>Move forward to the beginning of a sentence. This
command shall be equivalent to the ]] command, with the
exception that sentence bound- aries shall be used instead
of section boundaries.</p>

<p>Move Back to Preceding Paragraph Synopsis:</p>

<p>[count] {</p>

<p>Move back to the beginning of the preceding paragraph.
This command shall be equivalent to the [[ command, with the
exception that para- graph boundaries shall be used instead
of section boundaries.</p>

<p>Move Forward to Next Paragraph Synopsis:</p>

<p>[count] }</p>

<p>Move forward to the beginning of the next paragraph.
This command shall be equivalent to the ]] command, with the
exception that paragraph boundaries shall be used instead of
section boundaries.</p>

<p>Move to Specific Column Position Synopsis:</p>

<p>[count] |</p>

<p>For the purposes of this command, lines that are too
long for the cur- rent display and that have been folded
shall be treated as having a single, 1-based, number of
columns.</p>

<p>If there are less than count columns in which characters
from the cur- rent line are displayed on the screen, count
shall be adjusted to be the last column in which any portion
of the line is displayed on the screen.</p>

<p>If used as a motion command:</p>

<p>1. If the line is empty, or the cursor character is the
same as the character on the countth column of the line, it
shall be an error.</p>

<p>2. If the cursor is before the countth column of the
line, the text region shall be comprised of the current
character, up to but not including the character on the
countth column of the line.</p>

<p>3. If the cursor is after the countth column of the
line, the text region shall be from the character before the
starting cursor up to and including the character on the
countth column of the line.</p>

<p>4. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column in which any
portion of the character that is displayed in the count
column of the line is dis- played.</p>

<p>Reverse Find Character Synopsis:</p>

<p>[count] ,</p>

<p>If the last F, f, T, or t command was F, f, T, or t,
this command shall be equivalent to an f, F, t, or T
command, respectively, with the spec- ified count and the
same search character.</p>

<p>If there was no previous F, f, T, or t command, it shall
be an error.</p>

<p>Repeat Synopsis:</p>

<p>[count] .</p>

<p>Repeat the last !, &lt;, &gt;, A, C, D, I, J, O, P, R,
S, X, Y, a, c, d, i, o, p, r, s, x, y, or ~ command. It
shall be an error if none of these commands have been
executed. Commands (other than commands that enter text
input mode) executed as a result of map expansions, shall
not change the value of the last repeatable command.</p>

<p>Repeated commands with associated motion commands shall
repeat the motion command as well; however, any specified
count shall replace the count(s) that were originally
specified to the repeated command or its associated motion
command.</p>

<p>If the motion component of the repeated command is f, F,
t, or T, the repeated command shall not set the remembered
search character for the ; and , commands.</p>

<p>If the repeated command is p or P, and the buffer
associated with that command was a numeric buffer named with
a number less than 9, the buffer associated with the
repeated command shall be set to be the buffer named by the
name of the previous buffer logically incremented by 1.</p>

<p>If the repeated character is a text input command, the
input text asso- ciated with that command is repeated
literally:</p>

<p>* Input characters are neither macro or
abbreviation-expanded.</p>

<p>* Input characters are not interpreted in any special
way with the exception that &lt;newline&gt;,
&lt;carriage-return&gt;, and &lt;control&gt;-T behave as
described in Input Mode Commands in vi .</p>

<p>Current line: Set as described for the repeated
command.</p>

<p>Current column: Set as described for the repeated
command.</p>

<p>Find Regular Expression Synopsis:</p>

<p>/</p>

<p>If the input line contains no non- &lt;newline&gt;s, it
shall be equivalent to a line containing only the last
regular expression encountered. The enhanced regular
expressions supported by vi are described in Regular
Expressions in ex .</p>

<p>Otherwise, the line shall be interpreted as one or more
regular expres- sions, optionally followed by an address
offset or a vi z command.</p>

<p>If the regular expression is not the last regular
expression on the line, or if a line offset or z command is
specified, the regular expression shall be terminated by an
unescaped / character, which shall not be used as part of
the regular expression. If the regular expression is not the
first regular expression on the line, it shall be preceded
by zero or more &lt;blank&gt;s, a semicolon, zero or more
&lt;blank&gt;s, and a leading/character, which shall not be
interpreted as part of the regular expression. It shall be
an error to precede any regular expression with any
characters other than these.</p>

<p>Each search shall begin from the character after the
first character of the last match (or, if it is the first
search, after the cursor). If the wrapscan edit option is
set, the search shall continue to the char- acter before the
starting cursor character; otherwise, to the end of the edit
buffer. It shall be an error if any search fails to find a
match, and an informational message to this effect shall be
displayed.</p>

<p>An optional address offset (see Addressing in ex ) can
be specified after the last regular expression by including
a trailing/ character after the regular expression and
specifying the address offset. This offset will be from the
line containing the match for the last regular expression
specified. It shall be an error if the line offset would
indicate a line address less than 1 or greater than the last
line in the edit buffer. An address offset of zero shall be
supported. It shall be an error to follow the address offset
with any other characters than &lt;blank&gt;s.</p>

<p>If not used as a motion command, an optional z command
(see Redraw Win- dow ) can be specified after the last
regular expression by including a trailing / character after
the regular expression, zero or more &lt;blank&gt;s, a z,
zero or more &lt;blank&gt;s, an optional new window edit
option value, zero or more &lt;blank&gt;s, and a location
character. The effect shall be as if the z command was
executed after the / command. It shall be an error to follow
the z command with any other characters than
&lt;blank&gt;s.</p>

<p>The remembered search direction shall be set to
forward.</p>

<p>If used as a motion command:</p>

<p>1. It shall be an error if the last match references the
same charac- ter in the edit buffer as the starting
cursor.</p>

<p>2. If any address offset is specified, the last match
shall be adjusted by the specified offset as described
previously.</p>

<p>3. If the starting cursor is after the last match, then
the locations of the starting cursor and the last match in
the edit buffer shall be logically swapped.</p>

<p>4. If any address offset is specified, the text region
shall consist of all lines containing characters from the
starting cursor to the last match line, inclusive, and any
text copied to a buffer shall be in line mode.</p>

<p>5. Otherwise, if the starting line is empty or the
starting cursor is at or before the first non- &lt;blank&gt;
non- &lt;newline&gt; of the starting line, and the last
match line is empty or the last match starts at the first
character of the last match line, the text region shall
consist of all lines containing characters from the starting
cursor to the line before the last match line, inclusive,
and any text copied to a buffer shall be in line mode.</p>

<p>6. Otherwise, if the last match line is empty or the
last match begins at a character at or before the first non-
&lt;blank&gt; non- &lt;newline&gt; of the last match line,
the region of text shall be from the cur- rent cursor to the
last non- &lt;newline&gt; of the line before the last match
line, inclusive, and any text copied to a buffer shall be in
character mode.</p>

<p>7. Otherwise, the region of text shall be from the
current cursor (inclusive), to the first character of the
last match (exclusive), and any text copied to a buffer
shall be in character mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: If a match is found, set to the last
matched line plus the address offset, if any; otherwise,
unchanged.</p>

<p>Current column: Set to the last column on which any
portion of the first character in the last matched string is
displayed, if a match is found; otherwise, unchanged.</p>

<p>Move to First Character in Line Synopsis:</p>

<p>0 (zero)</p>

<p>Move to the first character on the current line. The
character0 shall not be interpreted as a command if it is
immediately preceded by a digit.</p>

<p>If used as a motion command:</p>

<p>1. If the cursor character is the first character in the
line, it shall be an error.</p>

<p>2. The text region shall be from the character before
the cursor char- acter up to and including the first
character in the line.</p>

<p>3. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: The last column in which any portion of
the first char- acter in the line is displayed, or if the
line is empty, unchanged.</p>

<p>Execute an ex Command Synopsis:</p>

<p>:</p>

<p>Execute one or more ex commands.</p>

<p>If any portion of the screen other than the last line of
the screen was overwritten by any ex command (except shell),
vi shall display a mes- sage indicating that it is waiting
for an input from the user, and shall then read a character.
This action may also be taken for other, unspecified
reasons.</p>

<p>If the next character entered is a, another ex command
shall be accepted and executed. Any other character shall
cause the screen to be refreshed and vi shall return to
command mode.</p>

<p>Current line: As specified for the ex command.</p>

<p>Current column: As specified for the ex command.</p>

<p>Repeat Find Synopsis:</p>

<p>[count] ;</p>

<p>This command shall be equivalent to the last F, f, T, or
t command, with the specified count, and with the same
search character used for the last F, f, T, or t command. If
there was no previous F, f, T, or t command, it shall be an
error.</p>

<p>Shift Left Synopsis:</p>

<p>[count] &lt; motion</p>

<p>If the motion command is the &lt; command repeated:</p>

<p>1. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>2. The text region shall be from the current line, up to
and including the next count -1 lines.</p>

<p>Shift any line in the text region specified by the count
and motion command one shiftwidth (see the ex shiftwidth
option) toward the start of the line, as described by the ex
&lt; command. The unshifted lines shall be copied to the
unnamed buffer in line mode.</p>

<p>Current line: If the motion was from the current cursor
position toward the end of the edit buffer, unchanged.
Otherwise, set to the first line in the edit buffer that is
part of the text region specified by the motion command.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Shift Right Synopsis:</p>

<p>[count] &gt; motion</p>

<p>If the motion command is the &gt; command repeated:</p>

<p>1. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>2. The text region shall be from the current line, up to
and including the next count -1 lines.</p>

<p>Shift any line with characters in the text region
specified by the count and motion command one shiftwidth
(see the ex shiftwidth option) away from the start of the
line, as described by the ex &gt; command. The unshifted
lines shall be copied into the unnamed buffer in line
mode.</p>

<p>Current line: If the motion was from the current cursor
position toward the end of the edit buffer, unchanged.
Otherwise, set to the first line in the edit buffer that is
part of the text region specified by the motion command.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Scan Backwards for Regular Expression Synopsis:</p>

<p>?</p>

<p>Scan backwards; the ? command shall be equivalent to the
/ command (see Find Regular Expression ) with the following
exceptions:</p>

<p>1. The input prompt shall be a?.</p>

<p>2. Each search shall begin from the character before the
first charac- ter of the last match (or, if it is the first
search, the character before the cursor character).</p>

<p>3. The search direction shall be from the cursor toward
the beginning of the edit buffer, and the wrapscan edit
option shall affect whether the search wraps to the end of
the edit buffer and contin- ues.</p>

<p>4. The remembered search direction shall be set to
backward.</p>

<p>Execute Synopsis:</p>

<p>@buffer</p>

<p>If the buffer is specified as @, the last buffer
executed shall be used. If no previous buffer has been
executed, it shall be an error.</p>

<p>Behave as if the contents of the named buffer were
entered as standard input. After each line of a line-mode
buffer, and all but the last line of a character mode
buffer, behave as if a &lt;newline&gt; were entered as
standard input.</p>

<p>If an error occurs during this process, an error message
shall be writ- ten, and no more characters resulting from
the execution of this com- mand shall be processed.</p>

<p>If a count is specified, behave as if that count were
entered as user input before the characters from the @
buffer were entered.</p>

<p>Current line: As specified for the individual
commands.</p>

<p>Current column: As specified for the individual
commands.</p>

<p>Reverse Case Synopsis:</p>

<p>[count] ~</p>

<p>Reverse the case of the current character and the next
count -1 charac- ters, such that lowercase characters that
have uppercase counterparts shall be changed to uppercase
characters, and uppercase characters that have lowercase
counterparts shall be changed to lowercase characters, as
prescribed by the current locale. No other characters shall
be affected by this command.</p>

<p>If there are less than count -1 characters after the
cursor in the edit buffer, count shall be adjusted to the
number of characters after the cursor in the edit buffer
minus 1.</p>

<p>For the purposes of this command, the next character
after the last non- &lt;newline&gt; on the line shall be the
next character in the edit buffer.</p>

<p>Current line: Set to the line including the ( count-1)th
character after the cursor.</p>

<p>Current column: Set to the last column in which any
portion of the ( count-1)th character after the cursor is
displayed.</p>

<p>Append Synopsis:</p>

<p>[count] a</p>

<p>Enter text input mode after the current cursor position.
No characters already in the edit buffer shall be affected
by this command. A count shall cause the input text to be
appended count -1 more times to the end of the input.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Append at End-of-Line Synopsis:</p>

<p>[count] A</p>

<p>This command shall be equivalent to the vi command:</p>

<p>$ [ count ] a</p>

<p>(see Append ).</p>

<p>Move Backward to Preceding Word Synopsis:</p>

<p>[count] b</p>

<p>With the exception that words are used as the delimiter
instead of big- words, this command shall be equivalent to
the B command.</p>

<p>Move Backward to Preceding Bigword Synopsis:</p>

<p>[count] B</p>

<p>If the edit buffer is empty or the cursor is on the
first character of the edit buffer, it shall be an error. If
less than count bigwords begin between the cursor and the
start of the edit buffer, count shall be adjusted to the
number of bigword beginnings between the cursor and the
start of the edit buffer.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the first character of
the countth previous bigword beginning up to but not
including the cursor char- acter.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line containing the current
column.</p>

<p>Current column: Set to the last column upon which any
part of the first character of the countth previous bigword
is displayed.</p>

<p>Change Synopsis:</p>

<p>[buffer][count] c motion</p>

<p>If the motion command is the c command repeated:</p>

<p>1. The buffer text shall be in line mode.</p>

<p>2. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>3. The text region shall be from the current line up to
and including the next count -1 lines.</p>

<p>Otherwise, the buffer text mode and text region shall be
as specified by the motion command.</p>

<p>The replaced text shall be copied into buffer, if
specified, and into the unnamed buffer. If the text to be
replaced contains characters from more than a single line,
or the buffer text is in line mode, the replaced text shall
be copied into the numeric buffers as well.</p>

<p>If the buffer text is in line mode:</p>

<p>1. Any lines that contain characters in the region shall
be deleted, and the editor shall enter text input mode at
the beginning of a new line which shall replace the first
line deleted.</p>

<p>2. If the autoindent edit option is set, autoindent
characters equal to the autoindent characters on the first
line deleted shall be inserted as if entered by the
user.</p>

<p>Otherwise, if characters from more than one line are in
the region of text:</p>

<p>1. The text shall be deleted.</p>

<p>2. Any text remaining in the last line in the text
region shall be appended to the first line in the region,
and the last line in the region shall be deleted.</p>

<p>3. The editor shall enter text input mode after the last
character not deleted from the first line in the text
region, if any; otherwise, on the first column of the first
line in the region.</p>

<p>Otherwise:</p>

<p>1. If the glyph for$is smaller than the region, the end
of the region shall be marked with a$.</p>

<p>2. The editor shall enter text input mode, overwriting
the region of text.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Change to End-of-Line Synopsis:</p>

<p>[buffer][count] C</p>

<p>This command shall be equivalent to the vi command:</p>

<p>[buffer][count] c$</p>

<p>See the c command.</p>

<p>Delete Synopsis:</p>

<p>[buffer][count] d motion</p>

<p>If the motion command is the d command repeated:</p>

<p>1. The buffer text shall be in line mode.</p>

<p>2. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>3. The text region shall be from the current line up to
and including the next count -1 lines.</p>

<p>Otherwise, the buffer text mode and text region shall be
as specified by the motion command.</p>

<p>If in open mode, and the current line is deleted, and
the line remains on the display, an@character shall be
displayed as the first glyph of that line.</p>

<p>Delete the region of text into buffer, if specified, and
into the unnamed buffer. If the text to be deleted contains
characters from more than a single line, or the buffer text
is in line mode, the deleted text shall be copied into the
numeric buffers, as well.</p>

<p>Current line: Set to the first text region line that
appears in the edit buffer, unless that line has been
deleted, in which case it shall be set to the last line in
the edit buffer, or line 1 if the edit buffer is empty.</p>

<p>Current column:</p>

<p>1. If the line is empty, set to column position 1.</p>

<p>2. Otherwise, if the buffer text is in line mode or the
motion was from the cursor toward the end of the edit
buffer:</p>

<p>a. If a character from the current line is displayed in
the cur- rent column, set to the last column that displays
any portion of that character.</p>

<p>b. Otherwise, set to the last column in which any
portion of any character in the line is displayed.</p>

<p>3. Otherwise, if a character is displayed in the column
that began the text region, set to the last column that
displays any portion of that character.</p>

<p>4. Otherwise, set to the last column in which any
portion of any char- acter in the line is displayed.</p>

<p>Delete to End-of-Line Synopsis:</p>

<p>[buffer] D</p>

<p>Delete the text from the current position to the end of
the current line; equivalent to the vi command:</p>

<p>[buffer] d$</p>

<p>Move to End-of-Word Synopsis:</p>

<p>[count] e</p>

<p>With the exception that words are used instead of
bigwords as the delimiter, this command shall be equivalent
to the E command.</p>

<p>Move to End-of-Bigword Synopsis:</p>

<p>[count] E</p>

<p>If the edit buffer is empty it shall be an error. If
less than count bigwords end between the cursor and the end
of the edit buffer, count shall be adjusted to the number of
bigword endings between the cursor and the end of the edit
buffer.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the last character of
the countth next bigword up to and including the cursor
character.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to the line containing the current
column.</p>

<p>Current column: Set to the last column upon which any
part of the last character of the countth next bigword is
displayed.</p>

<p>Find Character in Current Line (Forward) Synopsis:</p>

<p>[count] f character</p>

<p>It shall be an error if count occurrences of the
character do not occur after the cursor in the line.</p>

<p>If used as a motion command:</p>

<p>1. The text range shall be from the cursor character up
to and includ- ing the countth occurrence of the specified
character after the cursor.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column in which any
portion of the countth occurrence of the specified character
after the cursor appears in the line.</p>

<p>Find Character in Current Line (Reverse) Synopsis:</p>

<p>[count] F character</p>

<p>It shall be an error if count occurrences of the
character do not occur before the cursor in the line.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the countth occurrence
of the speci- fied character before the cursor, up to, but
not including the cur- sor character.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column in which any
portion of the countth occurrence of the specified character
before the cursor appears in the line.</p>

<p>Move to Line Synopsis:</p>

<p>[count] G</p>

<p>If count is not specified, it shall default to the last
line of the edit buffer. If count is greater than the last
line of the edit buffer, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the cursor line up to
and including the specified line.</p>

<p>2. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Set to count if count is specified;
otherwise, the last line.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Move to Top of Screen Synopsis:</p>

<p>[count] H</p>

<p>If the beginning of the line count greater than the
first line of which any portion appears on the display does
not exist, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. If in open mode, the text region shall be the current
line.</p>

<p>2. Otherwise, the text region shall be from the starting
line up to and including (the first line of the display +
count -1).</p>

<p>3. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>If in open mode, this command shall set the current
column to non- &lt;blank&gt; and do nothing else.</p>

<p>Otherwise, it shall set the current line and current
column as follows.</p>

<p>Current line: Set to (the first line of the display +
count -1).</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Insert Before Cursor Synopsis:</p>

<p>[count] i</p>

<p>Enter text input mode before the current cursor
position. No characters already in the edit buffer shall be
affected by this command. A count shall cause the input text
to be appended count -1 more times to the end of the
input.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Insert at Beginning of Line Synopsis:</p>

<p>[count] I</p>

<p>This command shall be equivalent to the vi command ^[
count] i.</p>

<p>Join Synopsis:</p>

<p>[count] J</p>

<p>If the current line is the last line in the edit buffer,
it shall be an error.</p>

<p>This command shall be equivalent to the ex join command
with no addresses, and an ex command count value of 1 if
count was not speci- fied or if a count of 1 was specified,
and an ex command count value of count -1 for any other
value of count, except that the current line and column
shall be set as follows.</p>

<p>Current line: Unchanged.</p>

<p>Current column: The last column in which any portion of
the character following the last character in the initial
line is displayed, or the last non- &lt;newline&gt; in the
line if no characters were appended.</p>

<p>Move to Bottom of Screen Synopsis:</p>

<p>[count] L</p>

<p>If the beginning of the line count less than the last
line of which any portion appears on the display does not
exist, it shall be an error.</p>

<p>If used as a motion command:</p>

<p>1. If in open mode, the text region shall be the current
line.</p>

<p>2. Otherwise, the text region shall include all lines
from the start- ing cursor line to (the last line of the
display -( count -1)).</p>

<p>3. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>1. If in open mode, this command shall set the current
column to non- &lt;blank&gt; and do nothing else.</p>

<p>2. Otherwise, it shall set the current line and current
column as fol- lows.</p>

<p>Current line: Set to (the last line of the display -(
count -1)).</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Mark Position Synopsis:</p>

<p>m letter</p>

<p>This command shall be equivalent to the ex mark command
with the speci- fied character as an argument.</p>

<p>Move to Middle of Screen Synopsis:</p>

<p>M</p>

<p>The middle line of the display shall be calculated as
follows:</p>

<p>(the top line of the display) + (((number of lines
displayed) +1) /2) -1</p>

<p>If used as a motion command:</p>

<p>1. If in open mode, the text region shall be the current
line.</p>

<p>2. Otherwise, the text region shall include all lines
from the start- ing cursor line up to and including the
middle line of the display.</p>

<p>3. Any text copied to a buffer shall be in line
mode.</p>

<p>If not used as a motion command:</p>

<p>If in open mode, this command shall set the current
column to non- &lt;blank&gt; and do nothing else.</p>

<p>Otherwise, it shall set the current line and current
column as follows.</p>

<p>Current line: Set to the middle line of the display.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Repeat Regular Expression Find (Forward) Synopsis:</p>

<p>n</p>

<p>If the remembered search direction was forward, the n
command shall be equivalent to the vi / command with no
characters entered by the user. Otherwise, it shall be
equivalent to the vi ? command with no charac- ters entered
by the user.</p>

<p>If the n command is used as a motion command for the !
command, the editor shall not enter text input mode on the
last line on the screen, and shall behave as if the user
entered a single!character as the text input.</p>

<p>Repeat Regular Expression Find (Reverse) Synopsis:</p>

<p>N</p>

<p>Scan for the next match of the last pattern given to /
or ?, but in the reverse direction; this is the reverse of
n.</p>

<p>If the remembered search direction was forward, the N
command shall be equivalent to the vi ? command with no
characters entered by the user. Otherwise, it shall be
equivalent to the vi / command with no charac- ters entered
by the user. If the N command is used as a motion command
for the ! command, the editor shall not enter text input
mode on the last line on the screen, and shall behave as if
the user entered a sin- gle ! character as the text
input.</p>

<p>Insert Empty Line Below Synopsis:</p>

<p>o</p>

<p>Enter text input mode in a new line appended after the
current line. A count shall cause the input text to be
appended count -1 more times to the end of the already added
text, each time starting on a new, appended line.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Insert Empty Line Above Synopsis:</p>

<p>O</p>

<p>Enter text input mode in a new line inserted before the
current line. A count shall cause the input text to be
appended count -1 more times to the end of the already added
text, each time starting on a new, appended line.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Put from Buffer Following Synopsis:</p>

<p>[buffer] p</p>

<p>If no buffer is specified, the unnamed buffer shall be
used.</p>

<p>If the buffer text is in line mode, the text shall be
appended below the current line, and each line of the buffer
shall become a new line in the edit buffer. A count shall
cause the buffer text to be appended count -1 more times to
the end of the already added text, each time starting on a
new, appended line.</p>

<p>If the buffer text is in character mode, the text shall
be appended into the current line after the cursor, and each
line of the buffer other than the first and last shall
become a new line in the edit buffer. A count shall cause
the buffer text to be appended count -1 more times to the
end of the already added text, each time starting after the
last added character.</p>

<p>Current line: If the buffer text is in line mode, set
the line to line +1; otherwise, unchanged.</p>

<p>Current column: If the buffer text is in line mode:</p>

<p>1. If there is a non- &lt;blank&gt; in the first line of
the buffer, set to the last column on which any portion of
the first non- &lt;blank&gt; in the line is displayed.</p>

<p>2. If there is no non- &lt;blank&gt; in the first line
of the buffer, set to the last column on which any portion
of the last non- &lt;newline&gt; in the first line of the
buffer is displayed.</p>

<p>If the buffer text is in character mode:</p>

<p>1. If the text in the buffer is from more than a single
line, then set to the last column on which any portion of
the first character from the buffer is displayed.</p>

<p>2. Otherwise, if the buffer is the unnamed buffer, set
to the last column on which any portion of the last
character from the buffer is displayed.</p>

<p>3. Otherwise, set to the first column on which any
portion of the first character from the buffer is
displayed.</p>

<p>Put from Buffer Before Synopsis:</p>

<p>[buffer] P</p>

<p>If no buffer is specified, the unnamed buffer shall be
used.</p>

<p>If the buffer text is in line mode, the text shall be
inserted above the current line, and each line of the buffer
shall become a new line in the edit buffer. A count shall
cause the buffer text to be appended count -1 more times to
the end of the already added text, each time starting on a
new, appended line.</p>

<p>If the buffer text is in character mode, the text shall
be inserted into the current line before the cursor, and
each line of the buffer other than the first and last shall
become a new line in the edit buffer. A count shall cause
the buffer text to be appended count -1 more times to the
end of the already added text, each time starting after the
last added character.</p>

<p>Current line: Unchanged.</p>

<p>Current column: If the buffer text is in line mode:</p>

<p>1. If there is a non- &lt;blank&gt; in the first line of
the buffer, set to the last column on which any portion of
that character is dis- played.</p>

<p>2. If there is no non- &lt;blank&gt; in the first line
of the buffer, set to the last column on which any portion
of the last non- &lt;newline&gt; in the first line of the
buffer is displayed.</p>

<p>If the buffer text is in character mode:</p>

<p>1. If the buffer is the unnamed buffer, set to the last
column on which any portion of the last character from the
buffer is dis- played.</p>

<p>2. Otherwise, set to the first column on which any
portion of the first character from the buffer is
displayed.</p>

<p>Enter ex Mode Synopsis:</p>

<p>Q</p>

<p>Leave visual or open mode and enter ex command mode.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>Replace Character Synopsis:</p>

<p>[count] r character</p>

<p>Replace the count characters at and after the cursor
with the specified character. If there are less than count
non- &lt;newline&gt;s at and after the cursor on the line,
it shall be an error.</p>

<p>If character is &lt;control&gt;-V, any next character
other than the &lt;new- line&gt; shall be stripped of any
special meaning and used as a literal character.</p>

<p>If character is &lt;ESC&gt;, no replacement shall be
made and the current line and current column shall be
unchanged.</p>

<p>If character is &lt;carriage-return&gt; or
&lt;newline&gt;, count new lines shall be appended to the
current line. All but the last of these lines shall be
empty. count characters at and after the cursor shall be
discarded, and any remaining characters after the cursor in
the current line shall be moved to the last of the new
lines. If the autoindent edit option is set, they shall be
preceded by the same number of autoindent characters found
on the line from which the command was executed.</p>

<p>Current line: Unchanged unless the replacement character
is a &lt;car- riage-return&gt; or &lt;newline&gt;, in which
case it shall be set to line + count.</p>

<p>Current column: Set to the last column position on which
a portion of the last replaced character is displayed, or if
the replacement charac- ter caused new lines to be created,
set to non- &lt;blank&gt;.</p>

<p>Replace Characters Synopsis:</p>

<p>R</p>

<p>Enter text input mode at the current cursor position
possibly replacing text on the current line. A count shall
cause the input text to be appended count -1 more times to
the end of the input.</p>

<p>Current line/column: As specified for the text input
commands (see Input Mode Commands in vi ).</p>

<p>Substitute Character Synopsis:</p>

<p>[buffer][count] s</p>

<p>This command shall be equivalent to the vi command:</p>

<p>[buffer][count] c&lt;space&gt;</p>

<p>Substitute Lines Synopsis:</p>

<p>[buffer][count] S</p>

<p>This command shall be equivalent to the vi command:</p>

<p>[buffer][count] c_</p>

<p>Move Cursor to Before Character (Forward) Synopsis:</p>

<p>[count] t character</p>

<p>It shall be an error if count occurrences of the
character do not occur after the cursor in the line.</p>

<p>If used as a motion command:</p>

<p>1. The text region shall be from the cursor up to but
not including the countth occurrence of the specified
character after the cursor.</p>

<p>2. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column in which any
portion of the character before the countth occurrence of
the specified character after the cursor appears in the
line.</p>

<p>Move Cursor to After Character (Reverse) Synopsis:</p>

<p>[count] T character</p>

<p>It shall be an error if count occurrences of the
character do not occur before the cursor in the line.</p>

<p>If used as a motion command:</p>

<p>1. If the character before the cursor is the specified
character, it shall be an error.</p>

<p>2. The text region shall be from the character before
the cursor up to but not including the countth occurrence of
the specified character before the cursor.</p>

<p>3. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the last column in which any
portion of the character after the countth occurrence of the
specified character before the cursor appears in the
line.</p>

<p>Undo Synopsis:</p>

<p>u</p>

<p>This command shall be equivalent to the ex undo command
except that the current line and current column shall be set
as follows:</p>

<p>Current line: Set to the first line added or changed if
any; otherwise, move to the line preceding any deleted text
if one exists; otherwise, move to line 1.</p>

<p>Current column: If undoing an ex command, set to the
first non- &lt;blank&gt;.</p>

<p>Otherwise, if undoing a text input command:</p>

<p>1. If the command was a C, c, O, o, R, S, or s command,
the current column shall be set to the value it held when
the text input com- mand was entered.</p>

<p>2. Otherwise, set to the last column in which any
portion of the first character after the deleted text is
displayed, or, if no non- &lt;new- line&gt;s follow the text
deleted from this line, set to the last col- umn in which
any portion of the last non- &lt;newline&gt; in the line is
displayed, or 1 if the line is empty.</p>

<p>Otherwise, if a single line was modified (that is, not
added or deleted) by the u command:</p>

<p>1. If text was added or changed, set to the last column
in which any portion of the first character added or changed
is displayed.</p>

<p>2. If text was deleted, set to the last column in which
any portion of the first character after the deleted text is
displayed, or, if no non- &lt;newline&gt;s follow the
deleted text, set to the last column in which any portion of
the last non- &lt;newline&gt; in the line is dis- played, or
1 if the line is empty.</p>

<p>Otherwise, set to non- &lt;blank&gt;.</p>

<p>Undo Current Line Synopsis:</p>

<p>U</p>

<p>Restore the current line to its state immediately before
the most recent time that it became the current line.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to the first column in the line in
which any por- tion of the first character in the line is
displayed.</p>

<p>Move to Beginning of Word Synopsis:</p>

<p>[count] w</p>

<p>With the exception that words are used as the delimiter
instead of big- words, this command shall be equivalent to
the W command.</p>

<p>Move to Beginning of Bigword Synopsis:</p>

<p>[count] W</p>

<p>If the edit buffer is empty, it shall be an error. If
there are less than count bigwords between the cursor and
the end of the edit buffer, count shall be adjusted to move
the cursor to the last bigword in the edit buffer.</p>

<p>If used as a motion command:</p>

<p>1. If the associated command is c, count is 1, and the
cursor is on a &lt;blank&gt;, the region of text shall be
the current character and no further action shall be
taken.</p>

<p>2. If there are less than count bigwords between the
cursor and the end of the edit buffer, then the command
shall succeed, and the region of text shall include the last
character of the edit buffer.</p>

<p>3. If there are &lt;blank&gt;s or an end-of-line that
precede the countth bigword, and the associated command is
c, the region of text shall be up to and including the last
character before the preceding &lt;blank&gt;s or
end-of-line.</p>

<p>4. If there are &lt;blank&gt;s or an end-of-line that
precede the bigword, and the associated command is d or y,
the region of text shall be up to and including the last
&lt;blank&gt; before the start of the big- word or
end-of-line.</p>

<p>5. Any text copied to a buffer shall be in character
mode.</p>

<p>If not used as a motion command:</p>

<p>1. If the cursor is on the last character of the edit
buffer, it shall be an error.</p>

<p>Current line: Set to the line containing the current
column.</p>

<p>Current column: Set to the last column in which any part
of the first character of the countth next bigword is
displayed.</p>

<p>Delete Character at Cursor Synopsis:</p>

<p>[buffer][count] x</p>

<p>Delete the count characters at and after the current
character into buffer, if specified, and into the unnamed
buffer.</p>

<p>If the line is empty, it shall be an error. If there are
less than count non- &lt;newline&gt;s at and after the
cursor on the current line, count shall be adjusted to the
number of non- &lt;newline&gt;s at and after the cursor.</p>

<p>Current line: Unchanged.</p>

<p>Current column: If the line is empty, set to column
position 1. Other- wise, if there were count or less non-
&lt;newline&gt;s at and after the cur- sor on the current
line, set to the last column that displays any part of the
last non- &lt;newline&gt; of the line. Otherwise,
unchanged.</p>

<p>Delete Character Before Cursor Synopsis:</p>

<p>[buffer][count] X</p>

<p>Delete the count characters before the current character
into buffer, if specified, and into the unnamed buffer.</p>

<p>If there are no characters before the current character
on the current line, it shall be an error. If there are less
than count previous char- acters on the current line, count
shall be adjusted to the number of previous characters on
the line.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to (current column - the width of
the deleted char- acters).</p>

<p>Yank Synopsis:</p>

<p>[buffer][count] y motion</p>

<p>Copy (yank) the region of text into buffer, if
specified, and into the unnamed buffer.</p>

<p>If the motion command is the y command repeated:</p>

<p>1. The buffer shall be in line mode.</p>

<p>2. If there are less than count -1 lines after the
current line in the edit buffer, it shall be an error.</p>

<p>3. The text region shall be from the current line up to
and including the next count -1 lines.</p>

<p>Otherwise, the buffer text mode and text region shall be
as specified by the motion command.</p>

<p>Current line: If the motion was from the current cursor
position toward the end of the edit buffer, unchanged.
Otherwise, set to the first line in the edit buffer that is
part of the text region specified by the motion command.</p>

<p>Current column:</p>

<p>1. If the motion was from the current cursor position
toward the end of the edit buffer, unchanged.</p>

<p>2. Otherwise, if the current line is empty, set to
column position 1.</p>

<p>3. Otherwise, set to the last column that displays any
part of the first character in the file that is part of the
text region speci- fied by the motion command.</p>

<p>Yank Current Line Synopsis:</p>

<p>[buffer][count] Y</p>

<p>This command shall be equivalent to the vi command:</p>

<p>[buffer][count] y_</p>

<p>Redraw Window If in open mode, the z command shall have
the Synopsis:</p>

<p>Synopsis:</p>

<p>[count] z</p>

<p>If count is not specified, it shall default to the
window edit option -1. The z command shall be equivalent to
the ex z command, with a type character of = and a count of
count -2, except that the current line and current column
shall be set as follows, and the window edit option shall
not be affected. If the calculation for the count argument
would result in a negative number, the count argument to the
ex z command shall be zero. A blank line shall be written
after the last line is written.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>If not in open mode, the z command shall have the
following Synopsis:</p>

<p>Synopsis:</p>

<p>[line] z [count] character</p>

<p>If line is not specified, it shall default to the
current line. If line is specified, but is greater than the
number of lines in the edit buffer, it shall default to the
number of lines in the edit buffer.</p>

<p>If count is specified, the value of the window edit
option shall be set to count (as described in the ex window
command), and the screen shall be redrawn.</p>

<p>line shall be placed as specified by the following
characters:</p>

<p>&lt;newline&gt;, &lt;carriage-return&gt;</p>

<p>Place the beginning of the line on the first line of the
dis- play.</p>

<p>. Place the beginning of the line in the center of the
display. The middle line of the display shall be calculated
as described for the M command.</p>

<p>- Place an unspecified portion of the line on the last
line of the display.</p>

<p>+ If line was specified, equivalent to the
&lt;newline&gt; case. If line was not specified, display a
screen where the first line of the display shall be (current
last line) +1. If there are no lines after the last line in
the display, it shall be an error.</p>

<p>^ If line was specified, display a screen where the last
line of the display shall contain an unspecified portion of
the first line of a display that had an unspecified portion
of the speci- fied line on the last line of the display. If
this calculation results in a line before the beginning of
the edit buffer, dis- play the first screen of the edit
buffer.</p>

<p>Otherwise, display a screen where the last line of the
display shall contain an unspecified portion of (current
first line -1). If this calculation results in a line before
the beginning of the edit buffer, it shall be an error.</p>

<p>Current line: If line and the^character were
specified:</p>

<p>1. If the first screen was displayed as a result of the
command attempting to display lines before the beginning of
the edit buffer: if the first screen was already displayed,
unchanged; oth- erwise, set to (current first line -1).</p>

<p>2. Otherwise, set to the last line of the display.</p>

<p>If line and the +character were specified, set to the
first line of the display.</p>

<p>Otherwise, if line was specified, set to line.</p>

<p>Otherwise, unchanged.</p>

<p>Current column: Set to non- &lt;blank&gt;.</p>

<p>Exit Synopsis:</p>

<p>ZZ</p>

<p>This command shall be equivalent to the ex xit command
with no addresses, trailing !, or filename (see the ex xit
command).</p>

<p>Input Mode Commands in vi In text input mode, the
current line shall consist of zero or more of the following
categories, plus the terminating &lt;newline&gt;:</p>

<p>1. Characters preceding the text input entry point</p>

<p>Characters in this category shall not be modified during
text input mode.</p>

<p>2. autoindent characters</p>

<p>autoindent characters shall be automatically inserted
into each line that is created in text input mode, either as
a result of entering a &lt;newline&gt; or
&lt;carriage-return&gt; while in text input mode, or as an
effect of the command itself; for example, O or o (see the
ex autoin- dent command), as if entered by the user.</p>

<p>It shall be possible to erase autoindent characters with
the &lt;con- trol&gt;-D command; it is unspecified whether
they can be erased by &lt;con- trol&gt;-H,
&lt;control&gt;-U, and &lt;control&gt;-W characters. Erasing
any autoin- dent character turns the glyph into
erase-columns and deletes the char- acter from the edit
buffer, but does not change its representation on the
screen.</p>

<p>3. Text input characters</p>

<p>Text input characters are the characters entered by the
user. Erasing any text input character turns the glyph into
erase-columns and deletes the character from the edit
buffer, but does not change its representa- tion on the
screen.</p>

<p>Each text input character entered by the user (that does
not have a special meaning) shall be treated as follows:</p>

<p>a. The text input character shall be appended to the
last char- acter in the edit buffer from the first, second,
or third categories.</p>

<p>b. If there are no erase-columns on the screen, the text
input command was the R command, and characters in the fifth
cate- gory from the original line follow the cursor, the
next such character shall be deleted from the edit buffer.
If the slowopen edit option is not set, the corresponding
glyph on the screen shall become erase-columns.</p>

<p>c. If there are erase-columns on the screen, as many
columns as they occupy, or as are necessary, shall be
overwritten to display the text input character. (If only
part of a multi- column glyph is overwritten, the remainder
shall be left on the screen, and continue to be treated as
erase-columns; it is unspecified whether the remainder of
the glyph is modi- fied in any way.)</p>

<p>d. If additional display line columns are needed to
display the text input character:</p>

<p>1. If the slowopen edit option is set, the text input
char- acters shall be displayed on subsequent display line
columns, overwriting any characters displayed in those
columns.</p>

<p>2. Otherwise, any characters currently displayed on or
after the column on the display line where the text input
character is to be displayed shall be pushed ahead the
number of display line columns necessary to display the rest
of the text input character.</p>

<p>4. Erase-columns</p>

<p>Erase-columns are not logically part of the edit buffer,
appearing only on the screen, and may be overwritten on the
screen by subsequent text input characters. When text input
mode ends, all erase-columns shall no longer appear on the
screen.</p>

<p>Erase-columns are initially the region of text specified
by the c com- mand (see Change ); however, erasing
autoindent or text input charac- ters causes the glyphs of
the erased characters to be treated as erase- columns.</p>

<p>5. Characters following the text region for the c
command, or the text input entry point for all other
commands</p>

<p>Characters in this category shall not be modified during
text input mode, except as specified in category 3.b. for
the R text input com- mand, or as &lt;blank&gt;s deleted
when a &lt;newline&gt; or &lt;carriage-return&gt; is
entered.</p>

<p>It is unspecified whether it is an error to attempt to
erase past the beginning of a line that was created by the
entry of a &lt;newline&gt; or &lt;carriage-return&gt; during
text input mode. If it is not an error, the editor shall
behave as if the erasing character was entered immediately
after the last text input character entered on the previous
line, and all of the non- &lt;newline&gt;s on the current
line shall be treated as erase-columns.</p>

<p>When text input mode is entered, or after a text input
mode character is entered (except as specified for the
special characters below), the cursor shall be positioned as
follows:</p>

<p>1. On the first column that displays any part of the
first erase-col- umn, if one exists</p>

<p>2. Otherwise, if the slowopen edit option is set, on the
first display line column after the last character in the
first, second, or third categories, if one exists</p>

<p>3. Otherwise, the first column that displays any part of
the first character in the fifth category, if one exists</p>

<p>4. Otherwise, the display line column after the last
character in the first, second, or third categories, if one
exists</p>

<p>5. Otherwise, on column position 1</p>

<p>The characters that are updated on the screen during
text input mode are unspecified, other than that the last
text input character shall always be updated, and, if the
slowopen edit option is not set, the current cursor
character shall always be updated.</p>

<p>The following specifications are for command characters
entered during text input mode.</p>

<p>NUL Synopsis:</p>

<p>NUL</p>

<p>If the first character of the text input is a NUL, the
most recently input text shall be input as if entered by the
user, and then text input mode shall be exited. The text
shall be input literally; that is, characters are neither
macro or abbreviation expanded, nor are any characters
interpreted in any special manner. It is unspecified whether
implementations shall support more than 256 bytes of
remembered input text.</p>

<p>&lt;control&gt;-D Synopsis:</p>

<p>&lt;control&gt;-D</p>

<p>The &lt;control&gt;-D character shall have no special
meaning when in text input mode for a line-oriented command
(see Command Descriptions in vi ).</p>

<p>This command need not be supported on block-mode
terminals.</p>

<p>If the cursor does not follow an autoindent character,
or an autoindent character and a0or^character:</p>

<p>1. If the cursor is in column position 1, the
&lt;control&gt;-D character shall be discarded and no
further action taken.</p>

<p>2. Otherwise, the &lt;control&gt;-D character shall have
no special meaning.</p>

<p>If the last input character was a, the cursor shall be
moved to column position 1.</p>

<p>Otherwise, if the last input character was a, the cursor
shall be moved to column position 1. In addition, the
autoindent level for the next input line shall be derived
from the same line from which the autoindent level for the
current input line was derived.</p>

<p>Otherwise, the cursor shall be moved back to the column
after the pre- vious shiftwidth (see the ex shiftwidth
command) boundary.</p>

<p>All of the glyphs on columns between the starting cursor
position and (inclusively) the ending cursor position shall
become erase-columns as described in Input Mode Commands in
vi .</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to 1 if the &lt;control&gt;-D was
preceded by a ^ or 0 ; otherwise, set to (column -1)
-((column -2) % shiftwidth).</p>

<p>&lt;control&gt;-H Synopsis:</p>

<p>&lt;control&gt;-H</p>

<p>If in text input mode for a line-oriented command, and
there are no characters to erase, text input mode shall be
terminated, no further action shall be done for this
command, and the current line and column shall be
unchanged.</p>

<p>If there are characters other than autoindent characters
that have been input on the current line before the cursor,
the cursor shall move back one character.</p>

<p>Otherwise, if there are autoindent characters on the
current line before the cursor, it is implementation-defined
whether the &lt;control&gt;-H command is an error or if the
cursor moves back one autoindent charac- ter.</p>

<p>Otherwise, if the cursor is in column position 1 and
there are previous lines that have been input, it is
implementation-defined whether the &lt;control&gt;-H command
is an error or if it is equivalent to entering
&lt;control&gt;-H after the last input character on the
previous input line.</p>

<p>Otherwise, it shall be an error.</p>

<p>All of the glyphs on columns between the starting cursor
position and (inclusively) the ending cursor position shall
become erase-columns as described in Input Mode Commands in
vi .</p>

<p>The current erase character (see stty) shall cause an
equivalent action to the &lt;control&gt;-H command, unless
the previously inserted character was a backslash, in which
case it shall be as if the literal current erase character
had been inserted instead of the backslash.</p>

<p>Current line: Unchanged, unless previously input lines
are erased, in which case it shall be set to line -1.</p>

<p>Current column: Set to the first column that displays
any portion of the character backed up over.</p>

<p>&lt;newline&gt; Synopsis:</p>

<p>&lt;newline&gt;</p>

<p>&lt;carriage-return&gt;</p>

<p>&lt;control&gt;-J</p>

<p>&lt;control&gt;-M</p>

<p>If input was part of a line-oriented command, text input
mode shall be terminated and the command shall continue
execution with the input pro- vided.</p>

<p>Otherwise, terminate the current line. If there are no
characters other than autoindent characters on the line, all
characters on the line shall be discarded. Otherwise, it is
unspecified whether the autoindent characters in the line
are modified by entering these characters.</p>

<p>Continue text input mode on a new line appended after
the current line. If the slowopen edit option is set, the
lines on the screen below the current line shall not be
pushed down, but the first of them shall be cleared and
shall appear to be overwritten. Otherwise, the lines of the
screen below the current line shall be pushed down.</p>

<p>If the autoindent edit option is set, an appropriate
number of autoin- dent characters shall be added as a prefix
to the line as described by the ex autoindent edit
option.</p>

<p>All columns after the cursor that are erase-columns (as
described in Input Mode Commands in vi ) shall be
discarded.</p>

<p>If the autoindent edit option is set, all &lt;blank&gt;s
immediately follow- ing the cursor shall be discarded.</p>

<p>All remaining characters after the cursor shall be
transferred to the new line, positioned after any autoindent
characters.</p>

<p>Current line: Set to current line +1.</p>

<p>Current column: Set to the first column that displays
any portion of the first character after the autoindent
characters on the new line, if any, or the first column
position after the last autoindent character, if any, or
column position 1.</p>

<p>&lt;control&gt;-T Synopsis:</p>

<p>&lt;control&gt;-T</p>

<p>The &lt;control&gt;-T character shall have no special
meaning when in text input mode for a line-oriented command
(see Command Descriptions in vi ).</p>

<p>This command need not be supported on block-mode
terminals.</p>

<p>Behave as if the user entered the minimum number of
&lt;blank&gt;s necessary to move the cursor forward to the
column position after the next shiftwidth (see the ex
shiftwidth command) boundary.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Set to column + shiftwidth - ((column
-1) % shiftwidth).</p>

<p>&lt;control&gt;-U Synopsis:</p>

<p>&lt;control&gt;-U</p>

<p>If there are characters other than autoindent characters
that have been input on the current line before the cursor,
the cursor shall move to the first character input after the
autoindent characters.</p>

<p>Otherwise, if there are autoindent characters on the
current line before the cursor, it is implementation-defined
whether the &lt;control&gt;-U command is an error or if the
cursor moves to the first column position on the line.</p>

<p>Otherwise, if the cursor is in column position 1 and
there are previous lines that have been input, it is
implementation-defined whether the &lt;control&gt;-U command
is an error or if it is equivalent to entering
&lt;control&gt;-U after the last input character on the
previous input line.</p>

<p>Otherwise, it shall be an error.</p>

<p>All of the glyphs on columns between the starting cursor
position and (inclusively) the ending cursor position shall
become erase-columns as described in Input Mode Commands in
vi .</p>

<p>The current kill character (see stty) shall cause an
equivalent action to the &lt;control&gt;-U command, unless
the previously inserted character was a backslash, in which
case it shall be as if the literal current kill character
had been inserted instead of the backslash.</p>

<p>Current line: Unchanged, unless previously input lines
are erased, in which case it shall be set to line -1.</p>

<p>Current column: Set to the first column that displays
any portion of the last character backed up over.</p>

<p>&lt;control&gt;-V Synopsis:</p>

<p>&lt;control&gt;-V</p>

<p>&lt;control&gt;-Q</p>

<p>Allow the entry of any subsequent character, other than
&lt;control&gt;-J or the &lt;newline&gt;, as a literal
character, removing any special meaning that it may have to
the editor in text input mode. If a &lt;control&gt;-V or
&lt;control&gt;-Q is entered before a &lt;control&gt;-J or
&lt;newline&gt;, the &lt;con- trol&gt;-V or
&lt;control&gt;-Q character shall be discarded, and the
&lt;con- trol&gt;-J or &lt;newline&gt; shall behave as
described in the &lt;newline&gt; command character during
input mode.</p>

<p>For purposes of the display only, the editor shall
behave as if a ^ character was entered, and the cursor shall
be positioned as if over- writing the ^ character. When a
subsequent character is entered, the editor shall behave as
if that character was entered instead of the original
&lt;control&gt;-V or &lt;control&gt;-Q character.</p>

<p>Current line: Unchanged.</p>

<p>Current column: Unchanged.</p>

<p>&lt;control&gt;-W Synopsis:</p>

<p>&lt;control&gt;-W</p>

<p>If there are characters other than autoindent characters
that have been input on the current line before the cursor,
the cursor shall move back over the last word preceding the
cursor (including any &lt;blank&gt;s between the end of the
last word and the current cursor); the cursor shall not move
to before the first character after the end of any
autoindent characters.</p>

<p>Otherwise, if there are autoindent characters on the
current line before the cursor, it is implementation-defined
whether the &lt;control&gt;-W command is an error or if the
cursor moves to the first column position on the line.</p>

<p>Otherwise, if the cursor is in column position 1 and
there are previous lines that have been input, it is
implementation-defined whether the &lt;control&gt;-W command
is an error or if it is equivalent to entering
&lt;control&gt;-W after the last input character on the
previous input line.</p>

<p>Otherwise, it shall be an error.</p>

<p>All of the glyphs on columns between the starting cursor
position and (inclusively) the ending cursor position shall
become erase-columns as described in Input Mode Commands in
vi .</p>

<p>Current line: Unchanged, unless previously input lines
are erased, in which case it shall be set to line -1.</p>

<p>Current column: Set to the first column that displays
any portion of the last character backed up over.</p>

<p>&lt;ESC&gt; Synopsis:</p>

<p>&lt;ESC&gt;</p>

<p>If input was part of a line-oriented command:</p>

<p>1. If interrupt was entered, text input mode shall be
terminated and the editor shall return to command mode. The
terminal shall be alerted.</p>

<p>2. If &lt;ESC&gt; was entered, text input mode shall be
terminated and the command shall continue execution with the
input provided.</p>

<p>Otherwise, terminate text input mode and return to
command mode.</p>

<p>Any autoindent characters entered on newly created lines
that have no other non- &lt;newline&gt;s shall be
deleted.</p>

<p>Any leading autoindent and &lt;blank&gt;s on newly
created lines shall be rewritten to be the minimum number of
&lt;blank&gt;s possible.</p>

<p>The screen shall be redisplayed as necessary to match
the contents of the edit buffer.</p>

<p>Current line: Unchanged.</p>

<p>Current column:</p>

<p>1. If there are text input characters on the current
line, the column shall be set to the last column where any
portion of the last text input character is displayed.</p>

<p>2. Otherwise, if a character is displayed in the current
column, unchanged.</p>

<p>3. Otherwise, set to column position 1.</p>

<p>EXIT STATUS The following exit values shall be
returned:</p>

<p>0 Successful completion.</p>

<p>&gt;0 An error occurred.</p>

<p>CONSEQUENCES OF ERRORS When any error is encountered and
the standard input is not a terminal device file, vi shall
not write the file or return to command or text input mode,
and shall terminate with a non-zero exit status.</p>

<p>Otherwise, when an unrecoverable error is encountered it
shall be equivalent to a SIGHUP asynchronous event.</p>

<p>Otherwise, when an error is encountered, the editor
shall behave as specified in Command Descriptions in vi
.</p>

<p>The following sections are informative.</p>

<p>APPLICATION USAGE None.</p>

<p>EXAMPLES None.</p>

<p>RATIONALE See the RATIONALE for ex for more information
on vi. Major portions of the vi utility specification point
to ex to avoid inadvertent diver- gence. While ex and vi
have historically been implemented as a single utility, this
is not required by IEEE Std 1003.1-2001.</p>

<p>It is recognized that portions of vi would be difficult,
if not impos- sible, to implement satisfactorily on a
block-mode terminal, or a ter- minal without any form of
cursor addressing, thus it is not a mandatory requirement
that such features should work on all terminals. It is the
intention, however, that a vi implementation should provide
the full set of capabilities on all terminals capable of
supporting them.</p>

<p>Historically, vi exited immediately if the standard
input was not a terminal. IEEE Std 1003.1-2001 permits, but
does not require, this behavior. An end-of-file condition is
not equivalent to an end-of-file character. A common
end-of-file character, &lt;control&gt;-D, is historically a
vi command.</p>

<p>The text in the STDOUT section reflects the usage of the
verb display in this section; some implementations of vi use
standard output to write to the terminal, but IEEE Std
1003.1-2001 does not require that to be the case.</p>

<p>Historically, implementations reverted to open mode if
the terminal was incapable of supporting full visual mode.
IEEE Std 1003.1-2001 requires this behavior. Historically,
the open mode of vi behaved roughly equivalently to the
visual mode, with the exception that only a single line from
the edit buffer (one &quot;buffer line&quot;) was kept
current at any time. This line was normally displayed on the
next-to-last line of a terminal with cursor addressing (and
the last line performed its normal visual functions for
line-oriented commands and messages). In addition, some few
commands behaved differently in open mode than in visual
mode. IEEE Std 1003.1-2001 requires conformance to
historical practice.</p>

<p>Historically, ex and vi implementations have expected
text to proceed in the usual European/Latin order of left to
right, top to bottom. There is no requirement in IEEE Std
1003.1-2001 that this be the case. The specification was
deliberately written using words like &quot;before&quot;,
&quot;after&quot;, &quot;first&quot;, and &quot;last&quot;
in order to permit implementations to sup- port the natural
text order of the language.</p>

<p>Historically, lines past the end of the edit buffer were
marked with single tilde ( ~) characters; that is, if the
one-based display was 20 lines in length, and the last line
of the file was on line one, then lines 2-20 would contain
only a single~character.</p>

<p>Historically, the vi editor attempted to display only
complete lines at the bottom of the screen (it did display
partial lines at the top of the screen). If a line was too
long to fit in its entirety at the bot- tom of the screen,
the screen lines where the line would have been dis- played
were displayed as single@characters, instead of displaying
part of the line. IEEE Std 1003.1-2001 permits, but does not
require, this behavior. Implementations are encouraged to
attempt always to display a complete line at the bottom of
the screen when doing scrolling or screen positioning by
buffer lines.</p>

<p>Historically, lines marked with @ were also used to
minimize output to dumb terminals over slow lines; that is,
changes local to the cursor were updated, but changes to
lines on the screen that were not close to the cursor were
simply marked with an @ sign instead of being updated to
match the current text. IEEE Std 1003.1-2001 permits, but
does not require this feature because it is used ever less
frequently as termi- nals become smarter and connections are
faster.</p>

<p>Initialization in ex and vi Historically, vi always had
a line in the edit buffer, even if the edit buffer was
&quot;empty&quot;. For example:</p>

<p>1. The ex command = executed from visual mode wrote
&quot;1&quot; when the buffer was empty.</p>

<p>2. Writes from visual mode of an empty edit buffer wrote
files of a single character (a &lt;newline&gt;), while
writes from ex mode of an empty edit buffer wrote empty
files.</p>

<p>3. Put and read commands into an empty edit buffer left
an empty line at the top of the edit buffer.</p>

<p>For consistency, IEEE Std 1003.1-2001 does not permit
any of these behaviors.</p>

<p>Historically, vi did not always return the terminal to
its original modes; for example, ICRNL was modified if it
was not originally set. IEEE Std 1003.1-2001 does not permit
this behavior.</p>

<p>Command Descriptions in vi Motion commands are among the
most complicated aspects of vi to describe. With some
exceptions, the text region and buffer type effect of a
motion command on a vi command are described on a
case-by-case basis. The descriptions of text regions in IEEE
Std 1003.1-2001 are not intended to imply direction; that
is, an inclusive region from line n to line n+5 is identical
to a region from line n+5 to line n. This is of more than
academic interest-movements to marks can be in either
direction, and, if the wrapscan option is set, so can
movements to search points. Historically, lines are always
stored into buffers in text order; that is, from the start
of the edit buffer to the end. IEEE Std 1003.1-2001 requires
conformance to historical practice.</p>

<p>Historically, command counts were applied to any
associated motion, and were multiplicative to any supplied
motion count. For example, 2cw is the same as c2w, and 2c3w
is the same as c6w. IEEE Std 1003.1-2001 requires this
behavior. Historically, vi commands that used bigwords,
words, paragraphs, and sentences as objects treated groups
of empty lines, or lines that contained only &lt;blank&gt;s,
inconsistently. Some commands treated them as a single
entity, while others treated each line separately. For
example, the w, W, and B commands treated groups of empty
lines as individual words; that is, the command would move
the cursor to each new empty line. The e and E commands
treated groups of empty lines as a single word; that is, the
first use would move past the group of lines. The b command
would just beep at the user, or if done from the start of
the line as a motion command, fail in unexpected ways. If
the lines contained only (or ended with) &lt;blank&gt;s, the
w and W commands would just beep at the user, the E and e
commands would treat the group as a single word, and the B
and b commands would treat the lines as individual words.
For consistency and simplicity of specifica- tion, IEEE Std
1003.1-2001 requires that all vi commands treat groups of
empty or blank lines as a single entity, and that movement
through lines ending with &lt;blank&gt;s be consistent with
other movements.</p>

<p>Historically, vi documentation indicated that any number
of double quotes were skipped after punctuation marks at
sentence boundaries; however, implementations only skipped
single quotes. IEEE Std 1003.1-2001 requires both to be
skipped.</p>

<p>Historically, the first and last characters in the edit
buffer were word boundaries. This historical practice is
required by IEEE Std 1003.1-2001.</p>

<p>Historically, vi attempted to update the minimum number
of columns on the screen possible, which could lead to
misleading information being displayed. IEEE Std 1003.1-2001
makes no requirements other than that the current character
being entered is displayed correctly, leaving all other
decisions in this area up to the implementation.</p>

<p>Historically, lines were arbitrarily folded between
columns of any characters that required multiple column
positions on the screen, with the exception of tabs, which
terminated at the right-hand margin. IEEE Std 1003.1-2001
permits the former and requires the latter. Imple-
mentations that do not arbitrarily break lines between
columns of char- acters that occupy multiple column
positions should not permit the cur- sor to rest on a column
that does not contain any part of a character.</p>

<p>The historical vi had a problem in that all movements
were by buffer lines, not by display or screen lines. This
is often the right thing to do; for example, single line
movements, such as j or k, should work on buffer lines.
Commands like dj, or j., where . is a change command, only
make sense for buffer lines. It is not, however, the right
thing to do for screen motion or scrolling commands like
&lt;control&gt;-D, &lt;con- trol&gt;-F, and H. If the window
is fairly small, using buffer lines in these cases can
result in completely random motion; for example, 1
&lt;control&gt;-D can result in a completely changed screen,
without any overlap. This is clearly not what the user
wanted. The problem is even worse in the case of the H, L,
and M commands-as they position the cur- sor at the first
non- &lt;blank&gt; of the line, they may all refer to the
same location in large lines, and will result in no movement
at all.</p>

<p>In addition, if the line is larger than the screen,
using buffer lines can make it impossible to display parts
of the line-there are not any commands that do not display
the beginning of the line in historical vi, and if both the
beginning and end of the line cannot be on the screen at the
same time, the user suffers. Finally, the page and half-
page scrolling commands historically moved to the first non-
&lt;blank&gt; in the new line. If the line is approximately
the same size as the screen, this is inadequate because the
cursor before and after a &lt;control&gt;-D command will
refer to the same location on the screen.</p>

<p>Implementations of ex and vi exist that do not have
these problems because the relevant commands (
&lt;control&gt;-B, &lt;control&gt;-D, &lt;control&gt;-F,
&lt;control&gt;-U, &lt;control&gt;-Y, &lt;control&gt;-E, H,
L, and M) operate on display (screen) lines, not (edit)
buffer lines.</p>

<p>IEEE Std 1003.1-2001 does not permit this behavior by
default because the standard developers believed that users
would find it too confus- ing. However, historical practice
has been relaxed. For example, ex and vi historically
attempted, albeit sometimes unsuccessfully, to never put
part of a line on the last lines of a screen; for example,
if a line would not fit in its entirety, no part of the line
was displayed, and the screen lines corresponding to the
line contained single @ characters. This behavior is
permitted, but not required by IEEE Std 1003.1-2001, so that
it is possible for implementations to support long lines in
small screens more reasonably without changing the commands
to be oriented to the display (instead of oriented to the
buffer). IEEE Std 1003.1-2001 also permits implementations
to refuse to edit any edit buffer containing a line that
will not fit on the screen in its entirety.</p>

<p>The display area (for example, the value of the window
edit option) has historically been &quot;grown&quot;, or
expanded, to display new text when local movements are done
in displays where the number of lines displayed is less than
the maximum possible. Expansion has historically been the
first choice, when the target line is less than the maximum
possible expansion value away. Scrolling has historically
been the next choice, done when the target line is less than
half a display away, and other- wise, the screen was
redrawn. There were exceptions, however, in that ex commands
generally always caused the screen to be redrawn. IEEE Std
1003.1-2001 does not specify a standard behavior because
there may be external issues, such as connection speed, the
number of charac- ters necessary to redraw as opposed to
scroll, or terminal capabilities that implementations will
have to accommodate.</p>

<p>The current line in IEEE Std 1003.1-2001 maps one-to-one
to a buffer line in the file. The current column does not.
There are two different column values that are described by
IEEE Std 1003.1-2001. The first is the current column value
as set by many of the vi commands. This value is remembered
for the lifetime of the editor. The second column value is
the actual position on the screen where the cursor rests.
The two are not always the same. For example, when the
cursor is backed by a multi-column character, the actual
cursor position on the screen has historically been the last
column of the character in command mode, and the first
column of the character in input mode.</p>

<p>Commands that set the current line, but that do not set
the current cursor value (for example, j and k) attempt to
get as close as possible to the remembered column position,
so that the cursor tends to restrict itself to a vertical
column as the user moves around in the edit buffer. IEEE Std
1003.1-2001 requires conformance to historical prac- tice,
requiring that the display location of the cursor on the
display line be adjusted from the current column value as
necessary to support this historical behavior.</p>

<p>Historically, only a single line (and for some
terminals, a single line minus 1 column) of characters could
be entered by the user for the line-oriented commands; that
is, :, !, /, or ?. IEEE Std 1003.1-2001 permits, but does
not require, this limitation.</p>

<p>Historically, &quot;soft&quot; errors in vi caused the
terminal to be alerted, but no error message was displayed.
As a general rule, no error message was displayed for errors
in command execution in vi, when the error resulted from the
user attempting an invalid or impossible action, or when a
searched-for object was not found. Examples of soft errors
included h at the left margin, &lt;control&gt;-B or [[ at
the beginning of the file, 2G at the end of the file, and so
on. In addition, errors such as %, ]], }, ), N, n, f, F, t,
and T failing to find the searched- for object were soft as
well. Less consistently, / and ? displayed an error message
if the pattern was not found, /, ?, N, and n displayed an
error message if no previous regular expression had been
specified, and ; did not display an error message if no
previous f, F, t, or T command had occurred. Also, behavior
in this area might reasonably be based on a runtime
evaluation of the speed of a network connection. Finally,
some implementations have provided error messages for soft
errors in order to assist naive users, based on the value of
a verbose edit option. IEEE Std 1003.1-2001 does not list
specific errors for which an error message shall be
displayed. Implementations should conform to historical
practice in the absence of any strong reason to diverge.</p>

<p>Page Backwards The &lt;control&gt;-B and
&lt;control&gt;-F commands historically considered it an
error to attempt to page past the beginning or end of the
file, whereas the &lt;control&gt;-D and &lt;control&gt;-U
commands simply moved to the beginning or end of the file.
For consistency, IEEE Std 1003.1-2001 requires the latter
behavior for all four commands. All four commands still
consider it an error if the current line is at the beginning
( &lt;control&gt;-B, &lt;control&gt;-U) or end (
&lt;control&gt;-F, &lt;control&gt;-D) of the file. Histori-
cally, the &lt;control&gt;-B and &lt;control&gt;-F commands
skip two lines in order to include overlapping lines when a
single command is entered. This makes less sense in the
presence of a count, as there will be, by defi- nition, no
overlapping lines. The actual calculation used by historical
implementations of the vi editor for &lt;control&gt;-B
was:</p>

<p>((current first line) - count x (window edit option))
+2</p>

<p>and for &lt;control&gt;-F was:</p>

<p>((current first line) + count x (window edit option))
-2</p>

<p>This calculation does not work well when intermixing
commands with and without counts; for example, 3
&lt;control&gt;-F is not equivalent to enter- ing the
&lt;control&gt;-F command three times, and is not reversible
by entering the &lt;control&gt;-B command three times. For
consistency with other vi commands that take counts, IEEE
Std 1003.1-2001 requires a different calculation.</p>

<p>Scroll Forward The 4BSD and System V implementations of
vi differed on the initial value used by the scroll command.
4BSD used:</p>

<p>((window edit option) +1) /2</p>

<p>while System V used the value of the scroll edit option.
The System V version is specified by IEEE Std 1003.1-2001
because the standard developers believed that it was more
intuitive and permitted the user a method of setting the
scroll value initially without also setting the number of
lines that are displayed.</p>

<p>Scroll Forward by Line Historically, the
&lt;control&gt;-E and &lt;control&gt;-Y commands considered
it an error if the last and first lines, respectively, were
already on the screen. IEEE Std 1003.1-2001 requires
conformance to historical prac- tice. Historically, the
&lt;control&gt;-E and &lt;control&gt;-Y commands had no
effect in open mode. For simplicity and consistency of
specification, IEEE Std 1003.1-2001 requires that they
behave as usual, albeit with a single line screen.</p>

<p>Clear and Redisplay The historical &lt;control&gt;-L
command refreshed the screen exactly as it was supposed to
be currently displayed, replacing any @ characters for lines
that had been deleted but not updated on the screen with
refreshed @ characters. The intent of the &lt;control&gt;-L
command is to refresh when the screen has been accidentally
overwritten; for example, by a write command from another
user, or modem noise.</p>

<p>Redraw Screen The historical &lt;control&gt;-R command
redisplayed only when necessary to update lines that had
been deleted but not updated on the screen and that were
flagged with@characters. There is no requirement that the
screen be in any way refreshed if no lines of this form are
currently displayed. IEEE Std 1003.1-2001 permits
implementations to extend this command to refresh lines on
the screen flagged with @ characters because they are too
long to be displayed in the current framework; however, the
current line and column need not be modified.</p>

<p>Search for tagstring Historically, the first non-
&lt;blank&gt; at or after the cursor was the first
character, and all subsequent characters that were word
charac- ters, up to the end of the line, were included. For
example, with the cursor on the leading space or on the #
character in the text &quot;#bar@&quot;, the tag was
&quot;#bar&quot; . On the characterbit was &quot;bar&quot;,
and on theait was &quot;ar&quot; . IEEE Std 1003.1-2001
requires this behavior.</p>

<p>Replace Text with Results from Shell Command
Historically, the &lt;, &gt;, and ! commands considered most
cursor motions other than line-oriented motions an error;
for example, the command &gt;/foo&lt;CR&gt; succeeded, while
the command &gt;l failed, even though the text region
described by the two commands might be identical. For
consis- tency, all three commands only consider entire lines
and not partial lines, and the region is defined as any line
that contains a character that was specified by the
motion.</p>

<p>Move to Matching Character Other matching characters
have been left implementation-defined in order to allow
extensions such as matching&lt;and &gt; for searching HTML,
or #ifdef, #else, and #endif for searching C source.</p>

<p>Repeat Substitution IEEE Std 1003.1-2001 requires that
any c and g flags specified to the previous substitute
command be ignored; however, the r flag may still apply, if
supported by the implementation.</p>

<p>Return to Previous (Context or Section) The [[, ]], (,
), {, and } commands are all affected by &quot;section
bound- aries&quot;, but in some historical implementations
not all of the commands recognize the same section
boundaries. This is a bug, not a feature, and a unique
section-boundary algorithm was not described for each com-
mand. One special case that is preserved is that the
sentence command moves to the end of the last line of the
edit buffer while the other commands go to the beginning, in
order to preserve the traditional character cut semantics of
the sentence command. Historically, vi sec- tion boundaries
at the beginning and end of the edit buffer were the first
non- &lt;blank&gt; on the first and last lines of the edit
buffer if one exists; otherwise, the last character of the
first and last lines of the edit buffer if one exists. To
increase consistency with other section locations, this has
been simplified by IEEE Std 1003.1-2001 to the first
character of the first and last lines of the edit buffer, or
the first and the last lines of the edit buffer if they are
empty.</p>

<p>Sentence boundaries were problematic in the historical
vi. They were not only the boundaries as defined for the
section and paragraph com- mands, but they were the first
non- &lt;blank&gt; that occurred after those boundaries, as
well. Historically, the vi section commands were docu-
mented as taking an optional window size as a count
preceding the com- mand. This was not implemented in
historical versions, so IEEE Std 1003.1-2001 requires that
the count repeat the command, for consistency with other vi
commands.</p>

<p>Repeat Historically, mapped commands other than text
input commands could not be repeated using the period
command. IEEE Std 1003.1-2001 requires conformance to
historical practice.</p>

<p>The restrictions on the interpretation of special
characters (for exam- ple, &lt;control&gt;-H) in the
repetition of text input mode commands is intended to match
historical practice. For example, given the input
sequence:</p>


<p>iab&lt;control&gt;-H&lt;control&gt;-H&lt;control&gt;-Hdef&lt;escape&gt;</p>

<p>the user should be informed of an error when the
sequence is first entered, but not during a command
repetition. The character &lt;control&gt;-T is specifically
exempted from this restriction. Historical implementa- tions
of vi ignored &lt;control&gt;-T characters that were input
in the orig- inal command during command repetition. IEEE
Std 1003.1-2001 prohibits this behavior.</p>

<p>Find Regular Expression Historically, commands did not
affect the line searched to or from if the motion command
was a search ( /, ?, N, n) and the final position was the
start/end of the line. There were some special cases and vi
was not consistent. IEEE Std 1003.1-2001 does not permit
this behavior, for consistency. Historical implementations
permitted but were unable to handle searches as motion
commands that wrapped (that is, due to the edit option
wrapscan) to the original location. IEEE Std 1003.1-2001
requires that this behavior be treated as an error.</p>

<p>Historically, the syntax &quot;/RE/0&quot; was used to
force the command to cut text in line mode. IEEE Std
1003.1-2001 requires conformance to histor- ical
practice.</p>

<p>Historically, in open mode, a z specified to a search
command redis- played the current line instead of displaying
the current screen with the current line highlighted. For
consistency and simplicity of speci- fication, IEEE Std
1003.1-2001 does not permit this behavior.</p>

<p>Historically, trailing z commands were permitted and
ignored if entered as part of a search used as a motion
command. For consistency and sim- plicity of specification,
IEEE Std 1003.1-2001 does not permit this behavior.</p>

<p>Execute an ex Command Historically, vi implementations
restricted the commands that could be entered on the colon
command line (for example, append and change), and some
other commands were known to cause them to fail
catastrophically. For consistency, IEEE Std 1003.1-2001 does
not permit these restric- tions. When executing an ex
command by entering :, it is not possible to enter a
&lt;newline&gt; as part of the command because it is
considered the end of the command. A different approach is
to enter ex command mode by using the vi Q command (and
later resuming visual mode with the ex vi command). In ex
command mode, the single-line limitation does not exist. So,
for example, the following is valid:</p>

<p>Q s/break here/break here/ vi</p>

<p>IEEE Std 1003.1-2001 requires that, if the ex command
overwrites any part of the screen that would be erased by a
refresh, vi pauses for a character from the user.
Historically, this character could be any character; for
example, a character input by the user before the mes- sage
appeared, or even a mapped character. This is probably a
bug, but implementations that have tried to be more rigorous
by requiring that the user enter a specific character, or
that the user enter a character after the message was
displayed, have been forced by user indignation back into
historical behavior. IEEE Std 1003.1-2001 requires confor-
mance to historical practice.</p>

<p>Shift Left (Right) Refer to the Rationale for the ! and
/ commands. Historically, the &lt; and &gt; commands
sometimes moved the cursor to the first non- &lt;blank&gt;
(for example if the command was repeated or with _ as the
motion com- mand), and sometimes left it unchanged. IEEE Std
1003.1-2001 does not permit this inconsistency, requiring
instead that the cursor always move to the first non-
&lt;blank&gt;. Historically, the &lt; and &gt; commands did
not support buffer arguments, although some implementations
allow the specification of an optional buffer. This behavior
is neither required nor disallowed by IEEE Std
1003.1-2001.</p>

<p>Execute Historically, buffers could execute other
buffers, and loops, infinite and otherwise, were possible.
IEEE Std 1003.1-2001 requires confor- mance to historical
practice. The * buffer syntax of ex is not required in vi,
because it is not historical practice and has been used in
some vi implementations to support additional scripting
languages.</p>

<p>Reverse Case Historically, the ~ command ignored any
associated count, and acted only on the characters in the
current line. For consistency with other vi commands, IEEE
Std 1003.1-2001 requires that an associated count act on the
next count characters, and that the command move to
subsequent lines if warranted by count, to make it possible
to modify large pieces of text in a reasonably efficient
manner. There exist vi implementa- tions that optionally
require an associated motion command for the ~ command.
Implementations supporting this functionality are encouraged
to base it on the tildedop edit option and handle the text
regions and cursor positioning identically to the yank
command.</p>

<p>Append Historically, counts specified to the A, a, I,
and i commands repeated the input of the first line count
times, and did not repeat the subse- quent lines of the
input text. IEEE Std 1003.1-2001 requires that the entire
text input be repeated count times.</p>

<p>Move Backward to Preceding Word Historically, vi became
confused if word commands were used as motion commands in
empty files. IEEE Std 1003.1-2001 requires that this be an
error. Historical implementations of vi had a large number
of bugs in the word movement commands, and they varied
greatly in behavior in the presence of empty lines,
&quot;words&quot; made up of a single character, and lines
containing only &lt;blank&gt;s. For consistency and
simplicity of spec- ification, IEEE Std 1003.1-2001 does not
permit this behavior.</p>

<p>Change to End-of-Line Some historical implementations of
the C command did not behave as described by IEEE Std
1003.1-2001 when the $ key was remapped because they were
implemented by pushing the $ key onto the input queue and
reprocessing it. IEEE Std 1003.1-2001 does not permit this
behavior. Historically, the C, S, and s commands did not
copy replaced text into the numeric buffers. For consistency
and simplicity of specification, IEEE Std 1003.1-2001
requires that they behave like their respective c commands
in all respects.</p>

<p>Delete Historically, lines in open mode that were
deleted were scrolled up, and an @ glyph written over the
beginning of the line. In the case of terminals that are
incapable of the necessary cursor motions, the edi- tor
erased the deleted line from the screen. IEEE Std
1003.1-2001 requires conformance to historical practice;
that is, if the terminal cannot display the@character, the
line cannot remain on the screen.</p>

<p>Delete to End-of-Line Some historical implementations of
the D command did not behave as described by IEEE Std
1003.1-2001 when the $ key was remapped because they were
implemented by pushing the $ key onto the input queue and
reprocessing it. IEEE Std 1003.1-2001 does not permit this
behavior.</p>

<p>Join An historical oddity of vi is that the commands J,
1J, and 2J are all equivalent. IEEE Std 1003.1-2001 requires
conformance to historical practice. The vi J command is
specified in terms of the ex join com- mand with an ex
command count value. The address correction for a count that
is past the end of the edit buffer is necessary for
historical compatibility for both ex and vi.</p>

<p>Mark Position Historical practice is that only lowercase
letters, pluand&quot;, could be used to mark a cursor
position. IEEE Std 1003.1-2001 requires conformance to
historical practice, but encourages implementations to
support other characters as marks as well.</p>

<p>Repeat Regular Expression Find (Forward and Reverse)
Historically, the N and n commands could not be used as
motion compo- nents for the c command. With the exception of
the cN command, which worked if the search crossed a line
boundary, the text region would be discarded, and the user
would not be in text input mode. For consis- tency and
simplicity of specification, IEEE Std 1003.1-2001 does not
permit this behavior.</p>

<p>Insert Empty Line (Below and Above) Historically, counts
to the O and o commands were used as the number of physical
lines to open, if the terminal was dumb and the slowopen
option was not set. This was intended to minimize traffic
over slow connections and repainting for dumb terminals.
IEEE Std 1003.1-2001 does not permit this behavior,
requiring that a count to the open com- mand behave as for
other text input commands. This change to historical
practice was made for consistency, and because a superset of
the func- tionality is provided by the slowopen edit
option.</p>

<p>Put from Buffer (Following and Before) Historically,
counts to the p and P commands were ignored if the buffer
was a line mode buffer, but were (mostly) implemented as
described in IEEE Std 1003.1-2001 if the buffer was a
character mode buffer. Because implementations exist that do
not have this limitation, and because pasting lines multiple
times is generally useful, IEEE Std 1003.1-2001 requires
that count be supported for all p and P commands.</p>

<p>Historical implementations of vi were widely known to
have major prob- lems in the p and P commands, particularly
when unusual regions of text were copied into the edit
buffer. The standard developers viewed these as bugs, and
they are not permitted for consistency and simplicity of
specification.</p>

<p>Historically, a P or p command (or an ex put command
executed from open or visual mode) executed in an empty
file, left an empty line as the first line of the file. For
consistency and simplicity of specifica- tion, IEEE Std
1003.1-2001 does not permit this behavior.</p>

<p>Replace Character Historically, the r command did not
correctly handle the erase and word erase characters as
arguments, nor did it handle an associated count greater
than 1 with a &lt;carriage-return&gt; argument, for which it
replaced count characters with a single &lt;newline&gt;.
IEEE Std 1003.1-2001 does not permit these
inconsistencies.</p>

<p>Historically, the r command permitted the
&lt;control&gt;-V escaping of entered characters, such as
&lt;ESC&gt; and the &lt;carriage-return&gt;; however, it
required two leading &lt;control&gt;-V characters instead of
one. IEEE Std 1003.1-2001 requires that this be changed for
consistency with the other text input commands of vi.</p>

<p>Historically, it is an error to enter the r command if
there are less than count characters at or after the cursor
in the line. While a rea- sonable and unambiguous extension
would be to permit the r command on empty lines, it would
require that too large a count be adjusted to match the
number of characters at or after the cursor for consistency,
which is sufficiently different from historical practice to
be avoided. IEEE Std 1003.1-2001 requires conformance to
historical practice.</p>

<p>Replace Characters Historically, if there were
autoindent characters in the line on which the R command was
run, and autoindent was set, the first &lt;newline&gt; would
be properly indented and no characters would be replaced by
the &lt;newline&gt;. Each additional &lt;newline&gt; would
replace n characters, where n was the number of characters
that were needed to indent the rest of the line to the
proper indentation level. This behavior is a bug and is not
permitted by IEEE Std 1003.1-2001.</p>

<p>Undo Historical practice for cursor positioning after
undoing commands was mixed. In most cases, when undoing
commands that affected a single line, the cursor was moved
to the start of added or changed text, or immediately after
deleted text. However, if the user had moved from the line
being changed, the column was either set to the first non-
&lt;blank&gt;, returned to the origin of the command, or
remained unchanged. When undoing commands that affected
multiple lines or entire lines, the cursor was moved to the
first character in the first line restored. As an example of
how inconsistent this was, a search, followed by an o text
input command, followed by an undo would return the cursor
to the location where the o command was entered, but a cw
command followed by an o command followed by an undo would
return the cursor to the first non- &lt;blank&gt; of the
line. IEEE Std 1003.1-2001 requires the most useful of these
behaviors, and discards the least useful, in the interest of
consistency and simplicity of specification.</p>

<p>Yank Historically, the yank command did not move to the
end of the motion if the motion was in the forward
direction. It moved to the end of the motion if the motion
was in the backward direction, except for the _ command, or
for the G and commands when the end of the motion was on the
current line. This was further complicated by the fact that
for a number of motion commands, the yank command moved the
cursor but did not update the screen; for example, a
subsequent command would move the cursor from the end of the
motion, even though the cursor on the screen had not
reflected the cursor movement for the yank command. IEEE Std
1003.1-2001 requires that all yank commands associated with
backward motions move the cursor to the end of the motion
for consis- tency, and specifically, to make commands as
motions consistent with search patterns as motions.</p>

<p>Yank Current Line Some historical implementations of the
Y command did not behave as described by IEEE Std
1003.1-2001 when the _key was remapped because they were
implemented by pushing the_key onto the input queue and
reprocessing it. IEEE Std 1003.1-2001 does not permit this
behavior.</p>

<p>Redraw Window Historically, the z command always redrew
the screen. This is permitted but not required by IEEE Std
1003.1-2001, because of the frequent use of the z command in
macros such as map n nz. for screen positioning, instead of
its use to change the screen size. The standard developers
believed that expanding or scrolling the screen offered a
better inter- face for users. The ability to redraw the
screen is preserved if the optional new window size is
specified, and in the &lt;control&gt;-L and &lt;con-
trol&gt;-R commands.</p>

<p>The semantics of z^ are confusing at best. Historical
practice is that the screen before the screen that ended
with the specified line is dis- played. IEEE Std 1003.1-2001
requires conformance to historical prac- tice.</p>

<p>Historically, the z command would not display a partial
line at the top or bottom of the screen. If the partial line
would normally have been displayed at the bottom of the
screen, the command worked, but the par- tial line was
replaced with@characters. If the partial line would normally
have been displayed at the top of the screen, the command
would fail. For consistency and simplicity of specification,
IEEE Std 1003.1-2001 does not permit this behavior.</p>

<p>Historically, the z command with a line specification of
1 ignored the command. For consistency and simplicity of
specification, IEEE Std 1003.1-2001 does not permit this
behavior.</p>

<p>Historically, the z command did not set the cursor
column to the first non- &lt;blank&gt; for the character if
the first screen was to be displayed, and was already
displayed. For consistency and simplicity of specifica-
tion, IEEE Std 1003.1-2001 does not permit this
behavior.</p>

<p>Input Mode Commands in vi Historical implementations of
vi did not permit the user to erase more than a single line
of input, or to use normal erase characters such as line
erase, worderase, and erase to erase autoindent characters.
As there exist implementations of vi that do not have these
limitations, both behaviors are permitted, but only
historical practice is required. In the case of these
extensions, vi is required to pause at the autoin- dent and
previous line boundaries.</p>

<p>Historical implementations of vi updated only the
portion of the screen where the current cursor character was
displayed. For example, con- sider the vi input
keystrokes:</p>

<p>iabcd&lt;escape&gt;0C&lt;tab&gt;</p>

<p>Historically, the &lt;tab&gt; would overwrite the
characters &quot;abcd&quot; when it was displayed. Other
implementations replace only thea character with the
&lt;tab&gt;, and then push the rest of the characters ahead
of the cursor. Both implementations have problems. The
historical implementa- tion is probably visually nicer for
the above example; however, for the keystrokes:</p>

<p>iabcd&lt;ESC&gt;0R&lt;tab&gt;&lt;ESC&gt;</p>

<p>the historical implementation results in the string
&quot;bcd&quot; disappearing and then magically reappearing
when the &lt;ESC&gt; character is entered. IEEE Std
1003.1-2001 requires the former behavior when overwriting
erase-columns-that is, overwriting characters that are no
longer logi- cally part of the edit buffer-and the latter
behavior otherwise.</p>

<p>Historical implementations of vi discarded the
&lt;control&gt;-D and &lt;con- trol&gt;-T characters when
they were entered at places where their command
functionality was not appropriate. IEEE Std 1003.1-2001
requires that the &lt;control&gt;-T functionality always be
available, and that &lt;control&gt;-D be treated as any
other key when not operating on autoindent charac- ters.</p>

<p>NUL Some historical implementations of vi limited the
number of characters entered using the NUL input character
to 256 bytes. IEEE Std 1003.1-2001 permits this limitation;
however, implementations are encouraged to remove this
limit.</p>

<p>&lt;control&gt;-D See also Rationale for the input mode
command &lt;newline&gt;. The hidden assumptions in the
&lt;control&gt;-D command (and in the vi autoindent speci-
fication in general) is that &lt;space&gt;s take up a single
column on the screen and that &lt;tab&gt;s are comprised of
an integral number of &lt;space&gt;s.</p>

<p>&lt;newline&gt; Implementations are permitted to rewrite
autoindent characters in the line when &lt;newline&gt;,
&lt;carriage-return&gt;, &lt;control&gt;-D, and
&lt;control&gt;-T are entered, or when the shift commands
are used, because historical implementations have both done
so and found it necessary to do so. For example, a
&lt;control&gt;-D when the cursor is preceded by a single
&lt;tab&gt;, with tabstop set to 8, and shiftwidth set to 3,
will result in the &lt;tab&gt; being replaced by several
&lt;space&gt;s.</p>

<p>&lt;control&gt;-T See also the Rationale for the input
mode command &lt;newline&gt;. Histori- cally,
&lt;control&gt;-T only worked if no non- &lt;blank&gt;s had
yet been input in the current input line. In addition, the
characters inserted by &lt;control&gt;-T were treated as
autoindent characters, and could not be erased using normal
user erase characters. Because implementations exist that do
not have these limitations, and as moving to a column
boundary is generally useful, IEEE Std 1003.1-2001 requires
that both limitations be removed.</p>

<p>&lt;control&gt;-V Historically, vi used ^V, regardless
of the value of the literal-next character of the terminal.
IEEE Std 1003.1-2001 requires conformance to historical
practice.</p>

<p>The uses described for &lt;control&gt;-V can also be
accomplished with &lt;con- trol&gt;-Q, which is useful on
terminals that use &lt;control&gt;-V for the down-arrow
function. However, most historical implementations use
&lt;con- trol&gt;-Q for the termios START character, so the
editor will generally not receive the &lt;control&gt;-Q
unless stty ixon mode is set to off. (In addition, some
historical implementations of vi explicitly set ixon mode to
on, so it was difficult for the user to set it to off.) Any
of the command characters described in IEEE Std 1003.1-2001
can be made ineffective by their selection as termios
control characters, using the stty utility or other methods
described in the System Interfaces volume of IEEE Std
1003.1-2001.</p>

<p>&lt;ESC&gt; Historically, SIGINT alerted the terminal
when used to end input mode. This behavior is permitted, but
not required, by IEEE Std 1003.1-2001.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO ed, ex, stty</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 VI(1P)</p>
<hr>
</body>
</html>
