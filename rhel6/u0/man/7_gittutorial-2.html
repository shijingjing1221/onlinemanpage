<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GITTUTORIAL-2(7) Git Manual GITTUTORIAL-2(7)</p>

<p>NAME gittutorial-2 - A tutorial introduction to git:
part two</p>

<p>SYNOPSIS git *</p>

<p>DESCRIPTION You should work through gittutorial(7)
before reading this tutorial.</p>

<p>The goal of this tutorial is to introduce two
fundamental pieces of gits architecturethe object database
and the index fileand to provide the reader with everything
necessary to understand the rest of the git
documentation.</p>

<p>THE GIT OBJECT DATABASE Lets start a new project and
create a small amount of history:</p>

<p>$ mkdir test-project $ cd test-project $ git init
Initialized empty Git repository in .git/ $ echo
&acute;hello world&acute; &gt; file.txt $ git add . $ git
commit -a -m &quot;initial commit&quot; [master
(root-commit) 54196cc] initial commit 1 files changed, 1
insertions(+), 0 deletions(-) create mode 100644 file.txt $
echo &acute;hello world!&acute; &gt;file.txt $ git commit -a
-m &quot;add emphasis&quot; [master c4d59f3] add emphasis 1
files changed, 1 insertions(+), 1 deletions(-)</p>

<p>What are the 7 digits of hex that git responded to the
commit with?</p>

<p>We saw in part one of the tutorial that commits have
names like this. It turns out that every object in the git
history is stored under a 40-digit hex name. That name is
the SHA1 hash of the objects contents; among other things,
this ensures that git will never store the same data twice
(since identical data is given an identical SHA1 name), and
that the contents of a git object will never change (since
that would change the objects name as well). The 7 char hex
strings here are simply the abbreviation of such 40
character long strings. Abbreviations can be used everywhere
where the 40 character strings can be used, so long as they
are unambiguous.</p>

<p>It is expected that the content of the commit object you
created while following the example above generates a
different SHA1 hash than the one shown above because the
commit object records the time when it was created and the
name of the person performing the commit.</p>

<p>We can ask git about this particular object with the
cat-file command. Dont copy the 40 hex digits from this
example but use those from your own version. Note that you
can shorten it to only a few characters to save yourself
typing all 40 hex digits:</p>

<p>$ git cat-file -t 54196cc2 commit $ git cat-file commit
54196cc2 tree 92b8b694ffb1675e5975148e1121810081dbdffe
author J. Bruce Fields &lt;bfields@puzzle.fieldses.org&gt;
1143414668 -0500 committer J. Bruce Fields
&lt;bfields@puzzle.fieldses.org&gt; 1143414668 -0500</p>

<p>initial commit</p>

<p>A tree can refer to one or more &quot;blob&quot;
objects, each corresponding to a file. In addition, a tree
can also refer to other tree objects, thus creating a
directory hierarchy. You can examine the contents of any
tree using ls-tree (remember that a long enough initial
portion of the SHA1 will also work):</p>

<p>$ git ls-tree 92b8b694 100644 blob
3b18e512dba79e4c8300dd08aeb37f8e728b8dad file.txt</p>

<p>Thus we see that this tree has one file in it. The SHA1
hash is a reference to that files data:</p>

<p>$ git cat-file -t 3b18e512 blob</p>

<p>A &quot;blob&quot; is just file data, which we can also
examine with cat-file:</p>

<p>$ git cat-file blob 3b18e512 hello world</p>

<p>Note that this is the old file data; so the object that
git named in its response to the initial tree was a tree
with a snapshot of the directory state that was recorded by
the first commit.</p>

<p>All of these objects are stored under their SHA1 names
inside the git directory:</p>

<p>$ find .git/objects/ .git/objects/ .git/objects/pack
.git/objects/info .git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/92
.git/objects/92/b8b694ffb1675e5975148e1121810081dbdffe
.git/objects/54
.git/objects/54/196cc2703dc165cbd373a65a4dcf22d50ae7f7
.git/objects/a0
.git/objects/a0/423896973644771497bdc03eb99d5281615b51
.git/objects/d0
.git/objects/d0/492b368b66bdabf2ac1fd8c92b39d3db916e59
.git/objects/c4
.git/objects/c4/d59f390b9cfd4318117afde11d601c1085f241</p>

<p>and the contents of these files is just the compressed
data plus a header identifying their length and their type.
The type is either a blob, a tree, a commit, or a tag.</p>

<p>The simplest commit to find is the HEAD commit, which we
can find from .git/HEAD:</p>

<p>$ cat .git/HEAD ref: refs/heads/master</p>

<p>As you can see, this tells us which branch were
currently on, and it tells us this by naming a file under
the .git directory, which itself contains a SHA1 name
referring to a commit object, which we can examine with
cat-file:</p>

<p>$ cat .git/refs/heads/master
c4d59f390b9cfd4318117afde11d601c1085f241 $ git cat-file -t
c4d59f39 commit $ git cat-file commit c4d59f39 tree
d0492b368b66bdabf2ac1fd8c92b39d3db916e59 parent
54196cc2703dc165cbd373a65a4dcf22d50ae7f7 author J. Bruce
Fields &lt;bfields@puzzle.fieldses.org&gt; 1143418702 -0500
committer J. Bruce Fields
&lt;bfields@puzzle.fieldses.org&gt; 1143418702 -0500</p>

<p>add emphasis</p>

<p>The &quot;tree&quot; object here refers to the new state
of the tree:</p>

<p>$ git ls-tree d0492b36 100644 blob
a0423896973644771497bdc03eb99d5281615b51 file.txt $ git
cat-file blob a0423896 hello world!</p>

<p>and the &quot;parent&quot; object refers to the previous
commit:</p>

<p>$ git cat-file commit 54196cc2 tree
92b8b694ffb1675e5975148e1121810081dbdffe author J. Bruce
Fields &lt;bfields@puzzle.fieldses.org&gt; 1143414668 -0500
committer J. Bruce Fields
&lt;bfields@puzzle.fieldses.org&gt; 1143414668 -0500</p>

<p>initial commit</p>

<p>The tree object is the tree we examined first, and this
commit is unusual in that it lacks any parent.</p>

<p>Most commits have only one parent, but it is also common
for a commit to have multiple parents. In that case the
commit represents a merge, with the parent references
pointing to the heads of the merged branches.</p>

<p>Besides blobs, trees, and commits, the only remaining
type of object is a &quot;tag&quot;, which we wont discuss
here; refer to git-tag(1) for details.</p>

<p>So now we know how git uses the object database to
represent a projects history:</p>

<p>&middot; &quot;commit&quot; objects refer to
&quot;tree&quot; objects representing the snapshot of a
directory tree at a particular point in the history, and
refer to &quot;parent&quot; commits to show how theyre
connected into the project history.</p>

<p>&middot; &quot;tree&quot; objects represent the state of
a single directory, associating directory names to
&quot;blob&quot; objects containing file data and
&quot;tree&quot; objects containing subdirectory
information.</p>

<p>&middot; &quot;blob&quot; objects contain file data
without any other structure.</p>

<p>&middot; References to commit objects at the head of
each branch are stored in files under .git/refs/heads/.</p>

<p>&middot; The name of the current branch is stored in
.git/HEAD.</p>

<p>Note, by the way, that lots of commands take a tree as
an argument. But as we can see above, a tree can be referred
to in many different ways by the SHA1 name for that tree, by
the name of a commit that refers to the tree, by the name of
a branch whose head refers to that tree, etc.--and most such
commands can accept any of these names.</p>

<p>In command synopses, the word &quot;tree-ish&quot; is
sometimes used to designate such an argument.</p>

<p>THE INDEX FILE The primary tool weve been using to
create commits is git-commit -a, which creates a commit
including every change youve made to your working tree. But
what if you want to commit changes only to certain files? Or
only certain changes to certain files?</p>

<p>If we look at the way commits are created under the
cover, well see that there are more flexible ways creating
commits.</p>

<p>Continuing with our test-project, let s modify file.txt
again:</p>

<p>$ echo &quot;hello world, again&quot;
&gt;&gt;file.txt</p>

<p>but this time instead of immediately making the commit,
lets take an intermediate step, and ask for diffs along the
way to keep track of whats happening:</p>

<p>$ git diff --- a/file.txt +++ b/file.txt @@ -1 +1,2 @@
hello world! +hello world, again $ git add file.txt $ git
diff</p>

<p>The last diff is empty, but no new commits have been
made, and the head still doesnt contain the new line:</p>

<p>$ git diff HEAD diff --git a/file.txt b/file.txt index
a042389..513feba 100644 --- a/file.txt +++ b/file.txt @@ -1
+1,2 @@ hello world! +hello world, again</p>

<p>So git diff is comparing against something other than
the head. The thing that it s comparing against is actually
the index file, which is stored in .git/index in a binary
format, but whose contents we can examine with ls-files:</p>

<p>$ git ls-files --stage 100644
513feba2e53ebbd2532419ded848ba19de88ba00 0 file.txt $ git
cat-file -t 513feba2 blob $ git cat-file blob 513feba2 hello
world! hello world, again</p>

<p>So what our git add did was store a new blob and then
put a reference to it in the index file. If we modify the
file again, well see that the new modifications are
reflected in the git diff output:</p>

<p>$ echo &acute;again?&acute; &gt;&gt;file.txt $ git diff
index 513feba..ba3da7b 100644 --- a/file.txt +++ b/file.txt
@@ -1,2 +1,3 @@ hello world! hello world, again +again?</p>

<p>With the right arguments, git diff can also show us the
difference between the working directory and the last
commit, or between the index and the last commit:</p>

<p>$ git diff HEAD diff --git a/file.txt b/file.txt index
a042389..ba3da7b 100644 --- a/file.txt +++ b/file.txt @@ -1
+1,3 @@ hello world! +hello world, again +again? $ git diff
--cached diff --git a/file.txt b/file.txt index
a042389..513feba 100644 --- a/file.txt +++ b/file.txt @@ -1
+1,2 @@ hello world! +hello world, again</p>

<p>At any time, we can create a new commit using git commit
(without the &quot;-a&quot; option), and verify that the
state committed only includes the changes stored in the
index file, not the additional change that is still only in
our working tree:</p>

<p>$ git commit -m &quot;repeat&quot; $ git diff HEAD diff
--git a/file.txt b/file.txt index 513feba..ba3da7b 100644
--- a/file.txt +++ b/file.txt @@ -1,2 +1,3 @@ hello world!
hello world, again +again?</p>

<p>So by default git commit uses the index to create the
commit, not the working tree; the &quot;-a&quot; option to
commit tells it to first update the index with all changes
in the working tree.</p>

<p>Finally, its worth looking at the effect of git add on
the index file:</p>

<p>$ echo &quot;goodbye, world&quot; &gt;closing.txt $ git
add closing.txt</p>

<p>The effect of the git add was to add one entry to the
index file:</p>

<p>$ git ls-files --stage 100644
8b9743b20d4b15be3955fc8d5cd2b09cd2336138 0 closing.txt
100644 513feba2e53ebbd2532419ded848ba19de88ba00 0
file.txt</p>

<p>And, as you can see with cat-file, this new entry refers
to the current contents of the file:</p>

<p>$ git cat-file blob 8b9743b2 goodbye, world</p>

<p>The &quot;status&quot; command is a useful way to get a
quick summary of the situation:</p>

<p>$ git status # On branch master # Changes to be
committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot;
to unstage) # # new file: closing.txt # # Changed but not
updated: # (use &quot;git add &lt;file&gt;...&quot; to
update what will be committed) # # modified: file.txt #</p>

<p>Since the current state of closing.txt is cached in the
index file, it is listed as &quot;Changes to be
committed&quot;. Since file.txt has changes in the working
directory that arent reflected in the index, it is marked
&quot;changed but not updated&quot;. At this point, running
&quot;git commit&quot; would create a commit that added
closing.txt (with its new contents), but that didnt modify
file.txt.</p>

<p>Also, note that a bare git diff shows the changes to
file.txt, but not the addition of closing.txt, because the
version of closing.txt in the index file is identical to the
one in the working directory.</p>

<p>In addition to being the staging area for new commits,
the index file is also populated from the object database
when checking out a branch, and is used to hold the trees
involved in a merge operation. See gitcore-tutorial(7) and
the relevant man pages for details.</p>

<p>WHAT NEXT? At this point you should know everything
necessary to read the man pages for any of the git commands;
one good place to start would be with the commands mentioned
in Everyday git[1]. You should be able to find any unknown
jargon in gitglossary(7).</p>

<p>The Git Users Manual[2] provides a more comprehensive
introduction to git.</p>

<p>gitcvs-migration(7) explains how to import a CVS
repository into git, and shows how to use git in a CVS-like
way.</p>

<p>For some interesting examples of git use, see the
howtos[3].</p>

<p>For git developers, gitcore-tutorial(7) goes into detail
on the lower-level git mechanisms involved in, for example,
creating a new commit.</p>

<p>SEE ALSO gittutorial(7), gitcvs-migration(7),
gitcore-tutorial(7), gitglossary(7), git-help(1), Everyday
git[1], The Git Uses Manual[2]</p>

<p>GIT Part of the git(1) suite.</p>

<p>NOTES 1. Everyday git
file:///usr/share/doc/git-1.7.1/everyday.html</p>

<p>2. Git Users Manual
file:///usr/share/doc/git-1.7.1/user-manual.html</p>

<p>3. howtos
file:///usr/share/doc/git-1.7.1/howto-index.html</p>

<p>Git 1.7.1 07/27/2010 GITTUTORIAL-2(7)</p>
<hr>
</body>
</html>
