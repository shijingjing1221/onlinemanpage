<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:16 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MAKECONTEXT(3) Linux Programmer s Manual
MAKECONTEXT(3)</p>

<p>NAME makecontext, swapcontext - manipulate user
context</p>

<p>SYNOPSIS #include &lt;ucontext.h&gt;</p>

<p>void makecontext(ucontext_t *ucp, void (*func)(), int
argc, ...);</p>

<p>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</p>

<p>DESCRIPTION In a System V-like environment, one has the
type ucontext_t defined in &lt;ucontext.h&gt; and the four
functions getcontext(2), setcontext(2), make- context() and
swapcontext() that allow user-level context switching
between multiple threads of control within a process.</p>

<p>For the type and the first two functions, see
getcontext(2).</p>

<p>The makecontext() function modifies the context pointed
to by ucp (which was obtained from a call to getcontext(2)).
Before invoking makecontext(), the caller must allocate a
new stack for this context and assign its address to
ucp-&gt;uc_stack, and define a successor context and assign
its address to ucp-&gt;uc_link.</p>

<p>When this context is later activated (using
setcontext(2) or swapcon- text()) the function func is
called, and passed the series of integer (int) arguments
that follow argc; the caller must specify the number of
these arguments in argc. When this function returns, the
successor context is activated. If the successor context
pointer is NULL, the thread exits.</p>

<p>The swapcontext() function saves the current context in
the structure pointed to by oucp, and then activates the
context pointed to by ucp.</p>

<p>RETURN VALUE When successful, swapcontext() does not
return. (But we may return later, in case oucp is activated,
in which case it looks like swapcon- text() returns 0.) On
error, swapcontext() returns -1 and sets errno
appropriately.</p>

<p>ERRORS ENOMEM Insufficient stack space left.</p>

<p>VERSIONS makecontext() and swapcontext() are provided in
glibc since version 2.1.</p>

<p>CONFORMING TO SUSv2, POSIX.1-2001. POSIX.1-2008 removes
the specifications of make- context() and swapcontext(),
citing portability issues, and recommend- ing that
applications be rewritten to use POSIX threads instead.</p>

<p>NOTES The interpretation of ucp-&gt;uc_stack is just as
in sigaltstack(2), namely, this struct contains the start
and length of a memory area to be used as the stack,
regardless of the direction of growth of the stack. Thus, it
is not necessary for the user program to worry about this
direction.</p>

<p>On architectures where int and pointer types are the
same size (e.g., x86-32, where both types are 32 bits), you
may be able to get away with passing pointers as arguments
to makecontext() following argc. However, doing this is not
guaranteed to be portable, is undefined according to the
standards, and won t work on architectures where pointers
are larger than ints. Nevertheless, starting with version
2.8, glibc makes some changes to makecontext(3), to permit
this on some 64-bit architectures (e.g., x86-64).</p>

<p>EXAMPLE The example program below demonstrates the use
of getcontext(2), make- context(), and swapcontext().
Running the program produces the follow- ing output:</p>

<p>$ ./a.out main: swapcontext(&amp;uctx_main,
&amp;uctx_func2) func2: started func2:
swapcontext(&amp;uctx_func2, &amp;uctx_func1) func1: started
func1: swapcontext(&amp;uctx_func1, &amp;uctx_func2) func2:
returning func1: returning main: exiting</p>

<p>Program source</p>

<p>#include &lt;ucontext.h&gt; #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>

<p>static ucontext_t uctx_main, uctx_func1, uctx_func2;</p>

<p>#define handle_error(msg) do { perror(msg);
exit(EXIT_FAILURE); } while (0)</p>

<p>static void func1(void) { printf(&quot;func1: started0);
printf(&quot;func1: swapcontext(&amp;uctx_func1,
&amp;uctx_func2)0); if (swapcontext(&amp;uctx_func1,
&amp;uctx_func2) == -1)
handle_error(&quot;swapcontext&quot;); printf(&quot;func1:
returning0); }</p>

<p>static void func2(void) { printf(&quot;func2: started0);
printf(&quot;func2: swapcontext(&amp;uctx_func2,
&amp;uctx_func1)0); if (swapcontext(&amp;uctx_func2,
&amp;uctx_func1) == -1)
handle_error(&quot;swapcontext&quot;); printf(&quot;func2:
returning0); }</p>

<p>int main(int argc, char *argv[]) { char
func1_stack[16384]; char func2_stack[16384];</p>

<p>if (getcontext(&amp;uctx_func1) == -1)
handle_error(&quot;getcontext&quot;);
uctx_func1.uc_stack.ss_sp = func1_stack;
uctx_func1.uc_stack.ss_size = sizeof(func1_stack);
uctx_func1.uc_link = &amp;uctx_main;
makecontext(&amp;uctx_func1, func1, 0);</p>

<p>if (getcontext(&amp;uctx_func2) == -1)
handle_error(&quot;getcontext&quot;);
uctx_func2.uc_stack.ss_sp = func2_stack;
uctx_func2.uc_stack.ss_size = sizeof(func2_stack); /*
Successor context is f1(), unless argc &gt; 1 */
uctx_func2.uc_link = (argc &gt; 1) ? NULL : &amp;uctx_func1;
makecontext(&amp;uctx_func2, func2, 0);</p>

<p>printf(&quot;main: swapcontext(&amp;uctx_main,
&amp;uctx_func2)0); if (swapcontext(&amp;uctx_main,
&amp;uctx_func2) == -1)
handle_error(&quot;swapcontext&quot;);</p>

<p>printf(&quot;main: exiting0); exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO getcontext(2), sigaction(2), sigaltstack(2),
sigprocmask(2), sigsetjmp(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>GNU 2009-03-31 MAKECONTEXT(3)</p>
<hr>
</body>
</html>
