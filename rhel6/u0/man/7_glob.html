<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:49 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GLOB(7) Linux Programmer s Manual GLOB(7)</p>

<p>NAME glob - Globbing pathnames</p>

<p>DESCRIPTION Long ago, in Unix V6, there was a program
/etc/glob that would expand wildcard patterns. Soon
afterwards this became a shell built-in.</p>

<p>These days there is also a library routine glob(3) that
will perform this function for a user program.</p>

<p>The rules are as follows (POSIX.2, 3.13).</p>

<p>Wildcard Matching A string is a wildcard pattern if it
contains one of the characters &rsquo;?&rsquo;,
&rsquo;*&rsquo; or &rsquo;[&rsquo;. Globbing is the
operation that expands a wildcard pattern into the list of
pathnames matching the pattern. Matching is defined by:</p>

<p>A &rsquo;?&rsquo; (not between brackets) matches any
single character.</p>

<p>A &rsquo;*&rsquo; (not between brackets) matches any
string, including the empty string.</p>

<p>Character classes</p>

<p>An expression &quot;[...]&quot; where the first
character after the leading &rsquo;[&rsquo; is not an
&rsquo;!&rsquo; matches a single character, namely any of
the characters enclosed by the brackets. The string enclosed
by the brackets cannot be empty; therefore &rsquo;]&rsquo;
can be allowed between the brackets, provided that it is the
first character. (Thus, &quot;[][!]&quot; matches the three
char- acters &rsquo;[&rsquo;, &rsquo;]&rsquo; and
&rsquo;!&rsquo;.)</p>

<p>Ranges</p>

<p>There is one special convention: two characters
separated by &rsquo;-&rsquo; denote a range. (Thus,
&quot;[A-Fa-f0-9]&quot; is equivalent to &quot;[ABCDE-
Fabcdef0123456789]&quot;.) One may include &rsquo;-&rsquo;
in its literal meaning by making it the first or last
character between the brackets. (Thus, &quot;[]-]&quot;
matches just the two characters &rsquo;]&rsquo; and
&rsquo;-&rsquo;, and &quot;[--0]&quot; matches the three
characters &rsquo;-&rsquo;, &rsquo;.&rsquo;,
&rsquo;0&rsquo;, since &rsquo;/&rsquo; cannot be
matched.)</p>

<p>Complementation</p>

<p>An expression &quot;[!...]&quot; matches a single
character, namely any character that is not matched by the
expression obtained by removing the first &rsquo;!&rsquo;
from it. (Thus, &quot;[!]a-]&quot; matches any single
character except &rsquo;]&rsquo;, &rsquo;a&rsquo; and
&rsquo;-&rsquo;.)</p>

<p>One can remove the special meaning of &rsquo;?&rsquo;,
&rsquo;*&rsquo; and &rsquo;[&rsquo; by preceding them by a
backslash, or, in case this is part of a shell command line,
enclosing them in quotes. Between brackets these characters
stand for themselves. Thus, &quot;[[?*]&quot; matches the
four characters &rsquo;[&rsquo;, &rsquo;?&rsquo;,
&rsquo;*&rsquo; and &rsquo;&acute;.</p>

<p>Pathnames Globbing is applied on each of the components
of a pathname separately. A &rsquo;/&rsquo; in a pathname
cannot be matched by a &rsquo;?&rsquo; or &rsquo;*&rsquo;
wildcard, or by a range like &quot;[.-0]&quot;. A range
cannot contain an explicit &rsquo;/&rsquo; character; this
would lead to a syntax error.</p>

<p>If a filename starts with a &rsquo;.&rsquo;, this
character must be matched explic- itly. (Thus, rm * will not
remove .profile, and tar c * will not archive all your
files; tar c . is better.)</p>

<p>Empty Lists The nice and simple rule given above:
&quot;expand a wildcard pattern into the list of matching
pathnames&quot; was the original Unix definition. It allowed
one to have patterns that expand into an empty list, as in
xv -wait 0 *.gif *.jpg where perhaps no *.gif files are
present (and this is not an error). However, POSIX requires
that a wildcard pattern is left unchanged when it is
syntactically incorrect, or the list of matching pathnames
is empty. With bash one can force the classical behavior by
setting allow_null_glob_expansion=true.</p>

<p>(Similar problems occur elsewhere. E.g., where old
scripts have rm &lsquo;find . -name &quot;*~&quot;&lsquo;
new scripts require rm -f nosuchfile &lsquo;find . -name
&quot;*~&quot;&lsquo; to avoid error messages from rm called
with an empty argument list.)</p>

<p>NOTES Regular expressions Note that wildcard patterns
are not regular expressions, although they are a bit
similar. First of all, they match filenames, rather than
text, and secondly, the conventions are not the same: for
example, in a regular expression &rsquo;*&rsquo; means zero
or more copies of the preceding thing.</p>

<p>Now that regular expressions have bracket expressions
where the nega- tion is indicated by a &rsquo;^&rsquo;,
POSIX has declared the effect of a wildcard pattern
&quot;[^...]&quot; to be undefined.</p>

<p>Character classes and Internationalization Of course
ranges were originally meant to be ASCII ranges, so that
&quot;[ -%]&quot; stands for &quot;[ !&quot;#$%]&quot; and
&quot;[a-z]&quot; stands for &quot;any lowercase
letter&quot;. Some Unix implementations generalized this so
that a range X-Y stands for the set of characters with code
between the codes for X and for Y. However, this requires
the user to know the character cod- ing in use on the local
system, and moreover, is not convenient if the collating
sequence for the local alphabet differs from the ordering of
the character codes. Therefore, POSIX extended the bracket
notation greatly, both for wildcard patterns and for regular
expressions. In the above we saw three types of items that
can occur in a bracket expression: namely (i) the negation,
(ii) explicit single characters, and (iii) ranges. POSIX
specifies ranges in an internationally more useful way and
adds three more types:</p>

<p>(iii) Ranges X-Y comprise all characters that fall
between X and Y (inclusive) in the current collating
sequence as defined by the LC_COL- LATE category in the
current locale.</p>

<p>(iv) Named character classes, like</p>

<p>[:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:]
[:graph:] [:lower:] [:print:] [:punct:] [:space:] [:upper:]
[:xdigit:]</p>

<p>so that one can say &quot;[[:lower:]]&quot; instead of
&quot;[a-z]&quot;, and have things work in Denmark, too,
where there are three letters past &rsquo;z&rsquo; in the
alphabet. These character classes are defined by the
LC_CTYPE category in the current locale.</p>

<p>(v) Collating symbols, like &quot;[.ch.]&quot; or
&quot;[.a-acute.]&quot;, where the string between
&quot;[.&quot; and &quot;.]&quot; is a collating element
defined for the current locale. Note that this may be a
multi-character element.</p>

<p>(vi) Equivalence class expressions, like
&quot;[=a=]&quot;, where the string between &quot;[=&quot;
and &quot;=]&quot; is any collating element from its
equivalence class, as defined for the current locale. For
example, &quot;[[=a=]]&quot; might be equivalent to
&quot;[a&aacute;&agrave;&auml;&acirc;]&quot; (warning:
Latin-1 here), that is, to &quot;[a[.a-
acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]&quot;.</p>

<p>SEE ALSO sh(1), fnmatch(3), glob(3), locale(7),
regex(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2003-08-24 GLOB(7)</p>
<hr>
</body>
</html>
