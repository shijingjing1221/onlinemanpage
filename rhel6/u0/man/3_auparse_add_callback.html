<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 21:53:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>AUPARSE_ADD_CALLBACK(3) Linux Audit API
AUPARSE_ADD_CALLBACK(3)</p>

<p>NAME auparse_add_callback - add a callback handler for
notifications</p>

<p>SYNOPSIS #include &lt;auparse.h&gt;</p>

<p>void auparse_add_callback(auparse_state_t *au,
auparse_callback_ptr callback, void *user_data, user_destroy
user_destroy_func);</p>

<p>DESCRIPTION auparse_add_callback adds a callback
function to the parse state which is invoked to notify the
application of parsing events.</p>

<p>The signature of the callback is:</p>

<p>void auparse_callback(auparse_state_t *au,
auparse_cb_event_t cb_event_type, void *user_data);</p>

<p>When the callback is invoked it is passed:</p>

<p>au a pointer to the parse_state</p>

<p>cb_event_type enumerated value indicating the reason why
the callback was invoked</p>

<p>user_data pointer to user supplied private data. May be
NULL.</p>

<p>user_destroy_func pointer to function called when
user_data is destroyed. May be NULL. The signature is:</p>

<p>void destroy(void *user_data);</p>

<p>The destroy() function should be prepared to accept
user_data possibly being NULL.</p>

<p>The cb_event_type argument indicates why the callback
was invoked. Its possible values are:</p>

<p>AUPARSE_CB_EVENT_READY A complete event has been parsed
and is ready to be examined. This is logically equivalent to
the parse state immediately fol- lowing
auparse_next_event()</p>

<p>See auparse_feed(3) for a complete code example.</p>

<p>RETURN VALUE Returns the previous callback pointer.</p>

<p>SEE ALSO auparse_feed(3), auparse_flush_feed(3).</p>

<p>AUTHOR John Dennis</p>

<p>Red Hat May 2007 AUPARSE_ADD_CALLBACK(3)</p>
<hr>
</body>
</html>
