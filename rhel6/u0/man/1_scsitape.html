<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:14:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SCSITAPE(1) SCSITAPE(1)</p>

<p>NAME scsitape - control SCSI tape devices</p>

<p>SYNOPSIS scsitape [-f &lt;scsi-generic-device&gt;]
commands</p>

<p>DESCRIPTION The scsitape command controls SCSI tape
drives in a platform-indepen- dent manner. As long as mtx
works on the platform, so does scsi- tape.</p>

<p>Note that scsitape and your OSs native tape driver may
stomp on each other. In particular, if you use setblk and
your OSs native tape driver has a different notion of the
block size, you may get evil results. It is recommended to
use scsitape only for software where youve written your own
low-level READ and WRITE routines that use the SCSI command
set to directly talk to tape drives (i.e., you do not use
the OSs native tape driver at all).</p>

<p>OPTIONS The first argument, given following -f , is the
SCSI generic device corresponding to your tape drive.
Consult your operating systems doc- umentation for more
information (for example, under Linux these are generally
/dev/sg0 through /dev/sg15, under FreeBSD these are
/dev/pass0 through /dev/passX. Under Solaris this is usually
the same as your tape drive (Solaris has a SCSI passthrough
ioctl). You can set the STAPE or TAPE environment variable
rather than use -f.</p>

<p>COMMANDS setblk &lt;n&gt; Set the tape drive s SCSI
block size to &lt;n&gt; bytes. (NOTE: if you are using your
OSs native tape driver, THIS IS EVIL!).</p>

<p>fsf &lt;n&gt; Go forward by &lt;n&gt; tapemarks.</p>

<p>bsf &lt;n&gt; Go to immediately previous the &lt;n&gt;th
previous tapemark. (WARNING: This probably doesn t do what
you expect -- e.g. if you are immediately after a tapemark
and type bfs 1, it moves to immediately *before* that tape
mark, for a sum total of zero effective movement!).</p>

<p>eod Go to end of data.</p>

<p>rewind Rewind the tape drive.</p>

<p>eject Eject the tape currently in the drive.</p>

<p>erase Does a *short* erase (warning: does NOT work on
all drives!).</p>

<p>mark &lt;n&gt; write &lt;n&gt; filemarks ( mark 0
flushes the drives buffers ).</p>

<p>seek &lt;n&gt; Seek to a logical position &lt;n&gt; that
was reported by a previ- ous tapeinfo command.</p>

<p>write &lt;blocksize&gt; write blocks from stdin to the
tape. Chunk the data into &lt;blocksize&gt;-sized chunks.
*DOES NOT WRITE OUT A TAPEMARK!* (you will need to use a
subsequent mark 1 command to write out a tape mark).</p>

<p>read [&lt;blocksize&gt;] [ &lt;#blocks/#bytes&gt; ] read
blocks from the tape, write them to stdout. If we are in
variable block mode, &lt;blocksize&gt; should be zero (note:
The maximum block size we currently support in variable
block mode is 128K, MAX_READ_SIZE will need to be turned
into a settable variable to allow bigger reads). If
&lt;blocksize&gt; is ommitted, we assume that we re in
variable block mode, and that we are going to read from tape
until we hit a tapemark or end of partition or end of
tape.</p>

<p>AUTHORS This program was written by Eric Lee Green
&lt;eric@badtux.org&gt;. Major portions of the mtxl.c
library used herein were written by Leonard Zubkoff.</p>

<p>The SCSI read and write routines are based upon those
that Richard Fish wrote for Enhanced Software Technology s
BRU 16.1 product, substan- tially modified to work in our
particular environment (in particular, all the variable
block stuff is new since BRU only does fixed block reads and
writes, and the BRU code uses bitmasks rather than bitfields
for the various flags and such in return values, as well as
the BRU code having a different SCSI API and having variable
names considerably shorter than the rather sesquipedalian
mtx identifiers). As required by mtxl.c, these routines are
licensed under the GNU General Public License.</p>

<p>HINTS Under Linux, cat /proc/scsi/scsi will tell you
what SCSI devices you have. You can then refer to them as
/dev/sga, /dev/sgb, etc. by the order they are reported.</p>

<p>Under FreeBSD, camcontrol devlist will tell you what
SCSI devices you have, along with which pass device controls
them.</p>

<p>Under Solaris 7 and 8, /usr/sbin/devfsadm -C will clean
up your /devices directory. Then find /devices
-namest@*-print will return a list of all tape drives. /dev
on Solaris is apparently only of his- torical interest.</p>

<p>BUGS AND LIMITATIONS for scsitape read 0 &lt;n&gt; where
you are doing variable-block-size reads and wish for
&lt;n&gt; bytes, it instead reads one and exactly one block
from tape and prints that (no matter what its size). Use dd
on the output of scsitape if you want finer control.</p>

<p>scsitape read 0 attempts reads of MAX_READ_SIZE, which
is currently 128K. If blocks on tape are larger than 128K,
only the first 128K will be read -- the remainder will be
silently dumped in the toilet.</p>

<p>This program does not interact well (or at all :-) with
your OSs native tape driver. You will likely see weird
things happen if you attempt to intermingle scsitape
commands with native tape driver opera- tions. Note that BRU
16.1 for Solaris (and possibly others, but Solaris I know
about) will have a scsi keyword to bypass the native tape
driver and write via direct uscsi commands, so if you use
&acute;scsitape&acute; to bypass the flaws of the native
Solaris driver, you can use BRU 16.1 to write your actual
tape archives. (Assuming that BRU 16.1 has been released at
the time that you read this).</p>

<p>AVAILABILITY This version of scsitape is currently being
maintained by Robert Nelson
&lt;robertnelson@users.sourceforge.net&gt; as part of the
mtx suite of pro- grams. The mtx home page is
http://mtx.sourceforge.net and the actual code is currently
available there and via SVN from http://source-
forge.net/projects/mtx.</p>

<p>SEE ALSO loaderinfo(1),tapeinfo(1),mtx(1)</p>

<p>SCSITAPE1.0 SCSITAPE(1)</p>
<hr>
</body>
</html>
