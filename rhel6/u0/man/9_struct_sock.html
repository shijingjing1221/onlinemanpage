<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:07 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT SOCK(9) Linux Networking STRUCT SOCK(9)</p>

<p>NAME struct_sock - network layer representation of
sockets</p>

<p>SYNOPSIS struct sock { struct sock_common __sk_common;
#define sk_node __sk_common.skc_node #define sk_nulls_node
__sk_common.skc_nulls_node #define sk_refcnt
__sk_common.skc_refcnt #define sk_copy_start
__sk_common.skc_hash #define sk_hash __sk_common.skc_hash
#define sk_family __sk_common.skc_family #define sk_state
__sk_common.skc_state #define sk_reuse __sk_common.skc_reuse
#define sk_bound_dev_if __sk_common.skc_bound_dev_if #define
sk_bind_node __sk_common.skc_bind_node #define sk_prot
__sk_common.skc_prot #define sk_net __sk_common.skc_net
unsigned int sk_shutdown:2; unsigned int sk_no_check:2;
unsigned int sk_userlocks:4; unsigned int sk_protocol:8;
unsigned int sk_type:16; int sk_rcvbuf; socket_lock_t
sk_lock; struct sk_backlog; wait_queue_head_t * sk_sleep;
struct dst_entry * sk_dst_cache; #ifdef CONFIG_XFRM struct
xfrm_policy * sk_policy[2]; #endif rwlock_t sk_dst_lock;
atomic_t sk_rmem_alloc; atomic_t sk_wmem_alloc; atomic_t
sk_omem_alloc; int sk_sndbuf; struct sk_buff_head
sk_receive_queue; struct sk_buff_head sk_write_queue; #ifdef
CONFIG_NET_DMA struct sk_buff_head sk_async_wait_queue;
#endif int sk_wmem_queued; int sk_forward_alloc; gfp_t
sk_allocation; int sk_route_caps; int sk_gso_type; unsigned
int sk_gso_max_size; int sk_rcvlowat; unsigned long
sk_flags; unsigned long sk_lingertime; struct sk_buff_head
sk_error_queue; struct proto * sk_prot_creator; rwlock_t
sk_callback_lock; int sk_err; int sk_err_soft; atomic_t
sk_drops; unsigned short sk_ack_backlog; unsigned short
sk_max_ack_backlog; __u32 sk_priority; struct ucred
sk_peercred; long sk_rcvtimeo; long sk_sndtimeo; struct
sk_filter * sk_filter; void * sk_protinfo; struct timer_list
sk_timer; ktime_t sk_stamp; struct socket * sk_socket; void
* sk_user_data; struct page * sk_sndmsg_page; struct sk_buff
* sk_send_head; __u32 sk_sndmsg_off; int sk_write_pending;
#ifdef CONFIG_SECURITY void * sk_security; #endif __u32
sk_mark; void (* sk_state_change) (struct sock *sk); void (*
sk_data_ready) (struct sock *sk, int bytes); void (*
sk_write_space) (struct sock *sk); void (* sk_error_report)
(struct sock *sk); int (* sk_backlog_rcv) (struct sock
*sk,struct sk_buff *skb); void (* sk_destruct) (struct sock
*sk); };</p>

<p>MEMBERS __sk_common shared layout with
inet_timewait_sock</p>

<p>sk_shutdown mask of SEND_SHUTDOWN and/or
RCV_SHUTDOWN</p>

<p>sk_no_check</p>

<p>SO_NO_CHECK setting, wether or not checkup packets</p>

<p>sk_userlocks</p>

<p>SO_SNDBUF and SO_RCVBUF settings</p>

<p>sk_protocol which protocol this socket belongs in this
network family</p>

<p>sk_type socket type (SOCK_STREAM, etc)</p>

<p>sk_rcvbuf size of receive buffer in bytes</p>

<p>sk_lock synchronizer</p>

<p>sk_backlog always used with the per-socket spinlock
held</p>

<p>sk_sleep sock wait queue</p>

<p>sk_dst_cache destination cache</p>

<p>sk_policy[2] flow policy</p>

<p>sk_dst_lock destination cache lock</p>

<p>sk_rmem_alloc receive queue bytes committed</p>

<p>sk_wmem_alloc transmit queue bytes committed</p>

<p>sk_omem_alloc &quot;o is option or other&quot;</p>

<p>sk_sndbuf size of send buffer in bytes</p>

<p>sk_receive_queue incoming packets</p>

<p>sk_write_queue Packet sending queue</p>

<p>sk_async_wait_queue DMA copied packets</p>

<p>sk_wmem_queued persistent queue size</p>

<p>sk_forward_alloc space allocated forward</p>

<p>sk_allocation allocation mode</p>

<p>sk_route_caps route capabilities (e.g. NETIF_F_TSO)</p>

<p>sk_gso_type GSO type (e.g. SKB_GSO_TCPV4)</p>

<p>sk_gso_max_size Maximum GSO segment size to build</p>

<p>sk_rcvlowat</p>

<p>SO_RCVLOWAT setting</p>

<p>sk_flags</p>

<p>SO_LINGER (l_onoff), SO_BROADCAST, SO_KEEPALIVE,
SO_OOBINLINE settings, SO_TIMESTAMPING settings</p>

<p>sk_lingertime</p>

<p>SO_LINGER l_linger setting</p>

<p>sk_error_queue rarely used</p>

<p>sk_prot_creator sk_prot of original sock creator (see
ipv6_setsockopt, IPV6_ADDRFORM for instance)</p>

<p>sk_callback_lock used with the callbacks in the end of
this struct</p>

<p>sk_err last error</p>

<p>sk_err_soft errors that don&acute;t cause failure but
are the cause of a persistent failure not just &acute;timed
out&acute;</p>

<p>sk_drops raw/udp drops counter</p>

<p>sk_ack_backlog current listen backlog</p>

<p>sk_max_ack_backlog listen backlog set in listen</p>

<p>sk_priority</p>

<p>SO_PRIORITY setting</p>

<p>sk_peercred</p>

<p>SO_PEERCRED setting</p>

<p>sk_rcvtimeo</p>

<p>SO_RCVTIMEO setting</p>

<p>sk_sndtimeo</p>

<p>SO_SNDTIMEO setting</p>

<p>sk_filter socket filtering instructions</p>

<p>sk_protinfo private area, net family specific, when not
using slab</p>

<p>sk_timer sock cleanup timer</p>

<p>sk_stamp time stamp of last packet received</p>

<p>sk_socket Identd and reporting IO signals</p>

<p>sk_user_data RPC layer private data</p>

<p>sk_sndmsg_page cached page for sendmsg</p>

<p>sk_send_head front of stuff to transmit</p>

<p>sk_sndmsg_off cached offset for sendmsg</p>

<p>sk_write_pending a write to stream socket waits to
start</p>

<p>sk_security used by security modules</p>

<p>sk_mark generic packet mark</p>

<p>sk_state_change callback to indicate change in the state
of the sock</p>

<p>sk_data_ready callback to indicate there is data to be
processed</p>

<p>sk_write_space callback to indicate there is bf sending
space available</p>

<p>sk_error_report callback to indicate errors (e.g.
MSG_ERRQUEUE)</p>

<p>sk_backlog_rcv callback to process the backlog</p>

<p>sk_destruct called at sock freeing time, i.e. when all
refcnt == 0</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
STRUCT SOCK(9)</p>
<hr>
</body>
</html>
