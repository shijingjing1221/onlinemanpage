<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:26:19 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>XDR(3) Linux Programmer s Manual XDR(3)</p>

<p>NAME xdr - library routines for external data
representation</p>

<p>SYNOPSIS AND DESCRIPTION These routines allow C
programmers to describe arbitrary data struc- tures in a
machine-independent fashion. Data for remote procedure calls
are transmitted using these routines.</p>

<p>The prototypes below are declared in &lt;rpc/xdr.h&gt;
and make use of the following types:</p>

<p>typedef int bool_t;</p>

<p>typedef bool_t (*xdrproc_t) (XDR *, void *,...);</p>

<p>For the declaration of the XDR type, see
&lt;rpc/xdr.h&gt;.</p>

<p>bool_t xdr_array(XDR *xdrs, char **arrp, unsigned int
*sizep, unsigned int maxsize, unsigned int elsize, xdrproc_t
elproc);</p>

<p>A filter primitive that translates between
variable-length arrays and their corresponding external
representations. The argument arrp is the address of the
pointer to the array, while sizep is the address of the
element count of the array; this element count cannot exceed
maxsize. The argument elsize is the sizeof each of the
arrays elements, and elproc is an XDR filter that translates
between the array elements C form, and their external
representation. This routine returns one if it suc- ceeds,
zero otherwise.</p>

<p>bool_t xdr_bool(XDR *xdrs, bool_t *bp);</p>

<p>A filter primitive that translates between booleans (C
integers) and their external representations. When encoding
data, this filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_bytes(XDR *xdrs, char **sp, unsigned int
*sizep, unsigned int maxsize);</p>

<p>A filter primitive that translates between counted byte
strings and their external representations. The argument sp
is the address of the string pointer. The length of the
string is located at address sizep; strings cannot be longer
than maxsize. This routine returns one if it succeeds, zero
otherwise.</p>

<p>bool_t xdr_char(XDR *xdrs, char *cp);</p>

<p>A filter primitive that translates between C characters
and their external representations. This routine returns one
if it succeeds, zero otherwise. Note: encoded characters are
not packed, and occupy 4 bytes each. For arrays of
characters, it is worthwhile to consider xdr_bytes(),
xdr_opaque() or xdr_string().</p>

<p>void xdr_destroy(XDR *xdrs);</p>

<p>A macro that invokes the destroy routine associated with
the XDR stream, xdrs. Destruction usually involves freeing
private data structures associated with the stream. Using
xdrs after invok- ing xdr_destroy() is undefined.</p>

<p>bool_t xdr_double(XDR *xdrs, double *dp);</p>

<p>A filter primitive that translates between C double
precision numbers and their external representations. This
routine returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_enum(XDR *xdrs, enum_t *ep);</p>

<p>A filter primitive that translates between C enums
(actually integers) and their external representations. This
routine returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_float(XDR *xdrs, float *fp);</p>

<p>A filter primitive that translates between C floats and
their external representations. This routine returns one if
it suc- ceeds, zero otherwise.</p>

<p>void xdr_free(xdrproc_t proc, char *objp);</p>

<p>Generic freeing routine. The first argument is the XDR
routine for the object being freed. The second argument is a
pointer to the object itself. Note: the pointer passed to
this routine is not freed, but what it points to is freed
(recursively).</p>

<p>unsigned int xdr_getpos(XDR *xdrs);</p>

<p>A macro that invokes the get-position routine associated
with the XDR stream, xdrs. The routine returns an unsigned
integer, which indicates the position of the XDR byte
stream. A desir- able feature of XDR streams is that simple
arithmetic works with this number, although the XDR stream
instances need not guaran- tee this.</p>

<p>long *xdr_inline(XDR *xdrs, int len);</p>

<p>A macro that invokes the inline routine associated with
the XDR stream, xdrs. The routine returns a pointer to a
contiguous piece of the streams buffer; len is the byte
length of the desired buffer. Note: pointer is cast to long
*.</p>

<p>Warning: xdr_inline() may return NULL (0) if it cannot
allocate a contiguous piece of a buffer. Therefore the
behavior may vary among stream instances; it exists for the
sake of efficiency.</p>

<p>bool_t xdr_int(XDR *xdrs, int *ip);</p>

<p>A filter primitive that translates between C integers
and their external representations. This routine returns one
if it suc- ceeds, zero otherwise.</p>

<p>bool_t xdr_long(XDR *xdrs, long *lp);</p>

<p>A filter primitive that translates between C long
integers and their external representations. This routine
returns one if it succeeds, zero otherwise.</p>

<p>void xdrmem_create(XDR *xdrs, char *addr, unsigned int
size, enum xdr_op op);</p>

<p>This routine initializes the XDR stream object pointed
to by xdrs. The stream s data is written to, or read from, a
chunk of memory at location addr whose length is no more
than size bytes long. The op determines the direction of the
XDR stream (either XDR_ENCODE, XDR_DECODE, or XDR_FREE).</p>

<p>bool_t xdr_opaque(XDR *xdrs, char *cp, unsigned int
cnt);</p>

<p>A filter primitive that translates between fixed size
opaque data and its external representation. The argument cp
is the address of the opaque object, and cnt is its size in
bytes. This routine returns one if it succeeds, zero
otherwise.</p>

<p>bool_t xdr_pointer(XDR *xdrs, char **objpp, unsigned int
objsize, xdrproc_t xdrobj);</p>

<p>Like xdr_reference() except that it serializes NULL
pointers, whereas xdr_reference() does not. Thus,
xdr_pointer() can rep- resent recursive data structures,
such as binary trees or linked lists.</p>

<p>void xdrrec_create(XDR *xdrs, unsigned int sendsize,
unsigned int recvsize, char *handle, int (*readit) (char *,
char *, int), int (*writeit) (char *, char *, int));</p>

<p>This routine initializes the XDR stream object pointed
to by xdrs. The streams data is written to a buffer of size
send- size; a value of zero indicates the system should use
a suitable default. The streams data is read from a buffer
of size recv- size; it too can be set to a suitable default
by passing a zero value. When a stream s output buffer is
full, writeit is called. Similarly, when a streams input
buffer is empty, rea- dit is called. The behavior of these
two routines is similar to the system calls read(2) and
write(2), except that handle is passed to the former
routines as the first argument. Note: the XDR streams op
field must be set by the caller.</p>

<p>Warning: this XDR stream implements an intermediate
record stream. Therefore there are additional bytes in the
stream to provide record boundary information.</p>

<p>bool_t xdrrec_endofrecord(XDR *xdrs, int sendnow);</p>

<p>This routine can be invoked only on streams created by
xdr- rec_create(). The data in the output buffer is marked
as a com- pleted record, and the output buffer is optionally
written out if sendnow is non-zero. This routine returns one
if it suc- ceeds, zero otherwise.</p>

<p>bool_t xdrrec_eof(XDR *xdrs);</p>

<p>This routine can be invoked only on streams created by
xdr- rec_create(). After consuming the rest of the current
record in the stream, this routine returns one if the stream
has no more input, zero otherwise.</p>

<p>bool_t xdrrec_skiprecord(XDR *xdrs);</p>

<p>This routine can be invoked only on streams created by
xdr- rec_create(). It tells the XDR implementation that the
rest of the current record in the streams input buffer
should be dis- carded. This routine returns one if it
succeeds, zero other- wise.</p>

<p>bool_t xdr_reference(XDR *xdrs, char **pp, unsigned int
size, xdrproc_t proc);</p>

<p>A primitive that provides pointer chasing within
structures. The argument pp is the address of the pointer;
size is the sizeof the structure that *pp points to; and
proc is an XDR procedure that filters the structure between
its C form and its external representation. This routine
returns one if it suc- ceeds, zero otherwise.</p>

<p>Warning: this routine does not understand NULL pointers.
Use xdr_pointer() instead.</p>

<p>xdr_setpos(XDR *xdrs, unsigned int pos);</p>

<p>A macro that invokes the set position routine associated
with the XDR stream xdrs. The argument pos is a position
value obtained from xdr_getpos(). This routine returns one
if the XDR stream could be repositioned, and zero
otherwise.</p>

<p>Warning: it is difficult to reposition some types of XDR
streams, so this routine may fail with one type of stream
and succeed with another.</p>

<p>bool_t xdr_short(XDR *xdrs, short *sp);</p>

<p>A filter primitive that translates between C short
integers and their external representations. This routine
returns one if it succeeds, zero otherwise.</p>

<p>void xdrstdio_create(XDR *xdrs, FILE *file, enum xdr_op
op);</p>

<p>This routine initializes the XDR stream object pointed
to by xdrs. The XDR stream data is written to, or read from,
the stdio stream file. The argument op determines the
direction of the XDR stream (either XDR_ENCODE, XDR_DECODE,
or XDR_FREE).</p>

<p>Warning: the destroy routine associated with such XDR
streams calls fflush(3) on the file stream, but never
fclose(3).</p>

<p>bool_t xdr_string(XDR *xdrs, char **sp, unsigned int
maxsize);</p>

<p>A filter primitive that translates between C strings and
their corresponding external representations. Strings cannot
be longer than maxsize. Note: sp is the address of the
strings pointer. This routine returns one if it succeeds,
zero other- wise.</p>

<p>bool_t xdr_u_char(XDR *xdrs, unsigned char *ucp);</p>

<p>A filter primitive that translates between unsigned C
characters and their external representations. This routine
returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_u_int(XDR *xdrs, unsigned *up);</p>

<p>A filter primitive that translates between C unsigned
integers and their external representations. This routine
returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_u_long(XDR *xdrs, unsigned long *ulp);</p>

<p>A filter primitive that translates between C unsigned
long inte- gers and their external representations. This
routine returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_u_short(XDR *xdrs, unsigned short *usp);</p>

<p>A filter primitive that translates between C unsigned
short integers and their external representations. This
routine returns one if it succeeds, zero otherwise.</p>

<p>bool_t xdr_union(XDR *xdrs, int *dscmp, char *unp,
struct xdr_discrim *choices, xdrproc_t defaultarm); /* may
equal NULL */</p>

<p>A filter primitive that translates between a
discriminated C union and its corresponding external
representation. It first translates the discriminant of the
union located at dscmp. This discriminant is always an
enum_t. Next the union located at unp is translated. The
argument choices is a pointer to an array of xdr_discrim()
structures. Each structure contains an ordered pair of
[value,proc]. If the union s discriminant is equal to the
associated value, then the proc is called to translate the
union. The end of the xdr_discrim() structure array is
denoted by a routine of value NULL. If the discriminant is
not found in the choices array, then the defaultarm
procedure is called (if it is not NULL). Returns one if it
succeeds, zero otherwise.</p>

<p>bool_t xdr_vector(XDR *xdrs, char *arrp, unsigned int
size, unsigned int elsize, xdrproc_t elproc);</p>

<p>A filter primitive that translates between fixed-length
arrays and their corresponding external representations. The
argument arrp is the address of the pointer to the array,
while size is the element count of the array. The argument
elsize is the sizeof each of the arrays elements, and elproc
is an XDR filter that translates between the array elements
C form, and their external representation. This routine
returns one if it suc- ceeds, zero otherwise.</p>

<p>bool_t xdr_void(void);</p>

<p>This routine always returns one. It may be passed to RPC
rou- tines that require a function argument, where nothing
is to be done.</p>

<p>bool_t xdr_wrapstring(XDR *xdrs, char **sp);</p>

<p>A primitive that calls xdr_string(xdrs,
sp,MAXUN.UNSIGNED ); where MAXUN.UNSIGNED is the maximum
value of an unsigned inte- ger. xdr_wrapstring() is handy
because the RPC package passes a maximum of two XDR routines
as arguments, and xdr_string(), one of the most frequently
used primitives, requires three. Returns one if it succeeds,
zero otherwise.</p>

<p>SEE ALSO rpc(3)</p>

<p>The following manuals: eXternal Data Representation
Standard: Protocol Specification eXternal Data
Representation: Sun Technical Notes XDR: External Data
Representation Standard, RFC 1014, Sun Microsystems, Inc.,
USC-ISI.</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>2007-12-30 XDR(3)</p>
<hr>
</body>
</html>
