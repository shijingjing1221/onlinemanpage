<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLSTYLE(1) Perl Programmers Reference Guide
PERLSTYLE(1)</p>

<p>NAME perlstyle - Perl style guide</p>

<p>DESCRIPTION Each programmer will, of course, have his or
her own preferences in regards to formatting, but there are
some general guidelines that will make your programs easier
to read, understand, and maintain.</p>

<p>The most important thing is to run your programs under
the -w flag at all times. You may turn it off explicitly for
particular portions of code via the &quot;no warnings&quot;
pragma or the $^W variable if you must. You should also
always run under &quot;use strict&quot; or know the reason
why not. The &quot;use sigtrap&quot; and even &quot;use
diagnostics&quot; pragmas may also prove useful.</p>

<p>Regarding aesthetics of code lay out, about the only
thing Larry cares strongly about is that the closing curly
bracket of a multi-line BLOCK should line up with the
keyword that started the construct. Beyond that, he has
other preferences that arent so strong:</p>

<p>&middot; 4-column indent.</p>

<p>&middot; Opening curly on same line as keyword, if
possible, otherwise line up.</p>

<p>&middot; Space before the opening curly of a multi-line
BLOCK.</p>

<p>&middot; One-line BLOCK may be put on one line,
including curlies.</p>

<p>&middot; No space before the semicolon.</p>

<p>&middot; Semicolon omitted in &quot;short&quot; one-line
BLOCK.</p>

<p>&middot; Space around most operators.</p>

<p>&middot; Space around a &quot;complex&quot; subscript
(inside brackets).</p>

<p>&middot; Blank lines between chunks that do different
things.</p>

<p>&middot; Uncuddled elses.</p>

<p>&middot; No space between function name and its opening
parenthesis.</p>

<p>&middot; Space after each comma.</p>

<p>&middot; Long lines broken after an operator (except
&quot;and&quot; and &quot;or&quot;).</p>

<p>&middot; Space after last parenthesis matching on
current line.</p>

<p>&middot; Line up corresponding items vertically.</p>

<p>&middot; Omit redundant punctuation as long as clarity
doesn t suffer.</p>

<p>Larry has his reasons for each of these things, but he
doesnt claim that everyone elses mind works the same as his
does.</p>

<p>Here are some other more substantive style issues to
think about:</p>

<p>&middot; Just because you CAN do something a particular
way doesnt mean that you SHOULD do it that way. Perl is
designed to give you several ways to do anything, so
consider picking the most readable one. For instance</p>

<p>open(FOO,$foo) || die &quot;Can&rsquo;t open $foo:
$!&quot;;</p>

<p>is better than</p>

<p>die &quot;Can&rsquo;t open $foo: $!&quot; unless
open(FOO,$foo);</p>

<p>because the second way hides the main point of the
statement in a modifier. On the other hand</p>

<p>print &quot;Starting analysis0 if $verbose;</p>

<p>is better than</p>

<p>$verbose &amp;&amp; print &quot;Starting analysis0;</p>

<p>because the main point isnt whether the user typed -v or
not.</p>

<p>Similarly, just because an operator lets you assume
default arguments doesnt mean that you have to make use of
the defaults. The defaults are there for lazy systems
programmers writing one- shot programs. If you want your
program to be readable, consider supplying the argument.</p>

<p>Along the same lines, just because you CAN omit
parentheses in many places doesnt mean that you ought
to:</p>

<p>return print reverse sort num values %array; return
print(reverse(sort num (values(%array))));</p>

<p>When in doubt, parenthesize. At the very least it will
let some poor schmuck bounce on the % key in vi.</p>

<p>Even if you aren t in doubt, consider the mental welfare
of the person who has to maintain the code after you, and
who will probably put parentheses in the wrong place.</p>

<p>&middot; Dont go through silly contortions to exit a
loop at the top or the bottom, when Perl provides the
&quot;last&quot; operator so you can exit in the middle.
Just &quot;outdent&quot; it a little to make it more
visible:</p>

<p>LINE: for (;;) { statements; last LINE if $foo; next
LINE if /^#/; statements; }</p>

<p>&middot; Don t be afraid to use loop labels--theyre
there to enhance readability as well as to allow multilevel
loop breaks. See the previous example.</p>

<p>&middot; Avoid using &quot;grep()&quot; (or
&quot;map()&quot;) or backticks in a void context, that is,
when you just throw away their return values. Those
functions all have return values, so use them. Otherwise use
a &quot;foreach()&quot; loop or the &quot;system()&quot;
function instead.</p>

<p>&middot; For portability, when using features that may
not be implemented on every machine, test the construct in
an eval to see if it fails. If you know what version or
patchlevel a particular feature was implemented, you can
test $] ($PERL_VERSION in &quot;English&quot;) to see if it
will be there. The &quot;Config&quot; module will also let
you interrogate values determined by the Configure program
when Perl was installed.</p>

<p>&middot; Choose mnemonic identifiers. If you can t
remember what mnemonic means, youve got a problem.</p>

<p>&middot; While short identifiers like $gotit are
probably ok, use underscores to separate words in longer
identifiers. It is generally easier to read
$var_names_like_this than $VarNamesLikeThis, especially for
non-native speakers of English. Its also a simple rule that
works consistently with &quot;VAR_NAMES_LIKE_THIS&quot;.</p>

<p>Package names are sometimes an exception to this rule.
Perl informally reserves lowercase module names for
&quot;pragma&quot; modules like &quot;integer&quot; and
&quot;strict&quot;. Other modules should begin with a
capital letter and use mixed case, but probably without
underscores due to limitations in primitive file systems
representations of module names as files that must fit into
a few sparse bytes.</p>

<p>&middot; You may find it helpful to use letter case to
indicate the scope or nature of a variable. For example:</p>

<p>$ALL_CAPS_HERE constants only (beware clashes with perl
vars!) $Some_Caps_Here package-wide global/static
$no_caps_here function scope my() or local() variables</p>

<p>Function and method names seem to work best as all
lowercase. E.g., &quot;$obj-&gt;as_string()&quot;.</p>

<p>You can use a leading underscore to indicate that a
variable or function should not be used outside the package
that defined it.</p>

<p>&middot; If you have a really hairy regular expression,
use the &quot;/x&quot; modifier and put in some whitespace
to make it look a little less like line noise. Dont use
slash as a delimiter when your regexp has slashes or
backslashes.</p>

<p>&middot; Use the new &quot;and&quot; and &quot;or&quot;
operators to avoid having to parenthesize list operators so
much, and to reduce the incidence of punctuation operators
like &quot;&amp;&amp;&quot; and &quot;||&quot;. Call your
subroutines as if they were functions or list operators to
avoid excessive ampersands and parentheses.</p>

<p>&middot; Use here documents instead of repeated
&quot;print()&quot; statements.</p>

<p>&middot; Line up corresponding things vertically,
especially if itd be too long to fit on one line anyway.</p>

<p>$IDX = $ST_MTIME; $IDX = $ST_ATIME if $opt_u; $IDX =
$ST_CTIME if $opt_c; $IDX = $ST_SIZE if $opt_s;</p>

<p>mkdir $tmpdir, 0700 or die &quot;can&rsquo;t mkdir
$tmpdir: $!&quot;; chdir($tmpdir) or die &quot;can&rsquo;t
chdir $tmpdir: $!&quot;; mkdir &rsquo;tmp&rsquo;, 0777 or
die &quot;can&rsquo;t mkdir $tmpdir/tmp: $!&quot;;</p>

<p>&middot; Always check the return codes of system calls.
Good error messages should go to &quot;STDERR&quot;, include
which program caused the problem, what the failed system
call and arguments were, and (VERY IMPORTANT) should contain
the standard system error message for what went wrong. Here
s a simple but sufficient example:</p>

<p>opendir(D, $dir) or die &quot;can&rsquo;t opendir $dir:
$!&quot;;</p>

<p>&middot; Line up your transliterations when it makes
sense:</p>

<p>tr [abc] [xyz];</p>

<p>&middot; Think about reusability. Why waste brainpower
on a one-shot when you might want to do something like it
again? Consider generalizing your code. Consider writing a
module or object class. Consider making your code run
cleanly with &quot;use strict&quot; and &quot;use
warnings&quot; (or -w) in effect. Consider giving away your
code. Consider changing your whole world view. Consider...
oh, never mind.</p>

<p>&middot; Try to document your code and use Pod
formatting in a consistent way. Here are commonly expected
conventions:</p>

<p>&middot; use &quot;C&lt;&gt;&quot; for function,
variable and module names (and more generally anything that
can be considered part of code, like filehandles or specific
values). Note that function names are considered more
readable with parentheses after their name, that is
&quot;function()&quot;.</p>

<p>&middot; use &quot;B&lt;&gt;&quot; for commands names
like cat or grep.</p>

<p>&middot; use &quot;F&lt;&gt;&quot; or
&quot;C&lt;&gt;&quot; for file names. &quot;F&lt;&gt;&quot;
should be the only Pod code for file names, but as most Pod
formatters render it as italic, Unix and Windows paths with
their slashes and backslashes may be less readable, and
better rendered with &quot;C&lt;&gt;&quot;.</p>

<p>&middot; Be consistent.</p>

<p>&middot; Be nice.</p>

<p>perl v5.10.1 2009-02-12 PERLSTYLE(1)</p>
<hr>
</body>
</html>
