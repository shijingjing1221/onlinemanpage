<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:21:12 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>Tcl_SetChannelError(3) Tcl Library Procedures
Tcl_SetChannelError(3)</p>


<p>______________________________________________________________________________</p>

<p>NAME Tcl_SetChannelError, Tcl_SetChannelErrorInterp,
Tcl_GetChannelError, Tcl_GetChannelErrorInterp - functions
to create/intercept Tcl errors by channel drivers.</p>

<p>SYNOPSIS #include &lt;tcl.h&gt;</p>

<p>void Tcl_SetChannelError(chan, msg)</p>

<p>void Tcl_SetChannelErrorInterp(interp, msg)</p>

<p>void Tcl_GetChannelError(chan, msgPtr)</p>

<p>void Tcl_GetChannelErrorInterp(interp, msgPtr)</p>

<p>ARGUMENTS Tcl_Channel chan (in) Refers to the Tcl
channel whose bypass area is accessed.</p>

<p>Tcl_Interp* interp (in) Refers to the Tcl interpreter
whose bypass area is accessed.</p>

<p>Tcl_Obj* msg (in) Error message put into a bypass area.
A list of return options and values, fol- lowed by a string
message. Both message and the option/value information are
optional.</p>

<p>Tcl_Obj** msgPtr (out) Reference to a place where the
message stored in the accessed bypass area can be stored in.
_________________________________________________________________</p>

<p>DESCRIPTION The current definition of a Tcl channel
driver does not permit the direct return of arbitrary error
messages, except for the setting and retrieval of channel
options. All other functions are restricted to POSIX error
codes.</p>

<p>The functions described here overcome this limitation.
Channel drivers are allowed to use Tcl_SetChannelError and
Tcl_SetChannelErrorInterp to place arbitrary error messages
in bypass areas defined for channels and interpreters. And
the generic I/O layer uses Tcl_GetChannelError and
Tcl_GetChannelErrorInterp to look for messages in the bypass
areas and arrange for their return as errors. The posix
error codes set by a driver are used now if and only if no
messages are present.</p>

<p>Tcl_SetChannelError stores error information in the
bypass area of the specified channel. The number of
references to the msg object goes up by one. Previously
stored information will be discarded, by releasing the
reference held by the channel. The channel reference must
not be NULL.</p>

<p>Tcl_SetChannelErrorInterp stores error information in
the bypass area of the specified interpreter. The number of
references to the msg object goes up by one. Previously
stored information will be discarded, by releasing the
reference held by the interpreter. The interpreter reference
must not be NULL.</p>

<p>Tcl_GetChannelError places either the error message held
in the bypass area of the specified channel into msgPtr, or
NULL; and resets the bypass. I.e. after an invokation all
following invokations will return NULL, until an intervening
invokation of Tcl_SetChannelError with a non-NULL message.
The msgPtr must not be NULL. The reference count of the
message is not touched. The reference previously held by the
chan- nel is now held by the caller of the function and it
is its responsi- bility to release that reference when it is
done with the object.</p>

<p>Tcl_GetChannelErrorInterp places either the error
message held in the bypass area of the specified interpreter
into msgPtr, or NULL; and resets the bypass. I.e. after an
invokation all following invokations will return NULL, until
an intervening invokation of Tcl_SetChannelEr- rorInterp
with a non-NULL message. The msgPtr must not be NULL. The
reference count of the message is not touched. The reference
previ- ously held by the interpreter is now held by the
caller of the function and it is its responsibility to
release that reference when it is done with the object.</p>

<p>Which functions of a channel driver are allowed to use
which bypass function is listed below, as is which functions
of the public channel API may leave a messages in the bypass
areas.</p>

<p>Tcl_DriverCloseProc May use Tcl_SetChannelErrorInterp,
and only this function.</p>

<p>Tcl_DriverInputProc May use Tcl_SetChannelError, and
only this function.</p>

<p>Tcl_DriverOutputProc May use Tcl_SetChannelError, and
only this function.</p>

<p>Tcl_DriverSeekProc May use Tcl_SetChannelError, and only
this function.</p>

<p>Tcl_DriverWideSeekProc May use Tcl_SetChannelError, and
only this function.</p>

<p>Tcl_DriverSetOptionProc Has already the ability to pass
arbitrary error messages. Must not use any of the new
functions.</p>

<p>Tcl_DriverGetOptionProc Has already the ability to pass
arbitrary error messages. Must not use any of the new
functions.</p>

<p>Tcl_DriverWatchProc Must not use any of the new
functions. Is internally called and has no ability to return
any type of error whatsoever.</p>

<p>Tcl_DriverBlockModeProc May use Tcl_SetChannelError, and
only this function.</p>

<p>Tcl_DriverGetHandleProc Must not use any of the new
functions. It is only a low-level function, and not used by
Tcl commands.</p>

<p>Tcl_DriverHandlerProc Must not use any of the new
functions. Is internally called and has no ability to return
any type of error whatsoever.</p>

<p>Given the information above the following public
functions of the Tcl C API are affected by these changes.
I.e. when these functions are called the channel may now
contain a stored arbitrary error message requiring
processing by the caller.</p>

<p>Tcl_StackChannel</p>

<p>Tcl_Seek</p>

<p>Tcl_Tell</p>

<p>Tcl_ReadRaw</p>

<p>Tcl_Read</p>

<p>Tcl_ReadChars</p>

<p>Tcl_Gets</p>

<p>Tcl_GetsObj</p>

<p>Tcl_Flush</p>

<p>Tcl_WriteRaw</p>

<p>Tcl_WriteObj</p>

<p>Tcl_Write</p>

<p>Tcl_WriteChars</p>

<p>All other API functions are unchanged. Especially the
functions below leave all their error information in the
interpreter result.</p>

<p>Tcl_Close</p>

<p>Tcl_UnregisterChannel</p>

<p>Tcl_UnstackChannel</p>

<p>SEE ALSO Tcl_Close(3), Tcl_OpenFileChannel(3),
Tcl_SetErrno(3)</p>

<p>KEYWORDS channel driver, error messages, channel
type</p>

<p>Tcl 8.5 Tcl_SetChannelError(3)</p>
<hr>
</body>
</html>
