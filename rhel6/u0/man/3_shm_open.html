<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:15:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SHM_OPEN(3) Linux Programmer s Manual SHM_OPEN(3)</p>

<p>NAME shm_open, shm_unlink - Create/open or unlink POSIX
shared memory objects</p>

<p>SYNOPSIS #include &lt;sys/mman.h&gt; #include
&lt;sys/stat.h&gt; /* For mode constants */ #include
&lt;fcntl.h&gt; /* For O_* constants */</p>

<p>int shm_open(const char *name, int oflag, mode_t
mode);</p>

<p>int shm_unlink(const char *name);</p>

<p>Link with -lrt.</p>

<p>DESCRIPTION shm_open() creates and opens a new, or opens
an existing, POSIX shared memory object. A POSIX shared
memory object is in effect a handle which can be used by
unrelated processes to mmap(2) the same region of shared
memory. The shm_unlink() function performs the converse
opera- tion, removing an object previously created by
shm_open().</p>

<p>The operation of shm_open() is analogous to that of
open(2). name specifies the shared memory object to be
created or opened. For portable use, a shared memory object
should be identified by a name of the form /somename; that
is, a null-terminated string of up to NAME_MAX (i.e., 255)
characters consisting of an initial slash, followed by one
or more characters, none of which are slashes.</p>

<p>oflag is a bit mask created by ORing together exactly
one of O_RDONLY or O_RDWR and any of the other flags listed
here:</p>

<p>O_RDONLY Open the object for read access. A shared
memory object opened in this way can only be mmap(2)ed for
read (PROT_READ) access.</p>

<p>O_RDWR Open the object for read-write access.</p>

<p>O_CREAT Create the shared memory object if it does not
exist. The user and group ownership of the object are taken
from the corresponding effective IDs of the calling process,
and the object s permission bits are set according to the
low-order 9 bits of mode, except that those bits set in the
process file mode creation mask (see umask(2)) are cleared
for the new object. A set of macro constants which can be
used to define mode is listed in open(2). (Symbolic
definitions of these constants can be obtained by including
&lt;sys/stat.h&gt;.)</p>

<p>A new shared memory object initially has zero length the
size of the object can be set using ftruncate(2). The newly
allocated bytes of a shared memory object are automatically
initialized to 0.</p>

<p>O_EXCL If O_CREAT was also specified, and a shared
memory object with the given name already exists, return an
error. The check for the existence of the object, and its
creation if it does not exist, are performed atomically.</p>

<p>O_TRUNC If the shared memory object already exists,
truncate it to zero bytes.</p>

<p>Definitions of these flag values can be obtained by
including &lt;fcntl.h&gt;.</p>

<p>On successful completion shm_open() returns a new file
descriptor referring to the shared memory object. This file
descriptor is guaran- teed to be the lowest-numbered file
descriptor not previously opened within the process. The
FD_CLOEXEC flag (see fcntl(2)) is set for the file
descriptor.</p>

<p>The file descriptor is normally used in subsequent calls
to ftrun- cate(2) (for a newly created object) and mmap(2).
After a call to mmap(2) the file descriptor may be closed
without affecting the memory mapping.</p>

<p>The operation of shm_unlink() is analogous to unlink(2):
it removes a shared memory object name, and, once all
processes have unmapped the object, de-allocates and
destroys the contents of the associated memory region. After
a successful shm_unlink(), attempts to shm_open() an object
with the same name will fail (unless O_CREAT was specified,
in which case a new, distinct object is created).</p>

<p>RETURN VALUE On success, shm_open() returns a
non-negative file descriptor. On failure, shm_open() returns
-1. shm_unlink() returns 0 on success, or -1 on error.</p>

<p>ERRORS On failure, errno is set to indicate the cause of
the error. Values which may appear in errno include the
following:</p>

<p>EACCES Permission to shm_unlink() the shared memory
object was denied.</p>

<p>EACCES Permission was denied to shm_open() name in the
specified mode, or O_TRUNC was specified and the caller does
not have write per- mission on the object.</p>

<p>EEXIST Both O_CREAT and O_EXCL were specified to
shm_open() and the shared memory object specified by name
already exists.</p>

<p>EINVAL The name argument to shm_open() was invalid.</p>

<p>EMFILE The process already has the maximum number of
files open.</p>

<p>ENAMETOOLONG The length of name exceeds PATH_MAX.</p>

<p>ENFILE The limit on the total number of files open on
the system has been reached.</p>

<p>ENOENT An attempt was made to shm_open() a name that did
not exist, and O_CREAT was not specified.</p>

<p>ENOENT An attempt was to made to shm_unlink() a name
that does not exist.</p>

<p>VERSIONS These functions are provided in glibc 2.2 and
later.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>POSIX.1-2001 says that the group ownership of a newly
created shared memory object is set to either the calling
process s effective group ID or &quot;a system default group
ID&quot;.</p>

<p>NOTES POSIX leaves the behavior of the combination of
O_RDONLY and O_TRUNC unspecified. On Linux, this will
successfully truncate an existing shared memory object this
may not be so on other Unix systems.</p>

<p>The POSIX shared memory object implementation on Linux
2.4 makes use of a dedicated file system, which is normally
mounted under /dev/shm.</p>

<p>SEE ALSO close(2), fchmod(2), fchown(2), fcntl(2),
fstat(2), ftruncate(2), mmap(2), open(2), umask(2),
shm_overview(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2009-02-25 SHM_OPEN(3)</p>
<hr>
</body>
</html>
