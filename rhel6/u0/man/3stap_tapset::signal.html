<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TAPSET::SIGNAL(3stap) TAPSET::SIGNAL(3stap)</p>

<p>NAME tapset::signal - systemtap signal probe points</p>

<p>DESCRIPTION This family of probe points is used to probe
signal activities. It contains the following probe
points:</p>

<p>signal.send</p>

<p>Fires when a signal is sent to a process</p>

<p>Arguments:</p>

<p>sig signal number</p>

<p>sig_name a string representation of the signal</p>

<p>sig_pid pid of the signal recipient process</p>

<p>pid_name name of the signal recipient process</p>

<p>si_code indicates the signal type</p>

<p>task a task handle to the signal recipient</p>

<p>sinfo the address of siginfo struct</p>

<p>shared indicates whether this signal is shared by the
thread group</p>

<p>send2queue indicates whether this signal is sent to an
existing sigqueue</p>

<p>name name of the function used to send out this
signal</p>

<p>signal.send.return</p>

<p>Fires when return from sending a signal</p>

<p>Arguments:</p>

<p>retstr the return value</p>

<p>Return values for &quot;__group_send_sig_info&quot; and
&quot;spe- cific_send_sig_info&quot;</p>

<p>- return 0 if the signal is successfully sent to a
process, which means the following:</p>

<p>&lt;1&gt; the signal is ignored by receiving process</p>

<p>&lt;2&gt; this is a non-RT signal and we already have
one queued</p>

<p>&lt;3&gt; the signal is successfully added into the
sigqueue of receiving process</p>

<p>- return -EAGAIN if the sigqueue is overflow the signal
was RT and sent by user using something other than
kill()</p>

<p>Return values for &quot;send_group_sigqueue&quot;</p>

<p>- return 0 if the signal is either successfully added
into the sigqueue of receiving process or a SI_TIMER entry
is already queued so just increment the overrun count</p>

<p>- return 1 if this signal is ignored by receiving
process</p>

<p>Return values for &quot;send_sigqueue&quot;</p>

<p>- return 0 if the signal is either successfully added
into the sigqueue of receiving process or a SI_TIMER entry
is already queued so just increment the overrun count</p>

<p>- return 1 if this signal is ignored by receiving
process</p>

<p>- return -1 if the task is marked exiting, so
posix_timer_event can redirect it to the group leader</p>

<p>shared indicates whether this signal is shared by the
thread group</p>

<p>send2queue indicates whether this signal is sent to an
existing sigqueue</p>

<p>name name of the function used to send out this
signal</p>

<p>signal.checkperm</p>

<p>Fires when check permissions for sending the signal</p>

<p>Arguments:</p>

<p>sig the number of the signal</p>

<p>sig_name a string representation of the signal</p>

<p>sig_pid pid of the signal recipient process</p>

<p>pid_name name of the signal recipient process</p>

<p>si_code indicates the signal type</p>

<p>task a task handle to the signal recipient</p>

<p>sinfo the address of siginfo struct</p>

<p>name name of the probe point, is set to
&quot;signal.checkperm&quot;</p>

<p>signal.checkperm.return</p>

<p>Fires when return from permissions check for sending a
signal</p>

<p>Arguments:</p>

<p>retstr the return value</p>

<p>name name of the probe point, is set to
&quot;signal.checkperm&quot;</p>

<p>signal.wakeup</p>

<p>Fires when wake up the process for new active
signals</p>

<p>Arguments:</p>

<p>sig_pid pid of the process to be woke up</p>

<p>pid_name name of the process to be woke up</p>

<p>resume indicate whether to wake up a task in STOPPED or
TRACED state</p>

<p>state_mask a string representation indicate the mask of
task states that can be woken. Possible values are
(TASK_INTERRUPT- IBLE|TASK_STOPPED|TASK_TRACED) and
TASK_INTERRUPTIBLE.</p>

<p>signal.check_ignored</p>

<p>Fires when check whether the signal is ignored or
not</p>

<p>Arguments:</p>

<p>sig_pid pid of the signal recipient process</p>

<p>pid_name name of the signal recipient process</p>

<p>sig the signal to be checked</p>

<p>sig_name name of the signal</p>

<p>signal.check_ignored.return</p>

<p>Fires when return from signal.check_ignored</p>

<p>Arguments:</p>

<p>retstr return value. 0 indicate the current signal isn t
ignored.</p>

<p>signal.force_segv</p>

<p>Forces SIGSEGV when there are some issues while handling
signals for the process</p>

<p>Arguments:</p>

<p>sig_pid pid of the signal recipient process</p>

<p>pid_name name of the signal recipient process</p>

<p>sig the signal being handled</p>

<p>sig_name name of this signal</p>

<p>signal.force_segv.return</p>

<p>Fires when return from signal.force_segv</p>

<p>Arguments:</p>

<p>retstr return value. Always return 0</p>

<p>signal.syskill</p>

<p>Fires when sys_kill is called to send a signal to a
process.</p>

<p>Arguments:</p>

<p>pid pid of the recipient process</p>

<p>sig the signal to be sent</p>

<p>signal.syskill.return</p>

<p>Fires when returning from sys_kill</p>

<p>signal.tgkill</p>

<p>Fires when sys_tgkill is called to send a signal to one
specific thread</p>

<p>Arguments:</p>

<p>pid pid of the recipient thread</p>

<p>tgid thread group id which the target thread should
have</p>

<p>sig the signal to be sent</p>

<p>signal.tgkill.return</p>

<p>Fires when returning from sys_tgkill</p>

<p>signal.tkill</p>

<p>Fires when sys_tkill is called to send a signal to a
single pro- cess.</p>

<p>Arguments:</p>

<p>pid pid of the recipient process</p>

<p>sig the signal to be sent</p>

<p>signal.tkill.return</p>

<p>Fires when returning from sys_tkill</p>

<p>signal.send_sig_queue</p>

<p>Fires when queue a signal to a process</p>

<p>Arguments:</p>

<p>sig the signal to be queued</p>

<p>sig_name name of this signal</p>

<p>sig_pid pid of the process to which the signal is
queued</p>

<p>pid_name name of the process to which the signal is
queued</p>

<p>sigqueue_addr address of the signal queue</p>

<p>signal.send_sig_queue.return</p>

<p>Fires when return from signal.send_sig_queue</p>

<p>Arguments:</p>

<p>retstr return value</p>

<p>signal.pending</p>

<p>Fires when examine the set of signals that are pending
for delivery to the calling thread</p>

<p>Arguments:</p>

<p>sigset_add address of user space sigset_t</p>

<p>sigset_size sigset size</p>

<p>signal.pending.return</p>

<p>Fires when return from signal.pending</p>

<p>Arguments:</p>

<p>retstr return value</p>

<p>signal.handle</p>

<p>Fires when invoking the signal handler</p>

<p>Arguments:</p>

<p>sig signal number</p>

<p>sig_name signal name</p>

<p>sinfo address of siginfo struct</p>

<p>sig_code the si_code of siginfo</p>

<p>ka_addr Address of the k_sigaction struct associated
with the signal</p>

<p>oldset_addr Address of a bit mask array of blocked
signals</p>

<p>sig_mode indicates whether the signal is a User Mode or
Kernel mode Signal</p>

<p>signal.handle.return</p>

<p>Fires when return from signal.handle</p>

<p>Arguments:</p>

<p>retstr return value of handle_signal()</p>

<p>signal.do_action</p>

<p>Fires by calling thread to examine and change a signal
action</p>

<p>Arguments:</p>

<p>sig signal number</p>

<p>sigact_addr address of the new sigaction struct
associated with the signal</p>

<p>oldsigact_addr address of a previous sigaction struct
associated with the signal</p>

<p>sa_handler the new handler of the signal</p>

<p>sa_mask the new mask of the signal</p>

<p>signal.do_action.return</p>

<p>Fires when return from signal.do_action</p>

<p>Arguments:</p>

<p>retstr return value of do_sigaction()</p>

<p>signal.procmask</p>

<p>Fires by calling thread to examine and change blocked
signals</p>

<p>Arguments:</p>

<p>how indicates how to change the blocked signals.
Possible values are: SIG_BLOCK=0 for blocking signals
SIG_UNBLOCK=1 for unblocking signals SIG_SETMASK=2 for
setting the signal mask</p>

<p>sigset_addr address of sigset_t to be set</p>

<p>oldsigset_addr address of the old sigset_t</p>

<p>sigset the actual sigset to be set</p>

<p>signal.procmask.return</p>

<p>Fires when return from signal.procmask</p>

<p>Arguments:</p>

<p>retstr return value of sigprocmask()</p>

<p>signal.flush</p>

<p>Fires when flush all pending signals for a task</p>

<p>Arguments:</p>

<p>task the task handler of the process</p>

<p>sig_pid pid of the task</p>

<p>pid_name name of the task</p>

<p>SEE ALSO stap(1), stapprobes(3stap)</p>

<p>IBM TAPSET::SIGNAL(3stap)</p>
<hr>
</body>
</html>
