<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:09:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>Pamflip User Manual(0) Pamflip User Manual(0)</p>

<p>NAME pamflip - flip or rotate a PAM or PNM image</p>

<p>SYNOPSIS pamflip { -leftright | -lr | -topbottom | -tb |
-transpose | -xy | -rotate90 | -r90 | -cw | -rotate270 |
-r270 | -ccw | -rotate180 | -r180 -null |
-xform=xform1,xform2... } [-memsize=mebibytes] [-page-
size=bytes] [pamfile]</p>

<p>All options can be abbreviated to their shortest unique
prefix. You may use two hyphens instead of one to designate
an option. You may use either white space or an equals sign
between an option name and its value.</p>

<p>DESCRIPTION This program is part of Netpbm(1).</p>

<p>pamflip flips a PAM or PNM image top for bottom or left
for right, or transposes it horizontal for vertical, or
rotates it 1, 2, or 3 quarter turns.</p>

<p>To rotate at other angles, use pnmrotate. It is much
slower, though.</p>

<p>The input image is pamfile, or Standard Input if pamfile
is not speci- fied.</p>

<p>To flip/rotate a JFIF (JPEG) image losslessly, use
jpegtran. jpegtran is part of the Independent Jpeg Groups
compression library package, not part of Netpbm. The normal
Netpbm way to flip a JFIF file would be to convert it to
PNM, use pamflip, and convert back to JFIF. But since JPEG
compression is lossy, the resulting image would have less
quality than the original. jpegtran, on the other hand, can
do this particular transformation directly on the compressed
data without loss.</p>

<p>OPTIONS You must supply exactly one of the following
options:</p>

<p>pamflip s predecessor (before Netpbm 10.7 - August 2002)
pnmflip did not have the -xform option and instead allowed
you to specify any num- ber of the other options, including
zero. It applied all the indicated transformations, in the
order given, just like with pamflips -xform option. (Reason
for the change: this kind of interpretation of options is
inconsistent with the rest of Netpbm and most of the Unix
world, and thus hard to understand and to implement).</p>

<p>-leftright</p>

<p>-lr Flip left for right.</p>

<p>-topbottom</p>

<p>-tb Flip top for bottom.</p>

<p>-transpose</p>

<p>-xy Transpose horizontal for vertical. I.e. make the
pixel at (x,y) be at (y,x).</p>

<p>-rotate90</p>

<p>-r90</p>

<p>-ccw Rotate counterclockwise 90 degrees.</p>

<p>-rotate180</p>

<p>-r180 Rotate 180 degrees.</p>

<p>-rotate270</p>

<p>-r270</p>

<p>-cw Rotate counterclockwise 270 degrees (clockwise 90
degrees)</p>

<p>-null No change. (The purpose of this option is the
convenience of programs that invoke pamflip after computing
the kind of trans- formation desired, including none at
all).</p>

<p>This option was new in Netpbm 10.13 (December 2002).</p>

<p>-xform=xform1,xform2... Apply all the transforms listed,
in order. The valid values for the transforms are as follows
and have the same meanings as the identically named options
above.</p>

<p>&middot; leftright</p>

<p>&middot; topbottom</p>

<p>&middot; transpose</p>

<p>This option was new in Netpbm 10.13 (December 2002).</p>

<p>The following options help pamflip use memory
efficiently. Some flip- ping operations on very large images
can cause pamflip to have a very large working set, which
means if you dont have enough real memory, the program can
page thrash, which means it takes a ridiculous amount time
to run. If your entire image fits in real memory, you dont
have a problem. If youre just flipping top for bottom or
left for right, you don t have a problem. Otherwise, pay
attention. If youre inter- ested in the details of the
thrashing problem and how pamflip approaches it, you re
invited to read a complete explanation in com- ments in the
source code.</p>

<p>-memsize=mebibytes mebibytes is the size in mebibytes
(aka megabytes) of memory available for pamflip. It is the
lesser of the amount of real or virtual memory
available.</p>

<p>pamflip does nothing special to allocate real memory or
control its allocation -- it gets whatever it gets just by
referencing virtual memory normally. The real memory figure
in question is the maximum amount that pamflip can be
expected to end up with by doing that. This is just about
impossible for you to know, of course, but you can estimate.
The total real memory in your system should be a major
factor in your estimate.</p>

<p>If pamflip cannot fit the entire image in the amount of
memory you specify, it does the transformation in chunks,
using tempo- rary files for intermediate results.</p>

<p>Strict horizontal transformations (either left for right
or null), pamflip never keeps more than one row in memory,
so the memory size is irrelevant and pamflip doesn t use
temporary files.</p>

<p>The real memory is important when you do a column for
row type of transformation (e.g. -rotate90). In that case,
even if pam- flip can fit the entire image in virtual memory
at once, if it does not also fit in real memory, the program
will thrash like crazy because of the order in which pamflip
accesses the pixels, and that means it will take a
ridiculously long time to run. A proper -memsize drastically
reduces the paging.</p>

<p>If you specify -memsize too large, pamflip may attempt
to get more virtual memory than the system allows it and
fail. If it can get the virtual memory, but -memsize is
larger than the amount of real memory the system allows it
and the transforma- tion is row for column, it will page
thrash and run very slowly. A value even slightly too high
is the same as infinity.</p>

<p>If you specify -memsize too small, the program will run
slightly more slowly due to extra overhead in manipulating
temporary files. Also, if your environment isnt set up to
make temporary files possible, pamflip will fail.</p>

<p>Doing the entire transformation in memory doesn t speed
things up as much as you might think, because even with the
temporary files, the data is just as likely to be in memory.
Virtual mem- ory gets paged to disk and disk files get
cached in memory. In fact, the pixels fit much more
compactly into memory when stored in a temporary file than
when stored in memory because pamflip uses a more efficient
format. So youre likely to have less disk I/O when you allow
pamflip less memory.</p>

<p>If you do not specify -memsize, pamflip assumes
infinity.</p>

<p>This option did not exist before Netpbm 10.7 (August
2002).</p>

<p>Before Netpbm 10.42 (March 2008), this option applied
only to real memory. pamflip would always keep the entire
image in vir- tual memory and if it could not get enough
virtual memory, it failed. pamflip accessed the pixels in an
order designed to keep real memory use within the specified
amount.</p>

<p>-pagesize=bytes bytes is the size in bytes of a paging
unit -- the amount of memory that gets paged in or out as an
indivisible unit -- in your system. The default is 4KiB.</p>

<p>This option has no effect.</p>

<p>Before Netpbm 10.42 (March 2008), pamflip used it to
control its use of real memory.</p>

<p>This option did not exist before Netpbm 10.7 (August
2002).</p>

<p>Miscellaneous options:</p>

<p>-verbose This option causes pamflip to issue messages to
Standard Error about its progress.</p>

<p>SEE ALSO pnmrotate(1), pnm(1), pam(1), jpegtran
manual</p>

<p>HISTORY pamflip replaced pnmflip in Netpbm 10.13
(December 2002). pamflip is backward compatible, but also
works on PAM images.</p>

<p>AUTHOR Copyright (C) 1989 by Jef Poskanzer.</p>

<p>netpbm documentation 20 January 2008 Pamflip User
Manual(0)</p>
<hr>
</body>
</html>
