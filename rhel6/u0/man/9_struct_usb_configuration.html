<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:09 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT USB_CONFIGURA(9) Kernel Mode Gadget API STRUCT
USB_CONFIGURA(9)</p>

<p>NAME struct_usb_configuration - represents one gadget
configuration</p>

<p>SYNOPSIS struct usb_configuration { const char * label;
struct usb_gadget_strings ** strings; const struct
usb_descriptor_header ** descriptors; int (* bind) (struct
usb_configuration *); void (* unbind) (struct
usb_configuration *); int (* setup) (struct
usb_configuration *,const struct usb_ctrlrequest *); u8
bConfigurationValue; u8 iConfiguration; u8 bmAttributes; u8
bMaxPower; struct usb_composite_dev * cdev; };</p>

<p>MEMBERS label For diagnostics, describes the
configuration.</p>

<p>strings Tables of strings, keyed by identifiers assigned
during bind() and by language IDs provided in control
requests.</p>

<p>descriptors Table of descriptors preceding all function
descriptors. Examples include OTG and vendor-specific
descriptors.</p>

<p>bind Called from usb_add_config() to allocate resources
unique to this configuration and to call usb_add_function()
for each function used.</p>

<p>unbind Reverses bind; called as a side effect of
unregistering the driver which added this configuration.</p>

<p>setup Used to delegate control requests that
aren&acute;t handled by standard device infrastructure or
directed at a specific interface.</p>

<p>bConfigurationValue Copied into configuration
descriptor.</p>

<p>iConfiguration Copied into configuration descriptor.</p>

<p>bmAttributes Copied into configuration descriptor.</p>

<p>bMaxPower Copied into configuration descriptor.</p>

<p>cdev assigned by usb_add_config() before calling bind();
this is the device associated with this configuration.</p>

<p>DESCRIPTION Configurations are building blocks for
gadget drivers structured around function drivers. Simple
USB gadgets require only one function and one configuration,
and handle dual-speed hardware by always providing the same
functionality. Slightly more complex gadgets may have more
than one single-function configuration at a given speed; or
have configurations that only work at one speed.</p>

<p>Composite devices are, by definition, ones with
configurations which include more than one function.</p>

<p>The lifecycle of a usb_configuration includes
allocation, initialization of the fields described above,
and calling usb_add_config() to set up internal data and
bind it to a specific device. The configuration&acute;s
bind() method is then used to initialize all the functions
and then call usb_add_function() for them.</p>

<p>Those functions would normally be independant of each
other, but that&acute;s not mandatory. CDC WMC devices are
an example where functions often depend on other functions,
with some functions subsidiary to others. Such
interdependency may be managed in any way, so long as all of
the descriptors complete by the time the composite driver
returns from its bind routine.</p>

<p>AUTHOR David Brownell
&lt;dbrownell@users.sourceforge.net&gt; Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
STRUCT USB_CONFIGURA(9)</p>
<hr>
</body>
</html>
