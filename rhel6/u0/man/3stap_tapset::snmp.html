<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TAPSET::SNMP(3stap) TAPSET::SNMP(3stap)</p>

<p>NAME tapset::snmp - Systemtap simple network management
protocol probe points.</p>

<p>DESCRIPTION This family of probe points enhances the
Linux systems implementation of the Simple Network
Management Protocol (SNMP) by allowing the user to collect
per-socket statistics. SNMP data is collected in the Linux
kernel by counting various events occurring in the
networking subsys- tem. Linux provides one counter for each
type of event, thus providing a system-wide collection of
network statistics. These statistics can be viewed with the
command: netstat -s.</p>

<p>The probe points defined in the SNMP group of tapsets
allow users to aberrate each SNMP counter into groups of
counters. For example, the user may count SNMP events for a
single network socket or for a group of sockets.</p>

<p>Severals SNMP tapsets have been created. Each tapset
represents a sin- gle layer of the network stack and defines
a group of counters called management information blocks or
MIBs. Currently tapsets are provided that support MIBS for
IP, TCP layers and the enhanced linux MIB. See the file
/usr/include/linux/snmp.h for a list of MIBS supported by
linux.</p>

<p>PROBE HANDLERS, COUNTERS AND CALLBACKS Each probe
represents a single SNMP statistic. The probes handler is
called each time the system performs an operation that would
alter the associated statistic. Each probe also defines an
indexed set of coun- ters used to record probe hits. The
probe handler calls a user supplied callback functions to
determine which counter to alter. The users callback should
return a key value that will be used to index the counter.
For example a callback could return a unique value for each
socket. This would results in a separate counter being used
for each socket.</p>

<p>Each tapset is now described. Examples of probe names
and counter names are given. See the tapset itself for a
complete list of supported probes. Users of the tapset must
provide a callback function matching the name and prototype
as shown.</p>

<p>IP MIB Tapset:</p>

<p>Example probe name: ipmib.InReceives</p>

<p>Example counter name: InReceives</p>

<p>Callback prototype:</p>

<p>ipmib_filter_key:long (skb:long, op:long,
SourceIsLocal:long)</p>

<p>This user supplied function should compute and return a
value used to index the statistical counter. The skb is a
pointer to the struct sk_buff being processed at the time.
The local ip-address and port num- ber will be located in
either the source or destination fields of the network
packet. SourceIsLocal will be true if the local address is
in the source field. The probe handler will add the value of
op to the counter. To skip counting the event return a value
of zero.</p>

<p>TCP MIB tapset:</p>

<p>Example probe name: tcpmib.InSegs</p>

<p>Example counter name: InSegs</p>

<p>Callback prototype:</p>

<p>tcpmib_filter_key:long (sk:long, op:long)</p>

<p>This user supplied function should compute and return a
value used to index the statistical counter. The sk is a
pointer to the struct sock being processed at the time. The
probe handler will add the value of op to the counter. To
skip counting the event return a value of zero.</p>

<p>LINUX MIB tapset:</p>

<p>linuxmib.stp</p>

<p>Example probe name: linuxmib.DelayedACKs</p>

<p>Example counter name: DelayedACKs</p>

<p>Callback prototype:</p>

<p>linuxmib_filter_key:long (sk:long, op:long)</p>

<p>This user supplied function should compute and return a
value used to index the statistical counter. The sk is a
pointer to the struct sock being processed at the time. The
probe handler will add the value of op to the counter. To
skip counting the event return a value of zero.</p>

<p>EXAMPLE This example script counts the number of TCP
retransmits and records them per-remote address. It displays
the counts when terminated.</p>

<p>/* Enable the statistic we want to record. */ probe
tcpmib.RetransSegs {}</p>

<p>/* * Find the remote address and return * it as an index
to the counter array. */ function tcpmib_filter_key: long (
sk:long, op:long ){ if ( !sk ) return 0; raddr =
sk_get_daddr(sk); return raddr }</p>

<p>/* Print the results. */ probe end { foreach (addr in
RetransSegs ) printf (&quot;%s %d
&quot;,ip_ntop(htonl(addr)), lport) }</p>

<p>FILES
/usr/share/doc/systemtap*/examples/tcpipstat.stp</p>

<p>SEE ALSO stap(1), stapprobes(3stap),
stapfuncs(3stap)</p>

<p>IBM TAPSET::SNMP(3stap)</p>
<hr>
</body>
</html>
