<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:03 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT JOURNAL_S(9) The Linux Journalling API STRUCT
JOURNAL_S(9)</p>

<p>NAME struct_journal_s - this is the concrete type
associated with journal_t.</p>

<p>SYNOPSIS struct journal_s { unsigned long j_flags; int
j_errno; struct buffer_head * j_sb_buffer;
journal_superblock_t * j_superblock; int j_format_version;
spinlock_t j_state_lock; int j_barrier_count; struct mutex
j_barrier; transaction_t * j_running_transaction;
transaction_t * j_committing_transaction; transaction_t *
j_checkpoint_transactions; wait_queue_head_t
j_wait_transaction_locked; wait_queue_head_t
j_wait_logspace; wait_queue_head_t j_wait_done_commit;
wait_queue_head_t j_wait_checkpoint; wait_queue_head_t
j_wait_commit; wait_queue_head_t j_wait_updates; struct
mutex j_checkpoint_mutex; unsigned int j_head; unsigned int
j_tail; unsigned int j_free; unsigned int j_first; unsigned
int j_last; struct block_device * j_dev; int j_blocksize;
unsigned int j_blk_offset; struct block_device * j_fs_dev;
unsigned int j_maxlen; spinlock_t j_list_lock; struct inode
* j_inode; tid_t j_tail_sequence; tid_t
j_transaction_sequence; tid_t j_commit_sequence; tid_t
j_commit_request; __u8 j_uuid[16]; struct task_struct *
j_task; int j_max_transaction_buffers; unsigned long
j_commit_interval; struct timer_list j_commit_timer;
spinlock_t j_revoke_lock; struct jbd_revoke_table_s *
j_revoke; struct jbd_revoke_table_s * j_revoke_table[2];
struct buffer_head ** j_wbuf; int j_wbufsize; pid_t
j_last_sync_writer; u64 j_average_commit_time; void *
j_private; };</p>

<p>MEMBERS j_flags General journaling state flags</p>

<p>j_errno Is there an outstanding uncleared error on the
journal (from a prior abort)?</p>

<p>j_sb_buffer First part of superblock buffer</p>

<p>j_superblock Second part of superblock buffer</p>

<p>j_format_version Version of the superblock format</p>

<p>j_state_lock Protect the various scalars in the
journal</p>

<p>j_barrier_count Number of processes waiting to create a
barrier lock</p>

<p>j_barrier The barrier lock itself</p>

<p>j_running_transaction The current running
transaction..</p>

<p>j_committing_transaction the transaction we are pushing
to disk</p>

<p>j_checkpoint_transactions a linked circular list of all
transactions waiting for checkpointing</p>

<p>j_wait_transaction_locked Wait queue for waiting for a
locked transaction to start committing, or for a barrier
lock to be released</p>

<p>j_wait_logspace Wait queue for waiting for checkpointing
to complete</p>

<p>j_wait_done_commit Wait queue for waiting for commit to
complete</p>

<p>j_wait_checkpoint Wait queue to trigger
checkpointing</p>

<p>j_wait_commit Wait queue to trigger commit</p>

<p>j_wait_updates Wait queue to wait for updates to
complete</p>

<p>j_checkpoint_mutex Mutex for locking against concurrent
checkpoints</p>

<p>j_head Journal head - identifies the first unused block
in the journal</p>

<p>j_tail Journal tail - identifies the oldest still-used
block in the journal.</p>

<p>j_free Journal free - how many free blocks are there in
the journal?</p>

<p>j_first The block number of the first usable block</p>

<p>j_last The block number one beyond the last usable
block</p>

<p>j_dev Device where we store the journal</p>

<p>j_blocksize blocksize for the location where we store
the journal.</p>

<p>j_blk_offset starting block offset for into the device
where we store the journal</p>

<p>j_fs_dev Device which holds the client fs. For internal
journal this will be equal to j_dev</p>

<p>j_maxlen Total maximum capacity of the journal region on
disk.</p>

<p>j_list_lock Protects the buffer lists and internal
buffer state.</p>

<p>j_inode Optional inode where we store the journal. If
present, all journal block numbers are mapped into this
inode via bmap.</p>

<p>j_tail_sequence Sequence number of the oldest
transaction in the log</p>

<p>j_transaction_sequence Sequence number of the next
transaction to grant</p>

<p>j_commit_sequence Sequence number of the most recently
committed transaction</p>

<p>j_commit_request Sequence number of the most recent
transaction wanting commit</p>

<p>j_uuid[16] Uuid of client object.</p>

<p>j_task Pointer to the current commit thread for this
journal</p>

<p>j_max_transaction_buffers Maximum number of metadata
buffers to allow in a single compound commit transaction</p>

<p>j_commit_interval What is the maximum transaction
lifetime before we begin a commit?</p>

<p>j_commit_timer The timer used to wakeup the commit
thread</p>

<p>j_revoke_lock Protect the revoke table</p>

<p>j_revoke The revoke table - maintains the list of
revoked blocks in the current transaction.</p>

<p>j_revoke_table[2] alternate revoke tables for
j_revoke</p>

<p>j_wbuf array of buffer_heads for
journal_commit_transaction</p>

<p>j_wbufsize maximum number of buffer_heads allowed in
j_wbuf, the number that will fit in j_blocksize</p>

<p>j_last_sync_writer most recent pid which did a
synchronous write</p>

<p>j_average_commit_time the average amount of time in
nanoseconds it takes to commit a transaction to the
disk.</p>

<p>j_private An opaque pointer to fs-private
information.</p>

<p>AUTHORS Roger Gammans
&lt;rgammans@computer-surgery.co.uk&gt; Author.</p>

<p>Stephen Tweedie &lt;sct@redhat.com&gt; Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
STRUCT JOURNAL_S(9)</p>
<hr>
</body>
</html>
