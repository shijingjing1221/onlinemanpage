<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:05:39 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>A64L(3) Linux Programmer s Manual A64L(3)</p>

<p>NAME a64l, l64a - convert between long and base-64</p>

<p>SYNOPSIS #include &lt;stdlib.h&gt;</p>

<p>long a64l(char *str64);</p>

<p>char *l64a(long value);</p>

<p>Feature Test Macro Requirements for glibc (see
feature_test_macros(7)):</p>

<p>a64l(), l64a(): _SVID_SOURCE || _XOPEN_SOURCE &gt;=
500</p>

<p>DESCRIPTION These functions provide a conversion between
32-bit long integers and little-endian base-64 ASCII strings
(of length zero to six). If the string used as argument for
a64l() has length greater than six, only the first six bytes
are used. If the type long has more than 32 bits, then
l64a() uses only the low order 32 bits of value, and a64l()
sign- extends its 32-bit result.</p>

<p>The 64 digits in the base-64 system are:</p>

<p>&rsquo;.&rsquo; represents a 0 &rsquo;/&rsquo;
represents a 1 0-9 represent 2-11 A-Z represent 12-37 a-z
represent 38-63</p>

<p>So 123 = 59*64^0 + 1*64^1 = &quot;v/&quot;.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES The value returned by a64l() may be a pointer to a
static buffer, pos- sibly overwritten by later calls.</p>

<p>The behavior of l64a() is undefined when value is
negative. If value is zero, it returns an empty string.</p>

<p>These functions are broken in glibc before 2.2.5 (puts
most significant digit first).</p>

<p>This is not the encoding used by uuencode(1).</p>

<p>SEE ALSO uuencode(1), strtoul(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>2007-07-26 A64L(3)</p>
<hr>
</body>
</html>
