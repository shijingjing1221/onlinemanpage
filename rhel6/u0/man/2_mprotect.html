<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:07:33 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MPROTECT(2) Linux Programmer s Manual MPROTECT(2)</p>

<p>NAME mprotect - set protection on a region of memory</p>

<p>SYNOPSIS #include &lt;sys/mman.h&gt;</p>

<p>int mprotect(const void *addr, size_t len, int
prot);</p>

<p>DESCRIPTION mprotect() changes protection for the
calling process s memory page(s) containing any part of the
address range in the interval [addr, addr+len-1]. addr must
be aligned to a page boundary.</p>

<p>If the calling process tries to access memory in a
manner that violates the protection, then the kernel
generates a SIGSEGV signal for the pro- cess.</p>

<p>prot is either PROT_NONE or a bitwise-or of the other
values in the following list:</p>

<p>PROT_NONE The memory cannot be accessed at all.</p>

<p>PROT_READ The memory can be read.</p>

<p>PROT_WRITE The memory can be modified.</p>

<p>PROT_EXEC The memory can be executed.</p>

<p>RETURN VALUE On success, mprotect() returns zero. On
error, -1 is returned, and errno is set appropriately.</p>

<p>ERRORS EACCES The memory cannot be given the specified
access. This can hap- pen, for example, if you mmap(2) a
file to which you have read- only access, then ask
mprotect() to mark it PROT_WRITE.</p>

<p>EINVAL addr is not a valid pointer, or not a multiple of
the system page size.</p>

<p>ENOMEM Internal kernel structures could not be
allocated.</p>

<p>ENOMEM Addresses in the range [addr, addr+len] are
invalid for the address space of the process, or specify one
or more pages that are not mapped. (Before kernel 2.4.19,
the error EFAULT was incorrectly produced for these
cases.)</p>

<p>CONFORMING TO SVr4, POSIX.1-2001. POSIX says that the
behavior of mprotect() is unspecified if it is applied to a
region of memory that was not obtained via mmap(2).</p>

<p>NOTES On Linux it is always permissible to call
mprotect() on any address in a processs address space
(except for the kernel vsyscall area). In particular it can
be used to change existing code mappings to be writable.</p>

<p>Whether PROT_EXEC has any effect different from
PROT_READ is architec- ture- and kernel version-dependent.
On some hardware architectures (e.g., i386), PROT_WRITE
implies PROT_READ.</p>

<p>POSIX.1-2001 says that an implementation may permit
access other than that specified in prot, but at a minimum
can only allow write access if PROT_WRITE has been set, and
must not allow any access if PROT_NONE has been set.</p>

<p>EXAMPLE The program below allocates four pages of
memory, makes the third of these pages read-only, and then
executes a loop that walks upwards through the allocated
region modifying bytes.</p>

<p>An example of what we might see when running the program
is the follow- ing:</p>

<p>$ ./a.out Start of region: 0x804c000 Got SIGSEGV at
address: 0x804e000</p>

<p>Program source</p>

<p>#include &lt;unistd.h&gt; #include &lt;signal.h&gt;
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include
&lt;stdlib.h&gt; #include &lt;errno.h&gt; #include
&lt;sys/mman.h&gt;</p>

<p>#define handle_error(msg) do { perror(msg);
exit(EXIT_FAILURE); } while (0)</p>

<p>char *buffer;</p>

<p>static void handler(int sig, siginfo_t *si, void
*unused) { printf(&quot;Got SIGSEGV at address: 0x%lx0,
(long) si-&gt;si_addr); exit(EXIT_FAILURE); }</p>

<p>int main(int argc, char *argv[]) { char *p; int
pagesize; struct sigaction sa;</p>

<p>sa.sa_flags = SA_SIGINFO; sigemptyset(&amp;sa.sa_mask);
sa.sa_sigaction = handler; if (sigaction(SIGSEGV, &amp;sa,
NULL) == -1) handle_error(&quot;sigaction&quot;);</p>

<p>pagesize = sysconf(_SC_PAGE_SIZE); if (pagesize == -1)
handle_error(&quot;sysconf&quot;);</p>

<p>/* Allocate a buffer aligned on a page boundary; initial
protection is PROT_READ | PROT_WRITE */</p>

<p>buffer = memalign(pagesize, 4 * pagesize); if (buffer ==
NULL) handle_error(&quot;memalign&quot;);</p>

<p>printf(&quot;Start of region: 0x%lx0, (long)
buffer);</p>

<p>if (mprotect(buffer + pagesize * 2, pagesize, PROT_NONE)
== -1) handle_error(&quot;mprotect&quot;);</p>

<p>for (p = buffer ; ; ) *(p++) = &rsquo;a&rsquo;;</p>

<p>printf(&quot;Loop completed0); /* Should never happen */
exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO mmap(2), sysconf(3)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-08-06 MPROTECT(2)</p>
<hr>
</body>
</html>
