<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:05:12 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>jarsigner(1) jarsigner(1)</p>

<p>NAME jarsigner - JAR Signing and Verification Tool</p>

<p>Generates signatures for Java ARchive (JAR) files, and
verifies the signatures of signed JAR files.</p>

<p>SYNOPSIS jarsigner [ options ] jar-file alias jarsigner
-verify [ options ] jar-file</p>

<p>DESCRIPTION The jarsigner tool is used for two
purposes:</p>

<p>1. to sign Java ARchive (JAR) files, and</p>

<p>2. to verify the signatures and integrity of signed JAR
files.</p>

<p>The JAR feature enables the packaging of class files,
images, sounds, and other digital data in a single file for
faster and easier distribu- tion. A tool named jar enables
developers to produce JAR files. (Tech- nically, any zip
file can also be considered a JAR file, although when
created by jar or processed by jarsigner, JAR files also
contain a META-INF/MANIFEST.MF file.)</p>

<p>A digital signature is a string of bits that is computed
from some data (the data being &quot;signed&quot;) and the
private key of an entity (a person, company, etc.). Like a
handwritten signature, a digital signature has many useful
characteristics:</p>

<p>o Its authenticity can be verified, via a computation
that uses the public key corresponding to the private key
used to generate the signature.</p>

<p>o It cannot be forged, assuming the private key is kept
secret.</p>

<p>o It is a function of the data signed and thus cant be
claimed to be the signature for other data as well.</p>

<p>o The signed data cannot be changed; if it is, the
signature will no longer verify as being authentic.</p>

<p>In order for an entitys signature to be generated for a
file, the entity must first have a public/private key pair
associated with it, and also one or more certificates
authenticating its public key. A cer- tificate is a
digitally signed statement from one entity, saying that the
public key of some other entity has a particular value.</p>

<p>jarsigner uses key and certificate information from a
keystore to generate digital signatures for JAR files. A
keystore is a database of private keys and their associated
X.509 certificate chains authenticat- ing the corresponding
public keys. The keytool utility is used to cre- ate and
administer keystores.</p>

<p>jarsigner uses an entitys private key to generate a
signature. The signed JAR file contains, among other things,
a copy of the certificate from the keystore for the public
key corresponding to the private key used to sign the file.
jarsigner can verify the digital signature of the signed JAR
file using the certificate inside it (in its signature block
file).</p>

<p>Starting in J2SE 5.0, jarsigner can generate signatures
that include a timestamp, thus enabling systems/deployer
(including Java Plug-in) to check whether the JAR file was
signed while the signing certificate was still valid. In
addition, APIs were added in J2SE 5.0 to allow applica-
tions to obtain the timestamp information.</p>

<p>At this time, jarsigner can only sign JAR files created
by the SDK jar tool or zip files. (JAR files are the same as
zip files, except they also have a META-INF/MANIFEST.MF
file. Such a file will automatically be created when
jarsigner signs a zip file.)</p>

<p>The default jarsigner behavior is to sign a JAR (or zip)
file. Use the -verify option to instead have it verify a
signed JAR file.</p>

<p>Compatibility with JDK 1.1 The keytool and jarsigner
tools completely replace the javakey tool provided in JDK
1.1. These new tools provide more features than javakey,
including the ability to protect the keystore and private
keys with passwords, and the ability to verify signatures in
addi- tion to generating them.</p>

<p>The new keystore architecture replaces the identity
database that javakey created and managed. There is no
backwards compatibility between the keystore format and the
database format used by javakey in 1.1. However,</p>

<p>o It is possible to import the information from an
identity database into a keystore, via the keytool
-identitydb command.</p>

<p>o jarsigner can sign JAR files also previously signed
using javakey.</p>

<p>o jarsigner can verify JAR files signed using javakey.
Thus, it recognizes and can work with signer aliases that
are from a JDK 1.1 identity database rather than a Java 2
SDK keystore.</p>

<p>The following table explains how JAR files that were
signed in JDK 1.1.x are treated in the Java 2 platform.</p>

<p>Notes:</p>

<p>1. If an identity/alias is mentioned in the policy file,
it must be imported into the keystore for the policy file to
have any effect on privileges granted.</p>

<p>2. The policy file/keystore combination has precedence
over a trusted identity in the identity database.</p>

<p>3. Untrusted identities are ignored in the Java 2
platform.</p>

<p>4. Only trusted identities can be imported into Java 2
SDK key- stores.</p>

<p>Keystore Aliases All keystore entities are accessed via
unique aliases.</p>

<p>When using jarsigner to sign a JAR file, you must
specify the alias for the keystore entry containing the
private key needed to generate the signature. For example,
the following will sign the JAR file named
&quot;MyJARFile.jar&quot;, using the private key associated
with the alias &quot;duke&quot; in the keystore named
&quot;mystore&quot; in the &quot;working&quot; direc- tory.
Since no output file is specified, it overwrites
MyJARFile.jar with the signed JAR file.</p>

<p>jarsigner -keystore /working/mystore -storepass myspass
-keypass dukekeypasswd MyJARFile.jar duke</p>

<p>Keystores are protected with a password, so the store
password (in this case &quot;myspass&quot;) must be
specified. You will be prompted for it if you dont specify
it on the command line. Similarly, private keys are
protected in a keystore with a password, so the private keys
password (in this case &quot;dukekeypasswd&quot;) must be
specified, and you will be prompted for it if you dont
specify it on the command line and it isnt the same as the
store password.</p>

<p>Keystore Location jarsigner has a -keystore option for
specifying the URL of the key- store to be used. The
keystore is by default stored in a file named .keystore in
the user s home directory, as determined by the user.home
system property. On Solaris systems user.home defaults to
the users home directory.</p>

<p>Note that the input stream from the -keystore option is
passed to the KeyStore.load method. If NONE is specified as
the URL, then a null stream is passed to the KeyStore.load
method. NONE should be specified if the KeyStore is not
file-based, for example, if it resides on a hardware token
device.</p>

<p>Keystore Implementation The KeyStore class provided in
the java.security package supplies well-defined interfaces
to access and modify the information in a keystore. It is
possible for there to be multiple different concrete
implementations, where each implementation is that for a
particular type of keystore.</p>

<p>Currently, there are two command-line tools that make
use of key- store implementations (keytool and jarsigner),
and also a GUI-based tool named Policy Tool. Since KeyStore
is publicly available, Java 2 SDK users can write additional
security applications that use it.</p>

<p>There is a built-in default implementation, provided by
Sun Microsystems. It implements the keystore as a file,
utilizing a pro- prietary keystore type (format) named
&quot;JKS&quot;. It protects each pri- vate key with its
individual password, and also protects the integrity of the
entire keystore with a (possibly different) pass- word.</p>

<p>Keystore implementations are provider-based. More
specifically, the application interfaces supplied by
KeyStore are implemented in terms of a &quot;Service
Provider Interface&quot; (SPI). That is, there is a corre-
sponding abstract KeystoreSpi class, also in the
java.security pack- age, which defines the Service Provider
Interface methods that &quot;providers&quot; must implement.
(The term &quot;provider&quot; refers to a package or a set
of packages that supply a concrete implementation of a sub-
set of services that can be accessed by the Java Security
API.) Thus, to provide a keystore implementation, clients
must implement a provider and supply a KeystoreSpi subclass
implementation, as described in How to Implement a Provider
for the Java Cryptography Architecture @
http://java.sun.com/javase/6/docs/technotes/guides/security/HowToIm-
plAProvider.html.</p>

<p>Applications can choose different types of keystore
implementations from different providers, using the
&quot;getInstance&quot; factory method supplied in the
KeyStore class. A keystore type defines the storage and data
format of the keystore information, and the algorithms used
to protect private keys in the keystore and the integrity of
the keystore itself. Keystore implementations of different
types are not compatible.</p>

<p>keytool works on any file-based keystore implementation.
(It treats the keytore location that is passed to it at the
command line as a filename and converts it to a
FileInputStream, from which it loads the keystore
information.) The jarsigner and policytool tools, on the
other hand, can read a keystore from any location that can
be specified using a URL.</p>

<p>For jarsigner and keytool, you can specify a keystore
type at the command line, via the -storetype option. For
Policy Tool, you can specify a keystore type via the
&quot;Change Keystore&quot; command in the Edit menu.</p>

<p>If you dont explicitly specify a keystore type, the
tools choose a keystore implementation based simply on the
value of the key- store.type property specified in the
security properties file. The security properties file is
called java.security, and it resides in the SDK security
properties directory, java.home/lib/security, where
java.home is the runtime environments directory (the jre
directory in the SDK or the top-level directory of the Java
2 Runtime Environ- ment).</p>

<p>Each tool gets the keystore.type value and then examines
all the currently-installed providers until it finds one
that implements keystores of that type. It then uses the
keystore implementation from that provider.</p>

<p>The KeyStore class defines a static method named
getDefaultType that lets applications and applets retrieve
the value of the key- store.type property. The following
line of code creates an instance of the default keystore
type (as specified in the keystore.type property):</p>

<p>KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p>The default keystore type is &quot;jks&quot; (the
proprietary type of the key- store implementation provided
by Sun). This is specified by the fol- lowing line in the
security properties file:</p>

<p>keystore.type=jks</p>

<p>Note: Case doesnt matter in keystore type designations.
For exam- ple, &quot;JKS&quot; would be considered the same
as &quot;jks&quot;.</p>

<p>To have the tools utilize a keystore implementation
other than the default, change that line to specify a
different keystore type. For example, if you have a provider
package that supplies a keystore implementation for a
keystore type called &quot;pkcs12&quot;, change the line
to</p>

<p>keystore.type=pkcs12</p>

<p>Note that if you us the PKCS#11 provider package, you
should refer to the KeyTool and JarSigner @
http://java.sun.com/javase/6/docs/technotes/guides/secu-
rity/p11guide.html#keytooljarsigner section of the Java
PKCS#11 Ref- erence Guide for details.</p>

<p>Supported Algorithms By default, jarsigner signs a JAR
file using either</p>

<p>o DSA (Digital Signature Algorithm) with the SHA-1
digest algo- rithm, or</p>

<p>o the RSA algorithm with the MD5 digest algorithm.</p>

<p>That is, if the signers public and private keys are DSA
keys, jar- signer will sign the JAR file using the
&quot;SHA1withDSA&quot; algorithm. If the signers keys are
RSA keys, jarsigner will attempt to sign the JAR file using
the &quot;MD5withRSA&quot; algorithm.</p>

<p>These default signature algorithms can be overridden
using the -sigalg option.</p>

<p>The Signed JAR File When jarsigner is used to sign a JAR
file, the output signed JAR file is exactly the same as the
input JAR file, except that it has two additional files
placed in the META-INF directory:</p>

<p>o a signature file, with a .SF extension, and</p>

<p>o a signature block file, with a .DSA extension.</p>

<p>The base file names for these two files come from the
value of the -sigFile option. For example, if the option
appears as</p>

<p>-sigFile MKSIGN</p>

<p>the files are named &quot;MKSIGN.SF&quot; and
&quot;MKSIGN.DSA&quot;.</p>

<p>If no -sigfile option appears on the command line, the
base file name for the .SF and .DSA files will be the first
8 characters of the alias name specified on the command
line, all converted to upper case. If the alias name has
fewer than 8 characters, the full alias name is used. If the
alias name contains any characters that are not allowed in a
signature file name, each such character is converted to an
underscore (&quot;_&quot;) character in forming the file
name. Legal characters include letters, digits, underscores,
and hyphens.</p>

<p>The Signature (.SF) File</p>

<p>A signature file (the .SF file) looks similar to the
manifest file that is always included in a JAR file when
jarsigner is used to sign the file. That is, for each source
file included in the JAR file, the .SF file has three lines,
just as in the manifest file, listing the following:</p>

<p>o the file name,</p>

<p>o the name of the digest algorithm used (SHA), and</p>

<p>o a SHA digest value.</p>

<p>In the manifest file, the SHA digest value for each
source file is the digest (hash) of the binary data in the
source file. In the .SF file, on the other hand, the digest
value for a given source file is the hash of the three lines
in the manifest file for the source file.</p>

<p>The signature file also, by default, includes a header
containing a hash of the whole manifest file. The presence
of the header enables verification optimization, as
described in JAR File Veri- fication.</p>

<p>The Signature Block (.DSA) File</p>

<p>The .SF file is signed and the signature is placed in
the .DSA file. The .DSA file also contains, encoded inside
it, the cer- tificate or certificate chain from the keystore
which authenti- cates the public key corresponding to the
private key used for signing.</p>

<p>Signature Timestamp As of the J2SE 5.0 release, the
jarsigner tool can now generate and store a signature
timestamp when signing a JAR file. In addition, jarsigner
supports alternative signing mechanisms. This behavior is
optional and is controlled by the user at the time of
signing through these options:</p>

<p>o -tsa url</p>

<p>o -tsacert alias</p>

<p>o -altsigner class</p>

<p>o -altsignerpath classpathlist</p>

<p>Each of these options is detailed in the Options section
below.</p>

<p>JAR File Verification A successful JAR file verification
occurs if the signature(s) are valid, and none of the files
that were in the JAR file when the sig- natures were
generated have been changed since then. JAR file veri-
fication involves the following steps:</p>

<p>1. Verify the signature of the .SF file itself.</p>

<p>That is, the verification ensures that the signature
stored in each signature block (.DSA) file was in fact
generated using the private key corresponding to the public
key whose certificate (or certificate chain) also appears in
the .DSA file. It also ensures that the signature is a valid
signature of the corresponding sig- nature (.SF) file, and
thus the .SF file has not been tampered with.</p>

<p>2. Verify the digest listed in each entry in the .SF
file with each corresponding section in the manifest.</p>

<p>The .SF file by default includes a header containing a
hash of the entire manifest file. When the header is
present, then the verification can check to see whether or
not the hash in the header indeed matches the hash of the
manifest file. If that is the case, verification proceeds to
the next step.</p>

<p>If that is not the case, a less optimized verification
is required to ensure that the hash in each source file
information section in the .SF file equals the hash of its
corresponding sec- tion in the manifest file (see The
Signature (.SF) File).</p>

<p>One reason the hash of the manifest file that is stored
in the .SF file header may not equal the hash of the current
manifest file would be because one or more files were added
to the JAR file (using the jar tool) after the signature
(and thus the .SF file) was generated. When the jar tool is
used to add files, the manifest file is changed (sections
are added to it for the new files), but the .SF file is not.
A verification is still consid- ered successful if none of
the files that were in the JAR file when the signature was
generated have been changed since then, which is the case if
the hashes in the non-header sections of the .SF file equal
the hashes of the corresponding sections in the manifest
file.</p>

<p>3. Read each file in the JAR file that has an entry in
the .SF file. While reading, compute the file s digest, and
then com- pare the result with the digest for this file in
the manifest section. The digests should be the same, or
verification fails.</p>

<p>If any serious verification failures occur during the
verification process, the process is stopped and a security
exception is thrown. It is caught and displayed by
jarsigner.</p>

<p>Multiple Signatures for a JAR File A JAR file can be
signed by multiple people simply by running the jarsigner
tool on the file multiple times, specifying the alias for a
different person each time, as in:</p>

<p>jarsigner myBundle.jar susan jarsigner myBundle.jar
kevin</p>

<p>When a JAR file is signed multiple times, there are
multiple .SF and .DSA files in the resulting JAR file, one
pair for each signature. Thus, in the example above, the
output JAR file includes files with the following names:</p>

<p>SUSAN.SF SUSAN.DSA KEVIN.SF KEVIN.DSA</p>

<p>Note: It is also possible for a JAR file to have mixed
signatures, some generated by the JDK 1.1 javakey tool and
others by jarsigner. That is, jarsigner can be used to sign
JAR files already previously signed using javakey.</p>

<p>OPTIONS The various jarsigner options are listed and
described below. Note:</p>

<p>o All option names are preceded by a minus sign (-).</p>

<p>o The options may be provided in any order.</p>

<p>o Items in italics (option values) represent the actual
values that must be supplied.</p>

<p>o The -keystore, -storepass, -keypass, -sigfile,
-sigalg, -digestalg, and -signedjar options are only
relevant when signing a JAR file, not when verifying a
signed JAR file. Similarly, an alias is only specified on
the command line when signing a JAR file.</p>

<p>-keystore url Specifies the URL that tells the keystore
location. This defaults to the file .keystore in the users
home directory, as determined by the &quot;user.home&quot;
system property.</p>

<p>A keystore is required when signing, so you must
explicitly specify one if the default keystore does not
exist (or you want to use one other than the default).</p>

<p>A keystore is not required when verifying, but if one is
specified, or the default exists, and the -verbose option
was also specified, additional information is output
regarding whether or not any of the certificates used to
verify the JAR file are contained in that key- store.</p>

<p>Note: the -keystore argument can actually be a file name
(and path) specification rather than a URL, in which case it
will be treated the same as a &quot;file:&quot; URL. That
is,</p>

<p>-keystore filePathAndName</p>

<p>is treated as equivalent to</p>

<p>-keystore file:filePathAndName</p>

<p>If the Sun PKCS#11 provider has been configured in the
java.security security properties file (located in the JRE s
$JAVA_HOME/lib/secu- rity directory), then keytool and
jarsigner can operate on the PKCS#11 token by specifying
these options:</p>

<p>o -keystore NONE</p>

<p>o -storetype PKCS11 For example, this command lists the
contents of the configured PKCS#11 token:</p>

<p>jarsigner -keystore NONE -storetype PKCS11 -list</p>

<p>-storetype storetype Specifies the type of keystore to
be instantiated. The default keystore type is the one that
is specified as the value of the &quot;keystore.type&quot;
property in the security properties file, which is returned
by the static getDefaultType method in java.secu-
rity.KeyStore.</p>

<p>The PIN for a PCKS#11 token can also be specified using
the -storepass option. If none has been specified, keytool
and jarsigner will prompt for the token PIN. If the token
has a protected authen- tication path (such as a dedicated
PIN-pad or a biometric reader), then the -protected option
must be specified and no password options can be
specified.</p>

<p>-storepass password Specifies the password which is
required to access the keystore. This is only needed when
signing (not verifying) a JAR file. In that case, if a
-storepass option is not provided at the command line, the
user is prompted for the password.</p>

<p>Note: The password shouldnt be specified on the command
line or in a script unless it is for testing purposes, or
you are on a secure system. Also, when typing in a password
at the password prompt, the password is echoed (displayed
exactly as typed), so be careful not to type it in front of
anyone.</p>

<p>-keypass password Specifies the password used to protect
the private key of the keystore entry addressed by the alias
specified on the command line. The password is required when
using jarsigner to sign a JAR file. If no password is
provided on the command line, and the required password is
different from the store password, the user is prompted for
it.</p>

<p>Note: The password shouldnt be specified on the command
line or in a script unless it is for testing purposes, or
you are on a secure system. Also, when typing in a password
at the password prompt, the password is echoed (displayed
exactly as typed), so be careful not to type it in front of
anyone.</p>

<p>-sigfile file Specifies the base file name to be used
for the generated .SF and .DSA files. For example, if file
is &quot;DUKESIGN&quot;, the generated .SF and .DSA files
will be named &quot;DUKESIGN.SF&quot; and
&quot;DUKESIGN.DSA&quot;, and will be placed in the
&quot;META-INF&quot; directory of the signed JAR file.</p>

<p>The characters in file must come from the set
&quot;a-zA-Z0-9_-&quot;. That is, only letters, numbers,
underscore, and hyphen characters are allowed. Note: All
lowercase characters will be converted to upper- case for
the .SF and .DSA file names.</p>

<p>If no -sigfile option appears on the command line, the
base file name for the .SF and .DSA files will be the first
8 characters of the alias name specified on the command
line, all converted to upper case. If the alias name has
fewer than 8 characters, the full alias name is used. If the
alias name contains any characters that are not legal in a
signature file name, each such character is converted to an
underscore (&quot;_&quot;) character in forming the file
name.</p>

<p>-sigalg algorithm</p>

<p>Specifies the name of the signature algorithm to use to
sign the JAR file.</p>

<p>See Appendix A @
http://java.sun.com/javase/6/docs/technotes/guides/secu-
rity/crypto/CryptoSpec.html#appa of the Java Cryptography
Archi- tecture for a list of standard signature algorithm
names. This algorithm must be compatible with the private
key used to sign the JAR file. If this option is not
specified, SHA1withDSA or MD5withRSA will be used depending
on the type of private key. There must either be a
statically installed provider supplying an implementation of
the specified algorithm or the user must spec- ify one with
the -providerClass option, otherwise the command will not
succeed.</p>

<p>-digestalg algorithm Specifies the name of the message
digest algorithm to use when digesting the entries of a jar
file.</p>

<p>See Appendix A @
http://java.sun.com/javase/6/docs/technotes/guides/secu-
rity/crypto/CryptoSpec.html#appa of the Java Cryptography
Archi- tecture for a list of standard message digest
algorithm names. If this option is not specified, SHA-1 will
be used. There must either be a statically installed
provider supplying an implemen- tation of the specified
algorithm or the user must specify one with the
-providerClass option, otherwise the command will not
succeed.</p>

<p>-signedjar file Specifies the name to be used for the
signed JAR file.</p>

<p>If no name is specified on the command line, the name
used is the same as the input JAR file name (the name of the
JAR file to be signed); in other words, that file is
overwritten with the signed JAR file.</p>

<p>-verify If this appears on the command line, the
specified JAR file will be verified, not signed. If the
verification is successful, &quot;jar verified&quot; will be
displayed. If you try to verify an unsigned JAR file, or a
JAR file signed with an unsupported algorithm (e.g., RSA
when you dont have an RSA provider installed), the following
is displayed: &quot;jar is unsigned. (signatures missing or
not parsable)&quot;</p>

<p>It is possible to verify JAR files signed using either
jarsigner or the JDK 1.1 javakey tool, or both.</p>

<p>For further information on verification, see JAR File
Verification.</p>

<p>-certs If this appears on the command line, along with
the -verify and -verbose options, the output includes
certificate information for each signer of the JAR file.
This information includes</p>

<p>o the name of the type of certificate (stored in the
.DSA file) that certifies the signers public key</p>

<p>o if the certificate is an X.509 certificate (more
specifically, an instance of
java.security.cert.X509Certificate): the distin- guished
name of the signer</p>

<p>The keystore is also examined. If no keystore value is
specified on the command line, the default keystore file (if
any) will be checked. If the public key certificate for a
signer matches an entry in the keystore, then the following
information will also be dis- played:</p>

<p>o in parentheses, the alias name for the keystore entry
for that signer. If the signer actually comes from a JDK 1.1
identity database instead of from a keystore, the alias name
will appear in brackets instead of parentheses.</p>

<p>-verbose If this appears on the command line, it
indicates &quot;verbose&quot; mode, which causes jarsigner
to output extra information as to the progress of the JAR
signing or verification.</p>

<p>-internalsf In the past, the .DSA (signature block) file
generated when a JAR file was signed used to include a
complete encoded copy of the .SF file (signature file) also
generated. This behavior has been changed. To reduce the
overall size of the output JAR file, the .DSA file by
default doesnt contain a copy of the .SF file anymore. But
if -internalsf appears on the command line, the old behavior
is utilized. This option is mainly useful for testing; in
practice, it should not be used, since doing so eliminates a
useful optimization.</p>

<p>-sectionsonly If this appears on the command line, the
.SF file (signature file) generated when a JAR file is
signed does not include a header containing a hash of the
whole manifest file. It just con- tains information and
hashes related to each individual source file included in
the JAR file, as described in The Signature (.SF) File .</p>

<p>By default, this header is added, as an optimization.
When the header is present, then whenever the JAR file is
verified, the veri- fication can first check to see whether
or not the hash in the header indeed matches the hash of the
whole manifest file. If so, verification proceeds to the
next step. If not, it is necessary to do a less optimized
verification that the hash in each source file information
section in the .SF file equals the hash of its corre-
sponding section in the manifest file.</p>

<p>For further information, see JAR File Verification.</p>

<p>This option is mainly useful for testing; in practice,
it should not be used, since doing so eliminates a useful
optimization.</p>

<p>-protected Either true or false. This value should be
specified as true if a password must be given via a
protected authentication path such as a dedicated PIN
reader.</p>

<p>-provider provider-class-name Used to specify the name
of cryptographic service providers mas- ter class file when
the service provider is not listed in the security
properties file, java.security.</p>

<p>Used in conjunction with the -providerArg ConfigFilePath
option, keytool and jarsigner will install the provider
dynamically (where ConfigFilePath is the path to the token
configuration file). Heres an example of a command to list a
PKCS#11 keystore when the Sun PKCS#11 provider has not been
configured in the security properties file.</p>

<p>jarsigner -keystore NONE -storetype PKCS11
-providerClass sun.security.pkcs11.SunPKCS11 -providerArg
/foo/bar/token.config -list</p>

<p>-providerName providerName If more than one provider has
been configured in the java.secu- rity security properties
file, you can use the -providerName option to target a
specific provider instance. The argument to this option is
the name of the provider.</p>

<p>For the Sun PKCS#11 provider, providerName is of the
form SunPKCS11-TokenName, where TokenName is the name suffix
that the provider instance has been configured with, as
detailed in the con- figuration attributes table @
http://java.sun.com/javase/6/docs/technotes/guides/secu-
rity/p11guide.html#KeyToolJarSigner#ATTRS. For example, the
follow- ing command lists the contents of the PKCS#11
keystore provider instance with name suffix SmartCard:</p>

<p>jarsigner -keystore NONE -storetype PKCS11 -providerName
SunPKCS11-SmartCard -list</p>

<p>-Jjavaoption Passes through the specified javaoption
string directly to the Java interpreter. (jarsigner is
actually a &quot;wrapper&quot; around the interpreter.) This
option should not contain any spaces. It is useful for
adjusting the execution environment or memory usage. For a
list of possible interpreter options, type java -h or java
-X at the command line.</p>

<p>-tsa url If &quot;-tsa http://example.tsa.url&quot;
appears on the command line when signing a JAR file then a
timestamp is generated for the signa- ture. The URL,
http://example.tsa.url, identifies the location of the Time
Stamping Authority (TSA). It overrides any URL found via the
-tsacert option. The -tsa option does not require the TSAs
public key certificate to be present in the keystore.</p>

<p>To generate the timestamp, jarsigner communicates with
the TSA using the Time-Stamp Protocol (TSP) defined in RFC
3161 @ http://www.ietf.org/rfc/rfc3161.txt. If successful,
the timestamp token returned by the TSA is stored along with
the signature in the signature block file.</p>

<p>-tsacert alias If &quot;-tsacert alias&quot; appears on
the command line when signing a JAR file then a timestamp is
generated for the signature. The alias identifies the TSAs
public key certificate in the keystore that is currently in
effect. The entrys certificate is examined for a Subject
Information Access extension that contains a URL identifying
the location of the TSA.</p>

<p>The TSAs public key certificate must be present in the
keystore when using -tsacert.</p>

<p>-altsigner class Specifies that an alternative signing
mechanism be used. The fully-qualified class name identifies
a class file that extends the
com.sun.jarsigner.ContentSigner abstract class. The path to
this class file is defined by the -altsignerpath option. If
the -altsigner option is used, jarsigner uses the signing
mechanism provided by the specified class. Otherwise,
jarsigner uses its default signing mechanism.</p>

<p>For example, to use the signing mechanism provided by a
class named com.sun.sun.jarsigner.AuthSigner, use the
jarsigner option &quot;-alt- signer
com.sun.jarsigner.AuthSigner&quot;</p>

<p>-altsignerpath classpathlist Specifies the path to the
class file (the class file name is specified with the
-altsigner option described above) and any JAR files it
depends on. If the class file is in a JAR file, then this
specifies the path to that JAR file, as shown in the example
below.</p>

<p>An absolute path or a path relative to the current
directory may be specified. If classpathlist contains
multiple paths or JAR files, they should be separated with a
colon (:) on Solaris and a semi-colon (;) on Windows. This
option is not necessary if the class is already in the
search path.</p>

<p>Example of specifying the path to a jar file that
contains the class file:</p>

<p>-altsignerpath /home/user/lib/authsigner.jar</p>

<p>Note that the JAR file name is included.</p>

<p>Example of specifying the path to the jar file that
contains the class file:</p>

<p>-altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</p>

<p>Note that the JAR file name is omitted.</p>

<p>EXAMPLES Signing a JAR File Suppose you have a JAR file
named &quot;bundle.jar&quot; and youd like to sign it using
the private key of the user whose keystore alias is
&quot;jane&quot; in the keystore named &quot;mystore&quot;
in the &quot;working&quot; directory. Suppose the keystore
password is &quot;myspass&quot; and the password for jane s
private key is &quot;j638klm&quot;. You can use the
following to sign the JAR file and name the signed JAR file
&quot;sbundle.jar&quot;:</p>

<p>jarsigner -keystore /working/mystore -storepass myspass
-keypass j638klm -signedjar sbundle.jar bundle.jar jane</p>

<p>Note that there is no -sigfile specified in the command
above, so the generated .SF and .DSA files to be placed in
the signed JAR file will have default names based on the
alias name. That is, they will be named JANE.SF and
JANE.DSA.</p>

<p>If you want to be prompted for the store password and
the private key password, you could shorten the above
command to</p>

<p>jarsigner -keystore /working/mystore -signedjar
sbundle.jar bundle.jar jane</p>

<p>If the keystore to be used is the default keystore (the
one named &quot;.keystore&quot; in your home directory), you
dont need to specify a keystore, as in:</p>

<p>jarsigner -signedjar sbundle.jar bundle.jar jane</p>

<p>Finally, if you want the signed JAR file to simply
overwrite the input JAR file (bundle.jar), you dont need to
specify a -signedjar option:</p>

<p>jarsigner bundle.jar jane</p>

<p>Verifying a Signed JAR File To verify a signed JAR file,
that is, to verify that the signature is valid and the JAR
file has not been tampered with, use a command such as the
following:</p>

<p>jarsigner -verify sbundle.jar</p>

<p>If the verification is successful,</p>

<p>jar verified.</p>

<p>is displayed. Otherwise, an error message appears.</p>

<p>You can get more information if you use the -verbose
option. A sam- ple use of jarsigner with the -verbose option
is shown below, along with sample output:</p>

<p>jarsigner -verify -verbose sbundle.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA smk 2752 Fri Sep
26 16:12:30 PDT 1997 AclEx.class smk 849 Fri Sep 26 16:12:46
PDT 1997 test.class</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>Verification with Certificate Information If you specify
the -certs option when verifying, along with the -verify and
-verbose options, the output includes certificate
information for each signer of the JAR file, including the
certificate type, the signer distinguished name information
(iff it s an X.509 certificate), and, in parentheses, the
keystore alias for the signer if the public key cer-
tificate in the JAR file matches that in a keystore entry.
For example,</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs myTest.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 208 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.SF 1087 Fri Sep 26
16:23:30 PDT 1997 META-INF/JAVATEST.DSA smk 2752 Fri Sep 26
16:12:30 PDT 1997 Tst.class</p>

<p>X.509, CN=Test Group, OU=Java Software, O=Sun
Microsystems, L=CUP, S=CA, C=US (javatest) X.509, CN=Jane
Smith, OU=Java Software, O=Sun, L=cup, S=ca, C=us (jane)</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in
keystore</p>

<p>jar verified.</p>

<p>If the certificate for a signer is not an X.509
certificate, there is no distinguished name information. In
that case, just the certificate type and the alias are
shown. For example, if the certificate is a PGP certificate,
and the alias is &quot;bob&quot;, youd get</p>

<p>PGP, (bob)</p>

<p>Verification of a JAR File that Includes Identity
Database Signers If a JAR file has been signed using the JDK
1.1 javakey tool, and thus the signer is an alias in an
identity database, the verification output includes an
&quot;i&quot; symbol. If the JAR file has been signed by
both an alias in an identity database and an alias in a
keystore, both &quot;k&quot; and &quot;i&quot; appear.</p>

<p>When the -certs option is used, any identity database
aliases are shown in square brackets rather than the
parentheses used for keystore aliases. For example:</p>

<p>jarsigner -keystore /working/mystore -verify -verbose
-certs writeFile.jar</p>

<p>198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF 1013 Fri
Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA 199 Fri Sep 27
12:22:30 PDT 1997 META-INF/DUKE.SF 1013 Fri Sep 27 12:22:30
PDT 1997 META-INF/DUKE.DSA smki 2752 Fri Sep 26 16:12:30 PDT
1997 writeFile.html</p>

<p>X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup,
S=ca, C=us (jane) X.509, CN=Duke, OU=Java Software, O=Sun,
L=cup, S=ca, C=us [duke]</p>

<p>s = signature was verified m = entry is listed in
manifest k = at least one certificate was found in keystore
i = at least one certificate was found in identity scope</p>

<p>jar verified.</p>

<p>Note that the alias &quot;duke&quot; is in brackets to
denote that it is an iden- tity database alias, not a
keystore alias.</p>

<p>SEE ALSO o jar tool documentation</p>

<p>o keytool tool documentation</p>

<p>o the Security @
http://java.sun.com/docs/books/tutorial/security1.2/index.html
trail of the Java Tutorial @
http://java.sun.com/docs/books/tutorial/trailmap.html for
examples of the use of the jarsigner tool</p>

<p>07 Aug 2006 jarsigner(1)</p>
<hr>
</body>
</html>
