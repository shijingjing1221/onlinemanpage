<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:12:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PTHREAD_CLEANUP_PUSH(3) Linux Programmer s Manual
PTHREAD_CLEANUP_PUSH(3)</p>

<p>NAME pthread_cleanup_push, pthread_cleanup_pop - push
and pop thread cancel- lation clean-up handlers</p>

<p>SYNOPSIS #include &lt;pthread.h&gt;</p>

<p>void pthread_cleanup_push(void (*routine)(void *), void
*arg); void pthread_cleanup_pop(int execute);</p>

<p>Compile and link with -pthread.</p>

<p>DESCRIPTION These functions manipulate the calling
threads stack of thread-cancel- lation clean-up handlers. A
clean-up handler is a function that is automatically
executed when a thread is canceled (or in various other
circumstances described below); it might, for example,
unlock a mutex so that it becomes available to other threads
in the process.</p>

<p>The pthread_cleanup_push() function pushes routine onto
the top of the stack of clean-up handlers. When routine is
later invoked, it will be given arg as its argument.</p>

<p>The pthread_cleanup_pop() function removes the routine
at the top of the stack of clean-up handlers, and optionally
executes it if execute is non-zero.</p>

<p>A cancellation clean-up handler is popped from the stack
and executed in the following circumstances:</p>

<p>1. When a thread is canceled, all of the stacked
clean-up handlers are popped and executed in the reverse of
the order in which they were pushed onto the stack.</p>

<p>2. When a thread terminates by calling pthread_exit(3),
all clean-up handlers are executed as described in the
preceding point. (Clean- up handlers are not called if the
thread terminates by performing a return from the thread
start function.)</p>

<p>3. When a thread calls pthread_cleanup_pop() with a
non-zero execute argument, the top-most clean-up handler is
popped and executed.</p>

<p>POSIX.1 permits pthread_cleanup_push() and
pthread_cleanup_pop() to be implemented as macros that
expand to text containing &rsquo;{&rsquo; and
&rsquo;}&rsquo;, respectively. For this reason, the caller
must ensure that calls to these functions are paired within
the same function, and at the same lexical nesting level.
(In other words, a clean-up handler is only established
during the execution of a specified section of code.)</p>

<p>Calling longjmp(3) (siglongjmp(3)) produces undefined
results if any call has been made to pthread_cleanup_push()
or pthread_cleanup_pop() without the matching call of the
pair since the jump buffer was filled by setjmp(3)
(sigsetjmp(3)). Likewise, calling longjmp(3) (sig-
longjmp(3)) from inside a clean-up handler produces
undefined results unless the jump buffer was also filled by
setjmp(3) (sigsetjmp(3)) inside the handler.</p>

<p>RETURN VALUE These functions do not return a value.</p>

<p>ERRORS There are no errors.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES On Linux, the pthread_cleanup_push() and
pthread_cleanup_pop() func- tions are implemented as macros
that expand to text containing &rsquo;{&rsquo; and
&rsquo;}&rsquo;, respectively. This means that variables
declared within the scope of paired calls to these functions
will only be visible within that scope.</p>

<p>POSIX.1 says that the effect of using return, break,
continue, or goto to prematurely leave a block bracketed
pthread_cleanup_push() and pthread_cleanup_pop() is
undefined. Portable applications should avoid doing
this.</p>

<p>EXAMPLE The program below provides a simple example of
the use of the functions described in this page. The program
creates a thread that executes a loop bracketed by
pthread_cleanup_push() and pthread_cleanup_pop(). This loop
increments a global variable, cnt, once each second. Depend-
ing on what command-line arguments are supplied, the main
thread sends the other thread a cancellation request, or
sets a global variable that causes the other thread to exit
its loop and terminate normally (by doing a return).</p>

<p>In the following shell session, the main thread sends a
cancellation request to the other thread:</p>

<p>$ ./a.out New thread started cnt = 0 cnt = 1 Canceling
thread Called clean-up handler Thread was canceled; cnt =
0</p>

<p>From the above, we see that the thread was canceled, and
that the can- cellation clean-up handler was called and it
reset the value of the global variable cnt to 0.</p>

<p>In the next run, the main program sets a global variable
that causes other thread to terminate normally:</p>

<p>$ ./a.out x New thread started cnt = 0 cnt = 1 Thread
terminated normally; cnt = 2</p>

<p>From the above, we see that the clean-up handler was not
executed (because cleanup_pop_arg was 0), and therefore the
value of cnt was not reset.</p>

<p>In the next run, the main program sets a global variable
that causes the other thread to terminate normally, and
supplies a non-zero value for cleanup_pop_arg:</p>

<p>$ ./a.out x 1 New thread started cnt = 0 cnt = 1 Called
clean-up handler Thread terminated normally; cnt = 0</p>

<p>In the above, we see that although the thread was not
canceled, the clean-up handler was executed, because the
argument given to pthread_cleanup_pop() was non-zero.</p>

<p>Program source</p>

<p>#include &lt;pthread.h&gt; #include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include
&lt;unistd.h&gt; #include &lt;errno.h&gt;</p>

<p>#define handle_error_en(en, msg) do { errno = en;
perror(msg); exit(EXIT_FAILURE); } while (0)</p>

<p>static int done = 0; static int cleanup_pop_arg = 0;
static int cnt = 0;</p>

<p>static void cleanup_handler(void *arg) {
printf(&quot;Called clean-up handler0); cnt = 0; }</p>

<p>static void * thread_start(void *arg) { time_t start,
curr;</p>

<p>printf(&quot;New thread started0);</p>

<p>pthread_cleanup_push(cleanup_handler, NULL);</p>

<p>curr = start = time(NULL);</p>

<p>while (!done) { pthread_testcancel(); /* A cancellation
point */ if (curr &lt; time(NULL)) { curr = time(NULL);
printf(&quot;cnt = %d0, cnt); /* A cancellation point */
cnt++; } }</p>

<p>pthread_cleanup_pop(cleanup_pop_arg); return NULL; }</p>

<p>int main(int argc, char *argv[]) { pthread_t thr; int s;
void *res;</p>

<p>s = pthread_create(&amp;thr, NULL, thread_start, NULL);
if (s != 0) handle_error_en(s,
&quot;pthread_create&quot;);</p>

<p>sleep(2); /* Allow new thread to run a while */</p>

<p>if (argc &gt; 1) { if (argc &gt; 2) cleanup_pop_arg =
atoi(argv[2]); done = 1;</p>

<p>} else { printf(&quot;Canceling thread0); s =
pthread_cancel(thr); if (s != 0) handle_error_en(s,
&quot;pthread_cancel&quot;); }</p>

<p>s = pthread_join(thr, &amp;res); if (s != 0)
handle_error_en(s, &quot;pthread_join&quot;);</p>

<p>if (res == PTHREAD_CANCELED) printf(&quot;Thread was
canceled; cnt = %d0, cnt); else printf(&quot;Thread
terminated normally; cnt = %d0, cnt); exit(EXIT_SUCCESS);
}</p>

<p>SEE ALSO pthread_cancel(3),
pthread_cleanup_push_defer_np(3), pthread_setcancel-
state(3), pthread_testcancel(3), pthreads(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-11-24 PTHREAD_CLEANUP_PUSH(3)</p>
<hr>
</body>
</html>
