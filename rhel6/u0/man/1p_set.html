<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:15:03 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SET(1P) POSIX Programmer s Manual SET(1P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME set - set or unset options and positional
parameters</p>

<p>SYNOPSIS set [-abCefmnuvx][-h][-o
option][argument...]</p>

<p>set [+abCefmnuvx][+h][+o option][argument...]</p>

<p>set -- [argument...]</p>

<p>set -o</p>

<p>set +o</p>

<p>DESCRIPTION If no options or arguments are specified,
set shall write the names and values of all shell variables
in the collation sequence of the current locale. Each name
shall start on a separate line, using the format:</p>

<p>&quot;%s=%n&quot;, &lt;name&gt;, &lt;value&gt;</p>

<p>The value string shall be written with appropriate
quoting; see the description of shell quoting in Quoting .
The output shall be suitable for reinput to the shell,
setting or resetting, as far as possible, the variables that
are currently set; read-only variables cannot be reset.</p>

<p>When options are specified, they shall set or unset
attributes of the shell, as described below. When arguments
are specified, they cause positional parameters to be set or
unset, as described below. Setting or unsetting attributes
and positional parameters are not necessarily related
actions, but they can be combined in a single invocation of
set.</p>

<p>The set special built-in shall support the Base
Definitions volume of IEEE Std 1003.1-2001, Section 12.2,
Utility Syntax Guidelines except that options can be
specified with either a leading hyphen (meaning enable the
option) or plus sign (meaning disable it) unless otherwise
specified.</p>

<p>Implementations shall support the options in the
following list in both their hyphen and plus-sign forms.
These options can also be specified as options to sh.</p>

<p>-a When this option is on, the export attribute shall be
set for each variable to which an assignment is performed;
see the Base Definitions volume of IEEE Std 1003.1-2001,
Section 4.21, Vari- able Assignment. If the assignment
precedes a utility name in a command, the export attribute
shall not persist in the current execution environment after
the utility completes, with the exception that preceding one
of the special built-in utilities causes the export
attribute to persist after the built-in has completed. If
the assignment does not precede a utility name in the
command, or if the assignment is a result of the operation
of the getopts or read utilities, the export attribute shall
persist until the variable is unset.</p>

<p>-b This option shall be supported if the implementation
supports the User Portability Utilities option. It shall
cause the shell to notify the user asynchronously of
background job completions. The following message is written
to standard error:</p>

<p>&quot;[%d]%c %s%n&quot;, &lt;job-number&gt;,
&lt;current&gt;, &lt;status&gt;, &lt;job-name&gt;</p>

<p>where the fields shall be as follows:</p>

<p>&lt;current&gt; The character + identifies the job that
would be used as a default for the fg or bg utilities; this
job can also be speci- fied using the job_id &quot;%+&quot;
or &quot;%%&quot; . The character-identi- fies the job that
would become the default if the current default job were to
exit; this job can also be specified using the job_id
&quot;%-&quot; . For other jobs, this field is a
&lt;space&gt;. At most one job can be identified with+and at
most one job can be identified with-. If there is any
suspended job, then the current job shall be a suspended
job. If there are at least two suspended jobs, then the
previous job also shall be a suspended job.</p>

<p>&lt;job-number&gt; A number that can be used to identify
the process group to the wait, fg, bg, and kill utilities.
Using these utilities, the job can be identified by
prefixing the job number with% .</p>

<p>&lt;status&gt; Unspecified.</p>

<p>&lt;job-name&gt; Unspecified.</p>

<p>When the shell notifies the user a job has been
completed, it may remove the jobs process ID from the list
of those known in the current shell execution environment;
see Asynchronous Lists . Asynchronous notification shall not
be enabled by default.</p>

<p>-C (Uppercase C.) Prevent existing files from being
overwritten by the shells&gt;redirection operator (see
Redirecting Output ); the &quot;&gt;|&quot; redirection
operator shall override this noclobber option for an
individual file.</p>

<p>-e When this option is on, if a simple command fails for
any of the reasons listed in Consequences of Shell Errors or
returns an exit status value &gt;0, and is not part of the
compound list fol- lowing a while, until, or if keyword, and
is not a part of an AND or OR list, and is not a pipeline
preceded by the ! reserved word, then the shell shall
immediately exit.</p>

<p>-f The shell shall disable pathname expansion.</p>

<p>-h Locate and remember utilities invoked by functions as
those functions are defined (the utilities are normally
located when the function is executed).</p>

<p>-m This option shall be supported if the implementation
supports the User Portability Utilities option. All jobs
shall be run in their own process groups. Immediately before
the shell issues a prompt after completion of the background
job, a message report- ing the exit status of the background
job shall be written to standard error. If a foreground job
stops, the shell shall write a message to standard error to
that effect, formatted as described by the jobs utility. In
addition, if a job changes status other than exiting (for
example, if it stops for input or output or is stopped by a
SIGSTOP signal), the shell shall write a similar message
immediately prior to writing the next prompt. This option is
enabled by default for interactive shells.</p>

<p>-n The shell shall read commands but does not execute
them; this can be used to check for shell script syntax
errors. An interac- tive shell may ignore this option.</p>

<p>-o Write the current settings of the options to standard
output in an unspecified format.</p>

<p>+o Write the current option settings to standard output
in a format that is suitable for reinput to the shell as
commands that achieve the same options settings.</p>

<p>-o option</p>

<p>This option is supported if the system supports the User
Porta- bility Utilities option. It shall set various
options, many of which shall be equivalent to the single
option letters. The fol- lowing values of option shall be
supported:</p>

<p>allexport Equivalent to -a.</p>

<p>errexit Equivalent to -e.</p>

<p>ignoreeof Prevent an interactive shell from exiting on
end-of-file. This setting prevents accidental logouts when
&lt;control&gt;-D is entered. A user shall explicitly exit
to leave the interactive shell.</p>

<p>monitor Equivalent to -m. This option is supported if
the system sup- ports the User Portability Utilities
option.</p>

<p>noclobber Equivalent to -C (uppercase C).</p>

<p>noglob Equivalent to -f.</p>

<p>noexec Equivalent to -n.</p>

<p>nolog Prevent the entry of function definitions into the
command his- tory; see Command History List .</p>

<p>notify Equivalent to -b.</p>

<p>nounset Equivalent to -u.</p>

<p>verbose Equivalent to -v.</p>

<p>vi Allow shell command line editing using the built-in
vi editor. Enabling vi mode shall disable any other command
line editing mode provided as an implementation
extension.</p>

<p>It need not be possible to set vi mode on for certain
block-mode terminals.</p>

<p>xtrace Equivalent to -x.</p>

<p>-u The shell shall write a message to standard error
when it tries to expand a variable that is not set and
immediately exit. An interactive shell shall not exit.</p>

<p>-v The shell shall write its input to standard error as
it is read.</p>

<p>-x The shell shall write to standard error a trace for
each command after it expands the command and before it
executes it. It is unspecified whether the command that
turns tracing off is traced.</p>

<p>The default for all these options shall be off (unset)
unless stated otherwise in the description of the option or
unless the shell was invoked with them on; see sh.</p>

<p>The remaining arguments shall be assigned in order to
the positional parameters. The special parameter#shall be
set to reflect the num- ber of positional parameters. All
positional parameters shall be unset before any new values
are assigned.</p>

<p>The special argument &quot;--&quot; immediately
following the set command name can be used to delimit the
arguments if the first argument begins with + or , or to
prevent inadvertent listing of all shell variables when
there are no arguments. The command set -- without argument
shall unset all positional parameters and set the special
parameter#to zero.</p>

<p>OPTIONS See the DESCRIPTION.</p>

<p>OPERANDS See the DESCRIPTION.</p>

<p>STDIN Not used.</p>

<p>INPUT FILES None.</p>

<p>ENVIRONMENT VARIABLES None.</p>

<p>ASYNCHRONOUS EVENTS Default.</p>

<p>STDOUT See the DESCRIPTION.</p>

<p>STDERR The standard error shall be used only for
diagnostic messages.</p>

<p>OUTPUT FILES None.</p>

<p>EXTENDED DESCRIPTION None.</p>

<p>EXIT STATUS Zero.</p>

<p>CONSEQUENCES OF ERRORS Default.</p>

<p>The following sections are informative.</p>

<p>APPLICATION USAGE None.</p>

<p>EXAMPLES Write out all variables and their values:</p>

<p>set</p>

<p>Set $1, $2, and $3 and set &quot;$#&quot; to 3:</p>

<p>set c a b</p>

<p>Turn on the -x and -v options:</p>

<p>set -xv</p>

<p>Unset all positional parameters:</p>

<p>set --</p>

<p>Set $1 to the value of x, even if it begins
with-or+:</p>

<p>set -- &quot;$x&quot;</p>

<p>Set the positional parameters to the expansion of x,
even if x expands with a leading-or+:</p>

<p>set -- $x</p>

<p>RATIONALE The set -- form is listed specifically in the
SYNOPSIS even though this usage is implied by the Utility
Syntax Guidelines. The explanation of this feature removes
any ambiguity about whether the set -- form might be
misinterpreted as being equivalent to set without any
options or arguments. The functionality of this form has
been adopted from the KornShell. In System V, set -- only
unsets parameters if there is at least one argument; the
only way to unset all parameters is to use shift. Using the
KornShell version should not affect System V scripts because
there should be no reason to issue it without arguments
delib- erately; if it were issued as, for example:</p>

<p>set -- &quot;$@&quot;</p>

<p>and there were in fact no arguments resulting from
&quot;$@&quot;, unsetting the parameters would have no
result.</p>

<p>The set + form in early proposals was omitted as being
an unnecessary duplication of set alone and not widespread
historical practice.</p>

<p>The noclobber option was changed to allow set -C as well
as the set -o noclobber option. The single-letter version
was added so that the historical &quot;$-&quot; paradigm
would not be broken; see Special Parameters .</p>

<p>The -h flag is related to command name hashing and is
only required on XSI-conformant systems.</p>

<p>The following set flags were omitted intentionally with
the following rationale:</p>

<p>-k The -k flag was originally added by the author of the
Bourne shell to make it easier for users of pre-release
versions of the shell. In early versions of the Bourne shell
the construct set name= value had to be used to assign
values to shell variables. The problem with -k is that the
behavior affects parsing, virtu- ally precluding writing any
compilers. To explain the behavior of -k, it is necessary to
describe the parsing algorithm, which is
implementation-defined. For example:</p>

<p>set -k; echo name=value</p>

<p>and:</p>

<p>set -k echo name=value</p>

<p>behave differently. The interaction with functions is
even more com- plex. What is more, the -k flag is never
needed, since the command line could have been
reordered.</p>

<p>-t The -t flag is hard to specify and almost never used.
The only known use could be done with here-documents.
Moreover, the behavior with ksh and sh differs. The
reference page says that it exits after reading and
executing one command. What is one command? If the input is
date; date, sh executes both date com- mands while ksh does
only the first.</p>

<p>Consideration was given to rewriting set to simplify its
confusing syn- tax. A specific suggestion was that the unset
utility should be used to unset options instead of using the
non- getopt() -able + option syntax. However, the conclusion
was reached that the historical practice of using + option
was satisfactory and that there was no compelling reason to
modify such widespread historical practice.</p>

<p>The -o option was adopted from the KornShell to address
user needs. In addition to its generally friendly interface,
-o is needed to provide the vi command line editing mode,
for which historical practice yields no single-letter option
name. (Although it might have been possible to invent such a
letter, it was recognized that other editing modes would be
developed and -o provides ample name space for describing
such extensions.)</p>

<p>Historical implementations are inconsistent in the
format used for -o option status reporting. The +o format
without an option-argument was added to allow portable
access to the options that can be saved and then later
restored using, for instance, a dot script.</p>

<p>Historically, sh did trace the command set +x, but ksh
did not.</p>

<p>The ignoreeof setting prevents accidental logouts when
the end-of-file character (typically &lt;control&gt;-D) is
entered. A user shall explicitly exit to leave the
interactive shell.</p>

<p>The set -m option was added to apply only to the UPE
because it applies primarily to interactive use, not shell
script applications.</p>

<p>The ability to do asynchronous notification became
available in the 1988 version of the KornShell. To have it
occur, the user had to issue the command:</p>

<p>trap &quot;jobs -n&quot; CLD</p>

<p>The C shell provides two different levels of an
asynchronous notifica- tion capability. The environment
variable notify is analogous to what is done in set -b or
set -o notify. When set, it notifies the user immediately of
background job completions. When unset, this capability is
turned off.</p>

<p>The other notification ability comes through the
built-in utility notify. The syntax is:</p>

<p>notify [%job ... ]</p>

<p>By issuing notify with no operands, it causes the C
shell to notify the user asynchronously when the state of
the current job changes. If given operands, notify
asynchronously informs the user of changes in the states of
the specified jobs.</p>

<p>To add asynchronous notification to the POSIX shell,
neither the Korn- Shell extensions to trap, nor the C shell
notify environment variable seemed appropriate ( notify is
not a proper POSIX environment variable name).</p>

<p>The set -b option was selected as a compromise.</p>

<p>The notify built-in was considered to have more
functionality than was required for simple asynchronous
notification.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO Special Built-In Utilities</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 SET(1P)</p>
<hr>
</body>
</html>
