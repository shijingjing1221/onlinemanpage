<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:28:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>XmResolveAllPartOffsets(library call)
XmResolveAllPartOffsets(library call)</p>

<p>NAME XmResolveAllPartOffsets A function that allows
writing of upward-com- patible applications and widgets</p>

<p>SYNOPSIS #include &lt;Xm/Xm.h&gt; void
XmResolveAllPartOffsets( WidgetClass widget_class,
XmOffsetPtr * offset, XmOffsetPtr * constraint_offset);</p>

<p>DESCRIPTION Note:</p>

<p>This routine is obsolete and exists for compatibility
with pre- vious releases. You should call
XmeResolvePartOffsets instead.</p>

<p>The use of offset records requires two extra global
variables per wid- get class. The variables consist of
pointers to arrays of offsets into the widget record and
constraint record for each part of the widget structure. The
XmResolveAllPartOffsets function allocates the offset
records needed by an application to guarantee
upward-compatible access to widget instance and constraint
records by applications and widgets. These offset records
are used by the widget to access all of the wid- gets
variables. A widget needs to take the steps described in the
following paragraphs.</p>

<p>Instead of creating a resource list, the widget creates
an offset resource list. To accomplish this, use the
XmPartResource structure and the XmPartOffset macro. The
XmPartResource data structure looks just like a resource
list, but instead of having one integer for its offset, it
has two shorts. This structure is put into the class record
as if it were a normal resource list. Instead of using
XtOffset for the offset, the widget uses XmPartOffset.</p>

<p>If the widget is a subclass of the Constraint class and
it defines additional constraint resources, create an offset
resource list for the constraint part as well. Instead of
using XtOffset for the offset, the widget uses
XmConstraintPartOffset in the constraint resource list.</p>

<p>XmPartResource resources[] = { { BarNxyz, BarCXyz,
XmRBoolean, sizeof(Boolean), XmPartOffset(Bar,xyz),
XmRImmediate, (XtPointer)False } }; XmPartResource
constraints[] = { { BarNmaxWidth, BarNMaxWidth,
XmRDimension, sizeof(Dimension),
XmConstraintPartOffset(Bar,max_width), XmRImmediate,
(XtPointer)100 } };</p>

<p>Instead of putting the widget size in the class record,
the widget puts the widget part size in the same field. If
the widget is a subclass of the Constraint class, instead of
putting the widget constraint record size in the class
record, the widget puts the widget constraint part size in
the same field.</p>

<p>Instead of putting XtVersion in the class record, the
widget puts XtVersionDontCheck in the class record.</p>

<p>Define a variable, of type XmOffsetPtr, to point to the
offset record. If the widget is a subclass of the Constraint
class, define a variable of type XmOffsetPtr to point to the
constraint offset record. These can be part of the widgets
class record or separate global variables.</p>

<p>In class initialization, the widget calls
XmResolveAllPartOffsets, passing it pointers to the class
record, the address of the offset record, and the address of
the constraint offset record. If the widget not is a
subclass of the Constraint class, it should pass NULL as the
address of the constraint offset record. This does several
things:</p>

<p>&middot; Adds the superclass (which, by definition, has
already been ini- tialized) size field to the part size
field</p>

<p>&middot; If the widget is a subclass of the Constraint
class, adds the superclass constraint size field to the
constraint size field</p>

<p>&middot; Allocates an array based upon the number of
superclasses</p>

<p>&middot; If the widget is a subclass of the constraint
class, allocates an array for the constraint offset
record</p>

<p>&middot; Fills in the offsets of all the widget parts
and constraint parts with the appropriate values, determined
by examining the size fields of all superclass records</p>

<p>&middot; Uses the part offset array to modify the offset
entries in the resource list to be real offsets, in
place</p>

<p>The widget defines a constant that will be the index to
its part struc- ture in the offsets array. The value should
be 1 greater than the index of the widgets superclass.
Constants defined for all Xm widgets can be found in
XmP.h.</p>

<p>#define BarIndex (XmBulletinBIndex + 1)</p>

<p>Instead of accessing fields directly, the widget must
always go through the offset table. The XmField and
XmConstraintField macros help you access these fields.
Because the XmPartOffset, XmConstraintPartOffset, XmField,
and XmConstraintField macros concatenate things, you must
ensure that there is no space after the part argument. For
example, the following macros do not work because of the
space after the part (Label) argument:</p>

<p>XmField(w, offset, Label, text, char *)
XmPartOffset(Label, text).</p>

<p>Therefore, you must not have any spaces after the part
(Label) argu- ment, as illustrated here:</p>

<p>XmField(w, offset, Label, text, char *)</p>

<p>You can define macros for each field to make this
easier. Assume an integer field xyz:</p>

<p>#define BarXyz(w) (*(int *)(((char *) w) +
offset[BarIndex] + XtOffset(BarPart,xyz)))</p>

<p>For constraint field max_width:</p>

<p>#define BarMaxWidth(w)
XmConstraintField(w,constraint_offsets,Bar,max_width,Dimension)</p>

<p>The parameters for XmResolveAllPartOffsets are</p>

<p>widget_class Specifies the widget class pointer for the
created widget</p>

<p>offset Returns the offset record</p>

<p>constraint_offset Returns the constraint offset
record</p>

<p>RELATED INFORMATION XmResolvePartOffsets(3).</p>

<p>XmResolveAllPartOffsets(library call)</p>
<hr>
</body>
</html>
