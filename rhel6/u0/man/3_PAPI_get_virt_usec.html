<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:09:19 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PAPI_get_virt_cyc(3) PAPI PAPI_get_virt_cyc(3)</p>

<p>NAME PAPI_get_virt_cyc - get virtual time counter value
in clock cycles</p>

<p>PAPI_get_virt_usec - get virtual time counter values in
microseconds</p>

<p>SYNOPSIS C Interface #include &lt;papi.h&gt; long_long
PAPI_get_virt_cyc(void); long_long PAPI_get_virt_usec(void);
Fortran Interface #include fpapi.h
PAPIF_get_virt_usec(C_LONG_LONG time)
PAPIF_get_virt_cyc(C_LONG_LONG virt_cyc)</p>

<p>DESCRIPTION Both of these functions return the total
number of virtual units from some arbitrary starting point.
Virtual units accrue every time the pro- cess is running in
user-mode on behalf of the process. Like the real time
counters, these are guaranteed to exist on every platform
PAPI supports. However on some platforms, the resolution can
be as bad as 1/Hz as defined by the operating system.</p>

<p>ERRORS The functions returns PAPI_ECNFLCT if there is no
master event set. This will happen if the library has not
been initialized, or for threaded applications, if there has
been no thread id function defined by the PAPI_thread_init
function.</p>

<p>For threaded applications, if there has not yet been any
thread spe- cific master event created for the current
thread, and if the alloca- tion of such an event set fails,
the call will return PAPI_ENOMEMor- PAPI_ESYS.</p>

<p>EXAMPLE s = PAPI_get_virt_cyc(); your_slow_code(); e =
PAPI_get_virt_cyc(); printf(&quot;Process has run for
cycles: %lld0,e-s);</p>

<p>BUGS These functions have no known bugs.</p>

<p>SEE ALSO PAPI_library_init(3), PAPI_get_real_usec(3),
PAPI_get_real_cyc(3), PAPI(3), PAPIF(3)</p>

<p>PAPI Programmer s Reference September, 2004
PAPI_get_virt_cyc(3)</p>
<hr>
</body>
</html>
