<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:05 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLFAQ7(1) Perl Programmers Reference Guide
PERLFAQ7(1)</p>

<p>NAME perlfaq7 - General Perl Language Issues</p>

<p>DESCRIPTION This section deals with general Perl
language issues that dont clearly fit into any of the other
sections.</p>

<p>Can I get a BNF/yacc/RE for the Perl language? There is
no BNF, but you can paw your way through the yacc grammar in
perly.y in the source distribution if you re particularly
brave. The grammar relies on very smart tokenizing code, so
be prepared to venture into toke.c as well.</p>

<p>In the words of Chaim Frenkel: &quot;Perls grammar can
not be reduced to BNF. The work of parsing perl is
distributed between yacc, the lexer, smoke and
mirrors.&quot;</p>

<p>What are all these $@%&amp;* punctuation signs, and how
do I know when to use them? They are type specifiers, as
detailed in perldata:</p>

<p>$ for scalar values (number, string or reference) @ for
arrays % for hashes (associative arrays) &amp; for
subroutines (aka functions, procedures, methods) * for all
types of that symbol name. In version 4 you used them like
pointers, but in modern perls you can just use
references.</p>

<p>There are couple of other symbols that you re likely to
encounter that arent really type specifiers:</p>

<p>&lt;&gt; are used for inputting a record from a
filehandle. takes a reference to something.</p>

<p>Note that &lt;FILE&gt; is neither the type specifier for
files nor the name of the handle. It is the
&quot;&lt;&gt;&quot; operator applied to the handle FILE. It
reads one line (well, record--see &quot;$/&quot; in perlvar)
from the handle FILE in scalar context, or all lines in list
context. When performing open, close, or any other operation
besides &quot;&lt;&gt;&quot; on files, or even when talking
about the handle, do not use the brackets. These are
correct: &quot;eof(FH)&quot;, &quot;seek(FH, 0, 2)&quot; and
&quot;copying from STDIN to FILE&quot;.</p>

<p>Do I always/never have to quote my strings or use
semicolons and commas? Normally, a bareword doesnt need to
be quoted, but in most cases probably should be (and must be
under &quot;use strict&quot;). But a hash key consisting of
a simple word (that isn t the name of a defined subroutine)
and the left-hand operand to the &quot;=&gt;&quot; operator
both count as though they were quoted:</p>

<p>This is like this ------------ ---------------
$foo{line} $foo{&rsquo;line&rsquo;} bar =&gt; stuff
&rsquo;bar&rsquo; =&gt; stuff</p>

<p>The final semicolon in a block is optional, as is the
final comma in a list. Good style (see perlstyle) says to
put them in except for one- liners:</p>

<p>if ($whoops) { exit 1 } @nums = (1, 2, 3);</p>

<p>if ($whoops) { exit 1; }</p>

<p>@lines = ( &quot;There Beren came from mountains
cold&quot;, &quot;And lost he wandered under leaves&quot;,
);</p>

<p>How do I skip some return values? One way is to treat
the return values as a list and index into it:</p>

<p>$dir = (getpwnam($user))[7];</p>

<p>Another way is to use undef as an element on the
left-hand-side:</p>

<p>($dev, $ino, undef, undef, $uid, $gid) =
stat($file);</p>

<p>You can also use a list slice to select only the
elements that you need:</p>

<p>($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];</p>

<p>How do I temporarily block warnings? If you are running
Perl 5.6.0 or better, the &quot;use warnings&quot; pragma
allows fine control of what warning are produced. See
perllexwarn for more details.</p>

<p>{ no warnings; # temporarily turn off warnings $a = $b +
$c; # I know these might be undef }</p>

<p>Additionally, you can enable and disable categories of
warnings. You turn off the categories you want to ignore and
you can still get other categories of warnings. See
perllexwarn for the complete details, including the category
names and hierarchy.</p>

<p>{ no warnings &rsquo;uninitialized&rsquo;; $a = $b + $c;
}</p>

<p>If you have an older version of Perl, the $^W variable
(documented in perlvar) controls runtime warnings for a
block:</p>

<p>{ local $^W = 0; # temporarily turn off warnings $a = $b
+ $c; # I know these might be undef }</p>

<p>Note that like all the punctuation variables, you cannot
currently use my() on $^W, only local().</p>

<p>Whas an extension? An extension is a way of calling
compiled C code from Perl. Reading perlxstut is a good place
to learn more about extensions.</p>

<p>Why do Perl operators have different precedence than C
operators? Actually, they don t. All C operators that Perl
copies have the same precedence in Perl as they do in C. The
problem is with operators that C doesn t have, especially
functions that give a list context to everything on their
right, eg. print, chmod, exec, and so on. Such functions are
called &quot;list operators&quot; and appear as such in the
precedence table in perlop.</p>

<p>A common mistake is to write:</p>

<p>unlink $file || die &quot;snafu&quot;;</p>

<p>This gets interpreted as:</p>

<p>unlink ($file || die &quot;snafu&quot;);</p>

<p>To avoid this problem, either put in extra parentheses
or use the super low precedence &quot;or&quot; operator:</p>

<p>(unlink $file) || die &quot;snafu&quot;; unlink $file or
die &quot;snafu&quot;;</p>

<p>The &quot;English&quot; operators (&quot;and&quot;,
&quot;or&quot;, &quot;xor&quot;, and &quot;not&quot;)
deliberately have precedence lower than that of list
operators for just such situations as the one above.</p>

<p>Another operator with surprising precedence is
exponentiation. It binds more tightly even than unary minus,
making &quot;-2**2&quot; produce a negative not a positive
four. It is also right-associating, meaning that
&quot;2**3**2&quot; is two raised to the ninth power, not
eight squared.</p>

<p>Although it has the same precedence as in C, Perls
&quot;?:&quot; operator produces an lvalue. This assigns $x
to either $a or $b, depending on the trueness of $maybe:</p>

<p>($maybe ? $a : $b) = $x;</p>

<p>How do I declare/create a structure? In general, you
dont &quot;declare&quot; a structure. Just use a (probably
anonymous) hash reference. See perlref and perldsc for
details. Heres an example:</p>

<p>$person = {}; # new anonymous hash $person-&gt;{AGE} =
24; # set field AGE to 24 $person-&gt;{NAME} =
&quot;Nat&quot;; # set field NAME to &quot;Nat&quot;</p>

<p>If youre looking for something a bit more rigorous, try
perltoot.</p>

<p>How do I create a module? (contributed by brian d
foy)</p>

<p>perlmod, perlmodlib, perlmodstyle explain modules in all
the gory details. perlnewmod gives a brief overview of the
process along with a couple of suggestions about style.</p>

<p>If you need to include C code or C library interfaces in
your module, youll need h2xs. h2xs will create the module
distribution structure and the initial interface files youll
need. perlxs and perlxstut explain the details.</p>

<p>If you dont need to use C code, other tools such as
ExtUtils::ModuleMaker and Module::Starter, can help you
create a skeleton module distribution.</p>

<p>You may also want to see Sam Tregars &quot;Writing Perl
Modules for CPAN&quot; (
http://apress.com/book/bookDisplay.html?bID=14 ) which is
the best hands-on guide to creating module
distributions.</p>

<p>How do I adopt or take over a module already on CPAN?
(contributed by brian d foy)</p>

<p>The full answer to this can be found at
http://cpan.org/modules/04pause.html#takeover</p>

<p>The easiest way to take over a module is to have the
current module maintainer either make you a co-maintainer or
transfer the module to you.</p>

<p>If you cant reach the author for some reason (e.g. email
bounces), the PAUSE admins at modules@perl.org can help. The
PAUSE admins treat each case individually.</p>

<p>&middot; Get a login for the Perl Authors Upload Server
(PAUSE) if you dont already have one:
http://pause.perl.org</p>

<p>&middot; Write to modules@perl.org explaining what you
did to contact the current maintainer. The PAUSE admins will
also try to reach the maintainer.</p>

<p>&middot; Post a public message in a heavily trafficked
site announcing your intention to take over the module.</p>

<p>&middot; Wait a bit. The PAUSE admins dont want to act
too quickly in case the current maintainer is on holiday. If
there s no response to private communication or the public
post, a PAUSE admin can transfer it to you.</p>

<p>How do I create a class? (contributed by brian d
foy)</p>

<p>In Perl, a class is just a package, and methods are just
subroutines. Perl doesnt get more formal than that and lets
you set up the package just the way that you like it (that
is, it doesnt set up anything for you).</p>

<p>The Perl documentation has several tutorials that cover
class creation, including perlboot (Barnyard Object Oriented
Tutorial), perltoot (Toms Object Oriented Tutorial), perlbot
(Bag o Object Tricks), and perlobj.</p>

<p>How can I tell if a variable is tainted? You can use the
tainted() function of the Scalar::Util module, available
from CPAN (or included with Perl since release 5.8.0). See
also &quot;Laundering and Detecting Tainted Data&quot; in
perlsec.</p>

<p>Whas a closure? Closures are documented in perlref.</p>

<p>Closure is a computer science term with a precise but
hard-to-explain meaning. Usually, closures are implemented
in Perl as anonymous subroutines with lasting references to
lexical variables outside their own scopes. These lexicals
magically refer to the variables that were around when the
subroutine was defined (deep binding).</p>

<p>Closures are most often used in programming languages
where you can have the return value of a function be itself
a function, as you can in Perl. Note that some languages
provide anonymous functions but are not capable of providing
proper closures: the Python language, for example. For more
information on closures, check out any textbook on
functional programming. Scheme is a language that not only
supports but encourages closures.</p>

<p>Heres a classic non-closure function-generating
function:</p>

<p>sub add_function_generator { return sub { shift() +
shift() }; }</p>

<p>$add_sub = add_function_generator(); $sum =
$add_sub-&gt;(4,5); # $sum is 9 now.</p>

<p>The anonymous subroutine returned by
add_function_generator() isnt technically a closure because
it refers to no lexicals outside its own scope. Using a
closure gives you a function template with some
customization slots left out to be filled later.</p>

<p>Contrast this with the following make_adder() function,
in which the returned anonymous function contains a
reference to a lexical variable outside the scope of that
function itself. Such a reference requires that Perl return
a proper closure, thus locking in for all time the value
that the lexical had when the function was created.</p>

<p>sub make_adder { my $addpiece = shift; return sub {
shift() + $addpiece }; }</p>

<p>$f1 = make_adder(20); $f2 = make_adder(555);</p>

<p>Now &quot;&amp;$f1($n)&quot; is always 20 plus whatever
$n you pass in, whereas &quot;&amp;$f2($n)&quot; is always
555 plus whatever $n you pass in. The $addpiece in the
closure sticks around.</p>

<p>Closures are often used for less esoteric purposes. For
example, when you want to pass in a bit of code into a
function:</p>

<p>my $line; timeout( 30, sub { $line = &lt;STDIN&gt; }
);</p>

<p>If the code to execute had been passed in as a string,
&rsquo;$line = &lt;STDIN&gt;&rsquo;, there would have been
no way for the hypothetical timeout() function to access the
lexical variable $line back in its callers scope.</p>

<p>Another use for a closure is to make a variable private
to a named subroutine, e.g. a counter that gets initialized
at creation time of the sub and can only be modified from
within the sub. This is sometimes used with a BEGIN block in
package files to make sure a variable doesn t get meddled
with during the lifetime of the package:</p>

<p>BEGIN { my $id = 0; sub next_id { ++$id } }</p>

<p>This is discussed in more detail in perlsub, see the
entry on Persistent Private Variables.</p>

<p>What is variable suicide and how can I prevent it? This
problem was fixed in perl 5.004_05, so preventing it means
upgrading your version of perl. ;)</p>

<p>Variable suicide is when you (temporarily or
permanently) lose the value of a variable. It is caused by
scoping through my() and local() interacting with either
closures or aliased foreach() iterator variables and
subroutine arguments. It used to be easy to inadvertently
lose a variables value this way, but now its much harder.
Take this code:</p>

<p>my $f = &rsquo;foo&rsquo;; sub T { while ($i++ &lt; 3) {
my $f = $f; $f .= &quot;bar&quot;; print $f, &quot;0 } }</p>

<p>T; print &quot;Finally $f0;</p>

<p>If you are experiencing variable suicide, that &quot;my
$f&quot; in the subroutine doesn t pick up a fresh copy of
the $f whose value is &lt;foo&gt;. The output shows that
inside the subroutine the value of $f leaks through when it
shouldnt, as in this output:</p>

<p>foobar foobarbar foobarbarbar Finally foo</p>

<p>The $f that has &quot;bar&quot; added to it three times
should be a new $f &quot;my $f&quot; should create a new
lexical variable each time through the loop. The expected
output is:</p>

<p>foobar foobar foobar Finally foo</p>

<p>How can I pass/return a {Function, FileHandle, Array,
Hash, Method, Regex}? With the exception of regexes, you
need to pass references to these objects. See &quot;Pass by
Reference&quot; in perlsub for this particular question, and
perlref for information on references.</p>

<p>See &quot;Passing Regexes&quot;, later in perlfaq7, for
information on passing regular expressions.</p>

<p>Passing Variables and Functions Regular variables and
functions are quite easy to pass: just pass in a reference
to an existing or anonymous variable or function:</p>

<p>func( ome_scalar );</p>

<p>func( @some_array ); func( [ 1 .. 10 ] );</p>

<p>func( some_hash ); func( { this =&gt; 10, that =&gt; 20
} );</p>

<p>func( some_func ); func( sub { $_[0] ** $_[1] } );</p>

<p>Passing Filehandles As of Perl 5.6, you can represent
filehandles with scalar variables which you treat as any
other scalar.</p>

<p>open my $fh, $filename or die &quot;Cannot open
$filename! $!&quot;; func( $fh );</p>

<p>sub func { my $passed_fh = shift;</p>

<p>my $line = &lt;$passed_fh&gt;; }</p>

<p>Before Perl 5.6, you had to use the *FH or &quot;H&quot;
notations. These are &quot;typeglobs&quot;--see
&quot;Typeglobs and Filehandles&quot; in perldata and
especially &quot;Pass by Reference&quot; in perlsub for more
information.</p>

<p>Passing Regexes To pass regexes around, you ll need to
be using a release of Perl sufficiently recent as to support
the &quot;qr//&quot; construct, pass around strings and use
an exception-trapping eval, or else be very, very
clever.</p>

<p>Here s an example of how to pass in a string to be regex
compared using &quot;qr//&quot;:</p>

<p>sub compare($$) { my ($val1, $regex) = @_; my $retval =
$val1 =~ /$regex/; return $retval; } $match =
compare(&quot;old McDonald&quot;, qr/d.*D/i);</p>

<p>Notice how &quot;qr//&quot; allows flags at the end.
That pattern was compiled at compile time, although it was
executed later. The nifty &quot;qr//&quot; notation wasnt
introduced until the 5.005 release. Before that, you had to
approach this problem much less intuitively. For example,
here it is again if you don t have &quot;qr//&quot;:</p>

<p>sub compare($$) { my ($val1, $regex) = @_; my $retval =
eval { $val1 =~ /$regex/ }; die if $@; return $retval; }</p>

<p>$match = compare(&quot;old McDonald&quot;,
q/($?i)d.*D/);</p>

<p>Make sure you never say something like this:</p>

<p>return eval &quot;al =~ /$regex/&quot;; # WRONG</p>

<p>or someone can sneak shell escapes into the regex due to
the double interpolation of the eval and the double-quoted
string. For example:</p>

<p>$pattern_of_evil = &rsquo;danger ${ system(&quot;rm -rf
* &amp;&quot;) } danger&rsquo;;</p>

<p>eval &quot;tring =~ /$pattern_of_evil/&quot;;</p>

<p>Those preferring to be very, very clever might see the
OReilly book, Mastering Regular Expressions, by Jeffrey
Friedl. Page 273s Build_MatchMany_Function() is particularly
interesting. A complete citation of this book is given in
perlfaq2.</p>

<p>Passing Methods To pass an object method into a
subroutine, you can do this:</p>

<p>call_a_lot(10, $some_obj, &quot;methname&quot;) sub
call_a_lot { my ($count, $widget, $trick) = @_; for (my $i =
0; $i &lt; $count; $i++) { $widget-&gt;$trick(); } }</p>

<p>Or, you can use a closure to bundle up the object, its
method call, and arguments:</p>

<p>my $whatnot = sub { $some_obj-&gt;obfuscate(@args) };
func($whatnot); sub func { my $code = shift; &amp;$code();
}</p>

<p>You could also investigate the can() method in the
UNIVERSAL class (part of the standard perl
distribution).</p>

<p>How do I create a static variable? (contributed by brian
d foy)</p>

<p>In Perl 5.10, declare the variable with
&quot;state&quot;. The &quot;state&quot; declaration creates
the lexical variable that persists between calls to the
subroutine:</p>

<p>sub counter { state $count = 1; $counter++ }</p>

<p>You can fake a static variable by using a lexical
variable which goes out of scope. In this example, you
define the subroutine &quot;counter&quot;, and it uses the
lexical variable $count. Since you wrap this in a BEGIN
block, $count is defined at compile-time, but also goes out
of scope at the end of the BEGIN block. The BEGIN block also
ensures that the subroutine and the value it uses is defined
at compile-time so the subroutine is ready to use just like
any other subroutine, and you can put this code in the same
place as other subroutines in the program text (i.e. at the
end of the code, typically). The subroutine
&quot;counter&quot; still has a reference to the data, and
is the only way you can access the value (and each time you
do, you increment the value). The data in chunk of memory
defined by $count is private to &quot;counter&quot;.</p>

<p>BEGIN { my $count = 1; sub counter { $count++ } }</p>

<p>my $start = counter();</p>

<p>.... # code that calls counter();</p>

<p>my $end = counter();</p>

<p>In the previous example, you created a function-private
variable because only one function remembered its reference.
You could define multiple functions while the variable is in
scope, and each function can share the &quot;private&quot;
variable. Its not really &quot;static&quot; because you can
access it outside the function while the lexical variable is
in scope, and even create references to it. In this example,
&quot;increment_count&quot; and &quot;return_count&quot;
share the variable. One function adds to the value and the
other simply returns the value. They can both access $count,
and since it has gone out of scope, there is no other way to
access it.</p>

<p>BEGIN { my $count = 1; sub increment_count { $count++ }
sub return_count { $count } }</p>

<p>To declare a file-private variable, you still use a
lexical variable. A file is also a scope, so a lexical
variable defined in the file cannot be seen from any other
file.</p>

<p>See &quot;Persistent Private Variables&quot; in perlsub
for more information. The discussion of closures in perlref
may help you even though we did not use anonymous
subroutines in this answer. See &quot;Persistent Private
Variables&quot; in perlsub for details.</p>

<p>Whas the difference between dynamic and lexical (static)
scoping? Between local() and my()? &quot;local($x)&quot;
saves away the old value of the global variable $x and
assigns a new value for the duration of the subroutine which
is visible in other functions called from that subroutine.
This is done at run- time, so is called dynamic scoping.
local() always affects global variables, also called package
variables or dynamic variables.</p>

<p>&quot;my($x)&quot; creates a new variable that is only
visible in the current subroutine. This is done at
compile-time, so it is called lexical or static scoping.
my() always affects private variables, also called lexical
variables or (improperly) static(ly scoped) variables.</p>

<p>For instance:</p>

<p>sub visible { print &quot;var has value $var0; }</p>

<p>sub dynamic { local $var = &rsquo;local&rsquo;; # new
temporary value for the still-global visible(); # variable
called $var }</p>

<p>sub lexical { my $var = &rsquo;private&rsquo;; # new
private variable, $var visible(); # (invisible outside of
sub scope) }</p>

<p>$var = &rsquo;global&rsquo;;</p>

<p>visible(); # prints global dynamic(); # prints local
lexical(); # prints global</p>

<p>Notice how at no point does the value
&quot;private&quot; get printed. Thats because $var only has
that value within the block of the lexical() function, and
it is hidden from called subroutine.</p>

<p>In summary, local() doesnt make what you think of as
private, local variables. It gives a global variable a
temporary value. my() is what youre looking for if you want
private variables.</p>

<p>See &quot;Private Variables via my()&quot; in perlsub
and &quot;Temporary Values via local()&quot; in perlsub for
excruciating details.</p>

<p>How can I access a dynamic variable while a similarly
named lexical is in scope? If you know your package, you can
just mention it explicitly, as in $Some_Pack::var. Note that
the notation $::var is not the dynamic $var in the current
package, but rather the one in the &quot;main&quot; package,
as though you had written $main::var.</p>

<p>use vars &rsquo;$var&rsquo;; local $var =
&quot;global&quot;; my $var = &quot;lexical&quot;;</p>

<p>print &quot;lexical is $var0; print &quot;global is
$main::var0;</p>

<p>Alternatively you can use the compiler directive our()
to bring a dynamic variable into the current lexical
scope.</p>

<p>require 5.006; # our() did not exist before 5.6 use vars
&rsquo;$var&rsquo;;</p>

<p>local $var = &quot;global&quot;; my $var =
&quot;lexical&quot;;</p>

<p>print &quot;lexical is $var0;</p>

<p>{ our $var; print &quot;global is $var0; }</p>

<p>Whas the difference between deep and shallow binding? In
deep binding, lexical variables mentioned in anonymous
subroutines are the same ones that were in scope when the
subroutine was created. In shallow binding, they are
whichever variables with the same names happen to be in
scope when the subroutine is called. Perl always uses deep
binding of lexical variables (i.e., those created with
my()). However, dynamic variables (aka global, local, or
package variables) are effectively shallowly bound. Consider
this just one more reason not to use them. See the answer to
&quot;Whats a closure?&quot;.</p>

<p>Why doest &quot;my($foo) = &lt;FILE&gt;;&quot; work
right? &quot;my()&quot; and &quot;local()&quot; give list
context to the right hand side of &quot;=&quot;. The
&lt;FH&gt; read operation, like so many of Perl s functions
and operators, can tell which context it was called in and
behaves appropriately. In general, the scalar() function can
help. This function does nothing to the data itself
(contrary to popular myth) but rather tells its argument to
behave in whatever its scalar fashion is. If that function
doesnt have a defined scalar behavior, this of course doesnt
help you (such as with sort()).</p>

<p>To enforce scalar context in this particular case,
however, you need merely omit the parentheses:</p>

<p>local($foo) = &lt;FILE&gt;; # WRONG local($foo) =
scalar(&lt;FILE&gt;); # ok local $foo = &lt;FILE&gt;; #
right</p>

<p>You should probably be using lexical variables anyway,
although the issue is the same here:</p>

<p>my($foo) = &lt;FILE&gt;; # WRONG my $foo = &lt;FILE&gt;;
# right</p>

<p>How do I redefine a builtin function, operator, or
method? Why do you want to do that? :-)</p>

<p>If you want to override a predefined function, such as
open(), then you ll have to import the new definition from a
different module. See &quot;Overriding Built-in
Functions&quot; in perlsub. There s also an example in
&quot;Class::Template&quot; in perltoot.</p>

<p>If you want to overload a Perl operator, such as
&quot;+&quot; or &quot;**&quot;, then youll want to use the
&quot;use overload&quot; pragma, documented in overload.</p>

<p>If you re talking about obscuring method calls in parent
classes, see &quot;Overridden Methods&quot; in perltoot.</p>

<p>Whas the difference between calling a function as
&amp;foo and foo()? (contributed by brian d foy)</p>

<p>Calling a subroutine as &amp;foo with no trailing
parentheses ignores the prototype of &quot;foo&quot; and
passes it the current value of the argumet list, @_. Here s
an example; the &quot;bar&quot; subroutine calls &amp;foo,
which prints what its arguments list:</p>

<p>sub bar { &amp;foo }</p>

<p>sub foo { print &quot;Args in foo are: @_0 }</p>

<p>bar( qw( a b c ) );</p>

<p>When you call &quot;bar&quot; with arguments, you see
that &quot;foo&quot; got the same @_:</p>

<p>Args in foo are: a b c</p>

<p>Calling the subroutine with trailing parentheses, with
or without arguments, does not use the current @_ and
respects the subroutine prototype. Changing the example to
put parentheses after the call to &quot;foo&quot; changes
the program:</p>

<p>sub bar { &amp;foo() }</p>

<p>sub foo { print &quot;Args in foo are: @_0 }</p>

<p>bar( qw( a b c ) );</p>

<p>Now the output shows that &quot;foo&quot; doesnt get the
@_ from its caller.</p>

<p>Args in foo are:</p>

<p>The main use of the @_ pass-through feature is to write
subroutines whose main job it is to call other subroutines
for you. For further details, see perlsub.</p>

<p>How do I create a switch or case statement? In Perl
5.10, use the &quot;given-when&quot; construct described in
perlsyn:</p>

<p>use 5.010;</p>

<p>given ( $string ) { when( &rsquo;Fred&rsquo; ) { say
&quot;I found Fred!&quot; } when( &rsquo;Barney&rsquo; ) {
say &quot;I found Barney!&quot; } when( /Bamm-?Bamm/ ) { say
&quot;I found Bamm-Bamm!&quot; } default { say &quot;I
don&rsquo;t recognize the name!&quot; } };</p>

<p>If one wants to use pure Perl and to be compatible with
Perl versions prior to 5.10, the general answer is to use
&quot;if-elsif-else&quot;:</p>

<p>for ($variable_to_test) { if (/pat1/) { } # do something
elsif (/pat2/) { } # do something else elsif (/pat3/) { } #
do something else else { } # default }</p>

<p>Heres a simple example of a switch based on pattern
matching, lined up in a way to make it look more like a
switch statement. We ll do a multiway conditional based on
the type of reference stored in $whatchamacallit:</p>

<p>SWITCH: for (ref $whatchamacallit) {</p>

<p>/^$/ &amp;&amp; die &quot;not a reference&quot;;</p>

<p>/SCALAR/ &amp;&amp; do { print_scalar($$ref); last
SWITCH; };</p>

<p>/ARRAY/ &amp;&amp; do { print_array(@$ref); last SWITCH;
};</p>

<p>/HASH/ &amp;&amp; do { print_hash(%$ref); last SWITCH;
};</p>

<p>/CODE/ &amp;&amp; do { warn &quot;can&rsquo;t print
function ref&quot;; last SWITCH; };</p>

<p># DEFAULT</p>

<p>warn &quot;User defined type skipped&quot;;</p>

<p>}</p>

<p>See perlsyn for other examples in this style.</p>

<p>Sometimes you should change the positions of the
constant and the variable. For example, lets say you wanted
to test which of many answers you were given, but in a
case-insensitive way that also allows abbreviations. You can
use the following technique if the strings all start with
different characters or if you want to arrange the matches
so that one takes precedence over another, as
&quot;SEND&quot; has precedence over &quot;STOP&quot;
here:</p>

<p>chomp($answer = &lt;&gt;); if (&quot;SEND&quot; =~
/^Q$answer/i) { print &quot;Action is send0 } elsif
(&quot;STOP&quot; =~ /^Q$answer/i) { print &quot;Action is
stop0 } elsif (&quot;ABORT&quot; =~ /^Q$answer/i) { print
&quot;Action is abort0 } elsif (&quot;LIST&quot; =~
/^Q$answer/i) { print &quot;Action is list0 } elsif
(&quot;EDIT&quot; =~ /^Q$answer/i) { print &quot;Action is
edit0 }</p>

<p>A totally different approach is to create a hash of
function references.</p>

<p>my %commands = ( &quot;happy&quot; =&gt; joy,
&quot;sad&quot;, =&gt; sullen, &quot;done&quot; =&gt; sub {
die &quot;See ya!&quot; }, &quot;mad&quot; =&gt; angry,
);</p>

<p>print &quot;How are you? &quot;; chomp($string =
&lt;STDIN&gt;); if ($commands{$string}) {
$commands{$string}-&gt;(); } else { print &quot;No such
command: $string0; }</p>

<p>Starting from Perl 5.8, a source filter module,
&quot;Switch&quot;, can also be used to get switch and case.
Its use is now discouraged, because its not fully compatible
with the native switch of Perl 5.10, and because, as it s
implemented as a source filter, it doesnt always work as
intended when complex syntax is involved.</p>

<p>How can I catch accesses to undefined variables,
functions, or methods? The AUTOLOAD method, discussed in
&quot;Autoloading&quot; in perlsub and &quot;AUTOLOAD: Proxy
Methods&quot; in perltoot, lets you capture calls to
undefined functions and methods.</p>

<p>When it comes to undefined variables that would trigger
a warning under &quot;use warnings&quot;, you can promote
the warning to an error.</p>

<p>use warnings FATAL =&gt; qw(uninitialized);</p>

<p>Why cat a method included in this same file be found?
Some possible reasons: your inheritance is getting confused,
youve misspelled the method name, or the object is of the
wrong type. Check out perltoot for details about any of the
above cases. You may also use &quot;print ref($object)&quot;
to find out the class $object was blessed into.</p>

<p>Another possible reason for problems is because youve
used the indirect object syntax (eg, &quot;find Guru
&quot;Samy&quot;&quot;) on a class name before Perl has seen
that such a package exists. Its wisest to make sure your
packages are all defined before you start using them, which
will be taken care of if you use the &quot;use&quot;
statement instead of &quot;require&quot;. If not, make sure
to use arrow notation (eg.,
&quot;Guru-&gt;find(&quot;Samy&quot;)&quot;) instead. Object
notation is explained in perlobj.</p>

<p>Make sure to read about creating modules in perlmod and
the perils of indirect objects in &quot;Method
Invocation&quot; in perlobj.</p>

<p>How can I find out my current or calling package?
(contributed by brian d foy)</p>

<p>To find the package you are currently in, use the
special literal &quot;__PACKAGE__&quot;, as documented in
perldata. You can only use the special literals as separate
tokens, so you cant interpolate them into strings like you
can with variables:</p>

<p>my $current_package = __PACKAGE__; print &quot;I am in
package $current_package0;</p>

<p>This is different from finding out the package an object
is blessed into, which might not be the current package. For
that, use &quot;blessed&quot; from &quot;Scalar::Util&quot;,
part of the Standard Library since Perl 5.8:</p>

<p>use Scalar::Util qw(blessed); my $object_package =
blessed( $object );</p>

<p>Most of the time, you shouldnt care what package an
object is blessed into, however, as long as it claims to
inherit from that class:</p>

<p>my $is_right_class = eval { $object-&gt;isa( $package )
}; # true or false</p>

<p>If you want to find the package calling your code,
perhaps to give better diagnostics as &quot;Carp&quot; does,
use the &quot;caller&quot; built-in:</p>

<p>sub foo { my @args = ...; my( $package, $filename, $line
) = caller;</p>

<p>print &quot;I was called from package $package0; );</p>

<p>By default, your program starts in package
&quot;main&quot;, so you should always be in some package
unless someone uses the &quot;package&quot; built-in with no
namespace. See the &quot;package&quot; entry in perlfunc for
the details of empty packges.</p>

<p>How can I comment out a large block of Perl code?
(contributed by brian d foy)</p>

<p>The quick-and-dirty way to comment out more than one
line of Perl is to surround those lines with Pod directives.
You have to put these directives at the beginning of the
line and somewhere where Perl expects a new statement (so
not in the middle of statements like the # comments). You
end the comment with &quot;=cut&quot;, ending the Pod
section:</p>

<p>=pod</p>

<p>my $object = NotGonnaHappen-&gt;new();</p>

<p>ignored_sub();</p>

<p>$wont_be_assigned = 37;</p>

<p>=cut</p>

<p>The quick-and-dirty method only works well when you don
t plan to leave the commented code in the source. If a Pod
parser comes along, youre multiline comment is going to show
up in the Pod translation. A better way hides it from Pod
parsers as well.</p>

<p>The &quot;=begin&quot; directive can mark a section for
a particular purpose. If the Pod parser doesnt want to
handle it, it just ignores it. Label the comments with
&quot;comment&quot;. End the comment using &quot;=end&quot;
with the same label. You still need the &quot;=cut&quot; to
go back to Perl code from the Pod comment:</p>

<p>=begin comment</p>

<p>my $object = NotGonnaHappen-&gt;new();</p>

<p>ignored_sub();</p>

<p>$wont_be_assigned = 37;</p>

<p>=end comment</p>

<p>=cut</p>

<p>For more information on Pod, check out perlpod and
perlpodspec.</p>

<p>How do I clear a package? Use this code, provided by
Mark-Jason Dominus:</p>

<p>sub scrub_package { no strict &rsquo;refs&rsquo;; my
$pack = shift; die &quot;Shouldn&rsquo;t delete main
package&quot; if $pack eq &quot;&quot; || $pack eq
&quot;main&quot;; my $stash = *{$pack .
&rsquo;::&rsquo;}{HASH}; my $name; foreach $name (keys
%$stash) { my $fullname = $pack . &rsquo;::&rsquo; . $name;
# Get rid of everything with that name. undef $$fullname;
undef @$fullname; undef %$fullname; undef &amp;$fullname;
undef *$fullname; } }</p>

<p>Or, if youre using a recent release of Perl, you can
just use the Symbol::delete_package() function instead.</p>

<p>How can I use a variable as a variable name? Beginners
often think they want to have a variable contain the name of
a variable.</p>

<p>$fred = 23; $varname = &quot;fred&quot;; ++$$varname; #
$fred now 24</p>

<p>This works sometimes, but it is a very bad idea for two
reasons.</p>

<p>The first reason is that this technique only works on
global variables. That means that if $fred is a lexical
variable created with my() in the above example, the code
wouldn t work at all: you d accidentally access the global
and skip right over the private lexical altogether. Global
variables are bad because they can easily collide
accidentally and in general make for non-scalable and
confusing code.</p>

<p>Symbolic references are forbidden under the &quot;use
strict&quot; pragma. They are not true references and
consequently are not reference counted or garbage
collected.</p>

<p>The other reason why using a variable to hold the name
of another variable is a bad idea is that the question often
stems from a lack of understanding of Perl data structures,
particularly hashes. By using symbolic references, you are
just using the package s symbol-table hash (like %main::)
instead of a user-defined hash. The solution is to use your
own hash or a real reference instead.</p>

<p>$USER_VARS{&quot;fred&quot;} = 23; $varname =
&quot;fred&quot;; $USER_VARS{$varname}++; # not
$$varname++</p>

<p>There were using the %USER_VARS hash instead of symbolic
references. Sometimes this comes up in reading strings from
the user with variable references and wanting to expand them
to the values of your perl program s variables. This is also
a bad idea because it conflates the program-addressable
namespace and the user-addressable one. Instead of reading a
string and expanding it to the actual contents of your
programs own variables:</p>

<p>$str = &rsquo;this has a $fred and $barney in it&rsquo;;
$str =~ s/(w+)/$1/eeg; # need double eval</p>

<p>it would be better to keep a hash around like %USER_VARS
and have variable references actually refer to entries in
that hash:</p>

<p>$str =~ s/+)/$USER_VARS{$1}/g; # no /e here at all</p>

<p>That s faster, cleaner, and safer than the previous
approach. Of course, you dont need to use a dollar sign. You
could use your own scheme to make it less confusing, like
bracketed percent symbols, etc.</p>

<p>$str = &rsquo;this has a %fred% and %barney% in
it&rsquo;; $str =~ s/%(1008</p>

<p>Another reason that folks sometimes think they want a
variable to contain the name of a variable is because they
don t know how to build proper data structures using hashes.
For example, lets say they wanted two hashes in their
program: %fred and %barney, and that they wanted to use
another scalar variable to refer to those by name.</p>

<p>$name = &quot;fred&quot;; $$name{WIFE} =
&quot;wilma&quot;; # set %fred</p>

<p>$name = &quot;barney&quot;; $$name{WIFE} =
&quot;betty&quot;; # set %barney</p>

<p>This is still a symbolic reference, and is still saddled
with the problems enumerated above. It would be far better
to write:</p>

<p>$folks{&quot;fred&quot;}{WIFE} = &quot;wilma&quot;;
$folks{&quot;barney&quot;}{WIFE} = &quot;betty&quot;;</p>

<p>And just use a multilevel hash to start with.</p>

<p>The only times that you absolutely must use symbolic
references are when you really must refer to the symbol
table. This may be because its something that cant take a
real reference to, such as a format name. Doing so may also
be important for method calls, since these always go through
the symbol table for resolution.</p>

<p>In those cases, you would turn off &quot;strict
&rsquo;refs&rsquo;&quot; temporarily so you can play around
with the symbol table. For example:</p>

<p>@colors = qw(red blue green yellow orange purple
violet); for my $name (@colors) { no strict
&rsquo;refs&rsquo;; # renege for the block *$name = sub {
&quot;&lt;FONT
COLOR=&rsquo;$name&rsquo;&gt;@_&lt;/FONT&gt;&quot; }; }</p>

<p>All those functions (red(), blue(), green(), etc.)
appear to be separate, but the real code in the closure
actually was compiled only once.</p>

<p>So, sometimes you might want to use symbolic references
to directly manipulate the symbol table. This doesn t matter
for formats, handles, and subroutines, because they are
always global--you cant use my() on them. For scalars,
arrays, and hashes, though--and usually for subroutines--
you probably only want to use hard references.</p>

<p>What does &quot;bad interpreter&quot; mean? (contributed
by brian d foy)</p>

<p>The &quot;bad interpreter&quot; message comes from the
shell, not perl. The actual message may vary depending on
your platform, shell, and locale settings.</p>

<p>If you see &quot;bad interpreter - no such file or
directory&quot;, the first line in your perl script (the
&quot;shebang&quot; line) does not contain the right path to
perl (or any other program capable of running scripts).
Sometimes this happens when you move the script from one
machine to another and each machine has a different path to
perl--/usr/bin/perl versus /usr/local/bin/perl for instance.
It may also indicate that the source machine has CRLF line
terminators and the destination machine has LF only: the
shell tries to find /usr/bin/perl&lt;CR&gt;, but cant.</p>

<p>If you see &quot;bad interpreter: Permission
denied&quot;, you need to make your script executable.</p>

<p>In either case, you should still be able to run the
scripts with perl explicitly:</p>

<p>% perl script.pl</p>

<p>If you get a message like &quot;perl: command not
found&quot;, perl is not in your PATH, which might also mean
that the location of perl is not where you expect it so you
need to adjust your shebang line.</p>

<p>REVISION Revision: $Revision$</p>

<p>Date: $Date$</p>

<p>See perlfaq for source control details and
availability.</p>

<p>AUTHOR AND COPYRIGHT Copyright (c) 1997-2009 Tom
Christiansen, Nathan Torkington, and other authors as noted.
All rights reserved.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
this file are hereby placed into the public domain. You are
permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>perl v5.10.1 2009-08-15 PERLFAQ7(1)</p>
<hr>
</body>
</html>
