<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:07:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MOUNT.CIFS(8) System Administration tools
MOUNT.CIFS(8)</p>

<p>NAME mount.cifs - mount using the Common Internet File
System (CIFS)</p>

<p>SYNOPSIS mount.cifs {service} {mount-point} [-o
options]</p>

<p>DESCRIPTION This tool is part of the cifs-utils
suite.</p>

<p>mount.cifs mounts a Linux CIFS filesystem. It is usually
invoked indirectly by the mount(8) command when using the
&quot;-t cifs&quot; option. This command only works in
Linux, and the kernel must support the cifs filesystem. The
CIFS protocol is the successor to the SMB protocol and is
supported by most Windows servers and many other commercial
servers and Network Attached Storage appliances as well as
by the popular Open Source server Samba.</p>

<p>The mount.cifs utility attaches the UNC name (exported
network resource) specified as service (using //server/share
syntax, where &quot;server&quot; is the server name or IP
address and &quot;share&quot; is the name of the share) to
the local directory mount-point.</p>

<p>Options to mount.cifs are specified as a comma-separated
list of key=value pairs. It is possible to send options
other than those listed here, assuming that the cifs
filesystem kernel module (cifs.ko) supports them.
Unrecognized cifs mount options passed to the cifs vfs
kernel code will be logged to the kernel log.</p>

<p>mount.cifs causes the cifs vfs to launch a thread named
cifsd. After mounting it keeps running until the mounted
resource is unmounted (usually via the umount utility).</p>

<p>mount.cifs -V command displays the version of cifs mount
helper.</p>

<p>modinfo cifs command displays the version of cifs
module.</p>

<p>OPTIONS user=arg specifies the username to connect as.
If this is not given, then the environment variable USER is
used. This option can also take the form
&quot;user%password&quot; or &quot;workgroup/user&quot; or
&quot;workgroup/user%password&quot; to allow the password
and workgroup to be specified as part of the username.</p>

<p>Note The cifs vfs accepts the parameter user=, or for
users familiar with smbfs it accepts the longer form of the
parameter username=. Similarly the longer smbfs style
parameter names may be accepted as synonyms for the shorter
cifs parameters pass=,dom= and cred=.</p>

<p>password=arg specifies the CIFS password. If this option
is not given then the environment variable PASSWD is used.
If the password is not specified directly or indirectly via
an argument to mount, mount.cifs will prompt for a password,
unless the guest option is specified.</p>

<p>Note that a password which contains the delimiter
character (i.e. a comma &acute;,&acute;) will fail to be
parsed correctly on the command line. However, the same
password defined in the PASSWD environment variable or via a
credentials file (see below) or entered at the password
prompt will be read correctly.</p>

<p>credentials=filename specifies a file that contains a
username and/or password and optionally the name of the
workgroup. The format of the file is:</p>

<p>username=value password=value domain=value</p>

<p>This is preferred over having passwords in plaintext in
a shared file, such as /etc/fstab. Be sure to protect any
credentials file properly.</p>

<p>uid=arg sets the uid that will own all files or
directories on the mounted filesystem when the server does
not provide ownership information. It may be specified as
either a username or a numeric uid. When not specified, the
default is uid 0. The mount.cifs helper must be at version
1.10 or higher to support specifying the uid in non-numeric
form. See the section on FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS below for more information.</p>

<p>forceuid instructs the client to ignore any uid provided
by the server for files and directories and to always assign
the owner to be the value of the uid= option. See the
section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS
below for more information.</p>

<p>gid=arg sets the gid that will own all files or
directories on the mounted filesystem when the server does
not provide ownership information. It may be specified as
either a groupname or a numeric gid. When not specified, the
default is gid 0. The mount.cifs helper must be at version
1.10 or higher to support specifying the gid in non-numeric
form. See the section on FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS below for more information.</p>

<p>forcegid instructs the client to ignore any gid provided
by the server for files and directories and to always assign
the owner to be the value of the gid= option. See the
section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS
below for more information.</p>

<p>port=arg sets the port number on the server to attempt
to contact to negotiate CIFS support. If the CIFS server is
not listening on this port or if it is not specified, the
default ports will be tried i.e. port 445 is tried and if no
response then port 139 is tried.</p>

<p>servern=arg Specify the server netbios name (RFC1001
name) to use when attempting to setup a session to the
server. Although rarely needed for mounting to newer
servers, this option is needed for mounting to some older
servers (such as OS/2 or Windows 98 and Windows ME) since
when connecting over port 139 they, unlike most newer
servers, do not support a default server name. A server name
can be up to 15 characters long and is usually
uppercased.</p>

<p>netbiosname=arg When mounting to servers via port 139,
specifies the RFC1001 source name to use to represent the
client netbios machine name when doing the RFC1001 netbios
session initialize.</p>

<p>file_mode=arg If the server does not support the CIFS
Unix extensions this overrides the default file mode.</p>

<p>dir_mode=arg If the server does not support the CIFS
Unix extensions this overrides the default mode for
directories.</p>

<p>ip=arg sets the destination IP address. This option is
set automatically if the server name portion of the
requested UNC name can be resolved so rarely needs to be
specified by the user.</p>

<p>domain=arg sets the domain (workgroup) of the user</p>

<p>guest don&acute;t prompt for a password</p>

<p>iocharset Charset used to convert local path names to
and from Unicode. Unicode is used by default for network
path names if the server supports it. If iocharset is not
specified then the nls_default specified during the local
client kernel build will be used. If server does not support
Unicode, this parameter is unused.</p>

<p>ro mount read-only</p>

<p>rw mount read-write</p>

<p>setuids If the CIFS Unix extensions are negotiated with
the server the client will attempt to set the effective uid
and gid of the local process on newly created files,
directories, and devices (create, mkdir, mknod). If the CIFS
Unix Extensions are not negotiated, for newly created files
and directories instead of using the default uid and gid
specified on the the mount, cache the new file&acute;s uid
and gid locally which means that the uid for the file can
change when the inode is reloaded (or the user remounts the
share).</p>

<p>nosetuids The client will not attempt to set the uid and
gid on on newly created files, directories, and devices
(create, mkdir, mknod) which will result in the server
setting the uid and gid to the default (usually the server
uid of the user who mounted the share). Letting the server
(rather than the client) set the uid and gid is the
default.If the CIFS Unix Extensions are not negotiated then
the uid and gid for new files will appear to be the uid
(gid) of the mounter or the uid (gid) parameter specified on
the mount.</p>

<p>perm Client does permission checks (vfs_permission check
of uid and gid of the file against the mode and desired
operation), Note that this is in addition to the normal ACL
check on the target machine done by the server software.
Client permission checking is enabled by default.</p>

<p>noperm Client does not do permission checks. This can
expose files on this mount to access by other users on the
local client system. It is typically only needed when the
server supports the CIFS Unix Extensions but the UIDs/GIDs
on the client and server system do not match closely enough
to allow access by the user doing the mount. Note that this
does not affect the normal ACL check on the target machine
done by the server software (of the server ACL against the
user name provided at mount time).</p>

<p>dynperm Instructs the server to maintain ownership and
permissions in memory that can&acute;t be stored on the
server. This information can disappear at any time (whenever
the inode is flushed from the cache), so while this may help
make some applications work, it&acute;s behavior is somewhat
unreliable. See the section below on FILE AND DIRECTORY
OWNERSHIP AND PERMISSIONS for more information.</p>

<p>directio Do not do inode data caching on files opened on
this mount. This precludes mmaping files on this mount. In
some cases with fast networks and little or no caching
benefits on the client (e.g. when the application is doing
large sequential reads bigger than page size without
rereading the same data) this can provide better performance
than the default behavior which caches reads (readahead) and
writes (writebehind) through the local Linux client
pagecache if oplock (caching token) is granted and held.
Note that direct allows write operations larger than page
size to be sent to the server. On some kernels this requires
the cifs.ko module to be built with the CIFS_EXPERIMENTAL
configure option.</p>

<p>mapchars Translate six of the seven reserved characters
(not backslash, but including the colon, question mark,
pipe, asterik, greater than and less than characters) to the
remap range (above 0xF000), which also allows the CIFS
client to recognize files created with such characters by
Windows&acute;s POSIX emulation. This can also be useful
when mounting to most versions of Samba (which also forbids
creating and opening files whose names contain any of these
seven characters). This has no effect if the server does not
support Unicode on the wire. Please note that the files
created with mapchars mount option may not be accessible if
the share is mounted without that option.</p>

<p>nomapchars Do not translate any of these seven
characters (default)</p>

<p>intr currently unimplemented</p>

<p>nointr (default) currently unimplemented</p>

<p>hard The program accessing a file on the cifs mounted
file system will hang when the server crashes.</p>

<p>soft (default) The program accessing a file on the cifs
mounted file system will not hang when the server crashes
and will return errors to the user application.</p>

<p>noacl Do not allow POSIX ACL operations even if server
would support them.</p>

<p>The CIFS client can get and set POSIX ACLs (getfacl,
setfacl) to Samba servers version 3.0.10 and later. Setting
POSIX ACLs requires enabling both XATTR and then POSIX
support in the CIFS configuration options when building the
cifs module. POSIX ACL support can be disabled on a per
mount basis by specifying &quot;noacl&quot; on mount.</p>

<p>nocase Request case insensitive path name matching (case
sensitive is the default if the server suports it).</p>

<p>sec= Security mode. Allowed values are:</p>

<p>&middot; none attempt to connection as a null user (no
name)</p>

<p>&middot; krb5 Use Kerberos version 5 authentication</p>

<p>&middot; krb5i Use Kerberos authentication and packet
signing</p>

<p>&middot; ntlm Use NTLM password hashing (default)</p>

<p>&middot; ntlmi Use NTLM password hashing with signing
(if /proc/fs/cifs/PacketSigningEnabled on or if server
requires signing also can be the default)</p>

<p>&middot; ntlmv2 Use NTLMv2 password hashing</p>

<p>&middot; ntlmv2i Use NTLMv2 password hashing with packet
signing</p>

<p>[NB This [sec parameter] is under development and
expected to be available in cifs kernel module 1.40 and
later]</p>

<p>nobrl Do not send byte range lock requests to the
server. This is necessary for certain applications that
break with cifs style mandatory byte range locks (and most
cifs servers do not yet support requesting advisory byte
range locks).</p>

<p>sfu When the CIFS Unix Extensions are not negotiated,
attempt to create device files and fifos in a format
compatible with Services for Unix (SFU). In addition
retrieve bits 10-12 of the mode via the SETFILEBITS extended
attribute (as SFU does). In the future the bottom 9 bits of
the mode mode also will be emulated using queries of the
security descriptor (ACL). [NB: requires version 1.39 or
later of the CIFS VFS. To recognize symlinks and be able to
create symlinks in an SFU interoperable form requires
version 1.40 or later of the CIFS VFS kernel module.</p>

<p>serverino Use inode numbers (unique persistent file
identifiers) returned by the server instead of automatically
generating temporary inode numbers on the client. Although
server inode numbers make it easier to spot hardlinked files
(as they will have the same inode numbers) and inode numbers
may be persistent (which is userful for some sofware), the
server does not guarantee that the inode numbers are unique
if multiple server side mounts are exported under a single
share (since inode numbers on the servers might not be
unique if multiple filesystems are mounted under the same
shared higher level directory). Note that not all servers
support returning server inode numbers, although those that
support the CIFS Unix Extensions, and Windows 2000 and later
servers typically do support this (although not necessarily
on every local server filesystem). Parameter has no effect
if the server lacks support for returning inode numbers or
equivalent.</p>

<p>noserverino Client generates inode numbers (rather than
using the actual one from the server) by default.</p>

<p>See section INODE NUMBERS for more information.</p>

<p>nounix Disable the CIFS Unix Extensions for this mount.
This can be useful in order to turn off multiple settings at
once. This includes POSIX acls, POSIX locks, POSIX paths,
symlink support and retrieving uids/gids/mode from the
server. This can also be useful to work around a bug in a
server that supports Unix Extensions.</p>

<p>See section INODE NUMBERS for more information.</p>

<p>nouser_xattr (default) Do not allow getfattr/setfattr to
get/set xattrs, even if server would support it
otherwise.</p>

<p>rsize=arg default network read size (usually 16K). The
client currently can not use rsize larger than
CIFSMaxBufSize. CIFSMaxBufSize defaults to 16K and may be
changed (from 8K to the maximum kmalloc size allowed by your
kernel) at module install time for cifs.ko. Setting
CIFSMaxBufSize to a very large value will cause cifs to use
more memory and may reduce performance in some cases. To use
rsize greater than 127K (the original cifs protocol maximum)
also requires that the server support a new Unix Capability
flag (for very large read) which some newer servers (e.g.
Samba 3.0.26 or later) do. rsize can be set from a minimum
of 2048 to a maximum of 130048 (127K or CIFSMaxBufSize,
whichever is smaller)</p>

<p>wsize=arg default network write size (default 57344)
maximum wsize currently allowed by CIFS is 57344 (fourteen
4096 byte pages)</p>

<p>--verbose Print additional debugging information for the
mount. Note that this parameter must be specified before the
-o. For example:</p>

<p>mount -t cifs //server/share /mnt --verbose -o
user=username</p>

<p>SERVICE FORMATTING AND DELIMITERS It&acute;s generally
preferred to use forward slashes (/) as a delimiter in
service names. They are considered to be the &quot;universal
delimiter&quot; since they are generally not allowed to be
embedded within path components on Windows machines and the
client can convert them to blackslashes ( unconditionally.
Conversely, backslash characters are allowed by POSIX to be
part of a path component, and can&acute;t be automatically
converted in the same way.</p>

<p>mount.cifs will attempt to convert backslashes to
forward slashes where it&acute;s able to do so, but it
cannot do so in any path component following the
sharename.</p>

<p>INODE NUMBERS When Unix Extensions are enabled, we use
the actual inode number provided by the server in response
to the POSIX calls as an inode number.</p>

<p>When Unix Extensions are disabled and
&quot;serverino&quot; mount option is enabled there is no
way to get the server inode number. The client typically
maps the server-assigned &quot;UniqueID&quot; onto an inode
number.</p>

<p>Note that the UniqueID is a different value from the
server inode number. The UniqueID value is unique over the
scope of the entire server and is often greater than 2 power
32. This value often makes programs that are not compiled
with LFS (Large File Support), to trigger a glibc EOVERFLOW
error as this won&acute;t fit in the target structure field.
It is strongly recommended to compile your programs with LFS
support (i.e. with -D_FILE_OFFSET_BITS=64) to prevent this
problem. You can also use &quot;noserverino&quot; mount
option to generate inode numbers smaller than 2 power 32 on
the client. But you may not be able to detect hardlinks
properly.</p>

<p>FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS The core
CIFS protocol does not provide unix ownership information or
mode for files and directories. Because of this, files and
directories will generally appear to be owned by whatever
values the uid= or gid= options are set, and will have
permissions set to the default file_mode and dir_mode for
the mount. Attempting to change these values via chmod/chown
will return success but have no effect.</p>

<p>When the client and server negotiate unix extensions,
files and directories will be assigned the uid, gid, and
mode provided by the server. Because CIFS mounts are
generally single-user, and the same credentials are used no
matter what user accesses the mount, newly created files and
directories will generally be given ownership corresponding
to whatever credentials were used to mount the share.</p>

<p>If the uid&acute;s and gid&acute;s being used do not
match on the client and server, the forceuid and forcegid
options may be helpful. Note however, that there is no
corresponding option to override the mode. Permissions
assigned to a file when forceuid or forcegid are in effect
may not reflect the the real permissions.</p>

<p>When unix extensions are not negotiated, it&acute;s also
possible to emulate them locally on the server using the
&quot;dynperm&quot; mount option. When this mount option is
in effect, newly created files and directories will receive
what appear to be proper permissions. These permissions are
not stored on the server however and can disappear at any
time in the future (subject to the whims of the kernel
flushing out the inode cache). In general, this mount option
is discouraged.</p>

<p>It&acute;s also possible to override permission checking
on the client altogether via the noperm option. Server-side
permission checks cannot be overriden. The permission checks
done by the server will always correspond to the credentials
used to mount the share, and not necessarily to the user who
is accessing the share.</p>

<p>ENVIRONMENT VARIABLES The variable USER may contain the
username of the person to be used to authenticate to the
server. The variable can be used to set both username and
password by using the format username%password.</p>

<p>The variable PASSWD may contain the password of the
person using the client.</p>

<p>The variable PASSWD_FILE may contain the pathname of a
file to read the password from. A single line of input is
read and used as the password.</p>

<p>NOTES This command may be used only by root, unless
installed setuid, in which case the noeexec and nosuid mount
flags are enabled. When installed as a setuid program, the
program follows the conventions set forth by the mount
program for user mounts.</p>

<p>Some samba client tools like smbclient(8) honour
client-side configuration parameters present in smb.conf.
Unlike those client tools, mount.cifs ignores smb.conf
completely.</p>

<p>CONFIGURATION The primary mechanism for making
configuration changes and for reading debug information for
the cifs vfs is via the Linux /proc filesystem. In the
directory /proc/fs/cifs are various configuration files and
pseudo files which can display debug information. There are
additional startup options such as maximum buffer size and
number of buffers which only may be set when the kernel cifs
vfs (cifs.ko module) is loaded. These can be seen by running
the modinfo utility against the file cifs.ko which will list
the options that may be passed to cifs during module
installation (device driver load). For more information see
the kernel file fs/cifs/README.</p>

<p>BUGS Mounting using the CIFS URL specification is
currently not supported.</p>

<p>The credentials file does not handle usernames or
passwords with leading space.</p>

<p>Note that the typical response to a bug report is a
suggestion to try the latest version first. So please try
doing that first, and always include which versions you use
of relevant software when reporting bugs (minimum:
mount.cifs (try mount.cifs -V), kernel (see /proc/version)
and server type you are trying to contact.</p>

<p>VERSION This man page is correct for version 1.52 of the
cifs vfs filesystem (roughly Linux kernel 2.6.24).</p>

<p>SEE ALSO Documentation/filesystems/cifs.txt and
fs/cifs/README in the linux kernel source tree may contain
additional options and information.</p>

<p>umount.cifs(8)</p>

<p>AUTHOR Steve French</p>

<p>The syntax and manpage were loosely based on that of
smbmount. It was converted to Docbook/XML by Jelmer
Vernooij.</p>

<p>The maintainer of the Linux cifs vfs and the userspace
tool mount.cifs is Steve French. The Linux CIFS Mailing list
is the preferred place to ask questions regarding these
programs.</p>

<p>cifs-utils 4.0 02/07/2010 MOUNT.CIFS(8)</p>
<hr>
</body>
</html>
