<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:24:29 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_LOCK_DEVICE_FOR_(9) USB Core APIs
USB_LOCK_DEVICE_FOR_(9)</p>

<p>NAME usb_lock_device_for_reset - cautiously acquire the
lock for a usb device structure</p>

<p>SYNOPSIS int usb_lock_device_for_reset(struct usb_device
* udev, const struct usb_interface * iface);</p>

<p>ARGUMENTS udev device that&acute;s being locked</p>

<p>iface interface bound to the driver making the request
(optional)</p>

<p>DESCRIPTION Attempts to acquire the device lock, but
fails if the device is NOTATTACHED or SUSPENDED, or if iface
is specified and the interface is neither BINDING nor BOUND.
Rather than sleeping to wait for the lock, the routine polls
repeatedly. This is to prevent deadlock with disconnect; in
some drivers (such as usb-storage) the disconnect or suspend
method will block waiting for a device reset to
complete.</p>

<p>Returns a negative error code for failure, otherwise
0.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
USB_LOCK_DEVICE_FOR_(9)</p>
<hr>
</body>
</html>
