<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TAPSET::SOCKET(3stap) TAPSET::SOCKET(3stap)</p>

<p>NAME tapset::socket - systemtap socket probe points</p>

<p>DESCRIPTION This family of probe points is used to probe
socket activities. It contains the following probe
points:</p>

<p>socket.send</p>

<p>Fires at the conclusion of sending a message on a
socket. This probe alias includes the socket.sendmsg.return,
socket.aio_write.return and socket.writev.return probes
(these probes should catch all messages sent on sockets).
The argu- ments supplied at the beginning of the send are
cached and made available in this probe.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>name Name of this probe.</p>

<p>size Size of message sent (in bytes) or error code if
success == 0</p>

<p>protocol Protocol used on the socket. Use
sock_prot_num2str(protocol) to convert to a string.</p>

<p>Common values include: 0 - IP (Internet Protocol, local
interprocess communi- cations) 6 - TCP (Transmission Control
Protocol) 17 - UDP (User Datagram Protocol) 132 - SCTP
(Stream Control Transmission Protocol)</p>

<p>Refer to /etc/protocols for a complete list of possible
values.</p>

<p>family Protocol family of the socket (from
include/linux/socket.h). Use sock_fam_num2str(family) to
convert to a string.</p>

<p>Possible values are: 0 - UNSPEC (Unspecified) 1 - LOCAL
(Unix domain/local sockets) 2 - INET (Internet Protocol
(IP)) 3 - AX25 (Amateur Radio AX.25) 4 - IPX (Novell IPX) 5
- APPLETALK (AppleTalk DDP) 6 - NETROM (Amateur Radio
NET/ROM) 7 - BRIDGE (Multiprotocol bridge) 8 - ATMPVC (ATM
PVCs) 9 - X25 (X.25) 10 - INET6 (IP version 6) 11 - ROSE
(Amateur Radio X.25 PLP) 12 - DECNET (Reserved for DECnet
project) 13 - NETBEUI (Reserved for 802.2LLC project) 14 -
SECURITY (Security callback pseudo AF) 15 - KEY (key
management API) 16 - NETLINK (Netlink protocol) 17 - PACKET
(Packet family) 18 - ASH (Ash) 19 - ECONET (Acorn Econet) 20
- ATMSVC (ATM SVCs) 22 - SNA (Linux SNA Project) 23 - IRDA
(IRDA sockets) 24 - PPP0X (PPPoX sockets) 25 - WANPIPE
(Wanpipe API Sockets) 26 - LLC (Linux LLC) 30 - TIPC (TIPC
sockets) 31 - BLUETOOTH (Bluetooth sockets)</p>

<p>state State of the socket. Use sock_state_num2str(state)
to con- vert to a string.</p>

<p>Possible values are: 0 - FREE (not allocated) 1 -
UNCONNECTED (unconnected to any socket) 2 - CONNECTING (in
the process of connecting) 3 - CONNECTED (connected to a
socket) 4 - DISCONNECTING (in the process of
disconnecting)</p>

<p>flags Socket flags. Use sock_flags_num2str(flags) to
convert to a string.</p>

<p>Possible values are: 0 - ASYNC_NOSPACE 1 -
ASYNC_WAITDATA 2 - NOSPACE 3 - PASSCRED 4 - PASSSEC</p>

<p>type Socket type. Use sock_type_num2str(type) to convert
to a string.</p>

<p>Possible values are: 1 - STREAM (stream connection
socket) 2 - DGRAM (datagram connectionless socket) 3 - RAW
(raw socket) 4 - RDM (reliably-deliverd message) 5 -
SEQPACKET (sequential packet socket) 6 - DCCP (datagram
congestion control protocol socket) 10 - PACKET
(Linux-specific way of getting packets at device level)</p>

<p>success Was send successful?</p>

<p>Possible values are: 1 - Yes 0 - No</p>

<p>socket.receive</p>

<p>Fires at the conclusion of receiving a message on a
socket. This probe alias includes the socket.recvmsg.return,
socket.aio_read.return and socket.readv.return probes (these
probes should catch all messages received on sockets). The
arguments supplied at the beginning of the receive are
cached and made available in this probe.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.send.</p>

<p>socket.sendmsg</p>

<p>Fires when the sock_sendmsg() kernel function is
entered.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send, with the following exceptions:</p>

<p>size</p>

<p>Size of message being sent (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.sendmsg.return</p>

<p>Fires when the sock_sendmsg() kernel function
returns.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send</p>

<p>socket.recvmsg</p>

<p>Fires when the sock_recvmsg() kernel function is
entered.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive, with the following
exceptions:</p>

<p>size</p>

<p>Size of message being received (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.recvmsg.return</p>

<p>Fires when the sock_recvmsg() kernel function
returns.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive.</p>

<p>socket.aio_write</p>

<p>Fires when the sock_aio_write() kernel function is
entered.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send, with the following exceptions:</p>

<p>size</p>

<p>Size of message being sent (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.aio_write.return</p>

<p>Fires when the sock_aio_write() kernel function
returns.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send.</p>

<p>socket.aio_read</p>

<p>Fires when the sock_aio_read() kernel function is
entered.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive, with the following
exceptions:</p>

<p>size</p>

<p>Size of message being received (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.aio_read.return</p>

<p>Fires when the sock_aio_read() kernel function
returns.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive.</p>

<p>socket.writev</p>

<p>Fires when the sock_writev() kernel function is
entered.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send, with the following exceptions:</p>

<p>size</p>

<p>Size of message being sent (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.writev.return</p>

<p>Fires when the sock_writev() kernel function
returns.</p>

<p>Context:</p>

<p>The message sender.</p>

<p>Arguments:</p>

<p>Same as socket.send.</p>

<p>socket.readv</p>

<p>Fires when the sock_readv() kernel function is
entered.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive, with the following
exceptions:</p>

<p>size</p>

<p>Size of message being received (in bytes).</p>

<p>success</p>

<p>Not used.</p>

<p>socket.readv.return</p>

<p>Fires when the sock_readv() kernel function returns.</p>

<p>Context:</p>

<p>The message receiver.</p>

<p>Arguments:</p>

<p>Same as socket.receive.</p>

<p>socket.create</p>

<p>Fires at the beginning of creating a socket.</p>

<p>Context:</p>

<p>The socket creator.</p>

<p>Arguments:</p>

<p>name protocol family type See socket.send.</p>

<p>requester Requester type.</p>

<p>Possible values are: 1 - kernel 0 - user</p>

<p>socket.create.return</p>

<p>Fires at the end of creating a socket.</p>

<p>Context:</p>

<p>The socket creator.</p>

<p>Arguments:</p>

<p>Same as socket.create, plus:</p>

<p>err Return code.</p>

<p>Possible values are: 0 - success &lt; 0 - error</p>

<p>success Was the socket created successfully?</p>

<p>Possible values are: 1 - Yes 0 - No</p>

<p>socket.close</p>

<p>Fires at the beginning of closing a socket.</p>

<p>Context:</p>

<p>The socket closer.</p>

<p>Arguments:</p>

<p>name protocol family state flags type See
socket.send.</p>

<p>socket.close.return</p>

<p>Fires at the end of closing a socket.</p>

<p>Context:</p>

<p>The socket closer.</p>

<p>Arguments:</p>

<p>name Name of this probe.</p>

<p>SEE ALSO stap(1), stapprobes(3stap),
stapfuncs(3stap)</p>

<p>IBM TAPSET::SOCKET(3stap)</p>
<hr>
</body>
</html>
