<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:07:01 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>mathop(n) Tcl Mathematical Operator Commands
mathop(n)</p>


<p>______________________________________________________________________________</p>

<p>NAME mathop - Mathematical operators as Tcl commands</p>

<p>SYNOPSIS package require Tcl 8.5</p>

<p>::tcl::mathop::! number ::tcl::mathop::~ number
::tcl::mathop::+ ?number ...? ::tcl::mathop::- number
?number ...? ::tcl::mathop::* ?number ...? ::tcl::mathop::/
number ?number ...? ::tcl::mathop::% number number
::tcl::mathop::** ?number ...? ::tcl::mathop::&amp; ?number
...? ::tcl::mathop::| ?number ...? ::tcl::mathop::^ ?number
...? ::tcl::mathop::&lt;&lt; number number
::tcl::mathop::&gt;&gt; number number ::tcl::mathop::== ?arg
...? ::tcl::mathop::!= arg arg ::tcl::mathop::&lt; ?arg ...?
::tcl::mathop::&lt;= ?arg ...? ::tcl::mathop::&gt;= ?arg
...? ::tcl::mathop::&gt; ?arg ...? ::tcl::mathop::eq ?arg
...? ::tcl::mathop::ne arg arg ::tcl::mathop::in arg list
::tcl::mathop::ni arg list</p>


<p>_________________________________________________________________</p>

<p>DESCRIPTION The commands in the ::tcl::mathop namespace
implement the same set of operations as supported by the
expr command. All are exported from the namespace, but are
not imported into any other namespace by default. Note that
renaming, reimplementing or deleting any of the commands in
the namespace does not alter the way that the expr command
behaves, and nor does defining any new commands in the
::tcl::mathop namespace.</p>

<p>The following operator commands are supported:</p>

<p>~ ! + - * / % ** &amp; | ^ &gt;&gt; &lt;&lt; == eq != ne
&lt; &lt;= &gt; &gt;= in ni</p>

<p>MATHEMATICAL OPERATORS The behaviors of the mathematical
operator commands are as follows:</p>

<p>! boolean Returns the boolean negation of boolean, where
boolean may be any numeric value or any other form of
boolean value (i.e. it returns truth if the argument is
falsity or zero, and falsity if the argument is truth or
non-zero).</p>

<p>+ ?number ...? Returns the sum of arbitrarily many
arguments. Each number argu- ment may be any numeric value.
If no arguments are given, the result will be zero (the
summation identity).</p>

<p>- number ?number ...? If only a single number argument
is given, returns the negation of that numeric value.
Otherwise returns the number that results when all
subsequent numeric values are subtracted from the first one.
All number arguments must be numeric values. At least one
argument must be given.</p>

<p>* ?number ...? Returns the product of arbitrarily many
arguments. Each number may be any numeric value. If no
arguments are given, the result will be one (the
multiplicative identity).</p>

<p>/ number ?number ...? If only a single number argument
is given, returns the recipro- cal of that numeric value
(i.e. the value obtained by dividing 1.0 by that value).
Otherwise returns the number that results when the first
numeric argument is divided by all subsequent numeric
arguments. All number arguments must be numeric values. At
least one argument must be given.</p>

<p>Note that when the leading values in the list of
arguments are integers, integer division will be used for
those initial steps (i.e. the intermediate results will be
as if the functions floor and int are applied to them, in
that order). If all values in the operation are integers,
the result will be an integer.</p>

<p>% number number Returns the integral modulus of the
first argument with respect to the second. Each number must
have an integral value. Note that Tcl defines this operation
exactly even for negative num- bers, so that the following
equality holds true: (x / y) * y == x - (x % y)</p>

<p>** ?number ...? Returns the result of raising each value
to the power of the result of recursively operating on the
result of processing the following arguments, so ** 2 3 4 is
the same as ** 2 [** 3 4]. Each number may be any numeric
value, though the second number must not be fractional if
the first is negative. If no arguments are given, the result
will be one, and if only one argument is given, the result
will be that argument. The result will have an integral
value only when all arguments are integral values.</p>

<p>COMPARISON OPERATORS The behaviors of the comparison
operator commands (most of which oper- ate preferentially on
numeric arguments) are as follows:</p>

<p>== ?arg ...? Returns whether each argument is equal to
the arguments on each side of it in the sense of the expr ==
operator (i.e., numeric comparison if possible, exact string
comparison otherwise). If fewer than two arguments are
given, this operation always returns a true value.</p>

<p>eq ?arg ...? Returns whether each argument is equal to
the arguments on each side of it using exact string
comparison. If fewer than two arguments are given, this
operation always returns a true value.</p>

<p>!= arg arg Returns whether the two arguments are not
equal to each other, in the sense of the expr != operator
(i.e., numeric comparison if possible, exact string
comparison otherwise).</p>

<p>ne arg arg Returns whether the two arguments are not
equal to each other using exact string comparison.</p>

<p>&lt; ?arg ...? Returns whether the arbitrarily-many
arguments are ordered, with each argument after the first
having to be strictly more than the one preceding it.
Comparisons are performed preferentially on the numeric
values, and are otherwise performed using UNICODE string
comparison. If fewer than two arguments are present, this
operation always returns a true value. When the arguments
are numeric but should be compared as strings, the string
compare command should be used instead.</p>

<p>&lt;= ?arg ...? Returns whether the arbitrarily-many
arguments are ordered, with each argument after the first
having to be equal to or more than the one preceding it.
Comparisons are performed preferentially on the numeric
values, and are otherwise performed using UNICODE string
comparison. If fewer than two arguments are present, this
operation always returns a true value. When the arguments
are numeric but should be compared as strings, the string
compare command should be used instead.</p>

<p>&gt; ?arg ...? Returns whether the arbitrarily-many
arguments are ordered, with each argument after the first
having to be strictly less than the one preceding it.
Comparisons are performed preferentially on the numeric
values, and are otherwise performed using UNICODE string
comparison. If fewer than two arguments are present, this
operation always returns a true value. When the arguments
are numeric but should be compared as strings, the string
compare command should be used instead.</p>

<p>&gt;= ?arg ...? Returns whether the arbitrarily-many
arguments are ordered, with each argument after the first
having to be equal to or less than the one preceding it.
Comparisons are performed preferentially on the numeric
values, and are otherwise performed using UNICODE string
comparison. If fewer than two arguments are present, this
operation always returns a true value. When the arguments
are numeric but should be compared as strings, the string
compare command should be used instead.</p>

<p>BIT-WISE OPERATORS The behaviors of the bit-wise
operator commands (all of which only operate on integral
arguments) are as follows:</p>

<p>~ number Returns the bit-wise negation of number. Number
may be an inte- ger of any size. Note that the result of
this operation will always have the opposite sign to the
input number.</p>

<p>&amp; ?number ...? Returns the bit-wise AND of each of
the arbitrarily many argu- ments. Each number must have an
integral value. If no arguments are given, the result will
be minus one.</p>

<p>| ?number ...? Returns the bit-wise OR of each of the
arbitrarily many argu- ments. Each number must have an
integral value. If no arguments are given, the result will
be zero..TP ^ ?number ...? Returns the bit-wise XOR of each
of the arbitrarily many arguments. Each number must have an
integral value. If no arguments are given, the result will
be zero.</p>

<p>&lt;&lt; number number Returns the result of bit-wise
shifting the first argument left by the number of bits
specified in the second argument. Each number must have an
integral value.</p>

<p>&gt;&gt; number number Returns the result of bit-wise
shifting the first argument right by the number of bits
specified in the second argument. Each number must have an
integral value.</p>

<p>LIST OPERATORS The behaviors of the list-oriented
operator commands are as follows:</p>

<p>in arg list Returns whether the value arg is present in
the list list (according to exact string comparison of
elements).</p>

<p>ni arg list Returns whether the value arg is not present
in the list list (according to exact string comparison of
elements).</p>

<p>EXAMPLES The simplest way to use the operators is often
by using namespace path to make the commands available. This
has the advantage of not affecting the set of commands
defined by the current namespace. namespace path
{::tcl::mathop ::tcl::mathfunc}</p>

<p># Compute the sum of some numbers set sum [+ 1 2 3]</p>

<p># Compute the average of a list set list {1 2 3 4 5 6}
set mean [/ [+ {*}$list] [double [llength $list]]]</p>

<p># Test for list membership set gotIt [in 3 $list]</p>

<p># Test to see if a value is within some defined range
set inRange [&lt;= 1 $x 5]</p>

<p># Test to see if a list is sorted set sorted [&lt;=
{*}$list]</p>

<p>SEE ALSO expr(n), mathfunc(n), namespace(n)</p>

<p>KEYWORDS command, expression, operator</p>

<p>Tcl 8.5 mathop(n)</p>
<hr>
</body>
</html>
