<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:03:39 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>hunspell(3) hunspell(3)</p>

<p>NAME hunspell - spell checking, stemming, morphological
generation and analysis</p>

<p>SYNOPSIS #include &lt;hunspell/hunspell.hxx&gt; /* or */
#include &lt;hunspell/hunspell.h&gt;</p>

<p>Hunspell(const char *affpath, const char *dpath);</p>

<p>Hunspell(const char *affpath, const char *dpath, const
char * key);</p>

<p>~Hunspell();</p>

<p>int add_dic(const char *dpath);</p>

<p>int add_dic(const char *dpath, const char *key);</p>

<p>int spell(const char *word);</p>

<p>int spell(const char *word, int *info, char **root);</p>

<p>int suggest(char***slst, const char *word);</p>

<p>int analyze(char***slst, const char *word);</p>

<p>int stem(char***slst, const char *word);</p>

<p>int stem(char***slst, char **morph, int n);</p>

<p>int generate(char***slst, const char *word, const char
*word2);</p>

<p>int generate(char***slst, const char *word, char **desc,
int n);</p>

<p>void free_list(char ***slst, int n);</p>

<p>int add(const char *word);</p>

<p>int add_with_affix(const char *word, const char
*example);</p>

<p>int remove(const char *word);</p>

<p>char * get_dic_encoding();</p>

<p>const char * get_wordchars();</p>

<p>unsigned short * get_wordchars_utf16(int *len);</p>

<p>struct cs_info * get_csconv();</p>

<p>const char * get_version();</p>

<p>DESCRIPTION The Hunspell library routines give the user
word-level linguistic functions: spell checking and
correction, stemming, morphological generation and analysis
in item-and-arrangement style.</p>

<p>The optional C header contains the C interface of the
C++ library with Hunspell_create and Hunspell_destroy
constructor and destructor, and an extra HunHandle parameter
(the allocated object) in the wrapper functions (see in the
C header file hunspell.h).</p>

<p>The basic spelling functions, spell() and suggest() can
be used for stemming, morphological generation and analysis
by XML input texts (see XML API).</p>

<p>Constructor and destructor Hunspells constructor needs
paths of the affix and dictionary files. See the hunspell(4)
manual page for the dictionary format. Optional key
parameter is for dictionaries encrypted by the hzip tool of
the Hunspell distribution.</p>

<p>Extra dictionaries The add_dic() function load an extra
dictionary file. The extra dictionaries use the affix file
of the allocated Hunspell object. Maximal number of the
extra dictionaries is limited in the source code (20).</p>

<p>Spelling and correction The spell() function returns
non-zero, if the input word is recognised by the spell
checker, and a zero value if not. Optional reference
variables return a bit array (info) and the root word of the
input word. Info bits checked with the SPELL_COMPOUND and
SPELL_FORBIDDEN macros sign compound words and explicit
forbidden words.</p>

<p>The suggest() function has two input parameters, a
reference variable of the output suggestion list, and an
input word. The function returns the number of the
suggestions. The reference variable will contain the address
of the newly allocated suggestion list or NULL, if the
return value of suggest() is zero. Maximal number of the
suggestions is limited in the source code.</p>

<p>The spell() and suggest() can recognize XML input, see
the XML API section.</p>

<p>Morphological functions The plain stem() and analyze()
functions are similar to the suggest(), but instead of
suggestions, return stems and results of the morphological
analysis. The plain generate() waits a second word, too.
This extra word and its affixation will be the model of the
morphological generation of the requested forms of the first
word.</p>

<p>The extended stem() and generate() use the results of a
morphological analysis:</p>

<p>char ** result, result2; int n1 = analyze(&amp;result,
&quot;words&quot;); int n2 = stem(&amp;result2, result,
n1);</p>

<p>The morphological annotation of the Hunspell library has
fixed (two letter and a colon) field identifiers, see the
hunspell(4) manual page.</p>

<p>char ** result; char * affix = &quot;is:plural&quot;; //
description depends from dictionaries, too int n =
generate(&amp;result, &quot;word&quot;, &amp;affix, 1); for
(int i = 0; i &lt; n; i++) printf(&quot;%s0, result[i]);</p>

<p>Memory deallocation The free_list() function frees the
memory allocated by suggest(), analyze, generate and stem()
functions.</p>

<p>Other functions The add(), add_with_affix() and remove()
are helper functions of a personal dictionary implementation
to add and remove words from the base dictionary in
run-time. The add_with_affix() uses a second word as a model
of the enabled affixation of the new word.</p>

<p>The get_dic_encoding() function returns
&quot;ISO8859-1&quot; or the character encoding defined in
the affix file with the &quot;SET&quot; keyword.</p>

<p>The get_csconv() function returns the 8-bit character
case table of the encoding of the dictionary.</p>

<p>The get_wordchars() and get_wordchars_utf16() return the
extra word characters definied in affix file for
tokenization by the &quot;WORDCHARS&quot; keyword.</p>

<p>The get_version() returns the version string of the
library.</p>

<p>XML API The spell() function returns non-zero for the
&quot;&lt;?xml?&gt;&quot; input indicating the XML API
support.</p>

<p>The suggest() function stems, analyzes and generates the
forms of the input word, if it was added by one of the
following &quot;SPELLML&quot; syntaxes:</p>

<p>&lt;?xml?&gt; &lt;query type=&quot;analyze&quot;&gt;
&lt;word&gt;dogs&lt;/word&gt; &lt;/query&gt;</p>

<p>&lt;?xml?&gt; &lt;query type=&quot;stem&quot;&gt;
&lt;word&gt;dogs&lt;/word&gt; &lt;/query&gt;</p>

<p>&lt;?xml?&gt; &lt;query type=&quot;generate&quot;&gt;
&lt;word&gt;dog&lt;/word&gt; &lt;word&gt;cats&lt;/word&gt;
&lt;/query&gt;</p>

<p>&lt;?xml?&gt; &lt;query type=&quot;generate&quot;&gt;
&lt;word&gt;dog&lt;/word&gt;
&lt;code&gt;&lt;a&gt;is:pl&lt;/a&gt;&lt;a&gt;is:poss&lt;/a&gt;&lt;/code&gt;
&lt;/query&gt;</p>

<p>The outputs of the type=&quot;stem&quot; query and the
stem() library function are the same. The output of the
type=&quot;analyze&quot; query is a string contained a
&lt;code&gt;&lt;a&gt;result1&lt;/a&gt;&lt;a&gt;result2&lt;/a&gt;...&lt;/code&gt;
element. This element can be used in the second syntax of
the type=&quot;generate&quot; query.</p>

<p>EXAMPLE See analyze.cxx in the Hunspell
distribution.</p>

<p>AUTHORS Hunspell based on Ispell s spell checking
algorithms and OpenOffice.orgs Myspell source code.</p>

<p>Author of International Ispell is Geoff Kuenning.</p>

<p>Author of MySpell is Kevin Hendricks.</p>

<p>Author of Hunspell is L&aacute;szl&oacute;
N&eacute;meth.</p>

<p>Author of the original C API is Caolan McNamara.</p>

<p>Author of the Aspell table-driven phonetic transcription
algorithm and code is Bj&ouml;rn Jacke.</p>

<p>See also THANKS and Changelog files of Hunspell
distribution.</p>

<p>2008-06-17 hunspell(3)</p>
<hr>
</body>
</html>
