<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:12:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PTHREAD_ATTR_INIT(3) Linux Programmer s Manual
PTHREAD_ATTR_INIT(3)</p>

<p>NAME pthread_attr_init, pthread_attr_destroy -
initialize and destroy thread attributes object</p>

<p>SYNOPSIS #include &lt;pthread.h&gt;</p>

<p>int pthread_attr_init(pthread_attr_t *attr); int
pthread_attr_destroy(pthread_attr_t *attr);</p>

<p>Compile and link with -pthread.</p>

<p>DESCRIPTION The pthread_attr_init() function initializes
the thread attributes object pointed to by attr with default
attribute values. After this call, individual attributes of
the object can be set using various related functions
(listed under SEE ALSO), and then the object can be used in
one or more pthread_create(3) calls that create threads.</p>

<p>Calling pthread_attr_init() on a thread attributes
object that has already been initialized results in
undefined behavior.</p>

<p>When a thread attributes object is no longer required,
it should be destroyed using the pthread_attr_destroy()
function. Destroying a thread attributes object has no
effect on threads that were created using that object.</p>

<p>Once a thread attributes object has been destroyed, it
can be reini- tialized using pthread_attr_init(). Any other
use of a destroyed thread attributes object has undefined
results.</p>

<p>RETURN VALUE On success, these functions return 0; on
error, they return a non-zero error number.</p>

<p>ERRORS POSIX.1-2001 documents an ENOMEM error for
pthread_attr_init(); on Linux these functions always succeed
(but portable and future-proof applications should
nevertheless handle a possible error return).</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES The pthread_attr_t type should be treated as
opaque: any access to the object other than via pthreads
functions is non-portable and produces undefined
results.</p>

<p>EXAMPLE The program below optionally makes use of
pthread_attr_init() and vari- ous related functions to
initialize a thread attributes object that is used to create
a single thread. Once created, the thread uses the
pthread_getattr_np() function (a non-standard GNU extension)
to retrieve the threads attributes, and then displays those
attributes.</p>

<p>If the program is run with no command-line argument,
then it passes NULL as the attr argument of
pthread_create(3), so that the thread is created with
default attributes. Running the program on Linux/x86-32 with
the NPTL threading implementation, we see the following:</p>

<p>$ ulimit -s # No stack imit ==&gt; default stack size is
2MB unlimited $ ./a.out Thread attributes: Detach state =
PTHREAD_CREATE_JOINABLE Scope = PTHREAD_SCOPE_SYSTEM Inherit
scheduler = PTHREAD_INHERIT_SCHED Scheduling policy =
SCHED_OTHER Scheduling priority = 0 Guard size = 4096 bytes
Stack address = 0x40196000 Stack size = 0x201000 bytes</p>

<p>When we supply a stack size as a command-line argument,
the program initializes a thread attributes object, sets
various attributes in that object, and passes a pointer to
the object in the call to pthread_cre- ate(3). Running the
program on Linux/x86-32 with the NPTL threading
implementation, we see the following:</p>

<p>$ ./a.out 0x3000000 posix_memalign() allocated at
0x40197000 Thread attributes: Detach state =
PTHREAD_CREATE_DETACHED Scope = PTHREAD_SCOPE_SYSTEM Inherit
scheduler = PTHREAD_EXPLICIT_SCHED Scheduling policy =
SCHED_OTHER Scheduling priority = 0 Guard size = 0 bytes
Stack address = 0x40197000 Stack size = 0x3000000 bytes</p>

<p>Program source</p>

<p>#define _GNU_SOURCE /* To get pthread_getattr_np()
declaration */ #include &lt;pthread.h&gt; #include
&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include
&lt;unistd.h&gt; #include &lt;errno.h&gt;</p>

<p>#define handle_error_en(en, msg) do { errno = en;
perror(msg); exit(EXIT_FAILURE); } while (0)</p>

<p>static void display_pthread_attr(pthread_attr_t *attr,
char *prefix) { int s, i; size_t v; void *stkaddr; struct
sched_param sp;</p>

<p>s = pthread_attr_getdetachstate(attr, &amp;i); if (s !=
0) handle_error_en(s,
&quot;pthread_attr_getdetachstate&quot;);
printf(&quot;%sDetach state = %s0, prefix, (i ==
PTHREAD_CREATE_DETACHED) ?
&quot;PTHREAD_CREATE_DETACHED&quot; : (i ==
PTHREAD_CREATE_JOINABLE) ?
&quot;PTHREAD_CREATE_JOINABLE&quot; : &quot;???&quot;);</p>

<p>s = pthread_attr_getscope(attr, &amp;i); if (s != 0)
handle_error_en(s, &quot;pthread_attr_getscope&quot;);
printf(&quot;%sScope = %s0, prefix, (i ==
PTHREAD_SCOPE_SYSTEM) ? &quot;PTHREAD_SCOPE_SYSTEM&quot; :
(i == PTHREAD_SCOPE_PROCESS) ?
&quot;PTHREAD_SCOPE_PROCESS&quot; : &quot;???&quot;);</p>

<p>s = pthread_attr_getinheritsched(attr, &amp;i); if (s !=
0) handle_error_en(s,
&quot;pthread_attr_getinheritsched&quot;);
printf(&quot;%sInherit scheduler = %s0, prefix, (i ==
PTHREAD_INHERIT_SCHED) ? &quot;PTHREAD_INHERIT_SCHED&quot; :
(i == PTHREAD_EXPLICIT_SCHED) ?
&quot;PTHREAD_EXPLICIT_SCHED&quot; : &quot;???&quot;);</p>

<p>s = pthread_attr_getschedpolicy(attr, &amp;i); if (s !=
0) handle_error_en(s,
&quot;pthread_attr_getschedpolicy&quot;);
printf(&quot;%sScheduling policy = %s0, prefix, (i ==
SCHED_OTHER) ? &quot;SCHED_OTHER&quot; : (i == SCHED_FIFO) ?
&quot;SCHED_FIFO&quot; : (i == SCHED_RR) ?
&quot;SCHED_RR&quot; : &quot;???&quot;);</p>

<p>s = pthread_attr_getschedparam(attr, &amp;sp); if (s !=
0) handle_error_en(s,
&quot;pthread_attr_getschedparam&quot;);
printf(&quot;%sScheduling priority = %d0, prefix,
sp.sched_priority);</p>

<p>s = pthread_attr_getguardsize(attr, &amp;v); if (s != 0)
handle_error_en(s, &quot;pthread_attr_getguardsize&quot;);
printf(&quot;%sGuard size = %d bytes0, prefix, v);</p>

<p>s = pthread_attr_getstack(attr, &amp;stkaddr, &amp;v);
if (s != 0) handle_error_en(s,
&quot;pthread_attr_getstack&quot;); printf(&quot;%sStack
address = %p0, prefix, stkaddr); printf(&quot;%sStack size =
0x%x bytes0, prefix, v); }</p>

<p>static void * thread_start(void *arg) { int s;
pthread_attr_t gattr;</p>

<p>/* pthread_getattr_np() is a non-standard GNU extension
that retrieves the attributes of the thread specified in its
first argument */</p>

<p>s = pthread_getattr_np(pthread_self(), &amp;gattr); if
(s != 0) handle_error_en(s,
&quot;pthread_getattr_np&quot;);</p>

<p>printf(&quot;Thread attributes:0);
display_pthread_attr(&amp;gattr, &quot;&quot;);</p>

<p>exit(EXIT_SUCCESS); /* Terminate all threads */ }</p>

<p>int main(int argc, char *argv[]) { pthread_t thr;
pthread_attr_t attr; pthread_attr_t *attrp; /* NULL or
&amp;attr */ int s;</p>

<p>attrp = NULL;</p>

<p>/* If a command-line argument was supplied, use it to
set the stack-size attribute and set a few other thread
attributes, and set attrp pointing to thread attributes
object */</p>

<p>if (argc &gt; 1) { int stack_size; void *sp;</p>

<p>attrp = &amp;attr;</p>

<p>s = pthread_attr_init(&amp;attr); if (s != 0)
handle_error_en(s, &quot;pthread_attr_init&quot;);</p>

<p>s = pthread_attr_setdetachstate(&amp;attr,
PTHREAD_CREATE_DETACHED); if (s != 0) handle_error_en(s,
&quot;pthread_attr_setdetachstate&quot;);</p>

<p>s = pthread_attr_setinheritsched(&amp;attr,
PTHREAD_EXPLICIT_SCHED); if (s != 0) handle_error_en(s,
&quot;pthread_attr_setinheritsched&quot;);</p>

<p>stack_size = strtoul(argv[1], NULL, 0);</p>

<p>s = posix_memalign(&amp;sp, sysconf(_SC_PAGESIZE),
stack_size); if (s != 0) handle_error_en(s,
&quot;posix_memalign&quot;);</p>

<p>printf(&quot;posix_memalign() allocated at %p0, sp);</p>

<p>s = pthread_attr_setstack(&amp;attr, sp, stack_size); if
(s != 0) handle_error_en(s,
&quot;pthread_attr_setstack&quot;); }</p>

<p>s = pthread_create(&amp;thr, attrp, &amp;thread_start,
NULL); if (s != 0) handle_error_en(s,
&quot;pthread_create&quot;);</p>

<p>if (attrp != NULL) { s = pthread_attr_destroy(attrp); if
(s != 0) handle_error_en(s,
&quot;pthread_attr_destroy&quot;); }</p>

<p>pause(); /* Terminates when other thread calls exit() */
}</p>

<p>SEE ALSO pthread_attr_setaffinity_np(3),
pthread_attr_setdetachstate(3),
pthread_attr_setguardsize(3),
pthread_attr_setinheritsched(3),
pthread_attr_setschedparam(3),
pthread_attr_setschedpolicy(3), pthread_attr_setscope(3),
pthread_attr_setstack(3), pthread_attr_set- stackaddr(3),
pthread_attr_setstacksize(3), pthread_create(3),
pthread_getattr_np(3), pthreads(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2008-11-11 PTHREAD_ATTR_INIT(3)</p>
<hr>
</body>
</html>
