<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:24:29 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_MAKE_PATH(9) Host-Side Data Types and Macro
USB_MAKE_PATH(9)</p>

<p>NAME usb_make_path - returns stable device path in the
usb tree</p>

<p>SYNOPSIS int usb_make_path(struct usb_device * dev, char
* buf, size_t size);</p>

<p>ARGUMENTS dev the device whose path is being
constructed</p>

<p>buf where to put the string</p>

<p>size how big is buf?</p>

<p>DESCRIPTION Returns length of the string (&gt; 0) or
negative if size was too small.</p>

<p>This identifier is intended to be stable, reflecting
physical paths in hardware such as physical bus addresses
for host controllers or ports on USB hubs. That makes it
stay the same until systems are physically reconfigured, by
re-cabling a tree of USB devices or by moving USB host
controllers. Adding and removing devices, including virtual
root hubs in host controller driver modules, does not change
these path identifers; neither does rebooting or
re-enumerating. These are more useful identifiers than
changeable ( unstable ) ones like bus numbers or device
addresses.</p>

<p>With a partial exception for devices connected to USB
2.0 root hubs, these identifiers are also predictable. So
long as the device tree isn&acute;t changed, plugging any
USB device into a given hub port always gives it the same
path. Because of the use of companion controllers, devices
connected to ports on USB 2.0 root hubs (EHCI host
controllers) will get one path ID if they are high speed,
and a different one if they are full or low speed.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
USB_MAKE_PATH(9)</p>
<hr>
</body>
</html>
