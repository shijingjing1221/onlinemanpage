<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:05:28 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>keytool(1) keytool(1)</p>

<p>NAME keytool - Key and Certificate Management Tool</p>

<p>Manages a keystore (database) of cryptographic keys,
X.509 certifi- cate chains, and trusted certificates.</p>

<p>SYNOPSIS keytool [ commands ]</p>

<p>The keytool command interface has changed in Java SE 6.
See the Changes Section for a detailed description. Note
that previously defined com- mands are still supported.</p>

<p>DESCRIPTION keytool is a key and certificate management
utility. It allows users to administer their own
public/private key pairs and associated certifi- cates for
use in self-authentication (where the user authenticates
him- self/herself to other users/services) or data integrity
and authentica- tion services, using digital signatures. It
also allows users to cache the public keys (in the form of
certificates) of their communicating peers.</p>

<p>A certificate is a digitally signed statement from one
entity (person, company, etc.), saying that the public key
(and some other information) of some other entity has a
particular value. (See Certificates.) When data is digitally
signed, the signature can be verified to check the data
integrity and authenticity. Integrity means that the data
has not been modified or tampered with, and authenticity
means the data indeed comes from whoever claims to have
created and signed it.</p>

<p>keytool also enables users to administer secret keys
used in symmetric encryption/decryption (e.g. DES).</p>

<p>keytool stores the keys and certificates in a
keystore.</p>

<p>COMMAND AND OPTION NOTES The various commands and their
options are listed and described below . Note:</p>

<p>o All command and option names are preceded by a minus
sign (-).</p>

<p>o The options for each command may be provided in any
order.</p>

<p>o All items not italicized or in braces or square
brackets are required to appear as is.</p>

<p>o Braces surrounding an option generally signify that a
default value will be used if the option is not specified on
the command line. Braces are also used around the -v, -rfc,
and -J options, which only have meaning if they appear on
the command line (that is, they dont have any
&quot;default&quot; values other than not existing).</p>

<p>o Brackets surrounding an option signify that the user
is prompted for the value(s) if the option is not specified
on the command line. (For a -keypass option, if you do not
specify the option on the command line, keytool will first
attempt to use the keystore password to recover the
private/secret key, and if this fails, will then prompt you
for the private/secret key password.)</p>

<p>o Items in italics (option values) represent the actual
values that must be supplied. For example, here is the
format of the -print- cert command:</p>

<p>keytool -printcert {-file cert_file} {-v}</p>

<p>When specifying a -printcert command, replace cert_file
with the actual file name, as in:</p>

<p>keytool -printcert -file VScert.cer</p>

<p>o Option values must be quoted if they contain a blank
(space).</p>

<p>o The -help command is the default. Thus, the command
line</p>

<p>keytool</p>

<p>is equivalent to</p>

<p>keytool -help</p>

<p>Option Defaults Below are the defaults for various
option values.</p>

<p>-alias &quot;mykey&quot;</p>

<p>-keyalg &quot;DSA&quot; (when using -genkeypair)
&quot;DES&quot; (when using -genseckey)</p>

<p>-keysize 1024 (when using -genkeypair) 56 (when using
-genseckey and -keyalg is &quot;DES&quot;) 168 (when using
-genseckey and -keyalg is &quot;DESede&quot;)</p>

<p>-validity 90</p>

<p>-keystore the file named .keystore in the uses home
directory</p>

<p>-storetype the value of the &quot;keystore.type&quot;
property in the security properties file, which is returned
by the static getDefaultType method in
java.security.KeyStore</p>

<p>-file stdin if reading, stdout if writing</p>

<p>-protected false</p>

<p>In generating a public/private key pair, the signature
algorithm (-sigalg option) is derived from the algorithm of
the underlying private key: If the underlying private key is
of type &quot;DSA&quot;, the -sigalg option defaults to
&quot;SHA1withDSA&quot;, and if the underlying pri- vate key
is of type &quot;RSA&quot;, -sigalg defaults to
&quot;MD5withRSA&quot;. Please consult the Java Cryptography
Architecture API Specification &amp; Ref- erence @
http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA
for a full list of -keyalg and -sigalg you can choose
from.</p>

<p>Common Options The -v option can appear for all commands
except -help. If it appears, it signifies
&quot;verbose&quot; mode; more information will be out-
put.</p>

<p>There is also a -Jjavaoption option that may appear for
any command. If it appears, the specified javaoption string
is passed through directly to the Java interpreter. This
option should not contain any spaces. It is useful for
adjusting the execution environment or mem- ory usage. For a
list of possible interpreter options, type java -h or java
-X at the command line.</p>

<p>These options may appear for all commands operating on a
keystore:</p>

<p>-storetype storetype This qualifier specifies the type
of keystore to be instanti- ated.</p>

<p>-keystore keystore The keystore location.</p>

<p>If the JKS storetype is used and a keystore file does
not yet exist, then certain keytool commands may result in a
new keystore file being created. For example, if keytool
-genkeypair is invoked and the -keystore option is not
specified, the default keystore file named .keystore in the
users home directory will be created if it does not already
exist. Similarly, if the -key- store ks_file option is
specified but ks_file does not exist, then it will be
created</p>

<p>Note that the input stream from the -keystore option is
passed to the KeyStore.load method. If NONE is specified as
the URL, then a null stream is passed to the KeyStore.load
method. NONE should be specified if the KeyStore is not
file-based (for example, if it resides on a hardware token
device).</p>

<p>-storepass storepass The password which is used to
protect the integrity of the keystore.</p>

<p>storepass must be at least 6 characters long. It must be
provided to all commands that access the keystore contents.
For such com- mands, if a -storepass option is not provided
at the command line, the user is prompted for it.</p>

<p>When retrieving information from the keystore, the
password is optional; if no password is given, the integrity
of the retrieved information cannot be checked and a warning
is displayed.</p>

<p>-providerName provider_name Used to identify a
cryptographic service provider s name when listed in the
security properties file.</p>

<p>-providerClass provider_class_name Used to specify the
name of cryptographic service providers master class file
when the service provider is not listed in the security
properties file.</p>

<p>-providerArg provider_arg Used in conjunction with
-providerClass. Represents an optional string input argument
for the constructor of provider_class_name.</p>

<p>-protected Either true or false. This value should be
specified as true if a password must be given via a
protected authentication path such as a dedicated PIN
reader.</p>

<p>COMMANDS Creating or Adding Data to the Keystore
-genkeypair {-alias alias} {-keyalg keyalg} {-keysize
keysize} {-sigalg sigalg} [-dname dname] [-keypass keypass]
{-validity valDays} {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a key pair (a public key and associated
private key). Wraps the public key into an X.509 v3
self-signed certificate, which is stored as a single-element
certificate chain. This cer- tificate chain and the private
key are stored in a new keystore entry identified by
alias.</p>

<p>keyalg specifies the algorithm to be used to generate
the key pair, and keysize specifies the size of each key to
be generated. sigalg specifies the algorithm that should be
used to sign the self-signed certificate; this algorithm
must be compatible with keyalg.</p>

<p>dname specifies the X.500 Distinguished Name to be
associated with alias, and is used as the issuer and subject
fields in the self-signed certificate. If no distinguished
name is provided at the command line, the user will be
prompted for one.</p>

<p>keypass is a password used to protect the private key of
the gen- erated key pair. If no password is provided, the
user is prompted for it. If you press RETURN at the prompt,
the key password is set to the same password as that used
for the keystore. keypass must be at least 6 characters
long.</p>

<p>valDays tells the number of days for which the
certificate should be considered valid.</p>

<p>This command was named -genkey in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
-genkeypair, is preferred going forward.</p>

<p>-genseckey {-alias alias} {-keyalg keyalg} {-keysize
keysize} [-keypass keypass] {-storetype storetype}
{-keystore keystore} [-storepass storepass] {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a secret key and stores it in a new Key-
Store.SecretKeyEntry identified by alias.</p>

<p>keyalg specifies the algorithm to be used to generate
the secret key, and keysize specifies the size of the key to
be generated. keypass is a password used to protect the
secret key. If no pass- word is provided, the user is
prompted for it. If you press RETURN at the prompt, the key
password is set to the same pass- word as that used for the
keystore. keypass must be at least 6 characters long.</p>

<p>-importcert {-alias alias} {-file cert_file} [-keypass
keypass] {-noprompt} {-trustcacerts} {-storetype storetype}
{-keystore keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p>Reads the certificate or certificate chain (where the
latter is supplied in a PKCS#7 formatted reply) from the
file cert_file, and stores it in the keystore entry
identified by alias. If no file is given, the certificate or
PKCS#7 reply is read from stdin.</p>

<p>keytool can import X.509 v1, v2, and v3 certificates,
and PKCS#7 formatted certificate chains consisting of
certificates of that type. The data to be imported must be
provided either in binary encoding format, or in printable
encoding format (also known as Base64 encoding) as defined
by the Internet RFC 1421 standard. In the latter case, the
encoding must be bounded at the beginning by a string that
starts with &quot;-----BEGIN&quot;, and bounded at the end
by a string that starts with &quot;-----END&quot;.</p>

<p>You import a certificate for two reasons:</p>

<p>1. to add it to the list of trusted certificates, or</p>

<p>2. to import a certificate reply received from a CA as
the result of submitting a Certificate Signing Request (see
the -certreq command) to that CA.</p>

<p>Which type of import is intended is indicated by the
value of the -alias option:</p>

<p>1. If the alias does not point to a key entry, then
keytool assumes you are adding a trusted certificate entry.
In this case, the alias should not already exist in the
keystore. If the alias does already exist, then keytool
outputs an error, since there is already a trusted
certificate for that alias, and does not import the
certificate.</p>

<p>2. If the alias points to a key entry, then keytool
assumes you are importing a certificate reply. Importing a
New Trusted Certificate</p>

<p>Before adding the certificate to the keystore, keytool
tries to verify it by attempting to construct a chain of
trust from that certificate to a self-signed certificate
(belonging to a root CA), using trusted certificates that
are already avail- able in the keystore.</p>

<p>If the -trustcacerts option has been specified,
additional certificates are considered for the chain of
trust, namely the certificates in a file named
&quot;cacerts&quot;.</p>

<p>If keytool fails to establish a trust path from the
certifi- cate to be imported up to a self-signed certificate
(either from the keystore or the &quot;cacerts&quot; file),
the certificate information is printed out, and the user is
prompted to verify it, e.g., by comparing the displayed
certificate fingerprints with the fingerprints obtained from
some other (trusted) source of information, which might be
the certificate owner himself/herself. Be very careful to
ensure the certificate is valid prior to importing it as a
&quot;trusted&quot; certificate! -- see WARNING Regarding
Importing Trusted Certificates. The user then has the option
of aborting the import operation. If the -noprompt option is
given, however, there will be no interac- tion with the
user.</p>

<p>Importing a Certificate Reply</p>

<p>When importing a certificate reply, the certificate
reply is validated using trusted certificates from the
keystore, and optionally using the certificates configured
in the &quot;cacerts&quot; keystore file (if the
-trustcacerts option was specified).</p>

<p>The methods of determining whether the certificate reply
is trusted are described in the following:</p>

<p>o If the reply is a single X.509 certificate, keytool
attempts to establish a trust chain, starting at the cer-
tificate reply and ending at a self-signed certificate
(belonging to a root CA). The certificate reply and the
hierarchy of certificates used to authenticate the cer-
tificate reply form the new certificate chain of alias. If a
trust chain cannot be established, the certificate reply is
not imported. In this case, keytool does not print out the
certificate and prompt the user to verify it, because it is
very hard (if not impossible) for a user to determine the
authenticity of the certificate reply.</p>

<p>o If the reply is a PKCS#7 formatted certificate chain,
the chain is first ordered (with the user certificate first
and the self-signed root CA certificate last), before
keytool attempts to match the root CA certificate pro- vided
in the reply with any of the trusted certificates in the
keystore or the &quot;cacerts&quot; keystore file (if the
-trustcacerts option was specified). If no match can be
found, the information of the root CA certificate is printed
out, and the user is prompted to verify it, e.g., by
comparing the displayed certificate fingerprints with the
fingerprints obtained from some other (trusted) source of
information, which might be the root CA itself. The user
then has the option of aborting the import oper- ation. If
the -noprompt option is given, however, there will be no
interaction with the user.</p>

<p>If the public key in the certificate reply matches the
users public key already stored with under alias, the old
certifi- cate chain is replaced with the new certificate
chain in the reply. The old chain can only be replaced if a
valid keypass, the password used to protect the private key
of the entry, is supplied. If no password is provided, and
the private key password is different from the keystore
password, the user is prompted for it.</p>

<p>This command was named -import in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
-importcert, is preferred going forward.</p>

<p>-importkeystore -srckeystore srckeystore -destkeystore
destkey- store {-srcstoretype srcstoretype} {-deststoretype
deststoretype} [-srcstorepass srcstorepass] [-deststorepass
deststorepass] {-srcprotected} {-destprotected} {-srcalias
srcalias {-destalias destalias} [-srckeypass srckeypass]
[-destkeypass destkeypass] } {-noprompt} {-srcProviderName
src_provider_name} {-destProvider- Name dest_provider_name}
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-protected} {-Jjavaoption}</p>

<p>Imports a single entry or all entries from a source
keystore to a destination keystore.</p>

<p>When the srcalias option is provided, the command
imports the single entry identified by the alias to the
destination keystore. If a destination alias is not provided
with destalias, then srcalias is used as the destination
alias. If the source entry is protected by a password,
srckeypass will be used to recover the entry. If srckeypass
is not provided, then keytool will attempt to use
srcstorepass to recover the entry. If srcstorepass is either
not provided or is incorrect, the user will be prompted for
a password. The destination entry will be protected using
destkeypass. If destkeypass is not provided, the destination
entry will be protected with the source entry password.</p>

<p>If the srcalias option is not provided, then all entries
in the source keystore are imported into the destination
keystore. Each destination entry will be stored under the
alias from the source entry. If the source entry is
protected by a password, src- storepass will be used to
recover the entry. If srcstorepass is either not provided or
is incorrect, the user will be prompted for a password. If a
source keystore entry type is not supported in the
destination keystore, or if an error occurs while storing an
entry into the destination keystore, the user will be
prompted whether to skip the entry and continue, or to quit.
The destina- tion entry will be protected with the source
entry password.</p>

<p>If the destination alias already exists in the
destination key- store, the user is prompted to either
overwrite the entry, or to create a new entry under a
different alias name.</p>

<p>Note that if -noprompt is provided, the user will not be
prompted for a new destination alias. Existing entries will
automatically be overwritten with the destination alias
name. Finally, entries that can not be imported are
automatically skipped and a warning is output.</p>

<p>Exporting Data -certreq {-alias alias} {-sigalg sigalg}
{-file certreq_file} [-keypass keypass] {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} {-provider- Class
provider_class_name {-providerArg provider_arg}} {-v}
{-protected} {-Jjavaoption}</p>

<p>Generates a Certificate Signing Request (CSR), using the
PKCS#10 format.</p>

<p>A CSR is intended to be sent to a certificate authority
(CA). The CA will authenticate the certificate requestor
(usually off-line) and will return a certificate or
certificate chain, used to replace the existing certificate
chain (which initially consists of a self-signed
certificate) in the keystore.</p>

<p>The private key and X.500 Distinguished Name associated
with alias are used to create the PKCS#10 certificate
request. In order to access the private key, the appropriate
password must be provided, since private keys are protected
in the keystore with a password. If keypass is not provided
at the command line, and is different from the password used
to protect the integrity of the keystore, the user is
prompted for it.</p>

<p>sigalg specifies the algorithm that should be used to
sign the CSR.</p>

<p>The CSR is stored in the file certreq_file. If no file
is given, the CSR is output to stdout.</p>

<p>Use the importcert command to import the response from
the CA.</p>

<p>-exportcert {-alias alias} {-file cert_file} {-storetype
store- type} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-rfc} {-v}
{-protected} {-Jjavaoption}</p>

<p>Reads (from the keystore) the certificate associated
with alias, and stores it in the file cert_file.</p>

<p>If no file is given, the certificate is output to
stdout.</p>

<p>The certificate is by default output in binary encoding,
but will instead be output in the printable encoding format,
as defined by the Internet RFC 1421 standard, if the -rfc
option is specified.</p>

<p>If alias refers to a trusted certificate, that
certificate is output. Otherwise, alias refers to a key
entry with an associated certificate chain. In that case,
the first certificate in the chain is returned. This
certificate authenticates the public key of the entity
addressed by alias.</p>

<p>This command was named -export in previous releases.
This old name is still supported in this release and will be
supported in future releases, but for clarify the new name,
-exportcert, is preferred going forward.</p>

<p>Displaying Data -list {-alias alias} {-storetype
storetype} {-keystore keystore} [-storepass storepass]
{-providerName provider_name} {-provider- Class
provider_class_name {-providerArg provider_arg}} {-v | -rfc}
{-protected} {-Jjavaoption}</p>

<p>Prints (to stdout) the contents of the keystore entry
identified by alias. If no alias is specified, the contents
of the entire keystore are printed.</p>

<p>This command by default prints the MD5 fingerprint of a
certifi- cate. If the -v option is specified, the
certificate is printed in human-readable format, with
additional information such as the owner, issuer, serial
number, and any extensions. If the -rfc option is specified,
certificate contents are printed using the printable
encoding format, as defined by the Internet RFC 1421
standard</p>

<p>You cannot specify both -v and -rfc.</p>

<p>-printcert {-file cert_file} {-v} {-Jjavaoption}</p>

<p>Internet RFC 1421 standard.</p>

<p>Note: This option can be used independently of a
keystore.</p>

<p>Managing the Keystore -storepasswd [-new new_storepass]
{-storetype storetype} {-key- store keystore} [-storepass
storepass] {-providerName provider_name} {-providerClass
provider_class_name {-providerArg provider_arg}} {-v}
{-Jjavaoption}</p>

<p>Changes the password used to protect the integrity of
the key- store contents. The new password is new_storepass,
which must be at least 6 characters long.</p>

<p>-keypasswd {-alias alias} [-keypass old_keypass] [-new
new_key- pass] {-storetype storetype} {-keystore keystore}
[-storepass storepass] {-providerName provider_name}
{-providerClass provider_class_name {-providerArg
provider_arg}} {-v} {-Jjavaop- tion}</p>

<p>Changes the password under which the private/secret key
identi- fied by alias is protected, from old_keypass to
new_keypass, which must be at least 6 characters long.</p>

<p>If the -keypass option is not provided at the command
line, and the key password is different from the keystore
password, the user is prompted for it.</p>

<p>If the -new option is not provided at the command line,
the user is prompted for it.</p>

<p>-delete [-alias alias] {-storetype storetype} {-keystore
key- store} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-protected}
{-Jjavaoption}</p>

<p>Deletes from the keystore the entry identified by alias.
The user is prompted for the alias, if no alias is provided
at the command line.</p>

<p>-changealias {-alias alias} [-destalias destalias]
[-keypass key- pass] {-storetype storetype} {-keystore
keystore} [-storepass storepass] {-providerName
provider_name} {-providerClass provider_class_name
{-providerArg provider_arg}} {-v} {-pro- tected}
{-Jjavaoption}</p>

<p>Move an existing keystore entry from the specified alias
to a new alias, destalias. If no destination alias is
provided, the com- mand will prompt for one. If the original
entry is protected with an entry password, the password can
be supplied via the &quot;-key- pass&quot; option. If no key
password is provided, the storepass (if given) will be
attempted first. If that attempt fails, the user will be
prompted for a password.</p>

<p>Getting Help -help</p>

<p>Lists the basic commands and their options.</p>

<p>EXAMPLES Suppose you want to create a keystore for
managing your public/private key pair and certificates from
entities you trust.</p>

<p>Generating Your Key Pair The first thing you need to do
is create a keystore and generate the key pair. You could
use a command such as the following:</p>

<p>keytool -genkeypair -dname &quot;cn=Mark Jones,
ou=JavaSoft, o=Sun, c=US&quot; -alias business -keypass
kpi135 -keystore /working/mykeystore -storepass ab987c
-validity 180</p>

<p>(Please note: This must be typed as a single line.
Multiple lines are used in the examples just for legibility
purposes.)</p>

<p>This command creates the keystore named
&quot;mykeystore&quot; in the &quot;work- ing&quot;
directory (assuming it doesnt already exist), and assigns it
the password &quot;ab987c&quot;. It generates a
public/private key pair for the entity whose
&quot;distinguished name&quot; has a common name of
&quot;Mark Jones&quot;, organizational unit of
&quot;JavaSoft&quot;, organization of &quot;Sun&quot; and
two-letter country code of &quot;US&quot;. It uses the
default &quot;DSA&quot; key gen- eration algorithm to create
the keys, both 1024 bits long.</p>

<p>It creates a self-signed certificate (using the default
&quot;SHA1with- DSA&quot; signature algorithm) that includes
the public key and the dis- tinguished name information.
This certificate will be valid for 180 days, and is
associated with the private key in a keystore entry referred
to by the alias &quot;business&quot;. The private key is
assigned the password &quot;kpi135&quot;.</p>

<p>The command could be significantly shorter if option
defaults were accepted. As a matter of fact, no options are
required; defaults are used for unspecified options that
have default values, and you are prompted for any required
values. Thus, you could simply have the following:</p>

<p>keytool -genkeypair</p>

<p>In this case, a keystore entry with alias
&quot;mykey&quot; is created, with a newly-generated key
pair and a certificate that is valid for 90 days. This entry
is placed in the keystore named &quot;.keystore&quot; in
your home directory. (The keystore is created if it doesn t
already exist.) You will be prompted for the distinguished
name information, the keystore password, and the private key
password.</p>

<p>The rest of the examples assume you executed the
-genkeypair command without options specified, and that you
responded to the prompts with values equal to those given in
the first -genkeypair command, above (a private key password
of &quot;kpi135&quot;, etc.)</p>

<p>Requesting a Signed Certificate from a Certification
Authority So far all weve got is a self-signed certificate.
A certificate is more likely to be trusted by others if it
is signed by a Certifica- tion Authority (CA). To get such a
signature, you first generate a Certificate Signing Request
(CSR), via the following:</p>

<p>keytool -certreq -file MarkJ.csr</p>

<p>This creates a CSR (for the entity identified by the
default alias &quot;mykey&quot;) and puts the request in the
file named &quot;MarkJ.csr&quot;. Submit this file to a CA,
such as VeriSign, Inc. The CA will authenticate you, the
requestor (usually off-line), and then will return a cer-
tificate, signed by them, authenticating your public key.
(In some cases, they will actually return a chain of
certificates, each one authenticating the public key of the
signer of the previous certifi- cate in the chain.)</p>

<p>Importing a Certificate for the CA You need to replace
your self-signed certificate with a certificate chain, where
each certificate in the chain authenticates the public key
of the signer of the previous certificate in the chain, up
to a &quot;root&quot; CA.</p>

<p>Before you import the certificate reply from a CA, you
need one or more &quot;trusted certificates&quot; in your
keystore or in the cacerts key- store file (which is
described in importcert command):</p>

<p>o If the certificate reply is a certificate chain, you
just need the top certificate of the chain (that is, the
&quot;root&quot; CA cer- tificate authenticating that CAs
public key).</p>

<p>o If the certificate reply is a single certificate, you
need a certificate for the issuing CA (the one that signed
it), and if that certificate is not self-signed, you need a
certificate for its signer, and so on, up to a self-signed
&quot;root&quot; CA certifi- cate.</p>

<p>The &quot;cacerts&quot; keystore file ships with five
VeriSign root CA cer- tificates, so you probably won t need
to import a VeriSign certifi- cate as a trusted certificate
in your keystore. But if you request a signed certificate
from a different CA, and a certificate authenti- cating that
CA s public key hasn t been added to &quot;cacerts&quot;,
you will need to import a certificate from the CA as a
&quot;trusted certificate&quot;.</p>

<p>A certificate from a CA is usually either self-signed,
or signed by another CA (in which case you also need a
certificate authenticating that CA s public key). Suppose
company ABC, Inc., is a CA, and you obtain a file named
&quot;ABCCA.cer&quot; that is purportedly a self-signed
certificate from ABC, authenticating that CAs public
key.</p>

<p>Be very careful to ensure the certificate is valid prior
to import- ing it as a &quot;trusted&quot; certificate! View
it first (using the keytool -printcert command, or the
keytool -importcert command without the -noprompt option),
and make sure that the displayed certificate fin-
gerprint(s) match the expected ones. You can call the person
who sent the certificate, and compare the fingerprint(s)
that you see with the ones that they show (or that a secure
public key repository shows). Only if the fingerprints are
equal is it guaranteed that the certificate has not been
replaced in transit with somebody elses (for example, an
attacker s) certificate. If such an attack took place, and
you did not check the certificate before you imported it,
you would end up trusting anything the attacker has
signed.</p>

<p>If you trust that the certificate is valid, then you can
add it to your keystore via the following:</p>

<p>keytool -importcert -alias abc -file ABCCA.cer</p>

<p>This creates a &quot;trusted certificate&quot; entry in
the keystore, with the data from the file
&quot;ABCCA.cer&quot;, and assigns the alias &quot;abc&quot;
to the entry.</p>

<p>Importing the Certificate Reply from the CA Once you ve
imported a certificate authenticating the public key of the
CA you submitted your certificate signing request to (or
theres already such a certificate in the &quot;cacerts&quot;
file), you can import the certificate reply and thereby
replace your self-signed certificate with a certificate
chain. This chain is the one returned by the CA in response
to your request (if the CA reply is a chain), or one
constructed (if the CA reply is a single certificate) using
the certificate reply and trusted certificates that are
already available in the keystore where you import the reply
or in the &quot;cac- erts&quot; keystore file.</p>

<p>For example, suppose you sent your certificate signing
request to VeriSign. You can then import the reply via the
following, which assumes the returned certificate is named
&quot;VSMarkJ.cer&quot;:</p>

<p>keytool -importcert -trustcacerts -file VSMarkJ.cer</p>

<p>Exporting a Certificate Authenticating Your Public Key
Suppose you have used the jarsigner @
http://java.sun.com/javase/6/docs/tooldocs/solaris/jarsigner.html
tool to sign a Java ARchive (JAR) file. Clients that want to
use the file will want to authenticate your signature.</p>

<p>One way they can do this is by first importing your
public key cer- tificate into their keystore as a
&quot;trusted&quot; entry. You can export the certificate
and supply it to your clients. As an example, you can copy
your certificate to a file named MJ.cer via the following,
assuming the entry is aliased by &quot;mykey&quot;:</p>

<p>keytool -exportcert -alias mykey -file MJ.cer</p>

<p>Given that certificate, and the signed JAR file, a
client can use the jarsigner tool to authenticate your
signature.</p>

<p>Importing Keystore The command
&quot;importkeystore&quot; is used to import an entire
keystore into another keystore, which means all entries from
the source key- store, including keys and certificates, are
all imported to the des- tination keystore within a single
command. You can use this command to import entries from a
different type of keystore. During the import, all new
entries in the destination keystore will have the same alias
names and protection passwords (for secret keys and pri-
vate keys). If keytool has difficulties recover the private
keys or secret keys from the source keystore, it will prompt
you for a pass- word. If it detects alias duplication, it
will ask you for a new one, you can specify a new alias or
simply allow keytool to over- write the existing one.</p>

<p>For example, to import entries from a normal JKS type
keystore key.jks into a PKCS #11 type hardware based
keystore, you can use the command:</p>

<p>keytool -importkeystore -srckeystore key.jks
-destkeystore NONE -srcstoretype JKS -deststoretype PKCS11
-srcstorepass changeit -deststorepass topsecret</p>

<p>The importkeystore command can also be used to import a
single entry from a source keystore to a destination
keystore. In this case, besides the options you see in the
above example, you need to spec- ify the alias you want to
import. With the srcalias option given, you can also specify
the desination alias name in the command line, as well as
protection password for a secret/private key and the des-
tination protection password you want. In this way, you can
issue a keytool command that will never ask you a question.
This makes it very convenient to include a keytool command
into a script file, like this:</p>

<p>keytool -importkeystore -srckeystore key.jks
-destkeystore NONE -srcstoretype JKS -deststoretype PKCS11
-srcstorepass changeit -deststorepass topsecret -srcalias
myprivatekey -destalias myoldprivatekey -srckeypass
oldkeypass -destkeypass mynewkeypass -noprompt</p>

<p>TERMINOLOGY and WARNINGS KeyStore A keystore is a
storage facility for cryptographic keys and certifi-
cates.</p>

<p>o</p>

<p>o KeyStore Entries</p>

<p>Keystores may have different types of entries. The two
most applicable entry types for keytool include:</p>

<p>1. key entries - each holds very sensitive cryptographic
key information, which is stored in a protected format to
pre- vent unauthorized access. Typically, a key stored in
this type of entry is a secret key, or a private key
accompanied by the certificate &quot;chain&quot; for the
corresponding public key. The keytool can handle both types
od entry, while jar- signer tool only handle the latter type
of entry, that is private keys and their associated
certificate chains.</p>

<p>2. trusted certificate entries - each contains a single
public key certificate belonging to another party. It is
called a &quot;trusted certificate&quot; because the
keystore owner trusts that the public key in the certificate
indeed belongs to the identity identified by the
&quot;subject&quot; (owner) of the certificate. The issuer
of the certificate vouches for this, by signing the
certificate.</p>

<p>o KeyStore Aliases</p>

<p>All keystore entries (key and trusted certificate
entries) are accessed via unique aliases.</p>

<p>An alias is specified when you add an entity to the
keystore using the -genseckey command to generate a secret
key, -genkey- pair command to generate a key pair (public
and private key) or the -importcert command to add a
certificate or certificate chain to the list of trusted
certificates. Subsequent keytool commands must use this same
alias to refer to the entity.</p>

<p>For example, suppose you use the alias duke to generate
a new public/private key pair and wrap the public key into a
self-signed certificate (see Certificate Chains) via the
follow- ing command:</p>

<p>keytool -genkeypair -alias duke -keypass
dukekeypasswd</p>

<p>This specifies an inital password of
&quot;dukekeypasswd&quot; required by subsequent commands to
access the private key assocated with the alias duke. If you
later want to change dukes private key pass- word, you use a
command like the following:</p>

<p>keytool -keypasswd -alias duke -keypass dukekeypasswd
-new newpass</p>

<p>This changes the password from &quot;dukekeypasswd&quot;
to &quot;newpass&quot;.</p>

<p>Please note: A password should not actually be specified
on a command line or in a script unless it is for testing
purposes, or you are on a secure system. If you don t
specify a required pass- word option on a command line, you
will be prompted for it.</p>

<p>o KeyStore Implementation The KeyStore class provided in
the java.security package supplies well-defined interfaces
to access and modify the information in a keystore. It is
possible for there to be multiple different con- crete
implementations, where each implementation is that for a
particular type of keystore.</p>

<p>Currently, two command-line tools (keytool and
jarsigner) and a GUI-based tool named Policy Tool make use
of keystore implementa- tions. Since KeyStore is publicly
available, users can write additional security applications
that use it.</p>

<p>There is a built-in default implementation, provided by
Sun Microsystems. It implements the keystore as a file,
utilizing a proprietary keystore type (format) named
&quot;JKS&quot;. It protects each private key with its
individual password, and also protects the integrity of the
entire keystore with a (possibly different) password.</p>

<p>Keystore implementations are provider-based. More
specifically, the application interfaces supplied by
KeyStore are implemented in terms of a &quot;Service
Provider Interface&quot; (SPI). That is, there is a
corresponding abstract KeystoreSpi class, also in the
java.security package, which defines the Service Provider
Inter- face methods that &quot;providers&quot; must
implement. (The term &quot;provider&quot; refers to a
package or a set of packages that supply a concrete
implementation of a subset of services that can be accessed
by the Java Security API.) Thus, to provide a keystore
implementation, clients must implement a
&quot;provider&quot; and supply a KeystoreSpi subclass
implementation, as described in How to Implement a Provider
for the Java Cryptography Architecture.</p>

<p>Applications can choose different types of keystore
implementa- tions from different providers, using the
&quot;getInstance&quot; factory method supplied in the
KeyStore class. A keystore type defines the storage and data
format of the keystore information, and the algorithms used
to protect private/secret keys in the keystore and the
integrity of the keystore itself. Keystore implementa- tions
of different types are not compatible.</p>

<p>keytool works on any file-based keystore implementation.
(It treats the keytore location that is passed to it at the
command line as a filename and converts it to a
FileInputStream, from which it loads the keystore
information.) The jarsigner and poli- cytool tools, on the
other hand, can read a keystore from any location that can
be specified using a URL.</p>

<p>For keytool and jarsigner, you can specify a keystore
type at the command line, via the -storetype option. For
Policy Tool, you can specify a keystore type via the
&quot;Keystore&quot; menu.</p>

<p>If you dont explicitly specify a keystore type, the
tools choose a keystore implementation based simply on the
value of the key- store.type property specified in the
security properties file. The security properties file is
called java.security, and it resides in the security
properties directory, java.home/lib/secu- rity, where
java.home is the runtime environment s directory (the jre
directory in the SDK or the top-level directory of the Java
2 Runtime Environment).</p>

<p>Each tool gets the keystore.type value and then examines
all the currently-installed providers until it finds one
that implements keystores of that type. It then uses the
keystore implementation from that provider.</p>

<p>The KeyStore class defines a static method named
getDefaultType that lets applications and applets retrieve
the value of the key- store.type property. The following
line of code creates an instance of the default keystore
type (as specified in the key- store.type property):</p>

<p>KeyStore keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</p>

<p>The default keystore type is &quot;jks&quot; (the
proprietary type of the keystore implementation provided by
Sun). This is specified by the following line in the
security properties file:</p>

<p>keystore.type=jks</p>

<p>To have the tools utilize a keystore implementation
other than the default, you can change that line to specify
a different key- store type.</p>

<p>For example, if you have a provider package that
supplies a key- store implementation for a keystore type
called &quot;pkcs12&quot;, change the line to</p>

<p>keystore.type=pkcs12</p>

<p>Note: case doesn t matter in keystore type designations.
For example, &quot;JKS&quot; would be considered the same as
&quot;jks&quot;.</p>

<p>Certificate A certificate (also known as a public-key
certificate) is a digi- tally signed statement from one
entity (the issuer), saying that the public key (and some
other information) of another entity (the sub- ject) has
some specific value.</p>

<p>o</p>

<p>o Certificate Terms</p>

<p>Public Keys These are numbers associated with a
particular entity, and are intended to be known to everyone
who needs to have trusted interactions with that entity.
Public keys are used to verify signatures.</p>

<p>Digitally Signed If some data is digitally signed it has
been stored with the &quot;identity&quot; of an entity, and
a signature that proves that entity knows about the data.
The data is rendered unforgeable by signing with the entity
s private key.</p>

<p>Identity A known way of addressing an entity. In some
systems the identity is the public key, in others it can be
anything from a Unix UID to an Email address to an X.509
Distin- guished Name.</p>

<p>Signature A signature is computed over some data using
the private key of an entity (the signer, which in the case
of a cer- tificate is also known as the issuer).</p>

<p>Private Keys These are numbers, each of which is
supposed to be known only to the particular entity whose
private key it is (that is, it s supposed to be kept
secret). Private and public keys exist in pairs in all
public key cryptography systems (also referred to as
&quot;public key crypto systems&quot;). In a typical public
key crypto system, such as DSA, a private key corresponds to
exactly one public key. Private keys are used to compute
signatures.</p>

<p>Entity An entity is a person, organization, program,
computer, business, bank, or something else you are trusting
to some degree.</p>

<p>Basically, public key cryptography requires access to
users pub- lic keys. In a large-scale networked environment
it is impossible to guarantee that prior relationships
between communicating enti- ties have been established or
that a trusted repository exists with all used public keys.
Certificates were invented as a solu- tion to this public
key distribution problem. Now a Certification Authority (CA)
can act as a trusted third party. CAs are entities (for
example, businesses) that are trusted to sign (issue) cer-
tificates for other entities. It is assumed that CAs will
only create valid and reliable certificates, as they are
bound by legal agreements. There are many public
Certification Authori- ties, such as VeriSign @
http://www.verisign.com/, Thawte @ http://www.thawte.com/,
Entrust @ http://www.entrust.com/, and so on. You can also
run your own Certification Authority using products such as
the Netscape/Microsoft Certificate Servers or the Entrust CA
product for your organization.</p>

<p>Using keytool, it is possible to display, import, and
export cer- tificates. It is also possible to generate
self-signed certifi- cates.</p>

<p>keytool currently handles X.509 certificates.</p>

<p>o X.509 Certificates The X.509 standard defines what
information can go into a cer- tificate, and describes how
to write it down (the data format). All the data in a
certificate is encoded using two related stan- dards called
ASN.1/DER. Abstract Syntax Notation 1 describes data. The
Definite Encoding Rules describe a single way to store and
transfer that data.</p>

<p>All X.509 certificates have the following data, in
addition to the signature:</p>

<p>Version This identifies which version of the X.509
standard applies to this certificate, which affects what
information can be specified in it. Thus far, three versions
are defined. key- tool can import and export v1, v2, and v3
certificates. It generates v3 certificates.</p>

<p>X.509 Version 1 has been available since 1988, is widely
deployed, and is the most generic.</p>

<p>X.509 Version 2 introduced the concept of subject and
issuer unique identifiers to handle the possibility of reuse
of sub- ject and/or issuer names over time. Most certificate
profile documents strongly recommend that names not be
reused, and that certificates should not make use of unique
identifiers. Version 2 certificates are not widely used.</p>

<p>X.509 Version 3 is the most recent (1996) and supports
the notion of extensions, whereby anyone can define an
extension and include it in the certificate. Some common
extensions in use today are: KeyUsage (limits the use of the
keys to partic- ular purposes such as
&quot;signing-only&quot;) and AlternativeNames (allows other
identities to also be associated with this pub- lic key,
e.g. DNS names, Email addresses, IP addresses). Extensions
can be marked critical to indicate that the exten- sion
should be checked and enforced/used. For example, if a
certificate has the KeyUsage extension marked critical and
set to &quot;keyCertSign&quot; then if this certificate is
presented during SSL communication, it should be rejected,
as the certificate extension indicates that the associated
private key should only be used for signing certificates and
not for SSL use.</p>

<p>Serial Number The entity that created the certificate is
responsible for assigning it a serial number to distinguish
it from other certificates it issues. This information is
used in numerous ways, for example when a certificate is
revoked its serial number is placed in a Certificate
Revocation List (CRL).</p>

<p>Signature Algorithm Identifier This identifies the
algorithm used by the CA to sign the certificate.</p>

<p>Issuer Name The X.500 Distinguished Name of the entity
that signed the certificate. This is normally a CA. Using
this certificate implies trusting the entity that signed
this certificate. (Note that in some cases, such as root or
top-level CA cer- tificates, the issuer signs its own
certificate.)</p>

<p>Validity Period Each certificate is valid only for a
limited amount of time. This period is described by a start
date and time and an end date and time, and can be as short
as a few seconds or almost as long as a century. The
validity period chosen depends on a number of factors, such
as the strength of the private key used to sign the
certificate or the amount one is willing to pay for a
certificate. This is the expected period that entities can
rely on the public value, if the associated private key has
not been compromised.</p>

<p>Subject Name The name of the entity whose public key the
certificate identifies. This name uses the X.500 standard,
so it is intended to be unique across the Internet. This is
the X.500 Distinguished Name (DN) of the entity, for
example,</p>

<p>CN=Java Duke, OU=Java Software Division, O=Sun
Microsystems Inc, C=US</p>

<p>(These refer to the subject s Common Name,
Organizational Unit, Organization, and Country.)</p>

<p>Subject Public Key Information This is the public key of
the entity being named, together with an algorithm
identifier which specifies which public key crypto system
this key belongs to and any associated key parameters.</p>

<p>o Certificate Chains</p>

<p>keytool can create and manage keystore &quot;key&quot;
entries that each contain a private key and an associated
certificate &quot;chain&quot;. The first certificate in the
chain contains the public key corre- sponding to the private
key.</p>

<p>When keys are first generated (see the -genkeypair
command), the chain starts off containing a single element,
a self-signed cer- tificate. A self-signed certificate is
one for which the issuer (signer) is the same as the subject
(the entity whose public key is being authenticated by the
certificate). Whenever the -genkey- pair command is called
to generate a new public/private key pair, it also wraps the
public key into a self-signed certificate.</p>

<p>Later, after a Certificate Signing Request (CSR) has
been gener- ated (see the -certreq command) and sent to a
Certification Authority (CA), the response from the CA is
imported (see -importcert), and the self-signed certificate
is replaced by a chain of certificates. At the bottom of the
chain is the certificate (reply) issued by the CA
authenticating the subjects public key. The next certificate
in the chain is one that authen- ticates the CAs public
key.</p>

<p>In many cases, this is a self-signed certificate (that
is, a cer- tificate from the CA authenticating its own
public key) and the last certificate in the chain. In other
cases, the CA may return a chain of certificates. In this
case, the bottom certificate in the chain is the same (a
certificate signed by the CA, authenti- cating the public
key of the key entry), but the second certifi- cate in the
chain is a certificate signed by a different CA,
authenticating the public key of the CA you sent the CSR to.
Then, the next certificate in the chain will be a
certificate authenticating the second CAs key, and so on,
until a self-signed &quot;root&quot; certificate is reached.
Each certificate in the chain (after the first) thus
authenticates the public key of the signer of the previous
certificate in the chain.</p>

<p>Many CAs only return the issued certificate, with no
supporting chain, especially when there is a flat hierarchy
(no intermedi- ates CAs). In this case, the certificate
chain must be estab- lished from trusted certificate
information already stored in the keystore.</p>

<p>A different reply format (defined by the PKCS#7
standard) also includes the supporting certificate chain, in
addition to the issued certificate. Both reply formats can
be handled by keytool.</p>

<p>The top-level (root) CA certificate is self-signed.
However, the trust into the roots public key does not come
from the root cer- tificate itself (anybody could generate a
self-signed certificate with the distinguished name of say,
the VeriSign root CA!), but from other sources like a
newspaper. The root CA public key is widely known. The only
reason it is stored in a certificate is because this is the
format understood by most tools, so the cer- tificate in
this case is only used as a &quot;vehicle&quot; to transport
the root CAs public key. Before you add the root CA
certificate to your keystore, you should view it (using the
-printcert option) and compare the displayed fingerprint
with the well-known fingerprint (obtained from a newspaper,
the root CAs webpage, etc.).</p>

<p>o The cacerts Certificates File</p>

<p>A certificates file named &quot;cacerts&quot; resides in
the security prop- erties directory, java.home/lib/security,
where java.home is the runtime environments directory (the
jre directory in the SDK or the top-level directory of the
Java 2 Runtime Environment).</p>

<p>The &quot;cacerts&quot; file represents a system-wide
keystore with CA cer- tificates. System administrators can
configure and manage that file using keytool, specifying
&quot;jks&quot; as the keystore type. The
&quot;cacerts&quot; keystore file ships with several root CA
certificates with the following aliases and X.500 owner
distinguished names:</p>

<p>* Alias: thawtepersonalfreemailca Owner DN:
EmailAddress=personal-freemail@thawte.com, CN=Thawte
Personal Freemail CA, OU=Certification Services Division,
O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</p>

<p>* Alias: thawtepersonalbasicca Owner DN:
EmailAddress=personal-basic@thawte.com, CN=Thawte Personal
Basic CA, OU=Certification Services Division, O=Thawte
Consulting, L=Cape Town, ST=Western Cape, C=ZA</p>

<p>* Alias: thawtepersonalpremiumca Owner DN:
EmailAddress=personal-premium@thawte.com, CN=Thawte Personal
Premium CA, OU=Certification Services Division, O=Thawte
Consulting, L=Cape Town, ST=Western Cape, C=ZA</p>

<p>* Alias: thawteserverca Owner DN:
EmailAddress=server-certs@thawte.com, CN=Thawte Server CA,
OU=Certification Services Division, O=Thawte Consulting cc,
L=Cape Town, ST=Western Cape, C=ZA</p>

<p>* Alias: thawtepremiumserverca Owner DN:
EmailAddress=premium-server@thawte.com, CN=Thawte Premium
Server CA, OU=Certification Services Division, O=Thawte
Consulting cc, L=Cape Town, ST=Western Cape, C=ZA</p>

<p>* Alias: verisignclass1ca Owner DN: OU=Class 1 Public
Primary Certification Authority, O=&quot;VeriSign,
Inc.&quot;, C=US</p>

<p>* Alias: verisignclass2ca Owner DN: OU=Class 2 Public
Primary Certification Authority, O=&quot;VeriSign,
Inc.&quot;, C=US</p>

<p>* Alias: verisignclass3ca Owner DN: OU=Class 3 Public
Primary Certification Authority, O=&quot;VeriSign,
Inc.&quot;, C=US</p>

<p>* Alias: verisignserverca Owner DN: OU=Secure Server
Certification Authority, O=&quot;RSA Data Security,
Inc.&quot;, C=US</p>

<p>* Alias: verisignclass1g2ca Owner DN: OU=VeriSign Trust
Network, OU=&quot;(c) 1998 VeriSign, Inc. - For authorized
use only&quot;, OU=Class 1 Public Primary Certification
Authority - G2, O=&quot;VeriSign, Inc.&quot;, C=US</p>

<p>* Alias: verisignclass1g3ca Owner DN: CN=VeriSign Class
1 Public Primary Certification Authority - G3, OU=&quot;(c)
1999 VeriSign, Inc. - For authorized use only&quot;,
OU=VeriSign Trust Network, O=&quot;VeriSign, Inc.&quot;,
C=US</p>

<p>* Alias: verisignclass2g2ca Owner DN: OU=VeriSign Trust
Network, OU=&quot;(c) 1998 VeriSign, Inc. - For authorized
use only&quot;, OU=Class 2 Public Primary Certification
Authority - G2, O=&quot;VeriSign, Inc.&quot;, C=US</p>

<p>* Alias: verisignclass2g3ca Owner DN: CN=VeriSign Class
2 Public Primary Certification Authority - G3, OU=&quot;(c)
1999 VeriSign, Inc. - For authorized use only&quot;,
OU=VeriSign Trust Network, O=&quot;VeriSign, Inc.&quot;,
C=US</p>

<p>* Alias: verisignclass3g2ca Owner DN: OU=VeriSign Trust
Network, OU=&quot;(c) 1998 VeriSign, Inc. - For authorized
use only&quot;, OU=Class 3 Public Primary Certification
Authority - G2, O=&quot;VeriSign, Inc.&quot;, C=US</p>

<p>* Alias: verisignclass3g3ca Owner DN: CN=VeriSign Class
3 Public Primary Certification Authority - G3, OU=&quot;(c)
1999 VeriSign, Inc. - For authorized use only&quot;,
OU=VeriSign Trust Network, O=&quot;VeriSign, Inc.&quot;,
C=US</p>

<p>* Alias: baltimorecodesigningca Owner DN: CN=Baltimore
CyberTrust Code Signing Root, OU=CyberTrust, O=Baltimore,
C=IE</p>

<p>* Alias: gtecybertrustglobalca Owner DN: CN=GTE
CyberTrust Global Root, OU=&quot;GTE CyberTrust Solutions,
Inc.&quot;, O=GTE Corporation, C=US</p>

<p>* Alias: baltimorecybertrustca Owner DN: CN=Baltimore
CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE</p>

<p>* Alias: gtecybertrustca Owner DN: CN=GTE CyberTrust
Root, O=GTE Corporation, C=US</p>

<p>* Alias: gtecybertrust5ca Owner DN: CN=GTE CyberTrust
Root 5, OU=&quot;GTE CyberTrust Solutions, Inc.&quot;, O=GTE
Corporation, C=US</p>

<p>* Alias: entrustclientca Owner DN: CN=Entrust.net Client
Certification Authority, OU=(c) 1999 Entrust.net Limited,
OU=www.entrust.net/Client_CA_Info/CPS incorp. by ref. limits
liab., O=Entrust.net, C=US</p>

<p>* Alias: entrustglobalclientca Owner DN: CN=Entrust.net
Client Certification Authority, OU=(c) 2000 Entrust.net
Limited, OU=www.entrust.net/GCCA_CPS incorp. by ref. (limits
liab.), O=Entrust.net</p>

<p>* Alias: entrust2048ca Owner DN: CN=Entrust.net
Certification Authority (2048), OU=(c) 1999 Entrust.net
Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits
liab.), O=Entrust.net</p>

<p>* Alias: entrustsslca Owner DN: CN=Entrust.net Secure
Server Certification Author- ity, OU=(c) 1999 Entrust.net
Limited, OU=www.entrust.net/CPS incorp. by ref. (limits
liab.), O=Entrust.net, C=US</p>

<p>* Alias: entrustgsslca Owner DN: CN=Entrust.net Secure
Server Certification Author- ity, OU=(c) 2000 Entrust.net
Limited, OU=www.entrust.net/SSL_CPS incorp. by ref. (limits
liab.), O=Entrust.net</p>

<p>* Alias: godaddyclass2ca Owner DN: OU=Go Daddy Class 2
Certification Authority, O=&quot;The Go Daddy Group,
Inc.&quot;, C=US</p>

<p>* Alias: starfieldclass2ca Owner DN: OU=Starfield Class
2 Certification Authority, O=&quot;Starfield Technologies,
Inc.&quot;, C=US</p>

<p>* Alias: valicertclass2ca Owner DN:
EMAILADDRESS=info@valicert.com, CN=http://www.valicert.com/,
OU=ValiCert Class 2 Policy Validation Authority,
O=&quot;ValiCert, Inc.&quot;, L=ValiCert Validation
Network</p>

<p>* Alias: geotrustglobalca Owner DN: CN=GeoTrust Global
CA, O=GeoTrust Inc., C=US</p>

<p>* Alias: equifaxsecureca Owner DN: OU=Equifax Secure
Certificate Authority, O=Equifax, C=US</p>

<p>* Alias: equifaxsecureebusinessca1 Owner DN: CN=Equifax
Secure eBusiness CA-1, O=Equifax Secure Inc., C=US</p>

<p>* Alias: equifaxsecureebusinessca2 Owner DN: OU=Equifax
Secure eBusiness CA-2, O=Equifax Secure, C=US</p>

<p>* Alias: equifaxsecureglobalebusinessca1 Owner DN:
CN=Equifax Secure Global eBusiness CA-1, O=Equifax Secure
Inc., C=US</p>

<p>* Alias: soneraclass1ca Owner DN: CN=Sonera Class1 CA,
O=Sonera, C=FI</p>

<p>* Alias: soneraclass2ca Owner DN: CN=Sonera Class2 CA,
O=Sonera, C=FI</p>

<p>* Alias: comodoaaaca Owner DN: CN=AAA Certificate
Services, O=Comodo CA Limited, L=Salford, ST=Greater
Manchester, C=GB</p>

<p>* Alias: addtrustclass1ca Owner DN: CN=AddTrust Class 1
CA Root, OU=AddTrust TTP Network, O=AddTrust AB, C=SE</p>

<p>* Alias: addtrustexternalca Owner DN: CN=AddTrust
External CA Root, OU=AddTrust External TTP Network,
O=AddTrust AB, C=SE</p>

<p>* Alias: addtrustqualifiedca Owner DN: CN=AddTrust
Qualified CA Root, OU=AddTrust TTP Network, O=AddTrust AB,
C=SE</p>

<p>* Alias: utnuserfirsthardwareca Owner DN:
CN=UTN-USERFirst-Hardware, OU=http://www.usertrust.com,
O=The USERTRUST Network, L=Salt Lake City, ST=UT, C=US</p>

<p>* Alias: utnuserfirstclientauthemailca Owner DN:
CN=UTN-USERFirst-Client Authentication and Email,
OU=http://www.usertrust.com, O=The USERTRUST Network, L=Salt
Lake City, ST=UT, C=US</p>

<p>* Alias: utndatacorpsgcca Owner DN: CN=UTN - DATACorp
SGC, OU=http://www.usertrust.com, O=The USERTRUST Network,
L=Salt Lake City, ST=UT, C=US</p>

<p>* Alias: utnuserfirstobjectca Owner DN:
CN=UTN-USERFirst-Object, OU=http://www.usertrust.com, O=The
USERTRUST Network, L=Salt Lake City, ST=UT, C=US</p>

<p>The initial password of the &quot;cacerts&quot; keystore
file is &quot;changeit&quot;. System administrators should
change that password and the default access permission of
that file upon installing the SDK.</p>

<p>IMPORTANT: Verify Your cacerts File</p>

<p>Since you trust the CAs in the cacerts file as entities
for signing and issuing certificates to other entities, you
must manage the cacerts file carefully. The cacerts file
should contain only certificates of the CAs you trust. It is
your responsibility to verify the trusted root CA
certificates bun- dled in the cacerts file and make your own
trust decisions. To remove an untrusted CA certificate from
the cacerts file, use the delete option of the keytool
command. You can find the cacerts file in the JRE
installation directory. Contact your system administrator if
you do not have permission to edit this file.</p>

<p>o The Internet RFC 1421 Certificate Encoding
Standard</p>

<p>Certificates are often stored using the printable
encoding format defined by the Internet RFC 1421 standard,
instead of their binary encoding. This certificate format,
also known as &quot;Base 64 encoding&quot;, facilitates
exporting certificates to other applica- tions by email or
through some other mechanism.</p>

<p>Certificates read by the -importcert and -printcert
commands can be in either this format or binary encoded.</p>

<p>The -exportcert command by default outputs a certificate
in binary encoding, but will instead output a certificate in
the printable encoding format, if the -rfc option is
specified.</p>

<p>The -list command by default prints the MD5 fingerprint
of a cer- tificate. If the -v option is specified, the
certificate is printed in human-readable format, while if
the -rfc option is specified, the certificate is output in
the printable encoding format.</p>

<p>In its printable encoding format, the encoded
certificate is bounded at the beginning by</p>

<p>-----BEGIN CERTIFICATE-----</p>

<p>and at the end by</p>

<p>-----END CERTIFICATE-----</p>

<p>X.500 Distinguished Names X.500 Distinguished Names are
used to identify entities, such as those which are named by
the subject and issuer (signer) fields of X.509
certificates. keytool supports the following subparts:</p>

<p>o commonName - common name of a person, e.g.,
&quot;Susan Jones&quot;</p>

<p>o organizationUnit - small organization (e.g, department
or divi- sion) name, e.g., &quot;Purchasing&quot;</p>

<p>o organizationName - large organization name, e.g.,
&quot;ABCSystems, Inc.&quot;</p>

<p>o localityName - locality (city) name, e.g., &quot;Palo
Alto&quot;</p>

<p>o stateName - state or province name, e.g.,
&quot;California&quot;</p>

<p>o country - two-letter country code, e.g.,
&quot;CH&quot;</p>

<p>When supplying a distinguished name string as the value
of a -dname option, as for the -genkeypair command, the
string must be in the following format:</p>

<p>CN=cName, OU=orgUnit, O=org, L=city, S=state,
C=countryCode</p>

<p>where all the italicized items represent actual values
and the above keywords are abbreviations for the
following:</p>

<p>CN=commonName OU=organizationUnit O=organizationName
L=localityName S=stateName C=country</p>

<p>A sample distinguished name string is</p>

<p>CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino,
S=California, C=US</p>

<p>and a sample command using such a string is</p>

<p>keytool -genkeypair -dname &quot;CN=Mark Smith,
OU=JavaSoft, O=Sun, L=Cupertino, S=California, C=US&quot;
-alias mark</p>

<p>Case does not matter for the keyword abbreviations. For
example, &quot;CN&quot;, &quot;cn&quot;, and &quot;Cn&quot;
are all treated the same.</p>

<p>Order matters; each subcomponent must appear in the
designated order. However, it is not necessary to have all
the subcomponents. You may use a subset, for example:</p>

<p>CN=Steve Meier, OU=SunSoft, O=Sun, C=US</p>

<p>If a distinguished name string value contains a comma,
the comma must be escaped by a &quot; command line, as
in</p>

<p>cn=peter schuster, o=Sun Microsystem, Inc., o=sun,
c=us</p>

<p>It is never necessary to specify a distinguished name
string on a command line. If it is needed for a command, but
not supplied on the command line, the user is prompted for
each of the subcomponents. In this case, a comma does not
need to be escaped by a &quot;</p>

<p>WARNING Regarding Importing Trusted Certificates
IMPORTANT: Be sure to check a certificate very carefully
before importing it as a trusted certificate!</p>

<p>View it first (using the -printcert command, or the
-importcert com- mand without the -noprompt option), and
make sure that the displayed certificate fingerprint(s)
match the expected ones. For example, suppose someone sends
or emails you a certificate, and you put it in a file named
/tmp/cert. Before you consider adding the certificate to
your list of trusted certificates, you can execute a
-printcert command to view its fingerprints, as in</p>

<p>keytool -printcert -file /tmp/cert Owner: CN=ll, OU=ll,
O=ll, L=ll, S=ll, C=ll Issuer: CN=ll, OU=ll, O=ll, L=ll,
S=ll, C=ll Serial Number: 59092b34 Valid from: Thu Sep 25
18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints: MD5:
11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F SHA1:
20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE</p>

<p>Then call or otherwise contact the person who sent the
certificate, and compare the fingerprint(s) that you see
with the ones that they show. Only if the fingerprints are
equal is it guaranteed that the certificate has not been
replaced in transit with somebody elses (for example, an
attacker s) certificate. If such an attack took place, and
you did not check the certificate before you imported it,
you would end up trusting anything the attacker has signed
(for example, a JAR file with malicious class files
inside).</p>

<p>Note: it is not required that you execute a -printcert
command prior to importing a certificate, since before
adding a certificate to the list of trusted certificates in
the keystore, the -importcert com- mand prints out the
certificate information and prompts you to ver- ify it. You
then have the option of aborting the import operation. Note,
however, this is only the case if you invoke the -importcert
command without the -noprompt option. If the -noprompt
option is given, there is no interaction with the user.</p>

<p>Warning Regarding Passwords Most commands operating on a
keystore require the store password. Some commands require a
private/secret key password.</p>

<p>Passwords can be specified on the command line (in the
-storepass and -keypass options, respectively). However, a
password should not be specified on a command line or in a
script unless it is for test- ing purposes, or you are on a
secure system.</p>

<p>If you dont specify a required password option on a
command line, you will be prompted for it.</p>

<p>SEE ALSO o jar @
http://java.sun.com/javase/6/docs/tooldocs/solaris/jar.html
tool documentation</p>

<p>o jarsigner @
http://java.sun.com/javase/6/docs/tooldocs/solaris/jarsigner.html
tool documentation</p>

<p>o the Security @
http://java.sun.com/docs/books/tutorial/security/index.html
trail of the Java Tutorial @
http://java.sun.com/docs/books/tutorial/trailmap.html for
examples of the use of keytool</p>

<p>CHANGES The command interface for keytool changed in
Java SE 6.</p>

<p>keytool no longer displays password input when entered
by users. Since password input can no longer be viewed when
entered, users will be prompted to re-enter passwords any
time a password is being set or changed (for example, when
setting the initial keystore password, or when changing a
key password).</p>

<p>Some commands have simply been renamed, and other
commands deemed obso- lete are no longer listed in this
document. All previous commands (both renamed and obsolete)
are still supported in this release and will con- tinue to
be supported in future releases. The following summarizes
all of the changes made to the keytool command
interface:</p>

<p>Renamed commands:</p>

<p>o -export, renamed to -exportcert</p>

<p>o -genkey, renamed to -genkeypair</p>

<p>o -import, renamed to -importcert</p>

<p>Commands deemed obsolete and no longer documented:</p>

<p>o -keyclone @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/key-
tool.html#keycloneCmd</p>

<p>o -identitydb @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/key-
tool.html#identitydbCmd</p>

<p>o -selfcert @
http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/key-
tool.html#selfcertCmd</p>

<p>07 Aug 2006 keytool(1)</p>
<hr>
</body>
</html>
