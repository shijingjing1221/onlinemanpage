<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLTOOT(1) Perl Programmers Reference Guide
PERLTOOT(1)</p>

<p>NAME perltoot - Toms object-oriented tutorial for
perl</p>

<p>DESCRIPTION Object-oriented programming is a big seller
these days. Some managers would rather have objects than
sliced bread. Why is that? Whats so special about an object?
Just what is an object anyway?</p>

<p>An object is nothing but a way of tucking away complex
behaviours into a neat little easy-to-use bundle. (This is
what professors call abstraction.) Smart people who have
nothing to do but sit around for weeks on end figuring out
really hard problems make these nifty objects that even
regular people can use. (This is what professors call
software reuse.) Users (well, programmers) can play with
this little bundle all they want, but they arent to open it
up and mess with the insides. Just like an expensive piece
of hardware, the contract says that you void the warranty if
you muck with the cover. So dont do that.</p>

<p>The heart of objects is the class, a protected little
private namespace full of data and functions. A class is a
set of related routines that addresses some problem area.
You can think of it as a user-defined type. The Perl package
mechanism, also used for more traditional modules, is used
for class modules as well. Objects &quot;live&quot; in a
class, meaning that they belong to some package.</p>

<p>More often than not, the class provides the user with
little bundles. These bundles are objects. They know whose
class they belong to, and how to behave. Users ask the class
to do something, like &quot;give me an object.&quot; Or they
can ask one of these objects to do something. Asking a class
to do something for you is calling a class method. Asking an
object to do something for you is calling an object method.
Asking either a class (usually) or an object (sometimes) to
give you back an object is calling a constructor, which is
just a kind of method.</p>

<p>Thats all well and good, but how is an object different
from any other Perl data type? Just what is an object
really; that is, whats its fundamental type? The answer to
the first question is easy. An object is different from any
other data type in Perl in one and only one way: you may
dereference it using not merely string or numeric subscripts
as with simple arrays and hashes, but with named subroutine
calls. In a word, with methods.</p>

<p>The answer to the second question is that its a
reference, and not just any reference, mind you, but one
whose referent has been bless()ed into a particular class
(read: package). What kind of reference? Well, the answer to
that one is a bit less concrete. That s because in Perl the
designer of the class can employ any sort of reference theyd
like as the underlying intrinsic data type. It could be a
scalar, an array, or a hash reference. It could even be a
code reference. But because of its inherent flexibility, an
object is usually a hash reference.</p>

<p>Creating a Class Before you create a class, you need to
decide what to name it. Thats because the class (package)
name governs the name of the file used to house it, just as
with regular modules. Then, that class (package) should
provide one or more ways to generate objects. Finally, it
should provide mechanisms to allow users of its objects to
indirectly manipulate these objects from a distance.</p>

<p>For example, lets make a simple Person class module. It
gets stored in the file Person.pm. If it were called a
Happy::Person class, it would be stored in the file
Happy/Person.pm, and its package would become Happy::Person
instead of just Person. (On a personal computer not running
Unix or Plan 9, but something like Mac OS or VMS, the
directory separator may be different, but the principle is
the same.) Do not assume any formal relationship between
modules based on their directory names. This is merely a
grouping convenience, and has no effect on inheritance,
variable accessibility, or anything else.</p>

<p>For this module we arent going to use Exporter, because
we re a well- behaved class module that doesnt export
anything at all. In order to manufacture objects, a class
needs to have a constructor method. A constructor gives you
back not just a regular data type, but a brand- new object
in that class. This magic is taken care of by the bless()
function, whose sole purpose is to enable its referent to be
used as an object. Remember: being an object really means
nothing more than that methods may now be called against
it.</p>

<p>While a constructor may be named anything youd like,
most Perl programmers seem to like to call theirs new().
However, new() is not a reserved word, and a class is under
no obligation to supply such. Some programmers have also
been known to use a function with the same name as the class
as the constructor.</p>

<p>Object Representation By far the most common mechanism
used in Perl to represent a Pascal record, a C struct, or a
C++ class is an anonymous hash. Thats because a hash has an
arbitrary number of data fields, each conveniently accessed
by an arbitrary name of your own devising.</p>

<p>If you were just doing a simple struct-like emulation,
you would likely go about it something like this:</p>

<p>$rec = { name =&gt; &quot;Jason&quot;, age =&gt; 23,
peers =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;,
&quot;Phineas&quot;], };</p>

<p>If you felt like it, you could add a bit of visual
distinction by up- casing the hash keys:</p>

<p>$rec = { NAME =&gt; &quot;Jason&quot;, AGE =&gt; 23,
PEERS =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;,
&quot;Phineas&quot;], };</p>

<p>And so you could get at &quot;$rec-&gt;{NAME}&quot; to
find &quot;Jason&quot;, or &quot;@{ $rec-&gt;{PEERS} }&quot;
to get at &quot;Norbert&quot;, &quot;Rhys&quot;, and
&quot;Phineas&quot;. (Have you ever noticed how many
23-year-old programmers seem to be named &quot;Jason&quot;
these days? :-)</p>

<p>This same model is often used for classes, although it
is not considered the pinnacle of programming propriety for
folks from outside the class to come waltzing into an
object, brazenly accessing its data members directly.
Generally speaking, an object should be considered an opaque
cookie that you use object methods to access. Visually,
methods look like you re dereffing a reference using a
function name instead of brackets or braces.</p>

<p>Class Interface Some languages provide a formal
syntactic interface to a classs methods, but Perl does not.
It relies on you to read the documentation of each class. If
you try to call an undefined method on an object, Perl won t
complain, but the program will trigger an exception while
its running. Likewise, if you call a method expecting a
prime number as its argument with a non-prime one instead,
you cant expect the compiler to catch this. (Well, you can
expect it all you like, but its not going to happen.)</p>

<p>Let s suppose you have a well-educated user of your
Person class, someone who has read the docs that explain the
prescribed interface. Heres how they might use the Person
class:</p>

<p>use Person;</p>

<p>$him = Person-&gt;new();
$him-&gt;name(&quot;Jason&quot;); $him-&gt;age(23);
$him-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;,
&quot;Phineas&quot; );</p>

<p>push @All_Recs, $him; # save object in array for
later</p>

<p>printf &quot;%s is %d years old.0, $him-&gt;name,
$him-&gt;age; print &quot;His peers are: &quot;,
join(&quot;, &quot;, $him-&gt;peers), &quot;0;</p>

<p>printf &quot;Last rec&rsquo;s name is %s0,
$All_Recs[-1]-&gt;name;</p>

<p>As you can see, the user of the class doesnt know (or at
least, has no business paying attention to the fact) that
the object has one particular implementation or another. The
interface to the class and its objects is exclusively via
methods, and thats all the user of the class should ever
play with.</p>

<p>Constructors and Instance Methods Still, someone has to
know whats in the object. And that someone is the class. It
implements methods that the programmer uses to access the
object. Heres how to implement the Person class using the
standard hash-ref-as-an-object idiom. Well make a class
method called new() to act as the constructor, and three
object methods called name(), age(), and peers() to get at
per-object data hidden away in our anonymous hash.</p>

<p>package Person; use strict;</p>

<p>################################################## ##
the object constructor (simplistic version) ##
################################################## sub new {
my $self = {}; $self-&gt;{NAME} = undef; $self-&gt;{AGE} =
undef; $self-&gt;{PEERS} = []; bless($self); # but see below
return $self; }</p>

<p>############################################## ##
methods to access per-object data ## ## ## ## With args,
they set the value. Without ## ## any, they only retrieve
it/them. ##
##############################################</p>

<p>sub name { my $self = shift; if (@_) { $self-&gt;{NAME}
= shift } return $self-&gt;{NAME}; }</p>

<p>sub age { my $self = shift; if (@_) { $self-&gt;{AGE} =
shift } return $self-&gt;{AGE}; }</p>

<p>sub peers { my $self = shift; if (@_) { @{
$self-&gt;{PEERS} } = @_ } return @{ $self-&gt;{PEERS} };
}</p>

<p>1; # so the require or use succeeds</p>

<p>Weve created three methods to access an object s data,
name(), age(), and peers(). These are all substantially
similar. If called with an argument, they set the
appropriate field; otherwise they return the value held by
that field, meaning the value of that hash key.</p>

<p>Planning for the Future: Better Constructors Even though
at this point you may not even know what it means, someday
you re going to worry about inheritance. (You can safely
ignore this for now and worry about it later if youd like.)
To ensure that this all works out smoothly, you must use the
double-argument form of bless(). The second argument is the
class into which the referent will be blessed. By not
assuming our own class as the default second argument and
instead using the class passed into us, we make our
constructor inheritable.</p>

<p>sub new { my $class = shift; my $self = {};
$self-&gt;{NAME} = undef; $self-&gt;{AGE} = undef;
$self-&gt;{PEERS} = []; bless ($self, $class); return $self;
}</p>

<p>That s about all there is for constructors. These
methods bring objects to life, returning neat little opaque
bundles to the user to be used in subsequent method
calls.</p>

<p>Destructors Every story has a beginning and an end. The
beginning of the objects story is its constructor,
explicitly called when the object comes into existence. But
the ending of its story is the destructor, a method
implicitly called when an object leaves this life. Any
per-object clean-up code is placed in the destructor, which
must (in Perl) be called DESTROY.</p>

<p>If constructors can have arbitrary names, then why not
destructors? Because while a constructor is explicitly
called, a destructor is not. Destruction happens
automatically via Perl s garbage collection (GC) system,
which is a quick but somewhat lazy reference-based GC
system. To know what to call, Perl insists that the
destructor be named DESTROY. Perl s notion of the right time
to call a destructor is not well-defined currently, which is
why your destructors should not rely on when they are
called.</p>

<p>Why is DESTROY in all caps? Perl on occasion uses purely
uppercase function names as a convention to indicate that
the function will be automatically called by Perl in some
way. Others that are called implicitly include BEGIN, END,
AUTOLOAD, plus all methods used by tied objects, described
in perltie.</p>

<p>In really good object-oriented programming languages,
the user doesnt care when the destructor is called. It just
happens when its supposed to. In low-level languages without
any GC at all, theres no way to depend on this happening at
the right time, so the programmer must explicitly call the
destructor to clean up memory and state, crossing their
fingers that its the right time to do so. Unlike C++, an
object destructor is nearly never needed in Perl, and even
when it is, explicit invocation is uncalled for. In the case
of our Person class, we don t need a destructor because Perl
takes care of simple matters like memory deallocation.</p>

<p>The only situation where Perls reference-based GC won t
work is when theres a circularity in the data structure,
such as:</p>

<p>$this-&gt;{WHATEVER} = $this;</p>

<p>In that case, you must delete the self-reference
manually if you expect your program not to leak memory.
While admittedly error-prone, this is the best we can do
right now. Nonetheless, rest assured that when your program
is finished, its objects destructors are all duly called. So
you are guaranteed that an object eventually gets properly
destroyed, except in the unique case of a program that never
exits. (If youre running Perl embedded in another
application, this full GC pass happens a bit more
frequently--whenever a thread shuts down.)</p>

<p>Other Object Methods The methods weve talked about so
far have either been constructors or else simple &quot;data
methods&quot;, interfaces to data stored in the object.
These are a bit like an objects data members in the C++
world, except that strangers don t access them as data.
Instead, they should only access the objects data indirectly
via its methods. This is an important rule: in Perl, access
to an objects data should only be made through methods.</p>

<p>Perl doesnt impose restrictions on who gets to use which
methods. The public-versus-private distinction is by
convention, not syntax. (Well, unless you use the Alias
module described below in &quot;Data Members as
Variables&quot;.) Occasionally you ll see method names
beginning or ending with an underscore or two. This marking
is a convention indicating that the methods are private to
that class alone and sometimes to its closest acquaintances,
its immediate subclasses. But this distinction is not
enforced by Perl itself. Its up to the programmer to
behave.</p>

<p>Theres no reason to limit methods to those that simply
access data. Methods can do anything at all. The key point
is that theyre invoked against an object or a class. Lets
say we d like object methods that do more than fetch or set
one particular field.</p>

<p>sub exclaim { my $self = shift; return sprintf &quot;Hi,
I&rsquo;m %s, age %d, working with %s&quot;,
$self-&gt;{NAME}, $self-&gt;{AGE}, join(&quot;, &quot;,
@{$self-&gt;{PEERS}}); }</p>

<p>Or maybe even one like this:</p>

<p>sub happy_birthday { my $self = shift; return
++$self-&gt;{AGE}; }</p>

<p>Some might argue that one should go at these this
way:</p>

<p>sub exclaim { my $self = shift; return sprintf &quot;Hi,
I&rsquo;m %s, age %d, working with %s&quot;, $self-&gt;name,
$self-&gt;age, join(&quot;, &quot;, $self-&gt;peers); }</p>

<p>sub happy_birthday { my $self = shift; return
$self-&gt;age( $self-&gt;age() + 1 ); }</p>

<p>But since these methods are all executing in the class
itself, this may not be critical. There are tradeoffs to be
made. Using direct hash access is faster (about an order of
magnitude faster, in fact), and its more convenient when you
want to interpolate in strings. But using methods (the
external interface) internally shields not just the users of
your class but even you yourself from changes in your data
representation.</p>

<p>Class Data What about &quot;class data&quot;, data items
common to each object in a class? What would you want that
for? Well, in your Person class, you might like to keep
track of the total people alive. How do you implement
that?</p>

<p>You could make it a global variable called
$Person::Census. But about only reason youd do that would be
if you wanted people to be able to get at your class data
directly. They could just say $Person::Census and play
around with it. Maybe this is ok in your design scheme. You
might even conceivably want to make it an exported variable.
To be exportable, a variable must be a (package) global. If
this were a traditional module rather than an
object-oriented one, you might do that.</p>

<p>While this approach is expected in most traditional
modules, its generally considered rather poor form in most
object modules. In an object module, you should set up a
protective veil to separate interface from implementation.
So provide a class method to access class data just as you
provide object methods to access object data.</p>

<p>So, you could still keep $Census as a package global and
rely upon others to honor the contract of the module and
therefore not play around with its implementation. You could
even be supertricky and make $Census a tied object as
described in perltie, thereby intercepting all accesses.</p>

<p>But more often than not, you just want to make your
class data a file- scoped lexical. To do so, simply put this
at the top of the file:</p>

<p>my $Census = 0;</p>

<p>Even though the scope of a my() normally expires when
the block in which it was declared is done (in this case the
whole file being required or used), Perls deep binding of
lexical variables guarantees that the variable will not be
deallocated, remaining accessible to functions declared
within that scope. This doesn t work with global variables
given temporary values via local(), though.</p>

<p>Irrespective of whether you leave $Census a package
global or make it instead a file-scoped lexical, you should
make these changes to your Person::new() constructor:</p>

<p>sub new { my $class = shift; my $self = {}; $Census++;
$self-&gt;{NAME} = undef; $self-&gt;{AGE} = undef;
$self-&gt;{PEERS} = []; bless ($self, $class); return $self;
}</p>

<p>sub population { return $Census; }</p>

<p>Now that weve done this, we certainly do need a
destructor so that when Person is destroyed, the $Census
goes down. Here s how this could be done:</p>

<p>sub DESTROY { --$Census }</p>

<p>Notice how there s no memory to deallocate in the
destructor? Thats something that Perl takes care of for you
all by itself.</p>

<p>Alternatively, you could use the
Class::Data::Inheritable module from CPAN.</p>

<p>Accessing Class Data It turns out that this is not
really a good way to go about handling class data. A good
scalable rule is that you must never reference class data
directly from an object method. Otherwise you arent building
a scalable, inheritable class. The object must be the
rendezvous point for all operations, especially from an
object method. The globals (class data) would in some sense
be in the &quot;wrong&quot; package in your derived classes.
In Perl, methods execute in the context of the class they
were defined in, not that of the object that triggered them.
Therefore, namespace visibility of package globals in
methods is unrelated to inheritance.</p>

<p>Got that? Maybe not. Ok, lets say that some other class
&quot;borrowed&quot; (well, inherited) the DESTROY method as
it was defined above. When those objects are destroyed, the
original $Census variable will be altered, not the one in
the new classs package namespace. Perhaps this is what you
want, but probably it isnt.</p>

<p>Heres how to fix this. Well store a reference to the
data in the value accessed by the hash key
&quot;_CENSUS&quot;. Why the underscore? Well, mostly
because an initial underscore already conveys strong
feelings of magicalness to a C programmer. Its really just a
mnemonic device to remind ourselves that this field is
special and not to be used as a public data member in the
same way that NAME, AGE, and PEERS are. (Because weve been
developing this code under the strict pragma, prior to perl
version 5.004 well have to quote the field name.)</p>

<p>sub new { my $class = shift; my $self = {};
$self-&gt;{NAME} = undef; $self-&gt;{AGE} = undef;
$self-&gt;{PEERS} = []; # &quot;private&quot; data
$self-&gt;{&quot;_CENSUS&quot;} = ensus; bless ($self,
$class); ++ ${ $self-&gt;{&quot;_CENSUS&quot;} }; return
$self; }</p>

<p>sub population { my $self = shift; if (ref $self) {
return ${ $self-&gt;{&quot;_CENSUS&quot;} }; } else { return
$Census; } }</p>

<p>sub DESTROY { my $self = shift; -- ${
$self-&gt;{&quot;_CENSUS&quot;} }; }</p>

<p>Debugging Methods Its common for a class to have a
debugging mechanism. For example, you might want to see when
objects are created or destroyed. To do that, add a
debugging variable as a file-scoped lexical. For this, well
pull in the standard Carp module to emit our warnings and
fatal messages. That way messages will come out with the
caller s filename and line number instead of our own; if we
wanted them to be from our own perspective, wed just use
die() and warn() directly instead of croak() and carp()
respectively.</p>

<p>use Carp; my $Debugging = 0;</p>

<p>Now add a new class method to access the variable.</p>

<p>sub debug { my $class = shift; if (ref $class) { confess
&quot;Class method called as object method&quot; } unless
(@_ == 1) { confess &quot;usage:
CLASSNAME-&gt;debug(level)&quot; } $Debugging = shift; }</p>

<p>Now fix up DESTROY to murmur a bit as the moribund
object expires:</p>

<p>sub DESTROY { my $self = shift; if ($Debugging) { carp
&quot;Destroying $self &quot; . $self-&gt;name } -- ${
$self-&gt;{&quot;_CENSUS&quot;} }; }</p>

<p>One could conceivably make a per-object debug state.
That way you could call both of these:</p>

<p>Person-&gt;debug(1); # entire class $him-&gt;debug(1); #
just this object</p>

<p>To do so, we need our debugging method to be a
&quot;bimodal&quot; one, one that works on both classes and
objects. Therefore, adjust the debug() and DESTROY methods
as follows:</p>

<p>sub debug { my $self = shift; confess &quot;usage:
thing-&gt;debug(level)&quot; unless @_ == 1; my $level =
shift; if (ref($self)) { $self-&gt;{&quot;_DEBUG&quot;} =
$level; # just myself } else { $Debugging = $level; # whole
class } }</p>

<p>sub DESTROY { my $self = shift; if ($Debugging ||
$self-&gt;{&quot;_DEBUG&quot;}) { carp &quot;Destroying
$self &quot; . $self-&gt;name; } -- ${
$self-&gt;{&quot;_CENSUS&quot;} }; }</p>

<p>What happens if a derived class (which well call
Employee) inherits methods from this Person base class? Then
&quot;Employee-&gt;debug()&quot;, when called as a class
method, manipulates $Person::Debugging not
$Employee::Debugging.</p>

<p>Class Destructors The object destructor handles the
death of each distinct object. But sometimes you want a bit
of cleanup when the entire class is shut down, which
currently only happens when the program exits. To make such
a class destructor, create a function in that classs package
named END. This works just like the END function in
traditional modules, meaning that it gets called whenever
your program exits unless it execs or dies of an uncaught
signal. For example,</p>

<p>sub END { if ($Debugging) { print &quot;All persons are
going away now.0; } }</p>

<p>When the program exits, all the class destructors (END
functions) are be called in the opposite order that they
were loaded in (LIFO order).</p>

<p>Documenting the Interface And there you have it: we ve
just shown you the implementation of this Person class. Its
interface would be its documentation. Usually this means
putting it in pod (&quot;plain old documentation&quot;)
format right there in the same file. In our Person example,
we would place the following docs anywhere in the Person.pm
file. Even though it looks mostly like code, it s not. Its
embedded documentation such as would be used by the pod2man,
pod2html, or pod2text programs. The Perl compiler ignores
pods entirely, just as the translators ignore code. Heres an
example of some pods describing the informal interface:</p>

<p>=head1 NAME</p>

<p>Person - class to implement people</p>

<p>=head1 SYNOPSIS</p>

<p>use Person;</p>

<p>################# # class methods # #################
$ob = Person-&gt;new; $count = Person-&gt;population;</p>

<p>####################### # object data methods #
#######################</p>

<p>### get versions ### $who = $ob-&gt;name; $years =
$ob-&gt;age; @pals = $ob-&gt;peers;</p>

<p>### set versions ### $ob-&gt;name(&quot;Jason&quot;);
$ob-&gt;age(23); $ob-&gt;peers( &quot;Norbert&quot;,
&quot;Rhys&quot;, &quot;Phineas&quot; );</p>

<p>######################## # other object methods #
########################</p>

<p>$phrase = $ob-&gt;exclaim; $ob-&gt;happy_birthday;</p>

<p>=head1 DESCRIPTION</p>

<p>The Person class implements dah dee dah dee dah....</p>

<p>Thats all there is to the matter of interface versus
implementation. A programmer who opens up the module and
plays around with all the private little shiny bits that
were safely locked up behind the interface contract has
voided the warranty, and you shouldnt worry about their
fate.</p>

<p>Aggregation Suppose you later want to change the class
to implement better names. Perhaps you d like to support
both given names (called Christian names, irrespective of
ones religion) and family names (called surnames), plus
nicknames and titles. If users of your Person class have
been properly accessing it through its documented interface,
then you can easily change the underlying implementation. If
they havent, then they lose and its their fault for breaking
the contract and voiding their warranty.</p>

<p>To do this, we ll make another class, this one called
Fullname. Whats the Fullname class look like? To answer that
question, you have to first figure out how you want to use
it. How about we use it this way:</p>

<p>$him = Person-&gt;new();
$him-&gt;fullname-&gt;title(&quot;St&quot;);
$him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
$him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
$him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;); printf
&quot;His normal name is %s0, $him-&gt;name; printf
&quot;But his real name is %s0,
$him-&gt;fullname-&gt;as_string;</p>

<p>Ok. To do this, we ll change Person::new() so that it
supports a full name field this way:</p>

<p>sub new { my $class = shift; my $self = {};
$self-&gt;{FULLNAME} = Fullname-&gt;new(); $self-&gt;{AGE} =
undef; $self-&gt;{PEERS} = [];
$self-&gt;{&quot;_CENSUS&quot;} = ensus; bless ($self,
$class); ++ ${ $self-&gt;{&quot;_CENSUS&quot;} }; return
$self; }</p>

<p>sub fullname { my $self = shift; return
$self-&gt;{FULLNAME}; }</p>

<p>Then to support old code, define Person::name() this
way:</p>

<p>sub name { my $self = shift; return
$self-&gt;{FULLNAME}-&gt;nickname(@_) ||
$self-&gt;{FULLNAME}-&gt;christian(@_); }</p>

<p>Heres the Fullname class. Well use the same technique of
using a hash reference to hold data fields, and methods by
the appropriate name to access them:</p>

<p>package Fullname; use strict;</p>

<p>sub new { my $class = shift; my $self = { TITLE =&gt;
undef, CHRISTIAN =&gt; undef, SURNAME =&gt; undef, NICK
=&gt; undef, }; bless ($self, $class); return $self; }</p>

<p>sub christian { my $self = shift; if (@_) {
$self-&gt;{CHRISTIAN} = shift } return
$self-&gt;{CHRISTIAN}; }</p>

<p>sub surname { my $self = shift; if (@_) {
$self-&gt;{SURNAME} = shift } return $self-&gt;{SURNAME};
}</p>

<p>sub nickname { my $self = shift; if (@_) {
$self-&gt;{NICK} = shift } return $self-&gt;{NICK}; }</p>

<p>sub title { my $self = shift; if (@_) {
$self-&gt;{TITLE} = shift } return $self-&gt;{TITLE}; }</p>

<p>sub as_string { my $self = shift; my $name = join(&quot;
&quot;, @$self{&rsquo;CHRISTIAN&rsquo;,
&rsquo;SURNAME&rsquo;}); if ($self-&gt;{TITLE}) { $name =
$self-&gt;{TITLE} . &quot; &quot; . $name; } return $name;
}</p>

<p>1;</p>

<p>Finally, heres the test program:</p>

<p>#!/usr/bin/perl -w use strict; use Person; sub END {
show_census() }</p>

<p>sub show_census () { printf &quot;Current population:
%d0, Person-&gt;population; }</p>

<p>Person-&gt;debug(1);</p>

<p>show_census();</p>

<p>my $him = Person-&gt;new();</p>

<p>$him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
$him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
$him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);
$him-&gt;fullname-&gt;title(&quot;St&quot;);
$him-&gt;age(1);</p>

<p>printf &quot;%s is really %s.0, $him-&gt;name,
$him-&gt;fullname-&gt;as_string; printf &quot;%s&rsquo;s
age: %d.0, $him-&gt;name, $him-&gt;age;
$him-&gt;happy_birthday; printf &quot;%s&rsquo;s age: %d.0,
$him-&gt;name, $him-&gt;age;</p>

<p>show_census();</p>

<p>Inheritance Object-oriented programming systems all
support some notion of inheritance. Inheritance means
allowing one class to piggy-back on top of another one so
you dont have to write the same code again and again. Its
about software reuse, and therefore related to Laziness, the
principal virtue of a programmer. (The import/export
mechanisms in traditional modules are also a form of code
reuse, but a simpler one than the true inheritance that you
find in object modules.)</p>

<p>Sometimes the syntax of inheritance is built into the
core of the language, and sometimes it s not. Perl has no
special syntax for specifying the class (or classes) to
inherit from. Instead, its all strictly in the semantics.
Each package can have a variable called @ISA, which governs
(method) inheritance. If you try to call a method on an
object or class, and that method is not found in that
objects package, Perl then looks to @ISA for other packages
to go looking through in search of the missing method.</p>

<p>Like the special per-package variables recognized by
Exporter (such as @EXPORT, @EXPORT_OK, @EXPORT_FAIL,
%EXPORT_TAGS, and $VERSION), the @ISA array must be a
package-scoped global and not a file-scoped lexical created
via my(). Most classes have just one item in their @ISA
array. In this case, we have whats called &quot;single
inheritance&quot;, or SI for short.</p>

<p>Consider this class:</p>

<p>package Employee; use Person; @ISA =
(&quot;Person&quot;); 1;</p>

<p>Not a lot to it, eh? All its doing so far is loading in
another class and stating that this one will inherit methods
from that other class if need be. We have given it none of
its own methods. We rely upon an Employee to behave just
like a Person.</p>

<p>Setting up an empty class like this is called the
&quot;empty subclass test&quot;; that is, making a derived
class that does nothing but inherit from a base class. If
the original base class has been designed properly, then the
new derived class can be used as a drop-in replacement for
the old one. This means you should be able to write a
program like this:</p>

<p>use Employee; my $empl = Employee-&gt;new();
$empl-&gt;name(&quot;Jason&quot;); $empl-&gt;age(23); printf
&quot;%s is age %d.0, $empl-&gt;name, $empl-&gt;age;</p>

<p>By proper design, we mean always using the two-argument
form of bless(), avoiding direct access of global data, and
not exporting anything. If you look back at the
Person::new() function we defined above, we were careful to
do that. Theres a bit of package data used in the
constructor, but the reference to this is stored on the
object itself and all other methods access package data via
that reference, so we should be ok.</p>

<p>What do we mean by the Person::new() function -- isnt
that actually a method? Well, in principle, yes. A method is
just a function that expects as its first argument a class
name (package) or object (blessed reference). Person::new()
is the function that both the &quot;Person-&gt;new()&quot;
method and the &quot;Employee-&gt;new()&quot; method end up
calling. Understand that while a method call looks a lot
like a function call, they arent really quite the same, and
if you treat them as the same, youll very soon be left with
nothing but broken programs. First, the actual underlying
calling conventions are different: method calls get an extra
argument. Second, function calls don t do inheritance, but
methods do.</p>

<p>Method Call Resulting Function Call -----------
------------------------ Person-&gt;new()
Person::new(&quot;Person&quot;) Employee-&gt;new()
Person::new(&quot;Employee&quot;)</p>

<p>So dont use function calls when you mean to call a
method.</p>

<p>If an employee is just a Person, thats not all too very
interesting. So let s add some other methods. Well give our
employee data fields to access their salary, their employee
ID, and their start date.</p>

<p>If you re getting a little tired of creating all these
nearly identical methods just to get at the objects data, do
not despair. Later, well describe several different
convenience mechanisms for shortening this up. Meanwhile,
heres the straight-forward way:</p>

<p>sub salary { my $self = shift; if (@_) {
$self-&gt;{SALARY} = shift } return $self-&gt;{SALARY};
}</p>

<p>sub id_number { my $self = shift; if (@_) {
$self-&gt;{ID} = shift } return $self-&gt;{ID}; }</p>

<p>sub start_date { my $self = shift; if (@_) {
$self-&gt;{START_DATE} = shift } return
$self-&gt;{START_DATE}; }</p>

<p>Overridden Methods What happens when both a derived
class and its base class have the same method defined? Well,
then you get the derived classs version of that method. For
example, lets say that we want the peers() method called on
an employee to act a bit differently. Instead of just
returning the list of peer names, let s return slightly
different strings. So doing this:</p>

<p>$empl-&gt;peers(&quot;Peter&quot;, &quot;Paul&quot;,
&quot;Mary&quot;); printf &quot;His peers are: %s0,
join(&quot;, &quot;, $empl-&gt;peers);</p>

<p>will produce:</p>

<p>His peers are: PEON=PETER, PEON=PAUL, PEON=MARY</p>

<p>To do this, merely add this definition into the
Employee.pm file:</p>

<p>sub peers { my $self = shift; if (@_) { @{
$self-&gt;{PEERS} } = @_ } return map { &quot;PEON=U$_&quot;
} @{ $self-&gt;{PEERS} }; }</p>

<p>There, weve just demonstrated the high-falutin concept
known in certain circles as polymorphism. Weve taken on the
form and behaviour of an existing object, and then weve
altered it to suit our own purposes. This is a form of
Laziness. (Getting polymorphed is also what happens when the
wizard decides youd look better as a frog.)</p>

<p>Every now and then you ll want to have a method call
trigger both its derived class (also known as
&quot;subclass&quot;) version as well as its base class
(also known as &quot;superclass&quot;) version. In practice,
constructors and destructors are likely to want to do this,
and it probably also makes sense in the debug() method we
showed previously.</p>

<p>To do this, add this to Employee.pm:</p>

<p>use Carp; my $Debugging = 0;</p>

<p>sub debug { my $self = shift; confess &quot;usage:
thing-&gt;debug(level)&quot; unless @_ == 1; my $level =
shift; if (ref($self)) { $self-&gt;{&quot;_DEBUG&quot;} =
$level; } else { $Debugging = $level; # whole class }
Person::debug($self, $Debugging); # don&rsquo;t really do
this }</p>

<p>As you see, we turn around and call the Person packages
debug() function. But this is far too fragile for good
design. What if Person doesn t have a debug() function, but
is inheriting its debug() method from elsewhere? It would
have been slightly better to say</p>

<p>Person-&gt;debug($Debugging);</p>

<p>But even that s got too much hard-coded. Its somewhat
better to say</p>

<p>$self-&gt;Person::debug($Debugging);</p>

<p>Which is a funny way to say to start looking for a
debug() method up in Person. This strategy is more often
seen on overridden object methods than on overridden class
methods.</p>

<p>There is still something a bit off here. Weve hard-coded
our superclasss name. This in particular is bad if you
change which classes you inherit from, or add others.
Fortunately, the pseudoclass SUPER comes to the rescue
here.</p>

<p>$self-&gt;SUPER::debug($Debugging);</p>

<p>This way it starts looking in my classs @ISA. This only
makes sense from within a method call, though. Don t try to
access anything in SUPER:: from anywhere else, because it
doesn t exist outside an overridden method call. Note that
&quot;SUPER&quot; refers to the superclass of the current
package, not to the superclass of $self.</p>

<p>Things are getting a bit complicated here. Have we done
anything we shouldnt? As before, one way to test whether we
re designing a decent class is via the empty subclass test.
Since we already have an Employee class that were trying to
check, wed better get a new empty subclass that can derive
from Employee. Heres one:</p>

<p>package Boss; use Employee; # :-) @ISA =
qw(Employee);</p>

<p>And heres the test program:</p>

<p>#!/usr/bin/perl -w use strict; use Boss;
Boss-&gt;debug(1);</p>

<p>my $boss = Boss-&gt;new();</p>

<p>$boss-&gt;fullname-&gt;title(&quot;Don&quot;);
$boss-&gt;fullname-&gt;surname(&quot;Pichon Alvarez&quot;);
$boss-&gt;fullname-&gt;christian(&quot;Federico
Jesus&quot;);
$boss-&gt;fullname-&gt;nickname(&quot;Fred&quot;);</p>

<p>$boss-&gt;age(47); $boss-&gt;peers(&quot;Frank&quot;,
&quot;Felipe&quot;, &quot;Faust&quot;);</p>

<p>printf &quot;%s is age %d.0,
$boss-&gt;fullname-&gt;as_string, $boss-&gt;age; printf
&quot;His peers are: %s0, join(&quot;, &quot;,
$boss-&gt;peers);</p>

<p>Running it, we see that were still ok. If you d like to
dump out your object in a nice format, somewhat like the way
the x command works in the debugger, you could use the
Data::Dumper module from CPAN this way:</p>

<p>use Data::Dumper; print &quot;Here&rsquo;s the boss:0;
print Dumper($boss);</p>

<p>Which shows us something like this:</p>

<p>Here&rsquo;s the boss: $VAR1 = bless( { _CENSUS =&gt; 1,
FULLNAME =&gt; bless( { TITLE =&gt; &rsquo;Don&rsquo;,
SURNAME =&gt; &rsquo;Pichon Alvarez&rsquo;, NICK =&gt;
&rsquo;Fred&rsquo;, CHRISTIAN =&gt; &rsquo;Federico
Jesus&rsquo; }, &rsquo;Fullname&rsquo; ), AGE =&gt; 47,
PEERS =&gt; [ &rsquo;Frank&rsquo;, &rsquo;Felipe&rsquo;,
&rsquo;Faust&rsquo; ] }, &rsquo;Boss&rsquo; );</p>

<p>Hm.... something s missing there. What about the salary,
start date, and ID fields? Well, we never set them to
anything, even undef, so they don t show up in the hashs
keys. The Employee class has no new() method of its own, and
the new() method in Person doesn t know about Employees.
(Nor should it: proper OO design dictates that a subclass be
allowed to know about its immediate superclass, but never
vice- versa.) So lets fix up Employee::new() this way:</p>

<p>sub new { my $class = shift; my $self =
$class-&gt;SUPER::new(); $self-&gt;{SALARY} = undef;
$self-&gt;{ID} = undef; $self-&gt;{START_DATE} = undef;
bless ($self, $class); # reconsecrate return $self; }</p>

<p>Now if you dump out an Employee or Boss object, youll
find that new fields show up there now.</p>

<p>Multiple Inheritance Ok, at the risk of confusing
beginners and annoying OO gurus, its time to confess that
Perl s object system includes that controversial notion
known as multiple inheritance, or MI for short. All this
means is that rather than having just one parent class who
in turn might itself have a parent class, etc., that you can
directly inherit from two or more parents. It s true that
some uses of MI can get you into trouble, although hopefully
not quite so much trouble with Perl as with dubiously-OO
languages like C++.</p>

<p>The way it works is actually pretty simple: just put
more than one package name in your @ISA array. When it comes
time for Perl to go finding methods for your object, it
looks at each of these packages in order. Well, kinda. It s
actually a fully recursive, depth-first order by default
(see mro for alternate method resolution orders). Consider a
bunch of @ISA arrays like this:</p>

<p>@First::ISA = qw( Alpha ); @Second::ISA = qw( Beta );
@Third::ISA = qw( First Second );</p>

<p>If you have an object of class Third:</p>

<p>my $ob = Third-&gt;new(); $ob-&gt;spin();</p>

<p>How do we find a spin() method (or a new() method for
that matter)? Because the search is depth-first, classes
will be looked up in the following order: Third, First,
Alpha, Second, and Beta.</p>

<p>In practice, few class modules have been seen that
actually make use of MI. One nearly always chooses simple
containership of one class within another over MI. Thats why
our Person object contained a Fullname object. That doesnt
mean it was one.</p>

<p>However, there is one particular area where MI in Perl
is rampant: borrowing another classs class methods. This is
rather common, especially with some bundled
&quot;objectless&quot; classes, like Exporter, DynaLoader,
AutoLoader, and SelfLoader. These classes do not provide
constructors; they exist only so you may inherit their class
methods. (Its not entirely clear why inheritance was done
here rather than traditional module importation.)</p>

<p>For example, here is the POSIX modules @ISA:</p>

<p>package POSIX; @ISA = qw(Exporter DynaLoader);</p>

<p>The POSIX module isnt really an object module, but then,
neither are Exporter or DynaLoader. Theyre just lending
their classes behaviours to POSIX.</p>

<p>Why don t people use MI for object methods much? One
reason is that it can have complicated side-effects. For one
thing, your inheritance graph (no longer a tree) might
converge back to the same base class. Although Perl guards
against recursive inheritance, merely having parents who are
related to each other via a common ancestor, incestuous
though it sounds, is not forbidden. What if in our Third
class shown above we wanted its new() method to also call
both overridden constructors in its two parent classes? The
SUPER notation would only find the first one. Also, what
about if the Alpha and Beta classes both had a common
ancestor, like Nought? If you kept climbing up the
inheritance tree calling overridden methods, youd end up
calling Nought::new() twice, which might well be a bad
idea.</p>

<p>UNIVERSAL: The Root of All Objects Wouldnt it be
convenient if all objects were rooted at some ultimate base
class? That way you could give every object common methods
without having to go and add it to each and every @ISA.
Well, it turns out that you can. You dont see it, but Perl
tacitly and irrevocably assumes that theres an extra element
at the end of @ISA: the class UNIVERSAL. In version 5.003,
there were no predefined methods there, but you could put
whatever you felt like into it.</p>

<p>However, as of version 5.004 (or some subversive
releases, like 5.003_08), UNIVERSAL has some methods in it
already. These are builtin to your Perl binary, so they dont
take any extra time to load. Predefined methods include
isa(), can(), and VERSION(). isa() tells you whether an
object or class &quot;is&quot; another one without having to
traverse the hierarchy yourself:</p>

<p>$has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);
$itza_handle =
IO::Socket-&gt;isa(&quot;IO::Handle&quot;);</p>

<p>The can() method, called against that object or class,
reports back whether its string argument is a callable
method name in that class. In fact, it gives you back a
function reference to that method:</p>

<p>$his_print_method =
$obj-&gt;can(&rsquo;as_string&rsquo;);</p>

<p>Finally, the VERSION method checks whether the class (or
the objects class) has a package global called $VERSION
thats high enough, as in:</p>

<p>Some_Module-&gt;VERSION(3.0); $his_vers =
$ob-&gt;VERSION();</p>

<p>However, we don t usually call VERSION ourselves.
(Remember that an all uppercase function name is a Perl
convention that indicates that the function will be
automatically used by Perl in some way.) In this case, it
happens when you say</p>

<p>use Some_Module 3.0;</p>

<p>If you wanted to add version checking to your Person
class explained above, just add this to Person.pm:</p>

<p>our $VERSION = &rsquo;1.1&rsquo;;</p>

<p>and then in Employee.pm you can say</p>

<p>use Person 1.1;</p>

<p>And it would make sure that you have at least that
version number or higher available. This is not the same as
loading in that exact version number. No mechanism currently
exists for concurrent installation of multiple versions of a
module. Lamentably.</p>

<p>Deeper UNIVERSAL details It is also valid (though
perhaps unwise in most cases) to put other packages names in
@UNIVERSAL::ISA. These packages will also be implicitly
inherited by all classes, just as UNIVERSAL itself is.
However, neither UNIVERSAL nor any of its parents from the
@ISA tree are explicit base classes of all objects. To
clarify, given the following:</p>

<p>@UNIVERSAL::ISA = (&rsquo;REALLYUNIVERSAL&rsquo;);</p>

<p>package REALLYUNIVERSAL; sub special_method { return
&quot;123&quot; }</p>

<p>package Foo; sub normal_method { return &quot;321&quot;
}</p>

<p>Calling Foo-&gt;special_method() will return
&quot;123&quot;, but calling Foo-&gt;isa(REALLYUNIVERSAL) or
Foo-&gt;isa( UNIVERSAL ) will return false.</p>

<p>If your class is using an alternate mro like C3 (see
mro), method resolution within UNIVERSAL / @UNIVERSAL::ISA
will still occur in the default depth-first left-to-right
manner, after the classs C3 mro is exhausted.</p>

<p>All of the above is made more intuitive by realizing
what really happens during method lookup, which is roughly
like this ugly pseudo- code:</p>

<p>get_mro(class) { # recurses down the @ISA&rsquo;s
starting at class, # builds a single linear array of all #
classes to search in the appropriate order. # The method
resolution order (mro) to use # for the ordering is
whichever mro &quot;class&quot; # has set on it (either
default (depth first # l-to-r) or C3 ordering). # The first
entry in the list is the class # itself. }</p>

<p>find_method(class, methname) { foreach $class
(get_mro(class)) { if($class-&gt;has_method(methname)) {
return ref_to($class-&gt;$methname); } } foreach $class
(get_mro(UNIVERSAL)) { if($class-&gt;has_method(methname)) {
return ref_to($class-&gt;$methname); } } return undef; }</p>

<p>However the code that implements UNIVERSAL::isa does not
search in UNIVERSAL itself, only in the packages actual
@ISA.</p>

<p>Alternate Object Representations Nothing requires
objects to be implemented as hash references. An object can
be any sort of reference so long as its referent has been
suitably blessed. That means scalar, array, and code
references are also fair game.</p>

<p>A scalar would work if the object has only one datum to
hold. An array would work for most cases, but makes
inheritance a bit dodgy because you have to invent new
indices for the derived classes.</p>

<p>Arrays as Objects If the user of your class honors the
contract and sticks to the advertised interface, then you
can change its underlying interface if you feel like it.
Here s another implementation that conforms to the same
interface specification. This time well use an array
reference instead of a hash reference to represent the
object.</p>

<p>package Person; use strict;</p>

<p>my($NAME, $AGE, $PEERS) = ( 0 .. 2 );</p>

<p>############################################ ## the
object constructor (array version) ##
############################################ sub new { my
$self = []; $self-&gt;[$NAME] = undef; # this is unnecessary
$self-&gt;[$AGE] = undef; # as is this $self-&gt;[$PEERS] =
[]; # but this isn&rsquo;t, really bless($self); return
$self; }</p>

<p>sub name { my $self = shift; if (@_) { $self-&gt;[$NAME]
= shift } return $self-&gt;[$NAME]; }</p>

<p>sub age { my $self = shift; if (@_) { $self-&gt;[$AGE] =
shift } return $self-&gt;[$AGE]; }</p>

<p>sub peers { my $self = shift; if (@_) { @{
$self-&gt;[$PEERS] } = @_ } return @{ $self-&gt;[$PEERS] };
}</p>

<p>1; # so the require or use succeeds</p>

<p>You might guess that the array access would be a lot
faster than the hash access, but theyre actually comparable.
The array is a little bit faster, but not more than ten or
fifteen percent, even when you replace the variables above
like $AGE with literal numbers, like 1. A bigger difference
between the two approaches can be found in memory use. A
hash representation takes up more memory than an array
representation because you have to allocate memory for the
keys as well as for the values. However, it really isn t
that bad, especially since as of version 5.004, memory is
only allocated once for a given hash key, no matter how many
hashes have that key. It s expected that sometime in the
future, even these differences will fade into obscurity as
more efficient underlying representations are devised.</p>

<p>Still, the tiny edge in speed (and somewhat larger one
in memory) is enough to make some programmers choose an
array representation for simple classes. There s still a
little problem with scalability, though, because later in
life when you feel like creating subclasses, youll find that
hashes just work out better.</p>

<p>Closures as Objects Using a code reference to represent
an object offers some fascinating possibilities. We can
create a new anonymous function (closure) who alone in all
the world can see the objects data. This is because we put
the data into an anonymous hash that s lexically visible
only to the closure we create, bless, and return as the
object. This objects methods turn around and call the
closure as a regular subroutine call, passing it the field
we want to affect. (Yes, the double-function call is slow,
but if you wanted fast, you wouldn t be using objects at
all, eh? :-)</p>

<p>Use would be similar to before:</p>

<p>use Person; $him = Person-&gt;new();
$him-&gt;name(&quot;Jason&quot;); $him-&gt;age(23);
$him-&gt;peers( [ &quot;Norbert&quot;, &quot;Rhys&quot;,
&quot;Phineas&quot; ] ); printf &quot;%s is %d years old.0,
$him-&gt;name, $him-&gt;age; print &quot;His peers are:
&quot;, join(&quot;, &quot;, @{$him-&gt;peers}),
&quot;0;</p>

<p>but the implementation would be radically, perhaps even
sublimely different:</p>

<p>package Person;</p>

<p>sub new { my $class = shift; my $self = { NAME =&gt;
undef, AGE =&gt; undef, PEERS =&gt; [], }; my $closure = sub
{ my $field = shift; if (@_) { $self-&gt;{$field} = shift }
return $self-&gt;{$field}; }; bless($closure, $class);
return $closure; }</p>

<p>sub name { &amp;{ $_[0] }(&quot;NAME&quot;, @_[ 1 .. $#_
] ) } sub age { &amp;{ $_[0] }(&quot;AGE&quot;, @_[ 1 .. $#_
] ) } sub peers { &amp;{ $_[0] }(&quot;PEERS&quot;, @_[ 1 ..
$#_ ] ) }</p>

<p>1;</p>

<p>Because this object is hidden behind a code reference,
its probably a bit mysterious to those whose background is
more firmly rooted in standard procedural or object-based
programming languages than in functional programming
languages whence closures derive. The object created and
returned by the new() method is itself not a data reference
as weve seen before. Its an anonymous code reference that
has within it access to a specific version (lexical binding
and instantiation) of the objects data, which are stored in
the private variable $self. Although this is the same
function each time, it contains a different version of
$self.</p>

<p>When a method like
&quot;$him-&gt;name(&quot;Jason&quot;)&quot; is called, its
implicit zeroth argument is the invoking object--just as it
is with all method calls. But in this case, its our code
reference (something like a function pointer in C++, but
with deep binding of lexical variables). Theres not a lot to
be done with a code reference beyond calling it, so thats
just what we do when we say &quot;&amp;{$_[0]}&quot;. This
is just a regular function call, not a method call. The
initial argument is the string &quot;NAME&quot;, and any
remaining arguments are whatever had been passed to the
method itself.</p>

<p>Once were executing inside the closure that had been
created in new(), the $self hash reference suddenly becomes
visible. The closure grabs its first argument
(&quot;NAME&quot; in this case because thats what the name()
method passed it), and uses that string to subscript into
the private hash hidden in its unique version of $self.</p>

<p>Nothing under the sun will allow anyone outside the
executing method to be able to get at this hidden data.
Well, nearly nothing. You could single step through the
program using the debugger and find out the pieces while
youre in the method, but everyone else is out of luck.</p>

<p>There, if that doesnt excite the Scheme folks, then I
just dont know what will. Translation of this technique into
C++, Java, or any other braindead-static language is left as
a futile exercise for aficionados of those camps.</p>

<p>You could even add a bit of nosiness via the caller()
function and make the closure refuse to operate unless
called via its own package. This would no doubt satisfy
certain fastidious concerns of programming police and
related puritans.</p>

<p>If you were wondering when Hubris, the third principle
virtue of a programmer, would come into play, here you have
it. (More seriously, Hubris is just the pride in
craftsmanship that comes from having written a sound bit of
well-designed code.)</p>

<p>AUTOLOAD: Proxy Methods Autoloading is a way to
intercept calls to undefined methods. An autoload routine
may choose to create a new function on the fly, either
loaded from disk or perhaps just eval()ed right there. This
define-on- the-fly strategy is why its called
autoloading.</p>

<p>But thats only one possible approach. Another one is to
just have the autoloaded method itself directly provide the
requested service. When used in this way, you may think of
autoloaded methods as &quot;proxy&quot; methods.</p>

<p>When Perl tries to call an undefined function in a
particular package and that function is not defined, it
looks for a function in that same package called AUTOLOAD.
If one exists, its called with the same arguments as the
original function would have had. The fully-qualified name
of the function is stored in that packages global variable
$AUTOLOAD. Once called, the function can do anything it
would like, including defining a new function by the right
name, and then doing a really fancy kind of &quot;goto&quot;
right to it, erasing itself from the call stack.</p>

<p>What does this have to do with objects? After all, we
keep talking about functions, not methods. Well, since a
method is just a function with an extra argument and some
fancier semantics about where its found, we can use
autoloading for methods, too. Perl doesnt start looking for
an AUTOLOAD method until it has exhausted the recursive hunt
up through @ISA, though. Some programmers have even been
known to define a UNIVERSAL::AUTOLOAD method to trap
unresolved method calls to any kind of object.</p>

<p>Autoloaded Data Methods You probably began to get a
little suspicious about the duplicated code way back earlier
when we first showed you the Person class, and then later
the Employee class. Each method used to access the hash
fields looked virtually identical. This should have tickled
that great programming virtue, Impatience, but for the time,
we let Laziness win out, and so did nothing. Proxy methods
can cure this.</p>

<p>Instead of writing a new function every time we want a
new data field, well use the autoload mechanism to generate
(actually, mimic) methods on the fly. To verify that were
accessing a valid member, we will check against an
&quot;_permitted&quot; (pronounced
&quot;under-permitted&quot;) field, which is a reference to
a file-scoped lexical (like a C file static) hash of
permitted fields in this record called %fields. Why the
underscore? For the same reason as the _CENSUS field we once
used: as a marker that means &quot;for internal use
only&quot;.</p>

<p>Heres what the module initialization code and class
constructor will look like when taking this approach:</p>

<p>package Person; use Carp; our $AUTOLOAD; # it&rsquo;s a
package global</p>

<p>my %fields = ( name =&gt; undef, age =&gt; undef, peers
=&gt; undef, );</p>

<p>sub new { my $class = shift; my $self = { _permitted
=&gt; fields, %fields, }; bless $self, $class; return $self;
}</p>

<p>If we wanted our record to have default values, we could
fill those in where current we have &quot;undef&quot; in the
%fields hash.</p>

<p>Notice how we saved a reference to our class data on the
object itself? Remember that its important to access class
data through the object itself instead of having any method
reference %fields directly, or else you wont have a decent
inheritance.</p>

<p>The real magic, though, is going to reside in our proxy
method, which will handle all calls to undefined methods for
objects of class Person (or subclasses of Person). It has to
be called AUTOLOAD. Again, its all caps because its called
for us implicitly by Perl itself, not by a user
directly.</p>

<p>sub AUTOLOAD { my $self = shift; my $type = ref($self)
or croak &quot;$self is not an object&quot;;</p>

<p>my $name = $AUTOLOAD; $name =~ s/.*://; # strip
fully-qualified portion</p>

<p>unless (exists $self-&gt;{_permitted}-&gt;{$name} ) {
croak &quot;Can&rsquo;t access &lsquo;$name&rsquo; field in
class $type&quot;; }</p>

<p>if (@_) { return $self-&gt;{$name} = shift; } else {
return $self-&gt;{$name}; } }</p>

<p>Pretty nifty, eh? All we have to do to add new data
fields is modify %fields. No new functions need be
written.</p>

<p>I could have avoided the &quot;_permitted&quot; field
entirely, but I wanted to demonstrate how to store a
reference to class data on the object so you wouldnt have to
access that class data directly from an object method.</p>

<p>Inherited Autoloaded Data Methods But what about
inheritance? Can we define our Employee class similarly?
Yes, so long as were careful enough.</p>

<p>Heres how to be careful:</p>

<p>package Employee; use Person; use strict; our @ISA =
qw(Person);</p>

<p>my %fields = ( id =&gt; undef, salary =&gt; undef,
);</p>

<p>sub new { my $class = shift; my $self =
$class-&gt;SUPER::new(); my($element); foreach $element
(keys %fields) { $self-&gt;{_permitted}-&gt;{$element} =
$fields{$element}; } @{$self}{keys %fields} = values
%fields; return $self; }</p>

<p>Once weve done this, we dont even need to have an
AUTOLOAD function in the Employee package, because well grab
Persons version of that via inheritance, and it will all
work out just fine.</p>

<p>Metaclassical Tools Even though proxy methods can
provide a more convenient approach to making more
struct-like classes than tediously coding up data methods as
functions, it still leaves a bit to be desired. For one
thing, it means you have to handle bogus calls that you dont
mean to trap via your proxy. It also means you have to be
quite careful when dealing with inheritance, as detailed
above.</p>

<p>Perl programmers have responded to this by creating
several different class construction classes. These
metaclasses are classes that create other classes. A couple
worth looking at are Class::Struct and Alias. These and
other related metaclasses can be found in the modules
directory on CPAN.</p>

<p>Class::Struct One of the older ones is Class::Struct. In
fact, its syntax and interface were sketched out long before
perl5 even solidified into a real thing. What it does is
provide you a way to &quot;declare&quot; a class as having
objects whose fields are of a specific type. The function
that does this is called, not surprisingly enough, struct().
Because structures or records are not base types in Perl,
each time you want to create a class to provide a
record-like data object, you yourself have to define a new()
method, plus separate data-access methods for each of that
records fields. Youll quickly become bored with this
process. The Class::Struct::struct() function alleviates
this tedium.</p>

<p>Heres a simple example of using it:</p>

<p>use Class::Struct qw(struct); use Jobbie; #
user-defined; see below</p>

<p>struct &rsquo;Fred&rsquo; =&gt; { one =&gt;
&rsquo;$&rsquo;, many =&gt; &rsquo;@&rsquo;, profession
=&gt; &rsquo;Jobbie&rsquo;, # does not call Jobbie-&gt;new()
};</p>

<p>$ob = Fred-&gt;new(profession =&gt; Jobbie-&gt;new());
$ob-&gt;one(&quot;hmmmm&quot;);</p>

<p>$ob-&gt;many(0, &quot;here&quot;); $ob-&gt;many(1,
&quot;you&quot;); $ob-&gt;many(2, &quot;go&quot;); print
&quot;Just set: &quot;, $ob-&gt;many(2), &quot;0;</p>

<p>$ob-&gt;profession-&gt;salary(10_000);</p>

<p>You can declare types in the struct to be basic Perl
types, or user- defined types (classes). User types will be
initialized by calling that classs new() method.</p>

<p>Take care that the &quot;Jobbie&quot; object is not
created automatically by the &quot;Fred&quot; classs new()
method, so you should specify a &quot;Jobbie&quot; object
when you create an instance of &quot;Fred&quot;.</p>

<p>Here s a real-world example of using struct generation.
Lets say you wanted to override Perl s idea of
gethostbyname() and gethostbyaddr() so that they would
return objects that acted like C structures. We dont care
about high-falutin OO gunk. All we want is for these objects
to act like structs in the C sense.</p>

<p>use Socket; use Net::hostent; $h =
gethostbyname(&quot;perl.com&quot;); # object return printf
&quot;perl.com&rsquo;s real name is %s, address %s0,
$h-&gt;name, inet_ntoa($h-&gt;addr);</p>

<p>Here s how to do this using the Class::Struct module.
The crux is going to be this call:</p>

<p>struct &rsquo;Net::hostent&rsquo; =&gt; [ # note bracket
name =&gt; &rsquo;$&rsquo;, aliases =&gt; &rsquo;@&rsquo;,
addrtype =&gt; &rsquo;$&rsquo;, &rsquo;length&rsquo; =&gt;
&rsquo;$&rsquo;, addr_list =&gt; &rsquo;@&rsquo;, ];</p>

<p>Which creates object methods of those names and types.
It even creates a new() method for us.</p>

<p>We could also have implemented our object this way:</p>

<p>struct &rsquo;Net::hostent&rsquo; =&gt; { # note brace
name =&gt; &rsquo;$&rsquo;, aliases =&gt; &rsquo;@&rsquo;,
addrtype =&gt; &rsquo;$&rsquo;, &rsquo;length&rsquo; =&gt;
&rsquo;$&rsquo;, addr_list =&gt; &rsquo;@&rsquo;, };</p>

<p>and then Class::Struct would have used an anonymous hash
as the object type, instead of an anonymous array. The array
is faster and smaller, but the hash works out better if you
eventually want to do inheritance. Since for this
struct-like object we aren t planning on inheritance, this
time well opt for better speed and size over better
flexibility.</p>

<p>Heres the whole implementation:</p>

<p>package Net::hostent; use strict;</p>

<p>BEGIN { use Exporter (); our @EXPORT = qw(gethostbyname
gethostbyaddr gethost); our @EXPORT_OK = qw( $h_name
@h_aliases $h_addrtype $h_length @h_addr_list $h_addr ); our
%EXPORT_TAGS = ( FIELDS =&gt; [ @EXPORT_OK, @EXPORT ] ); }
our @EXPORT_OK;</p>

<p># Class::Struct forbids use of @ISA sub import { goto
&amp;Exporter::import }</p>

<p>use Class::Struct qw(struct); struct
&rsquo;Net::hostent&rsquo; =&gt; [ name =&gt;
&rsquo;$&rsquo;, aliases =&gt; &rsquo;@&rsquo;, addrtype
=&gt; &rsquo;$&rsquo;, &rsquo;length&rsquo; =&gt;
&rsquo;$&rsquo;, addr_list =&gt; &rsquo;@&rsquo;, ];</p>

<p>sub addr { shift-&gt;addr_list-&gt;[0] }</p>

<p>sub populate (@) { return unless @_; my $hob = new(); #
Class::Struct made this! $h_name = $hob-&gt;[0] = $_[0];
@h_aliases = @{ $hob-&gt;[1] } = split &rsquo; &rsquo;,
$_[1]; $h_addrtype = $hob-&gt;[2] = $_[2]; $h_length =
$hob-&gt;[3] = $_[3]; $h_addr = $_[4]; @h_addr_list = @{
$hob-&gt;[4] } = @_[ (4 .. $#_) ]; return $hob; }</p>

<p>sub gethostbyname ($) {
populate(CORE::gethostbyname(shift)) }</p>

<p>sub gethostbyaddr ($;$) { my ($addr, $addrtype); $addr =
shift; require Socket unless @_; $addrtype = @_ ? shift :
Socket::AF_INET(); populate(CORE::gethostbyaddr($addr,
$addrtype)) }</p>

<p>sub gethost($) { if ($_[0] =~
/^+(?:.+(?:.+(?:.+)?)?)?$/) { require Socket;
&amp;gethostbyaddr(Socket::inet_aton(shift)); } else {
&amp;gethostbyname; } }</p>

<p>1;</p>

<p>Weve snuck in quite a fair bit of other concepts besides
just dynamic class creation, like overriding core functions,
import/export bits, function prototyping, short-cut function
call via &amp;whatever, and function replacement with
&quot;goto &amp;whatever&quot;. These all mostly make sense
from the perspective of a traditional module, but as you can
see, we can also use them in an object module.</p>

<p>You can look at other object-based, struct-like
overrides of core functions in the 5.004 release of Perl in
File::stat, Net::hostent, Net::netent, Net::protoent,
Net::servent, Time::gmtime, Time::localtime, User::grent,
and User::pwent. These modules have a final component that s
all lowercase, by convention reserved for compiler pragmas,
because they affect the compilation and change a builtin
function. They also have the type names that a C programmer
would most expect.</p>

<p>Data Members as Variables If you re used to C++ objects,
then youre accustomed to being able to get at an objects
data members as simple variables from within a method. The
Alias module provides for this, as well as a good bit more,
such as the possibility of private methods that the object
can call but folks outside the class cannot.</p>

<p>Here s an example of creating a Person using the Alias
module. When you update these magical instance variables,
you automatically update value fields in the hash.
Convenient, eh?</p>

<p>package Person;</p>

<p># this is the same as before... sub new { my $class =
shift; my $self = { NAME =&gt; undef, AGE =&gt; undef, PEERS
=&gt; [], }; bless($self, $class); return $self; }</p>

<p>use Alias qw(attr); our ($NAME, $AGE, $PEERS);</p>

<p>sub name { my $self = attr shift; if (@_) { $NAME =
shift; } return $NAME; }</p>

<p>sub age { my $self = attr shift; if (@_) { $AGE = shift;
} return $AGE; }</p>

<p>sub peers { my $self = attr shift; if (@_) { @PEERS =
@_; } return @PEERS; }</p>

<p>sub exclaim { my $self = attr shift; return sprintf
&quot;Hi, I&rsquo;m %s, age %d, working with %s&quot;,
$NAME, $AGE, join(&quot;, &quot;, @PEERS); }</p>

<p>sub happy_birthday { my $self = attr shift; return
++$AGE; }</p>

<p>The need for the &quot;our&quot; declaration is because
what Alias does is play with package globals with the same
name as the fields. To use globals while &quot;use
strict&quot; is in effect, you have to predeclare them.
These package variables are localized to the block enclosing
the attr() call just as if youd used a local() on them.
However, that means that they re still considered global
variables with temporary values, just as with any other
local().</p>

<p>It would be nice to combine Alias with something like
Class::Struct or Class::MethodMaker.</p>

<p>NOTES Object Terminology In the various OO literature,
it seems that a lot of different words are used to describe
only a few different concepts. If youre not already an
object programmer, then you dont need to worry about all
these fancy words. But if you are, then you might like to
know how to get at the same concepts in Perl.</p>

<p>For example, its common to call an object an instance of
a class and to call those objects methods instance methods.
Data fields peculiar to each object are often called
instance data or object attributes, and data fields common
to all members of that class are class data, class
attributes, or static data members.</p>

<p>Also, base class, generic class, and superclass all
describe the same notion, whereas derived class, specific
class, and subclass describe the other related one.</p>

<p>C++ programmers have static methods and virtual methods,
but Perl only has class methods and object methods.
Actually, Perl only has methods. Whether a method gets used
as a class or object method is by usage only. You could
accidentally call a class method (one expecting a string
argument) on an object (one expecting a reference), or vice
versa.</p>

<p>From the C++ perspective, all methods in Perl are
virtual. This, by the way, is why they are never checked for
function prototypes in the argument list as regular builtin
and user-defined functions can be.</p>

<p>Because a class is itself something of an object, Perls
classes can be taken as describing both a &quot;class as
meta-object&quot; (also called object factory) philosophy
and the &quot;class as type definition&quot; (declaring
behaviour, not defining mechanism) idea. C++ supports the
latter notion, but not the former.</p>

<p>SEE ALSO The following manpages will doubtless provide
more background for this one: perlmod, perlref, perlobj,
perlbot, perltie, and overload.</p>

<p>perlboot is a kinder, gentler introduction to
object-oriented programming.</p>

<p>perltooc provides more detail on class data.</p>

<p>Some modules which might prove interesting are
Class::Accessor, Class::Class, Class::Contract,
Class::Data::Inheritable, Class::MethodMaker and
Tie::SecureHash</p>

<p>AUTHOR AND COPYRIGHT Copyright (c) 1997, 1998 Tom
Christiansen All rights reserved.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
this file are hereby placed into the public domain. You are
permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>COPYRIGHT Acknowledgments Thanks to Larry Wall, Roderick
Schertler, Gurusamy Sarathy, Dean Roehrich, Raphael
Manfredi, Brent Halsey, Greg Bacon, Brad Appleton, and many
others for their helpful comments.</p>

<p>perl v5.10.1 2009-02-12 PERLTOOT(1)</p>
<hr>
</body>
</html>
