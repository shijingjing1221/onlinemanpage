<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:07:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MIB2C.CONF(5) Net-SNMP MIB2C.CONF(5)</p>

<p>NAME mib2c.conf -- How to write mib2c.conf files to do
ANYTHING based on MIB input.</p>

<p>SYNOPSIS % cat &gt; mib2c.test.conf &lt;&lt; EOF
@foreach $t table@ Starting table $t @foreach $c column@
echo $t has column $c which has a syntax of $c.syntax
@end@</p>

<p>@end@ EOF</p>

<p>% mib2c -c mib2c.test.conf internet</p>

<p>DESCRIPTION The mib2c.conf script language is a
MIB-particular language designed to easily process MIB nodes
in ways that you want. mib2c is a misnomer (for historical
purposes), because you can produce anything (not just C
code). Look in the Net-SNMP &quot;local&quot; directory for
a bunch of example mib2c.*.conf files and behold the power
before you.</p>

<p>COMMANDS All commands within mib2c.conf files are
embraced by @ signs. Anything with an @ sign at the front
and back of the line is generally supposed to be a mib2c
specific command. These are detailed here:</p>

<p>@open FILE@ writes generated output to FILE note that
for file specifica- tions, opening - will print to
stdout.</p>

<p>@append FILE@ appends the given FILE</p>

<p>@close FILE@ closes the given FILE</p>

<p>@push@ save the current outputs, then clear outputs. Use
with @open@ and @pop@ to write to a new file without
interfering with cur- rent outputs.</p>

<p>@pop@ pop up the process() stack one level. Use after a
@push@ to return to the previous set of open files.</p>

<p>@foreach $VAR scalar@ repeat iterate over code until
@end@ setting $VAR to all known scalars</p>

<p>@foreach $VAR table@ repeat iterate over code until
@end@ setting $VAR to all known tables</p>

<p>@foreach $VAR column@ repeat iterate over code until
@end@ setting $VAR to all known columns within a given
table. Obviously this must be called within a foreach-table
clause.</p>

<p>@foreach $VAR nonindex@ repeat iterate over code until
@end@ setting $VAR to all known non-index columns within a
given table. Obviously this must be called within a
foreach-table clause.</p>

<p>@foreach $VAR internalindex@ repeat iterate over code
until @end@ setting $VAR to all known internal index columns
within a given table. Obviously this must be called within a
foreach-table clause.</p>

<p>@foreach $VAR externalindex@ repeat iterate over code
until @end@ setting $VAR to all known external index columns
within a given table. Obviously this must be called within a
foreach-table clause.</p>

<p>@foreach $VAR index@ repeat iterate over code until
@end@ setting $VAR to all known indexes within a given
table. Obviously this must be called within a foreach-table
clause.</p>

<p>@foreach $VAR notifications@ repeat iterate over code
until @end@ setting $VAR to all known notifications</p>

<p>@foreach $VAR varbinds@ repeat iterate over code until
@end@ setting $VAR to all known varbinds Obviously this must
be called within a foreach-notifi- cations clause.</p>

<p>@foreach $LABEL, $VALUE enum@ repeat iterate over code
until @end@ setting $LABEL and $VALUE to the label and
values from the enum list.</p>

<p>@foreach $RANGE_START, $RANGE_END range NODE@ repeat
iterate over code until @end@ setting $RANGE_START and
$RANGE_END to the legal accepted range set for a given mib
NODE.</p>

<p>@foreach $var stuff a b c d@ repeat iterate over values
a, b, c, d as assigned generically (ie, the values are taken
straight from the list with no mib- expansion, etc).</p>

<p>@while expression@ repeat iterate over code until the
expression is false</p>

<p>@eval $VAR = expression@ evaluates expression and
assigns the results to $VAR. This is not a full perl eval,
but sort of a &quot;&quot;psuedo&quot;&quot; eval useful for
simple expressions while keeping the same variable name
space. See below for a full-blown export to perl.</p>

<p>@perleval STUFF@ evaluates STUFF directly in perl. Note
that all mib2c variables interpereted within .conf files are
in $vars{NAME} and that a warning will be printed if STUFF
does not return 0. (adding a return 0; at the end of STUFF
is a workaround.</p>

<p>@startperl@</p>

<p>@endperl@ treats everything between these tags as perl
code, and evaluates it.</p>

<p>@next@ restart foreach; should only be used inside a
conditional. skips out of current conditional, then
continues to skip to end for the current foreach clause.</p>

<p>@if expression@ evaluates expression, and if expression
is true processes con- tained part until appropriate @end@
is reached. If the expres- sion is false, the next @elsif
expression@ expression (if it exists) will be evaluated,
until an expression is true. If no such expression exists
and an @else@ clause is found, it will be evaluated.</p>

<p>@ifconf file@ If the specified file can be found in the
conf file search path, and if found processes contained part
until an appropriate @end@ is found. As with a regular @if
expression@, @elsif expression@ and @else@ can be used.</p>

<p>@ifdir dir@ If the specified directory exists, process
contained part until an appropriate @end@ is found. As with
a regular @if expres- sion@, @elsif expression@ and @else@
can be used.</p>

<p>@define NAME@</p>

<p>@enddefine@ Memorizes &quot;&quot;stuff&quot;&quot;
between the define and enddefine tags for later calling as
NAME by @calldefine NAME@.</p>

<p>@calldefine NAME@ Executes stuff previously memorized as
NAME.</p>

<p>@printf &quot;expression&quot; stuff1, stuff2, ...@ Like
all the other printfs you know and love.</p>

<p>@run FILE@ Sources the contents of FILE as a mib2c file,
but does not affect current files opened.</p>

<p>@include FILE@ Sources the contents of FILE as a mib2c
file and appends its output to the current output.</p>

<p>@prompt $var QUESTION@ Presents the user with QUESTION,
expects a response and puts it in $var</p>

<p>@print STUFF@ Prints stuff directly to the users screen
(ie, not to where nor- mal mib2c output goes)</p>

<p>@quit@ Bail out (silently)</p>

<p>@exit@ Bail out!</p>

<p>VARIABLES Variables in the mib2c language look very
similar to perl variables, in that they start with a
&quot;$&quot;. They can be used for anything you want, but
most typically theyll hold mib node names being processed by
@foreach ...@ clauses.</p>

<p>They also have a special properties when they are a mib
node, such that adding special suffixes to them will allow
them to be interpreted in some fashion. The easiest way to
understand this is through an exam- ple. If the variable x
contained the word ifType then some magical things happen.
In mib2c output, anytime $x is seen it is replaced with
&quot;ifType&quot;. Additional suffixes can be used to get
other aspects of that mib node though. If $x.objectID is
seen, it ll be replaced by the OID for ifType:
&quot;.1.3.6.1.2.1.2.2.1.3&quot;. Other suffixes that can
appear after a dot are listed below.</p>

<p>One last thing: you can use things like $vartext
immediately ending in some other text, you can use {}s to
get proper expansion of only part of the mib2c input. IE,
$xtext will produce &quot;$xtext&quot;, but ${x}text will
produce &quot;ifTypetext&quot; instead.</p>

<p>$var.uc all upper case version of $var</p>

<p>$var.objectID dotted, fully-qualified, and numeric
OID</p>

<p>$var.commaoid comma separated numeric OID for array
initialization</p>

<p>$var.oidlength length of the oid</p>

<p>$var.subid last number component of oid</p>

<p>$var.module MIB name that the object comes from</p>

<p>$var.parent contains the label of the parent node of
$var.</p>

<p>$var.isscalar returns 1 if var contains the name of a
scalar</p>

<p>$var.iscolumn returns 1 if var contains the name of a
column</p>

<p>$var.children returns 1 if var has children</p>

<p>$var.perltype nodes perl SYNTAX
($SNMP::MIB{node}{syntax})</p>

<p>$var.type nodes ASN_XXX type (Net-SNMP specific
#define)</p>

<p>$var.decl C data type (char, u_long, ...)</p>

<p>$var.readable 1 if an object is readable, 0 if not</p>

<p>$var.settable 1 if an object is writable, 0 if not</p>

<p>$var.creatable 1 if a column object can be created as
part of a new row, 0 if not</p>

<p>$var.noaccess 1 if not-accessible, 0 if not</p>

<p>$var.accessible 1 if accessible, 0 if not</p>

<p>$var.rowstatus 1 if an object is a RowStatus object, 0
if not settable, cre- atable and rowstatus can also be used
with table variables to indicate whether it contains
writable, creatable or RowStatus column objects</p>

<p>$var.hasdefval returns 1 if var has a DEFVAL clause</p>

<p>$var.defval nodes DEFVAL</p>

<p>$var.hashint returns 1 if var has a HINT clause</p>

<p>$var.hint nodes HINT</p>

<p>$var.ranges returns 1 if var has a value range
defined</p>

<p>$var.enums returns 1 if var has enums defined for
it.</p>

<p>$var.access nodes access type</p>

<p>$var.status nodes status</p>

<p>$var.syntax nodes syntax</p>

<p>$var.reference nodes reference</p>

<p>$var.description nodes description</p>

<p>SEE ALSO mib2c(1)</p>

<p>4th Berkeley Distribution 28 Apr 2004 MIB2C.CONF(5)</p>
<hr>
</body>
</html>
