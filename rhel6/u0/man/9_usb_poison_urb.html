<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:24:29 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_POISON_URB(9) USB Core APIs USB_POISON_URB(9)</p>

<p>NAME usb_poison_urb - reliably kill a transfer and
prevent further use of an URB</p>

<p>SYNOPSIS void usb_poison_urb(struct urb * urb);</p>

<p>ARGUMENTS urb pointer to URB describing a previously
submitted request, may be NULL</p>

<p>DESCRIPTION This routine cancels an in-progress request.
It is guaranteed that upon return all completion handlers
will have finished and the URB will be totally idle and
cannot be reused. These features make this an ideal way to
stop I/O in a disconnect callback. If the request has not
already finished or been unlinked the completion handler
will see urb-&gt;status == -ENOENT.</p>

<p>After and while the routine runs, attempts to resubmit
the URB will fail with error -EPERM. Thus even if the
URB&acute;s completion handler always tries to resubmit, it
will not succeed and the URB will become idle.</p>

<p>This routine may not be used in an interrupt context
(such as a bottom half or a completion handler), or when
holding a spinlock, or in other situations where the caller
can&acute;t schedule.</p>

<p>This routine should not be called by a driver after its
disconnect method has returned.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
USB_POISON_URB(9)</p>
<hr>
</body>
</html>
