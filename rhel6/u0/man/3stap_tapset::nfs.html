<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:34 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TAPSET::NFS(3stap) TAPSET::NFS(3stap)</p>

<p>NAME tapset::nfs - systemtap NFS client side probe
points</p>

<p>DESCRIPTION This family of probe points is used to probe
NFS activities on client side. It contains the following
probe points:</p>

<p>nfs.fop.llseek</p>

<p>Fires whenever doing a llseek operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>maxbyte Maximum size of the files</p>

<p>offset the offset of file to be repositioned</p>

<p>origin the original position. The possible value could
be: SEEK_SET The offset is set to offset bytes. SEEK_CUR The
offset is set to its current location plus offset bytes.
SEEK_END The offset is set to the size of the file plus
offset bytes.</p>

<p>nfs.fop.llseek.return</p>

<p>Fires whenever nfs llseek operation is done</p>

<p>Arguments:</p>

<p>retstr resulting offset location</p>

<p>nfs.fop.read</p>

<p>Fires whenever doing a read operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>len,size number of bytes to be read</p>

<p>pos current file offset</p>

<p>buf the buf address</p>

<p>nfs.fop.read.return</p>

<p>Fires whenever nfs read operation is done</p>

<p>Arguments:</p>

<p>size number of bytes read</p>

<p>nfs.fop.write</p>

<p>Fires whenever doing a write operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>len,size number of bytes to written</p>

<p>pos current file offset</p>

<p>buf the buf address</p>

<p>nfs.fop.write.return</p>

<p>Fires whenever nfs write operation is done</p>

<p>Arguments:</p>

<p>size number of bytes written</p>

<p>nfs.fop.aio_read</p>

<p>Fires whenever doing an aio_read operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>count,size number of bytes to be read</p>

<p>pos current file offset</p>

<p>buf the buf address</p>

<p>parent_name parent dir name</p>

<p>file_name file name</p>

<p>cache_valid cache related bit mask flag</p>

<p>cache_time when we started read-caching this inode</p>

<p>attrtimeo how long the cached information is assumed to
be valid.</p>

<p>The cached attrs for this inode needed to be revalidated
if jiffies - read_cache_jiffies &gt; attrtime</p>

<p>nfs.fop.aio_read.return</p>

<p>Fires whenever nfs aio_read operation is done</p>

<p>Arguments:</p>

<p>size number of bytes read</p>

<p>nfs.fop.aio_write</p>

<p>Fires whenever doing an aio_write operation on nfs
client side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>count,size number of bytes to written</p>

<p>pos current file offset</p>

<p>buf the buf address</p>

<p>parent_name parent dir name</p>

<p>file_name file name</p>

<p>nfs.fop.aio_write.return</p>

<p>Fires whenever nfs aio_write operation is done</p>

<p>Arguments:</p>

<p>size number of bytes written</p>

<p>nfs.fop.mmap</p>

<p>Fires whenever doing an mmap operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>vm_start start address within vm_mm</p>

<p>vm_end the first byte after end address within vm_mm</p>

<p>vm_flag vm flags</p>

<p>parent_name parent dir name</p>

<p>file_name file name</p>

<p>cache_valid cache related bit mask flag</p>

<p>cache_time when we started read-caching this inode</p>

<p>attrtimeo how long the cached information is assumed to
be valid.</p>

<p>The cached attrs for this inode needed to be revalidated
if jiffies - read_cache_jiffies &gt; attrtime</p>

<p>nfs.fop.open</p>

<p>Fires whenever doing an open operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>file_name file name</p>

<p>flag file flag</p>

<p>i_size file length in bytes</p>

<p>nfs.fop.flush</p>

<p>Fires whenever doing an flush operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>mode file mode</p>

<p>ndirty number of dirty page to be flushed</p>

<p>nfs.fop.release</p>

<p>Fires whenever doing a release page operation on nfs
client side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>mode file mode</p>

<p>nfs.fop.fsync</p>

<p>Fires whenever doing a fsync operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>ndirty number of dirty page to be flushed</p>

<p>nfs.fop.lock</p>

<p>Fires whenever doing a file lock operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>i_mode file type and access rights</p>

<p>cmd cmd arguments</p>

<p>fl_type lock type</p>

<p>fl_flag lock flags</p>

<p>fl_start starting offset of locked region</p>

<p>fl_end ending offset of locked region</p>

<p>nfs.fop.sendfile</p>

<p>Fires whenever doing a send file operation on nfs client
side</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>s_id the pointer to s_id</p>

<p>devname the combination of server ip and the name of
block device on server</p>

<p>count,size number of bytes to sent</p>

<p>ppos current file offset</p>

<p>cache_valid cache related bit mask flag</p>

<p>cache_time when we started read-caching this inode</p>

<p>attrtimeo how long the cached information is assumed to
be valid.</p>

<p>The cached attrs for this inode needed to be revalidated
if jiffies - read_cache_jiffies &gt; attrtime</p>

<p>nfs.fop.sendfile.return</p>

<p>Fires whenever nfs sendfile operation is done</p>

<p>Arguments:</p>

<p>size number of bytes sent</p>

<p>nfs.fop.check_flags</p>

<p>Fires whenever doing a check flag operation on nfs
client side</p>

<p>Arguments:</p>

<p>flags file flag</p>

<p>nfs.aop.readpage</p>

<p>Fires when a previous async read operation failed</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>i_flag file flags</p>

<p>i_size file length in bytes</p>

<p>sb_flag super block flags</p>

<p>file file argument</p>

<p>page_index offset within mapping</p>

<p>rsize read size (in bytes)</p>

<p>nfs.aop.readpages</p>

<p>Fires when in readahead way, read several pages once</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>nr_pages ,size number of pages attempted to read in this
execution</p>

<p>file filp argument</p>

<p>rpages read size (in pages)</p>

<p>rsize read size (in bytes)</p>

<p>nfs.aop.readpages.return</p>

<p>Fires whenever a nfs read pages operation is done</p>

<p>Arguments:</p>

<p>size number of pages read</p>

<p>nfs.aop.set_page_dirty</p>

<p>Fires whenever set page dirty on nfs client side</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>page_flag page flags</p>

<p>nfs.aop.writepage</p>

<p>Fires whenever writing an mapped page to the server from
nfs client side</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>for_reclaim a flag of writeback_control, indicates if
its invoked from the page allocator</p>

<p>for_kupdate a flag of writeback_control, indicates if
its a kupdate writeback The priority of wb is decided by
above two flags</p>

<p>i_flag file flags</p>

<p>i_size file length in bytes</p>

<p>i_state inode state flags</p>

<p>sb_flag super block flags</p>

<p>page_index offset within mapping</p>

<p>wsize write size</p>

<p>nfs.aop.writepages</p>

<p>Fires whenever writing several dirty pages to the server
from nfs client sides</p>

<p>Arguments:</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>for_reclaim a flag of writeback_control, indicates if it
s invoked from the page allocator</p>

<p>for_kupdate a flag of writeback_control, indicates if
its a kupdate writeback The priority of wb is decided by
above two flags</p>

<p>wpages write size (in pages)</p>

<p>wsize write size</p>

<p>nr_to_write ,size number of pages attempted to be
written in this execution</p>

<p>nfs.aop.prepare_write</p>

<p>Fires whenever prepare a page for writing on nfs client
sides</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>offset start address of this write operation</p>

<p>to end address of this write operation</p>

<p>page_index offset within mapping</p>

<p>size read bytes</p>

<p>nfs.aop.commit_write</p>

<p>Fires often after prepare write operation</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>offset start address of this write operation</p>

<p>to end address of this write operation</p>

<p>i_flag file flags</p>

<p>i_size file length in bytes</p>

<p>sb_flag super block flag</p>

<p>page_index offset within mapping</p>

<p>size read bytes</p>

<p>nfs.aop.release_page</p>

<p>Arguments:</p>

<p>__page the address of page</p>

<p>dev device identifier</p>

<p>ino inode number</p>

<p>page_index offset within mapping</p>

<p>nfs.proc.lookup</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>filename the name of file which client opens/searches on
server</p>

<p>name_len the length of file name</p>

<p>bitmask0, bitmask1 V4 bitmask representing the set of
attributes supported on this filesystem (only in probe
nfs.proc4.lookup)</p>

<p>nfs.proc.read</p>

<p>Fires when client synchronously reads file from
server</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>flags used to set task-&gt;tk_flags in rpc_init_task
function</p>

<p>size,count number of bytes to be read in this
execution</p>

<p>offset the file offset</p>

<p>nfs.proc.read.return</p>

<p>Fires when synchronously reading file from server is
done</p>

<p>Arguments:</p>

<p>size number of bytes read</p>

<p>nfs.proc.write</p>

<p>Fires when client synchronously writes file to
server</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>flags used to set task-&gt;tk_flags in rpc_init_task
function</p>

<p>size,count number of bytes to be written in this
execution</p>

<p>offset the file offset</p>

<p>bitmask0, bitmask1 V4 bitmask representing the set of
attributes supported on this filesystem (only in probe
nfs.proc4.lookup)</p>

<p>nfs.proc.write.return</p>

<p>Fires when synchronously writing file from server is
done</p>

<p>Arguments:</p>

<p>size number of bytes written</p>

<p>nfs.proc.commit</p>

<p>Fires when client writes the buffered data to disk, the
buffered data is asynchronously written by client before(not
exist in NFSV2)</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>size,count number of bytes to be written in this
execution</p>

<p>offset the file offset</p>

<p>bitmask0, bitmask1 V4 bitmask representing the set of
attributes supported on this filesystem (only in probe
nfs.proc4.lookup)</p>

<p>nfs.proc.commit.return</p>

<p>Fires when committing operation is done</p>

<p>Arguments:</p>

<p>size number of bytes written</p>

<p>nfs.proc.read_setup</p>

<p>Fires when client asynchronously reads file from server,
this function is used to setup a read rpc task, not do a
real read operation.</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>size,count number of bytes to be read in this
execution</p>

<p>offset the file offset</p>

<p>nfs.proc.read_done</p>

<p>Fires when a read reply is received or some read error
occur (timeout or socket shutdown)</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>status result of last async read operation</p>

<p>count number of bytes read</p>

<p>timestamp time stamp, which is used for lease renewal
(only in nfs.proc4.read_done)</p>

<p>nfs.proc.write_setup</p>

<p>Fires when client asynchronously write data to server,
this function is used to setup a write rpc task, not do a
write read operation.</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>size,count number of bytes to be written in this
execution</p>

<p>offset the file offset</p>

<p>how used to set args.stable, The possible value could
be: NFS_UNSTABLE, NFS_DATA_SYNC, NFS_FILE_SYNC (only in
nfs.proc3.write_setup and nfs.proc4.write_setup)</p>

<p>bitmask0, bitmask1 V4 bitmask representing the set of
attributes supported on this filesystem (only in probe
nfs.proc4.write_setup)</p>

<p>nfs.proc.write_done</p>

<p>Fires when a write reply is received or some write error
occur (timeout or socket shutdown)</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>status result of last async write operation</p>

<p>valid fattr-&gt;valid, indicates which fields are
valid</p>

<p>count number of bytes written</p>

<p>timestamp time stamp, which is used for lease renewal
(only in nfs.proc4.read_done)</p>

<p>nfs.proc.commit_setup</p>

<p>Fires when client asynchronously do a commit operation,
this function is used to setup a commit rpc task, not do a
commit read operation.</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>size,count number of bytes to be written in this
execution</p>

<p>offset the file offset</p>

<p>bitmask0, bitmask1 V4 bitmask representing the set of
attributes supported on this filesystem (only in probe
nfs.proc4.commit_setup)</p>

<p>nfs.proc.commit_done</p>

<p>Fires when a commit reply is received or some commit
error occur (timeout or socket shutdown)</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>status result of last async write operation</p>

<p>valid fattr-&gt;valid, indicates which fields are
valid</p>

<p>count number of bytes written</p>

<p>timestamp time stamp, which is used for lease renewal
(only in nfs.proc4.read_done)</p>

<p>nfs.proc.open</p>

<p>Fires whenever doing a open operation on nfs client
side, the nfs_open function is used to allocate file
read/write context information</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>filename file name</p>

<p>flag file flag</p>

<p>mode file mode</p>

<p>nfs.proc.release</p>

<p>Fires whenever doing a release operation on nfs client
side,</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>filename file name</p>

<p>flag file flag</p>

<p>mode file mode</p>

<p>nfs.proc4.handle_exception</p>

<p>Fires whenever doing the error handling, only exist in
NFSV4</p>

<p>errorcode error code</p>

<p>nfs.proc.create</p>

<p>Fires whenever nfs client creates a file on server</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>fh file handler of parent dir</p>

<p>filename file name</p>

<p>filelen length of file name</p>

<p>flag indicates create mode(only for NFSV3 and NFSV4)</p>

<p>nfs.proc.remove</p>

<p>Fires whenever nfs client removes a file from server</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>fh file handler of parent dir</p>

<p>filename file name</p>

<p>filelen length of file name</p>

<p>nfs.proc.rename</p>

<p>Fires whenever nfs client renames a file on server</p>

<p>Arguments:</p>

<p>server_ip ip address of server</p>

<p>prot transfer protocol</p>

<p>version nfs version</p>

<p>old_fh file handler of old parent dir</p>

<p>old_name old file name</p>

<p>old_filelen length of old file name</p>

<p>new_fh file handler of new parent dir</p>

<p>new_name new file name</p>

<p>new_filelen length of new file name</p>

<p>SEE ALSO stap(1), stapprobes(3stap)</p>

<p>IBM TAPSET::NFS(3stap)</p>
<hr>
</body>
</html>
