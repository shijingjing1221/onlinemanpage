<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 21:59:59 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>FOPEN(3P) POSIX Programmer s Manual FOPEN(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME fopen - open a stream</p>

<p>SYNOPSIS #include &lt;stdio.h&gt;</p>

<p>FILE *fopen(const char *restrict filename, const char
*restrict mode);</p>

<p>DESCRIPTION The fopen() function shall open the file
whose pathname is the string pointed to by filename, and
associates a stream with it.</p>

<p>The mode argument points to a string. If the string is
one of the fol- lowing, the file shall be opened in the
indicated mode. Otherwise, the behavior is undefined.</p>

<p>r or rb Open file for reading.</p>

<p>w or wb Truncate to zero length or create file for
writing.</p>

<p>a or ab Append; open or create file for writing at
end-of-file.</p>

<p>r+ or rb+ or r+b Open file for update (reading and
writing).</p>

<p>w+ or wb+ or w+b Truncate to zero length or create file
for update.</p>

<p>a+ or ab+ or a+b Append; open or create file for update,
writing at end-of-file.</p>

<p>The characterbshall have no effect, but is allowed for
ISO C stan- dard conformance. Opening a file with read mode
(r as the first char- acter in the mode argument) shall fail
if the file does not exist or cannot be read.</p>

<p>Opening a file with append mode (a as the first
character in the mode argument) shall cause all subsequent
writes to the file to be forced to the then current
end-of-file, regardless of intervening calls to fseek().</p>

<p>When a file is opened with update mode (+as the second
or third character in the mode argument), both input and
output may be performed on the associated stream. However,
the application shall ensure that output is not directly
followed by input without an intervening call to fflush() or
to a file positioning function ( fseek(), fsetpos(), or
rewind()), and input is not directly followed by output
without an intervening call to a file positioning function,
unless the input oper- ation encounters end-of-file.</p>

<p>When opened, a stream is fully buffered if and only if
it can be determined not to refer to an interactive device.
The error and end-of- file indicators for the stream shall
be cleared.</p>

<p>If mode is w, wb, a, ab, w+, wb+, w+b, a+, ab+, or a+b,
and the file did not previously exist, upon successful
completion, the fopen() func- tion shall mark for update the
st_atime, st_ctime, and st_mtime fields of the file and the
st_ctime and st_mtime fields of the parent direc- tory.</p>

<p>If mode is w, wb, w+, wb+, or w+b, and the file did
previously exist, upon successful completion, fopen() shall
mark for update the st_ctime and st_mtime fields of the
file. The fopen() function shall allocate a file descriptor
as open() does.</p>

<p>After a successful call to the fopen() function, the
orientation of the stream shall be cleared, the encoding
rule shall be cleared, and the associated mbstate_t object
shall be set to describe an initial conver- sion state.</p>

<p>The largest value that can be represented correctly in
an object of type off_t shall be established as the offset
maximum in the open file description.</p>

<p>RETURN VALUE Upon successful completion, fopen() shall
return a pointer to the object controlling the stream.
Otherwise, a null pointer shall be returned, and errno shall
be set to indicate the error.</p>

<p>ERRORS The fopen() function shall fail if:</p>

<p>EACCES Search permission is denied on a component of the
path prefix, or the file exists and the permissions
specified by mode are denied, or the file does not exist and
write permission is denied for the parent directory of the
file to be created.</p>

<p>EINTR A signal was caught during fopen().</p>

<p>EISDIR The named file is a directory and mode requires
write access.</p>

<p>ELOOP A loop exists in symbolic links encountered during
resolution of the path argument.</p>

<p>EMFILE {OPEN_MAX} file descriptors are currently open in
the calling process.</p>

<p>ENAMETOOLONG</p>

<p>The length of the filename argument exceeds {PATH_MAX}
or a pathname component is longer than {NAME_MAX}.</p>

<p>ENFILE The maximum allowable number of files is
currently open in the system.</p>

<p>ENOENT A component of filename does not name an existing
file or file- name is an empty string.</p>

<p>ENOSPC The directory or file system that would contain
the new file cannot be expanded, the file does not exist,
and the file was to be created.</p>

<p>ENOTDIR A component of the path prefix is not a
directory.</p>

<p>ENXIO The named file is a character special or block
special file, and the device associated with this special
file does not exist.</p>

<p>EOVERFLOW The named file is a regular file and the size
of the file cannot be represented correctly in an object of
type off_t.</p>

<p>EROFS The named file resides on a read-only file system
and mode requires write access.</p>

<p>The fopen() function may fail if:</p>

<p>EINVAL The value of the mode argument is not valid.</p>

<p>ELOOP More than {SYMLOOP_MAX} symbolic links were
encountered during resolution of the path argument.</p>

<p>EMFILE {FOPEN_MAX} streams are currently open in the
calling process.</p>

<p>EMFILE {STREAM_MAX} streams are currently open in the
calling process.</p>

<p>ENAMETOOLONG</p>

<p>Pathname resolution of a symbolic link produced an
intermediate result whose length exceeds {PATH_MAX}.</p>

<p>ENOMEM Insufficient storage space is available.</p>

<p>ETXTBSY The file is a pure procedure (shared text) file
that is being executed and mode requires write access.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES Opening a File The following example tries to
open the file named file for reading. The fopen() function
returns a file pointer that is used in subsequent fgets()
and fclose() calls. If the program cannot open the file, it
just ignores it.</p>

<p>#include &lt;stdio.h&gt; ... FILE *fp; ... void
rgrep(const char *file) { ... if ((fp = fopen(file,
&quot;r&quot;)) == NULL) return; ... }</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO fclose(), fdopen(), freopen(), the Base
Definitions volume of IEEE Std 1003.1-2001,
&lt;stdio.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 FOPEN(3P)</p>
<hr>
</body>
</html>
