<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 21:52:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>apply(n) Tcl Built-In Commands apply(n)</p>


<p>______________________________________________________________________________</p>

<p>NAME apply - Apply an anonymous function</p>

<p>SYNOPSIS apply func ?arg1 arg2 ...?
_________________________________________________________________</p>

<p>DESCRIPTION The command apply applies the function func
to the arguments arg1 arg2 ... and returns the result.</p>

<p>The function func is a two element list {args body} or a
three element list {args body namespace} (as if the list
command had been used). The first element args specifies the
formal arguments to func. The specifi- cation of the formal
arguments args is shared with the proc command, and is
described in detail in the corresponding manual page.</p>

<p>The contents of body are executed by the Tcl interpreter
after the local variables corresponding to the formal
arguments are given the values of the actual parameters arg1
arg2 .... When body is being exe- cuted, variable names
normally refer to local variables, which are cre- ated
automatically when referenced and deleted when apply
returns. One local variable is automatically created for
each of the functions arguments. Global variables can only
be accessed by invoking the global command or the upvar
command. Namespace variables can only be accessed by
invoking the variable command or the upvar command.</p>

<p>The invocation of apply adds a call frame to Tcl s
evaluation stack (the stack of frames accessed via uplevel).
The execution of body pro- ceeds in this call frame, in the
namespace given by namespace or in the global namespace if
none was specified. If given, namespace is inter- preted
relative to the global namespace even if its name does not
start with ::.</p>

<p>The semantics of apply can also be described by:</p>

<p>proc apply {fun args} { set len [llength $fun] if {($len
&lt; 2) || ($len &gt; 3)} { error &quot;cant interpret }
lassign $fun argList body ns set name
::$ns::[getGloballyUniqueName] set body0 { rename [lindex
[info level 0] 0] {} } proc $name $argList ${body0}$body set
code [catch {uplevel 1 $name $args} res opt] return -options
$opt $res }</p>

<p>EXAMPLES This shows how to make a simple general command
that applies a trans- formation to each element of a list.
proc map {lambda list} { set result {} foreach item $list {
lappend result [apply $lambda $item] } return $result } map
{x {return [string length $x]:$x}} {a bb ccc dddd} _1:a 2:bb
3:ccc 4:dddd map {x {expr {$x**2 + 3*$x - 2}}} {-4 -3 -2 -1
0 1 2 3 4} _2 -2 -4 -4 -2 2 8 16 26</p>

<p>The apply command is also useful for defining callbacks
for use in the trace command: set vbl &quot;123abc&quot;
trace add variable vbl write {apply {{v1 v2 op} { upvar 1
$v1 v puts &quot;updated variable to }}} set vbl 123 set vbl
abc</p>

<p>SEE ALSO proc(n), uplevel(n)</p>

<p>KEYWORDS argument, procedure, anonymous function</p>

<p>Tcl apply(n)</p>
<hr>
</body>
</html>
