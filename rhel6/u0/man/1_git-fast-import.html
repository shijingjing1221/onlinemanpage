<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:33 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-FAST-IMPORT(1) Git Manual GIT-FAST-IMPORT(1)</p>

<p>NAME git-fast-import - Backend for fast Git data
importers</p>

<p>SYNOPSIS frontend | git fast-import [options]</p>

<p>DESCRIPTION This program is usually not what the end
user wants to run directly. Most end users want to use one
of the existing frontend programs, which parses a specific
type of foreign source and feeds the contents stored there
to git fast-import.</p>

<p>fast-import reads a mixed command/data stream from
standard input and writes one or more packfiles directly
into the current repository. When EOF is received on
standard input, fast import writes out updated branch and
tag refs, fully updating the current repository with the
newly imported data.</p>

<p>The fast-import backend itself can import into an empty
repository (one that has already been initialized by git
init) or incrementally update an existing populated
repository. Whether or not incremental imports are supported
from a particular foreign source depends on the frontend
program in use.</p>

<p>OPTIONS --date-format=&lt;fmt&gt; Specify the type of
dates the frontend will supply to fast-import within author,
committer and tagger commands. See Date Formats below for
details about which formats are supported, and their
syntax.</p>

<p>--force Force updating modified existing branches, even
if doing so would cause commits to be lost (as the new
commit does not contain the old commit).</p>

<p>--max-pack-size=&lt;n&gt; Maximum size of each output
packfile. The default is unlimited.</p>

<p>--big-file-threshold=&lt;n&gt; Maximum size of a blob
that fast-import will attempt to create a delta for,
expressed in bytes. The default is 512m (512 MiB). Some
importers may wish to lower this on systems with constrained
memory.</p>

<p>--depth=&lt;n&gt; Maximum delta depth, for blob and tree
deltification. Default is 10.</p>

<p>--active-branches=&lt;n&gt; Maximum number of branches
to maintain active at once. See Memory Utilization below for
details. Default is 5.</p>

<p>--export-marks=&lt;file&gt; Dumps the internal marks
table to &lt;file&gt; when complete. Marks are written one
per line as :markid SHA-1. Frontends can use this file to
validate imports after they have been completed, or to save
the marks table across incremental runs. As &lt;file&gt; is
only opened and truncated at checkpoint (or completion) the
same path can also be safely given to --import-marks.</p>

<p>--import-marks=&lt;file&gt; Before processing any input,
load the marks specified in &lt;file&gt;. The input file
must exist, must be readable, and must use the same format
as produced by --export-marks. Multiple options may be
supplied to import more than one set of marks. If a mark is
defined to different values, the last file wins.</p>

<p>--relative-marks After specifying --relative-marks= the
paths specified with --import-marks= and --export-marks= are
relative to an internal directory in the current repository.
In git-fast-import this means that the paths are relative to
the .git/info/fast-import directory. However, other
importers may use a different location.</p>

<p>--no-relative-marks Negates a previous --relative-marks.
Allows for combining relative and non-relative marks by
interweaving --(no-)-relative-marks= with the
--(import|export)-marks= options.</p>

<p>--export-pack-edges=&lt;file&gt; After creating a
packfile, print a line of data to &lt;file&gt; listing the
filename of the packfile and the last commit on each branch
that was written to that packfile. This information may be
useful after importing projects whose total object set
exceeds the 4 GiB packfile limit, as these commits can be
used as edge points during calls to git pack-objects.</p>

<p>--quiet Disable all non-fatal output, making fast-import
silent when it is successful. This option disables the
output shown by --stats.</p>

<p>--stats Display some basic statistics about the objects
fast-import has created, the packfiles they were stored
into, and the memory used by fast-import during this run.
Showing this output is currently the default, but can be
disabled with --quiet.</p>

<p>PERFORMANCE The design of fast-import allows it to
import large projects in a minimum amount of memory usage
and processing time. Assuming the frontend is able to keep
up with fast-import and feed it a constant stream of data,
import times for projects holding 10+ years of history and
containing 100,000+ individual commits are generally
completed in just 1-2 hours on quite modest (~$2,000 USD)
hardware.</p>

<p>Most bottlenecks appear to be in foreign source data
access (the source just cannot extract revisions fast
enough) or disk IO (fast-import writes as fast as the disk
will take the data). Imports will run faster if the source
data is stored on a different drive than the destination Git
repository (due to less IO contention).</p>

<p>DEVELOPMENT COST A typical frontend for fast-import
tends to weigh in at approximately 200 lines of
Perl/Python/Ruby code. Most developers have been able to
create working importers in just a couple of hours, even
though it is their first exposure to fast-import, and
sometimes even to Git. This is an ideal situation, given
that most conversion tools are throw-away (use once, and
never look back).</p>

<p>PARALLEL OPERATION Like git push or git fetch, imports
handled by fast-import are safe to run alongside parallel
git repack -a -d or git gc invocations, or any other Git
operation (including git prune, as loose objects are never
used by fast-import).</p>

<p>fast-import does not lock the branch or tag refs it is
actively importing. After the import, during its ref update
phase, fast-import tests each existing branch ref to verify
the update will be a fast-forward update (the commit stored
in the ref is contained in the new history of the commit to
be written). If the update is not a fast-forward update,
fast-import will skip updating that ref and instead prints a
warning message. fast-import will always attempt to update
all branch refs, and does not stop on the first failure.</p>

<p>Branch updates can be forced with --force, but its
recommended that this only be used on an otherwise quiet
repository. Using --force is not necessary for an initial
import into an empty repository.</p>

<p>TECHNICAL DISCUSSION fast-import tracks a set of
branches in memory. Any branch can be created or modified at
any point during the import process by sending a commit
command on the input stream. This design allows a frontend
program to process an unlimited number of branches
simultaneously, generating commits in the order they are
available from the source data. It also simplifies the
frontend programs considerably.</p>

<p>fast-import does not use or alter the current working
directory, or any file within it. (It does however update
the current Git repository, as referenced by GIT_DIR.)
Therefore an import frontend may use the working directory
for its own purposes, such as extracting file revisions from
the foreign source. This ignorance of the working directory
also allows fast-import to run very quickly, as it does not
need to perform any costly file update operations when
switching between branches.</p>

<p>INPUT FORMAT With the exception of raw file data (which
Git does not interpret) the fast-import input format is text
(ASCII) based. This text based format simplifies development
and debugging of frontend programs, especially when a higher
level language such as Perl, Python or Ruby is being
used.</p>

<p>fast-import is very strict about its input. Where we say
SP below we mean exactly one space. Likewise LF means one
(and only one) linefeed. Supplying additional whitespace
characters will cause unexpected results, such as branch
names or file names with leading or trailing spaces in their
name, or early termination of fast-import when it encounters
unexpected input.</p>

<p>Stream Comments To aid in debugging frontends
fast-import ignores any line that begins with # (ASCII
pound/hash) up to and including the line ending LF. A
comment line may contain any sequence of bytes that does not
contain an LF and therefore may be used to include any
detailed debugging information that might be specific to the
frontend and useful when inspecting a fast-import data
stream.</p>

<p>Date Formats The following date formats are supported. A
frontend should select the format it will use for this
import by passing the format name in the
--date-format=&lt;fmt&gt; command line option.</p>

<p>raw This is the Git native format and is &lt;time&gt; SP
&lt;offutc&gt;. It is also fast-imports default format, if
--date-format was not specified.</p>

<p>The time of the event is specified by &lt;time&gt; as
the number of seconds since the UNIX epoch (midnight, Jan 1,
1970, UTC) and is written as an ASCII decimal integer.</p>

<p>The local offset is specified by &lt;offutc&gt; as a
positive or negative offset from UTC. For example EST (which
is 5 hours behind UTC) would be expressed in &lt;tz&gt; by
-0500 while UTC is +0000 . The local offset does not affect
&lt;time&gt;; it is used only as an advisement to help
formatting routines display the timestamp.</p>

<p>If the local offset is not available in the source
material, use +0000 , or the most common local offset. For
example many organizations have a CVS repository which has
only ever been accessed by users who are located in the same
location and timezone. In this case a reasonable offset from
UTC could be assumed.</p>

<p>Unlike the rfc2822 format, this format is very strict.
Any variation in formatting will cause fast-import to reject
the value.</p>

<p>rfc2822 This is the standard email format as described
by RFC 2822.</p>

<p>An example value is Tue Feb 6 11:22:18 2007 -0500. The
Git parser is accurate, but a little on the lenient side. It
is the same parser used by git am when applying patches
received from email.</p>

<p>Some malformed strings may be accepted as valid dates.
In some of these cases Git will still be able to obtain the
correct date from the malformed string. There are also some
types of malformed strings which Git will parse wrong, and
yet consider valid. Seriously malformed strings will be
rejected.</p>

<p>Unlike the raw format above, the timezone/UTC offset
information contained in an RFC 2822 date string is used to
adjust the date value to UTC prior to storage. Therefore it
is important that this information be as accurate as
possible.</p>

<p>If the source material uses RFC 2822 style dates, the
frontend should let fast-import handle the parsing and
conversion (rather than attempting to do it itself) as the
Git parser has been well tested in the wild.</p>

<p>Frontends should prefer the raw format if the source
material already uses UNIX-epoch format, can be coaxed to
give dates in that format, or its format is easily
convertible to it, as there is no ambiguity in parsing.</p>

<p>now Always use the current time and timezone. The
literal now must always be supplied for &lt;when&gt;.</p>

<p>This is a toy format. The current time and timezone of
this system is always copied into the identity string at the
time it is being created by fast-import. There is no way to
specify a different time or timezone.</p>

<p>This particular format is supplied as it s short to
implement and may be useful to a process that wants to
create a new commit right now, without needing to use a
working directory or git update-index.</p>

<p>If separate author and committer commands are used in a
commit the timestamps may not match, as the system clock
will be polled twice (once for each command). The only way
to ensure that both author and committer identity
information has the same timestamp is to omit author (thus
copying from committer) or to use a date format other than
now.</p>

<p>Commands fast-import accepts several commands to update
the current repository and control the current import
process. More detailed discussion (with examples) of each
command follows later.</p>

<p>commit Creates a new branch or updates an existing
branch by creating a new commit and updating the branch to
point at the newly created commit.</p>

<p>tag Creates an annotated tag object from an existing
commit or branch. Lightweight tags are not supported by this
command, as they are not recommended for recording
meaningful points in time.</p>

<p>reset Reset an existing branch (or a new branch) to a
specific revision. This command must be used to change a
branch to a specific revision without making a commit on
it.</p>

<p>blob Convert raw file data into a blob, for future use
in a commit command. This command is optional and is not
needed to perform an import.</p>

<p>checkpoint Forces fast-import to close the current
packfile, generate its unique SHA-1 checksum and index, and
start a new packfile. This command is optional and is not
needed to perform an import.</p>

<p>progress Causes fast-import to echo the entire line to
its own standard output. This command is optional and is not
needed to perform an import.</p>

<p>feature Require that fast-import supports the specified
feature, or abort if it does not.</p>

<p>option Specify any of the options listed under OPTIONS
that do not change stream semantic to suit the frontends
needs. This command is optional and is not needed to perform
an import.</p>

<p>commit Create or update a branch with a new commit,
recording one logical change to the project.</p>

<p>&acute;commit&acute; SP &lt;ref&gt; LF mark?
(&acute;author&acute; (SP &lt;name&gt;)? SP LT &lt;email&gt;
GT SP &lt;when&gt; LF)? &acute;committer&acute; (SP
&lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
data (&acute;from&acute; SP &lt;committish&gt; LF)?
(&acute;merge&acute; SP &lt;committish&gt; LF)? (filemodify
| filedelete | filecopy | filerename | filedeleteall |
notemodify)* LF?</p>

<p>where &lt;ref&gt; is the name of the branch to make the
commit on. Typically branch names are prefixed with
refs/heads/ in Git, so importing the CVS branch symbol
RELENG-1_0 would use refs/heads/RELENG-1_0 for the value of
&lt;ref&gt;. The value of &lt;ref&gt; must be a valid
refname in Git. As LF is not valid in a Git refname, no
quoting or escaping syntax is supported here.</p>

<p>A mark command may optionally appear, requesting
fast-import to save a reference to the newly created commit
for future use by the frontend (see below for format). It is
very common for frontends to mark every commit they create,
thereby allowing future branch creation from any imported
commit.</p>

<p>The data command following committer must supply the
commit message (see below for data command syntax). To
import an empty commit message use a 0 length data. Commit
messages are free-form and are not interpreted by Git.
Currently they must be encoded in UTF-8, as fast-import does
not permit other encodings to be specified.</p>

<p>Zero or more filemodify, filedelete, filecopy,
filerename, filedeleteall and notemodify commands may be
included to update the contents of the branch prior to
creating the commit. These commands may be supplied in any
order. However it is recommended that a filedeleteall
command precede all filemodify, filecopy, filerename and
notemodify commands in the same commit, as filedeleteall
wipes the branch clean (see below).</p>

<p>The LF after the command is optional (it used to be
required).</p>

<p>author An author command may optionally appear, if the
author information might differ from the committer
information. If author is omitted then fast-import will
automatically use the committers information for the author
portion of the commit. See below for a description of the
fields in author, as they are identical to committer.</p>

<p>committer The committer command indicates who made this
commit, and when they made it.</p>

<p>Here &lt;name&gt; is the persons display name (for
example Com M Itter) and &lt;email&gt; is the persons email
address ( cm@example.com[1] ). LT and GT are the literal
less-than (c) and greater-than (e) symbols. These are
required to delimit the email address from the other fields
in the line. Note that &lt;name&gt; is free-form and may
contain any sequence of bytes, except LT and LF. It is
typically UTF-8 encoded.</p>

<p>The time of the change is specified by &lt;when&gt;
using the date format that was selected by the
--date-format=&lt;fmt&gt; command line option. See Date
Formats above for the set of supported formats, and their
syntax.</p>

<p>from The from command is used to specify the commit to
initialize this branch from. This revision will be the first
ancestor of the new commit.</p>

<p>Omitting the from command in the first commit of a new
branch will cause fast-import to create that commit with no
ancestor. This tends to be desired only for the initial
commit of a project. If the frontend creates all files from
scratch when making a new branch, a merge command may be
used instead of from to start the commit with an empty tree.
Omitting the from command on existing branches is usually
desired, as the current commit on that branch is
automatically assumed to be the first ancestor of the new
commit.</p>

<p>As LF is not valid in a Git refname or SHA-1 expression,
no quoting or escaping syntax is supported within
&lt;committish&gt;.</p>

<p>Here &lt;committish&gt; is any of the following:</p>

<p>&middot; The name of an existing branch already in
fast-imports internal branch table. If fast-import doesnt
know the name, its treated as a SHA-1 expression.</p>

<p>&middot; A mark reference, :&lt;idnum&gt;, where
&lt;idnum&gt; is the mark number.</p>

<p>The reason fast-import uses : to denote a mark reference
is this character is not legal in a Git branch name. The
leading : makes it easy to distinguish between the mark 42
(:42) and the branch 42 (42 or refs/heads/42), or an
abbreviated SHA-1 which happened to consist only of base-10
digits.</p>

<p>Marks must be declared (via mark) before they can be
used.</p>

<p>&middot; A complete 40 byte or abbreviated commit SHA-1
in hex.</p>

<p>&middot; Any valid Git SHA-1 expression that resolves to
a commit. See SPECIFYING REVISIONS in git-rev-parse(1) for
details.</p>

<p>The special case of restarting an incremental import
from the current branch value should be written as:</p>

<p>from refs/heads/branch^0</p>

<p>The ^0 suffix is necessary as fast-import does not
permit a branch to start from itself, and the branch is
created in memory before the from command is even read from
the input. Adding ^0 will force fast-import to resolve the
commit through Git s revision parsing library, rather than
its internal branch table, thereby loading in the existing
value of the branch.</p>

<p>merge Includes one additional ancestor commit. If the
from command is omitted when creating a new branch, the
first merge commit will be the first ancestor of the current
commit, and the branch will start out with no files. An
unlimited number of merge commands per commit are permitted
by fast-import, thereby establishing an n-way merge. However
Gits other tools never create commits with more than 15
additional ancestors (forming a 16-way merge). For this
reason it is suggested that frontends do not use more than
15 merge commands per commit; 16, if starting a new, empty
branch.</p>

<p>Here &lt;committish&gt; is any of the commit
specification expressions also accepted by from (see
above).</p>

<p>filemodify Included in a commit command to add a new
file or change the content of an existing file. This command
has two different means of specifying the content of the
file.</p>

<p>External data format The data content for the file was
already supplied by a prior blob command. The frontend just
needs to connect it.</p>

<p>&acute;M&acute; SP &lt;mode&gt; SP &lt;dataref&gt; SP
&lt;path&gt; LF</p>

<p>Here &lt;dataref&gt; can be either a mark reference
(:&lt;idnum&gt;) set by a prior blob command, or a full
40-byte SHA-1 of an existing Git blob object.</p>

<p>Inline data format The data content for the file has not
been supplied yet. The frontend wants to supply it as part
of this modify command.</p>

<p>&acute;M&acute; SP &lt;mode&gt; SP &acute;inline&acute;
SP &lt;path&gt; LF data</p>

<p>See below for a detailed description of the data
command.</p>

<p>In both formats &lt;mode&gt; is the type of file entry,
specified in octal. Git only supports the following
modes:</p>

<p>&middot; 100644 or 644: A normal (not-executable) file.
The majority of files in most projects use this mode. If in
doubt, this is what you want.</p>

<p>&middot; 100755 or 755: A normal, but executable,
file.</p>

<p>&middot; 120000: A symlink, the content of the file will
be the link target.</p>

<p>&middot; 160000: A gitlink, SHA-1 of the object refers
to a commit in another repository. Git links can only be
specified by SHA or through a commit mark. They are used to
implement submodules.</p>

<p>In both formats &lt;path&gt; is the complete path of the
file to be added (if not already existing) or modified (if
already existing).</p>

<p>A &lt;path&gt; string must use UNIX-style directory
separators (forward slash /), may contain any byte other
than LF, and must not start with double quote (&quot;).</p>

<p>If an LF or double quote must be encoded into
&lt;path&gt; shell-style quoting should be used, e.g.
&quot;path/withand</p>

<p>The value of &lt;path&gt; must be in canonical form.
That is it must not:</p>

<p>&middot; contain an empty directory component (e.g.
foo//bar is invalid),</p>

<p>&middot; end with a directory separator (e.g. foo/ is
invalid),</p>

<p>&middot; start with a directory separator (e.g. /foo is
invalid),</p>

<p>&middot; contain the special component . or .. (e.g.
foo/./bar and foo/../bar are invalid).</p>

<p>It is recommended that &lt;path&gt; always be encoded
using UTF-8.</p>

<p>filedelete Included in a commit command to remove a file
or recursively delete an entire directory from the branch.
If the file or directory removal makes its parent directory
empty, the parent directory will be automatically removed
too. This cascades up the tree until the first non-empty
directory or the root is reached.</p>

<p>&acute;D&acute; SP &lt;path&gt; LF</p>

<p>here &lt;path&gt; is the complete path of the file or
subdirectory to be removed from the branch. See filemodify
above for a detailed description of &lt;path&gt;.</p>

<p>filecopy Recursively copies an existing file or
subdirectory to a different location within the branch. The
existing file or directory must exist. If the destination
exists it will be completely replaced by the content copied
from the source.</p>

<p>&acute;C&acute; SP &lt;path&gt; SP &lt;path&gt; LF</p>

<p>here the first &lt;path&gt; is the source location and
the second &lt;path&gt; is the destination. See filemodify
above for a detailed description of what &lt;path&gt; may
look like. To use a source path that contains SP the path
must be quoted.</p>

<p>A filecopy command takes effect immediately. Once the
source location has been copied to the destination any
future commands applied to the source location will not
impact the destination of the copy.</p>

<p>filerename Renames an existing file or subdirectory to a
different location within the branch. The existing file or
directory must exist. If the destination exists it will be
replaced by the source directory.</p>

<p>&acute;R&acute; SP &lt;path&gt; SP &lt;path&gt; LF</p>

<p>here the first &lt;path&gt; is the source location and
the second &lt;path&gt; is the destination. See filemodify
above for a detailed description of what &lt;path&gt; may
look like. To use a source path that contains SP the path
must be quoted.</p>

<p>A filerename command takes effect immediately. Once the
source location has been renamed to the destination any
future commands applied to the source location will create
new files there and not impact the destination of the
rename.</p>

<p>Note that a filerename is the same as a filecopy
followed by a filedelete of the source location. There is a
slight performance advantage to using filerename, but the
advantage is so small that it is never worth trying to
convert a delete/add pair in source material into a rename
for fast-import. This filerename command is provided just to
simplify frontends that already have rename information and
dont want bother with decomposing it into a filecopy
followed by a filedelete.</p>

<p>filedeleteall Included in a commit command to remove all
files (and also all directories) from the branch. This
command resets the internal branch structure to have no
files in it, allowing the frontend to subsequently add all
interesting files from scratch.</p>

<p>&acute;deleteall&acute; LF</p>

<p>This command is extremely useful if the frontend does
not know (or does not care to know) what files are currently
on the branch, and therefore cannot generate the proper
filedelete commands to update the content.</p>

<p>Issuing a filedeleteall followed by the needed
filemodify commands to set the correct content will produce
the same results as sending only the needed filemodify and
filedelete commands. The filedeleteall approach may however
require fast-import to use slightly more memory per active
branch (less than 1 MiB for even most large projects); so
frontends that can easily obtain only the affected paths for
a commit are encouraged to do so.</p>

<p>notemodify Included in a commit command to add a new
note (annotating a given commit) or change the content of an
existing note. This command has two different means of
specifying the content of the note.</p>

<p>External data format The data content for the note was
already supplied by a prior blob command. The frontend just
needs to connect it to the commit that is to be
annotated.</p>

<p>&acute;N&acute; SP &lt;dataref&gt; SP &lt;committish&gt;
LF</p>

<p>Here &lt;dataref&gt; can be either a mark reference
(:&lt;idnum&gt;) set by a prior blob command, or a full
40-byte SHA-1 of an existing Git blob object.</p>

<p>Inline data format The data content for the note has not
been supplied yet. The frontend wants to supply it as part
of this modify command.</p>

<p>&acute;N&acute; SP &acute;inline&acute; SP
&lt;committish&gt; LF data</p>

<p>See below for a detailed description of the data
command.</p>

<p>In both formats &lt;committish&gt; is any of the commit
specification expressions also accepted by from (see
above).</p>

<p>mark Arranges for fast-import to save a reference to the
current object, allowing the frontend to recall this object
at a future point in time, without knowing its SHA-1. Here
the current object is the object creation command the mark
command appears within. This can be commit, tag, and blob,
but commit is the most common usage.</p>

<p>&acute;mark&acute; SP &acute;:&acute; &lt;idnum&gt;
LF</p>

<p>where &lt;idnum&gt; is the number assigned by the
frontend to this mark. The value of &lt;idnum&gt; is
expressed as an ASCII decimal integer. The value 0 is
reserved and cannot be used as a mark. Only values greater
than or equal to 1 may be used as marks.</p>

<p>New marks are created automatically. Existing marks can
be moved to another object simply by reusing the same
&lt;idnum&gt; in another mark command.</p>

<p>tag Creates an annotated tag referring to a specific
commit. To create lightweight (non-annotated) tags see the
reset command below.</p>

<p>&acute;tag&acute; SP &lt;name&gt; LF &acute;from&acute;
SP &lt;committish&gt; LF &acute;tagger&acute; (SP
&lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
data</p>

<p>where &lt;name&gt; is the name of the tag to create.</p>

<p>Tag names are automatically prefixed with refs/tags/
when stored in Git, so importing the CVS branch symbol
RELENG-1_0-FINAL would use just RELENG-1_0-FINAL for
&lt;name&gt;, and fast-import will write the corresponding
ref as refs/tags/RELENG-1_0-FINAL.</p>

<p>The value of &lt;name&gt; must be a valid refname in Git
and therefore may contain forward slashes. As LF is not
valid in a Git refname, no quoting or escaping syntax is
supported here.</p>

<p>The from command is the same as in the commit command;
see above for details.</p>

<p>The tagger command uses the same format as committer
within commit; again see above for details.</p>

<p>The data command following tagger must supply the
annotated tag message (see below for data command syntax).
To import an empty tag message use a 0 length data. Tag
messages are free-form and are not interpreted by Git.
Currently they must be encoded in UTF-8, as fast-import does
not permit other encodings to be specified.</p>

<p>Signing annotated tags during import from within
fast-import is not supported. Trying to include your own
PGP/GPG signature is not recommended, as the frontend does
not (easily) have access to the complete set of bytes which
normally goes into such a signature. If signing is required,
create lightweight tags from within fast-import with reset,
then create the annotated versions of those tags offline
with the standard git tag process.</p>

<p>reset Creates (or recreates) the named branch,
optionally starting from a specific revision. The reset
command allows a frontend to issue a new from command for an
existing branch, or to create a new branch from an existing
commit without creating a new commit.</p>

<p>&acute;reset&acute; SP &lt;ref&gt; LF
(&acute;from&acute; SP &lt;committish&gt; LF)? LF?</p>

<p>For a detailed description of &lt;ref&gt; and
&lt;committish&gt; see above under commit and from.</p>

<p>The LF after the command is optional (it used to be
required).</p>

<p>The reset command can also be used to create lightweight
(non-annotated) tags. For example:</p>

<p>reset refs/tags/938 from :938</p>

<p>would create the lightweight tag refs/tags/938 referring
to whatever commit mark :938 references.</p>

<p>blob Requests writing one file revision to the packfile.
The revision is not connected to any commit; this connection
must be formed in a subsequent commit command by referencing
the blob through an assigned mark.</p>

<p>&acute;blob&acute; LF mark? data</p>

<p>The mark command is optional here as some frontends have
chosen to generate the Git SHA-1 for the blob on their own,
and feed that directly to commit. This is typically more
work than its worth however, as marks are inexpensive to
store and easy to use.</p>

<p>data Supplies raw data (for use as blob/file content,
commit messages, or annotated tag messages) to fast-import.
Data can be supplied using an exact byte count or delimited
with a terminating line. Real frontends intended for
production-quality conversions should always use the exact
byte count format, as it is more robust and performs better.
The delimited format is intended primarily for testing
fast-import.</p>

<p>Comment lines appearing within the &lt;raw&gt; part of
data commands are always taken to be part of the body of the
data and are therefore never ignored by fast-import. This
makes it safe to import any file/message content whose lines
might start with #.</p>

<p>Exact byte count format The frontend must specify the
number of bytes of data.</p>

<p>&acute;data&acute; SP &lt;count&gt; LF &lt;raw&gt;
LF?</p>

<p>where &lt;count&gt; is the exact number of bytes
appearing within &lt;raw&gt;. The value of &lt;count&gt; is
expressed as an ASCII decimal integer. The LF on either side
of &lt;raw&gt; is not included in &lt;count&gt; and will not
be included in the imported data.</p>

<p>The LF after &lt;raw&gt; is optional (it used to be
required) but recommended. Always including it makes
debugging a fast-import stream easier as the next command
always starts in column 0 of the next line, even if
&lt;raw&gt; did not end with an LF.</p>

<p>Delimited format A delimiter string is used to mark the
end of the data. fast-import will compute the length by
searching for the delimiter. This format is primarily useful
for testing and is not recommended for real data.</p>

<p>&acute;data&acute; SP &acute;&lt;&lt;&acute;
&lt;delim&gt; LF &lt;raw&gt; LF &lt;delim&gt; LF LF?</p>

<p>where &lt;delim&gt; is the chosen delimiter string. The
string &lt;delim&gt; must not appear on a line by itself
within &lt;raw&gt;, as otherwise fast-import will think the
data ends earlier than it really does. The LF immediately
trailing &lt;raw&gt; is part of &lt;raw&gt;. This is one of
the limitations of the delimited format, it is impossible to
supply a data chunk which does not have an LF as its last
byte.</p>

<p>The LF after &lt;delim&gt; LF is optional (it used to be
required).</p>

<p>checkpoint Forces fast-import to close the current
packfile, start a new one, and to save out all current
branch refs, tags and marks.</p>

<p>&acute;checkpoint&acute; LF LF?</p>

<p>Note that fast-import automatically switches packfiles
when the current packfile reaches --max-pack-size, or 4 GiB,
whichever limit is smaller. During an automatic packfile
switch fast-import does not update the branch refs, tags or
marks.</p>

<p>As a checkpoint can require a significant amount of CPU
time and disk IO (to compute the overall pack SHA-1
checksum, generate the corresponding index file, and update
the refs) it can easily take several minutes for a single
checkpoint command to complete.</p>

<p>Frontends may choose to issue checkpoints during
extremely large and long running imports, or when they need
to allow another Git process access to a branch. However
given that a 30 GiB Subversion repository can be loaded into
Git through fast-import in about 3 hours, explicit
checkpointing may not be necessary.</p>

<p>The LF after the command is optional (it used to be
required).</p>

<p>progress Causes fast-import to print the entire progress
line unmodified to its standard output channel (file
descriptor 1) when the command is processed from the input
stream. The command otherwise has no impact on the current
import, or on any of fast-imports internal state.</p>

<p>&acute;progress&acute; SP &lt;any&gt; LF LF?</p>

<p>The &lt;any&gt; part of the command may contain any
sequence of bytes that does not contain LF. The LF after the
command is optional. Callers may wish to process the output
through a tool such as sed to remove the leading part of the
line, for example:</p>

<p>frontend | git fast-import | sed &acute;s/^progress
//&acute;</p>

<p>Placing a progress command immediately after a
checkpoint will inform the reader when the checkpoint has
been completed and it can safely access the refs that
fast-import updated.</p>

<p>feature Require that fast-import supports the specified
feature, or abort if it does not.</p>

<p>&acute;feature&acute; SP &lt;feature&gt; LF</p>

<p>The &lt;feature&gt; part of the command may be any
string matching ^[a-zA-Z][a-zA-Z-]*$ and should be
understood by fast-import.</p>

<p>Feature work identical as their option counterparts with
the exception of the import-marks feature, see below.</p>

<p>The following features are currently supported:</p>

<p>&middot; date-format</p>

<p>&middot; import-marks</p>

<p>&middot; export-marks</p>

<p>&middot; relative-marks</p>

<p>&middot; no-relative-marks</p>

<p>&middot; force</p>

<p>The import-marks behaves differently from when it is
specified as commandline option in that only one
&quot;feature import-marks&quot; is allowed per stream.
Also, any --import-marks= specified on the commandline will
override those from the stream (if any).</p>

<p>option Processes the specified option so that git
fast-import behaves in a way that suits the frontend s
needs. Note that options specified by the frontend are
overridden by any options the user may specify to git
fast-import itself.</p>

<p>&acute;option&acute; SP &lt;option&gt; LF</p>

<p>The &lt;option&gt; part of the command may contain any
of the options listed in the OPTIONS section that do not
change import semantics, without the leading -- and is
treated in the same way.</p>

<p>Option commands must be the first commands on the input
(not counting feature commands), to give an option command
after any non-option command is an error.</p>

<p>The following commandline options change import
semantics and may therefore not be passed as option:</p>

<p>&middot; date-format</p>

<p>&middot; import-marks</p>

<p>&middot; export-marks</p>

<p>&middot; force</p>

<p>CRASH REPORTS If fast-import is supplied invalid input
it will terminate with a non-zero exit status and create a
crash report in the top level of the Git repository it was
importing into. Crash reports contain a snapshot of the
internal fast-import state as well as the most recent
commands that lead up to the crash.</p>

<p>All recent commands (including stream comments, file
changes and progress commands) are shown in the command
history within the crash report, but raw file data and
commit messages are excluded from the crash report. This
exclusion saves space within the report file and reduces the
amount of buffering that fast-import must perform during
execution.</p>

<p>After writing a crash report fast-import will close the
current packfile and export the marks table. This allows the
frontend developer to inspect the repository state and
resume the import from the point where it crashed. The
modified branches and tags are not updated during a crash,
as the import did not complete successfully. Branch and tag
information can be found in the crash report and must be
applied manually if the update is needed.</p>

<p>An example crash:</p>

<p>$ cat &gt;in &lt;&lt;END_OF_INPUT # my very first test
commit commit refs/heads/master committer Shawn O. Pearce
&lt;spearce&gt; 19283 -0400 # who is that guy anyway? data
&lt;&lt;EOF this is my commit EOF M 644 inline .gitignore
data &lt;&lt;EOF .gitignore EOF M 777 inline bob
END_OF_INPUT</p>

<p>$ git fast-import &lt;in fatal: Corrupt mode: M 777
inline bob fast-import: dumping crash report to
.git/fast_import_crash_8434</p>

<p>$ cat .git/fast_import_crash_8434 fast-import crash
report: fast-import process: 8434 parent process : 1391 at
Sat Sep 1 00:58:12 2007</p>

<p>fatal: Corrupt mode: M 777 inline bob</p>

<p>Most Recent Commands Before Crash
--------------------------------- # my very first test
commit commit refs/heads/master committer Shawn O. Pearce
&lt;spearce&gt; 19283 -0400 # who is that guy anyway? data
&lt;&lt;EOF M 644 inline .gitignore data &lt;&lt;EOF * M 777
inline bob</p>

<p>Active Branch LRU ----------------- active_branches = 1
cur, 5 max</p>

<p>pos clock name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 1) 0
refs/heads/master</p>

<p>Inactive Branches ----------------- refs/heads/master:
status : active loaded dirty tip commit :
0000000000000000000000000000000000000000 old tree :
0000000000000000000000000000000000000000 cur tree :
0000000000000000000000000000000000000000 commit clock: 0
last pack :</p>

<p>------------------- END OF CRASH REPORT</p>

<p>TIPS AND TRICKS The following tips and tricks have been
collected from various users of fast-import, and are offered
here as suggestions.</p>

<p>Use One Mark Per Commit When doing a repository
conversion, use a unique mark per commit (mark :&lt;n&gt;)
and supply the --export-marks option on the command line.
fast-import will dump a file which lists every mark and the
Git object SHA-1 that corresponds to it. If the frontend can
tie the marks back to the source repository, it is easy to
verify the accuracy and completeness of the import by
comparing each Git commit to the corresponding source
revision.</p>

<p>Coming from a system such as Perforce or Subversion this
should be quite simple, as the fast-import mark can also be
the Perforce changeset number or the Subversion revision
number.</p>

<p>Freely Skip Around Branches Dont bother trying to
optimize the frontend to stick to one branch at a time
during an import. Although doing so might be slightly faster
for fast-import, it tends to increase the complexity of the
frontend code considerably.</p>

<p>The branch LRU builtin to fast-import tends to behave
very well, and the cost of activating an inactive branch is
so low that bouncing around between branches has virtually
no impact on import performance.</p>

<p>Handling Renames When importing a renamed file or
directory, simply delete the old name(s) and modify the new
name(s) during the corresponding commit. Git performs rename
detection after-the-fact, rather than explicitly during a
commit.</p>

<p>Use Tag Fixup Branches Some other SCM systems let the
user create a tag from multiple files which are not from the
same commit/changeset. Or to create tags which are a subset
of the files available in the repository.</p>

<p>Importing these tags as-is in Git is impossible without
making at least one commit which fixes up the files to match
the content of the tag. Use fast-import s reset command to
reset a dummy branch outside of your normal branch space to
the base commit for the tag, then commit one or more file
fixup commits, and finally tag the dummy branch.</p>

<p>For example since all normal branches are stored under
refs/heads/ name the tag fixup branch TAG_FIXUP. This way it
is impossible for the fixup branch used by the importer to
have namespace conflicts with real branches imported from
the source (the name TAG_FIXUP is not
refs/heads/TAG_FIXUP).</p>

<p>When committing fixups, consider using merge to connect
the commit(s) which are supplying file revisions to the
fixup branch. Doing so will allow tools such as git blame to
track through the real commit history and properly annotate
the source files.</p>

<p>After fast-import terminates the frontend will need to
do rm .git/TAG_FIXUP to remove the dummy branch.</p>

<p>Import Now, Repack Later As soon as fast-import
completes the Git repository is completely valid and ready
for use. Typically this takes only a very short time, even
for considerably large projects (100,000+ commits).</p>

<p>However repacking the repository is necessary to improve
data locality and access performance. It can also take hours
on extremely large projects (especially if -f and a large
--window parameter is used). Since repacking is safe to run
alongside readers and writers, run the repack in the
background and let it finish when it finishes. There is no
reason to wait to explore your new Git project!</p>

<p>If you choose to wait for the repack, dont try to run
benchmarks or performance tests until repacking is
completed. fast-import outputs suboptimal packfiles that are
simply never seen in real use situations.</p>

<p>Repacking Historical Data If you are repacking very old
imported data (e.g. older than the last year), consider
expending some extra CPU time and supplying --window=50 (or
higher) when you run git repack. This will take longer, but
will also produce a smaller packfile. You only need to
expend the effort once, and everyone using your project will
benefit from the smaller repository.</p>

<p>Include Some Progress Messages Every once in a while
have your frontend emit a progress message to fast-import.
The contents of the messages are entirely free-form, so one
suggestion would be to output the current month and year
each time the current commit date moves into the next month.
Your users will feel better knowing how much of the data
stream has been processed.</p>

<p>PACKFILE OPTIMIZATION When packing a blob fast-import
always attempts to deltify against the last blob written.
Unless specifically arranged for by the frontend, this will
probably not be a prior version of the same file, so the
generated delta will not be the smallest possible. The
resulting packfile will be compressed, but will not be
optimal.</p>

<p>Frontends which have efficient access to all revisions
of a single file (for example reading an RCS/CVS ,v file)
can choose to supply all revisions of that file as a
sequence of consecutive blob commands. This allows
fast-import to deltify the different file revisions against
each other, saving space in the final packfile. Marks can be
used to later identify individual file revisions during a
sequence of commit commands.</p>

<p>The packfile(s) created by fast-import do not encourage
good disk access patterns. This is caused by fast-import
writing the data in the order it is received on standard
input, while Git typically organizes data within packfiles
to make the most recent (current tip) data appear before
historical data. Git also clusters commits together,
speeding up revision traversal through better cache
locality.</p>

<p>For this reason it is strongly recommended that users
repack the repository with git repack -a -d after
fast-import completes, allowing Git to reorganize the
packfiles for faster data access. If blob deltas are
suboptimal (see above) then also adding the -f option to
force recomputation of all deltas can significantly reduce
the final packfile size (30-50% smaller can be quite
typical).</p>

<p>MEMORY UTILIZATION There are a number of factors which
affect how much memory fast-import requires to perform an
import. Like critical sections of core Git, fast-import uses
its own memory allocators to amortize any overheads
associated with malloc. In practice fast-import tends to
amortize any malloc overheads to 0, due to its use of large
block allocations.</p>

<p>per object fast-import maintains an in-memory structure
for every object written in this execution. On a 32 bit
system the structure is 32 bytes, on a 64 bit system the
structure is 40 bytes (due to the larger pointer sizes).
Objects in the table are not deallocated until fast-import
terminates. Importing 2 million objects on a 32 bit system
will require approximately 64 MiB of memory.</p>

<p>The object table is actually a hashtable keyed on the
object name (the unique SHA-1). This storage configuration
allows fast-import to reuse an existing or already written
object and avoid writing duplicates to the output packfile.
Duplicate blobs are surprisingly common in an import,
typically due to branch merges in the source.</p>

<p>per mark Marks are stored in a sparse array, using 1
pointer (4 bytes or 8 bytes, depending on pointer size) per
mark. Although the array is sparse, frontends are still
strongly encouraged to use marks between 1 and n, where n is
the total number of marks required for this import.</p>

<p>per branch Branches are classified as active and
inactive. The memory usage of the two classes is
significantly different.</p>

<p>Inactive branches are stored in a structure which uses
96 or 120 bytes (32 bit or 64 bit systems, respectively),
plus the length of the branch name (typically under 200
bytes), per branch. fast-import will easily handle as many
as 10,000 inactive branches in under 2 MiB of memory.</p>

<p>Active branches have the same overhead as inactive
branches, but also contain copies of every tree that has
been recently modified on that branch. If subtree include
has not been modified since the branch became active, its
contents will not be loaded into memory, but if subtree src
has been modified by a commit since the branch became
active, then its contents will be loaded in memory.</p>

<p>As active branches store metadata about the files
contained on that branch, their in-memory storage size can
grow to a considerable size (see below).</p>

<p>fast-import automatically moves active branches to
inactive status based on a simple least-recently-used
algorithm. The LRU chain is updated on each commit command.
The maximum number of active branches can be increased or
decreased on the command line with --active-branches=.</p>

<p>per active tree Trees (aka directories) use just 12
bytes of memory on top of the memory required for their
entries (see per active file below). The cost of a tree is
virtually 0, as its overhead amortizes out over the
individual file entries.</p>

<p>per active file entry Files (and pointers to subtrees)
within active trees require 52 or 64 bytes (32/64 bit
platforms) per entry. To conserve space, file and tree names
are pooled in a common string table, allowing the filename
Makefile to use just 16 bytes (after including the string
header overhead) no matter how many times it occurs within
the project.</p>

<p>The active branch LRU, when coupled with the filename
string pool and lazy loading of subtrees, allows fast-import
to efficiently import projects with 2,000+ branches and
45,114+ files in a very limited memory footprint (less than
2.7 MiB per active branch).</p>

<p>AUTHOR Written by Shawn O. Pearce
&lt;spearce@spearce.org[2]&gt;.</p>

<p>DOCUMENTATION Documentation by Shawn O. Pearce
&lt;spearce@spearce.org[2]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. cm@example.com mailto:cm@example.com</p>

<p>2. spearce@spearce.org mailto:spearce@spearce.org</p>

<p>Git 1.7.1 07/27/2010 GIT-FAST-IMPORT(1)</p>
<hr>
</body>
</html>
