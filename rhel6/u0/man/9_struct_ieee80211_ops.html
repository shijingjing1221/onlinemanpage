<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:18:02 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT IEEE80211_OPS(9) The basic mac80211 driver inte
STRUCT IEEE80211_OPS(9)</p>

<p>NAME struct_ieee80211_ops - callbacks from mac80211 to
the driver</p>

<p>SYNOPSIS struct ieee80211_ops { int (* tx) (struct
ieee80211_hw *hw, struct sk_buff *skb); int (* start)
(struct ieee80211_hw *hw); void (* stop) (struct
ieee80211_hw *hw); int (* add_interface) (struct
ieee80211_hw *hw,struct ieee80211_if_init_conf *conf); void
(* remove_interface) (struct ieee80211_hw *hw,struct
ieee80211_if_init_conf *conf); int (* config) (struct
ieee80211_hw *hw, u32 changed); void (* bss_info_changed)
(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct
ieee80211_bss_conf *info,u32 changed); u64 (*
prepare_multicast) (struct ieee80211_hw *hw,int mc_count,
struct dev_addr_list *mc_list); void (* configure_filter)
(struct ieee80211_hw *hw,unsigned int changed_flags,unsigned
int *total_flags,u64 multicast); int (* set_tim) (struct
ieee80211_hw *hw, struct ieee80211_sta *sta,bool set); int
(* set_key) (struct ieee80211_hw *hw, enum set_key_cmd
cmd,struct ieee80211_vif *vif, struct ieee80211_sta
*sta,struct ieee80211_key_conf *key); void (*
update_tkip_key) (struct ieee80211_hw *hw,struct
ieee80211_key_conf *conf, const u8 *address,u32 iv32, u16
*phase1key); int (* hw_scan) (struct ieee80211_hw *hw,struct
cfg80211_scan_request *req); void (* sw_scan_start) (struct
ieee80211_hw *hw); void (* sw_scan_complete) (struct
ieee80211_hw *hw); int (* get_stats) (struct ieee80211_hw
*hw,struct ieee80211_low_level_stats *stats); void (*
get_tkip_seq) (struct ieee80211_hw *hw, u8 hw_key_idx,u32
*iv32, u16 *iv16); int (* set_rts_threshold) (struct
ieee80211_hw *hw, u32 value); void (* sta_notify) (struct
ieee80211_hw *hw, struct ieee80211_vif *vif,enum
sta_notify_cmd, struct ieee80211_sta *sta); int (* conf_tx)
(struct ieee80211_hw *hw, u16 queue,const struct
ieee80211_tx_queue_params *params); int (* get_tx_stats)
(struct ieee80211_hw *hw,struct ieee80211_tx_queue_stats
*stats); u64 (* get_tsf) (struct ieee80211_hw *hw); void (*
set_tsf) (struct ieee80211_hw *hw, u64 tsf); void (*
reset_tsf) (struct ieee80211_hw *hw); int (* tx_last_beacon)
(struct ieee80211_hw *hw); int (* ampdu_action) (struct
ieee80211_hw *hw,enum ieee80211_ampdu_mlme_action
action,struct ieee80211_sta *sta, u16 tid, u16 *ssn); void
(* rfkill_poll) (struct ieee80211_hw *hw); #ifdef
CONFIG_NL80211_TESTMODE int (* testmode_cmd) (struct
ieee80211_hw *hw, void *data, int len); #endif };</p>

<p>MEMBERS tx Handler that 802.11 module calls for each
transmitted frame. skb contains the buffer starting from the
IEEE 802.11 header. The low-level driver should send the
frame out based on configuration in the TX control data.
This handler should, preferably, never fail and stop queues
appropriately, more importantly, however, it must never fail
for A-MPDU-queues. This function should return NETDEV_TX_OK
except in very limited cases. Must be implemented and
atomic.</p>

<p>start Called before the first netdevice attached to the
hardware is enabled. This should turn on the hardware and
must turn on frame reception (for possibly enabled monitor
interfaces.) Returns negative error codes, these may be seen
in userspace, or zero. When the device is started it should
not have a MAC address to avoid acknowledging frames before
a non-monitor device is added. Must be implemented.</p>

<p>stop Called after last netdevice attached to the
hardware is disabled. This should turn off the hardware (at
least it must turn off frame reception.) May be called right
after add_interface if that rejects an interface. If you
added any work onto the mac80211 workqueue you should ensure
to cancel it on this callback. Must be implemented.</p>

<p>add_interface Called when a netdevice attached to the
hardware is enabled. Because it is not called for monitor
mode devices, start and stop must be implemented. The driver
should perform any initialization it needs before the device
can be enabled. The initial configuration for the interface
is given in the conf parameter. The callback may refuse to
add an interface by returning a negative error code (which
will be seen in userspace.) Must be implemented.</p>

<p>remove_interface Notifies a driver that an interface is
going down. The stop callback is called after this if it is
the last interface and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the
hardware must be cleared so the device no longer
acknowledges packets, the mac_addr member of the conf
structure is, however, set to the MAC address of the device
going away. Hence, this callback must be implemented.</p>

<p>config Handler for configuration requests. IEEE 802.11
code calls this function to change hardware configuration,
e.g., channel. This function should never fail but returns a
negative error code if it does.</p>

<p>bss_info_changed Handler for configuration requests
related to BSS parameters that may vary during BSS&acute;s
lifespan, and may affect low level driver (e.g.
assoc/disassoc status, erp parameters). This function should
not be used if no BSS has been set, unless for association
indication. The changed parameter indicates which of the bss
parameters has changed when a call is made.</p>

<p>prepare_multicast Prepare for multicast filter
configuration. This callback is optional, and its return
value is passed to configure_filter. This callback must be
atomic.</p>

<p>configure_filter Configure the device&acute;s RX filter.
See the section Frame filtering for more information. This
callback must be implemented.</p>

<p>set_tim Set TIM bit. mac80211 calls this function when a
TIM bit must be set or cleared for a given STA. Must be
atomic.</p>

<p>set_key See the section Hardware crypto acceleration
This callback can sleep, and is only called between
add_interface and remove_interface calls, i.e. while the
given virtual interface is enabled. Returns a negative error
code if the key can&acute;t be added.</p>

<p>update_tkip_key See the section Hardware crypto
acceleration This callback will be called in the context of
Rx. Called for drivers which set
IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.</p>

<p>hw_scan Ask the hardware to service the scan request, no
need to start the scan state machine in stack. The scan must
honour the channel configuration done by the regulatory
agent in the wiphy&acute;s registered bands. The hardware
(or the driver) needs to make sure that power save is
disabled. The req ie/ie_len members are rewritten by
mac80211 to contain the entire IEs after the SSID, so that
drivers need not look at these at all but just send them
after the SSID -- mac80211 includes the (extended) supported
rates and HT information (where applicable). When the scan
finishes, ieee80211_scan_completed must be called; note that
it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error
code.</p>

<p>sw_scan_start Notifier function that is called just
before a software scan is started. Can be NULL, if the
driver doesn&acute;t need this notification.</p>

<p>sw_scan_complete Notifier function that is called just
after a software scan finished. Can be NULL, if the driver
doesn&acute;t need this notification.</p>

<p>get_stats Return low-level statistics. Returns zero if
statistics are available.</p>

<p>get_tkip_seq If your device implements TKIP encryption
in hardware this callback should be provided to read the
TKIP transmit IVs (both IV32 and IV16) for the given key
from hardware.</p>

<p>set_rts_threshold Configuration of RTS threshold (if
device needs it)</p>

<p>sta_notify Notifies low level driver about addition,
removal or power state transition of an associated station,
AP, IBSS/WDS/mesh peer etc. Must be atomic.</p>

<p>conf_tx Configure TX queue parameters (EDCF (aifs,
cw_min, cw_max), bursting) for a hardware TX queue. Returns
a negative error code on failure.</p>

<p>get_tx_stats Get statistics of the current TX queue
status. This is used to get number of currently queued
packets (queue length), maximum queue size (limit), and
total number of packets sent using each TX queue (count).
The &acute;stats&acute; pointer points to an array that has
hw-&gt;queues items.</p>

<p>get_tsf Get the current TSF timer value from
firmware/hardware. Currently, this is only used for IBSS
mode BSSID merging and debugging. Is not a required
function.</p>

<p>set_tsf Set the TSF timer to the specified value in the
firmware/hardware. Currently, this is only used for IBSS
mode debugging. Is not a required function.</p>

<p>reset_tsf Reset the TSF timer and allow
firmware/hardware to synchronize with other STAs in the
IBSS. This is only used in IBSS mode. This function is
optional if the firmware/hardware takes full care of TSF
synchronization.</p>

<p>tx_last_beacon Determine whether the last IBSS beacon
was sent by us. This is needed only for IBSS mode and the
result of this function is used to determine whether to
reply to Probe Requests. Returns non-zero if this device
sent the last beacon.</p>

<p>ampdu_action Perform a certain A-MPDU action The RA/TID
combination determines the destination and TID we want the
ampdu action to be performed for. The action is defined
through ieee80211_ampdu_mlme_action. Starting sequence
number (ssn) is the first frame we expect to perform the
action on. Notice that TX/RX_STOP can pass NULL for this
parameter. Returns a negative error code on failure.</p>

<p>rfkill_poll Poll rfkill hardware state. If you need
this, you also need to set wiphy-&gt;rfkill_poll to true
before registration, and need to call
wiphy_rfkill_set_hw_state in the callback.</p>

<p>testmode_cmd Implement a cfg80211 test mode command.</p>

<p>DESCRIPTION This structure contains various callbacks
that the driver may handle or, in some cases, must handle,
for example to configure the hardware to a new channel or to
transmit a frame.</p>

<p>AUTHOR Johannes Berg &lt;johannes@sipsolutions.net&gt;
Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. September 2010
STRUCT IEEE80211_OPS(9)</p>
<hr>
</body>
</html>
