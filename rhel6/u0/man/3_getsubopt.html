<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:01:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GETSUBOPT(3) Linux Programmer s Manual GETSUBOPT(3)</p>

<p>NAME getsubopt - parse suboption arguments from a
string</p>

<p>SYNOPSIS #define _XOPEN_SOURCE 500 #include
&lt;stdlib.h&gt;</p>

<p>int getsubopt(char **optionp, char * const *tokens, char
**valuep);</p>

<p>DESCRIPTION getsubopt() parses the list of
comma-separated suboptions provided in optionp. (Such a
suboption list is typically produced when getopt(3) is used
to parse a command line; see for example the -o option of
mount(8).) Each suboption may include an associated value,
which is separated from the suboption name by an equal sign.
The following is an example of the kind of string that might
be passed in optionp:</p>

<p>ro,name=xyz</p>

<p>The tokens argument is a pointer to a NULL-terminated
list of the tokens that getsubopt() will look for in
optionp. The tokens should be distinct, null-terminated
strings containing at least one character, with no embedded
equal signs or commas.</p>

<p>Each call to getsubopt() returns information about the
next unprocessed suboption in optionp. The first equal sign
in a suboption (if any) is interpreted as a separator
between the name and the value of that sub- option. The
value extends to the next comma, or (for the last subop-
tion) to the end of the string. If the name of the suboption
matches a known name from tokens, and a value string was
found, getsubopt() sets *valuep to the address of that
string. The first comma in optionp is overwritten with a
null byte, so *valuep is precisely the &quot;value
string&quot; for that suboption.</p>

<p>If the suboption is recognized, but no value string was
found, *valuep is set to NULL.</p>

<p>When getsubopt() returns, optionp points to the next
suboption, or to the null character at the end of the string
if the last suboption was just processed.</p>

<p>RETURN VALUE If the first suboption in optionp is
recognized, getsubopt() returns the index of the matching
suboption element in tokens. Otherwise, -1 is returned and
*valuep is the entire name[=value] string.</p>

<p>Since *optionp is changed, the first suboption before
the call to get- subopt() is not (necessarily) the same as
the first suboption after getsubopt().</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES Since getsubopt() overwrites any commas it finds
in the string *optionp, that string must be writable; it
cannot be a string constant.</p>

<p>EXAMPLE The following program expects suboptions
following a &quot;-o&quot; option.</p>

<p>#define _XOPEN_SOURCE 500 #include &lt;stdlib.h&gt;
#include &lt;assert.h&gt; #include &lt;stdio.h&gt;</p>

<p>int main(int argc, char **argv) { enum { RO_OPT = 0,
RW_OPT, NAME_OPT }; char *const token[] = { [RO_OPT] =
&quot;ro&quot;, [RW_OPT] = &quot;rw&quot;, [NAME_OPT] =
&quot;name&quot;, NULL }; char *subopts; char *value; int
opt;</p>

<p>int readonly = 0; int readwrite = 0; char *name = NULL;
int errfnd = 0;</p>

<p>while ((opt = getopt(argc, argv, &quot;o:&quot;)) != -1)
{ switch (opt) { case &rsquo;o&rsquo;: subopts = optarg;
while (*subopts != &rsquo; &rsquo; &amp;&amp; !errfnd) {</p>

<p>switch (getsubopt(&amp;subopts, token, &amp;value)) {
case RO_OPT: readonly = 1; break;</p>

<p>case RW_OPT: readwrite = 1; break;</p>

<p>case NAME_OPT: if (value == NULL) { fprintf(stderr,
&quot;Missing value for &quot; &quot;suboption
&rsquo;%s&rsquo;0, token[NAME_OPT]); errfnd = 1; continue;
}</p>

<p>name = value; break;</p>

<p>default: fprintf(stderr, &quot;No match found &quot;
&quot;for token: /%s/0, value); errfnd = 1; break; } } if
(readwrite &amp;&amp; readonly) { fprintf(stderr, &quot;Only
one of &rsquo;%s&rsquo; and &rsquo;%s&rsquo; can be &quot;
&quot;specified0, token[RO_OPT], token[RW_OPT]); errfnd = 1;
} break;</p>

<p>default: errfnd = 1; } }</p>

<p>if (errfnd || argc == 1) { fprintf(stderr, &quot;0sage:
%s -o &lt;suboptstring&gt;0, argv[0]); fprintf(stderr,
&quot;suboptions are &rsquo;ro&rsquo;, &rsquo;rw&rsquo;,
&quot; &quot;and &rsquo;name=&lt;value&gt;&rsquo;0);
exit(EXIT_FAILURE); }</p>

<p>/* Remainder of program... */</p>

<p>exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO getopt(3), feature_test_macros(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>GNU 2008-05-29 GETSUBOPT(3)</p>
<hr>
</body>
</html>
