<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:12:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RAW(8) RAW(8)</p>

<p>NAME raw - bind a Linux raw character device</p>

<p>SYNOPSIS raw /dev/raw/raw&lt;N&gt; &lt;major&gt;
&lt;minor&gt;</p>

<p>raw /dev/raw/raw&lt;N&gt; /dev/&lt;blockdev&gt;</p>

<p>raw -q /dev/raw/raw&lt;N&gt;</p>

<p>raw -qa</p>

<p>DESCRIPTION raw is used to bind a Linux raw character
device to a block device. Any block device may be used: at
the time of binding, the device driver does not even have to
be accessible (it may be loaded on demand as a kernel module
later).</p>

<p>raw is used in two modes: it either sets raw device
bindings, or it queries existing bindings. When setting a
raw device, /dev/raw/raw&lt;N&gt; is the device name of an
existing raw device node in the filesystem. The block device
to which it is to be bound can be specified either in terms
of its major and minor device numbers, or as a path name
/dev/&lt;blockdev&gt; to an existing block device file.</p>

<p>The bindings already in existence can be queried with
the -q option, with is used either with a raw device
filename to query that one device, or with the -a option to
query all bound raw devices.</p>

<p>Unbinding can be done by specifying major and minor
0.</p>

<p>Once bound to a block device, a raw device can be
opened, read and written, just like the block device it is
bound to. However, the raw device does not behave exactly
like the block device. In particular, access to the raw
device bypasses the kernel s block buffer cache entirely:
all I/O is done directly to and from the address space of
the process performing the I/O. If the underlying block
device driver can support DMA, then no data copying at all
is required to complete the I/O.</p>

<p>Because raw I/O involves direct hardware access to a
processs memory, a few extra restrictions must be observed.
All I/Os must be correctly aligned in memory and on disk:
they must start at a sector offset on disk, they must be an
exact number of sectors long, and the data buffer in virtual
memory must also be aligned to a multiple of the sector
size. The sector size is 512 bytes for most devices.</p>

<p>OPTIONS -q Set query mode. raw will query an existing
binding instead of setting a new one.</p>

<p>-a With -q , specifies that all bound raw devices should
be queried.</p>

<p>-h provides a usage summary.</p>

<p>BUGS The Linux dd (1) command should be used without bs=
option or the blocksize needs to be a multiple of the sector
size of the device (512 bytes usually) otherwise it will
fail with &quot;Invalid Argument&quot; messages
(EINVAL).</p>

<p>Raw I/O devices do not maintain cache coherency with the
Linux block device buffer cache. If you use raw I/O to
overwrite data already in the buffer cache, the buffer cache
will no longer correspond to the contents of the actual
storage device underneath. This is deliberate, but is
regarded either a bug or a feature depending on who you
ask!</p>

<p>AUTHOR Stephen Tweedie (sct@redhat.com)</p>

<p>AVAILABILITY The raw command is part of the
util-linux-ng package and is available from
ftp://ftp.kernel.org/pub/linux/utils/util-linux-ng/.</p>

<p>Version 0.1 Aug 1999 RAW(8)</p>
<hr>
</body>
</html>
