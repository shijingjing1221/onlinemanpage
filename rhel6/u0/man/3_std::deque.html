<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:17:15 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>std::deque(3) std::deque(3)</p>

<p>NAME std::deque -</p>

<p>A standard container using fixed-size memory allocation
and constant- time manipulation of elements at either
end.</p>

<p>SYNOPSIS Inherits std::_Deque_base&lt; _Tp, _Alloc
&gt;.</p>

<p>Public Types typedef _Alloc allocator_type typedef
_Base::const_iterator const_iterator typedef
_Tp_alloc_type::const_pointer const_pointer typedef
_Tp_alloc_type::const_reference const_reference typedef
std::reverse_iterator&lt; const_iterator &gt;
const_reverse_iterator typedef ptrdiff_t difference_type
typedef _Base::iterator iterator typedef
_Tp_alloc_type::pointer pointer typedef
_Tp_alloc_type::reference reference typedef
std::reverse_iterator&lt; iterator &gt; reverse_iterator
typedef size_t size_type typedef _Tp value_type</p>

<p>Public Member Functions void assign
(initializer_list&lt; value_type &gt; __l)
template&lt;typename _InputIterator &gt; void assign
(_InputIterator __first, _InputIterator __last) void assign
(size_type __n, const value_type &amp;__val) const_reference
at (size_type __n) const reference at (size_type __n)
const_reference back () const reference back ()
const_iterator begin () const iterator begin ()
const_iterator cbegin () const const_iterator cend () const
void clear () const_reverse_iterator crbegin () const
const_reverse_iterator crend () const template&lt;typename
_InputIterator &gt; deque (_InputIterator __first,
_InputIterator __last, const allocator_type
&amp;__a=allocator_type()) deque (initializer_list&lt;
value_type &gt; __l, const allocator_type
&amp;__a=allocator_type()) deque (deque &amp;&amp;__x) deque
(const deque &amp;__x) deque (size_type __n, const
value_type &amp;__value=value_type(), const allocator_type
&amp;__a=allocator_type()) deque (const allocator_type
&amp;__a) deque () template&lt;typename... _Args&gt;
iterator emplace (iterator __position, _Args
&amp;&amp;...__args) template&lt;typename... _Args&gt; void
emplace_back (_Args &amp;&amp;...__args)
template&lt;typename... _Args&gt; void emplace_front (_Args
&amp;&amp;...__args) bool empty () const const_iterator end
() const iterator end () iterator erase (iterator __first,
iterator __last) iterator erase (iterator __position)
const_reference front () const reference front ()
allocator_type get_allocator () const template&lt;typename
_InputIterator &gt; void insert (iterator __position,
_InputIterator __first, _InputIterator __last) void insert
(iterator __position, size_type __n, const value_type
&amp;__x) void insert (iterator __p, initializer_list&lt;
value_type &gt; __l) iterator insert (iterator __position,
value_type &amp;&amp;__x) iterator insert (iterator
__position, const value_type &amp;__x) size_type max_size ()
const deque &amp; operator= (initializer_list&lt; value_type
&gt; __l) deque &amp; operator= (deque &amp;&amp;__x) deque
&amp; operator= (const deque &amp;__x) const_reference
operator[] (size_type __n) const reference operator[]
(size_type __n) void pop_back () void pop_front () void
push_back (value_type &amp;&amp;__x) void push_back (const
value_type &amp;__x) void push_front (value_type
&amp;&amp;__x) void push_front (const value_type &amp;__x)
const_reverse_iterator rbegin () const reverse_iterator
rbegin () const_reverse_iterator rend () const
reverse_iterator rend () void resize (size_type __new_size,
value_type __x=value_type()) size_type size () const void
swap (deque &amp;&amp;__x) ~deque ()</p>

<p>Protected Types enum { _S_initial_map_size } typedef
_Alloc::template rebind&lt; _Tp * &gt;::other
_Map_alloc_type typedef pointer * _Map_pointer</p>

<p>Protected Member Functions _Tp ** _M_allocate_map
(size_t __n) _Tp * _M_allocate_node () template&lt;typename
_ForwardIterator &gt; void _M_assign_aux (_ForwardIterator
__first, _ForwardIterator __last, std::forward_iterator_tag)
template&lt;typename _InputIterator &gt; void _M_assign_aux
(_InputIterator __first, _InputIterator __last,
std::input_iterator_tag) template&lt;typename _InputIterator
&gt; void _M_assign_dispatch (_InputIterator __first,
_InputIterator __last, __false_type) template&lt;typename
_Integer &gt; void _M_assign_dispatch (_Integer __n,
_Integer __val, __true_type) void _M_create_nodes (_Tp
**__nstart, _Tp **__nfinish) void _M_deallocate_map (_Tp
**__p, size_t __n) void _M_deallocate_node (_Tp *__p) void
_M_destroy_data (iterator __first, iterator __last, const
std::allocator&lt; _Tp &gt; &amp;) template&lt;typename
_Alloc1 &gt; void _M_destroy_data (iterator __first,
iterator __last, const _Alloc1 &amp;) void
_M_destroy_data_aux (iterator __first, iterator __last) void
_M_destroy_nodes (_Tp **__nstart, _Tp **__nfinish) void
_M_erase_at_begin (iterator __pos) void _M_erase_at_end
(iterator __pos) void _M_fill_assign (size_type __n, const
value_type &amp;__val) void _M_fill_initialize (const
value_type &amp;__value) void _M_fill_insert (iterator
__pos, size_type __n, const value_type &amp;__x)
_Map_alloc_type _M_get_map_allocator () const const
_Tp_alloc_type &amp; _M_get_Tp_allocator () const
_Tp_alloc_type &amp; _M_get_Tp_allocator ()
template&lt;typename _InputIterator &gt; void
_M_initialize_dispatch (_InputIterator __first,
_InputIterator __last, __false_type) template&lt;typename
_Integer &gt; void _M_initialize_dispatch (_Integer __n,
_Integer __x, __true_type) void _M_initialize_map (size_t)
template&lt;typename _ForwardIterator &gt; void
_M_insert_aux (iterator __pos, _ForwardIterator __first,
_ForwardIterator __last, size_type __n) void _M_insert_aux
(iterator __pos, size_type __n, const value_type &amp;__x)
template&lt;typename... _Args&gt; iterator _M_insert_aux
(iterator __pos, _Args &amp;&amp;...__args)
template&lt;typename _InputIterator &gt; void
_M_insert_dispatch (iterator __pos, _InputIterator __first,
_InputIterator __last, __false_type) template&lt;typename
_Integer &gt; void _M_insert_dispatch (iterator __pos,
_Integer __n, _Integer __x, __true_type) void _M_range_check
(size_type __n) const template&lt;typename _ForwardIterator
&gt; void _M_range_insert_aux (iterator __pos,
_ForwardIterator __first, _ForwardIterator __last,
std::forward_iterator_tag) template&lt;typename
_InputIterator &gt; void _M_range_insert_aux (iterator
__pos, _InputIterator __first, _InputIterator __last,
std::input_iterator_tag)</p>

<p>void _M_new_elements_at_back (size_type __new_elements)
void _M_new_elements_at_front (size_type __new_elements)
void _M_pop_back_aux () void _M_pop_front_aux ()
template&lt;typename... _Args&gt; void _M_push_back_aux
(_Args &amp;&amp;...__args) template&lt;typename...
_Args&gt; void _M_push_front_aux (_Args &amp;&amp;...__args)
template&lt;typename _ForwardIterator &gt; void
_M_range_initialize (_ForwardIterator __first,
_ForwardIterator __last, std::forward_iterator_tag)
template&lt;typename _InputIterator &gt; void
_M_range_initialize (_InputIterator __first, _InputIterator
__last, std::input_iterator_tag) void _M_reallocate_map
(size_type __nodes_to_add, bool __add_at_front) iterator
_M_reserve_elements_at_back (size_type __n) iterator
_M_reserve_elements_at_front (size_type __n) void
_M_reserve_map_at_back (size_type __nodes_to_add=1) void
_M_reserve_map_at_front (size_type __nodes_to_add=1)</p>

<p>Static Protected Member Functions static size_t
_S_buffer_size ()</p>

<p>Protected Attributes _Deque_impl _M_impl</p>

<p>Detailed Description template&lt;typename _Tp, typename
_Alloc = std::allocator&lt;_Tp&gt;&gt; class std::deque&lt;
_Tp, _Alloc &gt; A standard container using fixed-size
memory allocation and constant- time manipulation of
elements at either end.</p>

<p>Meets the requirements of a container, a reversible
container, and a sequence, including the optional sequence
requirements.</p>

<p>In previous HP/SGI versions of deque, there was an extra
template parameter so users could control the node size.
This extension turned out to violate the C++ standard (it
can be detected using template template parameters), and it
was removed.</p>

<p>Heres how a deque&lt;Tp&gt; manages memory. Each deque
has 4 members:</p>

<p>&middot; Tp** _M_map</p>

<p>&middot; size_t _M_map_size</p>

<p>&middot; iterator _M_start, _M_finish</p>

<p>map_size is at least 8. map is an array of map_size
pointers- to-nodes. (The name map has nothing to do with the
std::map class, and nodes should not be confused with
std::lists usage of node.)</p>

<p>A node has no specific type name as such, but it is
referred to as node in this file. It is a simple
array-of-Tp. If Tp is very large, there will be one Tp
element per node (i.e., an array of one). For non-huge Tp s,
node size is inversely related to Tp size: the larger the
Tp, the fewer Tps will fit in a node. The goal here is to
keep the total size of a node relatively small and constant
over different Tps, to improve allocator efficiency.</p>

<p>Not every pointer in the map array will point to a node.
If the initial number of elements in the deque is small, the
/middle/ map pointers will be valid, and the ones at the
edges will be unused. This same situation will arise as the
map grows: available map pointers, if any, will be on the
ends. As new nodes are created, only a subset of the maps
pointers need to be copied outward.</p>

<p>Class invariants:</p>

<p>&middot; For any nonsingular iterator i:</p>

<p>&middot; i.node points to a member of the map array.
(Yes, you read that correctly: i.node does not actually
point to a node.) The member of the map array is what
actually points to the node.</p>

<p>&middot; i.first == *(i.node) (This points to the node
(first Tp element).)</p>

<p>&middot; i.last == i.first + node_size</p>

<p>&middot; i.cur is a pointer in the range [i.first,
i.last). NOTE: the implication of this is that i.cur is
always a dereferenceable pointer, even if i is a
past-the-end iterator.</p>

<p>&middot; Start and Finish are always nonsingular
iterators. NOTE: this means that an empty deque must have
one node, a deque with &lt;N elements (where N is the node
buffer size) must have one node, a deque with N through
(2N-1) elements must have two nodes, etc.</p>

<p>&middot; For every node other than start.node and
finish.node, every element in the node is an initialized
object. If start.node == finish.node, then [start.cur,
finish.cur) are initialized objects, and the elements
outside that range are uninitialized storage. Otherwise,
[start.cur, start.last) and [finish.first, finish.cur) are
initialized objects, and [start.first, start.cur) and
[finish.cur, finish.last) are uninitialized storage.</p>

<p>&middot; [map, map + map_size) is a valid, non-empty
range.</p>

<p>&middot; [start.node, finish.node] is a valid range
contained within [map, map + map_size).</p>

<p>&middot; A pointer in the range [map, map + map_size)
points to an allocated node if and only if the pointer is in
the range [start.node, finish.node].</p>

<p>Heres the magic: nothing in deque is aware of the
discontiguous storage!</p>

<p>The memory setup and layout occurs in the parent, _Base,
and the iterator class is entirely responsible for leaping
from one node to the next. All the implementation routines
for deque itself work only through the start and finish
iterators. This keeps the routines simple and sane, and we
can use other standard algorithms as well.</p>

<p>Definition at line 638 of file stl_deque.h.</p>

<p>Constructor &amp; Destructor Documentation
template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque () [inline] Default constructor creates no
elements.</p>

<p>Definition at line 690 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque (const allocator_type &amp; __a) [inline,
explicit] Creates a deque with no elements. Parameters: a An
allocator object.</p>

<p>Definition at line 698 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque (size_type __n, const value_type &amp; __value =
value_type(), const allocator_type &amp; __a =
allocator_type()) [inline, explicit] Creates a deque with
copies of an exemplar element. Parameters: n The number of
elements to initially create. value An element to copy. a An
allocator.</p>

<p>This constructor fills the deque with n copies of
value.</p>

<p>Definition at line 710 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_fill_initialize().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque (const deque&lt; _Tp, _Alloc &gt; &amp; __x)
[inline] Deque copy constructor. Parameters: x A deque of
identical element and allocator types.</p>

<p>The newly-created deque uses a copy of the allocation
object used by x.</p>

<p>Definition at line 722 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin(), and
std::deque&lt; _Tp, _Alloc &gt;::end().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque (deque&lt; _Tp, _Alloc &gt; &amp;&amp; __x)
[inline] Deque move constructor. Parameters: x A deque of
identical element and allocator types.</p>

<p>The newly-created deque contains the exact contents of
x. The contents of x are a valid, but unspecified deque.</p>

<p>Definition at line 736 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::deque (initializer_list&lt; value_type &gt; __l, const
allocator_type &amp; __a = allocator_type()) [inline] Builds
a deque from an initializer list. Parameters: l An
initializer_list. a An allocator object.</p>

<p>Create a deque consisting of copies of the elements in
the initializer_list l.</p>

<p>This will call the element types copy constructor N
times (where N is l.size()) and do no memory
reallocation.</p>

<p>Definition at line 750 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_range_initialize().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; template&lt;typename
_InputIterator &gt; std::deque&lt; _Tp, _Alloc &gt;::deque
(_InputIterator __first, _InputIterator __last, const
allocator_type &amp; __a = allocator_type()) [inline] Builds
a deque from a range. Parameters: first An input iterator.
last An input iterator. a An allocator object.</p>

<p>Create a deque consisting of copies of the elements from
[first, last).</p>

<p>If the iterators are forward, bidirectional, or
random-access, then this will call the elements copy
constructor N times (where N is distance(first,last)) and do
no memory reallocation. But if only input iterators are
used, then this will do at most 2N calls to the copy
constructor, and logN memory reallocations.</p>

<p>Definition at line 775 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; std::deque&lt; _Tp, _Alloc
&gt;::~deque () [inline] The dtor only erases the elements,
and note that if the elements themselves are pointers, the
pointed-to memory is not touched in any way. Managing the
pointer is the uses responsibility. Definition at line 789
of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin(), and
std::deque&lt; _Tp, _Alloc &gt;::end().</p>

<p>Member Function Documentation template&lt;typename _Tp ,
typename _Alloc &gt; void deque::_M_fill_initialize (const
value_type &amp; __value) [inline, protected] Fills the
deque with copies of value. Parameters: value Initial
value.</p>

<p>Returns: Nothing.</p>

<p>Precondition: _M_start and _M_finish have already been
initialized, but none of the deques elements have yet been
constructed.</p>

<p>This function is called only when the user provides an
explicit size (with or without an explicit exemplar
value).</p>

<p>Definition at line 277 of file deque.tcc.</p>

<p>References std::_Destroy().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::deque().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
std::_Deque_base&lt; _Tp, _Alloc &gt;::_M_initialize_map
(size_t __num_elements) [inline, protected, inherited]
Layout storage. Parameters: num_elements The count of Ts for
which to allocate space at first.</p>

<p>Returns: Nothing.</p>

<p>The initial underlying memory layout is a bit
complicated...</p>

<p>Definition at line 493 of file stl_deque.h.</p>

<p>References std::__deque_buf_size(), and std::max().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_range_initialize().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_back (size_type __new_elements)
[inline, protected] Helper functions for push_* and
pop_*.</p>

<p>Definition at line 771 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_map_at_back(), std::deque&lt; _Tp, _Alloc
&gt;::max_size(), and std::deque&lt; _Tp, _Alloc
&gt;::size().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_back().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_front (size_type __new_elements)
[inline, protected] Helper functions for push_* and
pop_*.</p>

<p>Definition at line 746 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_map_at_front(), std::deque&lt; _Tp, _Alloc
&gt;::max_size(), and std::deque&lt; _Tp, _Alloc
&gt;::size().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_front().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
deque::_M_pop_back_aux () [inline, protected] Helper
functions for push_* and pop_*.</p>

<p>Definition at line 427 of file deque.tcc.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::pop_back().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
deque::_M_pop_front_aux () [inline, protected] Helper
functions for push_* and pop_*.</p>

<p>Definition at line 442 of file deque.tcc.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::pop_front().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
template&lt;typename... _Args&gt; void
deque::_M_push_back_aux (_Args &amp;&amp;... __args)
[inline, protected] Helper functions for push_* and
pop_*.</p>

<p>Definition at line 361 of file deque.tcc.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::push_back().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
template&lt;typename... _Args&gt; void
deque::_M_push_front_aux (_Args &amp;&amp;... __args)
[inline, protected] Helper functions for push_* and
pop_*.</p>

<p>Definition at line 395 of file deque.tcc.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::push_front().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::_M_range_check (size_type __n) const [inline,
protected] Safety check used only from at().</p>

<p>Definition at line 1076 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::size().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc &gt;::at().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
template&lt;typename _ForwardIterator &gt; void
deque::_M_range_initialize (_ForwardIterator __first,
_ForwardIterator __last, std::forward_iterator_tag) [inline,
protected] Helper functions for push_* and pop_*.</p>

<p>Definition at line 323 of file deque.tcc.</p>

<p>References std::_Destroy(), std::_Deque_base&lt; _Tp,
_Alloc &gt;::_M_initialize_map(), std::advance(), and
std::distance().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
template&lt;typename _InputIterator &gt; void
deque::_M_range_initialize (_InputIterator __first,
_InputIterator __last, std::input_iterator_tag) [inline,
protected] Fills the deque with whatever is in [first,last).
Parameters: first An input iterator. last An input
iterator.</p>

<p>Returns: Nothing.</p>

<p>If the iterators are actually forward iterators (or
better), then the memory layout can be done all at once.
Else we move forward using push_back on each value from the
iterator.</p>

<p>Definition at line 303 of file deque.tcc.</p>

<p>References std::_Deque_base&lt; _Tp, _Alloc
&gt;::_M_initialize_map(), std::deque&lt; _Tp, _Alloc
&gt;::clear(), and std::deque&lt; _Tp, _Alloc
&gt;::push_back().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::deque().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt; void
deque::_M_reallocate_map (size_type __nodes_to_add, bool
__add_at_front) [inline, protected] Helper functions for
push_* and pop_*.</p>

<p>Definition at line 796 of file deque.tcc.</p>

<p>References std::copy_backward(), and std::max().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_map_at_back(), and std::deque&lt; _Tp,
_Alloc &gt;::_M_reserve_map_at_front().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; iterator std::deque&lt; _Tp,
_Alloc &gt;::_M_reserve_elements_at_back (size_type __n)
[inline, protected] Helper functions for push_* and
pop_*.</p>

<p>Definition at line 1689 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; iterator std::deque&lt; _Tp,
_Alloc &gt;::_M_reserve_elements_at_front (size_type __n)
[inline, protected] Memory-handling helpers for the previous
internal insert functions.</p>

<p>Definition at line 1679 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_front().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::_M_reserve_map_at_back (size_type
__nodes_to_add = 1) [inline, protected] Memory-handling
helpers for the major map. Makes sure the _M_map has space
for new nodes. Does not actually add the nodes. Can
invalidate _M_map pointers. (And consequently, deque
iterators.)</p>

<p>Definition at line 1715 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_reallocate_map().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::_M_reserve_map_at_front (size_type
__nodes_to_add = 1) [inline, protected] Helper functions for
push_* and pop_*.</p>

<p>Definition at line 1723 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_reallocate_map().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_front().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::assign (initializer_list&lt; value_type &gt;
__l) [inline] Assigns an initializer list to a deque.
Parameters: l An initializer_list.</p>

<p>This function fills a deque with copies of the elements
in the initializer_list l.</p>

<p>Note that the assignment completely changes the deque
and that the resulting deques size is the same as the number
of elements assigned. Old data may be lost.</p>

<p>Definition at line 885 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::assign().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::assign().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; template&lt;typename
_InputIterator &gt; void std::deque&lt; _Tp, _Alloc
&gt;::assign (_InputIterator __first, _InputIterator __last)
[inline] Assigns a range to a deque. Parameters: first An
input iterator. last An input iterator.</p>

<p>This function fills a deque with copies of the elements
in the range [first,last).</p>

<p>Note that the assignment completely changes the deque
and that the resulting deque s size is the same as the
number of elements assigned. Old data may be lost.</p>

<p>Definition at line 866 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::assign (size_type __n, const value_type &amp;
__val) [inline] Assigns a given value to a deque.
Parameters: n Number of elements to be assigned. val Value
to be assigned.</p>

<p>This function fills a deque with n copies of the given
value. Note that the assignment completely changes the deque
and that the resulting deques size is the same as the number
of elements assigned. Old data may be lost.</p>

<p>Definition at line 849 of file stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::operator=().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reference std::deque&lt;
_Tp, _Alloc &gt;::at (size_type __n) const [inline] Provides
access to the data contained in the deque. Parameters: n The
index of the element for which data should be accessed.</p>

<p>Returns: Read-only (constant) reference to data.</p>

<p>Exceptions: std::out_of_range If n is an invalid
index.</p>

<p>This function provides for safer data access. The
parameter is first checked that it is in the range of the
deque. The function throws out_of_range if the check
fails.</p>

<p>Definition at line 1113 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_range_check().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reference std::deque&lt; _Tp,
_Alloc &gt;::at (size_type __n) [inline] Provides access to
the data contained in the deque. Parameters: n The index of
the element for which data should be accessed.</p>

<p>Returns: Read/write reference to data.</p>

<p>Exceptions: std::out_of_range If n is an invalid
index.</p>

<p>This function provides for safer data access. The
parameter is first checked that it is in the range of the
deque. The function throws out_of_range if the check
fails.</p>

<p>Definition at line 1095 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_range_check().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reference std::deque&lt;
_Tp, _Alloc &gt;::back () const [inline] Returns a read-only
(constant) reference to the data at the last element of the
deque. Definition at line 1152 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::end().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reference std::deque&lt; _Tp,
_Alloc &gt;::back () [inline] Returns a read/write reference
to the data at the last element of the deque. Definition at
line 1140 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::end().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_iterator std::deque&lt;
_Tp, _Alloc &gt;::begin () const [inline] Returns a
read-only (constant) iterator that points to the first
element in the deque. Iteration is done in ordinary element
order. Definition at line 908 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; iterator std::deque&lt; _Tp,
_Alloc &gt;::begin () [inline] Returns a read/write iterator
that points to the first element in the deque. Iteration is
done in ordinary element order. Definition at line 900 of
file stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc &gt;::clear(),
std::deque&lt; _Tp, _Alloc &gt;::deque(), std::deque&lt;
_Tp, _Alloc &gt;::erase(), std::deque&lt; _Tp, _Alloc
&gt;::front(), std::operator==(), and std::deque&lt; _Tp,
_Alloc &gt;::~deque().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_iterator std::deque&lt;
_Tp, _Alloc &gt;::cbegin () const [inline] Returns a
read-only (constant) iterator that points to the first
element in the deque. Iteration is done in ordinary element
order. Definition at line 971 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_iterator std::deque&lt;
_Tp, _Alloc &gt;::cend () const [inline] Returns a read-only
(constant) iterator that points one past the last element in
the deque. Iteration is done in ordinary element order.
Definition at line 980 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::clear () [inline] Erases all the elements. Note
that this function only erases the elements, and that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the user s
responsibility. Definition at line 1422 of file
stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_range_initialize(), std::deque&lt; _Tp, _Alloc
&gt;::erase(), and std::deque&lt; _Tp, _Alloc
&gt;::operator=().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::crbegin () const [inline]
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order. Definition at line 989 of file
stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::crend () const [inline]
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order. Definition at line 998 of
file stl_deque.h.</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
template&lt;typename... _Args&gt; deque&lt; _Tp, _Alloc
&gt;::iterator deque::emplace (iterator __position, _Args
&amp;&amp;... __args) [inline] Inserts an object in deque
before specified iterator. Parameters: position An iterator
into the deque. args Arguments.</p>

<p>Returns: An iterator that points to the inserted
data.</p>

<p>This function will insert an object of type T
constructed with T(std::forward&lt;Args&gt;(args)...) before
the specified location.</p>

<p>Definition at line 144 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::push_back(),
and std::deque&lt; _Tp, _Alloc &gt;::push_front().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::insert().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; bool std::deque&lt; _Tp,
_Alloc &gt;::empty () const [inline] Returns true if the
deque is empty. (Thus begin() would equal end().) Definition
at line 1039 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_iterator std::deque&lt;
_Tp, _Alloc &gt;::end () const [inline] Returns a read-only
(constant) iterator that points one past the last element in
the deque. Iteration is done in ordinary element order.
Definition at line 926 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; iterator std::deque&lt; _Tp,
_Alloc &gt;::end () [inline] Returns a read/write iterator
that points one past the last element in the deque.
Iteration is done in ordinary element order. Definition at
line 917 of file stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc &gt;::back(),
std::deque&lt; _Tp, _Alloc &gt;::deque(), std::deque&lt;
_Tp, _Alloc &gt;::erase(), std::operator==(), and
std::deque&lt; _Tp, _Alloc &gt;::~deque().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
deque&lt; _Tp, _Alloc &gt;::iterator deque::erase (iterator
__first, iterator __last) [inline] Remove a range of
elements. Parameters: first Iterator pointing to the first
element to be erased. last Iterator pointing to one past the
last element to be erased.</p>

<p>Returns: An iterator pointing to the element pointed to
by last prior to erasing (or end()).</p>

<p>This function will erase the elements in the range
[first,last) and shorten the deque accordingly.</p>

<p>The user is cautioned that this function only erases the
elements, and that if the elements themselves are pointers,
the pointed-to memory is not touched in any way. Managing
the pointer is the users responsibility.</p>

<p>Definition at line 189 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin(),
std::deque&lt; _Tp, _Alloc &gt;::clear(), std::deque&lt;
_Tp, _Alloc &gt;::end(), and std::deque&lt; _Tp, _Alloc
&gt;::size().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
deque&lt; _Tp, _Alloc &gt;::iterator deque::erase (iterator
__position) [inline] Remove element at given position.
Parameters: position Iterator pointing to element to be
erased.</p>

<p>Returns: An iterator pointing to the next element (or
end()).</p>

<p>This function will erase the element at the given
position and thus shorten the deque by one.</p>

<p>The user is cautioned that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user s responsibility.</p>

<p>Definition at line 166 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin(),
std::deque&lt; _Tp, _Alloc &gt;::end(), std::deque&lt; _Tp,
_Alloc &gt;::pop_back(), std::deque&lt; _Tp, _Alloc
&gt;::pop_front(), and std::deque&lt; _Tp, _Alloc
&gt;::size().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reference std::deque&lt;
_Tp, _Alloc &gt;::front () const [inline] Returns a
read-only (constant) reference to the data at the first
element of the deque. Definition at line 1132 of file
stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reference std::deque&lt; _Tp,
_Alloc &gt;::front () [inline] Returns a read/write
reference to the data at the first element of the deque.
Definition at line 1124 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::begin().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; allocator_type std::deque&lt;
_Tp, _Alloc &gt;::get_allocator () const [inline] Get a copy
of the memory allocation object.</p>

<p>Reimplemented from std::_Deque_base&lt; _Tp, _Alloc
&gt;.</p>

<p>Definition at line 891 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; template&lt;typename
_InputIterator &gt; void std::deque&lt; _Tp, _Alloc
&gt;::insert (iterator __position, _InputIterator __first,
_InputIterator __last) [inline] Inserts a range into the
deque. Parameters: position An iterator into the deque.
first An input iterator. last An input iterator.</p>

<p>This function will insert copies of the data in the
range [first,last) into the deque before the location
specified by pos. This is known as range insert.</p>

<p>Definition at line 1345 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::insert (iterator __position, size_type __n,
const value_type &amp; __x) [inline] Inserts a number of
copies of given data into the deque. Parameters: position An
iterator into the deque. n Number of elements to be
inserted. x Data to be inserted.</p>

<p>This function will insert a specified number of copies
of the given data before the location specified by
position.</p>

<p>Definition at line 1330 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::insert (iterator __p, initializer_list&lt;
value_type &gt; __l) [inline] Inserts an initializer list
into the deque. Parameters: p An iterator into the deque. l
An initializer_list.</p>

<p>This function will insert copies of the data in the
initializer_list l into the deque before the location
specified by p. This is known as list insert.</p>

<p>Definition at line 1316 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::insert().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::insert().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; iterator std::deque&lt; _Tp,
_Alloc &gt;::insert (iterator __position, value_type
&amp;&amp; __x) [inline] Inserts given rvalue into deque
before specified iterator. Parameters: position An iterator
into the deque. x Data to be inserted.</p>

<p>Returns: An iterator that points to the inserted
data.</p>

<p>This function will insert a copy of the given rvalue
before the specified location.</p>

<p>Definition at line 1303 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::emplace(),
and std::move().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
deque&lt; _Tp, _Alloc &gt;::iterator deque::insert (iterator
__position, const value_type &amp; __x) [inline] Inserts
given value into deque before specified iterator.
Parameters: position An iterator into the deque. x Data to
be inserted.</p>

<p>Returns: An iterator that points to the inserted
data.</p>

<p>This function will insert a copy of the given value
before the specified location.</p>

<p>Definition at line 121 of file deque.tcc.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::push_back(),
and std::deque&lt; _Tp, _Alloc &gt;::push_front().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::resize().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; size_type std::deque&lt; _Tp,
_Alloc &gt;::max_size () const [inline] Returns the size()
of the largest possible deque. Definition at line 1010 of
file stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back(), and std::deque&lt; _Tp,
_Alloc &gt;::_M_new_elements_at_front().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; deque&amp; std::deque&lt; _Tp,
_Alloc &gt;::operator= (initializer_list&lt; value_type &gt;
__l) [inline] Assigns an initializer list to a deque.
Parameters: l An initializer_list.</p>

<p>This function fills a deque with copies of the elements
in the initializer_list l.</p>

<p>Note that the assignment completely changes the deque
and that the resulting deques size is the same as the number
of elements assigned. Old data may be lost.</p>

<p>Definition at line 831 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::assign().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; deque&amp; std::deque&lt; _Tp,
_Alloc &gt;::operator= (deque&lt; _Tp, _Alloc &gt;
&amp;&amp; __x) [inline] Deque move assignment operator.
Parameters: x A deque of identical element and allocator
types.</p>

<p>The contents of x are moved into this deque (without
copying). x is a valid, but unspecified deque.</p>

<p>Definition at line 811 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::clear(), and
std::deque&lt; _Tp, _Alloc &gt;::swap().</p>

<p>template&lt;typename _Tp , typename _Alloc &gt;
deque&lt; _Tp, _Alloc &gt; &amp; deque::operator= (const
deque&lt; _Tp, _Alloc &gt; &amp; __x) [inline] Deque
assignment operator. Parameters: x A deque of identical
element and allocator types.</p>

<p>All the elements of x are copied, but unlike the copy
constructor, the allocator object is not copied.</p>

<p>Definition at line 65 of file deque.tcc.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reference std::deque&lt;
_Tp, _Alloc &gt;::operator[] (size_type __n) const [inline]
Subscript access to the data contained in the deque.
Parameters: n The index of the element for which data should
be accessed.</p>

<p>Returns: Read-only (constant) reference to data.</p>

<p>This operator allows for easy, array-style, data access.
Note that data access with this operator is unchecked and
out_of_range lookups are not defined. (For checked lookups
see at().)</p>

<p>Definition at line 1070 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reference std::deque&lt; _Tp,
_Alloc &gt;::operator[] (size_type __n) [inline] Subscript
access to the data contained in the deque. Parameters: n The
index of the element for which data should be accessed.</p>

<p>Returns: Read/write reference to data.</p>

<p>This operator allows for easy, array-style, data access.
Note that data access with this operator is unchecked and
out_of_range lookups are not defined. (For checked lookups
see at().)</p>

<p>Definition at line 1055 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::pop_back () [inline] Removes last element. This
is a typical stack operation. It shrinks the deque by
one.</p>

<p>Note that no data is returned, and if the last elements
data is needed, it should be retrieved before pop_back() is
called.</p>

<p>Definition at line 1253 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_pop_back_aux().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::erase().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::pop_front () [inline] Removes first element.
This is a typical stack operation. It shrinks the deque by
one.</p>

<p>Note that no data is returned, and if the first elements
data is needed, it should be retrieved before pop_front() is
called.</p>

<p>Definition at line 1232 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_pop_front_aux().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::erase().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::push_back (const value_type &amp; __x) [inline]
Add data to the end of the deque. Parameters: x Data to be
added.</p>

<p>This is a typical stack operation. The function creates
an element at the end of the deque and assigns the given
data to it. Due to the nature of a deque this operation can
be done in constant time.</p>

<p>Definition at line 1201 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_push_back_aux().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_range_initialize(), std::deque&lt; _Tp, _Alloc
&gt;::emplace(), and std::deque&lt; _Tp, _Alloc
&gt;::insert().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::push_front (const value_type &amp; __x)
[inline] Add data to the front of the deque. Parameters: x
Data to be added.</p>

<p>This is a typical stack operation. The function creates
an element at the front of the deque and assigns the given
data to it. Due to the nature of a deque this operation can
be done in constant time.</p>

<p>Definition at line 1170 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc
&gt;::_M_push_front_aux().</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::emplace(), and std::deque&lt; _Tp, _Alloc
&gt;::insert().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::rbegin () const [inline]
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order. Definition at line 944 of file
stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::rbegin () [inline] Returns
a read/write reverse iterator that points to the last
element in the deque. Iteration is done in reverse element
order. Definition at line 935 of file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; const_reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::rend () const [inline]
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order. Definition at line 962 of
file stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; reverse_iterator
std::deque&lt; _Tp, _Alloc &gt;::rend () [inline] Returns a
read/write reverse iterator that points to one before the
first element in the deque. Iteration is done in reverse
element order. Definition at line 953 of file
stl_deque.h.</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::resize (size_type __new_size, value_type __x =
value_type()) [inline] Resizes the deque to the specified
number of elements. Parameters: new_size Number of elements
the deque should contain. x Data with which new elements
should be populated.</p>

<p>This function will resize the deque to the specified
number of elements. If the number is smaller than the deques
current size the deque is truncated, otherwise the deque is
extended and new elements are populated with given data.</p>

<p>Definition at line 1025 of file stl_deque.h.</p>

<p>References std::deque&lt; _Tp, _Alloc &gt;::insert(),
and std::deque&lt; _Tp, _Alloc &gt;::size().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; size_type std::deque&lt; _Tp,
_Alloc &gt;::size () const [inline] Returns the number of
elements in the deque. Definition at line 1005 of file
stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back(), std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_front(), std::deque&lt; _Tp, _Alloc
&gt;::_M_range_check(), std::deque&lt; _Tp, _Alloc
&gt;::erase(), std::operator==(), and std::deque&lt; _Tp,
_Alloc &gt;::resize().</p>

<p>template&lt;typename _Tp, typename _Alloc =
std::allocator&lt;_Tp&gt;&gt; void std::deque&lt; _Tp,
_Alloc &gt;::swap (deque&lt; _Tp, _Alloc &gt; &amp;&amp;
__x) [inline] Swaps data with another deque. Parameters: x A
deque of the same element and allocator types.</p>

<p>This exchanges the elements between two deques in
constant time. (Four pointers, so it should be quite fast.)
Note that the global std::swap() function is specialized
such that std::swap(d1,d2) will feed to this function.</p>

<p>Definition at line 1399 of file stl_deque.h.</p>

<p>Referenced by std::deque&lt; _Tp, _Alloc
&gt;::operator=(), and std::swap().</p>

<p>Author Generated automatically by Doxygen for libstdc++
from the source code.</p>

<p>libstdc++ 26 Jul 2010 std::deque(3)</p>
<hr>
</body>
</html>
