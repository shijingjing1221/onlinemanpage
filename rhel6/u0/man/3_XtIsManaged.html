<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:29:50 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>XtManageChildren(3) XT FUNCTIONS XtManageChildren(3)</p>

<p>NAME XtManageChildren, XtManageChild,
XtUnmanageChildren, XtUnmanageChild, XtChangeManagedSet,
XtIsManaged - manage and unmanage children</p>

<p>SYNTAX typedef Widget *WidgetList;</p>

<p>void XtManageChildren(WidgetList children, Cardinal
num_children);</p>

<p>void XtManageChild(Widget child);</p>

<p>void XtUnmanageChildren(WidgetList children, Cardinal
num_children);</p>

<p>void XtUnmanageChild(Widget child);</p>

<p>void XtChangeManagedSet(WidgetList unmanage_children,
Cardinal num_unmanage_children, XtDoChangeProc
do_change_proc, XtPointer client_data, WidgetList
manage_children, Cardinal num_man- age_children);</p>

<p>Boolean XtIsManaged(Widget widget);</p>

<p>ARGUMENTS child Specifies the child.</p>

<p>children Specifies a list of child widgets.</p>

<p>num_children Specifies the number of children.</p>

<p>widget Specifies the widget.</p>

<p>manage_children Specifies the list of widget children to
add to the managed set.</p>

<p>num_manage_children Specifies the number of entries in
the manage_children list.</p>

<p>unmanage_children Specifies the list of widget children
to remove from the man- aged set.</p>

<p>num_unmanage_children Specifies the number of entries in
the unmanage_children list.</p>

<p>do_change_proc Specifies the post unmanage, pre manage
hook procedure to invoke.</p>

<p>client_data Specifies the client data to be passed to
the hook procedure.</p>

<p>DESCRIPTION The XtManageChildren function performs the
following:</p>

<p>&middot; Issues an error if the children do not all have
the same parent or if the parent is not a subclass of
compositeWidgetClass.</p>

<p>&middot; Returns immediately if the common parent is
being destroyed; oth- erwise, for each unique child on the
list, XtManageChildren ignores the child if it already is
managed or is being destroyed and marks it if not.</p>

<p>&middot; If the parent is realized and after all
children have been marked, it makes some of the newly
managed children viewable:</p>

<p>- Calls the change_managed routine of the widgets
parent.</p>

<p>- Calls XtRealizeWidget on each previously unmanaged
child that is unrealized.</p>

<p>- Maps each previously unmanaged child that has
map_when_man- aged True.</p>

<p>Managing children is independent of the ordering of
children and inde- pendent of creating and deleting
children. The layout routine of the parent should consider
children whose managed field is True and should ignore all
other children. Note that some composite widgets, espe-
cially fixed boxes, call XtManageChild from their
insert_child proce- dure.</p>

<p>If the parent widget is realized, its change_managed
procedure is called to notify it that its set of managed
children has changed. The parent can reposition and resize
any of its children. It moves each child as needed by
calling XtMoveWidget, which first updates the x and y fields
and then calls XMoveWindow if the widget is realized.</p>

<p>The XtManageChild function constructs a WidgetList of
length one and calls XtManageChildren.</p>

<p>The XtUnmanageChildren function performs the
following:</p>

<p>&middot; Issues an error if the children do not all have
the same parent or if the parent is not a subclass of
compositeWidgetClass.</p>

<p>&middot; Returns immediately if the common parent is
being destroyed; oth- erwise, for each unique child on the
list, XtUnmanageChildren per- forms the following:</p>

<p>- Ignores the child if it already is unmanaged or is
being destroyed and marks it if not.</p>

<p>- If the child is realized, it makes it nonvisible by
unmapping it.</p>

<p>&middot; Calls the change_managed routine of the widgets
parent after all children have been marked if the parent is
realized.</p>

<p>XtUnmanageChildren does not destroy the children
widgets. Removing widgets from a parents managed set is
often a temporary banishment, and, some time later, you may
manage the children again.</p>

<p>The XtUnmanageChild function constructs a widget list of
length one and calls XtUnmanageChildren.</p>

<p>The XtChangeManagedSet function performs the
following:</p>

<p>&middot; Issues an error if the widgets specified in the
manage_children and the unmanage_children lists to no all
have the same parent, or if that parent is not a subclass of
compositeWidgetClass.</p>

<p>&middot; Returns immediately if the common parent is
being destroyed.</p>

<p>&middot; If no CompositeClassExtension is defined, or a
CompositeClassEx- tension is defined but with an
allows_change_managed_set field with a value of False, and
XtChangeManagedSet was invoked with a non-NULL
do_change_proc procedure then XtChangeManagedSet performs
the following:</p>

<p>- Calls XtUnmanageChildren (unmanage_children,
num_unman- age_children).</p>

<p>- Calls the do_change_proc specified.</p>

<p>- Calls XtManageChildren (manage_children,
num_manage_children) and then returns immediately.</p>

<p>&middot; Otherwise, if a CompositeClassExtension is
defined with an allows_change_managed_set field with a value
of True, or if no CompositeClassExtension is defined, and
XtChangeManagedSetwas do_change_proc procedure, then the
following is performed:</p>

<p>- For each child on the unmanage_children list; if the
child is already unmanaged or is being destroyed it is
ignored, other- wise it is marked as being unmanaged and if
it is realized it is made nonvisible by being unmapped.</p>

<p>- If the do_change_proc procedure is non-NULL then it is
invoked as specified.</p>

<p>- For each child on the manage_children list; if the
child is already managed or it is being destroyed it is
ignored, oth- erwise it is marked as managed</p>

<p>&middot; If the parent is realized and after all
children have been marked, the change_managed method of the
parent is invoked and subse- quently some of the newly
managed children are made viewable by:</p>

<p>- Calling XtRealizeWidget on each of the previously
unmanaged child that is unrealized.</p>

<p>- Mapping each previously unmanaged child that has
map_when_managed True.</p>

<p>The XtIsManaged function returns True if the specified
widget is of class RectObj or any subclass thereof and is
managed, or False other- wise.</p>

<p>SEE ALSO XtMapWidget(3Xt), XtRealizeWidget(3Xt) X
Toolkit Intrinsics - C Language Interface Xlib - C Language
X Interface</p>

<p>X Version 11 libXt 1.0.7 XtManageChildren(3)</p>
<hr>
</body>
</html>
