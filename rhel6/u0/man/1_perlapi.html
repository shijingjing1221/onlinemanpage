<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:09:58 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLAPI(1) Perl Programmers Reference Guide
PERLAPI(1)</p>

<p>NAME perlapi - autogenerated documentation for the perl
public API</p>

<p>DESCRIPTION This file contains the documentation of the
perl public API generated by embed.pl, specifically a
listing of functions, macros, flags, and variables that may
be used by extension writers. The interfaces of any
functions that are not listed here are subject to change
without notice. For this reason, blindly using functions
listed in proto.h is to be avoided when writing
extensions.</p>

<p>Note that all Perl API global variables must be
referenced with the &quot;PL_&quot; prefix. Some macros are
provided for compatibility with the older, unadorned names,
but this support may be disabled in a future release.</p>

<p>Perl was originally written to handle US-ASCII only
(that is characters whose ordinal numbers are in the range 0
- 127). And documentation and comments may still use the
term ASCII, when sometimes in fact the entire range from 0 -
255 is meant.</p>

<p>Note that Perl can be compiled and run under EBCDIC (See
perlebcdic) or ASCII. Most of the documentation (and even
comments in the code) ignore the EBCDIC possibility. For
almost all purposes the differences are transparent. As an
example, under EBCDIC, instead of UTF-8, UTF- EBCDIC is used
to encode Unicode strings, and so whenever this
documentation refers to &quot;utf8&quot; (and variants of
that name, including in function names), it also
(essentially transparently) means &quot;UTF-EBCDIC&quot;.
But the ordinals of characters differ between ASCII, EBCDIC,
and the UTF- encodings, and a string encoded in UTF-EBCDIC
may occupy more bytes than in UTF-8.</p>

<p>Also, on some EBCDIC machines, functions that are
documented as operating on US-ASCII (or Basic Latin in
Unicode terminology) may in fact operate on all 256
characters in the EBCDIC range, not just the subset
corresponding to US-ASCII.</p>

<p>The listing below is alphabetical, case insensitive.</p>

<p>&quot;Gimme&quot; Values GIMME A backward-compatible
version of &quot;GIMME_V&quot; which can only return
&quot;G_SCALAR&quot; or &quot;G_ARRAY&quot;; in a void
context, it returns &quot;G_SCALAR&quot;. Deprecated. Use
&quot;GIMME_V&quot; instead.</p>

<p>U32 GIMME</p>

<p>GIMME_V The XSUB-writers equivalent to Perls
&quot;wantarray&quot;. Returns &quot;G_VOID&quot;,
&quot;G_SCALAR&quot; or &quot;G_ARRAY&quot; for void, scalar
or list context, respectively.</p>

<p>U32 GIMME_V</p>

<p>G_ARRAY Used to indicate list context. See
&quot;GIMME_V&quot;, &quot;GIMME&quot; and perlcall.</p>

<p>G_DISCARD Indicates that arguments returned from a
callback should be discarded. See perlcall.</p>

<p>G_EVAL Used to force a Perl &quot;eval&quot; wrapper
around a callback. See perlcall.</p>

<p>G_NOARGS Indicates that no arguments are being sent to a
callback. See perlcall.</p>

<p>G_SCALAR Used to indicate scalar context. See
&quot;GIMME_V&quot;, &quot;GIMME&quot;, and perlcall.</p>

<p>G_VOID Used to indicate void context. See
&quot;GIMME_V&quot; and perlcall.</p>

<p>Array Manipulation Functions AvFILL Same as
&quot;av_len()&quot;. Deprecated, use &quot;av_len()&quot;
instead.</p>

<p>int AvFILL(AV* av)</p>

<p>av_clear Clears an array, making it empty. Does not free
the memory used by the array itself.</p>

<p>void av_clear(AV *av)</p>

<p>av_create_and_push Push an SV onto the end of the array,
creating the array if necessary. A small internal helper
function to remove a commonly duplicated idiom.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>void av_create_and_push(AV **const avp, SV *const
val)</p>

<p>av_create_and_unshift_one Unshifts an SV onto the
beginning of the array, creating the array if necessary. A
small internal helper function to remove a commonly
duplicated idiom.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>SV** av_create_and_unshift_one(AV **const avp, SV *const
val)</p>

<p>av_delete Deletes the element indexed by &quot;key&quot;
from the array. Returns the deleted element. If
&quot;flags&quot; equals &quot;G_DISCARD&quot;, the element
is freed and null is returned.</p>

<p>SV* av_delete(AV *av, I32 key, I32 flags)</p>

<p>av_exists Returns true if the element indexed by
&quot;key&quot; has been initialized.</p>

<p>This relies on the fact that uninitialized array
elements are set to &amp;PL_sv_undef.</p>

<p>bool av_exists(AV *av, I32 key)</p>

<p>av_extend Pre-extend an array. The &quot;key&quot; is
the index to which the array should be extended.</p>

<p>void av_extend(AV *av, I32 key)</p>

<p>av_fetch Returns the SV at the specified index in the
array. The &quot;key&quot; is the index. If &quot;lval&quot;
is set then the fetch will be part of a store. Check that
the return value is non-null before dereferencing it to a
&quot;SV*&quot;.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied arrays.</p>

<p>SV** av_fetch(AV *av, I32 key, I32 lval)</p>

<p>av_fill Set the highest index in the array to the given
number, equivalent to Perls &quot;$#array =
$fill;&quot;.</p>

<p>The number of elements in the an array will be
&quot;fill + 1&quot; after av_fill() returns. If the array
was previously shorter then the additional elements appended
are set to &quot;PL_sv_undef&quot;. If the array was longer,
then the excess elements are freed. &quot;av_fill(av,
-1)&quot; is the same as &quot;av_clear(av)&quot;.</p>

<p>void av_fill(AV *av, I32 fill)</p>

<p>av_len Returns the highest index in the array. The
number of elements in the array is &quot;av_len(av) +
1&quot;. Returns -1 if the array is empty.</p>

<p>I32 av_len(const AV *av)</p>

<p>av_make Creates a new AV and populates it with a list of
SVs. The SVs are copied into the array, so they may be freed
after the call to av_make. The new AV will have a reference
count of 1.</p>

<p>AV* av_make(I32 size, SV **strp)</p>

<p>av_pop Pops an SV off the end of the array. Returns
&amp;PL_sv_undef if the array is empty.</p>

<p>SV* av_pop(AV *av)</p>

<p>av_push Pushes an SV onto the end of the array. The
array will grow automatically to accommodate the addition.
Like &quot;av_store&quot;, this takes ownership of one
reference count.</p>

<p>void av_push(AV *av, SV *val)</p>

<p>av_shift Shifts an SV off the beginning of the array.
Returns &amp;PL_sv_undef if the array is empty.</p>

<p>SV* av_shift(AV *av)</p>

<p>av_store Stores an SV in an array. The array index is
specified as &quot;key&quot;. The return value will be NULL
if the operation failed or if the value did not need to be
actually stored within the array (as in the case of tied
arrays). Otherwise it can be dereferenced to get the
original &quot;SV*&quot;. Note that the caller is
responsible for suitably incrementing the reference count of
&quot;val&quot; before the call, and decrementing it if the
function returned NULL.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied arrays.</p>

<p>SV** av_store(AV *av, I32 key, SV *val)</p>

<p>av_undef Undefines the array. Frees the memory used by
the array itself.</p>

<p>void av_undef(AV *av)</p>

<p>av_unshift Unshift the given number of &quot;undef&quot;
values onto the beginning of the array. The array will grow
automatically to accommodate the addition. You must then use
&quot;av_store&quot; to assign values to these new
elements.</p>

<p>void av_unshift(AV *av, I32 num)</p>

<p>get_av Returns the AV of the specified Perl array.
&quot;flags&quot; are passed to &quot;gv_fetchpv&quot;. If
&quot;GV_ADD&quot; is set and the Perl variable does not
exist then it will be created. If &quot;flags&quot; is zero
and the variable does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>AV* get_av(const char *name, I32 flags)</p>

<p>newAV Creates a new AV. The reference count is set to
1.</p>

<p>AV* newAV()</p>

<p>sortsv Sort an array. Here is an example:</p>

<p>sortsv(AvARRAY(av), av_len(av)+1,
Perl_sv_cmp_locale);</p>

<p>Currently this always uses mergesort. See sortsv_flags
for a more flexible routine.</p>

<p>void sortsv(SV** array, size_t num_elts, SVCOMPARE_t
cmp)</p>

<p>sortsv_flags Sort an array, with various options.</p>

<p>void sortsv_flags(SV** array, size_t num_elts,
SVCOMPARE_t cmp, U32 flags)</p>

<p>Callback Functions call_argv Performs a callback to the
specified Perl sub. See perlcall.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>I32 call_argv(const char* sub_name, I32 flags, char**
argv)</p>

<p>call_method Performs a callback to the specified Perl
method. The blessed object must be on the stack. See
perlcall.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>I32 call_method(const char* methname, I32 flags)</p>

<p>call_pv Performs a callback to the specified Perl sub.
See perlcall.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>I32 call_pv(const char* sub_name, I32 flags)</p>

<p>call_sv Performs a callback to the Perl sub whose name
is in the SV. See perlcall.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>I32 call_sv(SV* sv, VOL I32 flags)</p>

<p>ENTER Opening bracket on a callback. See
&quot;LEAVE&quot; and perlcall.</p>

<p>ENTER;</p>

<p>eval_pv Tells Perl to &quot;eval&quot; the given string
and return an SV* result.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>SV* eval_pv(const char* p, I32 croak_on_error)</p>

<p>eval_sv Tells Perl to &quot;eval&quot; the string in the
SV.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>I32 eval_sv(SV* sv, I32 flags)</p>

<p>FREETMPS Closing bracket for temporaries on a callback.
See &quot;SAVETMPS&quot; and perlcall.</p>

<p>FREETMPS;</p>

<p>LEAVE Closing bracket on a callback. See
&quot;ENTER&quot; and perlcall.</p>

<p>LEAVE;</p>

<p>SAVETMPS Opening bracket for temporaries on a callback.
See &quot;FREETMPS&quot; and perlcall.</p>

<p>SAVETMPS;</p>

<p>Character classes isALNUM Returns a boolean indicating
whether the C &quot;char&quot; is a US-ASCII (Basic Latin)
alphanumeric character (including underscore) or digit.</p>

<p>bool isALNUM(char ch)</p>

<p>isALPHA Returns a boolean indicating whether the C
&quot;char&quot; is a US-ASCII (Basic Latin) alphabetic
character.</p>

<p>bool isALPHA(char ch)</p>

<p>isDIGIT Returns a boolean indicating whether the C
&quot;char&quot; is a US-ASCII (Basic Latin) digit.</p>

<p>bool isDIGIT(char ch)</p>

<p>isLOWER Returns a boolean indicating whether the C
&quot;char&quot; is a US-ASCII (Basic Latin) lowercase
character.</p>

<p>bool isLOWER(char ch)</p>

<p>isSPACE Returns a boolean indicating whether the C
&quot;char&quot; is a US-ASCII (Basic Latin) whitespace.</p>

<p>bool isSPACE(char ch)</p>

<p>isUPPER Returns a boolean indicating whether the C
&quot;char&quot; is a US-ASCII (Basic Latin) uppercase
character.</p>

<p>bool isUPPER(char ch)</p>

<p>toLOWER Converts the specified character to lowercase.
Characters outside the US-ASCII (Basic Latin) range are
viewed as not having any case.</p>

<p>char toLOWER(char ch)</p>

<p>toUPPER Converts the specified character to uppercase.
Characters outside the US-ASCII (Basic Latin) range are
viewed as not having any case.</p>

<p>char toUPPER(char ch)</p>

<p>Cloning an interpreter perl_clone Create and return a
new interpreter by cloning the current one.</p>

<p>perl_clone takes these flags as parameters:</p>

<p>CLONEf_COPY_STACKS - is used to, well, copy the stacks
also, without it we only clone the data and zero the stacks,
with it we copy the stacks and the new perl interpreter is
ready to run at the exact same point as the previous one.
The pseudo-fork code uses COPY_STACKS while the
threads-&gt;create doesnt.</p>

<p>CLONEf_KEEP_PTR_TABLE perl_clone keeps a ptr_table with
the pointer of the old variable as a key and the new
variable as a value, this allows it to check if something
has been cloned and not clone it again but rather just use
the value and increase the refcount. If KEEP_PTR_TABLE is
not set then perl_clone will kill the ptr_table using the
function &quot;ptr_table_free(PL_ptr_table); PL_ptr_table =
NULL;&quot;, reason to keep it around is if you want to dup
some of your own variable who are outside the graph perl
scans, example of this code is in threads.xs create</p>

<p>CLONEf_CLONE_HOST This is a win32 thing, it is ignored
on unix, it tells perls win32host code (which is c++) to
clone itself, this is needed on win32 if you want to run two
threads at the same time, if you just want to do some stuff
in a separate perl interpreter and then throw it away and
return to the original one, you dont need to do
anything.</p>

<p>PerlInterpreter* perl_clone(PerlInterpreter *proto_perl,
UV flags)</p>

<p>CV Manipulation Functions CvSTASH Returns the stash of
the CV.</p>

<p>HV* CvSTASH(CV* cv)</p>

<p>get_cv Uses &quot;strlen&quot; to get the length of
&quot;name&quot;, then calls &quot;get_cvn_flags&quot;.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>CV* get_cv(const char* name, I32 flags)</p>

<p>get_cvn_flags Returns the CV of the specified Perl
subroutine. &quot;flags&quot; are passed to
&quot;gv_fetchpvn_flags&quot;. If &quot;GV_ADD&quot; is set
and the Perl subroutine does not exist then it will be
declared (which has the same effect as saying &quot;sub
name;&quot;). If &quot;GV_ADD&quot; is not set and the
subroutine does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>CV* get_cvn_flags(const char* name, STRLEN len, I32
flags)</p>

<p>Embedding Functions cv_undef Clear out all the active
components of a CV. This can happen either by an explicit
&quot;undef &amp;foo&quot;, or by the reference count going
to zero. In the former case, we keep the CvOUTSIDE pointer,
so that any anonymous children can still follow the full
lexical scope chain.</p>

<p>void cv_undef(CV* cv)</p>

<p>load_module Loads the module whose name is pointed to by
the string part of name. Note that the actual module name,
not its filename, should be given. Eg, &quot;Foo::Bar&quot;
instead of &quot;Foo/Bar.pm&quot;. flags can be any of
PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or
PERL_LOADMOD_IMPORT_OPS (or 0 for no flags). ver, if
specified, provides version semantics similar to &quot;use
Foo::Bar VERSION&quot;. The optional trailing SV* arguments
can be used to specify arguments to the modules import()
method, similar to &quot;use Foo::Bar VERSION LIST&quot;.
They must be terminated with a final NULL pointer. Note that
this list can only be omitted when the PERL_LOADMOD_NOIMPORT
flag has been used. Otherwise at least a single NULL pointer
to designate the default import list is required.</p>

<p>void load_module(U32 flags, SV* name, SV* ver, ...)</p>

<p>nothreadhook Stub that provides thread hook for
perl_destruct when there are no threads.</p>

<p>int nothreadhook()</p>

<p>perl_alloc Allocates a new Perl interpreter. See
perlembed.</p>

<p>PerlInterpreter* perl_alloc()</p>

<p>perl_construct Initializes a new Perl interpreter. See
perlembed.</p>

<p>void perl_construct(PerlInterpreter *my_perl)</p>

<p>perl_destruct Shuts down a Perl interpreter. See
perlembed.</p>

<p>int perl_destruct(PerlInterpreter *my_perl)</p>

<p>perl_free Releases a Perl interpreter. See
perlembed.</p>

<p>void perl_free(PerlInterpreter *my_perl)</p>

<p>perl_parse Tells a Perl interpreter to parse a Perl
script. See perlembed.</p>

<p>int perl_parse(PerlInterpreter *my_perl, XSINIT_t
xsinit, int argc, char** argv, char** env)</p>

<p>perl_run Tells a Perl interpreter to run. See
perlembed.</p>

<p>int perl_run(PerlInterpreter *my_perl)</p>

<p>require_pv Tells Perl to &quot;require&quot; the file
named by the string argument. It is analogous to the Perl
code &quot;eval &quot;require
&rsquo;$file&rsquo;&quot;&quot;. Its even implemented that
way; consider using load_module instead.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>void require_pv(const char* pv)</p>

<p>Functions in file dump.c pv_display Similar to</p>

<p>pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);</p>

<p>except that an additional &quot; &quot; will be appended
to the string when len &gt; cur and pv[cur] is &quot;
&quot;.</p>

<p>Note that the final string may be up to 7 chars longer
than pvlim.</p>

<p>char* pv_display(SV *dsv, const char *pv, STRLEN cur,
STRLEN len, STRLEN pvlim)</p>

<p>pv_escape Escapes at most the first &quot;count&quot;
chars of pv and puts the results into dsv such that the size
of the escaped string will not exceed &quot;max&quot; chars
and will not contain any incomplete escape sequences.</p>

<p>If flags contains PERL_PV_ESCAPE_QUOTE then any double
quotes in the string will also be escaped.</p>

<p>Normally the SV will be cleared before the escaped
string is prepared, but when PERL_PV_ESCAPE_NOCLEAR is set
this will not occur.</p>

<p>If PERL_PV_ESCAPE_UNI is set then the input string is
treated as Unicode, if PERL_PV_ESCAPE_UNI_DETECT is set then
the input string is scanned using
&quot;is_utf8_string()&quot; to determine if it is
Unicode.</p>

<p>If PERL_PV_ESCAPE_ALL is set then all input chars will
be output using &quot;1F1&quot; style escapes, otherwise
only chars above 255 will be escaped using this style, other
non printable chars will use octal or common escaped
patterns like &quot;0. If PERL_PV_ESCAPE_NOBACKSLASH then
all chars below 255 will be treated as printable and will be
output as literals.</p>

<p>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first
char of the string will be escaped, regardles of max. If the
string is utf8 and the chars value is &gt;255 then it will
be returned as a plain hex sequence. Thus the output will
either be a single char, an octal escape sequence, a special
escape like &quot;0 or a 3 or more digit hex value.</p>

<p>If PERL_PV_ESCAPE_RE is set then the escape char used
will be a % and not a \. This is because regexes very often
contain backslashed sequences, whereas % is not a
particularly common character in patterns.</p>

<p>Returns a pointer to the escaped text as held by
dsv.</p>

<p>char* pv_escape(SV *dsv, char const * const str, const
STRLEN count, const STRLEN max, STRLEN * const escaped,
const U32 flags)</p>

<p>pv_pretty Converts a string into something presentable,
handling escaping via pv_escape() and supporting quoting and
ellipses.</p>

<p>If the PERL_PV_PRETTY_QUOTE flag is set then the result
will be double quoted with any double quotes in the string
escaped. Otherwise if the PERL_PV_PRETTY_LTGT flag is set
then the result be wrapped in angle brackets.</p>

<p>If the PERL_PV_PRETTY_ELLIPSES flag is set and not all
characters in string were output then an ellipsis
&quot;...&quot; will be appended to the string. Note that
this happens AFTER it has been quoted.</p>

<p>If start_color is non-null then it will be inserted
after the opening quote (if there is one) but before the
escaped text. If end_color is non-null then it will be
inserted after the escaped text but before any quotes or
ellipses.</p>

<p>Returns a pointer to the prettified text as held by
dsv.</p>

<p>char* pv_pretty(SV *dsv, char const * const str, const
STRLEN count, const STRLEN max, char const * const
start_color, char const * const end_color, const U32
flags)</p>

<p>Functions in file mathoms.c gv_fetchmethod See
gv_fetchmethod_autoload.</p>

<p>GV* gv_fetchmethod(HV* stash, const char* name)</p>

<p>pack_cat The engine implementing pack() Perl function.
Note: parameters next_in_list and flags are not used. This
call should not be used; use packlist instead.</p>

<p>void pack_cat(SV *cat, const char *pat, const char
*patend, SV **beglist, SV **endlist, SV ***next_in_list, U32
flags)</p>

<p>sv_2pvbyte_nolen Return a pointer to the byte-encoded
representation of the SV. May cause the SV to be downgraded
from UTF-8 as a side-effect.</p>

<p>Usually accessed via the &quot;SvPVbyte_nolen&quot;
macro.</p>

<p>char* sv_2pvbyte_nolen(SV* sv)</p>

<p>sv_2pvutf8_nolen Return a pointer to the UTF-8-encoded
representation of the SV. May cause the SV to be upgraded to
UTF-8 as a side-effect.</p>

<p>Usually accessed via the &quot;SvPVutf8_nolen&quot;
macro.</p>

<p>char* sv_2pvutf8_nolen(SV* sv)</p>

<p>sv_2pv_nolen Like &quot;sv_2pv()&quot;, but doesnt
return the length too. You should usually use the macro
wrapper &quot;SvPV_nolen(sv)&quot; instead. char*
sv_2pv_nolen(SV* sv)</p>

<p>sv_catpvn_mg Like &quot;sv_catpvn&quot;, but also
handles set magic.</p>

<p>void sv_catpvn_mg(SV *sv, const char *ptr, STRLEN
len)</p>

<p>sv_catsv_mg Like &quot;sv_catsv&quot;, but also handles
set magic.</p>

<p>void sv_catsv_mg(SV *dsv, SV *ssv)</p>

<p>sv_force_normal Undo various types of fakery on an SV:
if the PV is a shared string, make a private copy; if were a
ref, stop refing; if were a glob, downgrade to an xpvmg. See
also &quot;sv_force_normal_flags&quot;.</p>

<p>void sv_force_normal(SV *sv)</p>

<p>sv_iv A private implementation of the &quot;SvIVx&quot;
macro for compilers which cant cope with complex macro
expressions. Always use the macro instead.</p>

<p>IV sv_iv(SV* sv)</p>

<p>sv_nolocking Dummy routine which &quot;locks&quot; an SV
when there is no locking module present. Exists to avoid
test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.</p>

<p>&quot;Superseded&quot; by sv_nosharing().</p>

<p>void sv_nolocking(SV *sv)</p>

<p>sv_nounlocking Dummy routine which &quot;unlocks&quot;
an SV when there is no locking module present. Exists to
avoid test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.</p>

<p>&quot;Superseded&quot; by sv_nosharing().</p>

<p>void sv_nounlocking(SV *sv)</p>

<p>sv_nv A private implementation of the &quot;SvNVx&quot;
macro for compilers which cant cope with complex macro
expressions. Always use the macro instead.</p>

<p>NV sv_nv(SV* sv)</p>

<p>sv_pv Use the &quot;SvPV_nolen&quot; macro instead</p>

<p>char* sv_pv(SV *sv)</p>

<p>sv_pvbyte Use &quot;SvPVbyte_nolen&quot; instead.</p>

<p>char* sv_pvbyte(SV *sv)</p>

<p>sv_pvbyten A private implementation of the
&quot;SvPVbyte&quot; macro for compilers which cant cope
with complex macro expressions. Always use the macro
instead.</p>

<p>char* sv_pvbyten(SV *sv, STRLEN *lp)</p>

<p>sv_pvn A private implementation of the &quot;SvPV&quot;
macro for compilers which cant cope with complex macro
expressions. Always use the macro instead.</p>

<p>char* sv_pvn(SV *sv, STRLEN *lp)</p>

<p>sv_pvutf8 Use the &quot;SvPVutf8_nolen&quot; macro
instead</p>

<p>char* sv_pvutf8(SV *sv)</p>

<p>sv_pvutf8n A private implementation of the
&quot;SvPVutf8&quot; macro for compilers which cant cope
with complex macro expressions. Always use the macro
instead.</p>

<p>char* sv_pvutf8n(SV *sv, STRLEN *lp)</p>

<p>sv_taint Taint an SV. Use &quot;SvTAINTED_on&quot;
instead. void sv_taint(SV* sv)</p>

<p>sv_unref Unsets the RV status of the SV, and decrements
the reference count of whatever was being referenced by the
RV. This can almost be thought of as a reversal of
&quot;newSVrv&quot;. This is &quot;sv_unref_flags&quot; with
the &quot;flag&quot; being zero. See
&quot;SvROK_off&quot;.</p>

<p>void sv_unref(SV* sv)</p>

<p>sv_usepvn Tells an SV to use &quot;ptr&quot; to find its
string value. Implemented by calling
&quot;sv_usepvn_flags&quot; with &quot;flags&quot; of 0,
hence does not handle set magic. See
&quot;sv_usepvn_flags&quot;.</p>

<p>void sv_usepvn(SV* sv, char* ptr, STRLEN len)</p>

<p>sv_usepvn_mg Like &quot;sv_usepvn&quot;, but also
handles set magic.</p>

<p>void sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)</p>

<p>sv_uv A private implementation of the &quot;SvUVx&quot;
macro for compilers which cant cope with complex macro
expressions. Always use the macro instead.</p>

<p>UV sv_uv(SV* sv)</p>

<p>unpack_str The engine implementing unpack() Perl
function. Note: parameters strbeg, new_s and ocnt are not
used. This call should not be used, use unpackstring
instead.</p>

<p>I32 unpack_str(const char *pat, const char *patend,
const char *s, const char *strbeg, const char *strend, char
**new_s, I32 ocnt, U32 flags)</p>

<p>Functions in file perl.h PERL_SYS_INIT Provides
system-specific tune up of the C runtime environment
necessary to run Perl interpreters. This should be called
only once, before creating any Perl interpreters.</p>

<p>void PERL_SYS_INIT(int argc, char** argv)</p>

<p>PERL_SYS_INIT3 Provides system-specific tune up of the C
runtime environment necessary to run Perl interpreters. This
should be called only once, before creating any Perl
interpreters.</p>

<p>void PERL_SYS_INIT3(int argc, char** argv, char**
env)</p>

<p>PERL_SYS_TERM Provides system-specific clean up of the C
runtime environment after running Perl interpreters. This
should be called only once, after freeing any remaining Perl
interpreters.</p>

<p>void PERL_SYS_TERM()</p>

<p>Functions in file pp_ctl.c find_runcv Locate the CV
corresponding to the currently executing sub or eval. If
db_seqp is non_null, skip CVs that are in the DB package and
populate *db_seqp with the cop sequence number at the point
that the DB:: code was entered. (allows debuggers to eval in
the scope of the breakpoint rather than in the scope of the
debugger itself).</p>

<p>CV* find_runcv(U32 *db_seqp)</p>

<p>Functions in file pp_pack.c packlist The engine
implementing pack() Perl function.</p>

<p>void packlist(SV *cat, const char *pat, const char
*patend, SV **beglist, SV **endlist)</p>

<p>unpackstring The engine implementing unpack() Perl
function. &quot;unpackstring&quot; puts the extracted list
items on the stack and returns the number of elements. Issue
&quot;PUTBACK&quot; before and &quot;SPAGAIN&quot; after the
call to this function.</p>

<p>I32 unpackstring(const char *pat, const char *patend,
const char *s, const char *strend, U32 flags)</p>

<p>GV Functions GvSV Return the SV from the GV.</p>

<p>SV* GvSV(GV* gv)</p>

<p>gv_const_sv If &quot;gv&quot; is a typeglob whose
subroutine entry is a constant sub eligible for inlining, or
&quot;gv&quot; is a placeholder reference that would be
promoted to such a typeglob, then returns the value returned
by the sub. Otherwise, returns NULL.</p>

<p>SV* gv_const_sv(GV* gv)</p>

<p>gv_fetchmeth Returns the glob with the given
&quot;name&quot; and a defined subroutine or
&quot;NULL&quot;. The glob lives in the given
&quot;stash&quot;, or in the stashes accessible via @ISA and
UNIVERSAL::.</p>

<p>The argument &quot;level&quot; should be either 0 or -1.
If &quot;level==0&quot;, as a side-effect creates a glob
with the given &quot;name&quot; in the given
&quot;stash&quot; which in the case of success contains an
alias for the subroutine, and sets up caching info for this
glob.</p>

<p>This function grants &quot;SUPER&quot; token as a
postfix of the stash name. The GV returned from
&quot;gv_fetchmeth&quot; may be a method cache entry, which
is not visible to Perl code. So when calling
&quot;call_sv&quot;, you should not use the GV directly;
instead, you should use the methods CV, which can be
obtained from the GV with the &quot;GvCV&quot; macro.</p>

<p>GV* gv_fetchmeth(HV* stash, const char* name, STRLEN
len, I32 level)</p>

<p>gv_fetchmethod_autoload Returns the glob which contains
the subroutine to call to invoke the method on the
&quot;stash&quot;. In fact in the presence of autoloading
this may be the glob for &quot;AUTOLOAD&quot;. In this case
the corresponding variable $AUTOLOAD is already setup.</p>

<p>The third parameter of
&quot;gv_fetchmethod_autoload&quot; determines whether
AUTOLOAD lookup is performed if the given method is not
present: non-zero means yes, look for AUTOLOAD; zero means
no, don t look for AUTOLOAD. Calling
&quot;gv_fetchmethod&quot; is equivalent to calling
&quot;gv_fetchmethod_autoload&quot; with a non-zero
&quot;autoload&quot; parameter.</p>

<p>These functions grant &quot;SUPER&quot; token as a
prefix of the method name. Note that if you want to keep the
returned glob for a long time, you need to check for it
being &quot;AUTOLOAD&quot;, since at the later time the call
may load a different subroutine due to $AUTOLOAD changing
its value. Use the glob created via a side effect to do
this.</p>

<p>These functions have the same side-effects and as
&quot;gv_fetchmeth&quot; with &quot;level==0&quot;.
&quot;name&quot; should be writable if contains
&rsquo;:&rsquo; or &rsquo; &rsquo;&rsquo;. The warning
against passing the GV returned by &quot;gv_fetchmeth&quot;
to &quot;call_sv&quot; apply equally to these functions.</p>

<p>GV* gv_fetchmethod_autoload(HV* stash, const char* name,
I32 autoload)</p>

<p>gv_fetchmeth_autoload Same as gv_fetchmeth(), but looks
for autoloaded subroutines too. Returns a glob for the
subroutine.</p>

<p>For an autoloaded subroutine without a GV, will create a
GV even if &quot;level &lt; 0&quot;. For an autoloaded
subroutine without a stub, GvCV() of the result may be
zero.</p>

<p>GV* gv_fetchmeth_autoload(HV* stash, const char* name,
STRLEN len, I32 level)</p>

<p>gv_stashpv Returns a pointer to the stash for a
specified package. Uses &quot;strlen&quot; to determine the
length of &quot;name&quot;, then calls
&quot;gv_stashpvn()&quot;.</p>

<p>HV* gv_stashpv(const char* name, I32 flags)</p>

<p>gv_stashpvn Returns a pointer to the stash for a
specified package. The &quot;namelen&quot; parameter
indicates the length of the &quot;name&quot;, in bytes.
&quot;flags&quot; is passed to
&quot;gv_fetchpvn_flags()&quot;, so if set to
&quot;GV_ADD&quot; then the package will be created if it
does not already exist. If the package does not exist and
&quot;flags&quot; is 0 (or any other setting that does not
create packages) then NULL is returned.</p>

<p>HV* gv_stashpvn(const char* name, U32 namelen, I32
flags)</p>

<p>gv_stashpvs Like &quot;gv_stashpvn&quot;, but takes a
literal string instead of a string/length pair.</p>

<p>HV* gv_stashpvs(const char* name, I32 create)</p>

<p>gv_stashsv Returns a pointer to the stash for a
specified package. See &quot;gv_stashpvn&quot;.</p>

<p>HV* gv_stashsv(SV* sv, I32 flags)</p>

<p>Handy Values Nullav Null AV pointer.</p>

<p>Nullch Null character pointer.</p>

<p>Nullcv Null CV pointer.</p>

<p>Nullhv Null HV pointer.</p>

<p>Nullsv Null SV pointer.</p>

<p>Hash Manipulation Functions get_hv Returns the HV of the
specified Perl hash. &quot;flags&quot; are passed to
&quot;gv_fetchpv&quot;. If &quot;GV_ADD&quot; is set and the
Perl variable does not exist then it will be created. If
&quot;flags&quot; is zero and the variable does not exist
then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>HV* get_hv(const char *name, I32 flags)</p>

<p>HEf_SVKEY This flag, used in the length slot of hash
entries and magic structures, specifies the structure
contains an &quot;SV*&quot; pointer where a
&quot;char*&quot; pointer is to be expected. (For
information only--not to be used).</p>

<p>HeHASH Returns the computed hash stored in the hash
entry.</p>

<p>U32 HeHASH(HE* he)</p>

<p>HeKEY Returns the actual pointer stored in the key slot
of the hash entry. The pointer may be either
&quot;char*&quot; or &quot;SV*&quot;, depending on the value
of &quot;HeKLEN()&quot;. Can be assigned to. The
&quot;HePV()&quot; or &quot;HeSVKEY()&quot; macros are
usually preferable for finding the value of a key.</p>

<p>void* HeKEY(HE* he)</p>

<p>HeKLEN If this is negative, and amounts to
&quot;HEf_SVKEY&quot;, it indicates the entry holds an
&quot;SV*&quot; key. Otherwise, holds the actual length of
the key. Can be assigned to. The &quot;HePV()&quot; macro is
usually preferable for finding key lengths.</p>

<p>STRLEN HeKLEN(HE* he)</p>

<p>HePV Returns the key slot of the hash entry as a
&quot;char*&quot; value, doing any necessary dereferencing
of possibly &quot;SV*&quot; keys. The length of the string
is placed in &quot;len&quot; (this is a macro, so do not use
&amp;len). If you do not care about what the length of the
key is, you may use the global variable &quot;PL_na&quot;,
though this is rather less efficient than using a local
variable. Remember though, that hash keys in perl are free
to contain embedded nulls, so using &quot;strlen()&quot; or
similar is not a good way to find the length of hash keys.
This is very similar to the &quot;SvPV()&quot; macro
described elsewhere in this document. See also
&quot;HeUTF8&quot;.</p>

<p>If you are using &quot;HePV&quot; to get values to pass
to &quot;newSVpvn()&quot; to create a new SV, you should
consider using &quot;newSVhek(HeKEY_hek(he))&quot; as it is
more efficient.</p>

<p>char* HePV(HE* he, STRLEN len)</p>

<p>HeSVKEY Returns the key as an &quot;SV*&quot;, or
&quot;NULL&quot; if the hash entry does not contain an
&quot;SV*&quot; key.</p>

<p>SV* HeSVKEY(HE* he)</p>

<p>HeSVKEY_force Returns the key as an &quot;SV*&quot;.
Will create and return a temporary mortal &quot;SV*&quot; if
the hash entry contains only a &quot;char*&quot; key.</p>

<p>SV* HeSVKEY_force(HE* he)</p>

<p>HeSVKEY_set Sets the key to a given &quot;SV*&quot;,
taking care to set the appropriate flags to indicate the
presence of an &quot;SV*&quot; key, and returns the same
&quot;SV*&quot;.</p>

<p>SV* HeSVKEY_set(HE* he, SV* sv)</p>

<p>HeUTF8 Returns whether the &quot;char *&quot; value
returned by &quot;HePV&quot; is encoded in UTF-8, doing any
necessary dereferencing of possibly &quot;SV*&quot; keys.
The value returned will be 0 or non-0, not necessarily 1 (or
even a value with any low bits set), so do not blindly
assign this to a &quot;bool&quot; variable, as
&quot;bool&quot; may be a typedef for &quot;char&quot;.</p>

<p>char* HeUTF8(HE* he, STRLEN len)</p>

<p>HeVAL Returns the value slot (type &quot;SV*&quot;)
stored in the hash entry.</p>

<p>SV* HeVAL(HE* he)</p>

<p>HvNAME Returns the package name of a stash, or NULL if
&quot;stash&quot; isnt a stash. See &quot;SvSTASH&quot;,
&quot;CvSTASH&quot;.</p>

<p>char* HvNAME(HV* stash)</p>

<p>hv_assert Check that a hash is in an internally
consistent state.</p>

<p>void hv_assert(HV *hv)</p>

<p>hv_clear Clears a hash, making it empty.</p>

<p>void hv_clear(HV* hv)</p>

<p>hv_clear_placeholders Clears any placeholders from a
hash. If a restricted hash has any of its keys marked as
readonly and the key is subsequently deleted, the key is not
actually deleted but is marked by assigning it a value of
&amp;PL_sv_placeholder. This tags it so it will be ignored
by future operations such as iterating over the hash, but
will still allow the hash to have a value reassigned to the
key at some future point. This function clears any such
placeholder keys from the hash. See Hash::Util::lock_keys()
for an example of its use.</p>

<p>void hv_clear_placeholders(HV *hv)</p>

<p>hv_delete Deletes a key/value pair in the hash. The
value SV is removed from the hash and returned to the
caller. The &quot;klen&quot; is the length of the key. The
&quot;flags&quot; value will normally be zero; if set to
G_DISCARD then NULL will be returned.</p>

<p>SV* hv_delete(HV *hv, const char *key, I32 klen, I32
flags)</p>

<p>hv_delete_ent Deletes a key/value pair in the hash. The
value SV is removed from the hash and returned to the
caller. The &quot;flags&quot; value will normally be zero;
if set to G_DISCARD then NULL will be returned.
&quot;hash&quot; can be a valid precomputed hash value, or 0
to ask for it to be computed.</p>

<p>SV* hv_delete_ent(HV *hv, SV *keysv, I32 flags, U32
hash)</p>

<p>hv_exists Returns a boolean indicating whether the
specified hash key exists. The &quot;klen&quot; is the
length of the key.</p>

<p>bool hv_exists(HV *hv, const char *key, I32 klen)</p>

<p>hv_exists_ent Returns a boolean indicating whether the
specified hash key exists. &quot;hash&quot; can be a valid
precomputed hash value, or 0 to ask for it to be
computed.</p>

<p>bool hv_exists_ent(HV *hv, SV *keysv, U32 hash)</p>

<p>hv_fetch Returns the SV which corresponds to the
specified key in the hash. The &quot;klen&quot; is the
length of the key. If &quot;lval&quot; is set then the fetch
will be part of a store. Check that the return value is
non-null before dereferencing it to an &quot;SV*&quot;.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p>SV** hv_fetch(HV *hv, const char *key, I32 klen, I32
lval)</p>

<p>hv_fetchs Like &quot;hv_fetch&quot;, but takes a literal
string instead of a string/length pair.</p>

<p>SV** hv_fetchs(HV* tb, const char* key, I32 lval)</p>

<p>hv_fetch_ent Returns the hash entry which corresponds to
the specified key in the hash. &quot;hash&quot; must be a
valid precomputed hash number for the given &quot;key&quot;,
or 0 if you want the function to compute it. IF
&quot;lval&quot; is set then the fetch will be part of a
store. Make sure the return value is non-null before
accessing it. The return value when &quot;tb&quot; is a tied
hash is a pointer to a static location, so be sure to make a
copy of the structure if you need to store it somewhere.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p>HE* hv_fetch_ent(HV *hv, SV *keysv, I32 lval, U32
hash)</p>

<p>hv_iterinit Prepares a starting point to traverse a hash
table. Returns the number of keys in the hash (i.e. the same
as &quot;HvKEYS(tb)&quot;). The return value is currently
only meaningful for hashes without tie magic.</p>

<p>NOTE: Before version 5.004_65, &quot;hv_iterinit&quot;
used to return the number of hash buckets that happen to be
in use. If you still need that esoteric value, you can get
it through the macro &quot;HvFILL(tb)&quot;.</p>

<p>I32 hv_iterinit(HV *hv)</p>

<p>hv_iterkey Returns the key from the current position of
the hash iterator. See &quot;hv_iterinit&quot;.</p>

<p>char* hv_iterkey(HE* entry, I32* retlen)</p>

<p>hv_iterkeysv Returns the key as an &quot;SV*&quot; from
the current position of the hash iterator. The return value
will always be a mortal copy of the key. Also see
&quot;hv_iterinit&quot;.</p>

<p>SV* hv_iterkeysv(HE* entry)</p>

<p>hv_iternext Returns entries from a hash iterator. See
&quot;hv_iterinit&quot;.</p>

<p>You may call &quot;hv_delete&quot; or
&quot;hv_delete_ent&quot; on the hash entry that the
iterator currently points to, without losing your place or
invalidating your iterator. Note that in this case the
current entry is deleted from the hash with your iterator
holding the last reference to it. Your iterator is flagged
to free the entry on the next call to
&quot;hv_iternext&quot;, so you must not discard your
iterator immediately else the entry will leak - call
&quot;hv_iternext&quot; to trigger the resource
deallocation.</p>

<p>HE* hv_iternext(HV *hv)</p>

<p>hv_iternextsv Performs an &quot;hv_iternext&quot;,
&quot;hv_iterkey&quot;, and &quot;hv_iterval&quot; in one
operation.</p>

<p>SV* hv_iternextsv(HV *hv, char **key, I32 *retlen)</p>

<p>hv_iternext_flags Returns entries from a hash iterator.
See &quot;hv_iterinit&quot; and &quot;hv_iternext&quot;. The
&quot;flags&quot; value will normally be zero; if
HV_ITERNEXT_WANTPLACEHOLDERS is set the placeholders keys
(for restricted hashes) will be returned in addition to
normal keys. By default placeholders are automatically
skipped over. Currently a placeholder is implemented with a
value that is &amp;Perl_sv_placeholder. Note that the
implementation of placeholders and restricted hashes may
change, and the implementation currently is insufficiently
abstracted for any change to be tidy.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>HE* hv_iternext_flags(HV *hv, I32 flags)</p>

<p>hv_iterval Returns the value from the current position
of the hash iterator. See &quot;hv_iterkey&quot;.</p>

<p>SV* hv_iterval(HV *hv, HE *entry)</p>

<p>hv_magic Adds magic to a hash. See
&quot;sv_magic&quot;.</p>

<p>void hv_magic(HV *hv, GV *gv, int how)</p>

<p>hv_scalar Evaluates the hash in scalar context and
returns the result. Handles magic when the hash is tied.</p>

<p>SV* hv_scalar(HV *hv)</p>

<p>hv_store Stores an SV in a hash. The hash key is
specified as &quot;key&quot; and &quot;klen&quot; is the
length of the key. The &quot;hash&quot; parameter is the
precomputed hash value; if it is zero then Perl will compute
it. The return value will be NULL if the operation failed or
if the value did not need to be actually stored within the
hash (as in the case of tied hashes). Otherwise it can be
dereferenced to get the original &quot;SV*&quot;. Note that
the caller is responsible for suitably incrementing the
reference count of &quot;val&quot; before the call, and
decrementing it if the function returned NULL. Effectively a
successful hv_store takes ownership of one reference to
&quot;val&quot;. This is usually what you want; a newly
created SV has a reference count of one, so if all your code
does is create SVs then store them in a hash, hv_store will
own the only reference to the new SV, and your code doesn t
need to do anything further to tidy up. hv_store is not
implemented as a call to hv_store_ent, and does not create a
temporary SV for the key, so if your key data is not already
in SV form then use hv_store in preference to
hv_store_ent.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p>SV** hv_store(HV *hv, const char *key, I32 klen, SV
*val, U32 hash)</p>

<p>hv_stores Like &quot;hv_store&quot;, but takes a literal
string instead of a string/length pair and omits the hash
parameter.</p>

<p>SV** hv_stores(HV* tb, const char* key, NULLOK SV*
val)</p>

<p>hv_store_ent Stores &quot;val&quot; in a hash. The hash
key is specified as &quot;key&quot;. The &quot;hash&quot;
parameter is the precomputed hash value; if it is zero then
Perl will compute it. The return value is the new hash entry
so created. It will be NULL if the operation failed or if
the value did not need to be actually stored within the hash
(as in the case of tied hashes). Otherwise the contents of
the return value can be accessed using the &quot;He?&quot;
macros described here. Note that the caller is responsible
for suitably incrementing the reference count of
&quot;val&quot; before the call, and decrementing it if the
function returned NULL. Effectively a successful
hv_store_ent takes ownership of one reference to
&quot;val&quot;. This is usually what you want; a newly
created SV has a reference count of one, so if all your code
does is create SVs then store them in a hash, hv_store will
own the only reference to the new SV, and your code doesnt
need to do anything further to tidy up. Note that
hv_store_ent only reads the &quot;key&quot;; unlike
&quot;val&quot; it does not take ownership of it, so
maintaining the correct reference count on &quot;key&quot;
is entirely the caller s responsibility. hv_store is not
implemented as a call to hv_store_ent, and does not create a
temporary SV for the key, so if your key data is not already
in SV form then use hv_store in preference to
hv_store_ent.</p>

<p>See &quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p>HE* hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)</p>

<p>hv_undef Undefines the hash.</p>

<p>void hv_undef(HV *hv)</p>

<p>newHV Creates a new HV. The reference count is set to
1.</p>

<p>HV* newHV()</p>

<p>Magical Functions mg_clear Clear something magical that
the SV represents. See &quot;sv_magic&quot;.</p>

<p>int mg_clear(SV* sv)</p>

<p>mg_copy Copies the magic from one SV to another. See
&quot;sv_magic&quot;.</p>

<p>int mg_copy(SV *sv, SV *nsv, const char *key, I32
klen)</p>

<p>mg_find Finds the magic pointer for type matching the
SV. See &quot;sv_magic&quot;.</p>

<p>MAGIC* mg_find(const SV* sv, int type)</p>

<p>mg_free Free any magic storage used by the SV. See
&quot;sv_magic&quot;.</p>

<p>int mg_free(SV* sv)</p>

<p>mg_get Do magic after a value is retrieved from the SV.
See &quot;sv_magic&quot;.</p>

<p>int mg_get(SV* sv)</p>

<p>mg_length Report on the SVs length. See
&quot;sv_magic&quot;.</p>

<p>U32 mg_length(SV* sv)</p>

<p>mg_magical Turns on the magical status of an SV. See
&quot;sv_magic&quot;.</p>

<p>void mg_magical(SV* sv)</p>

<p>mg_set Do magic after a value is assigned to the SV. See
&quot;sv_magic&quot;.</p>

<p>int mg_set(SV* sv)</p>

<p>SvGETMAGIC Invokes &quot;mg_get&quot; on an SV if it has
get magic. This macro evaluates its argument more than
once.</p>

<p>void SvGETMAGIC(SV* sv)</p>

<p>SvLOCK Arranges for a mutual exclusion lock to be
obtained on sv if a suitable module has been loaded.</p>

<p>void SvLOCK(SV* sv)</p>

<p>SvSETMAGIC Invokes &quot;mg_set&quot; on an SV if it has
set magic. This macro evaluates its argument more than
once.</p>

<p>void SvSETMAGIC(SV* sv)</p>

<p>SvSetMagicSV Like &quot;SvSetSV&quot;, but does any set
magic required afterwards.</p>

<p>void SvSetMagicSV(SV* dsb, SV* ssv)</p>

<p>SvSetMagicSV_nosteal Like &quot;SvSetSV_nosteal&quot;,
but does any set magic required afterwards.</p>

<p>void SvSetMagicSV_nosteal(SV* dsv, SV* ssv)</p>

<p>SvSetSV Calls &quot;sv_setsv&quot; if dsv is not the
same as ssv. May evaluate arguments more than once.</p>

<p>void SvSetSV(SV* dsb, SV* ssv)</p>

<p>SvSetSV_nosteal Calls a non-destructive version of
&quot;sv_setsv&quot; if dsv is not the same as ssv. May
evaluate arguments more than once.</p>

<p>void SvSetSV_nosteal(SV* dsv, SV* ssv)</p>

<p>SvSHARE Arranges for sv to be shared between threads if
a suitable module has been loaded.</p>

<p>void SvSHARE(SV* sv)</p>

<p>SvUNLOCK Releases a mutual exclusion lock on sv if a
suitable module has been loaded.</p>

<p>void SvUNLOCK(SV* sv)</p>

<p>Memory Management Copy The XSUB-writer s interface to
the C &quot;memcpy&quot; function. The &quot;src&quot; is
the source, &quot;dest&quot; is the destination,
&quot;nitems&quot; is the number of items, and
&quot;type&quot; is the type. May fail on overlapping
copies. See also &quot;Move&quot;.</p>

<p>void Copy(void* src, void* dest, int nitems, type)</p>

<p>CopyD Like &quot;Copy&quot; but returns dest. Useful for
encouraging compilers to tail-call optimise.</p>

<p>void * CopyD(void* src, void* dest, int nitems,
type)</p>

<p>Move The XSUB-writers interface to the C
&quot;memmove&quot; function. The &quot;src&quot; is the
source, &quot;dest&quot; is the destination,
&quot;nitems&quot; is the number of items, and
&quot;type&quot; is the type. Can do overlapping moves. See
also &quot;Copy&quot;.</p>

<p>void Move(void* src, void* dest, int nitems, type)</p>

<p>MoveD Like &quot;Move&quot; but returns dest. Useful for
encouraging compilers to tail-call optimise.</p>

<p>void * MoveD(void* src, void* dest, int nitems,
type)</p>

<p>Newx The XSUB-writer s interface to the C
&quot;malloc&quot; function.</p>

<p>In 5.9.3, Newx() and friends replace the older New()
API, and drops the first parameter, x, a debug aid which
allowed callers to identify themselves. This aid has been
superseded by a new build option, PERL_MEM_LOG (see
&quot;PERL_MEM_LOG&quot; in perlhack). The older API is
still there for use in XS modules supporting older
perls.</p>

<p>void Newx(void* ptr, int nitems, type)</p>

<p>Newxc The XSUB-writer s interface to the C
&quot;malloc&quot; function, with cast. See also
&quot;Newx&quot;.</p>

<p>void Newxc(void* ptr, int nitems, type, cast)</p>

<p>Newxz The XSUB-writer s interface to the C
&quot;malloc&quot; function. The allocated memory is zeroed
with &quot;memzero&quot;. See also &quot;Newx&quot;.</p>

<p>void Newxz(void* ptr, int nitems, type)</p>

<p>Poison PoisonWith(0xEF) for catching access to freed
memory.</p>

<p>void Poison(void* dest, int nitems, type)</p>

<p>PoisonFree PoisonWith(0xEF) for catching access to freed
memory.</p>

<p>void PoisonFree(void* dest, int nitems, type)</p>

<p>PoisonNew PoisonWith(0xAB) for catching access to
allocated but uninitialized memory.</p>

<p>void PoisonNew(void* dest, int nitems, type)</p>

<p>PoisonWith Fill up memory with a byte pattern (a byte
repeated over and over again) that hopefully catches
attempts to access uninitialized memory.</p>

<p>void PoisonWith(void* dest, int nitems, type, U8
byte)</p>

<p>Renew The XSUB-writers interface to the C
&quot;realloc&quot; function.</p>

<p>void Renew(void* ptr, int nitems, type)</p>

<p>Renewc The XSUB-writers interface to the C
&quot;realloc&quot; function, with cast.</p>

<p>void Renewc(void* ptr, int nitems, type, cast)</p>

<p>Safefree The XSUB-writer s interface to the C
&quot;free&quot; function.</p>

<p>void Safefree(void* ptr)</p>

<p>savepv Perls version of &quot;strdup()&quot;. Returns a
pointer to a newly allocated string which is a duplicate of
&quot;pv&quot;. The size of the string is determined by
&quot;strlen()&quot;. The memory allocated for the new
string can be freed with the &quot;Safefree()&quot;
function.</p>

<p>char* savepv(const char* pv)</p>

<p>savepvn Perl s version of what &quot;strndup()&quot;
would be if it existed. Returns a pointer to a newly
allocated string which is a duplicate of the first
&quot;len&quot; bytes from &quot;pv&quot;, plus a trailing
NUL byte. The memory allocated for the new string can be
freed with the &quot;Safefree()&quot; function.</p>

<p>char* savepvn(const char* pv, I32 len)</p>

<p>savepvs Like &quot;savepvn&quot;, but takes a literal
string instead of a string/length pair.</p>

<p>char* savepvs(const char* s)</p>

<p>savesharedpv A version of &quot;savepv()&quot; which
allocates the duplicate string in memory which is shared
between threads.</p>

<p>char* savesharedpv(const char* pv)</p>

<p>savesharedpvn A version of &quot;savepvn()&quot; which
allocates the duplicate string in memory which is shared
between threads. (With the specific difference that a NULL
pointer is not acceptable)</p>

<p>char* savesharedpvn(const char *const pv, const STRLEN
len)</p>

<p>savesvpv A version of
&quot;savepv()&quot;/&quot;savepvn()&quot; which gets the
string to duplicate from the passed in SV using
&quot;SvPV()&quot;</p>

<p>char* savesvpv(SV* sv)</p>

<p>StructCopy This is an architecture-independent macro to
copy one structure to another.</p>

<p>void StructCopy(type src, type dest, type)</p>

<p>Zero The XSUB-writer s interface to the C
&quot;memzero&quot; function. The &quot;dest&quot; is the
destination, &quot;nitems&quot; is the number of items, and
&quot;type&quot; is the type.</p>

<p>void Zero(void* dest, int nitems, type)</p>

<p>ZeroD Like &quot;Zero&quot; but returns dest. Useful for
encouraging compilers to tail-call optimise.</p>

<p>void * ZeroD(void* dest, int nitems, type)</p>

<p>Miscellaneous Functions fbm_compile Analyses the string
in order to make fast searches on it using fbm_instr() --
the Boyer-Moore algorithm.</p>

<p>void fbm_compile(SV* sv, U32 flags)</p>

<p>fbm_instr Returns the location of the SV in the string
delimited by &quot;str&quot; and &quot;strend&quot;. It
returns &quot;NULL&quot; if the string can t be found. The
&quot;sv&quot; does not have to be fbm_compiled, but the
search will not be as fast then.</p>

<p>char* fbm_instr(unsigned char* big, unsigned char*
bigend, SV* littlestr, U32 flags)</p>

<p>form Takes a sprintf-style format pattern and
conventional (non-SV) arguments and returns the formatted
string.</p>

<p>(char *) Perl_form(pTHX_ const char* pat, ...)</p>

<p>can be used any place a string (char *) is required:</p>

<p>char * s = Perl_form(&quot;%d.%d&quot;,major,minor);</p>

<p>Uses a single private buffer so if you want to format
several strings you must explicitly copy the earlier strings
away (and free the copies when you are done).</p>

<p>char* form(const char* pat, ...)</p>

<p>getcwd_sv Fill the sv with current working directory</p>

<p>int getcwd_sv(SV* sv)</p>

<p>my_snprintf The C library &quot;snprintf&quot;
functionality, if available and standards-compliant (uses
&quot;vsnprintf&quot;, actually). However, if the
&quot;vsnprintf&quot; is not available, will unfortunately
use the unsafe &quot;vsprintf&quot; which can overrun the
buffer (there is an overrun check, but that may be too
late). Consider using &quot;sv_vcatpvf&quot; instead, or
getting &quot;vsnprintf&quot;.</p>

<p>int my_snprintf(char *buffer, const Size_t len, const
char *format, ...)</p>

<p>my_sprintf The C library &quot;sprintf&quot;, wrapped if
necessary, to ensure that it will return the length of the
string written to the buffer. Only rare pre-ANSI systems
need the wrapper function - usually this is a direct call to
&quot;sprintf&quot;.</p>

<p>int my_sprintf(char *buffer, const char *pat, ...)</p>

<p>my_vsnprintf The C library &quot;vsnprintf&quot; if
available and standards-compliant. However, if if the
&quot;vsnprintf&quot; is not available, will unfortunately
use the unsafe &quot;vsprintf&quot; which can overrun the
buffer (there is an overrun check, but that may be too
late). Consider using &quot;sv_vcatpvf&quot; instead, or
getting &quot;vsnprintf&quot;.</p>

<p>int my_vsnprintf(char *buffer, const Size_t len, const
char *format, va_list ap)</p>

<p>new_version Returns a new version object based on the
passed in SV:</p>

<p>SV *sv = new_version(SV *ver);</p>

<p>Does not alter the passed in ver SV. See
&quot;upg_version&quot; if you want to upgrade the SV.</p>

<p>SV* new_version(SV *ver)</p>

<p>scan_version Returns a pointer to the next character
after the parsed version string, as well as upgrading the
passed in SV to an RV.</p>

<p>Function must be called with an already existing SV
like</p>

<p>sv = newSV(0); s = scan_version(s, SV *sv, bool qv);</p>

<p>Performs some preprocessing to the string to ensure that
it has the correct characteristics of a version. Flags the
object if it contains an underscore (which denotes this is
an alpha version). The boolean qv denotes that the version
should be interpreted as if it had multiple decimals, even
if it doesnt.</p>

<p>const char* scan_version(const char *s, SV *rv, bool
qv)</p>

<p>strEQ Test two strings to see if they are equal. Returns
true or false.</p>

<p>bool strEQ(char* s1, char* s2)</p>

<p>strGE Test two strings to see if the first,
&quot;s1&quot;, is greater than or equal to the second,
&quot;s2&quot;. Returns true or false.</p>

<p>bool strGE(char* s1, char* s2)</p>

<p>strGT Test two strings to see if the first,
&quot;s1&quot;, is greater than the second, &quot;s2&quot;.
Returns true or false.</p>

<p>bool strGT(char* s1, char* s2)</p>

<p>strLE Test two strings to see if the first,
&quot;s1&quot;, is less than or equal to the second,
&quot;s2&quot;. Returns true or false.</p>

<p>bool strLE(char* s1, char* s2)</p>

<p>strLT Test two strings to see if the first,
&quot;s1&quot;, is less than the second, &quot;s2&quot;.
Returns true or false.</p>

<p>bool strLT(char* s1, char* s2)</p>

<p>strNE Test two strings to see if they are different.
Returns true or false.</p>

<p>bool strNE(char* s1, char* s2)</p>

<p>strnEQ Test two strings to see if they are equal. The
&quot;len&quot; parameter indicates the number of bytes to
compare. Returns true or false. (A wrapper for
&quot;strncmp&quot;).</p>

<p>bool strnEQ(char* s1, char* s2, STRLEN len)</p>

<p>strnNE Test two strings to see if they are different.
The &quot;len&quot; parameter indicates the number of bytes
to compare. Returns true or false. (A wrapper for
&quot;strncmp&quot;).</p>

<p>bool strnNE(char* s1, char* s2, STRLEN len)</p>

<p>sv_destroyable Dummy routine which reports that object
can be destroyed when there is no sharing module present. It
ignores its single SV argument, and returns true. Exists to
avoid test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.</p>

<p>bool sv_destroyable(SV *sv)</p>

<p>sv_nosharing Dummy routine which &quot;shares&quot; an
SV when there is no sharing module present. Or
&quot;locks&quot; it. Or &quot;unlocks&quot; it. In other
words, ignores its single SV argument. Exists to avoid test
for a NULL function pointer and because it could potentially
warn under some level of strict-ness.</p>

<p>void sv_nosharing(SV *sv)</p>

<p>upg_version In-place upgrade of the supplied SV to a
version object.</p>

<p>SV *sv = upg_version(SV *sv, bool qv);</p>

<p>Returns a pointer to the upgraded SV. Set the boolean qv
if you want to force this SV to be interpreted as an
&quot;extended&quot; version.</p>

<p>SV* upg_version(SV *ver, bool qv)</p>

<p>vcmp Version object aware cmp. Both operands must
already have been converted into version objects.</p>

<p>int vcmp(SV *lhv, SV *rhv)</p>

<p>vnormal Accepts a version object and returns the
normalized string representation. Call like:</p>

<p>sv = vnormal(rv);</p>

<p>NOTE: you can pass either the object directly or the SV
contained within the RV.</p>

<p>SV* vnormal(SV *vs)</p>

<p>vnumify Accepts a version object and returns the
normalized floating point representation. Call like:</p>

<p>sv = vnumify(rv);</p>

<p>NOTE: you can pass either the object directly or the SV
contained within the RV.</p>

<p>SV* vnumify(SV *vs)</p>

<p>vstringify In order to maintain maximum compatibility
with earlier versions of Perl, this function will return
either the floating point notation or the multiple dotted
notation, depending on whether the original version
contained 1 or more dots, respectively</p>

<p>SV* vstringify(SV *vs)</p>

<p>vverify Validates that the SV contains a valid version
object.</p>

<p>bool vverify(SV *vobj);</p>

<p>Note that it only confirms the bare minimum structure
(so as not to get confused by derived classes which may
contain additional hash entries):</p>

<p>bool vverify(SV *vs)</p>

<p>MRO Functions mro_get_linear_isa Returns either
&quot;mro_get_linear_isa_c3&quot; or
&quot;mro_get_linear_isa_dfs&quot; for the given stash,
dependant upon which MRO is in effect for that stash. The
return value is a read-only AV*.</p>

<p>You are responsible for &quot;SvREFCNT_inc()&quot; on
the return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted out from
under you the next time the cache is invalidated).</p>

<p>AV* mro_get_linear_isa(HV* stash)</p>

<p>mro_method_changed_in Invalidates method caching on any
child classes of the given stash, so that they might notice
the changes in this one.</p>

<p>Ideally, all instances of
&quot;PL_sub_generation++&quot; in perl source outside of
&quot;mro.c&quot; should be replaced by calls to this.</p>

<p>Perl automatically handles most of the common ways a
method might be redefined. However, there are a few ways you
could change a method in a stash without the cache code
noticing, in which case you need to call this method
afterwards:</p>

<p>1) Directly manipulating the stash HV entries from XS
code.</p>

<p>2) Assigning a reference to a readonly scalar constant
into a stash entry in order to create a constant subroutine
(like constant.pm does).</p>

<p>This same method is available from pure perl via,
&quot;mro::method_changed_in(classname)&quot;.</p>

<p>void mro_method_changed_in(HV* stash)</p>

<p>Multicall Functions dMULTICALL Declare local variables
for a multicall. See &quot;Lightweight Callbacks&quot; in
perlcall.</p>

<p>dMULTICALL;</p>

<p>MULTICALL Make a lightweight callback. See
&quot;Lightweight Callbacks&quot; in perlcall.</p>

<p>MULTICALL;</p>

<p>POP_MULTICALL Closing bracket for a lightweight
callback. See &quot;Lightweight Callbacks&quot; in
perlcall.</p>

<p>POP_MULTICALL;</p>

<p>PUSH_MULTICALL Opening bracket for a lightweight
callback. See &quot;Lightweight Callbacks&quot; in
perlcall.</p>

<p>PUSH_MULTICALL;</p>

<p>Numeric functions grok_bin converts a string
representing a binary number to numeric form.</p>

<p>On entry start and *len give the string to scan, *flags
gives conversion flags, and result should be NULL or a
pointer to an NV. The scan stops at the end of the string,
or the first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character will also trigger a
warning. On return *len is set to the length of the scanned
string, and *flags gives output flags.</p>

<p>If the value is &lt;= &quot;UV_MAX&quot; it is returned
as a UV, the output flags are clear, and nothing is written
to *result. If the value is &gt; UV_MAX &quot;grok_bin&quot;
returns UV_MAX, sets
&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in the output
flags, and writes the value to *result (or the value is
discarded if result is NULL).</p>

<p>The binary number may optionally be prefixed with
&quot;0b&quot; or &quot;b&quot; unless
&quot;PERL_SCAN_DISALLOW_PREFIX&quot; is set in *flags on
entry. If &quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in
*flags then the binary number may use _ characters to
separate digits.</p>

<p>UV grok_bin(const char* start, STRLEN* len_p, I32*
flags, NV *result)</p>

<p>grok_hex converts a string representing a hex number to
numeric form.</p>

<p>On entry start and *len give the string to scan, *flags
gives conversion flags, and result should be NULL or a
pointer to an NV. The scan stops at the end of the string,
or the first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character will also trigger a
warning. On return *len is set to the length of the scanned
string, and *flags gives output flags.</p>

<p>If the value is &lt;= UV_MAX it is returned as a UV, the
output flags are clear, and nothing is written to *result.
If the value is &gt; UV_MAX &quot;grok_hex&quot; returns
UV_MAX, sets &quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in
the output flags, and writes the value to *result (or the
value is discarded if result is NULL).</p>

<p>The hex number may optionally be prefixed with
&quot;0x&quot; or &quot;x&quot; unless
&quot;PERL_SCAN_DISALLOW_PREFIX&quot; is set in *flags on
entry. If &quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in
*flags then the hex number may use _ characters to separate
digits.</p>

<p>UV grok_hex(const char* start, STRLEN* len_p, I32*
flags, NV *result)</p>

<p>grok_number Recognise (or not) a number. The type of the
number is returned (0 if unrecognised), otherwise it is a
bit-ORed combination of IS_NUMBER_IN_UV,
IS_NUMBER_GREATER_THAN_UV_MAX, IS_NUMBER_NOT_INT,
IS_NUMBER_NEG, IS_NUMBER_INFINITY, IS_NUMBER_NAN (defined in
perl.h).</p>

<p>If the value of the number can fit an in UV, it is
returned in the *valuep IS_NUMBER_IN_UV will be set to
indicate that *valuep is valid, IS_NUMBER_IN_UV will never
be set unless *valuep is valid, but *valuep may have been
assigned to during processing even though IS_NUMBER_IN_UV is
not set on return. If valuep is NULL, IS_NUMBER_IN_UV will
be set for the same cases as when valuep is non-NULL, but no
actual assignment (or SEGV) will occur.</p>

<p>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if
trailing decimals were seen (in which case *valuep gives the
true value truncated to an integer), and IS_NUMBER_NEG if
the number is negative (in which case *valuep holds the
absolute value). IS_NUMBER_IN_UV is not set if e notation
was used or the number is larger than a UV.</p>

<p>int grok_number(const char *pv, STRLEN len, UV
*valuep)</p>

<p>grok_numeric_radix Scan and skip for a numeric decimal
separator (radix).</p>

<p>bool grok_numeric_radix(const char **sp, const char
*send)</p>

<p>grok_oct converts a string representing an octal number
to numeric form.</p>

<p>On entry start and *len give the string to scan, *flags
gives conversion flags, and result should be NULL or a
pointer to an NV. The scan stops at the end of the string,
or the first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character will also trigger a
warning. On return *len is set to the length of the scanned
string, and *flags gives output flags.</p>

<p>If the value is &lt;= UV_MAX it is returned as a UV, the
output flags are clear, and nothing is written to *result.
If the value is &gt; UV_MAX &quot;grok_oct&quot; returns
UV_MAX, sets &quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in
the output flags, and writes the value to *result (or the
value is discarded if result is NULL).</p>

<p>If &quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in
*flags then the octal number may use _ characters to
separate digits.</p>

<p>UV grok_oct(const char* start, STRLEN* len_p, I32*
flags, NV *result)</p>

<p>Perl_signbit Return a non-zero integer if the sign bit
on an NV is set, and 0 if it is not.</p>

<p>If Configure detects this system has a signbit() that
will work with our NVs, then we just use it via the #define
in perl.h. Otherwise, fall back on this implementation. As a
first pass, this gets everything right except -0.0. Alas,
catching -0.0 is the main use for this function, so this is
not too helpful yet. Still, at least we have the scaffolding
in place to support other systems, should that prove
useful.</p>

<p>Configure notes: This function is called Perl_signbit
instead of a plain signbit because it is easy to imagine a
system having a signbit() function or macro that doesnt
happen to work with our particular choice of NVs. We
shouldnt just re-#define signbit as Perl_signbit and expect
the standard system headers to be happy. Also, this is a
no-context function (no pTHX_) because Perl_signbit() is
usually re-#defined in perl.h as a simple macro call to the
systems signbit(). Users should just always call
Perl_signbit().</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>int Perl_signbit(NV f)</p>

<p>scan_bin For backwards compatibility. Use
&quot;grok_bin&quot; instead.</p>

<p>NV scan_bin(const char* start, STRLEN len, STRLEN*
retlen)</p>

<p>scan_hex For backwards compatibility. Use
&quot;grok_hex&quot; instead.</p>

<p>NV scan_hex(const char* start, STRLEN len, STRLEN*
retlen)</p>

<p>scan_oct For backwards compatibility. Use
&quot;grok_oct&quot; instead.</p>

<p>NV scan_oct(const char* start, STRLEN len, STRLEN*
retlen)</p>

<p>Optree Manipulation Functions cv_const_sv If
&quot;cv&quot; is a constant sub eligible for inlining.
returns the constant value returned by the sub. Otherwise,
returns NULL.</p>

<p>Constant subs can be created with
&quot;newCONSTSUB&quot; or as described in &quot;Constant
Functions&quot; in perlsub.</p>

<p>SV* cv_const_sv(CV* cv)</p>

<p>newCONSTSUB Creates a constant sub equivalent to Perl
&quot;sub FOO () { 123 }&quot; which is eligible for
inlining at compile-time.</p>

<p>CV* newCONSTSUB(HV* stash, const char* name, SV* sv)</p>

<p>newXS Used by &quot;xsubpp&quot; to hook up XSUBs as
Perl subs. filename needs to be static storage, as it is
used directly as CvFILE(), without a copy being made.</p>

<p>Pad Data Structures pad_sv Get the value at offset po in
the current pad. Use macro PAD_SV instead of calling this
function directly.</p>

<p>SV* pad_sv(PADOFFSET po)</p>

<p>Per-Interpreter Variables PL_modglobal
&quot;PL_modglobal&quot; is a general purpose, interpreter
global HV for use by extensions that need to keep
information on a per- interpreter basis. In a pinch, it can
also be used as a symbol table for extensions to share data
among each other. It is a good idea to use keys prefixed by
the package name of the extension that owns the data.</p>

<p>HV* PL_modglobal</p>

<p>PL_na A convenience variable which is typically used
with &quot;SvPV&quot; when one doesnt care about the length
of the string. It is usually more efficient to either
declare a local variable and use that instead or to use the
&quot;SvPV_nolen&quot; macro.</p>

<p>STRLEN PL_na</p>

<p>PL_sv_no This is the &quot;false&quot; SV. See
&quot;PL_sv_yes&quot;. Always refer to this as
&amp;PL_sv_no.</p>

<p>SV PL_sv_no</p>

<p>PL_sv_undef This is the &quot;undef&quot; SV. Always
refer to this as &amp;PL_sv_undef.</p>

<p>SV PL_sv_undef</p>

<p>PL_sv_yes This is the &quot;true&quot; SV. See
&quot;PL_sv_no&quot;. Always refer to this as
&amp;PL_sv_yes.</p>

<p>SV PL_sv_yes</p>

<p>REGEXP Functions SvRX Convenience macro to get the
REGEXP from a SV. This is approximately equivalent to the
following snippet:</p>

<p>if (SvMAGICAL(sv)) mg_get(sv); if (SvROK(sv) &amp;&amp;
(tmpsv = (SV*)SvRV(sv)) &amp;&amp; SvTYPE(tmpsv) == SVt_PVMG
&amp;&amp; (tmpmg = mg_find(tmpsv, PERL_MAGIC_qr))) { return
(REGEXP *)tmpmg-&gt;mg_obj; }</p>

<p>NULL will be returned if a REGEXP* is not found.</p>

<p>REGEXP * SvRX(SV *sv)</p>

<p>SvRXOK Returns a boolean indicating whether the SV
contains qr magic (PERL_MAGIC_qr).</p>

<p>If you want to do something with the REGEXP* later use
SvRX instead and check for NULL.</p>

<p>bool SvRXOK(SV* sv)</p>

<p>Simple Exception Handling Macros dXCPT Set up necessary
local variables for exception handling. See &quot;Exception
Handling&quot; in perlguts.</p>

<p>dXCPT;</p>

<p>XCPT_CATCH Introduces a catch block. See &quot;Exception
Handling&quot; in perlguts.</p>

<p>XCPT_RETHROW Rethrows a previously caught exception. See
&quot;Exception Handling&quot; in perlguts.</p>

<p>XCPT_RETHROW;</p>

<p>XCPT_TRY_END Ends a try block. See &quot;Exception
Handling&quot; in perlguts.</p>

<p>XCPT_TRY_START Starts a try block. See &quot;Exception
Handling&quot; in perlguts.</p>

<p>Stack Manipulation Macros dMARK Declare a stack marker
variable, &quot;mark&quot;, for the XSUB. See
&quot;MARK&quot; and &quot;dORIGMARK&quot;.</p>

<p>dMARK;</p>

<p>dORIGMARK Saves the original stack mark for the XSUB.
See &quot;ORIGMARK&quot;.</p>

<p>dORIGMARK;</p>

<p>dSP Declares a local copy of perls stack pointer for the
XSUB, available via the &quot;SP&quot; macro. See
&quot;SP&quot;.</p>

<p>dSP;</p>

<p>EXTEND Used to extend the argument stack for an XSUBs
return values. Once used, guarantees that there is room for
at least &quot;nitems&quot; to be pushed onto the stack.</p>

<p>void EXTEND(SP, int nitems)</p>

<p>MARK Stack marker variable for the XSUB. See
&quot;dMARK&quot;.</p>

<p>mPUSHi Push an integer onto the stack. The stack must
have room for this element. Does not use &quot;TARG&quot;.
See also &quot;PUSHi&quot;, &quot;mXPUSHi&quot; and
&quot;XPUSHi&quot;.</p>

<p>void mPUSHi(IV iv)</p>

<p>mPUSHn Push a double onto the stack. The stack must have
room for this element. Does not use &quot;TARG&quot;. See
also &quot;PUSHn&quot;, &quot;mXPUSHn&quot; and
&quot;XPUSHn&quot;.</p>

<p>void mPUSHn(NV nv)</p>

<p>mPUSHp Push a string onto the stack. The stack must have
room for this element. The &quot;len&quot; indicates the
length of the string. Does not use &quot;TARG&quot;. See
also &quot;PUSHp&quot;, &quot;mXPUSHp&quot; and
&quot;XPUSHp&quot;.</p>

<p>void mPUSHp(char* str, STRLEN len)</p>

<p>mPUSHs Push an SV onto the stack and mortalizes the SV.
The stack must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHs&quot; and
&quot;mXPUSHs&quot;.</p>

<p>void mPUSHs(SV* sv)</p>

<p>mPUSHu Push an unsigned integer onto the stack. The
stack must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHu&quot;,
&quot;mXPUSHu&quot; and &quot;XPUSHu&quot;.</p>

<p>void mPUSHu(UV uv)</p>

<p>mXPUSHi Push an integer onto the stack, extending the
stack if necessary. Does not use &quot;TARG&quot;. See also
&quot;XPUSHi&quot;, &quot;mPUSHi&quot; and
&quot;PUSHi&quot;.</p>

<p>void mXPUSHi(IV iv)</p>

<p>mXPUSHn Push a double onto the stack, extending the
stack if necessary. Does not use &quot;TARG&quot;. See also
&quot;XPUSHn&quot;, &quot;mPUSHn&quot; and
&quot;PUSHn&quot;.</p>

<p>void mXPUSHn(NV nv)</p>

<p>mXPUSHp Push a string onto the stack, extending the
stack if necessary. The &quot;len&quot; indicates the length
of the string. Does not use &quot;TARG&quot;. See also
&quot;XPUSHp&quot;, &quot;mPUSHp&quot; and
&quot;PUSHp&quot;.</p>

<p>void mXPUSHp(char* str, STRLEN len)</p>

<p>mXPUSHs Push an SV onto the stack, extending the stack
if necessary and mortalizes the SV. Does not use
&quot;TARG&quot;. See also &quot;XPUSHs&quot; and
&quot;mPUSHs&quot;.</p>

<p>void mXPUSHs(SV* sv)</p>

<p>mXPUSHu Push an unsigned integer onto the stack,
extending the stack if necessary. Does not use
&quot;TARG&quot;. See also &quot;XPUSHu&quot;,
&quot;mPUSHu&quot; and &quot;PUSHu&quot;.</p>

<p>void mXPUSHu(UV uv)</p>

<p>ORIGMARK The original stack mark for the XSUB. See
&quot;dORIGMARK&quot;.</p>

<p>POPi Pops an integer off the stack.</p>

<p>IV POPi</p>

<p>POPl Pops a long off the stack.</p>

<p>long POPl</p>

<p>POPn Pops a double off the stack.</p>

<p>NV POPn</p>

<p>POPp Pops a string off the stack. Deprecated. New code
should use POPpx.</p>

<p>char* POPp</p>

<p>POPpbytex Pops a string off the stack which must consist
of bytes i.e. characters &lt; 256.</p>

<p>char* POPpbytex</p>

<p>POPpx Pops a string off the stack.</p>

<p>char* POPpx</p>

<p>POPs Pops an SV off the stack.</p>

<p>SV* POPs</p>

<p>PUSHi Push an integer onto the stack. The stack must
have room for this element. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUBs - see &quot;mPUSHi&quot; instead. See also
&quot;XPUSHi&quot; and &quot;mXPUSHi&quot;.</p>

<p>void PUSHi(IV iv)</p>

<p>PUSHMARK Opening bracket for arguments on a callback.
See &quot;PUTBACK&quot; and perlcall.</p>

<p>void PUSHMARK(SP)</p>

<p>PUSHmortal Push a new mortal SV onto the stack. The
stack must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHs&quot;,
&quot;XPUSHmortal&quot; and &quot;XPUSHs&quot;.</p>

<p>void PUSHmortal()</p>

<p>PUSHn Push a double onto the stack. The stack must have
room for this element. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUBs - see &quot;mPUSHn&quot; instead. See also
&quot;XPUSHn&quot; and &quot;mXPUSHn&quot;.</p>

<p>void PUSHn(NV nv)</p>

<p>PUSHp Push a string onto the stack. The stack must have
room for this element. The &quot;len&quot; indicates the
length of the string. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUB s - see &quot;mPUSHp&quot; instead. See also
&quot;XPUSHp&quot; and &quot;mXPUSHp&quot;.</p>

<p>void PUSHp(char* str, STRLEN len)</p>

<p>PUSHs Push an SV onto the stack. The stack must have
room for this element. Does not handle set magic. Does not
use &quot;TARG&quot;. See also &quot;PUSHmortal&quot;,
&quot;XPUSHs&quot; and &quot;XPUSHmortal&quot;.</p>

<p>void PUSHs(SV* sv)</p>

<p>PUSHu Push an unsigned integer onto the stack. The stack
must have room for this element. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUB s - see &quot;mPUSHu&quot; instead. See also
&quot;XPUSHu&quot; and &quot;mXPUSHu&quot;.</p>

<p>void PUSHu(UV uv)</p>

<p>PUTBACK Closing bracket for XSUB arguments. This is
usually handled by &quot;xsubpp&quot;. See
&quot;PUSHMARK&quot; and perlcall for other uses.</p>

<p>PUTBACK;</p>

<p>SP Stack pointer. This is usually handled by
&quot;xsubpp&quot;. See &quot;dSP&quot; and
&quot;SPAGAIN&quot;.</p>

<p>SPAGAIN Refetch the stack pointer. Used after a
callback. See perlcall.</p>

<p>SPAGAIN;</p>

<p>XPUSHi Push an integer onto the stack, extending the
stack if necessary. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUBs - see &quot;mXPUSHi&quot; instead. See also
&quot;PUSHi&quot; and &quot;mPUSHi&quot;.</p>

<p>void XPUSHi(IV iv)</p>

<p>XPUSHmortal Push a new mortal SV onto the stack,
extending the stack if necessary. Does not use
&quot;TARG&quot;. See also &quot;XPUSHs&quot;,
&quot;PUSHmortal&quot; and &quot;PUSHs&quot;.</p>

<p>void XPUSHmortal()</p>

<p>XPUSHn Push a double onto the stack, extending the stack
if necessary. Handles set magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;-oriented macros to return lists from XSUB s
- see &quot;mXPUSHn&quot; instead. See also
&quot;PUSHn&quot; and &quot;mPUSHn&quot;.</p>

<p>void XPUSHn(NV nv)</p>

<p>XPUSHp Push a string onto the stack, extending the stack
if necessary. The &quot;len&quot; indicates the length of
the string. Handles set magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;-oriented macros to return lists from XSUBs
- see &quot;mXPUSHp&quot; instead. See also
&quot;PUSHp&quot; and &quot;mPUSHp&quot;.</p>

<p>void XPUSHp(char* str, STRLEN len)</p>

<p>XPUSHs Push an SV onto the stack, extending the stack if
necessary. Does not handle set magic. Does not use
&quot;TARG&quot;. See also &quot;XPUSHmortal&quot;,
&quot;PUSHs&quot; and &quot;PUSHmortal&quot;.</p>

<p>void XPUSHs(SV* sv)</p>

<p>XPUSHu Push an unsigned integer onto the stack,
extending the stack if necessary. Handles set magic. Uses
&quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;-oriented macros to return
lists from XSUB s - see &quot;mXPUSHu&quot; instead. See
also &quot;PUSHu&quot; and &quot;mPUSHu&quot;.</p>

<p>void XPUSHu(UV uv)</p>

<p>XSRETURN Return from XSUB, indicating number of items on
the stack. This is usually handled by
&quot;xsubpp&quot;.</p>

<p>void XSRETURN(int nitems)</p>

<p>XSRETURN_EMPTY Return an empty list from an XSUB
immediately.</p>

<p>XSRETURN_EMPTY;</p>

<p>XSRETURN_IV Return an integer from an XSUB immediately.
Uses &quot;XST_mIV&quot;.</p>

<p>void XSRETURN_IV(IV iv)</p>

<p>XSRETURN_NO Return &amp;PL_sv_no from an XSUB
immediately. Uses &quot;XST_mNO&quot;.</p>

<p>XSRETURN_NO;</p>

<p>XSRETURN_NV Return a double from an XSUB immediately.
Uses &quot;XST_mNV&quot;.</p>

<p>void XSRETURN_NV(NV nv)</p>

<p>XSRETURN_PV Return a copy of a string from an XSUB
immediately. Uses &quot;XST_mPV&quot;.</p>

<p>void XSRETURN_PV(char* str)</p>

<p>XSRETURN_UNDEF Return &amp;PL_sv_undef from an XSUB
immediately. Uses &quot;XST_mUNDEF&quot;.</p>

<p>XSRETURN_UNDEF;</p>

<p>XSRETURN_UV Return an integer from an XSUB immediately.
Uses &quot;XST_mUV&quot;.</p>

<p>void XSRETURN_UV(IV uv)</p>

<p>XSRETURN_YES Return &amp;PL_sv_yes from an XSUB
immediately. Uses &quot;XST_mYES&quot;.</p>

<p>XSRETURN_YES;</p>

<p>XST_mIV Place an integer into the specified position
&quot;pos&quot; on the stack. The value is stored in a new
mortal SV.</p>

<p>void XST_mIV(int pos, IV iv)</p>

<p>XST_mNO Place &amp;PL_sv_no into the specified position
&quot;pos&quot; on the stack.</p>

<p>void XST_mNO(int pos)</p>

<p>XST_mNV Place a double into the specified position
&quot;pos&quot; on the stack. The value is stored in a new
mortal SV.</p>

<p>void XST_mNV(int pos, NV nv)</p>

<p>XST_mPV Place a copy of a string into the specified
position &quot;pos&quot; on the stack. The value is stored
in a new mortal SV.</p>

<p>void XST_mPV(int pos, char* str)</p>

<p>XST_mUNDEF Place &amp;PL_sv_undef into the specified
position &quot;pos&quot; on the stack.</p>

<p>void XST_mUNDEF(int pos)</p>

<p>XST_mYES Place &amp;PL_sv_yes into the specified
position &quot;pos&quot; on the stack.</p>

<p>void XST_mYES(int pos)</p>

<p>SV Flags svtype An enum of flags for Perl types. These
are found in the file sv.h in the &quot;svtype&quot; enum.
Test these flags with the &quot;SvTYPE&quot; macro.</p>

<p>SVt_IV Integer type flag for scalars. See
&quot;svtype&quot;.</p>

<p>SVt_NV Double type flag for scalars. See
&quot;svtype&quot;.</p>

<p>SVt_PV Pointer type flag for scalars. See
&quot;svtype&quot;.</p>

<p>SVt_PVAV Type flag for arrays. See
&quot;svtype&quot;.</p>

<p>SVt_PVCV Type flag for code refs. See
&quot;svtype&quot;.</p>

<p>SVt_PVHV Type flag for hashes. See
&quot;svtype&quot;.</p>

<p>SVt_PVMG Type flag for blessed scalars. See
&quot;svtype&quot;.</p>

<p>SV Manipulation Functions croak_xs_usage A specialised
variant of &quot;croak()&quot; for emitting the usage
message for xsubs</p>

<p>croak_xs_usage(cv, &quot;eee_yow&quot;);</p>

<p>works out the package name and subroutine name from
&quot;cv&quot;, and then calls &quot;croak()&quot;. Hence if
&quot;cv&quot; is &amp;ouch::awk, it would call
&quot;croak&quot; as:</p>

<p>Perl_croak(aTHX_ &quot;Usage %s::%s(%s)&quot;,
&quot;ouch&quot; &quot;awk&quot;, &quot;eee_yow&quot;);</p>

<p>void croak_xs_usage(const CV *const cv, const char
*const params)</p>

<p>get_sv Returns the SV of the specified Perl scalar.
&quot;flags&quot; are passed to &quot;gv_fetchpv&quot;. If
&quot;GV_ADD&quot; is set and the Perl variable does not
exist then it will be created. If &quot;flags&quot; is zero
and the variable does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<p>SV* get_sv(const char *name, I32 flags)</p>

<p>newRV_inc Creates an RV wrapper for an SV. The reference
count for the original SV is incremented.</p>

<p>SV* newRV_inc(SV* sv)</p>

<p>newSVpvn_utf8 Creates a new SV and copies a string into
it. If utf8 is true, calls &quot;SvUTF8_on&quot; on the new
SV. Implemented as a wrapper around
&quot;newSVpvn_flags&quot;.</p>

<p>SV* newSVpvn_utf8(NULLOK const char* s, STRLEN len, U32
utf8)</p>

<p>SvCUR Returns the length of the string which is in the
SV. See &quot;SvLEN&quot;.</p>

<p>STRLEN SvCUR(SV* sv)</p>

<p>SvCUR_set Set the current length of the string which is
in the SV. See &quot;SvCUR&quot; and
&quot;SvIV_set&quot;.</p>

<p>void SvCUR_set(SV* sv, STRLEN len)</p>

<p>SvEND Returns a pointer to the last character in the
string which is in the SV. See &quot;SvCUR&quot;. Access the
character as *(SvEND(sv)).</p>

<p>char* SvEND(SV* sv)</p>

<p>SvGAMAGIC Returns true if the SV has get magic or
overloading. If either is true then the scalar is active
data, and has the potential to return a new value every time
it is accessed. Hence you must be careful to only read it
once per user logical operation and work with that returned
value. If neither is true then the scalars value cannot
change unless written to.</p>

<p>U32 SvGAMAGIC(SV* sv)</p>

<p>SvGROW Expands the character buffer in the SV so that it
has room for the indicated number of bytes (remember to
reserve space for an extra trailing NUL character). Calls
&quot;sv_grow&quot; to perform the expansion if necessary.
Returns a pointer to the character buffer.</p>

<p>char * SvGROW(SV* sv, STRLEN len)</p>

<p>SvIOK Returns a U32 value indicating whether the SV
contains an integer.</p>

<p>U32 SvIOK(SV* sv)</p>

<p>SvIOKp Returns a U32 value indicating whether the SV
contains an integer. Checks the private setting. Use
&quot;SvIOK&quot; instead.</p>

<p>U32 SvIOKp(SV* sv)</p>

<p>SvIOK_notUV Returns a boolean indicating whether the SV
contains a signed integer.</p>

<p>bool SvIOK_notUV(SV* sv)</p>

<p>SvIOK_off Unsets the IV status of an SV.</p>

<p>void SvIOK_off(SV* sv)</p>

<p>SvIOK_on Tells an SV that it is an integer.</p>

<p>void SvIOK_on(SV* sv)</p>

<p>SvIOK_only Tells an SV that it is an integer and
disables all other OK bits.</p>

<p>void SvIOK_only(SV* sv)</p>

<p>SvIOK_only_UV Tells and SV that it is an unsigned
integer and disables all other OK bits.</p>

<p>void SvIOK_only_UV(SV* sv)</p>

<p>SvIOK_UV Returns a boolean indicating whether the SV
contains an unsigned integer.</p>

<p>bool SvIOK_UV(SV* sv)</p>

<p>SvIsCOW Returns a boolean indicating whether the SV is
Copy-On-Write. (either shared hash key scalars, or full Copy
On Write scalars if 5.9.0 is configured for COW)</p>

<p>bool SvIsCOW(SV* sv)</p>

<p>SvIsCOW_shared_hash Returns a boolean indicating whether
the SV is Copy-On-Write shared hash key scalar.</p>

<p>bool SvIsCOW_shared_hash(SV* sv)</p>

<p>SvIV Coerces the given SV to an integer and returns it.
See &quot;SvIVx&quot; for a version which guarantees to
evaluate sv only once.</p>

<p>IV SvIV(SV* sv)</p>

<p>SvIVX Returns the raw value in the SVs IV slot, without
checks or conversions. Only use when you are sure SvIOK is
true. See also &quot;SvIV()&quot;.</p>

<p>IV SvIVX(SV* sv)</p>

<p>SvIVx Coerces the given SV to an integer and returns it.
Guarantees to evaluate &quot;sv&quot; only once. Only use
this if &quot;sv&quot; is an expression with side effects,
otherwise use the more efficient &quot;SvIV&quot;.</p>

<p>IV SvIVx(SV* sv)</p>

<p>SvIV_nomg Like &quot;SvIV&quot; but doesnt process
magic.</p>

<p>IV SvIV_nomg(SV* sv)</p>

<p>SvIV_set Set the value of the IV pointer in sv to val.
It is possible to perform the same function of this macro
with an lvalue assignment to &quot;SvIVX&quot;. With future
Perls, however, it will be more efficient to use
&quot;SvIV_set&quot; instead of the lvalue assignment to
&quot;SvIVX&quot;.</p>

<p>void SvIV_set(SV* sv, IV val)</p>

<p>SvLEN Returns the size of the string buffer in the SV,
not including any part attributable to &quot;SvOOK&quot;.
See &quot;SvCUR&quot;.</p>

<p>STRLEN SvLEN(SV* sv)</p>

<p>SvLEN_set Set the actual length of the string which is
in the SV. See &quot;SvIV_set&quot;.</p>

<p>void SvLEN_set(SV* sv, STRLEN len)</p>

<p>SvMAGIC_set Set the value of the MAGIC pointer in sv to
val. See &quot;SvIV_set&quot;.</p>

<p>void SvMAGIC_set(SV* sv, MAGIC* val)</p>

<p>SvNIOK Returns a U32 value indicating whether the SV
contains a number, integer or double.</p>

<p>U32 SvNIOK(SV* sv)</p>

<p>SvNIOKp Returns a U32 value indicating whether the SV
contains a number, integer or double. Checks the private
setting. Use &quot;SvNIOK&quot; instead.</p>

<p>U32 SvNIOKp(SV* sv)</p>

<p>SvNIOK_off Unsets the NV/IV status of an SV.</p>

<p>void SvNIOK_off(SV* sv)</p>

<p>SvNOK Returns a U32 value indicating whether the SV
contains a double.</p>

<p>U32 SvNOK(SV* sv)</p>

<p>SvNOKp Returns a U32 value indicating whether the SV
contains a double. Checks the private setting. Use
&quot;SvNOK&quot; instead.</p>

<p>U32 SvNOKp(SV* sv)</p>

<p>SvNOK_off Unsets the NV status of an SV.</p>

<p>void SvNOK_off(SV* sv)</p>

<p>SvNOK_on Tells an SV that it is a double.</p>

<p>void SvNOK_on(SV* sv)</p>

<p>SvNOK_only Tells an SV that it is a double and disables
all other OK bits.</p>

<p>void SvNOK_only(SV* sv)</p>

<p>SvNV Coerce the given SV to a double and return it. See
&quot;SvNVx&quot; for a version which guarantees to evaluate
sv only once.</p>

<p>NV SvNV(SV* sv)</p>

<p>SvNVX Returns the raw value in the SVs NV slot, without
checks or conversions. Only use when you are sure SvNOK is
true. See also &quot;SvNV()&quot;.</p>

<p>NV SvNVX(SV* sv)</p>

<p>SvNVx Coerces the given SV to a double and returns it.
Guarantees to evaluate &quot;sv&quot; only once. Only use
this if &quot;sv&quot; is an expression with side effects,
otherwise use the more efficient &quot;SvNV&quot;.</p>

<p>NV SvNVx(SV* sv)</p>

<p>SvNV_set Set the value of the NV pointer in sv to val.
See &quot;SvIV_set&quot;.</p>

<p>void SvNV_set(SV* sv, NV val)</p>

<p>SvOK Returns a U32 value indicating whether the value is
defined. This is only meaningful for scalars.</p>

<p>U32 SvOK(SV* sv)</p>

<p>SvOOK Returns a U32 indicating whether the SvIVX is a
valid offset value for the SvPVX. This hack is used
internally to speed up removal of characters from the
beginning of a SvPV. When SvOOK is true, then the start of
the allocated string buffer is really (SvPVX - SvIVX).</p>

<p>U32 SvOOK(SV* sv)</p>

<p>SvPOK Returns a U32 value indicating whether the SV
contains a character string.</p>

<p>U32 SvPOK(SV* sv)</p>

<p>SvPOKp Returns a U32 value indicating whether the SV
contains a character string. Checks the private setting. Use
&quot;SvPOK&quot; instead.</p>

<p>U32 SvPOKp(SV* sv)</p>

<p>SvPOK_off Unsets the PV status of an SV.</p>

<p>void SvPOK_off(SV* sv)</p>

<p>SvPOK_on Tells an SV that it is a string.</p>

<p>void SvPOK_on(SV* sv)</p>

<p>SvPOK_only Tells an SV that it is a string and disables
all other OK bits. Will also turn off the UTF-8 status.</p>

<p>void SvPOK_only(SV* sv)</p>

<p>SvPOK_only_UTF8 Tells an SV that it is a string and
disables all other OK bits, and leaves the UTF-8 status as
it was.</p>

<p>void SvPOK_only_UTF8(SV* sv)</p>

<p>SvPV Returns a pointer to the string in the SV, or a
stringified form of the SV if the SV does not contain a
string. The SV may cache the stringified version becoming
&quot;SvPOK&quot;. Handles get magic. See also
&quot;SvPVx&quot; for a version which guarantees to evaluate
sv only once.</p>

<p>char* SvPV(SV* sv, STRLEN len)</p>

<p>SvPVbyte Like &quot;SvPV&quot;, but converts sv to byte
representation first if necessary.</p>

<p>char* SvPVbyte(SV* sv, STRLEN len)</p>

<p>SvPVbytex Like &quot;SvPV&quot;, but converts sv to byte
representation first if necessary. Guarantees to evaluate sv
only once; use the more efficient &quot;SvPVbyte&quot;
otherwise.</p>

<p>char* SvPVbytex(SV* sv, STRLEN len)</p>

<p>SvPVbytex_force Like &quot;SvPV_force&quot;, but
converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient
&quot;SvPVbyte_force&quot; otherwise.</p>

<p>char* SvPVbytex_force(SV* sv, STRLEN len)</p>

<p>SvPVbyte_force Like &quot;SvPV_force&quot;, but converts
sv to byte representation first if necessary.</p>

<p>char* SvPVbyte_force(SV* sv, STRLEN len)</p>

<p>SvPVbyte_nolen Like &quot;SvPV_nolen&quot;, but converts
sv to byte representation first if necessary.</p>

<p>char* SvPVbyte_nolen(SV* sv)</p>

<p>SvPVutf8 Like &quot;SvPV&quot;, but converts sv to utf8
first if necessary.</p>

<p>char* SvPVutf8(SV* sv, STRLEN len)</p>

<p>SvPVutf8x Like &quot;SvPV&quot;, but converts sv to utf8
first if necessary. Guarantees to evaluate sv only once; use
the more efficient &quot;SvPVutf8&quot; otherwise.</p>

<p>char* SvPVutf8x(SV* sv, STRLEN len)</p>

<p>SvPVutf8x_force Like &quot;SvPV_force&quot;, but
converts sv to utf8 first if necessary. Guarantees to
evaluate sv only once; use the more efficient
&quot;SvPVutf8_force&quot; otherwise.</p>

<p>char* SvPVutf8x_force(SV* sv, STRLEN len)</p>

<p>SvPVutf8_force Like &quot;SvPV_force&quot;, but converts
sv to utf8 first if necessary.</p>

<p>char* SvPVutf8_force(SV* sv, STRLEN len)</p>

<p>SvPVutf8_nolen Like &quot;SvPV_nolen&quot;, but converts
sv to utf8 first if necessary.</p>

<p>char* SvPVutf8_nolen(SV* sv)</p>

<p>SvPVX Returns a pointer to the physical string in the
SV. The SV must contain a string.</p>

<p>char* SvPVX(SV* sv)</p>

<p>SvPVx A version of &quot;SvPV&quot; which guarantees to
evaluate &quot;sv&quot; only once. Only use this if
&quot;sv&quot; is an expression with side effects, otherwise
use the more efficient &quot;SvPVX&quot;.</p>

<p>char* SvPVx(SV* sv, STRLEN len)</p>

<p>SvPV_force Like &quot;SvPV&quot; but will force the SV
into containing just a string (&quot;SvPOK_only&quot;). You
want force if you are going to update the &quot;SvPVX&quot;
directly.</p>

<p>char* SvPV_force(SV* sv, STRLEN len)</p>

<p>SvPV_force_nomg Like &quot;SvPV&quot; but will force the
SV into containing just a string (&quot;SvPOK_only&quot;).
You want force if you are going to update the
&quot;SvPVX&quot; directly. Doesnt process magic.</p>

<p>char* SvPV_force_nomg(SV* sv, STRLEN len)</p>

<p>SvPV_nolen Returns a pointer to the string in the SV, or
a stringified form of the SV if the SV does not contain a
string. The SV may cache the stringified form becoming
&quot;SvPOK&quot;. Handles get magic.</p>

<p>char* SvPV_nolen(SV* sv)</p>

<p>SvPV_nomg Like &quot;SvPV&quot; but doesnt process
magic.</p>

<p>char* SvPV_nomg(SV* sv, STRLEN len)</p>

<p>SvPV_set Set the value of the PV pointer in sv to val.
See &quot;SvIV_set&quot;.</p>

<p>void SvPV_set(SV* sv, char* val)</p>

<p>SvREFCNT Returns the value of the objects reference
count.</p>

<p>U32 SvREFCNT(SV* sv)</p>

<p>SvREFCNT_dec Decrements the reference count of the given
SV.</p>

<p>void SvREFCNT_dec(SV* sv)</p>

<p>SvREFCNT_inc Increments the reference count of the given
SV.</p>

<p>All of the following SvREFCNT_inc* macros are optimized
versions of SvREFCNT_inc, and can be replaced with
SvREFCNT_inc.</p>

<p>SV* SvREFCNT_inc(SV* sv)</p>

<p>SvREFCNT_inc_NN Same as SvREFCNT_inc, but can only be
used if you know sv is not NULL. Since we don t have to
check the NULLness, its faster and smaller.</p>

<p>SV* SvREFCNT_inc_NN(SV* sv)</p>

<p>SvREFCNT_inc_simple Same as SvREFCNT_inc, but can only
be used with expressions without side effects. Since we dont
have to store a temporary value, its faster.</p>

<p>SV* SvREFCNT_inc_simple(SV* sv)</p>

<p>SvREFCNT_inc_simple_NN Same as SvREFCNT_inc_simple, but
can only be used if you know sv is not NULL. Since we dont
have to check the NULLness, its faster and smaller.</p>

<p>SV* SvREFCNT_inc_simple_NN(SV* sv)</p>

<p>SvREFCNT_inc_simple_void Same as SvREFCNT_inc_simple,
but can only be used if you dont need the return value. The
macro doesnt need to return a meaningful value.</p>

<p>void SvREFCNT_inc_simple_void(SV* sv)</p>

<p>SvREFCNT_inc_simple_void_NN Same as SvREFCNT_inc, but
can only be used if you dont need the return value, and you
know that sv is not NULL. The macro doesnt need to return a
meaningful value, or check for NULLness, so its smaller and
faster.</p>

<p>void SvREFCNT_inc_simple_void_NN(SV* sv)</p>

<p>SvREFCNT_inc_void Same as SvREFCNT_inc, but can only be
used if you dont need the return value. The macro doesnt
need to return a meaningful value.</p>

<p>void SvREFCNT_inc_void(SV* sv)</p>

<p>SvREFCNT_inc_void_NN Same as SvREFCNT_inc, but can only
be used if you dont need the return value, and you know that
sv is not NULL. The macro doesnt need to return a meaningful
value, or check for NULLness, so its smaller and faster.</p>

<p>void SvREFCNT_inc_void_NN(SV* sv)</p>

<p>SvROK Tests if the SV is an RV.</p>

<p>U32 SvROK(SV* sv)</p>

<p>SvROK_off Unsets the RV status of an SV.</p>

<p>void SvROK_off(SV* sv)</p>

<p>SvROK_on Tells an SV that it is an RV.</p>

<p>void SvROK_on(SV* sv)</p>

<p>SvRV Dereferences an RV to return the SV.</p>

<p>SV* SvRV(SV* sv)</p>

<p>SvRV_set Set the value of the RV pointer in sv to val.
See &quot;SvIV_set&quot;.</p>

<p>void SvRV_set(SV* sv, SV* val)</p>

<p>SvSTASH Returns the stash of the SV.</p>

<p>HV* SvSTASH(SV* sv)</p>

<p>SvSTASH_set Set the value of the STASH pointer in sv to
val. See &quot;SvIV_set&quot;.</p>

<p>void SvSTASH_set(SV* sv, HV* val)</p>

<p>SvTAINT Taints an SV if tainting is enabled.</p>

<p>void SvTAINT(SV* sv)</p>

<p>SvTAINTED Checks to see if an SV is tainted. Returns
TRUE if it is, FALSE if not.</p>

<p>bool SvTAINTED(SV* sv)</p>

<p>SvTAINTED_off Untaints an SV. Be very careful with this
routine, as it short- circuits some of Perl s fundamental
security features. XS module authors should not use this
function unless they fully understand all the implications
of unconditionally untainting the value. Untainting should
be done in the standard perl fashion, via a carefully
crafted regexp, rather than directly untainting
variables.</p>

<p>void SvTAINTED_off(SV* sv)</p>

<p>SvTAINTED_on Marks an SV as tainted if tainting is
enabled.</p>

<p>void SvTAINTED_on(SV* sv)</p>

<p>SvTRUE Returns a boolean indicating whether Perl would
evaluate the SV as true or false. See SvOK() for a
defined/undefined test. Does not handle get magic.</p>

<p>bool SvTRUE(SV* sv)</p>

<p>SvTYPE Returns the type of the SV. See
&quot;svtype&quot;.</p>

<p>svtype SvTYPE(SV* sv)</p>

<p>SvUOK Returns a boolean indicating whether the SV
contains an unsigned integer.</p>

<p>bool SvUOK(SV* sv)</p>

<p>SvUPGRADE Used to upgrade an SV to a more complex form.
Uses &quot;sv_upgrade&quot; to perform the upgrade if
necessary. See &quot;svtype&quot;.</p>

<p>void SvUPGRADE(SV* sv, svtype type)</p>

<p>SvUTF8 Returns a U32 value indicating whether the SV
contains UTF-8 encoded data. Call this after SvPV() in case
any call to string overloading updates the internal
flag.</p>

<p>U32 SvUTF8(SV* sv)</p>

<p>SvUTF8_off Unsets the UTF-8 status of an SV.</p>

<p>void SvUTF8_off(SV *sv)</p>

<p>SvUTF8_on Turn on the UTF-8 status of an SV (the data is
not changed, just the flag). Do not use frivolously.</p>

<p>void SvUTF8_on(SV *sv)</p>

<p>SvUV Coerces the given SV to an unsigned integer and
returns it. See &quot;SvUVx&quot; for a version which
guarantees to evaluate sv only once.</p>

<p>UV SvUV(SV* sv)</p>

<p>SvUVX Returns the raw value in the SVs UV slot, without
checks or conversions. Only use when you are sure SvIOK is
true. See also &quot;SvUV()&quot;.</p>

<p>UV SvUVX(SV* sv)</p>

<p>SvUVx Coerces the given SV to an unsigned integer and
returns it. Guarantees to &quot;sv&quot; only once. Only use
this if &quot;sv&quot; is an expression with side effects,
otherwise use the more efficient &quot;SvUV&quot;.</p>

<p>UV SvUVx(SV* sv)</p>

<p>SvUV_nomg Like &quot;SvUV&quot; but doesnt process
magic.</p>

<p>UV SvUV_nomg(SV* sv)</p>

<p>SvUV_set Set the value of the UV pointer in sv to val.
See &quot;SvIV_set&quot;.</p>

<p>void SvUV_set(SV* sv, UV val)</p>

<p>SvVOK Returns a boolean indicating whether the SV
contains a v-string.</p>

<p>bool SvVOK(SV* sv)</p>

<p>sv_catpvn_nomg Like &quot;sv_catpvn&quot; but doesnt
process magic.</p>

<p>void sv_catpvn_nomg(SV* sv, const char* ptr, STRLEN
len)</p>

<p>sv_catsv_nomg Like &quot;sv_catsv&quot; but doesnt
process magic.</p>

<p>void sv_catsv_nomg(SV* dsv, SV* ssv)</p>

<p>sv_derived_from Returns a boolean indicating whether the
SV is derived from the specified class at the C level. To
check derivation at the Perl level, call &quot;isa()&quot;
as a normal Perl method.</p>

<p>bool sv_derived_from(SV* sv, const char* name)</p>

<p>sv_does Returns a boolean indicating whether the SV
performs a specific, named role. The SV can be a Perl object
or the name of a Perl class.</p>

<p>bool sv_does(SV* sv, const char* name)</p>

<p>sv_report_used Dump the contents of all SVs not yet
freed. (Debugging aid).</p>

<p>void sv_report_used()</p>

<p>sv_setsv_nomg Like &quot;sv_setsv&quot; but doesnt
process magic.</p>

<p>void sv_setsv_nomg(SV* dsv, SV* ssv)</p>

<p>sv_utf8_upgrade_nomg Like sv_utf8_upgrade, but doesnt do
magic on &quot;sv&quot;</p>

<p>STRLEN sv_utf8_upgrade_nomg(NN SV *sv)</p>

<p>SV-Body Allocation looks_like_number Test if the content
of an SV looks like a number (or is a number).
&quot;Inf&quot; and &quot;Infinity&quot; are treated as
numbers (so will not issue a non-numeric warning), even if
your atof() doesnt grok them.</p>

<p>I32 looks_like_number(SV* sv)</p>

<p>newRV_noinc Creates an RV wrapper for an SV. The
reference count for the original SV is not incremented.</p>

<p>SV* newRV_noinc(SV* sv)</p>

<p>newSV Creates a new SV. A non-zero &quot;len&quot;
parameter indicates the number of bytes of preallocated
string space the SV should have. An extra byte for a
trailing NUL is also reserved. (SvPOK is not set for the SV
even if string space is allocated.) The reference count for
the new SV is set to 1.</p>

<p>In 5.9.3, newSV() replaces the older NEWSV() API, and
drops the first parameter, x, a debug aid which allowed
callers to identify themselves. This aid has been superseded
by a new build option, PERL_MEM_LOG (see
&quot;PERL_MEM_LOG&quot; in perlhack). The older API is
still there for use in XS modules supporting older
perls.</p>

<p>SV* newSV(STRLEN len)</p>

<p>newSVhek Creates a new SV from the hash key structure.
It will generate scalars that point to the shared string
table where possible. Returns a new (undefined) SV if the
hek is NULL.</p>

<p>SV* newSVhek(const HEK *hek)</p>

<p>newSViv Creates a new SV and copies an integer into it.
The reference count for the SV is set to 1.</p>

<p>SV* newSViv(IV i)</p>

<p>newSVnv Creates a new SV and copies a floating point
value into it. The reference count for the SV is set to
1.</p>

<p>SV* newSVnv(NV n)</p>

<p>newSVpv Creates a new SV and copies a string into it.
The reference count for the SV is set to 1. If
&quot;len&quot; is zero, Perl will compute the length using
strlen(). For efficiency, consider using
&quot;newSVpvn&quot; instead.</p>

<p>SV* newSVpv(const char* s, STRLEN len)</p>

<p>newSVpvf Creates a new SV and initializes it with the
string formatted like &quot;sprintf&quot;.</p>

<p>SV* newSVpvf(const char* pat, ...)</p>

<p>newSVpvn Creates a new SV and copies a string into it.
The reference count for the SV is set to 1. Note that if
&quot;len&quot; is zero, Perl will create a zero length
string. You are responsible for ensuring that the source
string is at least &quot;len&quot; bytes long. If the
&quot;s&quot; argument is NULL the new SV will be
undefined.</p>

<p>SV* newSVpvn(const char* s, STRLEN len)</p>

<p>newSVpvn_flags Creates a new SV and copies a string into
it. The reference count for the SV is set to 1. Note that if
&quot;len&quot; is zero, Perl will create a zero length
string. You are responsible for ensuring that the source
string is at least &quot;len&quot; bytes long. If the
&quot;s&quot; argument is NULL the new SV will be undefined.
Currently the only flag bits accepted are
&quot;SVf_UTF8&quot; and &quot;SVs_TEMP&quot;. If
&quot;SVs_TEMP&quot; is set, then &quot;sv2mortal()&quot; is
called on the result before returning. If
&quot;SVf_UTF8&quot; is set, then it will be set on the new
SV. &quot;newSVpvn_utf8()&quot; is a convenience wrapper for
this function, defined as</p>

<p>#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s),
(len), (u) ? SVf_UTF8 : 0)</p>

<p>SV* newSVpvn_flags(const char* s, STRLEN len, U32
flags)</p>

<p>newSVpvn_share Creates a new SV with its SvPVX_const
pointing to a shared string in the string table. If the
string does not already exist in the table, it is created
first. Turns on READONLY and FAKE. If the &quot;hash&quot;
parameter is non-zero, that value is used; otherwise the
hash is computed. The strings hash can be later be retrieved
from the SV with the &quot;SvSHARED_HASH()&quot; macro. The
idea here is that as the string table is used for shared
hash keys these strings will have SvPVX_const == HeKEY and
hash lookup will avoid string compare.</p>

<p>SV* newSVpvn_share(const char* s, I32 len, U32 hash)</p>

<p>newSVpvs Like &quot;newSVpvn&quot;, but takes a literal
string instead of a string/length pair.</p>

<p>SV* newSVpvs(const char* s)</p>

<p>newSVpvs_flags Like &quot;newSVpvn_flags&quot;, but
takes a literal string instead of a string/length pair.</p>

<p>SV* newSVpvs_flags(const char* s, U32 flags)</p>

<p>newSVpvs_share Like &quot;newSVpvn_share&quot;, but
takes a literal string instead of a string/length pair and
omits the hash parameter.</p>

<p>SV* newSVpvs_share(const char* s)</p>

<p>newSVrv Creates a new SV for the RV, &quot;rv&quot;, to
point to. If &quot;rv&quot; is not an RV then it will be
upgraded to one. If &quot;classname&quot; is non- null then
the new SV will be blessed in the specified package. The new
SV is returned and its reference count is 1.</p>

<p>SV* newSVrv(SV* rv, const char* classname)</p>

<p>newSVsv Creates a new SV which is an exact duplicate of
the original SV. (Uses &quot;sv_setsv&quot;).</p>

<p>SV* newSVsv(SV* old)</p>

<p>newSVuv Creates a new SV and copies an unsigned integer
into it. The reference count for the SV is set to 1.</p>

<p>SV* newSVuv(UV u)</p>

<p>newSV_type Creates a new SV, of the type specified. The
reference count for the new SV is set to 1.</p>

<p>SV* newSV_type(svtype type)</p>

<p>sv_2bool This function is only called on magical items,
and is only used by sv_true() or its macro equivalent.</p>

<p>bool sv_2bool(SV* sv)</p>

<p>sv_2cv Using various gambits, try to get a CV from an
SV; in addition, try if possible to set *st and *gvp to the
stash and GV associated with it. The flags in
&quot;lref&quot; are passed to sv_fetchsv.</p>

<p>CV* sv_2cv(SV* sv, HV** st, GV** gvp, I32 lref)</p>

<p>sv_2io Using various gambits, try to get an IO from an
SV: the IO slot if its a GV; or the recursive result if we
re an RV; or the IO slot of the symbol named after the PV if
were a string.</p>

<p>IO* sv_2io(SV* sv)</p>

<p>sv_2iv_flags Return the integer value of an SV, doing
any necessary string conversion. If flags includes
SV_GMAGIC, does an mg_get() first. Normally used via the
&quot;SvIV(sv)&quot; and &quot;SvIVx(sv)&quot; macros.</p>

<p>IV sv_2iv_flags(SV* sv, I32 flags)</p>

<p>sv_2mortal Marks an existing SV as mortal. The SV will
be destroyed &quot;soon&quot;, either by an explicit call to
FREETMPS, or by an implicit call at places such as statement
boundaries. SvTEMP() is turned on which means that the SV s
string buffer can be &quot;stolen&quot; if this SV is
copied. See also &quot;sv_newmortal&quot; and
&quot;sv_mortalcopy&quot;.</p>

<p>SV* sv_2mortal(SV* sv)</p>

<p>sv_2nv Return the num value of an SV, doing any
necessary string or integer conversion, magic etc. Normally
used via the &quot;SvNV(sv)&quot; and &quot;SvNVx(sv)&quot;
macros.</p>

<p>NV sv_2nv(SV* sv)</p>

<p>sv_2pvbyte Return a pointer to the byte-encoded
representation of the SV, and set *lp to its length. May
cause the SV to be downgraded from UTF-8 as a
side-effect.</p>

<p>Usually accessed via the &quot;SvPVbyte&quot; macro.</p>

<p>char* sv_2pvbyte(SV* sv, STRLEN* lp)</p>

<p>sv_2pvutf8 Return a pointer to the UTF-8-encoded
representation of the SV, and set *lp to its length. May
cause the SV to be upgraded to UTF-8 as a side-effect.</p>

<p>Usually accessed via the &quot;SvPVutf8&quot; macro.</p>

<p>char* sv_2pvutf8(SV* sv, STRLEN* lp)</p>

<p>sv_2pv_flags Returns a pointer to the string value of an
SV, and sets *lp to its length. If flags includes SV_GMAGIC,
does an mg_get() first. Coerces sv to a string if necessary.
Normally invoked via the &quot;SvPV_flags&quot; macro.
&quot;sv_2pv()&quot; and &quot;sv_2pv_nomg&quot; usually end
up here too.</p>

<p>char* sv_2pv_flags(SV* sv, STRLEN* lp, I32 flags)</p>

<p>sv_2uv_flags Return the unsigned integer value of an SV,
doing any necessary string conversion. If flags includes
SV_GMAGIC, does an mg_get() first. Normally used via the
&quot;SvUV(sv)&quot; and &quot;SvUVx(sv)&quot; macros.</p>

<p>UV sv_2uv_flags(SV* sv, I32 flags)</p>

<p>sv_backoff Remove any string offset. You should normally
use the &quot;SvOOK_off&quot; macro wrapper instead.</p>

<p>int sv_backoff(SV* sv)</p>

<p>sv_bless Blesses an SV into a specified package. The SV
must be an RV. The package must be designated by its stash
(see &quot;gv_stashpv()&quot;). The reference count of the
SV is unaffected.</p>

<p>SV* sv_bless(SV* sv, HV* stash)</p>

<p>sv_catpv Concatenates the string onto the end of the
string which is in the SV. If the SV has the UTF-8 status
set, then the bytes appended should be valid UTF-8. Handles
get magic, but not set magic. See
&quot;sv_catpv_mg&quot;.</p>

<p>void sv_catpv(SV* sv, const char* ptr)</p>

<p>sv_catpvf Processes its arguments like
&quot;sprintf&quot; and appends the formatted output to an
SV. If the appended data contains &quot;wide&quot;
characters (including, but not limited to, SVs with a UTF-8
PV formatted with %s, and characters &gt;255 formatted with
%c), the original SV might get upgraded to UTF-8. Handles
get magic, but not set magic. See &quot;sv_catpvf_mg&quot;.
If the original SV was UTF-8, the pattern should be valid
UTF-8; if the original SV was bytes, the pattern should be
too.</p>

<p>void sv_catpvf(SV* sv, const char* pat, ...)</p>

<p>sv_catpvf_mg Like &quot;sv_catpvf&quot;, but also
handles set magic.</p>

<p>void sv_catpvf_mg(SV *sv, const char* pat, ...)</p>

<p>sv_catpvn Concatenates the string onto the end of the
string which is in the SV. The &quot;len&quot; indicates
number of bytes to copy. If the SV has the UTF-8 status set,
then the bytes appended should be valid UTF-8. Handles get
magic, but not set magic. See &quot;sv_catpvn_mg&quot;.</p>

<p>void sv_catpvn(SV *dsv, const char *sstr, STRLEN
len)</p>

<p>sv_catpvn_flags Concatenates the string onto the end of
the string which is in the SV. The &quot;len&quot; indicates
number of bytes to copy. If the SV has the UTF-8 status set,
then the bytes appended should be valid UTF-8. If
&quot;flags&quot; has &quot;SV_GMAGIC&quot; bit set, will
&quot;mg_get&quot; on &quot;dsv&quot; if appropriate, else
not. &quot;sv_catpvn&quot; and &quot;sv_catpvn_nomg&quot;
are implemented in terms of this function.</p>

<p>void sv_catpvn_flags(SV *dstr, const char *sstr, STRLEN
len, I32 flags)</p>

<p>sv_catpvs Like &quot;sv_catpvn&quot;, but takes a
literal string instead of a string/length pair.</p>

<p>void sv_catpvs(SV* sv, const char* s)</p>

<p>sv_catpv_mg Like &quot;sv_catpv&quot;, but also handles
set magic.</p>

<p>void sv_catpv_mg(SV *sv, const char *ptr)</p>

<p>sv_catsv Concatenates the string from SV &quot;ssv&quot;
onto the end of the string in SV &quot;dsv&quot;. Modifies
&quot;dsv&quot; but not &quot;ssv&quot;. Handles get magic,
but not set magic. See &quot;sv_catsv_mg&quot;.</p>

<p>void sv_catsv(SV *dstr, SV *sstr)</p>

<p>sv_catsv_flags Concatenates the string from SV
&quot;ssv&quot; onto the end of the string in SV
&quot;dsv&quot;. Modifies &quot;dsv&quot; but not
&quot;ssv&quot;. If &quot;flags&quot; has
&quot;SV_GMAGIC&quot; bit set, will &quot;mg_get&quot; on
the SVs if appropriate, else not. &quot;sv_catsv&quot; and
&quot;sv_catsv_nomg&quot; are implemented in terms of this
function.</p>

<p>void sv_catsv_flags(SV* dsv, SV* ssv, I32 flags)</p>

<p>sv_chop Efficient removal of characters from the
beginning of the string buffer. SvPOK(sv) must be true and
the &quot;ptr&quot; must be a pointer to somewhere inside
the string buffer. The &quot;ptr&quot; becomes the first
character of the adjusted string. Uses the &quot;OOK
hack&quot;. Beware: after this function returns,
&quot;ptr&quot; and SvPVX_const(sv) may no longer refer to
the same chunk of data.</p>

<p>void sv_chop(SV* sv, const char* ptr)</p>

<p>sv_clear Clear an SV: call any destructors, free up any
memory used by the body, and free the body itself. The SVs
head is not freed, although its type is set to all 1s so
that it wont inadvertently be assumed to be live during
global destruction etc. This function should only be called
when REFCNT is zero. Most of the time youll want to call
&quot;sv_free()&quot; (or its macro wrapper
&quot;SvREFCNT_dec&quot;) instead.</p>

<p>void sv_clear(SV* sv)</p>

<p>sv_cmp Compares the strings in two SVs. Returns -1, 0,
or 1 indicating whether the string in &quot;sv1&quot; is
less than, equal to, or greater than the string in
&quot;sv2&quot;. Is UTF-8 and use bytes aware, handles get
magic, and will coerce its args to strings if necessary. See
also &quot;sv_cmp_locale&quot;.</p>

<p>I32 sv_cmp(SV* sv1, SV* sv2)</p>

<p>sv_cmp_locale Compares the strings in two SVs in a
locale-aware manner. Is UTF-8 and use bytes aware, handles
get magic, and will coerce its args to strings if necessary.
See also &quot;sv_cmp&quot;.</p>

<p>I32 sv_cmp_locale(SV* sv1, SV* sv2)</p>

<p>sv_collxfrm Add Collate Transform magic to an SV if it
doesnt already have it.</p>

<p>Any scalar variable may carry PERL_MAGIC_collxfrm magic
that contains the scalar data of the variable, but
transformed to such a format that a normal memory comparison
can be used to compare the data according to the locale
settings.</p>

<p>char* sv_collxfrm(SV* sv, STRLEN* nxp)</p>

<p>sv_copypv Copies a stringified representation of the
source SV into the destination SV. Automatically performs
any necessary mg_get and coercion of numeric values into
strings. Guaranteed to preserve UTF8 flag even from
overloaded objects. Similar in nature to sv_2pv[_flags] but
operates directly on an SV instead of just the string.
Mostly uses sv_2pv_flags to do its work, except when that
would lose the UTF-8ness of the PV.</p>

<p>void sv_copypv(SV* dsv, SV* ssv)</p>

<p>sv_dec Auto-decrement of the value in the SV, doing
string to numeric conversion if necessary. Handles get
magic.</p>

<p>void sv_dec(SV* sv)</p>

<p>sv_eq Returns a boolean indicating whether the strings
in the two SVs are identical. Is UTF-8 and use bytes aware,
handles get magic, and will coerce its args to strings if
necessary.</p>

<p>I32 sv_eq(SV* sv1, SV* sv2)</p>

<p>sv_force_normal_flags Undo various types of fakery on an
SV: if the PV is a shared string, make a private copy; if
were a ref, stop refing; if we re a glob, downgrade to an
xpvmg; if were a copy-on-write scalar, this is the on-write
time when we do the copy, and is also used locally. If
&quot;SV_COW_DROP_PV&quot; is set then a copy-on- write
scalar drops its PV buffer (if any) and becomes SvPOK_off
rather than making a copy. (Used where this scalar is about
to be set to some other value.) In addition, the
&quot;flags&quot; parameter gets passed to
&quot;sv_unref_flags()&quot; when unrefing.
&quot;sv_force_normal&quot; calls this function with flags
set to 0.</p>

<p>void sv_force_normal_flags(SV *sv, U32 flags)</p>

<p>sv_free Decrement an SVs reference count, and if it
drops to zero, call &quot;sv_clear&quot; to invoke
destructors and free up any memory used by the body;
finally, deallocate the SVs head itself. Normally called via
a wrapper macro &quot;SvREFCNT_dec&quot;.</p>

<p>void sv_free(SV* sv)</p>

<p>sv_gets Get a line from the filehandle and store it into
the SV, optionally appending to the currently-stored
string.</p>

<p>char* sv_gets(SV* sv, PerlIO* fp, I32 append)</p>

<p>sv_grow Expands the character buffer in the SV. If
necessary, uses &quot;sv_unref&quot; and upgrades the SV to
&quot;SVt_PV&quot;. Returns a pointer to the character
buffer. Use the &quot;SvGROW&quot; wrapper instead.</p>

<p>char* sv_grow(SV* sv, STRLEN newlen)</p>

<p>sv_inc Auto-increment of the value in the SV, doing
string to numeric conversion if necessary. Handles get
magic.</p>

<p>void sv_inc(SV* sv)</p>

<p>sv_insert Inserts a string at the specified
offset/length within the SV. Similar to the Perl substr()
function. Handles get magic.</p>

<p>void sv_insert(SV *bigstr, STRLEN offset, STRLEN len,
const char *little, STRLEN littlelen)</p>

<p>sv_insert_flags Same as &quot;sv_insert&quot;, but the
extra &quot;flags&quot; are passed the
&quot;SvPV_force_flags&quot; that applies to
&quot;bigstr&quot;.</p>

<p>void sv_insert_flags(SV *const bigstr, const STRLEN
offset, const STRLEN len, const char *const little, const
STRLEN littlelen, const U32 flags)</p>

<p>sv_isa Returns a boolean indicating whether the SV is
blessed into the specified class. This does not check for
subtypes; use &quot;sv_derived_from&quot; to verify an
inheritance relationship.</p>

<p>int sv_isa(SV* sv, const char* name)</p>

<p>sv_isobject Returns a boolean indicating whether the SV
is an RV pointing to a blessed object. If the SV is not an
RV, or if the object is not blessed, then this will return
false.</p>

<p>int sv_isobject(SV* sv)</p>

<p>sv_len Returns the length of the string in the SV.
Handles magic and type coercion. See also &quot;SvCUR&quot;,
which gives raw access to the xpv_cur slot.</p>

<p>STRLEN sv_len(SV* sv)</p>

<p>sv_len_utf8 Returns the number of characters in the
string in an SV, counting wide UTF-8 bytes as a single
character. Handles magic and type coercion.</p>

<p>STRLEN sv_len_utf8(SV* sv)</p>

<p>sv_magic Adds magic to an SV. First upgrades
&quot;sv&quot; to type &quot;SVt_PVMG&quot; if necessary,
then adds a new magic item of type &quot;how&quot; to the
head of the magic list.</p>

<p>See &quot;sv_magicext&quot; (which &quot;sv_magic&quot;
now calls) for a description of the handling of the
&quot;name&quot; and &quot;namlen&quot; arguments.</p>

<p>You need to use &quot;sv_magicext&quot; to add magic to
SvREADONLY SVs and also to add more than one instance of the
same how.</p>

<p>void sv_magic(SV* sv, SV* obj, int how, const char*
name, I32 namlen)</p>

<p>sv_magicext Adds magic to an SV, upgrading it if
necessary. Applies the supplied vtable and returns a pointer
to the magic added.</p>

<p>Note that &quot;sv_magicext&quot; will allow things that
&quot;sv_magic&quot; will not. In particular, you can add
magic to SvREADONLY SVs, and add more than one instance of
the same how.</p>

<p>If &quot;namlen&quot; is greater than zero then a
&quot;savepvn&quot; copy of &quot;name&quot; is stored, if
&quot;namlen&quot; is zero then &quot;name&quot; is stored
as- is and - as another special case - if &quot;(name
&amp;&amp; namlen == HEf_SVKEY)&quot; then &quot;name&quot;
is assumed to contain an &quot;SV*&quot; and is stored as-is
with its REFCNT incremented.</p>

<p>(This is now used as a subroutine by
&quot;sv_magic&quot;.)</p>

<p>MAGIC * sv_magicext(SV* sv, SV* obj, int how, const
MGVTBL *vtbl, const char* name, I32 namlen)</p>

<p>sv_mortalcopy Creates a new SV which is a copy of the
original SV (using &quot;sv_setsv&quot;). The new SV is
marked as mortal. It will be destroyed &quot;soon&quot;,
either by an explicit call to FREETMPS, or by an implicit
call at places such as statement boundaries. See also
&quot;sv_newmortal&quot; and &quot;sv_2mortal&quot;.</p>

<p>SV* sv_mortalcopy(SV* oldsv)</p>

<p>sv_newmortal Creates a new null SV which is mortal. The
reference count of the SV is set to 1. It will be destroyed
&quot;soon&quot;, either by an explicit call to FREETMPS, or
by an implicit call at places such as statement boundaries.
See also &quot;sv_mortalcopy&quot; and
&quot;sv_2mortal&quot;.</p>

<p>SV* sv_newmortal()</p>

<p>sv_newref Increment an SV s reference count. Use the
&quot;SvREFCNT_inc()&quot; wrapper instead.</p>

<p>SV* sv_newref(SV* sv)</p>

<p>sv_pos_b2u Converts the value pointed to by offsetp from
a count of bytes from the start of the string, to a count of
the equivalent number of UTF-8 chars. Handles magic and type
coercion.</p>

<p>void sv_pos_b2u(SV* sv, I32* offsetp)</p>

<p>sv_pos_u2b Converts the value pointed to by offsetp from
a count of UTF-8 chars from the start of the string, to a
count of the equivalent number of bytes; if lenp is
non-zero, it does the same to lenp, but this time starting
from the offset, rather than from the start of the string.
Handles magic and type coercion.</p>

<p>void sv_pos_u2b(SV* sv, I32* offsetp, I32* lenp)</p>

<p>sv_pvbyten_force The backend for the
&quot;SvPVbytex_force&quot; macro. Always use the macro
instead.</p>

<p>char* sv_pvbyten_force(SV* sv, STRLEN* lp)</p>

<p>sv_pvn_force Get a sensible string out of the SV
somehow. A private implementation of the
&quot;SvPV_force&quot; macro for compilers which cant cope
with complex macro expressions. Always use the macro
instead.</p>

<p>char* sv_pvn_force(SV* sv, STRLEN* lp)</p>

<p>sv_pvn_force_flags Get a sensible string out of the SV
somehow. If &quot;flags&quot; has &quot;SV_GMAGIC&quot; bit
set, will &quot;mg_get&quot; on &quot;sv&quot; if
appropriate, else not. &quot;sv_pvn_force&quot; and
&quot;sv_pvn_force_nomg&quot; are implemented in terms of
this function. You normally want to use the various wrapper
macros instead: see &quot;SvPV_force&quot; and
&quot;SvPV_force_nomg&quot;</p>

<p>char* sv_pvn_force_flags(SV* sv, STRLEN* lp, I32
flags)</p>

<p>sv_pvutf8n_force The backend for the
&quot;SvPVutf8x_force&quot; macro. Always use the macro
instead.</p>

<p>char* sv_pvutf8n_force(SV* sv, STRLEN* lp)</p>

<p>sv_reftype Returns a string describing what the SV is a
reference to.</p>

<p>const char* sv_reftype(const SV* sv, int ob)</p>

<p>sv_replace Make the first argument a copy of the second,
then delete the original. The target SV physically takes
over ownership of the body of the source SV and inherits its
flags; however, the target keeps any magic it owns, and any
magic in the source is discarded. Note that this is a rather
specialist SV copying operation; most of the time you ll
want to use &quot;sv_setsv&quot; or one of its many macro
front-ends.</p>

<p>void sv_replace(SV* sv, SV* nsv)</p>

<p>sv_reset Underlying implementation for the
&quot;reset&quot; Perl function. Note that the perl-level
function is vaguely deprecated.</p>

<p>void sv_reset(const char* s, HV* stash)</p>

<p>sv_rvweaken Weaken a reference: set the
&quot;SvWEAKREF&quot; flag on this RV; give the referred-to
SV &quot;PERL_MAGIC_backref&quot; magic if it hasnt already;
and push a back-reference to this RV onto the array of
backreferences associated with that magic. If the RV is
magical, set magic will be called after the RV is
cleared.</p>

<p>SV* sv_rvweaken(SV *sv)</p>

<p>sv_setiv Copies an integer into the given SV, upgrading
first if necessary. Does not handle set magic. See also
&quot;sv_setiv_mg&quot;.</p>

<p>void sv_setiv(SV* sv, IV num)</p>

<p>sv_setiv_mg Like &quot;sv_setiv&quot;, but also handles
set magic.</p>

<p>void sv_setiv_mg(SV *sv, IV i)</p>

<p>sv_setnv Copies a double into the given SV, upgrading
first if necessary. Does not handle set magic. See also
&quot;sv_setnv_mg&quot;.</p>

<p>void sv_setnv(SV* sv, NV num)</p>

<p>sv_setnv_mg Like &quot;sv_setnv&quot;, but also handles
set magic.</p>

<p>void sv_setnv_mg(SV *sv, NV num)</p>

<p>sv_setpv Copies a string into an SV. The string must be
null- terminated. Does not handle set magic. See
&quot;sv_setpv_mg&quot;.</p>

<p>void sv_setpv(SV* sv, const char* ptr)</p>

<p>sv_setpvf Works like &quot;sv_catpvf&quot; but copies
the text into the SV instead of appending it. Does not
handle set magic. See &quot;sv_setpvf_mg&quot;.</p>

<p>void sv_setpvf(SV* sv, const char* pat, ...)</p>

<p>sv_setpvf_mg Like &quot;sv_setpvf&quot;, but also
handles set magic.</p>

<p>void sv_setpvf_mg(SV *sv, const char* pat, ...)</p>

<p>sv_setpviv Copies an integer into the given SV, also
updating its string value. Does not handle set magic. See
&quot;sv_setpviv_mg&quot;.</p>

<p>void sv_setpviv(SV* sv, IV num)</p>

<p>sv_setpviv_mg Like &quot;sv_setpviv&quot;, but also
handles set magic.</p>

<p>void sv_setpviv_mg(SV *sv, IV iv)</p>

<p>sv_setpvn Copies a string into an SV. The
&quot;len&quot; parameter indicates the number of bytes to
be copied. If the &quot;ptr&quot; argument is NULL the SV
will become undefined. Does not handle set magic. See
&quot;sv_setpvn_mg&quot;.</p>

<p>void sv_setpvn(SV* sv, const char* ptr, STRLEN len)</p>

<p>sv_setpvn_mg Like &quot;sv_setpvn&quot;, but also
handles set magic.</p>

<p>void sv_setpvn_mg(SV *sv, const char *ptr, STRLEN
len)</p>

<p>sv_setpvs Like &quot;sv_setpvn&quot;, but takes a
literal string instead of a string/length pair.</p>

<p>void sv_setpvs(SV* sv, const char* s)</p>

<p>sv_setpv_mg Like &quot;sv_setpv&quot;, but also handles
set magic.</p>

<p>void sv_setpv_mg(SV *sv, const char *ptr)</p>

<p>sv_setref_iv Copies an integer into a new SV, optionally
blessing the SV. The &quot;rv&quot; argument will be
upgraded to an RV. That RV will be modified to point to the
new SV. The &quot;classname&quot; argument indicates the
package for the blessing. Set &quot;classname&quot; to
&quot;NULL&quot; to avoid the blessing. The new SV will have
a reference count of 1, and the RV will be returned.</p>

<p>SV* sv_setref_iv(SV* rv, const char* classname, IV
iv)</p>

<p>sv_setref_nv Copies a double into a new SV, optionally
blessing the SV. The &quot;rv&quot; argument will be
upgraded to an RV. That RV will be modified to point to the
new SV. The &quot;classname&quot; argument indicates the
package for the blessing. Set &quot;classname&quot; to
&quot;NULL&quot; to avoid the blessing. The new SV will have
a reference count of 1, and the RV will be returned.</p>

<p>SV* sv_setref_nv(SV* rv, const char* classname, NV
nv)</p>

<p>sv_setref_pv Copies a pointer into a new SV, optionally
blessing the SV. The &quot;rv&quot; argument will be
upgraded to an RV. That RV will be modified to point to the
new SV. If the &quot;pv&quot; argument is NULL then
&quot;PL_sv_undef&quot; will be placed into the SV. The
&quot;classname&quot; argument indicates the package for the
blessing. Set &quot;classname&quot; to &quot;NULL&quot; to
avoid the blessing. The new SV will have a reference count
of 1, and the RV will be returned.</p>

<p>Do not use with other Perl types such as HV, AV, SV, CV,
because those objects will become corrupted by the pointer
copy process.</p>

<p>Note that &quot;sv_setref_pvn&quot; copies the string
while this copies the pointer.</p>

<p>SV* sv_setref_pv(SV* rv, const char* classname, void*
pv)</p>

<p>sv_setref_pvn Copies a string into a new SV, optionally
blessing the SV. The length of the string must be specified
with &quot;n&quot;. The &quot;rv&quot; argument will be
upgraded to an RV. That RV will be modified to point to the
new SV. The &quot;classname&quot; argument indicates the
package for the blessing. Set &quot;classname&quot; to
&quot;NULL&quot; to avoid the blessing. The new SV will have
a reference count of 1, and the RV will be returned.</p>

<p>Note that &quot;sv_setref_pv&quot; copies the pointer
while this copies the string.</p>

<p>SV* sv_setref_pvn(SV* rv, const char* classname, const
char* pv, STRLEN n)</p>

<p>sv_setref_uv Copies an unsigned integer into a new SV,
optionally blessing the SV. The &quot;rv&quot; argument will
be upgraded to an RV. That RV will be modified to point to
the new SV. The &quot;classname&quot; argument indicates the
package for the blessing. Set &quot;classname&quot; to
&quot;NULL&quot; to avoid the blessing. The new SV will have
a reference count of 1, and the RV will be returned.</p>

<p>SV* sv_setref_uv(SV* rv, const char* classname, UV
uv)</p>

<p>sv_setsv Copies the contents of the source SV
&quot;ssv&quot; into the destination SV &quot;dsv&quot;. The
source SV may be destroyed if it is mortal, so don t use
this function if the source SV needs to be reused. Does not
handle set magic. Loosely speaking, it performs a
copy-by-value, obliterating any previous content of the
destination.</p>

<p>You probably want to use one of the assortment of
wrappers, such as &quot;SvSetSV&quot;,
&quot;SvSetSV_nosteal&quot;, &quot;SvSetMagicSV&quot; and
&quot;SvSetMagicSV_nosteal&quot;.</p>

<p>void sv_setsv(SV *dstr, SV *sstr)</p>

<p>sv_setsv_flags Copies the contents of the source SV
&quot;ssv&quot; into the destination SV &quot;dsv&quot;. The
source SV may be destroyed if it is mortal, so dont use this
function if the source SV needs to be reused. Does not
handle set magic. Loosely speaking, it performs a
copy-by-value, obliterating any previous content of the
destination. If the &quot;flags&quot; parameter has the
&quot;SV_GMAGIC&quot; bit set, will &quot;mg_get&quot; on
&quot;ssv&quot; if appropriate, else not. If the
&quot;flags&quot; parameter has the &quot;NOSTEAL&quot; bit
set then the buffers of temps will not be stolen.
&lt;sv_setsv&gt; and &quot;sv_setsv_nomg&quot; are
implemented in terms of this function.</p>

<p>You probably want to use one of the assortment of
wrappers, such as &quot;SvSetSV&quot;,
&quot;SvSetSV_nosteal&quot;, &quot;SvSetMagicSV&quot; and
&quot;SvSetMagicSV_nosteal&quot;.</p>

<p>This is the primary function for copying scalars, and
most other copy-ish functions and macros use this
underneath.</p>

<p>void sv_setsv_flags(SV *dstr, SV *sstr, I32 flags)</p>

<p>sv_setsv_mg Like &quot;sv_setsv&quot;, but also handles
set magic.</p>

<p>void sv_setsv_mg(SV *dstr, SV *sstr)</p>

<p>sv_setuv Copies an unsigned integer into the given SV,
upgrading first if necessary. Does not handle set magic. See
also &quot;sv_setuv_mg&quot;.</p>

<p>void sv_setuv(SV* sv, UV num)</p>

<p>sv_setuv_mg Like &quot;sv_setuv&quot;, but also handles
set magic.</p>

<p>void sv_setuv_mg(SV *sv, UV u)</p>

<p>sv_tainted Test an SV for taintedness. Use
&quot;SvTAINTED&quot; instead. bool sv_tainted(SV* sv)</p>

<p>sv_true Returns true if the SV has a true value by Perls
rules. Use the &quot;SvTRUE&quot; macro instead, which may
call &quot;sv_true()&quot; or may instead use an in-line
version.</p>

<p>I32 sv_true(SV *sv)</p>

<p>sv_unmagic Removes all magic of type &quot;type&quot;
from an SV.</p>

<p>int sv_unmagic(SV* sv, int type)</p>

<p>sv_unref_flags Unsets the RV status of the SV, and
decrements the reference count of whatever was being
referenced by the RV. This can almost be thought of as a
reversal of &quot;newSVrv&quot;. The &quot;cflags&quot;
argument can contain &quot;SV_IMMEDIATE_UNREF&quot; to force
the reference count to be decremented (otherwise the
decrementing is conditional on the reference count being
different from one or the reference being a readonly SV).
See &quot;SvROK_off&quot;.</p>

<p>void sv_unref_flags(SV *ref, U32 flags)</p>

<p>sv_untaint Untaint an SV. Use &quot;SvTAINTED_off&quot;
instead. void sv_untaint(SV* sv)</p>

<p>sv_upgrade Upgrade an SV to a more complex form.
Generally adds a new body type to the SV, then copies across
as much information as possible from the old body. You
generally want to use the &quot;SvUPGRADE&quot; macro
wrapper. See also &quot;svtype&quot;.</p>

<p>void sv_upgrade(SV* sv, svtype new_type)</p>

<p>sv_usepvn_flags Tells an SV to use &quot;ptr&quot; to
find its string value. Normally the string is stored inside
the SV but sv_usepvn allows the SV to use an outside string.
The &quot;ptr&quot; should point to memory that was
allocated by &quot;malloc&quot;. The string length,
&quot;len&quot;, must be supplied. By default this function
will realloc (i.e. move) the memory pointed to by
&quot;ptr&quot;, so that pointer should not be freed or used
by the programmer after giving it to sv_usepvn, and neither
should any pointers from &quot;behind&quot; that pointer
(e.g. ptr + 1) be used.</p>

<p>If &quot;flags&quot; &amp; SV_SMAGIC is true, will call
SvSETMAGIC. If &quot;flags&quot; &amp; SV_HAS_TRAILING_NUL
is true, then &quot;ptr[len]&quot; must be NUL, and the
realloc will be skipped. (i.e. the buffer is actually at
least 1 byte longer than &quot;len&quot;, and already meets
the requirements for storing in &quot;SvPVX&quot;)</p>

<p>void sv_usepvn_flags(SV* sv, char* ptr, STRLEN len, U32
flags)</p>

<p>sv_utf8_decode If the PV of the SV is an octet sequence
in UTF-8 and contains a multiple-byte character, the
&quot;SvUTF8&quot; flag is turned on so that it looks like a
character. If the PV contains only single- byte characters,
the &quot;SvUTF8&quot; flag stays being off. Scans PV for
validity and returns false if the PV is invalid UTF-8.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>bool sv_utf8_decode(SV *sv)</p>

<p>sv_utf8_downgrade Attempts to convert the PV of an SV
from characters to bytes. If the PV contains a character
that cannot fit in a byte, this conversion will fail; in
this case, either returns false or, if &quot;fail_ok&quot;
is not true, croaks.</p>

<p>This is not as a general purpose Unicode to byte
encoding interface: use the Encode extension for that.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>bool sv_utf8_downgrade(SV *sv, bool fail_ok)</p>

<p>sv_utf8_encode Converts the PV of an SV to UTF-8, but
then turns the &quot;SvUTF8&quot; flag off so that it looks
like octets again.</p>

<p>void sv_utf8_encode(SV *sv)</p>

<p>sv_utf8_upgrade Converts the PV of an SV to its
UTF-8-encoded form. Forces the SV to string form if it is
not already. Will &quot;mg_get&quot; on &quot;sv&quot; if
appropriate. Always sets the SvUTF8 flag to avoid future
validity checks even if the whole string is the same in
UTF-8 as not. Returns the number of bytes in the converted
string</p>

<p>This is not as a general purpose byte encoding to
Unicode interface: use the Encode extension for that.</p>

<p>STRLEN sv_utf8_upgrade(SV *sv)</p>

<p>sv_utf8_upgrade_flags Converts the PV of an SV to its
UTF-8-encoded form. Forces the SV to string form if it is
not already. Always sets the SvUTF8 flag to avoid future
validity checks even if all the bytes are invariant in
UTF-8. If &quot;flags&quot; has &quot;SV_GMAGIC&quot; bit
set, will &quot;mg_get&quot; on &quot;sv&quot; if
appropriate, else not. Returns the number of bytes in the
converted string &quot;sv_utf8_upgrade&quot; and
&quot;sv_utf8_upgrade_nomg&quot; are implemented in terms of
this function.</p>

<p>This is not as a general purpose byte encoding to
Unicode interface: use the Encode extension for that.</p>

<p>STRLEN sv_utf8_upgrade_flags(SV *sv, I32 flags)</p>

<p>sv_utf8_upgrade_nomg Like sv_utf8_upgrade, but doesnt do
magic on &quot;sv&quot;</p>

<p>STRLEN sv_utf8_upgrade_nomg(SV *sv)</p>

<p>sv_vcatpvf Processes its arguments like
&quot;vsprintf&quot; and appends the formatted output to an
SV. Does not handle set magic. See
&quot;sv_vcatpvf_mg&quot;.</p>

<p>Usually used via its frontend &quot;sv_catpvf&quot;.</p>

<p>void sv_vcatpvf(SV* sv, const char* pat, va_list*
args)</p>

<p>sv_vcatpvfn Processes its arguments like
&quot;vsprintf&quot; and appends the formatted output to an
SV. Uses an array of SVs if the C style variable argument
list is missing (NULL). When running with taint checks
enabled, indicates via &quot;maybe_tainted&quot; if results
are untrustworthy (often due to the use of locales).</p>

<p>Usually used via one of its frontends
&quot;sv_vcatpvf&quot; and &quot;sv_vcatpvf_mg&quot;.</p>

<p>void sv_vcatpvfn(SV* sv, const char* pat, STRLEN patlen,
va_list* args, SV** svargs, I32 svmax, bool
*maybe_tainted)</p>

<p>sv_vcatpvf_mg Like &quot;sv_vcatpvf&quot;, but also
handles set magic.</p>

<p>Usually used via its frontend
&quot;sv_catpvf_mg&quot;.</p>

<p>void sv_vcatpvf_mg(SV* sv, const char* pat, va_list*
args)</p>

<p>sv_vsetpvf Works like &quot;sv_vcatpvf&quot; but copies
the text into the SV instead of appending it. Does not
handle set magic. See &quot;sv_vsetpvf_mg&quot;.</p>

<p>Usually used via its frontend &quot;sv_setpvf&quot;.</p>

<p>void sv_vsetpvf(SV* sv, const char* pat, va_list*
args)</p>

<p>sv_vsetpvfn Works like &quot;sv_vcatpvfn&quot; but
copies the text into the SV instead of appending it.</p>

<p>Usually used via one of its frontends
&quot;sv_vsetpvf&quot; and &quot;sv_vsetpvf_mg&quot;.</p>

<p>void sv_vsetpvfn(SV* sv, const char* pat, STRLEN patlen,
va_list* args, SV** svargs, I32 svmax, bool
*maybe_tainted)</p>

<p>sv_vsetpvf_mg Like &quot;sv_vsetpvf&quot;, but also
handles set magic.</p>

<p>Usually used via its frontend
&quot;sv_setpvf_mg&quot;.</p>

<p>void sv_vsetpvf_mg(SV* sv, const char* pat, va_list*
args)</p>

<p>Unicode Support bytes_from_utf8 Converts a string
&quot;s&quot; of length &quot;len&quot; from UTF-8 into
native byte encoding. Unlike &quot;utf8_to_bytes&quot; but
like &quot;bytes_to_utf8&quot;, returns a pointer to the
newly-created string, and updates &quot;len&quot; to contain
the new length. Returns the original string if no conversion
occurs, &quot;len&quot; is unchanged. Do nothing if
&quot;is_utf8&quot; points to 0. Sets &quot;is_utf8&quot; to
0 if &quot;s&quot; is converted or consisted entirely of
characters that are invariant in utf8 (i.e., US-ASCII on
non-EBCDIC machines).</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>U8* bytes_from_utf8(const U8 *s, STRLEN *len, bool
*is_utf8)</p>

<p>bytes_to_utf8 Converts a string &quot;s&quot; of length
&quot;len&quot; from the native encoding into UTF-8. Returns
a pointer to the newly-created string, and sets
&quot;len&quot; to reflect the new length.</p>

<p>A NUL character will be written after the end of the
string.</p>

<p>If you want to convert to UTF-8 from encodings other
than the native (Latin1 or EBCDIC), see
sv_recode_to_utf8().</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>U8* bytes_to_utf8(const U8 *s, STRLEN *len)</p>

<p>ibcmp_utf8 Return true if the strings s1 and s2 differ
case-insensitively, false if not (if they are equal
case-insensitively). If u1 is true, the string s1 is assumed
to be in UTF-8-encoded Unicode. If u2 is true, the string s2
is assumed to be in UTF-8-encoded Unicode. If u1 or u2 are
false, the respective string is assumed to be in native
8-bit encoding.</p>

<p>If the pe1 and pe2 are non-NULL, the scanning pointers
will be copied in there (they will point at the beginning of
the next character). If the pointers behind pe1 or pe2 are
non-NULL, they are the end pointers beyond which scanning
will not continue under any circumstances. If the byte
lengths l1 and l2 are non-zero, s1+l1 and s2+l2 will be used
as goal end pointers that will also stop the scan, and which
qualify towards defining a successful match: all the scans
that define an explicit length must reach their goal
pointers for a match to succeed).</p>

<p>For case-insensitiveness, the &quot;casefolding&quot; of
Unicode is used instead of upper/lowercasing both the
characters, see http://www.unicode.org/unicode/reports/tr21/
(Case Mappings).</p>

<p>I32 ibcmp_utf8(const char *s1, char **pe1, UV l1, bool
u1, const char *s2, char **pe2, UV l2, bool u2)</p>

<p>is_utf8_char Tests if some arbitrary number of bytes
begins in a valid UTF-8 character. Note that an INVARIANT
(i.e. ASCII on non-EBCDIC machines) character is a valid
UTF-8 character. The actual number of bytes in the UTF-8
character will be returned if it is valid, otherwise 0.</p>

<p>STRLEN is_utf8_char(const U8 *s)</p>

<p>is_utf8_string Returns true if first &quot;len&quot;
bytes of the given string form a valid UTF-8 string, false
otherwise. Note that a valid UTF-8 string does not mean a
string that contains code points above 0x7F encoded in UTF-8
because a valid ASCII string is a valid UTF-8 string.</p>

<p>See also is_utf8_string_loclen() and
is_utf8_string_loc().</p>

<p>bool is_utf8_string(const U8 *s, STRLEN len)</p>

<p>is_utf8_string_loc Like is_utf8_string() but stores the
location of the failure (in the case of &quot;utf8ness
failure&quot;) or the location s+len (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot;.</p>

<p>See also is_utf8_string_loclen() and
is_utf8_string().</p>

<p>bool is_utf8_string_loc(const U8 *s, STRLEN len, const
U8 **p)</p>

<p>is_utf8_string_loclen Like is_utf8_string() but stores
the location of the failure (in the case of &quot;utf8ness
failure&quot;) or the location s+len (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot;, and the
number of UTF-8 encoded characters in the
&quot;el&quot;.</p>

<p>See also is_utf8_string_loc() and is_utf8_string().</p>

<p>bool is_utf8_string_loclen(const U8 *s, STRLEN len,
const U8 **ep, STRLEN *el)</p>

<p>pv_uni_display Build to the scalar dsv a displayable
version of the string spv, length len, the displayable
version being at most pvlim bytes long (if longer, the rest
is truncated and &quot;...&quot; will be appended).</p>

<p>The flags argument can have UNI_DISPLAY_ISPRINT set to
display isPRINT()able characters as themselves,
UNI_DISPLAY_BACKSLASH to display the \[nrfta\] as the
backslashed versions (like ) (UNI_DISPLAY_BACKSLASH is
preferred over 0 UNI_DISPLAY_ISPRINT for \). UNI_DISPLAY_QQ
(and its alias UNI_DISPLAY_REGEX) have both
UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</p>

<p>The pointer to the PV of the dsv is returned.</p>

<p>char* pv_uni_display(SV *dsv, const U8 *spv, STRLEN len,
STRLEN pvlim, UV flags)</p>

<p>sv_cat_decode The encoding is assumed to be an Encode
object, the PV of the ssv is assumed to be octets in that
encoding and decoding the input starts from the position
which (PV + *offset) pointed to. The dsv will be
concatenated the decoded UTF-8 string from ssv. Decoding
will terminate when the string tstr appears in decoding
output or the input ends on the PV of the ssv. The value
which the offset points will be modified to the last input
position on the ssv.</p>

<p>Returns TRUE if the terminator was found, else returns
FALSE.</p>

<p>bool sv_cat_decode(SV* dsv, SV *encoding, SV *ssv, int
*offset, char* tstr, int tlen)</p>

<p>sv_recode_to_utf8 The encoding is assumed to be an
Encode object, on entry the PV of the sv is assumed to be
octets in that encoding, and the sv will be converted into
Unicode (and UTF-8).</p>

<p>If the sv already is UTF-8 (or if it is not POK), or if
the encoding is not a reference, nothing is done to the sv.
If the encoding is not an &quot;Encode::XS&quot; Encoding
object, bad things will happen. (See lib/encoding.pm and
Encode).</p>

<p>The PV of the sv is returned.</p>

<p>char* sv_recode_to_utf8(SV* sv, SV *encoding)</p>

<p>sv_uni_display Build to the scalar dsv a displayable
version of the scalar sv, the displayable version being at
most pvlim bytes long (if longer, the rest is truncated and
&quot;...&quot; will be appended).</p>

<p>The flags argument is as in pv_uni_display().</p>

<p>The pointer to the PV of the dsv is returned.</p>

<p>char* sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim, UV
flags)</p>

<p>to_utf8_case The &quot;p&quot; contains the pointer to
the UTF-8 string encoding the character that is being
converted.</p>

<p>The &quot;ustrp&quot; is a pointer to the character
buffer to put the conversion result to. The &quot;lenp&quot;
is a pointer to the length of the result.</p>

<p>The &quot;swashp&quot; is a pointer to the swash to
use.</p>

<p>Both the special and normal mappings are stored
lib/unicore/To/Foo.pl, and loaded by SWASHNEW, using
lib/utf8_heavy.pl. The special (usually, but not always, a
multicharacter mapping), is tried first.</p>

<p>The &quot;special&quot; is a string like
&quot;utf8::ToSpecLower&quot;, which means the hash
%utf8::ToSpecLower. The access to the hash is through
Perl_to_utf8_case().</p>

<p>The &quot;normal&quot; is a string like
&quot;ToLower&quot; which means the swash
%utf8::ToLower.</p>

<p>UV to_utf8_case(const U8 *p, U8* ustrp, STRLEN *lenp, SV
**swashp, const char *normal, const char *special)</p>

<p>to_utf8_fold Convert the UTF-8 encoded character at p to
its foldcase version and store that in UTF-8 in ustrp and
its length in bytes in lenp. Note that the ustrp needs to be
at least UTF8_MAXBYTES_CASE+1 bytes since the foldcase
version may be longer than the original character (up to
three characters).</p>

<p>The first character of the foldcased version is returned
(but note, as explained above, that there may be more.)</p>

<p>UV to_utf8_fold(const U8 *p, U8* ustrp, STRLEN
*lenp)</p>

<p>to_utf8_lower Convert the UTF-8 encoded character at p
to its lowercase version and store that in UTF-8 in ustrp
and its length in bytes in lenp. Note that the ustrp needs
to be at least UTF8_MAXBYTES_CASE+1 bytes since the
lowercase version may be longer than the original
character.</p>

<p>The first character of the lowercased version is
returned (but note, as explained above, that there may be
more.)</p>

<p>UV to_utf8_lower(const U8 *p, U8* ustrp, STRLEN
*lenp)</p>

<p>to_utf8_title Convert the UTF-8 encoded character at p
to its titlecase version and store that in UTF-8 in ustrp
and its length in bytes in lenp. Note that the ustrp needs
to be at least UTF8_MAXBYTES_CASE+1 bytes since the
titlecase version may be longer than the original
character.</p>

<p>The first character of the titlecased version is
returned (but note, as explained above, that there may be
more.)</p>

<p>UV to_utf8_title(const U8 *p, U8* ustrp, STRLEN
*lenp)</p>

<p>to_utf8_upper Convert the UTF-8 encoded character at p
to its uppercase version and store that in UTF-8 in ustrp
and its length in bytes in lenp. Note that the ustrp needs
to be at least UTF8_MAXBYTES_CASE+1 bytes since the
uppercase version may be longer than the original
character.</p>

<p>The first character of the uppercased version is
returned (but note, as explained above, that there may be
more.)</p>

<p>UV to_utf8_upper(const U8 *p, U8* ustrp, STRLEN
*lenp)</p>

<p>utf8n_to_uvchr flags</p>

<p>Returns the native character value of the first
character in the string &quot;s&quot; which is assumed to be
in UTF-8 encoding; &quot;retlen&quot; will be set to the
length, in bytes, of that character.</p>

<p>Allows length and flags to be passed to low level
routine.</p>

<p>UV utf8n_to_uvchr(const U8 *s, STRLEN curlen, STRLEN
*retlen, U32 flags)</p>

<p>utf8n_to_uvuni Bottom level UTF-8 decode routine.
Returns the Unicode code point value of the first character
in the string &quot;s&quot; which is assumed to be in UTF-8
encoding and no longer than &quot;curlen&quot;;
&quot;retlen&quot; will be set to the length, in bytes, of
that character.</p>

<p>If &quot;s&quot; does not point to a well-formed UTF-8
character, the behaviour is dependent on the value of
&quot;flags&quot;: if it contains UTF8_CHECK_ONLY, it is
assumed that the caller will raise a warning, and this
function will silently just set &quot;retlen&quot; to
&quot;-1&quot; and return zero. If the &quot;flags&quot;
does not contain UTF8_CHECK_ONLY, warnings about
malformations will be given, &quot;retlen&quot; will be set
to the expected length of the UTF-8 character in bytes, and
zero will be returned.</p>

<p>The &quot;flags&quot; can also contain various flags to
allow deviations from the strict UTF-8 encoding (see
utf8.h).</p>

<p>Most code should use utf8_to_uvchr() rather than call
this directly.</p>

<p>UV utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN
*retlen, U32 flags)</p>

<p>utf8_distance Returns the number of UTF-8 characters
between the UTF-8 pointers &quot;a&quot; and
&quot;b&quot;.</p>

<p>WARNING: use only if you *know* that the pointers point
inside the same UTF-8 buffer.</p>

<p>IV utf8_distance(const U8 *a, const U8 *b)</p>

<p>utf8_hop Return the UTF-8 pointer &quot;s&quot;
displaced by &quot;off&quot; characters, either forward or
backward.</p>

<p>WARNING: do not use the following unless you *know*
&quot;off&quot; is within the UTF-8 data pointed to by
&quot;s&quot; *and* that on entry &quot;s&quot; is aligned
on the first byte of character or just after the last byte
of a character.</p>

<p>U8* utf8_hop(const U8 *s, I32 off)</p>

<p>utf8_length Return the length of the UTF-8 char encoded
string &quot;s&quot; in characters. Stops at &quot;e&quot;
(inclusive). If &quot;e &lt; s&quot; or if the scan would
end up past &quot;e&quot;, croaks.</p>

<p>STRLEN utf8_length(const U8* s, const U8 *e)</p>

<p>utf8_to_bytes Converts a string &quot;s&quot; of length
&quot;len&quot; from UTF-8 into native byte encoding. Unlike
&quot;bytes_to_utf8&quot;, this over-writes the original
string, and updates len to contain the new length. Returns
zero on failure, setting &quot;len&quot; to -1.</p>

<p>If you need a copy of the string, see
&quot;bytes_from_utf8&quot;.</p>

<p>NOTE: this function is experimental and may change or be
removed without notice.</p>

<p>U8* utf8_to_bytes(U8 *s, STRLEN *len)</p>

<p>utf8_to_uvchr Returns the native character value of the
first character in the string &quot;s&quot; which is assumed
to be in UTF-8 encoding; &quot;retlen&quot; will be set to
the length, in bytes, of that character.</p>

<p>If &quot;s&quot; does not point to a well-formed UTF-8
character, zero is returned and retlen is set, if possible,
to -1.</p>

<p>UV utf8_to_uvchr(const U8 *s, STRLEN *retlen)</p>

<p>utf8_to_uvuni Returns the Unicode code point of the
first character in the string &quot;s&quot; which is assumed
to be in UTF-8 encoding; &quot;retlen&quot; will be set to
the length, in bytes, of that character.</p>

<p>This function should only be used when the returned UV
is considered an index into the Unicode semantic tables
(e.g. swashes).</p>

<p>If &quot;s&quot; does not point to a well-formed UTF-8
character, zero is returned and retlen is set, if possible,
to -1.</p>

<p>UV utf8_to_uvuni(const U8 *s, STRLEN *retlen)</p>

<p>uvchr_to_utf8 Adds the UTF-8 representation of the
Native codepoint &quot;uv&quot; to the end of the string
&quot;d&quot;; &quot;d&quot; should be have at least
&quot;UTF8_MAXBYTES+1&quot; free bytes available. The return
value is the pointer to the byte after the end of the new
character. In other words,</p>

<p>d = uvchr_to_utf8(d, uv);</p>

<p>is the recommended wide native character-aware way of
saying</p>

<p>*(d++) = uv;</p>

<p>U8* uvchr_to_utf8(U8 *d, UV uv)</p>

<p>uvuni_to_utf8_flags Adds the UTF-8 representation of the
Unicode codepoint &quot;uv&quot; to the end of the string
&quot;d&quot;; &quot;d&quot; should be have at least
&quot;UTF8_MAXBYTES+1&quot; free bytes available. The return
value is the pointer to the byte after the end of the new
character. In other words,</p>

<p>d = uvuni_to_utf8_flags(d, uv, flags);</p>

<p>or, in most cases,</p>

<p>d = uvuni_to_utf8(d, uv);</p>

<p>(which is equivalent to)</p>

<p>d = uvuni_to_utf8_flags(d, uv, 0);</p>

<p>is the recommended Unicode-aware way of saying</p>

<p>*(d++) = uv;</p>

<p>U8* uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)</p>

<p>Variables created by &quot;xsubpp&quot; and
&quot;xsubpp&quot; internal functions ax Variable which is
setup by &quot;xsubpp&quot; to indicate the stack base
offset, used by the &quot;ST&quot;, &quot;XSprePUSH&quot;
and &quot;XSRETURN&quot; macros. The &quot;dMARK&quot; macro
must be called prior to setup the &quot;MARK&quot;
variable.</p>

<p>I32 ax</p>

<p>CLASS Variable which is setup by &quot;xsubpp&quot; to
indicate the class name for a C++ XS constructor. This is
always a &quot;char*&quot;. See &quot;THIS&quot;.</p>

<p>char* CLASS</p>

<p>dAX Sets up the &quot;ax&quot; variable. This is usually
handled automatically by &quot;xsubpp&quot; by calling
&quot;dXSARGS&quot;.</p>

<p>dAX;</p>

<p>dAXMARK Sets up the &quot;ax&quot; variable and stack
marker variable &quot;mark&quot;. This is usually handled
automatically by &quot;xsubpp&quot; by calling
&quot;dXSARGS&quot;.</p>

<p>dAXMARK;</p>

<p>dITEMS Sets up the &quot;items&quot; variable. This is
usually handled automatically by &quot;xsubpp&quot; by
calling &quot;dXSARGS&quot;.</p>

<p>dITEMS;</p>

<p>dUNDERBAR Sets up the &quot;padoff_du&quot; variable for
an XSUB that wishes to use &quot;UNDERBAR&quot;.</p>

<p>dUNDERBAR;</p>

<p>dXSARGS Sets up stack and mark pointers for an XSUB,
calling dSP and dMARK. Sets up the &quot;ax&quot; and
&quot;items&quot; variables by calling &quot;dAX&quot; and
&quot;dITEMS&quot;. This is usually handled automatically by
&quot;xsubpp&quot;.</p>

<p>dXSARGS;</p>

<p>dXSI32 Sets up the &quot;ix&quot; variable for an XSUB
which has aliases. This is usually handled automatically by
&quot;xsubpp&quot;.</p>

<p>dXSI32;</p>

<p>items Variable which is setup by &quot;xsubpp&quot; to
indicate the number of items on the stack. See
&quot;Variable-length Parameter Lists&quot; in perlxs.</p>

<p>I32 items</p>

<p>ix Variable which is setup by &quot;xsubpp&quot; to
indicate which of an XSUB s aliases was used to invoke it.
See &quot;The ALIAS: Keyword&quot; in perlxs.</p>

<p>I32 ix</p>

<p>newXSproto Used by &quot;xsubpp&quot; to hook up XSUBs
as Perl subs. Adds Perl prototypes to the subs.</p>

<p>RETVAL Variable which is setup by &quot;xsubpp&quot; to
hold the return value for an XSUB. This is always the proper
type for the XSUB. See &quot;The RETVAL Variable&quot; in
perlxs.</p>

<p>(whatever) RETVAL</p>

<p>ST Used to access elements on the XSUBs stack.</p>

<p>SV* ST(int ix)</p>

<p>THIS Variable which is setup by &quot;xsubpp&quot; to
designate the object in a C++ XSUB. This is always the
proper type for the C++ object. See &quot;CLASS&quot; and
&quot;Using XS With C++&quot; in perlxs.</p>

<p>(whatever) THIS</p>

<p>UNDERBAR The SV* corresponding to the $_ variable. Works
even if there is a lexical $_ in scope.</p>

<p>XS Macro to declare an XSUB and its C parameter list.
This is handled by &quot;xsubpp&quot;.</p>

<p>XS_VERSION The version identifier for an XS module. This
is usually handled automatically by
&quot;ExtUtils::MakeMaker&quot;. See
&quot;XS_VERSION_BOOTCHECK&quot;.</p>

<p>XS_VERSION_BOOTCHECK Macro to verify that a PM module s
$VERSION variable matches the XS modules
&quot;XS_VERSION&quot; variable. This is usually handled
automatically by &quot;xsubpp&quot;. See &quot;The
VERSIONCHECK: Keyword&quot; in perlxs.</p>

<p>XS_VERSION_BOOTCHECK;</p>

<p>Warning and Dieing croak This is the XSUB-writers
interface to Perls &quot;die&quot; function. Normally call
this function the same way you call the C &quot;printf&quot;
function. Calling &quot;croak&quot; returns control directly
to Perl, sidestepping the normal C order of execution. See
&quot;warn&quot;.</p>

<p>If you want to throw an exception object, assign the
object to $@ and then pass &quot;NULL&quot; to croak():</p>

<p>errsv = get_sv(&quot;@&quot;, GV_ADD); sv_setsv(errsv,
exception_object); croak(NULL);</p>

<p>void croak(const char* pat, ...)</p>

<p>warn This is the XSUB-writers interface to Perls
&quot;warn&quot; function. Call this function the same way
you call the C &quot;printf&quot; function. See
&quot;croak&quot;.</p>

<p>void warn(const char* pat, ...)</p>

<p>AUTHORS Until May 1997, this document was maintained by
Jeff Okamoto &lt;okamoto@corp.hp.com&gt;. It is now
maintained as part of Perl itself.</p>

<p>With lots of help and suggestions from Dean Roehrich,
Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya
Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim
Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant,
and Gurusamy Sarathy.</p>

<p>API Listing originally by Dean Roehrich
&lt;roehrich@cray.com&gt;.</p>

<p>Updated to be autogenerated from comments in the source
by Benjamin Stuhl.</p>

<p>SEE ALSO perlguts(1), perlxs(1), perlxstut(1),
perlintern(1)</p>

<p>perl v5.10.1 2010-07-19 PERLAPI(1)</p>
<hr>
</body>
</html>
