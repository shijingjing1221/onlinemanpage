<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:10:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLPODSPEC(1) Perl Programmers Reference Guide
PERLPODSPEC(1)</p>

<p>NAME perlpodspec - Plain Old Documentation: format
specification and notes</p>

<p>DESCRIPTION This document is detailed notes on the Pod
markup language. Most people will only have to read perlpod
to know how to write in Pod, but this document may answer
some incidental questions to do with parsing and rendering
Pod.</p>

<p>In this document, &quot;must&quot; / &quot;must
not&quot;, &quot;should&quot; / &quot;should not&quot;, and
&quot;may&quot; have their conventional (cf. RFC 2119)
meanings: &quot;X must do Y&quot; means that if X doesn t do
Y, it s against this specification, and should really be
fixed. &quot;X should do Y&quot; means that its recommended,
but X may fail to do Y, if theres a good reason. &quot;X may
do Y&quot; is merely a note that X can do Y at will
(although it is up to the reader to detect any connotation
of &quot;and I think it would be nice if X did Y&quot;
versus &quot;it wouldnt really bother me if X did
Y&quot;).</p>

<p>Notably, when I say &quot;the parser should do Y&quot;,
the parser may fail to do Y, if the calling application
explicitly requests that the parser not do Y. I often phrase
this as &quot;the parser should, by default, do Y.&quot;
This doesnt require the parser to provide an option for
turning off whatever feature Y is (like expanding tabs in
verbatim paragraphs), although it implicates that such an
option may be provided.</p>

<p>Pod Definitions Pod is embedded in files, typically Perl
source files -- although you can write a file thats nothing
but Pod.</p>

<p>A line in a file consists of zero or more non-newline
characters, terminated by either a newline or the end of the
file.</p>

<p>A newline sequence is usually a platform-dependent
concept, but Pod parsers should understand it to mean any of
CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed
immediately by ASCII 10), in addition to any other
system-specific meaning. The first CR/CRLF/LF sequence in
the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.</p>

<p>A blank line is a line consisting entirely of zero or
more spaces (ASCII 32) or tabs (ASCII 9), and terminated by
a newline or end-of- file. A non-blank line is a line
containing one or more characters other than space or tab
(and terminated by a newline or end-of-file).</p>

<p>(Note: Many older Pod parsers did not accept a line
consisting of spaces/tabs and then a newline as a blank line
-- the only lines they considered blank were lines
consisting of no characters at all, terminated by a
newline.)</p>

<p>Whitespace is used in this document as a blanket term
for spaces, tabs, and newline sequences. (By itself, this
term usually refers to literal whitespace. That is,
sequences of whitespace characters in Pod source, as opposed
to &quot;E&lt;32&gt;&quot;, which is a formatting code that
denotes a whitespace character.)</p>

<p>A Pod parser is a module meant for parsing Pod
(regardless of whether this involves calling callbacks or
building a parse tree or directly formatting it). A Pod
formatter (or Pod translator) is a module or program that
converts Pod to some other format (HTML, plaintext, TeX,
PostScript, RTF). A Pod processor might be a formatter or
translator, or might be a program that does something else
with the Pod (like counting words, scanning for index
points, etc.).</p>

<p>Pod content is contained in Pod blocks. A Pod block
starts with a line that matches &lt;m/0 matches &quot;m/0
&quot;m/0 Within a Pod block, there are Pod paragraphs. A
Pod paragraph consists of non-blank lines of text, separated
by one or more blank lines.</p>

<p>For purposes of Pod processing, there are four types of
paragraphs in a Pod block:</p>

<p>&middot; A command paragraph (also called a
&quot;directive&quot;). The first line of this paragraph
must match &quot;m/0 typically one line, as in:</p>

<p>=head1 NOTES</p>

<p>=item *</p>

<p>But they may span several (non-blank) lines:</p>

<p>=for comment Hm, I wonder what it would look like if you
tried to write a BNF for Pod from this.</p>

<p>=head3 Dr. Strangelove, or: How I Learned to Stop
Worrying and Love the Bomb</p>

<p>Some command paragraphs allow formatting codes in their
content (i.e., after the part that matches &quot;m/0 =head1
Did You Remember to C&lt;use strict;&gt;?</p>

<p>In other words, the Pod processing handler for
&quot;head1&quot; will apply the same processing to
&quot;Did You Remember to C&lt;use strict;&gt;?&quot; that
it would to an ordinary paragraph -- i.e., formatting codes
(like &quot;C&lt;...&gt;&quot;) are parsed and presumably
formatted appropriately, and whitespace in the form of
literal spaces and/or tabs is not significant.</p>

<p>&middot; A verbatim paragraph. The first line of this
paragraph must be a literal space or tab, and this paragraph
must not be inside a &quot;=begin identifier&quot;, ...
&quot;=end identifier&quot; sequence unless
&quot;identifier&quot; begins with a colon (&quot;:&quot;).
That is, if a paragraph starts with a literal space or tab,
but is inside a &quot;=begin identifier&quot;, ...
&quot;=end identifier&quot; region, then its a data
paragraph, unless &quot;identifier&quot; begins with a
colon.</p>

<p>Whitespace is significant in verbatim paragraphs
(although, in processing, tabs are probably expanded).</p>

<p>&middot; An ordinary paragraph. A paragraph is an
ordinary paragraph if its first line matches neither
&quot;m/0begin identifier&quot;, ... &quot;=end
identifier&quot; sequence unless &quot;identifier&quot;
begins with a colon (&quot;:&quot;).</p>

<p>&middot; A data paragraph. This is a paragraph that is
inside a &quot;=begin identifier&quot; ... &quot;=end
identifier&quot; sequence where &quot;identifier&quot; does
not begin with a literal colon (&quot;:&quot;). In some
sense, a data paragraph is not part of Pod at all (i.e.,
effectively its &quot;out- of-band&quot;), since its not
subject to most kinds of Pod parsing; but it is specified
here, since Pod parsers need to be able to call an event for
it, or store it in some form in a parse tree, or at least
just parse around it.</p>

<p>For example: consider the following paragraphs:</p>

<p># &lt;- that&rsquo;s the 0th column</p>

<p>=head1 Foo</p>

<p>Stuff</p>

<p>$foo-&gt;bar</p>

<p>=cut</p>

<p>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are
command paragraphs because the first line of each matches
&quot;m/0 verbatim paragraph, because its first line starts
with a literal whitespace character (and there s no
&quot;=begin&quot;...&quot;=end&quot; region around).</p>

<p>The &quot;=begin identifier&quot; ... &quot;=end
identifier&quot; commands stop paragraphs that they surround
from being parsed as ordinary or verbatim paragraphs, if
identifier doesnt begin with a colon. This is discussed in
detail in the section &quot;About Data Paragraphs and
&quot;=begin/=end&quot; Regions&quot;.</p>

<p>Pod Commands This section is intended to supplement and
clarify the discussion in &quot;Command Paragraph&quot; in
perlpod. These are the currently recognized Pod
commands:</p>

<p>&quot;=head1&quot;, &quot;=head2&quot;,
&quot;=head3&quot;, &quot;=head4&quot; This command
indicates that the text in the remainder of the paragraph is
a heading. That text may contain formatting codes.
Examples:</p>

<p>=head1 Object Attributes</p>

<p>=head3 What B&lt;Not&gt; to Do!</p>

<p>&quot;=pod&quot; This command indicates that this
paragraph begins a Pod block. (If we are already in the
middle of a Pod block, this command has no effect at all.)
If there is any text in this command paragraph after
&quot;=pod&quot;, it must be ignored. Examples:</p>

<p>=pod</p>

<p>This is a plain Pod paragraph.</p>

<p>=pod This text is ignored.</p>

<p>&quot;=cut&quot; This command indicates that this line
is the end of this previously started Pod block. If there is
any text after &quot;=cut&quot; on the line, it must be
ignored. Examples:</p>

<p>=cut</p>

<p>=cut The documentation ends here.</p>

<p>=cut # This is the first line of program text. sub foo {
# This is the second.</p>

<p>It is an error to try to start a Pod block with a
&quot;=cut&quot; command. In that case, the Pod processor
must halt parsing of the input file, and must by default
emit a warning.</p>

<p>&quot;=over&quot; This command indicates that this is
the start of a list/indent region. If there is any text
following the &quot;=over&quot;, it must consist of only a
nonzero positive numeral. The semantics of this numeral is
explained in the &quot;About =over...=back Regions&quot;
section, further below. Formatting codes are not expanded.
Examples:</p>

<p>=over 3</p>

<p>=over 3.5</p>

<p>=over</p>

<p>&quot;=item&quot; This command indicates that an item in
a list begins here. Formatting codes are processed. The
semantics of the (optional) text in the remainder of this
paragraph are explained in the &quot;About =over...=back
Regions&quot; section, further below. Examples:</p>

<p>=item</p>

<p>=item *</p>

<p>=item *</p>

<p>=item 14</p>

<p>=item 3.</p>

<p>=item C&lt;&lt; $thing-&gt;stuff(I&lt;dodad&gt;)
&gt;&gt;</p>

<p>=item For transporting us beyond seas to be tried for
pretended offenses</p>

<p>=item He is at this time transporting large armies of
foreign mercenaries to complete the works of death,
desolation and tyranny, already begun with circumstances of
cruelty and perfidy scarcely paralleled in the most
barbarous ages, and totally unworthy the head of a civilized
nation.</p>

<p>&quot;=back&quot; This command indicates that this is
the end of the region begun by the most recent
&quot;=over&quot; command. It permits no text after the
&quot;=back&quot; command.</p>

<p>&quot;=begin formatname&quot; &quot;=begin formatname
parameter&quot; This marks the following paragraphs (until
the matching &quot;=end formatname&quot;) as being for some
special kind of processing. Unless &quot;formatname&quot;
begins with a colon, the contained non-command paragraphs
are data paragraphs. But if &quot;formatname&quot; does
begin with a colon, then non-command paragraphs are ordinary
paragraphs or data paragraphs. This is discussed in detail
in the section &quot;About Data Paragraphs and
&quot;=begin/=end&quot; Regions&quot;.</p>

<p>It is advised that formatnames match the regexp
&quot;m/0 after the formatname is a parameter that may be
used by the formatter when dealing with this region. This
parameter must not be repeated in the &quot;=end&quot;
paragraph. Implementors should anticipate future expansion
in the semantics and syntax of the first parameter to
&quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</p>

<p>&quot;=end formatname&quot; This marks the end of the
region opened by the matching &quot;=begin formatname&quot;
region. If &quot;formatname&quot; is not the formatname of
the most recent open &quot;=begin formatname&quot; region,
then this is an error, and must generate an error message.
This is discussed in detail in the section &quot;About Data
Paragraphs and &quot;=begin/=end&quot; Regions&quot;.</p>

<p>&quot;=for formatname text...&quot; This is synonymous
with:</p>

<p>=begin formatname</p>

<p>text...</p>

<p>=end formatname</p>

<p>That is, it creates a region consisting of a single
paragraph; that paragraph is to be treated as a normal
paragraph if &quot;formatname&quot; begins with a
&quot;:&quot;; if &quot;formatname&quot; doesnt begin with a
colon, then &quot;text...&quot; will constitute a data
paragraph. There is no way to use &quot;=for formatname
text...&quot; to express &quot;text...&quot; as a verbatim
paragraph.</p>

<p>&quot;=encoding encodingname&quot; This command, which
should occur early in the document (at least before any
non-US-ASCII data!), declares that this document is encoded
in the encoding encodingname, which must be an encoding name
that Encode recognizes. (Encode s list of supported
encodings, in Encode::Supported, is useful here.) If the Pod
parser cannot decode the declared encoding, it should emit a
warning and may abort parsing the document altogether.</p>

<p>A document having more than one &quot;=encoding&quot;
line should be considered an error. Pod processors may
silently tolerate this if the not-first
&quot;=encoding&quot; lines are just duplicates of the first
one (e.g., if theres a &quot;=encoding utf8&quot; line, and
later on another &quot;=encoding utf8&quot; line). But Pod
processors should complain if there are contradictory
&quot;=encoding&quot; lines in the same document (e.g., if
there is a &quot;=encoding utf8&quot; early in the document
and &quot;=encoding big5&quot; later). Pod processors that
recognize BOMs may also complain if they see an
&quot;=encoding&quot; line that contradicts the BOM (e.g.,
if a document with a UTF-16LE BOM has an &quot;=encoding
shiftjis&quot; line).</p>

<p>If a Pod processor sees any command other than the ones
listed above (like &quot;=head&quot;, or &quot;=haed1&quot;,
or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or
&quot;=w123&quot;), that processor must by default treat
this as an error. It must not process the paragraph
beginning with that command, must by default warn of this as
an error, and may abort the parse. A Pod parser may allow a
way for particular applications to add to the above list of
known commands, and to stipulate, for each additional
command, whether formatting codes should be processed.</p>

<p>Future versions of this specification may add additional
commands.</p>

<p>Pod Formatting Codes (Note that in previous drafts of
this document and of perlpod, formatting codes were referred
to as &quot;interior sequences&quot;, and this term may
still be found in the documentation for Pod parsers, and in
error messages from Pod processors.)</p>

<p>There are two syntaxes for formatting codes:</p>

<p>&middot; A formatting code starts with a capital letter
(just US-ASCII [A-Z]) followed by a &quot;&lt;&quot;, any
number of characters, and ending with the first matching
&quot;&gt;&quot;. Examples:</p>

<p>That&rsquo;s what I&lt;you&gt; think!</p>

<p>What&rsquo;s C&lt;dump()&gt; for?</p>

<p>X&lt;C&lt;chmod&gt; and C&lt;unlink()&gt; Under
Different Operating Systems&gt;</p>

<p>&middot; A formatting code starts with a capital letter
(just US-ASCII [A-Z]) followed by two or more
&quot;&lt;&quot; s, one or more whitespace characters, any
number of characters, one or more whitespace characters, and
ending with the first matching sequence of two or more
&quot;&gt;&quot;s, where the number of &quot;&gt;&quot;s
equals the number of &quot;&lt;&quot;s in the opening of
this formatting code. Examples:</p>

<p>That&rsquo;s what I&lt;&lt; you &gt;&gt; think!</p>

<p>C&lt;&lt;&lt; open(X, &quot;&gt;&gt;thing.dat&quot;) ||
die $! &gt;&gt;&gt;</p>

<p>B&lt;&lt; $foo-&gt;bar(); &gt;&gt;</p>

<p>With this syntax, the whitespace character(s) after the
&quot;C&lt;&lt;&lt;&quot; and before the
&quot;&gt;&gt;&quot; (or whatever letter) are not renderable
-- they do not signify whitespace, are merely part of the
formatting codes themselves. That is, these are all
synonymous:</p>

<p>C&lt;thing&gt; C&lt;&lt; thing &gt;&gt; C&lt;&lt; thing
&gt;&gt; C&lt;&lt;&lt; thing &gt;&gt;&gt; C&lt;&lt;&lt;&lt;
thing &gt;&gt;&gt;&gt;</p>

<p>and so on.</p>

<p>In parsing Pod, a notably tricky part is the correct
parsing of (potentially nested!) formatting codes.
Implementors should consult the code in the
&quot;parse_text&quot; routine in Pod::Parser as an example
of a correct implementation.</p>

<p>&quot;I&lt;text&gt;&quot; -- italic text See the brief
discussion in &quot;Formatting Codes&quot; in perlpod.</p>

<p>&quot;B&lt;text&gt;&quot; -- bold text See the brief
discussion in &quot;Formatting Codes&quot; in perlpod.</p>

<p>&quot;C&lt;code&gt;&quot; -- code text See the brief
discussion in &quot;Formatting Codes&quot; in perlpod.</p>

<p>&quot;F&lt;filename&gt;&quot; -- style for filenames See
the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p>&quot;X&lt;topic name&gt;&quot; -- an index entry See
the brief discussion in &quot;Formatting Codes&quot; in
perlpod.</p>

<p>This code is unusual in that most formatters completely
discard this code and its content. Other formatters will
render it with invisible codes that can be used in building
an index of the current document.</p>

<p>&quot;Z&lt;&gt;&quot; -- a null (zero-effect) formatting
code Discussed briefly in &quot;Formatting Codes&quot; in
perlpod.</p>

<p>This code is unusual is that it should have no content.
That is, a processor may complain if it sees
&quot;Z&lt;potatoes&gt;&quot;. Whether or not it complains,
the potatoes text should ignored.</p>

<p>&quot;L&lt;name&gt;&quot; -- a hyperlink The complicated
syntaxes of this code are discussed at length in
&quot;Formatting Codes&quot; in perlpod, and implementation
details are discussed below, in &quot;About L&lt;...&gt;
Codes&quot;. Parsing the contents of L&lt;content&gt; is
tricky. Notably, the content has to be checked for whether
it looks like a URL, or whether it has to be split on
literal &quot;|&quot; and/or &quot;/&quot; (in the right
order!), and so on, before E&lt;...&gt; codes are
resolved.</p>

<p>&quot;E&lt;escape&gt;&quot; -- a character escape See
&quot;Formatting Codes&quot; in perlpod, and several points
in &quot;Notes on Implementing Pod Processors&quot;.</p>

<p>&quot;S&lt;text&gt;&quot; -- text contains non-breaking
spaces This formatting code is syntactically simple, but
semantically complex. What it means is that each space in
the printable content of this code signifies a non-breaking
space.</p>

<p>Consider:</p>

<p>C&lt;$x ? $y : $z&gt;</p>

<p>S&lt;C&lt;$x ? $y : $z&gt;&gt;</p>

<p>Both signify the monospace (c[ode] style) text
consisting of &quot;$x&quot;, one space, &quot;?&quot;, one
space, &quot;:&quot;, one space, &quot;$z&quot;. The
difference is that in the latter, with the S code, those
spaces are not &quot;normal&quot; spaces, but instead are
non-breaking spaces.</p>

<p>If a Pod processor sees any formatting code other than
the ones listed above (as in &quot;N&lt;...&gt;&quot;, or
&quot;Q&lt;...&gt;&quot;, etc.), that processor must by
default treat this as an error. A Pod parser may allow a way
for particular applications to add to the above list of
known formatting codes; a Pod parser might even allow a way
to stipulate, for each additional command, whether it
requires some form of special processing, as L&lt;...&gt;
does.</p>

<p>Future versions of this specification may add additional
formatting codes.</p>

<p>Historical note: A few older Pod processors would not
see a &quot;&gt;&quot; as closing a &quot;C&lt;&quot; code,
if the &quot;&gt;&quot; was immediately preceded by a
&quot;-&quot;. This was so that this:</p>

<p>C&lt;$foo-&gt;bar&gt;</p>

<p>would parse as equivalent to this:</p>

<p>C&lt;$foo-E&lt;gt&gt;bar&gt;</p>

<p>instead of as equivalent to a &quot;C&quot; formatting
code containing only &quot;$foo-&quot;, and then a
&quot;bar&gt;&quot; outside the &quot;C&quot; formatting
code. This problem has since been solved by the addition of
syntaxes like this:</p>

<p>C&lt;&lt; $foo-&gt;bar &gt;&gt;</p>

<p>Compliant parsers must not treat &quot;-&gt;&quot; as
special.</p>

<p>Formatting codes absolutely cannot span paragraphs. If a
code is opened in one paragraph, and no closing code is
found by the end of that paragraph, the Pod parser must
close that formatting code, and should complain (as in
&quot;Unterminated I code in the paragraph starting at line
123: Time objects are not... &quot;). So these two
paragraphs:</p>

<p>I&lt;I told you not to do this!</p>

<p>Don&rsquo;t make me say it again!&gt;</p>

<p>...must not be parsed as two paragraphs in italics (with
the I code starting in one paragraph and starting in
another.) Instead, the first paragraph should generate a
warning, but that aside, the above code must parse as if it
were:</p>

<p>I&lt;I told you not to do this!&gt;</p>

<p>Don&rsquo;t make me say it again!E&lt;gt&gt;</p>

<p>(In SGMLish jargon, all Pod commands are like
block-level elements, whereas all Pod formatting codes are
like inline-level elements.)</p>

<p>Notes on Implementing Pod Processors The following is a
long section of miscellaneous requirements and suggestions
to do with Pod processing.</p>

<p>&middot; Pod formatters should tolerate lines in
verbatim blocks that are of any length, even if that means
having to break them (possibly several times, for very long
lines) to avoid text running off the side of the page. Pod
formatters may warn of such line-breaking. Such warnings are
particularly appropriate for lines are over 100 characters
long, which are usually not intentional.</p>

<p>&middot; Pod parsers must recognize all of the three
well-known newline formats: CR, LF, and CRLF. See
perlport.</p>

<p>&middot; Pod parsers should accept input lines that are
of any length.</p>

<p>&middot; Since Perl recognizes a Unicode Byte Order Mark
at the start of files as signaling that the file is Unicode
encoded as in UTF-16 (whether big-endian or little-endian)
or UTF-8, Pod parsers should do the same. Otherwise, the
character encoding should be understood as being UTF-8 if
the first highbit byte sequence in the file seems valid as a
UTF-8 sequence, or otherwise as Latin-1.</p>

<p>Future versions of this specification may specify how
Pod can accept other encodings. Presumably treatment of
other encodings in Pod parsing would be as in XML parsing:
whatever the encoding declared by a particular Pod file,
content is to be stored in memory as Unicode characters.</p>

<p>&middot; The well known Unicode Byte Order Marks are as
follows: if the file begins with the two literal byte values
0xFE 0xFF, this is the BOM for big-endian UTF-16. If the
file begins with the two literal byte value 0xFF 0xFE, this
is the BOM for little-endian UTF-16. If the file begins with
the three literal byte values 0xEF 0xBB 0xBF, this is the
BOM for UTF-8.</p>

<p>&middot; A naive but sufficient heuristic for testing
the first highbit byte-sequence in a BOM-less file (whether
in code or in Pod!), to see whether that sequence is valid
as UTF-8 (RFC 2279) is to check whether that the first byte
in the sequence is in the range 0xC0 - 0xFD and whether the
next byte is in the range 0x80 - 0xBF. If so, the parser may
conclude that this file is in UTF-8, and all highbit
sequences in the file should be assumed to be UTF-8.
Otherwise the parser should treat the file as being in
Latin-1. In the unlikely circumstance that the first highbit
sequence in a truly non-UTF-8 file happens to appear to be
UTF-8, one can cater to our heuristic (as well as any more
intelligent heuristic) by prefacing that line with a comment
line containing a highbit sequence that is clearly not valid
as UTF-8. A line consisting of simply &quot;#&quot;, an
e-acute, and any non-highbit byte, is sufficient to
establish this files encoding.</p>

<p>&middot; This document s requirements and suggestions
about encodings do not apply to Pod processors running on
non-ASCII platforms, notably EBCDIC platforms.</p>

<p>&middot; Pod processors must treat a &quot;=for [label]
[content...]&quot; paragraph as meaning the same thing as a
&quot;=begin [label]&quot; paragraph, content, and an
&quot;=end [label]&quot; paragraph. (The parser may conflate
these two constructs, or may leave them distinct, in the
expectation that the formatter will nevertheless treat them
the same.)</p>

<p>&middot; When rendering Pod to a format that allows
comments (i.e., to nearly any format other than plaintext),
a Pod formatter must insert comment text identifying its
name and version number, and the name and version numbers of
any modules it might be using to process the Pod. Minimal
examples:</p>

<p>%% POD::Pod2PS v3.14159, using POD::Parser v1.92</p>

<p>&lt;!-- Pod::HTML v3.14159, using POD::Parser v1.92
--&gt;</p>

<p>{occomm generated by Pod::Tree::RTF 3.14159 using
Pod::Tree 1.08}</p>

<p>.</p>

<p>Formatters may also insert additional comments,
including: the release date of the Pod formatter program,
the contact address for the author(s) of the formatter, the
current time, the name of input file, the formatting options
in effect, version of Perl used, etc.</p>

<p>Formatters may also choose to note errors/warnings as
comments, besides or instead of emitting them otherwise (as
in messages to STDERR, or &quot;die&quot;ing).</p>

<p>&middot; Pod parsers may emit warnings or error messages
(&quot;Unknown E code E&lt;zslig&gt;!&quot;) to STDERR
(whether through printing to STDERR, or
&quot;warn&quot;ing/&quot;carp&quot;ing, or
&quot;die&quot;ing/&quot;croak&quot;ing), but must allow
suppressing all such STDERR output, and instead allow an
option for reporting errors/warnings in some other way,
whether by triggering a callback, or noting errors in some
attribute of the document object, or some similarly
unobtrusive mechanism -- or even by appending a &quot;Pod
Errors&quot; section to the end of the parsed form of the
document.</p>

<p>&middot; In cases of exceptionally aberrant documents,
Pod parsers may abort the parse. Even then, using
&quot;die&quot;ing/&quot;croak&quot;ing is to be avoided;
where possible, the parser library may simply close the
input file and add text like &quot;*** Formatting Aborted
***&quot; to the end of the (partial) in-memory
document.</p>

<p>&middot; In paragraphs where formatting codes (like
E&lt;...&gt;, B&lt;...&gt;) are understood (i.e., not
verbatim paragraphs, but including ordinary paragraphs, and
command paragraphs that produce renderable text, like
&quot;=head1&quot;), literal whitespace should generally be
considered &quot;insignificant&quot;, in that one literal
space has the same meaning as any (nonzero) number of
literal spaces, literal newlines, and literal tabs (as long
as this produces no blank lines, since those would terminate
the paragraph). Pod parsers should compact literal
whitespace in each processed paragraph, but may provide an
option for overriding this (since some processing tasks do
not require it), or may follow additional special rules (for
example, specially treating period-space-space or
period-newline sequences).</p>

<p>&middot; Pod parsers should not, by default, try to
coerce apostrophe () and quote (&quot;) into smart quotes
(little 9s, 66s, 99s, etc), nor try to turn backtick ( )
into anything else but a single backtick character (distinct
from an open quote character!), nor &quot;--&quot; into
anything but two minus signs. They must never do any of
those things to text in C&lt;...&gt; formatting codes, and
never ever to text in verbatim paragraphs.</p>

<p>&middot; When rendering Pod to a format that has two
kinds of hyphens (-), one that s a non-breaking hyphen, and
another thats a breakable hyphen (as in
&quot;object-oriented&quot;, which can be split across lines
as &quot;object-&quot;, newline, &quot;oriented&quot;),
formatters are encouraged to generally translate
&quot;-&quot; to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.</p>

<p>&middot; Pod formatters should make reasonable efforts
to keep words of Perl code from being broken across lines.
For example, &quot;Foo::Bar&quot; in some formatting systems
is seen as eligible for being broken across lines as
&quot;Foo::&quot; newline &quot;Bar&quot; or even
&quot;Foo::-&quot; newline &quot;Bar&quot;. This should be
avoided where possible, either by disabling all
line-breaking in mid-word, or by wrapping particular words
with internal punctuation in &quot;dont break this across
lines&quot; codes (which in some formats may not be a single
code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a
word.)</p>

<p>&middot; Pod parsers should, by default, expand tabs in
verbatim paragraphs as they are processed, before passing
them to the formatter or other processor. Parsers may also
allow an option for overriding this.</p>

<p>&middot; Pod parsers should, by default, remove newlines
from the end of ordinary and verbatim paragraphs before
passing them to the formatter. For example, while the
paragraph you re reading now could be considered, in Pod
source, to end with (and contain) the newline(s) that end
it, it should be processed as ending with (and containing)
the period character that ends this sentence.</p>

<p>&middot; Pod parsers, when reporting errors, should make
some effort to report an approximate line number
(&quot;Nested E&lt;&gt;s in Paragraph #52, near line 633 of
Thing/Foo.pm!&quot;), instead of merely noting the paragraph
number (&quot;Nested E&lt;&gt;s in Paragraph #52 of
Thing/Foo.pm!&quot;). Where this is problematic, the
paragraph number should at least be accompanied by an
excerpt from the paragraph (&quot;Nested E&lt;&gt;s in
Paragraph #52 of Thing/Foo.pm, which begins Read/write
accessor for the C&lt;interest rate&gt;
attribute...&quot;).</p>

<p>&middot; Pod parsers, when processing a series of
verbatim paragraphs one after another, should consider them
to be one large verbatim paragraph that happens to contain
blank lines. I.e., these two lines, which have a blank line
between them:</p>

<p>use Foo;</p>

<p>print Foo-&gt;VERSION</p>

<p>should be unified into one paragraph (&quot;use
Foo;0rint Foo-&gt;VERSION&quot;) before being passed to the
formatter or other processor. Parsers may also allow an
option for overriding this.</p>

<p>While this might be too cumbersome to implement in
event-based Pod parsers, it is straightforward for parsers
that return parse trees.</p>

<p>&middot; Pod formatters, where feasible, are advised to
avoid splitting short verbatim paragraphs (under twelve
lines, say) across pages.</p>

<p>&middot; Pod parsers must treat a line with only spaces
and/or tabs on it as a &quot;blank line&quot; such as
separates paragraphs. (Some older parsers recognized only
two adjacent newlines as a &quot;blank line&quot; but would
not recognize a newline, a space, and a newline, as a blank
line. This is noncompliant behavior.)</p>

<p>&middot; Authors of Pod formatters/processors should
make every effort to avoid writing their own Pod parser.
There are already several in CPAN, with a wide range of
interface styles -- and one of them, Pod::Parser, comes with
modern versions of Perl.</p>

<p>&middot; Characters in Pod documents may be conveyed
either as literals, or by number in E&lt;n&gt; codes, or by
an equivalent mnemonic, as in E&lt;eacute&gt; which is
exactly equivalent to E&lt;233&gt;.</p>

<p>Characters in the range 32-126 refer to those well known
US-ASCII characters (also defined there by Unicode, with the
same meaning), which all Pod formatters must render
faithfully. Characters in the ranges 0-31 and 127-159 should
not be used (neither as literals, nor as E&lt;number&gt;
codes), except for the literal byte-sequences for newline
(13, 13 10, or 10), and tab (9).</p>

<p>Characters in the range 160-255 refer to Latin-1
characters (also defined there by Unicode, with the same
meaning). Characters above 255 should be understood to refer
to Unicode characters.</p>

<p>&middot; Be warned that some formatters cannot reliably
render characters outside 32-126; and many are able to
handle 32-126 and 160-255, but nothing above 255.</p>

<p>&middot; Besides the well-known &quot;E&lt;lt&gt;&quot;
and &quot;E&lt;gt&gt;&quot; codes for less-than and
greater-than, Pod parsers must understand
&quot;E&lt;sol&gt;&quot; for &quot;/&quot; (solidus, slash),
and &quot;E&lt;verbar&gt;&quot; for &quot;|&quot; (vertical
bar, pipe). Pod parsers should also understand
&quot;E&lt;lchevron&gt;&quot; and
&quot;E&lt;rchevron&gt;&quot; as legacy codes for characters
171 and 187, i.e., &quot;left-pointing double angle
quotation mark&quot; = &quot;left pointing guillemet&quot;
and &quot;right-pointing double angle quotation mark&quot; =
&quot;right pointing guillemet&quot;. (These look like
little &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot;, and
they are now preferably expressed with the HTML/XHTML codes
&quot;E&lt;laquo&gt;&quot; and
&quot;E&lt;raquo&gt;&quot;.)</p>

<p>&middot; Pod parsers should understand all
&quot;E&lt;html&gt;&quot; codes as defined in the entity
declarations in the most recent XHTML specification at
&quot;www.W3.org&quot;. Pod parsers must understand at least
the entities that define characters in the range 160-255
(Latin-1). Pod parsers, when faced with some unknown
&quot;E&lt;identifier&gt;&quot; code, shouldn t simply
replace it with nullstring (by default, at least), but may
pass it through as a string consisting of the literal
characters E, less-than, identifier, greater-than. Or Pod
parsers may offer the alternative option of processing such
unknown &quot;E&lt;identifier&gt;&quot; codes by firing an
event especially for such codes, or by adding a special
node-type to the in-memory document tree. Such
&quot;E&lt;identifier&gt;&quot; may have special meaning to
some processors, or some processors may choose to add them
to a special error report.</p>

<p>&middot; Pod parsers must also support the XHTML codes
&quot;E&lt;quot&gt;&quot; for character 34 (doublequote,
&quot;), &quot;E&lt;amp&gt;&quot; for character 38
(ampersand, &amp;), and &quot;E&lt;apos&gt;&quot; for
character 39 (apostrophe, ).</p>

<p>&middot; Note that in all cases of
&quot;E&lt;whatever&gt;&quot;, whatever (whether an
htmlname, or a number in any base) must consist only of
alphanumeric characters -- that is, whatever must watch
&quot;m/1 spaces, which aren t alphanumeric characters. This
presumably does not need special treatment by a Pod
processor; &quot; 0 1 2 3 &quot; doesnt look like a number
in any base, so it would presumably be looked up in the
table of HTML-like names. Since there isn t (and cannot be)
an HTML-like entity called &quot; 0 1 2 3 &quot;, this will
be treated as an error. However, Pod processors may treat
&quot;E&lt; 0 1 2 3 &gt;&quot; or
&quot;E&lt;e-acute&gt;&quot; as syntactically invalid,
potentially earning a different error message than the error
message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in
&quot;E&lt;qacute&gt;&quot; [sic]. However, Pod parsers are
not required to make this distinction.</p>

<p>&middot; Note that E&lt;number&gt; must not be
interpreted as simply &quot;codepoint number in the
current/native character set&quot;. It always means only
&quot;the character represented by codepoint number in
Unicode.&quot; (This is identical to the semantics of
&amp;#number; in XML.)</p>

<p>This will likely require many formatters to have tables
mapping from treatable Unicode codepoints (such as the
&quot; for the e-acute character) to the escape sequences or
codes necessary for conveying such sequences in the target
output format. A converter to *roff would, for example know
that &quot; (whether conveyed literally, or via a
E&lt;...&gt; sequence) is to be conveyed as &quot;e\*&quot;.
Similarly, a program rendering Pod in a Mac OS application
window, would presumably need to know that &quot; maps to
codepoint 142 in MacRoman encoding that (at time of writing)
is native for Mac OS. Such Unicode2whatever mappings are
presumably already widely available for common output
formats. (Such mappings may be incomplete! Implementers are
not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical
symbols, or any of the other weird things that Unicode can
encode.) And if a Pod document uses a character not found in
such a mapping, the formatter should consider it an
unrenderable character.</p>

<p>&middot; If, surprisingly, the implementor of a Pod
formatter cant find a satisfactory pre-existing table
mapping from Unicode characters to escapes in the target
format (e.g., a decent table of Unicode characters to *roff
escapes), it will be necessary to build such a table. If you
are in this circumstance, you should begin with the
characters in the range 0x00A0 - 0x00FF, which is mostly the
heavily used accented characters. Then proceed (as patience
permits and fastidiousness compels) through the characters
that the (X)HTML standards groups judged important enough to
merit mnemonics for. These are declared in the (X)HTML
specifications at the www.W3.org site. At time of writing
(September 2001), the most recent entity declaration files
are:</p>

<p>http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</p>

<p>Then you can progress through any remaining notable
Unicode characters in the range 0x2000-0x204D (consult the
character tables at www.unicode.org), and whatever else
strikes your fancy. For example, in xhtml-symbol.ent, there
is the entry:</p>

<p>&lt;!ENTITY infin &quot;&amp;#8734;&quot;&gt; &lt;!--
infinity, U+221E ISOtech --&gt;</p>

<p>While the mapping &quot;infin&quot; to the character
&quot;}&quot; will (hopefully) have been already handled by
the Pod parser, the presence of the character in this file
means that it s reasonably important enough to include in a
formatters table that maps from notable Unicode characters
to the codes necessary for rendering them. So for a
Unicode-to-*roff mapping, for example, this would merit the
entry:</p>

<p>&quot;}&quot; =&gt; &rsquo;&rsquo;,</p>

<p>It is eagerly hoped that in the future, increasing
numbers of formats (and formatters) will support Unicode
characters directly (as (X)HTML does with
&quot;&amp;infin;&quot;, &quot;&amp;#8734;&quot;, or
&quot;&amp;#x221E;&quot;), reducing the need for
idiosyncratic mappings of Unicode-to-my_escapes.</p>

<p>&middot; It is up to individual Pod formatter to display
good judgement when confronted with an unrenderable
character (which is distinct from an unknown E&lt;thing&gt;
sequence that the parser couldnt resolve to anything,
renderable or not). It is good practice to map Latin letters
with diacritics (like
&quot;E&lt;eacute&gt;&quot;/&quot;E&lt;233&gt;&quot;) to the
corresponding unaccented US-ASCII letters (like a simple
character 101, &quot;e&quot;), but clearly this is often not
feasible, and an unrenderable character may be represented
as &quot;?&quot;, or the like. In attempting a sane fallback
(as from E&lt;233&gt; to &quot;e&quot;), Pod formatters may
use the %Latin1Code_to_fallback table in Pod::Escapes, or
Text::Unidecode, if available.</p>

<p>For example, this Pod text:</p>

<p>magic is enabled if you set C&lt;$Currency&gt; to
&rsquo;E&lt;euro&gt;&rsquo;.</p>

<p>may be rendered as: &quot;magic is enabled if you set
$Currency to ?&quot; or as &quot;magic is enabled if you set
$Currency to [euro] &quot;, or as &quot;magic is enabled if
you set $Currency to [x20AC] , etc.</p>

<p>A Pod formatter may also note, in a comment or warning,
a list of what unrenderable characters were encountered.</p>

<p>&middot; E&lt;...&gt; may freely appear in any
formatting code (other than in another E&lt;...&gt; or in an
Z&lt;&gt;). That is, &quot;X&lt;The E&lt;euro&gt;1,000,000
Solution&gt;&quot; is valid, as is &quot;L&lt;The
E&lt;euro&gt;1,000,000
Solution|Million::Euros&gt;&quot;.</p>

<p>&middot; Some Pod formatters output to formats that
implement non-breaking spaces as an individual character
(which Ill call &quot;NBSP&quot;), and others output to
formats that implement non-breaking spaces just as spaces
wrapped in a &quot;dont break this across lines&quot; code.
Note that at the level of Pod, both sorts of codes can
occur: Pod can contain a NBSP character (whether as a
literal, or as a &quot;E&lt;160&gt;&quot; or
&quot;E&lt;nbsp&gt;&quot; code); and Pod can contain
&quot;S&lt;foo I&lt;bar&gt; baz&gt;&quot; codes, where
&quot;mere spaces&quot; (character 32) in such codes are
taken to represent non-breaking spaces. Pod parsers should
consider supporting the optional parsing of &quot;S&lt;foo
I&lt;bar&gt; baz&gt;&quot; as if it were
&quot;fooNBSPI&lt;bar&gt;NBSPbaz&quot;, and, going the other
way, the optional parsing of groups of words joined by NBSPs
as if each group were in a S&lt;...&gt; code, so that
formatters may use the representation that maps best to what
the output format demands.</p>

<p>&middot; Some processors may find that the
&quot;S&lt;...&gt;&quot; code is easiest to implement by
replacing each space in the parse tree under the content of
the S, with an NBSP. But note: the replacement should apply
not to spaces in all text, but only to spaces in printable
text. (This distinction may or may not be evident in the
particular tree/event model implemented by the Pod parser.)
For example, consider this unusual case:</p>

<p>S&lt;L&lt;/Autoloaded Functions&gt;&gt;</p>

<p>This means that the space in the middle of the visible
link text must not be broken across lines. In other words,
it s the same as this:</p>


<p>L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/Autoloaded
Functions&gt;</p>

<p>However, a misapplied space-to-NBSP replacement could
(wrongly) produce something equivalent to this:</p>


<p>L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/AutoloadedE&lt;160&gt;Functions&gt;</p>

<p>...which is almost definitely not going to work as a
hyperlink (assuming this formatter outputs a format
supporting hypertext).</p>

<p>Formatters may choose to just not support the S format
code, especially in cases where the output format simply has
no NBSP character/code and no code for &quot;dont break this
stuff across lines&quot;.</p>

<p>&middot; Besides the NBSP character discussed above,
implementors are reminded of the existence of the other
&quot;special&quot; character in Latin-1, the &quot;soft
hyphen&quot; character, also known as &quot;discretionary
hyphen&quot;, i.e. &quot;E&lt;173&gt;&quot; =
&quot;E&lt;0xAD&gt;&quot; = &quot;E&lt;shy&gt;&quot;). This
character expresses an optional hyphenation point. That is,
it normally renders as nothing, but may render as a
&quot;-&quot; if a formatter breaks the word at that point.
Pod formatters should, as appropriate, do one of the
following: 1) render this with a code with the same meaning
(e.g., &quot;&minus;&quot; in RTF), 2) pass it through in
the expectation that the formatter understands this
character as such, or 3) delete it.</p>

<p>For example:</p>

<p>sigE&lt;shy&gt;action manuE&lt;shy&gt;script
JarkE&lt;shy&gt;ko
HieE&lt;shy&gt;taE&lt;shy&gt;nieE&lt;shy&gt;mi</p>

<p>These signal to a formatter that if it is to hyphenate
&quot;sigaction&quot; or &quot;manuscript&quot;, then it
should be done as &quot;sig-[linebreak]action&quot; or
&quot;manu-[linebreak]script&quot; (and if it doesn t
hyphenate it, then the &quot;E&lt;shy&gt;&quot; doesnt show
up at all). And if it is to hyphenate &quot;Jarkko&quot;
and/or &quot;Hietaniemi&quot;, it can do so only at the
points where there is a &quot;E&lt;shy&gt;&quot; code.</p>

<p>In practice, it is anticipated that this character will
not be used often, but formatters should either support it,
or delete it.</p>

<p>&middot; If you think that you want to add a new command
to Pod (like, say, a &quot;=biblio&quot; command), consider
whether you could get the same effect with a for or
begin/end sequence: &quot;=for biblio ...&quot; or
&quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod
processors that dont understand &quot;=for biblio&quot;,
etc, will simply ignore it, whereas they may complain loudly
if they see &quot;=biblio&quot;.</p>

<p>&middot; Throughout this document, &quot;Pod&quot; has
been the preferred spelling for the name of the
documentation format. One may also use &quot;POD&quot; or
&quot;pod&quot;. For the documentation that is (typically)
in the Pod format, you may use &quot;pod&quot;, or
&quot;Pod&quot;, or &quot;POD&quot;. Understanding these
distinctions is useful; but obsessing over how to spell
them, usually is not.</p>

<p>About L&lt;...&gt; Codes As you can tell from a glance
at perlpod, the L&lt;...&gt; code is the most complex of the
Pod formatting codes. The points below will hopefully
clarify what it means and how processors should deal with
it.</p>

<p>&middot; In parsing an L&lt;...&gt; code, Pod parsers
must distinguish at least four attributes:</p>

<p>First: The link-text. If there is none, this must be
undef. (E.g., in &quot;L&lt;Perl
Functions|perlfunc&gt;&quot;, the link-text is &quot;Perl
Functions&quot;. In &quot;L&lt;Time::HiRes&gt;&quot; and
even &quot;L&lt;|Time::HiRes&gt;&quot;, there is no link
text. Note that link text may contain formatting.)</p>

<p>Second: The possibly inferred link-text -- i.e., if
there was no real link text, then this is the text that well
infer in its place. (E.g., for
&quot;L&lt;Getopt::Std&gt;&quot;, the inferred link text is
&quot;Getopt::Std&quot;.)</p>

<p>Third: The name or URL, or undef if none. (E.g., in
&quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the name --
also sometimes called the page -- is &quot;perlfunc&quot;.
In &quot;L&lt;/CAVEATS&gt;&quot;, the name is undef.)</p>

<p>Fourth: The section (AKA &quot;item&quot; in older
perlpods), or undef if none. E.g., in
&quot;L&lt;Getopt::Std/DESCRIPTION&gt;&quot;,
&quot;DESCRIPTION&quot; is the section. (Note that this is
not the same as a manpage section like the &quot;5&quot; in
&quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the
Pod sense means the part of the text thats introduced by the
heading or item whose text is &quot;Foo&quot;.)</p>

<p>Pod parsers may also note additional attributes
including:</p>

<p>Fifth: A flag for whether item 3 (if present) is a URL
(like &quot;http://lists.perl.org&quot; is), in which case
there should be no section attribute; a Pod name (like
&quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or
possibly a man page name (like &quot;crontab(5)&quot;
is).</p>

<p>Sixth: The raw original L&lt;...&gt; content, before
text is split on &quot;|&quot;, &quot;/&quot;, etc, and
before E&lt;...&gt; codes are expanded.</p>

<p>(The above were numbered only for concise reference
below. It is not a requirement that these be passed as an
actual list or array.)</p>

<p>For example:</p>

<p>L&lt;Foo::Bar&gt; =&gt; undef, # link text
&quot;Foo::Bar&quot;, # possibly inferred link text
&quot;Foo::Bar&quot;, # name undef, # section
&rsquo;pod&rsquo;, # what sort of link &quot;Foo::Bar&quot;
# original content</p>

<p>L&lt;Perlport&rsquo;s section on
NL&rsquo;s|perlport/Newlines&gt; =&gt;
&quot;Perlport&rsquo;s section on NL&rsquo;s&quot;, # link
text &quot;Perlport&rsquo;s section on NL&rsquo;s&quot;, #
possibly inferred link text &quot;perlport&quot;, # name
&quot;Newlines&quot;, # section &rsquo;pod&rsquo;, # what
sort of link &quot;Perlport&rsquo;s section on
NL&rsquo;s|perlport/Newlines&quot; # orig. content</p>

<p>L&lt;perlport/Newlines&gt; =&gt; undef, # link text
&rsquo;&quot;Newlines&quot; in perlport&rsquo;, # possibly
inferred link text &quot;perlport&quot;, # name
&quot;Newlines&quot;, # section &rsquo;pod&rsquo;, # what
sort of link &quot;perlport/Newlines&quot; # original
content</p>

<p>L&lt;crontab(5)/&quot;DESCRIPTION&quot;&gt; =&gt; undef,
# link text &rsquo;&quot;DESCRIPTION&quot; in
crontab(5)&rsquo;, # possibly inferred link text
&quot;crontab(5)&quot;, # name &quot;DESCRIPTION&quot;, #
section &rsquo;man&rsquo;, # what sort of link
&rsquo;crontab(5)/&quot;DESCRIPTION&quot;&rsquo; # original
content</p>

<p>L&lt;/Object Attributes&gt; =&gt; undef, # link text
&rsquo;&quot;Object Attributes&quot;&rsquo;, # possibly
inferred link text undef, # name &quot;Object
Attributes&quot;, # section &rsquo;pod&rsquo;, # what sort
of link &quot;/Object Attributes&quot; # original
content</p>

<p>L&lt;http://www.perl.org/&gt; =&gt; undef, # link text
&quot;http://www.perl.org/&quot;, # possibly inferred link
text &quot;http://www.perl.org/&quot;, # name undef, #
section &rsquo;url&rsquo;, # what sort of link
&quot;http://www.perl.org/&quot; # original content</p>

<p>L&lt;Perl.org|http://www.perl.org/&gt; =&gt;
&quot;Perl.org&quot;, # link text
&quot;http://www.perl.org/&quot;, # possibly inferred link
text &quot;http://www.perl.org/&quot;, # name undef, #
section &rsquo;url&rsquo;, # what sort of link
&quot;Perl.org|http://www.perl.org/&quot; # original
content</p>

<p>Note that you can distinguish URL-links from anything
else by the fact that they match &quot;m/1
&quot;L&lt;http://www.perl.com&gt;&quot; is a URL, but
&quot;L&lt;HTTP::Response&gt;&quot; isn t.</p>

<p>&middot; In case of L&lt;...&gt; codes with no
&quot;text|&quot; part in them, older formatters have
exhibited great variation in actually displaying the link or
cross reference. For example, L&lt;crontab(5)&gt; would
render as &quot;the crontab(5) manpage&quot;, or &quot;in
the crontab(5) manpage&quot; or just
&quot;crontab(5)&quot;.</p>

<p>Pod processors must now treat &quot;text|&quot;-less
links as follows:</p>

<p>L&lt;name&gt; =&gt; L&lt;name|name&gt; L&lt;/section&gt;
=&gt; L&lt;&quot;section&quot;|/section&gt;
L&lt;name/section&gt; =&gt; L&lt;&quot;section&quot; in
name|name/section&gt;</p>

<p>&middot; Note that section names might contain markup.
I.e., if a section starts with:</p>

<p>=head2 About the C&lt;-M&gt; Operator</p>

<p>or with:</p>

<p>=item About the C&lt;-M&gt; Operator</p>

<p>then a link to it would look like this:</p>

<p>L&lt;somedoc/About the C&lt;-M&gt; Operator&gt;</p>

<p>Formatters may choose to ignore the markup for purposes
of resolving the link and use only the renderable characters
in the section name, as in:</p>

<p>&lt;h1&gt;&lt;a
name=&quot;About_the_-M_Operator&quot;&gt;About the
&lt;code&gt;-M&lt;/code&gt; Operator&lt;/h1&gt;</p>

<p>...</p>

<p>&lt;a
href=&quot;somedoc#About_the_-M_Operator&quot;&gt;About the
&lt;code&gt;-M&lt;/code&gt; Operator&quot; in
somedoc&lt;/a&gt;</p>

<p>&middot; Previous versions of perlpod distinguished
&quot;L&lt;name/&quot;section&quot;&gt;&quot; links from
&quot;L&lt;name/item&gt;&quot; links (and their targets).
These have been merged syntactically and semantically in the
current specification, and section can refer either to a
&quot;=headn Heading Content&quot; command or to a
&quot;=item Item Content&quot; command. This specification
does not specify what behavior should be in the case of a
given document having several things all seeming to produce
the same section identifier (e.g., in HTML, several things
all producing the same anchorname in &lt;a
name=&quot;anchorname&quot;&gt;...&lt;/a&gt; elements).
Where Pod processors can control this behavior, they should
use the first such anchor. That is,
&quot;L&lt;Foo/Bar&gt;&quot; refers to the first
&quot;Bar&quot; section in Foo.</p>

<p>But for some processors/formats this cannot be easily
controlled; as with the HTML example, the behavior of
multiple ambiguous &lt;a
name=&quot;anchorname&quot;&gt;...&lt;/a&gt; is most easily
just left up to browsers to decide.</p>

<p>&middot; Authors wanting to link to a particular
(absolute) URL, must do so only with
&quot;L&lt;scheme:...&gt;&quot; codes (like
L&lt;http://www.perl.org&gt;), and must not attempt
&quot;L&lt;Some Site Name|scheme:...&gt;&quot; codes. This
restriction avoids many problems in parsing and rendering
L&lt;...&gt; codes.</p>

<p>&middot; In a &quot;L&lt;text|...&gt;&quot; code, text
may contain formatting codes for formatting or for
E&lt;...&gt; escapes, as in:</p>

<p>L&lt;B&lt;ummE&lt;234&gt;stuff&gt;|...&gt;</p>

<p>For &quot;L&lt;...&gt;&quot; codes without a
&quot;name|&quot; part, only &quot;E&lt;...&gt;&quot; and
&quot;Z&lt;&gt;&quot; codes may occur -- no other formatting
codes. That is, authors should not use
&quot;&quot;L&lt;B&lt;Foo::Bar&gt;&gt;&quot;&quot;.</p>

<p>Note, however, that formatting codes and Z&lt;&gt;s can
occur in any and all parts of an L&lt;...&gt; (i.e., in
name, section, text, and url).</p>

<p>Authors must not nest L&lt;...&gt; codes. For example,
&quot;L&lt;The L&lt;Foo::Bar&gt; man page&gt;&quot; should
be treated as an error.</p>

<p>&middot; Note that Pod authors may use formatting codes
inside the &quot;text&quot; part of
&quot;L&lt;text|name&gt;&quot; (and so on for
L&lt;text|/&quot;sec&quot;&gt;).</p>

<p>In other words, this is valid:</p>

<p>Go read L&lt;the docs on
C&lt;$.&gt;|perlvar/&quot;$.&quot;&gt;</p>

<p>Some output formats that do allow rendering
&quot;L&lt;...&gt;&quot; codes as hypertext, might not allow
the link-text to be formatted; in that case, formatters will
have to just ignore that formatting.</p>

<p>&middot; At time of writing, &quot;L&lt;name&gt;&quot;
values are of two types: either the name of a Pod page like
&quot;L&lt;Foo::Bar&gt;&quot; (which might be a real Perl
module or program in an @INC / PATH directory, or a .pod
file in those places); or the name of a UNIX man page, like
&quot;L&lt;crontab(5)&gt;&quot;. In theory,
&quot;L&lt;chmod&gt;&quot; in ambiguous between a Pod page
called &quot;chmod&quot;, or the Unix man page
&quot;chmod&quot; (in whatever man- section). However, the
presence of a string in parens, as in
&quot;crontab(5)&quot;, is sufficient to signal that what is
being discussed is not a Pod page, and so is presumably a
UNIX man page. The distinction is of no importance to many
Pod processors, but some processors that render to hypertext
formats may need to distinguish them in order to know how to
render a given &quot;L&lt;foo&gt;&quot; code.</p>

<p>&middot; Previous versions of perlpod allowed for a
&quot;L&lt;section&gt;&quot; syntax (as in &quot;L&lt;Object
Attributes&gt;&quot;), which was not easily distinguishable
from &quot;L&lt;name&gt;&quot; syntax and for
&quot;L&lt;&quot;section&quot;&gt;&quot; which was only
slightly less ambiguous. This syntax is no longer in the
specification, and has been replaced by the
&quot;L&lt;/section&gt;&quot; syntax (where the slash was
formerly optional). Pod parsers should tolerate the
&quot;L&lt;&quot;section&quot;&gt;&quot; syntax, for a while
at least. The suggested heuristic for distinguishing
&quot;L&lt;section&gt;&quot; from &quot;L&lt;name&gt;&quot;
is that if it contains any whitespace, its a section. Pod
processors should warn about this being deprecated
syntax.</p>

<p>About =over...=back Regions
&quot;=over&quot;...&quot;=back&quot; regions are used for
various kinds of list-like structures. (I use the term
&quot;region&quot; here simply as a collective term for
everything from the &quot;=over&quot; to the matching
&quot;=back&quot;.)</p>

<p>&middot; The non-zero numeric indentlevel in &quot;=over
indentlevel&quot; ... &quot;=back&quot; is used for giving
the formatter a clue as to how many &quot;spaces&quot; (ems,
or roughly equivalent units) it should tab over, although
many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of
spaces (or M s) in the documents base font. Other formatters
may have to completely ignore the number. The lack of any
explicit indentlevel parameter is equivalent to an
indentlevel value of 4. Pod processors may complain if
indentlevel is present but is not a positive number matching
&quot;m/0 &middot; Authors of Pod formatters are reminded
that &quot;=over&quot; ... &quot;=back&quot; may map to
several different constructs in your output format. For
example, in converting Pod to (X)HTML, it can map to any of
&lt;ul&gt;...&lt;/ul&gt;, &lt;ol&gt;...&lt;/ol&gt;,
&lt;dl&gt;...&lt;/dl&gt;, or
&lt;blockquote&gt;...&lt;/blockquote&gt;. Similarly,
&quot;=item&quot; can map to &lt;li&gt; or &lt;dt&gt;.</p>

<p>&middot; Each &quot;=over&quot; ... &quot;=back&quot;
region should be one of the following:</p>

<p>&middot; An &quot;=over&quot; ... &quot;=back&quot;
region containing only &quot;=item *&quot; commands, each
followed by some number of ordinary/verbatim paragraphs,
other nested &quot;=over&quot; ... &quot;=back&quot;
regions, &quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions.</p>

<p>(Pod processors must tolerate a bare &quot;=item&quot;
as if it were &quot;=item *&quot;.) Whether &quot;*&quot; is
rendered as a literal asterisk, an &quot;o&quot;, or as some
kind of real bullet character, is left up to the Pod
formatter, and may depend on the level of nesting.</p>

<p>&middot; An &quot;=over&quot; ... &quot;=back&quot;
region containing only &quot;m/0 of them) followed by some
number of ordinary/verbatim paragraphs, other nested
&quot;=over&quot; ... &quot;=back&quot; regions,
&quot;=for...&quot; paragraphs, and/or
&quot;=begin&quot;...&quot;=end&quot; codes. Note that the
numbers must start at 1 in each section, and must proceed in
order and without skipping numbers.</p>

<p>(Pod processors must tolerate lines like &quot;=item
1&quot; as if they were &quot;=item 1.&quot;, with the
period.)</p>

<p>&middot; An &quot;=over&quot; ... &quot;=back&quot;
region containing only &quot;=item [text]&quot; commands,
each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested &quot;=over&quot;
... &quot;=back&quot; regions, or &quot;=for...&quot;
paragraphs, and &quot;=begin&quot;...&quot;=end&quot;
regions.</p>

<p>The &quot;=item [text]&quot; paragraph should not match
&quot;m/0 &middot; An &quot;=over&quot; ...
&quot;=back&quot; region containing no &quot;=item&quot;
paragraphs at all, and containing only some number of
ordinary/verbatim paragraphs, and possibly also some nested
&quot;=over&quot; ... &quot;=back&quot; regions,
&quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions. Such an
itemless &quot;=over&quot; ... &quot;=back&quot; region in
Pod is equivalent in meaning to a
&quot;&lt;blockquote&gt;...&lt;/blockquote&gt;&quot; element
in HTML.</p>

<p>Note that with all the above cases, you can determine
which type of &quot;=over&quot; ... &quot;=back&quot; you
have, by examining the first (non-&quot;=cut&quot;,
non-&quot;=pod&quot;) Pod paragraph after the
&quot;=over&quot; command.</p>

<p>&middot; Pod formatters must tolerate arbitrarily large
amounts of text in the &quot;=item text...&quot; paragraph.
In practice, most such paragraphs are short, as in:</p>

<p>=item For cutting off our trade with all parts of the
world</p>

<p>But they may be arbitrarily long:</p>

<p>=item For transporting us beyond seas to be tried for
pretended offenses</p>

<p>=item He is at this time transporting large armies of
foreign mercenaries to complete the works of death,
desolation and tyranny, already begun with circumstances of
cruelty and perfidy scarcely paralleled in the most
barbarous ages, and totally unworthy the head of a civilized
nation.</p>

<p>&middot; Pod processors should tolerate &quot;=item
*&quot; / &quot;=item number&quot; commands with no
accompanying paragraph. The middle item is an example:</p>

<p>=over</p>

<p>=item 1</p>

<p>Pick up dry cleaning.</p>

<p>=item 2</p>

<p>=item 3</p>

<p>Stop by the store. Get Abba Zabas, Stoli, and cheap lawn
chairs.</p>

<p>=back</p>

<p>&middot; No &quot;=over&quot; ... &quot;=back&quot;
region can contain headings. Processors may treat such a
heading as an error.</p>

<p>&middot; Note that an &quot;=over&quot; ...
&quot;=back&quot; region should have some content. That is,
authors should not have an empty region like this:</p>

<p>=over</p>

<p>=back</p>

<p>Pod processors seeing such a contentless
&quot;=over&quot; ... &quot;=back&quot; region, may ignore
it, or may report it as an error.</p>

<p>&middot; Processors must tolerate an &quot;=over&quot;
list that goes off the end of the document (i.e., which has
no matching &quot;=back&quot;), but they may warn about such
a list.</p>

<p>&middot; Authors of Pod formatters should note that this
construct:</p>

<p>=item Neque</p>

<p>=item Porro</p>

<p>=item Quisquam Est</p>

<p>Qui dolorem ipsum quia dolor sit amet, consectetur,
adipisci velit, sed quia non numquam eius modi tempora
incidunt ut labore et dolore magnam aliquam quaerat
voluptatem.</p>

<p>=item Ut Enim</p>

<p>is semantically ambiguous, in a way that makes
formatting decisions a bit difficult. On the one hand, it
could be mention of an item &quot;Neque&quot;, mention of
another item &quot;Porro&quot;, and mention of another item
&quot;Quisquam Est&quot;, with just the last one requiring
the explanatory paragraph &quot;Qui dolorem ipsum quia
dolor...&quot;; and then an item &quot;Ut Enim&quot;. In
that case, youd want to format it like so:</p>

<p>Neque</p>

<p>Porro</p>

<p>Quisquam Est Qui dolorem ipsum quia dolor sit amet,
consectetur, adipisci velit, sed quia non numquam eius modi
tempora incidunt ut labore et dolore magnam aliquam quaerat
voluptatem.</p>

<p>Ut Enim</p>

<p>But it could equally well be a discussion of three
(related or equivalent) items, &quot;Neque&quot;,
&quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by
a paragraph explaining them all, and then a new item
&quot;Ut Enim&quot;. In that case, youd probably want to
format it like so:</p>

<p>Neque Porro Quisquam Est Qui dolorem ipsum quia dolor
sit amet, consectetur, adipisci velit, sed quia non numquam
eius modi tempora incidunt ut labore et dolore magnam
aliquam quaerat voluptatem.</p>

<p>Ut Enim</p>

<p>But (for the foreseeable future), Pod does not provide
any way for Pod authors to distinguish which grouping is
meant by the above &quot;=item&quot;-cluster structure. So
formatters should format it like so:</p>

<p>Neque</p>

<p>Porro</p>

<p>Quisquam Est</p>

<p>Qui dolorem ipsum quia dolor sit amet, consectetur,
adipisci velit, sed quia non numquam eius modi tempora
incidunt ut labore et dolore magnam aliquam quaerat
voluptatem.</p>

<p>Ut Enim</p>

<p>That is, there should be (at least roughly) equal
spacing between items as between paragraphs (although that
spacing may well be less than the full height of a line of
text). This leaves it to the reader to use (con)textual cues
to figure out whether the &quot;Qui dolorem ipsum...&quot;
paragraph applies to the &quot;Quisquam Est&quot; item or to
all three items &quot;Neque&quot;, &quot;Porro&quot;, and
&quot;Quisquam Est&quot;. While not an ideal situation, this
is preferable to providing formatting cues that may be
actually contrary to the authors intent.</p>

<p>About Data Paragraphs and &quot;=begin/=end&quot;
Regions Data paragraphs are typically used for inlining
non-Pod data that is to be used (typically passed through)
when rendering the document to a specific format:</p>

<p>=begin rtf</p>

<p>ar{ardqri Printed =end rtf</p>

<p>The exact same effect could, incidentally, be achieved
with a single &quot;=for&quot; paragraph:</p>

<p>=for rtf ar{ardqri Printed (Although that is not
formally a data paragraph, it has the same meaning as one,
and Pod parsers may parse it as one.)</p>

<p>Another example of a data paragraph:</p>

<p>=begin html</p>

<p>I like &lt;em&gt;PIE&lt;/em&gt;!</p>

<p>&lt;hr&gt;Especially pecan pie!</p>

<p>=end html</p>

<p>If these were ordinary paragraphs, the Pod parser would
try to expand the &quot;E&lt;/em&gt;&quot; (in the first
paragraph) as a formatting code, just like
&quot;E&lt;lt&gt;&quot; or &quot;E&lt;eacute&gt;&quot;. But
since this is in a &quot;=begin
identifier&quot;...&quot;=end identifier&quot; region and
the identifier &quot;html&quot; doesnt begin have a
&quot;:&quot; prefix, the contents of this region are stored
as data paragraphs, instead of being processed as ordinary
paragraphs (or if they began with a spaces and/or tabs, as
verbatim paragraphs).</p>

<p>As a further example: At time of writing, no
&quot;biblio&quot; identifier is supported, but suppose some
processor were written to recognize it as a way of (say)
denoting a bibliographic reference (necessarily containing
formatting codes in ordinary paragraphs). The fact that
&quot;biblio&quot; paragraphs were meant for ordinary
processing would be indicated by prefacing each
&quot;biblio&quot; identifier with a colon:</p>

<p>=begin :biblio</p>

<p>Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures
= Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p>=end :biblio</p>

<p>This would signal to the parser that paragraphs in this
begin...end region are subject to normal handling as
ordinary/verbatim paragraphs (while still tagged as meant
only for processors that understand the &quot;biblio&quot;
identifier). The same effect could be had with:</p>

<p>=for :biblio Wirth, Niklaus. 1976. I&lt;Algorithms +
Data Structures = Programs.&gt; Prentice-Hall, Englewood
Cliffs, NJ.</p>

<p>The &quot;:&quot; on these identifiers means simply
&quot;process this stuff normally, even though the result
will be for some special target&quot;. I suggest that parser
APIs report &quot;biblio&quot; as the target identifier, but
also report that it had a &quot;:&quot; prefix. (And
similarly, with the above &quot;html&quot;, report
&quot;html&quot; as the target identifier, and note the lack
of a &quot;:&quot; prefix.)</p>

<p>Note that a &quot;=begin identifier&quot;...&quot;=end
identifier&quot; region where identifier begins with a
colon, can contain commands. For example:</p>

<p>=begin :biblio</p>

<p>Wirth&rsquo;s classic is available in several editions,
including:</p>

<p>=for comment hm, check abebooks.com for how much used
copies cost.</p>

<p>=over</p>

<p>=item</p>

<p>Wirth, Niklaus. 1975. I&lt;Algorithmen und
Datenstrukturen.&gt; Teubner, Stuttgart. [Yes, it&rsquo;s in
German.]</p>

<p>=item</p>

<p>Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures
= Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p>=back</p>

<p>=end :biblio</p>

<p>Note, however, a &quot;=begin
identifier&quot;...&quot;=end identifier&quot; region where
identifier does not begin with a colon, should not directly
contain &quot;=head1&quot; ... &quot;=head4&quot; commands,
nor &quot;=over&quot;, nor &quot;=back&quot;, nor
&quot;=item&quot;. For example, this may be considered
invalid:</p>

<p>=begin somedata</p>

<p>This is a data paragraph.</p>

<p>=head1 Don&rsquo;t do this!</p>

<p>This is a data paragraph too.</p>

<p>=end somedata</p>

<p>A Pod processor may signal that the above (specifically
the &quot;=head1&quot; paragraph) is an error. Note,
however, that the following should not be treated as an
error:</p>

<p>=begin somedata</p>

<p>This is a data paragraph.</p>

<p>=cut</p>

<p># Yup, this isn&rsquo;t Pod anymore. sub excl { (rand()
&gt; .5) ? &quot;hoo!&quot; : &quot;hah!&quot; }</p>

<p>=pod</p>

<p>This is a data paragraph too.</p>

<p>=end somedata</p>

<p>And this too is valid:</p>

<p>=begin someformat</p>

<p>This is a data paragraph.</p>

<p>And this is a data paragraph.</p>

<p>=begin someotherformat</p>

<p>This is a data paragraph too.</p>

<p>And this is a data paragraph too.</p>

<p>=begin :yetanotherformat</p>

<p>=head2 This is a command paragraph!</p>

<p>This is an ordinary paragraph!</p>

<p>And this is a verbatim paragraph!</p>

<p>=end :yetanotherformat</p>

<p>=end someotherformat</p>

<p>Another data paragraph!</p>

<p>=end someformat</p>

<p>The contents of the above &quot;=begin
:yetanotherformat&quot; ... &quot;=end
:yetanotherformat&quot; region arent data paragraphs,
because the immediately containing region s identifier
(&quot;:yetanotherformat&quot;) begins with a colon. In
practice, most regions that contain data paragraphs will
contain only data paragraphs; however, the above nesting is
syntactically valid as Pod, even if it is rare. However, the
handlers for some formats, like &quot;html&quot;, will
accept only data paragraphs, not nested regions; and they
may complain if they see (targeted for them) nested regions,
or commands, other than &quot;=end&quot;, &quot;=pod&quot;,
and &quot;=cut&quot;.</p>

<p>Also consider this valid structure:</p>

<p>=begin :biblio</p>

<p>Wirth&rsquo;s classic is available in several editions,
including:</p>

<p>=over</p>

<p>=item</p>

<p>Wirth, Niklaus. 1975. I&lt;Algorithmen und
Datenstrukturen.&gt; Teubner, Stuttgart. [Yes, it&rsquo;s in
German.]</p>

<p>=item</p>

<p>Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures
= Programs.&gt; Prentice-Hall, Englewood Cliffs, NJ.</p>

<p>=back</p>

<p>Buy buy buy!</p>

<p>=begin html</p>

<p>&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;</p>

<p>&lt;hr&gt;</p>

<p>=end html</p>

<p>Now now now!</p>

<p>=end :biblio</p>

<p>There, the &quot;=begin html&quot;...&quot;=end
html&quot; region is nested inside the larger &quot;=begin
:biblio&quot;...&quot;=end :biblio&quot; region. Note that
the content of the &quot;=begin html&quot;...&quot;=end
html&quot; region is data paragraph(s), because the
immediately containing region s identifier
(&quot;html&quot;) doesnt begin with a colon.</p>

<p>Pod parsers, when processing a series of data paragraphs
one after another (within a single region), should consider
them to be one large data paragraph that happens to contain
blank lines. So the content of the above &quot;=begin
html&quot;...&quot;=end html&quot; may be stored as two data
paragraphs (one consisting of &quot;&lt;img
src=wirth_spokesmodeling_book.png&gt;0 and another
consisting of &quot;&lt;hr&gt;0), but should be stored as a
single data paragraph (consisting of &quot;&lt;img
src=wirth_spokesmodeling_book.png&gt;0hr&gt;0).</p>

<p>Pod processors should tolerate empty &quot;=begin
something&quot;...&quot;=end something&quot; regions, empty
&quot;=begin :something&quot;...&quot;=end :something&quot;
regions, and contentless &quot;=for something&quot; and
&quot;=for :something&quot; paragraphs. I.e., these should
be tolerated:</p>

<p>=for html</p>

<p>=begin html</p>

<p>=end html</p>

<p>=begin :biblio</p>

<p>=end :biblio</p>

<p>Incidentally, note that theres no easy way to express a
data paragraph starting with something that looks like a
command. Consider:</p>

<p>=begin stuff</p>

<p>=shazbot</p>

<p>=end stuff</p>

<p>There, &quot;=shazbot&quot; will be parsed as a Pod
command &quot;shazbot&quot;, not as a data paragraph
&quot;=shazbot0. However, you can express a data paragraph
consisting of &quot;=shazbot0 using this code:</p>

<p>=for stuff =shazbot</p>

<p>The situation where this is necessary, is presumably
quite rare.</p>

<p>Note that =end commands must match the currently open
=begin command. That is, they must properly nest. For
example, this is valid:</p>

<p>=begin outer</p>

<p>X</p>

<p>=begin inner</p>

<p>Y</p>

<p>=end inner</p>

<p>Z</p>

<p>=end outer</p>

<p>while this is invalid:</p>

<p>=begin outer</p>

<p>X</p>

<p>=begin inner</p>

<p>Y</p>

<p>=end outer</p>

<p>Z</p>

<p>=end inner</p>

<p>This latter is improper because when the &quot;=end
outer&quot; command is seen, the currently open region has
the formatname &quot;inner&quot;, not &quot;outer&quot;. (It
just happens that &quot;outer&quot; is the format name of a
higher-up region.) This is an error. Processors must by
default report this as an error, and may halt processing the
document containing that error. A corollary of this is that
regions cannot &quot;overlap&quot; -- i.e., the latter block
above does not represent a region called &quot;outer&quot;
which contains X and Y, overlapping a region called
&quot;inner&quot; which contains Y and Z. But because it is
invalid (as all apparently overlapping regions would be), it
doesnt represent that, or anything at all.</p>

<p>Similarly, this is invalid:</p>

<p>=begin thing</p>

<p>=end hting</p>

<p>This is an error because the region is opened by
&quot;thing&quot;, and the &quot;=end&quot; tries to close
&quot;hting&quot; [sic].</p>

<p>This is also invalid:</p>

<p>=begin thing</p>

<p>=end</p>

<p>This is invalid because every &quot;=end&quot; command
must have a formatname parameter.</p>

<p>SEE ALSO perlpod, &quot;PODs: Embedded
Documentation&quot; in perlsyn, podchecker</p>

<p>AUTHOR Sean M. Burke</p>

<p>perl v5.10.1 2010-07-19 PERLPODSPEC(1)</p>
<hr>
</body>
</html>
