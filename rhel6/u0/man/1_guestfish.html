<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:03:21 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>guestfish(1) Virtualization Support guestfish(1)</p>

<p>NAME guestfish - the libguestfs Filesystem Interactive
SHell</p>

<p>SYNOPSIS guestfish [--options] [commands]</p>

<p>guestfish</p>

<p>guestfish -a disk.img</p>

<p>guestfish -a disk.img -m dev[:mountpoint]</p>

<p>guestfish -i libvirt-domain</p>

<p>guestfish -i disk.img [disk.img ...]</p>

<p>EXAMPLES As an interactive shell $ guestfish</p>

<p>Welcome to guestfish, the libguestfs filesystem
interactive shell for editing virtual machine
filesystems.</p>

<p>Type: &rsquo;help&rsquo; for help with commands
&rsquo;quit&rsquo; to quit the shell</p>

<p>&gt;&lt;fs&gt; help</p>

<p>From shell scripts Create a new &quot;/etc/motd&quot;
file in a guest:</p>

<p>guestfish &lt;&lt;_EOF_ add disk.img run mount
/dev/vg_guest/lv_root / write_file /etc/motd &quot;Welcome,
new users&quot; 0 _EOF_</p>

<p>List the LVM logical volumes in a guest:</p>

<p>guestfish -a disk.img --ro &lt;&lt;_EOF_ run lvs
_EOF_</p>

<p>On one command line Update &quot;/etc/resolv.conf&quot;
in a guest:</p>

<p>guestfish add disk.img : run : mount
/dev/vg_guest/lv_root / : write-file /etc/resolv.conf
&quot;nameserver 1.2.3.4&quot; 0</p>

<p>Edit &quot;/boot/grub/grub.conf&quot; interactively:</p>

<p>guestfish --add disk.img --mount /dev/vg_guest/lv_root
--mount /dev/sda1:/boot edit /boot/grub/grub.conf</p>

<p>Using virt-inspector Use the -i option to get
virt-inspector to mount the filesystems automatically as
they would be mounted in the virtual machine:</p>

<p>guestfish --ro -i disk.img cat /etc/group</p>

<p>As a script interpreter Create a 50MB disk containing an
ext2-formatted partition:</p>

<p>#!/usr/bin/guestfish -f alloc /tmp/output.img 50M run
part-disk /dev/sda mbr mkfs ext2 /dev/sda1</p>

<p>Remote control eval &lsquo;guestfish --listen
--ro&lsquo; guestfish --remote add disk.img guestfish
--remote run guestfish --remote lvs</p>

<p>DESCRIPTION Guestfish is a shell and command-line tool
for examining and modifying virtual machine filesystems. It
uses libguestfs and exposes all of the functionality of the
guestfs API, see guestfs(3).</p>

<p>Guestfish gives you structured access to the libguestfs
API, from shell scripts or the command line or
interactively. If you want to rescue a broken virtual
machine image, you should look at the virt-rescue(1)
command.</p>

<p>Using guestfish in read/write mode on live virtual
machines can be dangerous, potentially causing disk
corruption. Use the --ro (read- only) option to use
guestfish safely if the disk image or virtual machine might
be live.</p>

<p>OPTIONS --help Displays general help on options.</p>

<p>-h | --cmd-help Lists all available guestfish
commands.</p>

<p>-h cmd | --cmd-help cmd Displays detailed help on a
single command &quot;cmd&quot;.</p>

<p>-a image | --add image Add a block device or virtual
machine image to the shell.</p>

<p>-D | --no-dest-paths Don t tab-complete paths on the
guest filesystem. It is useful to be able to hit the tab key
to complete paths on the guest filesystem, but this causes
extra &quot;hidden&quot; guestfs calls to be made, so this
option is here to allow this feature to be disabled.</p>

<p>-f file | --file file Read commands from
&quot;file&quot;. To write pure guestfish scripts, use:</p>

<p>#!/usr/bin/guestfish -f</p>

<p>-i | --inspector Run virt-inspector on the named libvirt
domain or list of disk images. If virt-inspector is
available and if it can identify the domain or disk images,
then partitions will be mounted correctly at start-up.</p>

<p>Typical usage is either:</p>

<p>guestfish -i myguest</p>

<p>(for an inactive libvirt domain called myguest), or:</p>

<p>guestfish --ro -i myguest</p>

<p>(for active domains, readonly), or specify the block
device directly:</p>

<p>guestfish -i /dev/Guests/MyGuest</p>

<p>You cannot use -a, -m, --listen, --remote or --selinux
in conjunction with this option, and options other than --ro
might not behave correctly.</p>

<p>See also: virt-inspector(1).</p>

<p>--listen Fork into the background and listen for remote
commands. See section &quot;REMOTE CONTROL GUESTFISH OVER A
SOCKET&quot; below.</p>

<p>-m dev[:mountpoint] | --mount dev[:mountpoint] Mount the
named partition or logical volume on the given
mountpoint.</p>

<p>If the mountpoint is omitted, it defaults to
&quot;/&quot;.</p>

<p>You have to mount something on &quot;/&quot; before most
commands will work.</p>

<p>If any -m or --mount options are given, the guest is
automatically launched.</p>

<p>If you don t know what filesystems a disk image
contains, you can either run guestfish without this option,
then list the partitions and LVs available (see
&quot;list-partitions&quot; and &quot;lvs&quot; commands),
or you can use the virt-list-filesystems(1) program.</p>

<p>-n | --no-sync Disable autosync. This is enabled by
default. See the discussion of autosync in the guestfs(3)
manpage.</p>

<p>--remote[=pid] Send remote commands to $GUESTFISH_PID or
&quot;pid&quot;. See section &quot;REMOTE CONTROL GUESTFISH
OVER A SOCKET&quot; below.</p>

<p>-r | --ro This changes the -a and -m options so that
disks are added and mounts are done read-only (see
&quot;guestfs_mount_ro&quot; in guestfs(3)).</p>

<p>The option must always be used if the disk image or
virtual machine might be running, and is generally
recommended in cases where you dont need write access to the
disk.</p>

<p>--selinux Enable SELinux support for the guest. See
&quot;SELINUX&quot; in guestfs(3).</p>

<p>-v | --verbose Enable very verbose messages. This is
particularly useful if you find a bug.</p>

<p>-V | --version Display the guestfish / libguestfs
version number and exit.</p>

<p>-x Echo each command before executing it.</p>

<p>COMMANDS ON COMMAND LINE Any additional (non-option)
arguments are treated as commands to execute.</p>

<p>Commands to execute should be separated by a colon
(&quot;:&quot;), where the colon is a separate parameter.
Thus:</p>

<p>guestfish cmd [args...] : cmd [args...] : cmd [args...]
...</p>

<p>If there are no additional arguments, then we enter a
shell, either an interactive shell with a prompt (if the
input is a terminal) or a non- interactive shell.</p>

<p>In either command line mode or non-interactive shell,
the first command that gives an error causes the whole shell
to exit. In interactive mode (with a prompt) if a command
fails, you can continue to enter commands.</p>

<p>USING launch (OR run) As with guestfs(3), you must first
configure your guest by adding disks, then launch it, then
mount any disks you need, and finally issue
actions/commands. So the general order of the day is:</p>

<p>&middot; add or -a/--add</p>

<p>&middot; launch (aka run)</p>

<p>&middot; mount or -m/--mount</p>

<p>&middot; any other commands</p>

<p>&quot;run&quot; is a synonym for &quot;launch&quot;. You
must &quot;launch&quot; (or &quot;run&quot;) your guest
before mounting or performing any other commands.</p>

<p>The only exception is that if the -m or --mount option
was given, the guest is automatically run for you (simply
because guestfish cant mount the disks you asked for without
doing this).</p>

<p>QUOTING You can quote ordinary parameters using either
single or double quotes. For example:</p>

<p>add &quot;file with a space.img&quot;</p>

<p>rm &rsquo;/file name&rsquo;</p>

<p>rm &rsquo;/&quot;&rsquo;</p>

<p>A few commands require a list of strings to be passed.
For these, use a whitespace-separated list, enclosed in
quotes. Strings containing whitespace to be passed through
must be enclosed in single quotes. A literal single quote
must be escaped with a backslash.</p>

<p>vgcreate VG &quot;/dev/sda1 /dev/sdb1&quot; command
&quot;/bin/echo &rsquo;foo bar&rsquo;&quot; command
&quot;/bin/echo &acute;foo&acute;&quot;</p>

<p>NUMBERS Commands which take integers as parameters use
the C convention which is to use 0 to prefix an octal number
or &quot;0x&quot; to prefix a hexadecimal number. For
example:</p>

<p>1234 decimal number 1234 02322 octal number, equivalent
to decimal 1234 0x4d2 hexadecimal number, equivalent to
decimal 1234</p>

<p>When using the &quot;chmod&quot; command, you almost
always want to specify an octal number for the mode, and you
must prefix it with 0 (unlike the Unix chmod(1)
program):</p>

<p>chmod 0777 /public # OK chmod 777 /public # WRONG! This
is mode 777 decimal = 01411 octal.</p>

<p>Commands that return numbers currently always print them
in decimal.</p>

<p>WILDCARDS AND GLOBBING Neither guestfish nor the
underlying guestfs API performs wildcard expansion
(globbing) by default. So for example the following will not
do what you expect:</p>

<p>rm-rf /home/*</p>

<p>Assuming you don t have a directory literally called
&quot;/home/*&quot; then the above command will return an
error.</p>

<p>To perform wildcard expansion, use the &quot;glob&quot;
command.</p>

<p>glob rm-rf /home/*</p>

<p>runs &quot;rm-rf&quot; on each path that matches (ie.
potentially running the command many times), equivalent
to:</p>

<p>rm-rf /home/jim rm-rf /home/joe rm-rf /home/mary</p>

<p>&quot;glob&quot; only works on simple guest paths and
not on device names.</p>

<p>If you have several parameters, each containing a
wildcard, then glob will perform a cartesian product.</p>

<p>COMMENTS Any line which starts with a # character is
treated as a comment and ignored. The # can optionally be
preceeded by whitespace, but not by a command. For
example:</p>

<p># this is a comment # this is a comment foo # NOT a
comment</p>

<p>Blank lines are also ignored.</p>

<p>RUNNING COMMANDS LOCALLY Any line which starts with a !
character is treated as a command sent to the local shell
(&quot;/bin/sh&quot; or whatever system(3) uses). For
example:</p>

<p>!mkdir local tgz-out /remote
local/remote-data.tar.gz</p>

<p>will create a directory &quot;local&quot; on the host,
and then export the contents of &quot;/remote&quot; on the
mounted filesystem to &quot;local/remote-data.tar.gz&quot;.
(See &quot;tgz-out&quot;).</p>

<p>To change the local directory, use the &quot;lcd&quot;
command. &quot;!cd&quot; will have no effect, due to the way
that subprocesses work in Unix.</p>

<p>PIPES Use &quot;command &lt;space&gt; | command&quot; to
pipe the output of the first command (a guestfish command)
to the second command (any host command). For example:</p>

<p>cat /etc/passwd | awk -F: &rsquo;$3 == 0 { print
}&rsquo;</p>

<p>(where &quot;cat&quot; is the guestfish cat command, but
&quot;awk&quot; is the host awk program). The above command
would list all accounts in the guest filesystem which have
UID 0, ie. root accounts including backdoors. Other
examples:</p>

<p>hexdump /bin/ls | head list-devices | tail -1 tgz-out /
- | tar ztf -</p>

<p>The space before the pipe symbol is required, any space
after the pipe symbol is optional. Everything after the pipe
symbol is just passed straight to the host shell, so it can
contain redirections, globs and anything else that makes
sense on the host side.</p>

<p>To use a literal argument which begins with a pipe
symbol, you have to quote it, eg:</p>

<p>echo &quot;|&quot;</p>

<p>HOME DIRECTORIES If a parameter starts with the
character &quot;~&quot; then the tilde may be expanded as a
home directory path (either &quot;~&quot; for the current
users home directory, or &quot;~user&quot; for another
user).</p>

<p>Note that home directory expansion happens for users
known on the host, not in the guest filesystem.</p>

<p>To use a literal argument which begins with a tilde, you
have to quote it, eg:</p>

<p>echo &quot;~&quot;</p>

<p>WINDOWS PATHS If a path is prefixed with
&quot;win:&quot; then you can use Windows-style paths (with
some limitations). The following commands are
equivalent:</p>

<p>file /WINDOWS/system32/config/system.LOG</p>

<p>file win:/windows/system32/config/system.log</p>

<p>file win:312gtem.log</p>

<p>file WIN:C:WindowsTEM32 This syntax implicitly calls
&quot;case-sensitive-path&quot; (q.v.) so it also handles
case insensitivity like Windows would. This only works in
argument positions that expect a path.</p>

<p>UPLOADING AND DOWNLOADING FILES For commands such as
&quot;upload&quot;, &quot;download&quot;,
&quot;tar-in&quot;, &quot;tar-out&quot; and others which
upload from or download to a local file, you can use the
special filename &quot;-&quot; to mean &quot;from
stdin&quot; or &quot;to stdout&quot;. For example:</p>

<p>upload - /foo</p>

<p>reads stdin and creates from that a file
&quot;/foo&quot; in the disk image, and:</p>

<p>tar-out /etc - | tar tf -</p>

<p>writes the tarball to stdout and then pipes that into
the external &quot;tar&quot; command (see
&quot;PIPES&quot;).</p>

<p>When using &quot;-&quot; to read from stdin, the input
is read up to the end of stdin.</p>

<p>EXIT ON ERROR BEHAVIOUR By default, guestfish will
ignore any errors when in interactive mode (ie. taking
commands from a human over a tty), and will exit on the
first error in non-interactive mode (scripts, commands given
on the command line).</p>

<p>If you prefix a command with a - character, then that
command will not cause guestfish to exit, even if that (one)
command returns an error.</p>

<p>REMOTE CONTROL GUESTFISH OVER A SOCKET Guestfish can be
remote-controlled over a socket. This is useful particularly
in shell scripts where you want to make several different
changes to a filesystem, but you dont want the overhead of
starting up a guestfish process each time.</p>

<p>Start a guestfish server process using:</p>

<p>eval &lsquo;guestfish --listen&lsquo;</p>

<p>and then send it commands by doing:</p>

<p>guestfish --remote cmd [...]</p>

<p>To cause the server to exit, send it the exit
command:</p>

<p>guestfish --remote exit</p>

<p>Note that the server will normally exit if there is an
error in a command. You can change this in the usual way.
See section &quot;EXIT ON ERROR BEHAVIOUR&quot;.</p>

<p>CONTROLLING MULTIPLE GUESTFISH PROCESSES The
&quot;eval&quot; statement sets the environment variable
$GUESTFISH_PID, which is how the --remote option knows where
to send the commands. You can have several guestfish
listener processes running using:</p>

<p>eval &lsquo;guestfish --listen&lsquo;
pid1=$GUESTFISH_PID eval &lsquo;guestfish --listen&lsquo;
pid2=$GUESTFISH_PID ... guestfish --remote=$pid1 cmd
guestfish --remote=$pid2 cmd</p>

<p>REMOTE CONTROL DETAILS Remote control happens over a
Unix domain socket called
&quot;/tmp/.guestfish-$UID/socket-$PID&quot;, where $UID is
the effective user ID of the process, and $PID is the
process ID of the server.</p>

<p>Guestfish client and server versions must match
exactly.</p>

<p>GUESTFISH COMMANDS The commands in this section are
guestfish convenience commands, in other words, they are not
part of the guestfs(3) API.</p>

<p>alloc | allocate alloc filename size</p>

<p>This creates an empty (zeroed) file of the given size,
and then adds so it can be further examined.</p>

<p>For more advanced image creation, see qemu-img(1)
utility.</p>

<p>Size can be specified (where &quot;nn&quot; means a
number):</p>

<p>&quot;nn&quot; or &quot;nn&quot;K or &quot;nn&quot;KB
number of kilobytes, eg: 1440 = standard 3.5in floppy</p>

<p>&quot;nn&quot;M or &quot;nn&quot;MB number of
megabytes</p>

<p>&quot;nn&quot;G or &quot;nn&quot;GB number of
gigabytes</p>

<p>&quot;nn&quot;T or &quot;nn&quot;TB number of
terabytes</p>

<p>&quot;nn&quot;P or &quot;nn&quot;PB number of
petabytes</p>

<p>&quot;nn&quot;E or &quot;nn&quot;EB number of
exabytes</p>

<p>&quot;nn&quot;sects number of 512 byte sectors</p>

<p>echo echo [params ...]</p>

<p>This echos the parameters to the terminal.</p>

<p>edit | vi | emacs edit filename</p>

<p>This is used to edit a file. It downloads the file,
edits it locally using your editor, then uploads the
result.</p>

<p>The editor is $EDITOR. However if you use the alternate
commands &quot;vi&quot; or &quot;emacs&quot; you will get
those corresponding editors.</p>

<p>NOTE: This will not work reliably for large files (&gt;
2 MB) or binary files containing bytes.</p>

<p>glob glob command args...</p>

<p>Expand wildcards in any paths in the args list, and run
&quot;command&quot; repeatedly on each matching path.</p>

<p>See section WILDCARDS AND GLOBBING.</p>

<p>help help help cmd</p>

<p>Without any parameter, this lists all commands. With a
&quot;cmd&quot; parameter, this displays detailed help for a
command.</p>

<p>lcd lcd directory</p>

<p>Change the local directory, ie. the current directory of
guestfish itself.</p>

<p>Note that &quot;!cd&quot; wont do what you might
expect.</p>

<p>more | less more filename</p>

<p>less filename</p>

<p>This is used to view a file.</p>

<p>The default viewer is $PAGER. However if you use the
alternate command &quot;less&quot; you will get the
&quot;less&quot; command specifically.</p>

<p>NOTE: This will not work reliably for large files (&gt;
2 MB) or binary files containing bytes.</p>

<p>quit | exit This exits guestfish. You can also use
&quot;^D&quot; key.</p>

<p>reopen reopen</p>

<p>Close and reopen the libguestfs handle. It is not
necessary to use this normally, because the handle is closed
properly when guestfish exits. However this is occasionally
useful for testing.</p>

<p>sparse sparse filename size</p>

<p>This creates an empty sparse file of the given size, and
then adds so it can be further examined.</p>

<p>In all respects it works the same as the
&quot;alloc&quot; command, except that the image file is
allocated sparsely, which means that disk blocks are not
assigned to the file until they are needed. Sparse disk
files only use space when written to, but they are slower
and there is a danger you could run out of real disk space
during a write operation.</p>

<p>For more advanced image creation, see qemu-img(1)
utility.</p>

<p>Size can be specified (where &quot;nn&quot; means a
number):</p>

<p>&quot;nn&quot; or &quot;nn&quot;K or &quot;nn&quot;KB
number of kilobytes, eg: 1440 = standard 3.5in floppy</p>

<p>&quot;nn&quot;M or &quot;nn&quot;MB number of
megabytes</p>

<p>&quot;nn&quot;G or &quot;nn&quot;GB number of
gigabytes</p>

<p>&quot;nn&quot;T or &quot;nn&quot;TB number of
terabytes</p>

<p>&quot;nn&quot;P or &quot;nn&quot;PB number of
petabytes</p>

<p>&quot;nn&quot;E or &quot;nn&quot;EB number of
exabytes</p>

<p>&quot;nn&quot;sects number of 512 byte sectors</p>

<p>time time command args...</p>

<p>Run the command as usual, but print the elapsed time
afterwards. This can be useful for benchmarking
operations.</p>

<p>COMMANDS add-cdrom | cdrom add-cdrom filename</p>

<p>This function adds a virtual CD-ROM disk image to the
guest.</p>

<p>This is equivalent to the qemu parameter &quot;-cdrom
filename&quot;.</p>

<p>Notes:</p>

<p>&middot; This call checks for the existence of
&quot;filename&quot;. This stops you from specifying other
types of drive which are supported by qemu such as
&quot;nbd:&quot; and &quot;http:&quot; URLs. To specify
those, use the general &quot;config&quot; call instead.</p>

<p>&middot; If you just want to add an ISO file (often you
use this as an efficient way to transfer large files into
the guest), then you should probably use
&quot;add-drive-ro&quot; instead.</p>

<p>add-drive | add add-drive filename</p>

<p>This function adds a virtual machine disk image
&quot;filename&quot; to the guest. The first time you call
this function, the disk appears as IDE disk 0
(&quot;/dev/sda&quot;) in the guest, the second time as
&quot;/dev/sdb&quot;, and so on.</p>

<p>You don t necessarily need to be root when using
libguestfs. However you obviously do need sufficient
permissions to access the filename for whatever operations
you want to perform (ie. read access if you just want to
read the image or write access if you want to modify the
image).</p>

<p>This is equivalent to the qemu parameter &quot;-drive
file=filename,cache=off,if=...&quot;.</p>

<p>&quot;cache=off&quot; is omitted in cases where it is
not supported by the underlying filesystem.</p>

<p>&quot;if=...&quot; is set at compile time by the
configuration option &quot;./configure
--with-drive-if=...&quot;. In the rare case where you might
need to change this at run time, use
&quot;add-drive-with-if&quot; or
&quot;add-drive-ro-with-if&quot;.</p>

<p>Note that this call checks for the existence of
&quot;filename&quot;. This stops you from specifying other
types of drive which are supported by qemu such as
&quot;nbd:&quot; and &quot;http:&quot; URLs. To specify
those, use the general &quot;config&quot; call instead.</p>

<p>add-drive-ro | add-ro add-drive-ro filename</p>

<p>This adds a drive in snapshot mode, making it
effectively read-only.</p>

<p>Note that writes to the device are allowed, and will be
seen for the duration of the guestfs handle, but they are
written to a temporary file which is discarded as soon as
the guestfs handle is closed. We don t currently have any
method to enable changes to be committed, although qemu can
support this.</p>

<p>This is equivalent to the qemu parameter &quot;-drive
file=filename,snapshot=on,if=...&quot;.</p>

<p>&quot;if=...&quot; is set at compile time by the
configuration option &quot;./configure
--with-drive-if=...&quot;. In the rare case where you might
need to change this at run time, use
&quot;add-drive-with-if&quot; or
&quot;add-drive-ro-with-if&quot;.</p>

<p>Note that this call checks for the existence of
&quot;filename&quot;. This stops you from specifying other
types of drive which are supported by qemu such as
&quot;nbd:&quot; and &quot;http:&quot; URLs. To specify
those, use the general &quot;config&quot; call instead.</p>

<p>add-drive-ro-with-if add-drive-ro-with-if filename
iface</p>

<p>This is the same as &quot;add-drive-ro&quot; but it
allows you to specify the QEMU interface emulation to use at
run time.</p>

<p>add-drive-with-if add-drive-with-if filename iface</p>

<p>This is the same as &quot;add-drive&quot; but it allows
you to specify the QEMU interface emulation to use at run
time.</p>

<p>aug-clear aug-clear augpath</p>

<p>Set the value associated with &quot;path&quot; to
&quot;NULL&quot;. This is the same as the augtool(1)
&quot;clear&quot; command.</p>

<p>aug-close aug-close</p>

<p>Close the current Augeas handle and free up any
resources used by it. After calling this, you have to call
&quot;aug-init&quot; again before you can use any other
Augeas functions.</p>

<p>aug-defnode aug-defnode name expr val</p>

<p>Defines a variable &quot;name&quot; whose value is the
result of evaluating &quot;expr&quot;.</p>

<p>If &quot;expr&quot; evaluates to an empty nodeset, a
node is created, equivalent to calling &quot;aug-set&quot;
&quot;expr&quot;, &quot;value&quot;. &quot;name&quot; will
be the nodeset containing that single node.</p>

<p>On success this returns a pair containing the number of
nodes in the nodeset, and a boolean flag if a node was
created.</p>

<p>aug-defvar aug-defvar name expr</p>

<p>Defines an Augeas variable &quot;name&quot; whose value
is the result of evaluating &quot;expr&quot;. If
&quot;expr&quot; is NULL, then &quot;name&quot; is
undefined.</p>

<p>On success this returns the number of nodes in
&quot;expr&quot;, or 0 if &quot;expr&quot; evaluates to
something which is not a nodeset.</p>

<p>aug-get aug-get augpath</p>

<p>Look up the value associated with &quot;path&quot;. If
&quot;path&quot; matches exactly one node, the
&quot;value&quot; is returned.</p>

<p>aug-init aug-init root flags</p>

<p>Create a new Augeas handle for editing configuration
files. If there was any previous Augeas handle associated
with this guestfs session, then it is closed.</p>

<p>You must call this before using any other
&quot;aug-*&quot; commands.</p>

<p>&quot;root&quot; is the filesystem root.
&quot;root&quot; must not be NULL, use &quot;/&quot;
instead.</p>

<p>The flags are the same as the flags defined in
&lt;augeas.h&gt;, the logical or of the following
integers:</p>

<p>&quot;AUG_SAVE_BACKUP&quot; = 1 Keep the original file
with a &quot;.augsave&quot; extension.</p>

<p>&quot;AUG_SAVE_NEWFILE&quot; = 2 Save changes into a
file with extension &quot;.augnew&quot;, and do not
overwrite original. Overrides
&quot;AUG_SAVE_BACKUP&quot;.</p>

<p>&quot;AUG_TYPE_CHECK&quot; = 4 Typecheck lenses (can be
expensive).</p>

<p>&quot;AUG_NO_STDINC&quot; = 8 Do not use standard load
path for modules.</p>

<p>&quot;AUG_SAVE_NOOP&quot; = 16 Make save a no-op, just
record what would have been changed.</p>

<p>&quot;AUG_NO_LOAD&quot; = 32 Do not load the tree in
&quot;aug-init&quot;.</p>

<p>To close the handle, you can call
&quot;aug-close&quot;.</p>

<p>To find out more about Augeas, see
&lt;http://augeas.net/&gt;.</p>

<p>aug-insert aug-insert augpath label true|false</p>

<p>Create a new sibling &quot;label&quot; for
&quot;path&quot;, inserting it into the tree before or after
&quot;path&quot; (depending on the boolean flag
&quot;before&quot;).</p>

<p>&quot;path&quot; must match exactly one existing node in
the tree, and &quot;label&quot; must be a label, ie. not
contain &quot;/&quot;, &quot;*&quot; or end with a bracketed
index &quot;[N]&quot;.</p>

<p>aug-load aug-load</p>

<p>Load files into the tree.</p>

<p>See &quot;aug_load&quot; in the Augeas documentation for
the full gory details.</p>

<p>aug-ls aug-ls augpath</p>

<p>This is just a shortcut for listing
&quot;aug-match&quot; &quot;path/*&quot; and sorting the
resulting nodes into alphabetical order.</p>

<p>aug-match aug-match augpath</p>

<p>Returns a list of paths which match the path expression
&quot;path&quot;. The returned paths are sufficiently
qualified so that they match exactly one node in the current
tree.</p>

<p>aug-mv aug-mv src dest</p>

<p>Move the node &quot;src&quot; to &quot;dest&quot;.
&quot;src&quot; must match exactly one node.
&quot;dest&quot; is overwritten if it exists.</p>

<p>aug-rm aug-rm augpath</p>

<p>Remove &quot;path&quot; and all of its children.</p>

<p>On success this returns the number of entries which were
removed.</p>

<p>aug-save aug-save</p>

<p>This writes all pending changes to disk.</p>

<p>The flags which were passed to &quot;aug-init&quot;
affect exactly how files are saved.</p>

<p>aug-set aug-set augpath val</p>

<p>Set the value associated with &quot;path&quot; to
&quot;val&quot;.</p>

<p>In the Augeas API, it is possible to clear a node by
setting the value to NULL. Due to an oversight in the
libguestfs API you cannot do that with this call. Instead
you must use the &quot;aug-clear&quot; call.</p>

<p>available available &rsquo;groups ...&rsquo;</p>

<p>This command is used to check the availability of some
groups of functionality in the appliance, which not all
builds of the libguestfs appliance will be able to
provide.</p>

<p>The libguestfs groups, and the functions that those
groups correspond to, are listed in &quot;AVAILABILITY&quot;
in guestfs(3).</p>

<p>The argument &quot;groups&quot; is a list of group
names, eg: &quot;[&quot;inotify&quot;,
&quot;augeas&quot;]&quot; would check for the availability
of the Linux inotify functions and Augeas (configuration
file editing) functions.</p>

<p>The command returns no error if all requested groups are
available.</p>

<p>It fails with an error if one or more of the requested
groups is unavailable in the appliance.</p>

<p>If an unknown group name is included in the list of
groups then an error is always returned.</p>

<p>Notes:</p>

<p>&middot; You must call &quot;launch&quot; before calling
this function.</p>

<p>The reason is because we dont know what groups are
supported by the appliance/daemon until it is running and
can be queried.</p>

<p>&middot; If a group of functions is available, this does
not necessarily mean that they will work. You still have to
check for errors when calling individual API functions even
if they are available.</p>

<p>&middot; It is usually the job of distro packagers to
build complete functionality into the libguestfs appliance.
Upstream libguestfs, if built from source with all
requirements satisfied, will support everything.</p>

<p>&middot; This call was added in version 1.0.80. In
previous versions of libguestfs all you could do would be to
speculatively execute a command to find out if the daemon
implemented it. See also &quot;version&quot;.</p>

<p>blockdev-flushbufs blockdev-flushbufs device</p>

<p>This tells the kernel to flush internal buffers
associated with &quot;device&quot;.</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-getbsz blockdev-getbsz device</p>

<p>This returns the block size of a device.</p>

<p>(Note this is different from both size in blocks and
filesystem block size).</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-getro blockdev-getro device</p>

<p>Returns a boolean indicating if the block device is
read-only (true if read-only, false if not).</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-getsize64 blockdev-getsize64 device</p>

<p>This returns the size of the device in bytes.</p>

<p>See also &quot;blockdev-getsz&quot;.</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-getss blockdev-getss device</p>

<p>This returns the size of sectors on a block device.
Usually 512, but can be larger for modern devices.</p>

<p>(Note, this is not the size in sectors, use
&quot;blockdev-getsz&quot; for that).</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-getsz blockdev-getsz device</p>

<p>This returns the size of the device in units of 512-byte
sectors (even if the sectorsize isnt 512 bytes ...
weird).</p>

<p>See also &quot;blockdev-getss&quot; for the real sector
size of the device, and &quot;blockdev-getsize64&quot; for
the more useful size in bytes.</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-rereadpt blockdev-rereadpt device</p>

<p>Reread the partition table on &quot;device&quot;.</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-setbsz blockdev-setbsz device blocksize</p>

<p>This sets the block size of a device.</p>

<p>(Note this is different from both size in blocks and
filesystem block size).</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-setro blockdev-setro device</p>

<p>Sets the block device named &quot;device&quot; to
read-only.</p>

<p>This uses the blockdev(8) command.</p>

<p>blockdev-setrw blockdev-setrw device</p>

<p>Sets the block device named &quot;device&quot; to
read-write.</p>

<p>This uses the blockdev(8) command.</p>

<p>case-sensitive-path case-sensitive-path path</p>

<p>This can be used to resolve case insensitive paths on a
filesystem which is case sensitive. The use case is to
resolve paths which you have read from Windows configuration
files or the Windows Registry, to the true path.</p>

<p>The command handles a peculiarity of the Linux ntfs-3g
filesystem driver (and probably others), which is that
although the underlying filesystem is case-insensitive, the
driver exports the filesystem to Linux as
case-sensitive.</p>

<p>One consequence of this is that special directories such
as &quot;c:912ndows&quot; (or other things) depending on the
precise details of how they were created. In Windows itself
this would not be a problem.</p>

<p>Bug or feature? You decide:
&lt;http://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1&gt;</p>

<p>This function resolves the true case of each element in
the path and returns the case-sensitive path.</p>

<p>Thus &quot;case-sensitive-path&quot;
(&quot;/Windows/System32&quot;) might return
&quot;/WINDOWS/system32&quot; (the exact return value would
depend on details of how the directories were originally
created under Windows).</p>

<p>Note: This function does not handle drive names,
backslashes etc.</p>

<p>See also &quot;realpath&quot;.</p>

<p>cat cat path</p>

<p>Return the contents of the file named
&quot;path&quot;.</p>

<p>Note that this function cannot correctly handle binary
files (specifically, files containing &quot; &quot;
character which is treated as end of string). For those you
need to use the &quot;read-file&quot; or
&quot;download&quot; functions which have a more complex
interface.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>checksum checksum csumtype path</p>

<p>This call computes the MD5, SHAx or CRC checksum of the
file named &quot;path&quot;.</p>

<p>The type of checksum to compute is given by the
&quot;csumtype&quot; parameter which must have one of the
following values:</p>

<p>&quot;crc&quot; Compute the cyclic redundancy check
(CRC) specified by POSIX for the &quot;cksum&quot;
command.</p>

<p>&quot;md5&quot; Compute the MD5 hash (using the
&quot;md5sum&quot; program).</p>

<p>&quot;sha1&quot; Compute the SHA1 hash (using the
&quot;sha1sum&quot; program).</p>

<p>&quot;sha224&quot; Compute the SHA224 hash (using the
&quot;sha224sum&quot; program).</p>

<p>&quot;sha256&quot; Compute the SHA256 hash (using the
&quot;sha256sum&quot; program).</p>

<p>&quot;sha384&quot; Compute the SHA384 hash (using the
&quot;sha384sum&quot; program).</p>

<p>&quot;sha512&quot; Compute the SHA512 hash (using the
&quot;sha512sum&quot; program).</p>

<p>The checksum is returned as a printable string.</p>

<p>chmod chmod mode path</p>

<p>Change the mode (permissions) of &quot;path&quot; to
&quot;mode&quot;. Only numeric modes are supported.</p>

<p>Note: When using this command from guestfish,
&quot;mode&quot; by default would be decimal, unless you
prefix it with 0 to get octal, ie. use 0700 not 700.</p>

<p>The mode actually set is affected by the umask.</p>

<p>chown chown owner group path</p>

<p>Change the file owner to &quot;owner&quot; and group to
&quot;group&quot;.</p>

<p>Only numeric uid and gid are supported. If you want to
use names, you will need to locate and parse the password
file yourself (Augeas support makes this relatively
easy).</p>

<p>command command &rsquo;arguments ...&rsquo;</p>

<p>This call runs a command from the guest filesystem. The
filesystem must be mounted, and must contain a compatible
operating system (ie. something Linux, with the same or
compatible processor architecture).</p>

<p>The single parameter is an argv-style list of arguments.
The first element is the name of the program to run.
Subsequent elements are parameters. The list must be
non-empty (ie. must contain a program name). Note that the
command runs directly, and is not invoked via the shell (see
&quot;sh&quot;).</p>

<p>The return value is anything printed to stdout by the
command.</p>

<p>If the command returns a non-zero exit status, then this
function returns an error message. The error message string
is the content of stderr from the command.</p>

<p>The $PATH environment variable will contain at least
&quot;/usr/bin&quot; and &quot;/bin&quot;. If you require a
program from another location, you should provide the full
path in the first parameter.</p>

<p>Shared libraries and data files required by the program
must be available on filesystems which are mounted in the
correct places. It is the caller s responsibility to ensure
all filesystems that are needed are mounted at the right
locations.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>command-lines command-lines &rsquo;arguments
...&rsquo;</p>

<p>This is the same as &quot;command&quot;, but splits the
result into a list of lines.</p>

<p>See also: &quot;sh-lines&quot;</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>config config qemuparam qemuvalue</p>

<p>This can be used to add arbitrary qemu command line
parameters of the form &quot;-param value&quot;. Actually
its not quite arbitrary - we prevent you from setting some
parameters which would interfere with parameters that we
use.</p>

<p>The first character of &quot;param&quot; string must be
a &quot;-&quot; (dash).</p>

<p>&quot;value&quot; can be NULL.</p>

<p>copy-size copy-size src dest size</p>

<p>This command copies exactly &quot;size&quot; bytes from
one source device or file &quot;src&quot; to another
destination device or file &quot;dest&quot;.</p>

<p>Note this will fail if the source is too short or if the
destination is not large enough.</p>

<p>cp cp src dest</p>

<p>This copies a file from &quot;src&quot; to
&quot;dest&quot; where &quot;dest&quot; is either a
destination filename or destination directory.</p>

<p>cp-a cp-a src dest</p>

<p>This copies a file or directory from &quot;src&quot; to
&quot;dest&quot; recursively using the &quot;cp -a&quot;
command.</p>

<p>dd dd src dest</p>

<p>This command copies from one source device or file
&quot;src&quot; to another destination device or file
&quot;dest&quot;. Normally you would use this to copy to or
from a device or partition, for example to duplicate a
filesystem.</p>

<p>If the destination is a device, it must be as large or
larger than the source file or device, otherwise the copy
will fail. This command cannot do partial copies (see
&quot;copy-size&quot;).</p>

<p>debug debug subcmd &rsquo;extraargs ...&rsquo;</p>

<p>The &quot;debug&quot; command exposes some internals of
&quot;guestfsd&quot; (the guestfs daemon) that runs inside
the qemu subprocess.</p>

<p>There is no comprehensive help for this command. You
have to look at the file &quot;daemon/debug.c&quot; in the
libguestfs source to find out what you can do.</p>

<p>df df</p>

<p>This command runs the &quot;df&quot; command to report
disk space used.</p>

<p>This command is mostly useful for interactive sessions.
It is not intended that you try to parse the output string.
Use &quot;statvfs&quot; from programs.</p>

<p>df-h df-h</p>

<p>This command runs the &quot;df -h&quot; command to
report disk space used in human-readable format.</p>

<p>This command is mostly useful for interactive sessions.
It is not intended that you try to parse the output string.
Use &quot;statvfs&quot; from programs.</p>

<p>dmesg dmesg</p>

<p>This returns the kernel messages (&quot;dmesg&quot;
output) from the guest kernel. This is sometimes useful for
extended debugging of problems.</p>

<p>Another way to get the same information is to enable
verbose messages with &quot;set-verbose&quot; or by setting
the environment variable &quot;LIBGUESTFS_DEBUG=1&quot;
before running the program.</p>

<p>download download remotefilename (filename|-)</p>

<p>Download file &quot;remotefilename&quot; and save it as
&quot;filename&quot; on the local machine.</p>

<p>&quot;filename&quot; can also be a named pipe.</p>

<p>See also &quot;upload&quot;, &quot;cat&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>drop-caches drop-caches whattodrop</p>

<p>This instructs the guest kernel to drop its page cache,
and/or dentries and inode caches. The parameter
&quot;whattodrop&quot; tells the kernel what precisely to
drop, see &lt;http://linux-mm.org/Drop_Caches&gt;</p>

<p>Setting &quot;whattodrop&quot; to 3 should drop
everything.</p>

<p>This automatically calls sync(2) before the operation,
so that the maximum guest memory is freed.</p>

<p>du du path</p>

<p>This command runs the &quot;du -s&quot; command to
estimate file space usage for &quot;path&quot;.</p>

<p>&quot;path&quot; can be a file or a directory. If
&quot;path&quot; is a directory then the estimate includes
the contents of the directory and all subdirectories
(recursively).</p>

<p>The result is the estimated size in kilobytes (ie. units
of 1024 bytes).</p>

<p>e2fsck-f e2fsck-f device</p>

<p>This runs &quot;e2fsck -p -f device&quot;, ie. runs the
ext2/ext3 filesystem checker on &quot;device&quot;,
noninteractively (&quot;-p&quot;), even if the filesystem
appears to be clean (&quot;-f&quot;).</p>

<p>This command is only needed because of
&quot;resize2fs&quot; (q.v.). Normally you should use
&quot;fsck&quot;.</p>

<p>echo-daemon echo-daemon &rsquo;words ...&rsquo;</p>

<p>This command concatenate the list of &quot;words&quot;
passed with single spaces between them and returns the
resulting string.</p>

<p>You can use this command to test the connection through
to the daemon.</p>

<p>See also &quot;ping-daemon&quot;.</p>

<p>egrep egrep regex path</p>

<p>This calls the external &quot;egrep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>egrepi egrepi regex path</p>

<p>This calls the external &quot;egrep -i&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>equal equal file1 file2</p>

<p>This compares the two files &quot;file1&quot; and
&quot;file2&quot; and returns true if their content is
exactly equal, or false otherwise.</p>

<p>The external cmp(1) program is used for the
comparison.</p>

<p>exists exists path</p>

<p>This returns &quot;true&quot; if and only if there is a
file, directory (or anything) with the given
&quot;path&quot; name.</p>

<p>See also &quot;is-file&quot;, &quot;is-dir&quot;,
&quot;stat&quot;.</p>

<p>fallocate fallocate path len</p>

<p>This command preallocates a file (containing zero bytes)
named &quot;path&quot; of size &quot;len&quot; bytes. If the
file exists already, it is overwritten.</p>

<p>Do not confuse this with the guestfish-specific
&quot;alloc&quot; command which allocates a file in the host
and attaches it as a device.</p>

<p>fgrep fgrep pattern path</p>

<p>This calls the external &quot;fgrep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>fgrepi fgrepi pattern path</p>

<p>This calls the external &quot;fgrep -i&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>file file path</p>

<p>This call uses the standard file(1) command to determine
the type or contents of the file. This also works on
devices, for example to find out whether a partition
contains a filesystem.</p>

<p>This call will also transparently look inside various
types of compressed file.</p>

<p>The exact command which runs is &quot;file -zbsL
path&quot;. Note in particular that the filename is not
prepended to the output (the &quot;-b&quot; option).</p>

<p>filesize filesize file</p>

<p>This command returns the size of &quot;file&quot; in
bytes.</p>

<p>To get other stats about a file, use &quot;stat&quot;,
&quot;lstat&quot;, &quot;is-dir&quot;, &quot;is-file&quot;
etc. To get the size of block devices, use
&quot;blockdev-getsize64&quot;.</p>

<p>fill fill c len path</p>

<p>This command creates a new file called &quot;path&quot;.
The initial content of the file is &quot;len&quot; octets of
&quot;c&quot;, where &quot;c&quot; must be a number in the
range &quot;[0..255]&quot;.</p>

<p>To fill a file with zero bytes (sparsely), it is much
more efficient to use &quot;truncate-size&quot;.</p>

<p>find find directory</p>

<p>This command lists out all files and directories,
recursively, starting at &quot;directory&quot;. It is
essentially equivalent to running the shell command
&quot;find directory -print&quot; but some post-processing
happens on the output, described below.</p>

<p>This returns a list of strings without any prefix. Thus
if the directory structure was:</p>

<p>/tmp/a /tmp/b /tmp/c/d</p>

<p>then the returned list from &quot;find&quot;
&quot;/tmp&quot; would be 4 elements:</p>

<p>a b c c/d</p>

<p>If &quot;directory&quot; is not a directory, then this
command returns an error.</p>

<p>The returned list is sorted.</p>

<p>See also &quot;find0&quot;.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>find0 find0 directory (files|-)</p>

<p>This command lists out all files and directories,
recursively, starting at &quot;directory&quot;, placing the
resulting list in the external file called
&quot;files&quot;.</p>

<p>This command works the same way as &quot;find&quot; with
the following exceptions:</p>

<p>&middot; The resulting list is written to an external
file.</p>

<p>&middot; Items (filenames) in the result are separated
by &quot; &quot; characters. See find(1) option -print0.</p>

<p>&middot; This command is not limited in the number of
names that it can return.</p>

<p>&middot; The result list is not sorted.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>fsck fsck fstype device</p>

<p>This runs the filesystem checker (fsck) on
&quot;device&quot; which should have filesystem type
&quot;fstype&quot;.</p>

<p>The returned integer is the status. See fsck(8) for the
list of status codes from &quot;fsck&quot;.</p>

<p>Notes:</p>

<p>&middot; Multiple status codes can be summed
together.</p>

<p>&middot; A non-zero return code can mean
&quot;success&quot;, for example if errors have been
corrected on the filesystem.</p>

<p>&middot; Checking or repairing NTFS volumes is not
supported (by linux- ntfs).</p>

<p>This command is entirely equivalent to running
&quot;fsck -a -t fstype device&quot;.</p>

<p>get-append get-append</p>

<p>Return the additional kernel options which are added to
the guest kernel command line.</p>

<p>If &quot;NULL&quot; then no options are added.</p>

<p>get-autosync get-autosync</p>

<p>Get the autosync flag.</p>

<p>get-direct get-direct</p>

<p>Return the direct appliance mode flag.</p>

<p>get-e2label get-e2label device</p>

<p>This returns the ext2/3/4 filesystem label of the
filesystem on &quot;device&quot;.</p>

<p>get-e2uuid get-e2uuid device</p>

<p>This returns the ext2/3/4 filesystem UUID of the
filesystem on &quot;device&quot;.</p>

<p>get-memsize get-memsize</p>

<p>This gets the memory size in megabytes allocated to the
qemu subprocess.</p>

<p>If &quot;set-memsize&quot; was not called on this
handle, and if &quot;LIBGUESTFS_MEMSIZE&quot; was not set,
then this returns the compiled-in default value for
memsize.</p>

<p>For more information on the architecture of libguestfs,
see guestfs(3).</p>

<p>get-path get-path</p>

<p>Return the current search path.</p>

<p>This is always non-NULL. If it wasnt set already, then
this will return the default path.</p>

<p>get-pid | pid get-pid</p>

<p>Return the process ID of the qemu subprocess. If there
is no qemu subprocess, then this will return an error.</p>

<p>This is an internal call used for debugging and
testing.</p>

<p>get-qemu get-qemu</p>

<p>Return the current qemu binary.</p>

<p>This is always non-NULL. If it wasnt set already, then
this will return the default qemu binary name.</p>

<p>get-recovery-proc get-recovery-proc</p>

<p>Return the recovery process enabled flag.</p>

<p>get-selinux get-selinux</p>

<p>This returns the current setting of the selinux flag
which is passed to the appliance at boot time. See
&quot;set-selinux&quot;.</p>

<p>For more information on the architecture of libguestfs,
see guestfs(3).</p>

<p>get-state get-state</p>

<p>This returns the current state as an opaque integer.
This is only useful for printing debug and internal error
messages.</p>

<p>For more information on states, see guestfs(3).</p>

<p>get-trace get-trace</p>

<p>Return the command trace flag.</p>

<p>get-verbose get-verbose</p>

<p>This returns the verbose messages flag.</p>

<p>getcon getcon</p>

<p>This gets the SELinux security context of the
daemon.</p>

<p>See the documentation about SELINUX in guestfs(3), and
&quot;setcon&quot;</p>

<p>getxattrs getxattrs path</p>

<p>This call lists the extended attributes of the file or
directory &quot;path&quot;.</p>

<p>At the system call level, this is a combination of the
listxattr(2) and getxattr(2) calls.</p>

<p>See also: &quot;lgetxattrs&quot;, attr(5).</p>

<p>glob-expand glob-expand pattern</p>

<p>This command searches for all the pathnames matching
&quot;pattern&quot; according to the wildcard expansion
rules used by the shell.</p>

<p>If no paths match, then this returns an empty list
(note: not an error).</p>

<p>It is just a wrapper around the C glob(3) function with
flags &quot;GLOB_MARK|GLOB_BRACE&quot;. See that manual page
for more details.</p>

<p>grep grep regex path</p>

<p>This calls the external &quot;grep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>grepi grepi regex path</p>

<p>This calls the external &quot;grep -i&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>grub-install grub-install root device</p>

<p>This command installs GRUB (the Grand Unified
Bootloader) on &quot;device&quot;, with the root directory
being &quot;root&quot;.</p>

<p>head head path</p>

<p>This command returns up to the first 10 lines of a file
as a list of strings.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>head-n head-n nrlines path</p>

<p>If the parameter &quot;nrlines&quot; is a positive
number, this returns the first &quot;nrlines&quot; lines of
the file &quot;path&quot;.</p>

<p>If the parameter &quot;nrlines&quot; is a negative
number, this returns lines from the file &quot;path&quot;,
excluding the last &quot;nrlines&quot; lines.</p>

<p>If the parameter &quot;nrlines&quot; is zero, this
returns an empty list.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>hexdump hexdump path</p>

<p>This runs &quot;hexdump -C&quot; on the given
&quot;path&quot;. The result is the human- readable,
canonical hex dump of the file.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>initrd-cat initrd-cat initrdpath filename</p>

<p>This command unpacks the file &quot;filename&quot; from
the initrd file called &quot;initrdpath&quot;. The filename
must be given without the initial &quot;/&quot;
character.</p>

<p>For example, in guestfish you could use the following
command to examine the boot script (usually called
&quot;/init&quot;) contained in a Linux initrd or initramfs
image:</p>

<p>initrd-cat /boot/initrd-&lt;version&gt;.img init</p>

<p>See also &quot;initrd-list&quot;.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>initrd-list initrd-list path</p>

<p>This command lists out files contained in an initrd.</p>

<p>The files are listed without any initial &quot;/&quot;
character. The files are listed in the order they appear
(not necessarily alphabetical). Directory names are listed
as separate items.</p>

<p>Old Linux kernels (2.4 and earlier) used a compressed
ext2 filesystem as initrd. We only support the newer
initramfs format (compressed cpio files).</p>

<p>inotify-add-watch inotify-add-watch path mask</p>

<p>Watch &quot;path&quot; for the events listed in
&quot;mask&quot;.</p>

<p>Note that if &quot;path&quot; is a directory then events
within that directory are watched, but this does not happen
recursively (in subdirectories).</p>

<p>Note for non-C or non-Linux callers: the inotify events
are defined by the Linux kernel ABI and are listed in
&quot;/usr/include/sys/inotify.h&quot;.</p>

<p>inotify-close inotify-close</p>

<p>This closes the inotify handle which was previously
opened by inotify_init. It removes all watches, throws away
any pending events, and deallocates all resources.</p>

<p>inotify-files inotify-files</p>

<p>This function is a helpful wrapper around
&quot;inotify-read&quot; which just returns a list of
pathnames of objects that were touched. The returned
pathnames are sorted and deduplicated.</p>

<p>inotify-init inotify-init maxevents</p>

<p>This command creates a new inotify handle. The inotify
subsystem can be used to notify events which happen to
objects in the guest filesystem.</p>

<p>&quot;maxevents&quot; is the maximum number of events
which will be queued up between calls to
&quot;inotify-read&quot; or &quot;inotify-files&quot;. If
this is passed as 0, then the kernel (or previously set)
default is used. For Linux 2.6.29 the default was 16384
events. Beyond this limit, the kernel throws away events,
but records the fact that it threw them away by setting a
flag &quot;IN_Q_OVERFLOW&quot; in the returned structure
list (see &quot;inotify-read&quot;).</p>

<p>Before any events are generated, you have to add some
watches to the internal watch list. See:
&quot;inotify-add-watch&quot;, &quot;inotify-rm-watch&quot;
and &quot;inotify-watch-all&quot;.</p>

<p>Queued up events should be read periodically by calling
&quot;inotify-read&quot; (or &quot;inotify-files&quot; which
is just a helpful wrapper around &quot;inotify-read&quot;).
If you dont read the events out often enough then you risk
the internal queue overflowing.</p>

<p>The handle should be closed after use by calling
&quot;inotify-close&quot;. This also removes any watches
automatically.</p>

<p>See also inotify(7) for an overview of the inotify
interface as exposed by the Linux kernel, which is roughly
what we expose via libguestfs. Note that there is one global
inotify handle per libguestfs instance.</p>

<p>inotify-read inotify-read</p>

<p>Return the complete queue of events that have happened
since the previous read call.</p>

<p>If no events have happened, this returns an empty
list.</p>

<p>Note: In order to make sure that all events have been
read, you must call this function repeatedly until it
returns an empty list. The reason is that the call will read
events up to the maximum appliance- to-host message size and
leave remaining events in the queue.</p>

<p>inotify-rm-watch inotify-rm-watch wd</p>

<p>Remove a previously defined inotify watch. See
&quot;inotify-add-watch&quot;.</p>

<p>is-busy is-busy</p>

<p>This returns true iff this handle is busy processing a
command (in the &quot;BUSY&quot; state).</p>

<p>For more information on states, see guestfs(3).</p>

<p>is-config is-config</p>

<p>This returns true iff this handle is being configured
(in the &quot;CONFIG&quot; state).</p>

<p>For more information on states, see guestfs(3).</p>

<p>is-dir is-dir path</p>

<p>This returns &quot;true&quot; if and only if there is a
directory with the given &quot;path&quot; name. Note that it
returns false for other objects like files.</p>

<p>See also &quot;stat&quot;.</p>

<p>is-file is-file path</p>

<p>This returns &quot;true&quot; if and only if there is a
file with the given &quot;path&quot; name. Note that it
returns false for other objects like directories.</p>

<p>See also &quot;stat&quot;.</p>

<p>is-launching is-launching</p>

<p>This returns true iff this handle is launching the
subprocess (in the &quot;LAUNCHING&quot; state).</p>

<p>For more information on states, see guestfs(3).</p>

<p>is-lv is-lv device</p>

<p>This command tests whether &quot;device&quot; is a
logical volume, and returns true iff this is the case.</p>

<p>is-ready is-ready</p>

<p>This returns true iff this handle is ready to accept
commands (in the &quot;READY&quot; state).</p>

<p>For more information on states, see guestfs(3).</p>

<p>kill-subprocess kill-subprocess</p>

<p>This kills the qemu subprocess. You should never need to
call this.</p>

<p>launch | run launch</p>

<p>Internally libguestfs is implemented by running a
virtual machine using qemu(1).</p>

<p>You should call this after configuring the handle (eg.
adding drives) but before performing any actions.</p>

<p>lchown lchown owner group path</p>

<p>Change the file owner to &quot;owner&quot; and group to
&quot;group&quot;. This is like &quot;chown&quot; but if
&quot;path&quot; is a symlink then the link itself is
changed, not the target.</p>

<p>Only numeric uid and gid are supported. If you want to
use names, you will need to locate and parse the password
file yourself (Augeas support makes this relatively
easy).</p>

<p>lgetxattrs lgetxattrs path</p>

<p>This is the same as &quot;getxattrs&quot;, but if
&quot;path&quot; is a symbolic link, then it returns the
extended attributes of the link itself.</p>

<p>list-devices list-devices</p>

<p>List all the block devices.</p>

<p>The full block device names are returned, eg.
&quot;/dev/sda&quot;</p>

<p>list-partitions list-partitions</p>

<p>List all the partitions detected on all block
devices.</p>

<p>The full partition device names are returned, eg.
&quot;/dev/sda1&quot;</p>

<p>This does not return logical volumes. For that you will
need to call &quot;lvs&quot;.</p>

<p>ll ll directory</p>

<p>List the files in &quot;directory&quot; (relative to the
root directory, there is no cwd) in the format of ls
-la.</p>

<p>This command is mostly useful for interactive sessions.
It is not intended that you try to parse the output
string.</p>

<p>ln ln target linkname</p>

<p>This command creates a hard link using the
&quot;ln&quot; command.</p>

<p>ln-f ln-f target linkname</p>

<p>This command creates a hard link using the &quot;ln
-f&quot; command. The &quot;-f&quot; option removes the link
(&quot;linkname&quot;) if it exists already.</p>

<p>ln-s ln-s target linkname</p>

<p>This command creates a symbolic link using the &quot;ln
-s&quot; command.</p>

<p>ln-sf ln-sf target linkname</p>

<p>This command creates a symbolic link using the &quot;ln
-sf&quot; command, The &quot;-f&quot; option removes the
link (&quot;linkname&quot;) if it exists already.</p>

<p>lremovexattr lremovexattr xattr path</p>

<p>This is the same as &quot;removexattr&quot;, but if
&quot;path&quot; is a symbolic link, then it removes an
extended attribute of the link itself.</p>

<p>ls ls directory</p>

<p>List the files in &quot;directory&quot; (relative to the
root directory, there is no cwd). The . and .. entries are
not returned, but hidden files are shown.</p>

<p>This command is mostly useful for interactive sessions.
Programs should probably use &quot;readdir&quot;
instead.</p>

<p>lsetxattr lsetxattr xattr val vallen path</p>

<p>This is the same as &quot;setxattr&quot;, but if
&quot;path&quot; is a symbolic link, then it sets an
extended attribute of the link itself.</p>

<p>lstat lstat path</p>

<p>Returns file information for the given
&quot;path&quot;.</p>

<p>This is the same as &quot;stat&quot; except that if
&quot;path&quot; is a symbolic link, then the link is
stat-ed, not the file it refers to.</p>

<p>This is the same as the lstat(2) system call.</p>

<p>lstatlist lstatlist path &rsquo;names ...&rsquo;</p>

<p>This call allows you to perform the &quot;lstat&quot;
operation on multiple files, where all files are in the
directory &quot;path&quot;. &quot;names&quot; is the list of
files from this directory.</p>

<p>On return you get a list of stat structs, with a
one-to-one correspondence to the &quot;names&quot; list. If
any name did not exist or could not be lstatd, then the
&quot;ino&quot; field of that structure is set to
&quot;-1&quot;.</p>

<p>This call is intended for programs that want to
efficiently list a directory contents without making many
round-trips. See also &quot;lxattrlist&quot; for a similarly
efficient call for getting extended attributes. Very long
directory listings might cause the protocol message size to
be exceeded, causing this call to fail. The caller must
split up such requests into smaller groups of names.</p>

<p>lvcreate lvcreate logvol volgroup mbytes</p>

<p>This creates an LVM logical volume called
&quot;logvol&quot; on the volume group &quot;volgroup&quot;,
with &quot;size&quot; megabytes.</p>

<p>lvm-remove-all lvm-remove-all</p>

<p>This command removes all LVM logical volumes, volume
groups and physical volumes.</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>lvremove lvremove device</p>

<p>Remove an LVM logical volume &quot;device&quot;, where
&quot;device&quot; is the path to the LV, such as
&quot;/dev/VG/LV&quot;.</p>

<p>You can also remove all LVs in a volume group by
specifying the VG name, &quot;/dev/VG&quot;.</p>

<p>lvrename lvrename logvol newlogvol</p>

<p>Rename a logical volume &quot;logvol&quot; with the new
name &quot;newlogvol&quot;.</p>

<p>lvresize lvresize device mbytes</p>

<p>This resizes (expands or shrinks) an existing LVM
logical volume to &quot;mbytes&quot;. When reducing, data in
the reduced part is lost.</p>

<p>lvs lvs</p>

<p>List all the logical volumes detected. This is the
equivalent of the lvs(8) command.</p>

<p>This returns a list of the logical volume device names
(eg. &quot;/dev/VolGroup00/LogVol00&quot;).</p>

<p>See also &quot;lvs-full&quot;.</p>

<p>lvs-full lvs-full</p>

<p>List all the logical volumes detected. This is the
equivalent of the lvs(8) command. The &quot;full&quot;
version includes all fields.</p>

<p>lvuuid lvuuid device</p>

<p>This command returns the UUID of the LVM LV
&quot;device&quot;.</p>

<p>lxattrlist lxattrlist path &rsquo;names ...&rsquo;</p>

<p>This call allows you to get the extended attributes of
multiple files, where all files are in the directory
&quot;path&quot;. &quot;names&quot; is the list of files
from this directory.</p>

<p>On return you get a flat list of xattr structs which
must be interpreted sequentially. The first xattr struct
always has a zero- length &quot;attrname&quot;.
&quot;attrval&quot; in this struct is zero-length to
indicate there was an error doing &quot;lgetxattr&quot; for
this file, or is a C string which is a decimal number (the
number of following attributes for this file, which could be
&quot;0&quot;). Then after the first xattr struct are the
zero or more attributes for the first named file. This
repeats for the second and subsequent files.</p>

<p>This call is intended for programs that want to
efficiently list a directory contents without making many
round-trips. See also &quot;lstatlist&quot; for a similarly
efficient call for getting standard stats. Very long
directory listings might cause the protocol message size to
be exceeded, causing this call to fail. The caller must
split up such requests into smaller groups of names.</p>

<p>mkdir mkdir path</p>

<p>Create a directory named &quot;path&quot;.</p>

<p>mkdir-mode mkdir-mode path mode</p>

<p>This command creates a directory, setting the initial
permissions of the directory to &quot;mode&quot;.</p>

<p>For common Linux filesystems, the actual mode which is
set will be &quot;mode &amp; ~umask &amp; 01777&quot;.
Non-native-Linux filesystems may interpret the mode in other
ways.</p>

<p>See also &quot;mkdir&quot;, &quot;umask&quot;</p>

<p>mkdir-p mkdir-p path</p>

<p>Create a directory named &quot;path&quot;, creating any
parent directories as necessary. This is like the
&quot;mkdir -p&quot; shell command.</p>

<p>mkdtemp mkdtemp template</p>

<p>This command creates a temporary directory. The
&quot;template&quot; parameter should be a full pathname for
the temporary directory name with the final six characters
being &quot;XXXXXX&quot;.</p>

<p>For example: &quot;/tmp/myprogXXXXXX&quot; or
&quot;/Temp/myprogXXXXXX&quot;, the second one being
suitable for Windows filesystems.</p>

<p>The name of the temporary directory that was created is
returned.</p>

<p>The temporary directory is created with mode 0700 and is
owned by root.</p>

<p>The caller is responsible for deleting the temporary
directory and its contents after use.</p>

<p>See also: mkdtemp(3)</p>

<p>mke2fs-J mke2fs-J fstype blocksize device journal</p>

<p>This creates an ext2/3/4 filesystem on
&quot;device&quot; with an external journal on
&quot;journal&quot;. It is equivalent to the command:</p>

<p>mke2fs -t fstype -b blocksize -J device=&lt;journal&gt;
&lt;device&gt;</p>

<p>See also &quot;mke2journal&quot;.</p>

<p>mke2fs-JL mke2fs-JL fstype blocksize device label</p>

<p>This creates an ext2/3/4 filesystem on
&quot;device&quot; with an external journal on the journal
labeled &quot;label&quot;.</p>

<p>See also &quot;mke2journal-L&quot;.</p>

<p>mke2fs-JU mke2fs-JU fstype blocksize device uuid</p>

<p>This creates an ext2/3/4 filesystem on
&quot;device&quot; with an external journal on the journal
with UUID &quot;uuid&quot;.</p>

<p>See also &quot;mke2journal-U&quot;.</p>

<p>mke2journal mke2journal blocksize device</p>

<p>This creates an ext2 external journal on
&quot;device&quot;. It is equivalent to the command:</p>

<p>mke2fs -O journal_dev -b blocksize device</p>

<p>mke2journal-L mke2journal-L blocksize label device</p>

<p>This creates an ext2 external journal on
&quot;device&quot; with label &quot;label&quot;.</p>

<p>mke2journal-U mke2journal-U blocksize uuid device</p>

<p>This creates an ext2 external journal on
&quot;device&quot; with UUID &quot;uuid&quot;.</p>

<p>mkfifo mkfifo mode path</p>

<p>This call creates a FIFO (named pipe) called
&quot;path&quot; with mode &quot;mode&quot;. It is just a
convenient wrapper around &quot;mknod&quot;.</p>

<p>The mode actually set is affected by the umask.</p>

<p>mkfs mkfs fstype device</p>

<p>This creates a filesystem on &quot;device&quot; (usually
a partition or LVM logical volume). The filesystem type is
&quot;fstype&quot;, for example &quot;ext3&quot;.</p>

<p>mkfs-b mkfs-b fstype blocksize device</p>

<p>This call is similar to &quot;mkfs&quot;, but it allows
you to control the block size of the resulting filesystem.
Supported block sizes depend on the filesystem type, but
typically they are 1024, 2048 or 4096 only.</p>

<p>For VFAT and NTFS the &quot;blocksize&quot; parameter is
treated as the requested cluster size.</p>

<p>mkmountpoint mkmountpoint exemptpath</p>

<p>&quot;mkmountpoint&quot; and &quot;rmmountpoint&quot;
are specialized calls that can be used to create extra
mountpoints before mounting the first filesystem.</p>

<p>These calls are only necessary in some very limited
circumstances, mainly the case where you want to mount a mix
of unrelated and/or read- only filesystems together.</p>

<p>For example, live CDs often contain a &quot;Russian
doll&quot; nest of filesystems, an ISO outer layer, with a
squashfs image inside, with an ext2/3 image inside that. You
can unpack this as follows in guestfish:</p>

<p>add-ro Fedora-11-i686-Live.iso run mkmountpoint /cd
mkmountpoint /squash mkmountpoint /ext3 mount /dev/sda /cd
mount-loop /cd/LiveOS/squashfs.img /squash mount-loop
/squash/LiveOS/ext3fs.img /ext3</p>

<p>The inner filesystem is now unpacked under the /ext3
mountpoint.</p>

<p>mknod mknod mode devmajor devminor path</p>

<p>This call creates block or character special devices, or
named pipes (FIFOs).</p>

<p>The &quot;mode&quot; parameter should be the mode, using
the standard constants. &quot;devmajor&quot; and
&quot;devminor&quot; are the device major and minor numbers,
only used when creating block and character special
devices.</p>

<p>Note that, just like mknod(2), the mode must be bitwise
OR d with S_IFBLK, S_IFCHR, S_IFIFO or S_IFSOCK (otherwise
this call just creates a regular file). These constants are
available in the standard Linux header files, or you can use
&quot;mknod-b&quot;, &quot;mknod-c&quot; or
&quot;mkfifo&quot; which are wrappers around this command
which bitwise OR in the appropriate constant for you.</p>

<p>The mode actually set is affected by the umask.</p>

<p>mknod-b mknod-b mode devmajor devminor path</p>

<p>This call creates a block device node called
&quot;path&quot; with mode &quot;mode&quot; and device
major/minor &quot;devmajor&quot; and &quot;devminor&quot;.
It is just a convenient wrapper around
&quot;mknod&quot;.</p>

<p>The mode actually set is affected by the umask.</p>

<p>mknod-c mknod-c mode devmajor devminor path</p>

<p>This call creates a char device node called
&quot;path&quot; with mode &quot;mode&quot; and device
major/minor &quot;devmajor&quot; and &quot;devminor&quot;.
It is just a convenient wrapper around
&quot;mknod&quot;.</p>

<p>The mode actually set is affected by the umask.</p>

<p>mkswap mkswap device</p>

<p>Create a swap partition on &quot;device&quot;.</p>

<p>mkswap-L mkswap-L label device</p>

<p>Create a swap partition on &quot;device&quot; with label
&quot;label&quot;.</p>

<p>Note that you cannot attach a swap label to a block
device (eg. &quot;/dev/sda&quot;), just to a partition. This
appears to be a limitation of the kernel or swap tools.</p>

<p>mkswap-U mkswap-U uuid device</p>

<p>Create a swap partition on &quot;device&quot; with UUID
&quot;uuid&quot;.</p>

<p>mkswap-file mkswap-file path</p>

<p>Create a swap file.</p>

<p>This command just writes a swap file signature to an
existing file. To create the file itself, use something like
&quot;fallocate&quot;.</p>

<p>modprobe modprobe modulename</p>

<p>This loads a kernel module in the appliance.</p>

<p>The kernel module must have been whitelisted when
libguestfs was built (see
&quot;appliance/kmod.whitelist.in&quot; in the source).</p>

<p>mount mount device mountpoint</p>

<p>Mount a guest disk at a position in the filesystem.
Block devices are named &quot;/dev/sda&quot;,
&quot;/dev/sdb&quot; and so on, as they were added to the
guest. If those block devices contain partitions, they will
have the usual names (eg. &quot;/dev/sda1&quot;). Also LVM
&quot;/dev/VG/LV&quot;-style names can be used.</p>

<p>The rules are the same as for mount(2): A filesystem
must first be mounted on &quot;/&quot; before others can be
mounted. Other filesystems can only be mounted on
directories which already exist.</p>

<p>The mounted filesystem is writable, if we have
sufficient permissions on the underlying device.</p>

<p>Important note: When you use this call, the filesystem
options &quot;sync&quot; and &quot;noatime&quot; are set
implicitly. This was originally done because we thought it
would improve reliability, but it turns out that -o sync has
a very large negative performance impact and negligible
effect on reliability. Therefore we recommend that you avoid
using &quot;mount&quot; in any code that needs performance,
and instead use &quot;mount-options&quot; (use an empty
string for the first parameter if you don t want any
options).</p>

<p>mount-loop mount-loop file mountpoint</p>

<p>This command lets you mount &quot;file&quot; (a
filesystem image in a file) on a mount point. It is entirely
equivalent to the command &quot;mount -o loop file
mountpoint&quot;.</p>

<p>mount-options mount-options options device
mountpoint</p>

<p>This is the same as the &quot;mount&quot; command, but
it allows you to set the mount options as for the mount(8)
-o flag.</p>

<p>If the &quot;options&quot; parameter is an empty string,
then no options are passed (all options default to whatever
the filesystem uses).</p>

<p>mount-ro mount-ro device mountpoint</p>

<p>This is the same as the &quot;mount&quot; command, but
it mounts the filesystem with the read-only (-o ro)
flag.</p>

<p>mount-vfs mount-vfs options vfstype device
mountpoint</p>

<p>This is the same as the &quot;mount&quot; command, but
it allows you to set both the mount options and the vfstype
as for the mount(8) -o and -t flags.</p>

<p>mountpoints mountpoints</p>

<p>This call is similar to &quot;mounts&quot;. That call
returns a list of devices. This one returns a hash table
(map) of device name to directory where the device is
mounted.</p>

<p>mounts mounts</p>

<p>This returns the list of currently mounted filesystems.
It returns the list of devices (eg. &quot;/dev/sda1&quot;,
&quot;/dev/VG/LV&quot;).</p>

<p>Some internal mounts are not shown.</p>

<p>See also: &quot;mountpoints&quot;</p>

<p>mv mv src dest</p>

<p>This moves a file from &quot;src&quot; to
&quot;dest&quot; where &quot;dest&quot; is either a
destination filename or destination directory.</p>

<p>ntfs-3g-probe ntfs-3g-probe true|false device</p>

<p>This command runs the ntfs-3g.probe(8) command which
probes an NTFS &quot;device&quot; for mountability. (Not all
NTFS volumes can be mounted read- write, and some cannot be
mounted at all).</p>

<p>&quot;rw&quot; is a boolean flag. Set it to true if you
want to test if the volume can be mounted read-write. Set it
to false if you want to test if the volume can be mounted
read-only.</p>

<p>The return value is an integer which 0 if the operation
would succeed, or some non-zero value documented in the
ntfs-3g.probe(8) manual page.</p>

<p>part-add part-add device prlogex startsect endsect</p>

<p>This command adds a partition to &quot;device&quot;. If
there is no partition table on the device, call
&quot;part-init&quot; first.</p>

<p>The &quot;prlogex&quot; parameter is the type of
partition. Normally you should pass &quot;p&quot; or
&quot;primary&quot; here, but MBR partition tables also
support &quot;l&quot; (or &quot;logical&quot;) and
&quot;e&quot; (or &quot;extended&quot;) partition types.</p>

<p>&quot;startsect&quot; and &quot;endsect&quot; are the
start and end of the partition in sectors.
&quot;endsect&quot; may be negative, which means it counts
backwards from the end of the disk (&quot;-1&quot; is the
last sector).</p>

<p>Creating a partition which covers the whole disk is not
so easy. Use &quot;part-disk&quot; to do that.</p>

<p>part-del part-del device partnum</p>

<p>This command deletes the partition numbered
&quot;partnum&quot; on &quot;device&quot;.</p>

<p>Note that in the case of MBR partitioning, deleting an
extended partition also deletes any logical partitions it
contains.</p>

<p>part-disk part-disk device parttype</p>

<p>This command is simply a combination of
&quot;part-init&quot; followed by &quot;part-add&quot; to
create a single primary partition covering the whole
disk.</p>

<p>&quot;parttype&quot; is the partition table type,
usually &quot;mbr&quot; or &quot;gpt&quot;, but other
possible values are described in &quot;part-init&quot;.</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>part-get-bootable part-get-bootable device partnum</p>

<p>This command returns true if the partition
&quot;partnum&quot; on &quot;device&quot; has the bootable
flag set.</p>

<p>See also &quot;part-set-bootable&quot;.</p>

<p>part-get-mbr-id part-get-mbr-id device partnum</p>

<p>Returns the MBR type byte (also known as the ID byte)
from the numbered partition &quot;partnum&quot;.</p>

<p>Note that only MBR (old DOS-style) partitions have type
bytes. You will get undefined results for other partition
table types (see &quot;part-get-parttype&quot;).</p>

<p>part-get-parttype part-get-parttype device</p>

<p>This command examines the partition table on
&quot;device&quot; and returns the partition table type
(format) being used.</p>

<p>Common return values include: &quot;msdos&quot; (a
DOS/Windows style MBR partition table), &quot;gpt&quot; (a
GPT/EFI-style partition table). Other values are possible,
although unusual. See &quot;part-init&quot; for a full
list.</p>

<p>part-init part-init device parttype</p>

<p>This creates an empty partition table on
&quot;device&quot; of one of the partition types listed
below. Usually &quot;parttype&quot; should be either
&quot;msdos&quot; or &quot;gpt&quot; (for large disks).</p>

<p>Initially there are no partitions. Following this, you
should call &quot;part-add&quot; for each partition
required.</p>

<p>Possible values for &quot;parttype&quot; are:</p>

<p>efi | gpt Intel EFI / GPT partition table.</p>

<p>This is recommended for &gt;= 2 TB partitions that will
be accessed from Linux and Intel-based Mac OS X. It also has
limited backwards compatibility with the &quot;mbr&quot;
format.</p>

<p>mbr | msdos The standard PC &quot;Master Boot
Record&quot; (MBR) format used by MS-DOS and Windows. This
partition type will only work for device sizes up to 2 TB.
For large disks we recommend using &quot;gpt&quot;.</p>

<p>Other partition table types that may work but are not
supported include:</p>

<p>aix AIX disk labels.</p>

<p>amiga | rdb Amiga &quot;Rigid Disk Block&quot;
format.</p>

<p>bsd BSD disk labels.</p>

<p>dasd DASD, used on IBM mainframes.</p>

<p>dvh MIPS/SGI volumes.</p>

<p>mac Old Mac partition format. Modern Macs use
&quot;gpt&quot;.</p>

<p>pc98 NEC PC-98 format, common in Japan apparently.</p>

<p>sun Sun disk labels.</p>

<p>part-list part-list device</p>

<p>This command parses the partition table on
&quot;device&quot; and returns the list of partitions
found.</p>

<p>The fields in the returned structure are:</p>

<p>part_num Partition number, counting from 1.</p>

<p>part_start Start of the partition in bytes. To get
sectors you have to divide by the devices sector size, see
&quot;blockdev-getss&quot;.</p>

<p>part_end End of the partition in bytes.</p>

<p>part_size Size of the partition in bytes.</p>

<p>part-set-bootable part-set-bootable device partnum
true|false</p>

<p>This sets the bootable flag on partition numbered
&quot;partnum&quot; on device &quot;device&quot;. Note that
partitions are numbered from 1.</p>

<p>The bootable flag is used by some operating systems
(notably Windows) to determine which partition to boot from.
It is by no means universally recognized.</p>

<p>part-set-mbr-id part-set-mbr-id device partnum
idbyte</p>

<p>Sets the MBR type byte (also known as the ID byte) of
the numbered partition &quot;partnum&quot; to
&quot;idbyte&quot;. Note that the type bytes quoted in most
documentation are in fact hexadecimal numbers, but usually
documented without any leading &quot;0x&quot; which might be
confusing.</p>

<p>Note that only MBR (old DOS-style) partitions have type
bytes. You will get undefined results for other partition
table types (see &quot;part-get-parttype&quot;).</p>

<p>part-set-name part-set-name device partnum name</p>

<p>This sets the partition name on partition numbered
&quot;partnum&quot; on device &quot;device&quot;. Note that
partitions are numbered from 1.</p>

<p>The partition name can only be set on certain types of
partition table. This works on &quot;gpt&quot; but not on
&quot;mbr&quot; partitions.</p>

<p>ping-daemon ping-daemon</p>

<p>This is a test probe into the guestfs daemon running
inside the qemu subprocess. Calling this function checks
that the daemon responds to the ping message, without
affecting the daemon or attached block device(s) in any
other way.</p>

<p>pread pread path count offset</p>

<p>This command lets you read part of a file. It reads
&quot;count&quot; bytes of the file, starting at
&quot;offset&quot;, from file &quot;path&quot;.</p>

<p>This may read fewer bytes than requested. For further
details see the pread(2) system call.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>pvcreate pvcreate device</p>

<p>This creates an LVM physical volume on the named
&quot;device&quot;, where &quot;device&quot; should usually
be a partition name such as &quot;/dev/sda1&quot;.</p>

<p>pvremove pvremove device</p>

<p>This wipes a physical volume &quot;device&quot; so that
LVM will no longer recognise it.</p>

<p>The implementation uses the &quot;pvremove&quot; command
which refuses to wipe physical volumes that contain any
volume groups, so you have to remove those first.</p>

<p>pvresize pvresize device</p>

<p>This resizes (expands or shrinks) an existing LVM
physical volume to match the new size of the underlying
device.</p>

<p>pvs pvs</p>

<p>List all the physical volumes detected. This is the
equivalent of the pvs(8) command.</p>

<p>This returns a list of just the device names that
contain PVs (eg. &quot;/dev/sda2&quot;).</p>

<p>See also &quot;pvs-full&quot;.</p>

<p>pvs-full pvs-full</p>

<p>List all the physical volumes detected. This is the
equivalent of the pvs(8) command. The &quot;full&quot;
version includes all fields.</p>

<p>pvuuid pvuuid device</p>

<p>This command returns the UUID of the LVM PV
&quot;device&quot;.</p>

<p>read-file read-file path</p>

<p>This calls returns the contents of the file
&quot;path&quot; as a buffer.</p>

<p>Unlike &quot;cat&quot;, this function can correctly
handle files that contain embedded ASCII NUL characters.
However unlike &quot;download&quot;, this function is
limited in the total size of file that can be handled.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>read-lines read-lines path</p>

<p>Return the contents of the file named
&quot;path&quot;.</p>

<p>The file contents are returned as a list of lines.
Trailing &quot;LF&quot; and &quot;CRLF&quot; character
sequences are not returned.</p>

<p>Note that this function cannot correctly handle binary
files (specifically, files containing &quot; &quot;
character which is treated as end of line). For those you
need to use the &quot;read-file&quot; function which has a
more complex interface.</p>

<p>readdir readdir dir</p>

<p>This returns the list of directory entries in directory
&quot;dir&quot;.</p>

<p>All entries in the directory are returned, including
&quot;.&quot; and &quot;..&quot;. The entries are not
sorted, but returned in the same order as the underlying
filesystem.</p>

<p>Also this call returns basic file type information about
each file. The &quot;ftyp&quot; field will contain one of
the following characters:</p>

<p>b Block special</p>

<p>c Char special</p>

<p>d Directory</p>

<p>f FIFO (named pipe)</p>

<p>l Symbolic link</p>

<p>r Regular file</p>

<p>s Socket</p>

<p>u Unknown file type</p>

<p>? The readdir(3) returned a &quot;d_type&quot; field
with an unexpected value</p>

<p>This function is primarily intended for use by programs.
To get a simple list of names, use &quot;ls&quot;. To get a
printable directory for human consumption, use
&quot;ll&quot;.</p>

<p>readlink readlink path</p>

<p>This command reads the target of a symbolic link.</p>

<p>readlinklist readlinklist path &rsquo;names
...&rsquo;</p>

<p>This call allows you to do a &quot;readlink&quot;
operation on multiple files, where all files are in the
directory &quot;path&quot;. &quot;names&quot; is the list of
files from this directory.</p>

<p>On return you get a list of strings, with a one-to-one
correspondence to the &quot;names&quot; list. Each string is
the value of the symbol link.</p>

<p>If the readlink(2) operation fails on any name, then the
corresponding result string is the empty string
&quot;&quot;. However the whole operation is completed even
if there were readlink(2) errors, and so you can call this
function with names where you dont know if they are symbolic
links already (albeit slightly less efficient).</p>

<p>This call is intended for programs that want to
efficiently list a directory contents without making many
round-trips. Very long directory listings might cause the
protocol message size to be exceeded, causing this call to
fail. The caller must split up such requests into smaller
groups of names.</p>

<p>realpath realpath path</p>

<p>Return the canonicalized absolute pathname of
&quot;path&quot;. The returned path has no &quot;.&quot;,
&quot;..&quot; or symbolic link path elements.</p>

<p>removexattr removexattr xattr path</p>

<p>This call removes the extended attribute named
&quot;xattr&quot; of the file &quot;path&quot;.</p>

<p>See also: &quot;lremovexattr&quot;, attr(5).</p>

<p>resize2fs resize2fs device</p>

<p>This resizes an ext2 or ext3 filesystem to match the
size of the underlying device.</p>

<p>Note: It is sometimes required that you run
&quot;e2fsck-f&quot; on the &quot;device&quot; before
calling this command. For unknown reasons
&quot;resize2fs&quot; sometimes gives an error about this
and sometimes not. In any case, it is always safe to call
&quot;e2fsck-f&quot; before calling this function.</p>

<p>rm rm path</p>

<p>Remove the single file &quot;path&quot;.</p>

<p>rm-rf rm-rf path</p>

<p>Remove the file or directory &quot;path&quot;,
recursively removing the contents if its a directory. This
is like the &quot;rm -rf&quot; shell command.</p>

<p>rmdir rmdir path</p>

<p>Remove the single directory &quot;path&quot;.</p>

<p>rmmountpoint rmmountpoint exemptpath</p>

<p>This calls removes a mountpoint that was previously
created with &quot;mkmountpoint&quot;. See
&quot;mkmountpoint&quot; for full details.</p>

<p>scrub-device scrub-device device</p>

<p>This command writes patterns over &quot;device&quot; to
make data retrieval more difficult.</p>

<p>It is an interface to the scrub(1) program. See that
manual page for more details.</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>scrub-file scrub-file file</p>

<p>This command writes patterns over a file to make data
retrieval more difficult.</p>

<p>The file is removed after scrubbing.</p>

<p>It is an interface to the scrub(1) program. See that
manual page for more details.</p>

<p>scrub-freespace scrub-freespace dir</p>

<p>This command creates the directory &quot;dir&quot; and
then fills it with files until the filesystem is full, and
scrubs the files as for &quot;scrub-file&quot;, and deletes
them. The intention is to scrub any free space on the
partition containing &quot;dir&quot;.</p>

<p>It is an interface to the scrub(1) program. See that
manual page for more details.</p>

<p>set-append | append set-append append</p>

<p>This function is used to add additional options to the
guest kernel command line.</p>

<p>The default is &quot;NULL&quot; unless overridden by
setting &quot;LIBGUESTFS_APPEND&quot; environment
variable.</p>

<p>Setting &quot;append&quot; to &quot;NULL&quot; means no
additional options are passed (libguestfs always adds a few
of its own).</p>

<p>set-autosync | autosync set-autosync true|false</p>

<p>If &quot;autosync&quot; is true, this enables autosync.
Libguestfs will make a best effort attempt to run
&quot;umount-all&quot; followed by &quot;sync&quot; when the
handle is closed (also if the program exits without closing
handles).</p>

<p>This is disabled by default (except in guestfish where
it is enabled by default).</p>

<p>set-direct | direct set-direct true|false</p>

<p>If the direct appliance mode flag is enabled, then stdin
and stdout are passed directly through to the appliance once
it is launched.</p>

<p>One consequence of this is that log messages arent
caught by the library and handled by
&quot;set-log-message-callback&quot;, but go straight to
stdout.</p>

<p>You probably don t want to use this unless you know what
you are doing.</p>

<p>The default is disabled.</p>

<p>set-e2label set-e2label device label</p>

<p>This sets the ext2/3/4 filesystem label of the
filesystem on &quot;device&quot; to &quot;label&quot;.
Filesystem labels are limited to 16 characters.</p>

<p>You can use either &quot;tune2fs-l&quot; or
&quot;get-e2label&quot; to return the existing label on a
filesystem.</p>

<p>set-e2uuid set-e2uuid device uuid</p>

<p>This sets the ext2/3/4 filesystem UUID of the filesystem
on &quot;device&quot; to &quot;uuid&quot;. The format of the
UUID and alternatives such as &quot;clear&quot;,
&quot;random&quot; and &quot;time&quot; are described in the
tune2fs(8) manpage.</p>

<p>You can use either &quot;tune2fs-l&quot; or
&quot;get-e2uuid&quot; to return the existing UUID of a
filesystem.</p>

<p>set-memsize | memsize set-memsize memsize</p>

<p>This sets the memory size in megabytes allocated to the
qemu subprocess. This only has any effect if called before
&quot;launch&quot;.</p>

<p>You can also change this by setting the environment
variable &quot;LIBGUESTFS_MEMSIZE&quot; before the handle is
created.</p>

<p>For more information on the architecture of libguestfs,
see guestfs(3).</p>

<p>set-path | path set-path searchpath</p>

<p>Set the path that libguestfs searches for kernel and
initrd.img.</p>

<p>The default is &quot;$libdir/guestfs&quot; unless
overridden by setting &quot;LIBGUESTFS_PATH&quot;
environment variable.</p>

<p>Setting &quot;path&quot; to &quot;NULL&quot; restores
the default path.</p>

<p>set-qemu | qemu set-qemu qemu</p>

<p>Set the qemu binary that we will use.</p>

<p>The default is chosen when the library was compiled by
the configure script.</p>

<p>You can also override this by setting the
&quot;LIBGUESTFS_QEMU&quot; environment variable.</p>

<p>Setting &quot;qemu&quot; to &quot;NULL&quot; restores
the default qemu binary.</p>

<p>Note that you should call this function as early as
possible after creating the handle. This is because some
pre-launch operations depend on testing qemu features (by
running &quot;qemu -help&quot;). If the qemu binary changes,
we don t retest features, and so you might see inconsistent
results. Using the environment variable
&quot;LIBGUESTFS_QEMU&quot; is safest of all since that
picks the qemu binary at the same time as the handle is
created.</p>

<p>set-recovery-proc | recovery-proc set-recovery-proc
true|false</p>

<p>If this is called with the parameter &quot;false&quot;
then &quot;launch&quot; does not create a recovery process.
The purpose of the recovery process is to stop runaway qemu
processes in the case where the main program aborts
abruptly.</p>

<p>This only has any effect if called before
&quot;launch&quot;, and the default is true.</p>

<p>About the only time when you would want to disable this
is if the main process will fork itself into the background
(&quot;daemonize&quot; itself). In this case the recovery
process thinks that the main program has disappeared and so
kills qemu, which is not very helpful.</p>

<p>set-selinux | selinux set-selinux true|false</p>

<p>This sets the selinux flag that is passed to the
appliance at boot time. The default is &quot;selinux=0&quot;
(disabled).</p>

<p>Note that if SELinux is enabled, it is always in
Permissive mode (&quot;enforcing=0&quot;).</p>

<p>For more information on the architecture of libguestfs,
see guestfs(3).</p>

<p>set-trace | trace set-trace true|false</p>

<p>If the command trace flag is set to 1, then commands are
printed on stdout before they are executed in a format which
is very similar to the one used by guestfish. In other
words, you can run a program with this enabled, and you will
get out a script which you can feed to guestfish to perform
the same set of actions.</p>

<p>If you want to trace C API calls into libguestfs (and
other libraries) then possibly a better way is to use the
external ltrace(1) command.</p>

<p>Command traces are disabled unless the environment
variable &quot;LIBGUESTFS_TRACE&quot; is defined and set to
1.</p>

<p>set-verbose | verbose set-verbose true|false</p>

<p>If &quot;verbose&quot; is true, this turns on verbose
messages (to &quot;stderr&quot;).</p>

<p>Verbose messages are disabled unless the environment
variable &quot;LIBGUESTFS_DEBUG&quot; is defined and set to
1.</p>

<p>setcon setcon context</p>

<p>This sets the SELinux security context of the daemon to
the string &quot;context&quot;.</p>

<p>See the documentation about SELINUX in guestfs(3).</p>

<p>setxattr setxattr xattr val vallen path</p>

<p>This call sets the extended attribute named
&quot;xattr&quot; of the file &quot;path&quot; to the value
&quot;val&quot; (of length &quot;vallen&quot;). The value is
arbitrary 8 bit data.</p>

<p>See also: &quot;lsetxattr&quot;, attr(5).</p>

<p>sfdisk sfdisk device cyls heads sectors &rsquo;lines
...&rsquo;</p>

<p>This is a direct interface to the sfdisk(8) program for
creating partitions on block devices.</p>

<p>&quot;device&quot; should be a block device, for example
&quot;/dev/sda&quot;.</p>

<p>&quot;cyls&quot;, &quot;heads&quot; and
&quot;sectors&quot; are the number of cylinders, heads and
sectors on the device, which are passed directly to sfdisk
as the -C, -H and -S parameters. If you pass 0 for any of
these, then the corresponding parameter is omitted. Usually
for large disks, you can just pass 0 for these, but for
small (floppy-sized) disks, sfdisk (or rather, the kernel)
cannot work out the right geometry and you will need to tell
it.</p>

<p>&quot;lines&quot; is a list of lines that we feed to
&quot;sfdisk&quot;. For more information refer to the
sfdisk(8) manpage.</p>

<p>To create a single partition occupying the whole disk,
you would pass &quot;lines&quot; as a single element list,
when the single element being the string &quot;,&quot;
(comma).</p>

<p>See also: &quot;sfdisk-l&quot;, &quot;sfdisk-N&quot;,
&quot;part-init&quot;</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>sfdiskM sfdiskM device &rsquo;lines ...&rsquo;</p>

<p>This is a simplified interface to the &quot;sfdisk&quot;
command, where partition sizes are specified in megabytes
only (rounded to the nearest cylinder) and you dont need to
specify the cyls, heads and sectors parameters which were
rarely if ever used anyway.</p>

<p>See also: &quot;sfdisk&quot;, the sfdisk(8) manpage and
&quot;part-disk&quot;</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>sfdisk-N sfdisk-N device partnum cyls heads sectors
line</p>

<p>This runs sfdisk(8) option to modify just the single
partition &quot;n&quot; (note: &quot;n&quot; counts from
1).</p>

<p>For other parameters, see &quot;sfdisk&quot;. You should
usually pass 0 for the cyls/heads/sectors parameters.</p>

<p>See also: &quot;part-add&quot;</p>

<p>This command is dangerous. Without careful use you can
easily destroy all your data.</p>

<p>sfdisk-disk-geometry sfdisk-disk-geometry device</p>

<p>This displays the disk geometry of &quot;device&quot;
read from the partition table. Especially in the case where
the underlying block device has been resized, this can be
different from the kernels idea of the geometry (see
&quot;sfdisk-kernel-geometry&quot;).</p>

<p>The result is in human-readable format, and not designed
to be parsed.</p>

<p>sfdisk-kernel-geometry sfdisk-kernel-geometry device</p>

<p>This displays the kernel s idea of the geometry of
&quot;device&quot;.</p>

<p>The result is in human-readable format, and not designed
to be parsed.</p>

<p>sfdisk-l sfdisk-l device</p>

<p>This displays the partition table on &quot;device&quot;,
in the human-readable output of the sfdisk(8) command. It is
not intended to be parsed.</p>

<p>See also: &quot;part-list&quot;</p>

<p>sh sh command</p>

<p>This call runs a command from the guest filesystem via
the guests &quot;/bin/sh&quot;.</p>

<p>This is like &quot;command&quot;, but passes the command
to:</p>

<p>/bin/sh -c &quot;command&quot;</p>

<p>Depending on the guest s shell, this usually results in
wildcards being expanded, shell expressions being
interpolated and so on.</p>

<p>All the provisos about &quot;command&quot; apply to this
call.</p>

<p>sh-lines sh-lines command</p>

<p>This is the same as &quot;sh&quot;, but splits the
result into a list of lines.</p>

<p>See also: &quot;command-lines&quot;</p>

<p>sleep sleep secs</p>

<p>Sleep for &quot;secs&quot; seconds.</p>

<p>stat stat path</p>

<p>Returns file information for the given
&quot;path&quot;.</p>

<p>This is the same as the stat(2) system call.</p>

<p>statvfs statvfs path</p>

<p>Returns file system statistics for any mounted file
system. &quot;path&quot; should be a file or directory in
the mounted file system (typically it is the mount point
itself, but it doesnt need to be).</p>

<p>This is the same as the statvfs(2) system call.</p>

<p>strings strings path</p>

<p>This runs the strings(1) command on a file and returns
the list of printable strings found.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>strings-e strings-e encoding path</p>

<p>This is like the &quot;strings&quot; command, but allows
you to specify the encoding of strings that are looked for
in the source file &quot;path&quot;.</p>

<p>Allowed encodings are:</p>

<p>s Single 7-bit-byte characters like ASCII and the
ASCII-compatible parts of ISO-8859-X (this is what
&quot;strings&quot; uses).</p>

<p>S Single 8-bit-byte characters.</p>

<p>b 16-bit big endian strings such as those encoded in
UTF-16BE or UCS-2BE.</p>

<p>l (lower case letter L) 16-bit little endian such as
UTF-16LE and UCS-2LE. This is useful for examining binaries
in Windows guests.</p>

<p>B 32-bit big endian such as UCS-4BE.</p>

<p>L 32-bit little endian such as UCS-4LE.</p>

<p>The returned strings are transcoded to UTF-8.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>swapoff-device swapoff-device device</p>

<p>This command disables the libguestfs appliance swap
device or partition named &quot;device&quot;. See
&quot;swapon-device&quot;.</p>

<p>swapoff-file swapoff-file file</p>

<p>This command disables the libguestfs appliance swap on
file.</p>

<p>swapoff-label swapoff-label label</p>

<p>This command disables the libguestfs appliance swap on
labeled swap partition.</p>

<p>swapoff-uuid swapoff-uuid uuid</p>

<p>This command disables the libguestfs appliance swap
partition with the given UUID.</p>

<p>swapon-device swapon-device device</p>

<p>This command enables the libguestfs appliance to use the
swap device or partition named &quot;device&quot;. The
increased memory is made available for all commands, for
example those run using &quot;command&quot; or
&quot;sh&quot;.</p>

<p>Note that you should not swap to existing guest swap
partitions unless you know what you are doing. They may
contain hibernation information, or other information that
the guest doesnt want you to trash. You also risk leaking
information about the host to the guest this way. Instead,
attach a new host device to the guest and swap on that.</p>

<p>swapon-file swapon-file file</p>

<p>This command enables swap to a file. See
&quot;swapon-device&quot; for other notes.</p>

<p>swapon-label swapon-label label</p>

<p>This command enables swap to a labeled swap partition.
See &quot;swapon-device&quot; for other notes.</p>

<p>swapon-uuid swapon-uuid uuid</p>

<p>This command enables swap to a swap partition with the
given UUID. See &quot;swapon-device&quot; for other
notes.</p>

<p>sync sync</p>

<p>This syncs the disk, so that any writes are flushed
through to the underlying disk image.</p>

<p>You should always call this if you have modified a disk
image, before closing the handle.</p>

<p>tail tail path</p>

<p>This command returns up to the last 10 lines of a file
as a list of strings.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>tail-n tail-n nrlines path</p>

<p>If the parameter &quot;nrlines&quot; is a positive
number, this returns the last &quot;nrlines&quot; lines of
the file &quot;path&quot;.</p>

<p>If the parameter &quot;nrlines&quot; is a negative
number, this returns lines from the file &quot;path&quot;,
starting with the &quot;-nrlines&quot;th line.</p>

<p>If the parameter &quot;nrlines&quot; is zero, this
returns an empty list.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>tar-in tar-in (tarfile|-) directory</p>

<p>This command uploads and unpacks local file
&quot;tarfile&quot; (an uncompressed tar file) into
&quot;directory&quot;.</p>

<p>To upload a compressed tarball, use
&quot;tgz-in&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>tar-out tar-out directory (tarfile|-)</p>

<p>This command packs the contents of &quot;directory&quot;
and downloads it to local file &quot;tarfile&quot;.</p>

<p>To download a compressed tarball, use
&quot;tgz-out&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>tgz-in tgz-in (tarball|-) directory</p>

<p>This command uploads and unpacks local file
&quot;tarball&quot; (a gzip compressed tar file) into
&quot;directory&quot;.</p>

<p>To upload an uncompressed tarball, use
&quot;tar-in&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>tgz-out tgz-out directory (tarball|-)</p>

<p>This command packs the contents of &quot;directory&quot;
and downloads it to local file &quot;tarball&quot;.</p>

<p>To download an uncompressed tarball, use
&quot;tar-out&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>touch touch path</p>

<p>Touch acts like the touch(1) command. It can be used to
update the timestamps on a file, or, if the file does not
exist, to create a new zero-length file.</p>

<p>truncate truncate path</p>

<p>This command truncates &quot;path&quot; to a zero-length
file. The file must exist already.</p>

<p>truncate-size truncate-size path size</p>

<p>This command truncates &quot;path&quot; to size
&quot;size&quot; bytes. The file must exist already. If the
file is smaller than &quot;size&quot; then the file is
extended to the required size with null bytes.</p>

<p>tune2fs-l tune2fs-l device</p>

<p>This returns the contents of the ext2, ext3 or ext4
filesystem superblock on &quot;device&quot;.</p>

<p>It is the same as running &quot;tune2fs -l device&quot;.
See tune2fs(8) manpage for more details. The list of fields
returned isnt clearly defined, and depends on both the
version of &quot;tune2fs&quot; that libguestfs was built
against, and the filesystem itself.</p>

<p>umask umask mask</p>

<p>This function sets the mask used for creating new files
and device nodes to &quot;mask &amp; 0777&quot;.</p>

<p>Typical umask values would be 022 which creates new
files with permissions like &quot;-rw-r--r--&quot; or
&quot;-rwxr-xr-x&quot;, and 002 which creates new files with
permissions like &quot;-rw-rw-r--&quot; or
&quot;-rwxrwxr-x&quot;.</p>

<p>The default umask is 022. This is important because it
means that directories and device nodes will be created with
0644 or 0755 mode even if you specify 0777.</p>

<p>See also umask(2), &quot;mknod&quot;,
&quot;mkdir&quot;.</p>

<p>This call returns the previous umask.</p>

<p>umount | unmount umount pathordevice</p>

<p>This unmounts the given filesystem. The filesystem may
be specified either by its mountpoint (path) or the device
which contains the filesystem.</p>

<p>umount-all | unmount-all umount-all</p>

<p>This unmounts all mounted filesystems.</p>

<p>Some internal mounts are not unmounted by this call.</p>

<p>upload upload (filename|-) remotefilename</p>

<p>Upload local file &quot;filename&quot; to
&quot;remotefilename&quot; on the filesystem.</p>

<p>&quot;filename&quot; can also be a named pipe.</p>

<p>See also &quot;download&quot;.</p>

<p>Use &quot;-&quot; instead of a filename to read/write
from stdin/stdout.</p>

<p>utimens utimens path atsecs atnsecs mtsecs mtnsecs</p>

<p>This command sets the timestamps of a file with
nanosecond precision.</p>

<p>&quot;atsecs, atnsecs&quot; are the last access time
(atime) in secs and nanoseconds from the epoch.</p>

<p>&quot;mtsecs, mtnsecs&quot; are the last modification
time (mtime) in secs and nanoseconds from the epoch.</p>

<p>If the *nsecs field contains the special value
&quot;-1&quot; then the corresponding timestamp is set to
the current time. (The *secs field is ignored in this
case).</p>

<p>If the *nsecs field contains the special value
&quot;-2&quot; then the corresponding timestamp is left
unchanged. (The *secs field is ignored in this case).</p>

<p>version version</p>

<p>Return the libguestfs version number that the program is
linked against.</p>

<p>Note that because of dynamic linking this is not
necessarily the version of libguestfs that you compiled
against. You can compile the program, and then at runtime
dynamically link against a completely different
&quot;libguestfs.so&quot; library.</p>

<p>This call was added in version 1.0.58. In previous
versions of libguestfs there was no way to get the version
number. From C code you can use ELF weak linking tricks to
find out if this symbol exists (if it doesnt, then its an
earlier version).</p>

<p>The call returns a structure with four elements. The
first three (&quot;major&quot;, &quot;minor&quot; and
&quot;release&quot;) are numbers and correspond to the usual
version triplet. The fourth element (&quot;extra&quot;) is a
string and is normally empty, but may be used for
distro-specific information.</p>

<p>To construct the original version string:
&quot;$major.$minor.$release$extra&quot;</p>

<p>Note: Don t use this call to test for availability of
features. Distro backports makes this unreliable. Use
&quot;available&quot; instead.</p>

<p>vfs-type vfs-type device</p>

<p>This command gets the block device type corresponding to
a mounted device called &quot;device&quot;.</p>

<p>Usually the result is the name of the Linux VFS module
that is used to mount this device (probably determined
automatically if you used the &quot;mount&quot; call).</p>

<p>vg-activate vg-activate true|false &rsquo;volgroups
...&rsquo;</p>

<p>This command activates or (if &quot;activate&quot; is
false) deactivates all logical volumes in the listed volume
groups &quot;volgroups&quot;. If activated, then they are
made known to the kernel, ie. they appear as
&quot;/dev/mapper&quot; devices. If deactivated, then those
devices disappear.</p>

<p>This command is the same as running &quot;vgchange -a
y|n volgroups...&quot;</p>

<p>Note that if &quot;volgroups&quot; is an empty list then
all volume groups are activated or deactivated.</p>

<p>vg-activate-all vg-activate-all true|false</p>

<p>This command activates or (if &quot;activate&quot; is
false) deactivates all logical volumes in all volume groups.
If activated, then they are made known to the kernel, ie.
they appear as &quot;/dev/mapper&quot; devices. If
deactivated, then those devices disappear.</p>

<p>This command is the same as running &quot;vgchange -a
y|n&quot;</p>

<p>vgcreate vgcreate volgroup &rsquo;physvols
...&rsquo;</p>

<p>This creates an LVM volume group called
&quot;volgroup&quot; from the non-empty list of physical
volumes &quot;physvols&quot;.</p>

<p>vglvuuids vglvuuids vgname</p>

<p>Given a VG called &quot;vgname&quot;, this returns the
UUIDs of all the logical volumes created in this volume
group.</p>

<p>You can use this along with &quot;lvs&quot; and
&quot;lvuuid&quot; calls to associate logical volumes and
volume groups.</p>

<p>See also &quot;vgpvuuids&quot;.</p>

<p>vgpvuuids vgpvuuids vgname</p>

<p>Given a VG called &quot;vgname&quot;, this returns the
UUIDs of all the physical volumes that this volume group
resides on.</p>

<p>You can use this along with &quot;pvs&quot; and
&quot;pvuuid&quot; calls to associate physical volumes and
volume groups.</p>

<p>See also &quot;vglvuuids&quot;.</p>

<p>vgremove vgremove vgname</p>

<p>Remove an LVM volume group &quot;vgname&quot;, (for
example &quot;VG&quot;).</p>

<p>This also forcibly removes all logical volumes in the
volume group (if any).</p>

<p>vgrename vgrename volgroup newvolgroup</p>

<p>Rename a volume group &quot;volgroup&quot; with the new
name &quot;newvolgroup&quot;.</p>

<p>vgs vgs</p>

<p>List all the volumes groups detected. This is the
equivalent of the vgs(8) command.</p>

<p>This returns a list of just the volume group names that
were detected (eg. &quot;VolGroup00&quot;).</p>

<p>See also &quot;vgs-full&quot;.</p>

<p>vgs-full vgs-full</p>

<p>List all the volumes groups detected. This is the
equivalent of the vgs(8) command. The &quot;full&quot;
version includes all fields.</p>

<p>vguuid vguuid vgname</p>

<p>This command returns the UUID of the LVM VG named
&quot;vgname&quot;.</p>

<p>wc-c wc-c path</p>

<p>This command counts the characters in a file, using the
&quot;wc -c&quot; external command.</p>

<p>wc-l wc-l path</p>

<p>This command counts the lines in a file, using the
&quot;wc -l&quot; external command.</p>

<p>wc-w wc-w path</p>

<p>This command counts the words in a file, using the
&quot;wc -w&quot; external command.</p>

<p>write-file write-file path content size</p>

<p>This call creates a file called &quot;path&quot;. The
contents of the file is the string &quot;content&quot;
(which can contain any 8 bit data), with length
&quot;size&quot;.</p>

<p>As a special case, if &quot;size&quot; is 0 then the
length is calculated using &quot;strlen&quot; (so in this
case the content cannot contain embedded ASCII NULs).</p>

<p>NB. Owing to a bug, writing content containing ASCII NUL
characters does not work, even if the length is specified.
We hope to resolve this bug in a future version. In the
meantime use &quot;upload&quot;.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zegrep zegrep regex path</p>

<p>This calls the external &quot;zegrep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zegrepi zegrepi regex path</p>

<p>This calls the external &quot;zegrep -i&quot; program
and returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zero zero device</p>

<p>This command writes zeroes over the first few blocks of
&quot;device&quot;.</p>

<p>How many blocks are zeroed isnt specified (but its not
enough to securely wipe the device). It should be sufficient
to remove any partition tables, filesystem superblocks and
so on.</p>

<p>See also: &quot;scrub-device&quot;.</p>

<p>zerofree zerofree device</p>

<p>This runs the zerofree program on &quot;device&quot;.
This program claims to zero unused inodes and disk blocks on
an ext2/3 filesystem, thus making it possible to compress
the filesystem more effectively.</p>

<p>You should not run this program if the filesystem is
mounted.</p>

<p>It is possible that using this program can damage the
filesystem or data on the filesystem.</p>

<p>zfgrep zfgrep pattern path</p>

<p>This calls the external &quot;zfgrep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zfgrepi zfgrepi pattern path</p>

<p>This calls the external &quot;zfgrep -i&quot; program
and returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zfile zfile meth path</p>

<p>This command runs &quot;file&quot; after first
decompressing &quot;path&quot; using &quot;method&quot;.</p>

<p>&quot;method&quot; must be one of &quot;gzip&quot;,
&quot;compress&quot; or &quot;bzip2&quot;.</p>

<p>Since 1.0.63, use &quot;file&quot; instead which can now
process compressed files.</p>

<p>This function is deprecated. In new code, use the
&quot;file&quot; call instead.</p>

<p>Deprecated functions will not be removed from the API,
but the fact that they are deprecated indicates that there
are problems with correct use of these functions.</p>

<p>zgrep zgrep regex path</p>

<p>This calls the external &quot;zgrep&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>zgrepi zgrepi regex path</p>

<p>This calls the external &quot;zgrep -i&quot; program and
returns the matching lines.</p>

<p>Because of the message protocol, there is a transfer
limit of somewhere between 2MB and 4MB. See &quot;PROTOCOL
LIMITS&quot; in guestfs(3).</p>

<p>ENVIRONMENT VARIABLES EDITOR The &quot;edit&quot;
command uses $EDITOR as the editor. If not set, it uses
&quot;vi&quot;.</p>

<p>GUESTFISH_PID Used with the --remote option to specify
the remote guestfish process to control. See section
&quot;REMOTE CONTROL GUESTFISH OVER A SOCKET&quot;.</p>

<p>HOME If compiled with GNU readline support, then the
command history is saved in &quot;$HOME/.guestfish&quot;</p>

<p>LIBGUESTFS_APPEND Pass additional options to the guest
kernel.</p>

<p>LIBGUESTFS_DEBUG Set &quot;LIBGUESTFS_DEBUG=1&quot; to
enable verbose messages. This has the same effect as using
the -v option.</p>

<p>LIBGUESTFS_MEMSIZE Set the memory allocated to the qemu
process, in megabytes. For example:</p>

<p>LIBGUESTFS_MEMSIZE=700</p>

<p>LIBGUESTFS_PATH Set the path that guestfish uses to
search for kernel and initrd.img. See the discussion of
paths in guestfs(3).</p>

<p>LIBGUESTFS_QEMU Set the default qemu binary that
libguestfs uses. If not set, then the qemu which was found
at compile time by the configure script is used.</p>

<p>LIBGUESTFS_TRACE Set &quot;LIBGUESTFS_TRACE=1&quot; to
enable command traces.</p>

<p>PAGER The &quot;more&quot; command uses $PAGER as the
pager. If not set, it uses &quot;more&quot;.</p>

<p>TMPDIR Location of temporary directory, defaults to
&quot;/tmp&quot;.</p>

<p>If libguestfs was compiled to use the supermin appliance
then each handle will require rather a large amount of space
in this directory for short periods of time (~ 80 MB). You
can use $TMPDIR to configure another directory to use in
case &quot;/tmp&quot; is not large enough.</p>

<p>EXIT CODE guestfish returns 0 if the commands completed
without error, or 1 if there was an error.</p>

<p>SEE ALSO guestfs(3), &lt;http://libguestfs.org/&gt;,
virt-cat(1), virt-df(1), virt-edit(1),
virt-list-filesystems(1), virt-list-partitions(1),
virt-ls(1), virt-make-fs(1), virt-rescue(1), virt-resize(1),
virt-tar(1), virt-win-reg(1).</p>

<p>AUTHORS Richard W.M. Jones (&quot;rjones at redhat dot
com&quot;)</p>

<p>COPYRIGHT Copyright (C) 2009-2010 Red Hat Inc.
&lt;http://libguestfs.org/&gt;</p>

<p>This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.</p>

<p>This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more
details.</p>

<p>You should have received a copy of the GNU General
Public License along with this program; if not, write to the
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
02139, USA.</p>

<p>libguestfs-1.2.7 2010-09-07 guestfish(1)</p>
<hr>
</body>
</html>
