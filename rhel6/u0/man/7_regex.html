<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 22:12:49 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>REGEX(7) Linux Programmer s Manual REGEX(7)</p>

<p>NAME regex - POSIX.2 regular expressions</p>

<p>DESCRIPTION Regular expressions (&quot;RE&quot;s), as
defined in POSIX.2, come in two forms: modern REs (roughly
those of egrep; POSIX.2 calls these &quot;extended&quot;
REs) and obsolete REs (roughly those of ed(1); POSIX.2
&quot;basic&quot; REs). Obso- lete REs mostly exist for
backward compatibility in some old programs; they will be
discussed at the end. POSIX.2 leaves some aspects of RE
syntax and semantics open; &quot;(!)&quot; marks decisions
on these aspects that may not be fully portable to other
POSIX.2 implementations.</p>

<p>A (modern) RE is one(!) or more non-empty(!) branches,
separated by &rsquo;|&rsquo;. It matches anything that
matches one of the branches.</p>

<p>A branch is one(!) or more pieces, concatenated. It
matches a match for the first, followed by a match for the
second, etc.</p>

<p>A piece is an atom possibly followed by a single(!)
&rsquo;*&rsquo;, &rsquo;+&rsquo;, &rsquo;?&rsquo;, or bound.
An atom followed by &rsquo;*&rsquo; matches a sequence of 0
or more matches of the atom. An atom followed by
&rsquo;+&rsquo; matches a sequence of 1 or more matches of
the atom. An atom followed by &rsquo;?&rsquo; matches a
sequence of 0 or 1 matches of the atom.</p>

<p>A bound is &rsquo;{&rsquo; followed by an unsigned
decimal integer, possibly fol- lowed by &rsquo;,&rsquo;
possibly followed by another unsigned decimal integer,
always followed by &rsquo;}&rsquo;. The integers must lie
between 0 and RE_DUP_MAX (255(!)) inclusive, and if there
are two of them, the first may not exceed the second. An
atom followed by a bound containing one integer i and no
comma matches a sequence of exactly i matches of the atom.
An atom followed by a bound containing one integer i and a
comma matches a sequence of i or more matches of the atom.
An atom followed by a bound containing two integers i and j
matches a sequence of i through j (inclusive) matches of the
atom.</p>

<p>An atom is a regular expression enclosed in
&quot;()&quot; (matching a match for the regular
expression), an empty set of &quot;()&quot; (matching the
null string)(!), a bracket expression (see below),
&rsquo;.&rsquo; (matching any single character),
&rsquo;^&rsquo; (matching the null string at the beginning
of a line), &rsquo;$&rsquo; (matching the null string at the
end of a line), a &rsquo;&acute; followed by one of the
characters &quot;^.[$()|*+?{_ an ordinary character), a
&rsquo;&acute; followed by any other character(!) (matching
that character taken as an ordinary character, as if the
&rsquo;&acute; had not been present(!)), or a single
character with no other signifi- cance (matching that
character). A &rsquo;{&rsquo; followed by a character other
than a digit is an ordinary character, not the beginning of
a bound(!). It is illegal to end an RE with
&rsquo;&acute;.</p>

<p>A bracket expression is a list of characters enclosed in
&quot;[]&quot;. It nor- mally matches any single character
from the list (but see below). If the list begins with
&rsquo;^&rsquo;, it matches any single character (but see
below) not from the rest of the list. If two characters in
the list are separated by &rsquo;-&rsquo;, this is shorthand
for the full range of charac- ters between those two
(inclusive) in the collating sequence, for exam- ple,
&quot;[0-9]&quot; in ASCII matches any decimal digit. It is
illegal(!) for two ranges to share an endpoint, for example,
&quot;a-c-e&quot;. Ranges are very
collating-sequence-dependent, and portable programs should
avoid rely- ing on them.</p>

<p>To include a literal &rsquo;]&rsquo; in the list, make
it the first character (fol- lowing a possible
&rsquo;^&rsquo;). To include a literal &rsquo;-&rsquo;, make
it the first or last character, or the second endpoint of a
range. To use a literal &rsquo;-&rsquo; as the first
endpoint of a range, enclose it in &quot;[.&quot; and
&quot;.]&quot; to make it a collating element (see below).
With the exception of these and some combinations using
&rsquo;[&rsquo; (see next paragraphs), all other spe- cial
characters, including &rsquo;&acute;, lose their special
significance within a bracket expression.</p>

<p>Within a bracket expression, a collating element (a
character, a multi- character sequence that collates as if
it were a single character, or a collating-sequence name for
either) enclosed in &quot;[.&quot; and &quot;.]&quot; stands
for the sequence of characters of that collating element.
The sequence is a single element of the bracket expressions
list. A bracket expression containing a multi-character
collating element can thus match more than one character,
for example, if the collating sequence includes a
&quot;ch&quot; collating element, then the RE
&quot;[[.ch.]]*c&quot; matches the first five characters of
&quot;chchcc&quot;.</p>

<p>Within a bracket expression, a collating element
enclosed in &quot;[=&quot; and &quot;=]&quot; is an
equivalence class, standing for the sequences of characters
of all collating elements equivalent to that one, including
itself. (If there are no other equivalent collating
elements, the treatment is as if the enclosing delimiters
were &quot;[.&quot; and &quot;.]&quot;.) For example, if o
and ^ are the members of an equivalence class, then
&quot;[[=o=]]&quot;, &quot;[[=^=]]&quot;, and
&quot;[o^]&quot; are all synonymous. An equivalence class
may not(!) be an endpoint of a range.</p>

<p>Within a bracket expression, the name of a character
class enclosed in &quot;[:&quot; and &quot;:]&quot; stands
for the list of all characters belonging to that class.
Standard character class names are:</p>

<p>alnum digit punct alpha graph space blank lower upper
cntrl print xdigit</p>

<p>These stand for the character classes defined in
wctype(3). A locale may provide others. A character class
may not be used as an endpoint of a range.</p>

<p>In the event that an RE could match more than one
substring of a given string, the RE matches the one starting
earliest in the string. If the RE could match more than one
substring starting at that point, it matches the longest.
Subexpressions also match the longest possible substrings,
subject to the constraint that the whole match be as long as
possible, with subexpressions starting earlier in the RE
taking pri- ority over ones starting later. Note that
higher-level subexpressions thus take priority over their
lower-level component subexpressions.</p>

<p>Match lengths are measured in characters, not collating
elements. A null string is considered longer than no match
at all. For example, &quot;bb*&quot; matches the three
middle characters of &quot;abbbc&quot;,
&quot;(wee|week)(knights|nights)&quot; matches all ten
characters of &quot;weeknights&quot;, when
&quot;(.*).*&quot; is matched against &quot;abc&quot; the
parenthesized subexpression matches all three characters,
and when &quot;(a*)*&quot; is matched against &quot;bc&quot;
both the whole RE and the parenthesized subexpression match
the null string.</p>

<p>If case-independent matching is specified, the effect is
much as if all case distinctions had vanished from the
alphabet. When an alphabetic that exists in multiple cases
appears as an ordinary character outside a bracket
expression, it is effectively transformed into a bracket
expression containing both cases, for example,
&rsquo;x&rsquo; becomes &quot;[xX]&quot;. When it appears
inside a bracket expression, all case counterparts of it are
added to the bracket expression, so that, for example,
&quot;[x]&quot; becomes &quot;[xX]&quot; and
&quot;[^x]&quot; becomes &quot;[^xX]&quot;.</p>

<p>No particular limit is imposed on the length of REs(!).
Programs intended to be portable should not employ REs
longer than 256 bytes, as an implementation can refuse to
accept such REs and remain POSIX-com- pliant.</p>

<p>Obsolete (&quot;basic&quot;) regular expressions differ
in several respects. &rsquo;|&rsquo;, &rsquo;+&rsquo;, and
&rsquo;?&rsquo; are ordinary characters and there is no
equivalent for their functionality. The delimiters for
bounds are &quot;{&quot; and &quot;}&quot;, with
&rsquo;{&rsquo; and &rsquo;}&rsquo; by themselves ordinary
characters. The parentheses for nested subexpressions are
&quot;(&quot; and &quot;)&quot;, with &rsquo;(&rsquo; and
&rsquo;)&rsquo; by them- selves ordinary characters.
&rsquo;^&rsquo; is an ordinary character except at the
beginning of the RE or(!) the beginning of a parenthesized
subexpres- sion, &rsquo;$&rsquo; is an ordinary character
except at the end of the RE or(!) the end of a parenthesized
subexpression, and &rsquo;*&rsquo; is an ordinary char-
acter if it appears at the beginning of the RE or the
beginning of a parenthesized subexpression (after a possible
leading &rsquo;^&rsquo;).</p>

<p>Finally, there is one new type of atom, a back
reference: &rsquo;&acute; followed by a non-zero decimal
digit d matches the same sequence of characters matched by
the dth parenthesized subexpression (numbering subexpres-
sions by the positions of their opening parentheses, left to
right), so that, for example, &quot;([bc])1&quot; matches
&quot;bb&quot; or &quot;cc&quot; but not &quot;bc&quot;.</p>

<p>BUGS Having two kinds of REs is a botch.</p>

<p>The current POSIX.2 spec says that &rsquo;)&rsquo; is an
ordinary character in the absence of an unmatched
&rsquo;(&rsquo;; this was an unintentional result of a
wording error, and change is likely. Avoid relying on
it.</p>

<p>Back references are a dreadful botch, posing major
problems for effi- cient implementations. They are also
somewhat vaguely defined (does &quot;a((b)*2)*d&quot; match
&quot;abbbd&quot;?). Avoid using them.</p>

<p>POSIX.2s specification of case-independent matching is
vague. The &quot;one case implies all cases&quot; definition
given above is current consen- sus among implementors as to
the right interpretation.</p>

<p>AUTHOR This page was taken from Henry Spencers regex
package.</p>

<p>SEE ALSO grep(1), regex(3)</p>

<p>POSIX.2, section 2.8 (Regular Expression Notation).</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>2009-01-12 REGEX(7)</p>
<hr>
</body>
</html>
