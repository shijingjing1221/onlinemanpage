<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLOPENTUT(1) Perl Programmers Reference Guide
PERLOPENTUT(1)</p>

<p>NAME perlopentut - tutorial on opening things in
Perl</p>

<p>DESCRIPTION Perl has two simple, built-in ways to open
files: the shell way for convenience, and the C way for
precision. The shell way also has 2- and 3-argument forms,
which have different semantics for handling the filename.
The choice is yours.</p>

<p>Open a la shell Perl s &quot;open&quot; function was
designed to mimic the way command-line redirection in the
shell works. Here are some basic examples from the
shell:</p>

<p>$ myprogram file1 file2 file3 $ myprogram &lt; inputfile
$ myprogram &gt; outputfile $ myprogram &gt;&gt; outputfile
$ myprogram | otherprogram $ otherprogram | myprogram</p>

<p>And here are some more advanced examples:</p>

<p>$ otherprogram | myprogram f1 - f2 $ otherprogram
2&gt;&amp;1 | myprogram - $ myprogram &lt;&amp;3 $ myprogram
&gt;&amp;4</p>

<p>Programmers accustomed to constructs like those above
can take comfort in learning that Perl directly supports
these familiar constructs using virtually the same syntax as
the shell.</p>

<p>Simple Opens The &quot;open&quot; function takes two
arguments: the first is a filehandle, and the second is a
single string comprising both what to open and how to open
it. &quot;open&quot; returns true when it works, and when it
fails, returns a false value and sets the special variable
$! to reflect the system error. If the filehandle was
previously opened, it will be implicitly closed first.</p>

<p>For example:</p>

<p>open(INFO, &quot;datafile&quot;) ||
die(&quot;can&rsquo;t open datafile: $!&quot;); open(INFO,
&quot;&lt; datafile&quot;) || die(&quot;can&rsquo;t open
datafile: $!&quot;); open(RESULTS,&quot;&gt; runstats&quot;)
|| die(&quot;can&rsquo;t open runstats: $!&quot;); open(LOG,
&quot;&gt;&gt; logfile &quot;) || die(&quot;can&rsquo;t open
logfile: $!&quot;);</p>

<p>If you prefer the low-punctuation version, you could
write that this way:</p>

<p>open INFO, &quot;&lt; datafile&quot; or die
&quot;can&rsquo;t open datafile: $!&quot;; open
RESULTS,&quot;&gt; runstats&quot; or die &quot;can&rsquo;t
open runstats: $!&quot;; open LOG, &quot;&gt;&gt; logfile
&quot; or die &quot;can&rsquo;t open logfile: $!&quot;;</p>

<p>A few things to notice. First, the leading less-than is
optional. If omitted, Perl assumes that you want to open the
file for reading.</p>

<p>Note also that the first example uses the &quot;||&quot;
logical operator, and the second uses &quot;or&quot;, which
has lower precedence. Using &quot;||&quot; in the latter
examples would effectively mean</p>

<p>open INFO, ( &quot;&lt; datafile&quot; || die
&quot;can&rsquo;t open datafile: $!&quot; );</p>

<p>which is definitely not what you want.</p>

<p>The other important thing to notice is that, just as in
the shell, any whitespace before or after the filename is
ignored. This is good, because you wouldnt want these to do
different things:</p>

<p>open INFO, &quot;&lt;datafile&quot; open INFO,
&quot;&lt; datafile&quot; open INFO, &quot;&lt;
datafile&quot;</p>

<p>Ignoring surrounding whitespace also helps for when you
read a filename in from a different file, and forget to trim
it before opening:</p>

<p>$filename = &lt;INFO&gt;; # oops, still there
open(EXTRA, &quot;&lt; $filename&quot;) || die
&quot;can&rsquo;t open $filename: $!&quot;;</p>

<p>This is not a bug, but a feature. Because
&quot;open&quot; mimics the shell in its style of using
redirection arrows to specify how to open the file, it also
does so with respect to extra whitespace around the filename
itself as well. For accessing files with naughty names, see
&quot;Dispelling the Dweomer&quot;.</p>

<p>There is also a 3-argument version of &quot;open&quot;,
which lets you put the special redirection characters into
their own argument:</p>

<p>open( INFO, &quot;&gt;&quot;, $datafile ) || die
&quot;Can&rsquo;t create $datafile: $!&quot;;</p>

<p>In this case, the filename to open is the actual string
in $datafile, so you don t have to worry about $datafile
containing characters that might influence the open mode, or
whitespace at the beginning of the filename that would be
absorbed in the 2-argument version. Also, any reduction of
unnecessary string interpolation is a good thing.</p>

<p>Indirect Filehandles &quot;open&quot;s first argument
can be a reference to a filehandle. As of perl 5.6.0, if the
argument is uninitialized, Perl will automatically create a
filehandle and put a reference to it in the first argument,
like so:</p>

<p>open( my $in, $infile ) or die &quot;Couldn&rsquo;t read
$infile: $!&quot;; while ( &lt;$in&gt; ) { # do something
with $_ } close $in;</p>

<p>Indirect filehandles make namespace management easier.
Since filehandles are global to the current package, two
subroutines trying to open &quot;INFILE&quot; will clash.
With two functions opening indirect filehandles like
&quot;my $infile&quot;, theres no clash and no need to worry
about future conflicts.</p>

<p>Another convenient behavior is that an indirect
filehandle automatically closes when it goes out of scope or
when you undefine it:</p>

<p>sub firstline { open( my $in, shift ) &amp;&amp; return
scalar &lt;$in&gt;; # no close() required }</p>

<p>Pipe Opens In C, when you want to open a file using the
standard I/O library, you use the &quot;fopen&quot;
function, but when opening a pipe, you use the
&quot;popen&quot; function. But in the shell, you just use a
different redirection character. Thats also the case for
Perl. The &quot;open&quot; call remains the same--just its
argument differs.</p>

<p>If the leading character is a pipe symbol,
&quot;open&quot; starts up a new command and opens a
write-only filehandle leading into that command. This lets
you write into that handle and have what you write show up
on that commands standard input. For example:</p>

<p>open(PRINTER, &quot;| lpr -Plp1&quot;) || die
&quot;can&rsquo;t run lpr: $!&quot;; print PRINTER
&quot;stuff0; close(PRINTER) || die &quot;can&rsquo;t close
lpr: $!&quot;;</p>

<p>If the trailing character is a pipe, you start up a new
command and open a read-only filehandle leading out of that
command. This lets whatever that command writes to its
standard output show up on your handle for reading. For
example:</p>

<p>open(NET, &quot;netstat -i -n |&quot;) || die
&quot;can&rsquo;t fork netstat: $!&quot;; while
(&lt;NET&gt;) { } # do something with input close(NET) ||
die &quot;can&rsquo;t close netstat: $!&quot;;</p>

<p>What happens if you try to open a pipe to or from a
non-existent command? If possible, Perl will detect the
failure and set $! as usual. But if the command contains
special shell characters, such as &quot;&gt;&quot; or
&quot;*&quot;, called metacharacters, Perl does not execute
the command directly. Instead, Perl runs the shell, which
then tries to run the command. This means that it s the
shell that gets the error indication. In such a case, the
&quot;open&quot; call will only indicate failure if Perl
cant even run the shell. See &quot;How can I capture STDERR
from an external command?&quot; in perlfaq8 to see how to
cope with this. Theres also an explanation in perlipc.</p>

<p>If you would like to open a bidirectional pipe, the
IPC::Open2 library will handle this for you. Check out
&quot;Bidirectional Communication with Another Process&quot;
in perlipc</p>

<p>perl-5.6.x introduced a version of piped open that
executes a process based on its command line arguments
without relying on the shell. (Similar to the
&quot;system(@LIST)&quot; notation.) This is safer and
faster than executing a single argument pipe-command, but
does not allow special shell constructs. (It is also not
supported on Microsoft Windows, Mac OS Classic or RISC
OS.)</p>

<p>Heres an example of &quot;open &rsquo;-|&rsquo;&quot;,
which prints a random Unix fortune cookie as uppercase:</p>

<p>my $collection = shift(@ARGV); open my $fortune,
&rsquo;-|&rsquo;, &rsquo;fortune&rsquo;, $collection or die
&quot;Could not find fortune - $!&quot;; while
(&lt;$fortune&gt;) { print uc($_); } close($fortune);</p>

<p>And this &quot;open &rsquo;|-&rsquo;&quot; pipes into
lpr:</p>

<p>open my $printer, &rsquo;|-&rsquo;, &rsquo;lpr&rsquo;,
&rsquo;-Plp1&rsquo; or die &quot;can&rsquo;t run lpr:
$!&quot;; print {$printer} &quot;stuff0; close($printer) or
die &quot;can&rsquo;t close lpr: $!&quot;;</p>

<p>The Minus File Again following the lead of the standard
shell utilities, Perls &quot;open&quot; function treats a
file whose name is a single minus, &quot;-&quot;, in a
special way. If you open minus for reading, it really means
to access the standard input. If you open minus for writing,
it really means to access the standard output.</p>

<p>If minus can be used as the default input or default
output, what happens if you open a pipe into or out of
minus? What s the default command it would run? The same
script as youre currently running! This is actually a
stealth &quot;fork&quot; hidden inside an &quot;open&quot;
call. See &quot;Safe Pipe Opens&quot; in perlipc for
details.</p>

<p>Mixing Reads and Writes It is possible to specify both
read and write access. All you do is add a &quot;+&quot;
symbol in front of the redirection. But as in the shell,
using a less-than on a file never creates a new file; it
only opens an existing one. On the other hand, using a
greater-than always clobbers (truncates to zero length) an
existing file, or creates a brand-new one if there isnt an
old one. Adding a &quot;+&quot; for read-write doesnt affect
whether it only works on existing files or always clobbers
existing ones.</p>

<p>open(WTMP, &quot;+&lt; /usr/adm/wtmp&quot;) || die
&quot;can&rsquo;t open /usr/adm/wtmp: $!&quot;;</p>

<p>open(SCREEN, &quot;+&gt; lkscreen&quot;) || die
&quot;can&rsquo;t open lkscreen: $!&quot;;</p>

<p>open(LOGFILE, &quot;+&gt;&gt; /var/log/applog&quot;) ||
die &quot;can&rsquo;t open /var/log/applog: $!&quot;;</p>

<p>The first one wont create a new file, and the second one
will always clobber an old one. The third one will create a
new file if necessary and not clobber an old one, and it
will allow you to read at any point in the file, but all
writes will always go to the end. In short, the first case
is substantially more common than the second and third
cases, which are almost always wrong. (If you know C, the
plus in Perls &quot;open&quot; is historically derived from
the one in C s fopen(3S), which it ultimately calls.)</p>

<p>In fact, when it comes to updating a file, unless youre
working on a binary file as in the WTMP case above, you
probably don t want to use this approach for updating.
Instead, Perls -i flag comes to the rescue. The following
command takes all the C, C++, or yacc source or header files
and changes all their foos to bars, leaving the old version
in the original filename with a &quot;.orig&quot; tacked on
the end:</p>

<p>o o g &rsquo; * . $ perl -i.orig -pe &rsquo;s/[ C c h y
]</p>

<p>This is a short cut for some renaming games that are
really the best way to update textfiles. See the second
question in perlfaq5 for more details.</p>

<p>Filters One of the most common uses for &quot;open&quot;
is one you never even notice. When you process the ARGV
filehandle using &quot;&lt;ARGV&gt;&quot;, Perl actually
does an implicit open on each file in @ARGV. Thus a program
called like this:</p>

<p>$ myprogram file1 file2 file3</p>

<p>can have all its files opened and processed one at a
time using a construct no more complex than:</p>

<p>while (&lt;&gt;) { # do something with $_ }</p>

<p>If @ARGV is empty when the loop first begins, Perl
pretends youve opened up minus, that is, the standard input.
In fact, $ARGV, the currently open file during
&quot;&lt;ARGV&gt;&quot; processing, is even set to
&quot;-&quot; in these circumstances.</p>

<p>You are welcome to pre-process your @ARGV before
starting the loop to make sure its to your liking. One
reason to do this might be to remove command options
beginning with a minus. While you can always roll the simple
ones by hand, the Getopts modules are good for this:</p>

<p>use Getopt::Std;</p>

<p># -v, -D, -o ARG, sets $opt_v, $opt_D, $opt_o
getopts(&quot;vDo:&quot;);</p>

<p># -v, -D, -o ARG, sets $args{v}, $args{D}, $args{o}
getopts(&quot;vDo:&quot;, args);</p>

<p>Or the standard Getopt::Long module to permit named
arguments:</p>

<p>use Getopt::Long; GetOptions( &quot;verbose&quot; =&gt;
erbose, # --verbose &quot;Debug&quot; =&gt; ebug, # --Debug
&quot;output=s&quot; =&gt; utput ); # --output=somestring or
--output somestring</p>

<p>Another reason for preprocessing arguments is to make an
empty argument list default to all files:</p>

<p>@ARGV = glob(&quot;*&quot;) unless @ARGV;</p>

<p>You could even filter out all but plain, text files.
This is a bit silent, of course, and you might prefer to
mention them on the way.</p>

<p>@ARGV = grep { -f &amp;&amp; -T } @ARGV;</p>

<p>If youre using the -n or -p command-line options, you
should put changes to @ARGV in a &quot;BEGIN{}&quot;
block.</p>

<p>Remember that a normal &quot;open&quot; has special
properties, in that it might call fopen(3S) or it might
called popen(3S), depending on what its argument looks like;
thats why its sometimes called &quot;magic open&quot;. Heres
an example:</p>

<p>$pwdinfo = &lsquo;domainname&lsquo; =~ /^(&not;ne)?$/ ?
&rsquo;&lt; /etc/passwd&rsquo; : &rsquo;ypcat passwd
|&rsquo;;</p>

<p>open(PWD, $pwdinfo) or die &quot;can&rsquo;t open
$pwdinfo: $!&quot;;</p>

<p>This sort of thing also comes into play in filter
processing. Because &quot;&lt;ARGV&gt;&quot; processing
employs the normal, shell-style Perl &quot;open&quot;, it
respects all the special things weve already seen:</p>

<p>$ myprogram f1 &quot;cmd1|&quot; - f2 &quot;cmd2|&quot;
f3 &lt; tmpfile</p>

<p>That program will read from the file f1, the process
cmd1, standard input (tmpfile in this case), the f2 file,
the cmd2 command, and finally the f3 file.</p>

<p>Yes, this also means that if you have files named
&quot;-&quot; (and so on) in your directory, they wont be
processed as literal files by &quot;open&quot;. Youll need
to pass them as &quot;./-&quot;, much as you would for the
rm program, or you could use &quot;sysopen&quot; as
described below.</p>

<p>One of the more interesting applications is to change
files of a certain name into pipes. For example, to
autoprocess gzipped or compressed files by decompressing
them with gzip:</p>

<p>@ARGV = map { /.(gz|Z)$/ ? &quot;gzip -dc $_ |&quot; :
$_ } @ARGV;</p>

<p>Or, if you have the GET program installed from LWP, you
can fetch URLs before processing them:</p>

<p>@ARGV = map { m#^744</p>

<p>It s not for nothing that this is called magic
&quot;&lt;ARGV&gt;&quot;. Pretty nifty, eh?</p>

<p>Open a la C If you want the convenience of the shell,
then Perl s &quot;open&quot; is definitely the way to go. On
the other hand, if you want finer precision than Cs
simplistic fopen(3S) provides you should look to Perl s
&quot;sysopen&quot;, which is a direct hook into the open(2)
system call. That does mean its a bit more involved, but
that s the price of precision.</p>

<p>&quot;sysopen&quot; takes 3 (or 4) arguments.</p>

<p>sysopen HANDLE, PATH, FLAGS, [MASK]</p>

<p>The HANDLE argument is a filehandle just as with
&quot;open&quot;. The PATH is a literal path, one that doesn
t pay attention to any greater-thans or less-thans or pipes
or minuses, nor ignore whitespace. If its there, its part of
the path. The FLAGS argument contains one or more values
derived from the Fcntl module that have been ord together
using the bitwise &quot;|&quot; operator. The final
argument, the MASK, is optional; if present, it is combined
with the users current umask for the creation mode of the
file. You should usually omit this.</p>

<p>Although the traditional values of read-only,
write-only, and read- write are 0, 1, and 2 respectively,
this is known not to hold true on some systems. Instead, it
s best to load in the appropriate constants first from the
Fcntl module, which supplies the following standard
flags:</p>

<p>O_RDONLY Read only O_WRONLY Write only O_RDWR Read and
write O_CREAT Create the file if it doesn&rsquo;t exist
O_EXCL Fail if the file already exists O_APPEND Append to
the file O_TRUNC Truncate the file O_NONBLOCK Non-blocking
access</p>

<p>Less common flags that are sometimes available on some
operating systems include &quot;O_BINARY&quot;,
&quot;O_TEXT&quot;, &quot;O_SHLOCK&quot;,
&quot;O_EXLOCK&quot;, &quot;O_DEFER&quot;,
&quot;O_SYNC&quot;, &quot;O_ASYNC&quot;,
&quot;O_DSYNC&quot;, &quot;O_RSYNC&quot;,
&quot;O_NOCTTY&quot;, &quot;O_NDELAY&quot; and
&quot;O_LARGEFILE&quot;. Consult your open(2) manpage or its
local equivalent for details. (Note: starting from Perl
release 5.6 the &quot;O_LARGEFILE&quot; flag, if available,
is automatically added to the sysopen() flags because large
files are the default.)</p>

<p>Here s how to use &quot;sysopen&quot; to emulate the
simple &quot;open&quot; calls we had before. Well omit the
&quot;|| die $!&quot; checks for clarity, but make sure you
always check the return values in real code. These arent
quite the same, since &quot;open&quot; will trim leading and
trailing whitespace, but youll get the idea.</p>

<p>To open a file for reading:</p>

<p>open(FH, &quot;&lt; $path&quot;); sysopen(FH, $path,
O_RDONLY);</p>

<p>To open a file for writing, creating a new file if
needed or else truncating an old file:</p>

<p>open(FH, &quot;&gt; $path&quot;); sysopen(FH, $path,
O_WRONLY | O_TRUNC | O_CREAT);</p>

<p>To open a file for appending, creating one if
necessary:</p>

<p>open(FH, &quot;&gt;&gt; $path&quot;); sysopen(FH, $path,
O_WRONLY | O_APPEND | O_CREAT);</p>

<p>To open a file for update, where the file must already
exist:</p>

<p>open(FH, &quot;+&lt; $path&quot;); sysopen(FH, $path,
O_RDWR);</p>

<p>And here are things you can do with &quot;sysopen&quot;
that you cannot do with a regular &quot;open&quot;. As youll
see, it s just a matter of controlling the flags in the
third argument.</p>

<p>To open a file for writing, creating a new file which
must not previously exist:</p>

<p>sysopen(FH, $path, O_WRONLY | O_EXCL | O_CREAT);</p>

<p>To open a file for appending, where that file must
already exist:</p>

<p>sysopen(FH, $path, O_WRONLY | O_APPEND);</p>

<p>To open a file for update, creating a new file if
necessary:</p>

<p>sysopen(FH, $path, O_RDWR | O_CREAT);</p>

<p>To open a file for update, where that file must not
already exist:</p>

<p>sysopen(FH, $path, O_RDWR | O_EXCL | O_CREAT);</p>

<p>To open a file without blocking, creating one if
necessary:</p>

<p>sysopen(FH, $path, O_WRONLY | O_NONBLOCK | O_CREAT);</p>

<p>Permissions a la mode If you omit the MASK argument to
&quot;sysopen&quot;, Perl uses the octal value 0666. The
normal MASK to use for executables and directories should be
0777, and for anything else, 0666.</p>

<p>Why so permissive? Well, it isnt really. The MASK will
be modified by your process s current &quot;umask&quot;. A
umask is a number representing disabled permissions bits;
that is, bits that will not be turned on in the created
files permissions field.</p>

<p>For example, if your &quot;umask&quot; were 027, then
the 020 part would disable the group from writing, and the
007 part would disable others from reading, writing, or
executing. Under these conditions, passing
&quot;sysopen&quot; 0666 would create a file with mode 0640,
since &quot;0666 &amp; ~027&quot; is 0640.</p>

<p>You should seldom use the MASK argument to
&quot;sysopen()&quot;. That takes away the users freedom to
choose what permission new files will have. Denying choice
is almost always a bad thing. One exception would be for
cases where sensitive or private data is being stored, such
as with mail folders, cookie files, and internal temporary
files.</p>

<p>Obscure Open Tricks Re-Opening Files (dups) Sometimes
you already have a filehandle open, and want to make another
handle thats a duplicate of the first one. In the shell, we
place an ampersand in front of a file descriptor number when
doing redirections. For example, &quot;2&gt;&amp;1&quot;
makes descriptor 2 (thats STDERR in Perl) be redirected into
descriptor 1 (which is usually Perl s STDOUT). The same is
essentially true in Perl: a filename that begins with an
ampersand is treated instead as a file descriptor if a
number, or as a filehandle if a string.</p>

<p>open(SAVEOUT, &quot;&gt;&amp;SAVEERR&quot;) || die
&quot;couldn&rsquo;t dup SAVEERR: $!&quot;; open(MHCONTEXT,
&quot;&lt;&amp;4&quot;) || die &quot;couldn&rsquo;t dup fd4:
$!&quot;;</p>

<p>That means that if a function is expecting a filename,
but you dont want to give it a filename because you already
have the file open, you can just pass the filehandle with a
leading ampersand. It s best to use a fully qualified handle
though, just in case the function happens to be in a
different package:</p>

<p>somefunction(&quot;&amp;main::LOGFILE&quot;);</p>

<p>This way if somefunction() is planning on opening its
argument, it can just use the already opened handle. This
differs from passing a handle, because with a handle, you
dont open the file. Here you have something you can pass to
open.</p>

<p>If you have one of those tricky, newfangled I/O objects
that the C++ folks are raving about, then this doesnt work
because those arent a proper filehandle in the native Perl
sense. Youll have to use fileno() to pull out the proper
descriptor number, assuming you can:</p>

<p>use IO::Socket; $handle =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); $fd =
$handle-&gt;fileno; somefunction(&quot;&amp;$fd&quot;); #
not an indirect function call</p>

<p>It can be easier (and certainly will be faster) just to
use real filehandles though:</p>

<p>use IO::Socket; local *REMOTE =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); die
&quot;can&rsquo;t connect&quot; unless
defined(fileno(REMOTE));
somefunction(&quot;&amp;main::REMOTE&quot;);</p>

<p>If the filehandle or descriptor number is preceded not
just with a simple &quot;&amp;&quot; but rather with a
&quot;&amp;=&quot; combination, then Perl will not create a
completely new descriptor opened to the same place using the
dup(2) system call. Instead, it will just make something of
an alias to the existing one using the fdopen(3S) library
call. This is slightly more parsimonious of systems
resources, although this is less a concern these days. Heres
an example of that:</p>

<p>$fd = $ENV{&quot;MHCONTEXTFD&quot;}; open(MHCONTEXT,
&quot;&lt;&amp;=$fd&quot;) or die &quot;couldn&rsquo;t
fdopen $fd: $!&quot;;</p>

<p>If youre using magic &quot;&lt;ARGV&gt;&quot;, you could
even pass in as a command line argument in @ARGV something
like &quot;&lt;&amp;=$MHCONTEXTFD&quot;, but weve never seen
anyone actually do this.</p>

<p>Dispelling the Dweomer Perl is more of a DWIMmer
language than something like Java--where DWIM is an acronym
for &quot;do what I mean&quot;. But this principle sometimes
leads to more hidden magic than one knows what to do with.
In this way, Perl is also filled with dweomer, an obscure
word meaning an enchantment. Sometimes, Perls DWIMmer is
just too much like dweomer for comfort.</p>

<p>If magic &quot;open&quot; is a bit too magical for you,
you dont have to turn to &quot;sysopen&quot;. To open a file
with arbitrary weird characters in it, its necessary to
protect any leading and trailing whitespace. Leading
whitespace is protected by inserting a &quot;./&quot; in
front of a filename that starts with whitespace. Trailing
whitespace is protected by appending an ASCII NUL byte
(&quot; &quot;) at the end of the string.</p>

<p>$file =~ s#^(#./$1#; open(FH, &quot;&lt; $file &quot;)
|| die &quot;can&rsquo;t open $file: $!&quot;;</p>

<p>This assumes, of course, that your system considers dot
the current working directory, slash the directory
separator, and disallows ASCII NULs within a valid filename.
Most systems follow these conventions, including all POSIX
systems as well as proprietary Microsoft systems. The only
vaguely popular system that doesnt work this way is the
&quot;Classic&quot; Macintosh system, which uses a colon
where the rest of us use a slash. Maybe &quot;sysopen&quot;
isnt such a bad idea after all.</p>

<p>If you want to use &quot;&lt;ARGV&gt;&quot; processing
in a totally boring and non- magical way, you could do this
first:</p>

<p># &quot;Sam sat on the ground and put his head in his
hands. # &rsquo;I wish I had never come here, and I
don&rsquo;t want to see # no more magic,&rsquo; he said, and
fell silent.&quot; for (@ARGV) { s#^([^./])#./$1#; $_ .=
&quot; &quot;; } while (&lt;&gt;) { # now process $_ }</p>

<p>But be warned that users will not appreciate being
unable to use &quot;-&quot; to mean standard input, per the
standard convention.</p>

<p>Paths as Opens You ve probably noticed how Perl s
&quot;warn&quot; and &quot;die&quot; functions can produce
messages like:</p>

<p>Some warning at scriptname line 29, &lt;FH&gt; line
7.</p>

<p>Thats because you opened a filehandle FH, and had read
in seven records from it. But what was the name of the file,
rather than the handle?</p>

<p>If you arent running with &quot;strict refs&quot;, or if
you ve turned them off temporarily, then all you have to do
is this:</p>

<p>open($path, &quot;&lt; $path&quot;) || die
&quot;can&rsquo;t open $path: $!&quot;; while
(&lt;$path&gt;) { # whatever }</p>

<p>Since youre using the pathname of the file as its
handle, youll get warnings more like</p>

<p>Some warning at scriptname line 29, &lt;/etc/motd&gt;
line 7.</p>

<p>Single Argument Open Remember how we said that Perls
open took two arguments? That was a passive prevarication.
You see, it can also take just one argument. If and only if
the variable is a global variable, not a lexical, you can
pass &quot;open&quot; just one argument, the filehandle, and
it will get the path from the global scalar variable of the
same name.</p>

<p>$FILE = &quot;/etc/motd&quot;; open FILE or die
&quot;can&rsquo;t open $FILE: $!&quot;; while (&lt;FILE&gt;)
{ # whatever }</p>

<p>Why is this here? Someone has to cater to the hysterical
porpoises. Its something thats been in Perl since the very
beginning, if not before.</p>

<p>Playing with STDIN and STDOUT One clever move with
STDOUT is to explicitly close it when youre done with the
program.</p>

<p>END { close(STDOUT) || die &quot;can&rsquo;t close
stdout: $!&quot; }</p>

<p>If you dont do this, and your program fills up the disk
partition due to a command line redirection, it wont report
the error exit with a failure status.</p>

<p>You dont have to accept the STDIN and STDOUT you were
given. You are welcome to reopen them if youd like.</p>

<p>open(STDIN, &quot;&lt; datafile&quot;) || die
&quot;can&rsquo;t open datafile: $!&quot;;</p>

<p>open(STDOUT, &quot;&gt; output&quot;) || die
&quot;can&rsquo;t open output: $!&quot;;</p>

<p>And then these can be accessed directly or passed on to
subprocesses. This makes it look as though the program were
initially invoked with those redirections from the command
line.</p>

<p>It s probably more interesting to connect these to
pipes. For example:</p>

<p>$pager = $ENV{PAGER} || &quot;(less || more)&quot;;
open(STDOUT, &quot;| $pager&quot;) || die &quot;can&rsquo;t
fork a pager: $!&quot;;</p>

<p>This makes it appear as though your program were called
with its stdout already piped into your pager. You can also
use this kind of thing in conjunction with an implicit fork
to yourself. You might do this if you would rather handle
the post processing in your own program, just in a different
process:</p>

<p>head(100); while (&lt;&gt;) { print; }</p>

<p>sub head { my $lines = shift || 20; return if $pid =
open(STDOUT, &quot;|-&quot;); # return if parent die
&quot;cannot fork: $!&quot; unless defined $pid; while
(&lt;STDIN&gt;) { last if --$lines &lt; 0; print; } exit;
}</p>

<p>This technique can be applied to repeatedly push as many
filters on your output stream as you wish.</p>

<p>Other I/O Issues These topics arent really arguments
related to &quot;open&quot; or &quot;sysopen&quot;, but they
do affect what you do with your open files.</p>

<p>Opening Non-File Files When is a file not a file? Well,
you could say when it exists but isnt a plain file. Well
check whether it s a symbolic link first, just in case.</p>

<p>if (-l $file || ! -f _) { print &quot;$file is not a
plain file0; }</p>

<p>What other kinds of files are there than, well, files?
Directories, symbolic links, named pipes, Unix-domain
sockets, and block and character devices. Those are all
files, too--just not plain files. This isnt the same issue
as being a text file. Not all text files are plain files.
Not all plain files are text files. Thats why there are
separate &quot;-f&quot; and &quot;-T&quot; file tests.</p>

<p>To open a directory, you should use the
&quot;opendir&quot; function, then process it with
&quot;readdir&quot;, carefully restoring the directory name
if necessary:</p>

<p>opendir(DIR, $dirname) or die &quot;can&rsquo;t opendir
$dirname: $!&quot;; while (defined($file = readdir(DIR))) {
# do something with &quot;$dirname/$file&quot; }
closedir(DIR);</p>

<p>If you want to process directories recursively, its
better to use the File::Find module. For example, this
prints out all files recursively and adds a slash to their
names if the file is a directory.</p>

<p>@ARGV = qw(.) unless @ARGV; use File::Find; find sub {
print $File::Find::name, -d &amp;&amp; &rsquo;/&rsquo;,
&quot;0 }, @ARGV;</p>

<p>This finds all bogus symbolic links beneath a particular
directory:</p>

<p>find sub { print &quot;$File::Find::name0 if -l
&amp;&amp; !-e }, $dir;</p>

<p>As you see, with symbolic links, you can just pretend
that it is what it points to. Or, if you want to know what
it points to, then &quot;readlink&quot; is called for:</p>

<p>if (-l $file) { if (defined($whither = readlink($file)))
{ print &quot;$file points to $whither0; } else { print
&quot;$file points nowhere: $!0; } }</p>

<p>Opening Named Pipes Named pipes are a different matter.
You pretend theyre regular files, but their opens will
normally block until there is both a reader and a writer.
You can read more about them in &quot;Named Pipes&quot; in
perlipc. Unix-domain sockets are rather different beasts as
well; theyre described in &quot;Unix-Domain TCP Clients and
Servers&quot; in perlipc.</p>

<p>When it comes to opening devices, it can be easy and it
can be tricky. We ll assume that if youre opening up a block
device, you know what youre doing. The character devices are
more interesting. These are typically used for modems, mice,
and some kinds of printers. This is described in &quot;How
do I read and write the serial port?&quot; in perlfaq8 Its
often enough to open them carefully:</p>

<p>sysopen(TTYIN, &quot;/dev/ttyS1&quot;, O_RDWR | O_NDELAY
| O_NOCTTY) # (O_NOCTTY no longer needed on POSIX systems)
or die &quot;can&rsquo;t open /dev/ttyS1: $!&quot;;
open(TTYOUT, &quot;+&gt;&amp;TTYIN&quot;) or die
&quot;can&rsquo;t dup TTYIN: $!&quot;;</p>

<p>$ofh = select(TTYOUT); $| = 1; select($ofh);</p>

<p>print TTYOUT &quot;+++at 15&quot;; $answer =
&lt;TTYIN&gt;;</p>

<p>With descriptors that you havent opened using
&quot;sysopen&quot;, such as sockets, you can set them to be
non-blocking using &quot;fcntl&quot;:</p>

<p>use Fcntl; my $old_flags = fcntl($handle, F_GETFL, 0) or
die &quot;can&rsquo;t get flags: $!&quot;; fcntl($handle,
F_SETFL, $old_flags | O_NONBLOCK) or die &quot;can&rsquo;t
set non blocking: $!&quot;;</p>

<p>Rather than losing yourself in a morass of twisting,
turning &quot;ioctl&quot;s, all dissimilar, if youre going
to manipulate ttys, it s best to make calls out to the
stty(1) program if you have it, or else use the portable
POSIX interface. To figure this all out, you ll need to read
the termios(3) manpage, which describes the POSIX interface
to tty devices, and then POSIX, which describes Perl s
interface to POSIX. There are also some high-level modules
on CPAN that can help you with these games. Check out
Term::ReadKey and Term::ReadLine.</p>

<p>Opening Sockets What else can you open? To open a
connection using sockets, you wont use one of Perl s two
open functions. See &quot;Sockets: Client/Server
Communication&quot; in perlipc for that. Heres an example.
Once you have it, you can use FH as a bidirectional
filehandle.</p>

<p>use IO::Socket; local *FH =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);</p>

<p>For opening up a URL, the LWP modules from CPAN are just
what the doctor ordered. Theres no filehandle interface, but
its still easy to get the contents of a document:</p>

<p>use LWP::Simple; $doc =
get(&rsquo;http://www.linpro.no/lwp/&rsquo;);</p>

<p>Binary Files On certain legacy systems with what could
charitably be called terminally convoluted (some would say
broken) I/O models, a file isnt a file--at least, not with
respect to the C standard I/O library. On these old systems
whose libraries (but not kernels) distinguish between text
and binary streams, to get files to behave properly youll
have to bend over backwards to avoid nasty problems. On such
infelicitous systems, sockets and pipes are already opened
in binary mode, and there is currently no way to turn that
off. With files, you have more options.</p>

<p>Another option is to use the &quot;binmode&quot;
function on the appropriate handles before doing regular I/O
on them:</p>

<p>binmode(STDIN); binmode(STDOUT); while (&lt;STDIN&gt;) {
print }</p>

<p>Passing &quot;sysopen&quot; a non-standard flag option
will also open the file in binary mode on those systems that
support it. This is the equivalent of opening the file
normally, then calling &quot;binmode&quot; on the
handle.</p>

<p>sysopen(BINDAT, &quot;records.data&quot;, O_RDWR |
O_BINARY) || die &quot;can&rsquo;t open records.data:
$!&quot;;</p>

<p>Now you can use &quot;read&quot; and &quot;print&quot;
on that handle without worrying about the non-standard
system I/O library breaking your data. Its not a pretty
picture, but then, legacy systems seldom are. CP/M will be
with us until the end of days, and after.</p>

<p>On systems with exotic I/O systems, it turns out that,
astonishingly enough, even unbuffered I/O using
&quot;sysread&quot; and &quot;syswrite&quot; might do sneaky
data mutilation behind your back.</p>

<p>while (sysread(WHENCE, $buf, 1024)) { syswrite(WHITHER,
$buf, length($buf)); }</p>

<p>Depending on the vicissitudes of your runtime system,
even these calls may need &quot;binmode&quot; or
&quot;O_BINARY&quot; first. Systems known to be free of such
difficulties include Unix, the Mac OS, Plan 9, and
Inferno.</p>

<p>File Locking In a multitasking environment, you may need
to be careful not to collide with other processes who want
to do I/O on the same files as you are working on. Youll
often need shared or exclusive locks on files for reading
and writing respectively. You might just pretend that only
exclusive locks exist.</p>

<p>Never use the existence of a file &quot;-e $file&quot;
as a locking indication, because there is a race condition
between the test for the existence of the file and its
creation. It s possible for another process to create a file
in the slice of time between your existence check and your
attempt to create the file. Atomicity is critical.</p>

<p>Perls most portable locking interface is via the
&quot;flock&quot; function, whose simplicity is emulated on
systems that dont directly support it such as SysV or
Windows. The underlying semantics may affect how it all
works, so you should learn how &quot;flock&quot; is
implemented on your systems port of Perl.</p>

<p>File locking does not lock out another process that
would like to do I/O. A file lock only locks out others
trying to get a lock, not processes trying to do I/O.
Because locks are advisory, if one process uses locking and
another doesnt, all bets are off.</p>

<p>By default, the &quot;flock&quot; call will block until
a lock is granted. A request for a shared lock will be
granted as soon as there is no exclusive locker. A request
for an exclusive lock will be granted as soon as there is no
locker of any kind. Locks are on file descriptors, not file
names. You cant lock a file until you open it, and you cant
hold on to a lock once the file has been closed.</p>

<p>Heres how to get a blocking shared lock on a file,
typically used for reading:</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); open(FH,
&quot;&lt; filename&quot;) or die &quot;can&rsquo;t open
filename: $!&quot;; flock(FH, LOCK_SH) or die
&quot;can&rsquo;t lock filename: $!&quot;; # now read from
FH</p>

<p>You can get a non-blocking lock by using
&quot;LOCK_NB&quot;.</p>

<p>flock(FH, LOCK_SH | LOCK_NB) or die &quot;can&rsquo;t
lock filename: $!&quot;;</p>

<p>This can be useful for producing more user-friendly
behaviour by warning if youre going to be blocking:</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); open(FH,
&quot;&lt; filename&quot;) or die &quot;can&rsquo;t open
filename: $!&quot;; unless (flock(FH, LOCK_SH | LOCK_NB)) {
$| = 1; print &quot;Waiting for lock...&quot;; flock(FH,
LOCK_SH) or die &quot;can&rsquo;t lock filename: $!&quot;;
print &quot;got it.0 } # now read from FH</p>

<p>To get an exclusive lock, typically used for writing,
you have to be careful. We &quot;sysopen&quot; the file so
it can be locked before it gets emptied. You can get a
nonblocking version using &quot;LOCK_EX | LOCK_NB&quot;.</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); sysopen(FH,
&quot;filename&quot;, O_WRONLY | O_CREAT) or die
&quot;can&rsquo;t open filename: $!&quot;; flock(FH,
LOCK_EX) or die &quot;can&rsquo;t lock filename: $!&quot;;
truncate(FH, 0) or die &quot;can&rsquo;t truncate filename:
$!&quot;; # now write to FH</p>

<p>Finally, due to the uncounted millions who cannot be
dissuaded from wasting cycles on useless vanity devices
called hit counters, heres how to increment a number in a
file safely:</p>

<p>use Fcntl qw(:DEFAULT :flock);</p>

<p>sysopen(FH, &quot;numfile&quot;, O_RDWR | O_CREAT) or
die &quot;can&rsquo;t open numfile: $!&quot;; # autoflush FH
$ofh = select(FH); $| = 1; select ($ofh); flock(FH, LOCK_EX)
or die &quot;can&rsquo;t write-lock numfile: $!&quot;;</p>

<p>$num = &lt;FH&gt; || 0; seek(FH, 0, 0) or die
&quot;can&rsquo;t rewind numfile : $!&quot;; print FH
$num+1, &quot;0 or die &quot;can&rsquo;t write numfile:
$!&quot;;</p>

<p>truncate(FH, tell(FH)) or die &quot;can&rsquo;t truncate
numfile: $!&quot;; close(FH) or die &quot;can&rsquo;t close
numfile: $!&quot;;</p>

<p>IO Layers In Perl 5.8.0 a new I/O framework called
&quot;PerlIO&quot; was introduced. This is a new
&quot;plumbing&quot; for all the I/O happening in Perl; for
the most part everything will work just as it did, but
PerlIO also brought in some new features such as the ability
to think of I/O as &quot;layers&quot;. One I/O layer may in
addition to just moving the data also do transformations on
the data. Such transformations may include compression and
decompression, encryption and decryption, and transforming
between various character encodings.</p>

<p>Full discussion about the features of PerlIO is out of
scope for this tutorial, but here is how to recognize the
layers being used:</p>

<p>&middot; The three-(or more)-argument form of
&quot;open&quot; is being used and the second argument
contains something else in addition to the usual
&rsquo;&lt;&rsquo;, &rsquo;&gt;&rsquo;,
&rsquo;&gt;&gt;&rsquo;, &rsquo;|&rsquo; and their variants,
for example:</p>

<p>open(my $fh, &quot;&lt;:crlf&quot;, $fn);</p>

<p>&middot; The two-argument form of &quot;binmode&quot; is
being used, for example</p>

<p>binmode($fh, &quot;:encoding(utf16)&quot;);</p>

<p>For more detailed discussion about PerlIO see PerlIO;
for more detailed discussion about Unicode and I/O see
perluniintro.</p>

<p>SEE ALSO The &quot;open&quot; and &quot;sysopen&quot;
functions in perlfunc(1); the system open(2), dup(2),
fopen(3), and fdopen(3) manpages; the POSIX
documentation.</p>

<p>AUTHOR and COPYRIGHT Copyright 1998 Tom
Christiansen.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
these files are hereby placed into the public domain. You
are permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>HISTORY First release: Sat Jan 9 08:09:11 MST 1999</p>

<p>perl v5.10.1 2009-02-12 PERLOPENTUT(1)</p>
<hr>
</body>
</html>
