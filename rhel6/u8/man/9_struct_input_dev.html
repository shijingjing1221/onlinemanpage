<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:36:36 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT INPUT_DEV(9) Input Subsystem STRUCT
INPUT_DEV(9)</p>

<p>NAME struct_input_dev - represents an input device</p>

<p>SYNOPSIS struct input_dev { const char * name; const
char * phys; const char * uniq; struct input_id id; unsigned
long evbit[BITS_TO_LONGS(EV_CNT)]; unsigned long
keybit[BITS_TO_LONGS(KEY_CNT)]; unsigned long
relbit[BITS_TO_LONGS(REL_CNT)]; unsigned long
absbit[BITS_TO_LONGS(ABS_CNT)]; unsigned long
mscbit[BITS_TO_LONGS(MSC_CNT)]; unsigned long
ledbit[BITS_TO_LONGS(LED_CNT)]; unsigned long
sndbit[BITS_TO_LONGS(SND_CNT)]; unsigned long
ffbit[BITS_TO_LONGS(FF_CNT)]; unsigned long
swbit[BITS_TO_LONGS(SW_CNT)]; unsigned int keycodemax;
unsigned int keycodesize; void * keycode; int (* setkeycode)
(struct input_dev *dev, int scancode, int keycode); int (*
getkeycode) (struct input_dev *dev, int scancode, int
*keycode); struct ff_device * ff; unsigned int repeat_key;
struct timer_list timer; int sync; int abs[ABS_MAX + 1]; int
rep[REP_MAX + 1]; unsigned long key[BITS_TO_LONGS(KEY_CNT)];
unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long
snd[BITS_TO_LONGS(SND_CNT)]; unsigned long
sw[BITS_TO_LONGS(SW_CNT)]; int absmax[ABS_MAX + 1]; int
absmin[ABS_MAX + 1]; int absfuzz[ABS_MAX + 1]; int
absflat[ABS_MAX + 1]; int (* open) (struct input_dev *dev);
void (* close) (struct input_dev *dev); int (* flush)
(struct input_dev *dev, struct file *file); int (* event)
(struct input_dev *dev, unsigned int type, unsigned int
code, int value); struct input_handle * grab; spinlock_t
event_lock; struct mutex mutex; unsigned int users; bool
going_away; struct device dev; struct list_head h_list;
struct list_head node; #ifndef __GENKSYMS__ unsigned long
propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned int
hint_events_per_packet; struct input_mt * mt; #endif };</p>

<p>MEMBERS name name of the device</p>

<p>phys physical path to the device in the system
hierarchy</p>

<p>uniq unique identification code for the device (if
device has it)</p>

<p>id id of the device (struct input_id)</p>

<p>evbit[BITS_TO_LONGS(EV_CNT)] bitmap of types of events
supported by the device (EV_KEY, EV_REL, etc.)</p>

<p>keybit[BITS_TO_LONGS(KEY_CNT)] bitmap of keys/buttons
this device has</p>

<p>relbit[BITS_TO_LONGS(REL_CNT)] bitmap of relative axes
for the device</p>

<p>absbit[BITS_TO_LONGS(ABS_CNT)] bitmap of absolute axes
for the device</p>

<p>mscbit[BITS_TO_LONGS(MSC_CNT)] bitmap of miscellaneous
events supported by the device</p>

<p>ledbit[BITS_TO_LONGS(LED_CNT)] bitmap of leds present on
the device</p>

<p>sndbit[BITS_TO_LONGS(SND_CNT)] bitmap of sound effects
supported by the device</p>

<p>ffbit[BITS_TO_LONGS(FF_CNT)] bitmap of force feedback
effects supported by the device</p>

<p>swbit[BITS_TO_LONGS(SW_CNT)] bitmap of switches present
on the device</p>

<p>keycodemax size of keycode table</p>

<p>keycodesize size of elements in keycode table</p>

<p>keycode map of scancodes to keycodes for this device</p>

<p>setkeycode optional method to alter current keymap, used
to implement sparse keymaps. If not supplied default
mechanism will be used</p>

<p>getkeycode optional method to retrieve current keymap.
If not supplied default mechanism will be used</p>

<p>ff force feedback structure associated with the device
if device supports force feedback effects</p>

<p>repeat_key stores key code of the last key pressed; used
to implement software autorepeat</p>

<p>timer timer for software autorepeat</p>

<p>sync set to 1 when there were no new events since last
EV_SYNC</p>

<p>abs[ABS_MAX + 1] current values for reports from
absolute axes</p>

<p>rep[REP_MAX + 1] current values for autorepeat
parameters (delay, rate)</p>

<p>key[BITS_TO_LONGS(KEY_CNT)] reflects current state of
device&acute;s keys/buttons</p>

<p>led[BITS_TO_LONGS(LED_CNT)] reflects current state of
device&acute;s LEDs</p>

<p>snd[BITS_TO_LONGS(SND_CNT)] reflects current state of
sound effects</p>

<p>sw[BITS_TO_LONGS(SW_CNT)] reflects current state of
device&acute;s switches</p>

<p>absmax[ABS_MAX + 1] maximum values for events coming
from absolute axes</p>

<p>absmin[ABS_MAX + 1] minimum values for events coming
from absolute axes</p>

<p>absfuzz[ABS_MAX + 1] describes noisiness for axes</p>

<p>absflat[ABS_MAX + 1] size of the center flat position
(used by joydev)</p>

<p>open this method is called when the very first user
calls input_open_device. The driver must prepare the device
to start generating events (start polling thread, request an
IRQ, submit URB, etc.)</p>

<p>close this method is called when the very last user
calls input_close_device.</p>

<p>flush purges the device. Most commonly used to get rid
of force feedback effects loaded into the device when
disconnecting from it</p>

<p>event event handler for events sent _to_ the device,
like EV_LED or EV_SND. The device is expected to carry out
the requested action (turn on a LED, play sound, etc.) The
call is protected by event_lock and must not sleep</p>

<p>grab input handle that currently has the device grabbed
(via EVIOCGRAB ioctl). When a handle grabs a device it
becomes sole recipient for all input events coming from the
device</p>

<p>event_lock this spinlock is is taken when input core
receives and processes a new event for the device (in
input_event). Code that accesses and/or modifies parameters
of a device (such as keymap or absmin, absmax, absfuzz,
etc.) after device has been registered with input core must
take this lock.</p>

<p>mutex serializes calls to open, close and flush
methods</p>

<p>users stores number of users (input handlers) that
opened this device. It is used by input_open_device and
input_close_device to make sure that dev-&gt;open is only
called when the first user opens device and dev-&gt;close is
called when the very last user closes the device</p>

<p>going_away marks devices that are in a middle of
unregistering and causes input_open_device*() fail with
-ENODEV.</p>

<p>dev driver model&acute;s view of this device</p>

<p>h_list list of input handles associated with the device.
When accessing the list dev-&gt;mutex must be held</p>

<p>node used to place the device onto input_dev_list</p>

<p>propbit[BITS_TO_LONGS(INPUT_PROP_CNT)] bitmap of device
properties and quirks</p>

<p>hint_events_per_packet average number of events
generated by the device in a packet (between
EV_SYN/SYN_REPORT events). Used by event handlers to
estimate size of the buffer needed to hold events.</p>

<p>mt pointer to multitouch state</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016 STRUCT
INPUT_DEV(9)</p>
<hr>
</body>
</html>
