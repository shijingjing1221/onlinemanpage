<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:36:09 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STAPREF(1) STAPREF(1)</p>

<p>NAME stapref - systemtap language reference</p>

<p>SYNOPSIS stapref</p>

<p>DESCRIPTION The reference for the systemtap scripting
language.</p>

<p>LANGUAGE Keywords &middot; break &middot; continue
&middot; delete &middot; else &middot; exit &middot; foreach
&middot; for &middot; function &middot; global &middot; if
&middot; in &middot; next &middot; probe &middot; return
&middot; try/catch &middot; while</p>

<p>Data Types and Operators Integers &middot; var1 = 5
&middot; global var2 = 10</p>

<p>Strings &middot; var1 = &quot;string1&quot; &middot;
global var2 = &quot;string2&quot;</p>

<p>Associative Arrays &middot; global array1[] &middot;
global array2[SIZE] &middot; array[index] = 5</p>

<p>Context Variables &middot; $var &middot; $var$ (pretty
printed string form)</p>

<p>Binary numeric operators &middot; * / % + - &lt;&lt;
&gt;&gt; &amp; ^ | &amp;&amp; ||</p>

<p>Binary string operators &middot; . (string
concatenation)</p>

<p>Numeric assignment operators &middot; = += -= *= /= %=
&gt;&gt;= &lt;&lt;= &amp;= ^= |=</p>

<p>String assignment operators &middot; = .=</p>

<p>Unary numeric operators &middot; + - ! ~ ++ --</p>

<p>Numeric &amp; string comparison operators &middot; &lt;
&gt; &lt;= &gt;= == !=</p>

<p>Regular expression matching operators &middot; =~ !~</p>

<p>Ternary operator &middot; cond ? exp1 : exp2</p>

<p>Grouping operator &middot; ( expression )</p>

<p>Array operators &middot; array[index] (array read/write)
&middot; [index] in array</p>

<p>Aggregation operator &middot; var &lt;&lt;&lt; value</p>

<p>Statements Jump Statements &middot; continue &middot;
break &middot; next &middot; return expression &middot; try
statement catch (message)</p>

<p>Selection Statements &middot; if (expression) statement
&middot; else statement</p>

<p>Iteration Statements &middot; foreach (variable in
array) statement &middot; foreach ([var1,var2,...] in array)
statement &middot; for (expression; expression; expression)
statement &middot; while (expression) statement</p>

<p>Declaration Statements &middot; function name (variable
: type, ...) { statement } &middot; function name : type
(variable : type, ...) { statement } &middot; function name
: type (variable : type, ...) %{ c_statement %} &middot;
probe probepoint { statement } &middot; probe label =
probepoint { statement }</p>

<p>Lexical Structure Comments &middot; # ... comment
&middot; // ... comment &middot; /* ... comment ... */</p>

<p>Preprocessor &middot; %( expression %? true_tokens %:
false_tokens %) &middot; @define label (variable, ...) %{
statement %}</p>

<p>Builtin Functions Aggregation Builtin Functions &middot;
@avg (variable) &middot; @count (variable) &middot;
@hist_linear (variable, N, N, N) &middot; @hist_log
(variable) &middot; @max (variable) &middot; @min (variable)
&middot; @sum (variable)</p>

<p>Output Builtin Functions &middot; print (variable)
&middot; printf (format:string, variable, ...) where format
is of the form: %[flags][width][.precision][length]specifier
&middot; printd (delimiter:string, variable, ...) &middot;
printdln (delimiter:string, variable, ...) &middot; println
() &middot; sprint:string (variable) &middot; sprintf:string
(format:string, variable, ...)</p>

<p>Variable Access Builtin Functions &middot; @cast
(variable, &quot;type_name&quot;[, &quot;module&quot;])
&middot; @defined (variable)</p>

<p>Probepoints Some of the more commonly used probepoints
&middot; kernel.function(PATTERN)
kernel.function(PATTERN).call &middot;
kernel.function(PATTERN).return &middot; kernel.FUNCTION
(PATTERN).return.maxactive(VALUE) &middot; kernel.FUNCTION
(PATTERN).inline &middot; kernel.FUNCTION
(PATTERN).label(LPATTERN) &middot; module(MPATTERN).FUNCTION
(PATTERN) &middot; module(MPATTERN).FUNCTION (PATTERN).call
&middot; module(MPATTERN).FUNCTION
(PATTERN).return.maxactive(VALUE) &middot;
module(MPATTERN).FUNCTION (PATTERN).inline &middot;
kernel.statement(PATTERN) &middot;
kernel.statement(ADDRESS).absolute &middot;
module(MPATTERN).statement(PATTERN) &middot; kprobe.FUNCTION
(FUNCTION) &middot; kprobe.FUNCTION (FUNCTION).return
&middot; kprobe.module(NAME).FUNCTION (FUNCTION) &middot;
kprobe.module(NAME).FUNCTION (FUNCTION).return &middot;
kprobe.statement(ADDRESS).absolute &middot; process.begin
process(&quot;PATH&quot;).begin &middot; process(PID).begin
process.thread.begin &middot;
process(&quot;PATH&quot;).thread.begin &middot;
process(PID).thread.begin &middot; process.end &middot;
process(&quot;PATH&quot;).end &middot; process(PID).end
&middot; process.thread.end &middot;
process(&quot;PATH&quot;).thread.end &middot;
process(PID).thread.end &middot;
process(&quot;PATH&quot;).syscall &middot;
process(PID).syscall &middot; process.syscall.return
&middot; process(&quot;PATH&quot;).syscall.return &middot;
process(PID).syscall.return &middot;
process(&quot;PATH&quot;).FUNCTION (&quot;NAME&quot;)
&middot;
process(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
&middot; process(&quot;PATH&quot;).FUNCTION
(&quot;*&quot;).return &middot;
process(&quot;PATH&quot;).FUNCTION
(&quot;myfun&quot;).label(&quot;foo&quot;) &middot;
process(&quot;PATH&quot;).mark(&quot;LABEL&quot;) &middot;
java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
&middot;
java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return
&middot;
java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
&middot;
java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return</p>

<p>Tapset Functions Some of the more commonly used tapset
functions &middot; addr:long () &middot; backtrace:string ()
&middot; caller:string () &middot; caller_addr:long ()
&middot; cmdline_arg:string (N:long) &middot;
cmdline_args:string (N:long,m:long,delim:string) &middot;
cmdline_str:string () &middot; env_var:string (name:string)
&middot; execname:string () &middot; int_arg:long (N:long)
&middot; isinstr:long(s1:string,s2:string) &middot;
long_arg:long (N:long) &middot; modname:string () &middot;
module_name:string () &middot; pid:long () &middot;
pn:string () &middot; pointer_arg:string (N:long) &middot;
pp:string () &middot; print_backtrace () &middot;
probefunc:string () &middot; register:long(name:string)
&middot;
str_replace:string(prnt_str:string,srch_str:string,rplc_str:string)
&middot; stringat:long(str:string,pos:long) &middot;
strlen:long(str:string) &middot;
strtol:long(str:string,base:long) &middot;
substr:string(str:string,start:long,length:long) &middot;
user_long:long(addr:long) &middot;
user_string:string(addr:long)</p>

<p>SEE ALSO stap(1)</p>

<p>BUGS Use the Bugzilla link of the project web page or
our mailing list.
http://sourceware.org/systemtap/,&lt;systemtap@sourceware.org&gt;.</p>

<p>STAPREF(1)</p>
<hr>
</body>
</html>
