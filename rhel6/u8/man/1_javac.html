<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>javac(1) Basic Tools javac(1)</p>

<p>NAME javac - Reads Java class and interface definitions
and compiles them into bytecode and class files.</p>

<p>SYNOPSIS javac [ options ] [ sourcefiles ] [ classes] [
@argfiles ]</p>

<p>Arguments can be in any order:</p>

<p>options Command-line options. See Options.</p>

<p>sourcefiles One or more source files to be compiled
(such as MyClass.java).</p>

<p>classes One or more classes to be processed for
annotations (such as MyPackage.MyClass).</p>

<p>@argfiles One or more files that list options and source
files. The -J options are not allowed in these files. See
Command-Line Argument Files.</p>

<p>DESCRIPTION The javac command reads class and interface
definitions, written in the Java programming language, and
compiles them into bytecode class files. The javac command
can also process annotations in Java source files and
classes.</p>

<p>There are two ways to pass source code file names to
javac.</p>

<p>&middot; For a small number of source files, list the
file names on the command line.</p>

<p>&middot; For a large number of source files, list the
file names in a file that is separated by blanks or line
breaks. Use the list file name preceded by an at sign (@)
with the javac command.</p>

<p>Source code file names must have .java suffixes, class
file names must have .class suffixes, and both source and
class files must have root names that identify the class.
For example, a class called MyClass would be written in a
source file called MyClass.java and compiled into a bytecode
class file called MyClass.class.</p>

<p>Inner class definitions produce additional class files.
These class files have names that combine the inner and
outer class names, such as MyClass$MyInnerClass.class.</p>

<p>Arrange source files in a directory tree that reflects
their package tree. For example, if all of your source files
are in /workspace, then put the source code for
com.mysoft.mypack.MyClass in
/workspace/com/mysoft/mypack/MyClass.java.</p>

<p>By default, the compiler puts each class file in the
same directory as its source file. You can specify a
separate destination directory with the -d option.</p>

<p>OPTIONS The compiler has a set of standard options that
are supported on the current development environment. An
additional set of nonstandard options are specific to the
current virtual machine and compiler implementations and are
subject to change in the future. Nonstandard options begin
with the -X option.</p>

<p>&middot; See also Cross-Compilation Options</p>

<p>&middot; See also Nonstandard Options</p>

<p>STANDARD OPTIONS -Akey[=value] Specifies options to pass
to annotation processors. These options are not interpreted
by javac directly, but are made available for use by
individual processors. The key value should be one or more
identifiers separated by a dot (.).</p>

<p>-cp path or -classpath path Specifies where to find user
class files, and (optionally) annotation processors and
source files. This class path overrides the user class path
in the CLASSPATH environment variable. If neither CLASSPATH,
-cp nor -classpath is specified, then the user class path is
the current directory. See Setting the Class Path.</p>

<p>If the -sourcepath option is not specified, then the
user class path is also searched for source files.</p>

<p>If the -processorpath option is not specified, then the
class path is also searched for annotation processors.</p>

<p>-Djava.ext.dirs=directories Overrides the location of
installed extensions.</p>

<p>-Djava.endorsed.dirs=directories Overrides the location
of the endorsed standards path.</p>

<p>-d directory Sets the destination directory for class
files. The directory must already exist because javac does
not create it. If a class is part of a package, then javac
puts the class file in a subdirectory that reflects the
package name and creates directories as needed.</p>

<p>If you specify -d/home/myclasses and the class is called
com.mypackage.MyClass, then the class file is
/home/myclasses/com/mypackage/MyClass.class.</p>

<p>If the -d option is not specified, then javac puts each
class file in the same directory as the source file from
which it was generated.</p>

<p>Note: The directory specified by the -d option is not
automatically added to your user class path.</p>

<p>-deprecation Shows a description of each use or override
of a deprecated member or class. Without the -deprecation
option, javac shows a summary of the source files that use
or override deprecated members or classes. The -deprecation
option is shorthand for -Xlint:deprecation.</p>

<p>-encoding encoding Sets the source file encoding name,
such as EUC-JP and UTF-8. If the -encoding option is not
specified, then the platform default converter is used.</p>

<p>-endorseddirs directories Overrides the location of the
endorsed standards path.</p>

<p>-extdirs directories Overrides the location of the ext
directory. The directories variable is a colon-separated
list of directories. Each JAR file in the specified
directories is searched for class files. All JAR files found
become part of the class path.</p>

<p>If you are cross-compiling (compiling classes against
bootstrap and extension classes of a different Java platform
implementation), then this option specifies the directories
that contain the extension classes. See Cross-Compilation
Options for more information.</p>

<p>-g Generates all debugging information, including local
variables. By default, only line number and source file
information is generated.</p>

<p>-g:none Does not generate any debugging information.</p>

<p>-g:[keyword list] Generates only some kinds of debugging
information, specified by a comma separated list of
keywords. Valid keywords are:</p>

<p>source Source file debugging information.</p>

<p>lines Line number debugging information.</p>

<p>vars Local variable debugging information.</p>

<p>-help Prints a synopsis of standard options.</p>

<p>-implicit:[class, none] Controls the generation of class
files for implicitly loaded source files. To automatically
generate class files, use -implicit:class. To suppress class
file generation, use -implicit:none. If this option is not
specified, then the default is to automatically generate
class files. In this case, the compiler issues a warning if
any such class files are generated when also doing
annotation processing. The warning is not issued when the
-implicit option is set explicitly. See Searching for
Types.</p>

<p>-Joption Passes option to the Java Virtual Machine
(JVM), where option is one of the options described on the
reference page for the Java launcher. For example, -J-Xms48m
sets the startup memory to 48 MB. See java(1).</p>

<p>Note: The CLASSPATH, -classpath, -bootclasspath, and
-extdirs options do not specify the classes used to run
javac. Trying to customize the compiler implementation with
these options and variables is risky and often does not
accomplish what you want. If you must customize the complier
implementation, then use the -J option to pass options
through to the underlying Java launcher.</p>

<p>-nowarn Disables warning messages. This option operates
the same as the -Xlint:none option.</p>

<p>-parameters Stores formal parameter names of
constructors and methods in the generated class file so that
the method java.lang.reflect.Executable.getParameters from
the Reflection API can retrieve them.</p>

<p>-proc: [none, only] Controls whether annotation
processing and compilation are done. -proc:none means that
compilation takes place without annotation processing.
-proc:only means that only annotation processing is done,
without any subsequent compilation.</p>

<p>-processor class1 [,class2,class3...] Names of the
annotation processors to run. This bypasses the default
discovery process.</p>

<p>-processorpath path Specifies where to find annotation
processors. If this option is not used, then the class path
is searched for processors.</p>

<p>-s dir Specifies the directory where to place the
generated source files. The directory must already exist
because javac does not create it. If a class is part of a
package, then the compiler puts the source file in a
subdirectory that reflects the package name and creates
directories as needed.</p>

<p>If you specify -s /home/mysrc and the class is called
com.mypackage.MyClass, then the source file is put in
/home/mysrc/com/mypackage/MyClass.java.</p>

<p>-source release Specifies the version of source code
accepted. The following values for release are allowed:</p>

<p>1.3 The compiler does not support assertions, generics,
or other language features introduced after Java SE 1.3.</p>

<p>1.4 The compiler accepts code containing assertions,
which were introduced in Java SE 1.4.</p>

<p>1.5 The compiler accepts code containing generics and
other language features introduced in Java SE 5.</p>

<p>5 Synonym for 1.5.</p>

<p>1.6 No language changes were introduced in Java SE 6.
However, encoding errors in source files are now reported as
errors instead of warnings as in earlier releases of Java
Platform, Standard Edition.</p>

<p>6 Synonym for 1.6.</p>

<p>1.7 The compiler accepts code with features introduced
in Java SE 7.</p>

<p>7 Synonym for 1.7.</p>

<p>1.8 This is the default value. The compiler accepts code
with features introduced in Java SE 8.</p>

<p>8 Synonym for 1.8.</p>

<p>-sourcepath sourcepath Specifies the source code path to
search for class or interface definitions. As with the user
class path, source path entries are separated by colons (:)
on Oracle Solaris and semicolons on Windows and can be
directories, JAR archives, or ZIP archives. If packages are
used, then the local path name within the directory or
archive must reflect the package name.</p>

<p>Note: Classes found through the class path might be
recompiled when their source files are also found. See
Searching for Types.</p>

<p>-verbose Uses verbose output, which includes information
about each class loaded and each source file compiled.</p>

<p>-version Prints release information.</p>

<p>-werror Terminates compilation when warnings occur.</p>

<p>-X Displays information about nonstandard options and
exits.</p>

<p>CROSS-COMPILATION OPTIONS By default, classes are
compiled against the bootstrap and extension classes of the
platform that javac shipped with. But javac also supports
cross-compiling, where classes are compiled against a
bootstrap and extension classes of a different Java platform
implementation. It is important to use the -bootclasspath
and -extdirs options when cross-compiling.</p>

<p>-target version Generates class files that target a
specified release of the virtual machine. Class files will
run on the specified target and on later releases, but not
on earlier releases of the JVM. Valid targets are 1.1, 1.2,
1.3, 1.4, 1.5 (also 5), 1.6 (also 6), 1.7 (also 7), and 1.8
(also 8).</p>

<p>The default for the -target option depends on the value
of the -source option:</p>

<p>&middot; If the -source option is not specified, then
the value of the -target option is 1.8</p>

<p>&middot; If the -source option is 1.2, then the value of
the -target option is 1.4</p>

<p>&middot; If the -source option is 1.3, then the value of
the -target option is 1.4</p>

<p>&middot; If the -source option is 1.5, then the value of
the -target option is 1.8</p>

<p>&middot; If the -source option is 1.6, then the value of
the -target is option 1.8</p>

<p>&middot; If the -source option is 1.7, then the value of
the -target is option 1.8</p>

<p>&middot; For all other values of the -source option, the
value of the -target option is the value of the -source
option.</p>

<p>-bootclasspath bootclasspath Cross-compiles against the
specified set of boot classes. As with the user class path,
boot class path entries are separated by colons (:) and can
be directories, JAR archives, or ZIP archives.</p>

<p>COMPACT PROFILE OPTION Beginning with JDK 8, the javac
compiler supports compact profiles. With compact profiles,
applications that do not require the entire Java platform
can be deployed and run with a smaller footprint. The
compact profiles feature could be used to shorten the
download time for applications from app stores. This feature
makes for more compact deployment of Java applications that
bundle the JRE. This feature is also useful in small
devices.</p>

<p>The supported profile values are compact1, compact2, and
compact3. These are additive layers. Each higher-numbered
compact profile contains all of the APIs in profiles with
smaller number names.</p>

<p>-profile When using compact profiles, this option
specifies the profile name when compiling. For example:</p>

<p>javac -profile compact1 Hello.java</p>

<p>javac does not compile source code that uses any Java SE
APIs that is not in the specified profile. Here is an
example of the error message that results from attempting to
compile such source code:</p>

<p>cd jdk1.8.0/bin ./javac -profile compact1 Paint.java
Paint.java:5: error: Applet is not available in
profilecompact1 import java.applet.Applet;</p>

<p>In this example, you can correct the error by modifying
the source to not use the Applet class. You could also
correct the error by compiling without the -profile option.
Then the compilation would be run against the full set of
Java SE APIs. (None of the compact profiles include the
Applet class.)</p>

<p>An alternative way to compile with compact profiles is
to use the -bootclasspath option to specify a path to an
rt.jar file that specifies a profiles image. Using the
-profile option instead does not require a profile image to
be present on the system at compile time. This is useful
when cross-compiling.</p>

<p>NONSTANDARD OPTIONS -Xbootclasspath/p:path Adds a suffix
to the bootstrap class path.</p>

<p>-Xbootclasspath/a:path Adds a prefix to the bootstrap
class path.</p>

<p>-Xbootclasspath/:path Overrides the location of the
bootstrap class files.</p>

<p>-Xdoclint:[-]group [/access] Enables or disables
specific groups of checks, where group is one of the
following values: accessibility, syntax, reference, html or
missing. For more information about these groups of checks
see the -Xdoclint option of the javadoc command. The
-Xdoclint option is disabled by default in the javac
command.</p>

<p>The variable access specifies the minimum visibility
level of classes and members that the -Xdoclint option
checks. It can have one of the following values (in order of
most to least visible) : public, protected, package and
private. For example, the following option checks classes
and members (with all groups of checks) that have the access
level protected and higher (which includes protected,
package and public):</p>

<p>-Xdoclint:all/protected</p>

<p>The following option enables all groups of checks for
all access levels, except it will not check for HTML errors
for classes and members that have access level package and
higher (which includes package and public):</p>

<p>-Xdoclint:all,-html/package</p>

<p>-Xdoclint:none Disables all groups of checks.</p>

<p>-Xdoclint:all[/access] Enables all groups of checks.</p>

<p>-Xlint Enables all recommended warnings. In this
release, enabling all available warnings is recommended.</p>

<p>-Xlint:all Enables all recommended warnings. In this
release, enabling all available warnings is recommended.</p>

<p>-Xlint:none Disables all warnings.</p>

<p>-Xlint:name Disables warning name. See Enable or Disable
Warnings with the -Xlint Option for a list of warnings you
can disable with this option.</p>

<p>-Xlint:-name Disables warning name. See Enable or
Disable Warnings with the -Xlint Option with the -Xlint
option to get a list of warnings that you can disable with
this option.</p>

<p>-Xmaxerrs number Sets the maximum number of errors to
print.</p>

<p>-Xmaxwarns number Sets the maximum number of warnings to
print.</p>

<p>-Xstdout filename Sends compiler messages to the named
file. By default, compiler messages go to System.err.</p>

<p>-Xprefer:[newer,source] Specifies which file to read
when both a source file and class file are found for a type.
(See Searching for Types). If the -Xprefer:newer option is
used, then it reads the newer of the source or class file
for a type (default). If the -Xprefer:source option is used,
then it reads the source file. Use -Xprefer:source when you
want to be sure that any annotation processors can access
annotations declared with a retention policy of SOURCE.</p>

<p>-Xpkginfo:[always,legacy,nonempty] Control whether javac
generates package-info.class files from package-info.java
files. Possible mode arguments for this option include the
following.</p>

<p>always Always generate a package-info.class file for
every package-info.java file. This option may be useful if
you use a build system such as Ant, which checks that each
.java file has a corresponding .class file.</p>

<p>legacy Generate a package-info.class file only if
package- info.java contains annotations. Don t generate a
package- info.class file if package-info.java only contains
comments.</p>

<p>Note: A package-info.class file might be generated but
be empty if all the annotations in the package-info.java
file have RetentionPolicy.SOURCE.</p>

<p>nonempty Generate a package-info.class file only if
package- info.java contains annotations with
RetentionPolicy.CLASS or RetentionPolicy.RUNTIME.</p>

<p>-Xprint Prints a textual representation of specified
types for debugging purposes. Perform neither annotation
processing nor compilation. The format of the output could
change.</p>

<p>-XprintProcessorInfo Prints information about which
annotations a processor is asked to process.</p>

<p>-XprintRounds Prints information about initial and
subsequent annotation processing rounds.</p>

<p>ENABLE OR DISABLE WARNINGS WITH THE -XLINT OPTION Enable
warning name with the -Xlint:name option, where name is one
of the following warning names. Note that you can disable a
warning with the -Xlint:-name: option.</p>

<p>cast Warns about unnecessary and redundant casts, for
example:</p>

<p>String s = (String) &quot;Hello!&quot;</p>

<p>classfile Warns about issues related to class file
contents.</p>

<p>deprecation Warns about the use of deprecated items, for
example:</p>

<p>java.util.Date myDate = new java.util.Date(); int
currentDay = myDate.getDay();</p>

<p>The method java.util.Date.getDay has been deprecated
since JDK 1.1</p>

<p>dep-ann Warns about items that are documented with an
@deprecated Javadoc comment, but do not have a @Deprecated
annotation, for example:</p>

<p>/** * @deprecated As of Java SE 7, replaced by {@link
#newMethod()} */ public static void deprecatedMethood() { }
public static void newMethod() { }</p>

<p>divzero Warns about division by the constant integer 0,
for example:</p>

<p>int divideByZero = 42 / 0;</p>

<p>empty Warns about empty statements after ifstatements,
for example:</p>

<p>class E { void m() { if (true) ; } }</p>

<p>fallthrough Checks the switch blocks for fall-through
cases and provides a warning message for any that are found.
Fall-through cases are cases in a switch block, other than
the last case in the block, whose code does not include a
break statement, allowing code execution to fall through
from that case to the next case. For example, the code
following the case 1 label in this switch block does not end
with a break statement:</p>

<p>switch (x) { case 1: System.out.println(&quot;1&quot;);
// No break statement here. case 2:
System.out.println(&quot;2&quot;); }</p>

<p>If the -Xlint:fallthrough option was used when compiling
this code, then the compiler emits a warning about possible
fall- through into case, with the line number of the case in
question.</p>

<p>finally Warns about finally clauses that cannot complete
normally, for example:</p>

<p>public static int m() { try { throw new
NullPointerException(); } catch (NullPointerException(); {
System.err.println(&quot;Caught
NullPointerException.&quot;); return 1; } finally { return
0; } }</p>

<p>The compiler generates a warning for the finally block
in this example. When the int method is called, it returns a
value of 0. A finally block executes when the try block
exits. In this example, when control is transferred to the
catch block, the int method exits. However, the finally
block must execute, so it is executed, even though control
was transferred outside the method.</p>

<p>options Warns about issues that related to the use of
command-line options. See Cross-Compilation Options.</p>

<p>overrides Warns about issues regarding method overrides.
For example, consider the following two classes:</p>

<p>public class ClassWithVarargsMethod { void
varargsMethod(String... s) { } }</p>

<p>public class ClassWithOverridingMethod extends
ClassWithVarargsMethod { @Override void
varargsMethod(String[] s) { } }</p>

<p>The compiler generates a warning similar to the
following:.</p>

<p>warning: [override] varargsMethod(String[]) in
ClassWithOverridingMethod overrides varargsMethod(String...)
in ClassWithVarargsMethod; overriding method is
missing...</p>

<p>When the compiler encounters a varargs method, it
translates the varargs formal parameter into an array. In
the method ClassWithVarargsMethod.varargsMethod, the
compiler translates the varargs formal parameter String... s
to the formal parameter String[] s, an array, which matches
the formal parameter of the method
ClassWithOverridingMethod.varargsMethod. Consequently, this
example compiles.</p>

<p>path Warns about invalid path elements and nonexistent
path directories on the command line (with regard to the
class path, the source path, and other paths). Such warnings
cannot be suppressed with the @SuppressWarnings annotation,
for example:</p>

<p>javac -Xlint:path -classpath /nonexistentpath
Example.java</p>

<p>processing Warn about issues regarding annotation
processing. The compiler generates this warning when you
have a class that has an annotation, and you use an
annotation processor that cannot handle that type of
exception. For example, the following is a simple annotation
processor:</p>

<p>Source file AnnocProc.java:</p>

<p>import java.util.*; import
javax.annotation.processing.*; import javax.lang.model.*;
import.javaz.lang.model.element.*;</p>

<p>@SupportedAnnotationTypes(&quot;NotAnno&quot;) public
class AnnoProc extends AbstractProcessor { public boolean
process(Set&lt;? extends TypeElement&gt; elems,
RoundEnvironment renv){ return true; }</p>

<p>public SourceVersion getSupportedSourceVersion() {
return SourceVersion.latest(); } }</p>

<p>Source file AnnosWithoutProcessors.java:</p>

<p>@interface Anno { }</p>

<p>@Anno class AnnosWithoutProcessors { }</p>

<p>The following commands compile the annotation processor
AnnoProc, then run this annotation processor against the
source file AnnosWithoutProcessors.java:</p>

<p>javac AnnoProc.java javac -cp . -Xlint:processing
-processor AnnoProc -proc:only
AnnosWithoutProcessors.java</p>

<p>When the compiler runs the annotation processor against
the source file AnnosWithoutProcessors.java, it generates
the following warning:</p>

<p>warning: [processing] No processor claimed any of these
annotations: Anno</p>

<p>To resolve this issue, you can rename the annotation
defined and used in the class AnnosWithoutProcessors from
Anno to NotAnno.</p>

<p>rawtypes Warns about unchecked operations on raw types.
The following statement generates a rawtypes warning:</p>

<p>void countElements(List l) { ... }</p>

<p>The following example does not generate a rawtypes
warning</p>

<p>void countElements(List&lt;?&gt; l) { ... }</p>

<p>List is a raw type. However, List&lt;?&gt; is an
unbounded wildcard parameterized type. Because List is a
parameterized interface, always specify its type argument.
In this example, the List formal argument is specified with
an unbounded wildcard (?) as its formal type parameter,
which means that the countElements method can accept any
instantiation of the List interface.</p>

<p>Serial Warns about missing serialVersionUID definitions
on serializable classes, for example:</p>

<p>public class PersistentTime implements Serializable {
private Date time;</p>

<p>public PersistentTime() { time =
Calendar.getInstance().getTime(); }</p>

<p>public Date getTime() { return time; } }</p>

<p>The compiler generates the following warning:</p>

<p>warning: [serial] serializable class PersistentTime has
no definition of serialVersionUID</p>

<p>If a serializable class does not explicitly declare a
field named serialVersionUID, then the serialization runtime
environment calculates a default serialVersionUID value for
that class based on various aspects of the class, as
described in the Java Object Serialization Specification.
However, it is strongly recommended that all serializable
classes explicitly declare serialVersionUID values because
the default process of computing serialVersionUID vales is
highly sensitive to class details that can vary depending on
compiler implementations, and as a result, might cause an
unexpected InvalidClassExceptions during deserialization. To
guarantee a consistent serialVersionUID value across
different Java compiler implementations, a serializable
class must declare an explicit serialVersionUID value.</p>

<p>static Warns about issues relating to the use of
statics, for example:</p>

<p>class XLintStatic { static void m1() { } void m2() {
this.m1(); } }</p>

<p>The compiler generates the following warning:</p>

<p>warning: [static] static method should be qualified by
type name, XLintStatic, instead of by an expression</p>

<p>To resolve this issue, you can call the static method m1
as follows:</p>

<p>XLintStatic.m1();</p>

<p>Alternately, you can remove the static keyword from the
declaration of the method m1.</p>

<p>try Warns about issues relating to use of try blocks,
including try- with-resources statements. For example, a
warning is generated for the following statement because the
resource ac declared in the try block is not used:</p>

<p>try ( AutoCloseable ac = getResource() ) { // do
nothing}</p>

<p>unchecked Gives more detail for unchecked conversion
warnings that are mandated by the Java Language
Specification, for example:</p>

<p>List l = new ArrayList&lt;Number&gt;();
List&lt;String&gt; ls = l; // unchecked warning</p>

<p>During type erasure, the types ArrayList&lt;Number&gt;
and List&lt;String&gt; become ArrayList and List,
respectively.</p>

<p>The ls command has the parameterized type
List&lt;String&gt;. When the List referenced by l is
assigned to ls, the compiler generates an unchecked warning.
At compile time, the compiler and JVM cannot determine
whether l refers to a List&lt;String&gt; type. In this case,
l does not refer to a List&lt;String&gt; type. As a result,
heap pollution occurs.</p>

<p>A heap pollution situation occurs when the List object
l, whose static type is List&lt;Number&gt;, is assigned to
another List object, ls, that has a different static type,
List&lt;String&gt;. However, the compiler still allows this
assignment. It must allow this assignment to preserve
backward compatibility with releases of Java SE that do not
support generics. Because of type erasure,
List&lt;Number&gt; and List&lt;String&gt; both become List.
Consequently, the compiler allows the assignment of the
object l, which has a raw type of List, to the object
ls.</p>

<p>varargs Warns about unsafe usages of variable arguments
(varargs) methods, in particular, those that contain
non-reifiable arguments, for example:</p>

<p>public class ArrayBuilder { public static &lt;T&gt; void
addToList (List&lt;T&gt; listArg, T... elements) { for (T x
: elements) { listArg.add(x); } } }</p>

<p>Note: A non-reifiable type is a type whose type
information is not fully available at runtime.</p>

<p>The compiler generates the following warning for the
definition of the method ArrayBuilder.addToList</p>

<p>warning: [varargs] Possible heap pollution from
parameterized vararg type T</p>

<p>When the compiler encounters a varargs method, it
translates the varargs formal parameter into an array.
However, the Java programming language does not permit the
creation of arrays of parameterized types. In the method
ArrayBuilder.addToList, the compiler translates the varargs
formal parameter T... elements to the formal parameter T[]
elements, an array. However, because of type erasure, the
compiler converts the varargs formal parameter to Object[]
elements. Consequently, there is a possibility of heap
pollution.</p>

<p>COMMAND-LINE ARGUMENT FILES To shorten or simplify the
javac command, you can specify one or more files that
contain arguments to the javac command (except -J options).
This enables you to create javac commands of any length on
any operating system.</p>

<p>An argument file can include javac options and source
file names in any combination. The arguments within a file
can be separated by spaces or new line characters. If a file
name contains embedded spaces, then put the whole file name
in double quotation marks.</p>

<p>File Names within an argument file are relative to the
current directory, not the location of the argument file.
Wild cards (*) are not allowed in these lists (such as for
specifying *.java). Use of the at sign (@) to recursively
interpret files is not supported. The -J options are not
supported because they are passed to the launcher, which
does not support argument files.</p>

<p>When executing the javac command, pass in the path and
name of each argument file with the at sign (@) leading
character. When the javac command encounters an argument
beginning with the at sign (@), it expands the contents of
that file into the argument list.</p>

<p>Example 1 Single Argument File</p>

<p>You could use a single argument file named argfile to
hold all javac arguments:</p>

<p>javac @argfile</p>

<p>This argument file could contain the contents of both
files shown in Example 2</p>

<p>Example 2 Two Argument Files</p>

<p>You can create two argument files: one for the javac
options and the other for the source file names. Note that
the following lists have no line-continuation
characters.</p>

<p>Create a file named options that contains the
following:</p>

<p>-d classes -g -sourcepath
/java/pubs/ws/1.3/src/share/classes</p>

<p>Create a file named classes that contains the
following:</p>

<p>MyClass1.java MyClass2.java MyClass3.java</p>

<p>Then, run the javac command as follows:</p>

<p>javac @options @classes</p>

<p>Example 3 Argument Files with Paths</p>

<p>The argument files can have paths, but any file names
inside the files are relative to the current working
directory (not path1 or path2):</p>

<p>javac @path1/options @path2/classes</p>

<p>ANNOTATION PROCESSING The javac command provides direct
support for annotation processing, superseding the need for
the separate annotation processing command, apt.</p>

<p>The API for annotation processors is defined in the
javax.annotation.processing and javax.lang.model packages
and subpackages.</p>

<p>HOW ANNOTATION PROCESSING WORKS Unless annotation
processing is disabled with the -proc:none option, the
compiler searches for any annotation processors that are
available. The search path can be specified with the
-processorpath option. If no path is specified, then the
user class path is used. Processors are located by means of
service provider-configuration files named META-
INF/services/javax.annotation.processing.Processor on the
search path. Such files should contain the names of any
annotation processors to be used, listed one per line.
Alternatively, processors can be specified explicitly, using
the -processor option.</p>

<p>After scanning the source files and classes on the
command line to determine what annotations are present, the
compiler queries the processors to determine what
annotations they process. When a match is found, the
processor is called. A processor can claim the annotations
it processes, in which case no further attempt is made to
find any processors for those annotations. After all of the
annotations are claimed, the compiler does not search for
additional processors.</p>

<p>If any processors generate new source files, then
another round of annotation processing occurs: Any newly
generated source files are scanned, and the annotations
processed as before. Any processors called on previous
rounds are also called on all subsequent rounds. This
continues until no new source files are generated.</p>

<p>After a round occurs where no new source files are
generated, the annotation processors are called one last
time, to give them a chance to complete any remaining work.
Finally, unless the -proc:only option is used, the compiler
compiles the original and all generated source files.</p>

<p>IMPLICITLY LOADED SOURCE FILES To compile a set of
source files, the compiler might need to implicitly load
additional source files. See Searching for Types. Such files
are currently not subject to annotation processing. By
default, the compiler gives a warning when annotation
processing occurred and any implicitly loaded source files
are compiled. The -implicit option provides a way to
suppress the warning.</p>

<p>SEARCHING FOR TYPES To compile a source file, the
compiler often needs information about a type, but the type
definition is not in the source files specified on the
command line. The compiler needs type information for every
class or interface used, extended, or implemented in the
source file. This includes classes and interfaces not
explicitly mentioned in the source file, but that provide
information through inheritance.</p>

<p>For example, when you create a subclass
java.applet.Applet, you are also using the ancestor classes
of Applet: java.awt.Panel, java.awt.Container,
java.awt.Component, and java.lang.Object.</p>

<p>When the compiler needs type information, it searches
for a source file or class file that defines the type. The
compiler searches for class files first in the bootstrap and
extension classes, then in the user class path (which by
default is the current directory). The user class path is
defined by setting the CLASSPATH environment variable or by
using the -classpath option.</p>

<p>If you set the -sourcepath option, then the compiler
searches the indicated path for source files. Otherwise, the
compiler searches the user class path for both class files
and source files.</p>

<p>You can specify different bootstrap or extension classes
with the -bootclasspath and the -extdirs options. See
Cross-Compilation Options.</p>

<p>A successful type search may produce a class file, a
source file, or both. If both are found, then you can use
the -Xprefer option to instruct the compiler which to use.
If newer is specified, then the compiler uses the newer of
the two files. If source is specified, the compiler uses the
source file. The default is newer.</p>

<p>If a type search finds a source file for a required
type, either by itself, or as a result of the setting for
the -Xprefer option, then the compiler reads the source file
to get the information it needs. By default the compiler
also compiles the source file. You can use the -implicit
option to specify the behavior. If none is specified, then
no class files are generated for the source file. If class
is specified, then class files are generated for the source
file.</p>

<p>The compiler might not discover the need for some type
information until after annotation processing completes.
When the type information is found in a source file and no
-implicit option is specified, the compiler gives a warning
that the file is being compiled without being subject to
annotation processing. To disable the warning, either
specify the file on the command line (so that it will be
subject to annotation processing) or use the -implicit
option to specify whether or not class files should be
generated for such source files.</p>

<p>PROGRAMMATIC INTERFACE The javac command supports the
new Java Compiler API defined by the classes and interfaces
in the javax.tools package.</p>

<p>EXAMPLE To compile as though providing command-line
arguments, use the following syntax:</p>

<p>JavaCompiler javac =
ToolProvider.getSystemJavaCompiler();</p>

<p>The example writes diagnostics to the standard output
stream and returns the exit code that javac would give when
called from the command line.</p>

<p>You can use other methods in the
javax.tools.JavaCompiler interface to handle diagnostics,
control where files are read from and written to, and
more.</p>

<p>OLD INTERFACE Note: This API is retained for backward
compatibility only. All new code should use the newer Java
Compiler API.</p>

<p>The com.sun.tools.javac.Main class provides two static
methods to call the compiler from a program:</p>

<p>public static int compile(String[] args); public static
int compile(String[] args, PrintWriter out);</p>

<p>The args parameter represents any of the command-line
arguments that would typically be passed to the
compiler.</p>

<p>The out parameter indicates where the compiler
diagnostic output is directed.</p>

<p>The return value is equivalent to the exit value from
javac.</p>

<p>Note: All other classes and methods found in a package
with names that start with com.sun.tools.javac (subpackages
of com.sun.tools.javac) are strictly internal and subject to
change at any time.</p>

<p>EXAMPLES Example 1 Compile a Simple Program</p>

<p>This example shows how to compile the Hello.java source
file in the greetings directory. The class defined in
Hello.java is called greetings.Hello. The greetings
directory is the package directory both for the source file
and the class file and is underneath the current directory.
This makes it possible to use the default user class path.
It also makes it unnecessary to specify a separate
destination directory with the -d option.</p>

<p>The source code in Hello.java:</p>

<p>package greetings;</p>

<p>public class Hello { public static void main(String[]
args) { for (int i=0; i &lt; args.length; i++) {
System.out.println(&quot;Hello &quot; + args[i]); } } }</p>

<p>Compile greetings.Hello:</p>

<p>javac greetings/Hello.java</p>

<p>Run greetings.Hello:</p>

<p>java greetings.Hello World Universe Everyone Hello World
Hello Universe Hello Everyone</p>

<p>Example 2 Compile Multiple Source Files</p>

<p>This example compiles the Aloha.java, GutenTag.java,
Hello.java, and Hi.java source files in the greetings
package.</p>

<p>% javac greetings/*.java % ls greetings Aloha.class
GutenTag.class Hello.class Hi.class Aloha.java GutenTag.java
Hello.java Hi.java</p>

<p>Example 3 Specify a User Class Path</p>

<p>After changing one of the source files in the previous
example, recompile it:</p>

<p>pwd /examples javac greetings/Hi.java</p>

<p>Because greetings.Hi refers to other classes in the
greetings package, the compiler needs to find these other
classes. The previous example works because the default user
class path is the directory that contains the package
directory. If you want to recompile this file without
concern for which directory you are in, then add the
examples directory to the user class path by setting
CLASSPATH. This example uses the -classpath option.</p>

<p>javac -classpath /examples
/examples/greetings/Hi.java</p>

<p>If you change greetings.Hi to use a banner utility, then
that utility also needs to be accessible through the user
class path.</p>

<p>javac -classpath /examples:/lib/Banners.jar
/examples/greetings/Hi.java</p>

<p>To execute a class in the greetings package, the program
needs access to the greetings package, and to the classes
that the greetings classes use.</p>

<p>java -classpath /examples:/lib/Banners.jar
greetings.Hi</p>

<p>Example 4 Separate Source Files and Class Files</p>

<p>The following example uses javac to compile code that
runs on JVM 1.7.</p>

<p>javac -source 1.7 -target 1.7 -bootclasspath
jdk1.7.0/lib/rt.jar -extdirs &quot;&quot; OldCode.java</p>

<p>The -source 1.7 option specifies that release 1.7 (or 7)
of the Java programming language be used to compile
OldCode.java. The option -target 1.7 option ensures that the
generated class files are compatible with JVM 1.7. Note that
in most cases, the value of the -target option is the value
of the -source option; in this example, you can omit the
-target option.</p>

<p>You must specify the -bootclasspath option to specify
the correct version of the bootstrap classes (the rt.jar
library). If not, then the compiler generates a warning:</p>

<p>javac -source 1.7 OldCode.java warning: [options]
bootstrap class path not set in conjunction with -source
1.7</p>

<p>If you do not specify the correct version of bootstrap
classes, then the compiler uses the old language rules (in
this example, it uses version 1.7 of the Java programming
language) combined with the new bootstrap classes, which can
result in class files that do not work on the older platform
(in this case, Java SE 7) because reference to nonexistent
methods can get included.</p>

<p>Example 5 Cross Compile</p>

<p>This example uses javac to compile code that runs on JVM
1.7.</p>

<p>javac -source 1.7 -target 1.7 -bootclasspath
jdk1.7.0/lib/rt.jar -extdirs &quot;&quot; OldCode.java</p>

<p>The-source 1.7 option specifies that release 1.7 (or 7)
of the Java programming language to be used to compile
OldCode.java. The -target 1.7 option ensures that the
generated class files are compatible with JVM 1.7.</p>

<p>You must specify the -bootclasspath option to specify
the correct version of the bootstrap classes (the rt.jar
library). If not, then the compiler generates a warning:</p>

<p>javac -source 1.7 OldCode.java warning: [options]
bootstrap class path not set in conjunction with -source
1.7</p>

<p>If you do not specify the correct version of bootstrap
classes, then the compiler uses the old language rules
combined with the new bootstrap classes. This combination
can result in class files that do not work on the older
platform (in this case, Java SE 7) because reference to
nonexistent methods can get included. In this example, the
compiler uses release 1.7 of the Java programming
language.</p>

<p>SEE ALSO &middot; java(1)</p>

<p>&middot; jdb(1)</p>

<p>&middot; javah(1)</p>

<p>&middot; javadoc(1)</p>

<p>&middot; jar(1)</p>

<p>&middot; jdb(1)</p>

<p>JDK 8 03 March 2015 javac(1)</p>
<hr>
</body>
</html>
