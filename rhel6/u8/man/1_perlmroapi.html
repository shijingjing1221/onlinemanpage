<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLMROAPI(1) Perl Programmers Reference Guide
PERLMROAPI(1)</p>

<p>NAME perlmroapi - Perl method resolution plugin
interface</p>

<p>DESCRIPTION As of Perl 5.10.1 there is a new interface
for plugging and using method resolution orders other than
the default (linear depth first search). The C3 method
resolution order added in 5.10.0 has been re- implemented as
a plugin, without changing its Perl-space interface.</p>

<p>Each plugin should register itself with
&quot;Perl_mro_register&quot; by providing the following
structure</p>

<p>struct mro_alg { AV *(*resolve)(pTHX_ HV *stash, U32
level); const char *name; U16 length; U16 kflags; U32 hash;
};</p>

<p>resolve Pointer to the linearisation function, described
below.</p>

<p>name Name of the MRO, either in ISO-8859-1 or UTF-8.</p>

<p>length Length of the name.</p>

<p>kflags If the name is given in UTF-8, set this to
&quot;HVhek_UTF8&quot;. The value is passed direct as the
parameter kflags to &quot;hv_common()&quot;.</p>

<p>hash A precomputed hash value for the MROs name, or
0.</p>

<p>Callbacks The &quot;resolve&quot; function is called to
generate a linearised ISA for the given stash, using this
MRO. It is called with a pointer to the stash, and a level
of 0. The core always sets level to 0 when it calls your
function - the parameter is provided to allow your
implementation to track depth if it needs to recurse.</p>

<p>The function should return a reference to an array
containing the parent classes in order. The caller is
responsible for incrementing the reference count if it wants
to keep the structure. Hence if you have created a temporary
value that you keep no pointer to, &quot;sv_2mortal()&quot;
to ensure that it is disposed of correctly. If you have
cached your return value, then return a pointer to it
without changing the reference count.</p>

<p>Caching Computing MROs can be expensive. The
implementation provides a cache, in which you can store a
single &quot;SV *&quot;, or anything that can be cast to
&quot;SV *&quot;, such as &quot;AV *&quot;. To read your
private value, use the macro
&quot;MRO_GET_PRIVATE_DATA()&quot;, passing it the
&quot;mro_meta&quot; structure from the stash, and a pointer
to your &quot;mro_alg&quot; structure:</p>

<p>meta = HvMROMETA(stash); private_sv =
MRO_GET_PRIVATE_DATA(meta, &amp;my_mro_alg);</p>

<p>To set your private value, call
&quot;Perl_mro_set_private_data()&quot;:</p>

<p>Perl_mro_set_private_data(aTHX_ meta, &amp;c3_alg,
private_sv);</p>

<p>The private data cache will take ownership of a
reference to private_sv, much the same way that
&quot;hv_store()&quot; takes ownership of a reference to the
value that you pass it.</p>

<p>Examples For examples of MRO implementations, see
&quot;S_mro_get_linear_isa_c3()&quot; and the
&quot;BOOT:&quot; section of mro/mro.xs, and
&quot;S_mro_get_linear_isa_dfs()&quot; in mro.c</p>

<p>AUTHORS The implementation of the C3 MRO and switchable
MROs within the perl core was written by Brandon L Black.
Nicholas Clark created the pluggable interface, refactored
Brandons implementation to work with it, and wrote this
document.</p>

<p>perl v5.10.1 2009-06-27 PERLMROAPI(1)</p>
<hr>
</body>
</html>
