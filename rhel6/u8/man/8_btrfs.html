<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:06:52 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>BTRFS(8) btrfs BTRFS(8)</p>

<p>NAME btrfs - control a btrfs filesystem</p>

<p>SYNOPSIS btrfs subvolume snapshot [-r] &lt;source&gt;
[&lt;dest&gt;/]&lt;name&gt;</p>

<p>btrfs subvolume delete &lt;subvolume&gt;
[&lt;subvolume&gt;...]</p>

<p>btrfs subvolume create [&lt;dest&gt;/]&lt;name&gt;</p>

<p>btrfs subvolume list [-aprts] [-g [+|-]value] [-c
[+|-]value] [--rootid=rootid,gen,ogen,path] &lt;path&gt;</p>

<p>btrfs subvolume set-default &lt;id&gt; &lt;path&gt;</p>

<p>btrfs subvolume get-default &lt;path&gt;</p>

<p>btrfs filesystem defragment -c[zlib|lzo] [-l len] [-s
start] [-t size] -[vf] &lt;file&gt;|&lt;dir&gt;
[&lt;file&gt;|&lt;dir&gt;...]</p>

<p>btrfs filesystem sync &lt;path&gt;</p>

<p>btrfs filesystem resize
[devid:][+/-]&lt;size&gt;[gkm]|[devid:]max &lt;filesys-
tem&gt;</p>

<p>btrfs filesystem label &lt;dev&gt; [newlabel]</p>

<p>btrfs subvolume find-new &lt;subvolume&gt;
&lt;last_gen&gt;</p>

<p>btrfs filesystem balance &lt;path&gt;</p>

<p>btrfs device scan [--all-devices|&lt;device&gt;
[&lt;device&gt;...]]</p>

<p>btrfs device show
[--all-devices|&lt;uuid&gt;|&lt;label&gt;]</p>

<p>btrfs device add &lt;device&gt; [&lt;device&gt;...]
&lt;path&gt;</p>

<p>btrfs device delete &lt;device&gt; [&lt;device&gt;...]
&lt;path&gt;</p>

<p>btrfs scrub start [-Bdqru]
{&lt;path&gt;|&lt;device&gt;}</p>

<p>btrfs scrub cancel {&lt;path&gt;|&lt;device&gt;}</p>

<p>btrfs scrub resume [-Bdqru]
{&lt;path&gt;|&lt;device&gt;}</p>

<p>btrfs scrub status [-d]
{&lt;path&gt;|&lt;device&gt;}</p>

<p>btrfs inspect-internal inode-resolve [-v] &lt;inode&gt;
&lt;path&gt;</p>

<p>btrfs inspect-internal logical-resolve [-Pv] [-s size]
&lt;logical&gt; &lt;path&gt;</p>

<p>btrfs help|--help|-h</p>

<p>btrfs &lt;command&gt; --help</p>

<p>DESCRIPTION btrfs is used to control the filesystem and
the files and directories stored. It is the tool to create
or destroy a snapshot or a subvolume for the filesystem, to
defrag a file or a directory, flush the data to the disk, to
resize the filesystem, to scan the device.</p>

<p>It is possible to abbreviate the commands unless the
commands are ambiguous. For example: it is possible to run
btrfs sub snaps instead of btrfs subvolume snapshot. But
btrfs file s is not allowed, because file s may be
interpreted both as filesystem show and as filesystem sync.
In this case btrfs returns filesystem sync If a command is
ter- minated by --help , the detailed help is showed. If the
passed command matches more commands, detailed help of all
the matched commands is showed. For example btrfs dev --help
shows the help of all device* com- mands.</p>

<p>COMMANDS subvolume snapshot [-r] &lt;source&gt;
[&lt;dest&gt;/]&lt;name&gt; Create a writable/readonly
snapshot of the subvolume &lt;source&gt; with the name
&lt;name&gt; in the &lt;dest&gt; directory. If
&lt;source&gt; is not a subvolume, btrfs returns an error.
If -r is given, the snap- shot will be readonly.</p>

<p>subvolume delete &lt;subvolume&gt;
[&lt;subvolume&gt;...] Delete the subvolume
&lt;subvolume&gt;. If &lt;subvolume&gt; is not a sub-
volume, btrfs returns an error.</p>

<p>subvolume create [&lt;dest&gt;/]&lt;name&gt; Create a
subvolume in &lt;dest&gt; (or in the current directory if
&lt;dest&gt; is omitted).</p>

<p>subvolume list [-aprts][-g [+|-]value] [-c [+|-]value]
[--sort=gen,ogen,rootid,path] &lt;path&gt; List the
subvolumes present in the filesystem &lt;path&gt;. For every
subvolume the following information is shown by default. ID
&lt;ID&gt; top level &lt;ID&gt; path &lt;path&gt; where path
is the relative path of the subvolume to the top level
subvolume.</p>

<p>The subvolumes ID may be used by the subvolume
set-default com- mand, or at mount time via the subvol=
option. If -p is given, then parent &lt;ID&gt; is added to
the output between ID and top level. The parents ID may be
used at mount time via the subvol- rootid= option.</p>

<p>-t print the result as a table.</p>

<p>-a print all the subvolumes in the filesystem.</p>

<p>-r only readonly subvolumes in the filesystem wille be
listed.</p>

<p>-s only snapshot subvolumes in the filesystem will be
listed.</p>

<p>-g [+|-]value list subvolumes in the filesystem that its
genera- tion is &gt;=, &lt;= or = value. + means &gt;=
value, - means &lt;= value, If there is neither + nor - , it
means = value.</p>

<p>-c [+|-]value list subvolumes in the filesystem that its
ogener- ation is &gt;=, &lt;= or = value. The usage is the
same to -g option.</p>

<p>--sort=gen,ogen,path,rootid list subvolumes in order by
speci- fied items. you can add + or - in front of each
items, + means ascending,- means descending. The default is
ascending.</p>

<p>for --sort you can combine some items together by , ,
just like -sort=+ogen,-gen,path,rootid.</p>

<p>subvolume set-default &lt;id&gt; &lt;path&gt; Set the
subvolume of the filesystem &lt;path&gt; which is mounted as
default. The subvolume is identified by &lt;id&gt;, which is
returned by the subvolume list command.</p>

<p>subvolume get-default &lt;path&gt; Get the default
subvolume of the filesystem &lt;path&gt;. The output format
is similar to subvolume list command.</p>

<p>filesystem defragment -c[zlib|lzo] [-l len] [-s start]
[-t size] -[vf] &lt;file&gt;|&lt;dir&gt;
[&lt;file&gt;|&lt;dir&gt;...]</p>

<p>Defragment file data and/or directory metadata. To
defragment all files in a directory you have to specify each
one on its own or use your shell wildcards.</p>

<p>The start position and the number of bytes to defragment
can be specified by start and len. Any extent bigger than
threshold will be considered already defragged. Use 0 to
take the kernel default, and use 1 to say every single
extent must be rewritten. You can also turn on compression
in defragment operations.</p>

<p>-v be verbose</p>

<p>-c compress file contents while defragmenting</p>

<p>-f flush filesystem after defragmenting</p>

<p>-s start defragment only from byte start onward</p>

<p>-l len defragment only up to len bytes</p>

<p>-t size defragment only files at least size bytes
big</p>

<p>NOTE: defragmenting with kernels up to 2.6.37 will
unlink COW-ed copies of data, don t use it if you use
snapshots, have de- duplicated your data or made copies with
cp --reflink.</p>

<p>subvolume find-new &lt;subvolume&gt; &lt;last_gen&gt;
List the recently modified files in a subvolume, after
&lt;last_gen&gt; ID.</p>

<p>filesystem sync &lt;path&gt; Force a sync for the
filesystem identified by &lt;path&gt;.</p>

<p>filesystem resize
[devid:][+/-]&lt;size&gt;[gkm]|[devid:]max &lt;path&gt;
Resize a filesystem identified by &lt;path&gt; for the
underlying device devid. The devid can be found with btrfs
filesystem show and defaults to 1 if not specified. The
&lt;size&gt; parameter speci- fies the new size of the
filesystem. If the prefix + or - is present the size is
increased or decreased by the quantity &lt;size&gt;. If no
units are specified, the unit of the &lt;size&gt; parameter
defaults to bytes. Optionally, the size parameter may be
suffixed by one of the following units designators: K, M, or
G , kilobytes, megabytes, or gigabytes, respectively.</p>

<p>If max is passed, the filesystem will occupy all
available space on the device devid.</p>

<p>The resize command does not manipulate the size of
underlying partition. If you wish to enlarge/reduce a
filesystem, you must make sure you can expand the partition
before enlarging the filesystem and shrink the partition
after reducing the size of the filesystem. This can done
using fdisk(8) or parted(8) to delete the existing partition
and recreate it with the new desired size. When recreating
the partition make sure to use the same starting disk
cylinder as before.</p>

<p>filesystem label &lt;dev&gt; [newlabel] Show or update
the label of a filesystem. &lt;dev&gt; is used to iden- tify
the filesystem. If a newlabel optional argument is passed,
the label is changed. The following constraints exist for a
label:</p>

<p>- the maximum allowable length shall be less or equal
than 256 chars</p>

<p>- the label shall not contain the / or characters.</p>

<p>NOTE: Currently there are the following limitations:</p>

<p>- the filesystem has to be unmounted</p>

<p>- the filesystem should not have more than one
device.</p>

<p>filesystem show
[--all-devices|&lt;uuid&gt;|&lt;label&gt;] Show the btrfs
filesystem with some additional info. If no UUID or label is
passed, btrfs show info of all the btrfs filesystem. If
--all-devices is passed, all the devices under /dev are
scanned; otherwise the devices list is extracted from the
/proc/partitions file.</p>

<p>filesystem balance &lt;path&gt; Balance the chunks of
the filesystem identified by &lt;path&gt; across the
devices.</p>

<p>device add &lt;dev&gt; [&lt;dev&gt;..] &lt;path&gt; Add
device(s) to the filesystem identified by &lt;path&gt;.</p>

<p>device delete &lt;dev&gt; [&lt;dev&gt;..] &lt;path&gt;
Remove device(s) from a filesystem identified by
&lt;path&gt;.</p>

<p>device scan [--all-devices|&lt;device&gt;
[&lt;device&gt;...] If one or more devices are passed, these
are scanned for a btrfs filesystem. If no devices are
passed, btrfs scans all the block devices listed in the
/proc/partitions file. Finally, if --all- devices is passed,
all the devices under /dev are scanned.</p>

<p>scrub start [-Bdqru] {&lt;path&gt;|&lt;device&gt;} Start
a scrub on all devices of the filesystem identified by
&lt;path&gt; or on a single &lt;device&gt;. Without options,
scrub is started as a background process. Progress can be
obtained with the scrub status command. Scrubbing involves
reading all data from all disks and verifying checksums.
Errors are corrected along the way if possible.</p>

<p>Options</p>

<p>-B Do not background and print scrub statistics when
finished.</p>

<p>-d Print separate statistics for each device of the
filesystem (-B only).</p>

<p>-q Quiet. Omit error messages and statistics.</p>

<p>-r Read only mode. Do not attempt to correct
anything.</p>

<p>-u Scrub unused space as well. (NOT IMPLEMENTED)</p>

<p>scrub cancel {&lt;path&gt;|&lt;device&gt;} If a scrub is
running on the filesystem identified by &lt;path&gt;, cancel
it. Progress is saved in the scrub progress file and
scrubbing can be resumed later using the scrub resume
command. If a &lt;device&gt; is given, the corresponding
filesystem is found and scrub cancel behaves as if it was
called on that filesystem.</p>

<p>scrub resume [-Bdqru] {&lt;path&gt;|&lt;device&gt;}
Resume a canceled or interrupted scrub cycle on the
filesystem identified by &lt;path&gt; or on a given
&lt;device&gt;. Does not start a new scrub if the last scrub
finished successfully.</p>

<p>Options</p>

<p>see scrub start.</p>

<p>scrub status [-d] {&lt;path&gt;|&lt;device&gt;} Show
status of a running scrub for the filesystem identified by
&lt;path&gt; or for the specified &lt;device&gt;. If no
scrub is running, show statistics of the last finished or
canceled scrub for that filesystem or device.</p>

<p>Options</p>

<p>-d Print separate statistics for each device of the
filesys- tem.</p>

<p>inspect-internal inode-resolve [-v] &lt;inode&gt;
&lt;path&gt; Resolves an &lt;inode&gt; in subvolume
&lt;path&gt; to all filesystem paths.</p>

<p>Options</p>

<p>-v verbose mode. print count of returned paths and
ioctl() return value</p>

<p>inspect-internal logical-resolve [-Pv] [-s bufsize]
&lt;logical&gt; &lt;path&gt; Resolves a &lt;logical&gt;
address in the filesystem mounted at &lt;path&gt; to all
inodes. By default, each inode is then resolved to a file
system path (similar to the inode-resolve subcommand).</p>

<p>Options</p>

<p>-P skip the path resolving and print the inodes
instead</p>

<p>-v verbose mode. print count of returned paths and all
ioctl() return values</p>

<p>-s set inode containers size. This is used to increase
inode container s size in case it is not enough to read all
the resolved results. The max value one can set is 64k.</p>

<p>EXIT STATUS btrfs returns a zero exist status if it
succeeds. Non zero is returned in case of failure.</p>

<p>AVAILABILITY btrfs is part of btrfs-progs. Btrfs
filesystem is currently under heavy development, and not
suitable for any uses other than benchmarking and review.
Please refer to the btrfs wiki http://btrfs.wiki.kernel.org
for further details.</p>

<p>SEE ALSO mkfs.btrfs(8)</p>

<p>btrfs BTRFS(8)</p>
<hr>
</body>
</html>
