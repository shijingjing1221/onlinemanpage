<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:06:16 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>BITMAP_REMAP(9) Basic Kernel Library Functions
BITMAP_REMAP(9)</p>

<p>NAME bitmap_remap - Apply map defined by a pair of
bitmaps to another bitmap</p>

<p>SYNOPSIS void bitmap_remap(unsigned long * dst, const
unsigned long * src, const unsigned long * old, const
unsigned long * new, int bits);</p>

<p>ARGUMENTS dst remapped result</p>

<p>src subset to be remapped</p>

<p>old defines domain of map</p>

<p>new defines range of map</p>

<p>bits number of bits in each of these bitmaps</p>

<p>DESCRIPTION Let old and new define a mapping of bit
positions, such that whatever position is held by the n-th
set bit in old is mapped to the n-th set bit in new. In the
more general case, allowing for the possibility that the
weight &acute;w&acute; of new is less than the weight of
old, map the position of the n-th set bit in old to the
position of the m-th set bit in new, where m == n % w.</p>

<p>If either of the old and new bitmaps are empty, or if
src and dst point to the same location, then this routine
copies src to dst.</p>

<p>The positions of unset bits in old are mapped to
themselves (the identify map).</p>

<p>Apply the above specified mapping to src, placing the
result in dst, clearing any bits previously set in dst.</p>

<p>For example, lets say that old has bits 4 through 7 set,
and new has bits 12 through 15 set. This defines the mapping
of bit position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and
of all other bit positions unchanged. So if say src comes
into this routine with bits 1, 5 and 7 set, then dst should
leave with bits 1, 13 and 15 set.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
BITMAP_REMAP(9)</p>
<hr>
</body>
</html>
