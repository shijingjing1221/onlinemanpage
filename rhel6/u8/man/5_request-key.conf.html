<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:31:34 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>REQUEST-KEY.CONF(5) Linux Key Management Utilities
REQUEST-KEY.CONF(5)</p>

<p>NAME request-key.conf - Instantiation handler
configuration file</p>

<p>DESCRIPTION This file and its associated key-type
specific variants are used by the /sbin/request-key program
to determine which program it should run to instantiate a
key.</p>

<p>request-key looks first in /etc/request-key.d/ for a
file of the key type name plus &quot;.conf&quot; that it can
use. If that is not found, it will fall back to
/etc/request-key.conf.</p>

<p>request-key scans through the chosen file one line at a
time until it finds a match, which it will then use. If it
doesn t find a match, it ll return an error and the kernel
will automatically negate the key.</p>

<p>Any blank line or line beginning with a hash mark # is
considered to be a comment and ignored.</p>

<p>All other lines are assumed to be command lines with a
number of white space separated fields:</p>

<p>&lt;op&gt; &lt;type&gt; &lt;description&gt;
&lt;callout-info&gt; &lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt;
...</p>

<p>The first four fields are used to match the parameters
passed to request-key by the kernel. op is the operation
type; currently the only supported operation is
&quot;create&quot;.</p>

<p>type, description and callout-info match the three
parameters passed to keyctl request2 or the request_key()
system call. Each of these may contain one or more asterisk
* characters as wildcards anywhere within the string.</p>

<p>Should a match be made, the program specified by
&lt;prog&gt; will be execd. This must have a fully qualified
path name. argv[0] will be set from the part of the program
name that follows the last slash / character.</p>

<p>If the program name is prefixed with a pipe bar
character |, then the program will be forked and execd
attached to three pipes. The callout information will be
piped to it on its stdin and the intended payload data will
be retrieved from its stdout. Anything sent to stderr will
be posted in syslog. If the program exits 0, then
/sbin/request-key will attempt to instantiate the key with
the data read from stdout. If it fails in any other way,
then request-key will attempt to execute the appropriate
negate operation command.</p>

<p>The program arguments can be substituted with various
macros. Only com- plete argument substitution is supported -
macro substitutions cant be embedded. All macros begin with
a percent character % . An argument beginning with two
percent characters will have one of them discarded.</p>

<p>The following macros are supported:</p>

<p>%o Operation type %k Key ID %t Key type %d Key
description %c Callout information %u Key UID %g Key GID %T
Requestors thread keyring %P Requestors process keyring %S
Requestors session keyring</p>

<p>Theres another macro substitution too that permits the
interpolation of the contents of a key:</p>

<p>%{&lt;type&gt;:&lt;description&gt;}</p>

<p>This performs a lookup for a key of the given type and
description on the requestors keyrings, and if found,
substitutes the contents for the macro. If not found an
error will be logged and the key under con- struction will
be negated.</p>

<p>EXAMPLE A basic file will be installed in the /etc. This
will contain two debugging lines that can be used to test
the installation:</p>

<p>create user debug:* negate /bin/keyctl negate %k 30 %S
create user debug:loop:* * |/bin/cat create user debug:* *
/usr/share/keyutils/request-key-debug.sh %k %d %c %S negate
* * * /bin/keyctl negate %k 30 %S</p>

<p>This is set up so that something like:</p>

<p>keyctl request2 user debug:xxxx negate</p>

<p>will create a negative user-defined key, something
like:</p>

<p>keyctl request2 user debug:yyyy spoon</p>

<p>will create an instantiated user-defined key with
&quot;Debug spoon&quot; as the payload, and something
like:</p>

<p>keyctl request2 user debug:loop:zzzz abcdefghijkl</p>

<p>will create an instantiated user-defined key with the
callout informa- tion as the payload.</p>

<p>FILES /etc/request-key.conf
/etc/request-key.d/&lt;keytype&gt;.conf</p>

<p>SEE ALSO keyctl(1), request-key.conf(5)</p>

<p>Linux 15 November 2011 REQUEST-KEY.CONF(5)</p>
<hr>
</body>
</html>
