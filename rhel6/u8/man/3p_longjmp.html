<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:22:27 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LONGJMP(3P) POSIX Programmer s Manual LONGJMP(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME longjmp - non-local goto</p>

<p>SYNOPSIS #include &lt;setjmp.h&gt;</p>

<p>void longjmp(jmp_buf env, int val);</p>

<p>DESCRIPTION The longjmp() function shall restore the
environment saved by the most recent invocation of setjmp()
in the same thread, with the correspond- ing jmp_buf
argument. If there is no such invocation, or if the func-
tion containing the invocation of setjmp() has terminated
execution in the interim, or if the invocation of setjmp()
was within the scope of an identifier with variably modified
type and execution has left that scope in the interim, the
behavior is undefined. It is unspecified whether longjmp()
restores the signal mask, leaves the signal mask unchanged,
or restores it to its value at the time setjmp() was
called.</p>

<p>All accessible objects have values, and all other
components of the abstract machine have state (for example,
floating-point status flags and open files), as of the time
longjmp() was called, except that the values of objects of
automatic storage duration are unspecified if they meet all
the following conditions:</p>

<p>* They are local to the function containing the
corresponding setjmp() invocation.</p>

<p>* They do not have volatile-qualified type.</p>

<p>* They are changed between the setjmp() invocation and
longjmp() call.</p>

<p>As it bypasses the usual function call and return
mechanisms, longjmp() shall execute correctly in contexts of
interrupts, signals, and any of their associated functions.
However, if longjmp() is invoked from a nested signal
handler (that is, from a function invoked as a result of a
signal raised during the handling of another signal), the
behavior is undefined.</p>

<p>The effect of a call to longjmp() where initialization
of the jmp_buf structure was not performed in the calling
thread is undefined.</p>

<p>RETURN VALUE After longjmp() is completed, program
execution continues as if the corresponding invocation of
setjmp() had just returned the value speci- fied by val. The
longjmp() function shall not cause setjmp() to return 0; if
val is 0, setjmp() shall return 1.</p>

<p>ERRORS No errors are defined.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES None.</p>

<p>APPLICATION USAGE Applications whose behavior depends on
the value of the signal mask should not use longjmp() and
setjmp(), since their effect on the signal mask is
unspecified, but should instead use the siglongjmp() and
sigsetjmp() functions (which can save and restore the signal
mask under application control).</p>

<p>RATIONALE None.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO setjmp(), sigaction(), siglongjmp(),
sigsetjmp(), the Base Definitions volume of IEEE Std
1003.1-2001, &lt;setjmp.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 LONGJMP(3P)</p>
<hr>
</body>
</html>
