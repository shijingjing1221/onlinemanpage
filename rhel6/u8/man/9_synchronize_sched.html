<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:36:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SYNCHRONIZE_SCHED(9) Driver Basics
SYNCHRONIZE_SCHED(9)</p>

<p>NAME synchronize_sched - wait until an rcu-sched grace
period has elapsed.</p>

<p>SYNOPSIS void synchronize_sched(void);</p>

<p>ARGUMENTS void no arguments</p>

<p>DESCRIPTION Control will return to the caller some time
after a full rcu-sched grace period has elapsed, in other
words after all currently executing rcu-sched read-side
critical sections have completed. These read-side critical
sections are delimited by rcu_read_lock_sched and
rcu_read_unlock_sched, and may be nested. Note that
preempt_disable, local_irq_disable, and so on may be used in
place of rcu_read_lock_sched.</p>

<p>This means that all preempt_disable code sequences,
including NMI and hardware-interrupt handlers, in progress
on entry will have completed before this primitive returns.
However, this does not guarantee that softirq handlers will
have completed, since in some kernels, these handlers can
run in process context, and can block.</p>

<p>This primitive provides the guarantees made by the (now
removed) synchronize_kernel API. In contrast,
synchronize_rcu only guarantees that rcu_read_lock sections
will have completed. In classic RCU, these two guarantees
happen to be one and the same, but can differ in realtime
RCU implementations.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
SYNCHRONIZE_SCHED(9)</p>
<hr>
</body>
</html>
