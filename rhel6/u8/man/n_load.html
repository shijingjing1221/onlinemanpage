<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:22:10 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>load(n) Tcl Built-In Commands load(n)</p>


<p>______________________________________________________________________________</p>

<p>NAME load - Load machine code and initialize new
commands</p>

<p>SYNOPSIS load fileName load fileName packageName load
fileName packageName interp
_________________________________________________________________</p>

<p>DESCRIPTION This command loads binary code from a file
into the applications address space and calls an
initialization procedure in the package to incorporate it
into an interpreter. fileName is the name of the file
containing the code; its exact form varies from system to
system but on most systems it is a shared library, such as a
.so file under Solaris or a DLL under Windows. packageName
is the name of the pack- age, and is used to compute the
name of an initialization procedure. interp is the path name
of the interpreter into which to load the pack- age (see the
interp manual entry for details); if interp is omitted, it
defaults to the interpreter in which the load command was
invoked.</p>

<p>Once the file has been loaded into the applications
address space, one of two initialization procedures will be
invoked in the new code. Typ- ically the initialization
procedure will add new commands to a Tcl interpreter. The
name of the initialization procedure is determined by
packageName and whether or not the target interpreter is a
safe one. For normal interpreters the name of the
initialization procedure will have the form pkg_Init, where
pkg is the same as packageName except that the first letter
is converted to upper case and all other letters are
converted to lower case. For example, if packageName is foo
or FOo, the initialization procedures name will be
Foo_Init.</p>

<p>If the target interpreter is a safe interpreter, then
the name of the initialization procedure will be
pkg_SafeInit instead of pkg_Init. The pkg_SafeInit function
should be written carefully, so that it initial- izes the
safe interpreter only with partial functionality provided by
the package that is safe for use by untrusted code. For more
informa- tion on Safe-Tcl, see the safe manual entry.</p>

<p>The initialization procedure must match the following
prototype: typedef int Tcl_PackageInitProc(Tcl_Interp
*interp); The interp argument identifies the interpreter in
which the package is to be loaded. The initialization
procedure must return TCL_OK or TCL_ERROR to indicate
whether or not it completed successfully; in the event of an
error it should set the interpreters result to point to an
error message. The result of the load command will be the
result returned by the initialization procedure.</p>

<p>The actual loading of a file will only be done once for
each fileName in an application. If a given fileName is
loaded into multiple inter- preters, then the first load
will load the code and call the initial- ization procedure;
subsequent loads will call the initialization pro- cedure
without loading the code again. For Tcl versions lower than
8.5, it is not possible to unload or reload a package. From
version 8.5 however, the unload command allows the unloading
of libraries loaded with load, for libraries that are aware
of the Tcl s unloading mecha- nism.</p>

<p>The load command also supports packages that are
statically linked with the application, if those packages
have been registered by calling the Tcl_StaticPackage
procedure. If fileName is an empty string, then packageName
must be specified.</p>

<p>If packageName is omitted or specified as an empty
string, Tcl tries to guess the name of the package. This may
be done differently on differ- ent platforms. The default
guess, which is used on most UNIX plat- forms, is to take
the last element of fileName, strip off the first three
characters if they are lib, and use any following alphabetic
and underline characters as the module name. For example,
the command load libxyz4.2.so uses the module name xyz and
the command load bin/last.so {} uses the module name
last.</p>

<p>If fileName is an empty string, then packageName must be
specified. The load command first searches for a statically
loaded package (one that has been registered by calling the
Tcl_StaticPackage procedure) by that name; if one is found,
it is used. Otherwise, the load command searches for a
dynamically loaded package by that name, and uses it if it
is found. If several different files have been loaded with
differ- ent versions of the package, Tcl picks the file that
was loaded first.</p>

<p>PORTABILITY ISSUES Windows When a load fails with
library not found error, it is also possible that a
dependent library was not found. To see the dependent
libraries, type dumpbin -imports &lt;dllname&gt; in a DOS
console to see what the library must import. When loading a
DLL in the current directory, Windows will ignore ./ as a
path specifier and use a search heuristic to find the DLL
instead. To avoid this, load the DLL with: load [file join
[pwd] mylib.DLL]</p>

<p>BUGS If the same file is loaded by different fileNames,
it will be loaded into the process s address space multiple
times. The behavior of this varies from system to system
(some systems may detect the redundant loads, others may
not).</p>

<p>EXAMPLE The following is a minimal extension:</p>

<p>#include &lt;tcl.h&gt; #include &lt;stdio.h&gt; static
int fooCmd(ClientData clientData, Tcl_Interp *interp, int
objc, Tcl_Obj *const objv[]) { printf(&quot;called with %d
arguments0, objc); return TCL_OK; } int Foo_Init(Tcl_Interp
*interp) { if (Tcl_InitStubs(interp, &quot;8.1&quot;, 0) ==
NULL) { return TCL_ERROR; } printf(&quot;creating foo
command&quot;); Tcl_CreateObjCommand(interp,
&quot;foo&quot;, fooCmd, NULL, NULL); return TCL_OK; }</p>

<p>When built into a shared/dynamic library with a suitable
name (e.g. foo.dll on Windows, libfoo.so on Solaris and
Linux) it can then be loaded into Tcl with the
following:</p>

<p># Load the extension switch $tcl_platform(platform) {
windows { load [file join [pwd] foo.dll] } unix { load [file
join [pwd] libfoo[info sharedlibextension]] } }</p>

<p># Now execute the command defined by the extension
foo</p>

<p>SEE ALSO info sharedlibextension, Tcl_StaticPackage(3),
safe(n)</p>

<p>KEYWORDS binary code, loading, safe interpreter, shared
library</p>

<p>Tcl 7.5 load(n)</p>
<hr>
</body>
</html>
