<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:43:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>USB_QUEUE_RESET_DEVI(9) USB Core APIs
USB_QUEUE_RESET_DEVI(9)</p>

<p>NAME usb_queue_reset_device - Reset a USB device from an
atomic context</p>

<p>SYNOPSIS void usb_queue_reset_device(struct
usb_interface * iface);</p>

<p>ARGUMENTS iface USB interface belonging to the device to
reset</p>

<p>DESCRIPTION This function can be used to reset a USB
device from an atomic context, where usb_reset_device
won&acute;t work (as it blocks).</p>

<p>Doing a reset via this method is functionally equivalent
to calling usb_reset_device, except for the fact that it is
delayed to a workqueue. This means that any drivers bound to
other interfaces might be unbound, as well as users from
usbfs in user space.</p>

<p>CORNER CASES - Scheduling two resets at the same time
from two different drivers attached to two different
interfaces of the same device is possible; depending on how
the driver attached to each interface handles
-&gt;pre_reset, the second reset might happen or not.</p>

<p>- If a driver is unbound and it had a pending reset, the
reset will be cancelled.</p>

<p>- This function can be called during .probe or
.disconnect times. On return from .disconnect, any pending
resets will be cancelled.</p>

<p>There is no no need to lock/unlock the reset_ws as
schedule_work does its own.</p>

<p>NOTE We don&acute;t do any reference count tracking
because it is not needed. The lifecycle of the work_struct
is tied to the usb_interface. Before destroying the
interface we cancel the work_struct, so the fact that
work_struct is queued and or running means the interface
(and thus, the device) exist and are referenced.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
USB_QUEUE_RESET_DEVI(9)</p>
<hr>
</body>
</html>
