<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:35:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SPU_RUN(2) Linux Programmer s Manual SPU_RUN(2)</p>

<p>NAME spu_run - execute an SPU context</p>

<p>SYNOPSIS #include &lt;sys/spu.h&gt;</p>

<p>int spu_run(int fd, unsigned int *npc, unsigned int
*event);</p>

<p>DESCRIPTION The spu_run() system call is used on PowerPC
machines that implement the Cell Broadband Engine
Architecture in order to access Synergistic Processor Units
(SPUs). The fd argument is a file descriptor returned by
spu_create(2) that refers to a specific SPU context. When
the con- text gets scheduled to a physical SPU, it starts
execution at the instruction pointer passed in npc.</p>

<p>Execution of SPU code happens synchronously, meaning
that spu_run() blocks while the SPU is still running. If
there is a need to execute SPU code in parallel with other
code on either the main CPU or other SPUs, a new thread of
execution must be created first (e.g., using
pthread_create(3)).</p>

<p>When spu_run() returns, the current value of the SPU
program counter is written to npc, so successive calls to
spu_run() can use the same npc pointer.</p>

<p>The event argument provides a buffer for an extended
status code. If the SPU context was created with the
SPU_CREATE_EVENTS_ENABLED flag, then this buffer is
populated by the Linux kernel before spu_run() returns.</p>

<p>The status code may be one (or more) of the following
constants:</p>

<p>SPE_EVENT_DMA_ALIGNMENT A DMA alignment error
occurred.</p>

<p>SPE_EVENT_INVALID_DMA An invalid MFC DMA command was
attempted.</p>

<p>SPE_EVENT_SPE_DATA_STORAGE A DMA storage error
occurred.</p>

<p>SPE_EVENT_SPE_ERROR An illegal instruction was
executed.</p>

<p>NULL is a valid value for the event argument. In this
case, the events will not be reported to the calling
process.</p>

<p>RETURN VALUE On success, spu_run() returns the value of
the spu_status register. On error it returns -1 and sets
errno to one of the error codes listed below.</p>

<p>The spu_status register value is a bit mask of status
codes and option- ally a 14-bit code returned from the
stop-and-signal instruction on the SPU. The bit masks for
the status codes are:</p>

<p>0x02 SPU was stopped by a stop-and-signal
instruction.</p>

<p>0x04 SPU was stopped by a halt instruction.</p>

<p>0x08 SPU is waiting for a channel.</p>

<p>0x10 SPU is in single-step mode.</p>

<p>0x20 SPU has tried to execute an invalid
instruction.</p>

<p>0x40 SPU has tried to access an invalid channel.</p>

<p>0x3fff0000 The bits masked with this value contain the
code returned from a stop-and-signal instruction. These bits
are only valid if the 0x02 bit is set.</p>

<p>If spu_run() has not returned an error, one or more bits
among the lower eight ones are always set.</p>

<p>ERRORS EBADF fd is not a valid file descriptor.</p>

<p>EFAULT npc is not a valid pointer, or event is non-NULL
and an invalid pointer.</p>

<p>EINTR A signal occurred while spu_run() was in progress;
see sig- nal(7). The npc value has been updated to the new
program counter value if necessary.</p>

<p>EINVAL fd is not a valid file descriptor returned from
spu_create(2).</p>

<p>ENOMEM There was not enough memory available to handle a
page fault resulting from a Memory Flow Controller (MFC)
direct memory access.</p>

<p>ENOSYS The functionality is not provided by the current
system, because either the hardware does not provide SPUs or
the spufs module is not loaded.</p>

<p>VERSIONS The spu_run() system call was added to Linux in
kernel 2.6.16.</p>

<p>CONFORMING TO This call is Linux-specific and only
implemented by the PowerPC archi- tecture. Programs using
this system call are not portable.</p>

<p>NOTES Glibc does not provide a wrapper for this system
call; call it using syscall(2). Note however, that spu_run()
is meant to be used from libraries that implement a more
abstract interface to SPUs, not to be used from regular
applications. See http://www.bsc.es/projects/deep-
computing/linuxoncell/ for the recommended libraries.</p>

<p>EXAMPLE The following is an example of running a simple,
one-instruction SPU program with the spu_run() system
call.</p>

<p>#include &lt;stdlib.h&gt; #include &lt;stdint.h&gt;
#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include
&lt;sys/types.h&gt; #include &lt;fcntl.h&gt;</p>

<p>#define handle_error(msg) do { perror(msg);
exit(EXIT_FAILURE); } while (0)</p>

<p>int main(void) { int context, fd, spu_status; uint32_t
instruction, npc;</p>

<p>context = spu_create(&quot;/spu/example-context&quot;,
0, 0755); if (context == -1)
handle_error(&quot;spu_create&quot;);</p>

<p>/* write a &rsquo;stop 0x1234&rsquo; instruction to the
SPU&rsquo;s * local store memory */ instruction =
0x00001234;</p>

<p>fd = open(&quot;/spu/example-context/mem&quot;, O_RDWR);
if (fd == -1) handle_error(&quot;open&quot;); write(fd,
&amp;instruction, sizeof(instruction));</p>

<p>/* set npc to the starting instruction address of the *
SPU program. Since we wrote the instruction at the * start
of the mem file, the entry point will be 0x0 */ npc = 0;</p>

<p>spu_status = spu_run(context, &amp;npc, NULL); if
(spu_status == -1) handle_error(&quot;open&quot;);</p>

<p>/* we should see a status code of 0x1234002: *
0x00000002 (spu was stopped due to stop-and-signal) * |
0x12340000 (the stop-and-signal code) */ printf(&quot;SPU
Status: 0x%08x0, spu_status);</p>

<p>exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO close(2), spu_create(2), capabilities(7),
spufs(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2007-11-25 SPU_RUN(2)</p>
<hr>
</body>
</html>
