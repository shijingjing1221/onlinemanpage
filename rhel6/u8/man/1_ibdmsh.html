<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:10 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IBDMSH(1) IB DATA MODEL PACKAGE IBDMSH(1)</p>

<p>NAME ibdmsh IB DATA MODEL - Extentended TCL shell</p>

<p>DESCRIPTION ibdmsh is a TCL shell extended with
interface for the IB data model. To use this shell you will
write TCL code that directly access the IB data model
objects and functions.</p>

<p>The following sub sections provide detailed definition
for those objects and API.</p>

<p>IBDM Constants Node Types</p>

<p>The following constants are used by the node object type
field</p>

<p>[ Constant : int ] $IB_UNKNOWN_NODE_TYPE =
IB_UNKNOWN_NODE_TYPE</p>

<p>[ Constant : int ] $IB_SW_NODE = IB_SW_NODE</p>

<p>[ Constant : int ] $IB_CA_NODE = IB_CA_NODE</p>

<p>Log Verbosity Flags</p>

<p>The following constants are used as argument bits for
the global vari- able $FabricUtilsVerboseLevel</p>

<p>[ Constant : int ] $FABU_LOG_NONE = 0x0</p>

<p>[ Constant : int ] $FABU_LOG_ERROR = 0x1</p>

<p>[ Constant : int ] $FABU_LOG_INFO = 0x2</p>

<p>[ Constant : int ] $FABU_LOG_VERBOSE = 0x4</p>

<p>IBDM Globals Log level: set to FABU_LOG* values</p>

<p>[ Global : int ] $FabricUtilsVerboseLevel</p>

<p>IBDM Objects This section decribes the various object
types exposed by IBDM.</p>

<p>IBDM exposes some of its internal objects. The objects
identifiers returned by the various function calls are
formatted according to the following rules:</p>

<p>Fabric: fabric:&lt;idx&gt;</p>

<p>System: system:&lt;fab idx&gt;:&lt;sys name&gt;</p>

<p>SysPort: sysport:&lt;fab idx&gt;:&lt;sys
name&gt;:&lt;port name&gt;</p>

<p>Node: node:&lt;fab idx&gt;:&lt;node name&gt;</p>

<p>Port: port:&lt;fab idx&gt;:&lt;node name&gt;/&lt;port
num&gt;</p>

<p>IBDM Objects are standard Swig-Tcl objects. As such they
have two fla- vors for their usage: Variables, Objects.</p>

<p>Variables/Pointers: For each object attribute a
&quot;get&quot; and &quot;set&quot; methods are provided.
The format of the methods is:
&lt;class&gt;_&lt;attribute&gt;_&lt;get set&gt;. The
&quot;set&quot; method is only available for read/write
attributes.</p>

<p>Example: set nodes [ibdm_get_nodes] set node [lindex
$nodes 0] IBNode_numPorts_get $node</p>

<p>Objects: Given an object pointer one can convert it to a
Tcl &quot;Object&quot; using the following command:
&lt;class&gt; &lt;obj_name&gt; -this &lt;obj pointer&gt;</p>

<p>Once declared the &lt;obj-name&gt; can be used in
conjunction to with the standard &quot;configure&quot; and
&quot;cget&quot; commands.</p>

<p>Example (following the previous one): IBFabric VaTech
-this $fabric VaTech cget -NodeByName</p>

<p>To delete an object symbol (and enable its mapping to
another pointer) use: rename &lt;obj name&gt; &quot;&quot;
for example: rename VaTech &quot;&quot;</p>

<p>class IBPort</p>

<p>The following are the different fields and methods of
the IB Port class which describes an IB device (chip)
physical port.</p>

<p>[ Member data: returns IBPort * ] -p_remotePort Port
connected on the other side of link</p>

<p>[ Member data: returns IBSysPort * ] -p_sysPort The
system port (if any) connected to</p>

<p>[ Member data: returns IBNode * ] -p_node The node the
port is part of.</p>

<p>[ Member data: returns int ] -num Physical ports are
identified by number.</p>

<p>[ Member data: returns unsigned int ] -base_lid The base
lid assigned to the port.</p>

<p>[ Member data: returns IBLinkWidth * ] -width The link
width of the port</p>

<p>[ Member data: returns IBLinkSpeed * ] -speed The link
speed of the port</p>

<p>[ Member data: returns unsigned int ] -counter1 A
generic value to be used by various algorithms</p>

<p>[ Constructor: returns IBPort * ] IBPort name p_nodePtr
number IBPort constructor</p>

<p>[ Member : returns new_uint64_t ] guid_get Obtain the
guid of the port</p>

<p>[ Member : returns void ] guid_set guid Modify the guid
of the port</p>

<p>[ Member : returns new_string ] getName Get the port
name: A device port connected to system port (front pannel)
returns the front pannel port name.</p>

<p>[ Member : returns void ] connect p_otherPort ?width?
?speed? Connect the port to another node port with optional
width and speed parameters</p>

<p>[ Member : returns int ] disconnect Disconnect the port.
Return 0 if successful</p>

<p>class IBNode</p>

<p>The IB Node class represents a single IB Device
(chip)</p>

<p>[ Member data: returns string * ] -name Name of the node
(instance name of the chip)</p>

<p>[ Member data: returns IBNodeType ] -type Either a
$IB_SW_NODE or $IB_CA_NODE</p>

<p>[ Member data: returns uint16_t * ] -devId The device ID
of the node</p>

<p>[ Member data: returns uint16_t * ] -revId The device
revision Id.</p>

<p>[ Member data: returns uint16_t * ] -vendId The device
Vendor ID.</p>

<p>[ Member data: returns string * ] -attributes Comma-sep
string of arbitrary attributes k=v</p>

<p>[ Member data: returns uint8_t ] -rank The rank of the
node (0 is a root)</p>

<p>[ Member data: returns IBSystem * ] -p_system What
system we belong to</p>

<p>[ Member data: returns IBFabric * ] -p_fabric What
fabric we belong to.</p>

<p>[ Member data: returns unsigned int ] -numPorts Number
of physical ports</p>

<p>[ Member data: returns vec_pport * ] -Ports Vector of
all the ports</p>

<p>[ Member data: returns vec_vec_byte * ] -MinHopsTable A
table of the number of hops required to get from each port
to each target LID</p>

<p>[ Member data: returns vec_byte * ] -LFT The LFT of this
node (for switches only) which is a long vector of target
ports - index is the LID</p>

<p>[ Member : returns new_uint64_t ] guid_get Obtain the
node GUID</p>

<p>[ Member : returns void ] guid_set guid Set the node
GUID</p>

<p>[ Constructor: returns IBNode * ] IBNode name n p_fab
p_sys t np Constractor</p>

<p>[ Member : returns IBPort * ] makePort num Create a new
port by its number (if required) return the port pointer</p>

<p>[ Member : returns IBPort * ] getPort num Get a port by
number num = 1..N:</p>

<p>[ Member : returns void ] setHops p_port lid hops Set
the min hop for the given port (* is all) lid pair</p>

<p>[ Member : returns int ] getHops p_port lid Get the min
number of hops defined for the given port or all</p>

<p>[ Member : returns IBPort * ] getFirstMinHopPort lid
Scan the node ports and find the first port with min hop to
the lid</p>

<p>[ Member : returns void ] setLFTPortForLid lid portNum
Set the Linear Forwarding Table for the given LID</p>

<p>[ Member : returns int ] getLFTPortForLid lid Get the
LFT for a given LID</p>

<p>[ Member : returns void ] repHopTable Dump out the min
hop table of the node</p>

<p>class IBSysPort</p>

<p>The IBSysPort class represents an IB plug on the system
front or back pannels</p>

<p>[ Member data: returns string * ] -name The front pannel
name (silk) of the port</p>

<p>[ Member data: returns IBSysPort * ] -p_remoteSysPort If
connected the other side sys port</p>

<p>[ Member data: returns IBSystem * ] -p_system System it
benongs to</p>

<p>[ Member data: returns IBPort * ] -p_nodePort The node
port it connects to.</p>

<p>[ Constructor: returns IBSysPort * ] IBSysPort name n
p_sys Constructor</p>

<p>[ Member : returns void ] connect p_otherSysPort ?width?
?speed? Connect two SysPorts</p>

<p>[ Member : returns int ] disconnect Disconnect the
SysPort (and ports). Return 0 if successful</p>

<p>class IBSystem</p>

<p>The IBSystem class represents an entire chassis</p>

<p>[ Member data: returns string * ] -name The
&quot;host&quot; name of the system</p>

<p>[ Member data: returns string * ] -type What is the type
i.e. Cougar, Buffalo, MTS2400, etc. A corre- sponding IBNL
file should exist - defining this system type</p>

<p>[ Member data: returns IBFabric * ] -p_fabric Fabric the
system belongs to</p>

<p>[ Member data: returns map_str_pnode * ] -NodeByName
Provide the node pointer by its name</p>

<p>[ Member data: returns map_str_psysport * ] -PortByName
A map provising pointer to the SysPort by name</p>

<p>[ Constructor: returns IBSystem * ] IBSystem name n
p_fab t Constractor</p>

<p>[ Member : returns new_uint64_t ] guid_get Obtain the
system image GUID</p>

<p>[ Member : returns void ] guid_set guid Set the system
image GUID</p>

<p>[ Member : returns IBSysPort * ] makeSysPort pName Make
sure we got the port defined (so define it if not)</p>

<p>[ Member : returns IBPort * ] getSysPortNodePortByName
sysPortName Get the node port for the given sys port by
name</p>

<p>[ Member : returns IBSysPort * ] getSysPort name Get a
Sys Port by name</p>

<p>class IBFabric</p>

<p>Represents an entire IB subnet made of systems</p>

<p>[ Member data: returns map_str_pnode * ] -NodeByName
Provide a list of node name and pointer pairs</p>

<p>[ Member data: returns map_str_psys * ] -SystemByName
Provide a list of system name and pointer pairs</p>

<p>[ Member data: returns vec_pport * ] -PortByLid Provides
a list of system port name and pointer pairs</p>

<p>[ Member data: returns map_guid_pnode * ] -NodeByGuid
Provides a list of node guid and node pointer pairs</p>

<p>[ Member data: returns map_guid_psys * ] -SystemByGuid
Provides a list of system image guid and system pointer
pairs</p>

<p>[ Member data: returns map_guid_pport * ] -PortByGuid
Provides a list of port guid and port pointer pairs</p>

<p>[ Member data: returns unsigned int ] -minLid Track min
lid used.</p>

<p>[ Member data: returns unsigned int ] -maxLid Track max
lid used.</p>

<p>[ Member data: returns unsigned int ] -lmc LMC value
used</p>

<p>[ Member : returns IBNode * ] makeNode n p_sys type
numPorts Get the node by its name (create one of does not
exist)</p>

<p>[ Member : returns IBNode * ] getNode name Get the node
by its name</p>

<p>[ Member : returns list_pnode * ] getNodesByType type
Return the list of node pointers matching the required
type</p>

<p>[ Member : returns IBSystem * ] makeGenericSystem name
Create a new generic system - basically an empty container
for nodes...</p>

<p>[ Member : returns IBSystem * ] makeSystem name type
Create a new system - the type must have a registed
factory.</p>

<p>[ Member : returns IBSystem * ] getSystem name Get
system by name</p>

<p>[ Member : returns IBSystem * ] getSystemByGuid guid get
the system by its guid</p>

<p>[ Member : returns IBNode * ] getNodeByGuid guid get the
node by its guid</p>

<p>[ Member : returns IBPort * ] getPortByGuid guid get the
port by its guid</p>

<p>[ Member : returns void ] addCable t1 n1 p1 t2 n2 p2
?width? ?speed? Adds a cable given two sets of node type,
node name and port number. Optionally use a given width and
speed for the connec- tion</p>

<p>[ Member : returns int ] parseCables fn Parse the cables
file and build the fabric</p>

<p>[ Member : returns int ] parseTopology fn Parse Topology
File and build the fabric</p>

<p>[ Member : returns int ] addLink type1 numPorts1
sysGuid1 nodeGuid1 portGuid1 vend1 devId1 rev1 desc1 lid1
portNum1 type2 numPorts2 sys- Guid2 nodeGuid2 portGuid2
vend2 devId2 rev2 desc2 lid2 portNum2 ?width? ?speed? Add a
link into the fabric - this will create system and nodes as
required.</p>

<p>[ Member : returns int ] parseSubnetLinks fn Parse the
OpenSM subnet.lst file and build the fabric from it.</p>

<p>[ Member : returns int ] parseFdbFile fn Parse OpenSM
FDB dump file and fill in the switches LFT tables</p>

<p>[ Member : returns int ] parseMCFdbFile fn Parse an
OpenSM MCFDBs file and set the MFT table accordingly</p>

<p>[ Member : returns int ] parsePSLFile fn Parse Path to
SL mapping file. Each line with: src_node_guid DLID SL</p>

<p>Used by credit loop check</p>

<p>[ Member : returns int ] parseSLVLFile fn Parse SLVL
tables file. Each line holds: sw_node_guid in_port out_port
0x(sl0)(sl1) 0x(sl2)(sl3)...</p>

<p>[ Member : returns void ] setLidPort lid p_port Set a
lid port</p>

<p>[ Member : returns IBPort * ] getPortByLid lid Get a
port by lid</p>

<p>[ returns IBFabric * ] new_IBFabric Construct a new
fabric</p>

<p>[ returns void ] delete_IBFabric p_fabric Destruct a
fabric</p>

<p>IBDM Functions This section provide the details about
the functions IBDM exposes. The order follows the expected
order in a regular IBDM flow. They all return 0 on
succes.</p>

<p>Subnet Utilities</p>

<p>The file holds a set of utilities to be run on the
subnet to mimic OpenSM initialization and analyze the
results:</p>

<p>[ returns int ] ibdmAssignLids p_smNodePort ?lmc? Assign
LIDs with an optional LMC (multiple LID per port)</p>

<p>[ returns int ] ibdmCalcMinHopTables p_fabric Calculate
and populate the MinHopTables required for running OpenSM
style routing.</p>

<p>[ returns int ] ibdmCalcUpDnMinHopTbls p_fabric
rootNodesNameRex Calculate and populate the MinHopTables
following Up/Down rule.</p>

<p>[ returns int ] ibdmOsmRoute p_fabric Route the fabric
with OpenSM style routing</p>

<p>[ returns int ] ibdmEnhancedRoute p_fabric Route the
fabric with OpenSM style routing enhanced with better
support for LMC &gt; 0</p>

<p>[ returns int ] ibdmFatTreeRoute p_fabric rootNodes
Route the fabric using algorithm that fits only full fat
trees</p>

<p>[ returns int ] ibdmFatTreeAnalysis p_fabric Analyze the
fabric to see if it is a fat tree and route it if it is</p>

<p>[ returns int ] ibdmVerifyCAtoCARoutes p_fabric Make
sure all (H)CAs are connected to each other based on the LFT
settings</p>

<p>[ returns int ] ibdmVerifyAllPaths p_fabric Make sure
all Switches and (H)CAs are connected to each other based on
the LFT settings</p>

<p>[ returns int ] ibdmAnalyzeLoops p_fabric A rigorous
check for credit loops. This algorithm does a full and
accurate check but its reporting of credit loop paths is
hard to interpret. If you know the roots of the tree (or the
tree is symmetrical) it is preferable to use the ibdmReport-
NonUpDownCa2CaPaths</p>

<p>[ returns list_pnode ] ibdmFindSymmetricalTreeRoots
p_fabric Analyze the tree topology and find the roots of the
tree based on its symmetry</p>

<p>[ returns list_pnode ] ibdmFindRootNodesByMinHop
p_fabric Based on the MinHopTable find the roots of the
tree. A 5% assymetry is allowed</p>

<p>[ returns int ] ibdmRankFabricByRoots p_fabric rootNodes
Given the list of root nodes (names) rank the nodes (root =
0)</p>

<p>[ returns int ] ibdmReportNonUpDownCa2CaPaths p_fabric
rootNodes Analyze the routes to make sure Up/Down rule is
maintained</p>

<p>[ returns int ] ibdmCheckMulticastGroups p_fabric Verify
connectivity of multicast routing</p>

<p>[ returns int ]
ibdmCheckFabricMCGrpsForCreditLoopPotential p_fabric
rootNodes Analyze multicast routing to make sure it obeys
Up/Down rule</p>

<p>[ returns int ] ibdmLinkCoverageAnalysis p_fabric
rootNodes Prepare a schedule for transmission from a set of
sources to destinations such that in each stage there are no
links that are over subscribed and after all stages all the
links of the fabric were excersized</p>

<p>Tracing Utilities</p>

<p>These functions allows tracing paths reporting back the
visited nodes</p>

<p>[ returns int ] ibdmTraceDRPathRoute p_smNodePort
drPathPortNums Trace a directed route path from the given
port</p>

<p>[ returns int ] ibdmTraceRouteByMinHops p_fabric slid
dlid Trace a path along the MinHop from the source to
destination LIDs</p>

<p>[ returns int ] ibdmTraceRouteByLFT p_fabric slid dlid
hops p_nodesList Trace a path following the LFT updating the
hops and node list variables</p>

<p>Topology Matching Utilities</p>

<p>The following utilities matches two fabrics providing
both missmatch messages and a unified fabric</p>

<p>[ returns int ] ibdmMatchFabrics p_spec_fabric
p_discovered_fabric anchorNodeName anchorPortNum
anchorPortGuid Match a topology based fabric with a
discovered one starting at the enchor port</p>

<p>[ returns int ] ibdmBuildMergedFabric p_spec_fabric
p_discovered_fab- ric p_merged_fabric After matching using
ibdmMatchFabrics populate the &quot;merged fab- ric&quot;
with information merged for the matched nodes</p>

<p>Congestion Analysis Utilities</p>

<p>Provide ability to track and report link
oversubscription</p>

<p>[ returns int ] ibdmCongInit p_fabric Initialize the
tracking system</p>

<p>[ returns int ] ibdmCongCleanup p_fabric Cleanup the
counters and deallocate</p>

<p>[ returns int ] ibdmCongClear p_fabric Cleanup
counters</p>

<p>[ returns int ] ibdmCongTrace p_fabric srcLid dstLid
Trace a path between the LIDs updating link usage info</p>

<p>[ returns int ] ibdmCongReport p_fabric Report the
resulting congestion information</p>

<p>[ returns int ] ibdmCongDump p_fabric Dump all
congestion tracking info</p>

<p>AUTHOR Eitan Zahavi, Mellanox Technologies LTD,
eitan@mellanox.co.il</p>

<p>IBDM 1.0 2009-03-16 IBDMSH(1)</p>
<hr>
</body>
</html>
