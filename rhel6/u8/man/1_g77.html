<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:05 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>G77(1) GNU G77(1)</p>

<p>NAME g77 - GNU project Fortran 77 compiler</p>

<p>SYNOPSIS g77 [-c|-S|-E] [-g] [-pg] [-Olevel] [-Wwarn...]
[-pedantic] [-Idir...] [-Ldir...] [-Dmacro[=defn]...]
[-Umacro] [-foption...] [-mmachine-option...] [-o outfile]
infile...</p>

<p>Only the most useful options are listed here; see below
for the remainder.</p>

<p>DESCRIPTION The g77 command supports all the options
supported by the gcc command.</p>

<p>All gcc and g77 options are accepted both by g77 and by
gcc (as well as any other drivers built at the same time,
such as g++), since adding g77 to the gcc distribution
enables acceptance of g77 options by all of the relevant
drivers.</p>

<p>In some cases, options have positive and negative forms;
the negative form of -ffoo would be -fno-foo. This manual
documents only one of these two forms, whichever one is not
the default.</p>

<p>OPTIONS Here is a summary of all the options specific to
GNU Fortran, grouped by type. Explanations are in the
following sections.</p>

<p>Overall Options -fversion -fset-g77-defaults
-fno-silent</p>

<p>Shorthand Options -ff66 -fno-f66 -ff77 -fno-f77
-fno-ugly</p>

<p>Fortran Language Options -ffree-form -fno-fixed-form
-ff90 -fvxt -fdollar-ok -fno-backslash -fno-ugly-args
-fno-ugly-assign -fno-ugly-assumed -fugly-comma
-fugly-complex -fugly-init -fugly-logint -fonetrip
-ftypeless-boz -fintrin-case-initcap -fintrin-case-upper
-fintrin-case-lower -fintrin-case-any -fmatch-case-initcap
-fmatch-case-upper -fmatch-case-lower -fmatch-case-any
-fsource-case-upper -fsource-case-lower
-fsource-case-preserve -fsymbol-case-initcap
-fsymbol-case-upper -fsymbol-case-lower -fsymbol-case-any
-fcase-strict-upper -fcase-strict-lower -fcase-initcap
-fcase-upper -fcase-lower -fcase-preserve
-ff2c-intrinsics-delete -ff2c-intrinsics-hide
-ff2c-intrinsics-disable -ff2c-intrinsics-enable
-fbadu77-intrinsics-delete -fbadu77-intrinsics-hide
-fbadu77-intrinsics-disable -fbadu77-intrinsics-enable
-ff90-intrinsics-delete -ff90-intrinsics-hide
-ff90-intrinsics-disable -ff90-intrinsics-enable
-fgnu-intrinsics-delete -fgnu-intrinsics-hide
-fgnu-intrinsics-disable -fgnu-intrinsics-enable
-fmil-intrinsics-delete -fmil-intrinsics-hide
-fmil-intrinsics-disable -fmil-intrinsics-enable
-funix-intrinsics-delete -funix-intrinsics-hide
-funix-intrinsics-disable -funix-intrinsics-enable
-fvxt-intrinsics-delete -fvxt-intrinsics-hide
-fvxt-intrinsics-disable -fvxt-intrinsics-enable
-ffixed-line-length-n -ffixed-line-length-none</p>

<p>Warning Options -fsyntax-only -pedantic -pedantic-errors
-fpedantic -w -Wno-globals -Wimplicit -Wunused
-Wuninitialized -Wall -Wsurprising -Werror -W</p>

<p>Debugging Options -g</p>

<p>Optimization Options -malign-double -ffloat-store
-fforce-mem -fforce-addr -fno-inline -ffast-math
-fstrength-reduce -frerun-cse-after-loop
-funsafe-math-optimizations -ffinite-math-only
-fno-trapping-math -fexpensive-optimizations
-fdelayed-branch -fschedule-insns -fschedule-insn2
-fcaller-saves -funroll-loops -funroll-all-loops
-fno-move-all-movables -fno-reduce-all-givs
-fno-rerun-loop-opt</p>

<p>Directory Options -Idir -I-</p>

<p>Code Generation Options -fno-automatic -finit-local-zero
-fno-f2c -ff2c-library -fno-underscoring -fno-ident
-fpcc-struct-return -freg-struct-return -fshort-double
-fno-common -fpack-struct -fzeros -fno-second-underscore
-femulate-complex -falias-check -fargument-alias
-fargument-noalias -fno-argument-noalias-global -fno-globals
-fflatten-arrays -fbounds-check -ffortran-bounds-check</p>

<p>Compilation can involve as many as four stages:
preprocessing, code generation (often what is really meant
by the term compilation), assembly, and linking, always in
that order. The first three stages apply to an individual
source file, and end by producing an object file; linking
combines all the object files (those newly compiled, and
those specified as input) into an executable file.</p>

<p>For any given input file, the file name suffix
determines what kind of program is contained in the
file---that is, the language in which the program is written
is generally indicated by the suffix. Suffixes specific to
GNU Fortran are listed below.</p>

<p>file.f file.for file.FOR Fortran source code that should
not be preprocessed.</p>

<p>Such source code cannot contain any preprocessor
directives, such as &quot;#include&quot;,
&quot;#define&quot;, &quot;#if&quot;, and so on.</p>

<p>You can force .f files to be preprocessed by cpp by
using -x f77-cpp-input.</p>

<p>file.F file.fpp file.FPP Fortran source code that must
be preprocessed (by the C preprocessor cpp, which is part of
GCC).</p>

<p>Note that preprocessing is not extended to the contents
of files included by the &quot;INCLUDE&quot; directive---the
&quot;#include&quot; preprocessor directive must be used
instead.</p>

<p>file.r Ratfor source code, which must be preprocessed by
the ratfor command, which is available separately (as it is
not yet part of the GNU Fortran distribution). A public
domain version in C is at
&lt;http://sepwww.stanford.edu/sep/prof/ratfor.shar.2&gt;.</p>

<p>UNIX users typically use the file.f and file.F
nomenclature. Users of other operating systems, especially
those that cannot distinguish upper-case letters from
lower-case letters in their file names, typically use the
file.for and file.fpp nomenclature.</p>

<p>Use of the preprocessor cpp allows use of C-like
constructs such as &quot;#define&quot; and
&quot;#include&quot;, but can lead to unexpected, even
mistaken, results due to Fortran s source file format. It is
recommended that use of the C preprocessor be limited to
&quot;#include&quot; and, in conjunction with
&quot;#define&quot;, only &quot;#if&quot; and related
directives, thus avoiding in- line macro expansion entirely.
This recommendation applies especially when using the
traditional fixed source form. With free source form, fewer
unexpected transformations are likely to happen, but use of
constructs such as Hollerith and character constants can
nevertheless present problems, especially when these are
continued across multiple source lines. These problems
result, primarily, from differences between the way such
constants are interpreted by the C preprocessor and by a
Fortran compiler.</p>

<p>Another example of a problem that results from using the
C preprocessor is that a Fortran comment line that happens
to contain any characters interesting to the C preprocessor,
such as a backslash at the end of the line, is not
recognized by the preprocessor as a comment line, so instead
of being passed through raw, the line is edited according to
the rules for the preprocessor. For example, the backslash
at the end of the line is removed, along with the subsequent
newline, resulting in the next line being effectively
commented out---unfortunate if that line is a non-comment
line of important code!</p>

<p>Note: The -traditional and -undef flags are supplied to
cpp by default, to help avoid unpleasant surprises.</p>

<p>This means that ANSI C preprocessor features (such as
the # operator) aren t available, and only variables in the
C reserved namespace (generally, names with a leading
underscore) are liable to substitution by C predefines.
Thus, if you want to do system-specific tests, use, for
example, #ifdef __linux__ rather than #ifdef linux. Use the
-v option to see exactly how the preprocessor is
invoked.</p>

<p>Unfortunately, the -traditional flag will not avoid an
error from anything that cpp sees as an unterminated C
comment, such as:</p>

<p>C Some Fortran compilers accept /* as starting C an
inline comment.</p>

<p>The following options that affect overall processing are
recognized by the g77 and gcc commands in a GNU Fortran
installation:</p>

<p>-fversion Ensure that the g77 version of the compiler
phase is reported, if run, and, starting in &quot;egcs&quot;
version 1.1, that internal consistency checks in the f771
program are run.</p>

<p>This option is supplied automatically when -v or
--verbose is specified as a command-line option for g77 or
gcc and when the resulting commands compile Fortran source
files.</p>

<p>In GCC 3.1, this is changed back to the behavior gcc
displays for .c files.</p>

<p>-fset-g77-defaults Version info: This option was
obsolete as of &quot;egcs&quot; version 1.1. The effect is
instead achieved by the &quot;lang_init_options&quot;
routine in gcc/gcc/f/com.c.</p>

<p>Set up whatever gcc options are to apply to Fortran
compilations, and avoid running internal consistency checks
that might take some time.</p>

<p>This option is supplied automatically when compiling
Fortran code via the g77 or gcc command. The description of
this option is provided so that users seeing it in the
output of, say, g77 -v understand why it is there.</p>

<p>Also, developers who run &quot;f771&quot; directly might
want to specify it by hand to get the same defaults as they
would running &quot;f771&quot; via g77 or gcc However, such
developers should, after linking a new &quot;f771&quot;
executable, invoke it without this option once, e.g. via
&quot;./f771 -quiet &lt; /dev/null&quot;, to ensure that
they have not introduced any internal inconsistencies (such
as in the table of intrinsics) before proceeding---g77 will
crash with a diagnostic if it detects an inconsistency.</p>

<p>-fno-silent Print (to &quot;stderr&quot;) the names of
the program units as they are compiled, in a form similar to
that used by popular UNIX f77 implementations and f2c</p>

<p>Shorthand Options The following options serve as
shorthand for other options accepted by the compiler:</p>

<p>-fugly Note: This option is no longer supported. The
information, below, is provided to aid in the conversion of
old scripts.</p>

<p>Specify that certain ugly constructs are to be quietly
accepted. Same as:</p>

<p>-fugly-args -fugly-assign -fugly-assumed -fugly-comma
-fugly-complex -fugly-init -fugly-logint</p>

<p>These constructs are considered inappropriate to use in
new or well-maintained portable Fortran code, but widely
used in old code.</p>

<p>-fno-ugly Specify that all ugly constructs are to be
noisily rejected. Same as:</p>

<p>-fno-ugly-args -fno-ugly-assign -fno-ugly-assumed
-fno-ugly-comma -fno-ugly-complex -fno-ugly-init
-fno-ugly-logint</p>

<p>-ff66 Specify that the program is written in idiomatic
FORTRAN 66. Same as -fonetrip -fugly-assumed.</p>

<p>The -fno-f66 option is the inverse of -ff66. As such, it
is the same as -fno-onetrip -fno-ugly-assumed.</p>

<p>The meaning of this option is likely to be refined as
future versions of g77 provide more compatibility with other
existing and obsolete Fortran implementations.</p>

<p>-ff77 Specify that the program is written in idiomatic
UNIX FORTRAN 77 and/or the dialect accepted by the f2c
product. Same as -fbackslash -fno-typeless-boz.</p>

<p>The meaning of this option is likely to be refined as
future versions of g77 provide more compatibility with other
existing and obsolete Fortran implementations.</p>

<p>-fno-f77 The -fno-f77 option is not the inverse of
-ff77. It specifies that the program is not written in
idiomatic UNIX FORTRAN 77 or f2c but in a more widely
portable dialect. -fno-f77 is the same as
-fno-backslash.</p>

<p>The meaning of this option is likely to be refined as
future versions of g77 provide more compatibility with other
existing and obsolete Fortran implementations.</p>

<p>Options Controlling Fortran Dialect The following
options control the dialect of Fortran that the compiler
accepts:</p>

<p>-ffree-form -fno-fixed-form Specify that the source file
is written in free form (introduced in Fortran 90) instead
of the more-traditional fixed form.</p>

<p>-ff90 Allow certain Fortran-90 constructs.</p>

<p>This option controls whether certain Fortran 90
constructs are recognized. (Other Fortran 90 constructs
might or might not be recognized depending on other options
such as -fvxt, -ff90-intrinsics-enable, and the current
level of support for Fortran 90.)</p>

<p>-fvxt Specify the treatment of certain constructs that
have different meanings depending on whether the code is
written in GNU Fortran (based on FORTRAN 77 and akin to
Fortran 90) or VXT Fortran (more like VAX FORTRAN).</p>

<p>The default is -fno-vxt. -fvxt specifies that the VXT
Fortran interpretations for those constructs are to be
chosen.</p>

<p>-fdollar-ok Allow $ as a valid character in a symbol
name.</p>

<p>-fno-backslash Specify that is not to be specially
interpreted in character and Hollerith constants a la C and
many UNIX Fortran compilers.</p>

<p>For example, with -fbackslash in effect, nB specifies
three characters, with the second one being newline. With
-fno-backslash, it specifies four characters, A, n, and
B.</p>

<p>Note that g77 implements a fairly general form of
backslash processing that is incompatible with the narrower
forms supported by some other compilers. For example,003Bis
a three- character string in g77 whereas other compilers
that support backslash might not support the
three-octal-digit form, and thus treat that string as longer
than three characters.</p>

<p>-fno-ugly-args Disallow passing Hollerith and typeless
constants as actual arguments (for example, CALL
FOO(4HABCD)).</p>

<p>-fugly-assign Use the same storage for a given variable
regardless of whether it is used to hold an
assigned-statement label (as in ASSIGN 10 TO I) or used to
hold numeric data (as in I = 3).</p>

<p>-fugly-assumed Assume any dummy array with a final
dimension specified as 1 is really an assumed-size array, as
if * had been specified for the final dimension instead of
1.</p>

<p>For example, DIMENSION X(1) is treated as if it had read
DIMENSION X(*).</p>

<p>-fugly-comma In an external-procedure invocation, treat
a trailing comma in the argument list as specification of a
trailing null argument, and treat an empty argument list as
specification of a single null argument.</p>

<p>For example, CALL FOO(,) is treated as CALL FOO(%VAL(0),
%VAL(0)). That is, two null arguments are specified by the
procedure call when -fugly-comma is in force. And F = FUNC()
is treated as F = FUNC(%VAL(0)).</p>

<p>The default behavior, -fno-ugly-comma, is to ignore a
single trailing comma in an argument list. So, by default,
CALL FOO(X,) is treated exactly the same as CALL FOO(X).</p>

<p>-fugly-complex Do not complain about REAL(expr) or
AIMAG(expr) when expr is a &quot;COMPLEX&quot; type other
than &quot;COMPLEX(KIND=1)&quot;---usually this is used to
permit &quot;COMPLEX(KIND=2)&quot; (&quot;DOUBLE
COMPLEX&quot;) operands.</p>

<p>The -ff90 option controls the interpretation of this
construct.</p>

<p>-fno-ugly-init Disallow use of Hollerith and typeless
constants as initial values (in &quot;PARAMETER&quot; and
&quot;DATA&quot; statements), and use of character constants
to initialize numeric types and vice versa.</p>

<p>For example, DATA I/ F /, CHRVAR/65/, J/4HABCD/ is
disallowed by -fno-ugly-init.</p>

<p>-fugly-logint Treat &quot;INTEGER&quot; and
&quot;LOGICAL&quot; variables and expressions as potential
stand-ins for each other.</p>

<p>For example, automatic conversion between
&quot;INTEGER&quot; and &quot;LOGICAL&quot; is enabled, for
many contexts, via this option.</p>

<p>-fonetrip Executable iterative &quot;DO&quot; loops are
to be executed at least once each time they are reached.</p>

<p>ANSI FORTRAN 77 and more recent versions of the Fortran
standard specify that the body of an iterative
&quot;DO&quot; loop is not executed if the number of
iterations calculated from the parameters of the loop is
less than 1. (For example, DO 10 I = 1, 0.) Such a loop is
called a zero-trip loop.</p>

<p>Prior to ANSI FORTRAN 77, many compilers implemented
&quot;DO&quot; loops such that the body of a loop would be
executed at least once, even if the iteration count was
zero. Fortran code written assuming this behavior is said to
require one-trip loops. For example, some code written to
the FORTRAN 66 standard expects this behavior from its
&quot;DO&quot; loops, although that standard did not specify
this behavior.</p>

<p>The -fonetrip option specifies that the source file(s)
being compiled require one-trip loops.</p>

<p>This option affects only those loops specified by the
(iterative) &quot;DO&quot; statement and by
implied-&quot;DO&quot; lists in I/O statements. Loops
specified by implied-&quot;DO&quot; lists in
&quot;DATA&quot; and specification (non- executable)
statements are not affected.</p>

<p>-ftypeless-boz Specifies that prefix-radix non-decimal
constants, such as ABC, are typeless instead of
&quot;INTEGER(KIND=1)&quot;.</p>

<p>You can test for yourself whether a particular compiler
treats the prefix form as &quot;INTEGER(KIND=1)&quot; or
typeless by running the following program:</p>

<p>EQUIVALENCE (I, R) R = Z&rsquo;ABCD1234&rsquo; J =
Z&rsquo;ABCD1234&rsquo; IF (J .EQ. I) PRINT *, &rsquo;Prefix
form is TYPELESS&rsquo; IF (J .NE. I) PRINT *, &rsquo;Prefix
form is INTEGER&rsquo; END</p>

<p>Reports indicate that many compilers process this form
as &quot;INTEGER(KIND=1)&quot;, though a few as typeless,
and at least one based on a command-line option specifying
some kind of compatibility.</p>

<p>-fintrin-case-initcap -fintrin-case-upper
-fintrin-case-lower -fintrin-case-any Specify expected case
for intrinsic names. -fintrin-case-lower is the default.</p>

<p>-fmatch-case-initcap -fmatch-case-upper
-fmatch-case-lower -fmatch-case-any Specify expected case
for keywords. -fmatch-case-lower is the default.</p>

<p>-fsource-case-upper -fsource-case-lower
-fsource-case-preserve Specify whether source text other
than character and Hollerith constants is to be translated
to uppercase, to lowercase, or preserved as is.
-fsource-case-lower is the default.</p>

<p>-fsymbol-case-initcap -fsymbol-case-upper
-fsymbol-case-lower -fsymbol-case-any Specify valid cases
for user-defined symbol names. -fsymbol-case-any is the
default.</p>

<p>-fcase-strict-upper Same as -fintrin-case-upper
-fmatch-case-upper -fsource-case-preserve
-fsymbol-case-upper. (Requires all pertinent source to be in
uppercase.)</p>

<p>-fcase-strict-lower Same as -fintrin-case-lower
-fmatch-case-lower -fsource-case-preserve
-fsymbol-case-lower. (Requires all pertinent source to be in
lowercase.)</p>

<p>-fcase-initcap Same as -fintrin-case-initcap
-fmatch-case-initcap -fsource-case-preserve
-fsymbol-case-initcap. (Requires all pertinent source to be
in initial capitals, as in Print *,SqRt(Value).)</p>

<p>-fcase-upper Same as -fintrin-case-any -fmatch-case-any
-fsource-case-upper -fsymbol-case-any. (Maps all pertinent
source to uppercase.)</p>

<p>-fcase-lower Same as -fintrin-case-any -fmatch-case-any
-fsource-case-lower -fsymbol-case-any. (Maps all pertinent
source to lowercase.)</p>

<p>-fcase-preserve Same as -fintrin-case-any
-fmatch-case-any -fsource-case-preserve -fsymbol-case-any.
(Preserves all case in user-defined symbols, while allowing
any-case matching of intrinsics and keywords. For example,
call Foo(i,I) would pass two different variables named i and
I to a procedure named Foo.)</p>

<p>-fbadu77-intrinsics-delete -fbadu77-intrinsics-hide
-fbadu77-intrinsics-disable -fbadu77-intrinsics-enable
Specify status of UNIX intrinsics having inappropriate
forms. -fbadu77-intrinsics-enable is the default.</p>

<p>-ff2c-intrinsics-delete -ff2c-intrinsics-hide
-ff2c-intrinsics-disable -ff2c-intrinsics-enable Specify
status of f2c-specific intrinsics. -ff2c-intrinsics-enable
is the default.</p>

<p>-ff90-intrinsics-delete -ff90-intrinsics-hide
-ff90-intrinsics-disable -ff90-intrinsics-enable Specify
status of F90-specific intrinsics. -ff90-intrinsics-enable
is the default.</p>

<p>-fgnu-intrinsics-delete -fgnu-intrinsics-hide
-fgnu-intrinsics-disable -fgnu-intrinsics-enable Specify
status of Digitals COMPLEX-related intrinsics.
-fgnu-intrinsics-enable is the default.</p>

<p>-fmil-intrinsics-delete -fmil-intrinsics-hide
-fmil-intrinsics-disable -fmil-intrinsics-enable Specify
status of MIL-STD-1753-specific intrinsics.
-fmil-intrinsics-enable is the default.</p>

<p>-funix-intrinsics-delete -funix-intrinsics-hide
-funix-intrinsics-disable -funix-intrinsics-enable Specify
status of UNIX intrinsics. -funix-intrinsics-enable is the
default.</p>

<p>-fvxt-intrinsics-delete -fvxt-intrinsics-hide
-fvxt-intrinsics-disable -fvxt-intrinsics-enable Specify
status of VXT intrinsics. -fvxt-intrinsics-enable is the
default.</p>

<p>-ffixed-line-length-n Set column after which characters
are ignored in typical fixed-form lines in the source file,
and through which spaces are assumed (as if padded to that
length) after the ends of short fixed-form lines.</p>

<p>Popular values for n include 72 (the standard and the
default), 80 (card image), and 132 (corresponds to
extended-source options in some popular compilers). n may be
none, meaning that the entire line is meaningful and that
continued character constants never have implicit spaces
appended to them to fill out the line. -ffixed-line-length-0
means the same thing as -ffixed-line-length-none.</p>

<p>Options to Request or Suppress Warnings Warnings are
diagnostic messages that report constructions which are not
inherently erroneous but which are risky or suggest there
might have been an error.</p>

<p>You can request many specific warnings with options
beginning -W, for example -Wimplicit to request warnings on
implicit declarations. Each of these specific warning
options also has a negative form beginning -Wno- to turn off
warnings; for example, -Wno-implicit. This manual lists only
one of the two forms, whichever is not the default.</p>

<p>These options control the amount and kinds of warnings
produced by GNU Fortran:</p>

<p>-fsyntax-only Check the code for syntax errors, but dont
do anything beyond that.</p>

<p>-pedantic Issue warnings for uses of extensions to ANSI
FORTRAN 77. -pedantic also applies to C-language constructs
where they occur in GNU Fortran source files, such as use of
e in a character constant within a directive like
#include.</p>

<p>Valid ANSI FORTRAN 77 programs should compile properly
with or without this option. However, without this option,
certain GNU extensions and traditional Fortran features are
supported as well. With this option, many of them are
rejected.</p>

<p>Some users try to use -pedantic to check programs for
strict ANSI conformance. They soon find that it does not do
quite what they want---it finds some non-ANSI practices, but
not all. However, improvements to g77 in this area are
welcome.</p>

<p>-pedantic-errors Like -pedantic, except that errors are
produced rather than warnings.</p>

<p>-fpedantic Like -pedantic, but applies only to Fortran
constructs.</p>

<p>-w Inhibit all warning messages.</p>

<p>-Wno-globals Inhibit warnings about use of a name as
both a global name (a subroutine, function, or block data
program unit, or a common block) and implicitly as the name
of an intrinsic in a source file.</p>

<p>Also inhibit warnings about inconsistent invocations
and/or definitions of global procedures (function and
subroutines). Such inconsistencies include different numbers
of arguments and different types of arguments.</p>

<p>-Wimplicit Warn whenever a variable, array, or function
is implicitly declared. Has an effect similar to using the
&quot;IMPLICIT NONE&quot; statement in every program unit.
(Some Fortran compilers provide this feature by an option
named -u or /WARNINGS=DECLARATIONS.)</p>

<p>-Wunused Warn whenever a variable is unused aside from
its declaration.</p>

<p>-Wuninitialized Warn whenever an automatic variable is
used without first being initialized.</p>

<p>These warnings are possible only in optimizing
compilation, because they require data-flow information that
is computed only when optimizing. If you dont specify -O,
you simply wont get these warnings.</p>

<p>These warnings occur only for variables that are
candidates for register allocation. Therefore, they do not
occur for a variable whose address is taken, or whose size
is other than 1, 2, 4 or 8 bytes. Also, they do not occur
for arrays, even when they are in registers.</p>

<p>Note that there might be no warning about a variable
that is used only to compute a value that itself is never
used, because such computations may be deleted by data-flow
analysis before the warnings are printed.</p>

<p>These warnings are made optional because GNU Fortran is
not smart enough to see all the reasons why the code might
be correct despite appearing to have an error. Here is one
example of how this can happen:</p>

<p>SUBROUTINE DISPAT(J) IF (J.EQ.1) I=1 IF (J.EQ.2) I=4 IF
(J.EQ.3) I=5 CALL FOO(I) END</p>

<p>If the value of &quot;J&quot; is always 1, 2 or 3, then
&quot;I&quot; is always initialized, but GNU Fortran doesnt
know this. Here is another common case:</p>

<p>SUBROUTINE MAYBE(FLAG) LOGICAL FLAG IF (FLAG) VALUE =
9.4 ... IF (FLAG) PRINT *, VALUE END</p>

<p>This has no bug because &quot;VALUE&quot; is used only
if it is set.</p>

<p>-Wall The -Wunused and -Wuninitialized options combined.
These are all the options which pertain to usage that we
recommend avoiding and that we believe is easy to avoid. (As
more warnings are added to g77 some might be added to the
list enabled by -Wall.)</p>

<p>The remaining -W... options are not implied by -Wall
because they warn about constructions that we consider
reasonable to use, on occasion, in clean programs.</p>

<p>-Wsurprising Warn about suspicious constructs that are
interpreted by the compiler in a way that might well be
surprising to someone reading the code. These differences
can result in subtle, compiler- dependent (even
machine-dependent) behavioral differences. The constructs
warned about include:</p>

<p>&middot; Expressions having two arithmetic operators in
a row, such as X*-Y. Such a construct is nonstandard, and
can produce unexpected results in more complicated
situations such as X**-Y*Z. g77 along with many other
compilers, interprets this example differently than many
programmers, and a few other compilers. Specifically, g77
interprets X**-Y*Z as (X**(-Y))*Z, while others might think
it should be interpreted as X**(-(Y*Z)).</p>

<p>A revealing example is the constant expression 2**-2*1.,
which g77 evaluates to .25, while others might evaluate it
to 0., the difference resulting from the way precedence
affects type promotion.</p>

<p>(The -fpedantic option also warns about expressions
having two arithmetic operators in a row.)</p>

<p>&middot; Expressions with a unary minus followed by an
operand and then a binary operator other than plus or minus.
For example, -2**2 produces a warning, because the
precedence is -(2**2), yielding -4, not (-2)**2, which
yields 4, and which might represent what a programmer
expects.</p>

<p>An example of an expression producing different results
in a surprising way is -I*S, where I holds the value
-2147483648 and S holds 0.5. On many systems, negating I
results in the same value, not a positive number, because it
is already the lower bound of what an
&quot;INTEGER(KIND=1)&quot; variable can hold. So, the
expression evaluates to a positive number, while the
expected interpretation, (-I)*S, would evaluate to a
negative number.</p>

<p>Even cases such as -I*J produce warnings, even though,
in most configurations and situations, there is no
computational difference between the results of the two
interpretations---the purpose of this warning is to warn
about differing interpretations and encourage a better style
of coding, not to identify only those places where bugs
might exist in the users code.</p>

<p>&middot; &quot;DO&quot; loops with &quot;DO&quot;
variables that are not of integral type---that is, using
&quot;REAL&quot; variables as loop control variables.
Although such loops can be written to work in the obvious
way, the way g77 is required by the Fortran standard to
interpret such code is likely to be quite different from the
way many programmers expect. (This is true of all
&quot;DO&quot; loops, but the differences are pronounced for
non-integral loop control variables.)</p>

<p>-Werror Make all warnings into errors.</p>

<p>-W Turns on extra warnings and, if optimization is
specified via -O, the -Wuninitialized option. (This might
change in future versions of g77</p>

<p>Extra warnings are issued for:</p>

<p>&middot; Unused parameters to a procedure (when -Wunused
also is specified).</p>

<p>&middot; Overflows involving floating-point constants
(not available for certain configurations).</p>

<p>Some of these have no effect when compiling programs
written in Fortran:</p>

<p>-Wcomment -Wformat -Wparentheses -Wswitch
-Wswitch-default -Wswitch-enum -Wtraditional -Wshadow
-Wid-clash-len -Wlarger-than-len -Wconversion
-Waggregate-return -Wredundant-decls These options all could
have some relevant meaning for GNU Fortran programs, but are
not yet supported.</p>

<p>Options for Debugging Your Program or GNU Fortran GNU
Fortran has various special options that are used for
debugging either your program or g77</p>

<p>-g Produce debugging information in the operating
systems native format (stabs, COFF, XCOFF, or DWARF). GDB
can work with this debugging information.</p>

<p>A sample debugging session looks like this (note the use
of the breakpoint):</p>

<p>$ cat gdb.f PROGRAM PROG DIMENSION A(10) DATA A
/1.,2.,3.,4.,5.,6.,7.,8.,9.,10./ A(5) = 4. PRINT*,A END $
g77 -g -O gdb.f $ gdb a.out ... (gdb) break MAIN__
Breakpoint 1 at 0x8048e96: file gdb.f, line 4. (gdb) run
Starting program: /home/toon/g77-bugs/./a.out Breakpoint 1,
MAIN__ () at gdb.f:4 4 A(5) = 4. Current language: auto;
currently fortran (gdb) print a(5) $1 = 5 (gdb) step 5
PRINT*,A (gdb) print a(5) $2 = 4 ...</p>

<p>One could also add the setting of the breakpoint and the
first run command to the file .gdbinit in the current
directory, to simplify the debugging session.</p>

<p>Options That Control Optimization Most Fortran users
will want to use no optimization when developing and testing
programs, and use -O or -O2 when compiling programs for
late- cycle testing and for production use. However, note
that certain diagnostics---such as for uninitialized
variables---depend on the flow analysis done by -O, i.e. you
must use -O or -O2 to get such diagnostics.</p>

<p>The following flags have particular applicability when
compiling Fortran programs:</p>

<p>-malign-double (Intel x86 architecture only.)</p>

<p>Noticeably improves performance of g77 programs making
heavy use of &quot;REAL(KIND=2)&quot; (&quot;DOUBLE
PRECISION&quot;) data on some systems. In particular,
systems using Pentium, Pentium Pro, 586, and 686
implementations of the i386 architecture execute programs
faster when &quot;REAL(KIND=2)&quot; (&quot;DOUBLE
PRECISION&quot;) data are aligned on 64-bit boundaries in
memory.</p>

<p>This option can, at least, make benchmark results more
consistent across various system configurations, versions of
the program, and data sets.</p>

<p>Note: The warning in the gcc documentation about this
option does not apply, generally speaking, to Fortran code
compiled by g77</p>

<p>Also also note: The negative form of -malign-double is
-mno-align-double, not -benign-double.</p>

<p>-ffloat-store Might help a Fortran program that depends
on exact IEEE conformance on some machines, but might slow
down a program that doesnt.</p>

<p>This option is effective when the floating-point unit is
set to work in IEEE 854 extended precision---as it typically
is on x86 and m68k GNU systems---rather than IEEE 754 double
precision. -ffloat-store tries to remove the extra precision
by spilling data from floating-point registers into memory
and this typically involves a big performance hit. However,
it doesn t affect intermediate results, so that it is only
partially effective. Excess precision is avoided in code
like:</p>

<p>a = b + c d = a * e</p>

<p>but not in code like:</p>

<p>d = (b + c) * e</p>

<p>For another, potentially better, way of controlling the
precision, see Floating-point precision.</p>

<p>-fforce-mem -fforce-addr Might improve optimization of
loops.</p>

<p>-fno-inline Dont compile statement functions inline.
Might reduce the size of a program unit---which might be at
expense of some speed (though it should compile faster).
Note that if you are not optimizing, no functions can be
expanded inline.</p>

<p>-ffast-math Might allow some programs designed to not be
too dependent on IEEE behavior for floating-point to run
faster, or die trying. Sets -funsafe-math-optimizations,
-ffinite-math-only, and -fno-trapping-math.</p>

<p>-funsafe-math-optimizations Allow optimizations that may
be give incorrect results for certain IEEE inputs.</p>

<p>-ffinite-math-only Allow optimizations for
floating-point arithmetic that assume that arguments and
results are not NaNs or +-Infs.</p>

<p>This option should never be turned on by any -O option
since it can result in incorrect output for programs which
depend on an exact implementation of IEEE or ISO
rules/specifications.</p>

<p>The default is -fno-finite-math-only.</p>

<p>-fno-trapping-math Allow the compiler to assume that
floating-point arithmetic will not generate traps on any
inputs. This is useful, for example, when running a program
using IEEE &quot;non-stop&quot; floating-point
arithmetic.</p>

<p>-fstrength-reduce Might make some loops run faster.</p>

<p>-frerun-cse-after-loop -fexpensive-optimizations
-fdelayed-branch -fschedule-insns -fschedule-insns2
-fcaller-saves Might improve performance on some code.</p>

<p>-funroll-loops Typically improves performance on code
using iterative &quot;DO&quot; loops by unrolling them and
is probably generally appropriate for Fortran, though it is
not turned on at any optimization level. Note that outer
loop unrolling isnt done specifically; decisions about
whether to unroll a loop are made on the basis of its
instruction count.</p>

<p>Also, no loop discovery[1] is done, so only loops
written with &quot;DO&quot; benefit from loop optimizations,
including---but not limited to---unrolling. Loops written
with &quot;IF&quot; and &quot;GOTO&quot; are not currently
recognized as such. This option unrolls only iterative
&quot;DO&quot; loops, not &quot;DO WHILE&quot; loops.</p>

<p>-funroll-all-loops Probably improves performance on code
using &quot;DO WHILE&quot; loops by unrolling them in
addition to iterative &quot;DO&quot; loops. In the absence
of &quot;DO WHILE&quot;, this option is equivalent to
-funroll-loops but possibly slower.</p>

<p>-fno-move-all-movables -fno-reduce-all-givs
-fno-rerun-loop-opt In general, the optimizations enabled
with these options will lead to faster code being generated
by GNU Fortran; hence they are enabled by default when
issuing the g77 command.</p>

<p>-fmove-all-movables and -freduce-all-givs will enable
loop optimization to move all loop-invariant index
computations in nested loops over multi-rank array dummy
arguments out of these loops.</p>

<p>-frerun-loop-opt will move offset calculations resulting
from the fact that Fortran arrays by default have a lower
bound of 1 out of the loops.</p>

<p>These three options are intended to be removed someday,
once loop optimization is sufficiently advanced to perform
all those transformations without help from these
options.</p>

<p>Options Controlling the Preprocessor These options
control the C preprocessor, which is run on each C source
file before actual compilation.</p>

<p>Some of these options also affect how g77 processes the
&quot;INCLUDE&quot; directive. Since this directive is
processed even when preprocessing is not requested, it is
not described in this section.</p>

<p>However, the &quot;INCLUDE&quot; directive does not
apply preprocessing to the contents of the included file
itself.</p>

<p>Therefore, any file that contains preprocessor
directives (such as &quot;#include&quot;,
&quot;#define&quot;, and &quot;#if&quot;) must be included
via the &quot;#include&quot; directive, not via the
&quot;INCLUDE&quot; directive. Therefore, any file
containing preprocessor directives, if included, is
necessarily included by a file that itself contains
preprocessor directives.</p>

<p>Options for Directory Search These options affect how
the cpp preprocessor searches for files specified via the
&quot;#include&quot; directive. Therefore, when compiling
Fortran programs, they are meaningful when the preprocessor
is used.</p>

<p>Some of these options also affect how g77 searches for
files specified via the &quot;INCLUDE&quot; directive,
although files included by that directive are not,
themselves, preprocessed. These options are:</p>

<p>-I- -Idir These affect interpretation of the
&quot;INCLUDE&quot; directive (as well as of the
&quot;#include&quot; directive of the cpp preprocessor).</p>

<p>Note that -Idir must be specified without any spaces
between -I and the directory name---that is, -Ifoo/bar is
valid, but -I foo/bar is rejected by the g77 compiler
(though the preprocessor supports the latter form). Also
note that the general behavior of -I and &quot;INCLUDE&quot;
is pretty much the same as of -I with &quot;#include&quot;
in the cpp preprocessor, with regard to looking for
header.gcc files and other such things.</p>

<p>Options for Code Generation Conventions These
machine-independent options control the interface
conventions used in code generation.</p>

<p>Most of them have both positive and negative forms; the
negative form of -ffoo would be -fno-foo. In the table
below, only one of the forms is listed---the one which is
not the default. You can figure out the other form by either
removing no- or adding it.</p>

<p>-fno-automatic Treat each program unit as if the
&quot;SAVE&quot; statement was specified for every local
variable and array referenced in it. Does not affect common
blocks. (Some Fortran compilers provide this option under
the name -static.)</p>

<p>-finit-local-zero Specify that variables and arrays that
are local to a program unit (not in a common block and not
passed as an argument) are to be initialized to binary
zeros.</p>

<p>Since there is a run-time penalty for initialization of
variables that are not given the &quot;SAVE&quot; attribute,
it might be a good idea to also use -fno-automatic with
-finit-local-zero.</p>

<p>-fno-f2c Do not generate code designed to be compatible
with code generated by f2c use the GNU calling conventions
instead.</p>

<p>The f2c calling conventions require functions that
return type &quot;REAL(KIND=1)&quot; to actually return the
C type &quot;double&quot;, and functions that return type
&quot;COMPLEX&quot; to return the values via an extra
argument in the calling sequence that points to where to
store the return value. Under the GNU calling conventions,
such functions simply return their results as they would in
GNU C---&quot;REAL(KIND=1)&quot; functions return the C type
&quot;float&quot;, and &quot;COMPLEX&quot; functions return
the GNU C type &quot;complex&quot; (or its
&quot;struct&quot; equivalent).</p>

<p>This does not affect the generation of code that
interfaces with the &quot;libg2c&quot; library.</p>

<p>However, because the &quot;libg2c&quot; library uses f2c
calling conventions, g77 rejects attempts to pass intrinsics
implemented by routines in this library as actual arguments
when -fno-f2c is used, to avoid bugs when they are actually
called by code expecting the GNU calling conventions to
work.</p>

<p>For example, INTRINSIC ABS;CALL FOO(ABS) is rejected
when -fno-f2c is in force. (Future versions of the g77
run-time library might offer routines that provide
GNU-callable versions of the routines that implement the f2c
intrinsics that may be passed as actual arguments, so that
valid programs need not be rejected when -fno-f2c is
used.)</p>

<p>Caution: If -fno-f2c is used when compiling any source
file used in a program, it must be used when compiling all
Fortran source files used in that program.</p>

<p>-ff2c-library Specify that use of &quot;libg2c&quot; (or
the original &quot;libf2c&quot;) is required. This is the
default for the current version of g77</p>

<p>Currently it is not valid to specify -fno-f2c-library.
This option is provided so users can specify it in shell
scripts that build programs and libraries that require the
&quot;libf2c&quot; library, even when being compiled by
future versions of g77 that might otherwise default to
generating code for an incompatible library.</p>

<p>-fno-underscoring Do not transform names of entities
specified in the Fortran source file by appending
underscores to them.</p>

<p>With -funderscoring in effect, g77 appends two
underscores to names with underscores and one underscore to
external names with no underscores. (g77 also appends two
underscores to internal names with underscores to avoid
naming collisions with external names. The
-fno-second-underscore option disables appending of the
second underscore in all cases.)</p>

<p>This is done to ensure compatibility with code produced
by many UNIX Fortran compilers, including f2c which perform
the same transformations.</p>

<p>Use of -fno-underscoring is not recommended unless you
are experimenting with issues such as integration of (GNU)
Fortran into existing system environments (vis-a-vis
existing libraries, tools, and so on).</p>

<p>For example, with -funderscoring, and assuming other
defaults like -fcase-lower and that j() and max_count() are
external functions while my_var and lvar are local
variables, a statement like</p>

<p>I = J() + MAX_COUNT (MY_VAR, LVAR)</p>

<p>is implemented as something akin to:</p>

<p>i = j_() + max_count__(&amp;my_var__, &amp;lvar);</p>

<p>With -fno-underscoring, the same statement is
implemented as:</p>

<p>i = j() + max_count(&amp;my_var, &amp;lvar);</p>

<p>Use of -fno-underscoring allows direct specification of
user- defined names while debugging and when interfacing g77
code with other languages.</p>

<p>Note that just because the names match does not mean
that the interface implemented by g77 for an external name
matches the interface implemented by some other language for
that same name. That is, getting code produced by g77 to
link to code produced by some other compiler using this or
any other method can be only a small part of the overall
solution---getting the code generated by both compilers to
agree on issues other than naming can require significant
effort, and, unlike naming disagreements, linkers normally
cannot detect disagreements in these other areas.</p>

<p>Also, note that with -fno-underscoring, the lack of
appended underscores introduces the very real possibility
that a user- defined external name will conflict with a name
in a system library, which could make finding
unresolved-reference bugs quite difficult in some
cases---they might occur at program run time, and show up
only as buggy behavior at run time.</p>

<p>In future versions of g77 we hope to improve naming and
linking issues so that debugging always involves using the
names as they appear in the source, even if the names as
seen by the linker are mangled to prevent accidental linking
between procedures with incompatible interfaces.</p>

<p>-fno-second-underscore Do not append a second underscore
to names of entities specified in the Fortran source
file.</p>

<p>This option has no effect if -fno-underscoring is in
effect.</p>

<p>Otherwise, with this option, an external name such as
MAX_COUNT is implemented as a reference to the link-time
external symbol max_count_, instead of max_count__.</p>

<p>-fno-ident Ignore the #ident directive.</p>

<p>-fzeros Treat initial values of zero as if they were any
other value.</p>

<p>As of version 0.5.18, g77 normally treats
&quot;DATA&quot; and other statements that are used to
specify initial values of zero for variables and arrays as
if no values were actually specified, in the sense that no
diagnostics regarding multiple initializations are
produced.</p>

<p>This is done to speed up compiling of programs that
initialize large arrays to zeros.</p>

<p>Use -fzeros to revert to the simpler, slower behavior
that can catch multiple initializations by keeping track of
all initializations, zero or otherwise.</p>

<p>Caution: Future versions of g77 might disregard this
option (and its negative form, the default) or interpret it
somewhat differently. The interpretation changes will affect
only non- standard programs; standard-conforming programs
should not be affected.</p>

<p>-femulate-complex Implement &quot;COMPLEX&quot;
arithmetic via emulation, instead of using the facilities of
the gcc back end that provide direct support of
&quot;complex&quot; arithmetic.</p>

<p>(gcc had some bugs in its back-end support for
&quot;complex&quot; arithmetic, due primarily to the support
not being completed as of version 2.8.1 and &quot;egcs&quot;
1.1.2.)</p>

<p>Use -femulate-complex if you suspect code-generation
bugs, or experience compiler crashes, that might result from
g77 using the &quot;COMPLEX&quot; support in the gcc back
end. If using that option fixes the bugs or crashes you are
seeing, that indicates a likely g77 bugs (though, all
compiler crashes are considered bugs), so, please report it.
(Note that the known bugs, now believed fixed, produced
compiler crashes rather than causing the generation of
incorrect code.)</p>

<p>Use of this option should not affect how Fortran code
compiled by g77 works in terms of its interfaces to other
code, e.g. that compiled by f2c</p>

<p>As of GCC version 3.0, this option is not necessary
anymore.</p>

<p>Caution: Future versions of g77 might ignore both forms
of this option.</p>

<p>-falias-check -fargument-alias -fargument-noalias
-fno-argument-noalias-global Version info: These options are
not supported by versions of g77 based on gcc version
2.8.</p>

<p>These options specify to what degree aliasing (overlap)
is permitted between arguments (passed as pointers) and
&quot;COMMON&quot; (external, or public) storage.</p>

<p>The default for Fortran code, as mandated by the FORTRAN
77 and Fortran 90 standards, is -fargument-noalias-global.
The default for code written in the C language family is
-fargument-alias.</p>

<p>Note that, on some systems, compiling with -fforce-addr
in effect can produce more optimal code when the default
aliasing options are in effect (and when optimization is
enabled).</p>

<p>-fno-globals Disable diagnostics about inter-procedural
analysis problems, such as disagreements about the type of a
function or a procedures argument, that might cause a
compiler crash when attempting to inline a reference to a
procedure within a program unit. (The diagnostics themselves
are still produced, but as warnings, unless -Wno-globals is
specified, in which case no relevant diagnostics are
produced.)</p>

<p>Further, this option disables such inlining, to avoid
compiler crashes resulting from incorrect code that would
otherwise be diagnosed.</p>

<p>As such, this option might be quite useful when
compiling existing, working code that happens to have a few
bugs that do not generally show themselves, but which g77
diagnoses.</p>

<p>Use of this option therefore has the effect of
instructing g77 to behave more like it did up through
version 0.5.19.1, when it paid little or no attention to
disagreements between program units about a procedures type
and argument information, and when it performed no inlining
of procedures (except statement functions).</p>

<p>Without this option, g77 defaults to performing the
potentially inlining procedures as it started doing in
version 0.5.20, but as of version 0.5.21, it also diagnoses
disagreements that might cause such inlining to crash the
compiler as (fatal) errors, and warns about similar
disagreements that are currently believed to not likely to
result in the compiler later crashing or producing incorrect
code.</p>

<p>-fflatten-arrays Use back ends C-like constructs
(pointer plus offset) instead of its &quot;ARRAY_REF&quot;
construct to handle all array references.</p>

<p>Note: This option is not supported. It is intended for
use only by g77 developers, to evaluate code-generation
issues. It might be removed at any time.</p>

<p>-fbounds-check -ffortran-bounds-check Enable generation
of run-time checks for array subscripts and substring start
and end points against the (locally) declared minimum and
maximum values.</p>

<p>The current implementation uses the &quot;libf2c&quot;
library routine &quot;s_rnge&quot; to print the
diagnostic.</p>

<p>However, whereas f2c generates a single check per
reference for a multi-dimensional array, of the computed
offset against the valid offset range (0 through the size of
the array), g77 generates a single check per subscript
expression. This catches some cases of potential bugs that
f2c does not, such as references to below the beginning of
an assumed-size array.</p>

<p>g77 also generates checks for &quot;CHARACTER&quot;
substring references, something f2c currently does not
do.</p>

<p>Use the new -ffortran-bounds-check option to specify
bounds- checking for only the Fortran code you are
compiling, not necessarily for code written in other
languages.</p>

<p>Note: To provide more detailed information on the
offending subscript, g77 provides the &quot;libg2c&quot;
run-time library routine &quot;s_rnge&quot; with somewhat
differently-formatted information. Heres a sample
diagnostic:</p>

<p>Subscript out of range on file line 4, procedure
rnge.f/bf. Attempt to access the -6-th element of variable
b[subscript-2-of-2]. Aborted</p>

<p>The above message indicates that the offending source
line is line 4 of the file rnge.f, within the program unit
(or statement function) named bf. The offended array is
named b. The offended array dimension is the second for a
two-dimensional array, and the offending, computed subscript
expression was -6.</p>

<p>For a &quot;CHARACTER&quot; substring reference, the
second line has this appearance:</p>

<p>Attempt to access the 11-th element of variable
a[start-substring].</p>

<p>This indicates that the offended &quot;CHARACTER&quot;
variable or array is named a, the offended substring
position is the starting (leftmost) position, and the
offending substring expression is 11.</p>

<p>(Though the verbage of &quot;s_rnge&quot; is not ideal
for the purpose of the g77 compiler, the above information
should provide adequate diagnostic abilities to it
users.)</p>

<p>Some of these do not work when compiling programs
written in Fortran:</p>

<p>-fpcc-struct-return -freg-struct-return You should not
use these except strictly the same way as you used them to
build the version of &quot;libg2c&quot; with which you will
be linking all code compiled by g77 with the same
option.</p>

<p>-fshort-double This probably either has no effect on
Fortran programs, or makes them act loopy.</p>

<p>-fno-common Do not use this when compiling Fortran
programs, or there will be Trouble.</p>

<p>-fpack-struct This probably will break any calls to the
&quot;libg2c&quot; library, at the very least, even if it is
built with the same option.</p>

<p>ENVIRONMENT GNU Fortran currently does not make use of
any environment variables to control its operation above and
beyond those that affect the operation of gcc.</p>

<p>BUGS For instructions on reporting bugs, see
&lt;http://gcc.gnu.org/bugs.html&gt;. Use of the gccbug
script to report bugs is recommended.</p>

<p>FOOTNOTES 1. loop discovery refers to the process by
which a compiler, or indeed any reader of a program,
determines which portions of the program are more likely to
be executed repeatedly as it is being run. Such discovery
typically is done early when compiling using optimization
techniques, so the discovered loops get more attention---and
more run-time resources, such as registers---from the
compiler. It is easy to discover loops that are constructed
out of looping constructs in the language (such as Fortrans
&quot;DO&quot;). For some programs, discovering loops
constructed out of lower-level constructs (such as
&quot;IF&quot; and &quot;GOTO&quot;) can lead to generation
of more optimal code than otherwise.</p>

<p>SEE ALSO gpl(7), gfdl(7), fsf-funding(7), cpp(1),
gcov(1), gcc(1), as(1), ld(1), gdb(1), adb(1), dbx(1),
sdb(1) and the Info entries for gcc, cpp, g77, as, ld,
binutils and gdb.</p>

<p>AUTHOR See the Info entry for g77 for contributors to
GCC and G77.</p>

<p>COPYRIGHT Copyright (c) 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2004 Free Software Foundation, Inc.</p>

<p>Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation
License, Version 1.2 or any later version published by the
Free Software Foundation; with the Invariant Sections being
GNU General Public License and Funding Free Software , the
Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below). A copy of the
license is included in the gfdl(7) man page.</p>

<p>(a) The FSFs Front-Cover Text is:</p>

<p>A GNU Manual</p>

<p>(b) The FSFs Back-Cover Text is:</p>

<p>You have freedom to copy and modify this GNU Manual,
like GNU software. Copies published by the Free Software
Foundation raise funds for GNU development.</p>

<p>gcc-3.4.6 2010-06-28 G77(1)</p>
<hr>
</body>
</html>
