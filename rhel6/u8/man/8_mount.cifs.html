<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:23:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MOUNT.CIFS(8) System Administration tools
MOUNT.CIFS(8)</p>

<p>NAME mount.cifs - mount using the Common Internet File
System (CIFS)</p>

<p>SYNOPSIS mount.cifs {service} {mount-point} [-o
options]</p>

<p>DESCRIPTION This tool is part of the cifs-utils
suite.</p>

<p>mount.cifs mounts a Linux CIFS filesystem. It is usually
invoked indirectly by the mount(8) command when using the
&quot;-t cifs&quot; option. This command only works in
Linux, and the kernel must support the cifs filesystem. The
CIFS protocol is the successor to the SMB protocol and is
supported by most Windows servers and many other commercial
servers and Network Attached Storage appliances as well as
by the popular Open Source server Samba.</p>

<p>The mount.cifs utility attaches the UNC name (exported
network resource) specified as service (using //server/share
syntax, where &quot;server&quot; is the server name or IP
address and &quot;share&quot; is the name of the share) to
the local directory mount-point.</p>

<p>Options to mount.cifs are specified as a comma-separated
list of key=value pairs. It is possible to send options
other than those listed here, assuming that the cifs
filesystem kernel module (cifs.ko) supports them.
Unrecognized cifs mount options passed to the cifs vfs
kernel code will be logged to the kernel log.</p>

<p>mount.cifs causes the cifs vfs to launch a thread named
cifsd. After mounting it keeps running until the mounted
resource is unmounted (usually via the umount utility).</p>

<p>mount.cifs -V command displays the version of cifs mount
helper.</p>

<p>modinfo cifs command displays the version of cifs
module.</p>

<p>OPTIONS user=arg specifies the username to connect as.
If this is not given, then the environment variable USER is
used. This option can also take the form
&quot;user%password&quot; or &quot;workgroup/user&quot; or
&quot;workgroup/user%password&quot; to allow the password
and workgroup to be specified as part of the username.</p>

<p>Note The cifs vfs accepts the parameter user=, or for
users familiar with smbfs it accepts the longer form of the
parameter username=. Similarly the longer smbfs style
parameter names may be accepted as synonyms for the shorter
cifs parameters pass=,dom= and cred=.</p>

<p>password=arg specifies the CIFS password. If this option
is not given then the environment variable PASSWD is used.
If the password is not specified directly or indirectly via
an argument to mount, mount.cifs will prompt for a password,
unless the guest option is specified.</p>

<p>Note that a password which contains the delimiter
character (i.e. a comma &acute;,&acute;) will fail to be
parsed correctly on the command line. However, the same
password defined in the PASSWD environment variable or via a
credentials file (see below) or entered at the password
prompt will be read correctly.</p>

<p>credentials=filename specifies a file that contains a
username and/or password and optionally the name of the
workgroup. The format of the file is:</p>

<p>username=value password=value domain=value</p>

<p>This is preferred over having passwords in plaintext in
a shared file, such as /etc/fstab. Be sure to protect any
credentials file properly.</p>

<p>uid=arg sets the uid that will own all files or
directories on the mounted filesystem when the server does
not provide ownership information. It may be specified as
either a username or a numeric uid. When not specified, the
default is uid 0. The mount.cifs helper must be at version
1.10 or higher to support specifying the uid in non-numeric
form. See the section on FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS below for more information.</p>

<p>forceuid instructs the client to ignore any uid provided
by the server for files and directories and to always assign
the owner to be the value of the uid= option. See the
section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS
below for more information.</p>

<p>cruid=arg sets the uid of the owner of the credentials
cache. This is primarily useful with sec=krb5. The default
is the real uid of the process performing the mount. Setting
this parameter directs the upcall to look for a credentials
cache owned by that user.</p>

<p>gid=arg sets the gid that will own all files or
directories on the mounted filesystem when the server does
not provide ownership information. It may be specified as
either a groupname or a numeric gid. When not specified, the
default is gid 0. The mount.cifs helper must be at version
1.10 or higher to support specifying the gid in non-numeric
form. See the section on FILE AND DIRECTORY OWNERSHIP AND
PERMISSIONS below for more information.</p>

<p>forcegid instructs the client to ignore any gid provided
by the server for files and directories and to always assign
the owner to be the value of the gid= option. See the
section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS
below for more information.</p>

<p>port=arg sets the port number on which the client will
attempt to contact the CIFS server. If this value is
specified, look for an existing connection with this port,
and use that if one exists. If one doesnt exist, try to
create a new connection on that port. If that connection
fails, return an error. If this value isnt specified, look
for an existing connection on port 445 or 139. If no such
connection exists, try to connect on port 445 first and then
port 139 if that fails. Return an error if both fail.</p>

<p>servernetbiosname=arg Specify the server netbios name
(RFC1001 name) to use when attempting to setup a session to
the server. Although rarely needed for mounting to newer
servers, this option is needed for mounting to some older
servers (such as OS/2 or Windows 98 and Windows ME) since
when connecting over port 139 they, unlike most newer
servers, do not support a default server name. A server name
can be up to 15 characters long and is usually
uppercased.</p>

<p>servern=arg Synonym for servernetbiosname.</p>

<p>netbiosname=arg When mounting to servers via port 139,
specifies the RFC1001 source name to use to represent the
client netbios machine name when doing the RFC1001 netbios
session initialize.</p>

<p>file_mode=arg If the server does not support the CIFS
Unix extensions this overrides the default file mode.</p>

<p>dir_mode=arg If the server does not support the CIFS
Unix extensions this overrides the default mode for
directories.</p>

<p>ip=arg sets the destination IP address. This option is
set automatically if the server name portion of the
requested UNC name can be resolved so rarely needs to be
specified by the user.</p>

<p>domain=arg sets the domain (workgroup) of the user</p>

<p>guest don&acute;t prompt for a password</p>

<p>iocharset Charset used to convert local path names to
and from Unicode. Unicode is used by default for network
path names if the server supports it. If iocharset is not
specified then the nls_default specified during the local
client kernel build will be used. If server does not support
Unicode, this parameter is unused.</p>

<p>ro mount read-only</p>

<p>rw mount read-write</p>

<p>setuids If the CIFS Unix extensions are negotiated with
the server the client will attempt to set the effective uid
and gid of the local process on newly created files,
directories, and devices (create, mkdir, mknod). If the CIFS
Unix Extensions are not negotiated, for newly created files
and directories instead of using the default uid and gid
specified on the the mount, cache the new file&acute;s uid
and gid locally which means that the uid for the file can
change when the inode is reloaded (or the user remounts the
share).</p>

<p>nosetuids The client will not attempt to set the uid and
gid on on newly created files, directories, and devices
(create, mkdir, mknod) which will result in the server
setting the uid and gid to the default (usually the server
uid of the user who mounted the share). Letting the server
(rather than the client) set the uid and gid is the
default.If the CIFS Unix Extensions are not negotiated then
the uid and gid for new files will appear to be the uid
(gid) of the mounter or the uid (gid) parameter specified on
the mount.</p>

<p>perm Client does permission checks (vfs_permission check
of uid and gid of the file against the mode and desired
operation), Note that this is in addition to the normal ACL
check on the target machine done by the server software.
Client permission checking is enabled by default.</p>

<p>noperm Client does not do permission checks. This can
expose files on this mount to access by other users on the
local client system. It is typically only needed when the
server supports the CIFS Unix Extensions but the UIDs/GIDs
on the client and server system do not match closely enough
to allow access by the user doing the mount. Note that this
does not affect the normal ACL check on the target machine
done by the server software (of the server ACL against the
user name provided at mount time).</p>

<p>dynperm Instructs the server to maintain ownership and
permissions in memory that can&acute;t be stored on the
server. This information can disappear at any time (whenever
the inode is flushed from the cache), so while this may help
make some applications work, it&acute;s behavior is somewhat
unreliable. See the section below on FILE AND DIRECTORY
OWNERSHIP AND PERMISSIONS for more information.</p>

<p>cache= Cache mode. See the section below on CACHE
COHERENCY for details. Allowed values are:</p>

<p>&middot; none: do not cache file data at all</p>

<p>&middot; strict: follow the CIFS/SMB2 protocol
strictly</p>

<p>&middot; loose: allow loose caching semantics</p>

<p>The default in kernels prior to 3.7 was
&quot;loose&quot;. As of kernel 3.7 the default is
&quot;strict&quot;.</p>

<p>directio Do not do inode data caching on files opened on
this mount. This precludes mmaping files on this mount. In
some cases with fast networks and little or no caching
benefits on the client (e.g. when the application is doing
large sequential reads bigger than page size without
rereading the same data) this can provide better performance
than the default behavior which caches reads (readahead) and
writes (writebehind) through the local Linux client
pagecache if oplock (caching token) is granted and held.
Note that direct allows write operations larger than page
size to be sent to the server. On some kernels this requires
the cifs.ko module to be built with the CIFS_EXPERIMENTAL
configure option.</p>

<p>This option is will be deprecated in 3.7. Users should
use cache=none instead on more recent kernels.</p>

<p>strictcache Use for switching on strict cache mode. In
this mode the client reads from the cache all the time it
has Oplock Level II, otherwise - read from the server. As
for write - the client stores a data in the cache in
Exclusive Oplock case, otherwise - write directly to the
server.</p>

<p>This option is will be deprecated in 3.7. Users should
use cache=strict instead on more recent kernels.</p>

<p>rwpidforward Forward pid of a process who opened a file
to any read or write operation on that file. This prevent
applications like WINE from failing on read and write if we
use mandatory brlock style.</p>

<p>mapchars Translate six of the seven reserved characters
(not backslash, but including the colon, question mark,
pipe, asterik, greater than and less than characters) to the
remap range (above 0xF000), which also allows the CIFS
client to recognize files created with such characters by
Windows&acute;s POSIX emulation. This can also be useful
when mounting to most versions of Samba (which also forbids
creating and opening files whose names contain any of these
seven characters). This has no effect if the server does not
support Unicode on the wire. Please note that the files
created with mapchars mount option may not be accessible if
the share is mounted without that option.</p>

<p>nomapchars Do not translate any of these seven
characters (default)</p>

<p>intr currently unimplemented</p>

<p>nointr (default) currently unimplemented</p>

<p>hard The program accessing a file on the cifs mounted
file system will hang when the server crashes.</p>

<p>soft (default) The program accessing a file on the cifs
mounted file system will not hang when the server crashes
and will return errors to the user application.</p>

<p>noacl Do not allow POSIX ACL operations even if server
would support them.</p>

<p>The CIFS client can get and set POSIX ACLs (getfacl,
setfacl) to Samba servers version 3.0.10 and later. Setting
POSIX ACLs requires enabling both CIFS_XATTR and then
CIFS_POSIX support in the CIFS configuration options when
building the cifs module. POSIX ACL support can be disabled
on a per mount basis by specifying &quot;noacl&quot; on
mount.</p>

<p>cifsacl This option is used to map CIFS/NTFS ACLs
to/from Linux permission bits, map SIDs to/from UIDs and
GIDs, and get and set Security Descriptors.</p>

<p>See sections on CIFS/NTFS ACL, SID/UID/GID MAPPING,
SECURITY DESCRIPTORS for more information.</p>

<p>backupuid=arg Restrict access to files with the backup
intent to a user. Either a name or an id must be provided as
an argument, there are no default values.</p>

<p>See section ACCESSING FILES WITH BACKUP INTENT for more
details</p>

<p>backupgid=arg Restrict access to files with the backup
intent to a group. Either a name or an id must be provided
as an argument, there are no default values.</p>

<p>See section ACCESSING FILES WITH BACKUP INTENT for more
details</p>

<p>nocase Request case insensitive path name matching (case
sensitive is the default if the server suports it).</p>

<p>ignorecase Synonym for nocase.</p>

<p>sec= Security mode. Allowed values are:</p>

<p>&middot; none attempt to connection as a null user (no
name)</p>

<p>&middot; krb5 Use Kerberos version 5 authentication</p>

<p>&middot; krb5i Use Kerberos authentication and forcibly
enable packet signing</p>

<p>&middot; ntlm Use NTLM password hashing (default)</p>

<p>&middot; ntlmi Use NTLM password hashing and force
packet signing</p>

<p>&middot; ntlmv2 Use NTLMv2 password hashing</p>

<p>&middot; ntlmv2i Use NTLMv2 password hashing and force
packet signing</p>

<p>&middot; ntlmssp Use NTLMv2 password hashing
encapsulated in Raw NTLMSSP message</p>

<p>&middot; ntlmsspi Use NTLMv2 password hashing
encapsulated in Raw NTLMSSP message, and force packet
signing</p>

<p>If the server requires signing during protocol
negotiation, then it may be enabled automatically. Packet
signing may also be enabled automatically if it s enabled in
/proc/fs/cifs/SecurityFlags.</p>

<p>nobrl Do not send byte range lock requests to the
server. This is necessary for certain applications that
break with cifs style mandatory byte range locks (and most
cifs servers do not yet support requesting advisory byte
range locks).</p>

<p>sfu When the CIFS Unix Extensions are not negotiated,
attempt to create device files and fifos in a format
compatible with Services for Unix (SFU). In addition
retrieve bits 10-12 of the mode via the SETFILEBITS extended
attribute (as SFU does). In the future the bottom 9 bits of
the mode mode also will be emulated using queries of the
security descriptor (ACL). [NB: requires version 1.39 or
later of the CIFS VFS. To recognize symlinks and be able to
create symlinks in an SFU interoperable form requires
version 1.40 or later of the CIFS VFS kernel module.</p>

<p>serverino Use inode numbers (unique persistent file
identifiers) returned by the server instead of automatically
generating temporary inode numbers on the client. Although
server inode numbers make it easier to spot hardlinked files
(as they will have the same inode numbers) and inode numbers
may be persistent (which is userful for some sofware), the
server does not guarantee that the inode numbers are unique
if multiple server side mounts are exported under a single
share (since inode numbers on the servers might not be
unique if multiple filesystems are mounted under the same
shared higher level directory). Note that not all servers
support returning server inode numbers, although those that
support the CIFS Unix Extensions, and Windows 2000 and later
servers typically do support this (although not necessarily
on every local server filesystem). Parameter has no effect
if the server lacks support for returning inode numbers or
equivalent. This behavior is enabled by default.</p>

<p>noserverino Client generates inode numbers itself rather
than using the actual ones from the server.</p>

<p>See section INODE NUMBERS for more information.</p>

<p>nounix Disable the CIFS Unix Extensions for this mount.
This can be useful in order to turn off multiple settings at
once. This includes POSIX acls, POSIX locks, POSIX paths,
symlink support and retrieving uids/gids/mode from the
server. This can also be useful to work around a bug in a
server that supports Unix Extensions.</p>

<p>See section INODE NUMBERS for more information.</p>

<p>nouser_xattr (default) Do not allow getfattr/setfattr to
get/set xattrs, even if server would support it
otherwise.</p>

<p>rsize=arg default network read size (usually 16K). The
client currently can not use rsize larger than
CIFSMaxBufSize. CIFSMaxBufSize defaults to 16K and may be
changed (from 8K to the maximum kmalloc size allowed by your
kernel) at module install time for cifs.ko. Setting
CIFSMaxBufSize to a very large value will cause cifs to use
more memory and may reduce performance in some cases. To use
rsize greater than 127K (the original cifs protocol maximum)
also requires that the server support a new Unix Capability
flag (for very large read) which some newer servers (e.g.
Samba 3.0.26 or later) do. rsize can be set from a minimum
of 2048 to a maximum of 130048 (127K or CIFSMaxBufSize,
whichever is smaller)</p>

<p>wsize=bytes Maximum amount of data that the kernel will
send in a write request in bytes. Prior to RHEL6.2 kernels,
the default and maximum was 57344 (14 * 4096 pages). As of
RHEL6.2, the default depends on whether the client and
server negotiate large writes via POSIX extensions. If they
do then the default is 1M, and the maximum allowed is 16M.
If they do not, then the default is 65536 and the maximum
allowed is 131007.</p>

<p>Note that this value is just a starting point for
negotiation. The client and server may negotiate this size
downward according to the servers capabilities.</p>

<p>fsc Enable local disk caching using FS-Cache for CIFS.
This option could be useful to improve performance on a slow
link, heavily loaded server and/or network where reading
from the disk is faster than reading from the server (over
the network). This could also impact the scalability
positively as the number of calls to the server are reduced.
But, be warned that local caching is not suitable for all
workloads, for e.g., read-once type workloads. So, you need
to consider carefully the situation/workload before using
this option. Currently, local disk caching is enabled for
CIFS files opened as read-only.</p>

<p>NOTE: This feature is available only in the recent
kernels that have been built with the kernel config option
CONFIG_CIFS_FSCACHE. You also need to have cachefilesd
daemon installed and running to make the cache
operational.</p>

<p>multiuser Map user accesses to individual credentials
when accessing the server. By default, CIFS mounts only use
a single set of user credentials (the mount credentials)
when accessing a share. With this option, the client instead
creates a new session with the server using the users
credentials whenever a new user accesses the mount. Further
accesses by that user will also use those credentials.
Because the kernel cannot prompt for passwords, multiuser
mounts are limited to mounts using sec= options that dont
require passwords.</p>

<p>With this change, it s feasible for the server to handle
permissions enforcement, so this option also implies
&quot;noperm&quot;. Furthermore, when unix extensions arent
in use and the administrator has not overriden ownership
using the uid= or gid= options, ownership of files is
presented as the current user accessing the share.</p>

<p>actimeo=arg The time (in seconds) that the CIFS client
caches attributes of a file or directory before it requests
attribute information from a server. During this period the
changes that occur on the server remain undetected until the
client checks the server again.</p>

<p>By default, the attribute cache timeout is set to 1
second. This means more frequent on-the-wire calls to the
server to check whether attributes have changed which could
impact performance. With this option users can make a
tradeoff between performance and cache metadata correctness,
depending on workload needs. Shorter timeouts mean better
cache coherency, but frequent increased number of calls to
the server. Longer timeouts mean a reduced number of calls
to the server but looser cache coherency. The actimeo value
is a positive integer that can hold values between 0 and a
maximum value of 2^30 * HZ (frequency of timer interrupt)
setting.</p>

<p>noposixpaths If unix extensions are enabled on a share,
then the client will typically allow filenames to include
any character besides / in a pathname component, and will
use forward slashes as a pathname delimiter. This option
prevents the client from attempting to negotiate the use of
posix-style pathnames to the server.</p>

<p>posixpaths Inverse of noposixpaths.</p>

<p>prefixpath= Its possible to mount a subdirectory of a
share. The preferred way to do this is to append the path to
the UNC when mounting. However, its also possible to do the
same by setting this option and providing the path
there.</p>

<p>--verbose Print additional debugging information for the
mount. Note that this parameter must be specified before the
-o. For example:</p>

<p>mount -t cifs //server/share /mnt --verbose -o
user=username</p>

<p>SERVICE FORMATTING AND DELIMITERS It&acute;s generally
preferred to use forward slashes (/) as a delimiter in
service names. They are considered to be the &quot;universal
delimiter&quot; since they are generally not allowed to be
embedded within path components on Windows machines and the
client can convert them to blackslashes ( unconditionally.
Conversely, backslash characters are allowed by POSIX to be
part of a path component, and can&acute;t be automatically
converted in the same way.</p>

<p>mount.cifs will attempt to convert backslashes to
forward slashes where it&acute;s able to do so, but it
cannot do so in any path component following the
sharename.</p>

<p>INODE NUMBERS When Unix Extensions are enabled, we use
the actual inode number provided by the server in response
to the POSIX calls as an inode number.</p>

<p>When Unix Extensions are disabled and
&quot;serverino&quot; mount option is enabled there is no
way to get the server inode number. The client typically
maps the server-assigned &quot;UniqueID&quot; onto an inode
number.</p>

<p>Note that the UniqueID is a different value from the
server inode number. The UniqueID value is unique over the
scope of the entire server and is often greater than 2 power
32. This value often makes programs that are not compiled
with LFS (Large File Support), to trigger a glibc EOVERFLOW
error as this won&acute;t fit in the target structure field.
It is strongly recommended to compile your programs with LFS
support (i.e. with -D_FILE_OFFSET_BITS=64) to prevent this
problem. You can also use &quot;noserverino&quot; mount
option to generate inode numbers smaller than 2 power 32 on
the client. But you may not be able to detect hardlinks
properly.</p>

<p>CACHE COHERENCY With a network filesystem such as CIFS
or NFS, the client must contend with the fact that activity
on other clients or the server could change the contents or
attributes of a file without the client being aware of it.
One way to deal with such a problem is to mandate that all
file accesses go to the server directly. This is performance
prohibitive however, so most protocols have some mechanism
to allow the client to cache data locally.</p>

<p>The CIFS protocol mandates (in effect) that the client
should not cache file data unless it holds an opportunistic
lock (aka oplock) or a lease. Both of these entities allow
the client to guarantee certain types of exclusive access to
a file so that it can access its contents without needing to
continually interact with the server. The server will call
back the client when it needs to revoke either of them and
allow the client a certain amount of time to flush any
cached data.</p>

<p>The cifs client uses the kernels pagecache to cache file
data. Any I/O that s done through the pagecache is generally
page-aligned. This can be problematic when combined with
byte-range locks as Windows locking is mandatory and can
block reads and writes from occurring.</p>

<p>cache=none means that the client never utilizes the
cache for normal reads and writes. It always accesses the
server directly to satisfy a read or write request.</p>

<p>cache=strict means that the client will attempt to
follow the CIFS/SMB2 protocol strictly. That is, the cache
is only trusted when the client holds an oplock. When the
client does not hold an oplock, then the client bypasses the
cache and accesses the server directly to satisfy a read or
write request. By doing this, the client avoids problems
with byte range locks. Additionally, byte range locks are
cached on the client when it holds an oplock and are
&quot;pushed&quot; to the server when that oplock is
recalled.</p>

<p>cache=loose allows the client to use looser protocol
semantics which can sometimes provide better performance at
the expense of cache coherency. File access always involves
the pagecache. When an oplock or lease is not held, then the
client will attempt to flush the cache soon after a write to
a file. Note that that flush does not necessarily occur
before a write system call returns.</p>

<p>In the case of a read without holding an oplock, the
client will attempt to periodically check the attributes of
the file in order to ascertain whether it has changed and
the cache might no longer be valid. This mechanism is much
like the one that NFSv2/3 use for cache coherency, but it
particularly problematic with CIFS. Windows is quite
&quot;lazy&quot; with respect to updating the
&quot;LastWriteTime&quot; field that the client uses to
verify this. The effect is that cache=loose can cause data
corruption when multiple readers and writers are working on
the same files.</p>

<p>Because of this, when multiple clients are accessing the
same set of files, then cache=strict is recommended. That
helps eliminate problems with cache coherency by following
the CIFS/SMB2 protocols more strictly.</p>

<p>Note too that no matter what caching model is used, the
client will always use the pagecache to handle mmaped files.
Writes to mmaped files are only guaranteed to be flushed to
the server when msync() is called, or on close().</p>

<p>The default in kernels prior to 3.7 was
&quot;loose&quot;. As of 3.7, the default is
&quot;strict&quot;.</p>

<p>CIFS/NTFS ACL, SID/UID/GID MAPPING, SECURITY DESCRIPTORS
This option is used to work with file objects which posses
Security Descriptors and CIFS/NTFS ACL instead of UID, GID,
file permission bits, and POSIX ACL as user authentication
model. This is the most common authentication model for CIFS
servers and is the one used by Windows.</p>

<p>Support for this requires both CIFS_XATTR and CIFS_ACL
support in the CIFS configuration options when building the
cifs module.</p>

<p>A CIFS/NTFS ACL is mapped to file permission bits using
an algorithm specified in the following Microsoft TechNet
document:</p>

<p>&middot;
http://technet.microsoft.com/en-us/library/bb463216.aspx</p>

<p>Security descriptors for a file object can be retrieved
and set directly using extended attribute named
system.cifs_acl. The security descriptors presented via this
interface are &quot;raw&quot; blobs of data and need a
userspace utility to either parse and format or to assemble
it such as getcifsacl(8) and setcifsacl(8) respectively.</p>

<p>Some of the things to consider while using this mount
option:</p>

<p>&middot; There may be an increased latency when handling
metadata due to additional requests to get and set security
descriptors.</p>

<p>&middot; The mapping between a CIFS/NTFS ACL and POSIX
file permission bits is imperfect and some ACL information
may be lost in the translation.</p>

<p>&middot; While RHEL6 supports the mapping of permission
bits to windows ACLs, it does not map the owner SIDs to
UID/GID or vice versa.</p>

<p>ACCESSING FILES WITH BACKUP INTENT For an user on the
server, desired access to a file is determined by the
permissions and rights associated with that file. This is
typically accomplished using owenrship and ACL. For a user
who does not have access rights to a file, it is still
possible to access that file for a specific or a targeted
purpose by granting special rights. One of the specific
purposes is to access a file with the intent to either
backup or restore i.e. backup intent. The right to access a
file with the backup intent can typically be granted by
making that user a part of the built-in group Backup
Operators. Thus, when this user attempts to open a file with
the backup intent, open request is sent by setting the bit
FILE_OPEN_FOR_BACKUP_INTENT as one of the CreateOptions.</p>

<p>As an example, on a Windows server, a user named
testuser, cannot open this file with such a security
descriptor.</p>

<p>REVISION:0x1 CONTROL:0x9404 OWNER:Administrator
GROUP:Domain Users ACL:Administrator:ALLOWED/0x0/FULL</p>

<p>But the user testuser, if it becomes part of the group
Backup Operators, can open the file with the backup
intent.</p>

<p>Any user on the client side who can authenticate as such
a user on the server, can access the files with the backup
intent. But it is desirable and preferable for security
reasons amongst many, to restrict this special right.</p>

<p>The mount option backupuid is used to restrict this
special right to a user which is specified by either a name
or an id. The mount option backupgid is used to restrict
this special right to the users in a group which is
specified by either a name or an id. These two mount options
can be used together.</p>

<p>FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS The core
CIFS protocol does not provide unix ownership information or
mode for files and directories. Because of this, files and
directories will generally appear to be owned by whatever
values the uid= or gid= options are set, and will have
permissions set to the default file_mode and dir_mode for
the mount. Attempting to change these values via chmod/chown
will return success but have no effect.</p>

<p>When the client and server negotiate unix extensions,
files and directories will be assigned the uid, gid, and
mode provided by the server. Because CIFS mounts are
generally single-user, and the same credentials are used no
matter what user accesses the mount, newly created files and
directories will generally be given ownership corresponding
to whatever credentials were used to mount the share.</p>

<p>If the uid&acute;s and gid&acute;s being used do not
match on the client and server, the forceuid and forcegid
options may be helpful. Note however, that there is no
corresponding option to override the mode. Permissions
assigned to a file when forceuid or forcegid are in effect
may not reflect the the real permissions.</p>

<p>When unix extensions are not negotiated, it&acute;s also
possible to emulate them locally on the server using the
&quot;dynperm&quot; mount option. When this mount option is
in effect, newly created files and directories will receive
what appear to be proper permissions. These permissions are
not stored on the server however and can disappear at any
time in the future (subject to the whims of the kernel
flushing out the inode cache). In general, this mount option
is discouraged.</p>

<p>It&acute;s also possible to override permission checking
on the client altogether via the noperm option. Server-side
permission checks cannot be overriden. The permission checks
done by the server will always correspond to the credentials
used to mount the share, and not necessarily to the user who
is accessing the share.</p>

<p>ENVIRONMENT VARIABLES The variable USER may contain the
username of the person to be used to authenticate to the
server. The variable can be used to set both username and
password by using the format username%password.</p>

<p>The variable PASSWD may contain the password of the
person using the client.</p>

<p>The variable PASSWD_FILE may contain the pathname of a
file to read the password from. A single line of input is
read and used as the password.</p>

<p>NOTES This command may be used only by root, unless
installed setuid, in which case the noeexec and nosuid mount
flags are enabled. When installed as a setuid program, the
program follows the conventions set forth by the mount
program for user mounts, with the added restriction that
users must be able to chdir() into the mountpoint prior to
the mount in order to be able to mount onto it.</p>

<p>Some samba client tools like smbclient(8) honour
client-side configuration parameters present in smb.conf.
Unlike those client tools, mount.cifs ignores smb.conf
completely.</p>

<p>CONFIGURATION The primary mechanism for making
configuration changes and for reading debug information for
the cifs vfs is via the Linux /proc filesystem. In the
directory /proc/fs/cifs are various configuration files and
pseudo files which can display debug information. There are
additional startup options such as maximum buffer size and
number of buffers which only may be set when the kernel cifs
vfs (cifs.ko module) is loaded. These can be seen by running
the modinfo utility against the file cifs.ko which will list
the options that may be passed to cifs during module
installation (device driver load). For more information see
the kernel file fs/cifs/README.</p>

<p>BUGS Mounting using the CIFS URL specification is
currently not supported.</p>

<p>The credentials file does not handle usernames or
passwords with leading space.</p>

<p>Note that the typical response to a bug report is a
suggestion to try the latest version first. So please try
doing that first, and always include which versions you use
of relevant software when reporting bugs (minimum:
mount.cifs (try mount.cifs -V), kernel (see /proc/version)
and server type you are trying to contact.</p>

<p>VERSION This man page is correct for version 1.74 of the
cifs vfs filesystem (roughly Linux kernel 3.0).</p>

<p>SEE ALSO Documentation/filesystems/cifs.txt and
fs/cifs/README in the linux kernel source tree may contain
additional options and information.</p>

<p>cifs.upcall(8)</p>

<p>AUTHOR Steve French</p>

<p>The syntax and manpage were loosely based on that of
smbmount. It was converted to Docbook/XML by Jelmer
Vernooij.</p>

<p>The maintainer of the Linux cifs vfs and the userspace
tool mount.cifs is Steve French. The Linux CIFS Mailing list
is the preferred place to ask questions regarding these
programs.</p>

<p>cifs-utils 02/07/2010 MOUNT.CIFS(8)</p>
<hr>
</body>
</html>
