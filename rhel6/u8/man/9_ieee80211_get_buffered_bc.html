<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:31 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IEEE80211_GET_BUFFER(9) Advanced driver interface
IEEE80211_GET_BUFFER(9)</p>

<p>NAME ieee80211_get_buffered_bc - accessing buffered
broadcast and multicast frames</p>

<p>SYNOPSIS struct sk_buff *
ieee80211_get_buffered_bc(struct ieee80211_hw * hw, struct
ieee80211_vif * vif);</p>

<p>ARGUMENTS hw pointer as obtained from
ieee80211_alloc_hw.</p>

<p>vif</p>

<p>struct ieee80211_vif pointer from the add_interface
callback.</p>

<p>DESCRIPTION Function for accessing buffered broadcast
and multicast frames. If hardware/firmware does not
implement buffering of broadcast/multicast frames when power
saving is used, 802.11 code buffers them in the host memory.
The low-level driver uses this function to fetch next
buffered frame. In most cases, this is used when generating
beacon frame.</p>

<p>RETURN A pointer to the next buffered skb or NULL if no
more buffered frames are available.</p>

<p>NOTE buffered frames are returned only after DTIM beacon
frame was generated with ieee80211_beacon_get and the
low-level driver must thus call ieee80211_beacon_get first.
ieee80211_get_buffered_bc returns NULL if the previous
generated beacon was not DTIM, so the low-level driver does
not need to check for DTIM beacons separately and should be
able to use common code for all beacons.</p>

<p>AUTHOR Johannes Berg &lt;johannes@sipsolutions.net&gt;
Author.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
IEEE80211_GET_BUFFER(9)</p>
<hr>
</body>
</html>
