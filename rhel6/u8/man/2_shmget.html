<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:34:19 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SHMGET(2) Linux Programmer s Manual SHMGET(2)</p>

<p>NAME shmget - allocates a shared memory segment</p>

<p>SYNOPSIS #include &lt;sys/ipc.h&gt; #include
&lt;sys/shm.h&gt;</p>

<p>int shmget(key_t key, size_t size, int shmflg);</p>

<p>DESCRIPTION shmget() returns the identifier of the
shared memory segment associated with the value of the
argument key. A new shared memory segment, with size equal
to the value of size rounded up to a multiple of PAGE_SIZE,
is created if key has the value IPC_PRIVATE or key isnt
IPC_PRIVATE, no shared memory segment corresponding to key
exists, and IPC_CREAT is specified in shmflg.</p>

<p>If shmflg specifies both IPC_CREAT and IPC_EXCL and a
shared memory segment already exists for key, then shmget()
fails with errno set to EEXIST. (This is analogous to the
effect of the combination O_CREAT | O_EXCL for open(2).)</p>

<p>The value shmflg is composed of:</p>

<p>IPC_CREAT to create a new segment. If this flag is not
used, then shmget() will find the segment associated with
key and check to see if the user has permission to access
the seg- ment.</p>

<p>IPC_EXCL used with IPC_CREAT to ensure failure if the
segment already exists.</p>

<p>mode_flags (least significant 9 bits) specifying the
permissions granted to the owner, group, and world. These
bits have the same format, and the same meaning, as the mode
argument of open(2). Presently, the execute permissions are
not used by the system.</p>

<p>SHM_HUGETLB (since Linux 2.6) Allocate the segment using
&quot;huge pages.&quot; See the kernel source file
Documentation/vm/hugetlbpage.txt for further
information.</p>

<p>SHM_NORESERVE (since Linux 2.6.15) This flag serves the
same purpose as the mmap(2) MAP_NORE- SERVE flag. Do not
reserve swap space for this segment. When swap space is
reserved, one has the guarantee that it is possible to
modify the segment. When swap space is not reserved one
might get SIGSEGV upon a write if no physical memory is
available. See also the discussion of the file
/proc/sys/vm/overcommit_memory in proc(5).</p>

<p>When a new shared memory segment is created, its
contents are initial- ized to zero values, and its
associated data structure, shmid_ds (see shmctl(2)), is
initialized as follows:</p>

<p>shm_perm.cuid and shm_perm.uid are set to the effective
user ID of the calling process.</p>

<p>shm_perm.cgid and shm_perm.gid are set to the effective
group ID of the calling process.</p>

<p>The least significant 9 bits of shm_perm.mode are set to
the least significant 9 bit of shmflg.</p>

<p>shm_segsz is set to the value of size.</p>

<p>shm_lpid, shm_nattch, shm_atime and shm_dtime are set to
0.</p>

<p>shm_ctime is set to the current time.</p>

<p>If the shared memory segment already exists, the
permissions are veri- fied, and a check is made to see if it
is marked for destruction.</p>

<p>RETURN VALUE A valid segment identifier, shmid, is
returned on success, -1 on error.</p>

<p>ERRORS On failure, errno is set to one of the
following:</p>

<p>EACCES The user does not have permission to access the
shared memory segment, and does not have the CAP_IPC_OWNER
capability.</p>

<p>EEXIST IPC_CREAT | IPC_EXCL was specified and the
segment exists.</p>

<p>EINVAL A new segment was to be created and size &lt;
SHMMIN or size &gt; SHM- MAX, or no new segment was to be
created, a segment with given key existed, but size is
greater than the size of that segment.</p>

<p>ENFILE The system limit on the total number of open
files has been reached.</p>

<p>ENOENT No segment exists for the given key, and
IPC_CREAT was not spec- ified.</p>

<p>ENOMEM No memory could be allocated for segment
overhead.</p>

<p>ENOSPC All possible shared memory IDs have been taken
(SHMMNI), or allocating a segment of the requested size
would cause the sys- tem to exceed the system-wide limit on
shared memory (SHMALL).</p>

<p>EPERM The SHM_HUGETLB flag was specified, but the caller
was not priv- ileged (did not have the CAP_IPC_LOCK
capability).</p>

<p>CONFORMING TO SVr4, POSIX.1-2001.</p>

<p>SHM_HUGETLB is a non-portable Linux extension.</p>

<p>NOTES IPC_PRIVATE isn t a flag field but a key_t type.
If this special value is used for key, the system call
ignores everything but the least sig- nificant 9 bits of
shmflg and creates a new shared memory segment (on
success).</p>

<p>The following limits on shared memory segment resources
affect the shmget() call:</p>

<p>SHMALL System wide maximum of shared memory pages (on
Linux, this limit can be read and modified via
/proc/sys/kernel/shmall).</p>

<p>SHMMAX Maximum size in bytes for a shared memory
segment: policy depen- dent (on Linux, this limit can be
read and modified via /proc/sys/kernel/shmmax).</p>

<p>SHMMIN Minimum size in bytes for a shared memory
segment: implementa- tion dependent (currently 1 byte,
though PAGE_SIZE is the effec- tive minimum size).</p>

<p>SHMMNI System wide maximum number of shared memory
segments: implemen- tation dependent (currently 4096, was
128 before Linux 2.3.99; on Linux, this limit can be read
and modified via /proc/sys/ker- nel/shmmni).</p>

<p>The implementation has no specific limits for the
per-process maximum number of shared memory segments
(SHMSEG).</p>

<p>Linux Notes Until version 2.3.30 Linux would return
EIDRM for a shmget() on a shared memory segment scheduled
for deletion.</p>

<p>BUGS The name choice IPC_PRIVATE was perhaps
unfortunate, IPC_NEW would more clearly show its
function.</p>

<p>SEE ALSO shmat(2), shmctl(2), shmdt(2), ftok(3),
capabilities(7), shm_overview(7), svipc(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2006-05-02 SHMGET(2)</p>
<hr>
</body>
</html>
