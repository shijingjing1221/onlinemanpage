<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:08:02 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CLOSE(3P) POSIX Programmer s Manual CLOSE(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME close - close a file descriptor</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int close(int fildes);</p>

<p>DESCRIPTION The close() function shall deallocate the
file descriptor indicated by fildes. To deallocate means to
make the file descriptor available for return by subsequent
calls to open() or other functions that allocate file
descriptors. All outstanding record locks owned by the
process on the file associated with the file descriptor
shall be removed (that is, unlocked).</p>

<p>If close() is interrupted by a signal that is to be
caught, it shall return -1 with errno set to [EINTR] and the
state of fildes is unspeci- fied. If an I/O error occurred
while reading from or writing to the file system during
close(), it may return -1 with errno set to [EIO]; if this
error is returned, the state of fildes is unspecified.</p>

<p>When all file descriptors associated with a pipe or FIFO
special file are closed, any data remaining in the pipe or
FIFO shall be discarded.</p>

<p>When all file descriptors associated with an open file
description have been closed, the open file description
shall be freed.</p>

<p>If the link count of the file is 0, when all file
descriptors associ- ated with the file are closed, the space
occupied by the file shall be freed and the file shall no
longer be accessible.</p>

<p>If a STREAMS-based fildes is closed and the calling
process was previ- ously registered to receive a SIGPOLL
signal for events associated with that STREAM, the calling
process shall be unregistered for events asso- ciated with
the STREAM. The last close() for a STREAM shall cause the
STREAM associated with fildes to be dismantled. If
O_NONBLOCK is not set and there have been no signals posted
for the STREAM, and if there is data on the modules write
queue, close() shall wait for an unspeci- fied time (for
each module and driver) for any output to drain before
dismantling the STREAM. The time delay can be changed via an
I_SET- CLTIME ioctl() request. If the O_NONBLOCK flag is
set, or if there are any pending signals, close() shall not
wait for output to drain, and shall dismantle the STREAM
immediately.</p>

<p>If the implementation supports STREAMS-based pipes, and
fildes is asso- ciated with one end of a pipe, the last
close() shall cause a hangup to occur on the other end of
the pipe. In addition, if the other end of the pipe has been
named by fattach(), then the last close() shall force the
named end to be detached by fdetach(). If the named end has
no open file descriptors associated with it and gets
detached, the STREAM asso- ciated with that end shall also
be dismantled.</p>

<p>If fildes refers to the master side of a
pseudo-terminal, and this is the last close, a SIGHUP signal
shall be sent to the controlling process, if any, for which
the slave side of the pseudo-terminal is the controlling
terminal. It is unspecified whether closing the master side
of the pseudo-terminal flushes all queued input and
output.</p>

<p>If fildes refers to the slave side of a STREAMS-based
pseudo-terminal, a zero-length message may be sent to the
master.</p>

<p>When there is an outstanding cancelable asynchronous I/O
operation against fildes when close() is called, that I/O
operation may be can- celed. An I/O operation that is not
canceled completes as if the close() operation had not yet
occurred. All operations that are not canceled shall
complete as if the close() blocked until the operations
completed. The close() operation itself need not block
awaiting such I/O completion. Whether any I/O operation is
canceled, and which I/O operation may be canceled upon
close(), is implementation-defined.</p>

<p>If a shared memory object or a memory mapped file
remains referenced at the last close (that is, a process has
it mapped), then the entire con- tents of the memory object
shall persist until the memory object becomes unreferenced.
If this is the last close of a shared memory object or a
memory mapped file and the close results in the memory
object becoming unreferenced, and the memory object has been
unlinked, then the memory object shall be removed.</p>

<p>If fildes refers to a socket, close() shall cause the
socket to be destroyed. If the socket is in connection-mode,
and the SO_LINGER option is set for the socket with non-zero
linger time, and the socket has untransmitted data, then
close() shall block for up to the current linger interval
until all data is transmitted.</p>

<p>RETURN VALUE Upon successful completion, 0 shall be
returned; otherwise, -1 shall be returned and errno set to
indicate the error.</p>

<p>ERRORS The close() function shall fail if:</p>

<p>EBADF The fildes argument is not a valid file
descriptor.</p>

<p>EINTR The close() function was interrupted by a
signal.</p>

<p>The close() function may fail if:</p>

<p>EIO An I/O error occurred while reading from or writing
to the file system.</p>

<p>The following sections are informative.</p>

<p>EXAMPLES Reassigning a File Descriptor The following
example closes the file descriptor associated with stan-
dard output for the current process, re-assigns standard
output to a new file descriptor, and closes the original
file descriptor to clean up. This example assumes that the
file descriptor 0 (which is the descriptor for standard
input) is not closed.</p>

<p>#include &lt;unistd.h&gt; ... int pfd; ... close(1);
dup(pfd); close(pfd); ...</p>

<p>Incidentally, this is exactly what could be achieved
using:</p>

<p>dup2(pfd, 1); close(pfd);</p>

<p>Closing a File Descriptor In the following example,
close() is used to close a file descriptor after an
unsuccessful attempt is made to associate that file
descriptor with a stream.</p>

<p>#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;</p>

<p>#define LOCKFILE &quot;/etc/ptmp&quot; ... int pfd; FILE
*fpfd; ... if ((fpfd = fdopen (pfd, &quot;w&quot;)) == NULL)
{ close(pfd); unlink(LOCKFILE); exit(1); } ...</p>

<p>APPLICATION USAGE An application that had used the stdio
routine fopen() to open a file should use the corresponding
fclose() routine rather than close(). Once a file is closed,
the file descriptor no longer exists, since the integer
corresponding to it no longer refers to a file.</p>

<p>RATIONALE The use of interruptible device close routines
should be discouraged to avoid problems with the implicit
closes of file descriptors by exec and exit(). This volume
of IEEE Std 1003.1-2001 only intends to permit such behavior
by specifying the [EINTR] error condition.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO STREAMS, fattach(), fclose(), fdetach(),
fopen(), ioctl(), open(), the Base Definitions volume of
IEEE Std 1003.1-2001, &lt;unistd.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 CLOSE(3P)</p>
<hr>
</body>
</html>
