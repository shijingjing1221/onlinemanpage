<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:05:47 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LBER_DECODE(3) LBER_DECODE(3)</p>

<p>NAME ber_get_next, ber_skip_tag, ber_peek_tag,
ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb,
ber_get_stringa, ber_get_stringal, ber_get_stringbv,
ber_get_null, ber_get_boolean, ber_get_bitstring,
ber_first_element, ber_next_element - OpenLDAP LBER
simplified Basic Encoding Rules library routines for
decoding</p>

<p>LIBRARY OpenLDAP LBER (liblber, -llber)</p>

<p>SYNOPSIS #include &lt;lber.h&gt;</p>

<p>ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len,
BerElement *ber);</p>

<p>ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t
*len);</p>

<p>ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t
*len);</p>

<p>ber_tag_t ber_scanf(BerElement *ber, const char *fmt,
...);</p>

<p>ber_tag_t ber_get_int(BerElement *ber, ber_int_t
*num);</p>

<p>ber_tag_t ber_get_enum(BerElement *ber, ber_int_t
*num);</p>

<p>ber_tag_t ber_get_stringb(BerElement *ber, char *buf,
ber_len_t *len);</p>

<p>ber_tag_t ber_get_stringa(BerElement *ber, char
**buf);</p>

<p>ber_tag_t ber_get_stringal(BerElement *ber, struct
berval **bv);</p>

<p>ber_tag_t ber_get_stringbv(BerElement *ber, struct
berval *bv, int alloc);</p>

<p>ber_tag_t ber_get_null(BerElement *ber);</p>

<p>ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t
*bool);</p>

<p>ber_tag_t ber_get_bitstringa(BerElement *ber, char
**buf, ber_len_t *blen);</p>

<p>ber_tag_t ber_first_element(BerElement *ber, ber_len_t
*len, char **cookie);</p>

<p>ber_tag_t ber_next_element(BerElement *ber, ber_len_t
*len, const char *cookie);</p>

<p>DESCRIPTION These routines provide a subroutine
interface to a simplified implemen- tation of the Basic
Encoding Rules of ASN.1. The version of BER these routines
support is the one defined for the LDAP protocol. The encod-
ing rules are the same as BER, except that only definite
form lengths are used, and bitstrings and octet strings are
always encoded in primi- tive form. This man page describes
the decoding routines in the lber library. See
lber-encode(3) for details on the corresponding encoding
routines. Consult lber-types(3) for information about types,
alloca- tors, and deallocators.</p>

<p>Normally, the only routines that need to be called by an
application are ber_get_next() to get the next BER element
and ber_scanf() to do the actual decoding. In some cases,
ber_peek_tag() may also need to be called in normal usage.
The other routines are provided for those applications that
need more control than ber_scanf() provides. In gen- eral,
these routines return the tag of the element decoded, or
LBER_ERROR if an error occurred.</p>

<p>The ber_get_next() routine is used to read the next BER
element from the given Sockbuf, sb. It strips off and
returns the leading tag, strips off and returns the length
of the entire element in len, and sets up ber for subsequent
calls to ber_scanf() et al to decode the element. See
lber-sockbuf(3) for details of the Sockbuf implementation of
the sb parameter.</p>

<p>The ber_scanf() routine is used to decode a BER element
in much the same way that scanf(3) works. It reads from ber,
a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format
string fmt, and stores the results in its addi- tional
arguments. The format string contains conversion
specifications which are used to direct the interpretation
of the BER element. The format string can contain the
following characters.</p>

<p>a Octet string. A char ** should be supplied. Memory is
allo- cated, filled with the contents of the octet string,
null- terminated, and returned in the parameter. The caller
should free the returned string using ber_memfree().</p>

<p>A Octet string. A variant of &quot;a&quot;. A char **
should be sup- plied. Memory is allocated, filled with the
contents of the octet string, null-terminated, and returned
in the parameter, unless a zero-length string would result;
in that case, the arg is set to NULL. The caller should free
the returned string using ber_memfree().</p>

<p>s Octet string. A char * buffer should be supplied,
followed by a pointer to a ber_len_t initialized to the size
of the buffer. Upon return, the null-terminated octet string
is put into the buffer, and the ber_len_t is set to the
actual size of the octet string.</p>

<p>O Octet string. A struct ber_val ** should be supplied,
which upon return points to a dynamically allocated struct
berval containing the octet string and its length. The
caller should free the returned structure using
ber_bvfree().</p>

<p>o Octet string. A struct ber_val * should be supplied,
which upon return contains the dynamically allocated octet
string and its length. The caller should free the returned
octet string using ber_memfree().</p>

<p>m Octet string. A struct ber_val * should be supplied,
which upon return contains the octet string and its length.
The string resides in memory assigned to the BerElement, and
must not be freed by the caller.</p>

<p>b Boolean. A pointer to a ber_int_t should be
supplied.</p>

<p>e Enumeration. A pointer to a ber_int_t should be
supplied.</p>

<p>i Integer. A pointer to a ber_int_t should be
supplied.</p>

<p>B Bitstring. A char ** should be supplied which will
point to the dynamically allocated bits, followed by a
ber_len_t *, which will point to the length (in bits) of the
bitstring returned.</p>

<p>n Null. No parameter is required. The element is simply
skipped if it is recognized.</p>

<p>v Sequence of octet strings. A char *** should be
supplied, which upon return points to a dynamically
allocated null-ter- minated array of char *s containing the
octet strings. NULL is returned if the sequence is empty.
The caller should free the returned array and octet strings
using ber_memvfree().</p>

<p>V Sequence of octet strings with lengths. A struct
berval *** should be supplied, which upon return points to a
dynamically allocated null-terminated array of struct berval
*s contain- ing the octet strings and their lengths. NULL is
returned if the sequence is empty. The caller should free
the returned structures using ber_bvecfree().</p>

<p>W Sequence of octet strings with lengths. A BerVarray *
should be supplied, which upon return points to a
dynamically allo- cated array of struct bervals containing
the octet strings and their lengths. The array is terminated
by a struct berval with a NULL bv_val string pointer. NULL
is returned if the sequence is empty. The caller should free
the returned structures using ber_bvarray_free().</p>

<p>M Sequence of octet strings with lengths. This is a
general- ized form of the previous three formats. A void **
(ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off). Upon return (ptr) will point to a
dynami- cally allocated array whose elements are all of size
(*len). A struct berval will be filled starting at offset
(off) in each element. The strings in each struct berval
reside in memory assigned to the BerElement and must not be
freed by the caller. The array is terminated by a struct
berval with a NULL bv_val string pointer. NULL is returned
if the sequence is empty. The number of elements in the
array is also stored in (*len) on return. The caller should
free the returned array using ber_memfree().</p>

<p>l Length of the next element. A pointer to a ber_len_t
should be supplied.</p>

<p>t Tag of the next element. A pointer to a ber_tag_t
should be supplied.</p>

<p>T Skip element and return its tag. A pointer to a
ber_tag_t should be supplied.</p>

<p>x Skip element. The next element is skipped.</p>

<p>{ Begin sequence. No parameter is required. The initial
sequence tag and length are skipped.</p>

<p>} End sequence. No parameter is required and no action
is taken.</p>

<p>[ Begin set. No parameter is required. The initial set
tag and length are skipped.</p>

<p>] End set. No parameter is required and no action is
taken.</p>

<p>The ber_get_int() routine tries to interpret the next
element as an integer, returning the result in num. The tag
of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.</p>

<p>The ber_get_stringb() routine is used to read an octet
string into a preallocated buffer. The len parameter should
be initialized to the size of the buffer, and will contain
the length of the octet string read upon return. The buffer
should be big enough to take the octet string value plus a
terminating NULL byte.</p>

<p>The ber_get_stringa() routine is used to dynamically
allocate space into which an octet string is read. The
caller should free the returned string using
ber_memfree().</p>

<p>The ber_get_stringal() routine is used to dynamically
allocate space into which an octet string and its length are
read. It takes a struct berval **, and returns the result in
this parameter. The caller should free the returned
structure using ber_bvfree().</p>

<p>The ber_get_stringbv() routine is used to read an octet
string and its length into the provided struct berval *. If
the alloc parameter is zero, the string will reside in
memory assigned to the BerElement, and must not be freed by
the caller. If the alloc parameter is non-zero, the string
will be copied into dynamically allocated space which should
be returned using ber_memfree().</p>

<p>The ber_get_null() routine is used to read a NULL
element. It returns the tag of the element it skips
over.</p>

<p>The ber_get_boolean() routine is used to read a boolean
value. It is called the same way that ber_get_int() is
called.</p>

<p>The ber_get_enum() routine is used to read a enumeration
value. It is called the same way that ber_get_int() is
called.</p>

<p>The ber_get_bitstringa() routine is used to read a
bitstring value. It takes a char ** which will hold the
dynamically allocated bits, fol- lowed by an ber_len_t *,
which will point to the length (in bits) of the bitstring
returned. The caller should free the returned string using
ber_memfree().</p>

<p>The ber_first_element() routine is used to return the
tag and length of the first element in a set or sequence. It
also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which
returns similar information.</p>

<p>EXAMPLES Assume the variable ber contains a lightweight
BER encoding of the fol- lowing ASN.1 object:</p>

<p>AlmostASearchRequest := SEQUENCE { baseObject
DistinguishedName, scope ENUMERATED { baseObject (0),
singleLevel (1), wholeSubtree (2) }, derefAliases ENUMERATED
{ neverDerefaliases (0), derefInSearching (1),
derefFindingBaseObj (2), alwaysDerefAliases (3) }, sizelimit
INTEGER (0 .. 65535), timelimit INTEGER (0 .. 65535),
attrsOnly BOOLEAN, attributes SEQUENCE OF AttributeType
}</p>

<p>The element can be decoded using ber_scanf() as
follows.</p>

<p>ber_int_t scope, deref, size, time, attrsonly; char *dn,
**attrs; ber_tag_t tag;</p>

<p>tag = ber_scanf( ber, &quot;{aeeiib{v}}&quot;, &amp;dn,
&amp;scope, &amp;deref, &amp;size, &amp;time,
&amp;attrsonly, &amp;attrs );</p>

<p>if( tag == LBER_ERROR ) { /* error */ } else { /*
success */ }</p>

<p>ber_memfree( dn ); ber_memvfree( attrs );</p>

<p>ERRORS If an error occurs during decoding, generally
these routines return LBER_ERROR ((ber_tag_t)-1).</p>

<p>NOTES The return values for all of these functions are
declared in the &lt;lber.h&gt; header file. Some routines
may dynamically allocate memory which must be freed by the
caller using supplied deallocation routines.</p>

<p>SEE ALSO lber-encode(3), lber-memory(3),
lber-sockbuf(3), lber-types(3)</p>

<p>ACKNOWLEDGEMENTS OpenLDAP Software is developed and
maintained by The OpenLDAP Project
&lt;http://www.openldap.org/&gt;. OpenLDAP Software is
derived from Univer- sity of Michigan LDAP 3.3 Release.</p>

<p>OpenLDAP 2.4.40 2014/09/20 LBER_DECODE(3)</p>
<hr>
</body>
</html>
