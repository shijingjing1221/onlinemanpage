<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERF-PROBE(1) perf Manual PERF-PROBE(1)</p>

<p>NAME perf-probe - Define new dynamic tracepoints</p>

<p>SYNOPSIS perf probe [options] --add=PROBE [...] or perf
probe [options] PROBE or perf probe [options]
--del=[GROUP:]EVENT [...] or perf probe --list or perf probe
[options] --line=LINE or perf probe [options]
--vars=PROBEPOINT</p>

<p>DESCRIPTION This command defines dynamic tracepoint
events, by symbol and registers without debuginfo, or by C
expressions (C line numbers, C function names, and C local
variables) with debuginfo.</p>

<p>OPTIONS -k, --vmlinux=PATH Specify vmlinux path which
has debuginfo (Dwarf binary).</p>

<p>-m, --module=MODNAME|PATH Specify module name in which
perf-probe searches probe points or lines. If a path of
module file is passed, perf-probe treat it as an offline
module (this means you can add a probe on a module which has
not been loaded yet).</p>

<p>-s, --source=PATH Specify path to kernel source.</p>

<p>-v, --verbose Be more verbose (show parsed arguments,
etc). Can not use with -q.</p>

<p>-q, --quiet Be quiet (do not show any messages including
errors). Can not use with -v.</p>

<p>-a, --add= Define a probe event (see PROBE SYNTAX for
detail).</p>

<p>-d, --del= Delete probe events. This accepts glob
wildcards(*, ?) and character classes(e.g. [a-z],
[!A-Z]).</p>

<p>-l, --list List up current probe events.</p>

<p>-L, --line= Show source code lines which can be probed.
This needs an argument which specifies a range of the source
code. (see LINE SYNTAX for detail)</p>

<p>-V, --vars= Show available local variables at given
probe point. The argument syntax is same as PROBE SYNTAX,
but NO ARGs.</p>

<p>--externs (Only for --vars) Show external defined
variables in addition to local variables.</p>

<p>-F, --funcs Show available functions in given module or
kernel. With -x/--exec, can also list functions in a user
space executable / shared library.</p>

<p>--filter=FILTER (Only for --vars and --funcs) Set
filter. FILTER is a combination of glob pattern, see FILTER
PATTERN for detail. Default FILTER is &quot;!k???tab_* &amp;
!crc_*&quot; for --vars, and &quot;!_*&quot; for --funcs. If
several filters are specified, only the last filter is
used.</p>

<p>-f, --force Forcibly add events with existing name.</p>

<p>-n, --dry-run Dry run. With this option, --add and --del
doesn t execute actual adding and removal operations.</p>

<p>--max-probes=NUM Set the maximum number of probe points
for an event. Default is 128.</p>

<p>-x, --exec=PATH Specify path to the executable or shared
library file for user space tracing. Can also be used with
--funcs option. (this feature is unsupported in RHEL6)</p>

<p>--demangle Demangle application symbols. --no-demangle
is also available for disabling demangling.</p>

<p>--demangle-kernel Demangle kernel symbols.
--no-demangle-kernel is also available for disabling kernel
demangling.</p>

<p>In absence of -m/-x options, perf probe checks if the
first argument after the options is an absolute path name.
If its an absolute path, perf probe uses it as a target
module/target user space binary to probe.</p>

<p>PROBE SYNTAX Probe points are defined by following
syntax.</p>

<p>1) Define event based on function name
[EVENT=]FUNC[@SRC][:RLN|+OFFS|%return|;PTN] [ARG ...]</p>

<p>2) Define event based on source file with line number
[EVENT=]SRC:ALN [ARG ...]</p>

<p>3) Define event based on source file with lazy pattern
[EVENT=]SRC;PTN [ARG ...]</p>

<p>EVENT specifies the name of new event, if omitted, it
will be set the name of the probed function. Currently,
event group name is set as probe. FUNC specifies a probed
function name, and it may have one of the following options;
+OFFS is the offset from function entry address in bytes,
:RLN is the relative-line number from function entry line,
and %return means that it probes function return. And ;PTN
means lazy matching pattern (see LAZY MATCHING). Note that
;PTN must be the end of the probe point definition. In
addition, @SRC specifies a source file which has that
function. It is also possible to specify a probe point by
the source line number or lazy matching by using SRC:ALN or
SRC;PTN syntax, where SRC is the source file path, :ALN is
the line number and ;PTN is the lazy matching pattern. ARG
specifies the arguments of this probe point, (see PROBE
ARGUMENT).</p>

<p>PROBE ARGUMENT Each probe argument follows below
syntax.</p>

<p>[NAME=]LOCALVAR|$retval|%REG|@SYMBOL[:TYPE]</p>

<p>NAME specifies the name of this argument (optional). You
can use the name of local variable, local data structure
member (e.g. varfield, var.field2), local array with fixed
index (e.g. array[1], vararray[0], varpointer[2]), or
kprobe-tracer argument format (e.g. $retval, %ax, etc). Note
that the name of this argument will be set as the last
member name if you specify a local data structure member
(e.g. field2 for var_field1.field2.) $vars special argument
is also available for NAME, it is expanded to the local
variables which can access at given probe point. TYPE casts
the type of this argument (optional). If omitted, perf probe
automatically set the type based on debuginfo. You can
specify string type only for the local variable or structure
member which is an array of or a pointer to char or unsigned
char type.</p>

<p>On x86 systems %REG is always the short form of the
register: for example %AX. %RAX or %EAX is not valid.</p>

<p>LINE SYNTAX Line range is described by following
syntax.</p>


<p>&quot;FUNC[@SRC][:RLN[+NUM|-RLN2]]|SRC[:ALN[+NUM|-ALN2]]&quot;</p>

<p>FUNC specifies the function name of showing lines. RLN
is the start line number from function entry line, and RLN2
is the end line number. As same as probe syntax, SRC means
the source file path, ALN is start line number, and ALN2 is
end line number in the file. It is also possible to specify
how many lines to show by using NUM. Moreover, FUNC@SRC
combination is good for searching a specific function when
several functions share same name. So,
&quot;source.c:100-120&quot; shows lines between 100th to
l20th in source.c file. And &quot;func:10+20&quot; shows 20
lines from 10th line of func function.</p>

<p>LAZY MATCHING The lazy line matching is similar to glob
matching but ignoring spaces in both of pattern and target.
So this accepts wildcards(&acute;*&acute;, &acute;?&acute;)
and character classes(e.g. [a-z], [!A-Z]).</p>

<p>e.g. a=* can matches a=b, a = b, a == b and so on.</p>

<p>This provides some sort of flexibility and robustness to
probe point definitions against minor code changes. For
example, actual 10th line of schedule() can be moved easily
by modifying schedule(), but the same line matching
rq=cpu_rq* may still exist in the function.)</p>

<p>FILTER PATTERN The filter pattern is a glob matching
pattern(s) to filter variables. In addition, you can use
&quot;!&quot; for specifying filter-out rule. You also can
give several rules combined with &quot;&amp;&quot; or
&quot;|&quot;, and fold those rules as one rule by using
&quot;(&quot; &quot;)&quot;.</p>

<p>e.g. With --filter &quot;foo* | bar*&quot;, perf probe
-V shows variables which start with &quot;foo&quot; or
&quot;bar&quot;. With --filter &quot;!foo* &amp; *bar&quot;,
perf probe -V shows variables which dont start with
&quot;foo&quot; and end with &quot;bar&quot;, like
&quot;fizzbar&quot;. But &quot;foobar&quot; is filtered
out.</p>

<p>EXAMPLES Display which lines in schedule() can be
probed:</p>

<p>./perf probe --line schedule</p>

<p>Add a probe on schedule() function 12th line with
recording cpu local variable:</p>

<p>./perf probe schedule:12 cpu or ./perf probe
--add=&acute;schedule:12 cpu&acute;</p>

<p>this will add one or more probes which has the name
start with &quot;schedule&quot;.</p>

<p>Add probes on lines in schedule() function which calls
update_rq_clock().</p>

<p>./perf probe &acute;schedule;update_rq_clock*&acute; or
./perf probe
--add=&acute;schedule;update_rq_clock*&acute;</p>

<p>Delete all probes on schedule().</p>

<p>./perf probe --del=&acute;schedule*&acute;</p>

<p>Add probes at zfree() function on /bin/zsh</p>

<p>./perf probe -x /bin/zsh zfree or ./perf probe /bin/zsh
zfree</p>

<p>Add probes at malloc() function on libc</p>

<p>./perf probe -x /lib/libc.so.6 malloc or ./perf probe
/lib/libc.so.6 malloc</p>

<p>SEE ALSO perf-trace(1), perf-record(1)</p>

<p>perf 04/13/2016 PERF-PROBE(1)</p>
<hr>
</body>
</html>
