<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:53 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLUNICODE(1) Perl Programmers Reference Guide
PERLUNICODE(1)</p>

<p>NAME perlunicode - Unicode support in Perl</p>

<p>DESCRIPTION Important Caveats Unicode support is an
extensive requirement. While Perl does not implement the
Unicode standard or the accompanying technical reports from
cover to cover, Perl does support many Unicode features.</p>

<p>People who want to learn to use Unicode in Perl, should
probably read the Perl Unicode tutorial, perlunitut, before
reading this reference document.</p>

<p>Input and Output Layers Perl knows when a filehandle
uses Perls internal Unicode encodings (UTF-8, or UTF-EBCDIC
if in EBCDIC) if the filehandle is opened with the
&quot;:utf8&quot; layer. Other encodings can be converted to
Perls encoding on input or from Perls encoding on output by
use of the &quot;:encoding(...)&quot; layer. See open.</p>

<p>To indicate that Perl source itself is in UTF-8, use
&quot;use utf8;&quot;.</p>

<p>Regular Expressions The regular expression compiler
produces polymorphic opcodes. That is, the pattern adapts to
the data and automatically switches to the Unicode character
scheme when presented with data that is internally encoded
in UTF-8 -- or instead uses a traditional byte scheme when
presented with byte data.</p>

<p>&quot;use utf8&quot; still needed to enable
UTF-8/UTF-EBCDIC in scripts As a compatibility measure, the
&quot;use utf8&quot; pragma must be explicitly included to
enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identifier
names) on ASCII-based machines or to recognize UTF- EBCDIC
on EBCDIC-based machines. These are the only times when an
explicit &quot;use utf8&quot; is needed. See utf8.</p>

<p>BOM-marked scripts and UTF-16 scripts autodetected If a
Perl script begins marked with the Unicode BOM (UTF-16LE,
UTF16-BE, or UTF-8), or if the script looks like
non-BOM-marked UTF-16 of either endianness, Perl will
correctly read in the script as Unicode. (BOMless UTF-8
cannot be effectively recognized or differentiated from ISO
8859-1 or other eight-bit encodings.)</p>

<p>&quot;use encoding&quot; needed to upgrade non-Latin-1
byte strings By default, there is a fundamental asymmetry in
Perls Unicode model: implicit upgrading from byte strings to
Unicode strings assumes that they were encoded in ISO 8859-1
(Latin-1), but Unicode strings are downgraded with UTF-8
encoding. This happens because the first 256 codepoints in
Unicode happens to agree with Latin-1.</p>

<p>See &quot;Byte and Character Semantics&quot; for more
details.</p>

<p>Byte and Character Semantics Beginning with version 5.6,
Perl uses logically-wide characters to represent strings
internally.</p>

<p>In future, Perl-level operations will be expected to
work with characters rather than bytes.</p>

<p>However, as an interim compatibility measure, Perl aims
to provide a safe migration path from byte semantics to
character semantics for programs. For operations where Perl
can unambiguously decide that the input data are characters,
Perl switches to character semantics. For operations where
this determination cannot be made without additional
information from the user, Perl decides in favor of
compatibility and chooses to use byte semantics.</p>

<p>Under byte semantics, when &quot;use locale&quot; is in
effect, Perl uses the semantics associated with the current
locale. Absent a &quot;use locale&quot;, Perl currently uses
US-ASCII (or Basic Latin in Unicode terminology) byte
semantics, meaning that characters whose ordinal numbers are
in the range 128 - 255 are undefined except for their
ordinal numbers. This means that none have case (upper and
lower), nor are any a member of character classes, like
&quot;[:alpha:]&quot; or &quot;576 the &quot;W&quot; class
or the Perl regular expression extension
&quot;[:^alpha:]&quot;.)</p>

<p>This behavior preserves compatibility with earlier
versions of Perl, which allowed byte semantics in Perl
operations only if none of the program s inputs were marked
as being as source of Unicode character data. Such data may
come from filehandles, from calls to external programs, from
information provided by the system (such as %ENV), or from
literals and constants in the source text.</p>

<p>The &quot;bytes&quot; pragma will always, regardless of
platform, force byte semantics in a particular lexical
scope. See bytes.</p>

<p>The &quot;utf8&quot; pragma is primarily a compatibility
device that enables recognition of UTF-(8|EBCDIC) in
literals encountered by the parser. Note that this pragma is
only required while Perl defaults to byte semantics; when
character semantics become the default, this pragma may
become a no-op. See utf8.</p>

<p>Unless explicitly stated, Perl operators use character
semantics for Unicode data and byte semantics for
non-Unicode data. The decision to use character semantics is
made transparently. If input data comes from a Unicode
source--for example, if a character encoding layer is added
to a filehandle or a literal Unicode string constant appears
in a program--character semantics apply. Otherwise, byte
semantics are in effect. The &quot;bytes&quot; pragma should
be used to force byte semantics on Unicode data.</p>

<p>If strings operating under byte semantics and strings
with Unicode character data are concatenated, the new string
will have character semantics. This can cause surprises: See
&quot;BUGS&quot;, below</p>

<p>Under character semantics, many operations that formerly
operated on bytes now operate on characters. A character in
Perl is logically just a number ranging from 0 to 2**31 or
so. Larger characters may encode into longer sequences of
bytes internally, but this internal detail is mostly hidden
for Perl code. See perluniintro for more.</p>

<p>Effects of Character Semantics Character semantics have
the following effects:</p>

<p>&middot; Strings--including hash keys--and regular
expression patterns may contain characters that have an
ordinal value larger than 255.</p>

<p>If you use a Unicode editor to edit your program,
Unicode characters may occur directly within the literal
strings in UTF-8 encoding, or UTF-16. (The former requires a
BOM or &quot;use utf8&quot;, the latter requires a BOM.)</p>

<p>Unicode characters can also be added to a string by
using the &quot;.}&quot; notation. The Unicode code for the
desired character, in hexadecimal, should be placed in the
braces. For instance, a smiley face is &quot;}&quot;. This
encoding scheme works for all characters, but for characters
under 0x100, note that Perl may use an 8 bit encoding
internally, for optimization and/or backward
compatibility.</p>

<p>Additionally, if you</p>

<p>use charnames &rsquo;:full&rsquo;;</p>

<p>you can use the &quot;.}&quot; notation and put the
official Unicode character name within the braces, such as
&quot;HITE SMILING FACE}&quot;.</p>

<p>&middot; If an appropriate encoding is specified,
identifiers within the Perl script may contain Unicode
alphanumeric characters, including ideographs. Perl does not
currently attempt to canonicalize variable names.</p>

<p>&middot; Regular expressions match characters instead of
bytes. &quot;.&quot; matches a character instead of a
byte.</p>

<p>&middot; Character classes in regular expressions match
characters instead of bytes and match against the character
properties specified in the Unicode properties database.
&quot;552 Japanese ideograph, for instance.</p>

<p>&middot; Named Unicode properties, scripts, and block
ranges may be used like character classes via the
&quot;{}&quot; &quot;matches property&quot; construct and
the &quot;P{}&quot; negation, &quot;doesnt match
property&quot;.</p>

<p>See &quot;Unicode Character Properties&quot; for more
details.</p>

<p>You can define your own character properties and use
them in the regular expression with the &quot;{}&quot; or
&quot;P{}&quot; construct.</p>

<p>See &quot;User-Defined Character Properties&quot; for
more details.</p>

<p>&middot; The special pattern &quot;a combining character
sequence&quot; in Standardese--where the first character is
a base character and subsequent characters are mark
characters that apply to the base character. &quot;
&quot;(?&gt;PMM*)&quot;.</p>

<p>&middot; The &quot;tr///&quot; operator translates
characters instead of bytes. Note that the
&quot;tr///CU&quot; functionality has been removed. For
similar functionality see pack(U0, ...) and pack(C0,
...).</p>

<p>&middot; Case translation operators use the Unicode case
translation tables when character input is provided. Note
that &quot;uc()&quot;, or &quot;U&quot; in interpolated
strings, translates to uppercase, while &quot;ucfirst&quot;,
or &quot;&quot; in interpolated strings, translates to
titlecase in languages that make the distinction.</p>

<p>&middot; Most operators that deal with positions or
lengths in a string will automatically switch to using
character positions, including &quot;chop()&quot;,
&quot;chomp()&quot;, &quot;substr()&quot;,
&quot;pos()&quot;, &quot;index()&quot;,
&quot;rindex()&quot;, &quot;sprintf()&quot;,
&quot;write()&quot;, and &quot;length()&quot;. An operator
that specifically does not switch is &quot;vec()&quot;.
Operators that really don t care include operators that
treat strings as a bucket of bits such as
&quot;sort()&quot;, and operators dealing with
filenames.</p>

<p>&middot; The &quot;pack()&quot;/&quot;unpack()&quot;
letter &quot;C&quot; does not change, since it is often used
for byte-oriented formats. Again, think &quot;char&quot; in
the C language.</p>

<p>There is a new &quot;U&quot; specifier that converts
between Unicode characters and code points. There is also a
&quot;W&quot; specifier that is the equivalent of
&quot;chr&quot;/&quot;ord&quot; and properly handles
character values even if they are above 255.</p>

<p>&middot; The &quot;chr()&quot; and &quot;ord()&quot;
functions work on characters, similar to
&quot;pack(&quot;W&quot;)&quot; and
&quot;unpack(&quot;W&quot;)&quot;, not
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot;.
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot; are methods for emulating
byte- oriented &quot;chr()&quot; and &quot;ord()&quot; on
Unicode strings. While these methods reveal the internal
encoding of Unicode strings, that is not something one
normally needs to care about at all.</p>

<p>&middot; The bit string operators, &quot;&amp; | ^
~&quot;, can operate on character data. However, for
backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal
value, one should not use &quot;~&quot; (the bit complement)
with characters of both values less than 256 and values
greater than 256. Most importantly, DeMorgans laws
(&quot;~($x|$y) eq ~$x&amp;~$y&quot; and &quot;~($x&amp;$y)
eq ~$x|~$y&quot;) will not hold. The reason for this
mathematical faux pas is that the complement cannot return
both the 8-bit (byte-wide) bit complement and the full
character-wide bit complement.</p>

<p>&middot; lc(), uc(), lcfirst(), and ucfirst() work for
the following cases:</p>

<p>&middot; the case mapping is from a single Unicode
character to another single Unicode character, or</p>

<p>&middot; the case mapping is from a single Unicode
character to more than one Unicode character.</p>

<p>Things to do with locales (Lithuanian, Turkish, Azeri)
do not work since Perl does not understand the concept of
Unicode locales.</p>

<p>See the Unicode Technical Report #21, Case Mappings, for
more details.</p>

<p>But you can also define your own mappings to be used in
the lc(), lcfirst(), uc(), and ucfirst() (or their
string-inlined versions).</p>

<p>See &quot;User-Defined Case Mappings&quot; for more
details.</p>

<p>&middot; And finally, &quot;scalar reverse()&quot;
reverses by character rather than by byte.</p>

<p>Unicode Character Properties Named Unicode properties,
scripts, and block ranges may be used like character classes
via the &quot;{}&quot; &quot;matches property&quot;
construct and the &quot;P{}&quot; negation, &quot;doesnt
match property&quot;.</p>

<p>For instance, &quot;{Lu}&quot; matches any character
with the Unicode &quot;Lu&quot; (Letter, uppercase)
property, while &quot;{M}&quot; matches any character with
an &quot;M&quot; (mark--accents and such) property. Brackets
are not required for single letter properties, so
&quot;{M}&quot; is equivalent to &quot;M&quot;. Many
predefined properties are available, such as
&quot;{Mirrored}&quot; and &quot;{Tibetan}&quot;.</p>

<p>The official Unicode script and block names have spaces
and dashes as separators, but for convenience you can use
dashes, spaces, or underbars, and case is unimportant. It is
recommended, however, that for consistency you use the
following naming: the official Unicode script, property, or
block name (see below for the additional rules that apply to
block names) with whitespace and dashes removed, and the
words &quot;uppercase-first-lowercase-rest&quot;.
&quot;Latin-1 Supplement&quot; thus becomes
&quot;Latin1Supplement&quot;.</p>

<p>You can also use negation in both &quot;{}&quot; and
&quot;P{}&quot; by introducing a caret (^) between the first
brace and the property name: &quot;{^Tamil}&quot; is equal
to &quot;P{Tamil}&quot;.</p>

<p>NOTE: the properties, scripts, and blocks listed here
are as of Unicode 5.0.0 in July 2006.</p>

<p>General Category Here are the basic Unicode General
Category properties, followed by their long form. You can
use either; &quot;{Lu}&quot; and
&quot;{UppercaseLetter}&quot;, for instance, are
identical.</p>

<p>Short Long</p>

<p>L Letter LC CasedLetter Lu UppercaseLetter Ll
LowercaseLetter Lt TitlecaseLetter Lm ModifierLetter Lo
OtherLetter</p>

<p>M Mark Mn NonspacingMark Mc SpacingMark Me
EnclosingMark</p>

<p>N Number Nd DecimalNumber Nl LetterNumber No
OtherNumber</p>

<p>P Punctuation Pc ConnectorPunctuation Pd DashPunctuation
Ps OpenPunctuation Pe ClosePunctuation Pi InitialPunctuation
(may behave like Ps or Pe depending on usage) Pf
FinalPunctuation (may behave like Ps or Pe depending on
usage) Po OtherPunctuation</p>

<p>S Symbol Sm MathSymbol Sc CurrencySymbol Sk
ModifierSymbol So OtherSymbol</p>

<p>Z Separator Zs SpaceSeparator Zl LineSeparator Zp
ParagraphSeparator</p>

<p>C Other Cc Control Cf Format Cs Surrogate (not usable)
Co PrivateUse Cn Unassigned</p>

<p>Single-letter properties match all characters in any of
the two- letter sub-properties starting with the same
letter. &quot;LC&quot; and &quot;L&amp;&quot; are special
cases, which are aliases for the set of &quot;Ll&quot;,
&quot;Lu&quot;, and &quot;Lt&quot;.</p>

<p>Because Perl hides the need for the user to understand
the internal representation of Unicode characters, there is
no need to implement the somewhat messy concept of
surrogates. &quot;Cs&quot; is therefore not supported.</p>

<p>Bidirectional Character Types Because scripts differ in
their directionality--Hebrew is written right to left, for
example--Unicode supplies these properties in the BidiClass
class:</p>

<p>Property Meaning</p>

<p>L Left-to-Right LRE Left-to-Right Embedding LRO
Left-to-Right Override R Right-to-Left AL Right-to-Left
Arabic RLE Right-to-Left Embedding RLO Right-to-Left
Override PDF Pop Directional Format EN European Number ES
European Number Separator ET European Number Terminator AN
Arabic Number CS Common Number Separator NSM Non-Spacing
Mark BN Boundary Neutral B Paragraph Separator S Segment
Separator WS Whitespace ON Other Neutrals</p>

<p>For example, &quot;{BidiClass:R}&quot; matches
characters that are normally written right to left.</p>

<p>Scripts The script names which can be used by
&quot;{...}&quot; and &quot;P{...}&quot;, such as in
&quot;{Latin}&quot; or &quot;{Cyrillic}&quot;, are as
follows:</p>

<p>Arabic Armenian Balinese Bengali Bopomofo Braille
Buginese Buhid CanadianAboriginal Cherokee Coptic Cuneiform
Cypriot Cyrillic Deseret Devanagari Ethiopic Georgian
Glagolitic Gothic Greek Gujarati Gurmukhi Han Hangul Hanunoo
Hebrew Hiragana Inherited Kannada Katakana Kharoshthi Khmer
Lao Latin Limbu LinearB Malayalam Mongolian Myanmar
NewTaiLue Nko Ogham OldItalic OldPersian Oriya Osmanya
PhagsPa Phoenician Runic Shavian Sinhala SylotiNagri Syriac
Tagalog Tagbanwa TaiLe Tamil Telugu Thaana Thai Tibetan
Tifinagh Ugaritic Yi</p>

<p>Extended property classes Extended property classes can
supplement the basic properties, defined by the PropList
Unicode database:</p>

<p>ASCIIHexDigit BidiControl Dash Deprecated Diacritic
Extender HexDigit Hyphen Ideographic IDSBinaryOperator
IDSTrinaryOperator JoinControl LogicalOrderException
NoncharacterCodePoint OtherAlphabetic
OtherDefaultIgnorableCodePoint OtherGraphemeExtend
OtherIDStart OtherIDContinue OtherLowercase OtherMath
OtherUppercase PatternSyntax PatternWhiteSpace QuotationMark
Radical SoftDotted STerm TerminalPunctuation
UnifiedIdeograph VariationSelector WhiteSpace</p>

<p>and there are further derived properties:</p>

<p>Alphabetic = Lu + Ll + Lt + Lm + Lo + Nl +
OtherAlphabetic Lowercase = Ll + OtherLowercase Uppercase =
Lu + OtherUppercase Math = Sm + OtherMath</p>

<p>IDStart = Lu + Ll + Lt + Lm + Lo + Nl + OtherIDStart
IDContinue = IDStart + Mn + Mc + Nd + Pc +
OtherIDContinue</p>

<p>DefaultIgnorableCodePoint =
OtherDefaultIgnorableCodePoint + Cf + Cc + Cs +
Noncharacters + VariationSelector - WhiteSpace - FFF9..FFFB
(Annotation Characters)</p>

<p>Any = Any code points (i.e. U+0000 to U+10FFFF) Assigned
= Any non-Cn code points (i.e. synonym for P{Cn}) Unassigned
= Synonym for {Cn} ASCII = ASCII (i.e. U+0000 to U+007F)</p>

<p>Common = Any character (or unassigned code point) not
explicitly assigned to a script</p>

<p>Use of &quot;Is&quot; Prefix For backward compatibility
(with Perl 5.6), all properties mentioned so far may have
&quot;Is&quot; prepended to their name, so
&quot;P{IsLu}&quot;, for example, is equal to
&quot;P{Lu}&quot;.</p>

<p>Blocks In addition to scripts, Unicode also defines
blocks of characters. The difference between scripts and
blocks is that the concept of scripts is closer to natural
languages, while the concept of blocks is more of an
artificial grouping based on groups of 256 Unicode
characters. For example, the &quot;Latin&quot; script
contains letters from many blocks but does not contain all
the characters from those blocks. It does not, for example,
contain digits, because digits are shared across many
scripts. Digits and similar groups, like punctuation, are in
a category called &quot;Common&quot;.</p>

<p>For more about scripts, see the UAX#24 &quot;Script
Names&quot;:</p>

<p>http://www.unicode.org/reports/tr24/</p>

<p>For more about blocks, see:</p>

<p>http://www.unicode.org/Public/UNIDATA/Blocks.txt</p>

<p>Block names are given with the &quot;In&quot; prefix.
For example, the Katakana block is referenced via
&quot;{InKatakana}&quot;. The &quot;In&quot; prefix may be
omitted if there is no naming conflict with a script or any
other property, but it is recommended that &quot;In&quot;
always be used for block tests to avoid confusion.</p>

<p>These block names are supported:</p>

<p>InAegeanNumbers InAlphabeticPresentationForms
InAncientGreekMusicalNotation InAncientGreekNumbers InArabic
InArabicPresentationFormsA InArabicPresentationFormsB
InArabicSupplement InArmenian InArrows InBalinese
InBasicLatin InBengali InBlockElements InBopomofo
InBopomofoExtended InBoxDrawing InBraillePatterns InBuginese
InBuhid InByzantineMusicalSymbols InCJKCompatibility
InCJKCompatibilityForms InCJKCompatibilityIdeographs
InCJKCompatibilityIdeographsSupplement
InCJKRadicalsSupplement InCJKStrokes
InCJKSymbolsAndPunctuation InCJKUnifiedIdeographs
InCJKUnifiedIdeographsExtensionA
InCJKUnifiedIdeographsExtensionB InCherokee
InCombiningDiacriticalMarks
InCombiningDiacriticalMarksSupplement
InCombiningDiacriticalMarksforSymbols InCombiningHalfMarks
InControlPictures InCoptic InCountingRodNumerals InCuneiform
InCuneiformNumbersAndPunctuation InCurrencySymbols
InCypriotSyllabary InCyrillic InCyrillicSupplement InDeseret
InDevanagari InDingbats InEnclosedAlphanumerics
InEnclosedCJKLettersAndMonths InEthiopic InEthiopicExtended
InEthiopicSupplement InGeneralPunctuation InGeometricShapes
InGeorgian InGeorgianSupplement InGlagolitic InGothic
InGreekExtended InGreekAndCoptic InGujarati InGurmukhi
InHalfwidthAndFullwidthForms InHangulCompatibilityJamo
InHangulJamo InHangulSyllables InHanunoo InHebrew
InHighPrivateUseSurrogates InHighSurrogates InHiragana
InIPAExtensions InIdeographicDescriptionCharacters InKanbun
InKangxiRadicals InKannada InKatakana
InKatakanaPhoneticExtensions InKharoshthi InKhmer
InKhmerSymbols InLao InLatin1Supplement InLatinExtendedA
InLatinExtendedAdditional InLatinExtendedB InLatinExtendedC
InLatinExtendedD InLetterlikeSymbols InLimbu
InLinearBIdeograms InLinearBSyllabary InLowSurrogates
InMalayalam InMathematicalAlphanumericSymbols
InMathematicalOperators InMiscellaneousMathematicalSymbolsA
InMiscellaneousMathematicalSymbolsB InMiscellaneousSymbols
InMiscellaneousSymbolsAndArrows InMiscellaneousTechnical
InModifierToneLetters InMongolian InMusicalSymbols InMyanmar
InNKo InNewTaiLue InNumberForms InOgham InOldItalic
InOldPersian InOpticalCharacterRecognition InOriya InOsmanya
InPhagspa InPhoenician InPhoneticExtensions
InPhoneticExtensionsSupplement InPrivateUseArea InRunic
InShavian InSinhala InSmallFormVariants
InSpacingModifierLetters InSpecials
InSuperscriptsAndSubscripts InSupplementalArrowsA
InSupplementalArrowsB InSupplementalMathematicalOperators
InSupplementalPunctuation InSupplementaryPrivateUseAreaA
InSupplementaryPrivateUseAreaB InSylotiNagri InSyriac
InTagalog InTagbanwa InTags InTaiLe InTaiXuanJingSymbols
InTamil InTelugu InThaana InThai InTibetan InTifinagh
InUgaritic InUnifiedCanadianAboriginalSyllabics
InVariationSelectors InVariationSelectorsSupplement
InVerticalForms InYiRadicals InYiSyllables
InYijingHexagramSymbols</p>

<p>User-Defined Character Properties You can define your
own character properties by defining subroutines whose names
begin with &quot;In&quot; or &quot;Is&quot;. The subroutines
can be defined in any package. The user-defined properties
can be used in the regular expression &quot;&quot; and
&quot;P&quot; constructs; if you are using a user-defined
property from a package other than the one you are in, you
must specify its package in the &quot;&quot; or
&quot;P&quot; construct.</p>

<p># assuming property IsForeign defined in Lang:: package
main; # property package name required if ($txt =~
/{Lang::IsForeign}+/) { ... }</p>

<p>package Lang; # property package name not required if
($txt =~ /{IsForeign}+/) { ... }</p>

<p>Note that the effect is compile-time and immutable once
defined.</p>

<p>The subroutines must return a specially-formatted
string, with one or more newline-separated lines. Each line
must be one of the following:</p>

<p>&middot; A single hexadecimal number denoting a Unicode
code point to include.</p>

<p>&middot; Two hexadecimal numbers separated by horizontal
whitespace (space or tabular characters) denoting a range of
Unicode code points to include.</p>

<p>&middot; Something to include, prefixed by
&quot;+&quot;: a built-in character property (prefixed by
&quot;utf8::&quot;) or a user-defined character property, to
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p>&middot; Something to exclude, prefixed by
&quot;-&quot;: an existing character property (prefixed by
&quot;utf8::&quot;) or a user-defined character property, to
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p>&middot; Something to negate, prefixed &quot;!&quot;: an
existing character property (prefixed by &quot;utf8::&quot;)
or a user-defined character property, to represent all the
characters in that property; two hexadecimal code points for
a range; or a single hexadecimal code point.</p>

<p>&middot; Something to intersect with, prefixed by
&quot;&amp;&quot;: an existing character property (prefixed
by &quot;utf8::&quot;) or a user-defined character property,
for all the characters except the characters in the
property; two hexadecimal code points for a range; or a
single hexadecimal code point.</p>

<p>For example, to define a property that covers both the
Japanese syllabaries (hiragana and katakana), you can
define</p>

<p>sub InKana { return &lt;&lt;END; 3040309F 30A030FF END
}</p>

<p>Imagine that the here-doc end marker is at the beginning
of the line. Now you can use &quot;{InKana}&quot; and
&quot;P{InKana}&quot;.</p>

<p>You could also have used the existing block property
names:</p>

<p>sub InKana { return &lt;&lt;&rsquo;END&rsquo;;
+utf8::InHiragana +utf8::InKatakana END }</p>

<p>Suppose you wanted to match only the allocated
characters, not the raw block ranges: in other words, you
want to remove the non-characters:</p>

<p>sub InKana { return &lt;&lt;&rsquo;END&rsquo;;
+utf8::InHiragana +utf8::InKatakana -utf8::IsCn END }</p>

<p>The negation is useful for defining (surprise!) negated
classes.</p>

<p>sub InNotKana { return &lt;&lt;&rsquo;END&rsquo;;
!utf8::InHiragana -utf8::InKatakana +utf8::IsCn END }</p>

<p>Intersection is useful for getting the common characters
matched by two (or more) classes.</p>

<p>sub InFooAndBar { return &lt;&lt;&rsquo;END&rsquo;;
+main::Foo &amp;main::Bar END }</p>

<p>Its important to remember not to use &quot;&amp;&quot;
for the first set -- that would be intersecting with nothing
(resulting in an empty set).</p>

<p>User-Defined Case Mappings You can also define your own
mappings to be used in the lc(), lcfirst(), uc(), and
ucfirst() (or their string-inlined versions). The principle
is similar to that of user-defined character properties: to
define subroutines in the &quot;main&quot; package with
names like &quot;ToLower&quot; (for lc() and lcfirst()),
&quot;ToTitle&quot; (for the first character in ucfirst()),
and &quot;ToUpper&quot; (for uc(), and the rest of the
characters in ucfirst()).</p>

<p>The string returned by the subroutines needs now to be
three hexadecimal numbers separated by tabulators: start of
the source range, end of the source range, and start of the
destination range. For example:</p>

<p>sub ToUpper { return &lt;&lt;END; 006100630041 END }</p>

<p>defines an uc() mapping that causes only the characters
&quot;a&quot;, &quot;b&quot;, and &quot;c&quot; to be mapped
to &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, all other
characters will remain unchanged.</p>

<p>If there is no source range to speak of, that is, the
mapping is from a single character to another single
character, leave the end of the source range empty, but the
two tabulator characters are still needed. For example:</p>

<p>sub ToLower { return &lt;&lt;END; 00410061 END }</p>

<p>defines a lc() mapping that causes only &quot;A&quot; to
be mapped to &quot;a&quot;, all other characters will remain
unchanged.</p>

<p>(For serious hackers only) If you want to introspect the
default mappings, you can find the data in the directory
$Config{privlib}/unicore/To/. The mapping data is returned
as the here-document, and the &quot;utf8::ToSpecFoo&quot;
are special exception mappings derived from
&lt;$Config{privlib}&gt;/unicore/SpecialCasing.txt. The
&quot;Digit&quot; and &quot;Fold&quot; mappings that one can
see in the directory are not directly user-accessible, one
can use either the &quot;Unicode::UCD&quot; module, or just
match case-insensitively (thats when the &quot;Fold&quot;
mapping is used).</p>

<p>A final note on the user-defined case mappings: they
will be used only if the scalar has been marked as having
Unicode characters. Old byte- style strings will not be
affected.</p>

<p>Character Encodings for Input and Output See Encode.</p>

<p>Unicode Regular Expression Support Level The following
list of Unicode support for regular expressions describes
all the features currently supported. The references to
&quot;Level N&quot; and the section numbers refer to the
Unicode Technical Standard #18, &quot;Unicode Regular
Expressions&quot;, version 11, in May 2005.</p>

<p>&middot; Level 1 - Basic Unicode Support</p>

<p>RL1.1 Hex Notation - done [1] RL1.2 Properties - done
[2][3] RL1.2a Compatibility Properties - done [4] RL1.3
Subtraction and Intersection - MISSING [5] RL1.4 Simple Word
Boundaries - done [6] RL1.5 Simple Loose Matches - done [7]
RL1.6 Line Boundaries - MISSING [8] RL1.7 Supplementary Code
Points - done [9]</p>

<p>[1] .} [2] {...} P{...} [3] supports not only minimal
list (general category, scripts, Alphabetic, Lowercase,
Uppercase, WhiteSpace, NoncharacterCodePoint,
DefaultIgnorableCodePoint, Any, ASCII, Assigned), but also
bidirectional types, blocks, etc. (see &quot;Unicode
Character Properties&quot;) [4] [5] can use regular
expression look-ahead [a] or user-defined character
properties [b] to emulate set operations [6] 0 [7] note that
Perl does Full case-folding in matching, not Simple: for
example U+1F88 is equivalent to U+1F00 U+03B9, not with
1F80. This difference matters mainly for certain Greek
capital letters with certain modifiers: the Full
case-folding decomposes the letter, while the Simple
case-folding would map it to a single character. [8] should
do ^ and $ also on U+000B (in C),), FF (, CR ( 0, NEL
(U+0085), LS (U+2028), and CRLF ( PS (U+2029); should also
affect &lt;&gt;, $., and script line numbers; should not
split lines within CRLF [c] (i.e. there is no empty and 0
line between [9] UTF-8/UTF-EBDDIC used in perl allows not
only U+10000 to U+10FFFF but also beyond U+10FFFF [d]</p>

<p>[a] You can mimic class subtraction using lookahead. For
example, what UTS#18 might write as</p>

<p>[{Greek}-[{UNASSIGNED}]]</p>

<p>in Perl can be written as:</p>

<p>(?!{Unassigned}){InGreekAndCoptic}
(?={Assigned}){InGreekAndCoptic}</p>

<p>But in this particular example, you probably really
want</p>

<p>{GreekAndCoptic}</p>

<p>which will match assigned characters known to be part of
the Greek script.</p>

<p>Also see the Unicode::Regex::Set module, it does
implement the full UTS#18 grouping, intersection, union, and
removal (subtraction) syntax.</p>

<p>[b] + for union, - for removal (set-difference), &amp;
for intersection (see &quot;User-Defined Character
Properties&quot;)</p>

<p>[c] Try the &quot;:crlf&quot; layer (see PerlIO).</p>

<p>[d] Avoid &quot;use warning &rsquo;utf8&rsquo;;&quot;
(or say &quot;no warning &rsquo;utf8&rsquo;;&quot;) to allow
U+FFFF (&quot;FFF}&quot;).</p>

<p>&middot; Level 2 - Extended Unicode Support</p>

<p>RL2.1 Canonical Equivalents - MISSING [10][11] RL2.2
Default Grapheme Clusters - MISSING [12][13] RL2.3 Default
Word Boundaries - MISSING [14] RL2.4 Default Loose Matches -
MISSING [15] RL2.5 Name Properties - MISSING [16] RL2.6
Wildcard Properties - MISSING</p>

<p>[10] see UAX#15 &quot;Unicode Normalization Forms&quot;
[11] have Unicode::Normalize but not integrated to regexes
[12] have at this level . should equal that [13] UAX#29
&quot;Text Boundaries&quot; considers CRLF and Hangul
syllable clusters as a single grapheme cluster. [14] see
UAX#29, Word Boundaries [15] see UAX#21 &quot;Case
Mappings&quot; [16] have .} but neither compute names of CJK
Ideographs and Hangul Syllables nor use a loose match
[e]</p>

<p>[e] &quot;.}&quot; allows namespaces (see
charnames).</p>

<p>&middot; Level 3 - Tailored Support</p>

<p>RL3.1 Tailored Punctuation - MISSING RL3.2 Tailored
Grapheme Clusters - MISSING [17][18] RL3.3 Tailored Word
Boundaries - MISSING RL3.4 Tailored Loose Matches - MISSING
RL3.5 Tailored Ranges - MISSING RL3.6 Context Matching -
MISSING [19] RL3.7 Incremental Matches - MISSING ( RL3.8
Unicode Set Sharing ) RL3.9 Possible Match Sets - MISSING
RL3.10 Folded Matching - MISSING [20] RL3.11 Submatchers -
MISSING</p>

<p>[17] see UAX#10 &quot;Unicode Collation Algorithms&quot;
[18] have Unicode::Collate but not integrated to regexes
[19] have (?&lt;=x) and (?=x), but look-aheads or
look-behinds should see outside of the target substring [20]
need insensitive matching for linguistic features other than
case; for example, hiragana to katakana, wide and narrow,
simplified Han to traditional Han (see UTR#30
&quot;Character Foldings&quot;)</p>

<p>Unicode Encodings Unicode characters are assigned to
code points, which are abstract numbers. To use these
numbers, various encodings are needed.</p>

<p>&middot; UTF-8</p>

<p>UTF-8 is a variable-length (1 to 6 bytes, current
character allocations require 4 bytes), byte-order
independent encoding. For ASCII (and we really do mean 7-bit
ASCII, not another 8-bit encoding), UTF-8 is
transparent.</p>

<p>The following table is from Unicode 3.2.</p>

<p>Code Points 1st Byte 2nd Byte 3rd Byte 4th Byte</p>

<p>U+0000..U+007F 00..7F U+0080..U+07FF C2..DF 80..BF
U+0800..U+0FFF E0 A0..BF 80..BF U+1000..U+CFFF E1..EC 80..BF
80..BF U+D000..U+D7FF ED 80..9F 80..BF U+D800..U+DFFF
******* ill-formed ******* U+E000..U+FFFF EE..EF 80..BF
80..BF U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
U+100000..U+10FFFF F4 80..8F 80..BF 80..BF</p>

<p>Note the &quot;A0..BF&quot; in
&quot;U+0800..U+0FFF&quot;, the &quot;80..9F&quot; in
&quot;U+D000...U+D7FF&quot;, the &quot;90..B&quot;F in
&quot;U+10000..U+3FFFF&quot;, and the &quot;80...8F&quot; in
&quot;U+100000..U+10FFFF&quot;. The &quot;gaps&quot; are
caused by legal UTF-8 avoiding non-shortest encodings: it is
technically possible to UTF-8-encode a single code point in
different ways, but that is explicitly forbidden, and the
shortest possible encoding should always be used. So thats
what Perl does.</p>

<p>Another way to look at it is via bits:</p>

<p>Code Points 1st Byte 2nd Byte 3rd Byte 4th Byte</p>

<p>0aaaaaaa 0aaaaaaa 00000bbbbbaaaaaa 110bbbbb 10aaaaaa
ccccbbbbbbaaaaaa 1110cccc 10bbbbbb 10aaaaaa
00000dddccccccbbbbbbaaaaaa 11110ddd 10cccccc 10bbbbbb
10aaaaaa</p>

<p>As you can see, the continuation bytes all begin with
10, and the leading bits of the start byte tell how many
bytes the are in the encoded character.</p>

<p>&middot; UTF-EBCDIC</p>

<p>Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is
ASCII-safe.</p>

<p>&middot; UTF-16, UTF-16BE, UTF-16LE, Surrogates, and
BOMs (Byte Order Marks)</p>

<p>The followings items are mostly for reference and
general Unicode knowledge, Perl doesn t use these constructs
internally.</p>

<p>UTF-16 is a 2 or 4 byte encoding. The Unicode code
points &quot;U+0000..U+FFFF&quot; are stored in a single
16-bit unit, and the code points
&quot;U+10000..U+10FFFF&quot; in two 16-bit units. The
latter case is using surrogates, the first 16-bit unit being
the high surrogate, and the second being the low
surrogate.</p>

<p>Surrogates are code points set aside to encode the
&quot;U+10000..U+10FFFF&quot; range of Unicode code points
in pairs of 16-bit units. The high surrogates are the range
&quot;U+D800..U+DBFF&quot;, and the low surrogates are the
range &quot;U+DC00..U+DFFF&quot;. The surrogate encoding
is</p>

<p>$hi = ($uni - 0x10000) / 0x400 + 0xD800; $lo = ($uni -
0x10000) % 0x400 + 0xDC00;</p>

<p>and the decoding is</p>

<p>$uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo -
0xDC00);</p>

<p>If you try to generate surrogates (for example by using
chr()), you will get a warning if warnings are turned on,
because those code points are not valid for a Unicode
character.</p>

<p>Because of the 16-bitness, UTF-16 is byte-order
dependent. UTF-16 itself can be used for in-memory
computations, but if storage or transfer is required either
UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings
must be chosen.</p>

<p>This introduces another problem: what if you just know
that your data is UTF-16, but you dont know which
endianness? Byte Order Marks, or BOMs, are a solution to
this. A special character has been reserved in Unicode to
function as a byte order marker: the character with the code
point &quot;U+FEFF&quot; is the BOM.</p>

<p>The trick is that if you read a BOM, you will know the
byte order, since if it was written on a big-endian
platform, you will read the bytes &quot;0xFE 0xFF&quot;, but
if it was written on a little-endian platform, you will read
the bytes &quot;0xFF 0xFE&quot;. (And if the originating
platform was writing in UTF-8, you will read the bytes
&quot;0xEF 0xBB 0xBF&quot;.)</p>

<p>The way this trick works is that the character with the
code point &quot;U+FFFE&quot; is guaranteed not to be a
valid Unicode character, so the sequence of bytes &quot;0xFF
0xFE&quot; is unambiguously &quot;BOM, represented in
little-endian format&quot; and cannot be &quot;U+FFFE&quot;,
represented in big- endian format&quot;.</p>

<p>&middot; UTF-32, UTF-32BE, UTF-32LE</p>

<p>The UTF-32 family is pretty much like the UTF-16 family,
expect that the units are 32-bit, and therefore the
surrogate scheme is not needed. The BOM signatures will be
&quot;0x00 0x00 0xFE 0xFF&quot; for BE and &quot;0xFF 0xFE
0x00 0x00&quot; for LE.</p>

<p>&middot; UCS-2, UCS-4</p>

<p>Encodings defined by the ISO 10646 standard. UCS-2 is a
16-bit encoding. Unlike UTF-16, UCS-2 is not extensible
beyond &quot;U+FFFF&quot;, because it does not use
surrogates. UCS-4 is a 32-bit encoding, functionally
identical to UTF-32.</p>

<p>&middot; UTF-7</p>

<p>A seven-bit safe (non-eight-bit) encoding, which is
useful if the transport or storage is not eight-bit safe.
Defined by RFC 2152.</p>

<p>Security Implications of Unicode &middot; Malformed
UTF-8</p>

<p>Unfortunately, the specification of UTF-8 leaves some
room for interpretation of how many bytes of encoded output
one should generate from one input Unicode character.
Strictly speaking, the shortest possible sequence of UTF-8
bytes should be generated, because otherwise there is
potential for an input buffer overflow at the receiving end
of a UTF-8 connection. Perl always generates the shortest
length UTF-8, and with warnings on Perl will warn about
non-shortest length UTF-8 along with other malformations,
such as the surrogates, which are not real Unicode code
points.</p>

<p>&middot; Regular expressions behave slightly differently
between byte data and character (Unicode) data. For example,
the &quot;word character&quot; character class &quot;1104
eight-bit bytes or Unicode.</p>

<p>In the first case, the set of &quot;768 default set of
alphabetic characters, digits, and the &quot;_&quot;--or, if
you are using a locale (see perllocale), the &quot;384 few
more letters according to your language and country.</p>

<p>In the second case, the &quot;768 larger. Most
importantly, even in the set of the first 256 characters, it
will probably match different characters: unlike most
locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters
somewhere as &quot;1440 LETTER ETH is a letter (unless you
happen to speak Icelandic), but Unicode does.</p>

<p>As discussed elsewhere, Perl has one foot (two hooves?)
planted in each of two worlds: the old world of bytes and
the new world of characters, upgrading from bytes to
characters when necessary. If your legacy code does not
explicitly use Unicode, no automatic switch-over to
characters should happen. Characters shouldnt get downgraded
to bytes, either. It is possible to accidentally mix bytes
and characters, however (see perluniintro), in which case
&quot;1368 Review your code. Use warnings and the
&quot;strict&quot; pragma.</p>

<p>Unicode in Perl on EBCDIC The way Unicode is handled on
EBCDIC platforms is still experimental. On such platforms,
references to UTF-8 encoding in this document and elsewhere
should be read as meaning the UTF-EBCDIC specified in
Unicode Technical Report 16, unless ASCII vs. EBCDIC issues
are specifically discussed. There is no
&quot;utfebcdic&quot; pragma or &quot;:utfebcdic&quot;
layer; rather, &quot;utf8&quot; and &quot;:utf8&quot; are
reused to mean the platform s &quot;natural&quot; 8-bit
encoding of Unicode. See perlebcdic for more discussion of
the issues.</p>

<p>Locales Usually locale settings and Unicode do not
affect each other, but there are a couple of exceptions:</p>

<p>&middot; You can enable automatic UTF-8-ification of
your standard file handles, default &quot;open()&quot;
layer, and @ARGV by using either the &quot;-C&quot; command
line switch or the &quot;PERL_UNICODE&quot; environment
variable, see perlrun for the documentation of the
&quot;-C&quot; switch.</p>

<p>&middot; Perl tries really hard to work both with
Unicode and the old byte- oriented world. Most often this is
nice, but sometimes Perls straddling of the proverbial fence
causes problems.</p>

<p>When Unicode Does Not Happen While Perl does have
extensive ways to input and output in Unicode, and few other
entry points like the @ARGV which can be interpreted as
Unicode (UTF-8), there still are many places where Unicode
(in some encoding or another) could be given as arguments or
received as results, or both, but it is not.</p>

<p>The following are such interfaces. For all of these
interfaces Perl currently (as of 5.8.3) simply assumes byte
strings both as arguments and results, or UTF-8 strings if
the &quot;encoding&quot; pragma has been used.</p>

<p>One reason why Perl does not attempt to resolve the role
of Unicode in this cases is that the answers are highly
dependent on the operating system and the file system(s).
For example, whether filenames can be in Unicode, and in
exactly what kind of encoding, is not exactly a portable
concept. Similarly for the qx and system: how well will the
command line interface (and which of them?) handle
Unicode?</p>

<p>&middot; chdir, chmod, chown, chroot, exec, link, lstat,
mkdir, rename, rmdir, stat, symlink, truncate, unlink,
utime, -X</p>

<p>&middot; %ENV</p>

<p>&middot; glob (aka the &lt;*&gt;)</p>

<p>&middot; open, opendir, sysopen</p>

<p>&middot; qx (aka the backtick operator), system</p>

<p>&middot; readdir, readlink</p>

<p>Forcing Unicode in Perl (Or Unforcing Unicode in Perl)
Sometimes (see &quot;When Unicode Does Not Happen&quot;)
there are situations where you simply need to force a byte
string into UTF-8, or vice versa. The low-level calls
utf8::upgrade($bytestring) and utf8::downgrade($utf8string[,
FAIL_OK]) are the answers.</p>

<p>Note that utf8::downgrade() can fail if the string
contains characters that dont fit into a byte.</p>

<p>Using Unicode in XS If you want to handle Perl Unicode
in XS extensions, you may find the following C APIs useful.
See also &quot;Unicode Support&quot; in perlguts for an
explanation about Unicode at the XS level, and perlapi for
the API details.</p>

<p>&middot; &quot;DO_UTF8(sv)&quot; returns true if the
&quot;UTF8&quot; flag is on and the bytes pragma is not in
effect. &quot;SvUTF8(sv)&quot; returns true if the
&quot;UTF8&quot; flag is on; the bytes pragma is ignored.
The &quot;UTF8&quot; flag being on does not mean that there
are any characters of code points greater than 255 (or 127)
in the scalar or that there are even any characters in the
scalar. What the &quot;UTF8&quot; flag means is that the
sequence of octets in the representation of the scalar is
the sequence of UTF-8 encoded code points of the characters
of a string. The &quot;UTF8&quot; flag being off means that
each octet in this representation encodes a single character
with code point 0..255 within the string. Perls Unicode
model is not to use UTF-8 until it is absolutely
necessary.</p>

<p>&middot; &quot;uvchr_to_utf8(buf, chr)&quot; writes a
Unicode character code point into a buffer encoding the code
point as UTF-8, and returns a pointer pointing after the
UTF-8 bytes. It works appropriately on EBCDIC machines.</p>

<p>&middot; &quot;utf8_to_uvchr(buf, lenp)&quot; reads
UTF-8 encoded bytes from a buffer and returns the Unicode
character code point and, optionally, the length of the
UTF-8 byte sequence. It works appropriately on EBCDIC
machines.</p>

<p>&middot; &quot;utf8_length(start, end)&quot; returns the
length of the UTF-8 encoded buffer in characters.
&quot;sv_len_utf8(sv)&quot; returns the length of the UTF-8
encoded scalar.</p>

<p>&middot; &quot;sv_utf8_upgrade(sv)&quot; converts the
string of the scalar to its UTF-8 encoded form.
&quot;sv_utf8_downgrade(sv)&quot; does the opposite, if
possible. &quot;sv_utf8_encode(sv)&quot; is like
sv_utf8_upgrade except that it does not set the
&quot;UTF8&quot; flag. &quot;sv_utf8_decode()&quot; does the
opposite of &quot;sv_utf8_encode()&quot;. Note that none of
these are to be used as general-purpose encoding or decoding
interfaces: &quot;use Encode&quot; for that.
&quot;sv_utf8_upgrade()&quot; is affected by the encoding
pragma but &quot;sv_utf8_downgrade()&quot; is not (since the
encoding pragma is designed to be a one-way street).</p>

<p>&middot; is_utf8_char(s) returns true if the pointer
points to a valid UTF-8 character.</p>

<p>&middot; &quot;is_utf8_string(buf, len)&quot; returns
true if &quot;len&quot; bytes of the buffer are valid
UTF-8.</p>

<p>&middot; &quot;UTF8SKIP(buf)&quot; will return the
number of bytes in the UTF-8 encoded character in the
buffer. &quot;UNISKIP(chr)&quot; will return the number of
bytes required to UTF-8-encode the Unicode character code
point. &quot;UTF8SKIP()&quot; is useful for example for
iterating over the characters of a UTF-8 encoded buffer;
&quot;UNISKIP()&quot; is useful, for example, in computing
the size required for a UTF-8 encoded buffer.</p>

<p>&middot; &quot;utf8_distance(a, b)&quot; will tell the
distance in characters between the two pointers pointing to
the same UTF-8 encoded buffer.</p>

<p>&middot; &quot;utf8_hop(s, off)&quot; will return a
pointer to a UTF-8 encoded buffer that is &quot;off&quot;
(positive or negative) Unicode characters displaced from the
UTF-8 buffer &quot;s&quot;. Be careful not to overstep the
buffer: &quot;utf8_hop()&quot; will merrily run off the end
or the beginning of the buffer if told to do so.</p>

<p>&middot; &quot;pv_uni_display(dsv, spv, len, pvlim,
flags)&quot; and &quot;sv_uni_display(dsv, ssv, pvlim,
flags)&quot; are useful for debugging the output of Unicode
strings and scalars. By default they are useful only for
debugging--they display all characters as hexadecimal code
points--but with the flags &quot;UNI_DISPLAY_ISPRINT&quot;,
&quot;UNI_DISPLAY_BACKSLASH&quot;, and
&quot;UNI_DISPLAY_QQ&quot; you can make the output more
readable.</p>

<p>&middot; &quot;ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2,
u2)&quot; can be used to compare two strings
case-insensitively in Unicode. For case- sensitive
comparisons you can just use &quot;memEQ()&quot; and
&quot;memNE()&quot; as usual.</p>

<p>For more information, see perlapi, and utf8.c and utf8.h
in the Perl source code distribution.</p>

<p>BUGS Interaction with Locales Use of locales with
Unicode data may lead to odd results. Currently, Perl
attempts to attach 8-bit locale info to characters in the
range 0..255, but this technique is demonstrably incorrect
for locales that use characters above that range when mapped
into Unicode. Perls Unicode support will also tend to run
slower. Use of locales with Unicode is discouraged.</p>

<p>Problems with characters whose ordinal numbers are in
the range 128 - 255 with no Locale specified Without a
locale specified, unlike all other characters or code
points, these characters have very different semantics in
byte semantics versus character semantics. In character
semantics they are interpreted as Unicode code points, which
means they are viewed as Latin-1 (ISO-8859-1). In byte
semantics, they are considered to be unassigned characters,
meaning that the only semantics they have is their ordinal
numbers, and that they are not members of various character
classes. None are considered to match &quot;672W&quot;.
Besides these class matches, the known operations that this
affects are those that change the case, regular expression
matching while ignoring case, and quotemeta(). This can lead
to unexpected results in which a string s semantics suddenly
change if a code point above 255 is appended to or removed
from it, which changes the string s semantics from byte to
character or vice versa. This behavior is scheduled to
change in version 5.12, but in the meantime, a workaround is
to always call utf8::upgrade($string), or to use the
standard modules Encode or charnames.</p>

<p>Interaction with Extensions When Perl exchanges data
with an extension, the extension should be able to
understand the UTF8 flag and act accordingly. If the
extension doesnt know about the flag, its likely that the
extension will return incorrectly-flagged data.</p>

<p>So if you re working with Unicode data, consult the
documentation of every module youre using if there are any
issues with Unicode data exchange. If the documentation does
not talk about Unicode at all, suspect the worst and
probably look at the source to learn how the module is
implemented. Modules written completely in Perl shouldnt
cause problems. Modules that directly or indirectly access
code written in other programming languages are at risk.</p>

<p>For affected functions, the simple strategy to avoid
data corruption is to always make the encoding of the
exchanged data explicit. Choose an encoding that you know
the extension can handle. Convert arguments passed to the
extensions to that encoding and convert results back from
that encoding. Write wrapper functions that do the
conversions for you, so you can later change the functions
when the extension catches up.</p>

<p>To provide an example, let s say the popular
Foo::Bar::escape_html function doesnt deal with Unicode data
yet. The wrapper function would convert the argument to raw
UTF-8 and convert the result back to Perls internal
representation like so:</p>

<p>sub my_escape_html ($) { my($what) = shift; return
unless defined $what;
Encode::decode_utf8(Foo::Bar::escape_html(Encode::encode_utf8($what)));
}</p>

<p>Sometimes, when the extension does not convert data but
just stores and retrieves them, you will be in a position to
use the otherwise dangerous Encode::_utf8_on() function. Let
s say the popular &quot;Foo::Bar&quot; extension, written in
C, provides a &quot;param&quot; method that lets you store
and retrieve data according to these prototypes:</p>

<p>$self-&gt;param($name, $value); # set a scalar $value =
$self-&gt;param($name); # retrieve a scalar</p>

<p>If it does not yet provide support for any encoding, one
could write a derived class with such a &quot;param&quot;
method:</p>

<p>sub param { my($self,$name,$value) = @_;
utf8::upgrade($name); # make sure it is UTF-8 encoded if
(defined $value) { utf8::upgrade($value); # make sure it is
UTF-8 encoded return $self-&gt;SUPER::param($name,$value); }
else { my $ret = $self-&gt;SUPER::param($name);
Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
return $ret; } }</p>

<p>Some extensions provide filters on data entry/exit
points, such as DB_File::filter_store_key and family. Look
out for such filters in the documentation of your
extensions, they can make the transition to Unicode data
much easier.</p>

<p>Speed Some functions are slower when working on UTF-8
encoded strings than on byte encoded strings. All functions
that need to hop over characters such as length(), substr()
or index(), or matching regular expressions can work much
faster when the underlying data are byte-encoded.</p>

<p>In Perl 5.8.0 the slowness was often quite spectacular;
in Perl 5.8.1 a caching scheme was introduced which will
hopefully make the slowness somewhat less spectacular, at
least for some operations. In general, operations with UTF-8
encoded strings are still slower. As an example, the Unicode
properties (character classes) like &quot;{Nd}&quot; are
known to be quite a bit slower (5-20 times) than their
simpler counterparts like &quot;&quot; (then again, there
268 Unicode characters matching &quot;Nd&quot; compared with
the 10 ASCII characters matching &quot;d&quot;).</p>

<p>Possible problems on EBCDIC platforms In earlier
versions, when byte and character data were concatenated,
the new string was sometimes created by decoding the byte
strings as ISO 8859-1 (Latin-1), even if the old Unicode
string used EBCDIC.</p>

<p>If you find any of these, please report them as
bugs.</p>

<p>Porting code from perl-5.6.X Perl 5.8 has a different
Unicode model from 5.6. In 5.6 the programmer was required
to use the &quot;utf8&quot; pragma to declare that a given
scope expected to deal with Unicode data and had to make
sure that only Unicode data were reaching that scope. If you
have code that is working with 5.6, you will need some of
the following adjustments to your code. The examples are
written such that the code will continue to work under 5.6,
so you should be safe to try them out.</p>

<p>&middot; A filehandle that should read or write
UTF-8</p>

<p>if ($] &gt; 5.007) { binmode $fh,
&quot;:encoding(utf8)&quot;; }</p>

<p>&middot; A scalar that is going to be passed to some
extension</p>

<p>Be it Compress::Zlib, Apache::Request or any extension
that has no mention of Unicode in the manpage, you need to
make sure that the UTF8 flag is stripped off. Note that at
the time of this writing (October 2002) the mentioned
modules are not UTF-8-aware. Please check the documentation
to verify if this is still true.</p>

<p>if ($] &gt; 5.007) { require Encode; $val =
Encode::encode_utf8($val); # make octets }</p>

<p>&middot; A scalar we got back from an extension</p>

<p>If you believe the scalar comes back as UTF-8, you will
most likely want the UTF8 flag restored:</p>

<p>if ($] &gt; 5.007) { require Encode; $val =
Encode::decode_utf8($val); }</p>

<p>&middot; Same thing, if you are really sure it is
UTF-8</p>

<p>if ($] &gt; 5.007) { require Encode;
Encode::_utf8_on($val); }</p>

<p>&middot; A wrapper for fetchrow_array and
fetchrow_hashref</p>

<p>When the database contains only UTF-8, a wrapper
function or method is a convenient way to replace all your
fetchrow_array and fetchrow_hashref calls. A wrapper
function will also make it easier to adapt to future
enhancements in your database driver. Note that at the time
of this writing (October 2002), the DBI has no standardized
way to deal with UTF-8 data. Please check the documentation
to verify if that is still true.</p>

<p>sub fetchrow { my($self, $sth, $what) = @_; # $what is
one of fetchrow_{array,hashref} if ($] &lt; 5.007) { return
$sth-&gt;$what; } else { require Encode; if (wantarray) { my
@arr = $sth-&gt;$what; for (@arr) { defined &amp;&amp; /[^
00-177]/ &amp;&amp; Encode::_utf8_on($_); } return @arr; }
else { my $ret = $sth-&gt;$what; if (ref $ret) { for my $k
(keys %$ret) { defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_) for $ret-&gt;{$k}; } return $ret; }
else { defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_) for $ret; return $ret; } } } }</p>

<p>&middot; A large scalar that you know can only contain
ASCII</p>

<p>Scalars that contain only ASCII and are marked as UTF-8
are sometimes a drag to your program. If you recognize such
a situation, just remove the UTF8 flag:</p>

<p>utf8::downgrade($val) if $] &gt; 5.007;</p>

<p>SEE ALSO perlunitut, perluniintro, Encode, open, utf8,
bytes, perlretut, &quot;${^UNICODE}&quot; in perlvar</p>

<p>perl v5.10.1 2009-05-14 PERLUNICODE(1)</p>
<hr>
</body>
</html>
