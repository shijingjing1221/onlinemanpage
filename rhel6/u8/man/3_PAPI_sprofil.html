<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:25:52 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PAPI_sprofil(3) PAPI PAPI_sprofil(3)</p>

<p>NAME PAPI_sprofil - generate PC histogram data from
multiple code regions where hardware counter overflow
occurs</p>

<p>SYNOPSIS C Interface #include &lt;papi.h&gt; int
PAPI_sprofil(PAPI_sprofil_t * prof, int profcnt, int
EventSet, int EventCode, int threshold, int flags );</p>

<p>Fortran Interface The profiling routines have no Fortran
interface.</p>

<p>DESCRIPTION PAPI_sprofil() is a structure driven
profiler that profiles one or more disjoint regions of code
in a single call. It accepts a pointer to a preinitialized
array of sprofil structures, and initiates profiling based
on the values contained in the array. Each structure in the
array defines the profiling parameters that are normally
passed to PAPI_pro- fil(). For more information on
profiling, see: PAPI_pofil(3)</p>

<p>STRUCTURE FIELDS *pr_base -- pointer to the base address
of the buffer.</p>

<p>pr_size -- the size of the histogram buffer in
pr_base.</p>

<p>pr_off -- the start address of the region to be
profiled.</p>

<p>pr_scale -- the scaling factor applied to the
buffer.</p>

<p>These fields are described in greater detail in the
documentation for PAPI_pofil(3)</p>

<p>ARGUMENTS *prof -- pointer to an array of PAPI_sprofil_t
structures.</p>

<p>profcnt -- number of structures in the prof array for
hardware profil- ing.</p>

<p>EventSet -- The PAPI EventSet to profile. This EventSet
is marked as profiling-ready, but profiling doesnt actually
start until a PAPI_start() call is issued.</p>

<p>EventCode -- Code of the Event in the EventSet to
profile. This event must already be a member of the
EventSet.</p>

<p>threshold -- minimum number of events that must occur
before the PC is sampled. If hardware overflow is supported
for your substrate, this threshold will trigger an interrupt
when reached. Otherwise, the coun- ters will be sampled
periodically and the PC will be recorded for the first
sample that exceeds the threshold. If the value of threshold
is 0, profiling will be disabled for this event.</p>

<p>flags -- bit pattern to control profiling behavior.
Defined values are given in a table in the documentation for
PAPI_pofil(3)</p>

<p>RETURN VALUES On success, this function returns PAPI_OK.
On error, a non-zero error code is returned.</p>

<p>ERRORS Error returns for PAPI_sprofil() are identical to
those for PAPI_pro- fil(3) Please refer to that page for
further details.</p>

<p>EXAMPLES int retval; unsigned long length;
PAPI_exe_info_t *prginfo; unsigned short *profbuf1,
*profbuf2, profbucket; PAPI_sprofil_t sprof[3];</p>

<p>if ((prginfo = PAPI_get_executable_info()) == NULL)
handle_error(1);</p>

<p>length = (unsigned long)(prginfo-&gt;text_end -
prginfo-&gt;text_start);</p>

<p>/* Allocate 2 buffers of equal length */ profbuf1 =
(unsigned short *)malloc(length); profbuf2 = (unsigned short
*)malloc(length); if ((profbuf1 == NULL) || (profbuf2 ==
NULL)) handle_error(1); memset(profbuf1,0x00,length);
memset(profbuf2,0x00,length);</p>

<p>/* First buffer */ sprof[0].pr_base = profbuf1;
sprof[0].pr_size = length; sprof[0].pr_off = (caddr_t)
DO_FLOPS; sprof[0].pr_scale = 0x10000;</p>

<p>/* Second buffer */ sprof[1].pr_base = profbuf2;
sprof[1].pr_size = length; sprof[1].pr_off = (caddr_t)
DO_READS; sprof[1].pr_scale = 0x10000;</p>

<p>/* Overflow bucket */ sprof[2].pr_base = profbucket;
sprof[2].pr_size = 1; sprof[2].pr_off = 0; sprof[2].pr_scale
= 0x0002;</p>

<p>if ((retval = PAPI_sprofil(sprof, EventSet, PAPI_FP_INS,
1000000, PAPI_PROFIL_POSIX | PAPI_PROFIL_BUCKET_16)) !=
PAPI_OK) handle_error(retval);</p>

<p>BUGS These functions have no known bugs.</p>

<p>SEE ALSO PAPI_profil(3), PAPI_get_executable_info(3),
PAPI_overflow(3)</p>

<p>PAPI Programmer s Reference September, 2004
PAPI_sprofil(3)</p>
<hr>
</body>
</html>
