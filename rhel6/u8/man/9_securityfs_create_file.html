<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:33:30 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SECURITYFS_CREATE_FI(9) Security Framework
SECURITYFS_CREATE_FI(9)</p>

<p>NAME securityfs_create_file - create a file in the
securityfs filesystem</p>

<p>SYNOPSIS struct dentry * securityfs_create_file(const
char * name, mode_t mode, struct dentry * parent, void *
data, const struct file_operations * fops);</p>

<p>ARGUMENTS name a pointer to a string containing the name
of the file to create.</p>

<p>mode the permission that the file should have</p>

<p>parent a pointer to the parent dentry for this file.
This should be a directory dentry if set. If this parameter
is NULL, then the file will be created in the root of the
securityfs filesystem.</p>

<p>data a pointer to something that the caller will want to
get to later on. The inode.i_private pointer will point to
this value on the open call.</p>

<p>fops a pointer to a struct file_operations that should
be used for this file.</p>

<p>DESCRIPTION This is the basic create a file function for
securityfs. It allows for a wide range of flexibility in
creating a file, or a directory (if you want to create a
directory, the securityfs_create_dir function is recommended
to be used instead).</p>

<p>This function returns a pointer to a dentry if it
succeeds. This pointer must be passed to the
securityfs_remove function when the file is to be removed
(no automatic cleanup happens if your module is unloaded,
you are responsible here). If an error occurs, the function
will return the erorr value (via ERR_PTR).</p>

<p>If securityfs is not enabled in the kernel, the value
-ENODEV is returned.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
SECURITYFS_CREATE_FI(9)</p>
<hr>
</body>
</html>
