<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:34:28 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SIGQUEUE(2) Linux Programmer s Manual SIGQUEUE(2)</p>

<p>NAME sigqueue, rt_sigqueueinfo - queue a signal and data
to a process</p>

<p>SYNOPSIS #include &lt;signal.h&gt;</p>

<p>int sigqueue(pid_t pid, int sig, const union sigval
value);</p>

<p>Feature Test Macro Requirements for glibc (see
feature_test_macros(7)):</p>

<p>sigqueue(): _POSIX_C_SOURCE &gt;= 199309L</p>

<p>DESCRIPTION sigqueue() sends the signal specified in sig
to the process whose PID is given in pid. The permissions
required to send a signal are the same as for kill(2). As
with kill(2), the null signal (0) can be used to check if a
process with a given PID exists.</p>

<p>The value argument is used to specify an accompanying
item of data (either an integer or a pointer value) to be
sent with the signal, and has the following type:</p>

<p>union sigval { int sival_int; void *sival_ptr; };</p>

<p>If the receiving process has installed a handler for
this signal using the SA_SIGINFO flag to sigaction(2), then
it can obtain this data via the si_value field of the
siginfo_t structure passed as the second argument to the
handler. Furthermore, the si_code field of that struc- ture
will be set to SI_QUEUE.</p>

<p>RETURN VALUE On success, sigqueue() returns 0,
indicating that the signal was suc- cessfully queued to the
receiving process. Otherwise -1 is returned and errno is set
to indicate the error.</p>

<p>ERRORS EAGAIN The limit of signals which may be queued
has been reached. (See signal(7) for further
information.)</p>

<p>EINVAL sig was invalid.</p>

<p>EPERM The process does not have permission to send the
signal to the receiving process. For the required
permissions, see kill(2).</p>

<p>ESRCH No process has a PID matching pid.</p>

<p>VERSIONS This system call first appeared in Linux
2.2.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES If this function results in the sending of a
signal to the process that invoked it, and that signal was
not blocked by the calling thread, and no other threads were
willing to handle this signal (either by having it
unblocked, or by waiting for it using sigwait(3)), then at
least some signal must be delivered to this thread before
this function returns.</p>

<p>On Linux, the underlying system call is actually named
rt_sigqueue- info(), and differs in its third argument,
which is the siginfo_t structure that will be supplied to
the receiving processs signal han- dler or returned by the
receiving process s sigtimedwait(2) call. Inside the glibc
sigqueue() wrapper, this argument, info, is initial- ized as
follows:</p>

<p>info.si_signo = sig; /* argument supplied to sigqueue()
*/ info.si_code = SI_QUEUE; info.si_pid = getpid(); /*
Process ID of sender */ info.si_uid = getuid(); /* Real UID
of sender */ info.si_value = val; /* argument supplied to
sigqueue() */</p>

<p>SEE ALSO kill(2), sigaction(2), signal(2), sigwait(3),
signal(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2007-07-26 SIGQUEUE(2)</p>
<hr>
</body>
</html>
