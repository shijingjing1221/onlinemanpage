<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:15 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IBV_GET_ASYNC_EVENT(3) Libibverbs Programmer s Manual
IBV_GET_ASYNC_EVENT(3)</p>

<p>NAME ibv_get_async_event, ibv_ack_async_event - get or
acknowledge asyn- chronous events</p>

<p>SYNOPSIS #include &lt;infiniband/verbs.h&gt;</p>

<p>int ibv_get_async_event(struct ibv_context *context,
struct ibv_async_event *event);</p>

<p>void ibv_ack_async_event(struct ibv_async_event
*event);</p>

<p>DESCRIPTION ibv_get_async_event() waits for the next
async event of the RDMA device context context and returns
it through the pointer event, which is an ibv_async_event
struct, as defined in &lt;infiniband/verbs.h&gt;.</p>

<p>struct ibv_async_event { union { struct ibv_cq *cq; /*
CQ that got the event */ struct ibv_qp *qp; /* QP that got
the event */ struct ibv_srq *srq; /* SRQ that got the event
*/ int port_num; /* port number that got the event */ }
element; enum ibv_event_type event_type; /* type of the
event */ };</p>

<p>One member of the element union will be valid, depending
on the event_type member of the structure. event_type will
be one of the fol- lowing events:</p>

<p>QP events:</p>

<p>IBV_EVENT_QP_FATAL Error occurred on a QP and it
transitioned to error state</p>

<p>IBV_EVENT_QP_REQ_ERR Invalid Request Local Work Queue
Error</p>

<p>IBV_EVENT_QP_ACCESS_ERR Local access violation error</p>

<p>IBV_EVENT_COMM_EST Communication was established on a
QP</p>

<p>IBV_EVENT_SQ_DRAINED Send Queue was drained of
outstanding messages in progress</p>

<p>IBV_EVENT_PATH_MIG A connection has migrated to the
alternate path</p>

<p>IBV_EVENT_PATH_MIG_ERR A connection failed to migrate to
the alternate path</p>

<p>IBV_EVENT_QP_LAST_WQE_REACHED Last WQE Reached on a QP
associated with an SRQ</p>

<p>CQ events:</p>

<p>IBV_EVENT_CQ_ERR CQ is in error (CQ overrun)</p>

<p>SRQ events:</p>

<p>IBV_EVENT_SRQ_ERR Error occurred on an SRQ</p>

<p>IBV_EVENT_SRQ_LIMIT_REACHED SRQ limit was reached</p>

<p>Port events:</p>

<p>IBV_EVENT_PORT_ACTIVE Link became active on a port</p>

<p>IBV_EVENT_PORT_ERR Link became unavailable on a port</p>

<p>IBV_EVENT_LID_CHANGE LID was changed on a port</p>

<p>IBV_EVENT_PKEY_CHANGE P_Key table was changed on a
port</p>

<p>IBV_EVENT_SM_CHANGE SM was changed on a port</p>

<p>IBV_EVENT_CLIENT_REREGISTER SM sent a CLIENT_REREGISTER
request to a port</p>

<p>IBV_EVENT_GID_CHANGE GID table was changed on a port</p>

<p>CA events:</p>

<p>IBV_EVENT_DEVICE_FATAL CA is in FATAL state</p>

<p>ibv_ack_async_event() acknowledge the async event
event.</p>

<p>RETURN VALUE ibv_get_async_event() returns 0 on success,
and -1 on error.</p>

<p>ibv_ack_async_event() returns no value.</p>

<p>NOTES All async events that ibv_get_async_event()
returns must be acknowl- edged using ibv_ack_async_event().
To avoid races, destroying an object (CQ, SRQ or QP) will
wait for all affiliated events for the object to be
acknowledged; this avoids an application retrieving an
affiliated event after the corresponding object has already
been destroyed.</p>

<p>ibv_get_async_event() is a blocking function. If
multiple threads call this function simultaneously, then
when an async event occurs, only one thread will receive it,
and it is not possible to predict which thread will receive
it.</p>

<p>EXAMPLES The following code example demonstrates one
possible way to work with async events in non-blocking mode.
It performs the following steps:</p>

<p>1. Set the async events queue work mode to be
non-blocked 2. Poll the queue until it has an async event 3.
Get the async event and ack it</p>

<p>/* change the blocking mode of the async event queue */
flags = fcntl(ctx-&gt;async_fd, F_GETFL); rc =
fcntl(ctx-&gt;async_fd, F_SETFL, flags | O_NONBLOCK); if (rc
&lt; 0) { fprintf(stderr, &quot;Failed to change file
descriptor of async event queue0); return 1; }</p>

<p>/* * poll the queue until it has an event and sleep
ms_timeout * milliseconds between any iteration */
my_pollfd.fd = ctx-&gt;async_fd; my_pollfd.events = POLLIN;
my_pollfd.revents = 0;</p>

<p>do { rc = poll(&amp;my_pollfd, 1, ms_timeout); } while
(rc == 0); if (rc &lt; 0) { fprintf(stderr, &quot;poll
failed0); return 1; }</p>

<p>/* Get the async event */ if (ibv_get_async_event(ctx,
&amp;async_event)) { fprintf(stderr, &quot;Failed to get
async_event0); return 1; }</p>

<p>/* Ack the event */
ibv_ack_async_event(&amp;async_event);</p>

<p>SEE ALSO ibv_open_device(3)</p>

<p>AUTHORS Dotan Barak &lt;dotanba@gmail.com&gt;</p>

<p>libibverbs 2006-10-31 IBV_GET_ASYNC_EVENT(3)</p>
<hr>
</body>
</html>
