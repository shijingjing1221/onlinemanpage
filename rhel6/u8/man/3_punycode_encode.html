<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:30:36 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>punycode_encode(3) libidn punycode_encode(3)</p>

<p>NAME punycode_encode - API function</p>

<p>SYNOPSIS #include &lt;punycode.h&gt;</p>

<p>int punycode_encode(size_t input_length, const
punycode_uint [] input, const unsigned char [] case_flags,
size_t * output_length, char [] out- put);</p>

<p>ARGUMENTS size_t input_length The number of code points
in the input array and the number of flags in the case_flags
array.</p>

<p>const punycode_uint [] input An array of code points.
They are presumed to be Unicode code points, but that is not
strictly REQUIRED. The array contains code points, not code
units. UTF-16 uses code units D800 through DFFF to refer to
code points 10000..10FFFF. The code points D800..DFFF do not
occur in any valid Unicode string. The code points that can
occur in Unicode strings (0..D7FF and E000..10FFFF) are also
called Unicode scalar values.</p>

<p>const unsigned char [] case_flags A NULL pointer or an
array of boolean values parallel to the input array. Nonzero
(true, flagged) suggests that the corresponding Unicode
character be forced to uppercase after being decoded (if
possible), and zero (false, unflagged) suggests that it be
forced to lowercase (if pos- sible). ASCII code points
(0..7F) are encoded literally, except that ASCII letters are
forced to uppercase or lower- case according to the
corresponding case flags. If case_flags is a NULL pointer
then ASCII letters are left as they are, and other code
points are treated as unflagged.</p>

<p>size_t * output_length The caller passes in the maximum
number of ASCII code points that it can receive. On
successful return it will contain the number of ASCII code
points actually output.</p>

<p>char [] output An array of ASCII code points. It is
*not* null-termi- nated; it will contain zeros if and only
if the input con- tains zeros. (Of course the caller can
leave room for a terminator and add one if needed.)</p>

<p>DESCRIPTION Converts a sequence of code points (presumed
to be Unicode code points) to Punycode.</p>

<p>RETURN VALUE The return value can be any of the
Punycode_status values defined above except
PUNYCODE_BAD_INPUT. If not PUNYCODE_SUCCESS, then
output_size and output might contain garbage.</p>

<p>REPORTING BUGS Report bugs to
&lt;bug-libidn@gnu.org&gt;. GNU Libidn home page:
http://www.gnu.org/software/libidn/ General help using GNU
software: http://www.gnu.org/gethelp/</p>

<p>COPYRIGHT Copyright &copy; 2002, 2003, 2004, 2005, 2006,
2007, 2008, 2009, 2010 Simon Josefsson. Copying and
distribution of this file, with or without modification, are
permitted in any medium without royalty provided the
copyright notice and this notice are preserved.</p>

<p>SEE ALSO The full documentation for libidn is maintained
as a Texinfo manual. If the info and libidn programs are
properly installed at your site, the command</p>

<p>info libidn</p>

<p>should give you access to the complete manual.</p>

<p>libidn 1.18 punycode_encode(3)</p>
<hr>
</body>
</html>
