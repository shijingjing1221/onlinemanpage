<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:07:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CCISS(4) CCISS(4)</p>

<p>NAME cciss - HP Smart Array block driver</p>

<p>SYNOPSIS modprobe cciss [ cciss_allow_hpsa=1 ]</p>

<p>DESCRIPTION cciss is a block driver for older HP Smart
Array RAID controllers.</p>

<p>OPTIONS cciss_allow_hpsa=1 This option prevents the
cciss driver from attempt- ing to drive any controllers
which the hpsa driver is capable of controlling, which is to
say, the cciss driver is restricted by this option to the
following controllers:</p>

<p>Smart Array 5300 Smart Array 5i Smart Array 532 Smart
Array 5312 Smart Array 641 Smart Array 642 Smart Array 6400
Smart Array 6400 EM Smart Array 6i Smart Array P600 Smart
Array P400i Smart Array E200i Smart Array E200 Smart Array
E200i Smart Array E200i Smart Array E200i Smart Array
E500</p>

<p>SUPPORTED HARDWARE The cciss driver supports the
following Smart Array boards:</p>

<p>Smart Array 5300 Smart Array 5i Smart Array 532 Smart
Array 5312 Smart Array 641 Smart Array 642 Smart Array 6400
Smart Array 6400 U320 Expansion Module Smart Array 6i Smart
Array P600 Smart Array P800 Smart Array E400 Smart Array
P400i Smart Array E200 Smart Array E200i Smart Array E500
Smart Array P700m Smart Array P212 Smart Array P410 Smart
Array P410i Smart Array P411 Smart Array P812 Smart Array
P712m Smart Array P711m</p>

<p>CONFIGURATION DETAILS To configure HP Smart Array
controllers, use the HP Array Configuration Utiltiy (either
hpacuxe or hpacucli) or the Offline ROM-based Configu-
ration Utility (ORCA) run from the Smart Arrays option ROM
at boot time.</p>

<p>FILES DEVICE NODES The device naming scheme is as
follows: Major numbers: 104 cciss0 105 cciss1 106 cciss2 105
cciss3 108 cciss4 109 cciss5 110 cciss6 111 cciss7</p>

<p>Minor numbers: b7 b6 b5 b4 b3 b2 b1 b0 |----+----|
|----+----| | | | +-------- Partition ID (0=wholedev, 1-15
partition) | +-------------------- Logical Volume number</p>

<p>The device naming scheme is: /dev/cciss/c0d0 Controller
0, disk 0, whole device /dev/cciss/c0d0p1 Controller 0, disk
0, partition 1 /dev/cciss/c0d0p2 Controller 0, disk 0,
partition 2 /dev/cciss/c0d0p3 Controller 0, disk 0,
partition 3</p>

<p>/dev/cciss/c1d1 Controller 1, disk 1, whole device
/dev/cciss/c1d1p1 Controller 1, disk 1, partition 1
/dev/cciss/c1d1p2 Controller 1, disk 1, partition 2
/dev/cciss/c1d1p3 Controller 1, disk 1, partition 3</p>

<p>FILES IN /proc The files /proc/driver/cciss/cciss[0-9]+
contain information about the configuration of each
controller. For example:</p>

<p>someone@somehost:/proc/driver/cciss&gt; ls -l total 0
-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss0 -rw-r--r--
1 root root 0 2010-09-10 10:38 cciss1 -rw-r--r-- 1 root root
0 2010-09-10 10:38 cciss2
someone@somehost:/proc/driver/cciss&gt; cat cciss2 cciss2:
HP Smart Array P800 Controller Board ID: 0x3223103c Firmware
Version: 7.14 IRQ: 16 Logical drives: 1 Current Q depth: 0
Current # commands on controller: 0 Max Q depth since init:
1 Max # commands on controller since init: 2 Max SG entries
since init: 32 Sequential access devices: 0</p>

<p>cciss/c2d0: 36.38GB RAID 0
someone@somehost:/proc/driver/cciss&gt;</p>

<p>FILES IN /sys
/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/model</p>

<p>Displays the SCSI INQUIRY page 0 model for logical drive
Y of controller X.</p>

<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/rev</p>

<p>Displays the SCSI INQUIRY page 0 revision for logical
drive Y of controller X.</p>


<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/unique_id</p>

<p>Displays the SCSI INQUIRY page 83 serial number for
logical drive Y of controller X.</p>

<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/vendor</p>

<p>Displays the SCSI INQUIRY page 0 vendor for logical
drive Y of controller X.</p>


<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/block:cciss!cXdY</p>

<p>A symbolic link to /sys/block/cciss!cXdY</p>

<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/rescan</p>

<p>Kicks off a rescan of the controller to discover logical
drive topology changes.</p>

<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/lunid</p>

<p>Displays the 8-byte LUN ID used to address logical drive
Y of controller X.</p>


<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/raid_level</p>

<p>Displays the RAID level of logical drive Y of controller
X.</p>


<p>/sys/bus/pci/devices/&lt;dev&gt;/ccissX/cXdY/usage_count</p>

<p>Displays the usage count (number of opens) of logical
drive Y of controller X.</p>

<p>SCSI tape drive and medium changer support SCSI
sequential access devices and medium changer devices are
supported and appropriate device nodes are automatically
created. (e.g. /dev/st0, /dev/st1, etc. See the
&quot;st&quot; man page for more details.) You must enable
&quot;SCSI tape drive support for Smart Array 5xxx&quot; and
&quot;SCSI support&quot; in your kernel configuration to be
able to use SCSI tape drives with your Smart Array 5xxx
controller.</p>

<p>Additionally, note that the driver will not engage the
SCSI core at init time. The driver must be directed to
dynamically engage the SCSI core via the /proc filesystem
entry which the &quot;block&quot; side of the driver creates
as /proc/driver/cciss/cciss* at runtime. This is because at
driver init time, the SCSI core may not yet be initialized
(because the driver is a block driver) and attempting to
register it with the SCSI core in such a case would cause a
hang. This is best done via an initialization script
(typically in /etc/init.d, but could vary depending on
distribution). For example:</p>

<p>for x in /proc/driver/cciss/cciss[0-9]* do echo
&quot;engage scsi&quot; &gt; $x done</p>

<p>Once the SCSI core is engaged by the driver, it cannot
be disengaged (except by unloading the driver, if it happens
to be linked as a mod- ule.)</p>

<p>Note also that if no sequential access devices or medium
changers are detected, the SCSI core will not be engaged by
the action of the above script.</p>

<p>Hot plug support for SCSI tape drives Hot plugging of
SCSI tape drives is supported, with some caveats. The cciss
driver must be informed that changes to the SCSI bus have
been made. This may be done via the /proc filesystem. For
example:</p>

<p>echo &quot;rescan&quot; &gt; /proc/scsi/cciss0/1</p>

<p>This causes the driver to query the adapter about
changes to the physi- cal SCSI buses and/or fibre channel
arbitrated loop and the driver to make note of any new or
removed sequential access devices or medium changers. The
driver will output messages indicating what devices have
been added or removed and the controller, bus, target and
lun used to address the device. It then notifies the SCSI
mid layer of these changes.</p>

<p>Note that the naming convention of the /proc filesystem
entries con- tains a number in addition to the driver name.
(E.g. &quot;cciss0&quot; instead of just &quot;cciss&quot;
which you might expect.)</p>

<p>Note: ONLY sequential access devices and medium changers
are presented as SCSI devices to the SCSI mid layer by the
cciss driver. Specifi- cally, physical SCSI disk drives are
NOT presented to the SCSI mid layer. The physical SCSI disk
drives are controlled directly by the array controller
hardware and it is important to prevent the kernel from
attempting to directly access these devices too, as if the
array controller were merely a SCSI controller in the same
way that we are allowing it to access SCSI tape drives.</p>

<p>SCSI error handling for tape drives and medium changers
The linux SCSI mid layer provides an error handling protocol
which kicks into gear whenever a SCSI command fails to
complete within a cer- tain amount of time (which can vary
depending on the command). The cciss driver participates in
this protocol to some extent. The normal protocol is a four
step process. First the device is told to abort the command.
If that doesnt work, the device is reset. If that doesnt
work, the SCSI bus is reset. If that doesnt work the host
bus adapter is reset. Because the cciss driver is a block
driver as well as a SCSI driver and only the tape drives and
medium changers are presented to the SCSI mid layer, and
unlike more straightforward SCSI drivers, disk i/o continues
through the block side during the SCSI error recovery
process, the cciss driver only implements the first two of
these actions, aborting the command, and resetting the
device. Additionally, most tape drives will not oblige in
aborting commands, and sometimes it appears they will not
even obey a reset command, though in most circum- stances
they will. In the case that the command cannot be aborted
and the device cannot be reset, the device will be set
offline.</p>

<p>In the event the error handling code is triggered and a
tape drive is successfully reset or the tardy command is
successfully aborted, the tape drive may still not allow i/o
to continue until some command is issued which positions the
tape to a known position. Typically you must rewind the tape
(by issuing &quot;mt -f /dev/st0 rewind&quot; for example)
before i/o can proceed again to a tape drive which was
reset.</p>

<p>SEE ALSO hpsa(4), hpacucli(8), hpacuxe(8),
cciss_vol_status(8), http://cciss.sf.net, and from the linux
kernel source, Documenta- tion/blockdev/cciss.txt and
Documentation/ABI/testing/sysfs-bus-pci- devices-cciss</p>

<p>AUTHORS Don Brace, Steve Cameron, Chase Maupin, Mike
Miller, Michael Ni, Charles White, Francis Wiran and
probably some other people.</p>

<p>cciss CCISS(4)</p>
<hr>
</body>
</html>
