<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:45 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLRECHARCLASS(1) Perl Programmers Reference Guide
PERLRECHARCLASS(1)</p>

<p>NAME perlrecharclass - Perl Regular Expression Character
Classes</p>

<p>DESCRIPTION The top level documentation about Perl
regular expressions is found in perlre.</p>

<p>This manual page discusses the syntax and use of
character classes in Perl Regular Expressions.</p>

<p>A character class is a way of denoting a set of
characters, in such a way that one character of the set is
matched. It s important to remember that matching a
character class consumes exactly one character in the source
string. (The source string is the string the regular
expression is matched against.)</p>

<p>There are three types of character classes in Perl
regular expressions: the dot, backslashed sequences, and the
bracketed form.</p>

<p>The dot The dot (or period), &quot;.&quot; is probably
the most used, and certainly the most well-known character
class. By default, a dot matches any character, except for
the newline. The default can be changed to add matching the
newline with the single line modifier: either for the entire
regular expression using the &quot;/s&quot; modifier, or
locally using &quot;(?s)&quot;.</p>

<p>Here are some examples:</p>

<p>&quot;a&quot; =~ /./ # Match &quot;.&quot; =~ /./ #
Match &quot;&quot; =~ /./ # No match (dot has to match a
character) &quot;0 =~ /./ # No match (dot does not match a
newline) &quot;0 =~ /./s # Match (global &rsquo;single
line&rsquo; modifier) &quot;0 =~ /(?s:.)/ # Match (local
&rsquo;single line&rsquo; modifier) &quot;ab&quot; =~ /^.$/
# No match (dot matches one character)</p>

<p>Backslashed sequences Perl regular expressions contain
many backslashed sequences that constitute a character
class. That is, they will match a single character, if that
character belongs to a specific set of characters (defined
by the sequence). A backslashed sequence is a sequence of
characters starting with a backslash. Not all backslashed
sequences are character class; for a full list, see
perlrebackslash.</p>

<p>Here s a list of the backslashed sequences, which are
discussed in more detail below.</p>

<p>Match a digit character. Match a non-digit character. 0
Match a &quot;word&quot; character. W Match a
non-&quot;word&quot; character. Match a white space
character. Match a non-white space character. Match a
horizontal white space character. Match a character that
isn&rsquo;t horizontal white space. Match a vertical white
space character. Match a character that isn&rsquo;t vertical
white space. P, {Prop} Match a character matching a Unicode
property. PP, P{Prop} Match a character that doesn&rsquo;t
match a Unicode property.</p>

<p>Digits</p>

<p>&quot;&quot; matches a single character that is
considered to be a digit. What is considered a digit depends
on the internal encoding of the source string. If the source
string is in UTF-8 format, &quot;&quot; not only matches the
digits 0 - 9, but also Arabic, Devanagari and digits from
other languages. Otherwise, if there is a locale in effect,
it will match whatever characters the locale considers
digits. Without a locale, &quot;&quot; matches the digits 0
to 9. See &quot;Locale, Unicode and UTF-8&quot;.</p>

<p>Any character that isnt matched by &quot;&quot; will be
matched by &quot; Word characters</p>

<p>&quot;1560 is, an alphabetic character, or a digit), or
the underscore (&quot;_&quot;). What is considered a word
character depends on the internal encoding of the string. If
its in UTF-8 format, &quot;720 are considered word
characters in the Unicode database. That is, it not only
matches ASCII letters, but also Thai letters, Greek letters,
etc. If the source string isnt in UTF-8 format, &quot;336
characters that are considered word characters by the
current locale. Without a locale in effect, &quot;912 the
underscore.</p>

<p>Any character that isnt matched by &quot;480W&quot;.</p>

<p>White space</p>

<p>&quot;atches any single character that is consider white
space. In the ASCII range, &quot;atches the horizontal tab
(&quot;&quot;), the new line&quot;), and the (&quot;0), the
form feed (&quot;), the carriage return (&quot; space (the
vertical tab, &quot; characters matched by &quot;epends on
whether the source string is in UTF-8 format. If it is,
&quot;atches what is considered white space in the Unicode
database. Otherwise, if there is a locale in effect, &quot;
matches whatever is considered white space by the current
locale. Without a locale, &quot;atches the five characters
mentioned in the beginning of this paragraph. Perhaps the
most notable difference is that &quot;atches a non-breaking
space only if the non-breaking space is in a UTF-8 encoded
string.</p>

<p>Any character that isnt matched by &quot;ill be matched
by &quot; &quot;ill match any character that is considered
horizontal white space; this includes the space and the tab
characters. &quot;ill match any character that is not
considered horizontal white space.</p>

<p>&quot;ill match any character that is considered
vertical white space; this includes the carriage return and
line feed characters (newline). &quot; will match any
character that is not considered vertical white space.</p>

<p>&quot;nything that can be considered a newline under
Unicode rules. Its not a character class, as it can match a
multi-character sequence. Therefore, it cannot be used
inside a bracketed character class. Details are discussed in
perlrebackslash.</p>

<p>&quot; &quot; &quot; &quot;, and &quot;ew in perl
5.10.0.</p>

<p>Note that unlike &quot; &quot;&quot; and &quot;48nd
&quot;lways match the same characters, regardless whether
the source string is in UTF-8 format or not. The set of
characters they match is also not influenced by locale.</p>

<p>One might think that &quot;s equivalent with &quot;[
This is not true. The vertical tab (&quot;b&quot;) is not
matched by &quot; it is however considered vertical white
space. Furthermore, if the source string is not in UTF-8
format, the next line (&quot;5&quot;) and the no-break space
(&quot;) are not matched by &quot; but are by &quot;nd
&quot; respectively. If the source string is in UTF-8
format, both the next line and the no-break space are
matched by &quot; The following table is a complete listing
of characters matched by &quot; &quot;nd &quot; The first
column gives the code point of the character (in hex
format), the second column gives the (Unicode) name. The
third column indicates by which class(es) the character is
matched.</p>

<p>0x00009 CHARACTER TABULATION h s 0x0000a LINE FEED (LF)
vs 0x0000b LINE TABULATION v 0x0000c FORM FEED (FF) vs
0x0000d CARRIAGE RETURN (CR) vs 0x00020 SPACE h s 0x00085
NEXT LINE (NEL) vs [1] 0x000a0 NO-BREAK SPACE h s [1]
0x01680 OGHAM SPACE MARK h s 0x0180e MONGOLIAN VOWEL
SEPARATOR h s 0x02000 EN QUAD h s 0x02001 EM QUAD h s
0x02002 EN SPACE h s 0x02003 EM SPACE h s 0x02004
THREE-PER-EM SPACE h s 0x02005 FOUR-PER-EM SPACE h s 0x02006
SIX-PER-EM SPACE h s 0x02007 FIGURE SPACE h s 0x02008
PUNCTUATION SPACE h s 0x02009 THIN SPACE h s 0x0200a HAIR
SPACE h s 0x02028 LINE SEPARATOR vs 0x02029 PARAGRAPH
SEPARATOR vs 0x0202f NARROW NO-BREAK SPACE h s 0x0205f
MEDIUM MATHEMATICAL SPACE h s 0x03000 IDEOGRAPHIC SPACE h
s</p>

<p>[1] NEXT LINE and NO-BREAK SPACE only match &quot;f the
source string is in UTF-8 format.</p>

<p>It is worth noting that &quot;&quot;, &quot;840 complete
numbers or words. To match a number (that consists of
integers), use &quot;+&quot;; to match a word, use
&quot;48</p>

<p>Unicode Properties</p>

<p>&quot;P&quot; and &quot;{Prop}&quot; are character
classes to match characters that fit given Unicode classes.
One letter classes can be used in the &quot;P&quot; form,
with the class name following the &quot;&quot;, otherwise,
the property name is enclosed in braces, and follows the
&quot;&quot;. For instance, a match for a number can be
written as &quot;/N/&quot; or as &quot;/{Number}/&quot;.
Lowercase letters are matched by the property
LowercaseLetter which has as short form Ll. They have to be
written as &quot;/{Ll}/&quot; or
&quot;/{LowercaseLetter}/&quot;. &quot;/Ll/&quot; is valid,
but means something different. It matches a two character
string: a letter (Unicode property &quot;L&quot;), followed
by a lowercase &quot;l&quot;.</p>

<p>For a list of possible properties, see &quot;Unicode
Character Properties&quot; in perlunicode. It is also
possible to defined your own properties. This is discussed
in &quot;User-Defined Character Properties&quot; in
perlunicode.</p>

<p>Examples</p>

<p>&quot;a&quot; =~ /984 &quot;7&quot; =~ /1176
&quot;a&quot; =~ // # No match, &quot;a&quot; isn&rsquo;t a
digit. &quot;7&quot; =~ // # Match, &quot;7&quot; is a
digit. &quot; &quot; =~ / # Match, a space is white space.
&quot;a&quot; =~ / &quot;7&quot; =~ / &quot; &quot; =~ / #
No match, a space is not non-white space.</p>

<p>&quot; &quot; =~ / # Match, space is horizontal white
space. &quot; &quot; =~ / # No match, space is not vertical
white space. &quot; =~ / # Match, a return is vertical white
space. &quot;</p>

<p>&quot;a&quot; =~ /L/ # Match, &quot;a&quot; is a letter.
&quot;a&quot; =~ /{Lu}/ # No match, /{Lu}/ matches upper
case letters.</p>

<p>&quot;0b}&quot; =~ /{Thai}/ # Match, 0b} is the
character # &rsquo;THAI CHARACTER SO SO&rsquo;, and
that&rsquo;s in # Thai Unicode class. &quot;a&quot; =~
/P{Lao}/ # Match, as &quot;a&quot; is not a Laoian
character.</p>

<p>Bracketed Character Classes The third form of character
class you can use in Perl regular expressions is the
bracketed form. In its simplest form, it lists the
characters that may be matched inside square brackets, like
this: &quot;[aeiou]&quot;. This matches one of
&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;
or &quot;u&quot;. Just as the other character classes,
exactly one character will be matched. To match a longer
string consisting of characters mentioned in the characters
class, follow the character class with a quantifier. For
instance, &quot;[aeiou]+&quot; matches a string of one or
more lowercase ASCII vowels.</p>

<p>Repeating a character in a character class has no
effect; its considered to be in the set only once.</p>

<p>Examples:</p>

<p>&quot;e&quot; =~ /[aeiou]/ # Match, as &quot;e&quot; is
listed in the class. &quot;p&quot; =~ /[aeiou]/ # No match,
&quot;p&quot; is not listed in the class. &quot;ae&quot; =~
/^[aeiou]$/ # No match, a character class only matches # a
single character. &quot;ae&quot; =~ /^[aeiou]+$/ # Match,
due to the quantifier.</p>

<p>Special Characters Inside a Bracketed Character
Class</p>

<p>Most characters that are meta characters in regular
expressions (that is, characters that carry a special
meaning like &quot;*&quot; or &quot;(&quot;) lose their
special meaning and can be used inside a character class
without the need to escape them. For instance,
&quot;[()]&quot; matches either an opening parenthesis, or a
closing parenthesis, and the parens inside the character
class dont group or capture.</p>

<p>Characters that may carry a special meaning inside a
character class are: &quot; escaped with a backslash,
although this is sometimes not needed, in which case the
backslash may be omitted.</p>

<p>i s s p e c i a l i n s i d e a b r a c k e The sequence
&quot;t e d c h a r a c t e r c l a s s . W h i l e i s a n
a s s e r t i o n i outside the character class &quot;n d i
c a t i n g a p o i n t that does not have either two word
characters or two non-word characters on either side, inside
a bracketed character class, &quot; matches a backspace
character.</p>

<p>A &quot;[&quot; is not special inside a character class,
unless its the start of a POSIX character class (see below).
It normally does not need escaping.</p>

<p>A &quot;]&quot; is either the end of a POSIX character
class (see below), or it signals the end of the bracketed
character class. Normally it needs escaping if you want to
include a &quot;]&quot; in the set of characters. However,
if the &quot;]&quot; is the first (or the second if the
first character is a caret) character of a bracketed
character class, it does not denote the end of the class (as
you cannot have an empty class) and is considered part of
the set of characters that can be matched without
escaping.</p>

<p>Examples:</p>

<p>&quot;+&quot; =~ /[+?*]/ # Match, &quot;+&quot; in a
character class is not special. &quot; # is equivalent with
a backspace. &quot;]&quot; =~ /[][]/ # Match, as the
character class contains. # both [ and ]. &quot;[]&quot; =~
/[[]]/ # Match, the pattern contains a character class #
containing just ], and the character class is # followed by
a ].</p>

<p>Character Ranges</p>

<p>It is not uncommon to want to match a range of
characters. Luckily, instead of listing all the characters
in the range, one may use the hyphen (&quot;-&quot;). If
inside a bracketed character class you have two characters
separated by a hyphen, its treated as if all the characters
between the two are in the class. For instance,
&quot;[0-9]&quot; matches any ASCII digit, and
&quot;[a-m]&quot; matches any lowercase letter from the
first half of the ASCII alphabet.</p>

<p>Note that the two characters on either side of the
hyphen are not necessary both letters or both digits. Any
character is possible, although not advisable.
&quot;[&rsquo;-?]&quot; contains a range of characters, but
most people will not know which characters that will be.
Furthermore, such ranges may lead to portability problems if
the code has to run on a platform that uses a different
character set, such as EBCDIC.</p>

<p>If a hyphen in a character class cannot be part of a
range, for instance because it is the first or the last
character of the character class, or if it immediately
follows a range, the hyphen isnt special, and will be
considered a character that may be matched. You have to
escape the hyphen with a backslash if you want to have a
hyphen in your set of characters to be matched, and its
position in the class is such that it can be considered part
of a range.</p>

<p>Examples:</p>

<p>[a-z] # Matches a character that is a lower case ASCII
letter. [a-fz] # Matches any letter between &rsquo;a&rsquo;
and &rsquo;f&rsquo; (inclusive) or the # letter
&rsquo;z&rsquo;. [-z] # Matches either a hyphen
(&rsquo;-&rsquo;) or the letter &rsquo;z&rsquo;. [a-f-m] #
Matches any letter between &rsquo;a&rsquo; and
&rsquo;f&rsquo; (inclusive), the # hyphen (&rsquo;-&rsquo;),
or the letter &rsquo;m&rsquo;. [&rsquo;-?] # Matches any of
the characters &rsquo;()*+,-./0123456789:;&lt;=&gt;? # (But
not on an EBCDIC platform).</p>

<p>Negation</p>

<p>It is also possible to instead list the characters you
do not want to match. You can do so by using a caret
(&quot;^&quot;) as the first character in the character
class. For instance, &quot;[^a-z]&quot; matches a character
that is not a lowercase ASCII letter.</p>

<p>This syntax make the caret a special character inside a
bracketed character class, but only if it is the first
character of the class. So if you want to have the caret as
one of the characters you want to match, you either have to
escape the caret, or not list it first.</p>

<p>Examples:</p>

<p>&quot;e&quot; =~ /[^aeiou]/ # No match, the
&rsquo;e&rsquo; is listed. &quot;x&quot; =~ /[^aeiou]/ #
Match, as &rsquo;x&rsquo; isn&rsquo;t a lowercase vowel.
&quot;^&quot; =~ /[^^]/ # No match, matches anything that
isn&rsquo;t a caret. &quot;^&quot; =~ /[x^]/ # Match, caret
is not special here.</p>

<p>Backslash Sequences</p>

<p>You can put a backslash sequence character class inside
a bracketed character class, and it will act just as if you
put all the characters matched by the backslash sequence
inside the character class. For instance, &quot;[a-f]&quot;
will match any digit, or any of the lowercase letters
between a and f inclusive.</p>

<p>Examples:</p>

<p>/[{Thai}]/ # Matches a character that is either a Thai #
character, or a digit. /[^{Arabic}()]/ # Matches a character
that is neither an Arabic # character, nor a
parenthesis.</p>

<p>Backslash sequence character classes cannot form one of
the endpoints of a range.</p>

<p>Posix Character Classes</p>

<p>Posix character classes have the form
&quot;[:class:]&quot;, where class is name, and the
&quot;[:&quot; and &quot;:]&quot; delimiters. Posix
character classes appear inside bracketed character classes,
and are a convenient and descriptive way of listing a group
of characters. Be careful about the syntax,</p>

<p># Correct: $string =~ /[[:alpha:]]/</p>

<p># Incorrect (will warn): $string =~ /[:alpha:]/</p>

<p>The latter pattern would be a character class consisting
of a colon, and the letters &quot;a&quot;, &quot;l&quot;,
&quot;p&quot; and &quot;h&quot;.</p>

<p>Perl recognizes the following POSIX character
classes:</p>

<p>alpha Any alphabetical character. alnum Any
alphanumerical character. ascii Any ASCII character. blank A
GNU extension, equal to a space or a horizontal tab
(&quot;&quot;). cntrl Any control character. digit Any
digit, equivalent to &quot;&quot;. graph Any printable
character, excluding a space. lower Any lowercase character.
print Any printable character, including a space. punct Any
punctuation character. space Any white space character.
&quot;lus the vertical tab (&quot; upper Any uppercase
character. word Any &quot;word&quot; character, equivalent
to &quot;24 xdigit Any hexadecimal digit, &rsquo;0&rsquo; -
&rsquo;9&rsquo;, &rsquo;a&rsquo; - &rsquo;f&rsquo;,
&rsquo;A&rsquo; - &rsquo;F&rsquo;.</p>

<p>The exact set of characters matched depends on whether
the source string is internally in UTF-8 format or not. See
&quot;Locale, Unicode and UTF-8&quot;.</p>

<p>Most POSIX character classes have &quot;&quot;
counterparts. The difference is that the &quot;&quot;
classes will always match according to the Unicode
properties, regardless whether the string is in UTF-8 format
or not.</p>

<p>The following table shows the relation between POSIX
character classes and the Unicode properties:</p>

<p>[[:...:]] {...} backslash</p>

<p>alpha IsAlpha alnum IsAlnum ascii IsASCII blank cntrl
IsCntrl digit IsDigit graph IsGraph lower IsLower print
IsPrint punct IsPunct space IsSpace IsSpacePerl upper
IsUpper word IsWord xdigit IsXDigit</p>

<p>Some character classes may have a non-obvious name:</p>

<p>cntrl Any control character. Usually, control characters
don t produce output as such, but instead control the
terminal somehow: for example newline and backspace are
control characters. All characters with &quot;ord()&quot;
less than 32 are usually classified as control characters
(in ASCII, the ISO Latin character sets, and Unicode), as is
the character &quot;ord()&quot; value of 127
(&quot;DEL&quot;).</p>

<p>graph Any character that is graphical, that is, visible.
This class consists of all the alphanumerical characters and
all punctuation characters.</p>

<p>print All printable characters, which is the set of all
the graphical characters plus the space.</p>

<p>punct Any punctuation (special) character.</p>

<p>Negation</p>

<p>A Perl extension to the POSIX character class is the
ability to negate it. This is done by prefixing the class
name with a caret (&quot;^&quot;). Some examples:</p>

<p>POSIX Unicode Backslash [[:^digit:]] P{IsDigit} [= =]
and [. .]</p>

<p>Perl will recognize the POSIX character classes
&quot;[=class=]&quot;, and &quot;[.class.]&quot;, but does
not (yet?) support this construct. Use of such a construct
will lead to an error.</p>

<p>Examples</p>

<p>/[[:digit:]]/ # Matches a character that is a digit.
/[01[:lower:]]/ # Matches a character that is either a #
lowercase letter, or &rsquo;0&rsquo; or &rsquo;1&rsquo;.
/[[:digit:][:^xdigit:]]/ # Matches a character that can be
anything, # but the letters &rsquo;a&rsquo; to
&rsquo;f&rsquo; in either case. # This is because the
character class contains # all digits, and anything that
isn&rsquo;t a # hex digit, resulting in a class containing #
all characters, but the letters &rsquo;a&rsquo; to
&rsquo;f&rsquo; # and &rsquo;A&rsquo; to
&rsquo;F&rsquo;.</p>

<p>Locale, Unicode and UTF-8 Some of the character classes
have a somewhat different behaviour depending on the
internal encoding of the source string, and the locale that
is in effect.</p>

<p>&quot;48&quot;, &quot;nd the POSIX character classes
(and their negations, including &quot;W&quot;, &quot; suffer
from this behaviour.</p>

<p>The rule is that if the source string is in UTF-8
format, the character classes match according to the Unicode
properties. If the source string isn t, then the character
classes match according to whatever locale is in effect. If
there is no locale, they match the ASCII defaults (52
letters, 10 digits and underscore for &quot;312&quot;,
etc).</p>

<p>This usually means that if you are matching against
characters whose &quot;ord()&quot; values are between 128
and 255 inclusive, your character class may match or not
depending on the current locale, and whether the source
string is in UTF-8 format. The string will be in UTF-8
format if it contains characters whose &quot;ord()&quot;
value exceeds 255. But a string may be in UTF-8 format
without it having such characters.</p>

<p>For portability reasons, it may be better to not use
&quot;48&quot;, &quot; or the POSIX character classes, and
use the Unicode properties instead.</p>

<p>Examples</p>

<p>$str = &quot;&quot;; # $str is not in UTF-8 format. $str
=~ /^1200 $str .= &quot;0b}&quot;; # Now $str is in UTF-8
format. $str =~ /^1080 chop $str; $str =~ /^1296</p>

<p>perl v5.10.1 2009-05-14 PERLRECHARCLASS(1)</p>
<hr>
</body>
</html>
