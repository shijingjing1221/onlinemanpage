<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:46 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLREFTUT(1) Perl Programmers Reference Guide
PERLREFTUT(1)</p>

<p>NAME perlreftut - Marks very short tutorial about
references</p>

<p>DESCRIPTION One of the most important new features in
Perl 5 was the capability to manage complicated data
structures like multidimensional arrays and nested hashes.
To enable these, Perl 5 introduced a feature called
references , and using references is the key to managing
complicated, structured data in Perl. Unfortunately, theres
a lot of funny syntax to learn, and the main manual page can
be hard to follow. The manual is quite complete, and
sometimes people find that a problem, because it can be hard
to tell what is important and what isnt.</p>

<p>Fortunately, you only need to know 10% of whats in the
main page to get 90% of the benefit. This page will show you
that 10%.</p>

<p>Who Needs Complicated Data Structures? One problem that
came up all the time in Perl 4 was how to represent a hash
whose values were lists. Perl 4 had hashes, of course, but
the values had to be scalars; they couldnt be lists.</p>

<p>Why would you want a hash of lists? Lets take a simple
example: You have a file of city and country names, like
this:</p>

<p>Chicago, USA Frankfurt, Germany Berlin, Germany
Washington, USA Helsinki, Finland New York, USA</p>

<p>and you want to produce an output like this, with each
country mentioned once, and then an alphabetical list of the
cities in that country:</p>

<p>Finland: Helsinki. Germany: Berlin, Frankfurt. USA:
Chicago, New York, Washington.</p>

<p>The natural way to do this is to have a hash whose keys
are country names. Associated with each country name key is
a list of the cities in that country. Each time you read a
line of input, split it into a country and a city, look up
the list of cities already known to be in that country, and
append the new city to the list. When youre done reading the
input, iterate over the hash as usual, sorting each list of
cities before you print it out.</p>

<p>If hash values cant be lists, you lose. In Perl 4, hash
values cant be lists; they can only be strings. You lose.
Youd probably have to combine all the cities into a single
string somehow, and then when time came to write the output,
youd have to break the string into a list, sort the list,
and turn it back into a string. This is messy and
error-prone. And it s frustrating, because Perl already has
perfectly good lists that would solve the problem if only
you could use them.</p>

<p>The Solution By the time Perl 5 rolled around, we were
already stuck with this design: Hash values must be scalars.
The solution to this is references.</p>

<p>A reference is a scalar value that refers to an entire
array or an entire hash (or to just about anything else).
Names are one kind of reference that youre already familiar
with. Think of the President of the United States: a messy,
inconvenient bag of blood and bones. But to talk about him,
or to represent him in a computer program, all you need is
the easy, convenient scalar string &quot;Barack
Obama&quot;.</p>

<p>References in Perl are like names for arrays and hashes.
Theyre Perls private, internal names, so you can be sure
they re unambiguous. Unlike &quot;Barack Obama&quot;, a
reference only refers to one thing, and you always know what
it refers to. If you have a reference to an array, you can
recover the entire array from it. If you have a reference to
a hash, you can recover the entire hash. But the reference
is still an easy, compact scalar value.</p>

<p>You cant have a hash whose values are arrays; hash
values can only be scalars. Were stuck with that. But a
single reference can refer to an entire array, and
references are scalars, so you can have a hash of references
to arrays, and itll act a lot like a hash of arrays, and
itll be just as useful as a hash of arrays.</p>

<p>We ll come back to this city-country problem later,
after weve seen some syntax for managing references.</p>

<p>Syntax There are just two ways to make a reference, and
just two ways to use it once you have it.</p>

<p>Making References Make Rule 1</p>

<p>If you put a &quot; variable.</p>

<p>$aref = @array; # $aref now holds a reference to @array
$href = hash; # $href now holds a reference to %hash $sref =
calar; # $sref now holds a reference to $scalar</p>

<p>Once the reference is stored in a variable like $aref or
$href, you can copy it or store it just the same as any
other scalar value:</p>

<p>$xy = $aref; # $xy now holds a reference to @array $p[3]
= $href; # $p[3] now holds a reference to %hash $z = $p[3];
# $z now holds a reference to %hash</p>

<p>These examples show how to make references to variables
with names. Sometimes you want to make an array or a hash
that doesn t have a name. This is analogous to the way you
like to be able to use the string &quot;0 or the number 80
without having to store it in a named variable first.</p>

<p>Make Rule 2</p>

<p>&quot;[ ITEMS ]&quot; makes a new, anonymous array, and
returns a reference to that array. &quot;{ ITEMS }&quot;
makes a new, anonymous hash, and returns a reference to that
hash.</p>

<p>$aref = [ 1, &quot;foo&quot;, undef, 13 ]; # $aref now
holds a reference to an array</p>

<p>$href = { APR =&gt; 4, AUG =&gt; 8 }; # $href now holds
a reference to a hash</p>

<p>The references you get from rule 2 are the same kind of
references that you get from rule 1:</p>

<p># This: $aref = [ 1, 2, 3 ];</p>

<p># Does the same as this: @array = (1, 2, 3); $aref =
@array;</p>

<p>The first line is an abbreviation for the following two
lines, except that it doesn t create the superfluous array
variable @array.</p>

<p>If you write just &quot;[]&quot;, you get a new, empty
anonymous array. If you write just &quot;{}&quot;, you get a
new, empty anonymous hash.</p>

<p>Using References What can you do with a reference once
you have it? Its a scalar value, and weve seen that you can
store it as a scalar and get it back again just like any
scalar. There are just two more ways to use it:</p>

<p>Use Rule 1</p>

<p>You can always use an array reference, in curly braces,
in place of the name of an array. For example,
&quot;@{$aref}&quot; instead of @array.</p>

<p>Here are some examples of that:</p>

<p>Arrays:</p>

<p>@a @{$aref} An array reverse @a reverse @{$aref} Reverse
the array $a[3] ${$aref}[3] An element of the array $a[3] =
17; ${$aref}[3] = 17 Assigning an element</p>

<p>On each line are two expressions that do the same thing.
The left-hand versions operate on the array @a. The
right-hand versions operate on the array that is referred to
by $aref. Once they find the array theyre operating on, both
versions do the same things to the arrays.</p>

<p>Using a hash reference is exactly the same:</p>

<p>%h %{$href} A hash keys %h keys %{$href} Get the keys
from the hash $h{&rsquo;red&rsquo;}
${$href}{&rsquo;red&rsquo;} An element of the hash
$h{&rsquo;red&rsquo;} = 17 ${$href}{&rsquo;red&rsquo;} = 17
Assigning an element</p>

<p>Whatever you want to do with a reference, Use Rule 1
tells you how to do it. You just write the Perl code that
you would have written for doing the same thing to a regular
array or hash, and then replace the array or hash name with
&quot;{$reference}&quot;. &quot;How do I loop over an array
when all I have is a reference?&quot; Well, to loop over an
array, you would write</p>

<p>for my $element (@array) { ... }</p>

<p>so replace the array name, @array, with the
reference:</p>

<p>for my $element (@{$aref}) { ... }</p>

<p>&quot;How do I print out the contents of a hash when all
I have is a reference?&quot; First write the code for
printing out a hash:</p>

<p>for my $key (keys %hash) { print &quot;$key =&gt;
$hash{$key}0; }</p>

<p>And then replace the hash name with the reference:</p>

<p>for my $key (keys %{$href}) { print &quot;$key =&gt;
${$href}{$key}0; }</p>

<p>Use Rule 2</p>

<p>Use Rule 1 is all you really need, because it tells you
how to do absolutely everything you ever need to do with
references. But the most common thing to do with an array or
a hash is to extract a single element, and the Use Rule 1
notation is cumbersome. So there is an abbreviation.</p>

<p>&quot;${$aref}[3]&quot; is too hard to read, so you can
write &quot;$aref-&gt;[3]&quot; instead.</p>

<p>&quot;${$href}{red}&quot; is too hard to read, so you
can write &quot;$href-&gt;{red}&quot; instead.</p>

<p>If $aref holds a reference to an array, then
&quot;$aref-&gt;[3]&quot; is the fourth element of the
array. Dont confuse this with $aref[3], which is the fourth
element of a totally different array, one deceptively named
@aref. $aref and @aref are unrelated the same way that $item
and @item are.</p>

<p>Similarly, &quot;$href-&gt;{&rsquo;red&rsquo;}&quot; is
part of the hash referred to by the scalar variable $href,
perhaps even one with no name. $href{&rsquo;red&rsquo;} is
part of the deceptively named %href hash. Its easy to forget
to leave out the &quot;-&gt;&quot;, and if you do, you ll
get bizarre results when your program gets array and hash
elements out of totally unexpected hashes and arrays that
werent the ones you wanted to use.</p>

<p>An Example Lets see a quick example of how all this is
useful.</p>

<p>First, remember that &quot;[1, 2, 3]&quot; makes an
anonymous array containing &quot;(1, 2, 3)&quot;, and gives
you a reference to that array.</p>

<p>Now think about</p>

<p>@a = ( [1, 2, 3], [4, 5, 6], [7, 8, 9] );</p>

<p>@a is an array with three elements, and each one is a
reference to another array.</p>

<p>$a[1] is one of these references. It refers to an array,
the array containing &quot;(4, 5, 6)&quot;, and because it
is a reference to an array, Use Rule 2 says that we can
write $a[1]-&gt;[2] to get the third element from that
array. $a[1]-&gt;[2] is the 6. Similarly, $a[0]-&gt;[1] is
the 2. What we have here is like a two-dimensional array;
you can write $a[ROW]-&gt;[COLUMN] to get or set the element
in any row and any column of the array.</p>

<p>The notation still looks a little cumbersome, so there s
one more abbreviation:</p>

<p>Arrow Rule In between two subscripts, the arrow is
optional.</p>

<p>Instead of $a[1]-&gt;[2], we can write $a[1][2]; it
means the same thing. Instead of &quot;$a[0]-&gt;[1] =
23&quot;, we can write &quot;$a[0][1] = 23&quot;; it means
the same thing.</p>

<p>Now it really looks like two-dimensional arrays!</p>

<p>You can see why the arrows are important. Without them,
we would have had to write &quot;${$a[1]}[2]&quot; instead
of $a[1][2]. For three-dimensional arrays, they let us write
$x[2][3][5] instead of the unreadable
&quot;${${$x[2]}[3]}[5]&quot;.</p>

<p>Solution Heres the answer to the problem I posed
earlier, of reformatting a file of city and country
names.</p>

<p>1 my %table;</p>

<p>2 while (&lt;&gt;) { 3 chomp; 4 my ($city, $country) =
split /, /; 5 $table{$country} = [] unless exists
$table{$country}; 6 push @{$table{$country}}, $city; 7 }</p>

<p>8 foreach $country (sort keys %table) { 9 print
&quot;$country: &quot;; 10 my @cities = @{$table{$country}};
11 print join &rsquo;, &rsquo;, sort @cities; 12 print
&quot;.0; 13 }</p>

<p>The program has two pieces: Lines 2--7 read the input
and build a data structure, and lines 8-13 analyze the data
and print out the report. Were going to have a hash, %table,
whose keys are country names, and whose values are
references to arrays of city names. The data structure will
look like this:</p>

<p>%table +-------+---+ | | | +-----------+--------+
|Germany| *----&gt;| Frankfurt | Berlin | | | |
+-----------+--------+ +-------+---+ | | | +----------+
|Finland| *----&gt;| Helsinki | | | | +----------+
+-------+---+ | | | +---------+------------+----------+ |
USA | *----&gt;| Chicago | Washington | New York | | | |
+---------+------------+----------+ +-------+---+</p>

<p>Well look at output first. Supposing we already have
this structure, how do we print it out?</p>

<p>8 foreach $country (sort keys %table) { 9 print
&quot;$country: &quot;; 10 my @cities = @{$table{$country}};
11 print join &rsquo;, &rsquo;, sort @cities; 12 print
&quot;.0; 13 }</p>

<p>%table is an ordinary hash, and we get a list of keys
from it, sort the keys, and loop over the keys as usual. The
only use of references is in line 10. $table{$country} looks
up the key $country in the hash and gets the value, which is
a reference to an array of cities in that country. Use Rule
1 says that we can recover the array by saying
&quot;@{$table{$country}}&quot;. Line 10 is just like</p>

<p>@cities = @array;</p>

<p>except that the name &quot;array&quot; has been replaced
by the reference &quot;{$table{$country}}&quot;. The
&quot;@&quot; tells Perl to get the entire array. Having
gotten the list of cities, we sort it, join it, and print it
out as usual.</p>

<p>Lines 2-7 are responsible for building the structure in
the first place. Here they are again:</p>

<p>2 while (&lt;&gt;) { 3 chomp; 4 my ($city, $country) =
split /, /; 5 $table{$country} = [] unless exists
$table{$country}; 6 push @{$table{$country}}, $city; 7 }</p>

<p>Lines 2-4 acquire a city and country name. Line 5 looks
to see if the country is already present as a key in the
hash. If its not, the program uses the &quot;[]&quot;
notation (Make Rule 2) to manufacture a new, empty anonymous
array of cities, and installs a reference to it into the
hash under the appropriate key.</p>

<p>Line 6 installs the city name into the appropriate
array. $table{$country} now holds a reference to the array
of cities seen in that country so far. Line 6 is exactly
like</p>

<p>push @array, $city;</p>

<p>except that the name &quot;array&quot; has been replaced
by the reference &quot;{$table{$country}}&quot;. The
&quot;push&quot; adds a city name to the end of the
referred-to array.</p>

<p>Theres one fine point I skipped. Line 5 is unnecessary,
and we can get rid of it.</p>

<p>2 while (&lt;&gt;) { 3 chomp; 4 my ($city, $country) =
split /, /; 5 #### $table{$country} = [] unless exists
$table{$country}; 6 push @{$table{$country}}, $city; 7 }</p>

<p>If theres already an entry in %table for the current
$country, then nothing is different. Line 6 will locate the
value in $table{$country}, which is a reference to an array,
and push $city into the array. But what does it do when
$country holds a key, say &quot;Greece&quot;, that is not
yet in %table?</p>

<p>This is Perl, so it does the exact right thing. It sees
that you want to push &quot;Athens&quot; onto an array that
doesnt exist, so it helpfully makes a new, empty, anonymous
array for you, installs it into %table, and then pushes
&quot;Athens&quot; onto it. This is called
autovivification--bringing things to life automatically.
Perl saw that they key wasnt in the hash, so it created a
new hash entry automatically. Perl saw that you wanted to
use the hash value as an array, so it created a new empty
array and installed a reference to it in the hash
automatically. And as usual, Perl made the array one element
longer to hold the new city name.</p>

<p>The Rest I promised to give you 90% of the benefit with
10% of the details, and that means I left out 90% of the
details. Now that you have an overview of the important
parts, it should be easier to read the perlref manual page,
which discusses 100% of the details.</p>

<p>Some of the highlights of perlref:</p>

<p>&middot; You can make references to anything, including
scalars, functions, and other references.</p>

<p>&middot; In Use Rule 1, you can omit the curly brackets
whenever the thing inside them is an atomic scalar variable
like $aref. For example, @$aref is the same as
&quot;@{$aref}&quot;, and $$aref[1] is the same as
&quot;${$aref}[1]&quot;. If you re just starting out, you
may want to adopt the habit of always including the curly
brackets.</p>

<p>&middot; This doesnt copy the underlying array:</p>

<p>$aref2 = $aref1;</p>

<p>You get two references to the same array. If you modify
&quot;$aref1-&gt;[23]&quot; and then look at
&quot;$aref2-&gt;[23]&quot; youll see the change.</p>

<p>To copy the array, use</p>

<p>$aref2 = [@{$aref1}];</p>

<p>This uses &quot;[...]&quot; notation to create a new
anonymous array, and $aref2 is assigned a reference to the
new array. The new array is initialized with the contents of
the array referred to by $aref1.</p>

<p>Similarly, to copy an anonymous hash, you can use</p>

<p>$href2 = {%{$href1}};</p>

<p>&middot; To see if a variable contains a reference, use
the &quot;ref&quot; function. It returns true if its
argument is a reference. Actually its a little better than
that: It returns &quot;HASH&quot; for hash references and
&quot;ARRAY&quot; for array references.</p>

<p>&middot; If you try to use a reference like a string,
you get strings like</p>

<p>ARRAY(0x80f5dec) or HASH(0x826afc0)</p>

<p>If you ever see a string that looks like this, youll
know you printed out a reference by mistake.</p>

<p>A side effect of this representation is that you can use
&quot;eq&quot; to see if two references refer to the same
thing. (But you should usually use &quot;==&quot; instead
because its much faster.)</p>

<p>&middot; You can use a string as if it were a reference.
If you use the string &quot;foo&quot; as an array reference,
its taken to be a reference to the array @foo. This is
called a soft reference or symbolic reference. The
declaration &quot;use strict &rsquo;refs&rsquo;&quot;
disables this feature, which can cause all sorts of trouble
if you use it by accident.</p>

<p>You might prefer to go on to perllol instead of perlref;
it discusses lists of lists and multidimensional arrays in
detail. After that, you should move on to perldsc; its a
Data Structure Cookbook that shows recipes for using and
printing out arrays of hashes, hashes of arrays, and other
kinds of data.</p>

<p>Summary Everyone needs compound data structures, and in
Perl the way you get them is with references. There are four
important rules for managing references: Two for making
references and two for using them. Once you know these rules
you can do most of the important things you need to do with
references.</p>

<p>Credits Author: Mark Jason Dominus, Plover Systems
(&quot;mjd-perl-ref+@plover.com&quot;)</p>

<p>This article originally appeared in The Perl Journal (
http://www.tpj.com/ ) volume 3, #2. Reprinted with
permission.</p>

<p>The original title was Understand References Today.</p>

<p>Distribution Conditions Copyright 1998 The Perl
Journal.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
these files are hereby placed into the public domain. You
are permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>perl v5.10.1 2009-04-18 PERLREFTUT(1)</p>
<hr>
</body>
</html>
