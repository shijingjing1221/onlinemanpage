<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:05:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>AUPARSE_FEED(3) Linux Audit API AUPARSE_FEED(3)</p>

<p>NAME auparse_feed - feed data into parser</p>

<p>SYNOPSIS #include &lt;auparse.h&gt;</p>

<p>int auparse_feed(auparse_state_t *au, const char *data,
size_t data_len);</p>

<p>au The audit parse state</p>

<p>data a buffer of data to feed into the parser, it is
data_len bytes long. The data is copied in the parser, upon
return the caller may free or reuse the data buffer.</p>

<p>data_len number of bytes in data</p>

<p>DESCRIPTION auparse_feed supplies new data for the
parser to consume. auparse_init() must have been called with
a source type of AUSOURCE_FEED and a NULL pointer.</p>

<p>The parser consumes as much data as it can invoking a
user supplied callback specified with auparse_add_callback
with a cb_event_type of AUPARSE_CB_EVENT_READY each time the
parser recognizes a complete event in the data stream. Data
not fully parsed will persist and be prepended to the next
feed data. After all data has been feed to the parser
auparse_flush_feed should be called to signal the end of
input data and flush any pending parse data through the
parsing system.</p>

<p>EXAMPLE void auparse_callback(auparse_state_t *au,
auparse_cb_event_t cb_event_type, void *user_data) { int
*event_cnt = (int *)user_data;</p>

<p>if (cb_event_type == AUPARSE_CB_EVENT_READY) { if
(auparse_first_record(au) &lt;= 0) return;
printf(&quot;event: %d0, *event_cnt);
printf(&quot;records:%d0, auparse_get_num_records(au)); do {
printf(&quot;fields:%d0, auparse_get_num_fields(au));
printf(&quot;type=%d &quot;, auparse_get_type(au)); const
au_event_t *e = auparse_get_timestamp(au); if (e == NULL)
return; printf(&quot;event time: %u.%u:%lu0,
(unsigned)e-&gt;sec, e-&gt;milli, e-&gt;serial);
auparse_first_field(au); do { printf(&quot;%s=%s (%s)0,
auparse_get_field_name(au), auparse_get_field_str(au),
auparse_interpret_field(au)); } while
(auparse_next_field(au) &gt; 0); printf(&quot;0);</p>

<p>} while(auparse_next_record(au) &gt; 0); (*event_cnt)++;
} }</p>

<p>main(int argc, char **argv) { char *filename = argv[1];
FILE *fp; char buf[256]; size_t len; int *event_cnt =
malloc(sizeof(int));</p>

<p>au = auparse_init(AUSOURCE_FEED, 0);</p>

<p>*event_cnt = 1; auparse_add_callback(au,
auparse_callback, event_cnt, free);</p>

<p>if ((fp = fopen(filename, &quot;r&quot;)) == NULL) {
fprintf(stderr, &quot;could not open %s, %s0, filename,
strerror(errno)); return 1; }</p>

<p>while ((len = fread(buf, 1, sizeof(buf), fp))) {
auparse_feed(au, buf, len); } auparse_flush_feed(au); }</p>

<p>RETURN VALUE Returns -1 if an error occurs; otherwise, 0
for success.</p>

<p>SEE ALSO auparse_add_callback(3), auparse_flush_feed(3),
auparse_feed_has_data(3)</p>

<p>AUTHOR John Dennis</p>

<p>Red Hat May 2007 AUPARSE_FEED(3)</p>
<hr>
</body>
</html>
