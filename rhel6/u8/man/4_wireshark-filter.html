<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:44:32 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>WIRESHARK-FILTER(4) The Wireshark Network Analyzer
WIRESHARK-FILTER(4)</p>

<p>NAME wireshark-filter - Wireshark filter syntax and
reference</p>

<p>SYNOPSIS wireshark [other options] [ -R &quot;filter
expression&quot; ]</p>

<p>tshark [other options] [ -R &quot;filter
expression&quot; ]</p>

<p>DESCRIPTION Wireshark and TShark share a powerful filter
engine that helps remove the noise from a packet trace and
lets you see only the packets that interest you. If a packet
meets the requirements expressed in your filter, then it is
displayed in the list of packets. Display filters let you
compare the fields within a protocol against a specific
value, compare fields against fields, and check the
existence of specified fields or protocols.</p>

<p>Filters are also used by other features such as
statistics generation and packet list colorization (the
latter is only available to Wireshark). This manual page
describes their syntax. A comprehensive reference of filter
fields can be found within Wireshark and in the display
filter reference at
&lt;http://www.wireshark.org/docs/dfref/&gt;.</p>

<p>FILTER SYNTAX Check whether a field or protocol exists
The simplest filter allows you to check for the existence of
a protocol or field. If you want to see all packets which
contain the IP protocol, the filter would be &quot;ip&quot;
(without the quotation marks). To see all packets that
contain a Token-Ring RIF field, use &quot;tr.rif&quot;.</p>

<p>Think of a protocol or field in a filter as implicitly
having the &quot;exists&quot; operator.</p>

<p>Comparison operators Fields can also be compared against
values. The comparison operators can be expressed either
through English-like abbreviations or through C-like
symbols:</p>

<p>eq, == Equal ne, != Not Equal gt, &gt; Greater Than lt,
&lt; Less Than ge, &gt;= Greater than or Equal to le, &lt;=
Less than or Equal to</p>

<p>Search and match operators Additional operators exist
expressed only in English, not C-like syntax:</p>

<p>contains Does the protocol, field or slice contain a
value matches Does the protocol or text string match the
given Perl regular expression</p>

<p>The &quot;contains&quot; operator allows a filter to
search for a sequence of characters, expressed as a string
(quoted or unquoted), or bytes, expressed as a byte array.
For example, to search for a given HTTP URL in a capture,
the following filter can be used:</p>

<p>http contains &quot;http://www.wireshark.org&quot;</p>

<p>The &quot;contains&quot; operator cannot be used on
atomic fields, such as numbers or IP addresses.</p>

<p>The &quot;matches&quot; operator allows a filter to
apply to a specified Perl- compatible regular expression
(PCRE). The &quot;matches&quot; operator is only implemented
for protocols and for protocol fields with a text string
representation. For example, to search for a given WAP WSP
User-Agent, you can write:</p>

<p>wsp.user_agent matches &quot;(?i)cldc&quot;</p>

<p>This example shows an interesting PCRE feature: pattern
match options have to be specified with the (?option)
construct. For instance, (?i) performs a case-insensitive
pattern match. More information on PCRE can be found in the
pcrepattern(3) man page (Perl Regular Expressions are
explained in
&lt;http://www.perldoc.com/perl5.8.0/pod/perlre.html&gt;).</p>

<p>Note: the &quot;matches&quot; operator is only available
if Wireshark or TShark have been compiled with the PCRE
library. This can be checked by running:</p>

<p>wireshark -v tshark -v</p>

<p>or selecting the &quot;About Wireshark&quot; item from
the &quot;Help&quot; menu in Wireshark.</p>

<p>Functions The filter language has the following
functions:</p>

<p>upper(string-field) - converts a string field to
uppercase lower(string-field) - converts a string field to
lowercase</p>

<p>upper() and lower() are useful for performing
case-insensitive string comparisons. For example:</p>

<p>upper(ncp.nds_stream_name) contains &quot;MACRO&quot;
lower(mount.dump.hostname) == &quot;angel&quot;</p>

<p>Protocol field types Each protocol field is typed. The
types are:</p>

<p>ASN.1 object identifier Boolean Character string
Compiled Perl-Compatible Regular Expression (GRegex) object
Date and time Ethernet or other MAC address EUI64 address
Floating point (double-precision) Floating point
(single-precision) Frame number Globally Unique Identifier
IPv4 address IPv6 address IPX network number Label Protocol
Sequence of bytes Signed integer, 1, 2, 3, 4, or 8 bytes
Time offset Unsigned integer, 1, 2, 3, 4, or 8 bytes</p>

<p>An integer may be expressed in decimal, octal, or
hexadecimal notation. The following three display filters
are equivalent:</p>

<p>frame.pkt_len &gt; 10 frame.pkt_len &gt; 012
frame.pkt_len &gt; 0xa</p>

<p>Boolean values are either true or false. In a display
filter expression testing the value of a Boolean field,
&quot;true&quot; is expressed as 1 or any other non-zero
value, and &quot;false&quot; is expressed as zero. For
example, a token-ring packet s source route field is
Boolean. To find any source-routed packets, a display filter
would be:</p>

<p>tr.sr == 1</p>

<p>Non source-routed packets can be found with:</p>

<p>tr.sr == 0</p>

<p>Ethernet addresses and byte arrays are represented by
hex digits. The hex digits may be separated by colons,
periods, or hyphens:</p>

<p>eth.dst eq ff:ff:ff:ff:ff:ff aim.data == 0.1.0.d
fddi.src == aa-aa-aa-aa-aa-aa echo.data == 7a</p>

<p>IPv4 addresses can be represented in either dotted
decimal notation or by using the hostname:</p>

<p>ip.dst eq www.mit.edu ip.src == 192.168.1.1</p>

<p>IPv4 addresses can be compared with the same logical
relations as numbers: eq, ne, gt, ge, lt, and le. The IPv4
address is stored in host order, so you do not have to worry
about the endianness of an IPv4 address when using it in a
display filter.</p>

<p>Classless InterDomain Routing (CIDR) notation can be
used to test if an IPv4 address is in a certain subnet. For
example, this display filter will find all packets in the
129.111 Class-B network:</p>

<p>ip.addr == 129.111.0.0/16</p>

<p>Remember, the number after the slash represents the
number of bits used to represent the network. CIDR notation
can also be used with hostnames, as in this example of
finding IP addresses on the same Class C network as
sneezy:</p>

<p>ip.addr eq sneezy/24</p>

<p>The CIDR notation can only be used on IP addresses or
hostnames, not in variable names. So, a display filter like
&quot;ip.src/24 == ip.dst/24&quot; is not valid (yet).</p>

<p>IPX networks are represented by unsigned 32-bit
integers. Most likely you will be using hexadecimal when
testing IPX network values:</p>

<p>ipx.src.net == 0xc0a82c00</p>

<p>Strings are enclosed in double quotes:</p>

<p>http.request.method == &quot;POST&quot;</p>

<p>Inside double quotes, you may use a backslash to embed a
double quote or an arbitrary byte represented in either
octal or hexadecimal.</p>

<p>browser.comment == &quot;An embedded</p>

<p>Use of hexadecimal to look for &quot;HEAD&quot;:</p>

<p>http.request.method == &quot;8EAD&quot;</p>

<p>Use of octal to look for &quot;HEAD&quot;:</p>

<p>http.request.method == &quot;110EAD&quot;</p>

<p>This means that you must escape backslashes with
backslashes inside double quotes.</p>

<p>smb.path contains &quot;\\SERVER\SHARE&quot;</p>

<p>looks for \SERVERRE in &quot;smb.path&quot;.</p>

<p>The slice operator You can take a slice of a field if
the field is a text string or a byte array. For example, you
can filter on the vendor portion of an ethernet address (the
first three bytes) like this:</p>

<p>eth.src[0:3] == 00:00:83</p>

<p>Another example is:</p>

<p>http.content_type[0:4] == &quot;text&quot;</p>

<p>You can use the slice operator on a protocol name, too.
The &quot;frame&quot; protocol can be useful, encompassing
all the data captured by Wireshark or TShark.</p>

<p>token[0:5] ne 0.0.0.1.1 llc[0] eq aa frame[100-199]
contains &quot;wireshark&quot;</p>

<p>The following syntax governs slices:</p>

<p>[i:j] i = start_offset, j = length [i-j] i =
start_offset, j = end_offset, inclusive. [i] i =
start_offset, length = 1 [:j] start_offset = 0, length = j
[i:] start_offset = i, end_offset = end_of_field</p>

<p>Offsets can be negative, in which case they indicate the
offset from the end of the field. The last byte of the field
is at offset -1, the last but one byte is at offset -2, and
so on. Heres how to check the last four bytes of a
frame:</p>

<p>frame[-4:4] == 0.1.2.3</p>

<p>or</p>

<p>frame[-4:] == 0.1.2.3</p>

<p>A slice is alwasy compared against either a string or a
byte sequence. As a special case, when the slice is only 1
byte wide, you can compare it against a hex integer that
0xff or less (which means it fits inside one byte). This is
not allowed for byte sequences greater than one byte,
because then one would need to specify the endianness of the
multi-byte integer. Also, this is not allowed for decimal
numbers, since they would be confused with hex numbers that
are already allowed as byte strings. Neverthelss,
single-byte hex integers can be convienent:</p>

<p>frame[4] == 0xff</p>

<p>Slices can be combined. You can concatenate them using
the comma operator:</p>

<p>ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b</p>

<p>This concatenates offset 1, offsets 3-5, and offset 9 to
the end of the ftp data.</p>

<p>Type conversions If a field is a text string or a byte
array, it can be expressed in whichever way is most
convenient.</p>

<p>So, for instance, the following filters are
equivalent:</p>

<p>http.request.method == &quot;GET&quot;
http.request.method == 47.45.54</p>

<p>A range can also be expressed in either way:</p>

<p>frame[60:2] gt 50.51 frame[60:2] gt &quot;PQ&quot;</p>

<p>Bit field operations It is also possible to define tests
with bit field operations. Currently the following bit field
operation is supported:</p>

<p>bitwise_and, &amp; Bitwise AND</p>

<p>The bitwise AND operation allows testing to see if one
or more bits are set. Bitwise AND operates on integer
protocol fields and slices.</p>

<p>When testing for TCP SYN packets, you can write:</p>

<p>tcp.flags &amp; 0x02</p>

<p>That expression will match all packets that contain a
&quot;tcp.flags&quot; field with the 0x02 bit, i.e. the SYN
bit, set.</p>

<p>Similarly, filtering for all WSP GET and extended GET
methods is achieved with:</p>

<p>wsp.pdu_type &amp; 0x40</p>

<p>When using slices, the bit mask must be specified as a
byte string, and it must have the same number of bytes as
the slice itself, as in:</p>

<p>ip[42:2] &amp; 40:ff</p>

<p>Logical expressions Tests can be combined using logical
expressions. These too are expressible in C-like syntax or
with English-like abbreviations:</p>

<p>and, &amp;&amp; Logical AND or, || Logical OR not, !
Logical NOT</p>

<p>Expressions can be grouped by parentheses as well. The
following are all valid display filter expressions:</p>

<p>tcp.port == 80 and ip.src == 192.168.2.1 not llc http
and frame[100-199] contains &quot;wireshark&quot;
(ipx.src.net == 0xbad &amp;&amp; ipx.src.node ==
0.0.0.0.0.1) || ip</p>

<p>Remember that whenever a protocol or field name occurs
in an expression, the &quot;exists&quot; operator is
implicitly called. The &quot;exists&quot; operator has the
highest priority. This means that the first filter
expression must be read as &quot;show me the packets for
which tcp.port exists and equals 80, and ip.src exists and
equals 192.168.2.1&quot;. The second filter expression means
&quot;show me the packets where not (llc exists)&quot;, or
in other words &quot;where llc does not exist&quot; and
hence will match all packets that do not contain the llc
protocol. The third filter expression includes the
constraint that offset 199 in the frame exists, in other
words the length of the frame is at least 200.</p>

<p>A special caveat must be given regarding fields that
occur more than once per packet. &quot;ip.addr&quot; occurs
twice per IP packet, once for the source address, and once
for the destination address. Likewise,
&quot;tr.rif.ring&quot; fields can occur more than once per
packet. The following two expressions are not
equivalent:</p>

<p>ip.addr ne 192.168.4.1 not ip.addr eq 192.168.4.1</p>

<p>The first filter says &quot;show me packets where an
ip.addr exists that does not equal 192.168.4.1&quot;. That
is, as long as one ip.addr in the packet does not equal
192.168.4.1, the packet passes the display filter. The other
ip.addr could equal 192.168.4.1 and the packet would still
be displayed. The second filter says &quot;dont show me any
packets that have an ip.addr field equal to
192.168.4.1&quot;. If one ip.addr is 192.168.4.1, the packet
does not pass. If neither ip.addr field is 192.168.4.1, then
the packet is displayed.</p>

<p>It is easy to think of the ne and eq operators as having
an implicit &quot;exists&quot; modifier when dealing with
multiply-recurring fields. &quot;ip.addr ne
192.168.4.1&quot; can be thought of as &quot;there exists an
ip.addr that does not equal 192.168.4.1&quot;. &quot;not
ip.addr eq 192.168.4.1&quot; can be thought of as
&quot;there does not exist an ip.addr equal to
192.168.4.1&quot;.</p>

<p>Be careful with multiply-recurring fields; they can be
confusing.</p>

<p>Care must also be taken when using the display filter to
remove noise from the packet trace. If, for example, you
want to filter out all IP multicast packets to address
224.1.2.3, then using:</p>

<p>ip.dst ne 224.1.2.3</p>

<p>may be too restrictive. Filtering with
&quot;ip.dst&quot; selects only those IP packets that
satisfy the rule. Any other packets, including all non-IP
packets, will not be displayed. To display the non-IP
packets as well, you can use one of the following two
expressions:</p>

<p>not ip or ip.dst ne 224.1.2.3 not ip.addr eq
224.1.2.3</p>

<p>The first filter uses &quot;not ip&quot; to include all
non-IP packets and then lets &quot;ip.dst ne 224.1.2.3&quot;
filter out the unwanted IP packets. The second filter has
already been explained above where filtering with multiply
occurring fields was discussed.</p>

<p>FILTER FIELD REFERENCE The entire list of display
filters is too large to list here. You can can find
references and examples at the following locations:</p>

<p>&middot; The online Display Filter Reference:
&lt;http://www.wireshark.org/docs/dfref/&gt;</p>

<p>&middot; Help:Supported Protocols in Wireshark</p>

<p>&middot; &quot;tshark -G fields&quot; on the command
line</p>

<p>&middot; The Wireshark wiki:
&lt;http://wiki.wireshark.org/DisplayFilters&gt;</p>

<p>NOTES The wireshark-filters manpage is part of the
Wireshark distribution. The latest version of Wireshark can
be found at &lt;http://www.wireshark.org&gt;.</p>

<p>Regular expressions in the &quot;matches&quot; operator
are provided with libpcre, the Perl-Compatible Regular
Expressions library: see http://www.pcre.org/.</p>

<p>This manpage does not describe the capture filter
syntax, which is different. See the manual page of
pcap-filter(7) or, if that doesnt exist, tcpdump(8), or, if
that doesnt exist,
&lt;http://wiki.wireshark.org/CaptureFilters&gt; for a
description of capture filters.</p>

<p>SEE ALSO wireshark(1), tshark(1), editcap(1), pcap(3),
pcap-filter(7) or tcpdump(8) if it doesnt exist.</p>

<p>AUTHORS See the list of authors in the Wireshark man
page for a list of authors of that code.</p>

<p>1.8.10 2013-07-23 WIRESHARK-FILTER(4)</p>
<hr>
</body>
</html>
