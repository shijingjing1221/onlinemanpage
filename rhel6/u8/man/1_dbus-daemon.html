<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:09:31 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>dbus-daemon(1) dbus-daemon(1)</p>

<p>NAME dbus-daemon - Message bus daemon</p>

<p>SYNOPSIS dbus-daemon dbus-daemon [--version] [--session]
[--system] [--config- file=FILE]
[--print-address[=DESCRIPTOR]] [--print-pid[=DESCRIPTOR]]
[--fork]</p>

<p>DESCRIPTION dbus-daemon is the D-Bus message bus daemon.
See http://www.freedesk- top.org/software/dbus/ for more
information about the big picture. D- Bus is first a library
that provides one-to-one communication between any two
applications; dbus-daemon is an application that uses this
library to implement a message bus daemon. Multiple programs
connect to the message bus daemon and can exchange messages
with one another.</p>

<p>There are two standard message bus instances: the
systemwide message bus (installed on many systems as the
&quot;messagebus&quot; init service) and the
per-user-login-session message bus (started each time a user
logs in). dbus-daemon is used for both of these instances,
but with a dif- ferent configuration file.</p>

<p>The --session option is equivalent to
&quot;--config-file=/etc/dbus-1/ses- sion.conf&quot; and the
--system option is equivalent to &quot;--config-
file=/etc/dbus-1/system.conf&quot;. By creating additional
configuration files and using the --config-file option,
additional special-purpose message bus daemons could be
created.</p>

<p>The systemwide daemon is normally launched by an init
script, stan- dardly called simply
&quot;messagebus&quot;.</p>

<p>The systemwide daemon is largely used for broadcasting
system events, such as changes to the printer queue, or
adding/removing devices.</p>

<p>The per-session daemon is used for various interprocess
communication among desktop applications (however, it is not
tied to X or the GUI in any way).</p>

<p>SIGHUP will cause the D-Bus daemon to PARTIALLY reload
its configura- tion file and to flush its user/group
information caches. Some configu- ration changes would
require kicking all apps off the bus; so they will only take
effect if you restart the daemon. Policy changes should take
effect with SIGHUP.</p>

<p>OPTIONS The following options are supported:</p>

<p>--config-file=FILE Use the given configuration file.</p>

<p>--fork Force the message bus to fork and become a
daemon, even if the configuration file does not specify that
it should. In most contexts the configuration file already
gets this right, though.</p>

<p>--print-address[=DESCRIPTOR] Print the address of the
message bus to standard output, or to the given file
descriptor. This is used by programs that launch the message
bus.</p>

<p>--print-pid[=DESCRIPTOR] Print the process ID of the
message bus to standard output, or to the given file
descriptor. This is used by programs that launch the message
bus.</p>

<p>--session Use the standard configuration file for the
per-login-session message bus.</p>

<p>--system Use the standard configuration file for the
systemwide message bus.</p>

<p>--version Print the version of the daemon.</p>

<p>CONFIGURATION FILE A message bus daemon has a
configuration file that specializes it for a particular
application. For example, one configuration file might set
up the message bus to be a systemwide message bus, while
another might set it up to be a per-user-login-session
bus.</p>

<p>The configuration file also establishes resource limits,
security parameters, and so forth.</p>

<p>The configuration file is not part of any
interoperability specifica- tion and its backward
compatibility is not guaranteed; this document is
documentation, not specification.</p>

<p>The standard systemwide and per-session message bus
setups are config- ured in the files
&quot;/etc/dbus-1/system.conf&quot; and
&quot;/etc/dbus-1/ses- sion.conf&quot;. These files normally
&lt;include&gt; a system-local.conf or ses- sion-local.conf;
you can put local overrides in those files to avoid
modifying the primary configuration files.</p>

<p>The configuration file is an XML document. It must have
the following doctype declaration:</p>

<p>&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD
D-Bus Bus Configuration 1.0//EN&quot;
&quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;</p>

<p>The following elements may be present in the
configuration file.</p>

<p>&lt;busconfig&gt;</p>

<p>Root element.</p>

<p>&lt;type&gt;</p>

<p>The well-known type of the message bus. Currently known
values are &quot;system&quot; and &quot;session&quot;; if
other values are set, they should be either added to the
D-Bus specification, or namespaced. The last &lt;type&gt;
ele- ment &quot;wins&quot; (previous values are ignored).
This element only controls which message bus specific
environment variables are set in activated clients. Most of
the policy that distinguishes a session bus from the system
bus is controlled from the other elements in the
configuration file.</p>

<p>If the well-known type of the message bus is
&quot;session&quot;, then the DBUS_STARTER_BUS_TYPE
environment variable will be set to &quot;session&quot; and
the DBUS_SESSION_BUS_ADDRESS environment variable will be
set to the address of the session bus. Likewise, if the type
of the message bus is &quot;system&quot;, then the
DBUS_STARTER_BUS_TYPE environment variable will be set to
&quot;system&quot; and the DBUS_SESSION_BUS_ADDRESS
environment vari- able will be set to the address of the
system bus (which is normally well known anyway).</p>

<p>Example: &lt;type&gt;session&lt;/type&gt;</p>

<p>&lt;include&gt;</p>

<p>Include a file
&lt;include&gt;filename.conf&lt;/include&gt; at this point.
If the filename is relative, it is located relative to the
configuration file doing the including.</p>

<p>&lt;include&gt; has an optional attribute
&quot;ignore_missing=(yes|no)&quot; which defaults to
&quot;no&quot; if not provided. This attribute controls
whether its a fatal error for the included file to be
absent.</p>

<p>&lt;includedir&gt;</p>

<p>Include all files in
&lt;includedir&gt;foo.d&lt;/includedir&gt; at this point.
Files in the directory are included in undefined order. Only
files ending in &quot;.conf&quot; are included.</p>

<p>This is intended to allow extension of the system bus by
particular packages. For example, if CUPS wants to be able
to send out notifica- tion of printer queue changes, it
could install a file to /etc/dbus-1/system.d that allowed
all apps to receive this message and allowed the printer
daemon user to send it.</p>

<p>&lt;user&gt;</p>

<p>The user account the daemon should run as, as either a
username or a UID. If the daemon cannot change to this UID
on startup, it will exit. If this element is not present,
the daemon will not change or care about its UID.</p>

<p>The last &lt;user&gt; entry in the file
&quot;wins&quot;, the others are ignored.</p>

<p>The user is changed after the bus has completed
initialization. So sockets etc. will be created before
changing user, but no data will be read from clients before
changing user. This means that sockets and PID files can be
created in a location that requires root privileges for
writing.</p>

<p>&lt;fork&gt;</p>

<p>If present, the bus daemon becomes a real daemon (forks
into the back- ground, etc.). This is generally used rather
than the --fork command line option.</p>

<p>&lt;keep_umask&gt;</p>

<p>If present, the bus daemon keeps its original umask when
forking. This may be useful to avoid affecting the behavior
of child processes.</p>

<p>&lt;listen&gt;</p>

<p>Add an address that the bus should listen on. The
address is in the standard D-Bus format that contains a
transport name plus possible parameters/options.</p>

<p>Example:
&lt;listen&gt;unix:path=/tmp/foo&lt;/listen&gt;</p>

<p>Example:
&lt;listen&gt;tcp:host=localhost,port=1234&lt;/listen&gt;</p>

<p>If there are multiple &lt;listen&gt; elements, then the
bus listens on multi- ple addresses. The bus will pass its
address to started services or other interested parties with
the last address given in &lt;listen&gt; first. That is,
apps will try to connect to the last &lt;listen&gt; address
first.</p>

<p>tcp sockets can accept IPv4 addresses, IPv6 addresses or
hostnames. If a hostname resolves to multiple addresses, the
server will bind to all of them. The family=ipv4 or
family=ipv6 options can be used to force it to bind to a
subset of addresses</p>

<p>Example:
&lt;listen&gt;tcp:host=localhost,port=0,family=ipv4&lt;/listen&gt;</p>

<p>A special case is using a port number of zero (or
omitting the port), which means to choose an available port
selected by the operating sys- tem. The port number chosen
can be obtained with the --print-address command line
parameter and will be present in other cases where the
server reports its own address, such as when
DBUS_SESSION_BUS_ADDRESS is set.</p>

<p>Example:
&lt;listen&gt;tcp:host=localhost,port=0&lt;/listen&gt;</p>

<p>tcp addresses also allow a bind=hostname option, which
will override the host option specifying what address to
bind to, without changing the address reported by the bus.
The bind option can also take a spe- cial name * to cause
the bus to listen on all local address (INADDR_ANY). The
specified host should be a valid name of the local machine
or weird stuff will happen.</p>

<p>Example:
&lt;listen&gt;tcp:host=localhost,bind=*,port=0&lt;/listen&gt;</p>

<p>&lt;auth&gt;</p>

<p>Lists permitted authorization mechanisms. If this
element doesnt exist, then all known mechanisms are allowed.
If there are multiple &lt;auth&gt; elements, all the listed
mechanisms are allowed. The order in which mechanisms are
listed is not meaningful.</p>

<p>Example: &lt;auth&gt;EXTERNAL&lt;/auth&gt;</p>

<p>Example: &lt;auth&gt;DBUS_COOKIE_SHA1&lt;/auth&gt;</p>

<p>&lt;servicedir&gt;</p>

<p>Adds a directory to scan for .service files. Directories
are scanned starting with the last to appear in the config
file (the first .service file found that provides a
particular service will be used).</p>

<p>Service files tell the bus how to automatically start a
program. They are primarily used with the per-user-session
bus, not the systemwide bus.</p>

<p>&lt;standard_session_servicedirs/&gt;</p>

<p>&lt;standard_session_servicedirs/&gt; is equivalent to
specifying a series of &lt;servicedir/&gt; elements for each
of the data directories in the &quot;XDG Base Directory
Specification&quot; with the subdirectory
&quot;dbus-1/services&quot;, so for example
&quot;/usr/share/dbus-1/services&quot; would be among the
directo- ries searched.</p>

<p>The &quot;XDG Base Directory Specification&quot; can be
found at http://freedesk-
top.org/wiki/Standards/basedir-spec if it hasn t moved,
otherwise try your favorite search engine.</p>

<p>The &lt;standard_session_servicedirs/&gt; option is only
relevant to the per- user-session bus daemon defined in
/etc/dbus-1/session.conf. Putting it in any other
configuration file would probably be nonsense.</p>

<p>&lt;standard_system_servicedirs/&gt;</p>

<p>&lt;standard_system_servicedirs/&gt; specifies the
standard system-wide acti- vation directories that should be
searched for service files. This option defaults to
/usr/share/dbus-1/system-services.</p>

<p>The &lt;standard_system_servicedirs/&gt; option is only
relevant to the per- system bus daemon defined in
/etc/dbus-1/system.conf. Putting it in any other
configuration file would probably be nonsense.</p>

<p>&lt;servicehelper/&gt;</p>

<p>&lt;servicehelper/&gt; specifies the setuid helper that
is used to launch system daemons with an alternate user.
Typically this should be the dbus-daemon-launch-helper
executable in located in libexec.</p>

<p>The &lt;servicehelper/&gt; option is only relevant to
the per-system bus dae- mon defined in
/etc/dbus-1/system.conf. Putting it in any other config-
uration file would probably be nonsense.</p>

<p>&lt;limit&gt;</p>

<p>&lt;limit&gt; establishes a resource limit. For example:
&lt;limit
name=&quot;max_message_size&quot;&gt;64&lt;/limit&gt;
&lt;limit
name=&quot;max_completed_connections&quot;&gt;512&lt;/limit&gt;</p>

<p>The name attribute is mandatory. Available limit names
are: &quot;max_incoming_bytes&quot; : total size in bytes of
messages incoming from a single connection
&quot;max_outgoing_bytes&quot; : total size in bytes of
messages queued up for a single connection
&quot;max_message_size&quot; : max size of a single message
in bytes &quot;service_start_timeout&quot; : milliseconds
(thousandths) until a started service has to connect
&quot;auth_timeout&quot; : milliseconds (thousandths) a
connection is given to authenticate
&quot;max_completed_connections&quot; : max number of
authenticated connections
&quot;max_incomplete_connections&quot; : max number of
unauthenticated connections
&quot;max_connections_per_user&quot; : max number of
completed connections from the same user
&quot;max_pending_service_starts&quot; : max number of
service launches in progress at the same time
&quot;max_names_per_connection&quot; : max number of names a
single connection can own
&quot;max_match_rules_per_connection&quot;: max number of
match rules for a single connection
&quot;max_replies_per_connection&quot; : max number of
pending method replies per connection (number of
calls-in-progress) &quot;reply_timeout&quot; : milliseconds
(thousandths) until a method call times out</p>

<p>The max incoming/outgoing queue sizes allow a new
message to be queued if one byte remains below the max. So
you can in fact exceed the max by max_message_size.</p>

<p>max_completed_connections divided by
max_connections_per_user is the number of users that can
work together to denial-of-service all other users by using
up all connections on the systemwide bus.</p>

<p>Limits are normally only of interest on the systemwide
bus, not the user session buses.</p>

<p>&lt;policy&gt;</p>

<p>The &lt;policy&gt; element defines a security policy to
be applied to a par- ticular set of connections to the bus.
A policy is made up of &lt;allow&gt; and &lt;deny&gt;
elements. Policies are normally used with the systemwide
bus; they are analogous to a firewall in that they allow
expected traffic and prevent unexpected traffic.</p>

<p>Currently, the system bus has a default-deny policy for
sending method calls and owning bus names. Everything else,
in particular reply mes- sages, receive checks, and signals
has a default allow policy.</p>

<p>In general, it is best to keep system services as small,
targeted pro- grams which run in their own process and
provide a single bus name. Then, all that is needed is an
&lt;allow&gt; rule for the &quot;own&quot; permission to let
the process claim the bus name, and a
&quot;send_destination&quot; rule to allow traffic from some
or all uids to your service.</p>

<p>The &lt;policy&gt; element has one of four attributes:
daemon.1.in context=&quot;(default|mandatory)&quot;
at_console=&quot;(true|false)&quot; user=&quot;username or
userid&quot; group=&quot;group name or gid&quot;</p>

<p>Policies are applied to a connection as follows: - all
context=&quot;default&quot; policies are applied - all
group=&quot;connections user s group&quot; policies are
applied in undefined order - all user=&quot;connections auth
user&quot; policies are applied in undefined order - all
at_console=&quot;true&quot; policies are applied - all
at_console=&quot;false&quot; policies are applied - all
context=&quot;mandatory&quot; policies are applied</p>

<p>Policies applied later will override those applied
earlier, when the policies overlap. Multiple policies with
the same user/group/context are applied in the order they
appear in the config file.</p>

<p>&lt;deny&gt; &lt;allow&gt;</p>

<p>A &lt;deny&gt; element appears below a &lt;policy&gt;
element and prohibits some action. The &lt;allow&gt; element
makes an exception to previous &lt;deny&gt; statements, and
works just like &lt;deny&gt; but with the inverse
meaning.</p>

<p>The possible attributes of these elements are:
send_interface=&quot;interface_name&quot;
send_member=&quot;method_or_signal_name&quot;
send_error=&quot;error_name&quot;
send_destination=&quot;name&quot;
send_type=&quot;method_call&quot; |
&quot;method_return&quot; | &quot;signal&quot; |
&quot;error&quot; send_path=&quot;/path/name&quot;</p>

<p>receive_interface=&quot;interface_name&quot;
receive_member=&quot;method_or_signal_name&quot;
receive_error=&quot;error_name&quot;
receive_sender=&quot;name&quot;
receive_type=&quot;method_call&quot; |
&quot;method_return&quot; | &quot;signal&quot; |
&quot;error&quot; receive_path=&quot;/path/name&quot;</p>

<p>send_requested_reply=&quot;true&quot; |
&quot;false&quot; receive_requested_reply=&quot;true&quot; |
&quot;false&quot;</p>

<p>eavesdrop=&quot;true&quot; | &quot;false&quot;</p>

<p>own=&quot;name&quot; user=&quot;username&quot;
group=&quot;groupname&quot;</p>

<p>Examples: &lt;deny
send_interface=&quot;org.freedesktop.System&quot;
send_member=&quot;Reboot&quot;/&gt; &lt;deny
receive_interface=&quot;org.freedesktop.System&quot;
receive_member=&quot;Reboot&quot;/&gt; &lt;deny
own=&quot;org.freedesktop.System&quot;/&gt; &lt;deny
send_destination=&quot;org.freedesktop.System&quot;/&gt;
&lt;deny
receive_sender=&quot;org.freedesktop.System&quot;/&gt;
&lt;deny user=&quot;john&quot;/&gt; &lt;deny
group=&quot;enemies&quot;/&gt;</p>

<p>The &lt;deny&gt; elements attributes determine whether
the deny &quot;matches&quot; a particular action. If it
matches, the action is denied (unless later rules in the
config file allow it).</p>

<p>send_destination and receive_sender rules mean that
messages may not be sent to or received from the *owner* of
the given name, not that they may not be sent *to that
name*. That is, if a connection owns services A, B, C, and
sending to A is denied, sending to B or C will not work
either.</p>

<p>The other send_* and receive_* attributes are purely
textual/by-value matches against the given field in the
message header.</p>

<p>&quot;Eavesdropping&quot; occurs when an application
receives a message that was explicitly addressed to a name
the application does not own, or is a reply to such a
message. Eavesdropping thus only applies to messages that
are addressed to services and replies to such messages (i.e.
it does not apply to signals).</p>

<p>For &lt;allow&gt;, eavesdrop=&quot;true&quot; indicates
that the rule matches even when eavesdropping.
eavesdrop=&quot;false&quot; is the default and means that
the rule only allows messages to go to their specified
recipient. For &lt;deny&gt;, eavesdrop=&quot;true&quot;
indicates that the rule matches only when eavesdrop- ping.
eavesdrop=&quot;false&quot; is the default for &lt;deny&gt;
also, but here it means that the rule applies always, even
when not eavesdropping. The eavesdrop attribute can only be
combined with send and receive rules (with send_* and
receive_* attributes).</p>

<p>The [send|receive]_requested_reply attribute works
similarly to the eavesdrop attribute. It controls whether
the &lt;deny&gt; or &lt;allow&gt; matches a reply that is
expected (corresponds to a previous method call mes- sage).
This attribute only makes sense for reply messages (errors
and method returns), and is ignored for other message
types.</p>

<p>For &lt;allow&gt;,
[send|receive]_requested_reply=&quot;true&quot; is the
default and indicates that only requested replies are
allowed by the rule.
[send|receive]_requested_reply=&quot;false&quot; means that
the rule allows any reply even if unexpected.</p>

<p>For &lt;deny&gt;,
[send|receive]_requested_reply=&quot;false&quot; is the
default but indicates that the rule matches only when the
reply was not requested.
[send|receive]_requested_reply=&quot;true&quot; indicates
that the rule applies always, regardless of pending reply
state.</p>

<p>user and group denials mean that the given user or group
may not con- nect to the message bus.</p>

<p>For &quot;name&quot;, &quot;username&quot;,
&quot;groupname&quot;, etc. the character &quot;*&quot; can
be substituted, meaning &quot;any.&quot; Complex globs like
&quot;foo.bar.*&quot; arent allowed for now because theyd be
work to implement and maybe encourage sloppy security
anyway.</p>

<p>It does not make sense to deny a user or group inside a
&lt;policy&gt; for a user or group; user/group denials can
only be inside context=&quot;default&quot; or
context=&quot;mandatory&quot; policies.</p>

<p>A single &lt;deny&gt; rule may specify combinations of
attributes such as send_destination and send_interface and
send_type. In this case, the denial applies only if both
attributes match the message being denied. e.g. &lt;deny
send_interface=&quot;foo.bar&quot;
send_destination=&quot;foo.blah&quot;/&gt; would deny
messages with the given interface AND the given bus name. To
get an OR effect you specify multiple &lt;deny&gt;
rules.</p>

<p>You cant include both send_ and receive_ attributes on
the same rule, since &quot;whether the message can be
sent&quot; and &quot;whether it can be received&quot; are
evaluated separately.</p>

<p>Be careful with send_interface/receive_interface,
because the interface field in messages is optional. In
particular, do NOT specify &lt;deny
send_interface=&quot;org.foo.Bar&quot;/&gt;! This will cause
no-interface messages to be blocked for all services, which
is almost certainly not what you intended. Always use rules
of the form: &lt;deny send_inter-
face=&quot;org.foo.Bar&quot;
send_destination=&quot;org.foo.Service&quot;/&gt;</p>

<p>&lt;selinux&gt;</p>

<p>The &lt;selinux&gt; element contains settings related to
Security Enhanced Linux. More details below.</p>

<p>&lt;associate&gt;</p>

<p>An &lt;associate&gt; element appears below an
&lt;selinux&gt; element and creates a mapping. Right now
only one kind of association is possible: &lt;associate
own=&quot;org.freedesktop.Foobar&quot;
context=&quot;foo_t&quot;/&gt;</p>

<p>This means that if a connection asks to own the name
&quot;org.freedesk- top.Foobar&quot; then the source context
will be the context of the connec- tion and the target
context will be &quot;foo_t&quot; - see the short discussion
of SELinux below.</p>

<p>Note, the context here is the target context when
requesting a name, NOT the context of the connection owning
the name.</p>

<p>There s currently no way to set a default for owning any
name, if we add this syntax it will look like: &lt;associate
own=&quot;*&quot; context=&quot;foo_t&quot;/&gt; If you find
a reason this is useful, let the developers know. Right now
the default will be the security context of the bus
itself.</p>

<p>If two &lt;associate&gt; elements specify the same name,
the element appear- ing later in the configuration file will
be used.</p>

<p>SELinux See http://www.nsa.gov/selinux/ for full details
on SELinux. Some use- ful excerpts:</p>

<p>Every subject (process) and object (e.g. file, socket,
IPC object, etc) in the system is assigned a collection of
security attributes, known as a security context. A security
context contains all of the security attributes associated
with a par- ticular subject or object that are relevant to
the security policy.</p>

<p>In order to better encapsulate security contexts and to
provide greater efficiency, the policy enforcement code of
SELinux typ- ically handles security identifiers (SIDs)
rather than security contexts. A SID is an integer that is
mapped by the security server to a security context at
runtime.</p>

<p>When a security decision is required, the policy
enforcement code passes a pair of SIDs (typically the SID of
a subject and the SID of an object, but sometimes a pair of
subject SIDs or a pair of object SIDs), and an object
security class to the secu- rity server. The object security
class indicates the kind of object, e.g. a process, a
regular file, a directory, a TCP socket, etc.</p>

<p>Access decisions specify whether or not a permission is
granted for a given pair of SIDs and class. Each object
class has a set of associated permissions defined to control
operations on objects with that class.</p>

<p>D-Bus performs SELinux security checks in two
places.</p>

<p>First, any time a message is routed from one connection
to another con- nection, the bus daemon will check
permissions with the security con- text of the first
connection as source, security context of the second
connection as target, object class &quot;dbus&quot; and
requested permission &quot;send_msg&quot;.</p>

<p>If a security context is not available for a connection
(impossible when using UNIX domain sockets), then the target
context used is the context of the bus daemon itself. There
is currently no way to change this default, because were
assuming that only UNIX domain sockets will be used to
connect to the systemwide bus. If this changes, well proba-
bly add a way to set the default connection context.</p>

<p>Second, any time a connection asks to own a name, the
bus daemon will check permissions with the security context
of the connection as source, the security context specified
for the name in the config file as target, object class
&quot;dbus&quot; and requested permission
&quot;acquire_svc&quot;.</p>

<p>The security context for a bus name is specified with
the &lt;associate&gt; element described earlier in this
document. If a name has no security context associated in
the configuration file, the security context of the bus
daemon itself will be used.</p>

<p>DEBUGGING If youre trying to figure out where your
messages are going or why you aren t getting messages, there
are several things you can try.</p>

<p>Remember that the system bus is heavily locked down and
if you havent installed a security policy file to allow your
message through, it wont work. For the session bus, this is
not a concern.</p>

<p>The simplest way to figure out whats happening on the
bus is to run the dbus-monitor program, which comes with the
D-Bus package. You can also send test messages with
dbus-send. These programs have their own man pages.</p>

<p>If you want to know what the daemon itself is doing, you
might consider running a separate copy of the daemon to test
against. This will allow you to put the daemon under a
debugger, or run it with verbose output, without messing up
your real session and system daemons.</p>

<p>To run a separate test copy of the daemon, for example
you might open a terminal and type: DBUS_VERBOSE=1
dbus-daemon --session --print-address</p>

<p>The test daemon address will be printed when the daemon
starts. You will need to copy-and-paste this address and use
it as the value of the DBUS_SESSION_BUS_ADDRESS environment
variable when you launch the applications you want to test.
This will cause those applications to connect to your test
bus instead of the DBUS_SESSION_BUS_ADDRESS of your real
session bus.</p>

<p>DBUS_VERBOSE=1 will have NO EFFECT unless your copy of
D-Bus was com- piled with verbose mode enabled. This is not
recommended in production builds due to performance impact.
You may need to rebuild D-Bus if your copy was not built
with debugging in mind. (DBUS_VERBOSE also affects the D-Bus
library and thus applications using D-Bus; it may be useful
to see verbose output on both the client side and from the
daemon.)</p>

<p>If you want to get fancy, you can create a custom bus
configuration for your test bus (see the session.conf and
system.conf files that define the two default configurations
for example). This would allow you to specify a different
directory for .service files, for example.</p>

<p>AUTHOR See
http://www.freedesktop.org/software/dbus/doc/AUTHORS</p>

<p>BUGS Please send bug reports to the D-Bus mailing list
or bug tracker, see
http://www.freedesktop.org/software/dbus/</p>

<p>dbus-daemon(1)</p>
<hr>
</body>
</html>
