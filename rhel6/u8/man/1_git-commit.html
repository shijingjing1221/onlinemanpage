<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:15:59 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-COMMIT(1) Git Manual GIT-COMMIT(1)</p>

<p>NAME git-commit - Record changes to the repository</p>

<p>SYNOPSIS git commit [-a | --interactive] [-s] [-v]
[-u&lt;mode&gt;] [--amend] [--dry-run] [(-c | -C)
&lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;]
[--reset-author] [--allow-empty] [--no-verify] [-e]
[--author=&lt;author&gt;] [--date=&lt;date&gt;]
[--cleanup=&lt;mode&gt;] [--status | --no-status] [--] [[-i
| -o ]&lt;file&gt;...]</p>

<p>DESCRIPTION Stores the current contents of the index in
a new commit along with a log message from the user
describing the changes.</p>

<p>The content to be added can be specified in several
ways:</p>

<p>1. by using git add to incrementally &quot;add&quot;
changes to the index before using the commit command (Note:
even modified files must be &quot;added&quot;);</p>

<p>2. by using git rm to remove files from the working tree
and the index, again before using the commit command;</p>

<p>3. by listing files as arguments to the commit command,
in which case the commit will ignore changes staged in the
index, and instead record the current content of the listed
files (which must already be known to git);</p>

<p>4. by using the -a switch with the commit command to
automatically &quot;add&quot; changes from all known files
(i.e. all files that are already listed in the index) and to
automatically &quot;rm&quot; files in the index that have
been removed from the working tree, and then perform the
actual commit;</p>

<p>5. by using the --interactive switch with the commit
command to decide one by one which files should be part of
the commit, before finalizing the operation. Currently, this
is done by invoking git add --interactive.</p>

<p>The --dry-run option can be used to obtain a summary of
what is included by any of the above for the next commit by
giving the same set of parameters (options and paths).</p>

<p>If you make a commit and then find a mistake immediately
after that, you can recover from it with git reset.</p>

<p>OPTIONS -a, --all Tell the command to automatically
stage files that have been modified and deleted, but new
files you have not told git about are not affected.</p>

<p>-C &lt;commit&gt;, --reuse-message=&lt;commit&gt; Take
an existing commit object, and reuse the log message and the
authorship information (including the timestamp) when
creating the commit.</p>

<p>-c &lt;commit&gt;, --reedit-message=&lt;commit&gt; Like
-C, but with -c the editor is invoked, so that the user can
further edit the commit message.</p>

<p>--reset-author When used with -C/-c/--amend options,
declare that the authorship of the resulting commit now
belongs of the committer. This also renews the author
timestamp.</p>

<p>--short When doing a dry-run, give the output in the
short-format. See git- status(1) for details. Implies
--dry-run.</p>

<p>--porcelain When doing a dry-run, give the output in a
porcelain-ready format. See git-status(1) for details.
Implies --dry-run.</p>

<p>-z When showing short or porcelain status output,
terminate entries in the status output with NUL, instead of
LF. If no format is given, implies the --porcelain output
format.</p>

<p>-F &lt;file&gt;, --file=&lt;file&gt; Take the commit
message from the given file. Use - to read the message from
the standard input.</p>

<p>--author=&lt;author&gt; Override the author name used in
the commit. You can use the standard A U Thor
&lt;author@example.com[1]&gt; format. Otherwise, an existing
commit that matches the given string and its author name is
used.</p>

<p>--date=&lt;date&gt; Override the author date used in the
commit.</p>

<p>-m &lt;msg&gt;, --message=&lt;msg&gt; Use the given
&lt;msg&gt; as the commit message.</p>

<p>-t &lt;file&gt;, --template=&lt;file&gt; Use the
contents of the given file as the initial version of the
commit message. The editor is invoked and you can make
subsequent changes. If a message is specified using the -m
or -F options, this option has no effect. This overrides the
commit.template configuration variable.</p>

<p>-s, --signoff Add Signed-off-by line by the committer at
the end of the commit log message.</p>

<p>-n, --no-verify This option bypasses the pre-commit and
commit-msg hooks. See also githooks(5).</p>

<p>--allow-empty Usually recording a commit that has the
exact same tree as its sole parent commit is a mistake, and
the command prevents you from making such a commit. This
option bypasses the safety, and is primarily for use by
foreign scm interface scripts.</p>

<p>--cleanup=&lt;mode&gt; This option sets how the commit
message is cleaned up. The &lt;mode&gt; can be one of
verbatim, whitespace, strip, and default. The default mode
will strip leading and trailing empty lines and #commentary
from the commit message only if the message is to be edited.
Otherwise only whitespace removed. The verbatim mode does
not change message at all, whitespace removes just
leading/trailing whitespace lines and strip removes both
whitespace and commentary.</p>

<p>-e, --edit The message taken from file with -F, command
line with -m, and from file with -C are usually used as the
commit log message unmodified. This option lets you further
edit the message taken from these sources.</p>

<p>--amend Used to amend the tip of the current branch.
Prepare the tree object you would want to replace the latest
commit as usual (this includes the usual -i/-o and explicit
paths), and the commit log editor is seeded with the commit
message from the tip of the current branch. The commit you
create replaces the current tip if it was a merge, it will
have the parents of the current tip as parents so the
current top commit is discarded.</p>

<p>It is a rough equivalent for:</p>

<p>$ git reset --soft HEAD^ $ ... do something else to come
up with the right tree ... $ git commit -c ORIG_HEAD</p>

<p>but can be used to amend a merge commit.</p>

<p>You should understand the implications of rewriting
history if you amend a commit that has already been
published. (See the &quot;RECOVERING FROM UPSTREAM
REBASE&quot; section in git-rebase(1).)</p>

<p>-i, --include Before making a commit out of staged
contents so far, stage the contents of paths given on the
command line as well. This is usually not what you want
unless you are concluding a conflicted merge.</p>

<p>-o, --only Make a commit only from the paths specified
on the command line, disregarding any contents that have
been staged so far. This is the default mode of operation of
git commit if any paths are given on the command line, in
which case this option can be omitted. If this option is
specified together with --amend, then no paths need to be
specified, which can be used to amend the last commit
without committing changes that have already been
staged.</p>

<p>-u[&lt;mode&gt;], --untracked-files[=&lt;mode&gt;] Show
untracked files (Default: all).</p>

<p>The mode parameter is optional, and is used to specify
the handling of untracked files.</p>

<p>The possible options are:</p>

<p>&middot; no - Show no untracked files</p>

<p>&middot; normal - Shows untracked files and
directories</p>

<p>&middot; all - Also shows individual files in untracked
directories.</p>

<p>See git-config(1) for configuration variable used to
change the default for when the option is not specified.</p>

<p>-v, --verbose Show unified diff between the HEAD commit
and what would be committed at the bottom of the commit
message template. Note that this diff output doesnt have its
lines prefixed with #.</p>

<p>-q, --quiet Suppress commit summary message.</p>

<p>--dry-run Do not create a commit, but show a list of
paths that are to be committed, paths with local changes
that will be left uncommitted and paths that are
untracked.</p>

<p>--status Include the output of git-status(1) in the
commit message template when using an editor to prepare the
commit message. Defaults to on, but can be used to override
configuration variable commit.status.</p>

<p>--no-status Do not include the output of git-status(1)
in the commit message template when using an editor to
prepare the default commit message.</p>

<p>-- Do not interpret any more arguments as options.</p>

<p>&lt;file&gt;... When files are given on the command
line, the command commits the contents of the named files,
without recording the changes already staged. The contents
of these files are also staged for the next commit on top of
what have been staged before.</p>

<p>DATE FORMATS The GIT_AUTHOR_DATE, GIT_COMMITTER_DATE
environment variables and the --date option support the
following date formats:</p>

<p>Git internal format It is &lt;unix timestamp&gt;
&lt;timezone offset&gt;, where &lt;unix timestamp&gt; is the
number of seconds since the UNIX epoch. &lt;timezone
offset&gt; is a positive or negative offset from UTC. For
example CET (which is 2 hours ahead UTC) is +0200.</p>

<p>RFC 2822 The standard email format as described by RFC
2822, for example Thu, 07 Apr 2005 22:13:13 +0200.</p>

<p>ISO 8601 Time and date specified by the ISO 8601
standard, for example 2005-04-07T22:13:13. The parser
accepts a space instead of the T character as well.</p>

<p>Note In addition, the date part is accepted in the
following formats: YYYY.MM.DD, MM/DD/YYYY and
DD.MM.YYYY.</p>

<p>EXAMPLES When recording your own work, the contents of
modified files in your working tree are temporarily stored
to a staging area called the &quot;index&quot; with git add.
A file can be reverted back, only in the index but not in
the working tree, to that of the last commit with git reset
HEAD &lt;file&gt;, which effectively reverts git add and
prevents the changes to this file from participating in the
next commit. After building the state to be committed
incrementally with these commands, git commit (without any
pathname parameter) is used to record what has been staged
so far. This is the most basic form of the command. An
example:</p>

<p>$ edit hello.c $ git rm goodbye.c $ git add hello.c $
git commit</p>

<p>Instead of staging files after each individual change,
you can tell git commit to notice the changes to the files
whose contents are tracked in your working tree and do
corresponding git add and git rm for you. That is, this
example does the same as the earlier example if there is no
other change in your working tree:</p>

<p>$ edit hello.c $ rm goodbye.c $ git commit -a</p>

<p>The command git commit -a first looks at your working
tree, notices that you have modified hello.c and removed
goodbye.c, and performs necessary git add and git rm for
you.</p>

<p>After staging changes to many files, you can alter the
order the changes are recorded in, by giving pathnames to
git commit. When pathnames are given, the command makes a
commit that only records the changes made to the named
paths:</p>

<p>$ edit hello.c hello.h $ git add hello.c hello.h $ edit
Makefile $ git commit Makefile</p>

<p>This makes a commit that records the modification to
Makefile. The changes staged for hello.c and hello.h are not
included in the resulting commit. However, their changes are
not lost they are still staged and merely held back. After
the above sequence, if you do:</p>

<p>$ git commit</p>

<p>this second commit would record the changes to hello.c
and hello.h as expected.</p>

<p>After a merge (initiated by git merge or git pull) stops
because of conflicts, cleanly merged paths are already
staged to be committed for you, and paths that conflicted
are left in unmerged state. You would have to first check
which paths are conflicting with git status and after fixing
them manually in your working tree, you would stage the
result as usual with git add:</p>

<p>$ git status | grep unmerged unmerged: hello.c $ edit
hello.c $ git add hello.c</p>

<p>After resolving conflicts and staging the result, git
ls-files -u would stop mentioning the conflicted path. When
you are done, run git commit to finally record the
merge:</p>

<p>$ git commit</p>

<p>As with the case to record your own changes, you can use
-a option to save typing. One difference is that during a
merge resolution, you cannot use git commit with pathnames
to alter the order the changes are committed, because the
merge should be recorded as a single commit. In fact, the
command refuses to run when given pathnames (but see -i
option).</p>

<p>DISCUSSION Though not required, its a good idea to begin
the commit message with a single short (less than 50
character) line summarizing the change, followed by a blank
line and then a more thorough description. Tools that turn
commits into email, for example, use the first line on the
Subject: line and the rest of the commit in the body.</p>

<p>At the core level, git is character encoding
agnostic.</p>

<p>&middot; The pathnames recorded in the index and in the
tree objects are treated as uninterpreted sequences of
non-NUL bytes. What readdir(2) returns are what are recorded
and compared with the data git keeps track of, which in turn
are expected to be what lstat(2) and creat(2) accepts. There
is no such thing as pathname encoding translation.</p>

<p>&middot; The contents of the blob objects are
uninterpreted sequences of bytes. There is no encoding
translation at the core level.</p>

<p>&middot; The commit log messages are uninterpreted
sequences of non-NUL bytes.</p>

<p>Although we encourage that the commit log messages are
encoded in UTF-8, both the core and git Porcelain are
designed not to force UTF-8 on projects. If all participants
of a particular project find it more convenient to use
legacy encodings, git does not forbid it. However, there are
a few things to keep in mind.</p>

<p>1. git commit and git commit-tree issues a warning if
the commit log message given to it does not look like a
valid UTF-8 string, unless you explicitly say your project
uses a legacy encoding. The way to say this is to have
i18n.commitencoding in .git/config file, like this:</p>

<p>[i18n] commitencoding = ISO-8859-1</p>

<p>Commit objects created with the above setting record the
value of i18n.commitencoding in its encoding header. This is
to help other people who look at them later. Lack of this
header implies that the commit log message is encoded in
UTF-8.</p>

<p>2. git log, git show, git blame and friends look at the
encoding header of a commit object, and try to re-code the
log message into UTF-8 unless otherwise specified. You can
specify the desired output encoding with
i18n.logoutputencoding in .git/config file, like this:</p>

<p>[i18n] logoutputencoding = ISO-8859-1</p>

<p>If you do not have this configuration variable, the
value of i18n.commitencoding is used instead.</p>

<p>Note that we deliberately chose not to re-code the
commit log message when a commit is made to force UTF-8 at
the commit object level, because re-coding to UTF-8 is not
necessarily a reversible operation.</p>

<p>ENVIRONMENT AND CONFIGURATION VARIABLES The editor used
to edit the commit log message will be chosen from the
GIT_EDITOR environment variable, the core.editor
configuration variable, the VISUAL environment variable, or
the EDITOR environment variable (in that order). See
git-var(1) for details.</p>

<p>HOOKS This command can run commit-msg,
prepare-commit-msg, pre-commit, and post-commit hooks. See
githooks(5) for more information.</p>

<p>SEE ALSO git-add(1), git-rm(1), git-mv(1), git-merge(1),
git-commit-tree(1)</p>

<p>AUTHOR Written by Linus Torvalds
&lt;torvalds@osdl.org[2]&gt; and Junio C Hamano
&lt;gitster@pobox.com[3]&gt;</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. author@example.com
mailto:author@example.com</p>

<p>2. torvalds@osdl.org mailto:torvalds@osdl.org</p>

<p>3. gitster@pobox.com mailto:gitster@pobox.com</p>

<p>Git 1.7.1 03/18/2016 GIT-COMMIT(1)</p>
<hr>
</body>
</html>
