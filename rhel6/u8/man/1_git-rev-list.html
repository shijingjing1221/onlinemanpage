<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:16:11 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GIT-REV-LIST(1) Git Manual GIT-REV-LIST(1)</p>

<p>NAME git-rev-list - Lists commit objects in reverse
chronological order</p>

<p>SYNOPSIS git rev-list [ --max-count=number ] [
--skip=number ] [ --max-age=timestamp ] [
--min-age=timestamp ] [ --sparse ] [ --merges ] [
--no-merges ] [ --first-parent ] [ --remove-empty ] [
--full-history ] [ --not ] [ --all ] [ --branches[=pattern]
] [ --tags[=pattern] ] [ --remotes[=pattern] ] [
--glob=glob-pattern ] [ --stdin ] [ --quiet ] [ --topo-order
] [ --parents ] [ --timestamp ] [ --left-right ] [
--cherry-pick ] [ --encoding[=&lt;encoding&gt;] ] [
--(author|committer|grep)=&lt;pattern&gt; ] [
--regexp-ignore-case | -i ] [ --extended-regexp | -E ] [
--fixed-strings | -F ] [
--date={local|relative|default|iso|rfc|short} ] [ [--objects
| --objects-edge] [ --unpacked ] ] [ --pretty | --header ] [
--bisect ] [ --bisect-vars ] [ --bisect-all ] [ --merge ] [
--reverse ] [ --walk-reflogs ] [ --no-walk ] [ --do-walk ]
&lt;commit&gt;... [ -- &lt;paths&gt;... ]</p>

<p>DESCRIPTION List commits that are reachable by following
the parent links from the given commit(s), but exclude
commits that are reachable from the one(s) given with a ^ in
front of them. The output is given in reverse chronological
order by default.</p>

<p>You can think of this as a set operation. Commits given
on the command line form a set of commits that are reachable
from any of them, and then commits reachable from any of the
ones given with ^ in front are subtracted from that set. The
remaining commits are what comes out in the commands output.
Various other options and paths parameters can be used to
further limit the result.</p>

<p>Thus, the following command:</p>

<p>$ git rev-list foo bar ^baz</p>

<p>means &quot;list all the commits which are reachable
from foo or bar, but not from baz&quot;.</p>

<p>A special notation
&quot;&lt;commit1&gt;..&lt;commit2&gt;&quot; can be used as
a short-hand for &quot;^&lt;commit1&gt;
&lt;commit2&gt;&quot;. For example, either of the following
may be used interchangeably:</p>

<p>$ git rev-list origin..HEAD $ git rev-list HEAD
^origin</p>

<p>Another special notation is
&quot;&lt;commit1&gt;...&lt;commit2&gt;&quot; which is
useful for merges. The resulting set of commits is the
symmetric difference between the two operands. The following
two commands are equivalent:</p>

<p>$ git rev-list A B --not $(git merge-base --all A B) $
git rev-list A...B</p>

<p>rev-list is a very essential git command, since it
provides the ability to build and traverse commit ancestry
graphs. For this reason, it has a lot of different options
that enables it to be used by commands as different as git
bisect and git repack.</p>

<p>OPTIONS Commit Formatting Using these options,
git-rev-list(1) will act similar to the more specialized
family of commit log tools: git-log(1), git-show(1), and
git-whatchanged(1)</p>

<p>--pretty[=&lt;format&gt;], --format[=&lt;format&gt;]
Pretty-print the contents of the commit logs in a given
format, where &lt;format&gt; can be one of oneline, short,
medium, full, fuller, email, raw and format:&lt;string&gt;.
When omitted, the format defaults to medium.</p>

<p>Note: you can specify the default pretty format in the
repository configuration (see git-config(1)).</p>

<p>--abbrev-commit Instead of showing the full 40-byte
hexadecimal commit object name, show only a partial prefix.
Non default number of digits can be specified with
&quot;--abbrev=&lt;n&gt;&quot; (which also modifies diff
output, if it is displayed).</p>

<p>This should make &quot;--pretty=oneline&quot; a whole
lot more readable for people using 80-column terminals.</p>

<p>--oneline This is a shorthand for &quot;--pretty=oneline
--abbrev-commit&quot; used together.</p>

<p>--encoding[=&lt;encoding&gt;] The commit objects record
the encoding used for the log message in their encoding
header; this option can be used to tell the command to
re-code the commit log message in the encoding preferred by
the user. For non plumbing commands this defaults to
UTF-8.</p>

<p>--no-notes, --show-notes[=&lt;ref&gt;] Show the notes
(see git-notes(1)) that annotate the commit, when showing
the commit log message. This is the default for git log, git
show and git whatchanged commands when there is no --pretty,
--format nor --oneline option is given on the command
line.</p>

<p>With an optional argument, add this ref to the list of
notes. The ref is taken to be in refs/notes/ if it is not
qualified.</p>

<p>--[no-]standard-notes Enable or disable populating the
notes ref list from the core.notesRef and notes.displayRef
variables (or corresponding environment overrides). Enabled
by default. See git-config(1).</p>

<p>--relative-date Synonym for --date=relative.</p>

<p>--date={relative,local,default,iso,rfc,short,raw} Only
takes effect for dates shown in human-readable format, such
as when using &quot;--pretty&quot;. log.date config variable
sets a default value for log commands --date option.</p>

<p>--date=relative shows dates relative to the current
time, e.g. &quot;2 hours ago&quot;.</p>

<p>--date=local shows timestamps in users local
timezone.</p>

<p>--date=iso (or --date=iso8601) shows timestamps in ISO
8601 format.</p>

<p>--date=rfc (or --date=rfc2822) shows timestamps in RFC
2822 format, often found in E-mail messages.</p>

<p>--date=short shows only date but not time, in YYYY-MM-DD
format.</p>

<p>--date=raw shows the date in the internal raw git format
%s %z format.</p>

<p>--date=default shows timestamps in the original timezone
(either committers or authors).</p>

<p>--header Print the contents of the commit in raw-format;
each record is separated with a NUL character.</p>

<p>--parents Print the parents of the commit. Also enables
parent rewriting, see History Simplification below.</p>

<p>--children Print the children of the commit. Also
enables parent rewriting, see History Simplification
below.</p>

<p>--timestamp Print the raw commit timestamp.</p>

<p>--left-right Mark which side of a symmetric diff a
commit is reachable from. Commits from the left side are
prefixed with &lt; and those from the right with &gt;. If
combined with --boundary, those commits are prefixed with
-.</p>

<p>For example, if you have this topology:</p>

<p>y---b---b branch B / / / . / / o---x---a---a branch
A</p>

<p>you would get an output like this:</p>

<p>$ git rev-list --left-right --boundary --pretty=oneline
A...B</p>

<p>&gt;bbbbbbb... 3rd on b &gt;bbbbbbb... 2nd on b
&lt;aaaaaaa... 3rd on a &lt;aaaaaaa... 2nd on a -yyyyyyy...
1st on b -xxxxxxx... 1st on a</p>

<p>--graph Draw a text-based graphical representation of
the commit history on the left hand side of the output. This
may cause extra lines to be printed in between commits, in
order for the graph history to be drawn properly.</p>

<p>This implies the --topo-order option by default, but the
--date-order option may also be specified.</p>

<p>Commit Limiting Besides specifying a range of commits
that should be listed using the special notations explained
in the description, additional commit limiting may be
applied.</p>

<p>-n number, --max-count=&lt;number&gt; Limit the number
of commits output.</p>

<p>--skip=&lt;number&gt; Skip number commits before
starting to show the commit output.</p>

<p>--since=&lt;date&gt;, --after=&lt;date&gt; Show commits
more recent than a specific date.</p>

<p>--until=&lt;date&gt;, --before=&lt;date&gt; Show commits
older than a specific date.</p>

<p>--max-age=&lt;timestamp&gt;, --min-age=&lt;timestamp&gt;
Limit the commits output to specified time range.</p>

<p>--author=&lt;pattern&gt;, --committer=&lt;pattern&gt;
Limit the commits output to ones with author/committer
header lines that match the specified pattern (regular
expression).</p>

<p>--grep=&lt;pattern&gt; Limit the commits output to ones
with log message that matches the specified pattern (regular
expression).</p>

<p>--all-match Limit the commits output to ones that match
all given --grep, --author and --committer instead of ones
that match at least one.</p>

<p>-i, --regexp-ignore-case Match the regexp limiting
patterns without regard to letters case.</p>

<p>-E, --extended-regexp Consider the limiting patterns to
be extended regular expressions instead of the default basic
regular expressions.</p>

<p>-F, --fixed-strings Consider the limiting patterns to be
fixed strings (dont interpret pattern as a regular
expression).</p>

<p>--remove-empty Stop when a given path disappears from
the tree.</p>

<p>--merges Print only merge commits.</p>

<p>--no-merges Do not print commits with more than one
parent.</p>

<p>--first-parent Follow only the first parent commit upon
seeing a merge commit. This option can give a better
overview when viewing the evolution of a particular topic
branch, because merges into a topic branch tend to be only
about adjusting to updated upstream from time to time, and
this option allows you to ignore the individual commits
brought in to your history by such a merge.</p>

<p>--not Reverses the meaning of the ^ prefix (or lack
thereof) for all following revision specifiers, up to the
next --not.</p>

<p>--all Pretend as if all the refs in refs/ are listed on
the command line as &lt;commit&gt;.</p>

<p>--branches[=pattern] Pretend as if all the refs in
refs/heads are listed on the command line as &lt;commit&gt;.
If pattern is given, limit branches to ones matching given
shell glob. If pattern lacks ?, , or [, / at the end is
implied.</p>

<p>--tags[=pattern] Pretend as if all the refs in refs/tags
are listed on the command line as &lt;commit&gt;. If pattern
is given, limit tags to ones matching given shell glob. If
pattern lacks ?, , or [, / at the end is implied.</p>

<p>--remotes[=pattern] Pretend as if all the refs in
refs/remotes are listed on the command line as
&lt;commit&gt;. If patternis given, limit remote tracking
branches to ones matching given shell glob. If pattern lacks
?, , or [, / at the end is implied.</p>

<p>--glob=glob-pattern Pretend as if all the refs matching
shell glob glob-pattern are listed on the command line as
&lt;commit&gt;. Leading refs/, is automatically prepended if
missing. If pattern lacks ?, , or [, / at the end is
implied.</p>

<p>--stdin In addition to the &lt;commit&gt; listed on the
command line, read them from the standard input. If a --
separator is seen, stop reading commits and start reading
paths to limit the result.</p>

<p>--quiet Dont print anything to standard output. This
form is primarily meant to allow the caller to test the exit
status to see if a range of objects is fully connected (or
not). It is faster than redirecting stdout to /dev/null as
the output does not have to be formatted.</p>

<p>--cherry-pick Omit any commit that introduces the same
change as another commit on the &quot;other side&quot; when
the set of commits are limited with symmetric
difference.</p>

<p>For example, if you have two branches, A and B, a usual
way to list all commits on only one side of them is with
--left-right, like the example above in the description of
that option. It however shows the commits that were
cherry-picked from the other branch (for example, &quot;3rd
on b&quot; may be cherry-picked from branch A). With this
option, such pairs of commits are excluded from the
output.</p>

<p>-g, --walk-reflogs Instead of walking the commit
ancestry chain, walk reflog entries from the most recent one
to older ones. When this option is used you cannot specify
commits to exclude (that is, ^commit, commit1..commit2, nor
commit1...commit2 notations cannot be used).</p>

<p>With --pretty format other than oneline (for obvious
reasons), this causes the output to have two extra lines of
information taken from the reflog. By default, commit@{Nth}
notation is used in the output. When the starting commit is
specified as commit@{now}, output also uses
commit@{timestamp} notation instead. Under --pretty=oneline,
the commit message is prefixed with this information on the
same line. This option cannot be combined with --reverse.
See also git-reflog(1).</p>

<p>--merge After a failed merge, show refs that touch files
having a conflict and dont exist on all heads to merge.</p>

<p>--boundary Output uninteresting commits at the boundary,
which are usually not shown.</p>

<p>History Simplification Sometimes you are only interested
in parts of the history, for example the commits modifying a
particular &lt;path&gt;. But there are two parts of History
Simplification, one part is selecting the commits and the
other is how to do it, as there are various strategies to
simplify the history.</p>

<p>The following options select the commits to be
shown:</p>

<p>&lt;paths&gt; Commits modifying the given &lt;paths&gt;
are selected.</p>

<p>--simplify-by-decoration Commits that are referred by
some branch or tag are selected.</p>

<p>Note that extra commits can be shown to give a
meaningful history.</p>

<p>The following options affect the way the simplification
is performed:</p>

<p>Default mode Simplifies the history to the simplest
history explaining the final state of the tree. Simplest
because it prunes some side branches if the end result is
the same (i.e. merging branches with the same content)</p>

<p>--full-history As the default mode but does not prune
some history.</p>

<p>--dense Only the selected commits are shown, plus some
to have a meaningful history.</p>

<p>--sparse All commits in the simplified history are
shown.</p>

<p>--simplify-merges Additional option to --full-history to
remove some needless merges from the resulting history, as
there are no selected commits contributing to this
merge.</p>

<p>A more detailed explanation follows.</p>

<p>Suppose you specified foo as the &lt;paths&gt;. We shall
call commits that modify foo !TREESAME, and the rest
TREESAME. (In a diff filtered for foo, they look different
and equal, respectively.)</p>

<p>In the following, we will always refer to the same
example history to illustrate the differences between
simplification settings. We assume that you are filtering
for a file foo in this commit graph:</p>

<p>.-A---M---N---O---P / / / / / I B C D E / / / /
-------------&acute;</p>

<p>The horizontal line of history AP is taken to be the
first parent of each merge. The commits are:</p>

<p>&middot; I is the initial commit, in which foo exists
with contents &quot;asdf&quot;, and a file quux exists with
contents &quot;quux&quot;. Initial commits are compared to
an empty tree, so I is !TREESAME.</p>

<p>&middot; In A, foo contains just &quot;foo&quot;.</p>

<p>&middot; B contains the same change as A. Its merge M is
trivial and hence TREESAME to all parents.</p>

<p>&middot; C does not change foo, but its merge N changes
it to &quot;foobar&quot;, so it is not TREESAME to any
parent.</p>

<p>&middot; D sets foo to &quot;baz&quot;. Its merge O
combines the strings from N and D to &quot;foobarbaz&quot;;
i.e., it is not TREESAME to any parent.</p>

<p>&middot; E changes quux to &quot;xyzzy&quot;, and its
merge P combines the strings to &quot;quux xyzzy&quot;.
Despite appearing interesting, P is TREESAME to all
parents.</p>

<p>rev-list walks backwards through history, including or
excluding commits based on whether --full-history and/or
parent rewriting (via --parents or --children) are used. The
following settings are available.</p>

<p>Default mode Commits are included if they are not
TREESAME to any parent (though this can be changed, see
--sparse below). If the commit was a merge, and it was
TREESAME to one parent, follow only that parent. (Even if
there are several TREESAME parents, follow only one of
them.) Otherwise, follow all parents.</p>

<p>This results in:</p>

<p>.-A---N---O / / I---------D</p>

<p>Note how the rule to only follow the TREESAME parent, if
one is available, removed B from consideration entirely. C
was considered via N, but is TREESAME. Root commits are
compared to an empty tree, so I is !TREESAME.</p>

<p>Parent/child relations are only visible with --parents,
but that does not affect the commits selected in default
mode, so we have shown the parent lines.</p>

<p>--full-history without parent rewriting This mode
differs from the default in one point: always follow all
parents of a merge, even if it is TREESAME to one of them.
Even if more than one side of the merge has commits that are
included, this does not imply that the merge itself is! In
the example, we get</p>

<p>I A B N D O</p>

<p>P and M were excluded because they are TREESAME to a
parent. E, C and B were all walked, but only B was
!TREESAME, so the others do not appear.</p>

<p>Note that without parent rewriting, it is not really
possible to talk about the parent/child relationships
between the commits, so we show them disconnected.</p>

<p>--full-history with parent rewriting Ordinary commits
are only included if they are !TREESAME (though this can be
changed, see --sparse below).</p>

<p>Merges are always included. However, their parent list
is rewritten: Along each parent, prune away commits that are
not included themselves. This results in</p>

<p>.-A---M---N---O---P / / / / / I B / D / / / / /
-------------&acute;</p>

<p>Compare to --full-history without rewriting above. Note
that E was pruned away because it is TREESAME, but the
parent list of P was rewritten to contain E&acute;s parent
I. The same happened for C and N. Note also that P was
included despite being TREESAME.</p>

<p>In addition to the above settings, you can change
whether TREESAME affects inclusion:</p>

<p>--dense Commits that are walked are included if they are
not TREESAME to any parent.</p>

<p>--sparse All commits that are walked are included.</p>

<p>Note that without --full-history, this still simplifies
merges: if one of the parents is TREESAME, we follow only
that one, so the other sides of the merge are never
walked.</p>

<p>Finally, there is a fourth simplification mode
available:</p>

<p>--simplify-merges First, build a history graph in the
same way that --full-history with parent rewriting does (see
above).</p>

<p>Then simplify each commit C to its replacement C in the
final history according to the following rules:</p>

<p>&middot; Set C to C.</p>

<p>&middot; Replace each parent P of C with its
simplification P. In the process, drop parents that are
ancestors of other parents, and remove duplicates.</p>

<p>&middot; If after this parent rewriting, C is a root or
merge commit (has zero or &gt;1 parents), a boundary commit,
or !TREESAME, it remains. Otherwise, it is replaced with its
only parent. The effect of this is best shown by way of
comparing to --full-history with parent rewriting. The
example turns into:</p>

<p>.-A---M---N---O / / / I B D / / ---------&acute;</p>

<p>Note the major differences in N and P over
--full-history:</p>

<p>&middot; N&acute;s parent list had I removed, because it
is an ancestor of the other parent M. Still, N remained
because it is !TREESAME.</p>

<p>&middot; P&acute;s parent list similarly had I removed.
P was then removed completely, because it had one parent and
is TREESAME.</p>

<p>The --simplify-by-decoration option allows you to view
only the big picture of the topology of the history, by
omitting commits that are not referenced by tags. Commits
are marked as !TREESAME (in other words, kept after history
simplification rules described above) if (1) they are
referenced by tags, or (2) they change the contents of the
paths given on the command line. All other commits are
marked as TREESAME (subject to be simplified away).</p>

<p>Bisection Helpers --bisect Limit output to the one
commit object which is roughly halfway between included and
excluded commits. Note that the bad bisection ref
refs/bisect/bad is added to the included commits (if it
exists) and the good bisection refs refs/bisect/good-* are
added to the excluded commits (if they exist). Thus,
supposing there are no refs in refs/bisect/, if</p>

<p>$ git rev-list --bisect foo ^bar ^baz</p>

<p>outputs midpoint, the output of the two commands</p>

<p>$ git rev-list foo ^midpoint $ git rev-list midpoint
^bar ^baz</p>

<p>would be of roughly the same length. Finding the change
which introduces a regression is thus reduced to a binary
search: repeatedly generate and test new &acute;midpoints
until the commit chain is of length one.</p>

<p>--bisect-vars This calculates the same as --bisect,
except that refs in refs/bisect/ are not used, and except
that this outputs text ready to be evaled by the shell.
These lines will assign the name of the midpoint revision to
the variable bisect_rev, and the expected number of commits
to be tested after bisect_rev is tested to bisect_nr, the
expected number of commits to be tested if bisect_rev turns
out to be good to bisect_good, the expected number of
commits to be tested if bisect_rev turns out to be bad to
bisect_bad, and the number of commits we are bisecting right
now to bisect_all.</p>

<p>--bisect-all This outputs all the commit objects between
the included and excluded commits, ordered by their distance
to the included and excluded commits. Refs in refs/bisect/
are not used. The farthest from them is displayed first.
(This is the only one displayed by --bisect.)</p>

<p>This is useful because it makes it easy to choose a good
commit to test when you want to avoid to test some of them
for some reason (they may not compile for example).</p>

<p>This option can be used along with --bisect-vars, in
this case, after all the sorted commit objects, there will
be the same text as if --bisect-vars had been used
alone.</p>

<p>Commit Ordering By default, the commits are shown in
reverse chronological order.</p>

<p>--topo-order This option makes them appear in
topological order (i.e. descendant commits are shown before
their parents).</p>

<p>--date-order This option is similar to --topo-order in
the sense that no parent comes before all of its children,
but otherwise things are still ordered in the commit
timestamp order.</p>

<p>--reverse Output the commits in reverse order. Cannot be
combined with --walk-reflogs.</p>

<p>Object Traversal These options are mostly targeted for
packing of git repositories.</p>

<p>--objects Print the object IDs of any object referenced
by the listed commits. --objects foo ^bar thus means
&quot;send me all object IDs which I need to download if I
have the commit object bar, but not foo&quot;.</p>

<p>--objects-edge Similar to --objects, but also print the
IDs of excluded commits prefixed with a &quot;-&quot;
character. This is used by git-pack-objects(1) to build
&quot;thin&quot; pack, which records objects in deltified
form based on objects contained in these excluded commits to
reduce network traffic.</p>

<p>--unpacked Only useful with --objects; print the object
IDs that are not in packs.</p>

<p>--no-walk Only show the given revs, but do not traverse
their ancestors.</p>

<p>--do-walk Overrides a previous --no-walk.</p>

<p>PRETTY FORMATS If the commit is a merge, and if the
pretty-format is not oneline, email or raw, an additional
line is inserted before the Author: line. This line begins
with &quot;Merge: &quot; and the sha1s of ancestral commits
are printed, separated by spaces. Note that the listed
commits may not necessarily be the list of the direct parent
commits if you have limited your view of history: for
example, if you are only interested in changes related to a
certain directory or file.</p>

<p>Here are some additional details for each format:</p>

<p>&middot; oneline</p>

<p>&lt;sha1&gt; &lt;title line&gt;</p>

<p>This is designed to be as compact as possible.</p>

<p>&middot; short</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt;</p>

<p>&lt;title line&gt;</p>

<p>&middot; medium</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; Date:
&lt;author date&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; full</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; Commit:
&lt;committer&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; fuller</p>

<p>commit &lt;sha1&gt; Author: &lt;author&gt; AuthorDate:
&lt;author date&gt; Commit: &lt;committer&gt; CommitDate:
&lt;committer date&gt;</p>

<p>&lt;title line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; email</p>

<p>From &lt;sha1&gt; &lt;date&gt; From: &lt;author&gt;
Date: &lt;author date&gt; Subject: [PATCH] &lt;title
line&gt;</p>

<p>&lt;full commit message&gt;</p>

<p>&middot; raw</p>

<p>The raw format shows the entire commit exactly as stored
in the commit object. Notably, the SHA1s are displayed in
full, regardless of whether --abbrev or --no-abbrev are
used, and parents information show the true parent commits,
without taking grafts nor history simplification into
account.</p>

<p>&middot; format:</p>

<p>The format: format allows you to specify which
information you want to show. It works a little bit like
printf format, with the notable exception that you get a
newline with %n instead of n.</p>

<p>E.g, format:&quot;The author of %h was %an, %ar%nThe
title was &gt;&gt;%s&lt;&lt;%n&quot; would show something
like this:</p>

<p>The author of fe6e0ee was Junio C Hamano, 23 hours ago
The title was &gt;&gt;t4119: test autocomputing -p&lt;n&gt;
for traditional diff input.&lt;&lt;</p>

<p>The placeholders are:</p>

<p>&middot; %H: commit hash</p>

<p>&middot; %h: abbreviated commit hash</p>

<p>&middot; %T: tree hash</p>

<p>&middot; %t: abbreviated tree hash</p>

<p>&middot; %P: parent hashes</p>

<p>&middot; %p: abbreviated parent hashes</p>

<p>&middot; %an: author name</p>

<p>&middot; %aN: author name (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ae: author email</p>

<p>&middot; %aE: author email (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ad: author date (format respects --date=
option)</p>

<p>&middot; %aD: author date, RFC2822 style</p>

<p>&middot; %ar: author date, relative</p>

<p>&middot; %at: author date, UNIX timestamp</p>

<p>&middot; %ai: author date, ISO 8601 format</p>

<p>&middot; %cn: committer name</p>

<p>&middot; %cN: committer name (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %ce: committer email</p>

<p>&middot; %cE: committer email (respecting .mailmap, see
git-shortlog(1) or git-blame(1))</p>

<p>&middot; %cd: committer date</p>

<p>&middot; %cD: committer date, RFC2822 style</p>

<p>&middot; %cr: committer date, relative</p>

<p>&middot; %ct: committer date, UNIX timestamp</p>

<p>&middot; %ci: committer date, ISO 8601 format</p>

<p>&middot; %d: ref names, like the --decorate option of
git-log(1)</p>

<p>&middot; %e: encoding</p>

<p>&middot; %s: subject</p>

<p>&middot; %f: sanitized subject line, suitable for a
filename</p>

<p>&middot; %b: body</p>

<p>&middot; %N: commit notes</p>

<p>&middot; %gD: reflog selector, e.g., refs/stash@{1}</p>

<p>&middot; %gd: shortened reflog selector, e.g.,
stash@{1}</p>

<p>&middot; %gs: reflog subject</p>

<p>&middot; %Cred: switch color to red</p>

<p>&middot; %Cgreen: switch color to green</p>

<p>&middot; %Cblue: switch color to blue</p>

<p>&middot; %Creset: reset color</p>

<p>&middot; %C(...): color specification, as described in
color.branch.* config option</p>

<p>&middot; %m: left, right or boundary mark</p>

<p>&middot; %n: newline</p>

<p>&middot; %%: a raw %</p>

<p>&middot; %x00: print a byte from a hex code</p>

<p>&middot; %w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]]):
switch line wrapping, like the -w option of
git-shortlog(1).</p>

<p>Note Some placeholders may depend on other options given
to the revision traversal engine. For example, the %g*
reflog options will insert an empty string unless we are
traversing reflog entries (e.g., by git log -g). The %d
placeholder will use the &quot;short&quot; decoration format
if --decorate was not already provided on the command
line.</p>

<p>If you add a + (plus sign) after % of a placeholder, a
line-feed is inserted immediately before the expansion if
and only if the placeholder expands to a non-empty
string.</p>

<p>If you add a - (minus sign) after % of a placeholder,
line-feeds that immediately precede the expansion are
deleted if and only if the placeholder expands to an empty
string.</p>

<p>&middot; tformat:</p>

<p>The tformat: format works exactly like format:, except
that it provides &quot;terminator&quot; semantics instead of
&quot;separator&quot; semantics. In other words, each commit
has the message terminator character (usually a newline)
appended, rather than a separator placed between entries.
This means that the final entry of a single-line format will
be properly terminated with a new line, just as the
&quot;oneline&quot; format does. For example:</p>

<p>$ git log -2 --pretty=format:%h 4da45bef | perl -pe
&acute;$_ .= &quot; -- NO NEWLINE0 unless /0&acute; 4da45be
7134973 -- NO NEWLINE</p>

<p>$ git log -2 --pretty=tformat:%h 4da45bef | perl -pe
&acute;$_ .= &quot; -- NO NEWLINE0 unless /0&acute; 4da45be
7134973</p>

<p>In addition, any unrecognized string that has a % in it
is interpreted as if it has tformat: in front of it. For
example, these two are equivalent:</p>

<p>$ git log -2 --pretty=tformat:%h 4da45bef $ git log -2
--pretty=%h 4da45bef</p>

<p>AUTHOR Written by Linus Torvalds
&lt;torvalds@osdl.org[1]&gt;</p>

<p>DOCUMENTATION Documentation by David Greaves, Junio C
Hamano, Jonas Fonseca and the git-list
&lt;git@vger.kernel.org[2]&gt;.</p>

<p>GIT Part of the git(1) suite</p>

<p>NOTES 1. torvalds@osdl.org mailto:torvalds@osdl.org</p>

<p>2. git@vger.kernel.org mailto:git@vger.kernel.org</p>

<p>Git 1.7.1 03/18/2016 GIT-REV-LIST(1)</p>
<hr>
</body>
</html>
