<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:42 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLOP(1) Perl Programmers Reference Guide PERLOP(1)</p>

<p>NAME perlop - Perl operators and precedence</p>

<p>DESCRIPTION Operator Precedence and Associativity
Operator precedence and associativity work in Perl more or
less like they do in mathematics.</p>

<p>Operator precedence means some operators are evaluated
before others. For example, in &quot;2 + 4 * 5&quot;, the
multiplication has higher precedence so &quot;4 * 5&quot; is
evaluated first yielding &quot;2 + 20 == 22&quot; and not
&quot;6 * 5 == 30&quot;.</p>

<p>Operator associativity defines what happens if a
sequence of the same operators is used one after another:
whether the evaluator will evaluate the left operations
first or the right. For example, in &quot;8 - 4 - 2&quot;,
subtraction is left associative so Perl evaluates the
expression left to right. &quot;8 - 4&quot; is evaluated
first making the expression &quot;4 - 2 == 2&quot; and not
&quot;8 - 2 == 6&quot;.</p>

<p>Perl operators have the following associativity and
precedence, listed from highest precedence to lowest.
Operators borrowed from C keep the same precedence
relationship with each other, even where C s precedence is
slightly screwy. (This makes learning Perl easier for C
folks.) With very few exceptions, these all operate on
scalar values only, not array values.</p>

<p>left terms and list operators (leftward) left -&gt;
nonassoc ++ -- right ** right ! ~ and unary + and - left =~
!~ left * / % x left + - . left &lt;&lt; &gt;&gt; nonassoc
named unary operators nonassoc &lt; &gt; &lt;= &gt;= lt gt
le ge nonassoc == != &lt;=&gt; eq ne cmp ~~ left &amp; left
| ^ left &amp;&amp; left || // nonassoc .. ... right ?:
right = += -= *= etc. left , =&gt; nonassoc list operators
(rightward) right not left and left or xor</p>

<p>In the following sections, these operators are covered
in precedence order.</p>

<p>Many operators can be overloaded for objects. See
overload.</p>

<p>Terms and List Operators (Leftward) A TERM has the
highest precedence in Perl. They include variables, quote
and quote-like operators, any expression in parentheses, and
any function whose arguments are parenthesized. Actually,
there arent really functions in this sense, just list
operators and unary operators behaving as functions because
you put parentheses around the arguments. These are all
documented in perlfunc.</p>

<p>If any list operator (print(), etc.) or any unary
operator (chdir(), etc.) is followed by a left parenthesis
as the next token, the operator and arguments within
parentheses are taken to be of highest precedence, just like
a normal function call.</p>

<p>In the absence of parentheses, the precedence of list
operators such as &quot;print&quot;, &quot;sort&quot;, or
&quot;chmod&quot; is either very high or very low depending
on whether you are looking at the left side or the right
side of the operator. For example, in</p>

<p>@ary = (1, 3, sort 4, 2); print @ary; # prints 1324</p>

<p>the commas on the right of the sort are evaluated before
the sort, but the commas on the left are evaluated after. In
other words, list operators tend to gobble up all arguments
that follow, and then act like a simple TERM with regard to
the preceding expression. Be careful with parentheses:</p>

<p># These evaluate exit before doing the print:
print($foo, exit); # Obviously not what you want. print
$foo, exit; # Nor is this.</p>

<p># These do the print before evaluating exit: (print
$foo), exit; # This is what you want. print($foo), exit; #
Or this. print ($foo), exit; # Or even this.</p>

<p>Also note that</p>

<p>print ($foo &amp; 255) + 1, &quot;0;</p>

<p>probably doesn t do what you expect at first glance. The
parentheses enclose the argument list for &quot;print&quot;
which is evaluated (printing the result of &quot;$foo &amp;
255&quot;). Then one is added to the return value of
&quot;print&quot; (usually 1). The result is something like
this:</p>

<p>1 + 1, &quot;0; # Obviously not what you meant.</p>

<p>To do what you meant properly, you must write:</p>

<p>print(($foo &amp; 255) + 1, &quot;0);</p>

<p>See &quot;Named Unary Operators&quot; for more
discussion of this.</p>

<p>Also parsed as terms are the &quot;do {}&quot; and
&quot;eval {}&quot; constructs, as well as subroutine and
method calls, and the anonymous constructors &quot;[]&quot;
and &quot;{}&quot;.</p>

<p>See also &quot;Quote and Quote-like Operators&quot;
toward the end of this section, as well as &quot;I/O
Operators&quot;.</p>

<p>The Arrow Operator &quot;&quot;-&gt;&quot;&quot; is an
infix dereference operator, just as it is in C and C++. If
the right side is either a &quot;[...]&quot;,
&quot;{...}&quot;, or a &quot;(...)&quot; subscript, then
the left side must be either a hard or symbolic reference to
an array, a hash, or a subroutine respectively. (Or
technically speaking, a location capable of holding a hard
reference, if its an array or hash reference being used for
assignment.) See perlreftut and perlref.</p>

<p>Otherwise, the right side is a method name or a simple
scalar variable containing either the method name or a
subroutine reference, and the left side must be either an
object (a blessed reference) or a class name (that is, a
package name). See perlobj.</p>

<p>Auto-increment and Auto-decrement &quot;++&quot; and
&quot;--&quot; work as in C. That is, if placed before a
variable, they increment or decrement the variable by one
before returning the value, and if placed after, increment
or decrement after returning the value.</p>

<p>$i = 0; $j = 0; print $i++; # prints 0 print ++$j; #
prints 1</p>

<p>Note that just as in C, Perl doesnt define when the
variable is incremented or decremented. You just know it
will be done sometime before or after the value is returned.
This also means that modifying a variable twice in the same
statement will lead to undefined behaviour. Avoid statements
like:</p>

<p>$i = $i ++; print ++ $i + $i ++;</p>

<p>Perl will not guarantee what the result of the above
statements is.</p>

<p>The auto-increment operator has a little extra builtin
magic to it. If you increment a variable that is numeric, or
that has ever been used in a numeric context, you get a
normal increment. If, however, the variable has been used in
only string contexts since it was set, and has a value that
is not the empty string and matches the pattern
&quot;/^[a-zA-Z]*[0-9]*&quot;, the increment is done as a
string, preserving each character within its range, with
carry:</p>

<p>print ++($foo = &rsquo;99&rsquo;); # prints
&rsquo;100&rsquo; print ++($foo = &rsquo;a0&rsquo;); #
prints &rsquo;a1&rsquo; print ++($foo = &rsquo;Az&rsquo;); #
prints &rsquo;Ba&rsquo; print ++($foo = &rsquo;zz&rsquo;); #
prints &rsquo;aaa&rsquo;</p>

<p>&quot;undef&quot; is always treated as numeric, and in
particular is changed to 0 before incrementing (so that a
post-increment of an undef value will return 0 rather than
&quot;undef&quot;).</p>

<p>The auto-decrement operator is not magical.</p>

<p>Exponentiation Binary &quot;**&quot; is the
exponentiation operator. It binds even more tightly than
unary minus, so -2**4 is -(2**4), not (-2)**4. (This is
implemented using Cs pow(3) function, which actually works
on doubles internally.)</p>

<p>Symbolic Unary Operators Unary &quot;!&quot; performs
logical negation, i.e., &quot;not&quot;. See also
&quot;not&quot; for a lower precedence version of this.</p>

<p>Unary &quot;-&quot; performs arithmetic negation if the
operand is numeric. If the operand is an identifier, a
string consisting of a minus sign concatenated with the
identifier is returned. Otherwise, if the string starts with
a plus or minus, a string starting with the opposite sign is
returned. One effect of these rules is that -bareword is
equivalent to the string &quot;-bareword&quot;. If, however,
the string begins with a non- alphabetic character
(excluding &quot;+&quot; or &quot;-&quot;), Perl will
attempt to convert the string to a numeric and the
arithmetic negation is performed. If the string cannot be
cleanly converted to a numeric, Perl will give the warning
Argument &quot;the string&quot; ist numeric in negation (-)
at ....</p>

<p>Unary &quot;~&quot; performs bitwise negation, i.e., 1s
complement. For example, &quot;0666 &amp; ~027&quot; is
0640. (See also &quot;Integer Arithmetic&quot; and
&quot;Bitwise String Operators&quot;.) Note that the width
of the result is platform-dependent: ~0 is 32 bits wide on a
32-bit platform, but 64 bits wide on a 64-bit platform, so
if you are expecting a certain bit width, remember to use
the &amp; operator to mask off the excess bits.</p>

<p>Unary &quot;+&quot; has no effect whatsoever, even on
strings. It is useful syntactically for separating a
function name from a parenthesized expression that would
otherwise be interpreted as the complete list of function
arguments. (See examples above under &quot;Terms and List
Operators (Leftward)&quot;.)</p>

<p>Unary &quot; and perlref. Do not confuse this behavior
with the behavior of backslash within a string, although
both forms do convey the notion of protecting the next thing
from interpolation.</p>

<p>Binding Operators Binary &quot;=~&quot; binds a scalar
expression to a pattern match. Certain operations search or
modify the string $_ by default. This operator makes that
kind of operation work on some other string. The right
argument is a search pattern, substitution, or
transliteration. The left argument is what is supposed to be
searched, substituted, or transliterated instead of the
default $_. When used in scalar context, the return value
generally indicates the success of the operation. Behavior
in list context depends on the particular operator. See
&quot;Regexp Quote-Like Operators&quot; for details and
perlretut for examples using these operators.</p>

<p>If the right argument is an expression rather than a
search pattern, substitution, or transliteration, it is
interpreted as a search pattern at run time. Note that this
means that its contents will be interpolated twice, so</p>

<p>&rsquo;\&rsquo; =~ q&rsquo;\&rsquo;;</p>

<p>is not ok, as the regex engine will end up trying to
compile the pattern &quot;</p>

<p>Binary &quot;!~&quot; is just like &quot;=~&quot; except
the return value is negated in the logical sense.</p>

<p>Multiplicative Operators Binary &quot;*&quot; multiplies
two numbers.</p>

<p>Binary &quot;/&quot; divides two numbers.</p>

<p>Binary &quot;%&quot; is the modulo operator, which
computes the division remainder of its first argument with
respect to its second argument. Given integer operands $a
and $b: If $b is positive, then &quot;$a % $b&quot; is $a
minus the largest multiple of $b less than or equal to $a.
If $b is negative, then &quot;$a % $b&quot; is $a minus the
smallest multiple of $b that is not less than $a (i.e. the
result will be less than or equal to zero). If the operands
$a and $b are floating point values and the absolute value
of $b (that is &quot;abs($b)&quot;) is less than
&quot;(UV_MAX + 1)&quot;, only the integer portion of $a and
$b will be used in the operation (Note: here
&quot;UV_MAX&quot; means the maximum of the unsigned integer
type). If the absolute value of the right operand
(&quot;abs($b)&quot;) is greater than or equal to
&quot;(UV_MAX + 1)&quot;, &quot;%&quot; computes the
floating-point remainder $r in the equation &quot;($r = $a -
$i*$b)&quot; where $i is a certain integer that makes $r
have the same sign as the right operand $b (not as the left
operand $a like C function &quot;fmod()&quot;) and the
absolute value less than that of $b. Note that when
&quot;use integer&quot; is in scope, &quot;%&quot; gives you
direct access to the modulo operator as implemented by your
C compiler. This operator is not as well defined for
negative operands, but it will execute faster.</p>

<p>Binary &quot;x&quot; is the repetition operator. In
scalar context or if the left operand is not enclosed in
parentheses, it returns a string consisting of the left
operand repeated the number of times specified by the right
operand. In list context, if the left operand is enclosed in
parentheses or is a list formed by &quot;qw/STRING/&quot;,
it repeats the list. If the right operand is zero or
negative, it returns an empty string or an empty list,
depending on the context.</p>

<p>print &rsquo;-&rsquo; x 80; # print row of dashes</p>

<p>print &quot;&quot; x ($tab/8), &rsquo; &rsquo; x
($tab%8); # tab over</p>

<p>@ones = (1) x 80; # a list of 80 1&rsquo;s @ones = (5) x
@ones; # set all elements to 5</p>

<p>Additive Operators Binary &quot;+&quot; returns the sum
of two numbers.</p>

<p>Binary &quot;-&quot; returns the difference of two
numbers.</p>

<p>Binary &quot;.&quot; concatenates two strings.</p>

<p>Shift Operators Binary &quot;&lt;&lt;&quot; returns the
value of its left argument shifted left by the number of
bits specified by the right argument. Arguments should be
integers. (See also &quot;Integer Arithmetic&quot;.)</p>

<p>Binary &quot;&gt;&gt;&quot; returns the value of its
left argument shifted right by the number of bits specified
by the right argument. Arguments should be integers. (See
also &quot;Integer Arithmetic&quot;.)</p>

<p>Note that both &quot;&lt;&lt;&quot; and
&quot;&gt;&gt;&quot; in Perl are implemented directly using
&quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in C. If
&quot;use integer&quot; (see &quot;Integer Arithmetic&quot;)
is in force then signed C integers are used, else unsigned C
integers are used. Either way, the implementation isn t
going to generate results larger than the size of the
integer type Perl was built with (32 bits or 64 bits).</p>

<p>The result of overflowing the range of the integers is
undefined because it is undefined also in C. In other words,
using 32-bit integers, &quot;1 &lt;&lt; 32&quot; is
undefined. Shifting by a negative number of bits is also
undefined.</p>

<p>Named Unary Operators The various named unary operators
are treated as functions with one argument, with optional
parentheses.</p>

<p>If any list operator (print(), etc.) or any unary
operator (chdir(), etc.) is followed by a left parenthesis
as the next token, the operator and arguments within
parentheses are taken to be of highest precedence, just like
a normal function call. For example, because named unary
operators are higher precedence than ||:</p>

<p>chdir $foo || die; # (chdir $foo) || die chdir($foo) ||
die; # (chdir $foo) || die chdir ($foo) || die; # (chdir
$foo) || die chdir +($foo) || die; # (chdir $foo) || die</p>

<p>but, because * is higher precedence than named
operators:</p>

<p>chdir $foo * 20; # chdir ($foo * 20) chdir($foo) * 20; #
(chdir $foo) * 20 chdir ($foo) * 20; # (chdir $foo) * 20
chdir +($foo) * 20; # chdir ($foo * 20)</p>

<p>rand 10 * 20; # rand (10 * 20) rand(10) * 20; # (rand
10) * 20 rand (10) * 20; # (rand 10) * 20 rand +(10) * 20; #
rand (10 * 20)</p>

<p>Regarding precedence, the filetest operators, like
&quot;-f&quot;, &quot;-M&quot;, etc. are treated like named
unary operators, but they don t follow this functional
parenthesis rule. That means, for example, that
&quot;-f($file).&quot;.bak&quot;&quot; is equivalent to
&quot;-f &quot;$file.bak&quot;&quot;.</p>

<p>See also &quot;Terms and List Operators
(Leftward)&quot;.</p>

<p>Relational Operators Binary &quot;&lt;&quot; returns
true if the left argument is numerically less than the right
argument.</p>

<p>Binary &quot;&gt;&quot; returns true if the left
argument is numerically greater than the right argument.</p>

<p>Binary &quot;&lt;=&quot; returns true if the left
argument is numerically less than or equal to the right
argument.</p>

<p>Binary &quot;&gt;=&quot; returns true if the left
argument is numerically greater than or equal to the right
argument.</p>

<p>Binary &quot;lt&quot; returns true if the left argument
is stringwise less than the right argument.</p>

<p>Binary &quot;gt&quot; returns true if the left argument
is stringwise greater than the right argument.</p>

<p>Binary &quot;le&quot; returns true if the left argument
is stringwise less than or equal to the right argument.</p>

<p>Binary &quot;ge&quot; returns true if the left argument
is stringwise greater than or equal to the right
argument.</p>

<p>Equality Operators Binary &quot;==&quot; returns true if
the left argument is numerically equal to the right
argument.</p>

<p>Binary &quot;!=&quot; returns true if the left argument
is numerically not equal to the right argument.</p>

<p>Binary &quot;&lt;=&gt;&quot; returns -1, 0, or 1
depending on whether the left argument is numerically less
than, equal to, or greater than the right argument. If your
platform supports NaNs (not-a-numbers) as numeric values,
using them with &quot;&lt;=&gt;&quot; returns undef. NaN is
not &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;,
&quot;&lt;=&quot; or &quot;&gt;=&quot; anything (even NaN),
so those 5 return false. NaN != NaN returns true, as does
NaN != anything else. If your platform doesnt support NaNs
then NaN is just a string with numeric value 0.</p>

<p>perl -le &rsquo;$a = &quot;NaN&quot;; print &quot;No NaN
support here&quot; if $a == $a&rsquo; perl -le &rsquo;$a =
&quot;NaN&quot;; print &quot;NaN support here&quot; if $a !=
$a&rsquo;</p>

<p>Binary &quot;eq&quot; returns true if the left argument
is stringwise equal to the right argument.</p>

<p>Binary &quot;ne&quot; returns true if the left argument
is stringwise not equal to the right argument.</p>

<p>Binary &quot;cmp&quot; returns -1, 0, or 1 depending on
whether the left argument is stringwise less than, equal to,
or greater than the right argument.</p>

<p>Binary &quot;~~&quot; does a smart match between its
arguments. Smart matching is described in &quot;Smart
matching in detail&quot; in perlsyn.</p>

<p>&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;,
&quot;gt&quot; and &quot;cmp&quot; use the collation (sort)
order specified by the current locale if &quot;use
locale&quot; is in effect. See perllocale.</p>

<p>Bitwise And Binary &quot;&amp;&quot; returns its
operands ANDed together bit by bit. (See also &quot;Integer
Arithmetic&quot; and &quot;Bitwise String
Operators&quot;.)</p>

<p>Note that &quot;&amp;&quot; has lower priority than
relational operators, so for example the brackets are
essential in a test like</p>

<p>print &quot;Even0 if ($x &amp; 1) == 0;</p>

<p>Bitwise Or and Exclusive Or Binary &quot;|&quot; returns
its operands ORed together bit by bit. (See also
&quot;Integer Arithmetic&quot; and &quot;Bitwise String
Operators&quot;.)</p>

<p>Binary &quot;^&quot; returns its operands XORed together
bit by bit. (See also &quot;Integer Arithmetic&quot; and
&quot;Bitwise String Operators&quot;.)</p>

<p>Note that &quot;|&quot; and &quot;^&quot; have lower
priority than relational operators, so for example the
brackets are essential in a test like</p>

<p>print &quot;false0 if (8 | 2) != 10;</p>

<p>C-style Logical And Binary &quot;&amp;&amp;&quot;
performs a short-circuit logical AND operation. That is, if
the left operand is false, the right operand is not even
evaluated. Scalar or list context propagates down to the
right operand if it is evaluated.</p>

<p>C-style Logical Or Binary &quot;||&quot; performs a
short-circuit logical OR operation. That is, if the left
operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand
if it is evaluated.</p>

<p>C-style Logical Defined-Or Although it has no direct
equivalent in C, Perl s &quot;//&quot; operator is related
to its C-style or. In fact, its exactly the same as
&quot;||&quot;, except that it tests the left hand side s
definedness instead of its truth. Thus, &quot;$a // $b&quot;
is similar to &quot;defined($a) || $b&quot; (except that it
returns the value of $a rather than the value of
&quot;defined($a)&quot;) and is exactly equivalent to
&quot;defined($a) ? $a : $b&quot;. This is very useful for
providing default values for variables. If you actually want
to test if at least one of $a and $b is defined, use
&quot;defined($a // $b)&quot;.</p>

<p>The &quot;||&quot;, &quot;//&quot; and
&quot;&amp;&amp;&quot; operators return the last value
evaluated (unlike C s &quot;||&quot; and
&quot;&amp;&amp;&quot;, which return 0 or 1). Thus, a
reasonably portable way to find out the home directory might
be:</p>

<p>$home = $ENV{&rsquo;HOME&rsquo;} //
$ENV{&rsquo;LOGDIR&rsquo;} // (getpwuid($&lt;))[7] // die
&quot;You&rsquo;re homeless!0;</p>

<p>In particular, this means that you shouldnt use this for
selecting between two aggregates for assignment:</p>

<p>@a = @b || @c; # this is wrong @a = scalar(@b) || @c; #
really meant this @a = @b ? @b : @c; # this works fine,
though</p>

<p>As more readable alternatives to &quot;&amp;&amp;&quot;
and &quot;||&quot; when used for control flow, Perl provides
the &quot;and&quot; and &quot;or&quot; operators (see
below). The short-circuit behavior is identical. The
precedence of &quot;and&quot; and &quot;or&quot; is much
lower, however, so that you can safely use them after a list
operator without the need for parentheses:</p>

<p>unlink &quot;alpha&quot;, &quot;beta&quot;,
&quot;gamma&quot; or gripe(), next LINE;</p>

<p>With the C-style operators that would have been written
like this:</p>

<p>unlink(&quot;alpha&quot;, &quot;beta&quot;,
&quot;gamma&quot;) || (gripe(), next LINE);</p>

<p>Using &quot;or&quot; for assignment is unlikely to do
what you want; see below.</p>

<p>Range Operators Binary &quot;..&quot; is the range
operator, which is really two different operators depending
on the context. In list context, it returns a list of values
counting (up by ones) from the left value to the right
value. If the left value is greater than the right value
then it returns the empty list. The range operator is useful
for writing &quot;foreach (1..10)&quot; loops and for doing
slice operations on arrays. In the current implementation,
no temporary array is created when the range operator is
used as the expression in &quot;foreach&quot; loops, but
older versions of Perl might burn a lot of memory when you
write something like this:</p>

<p>for (1 .. 1_000_000) { # code }</p>

<p>The range operator also works on strings, using the
magical auto- increment, see below.</p>

<p>In scalar context, &quot;..&quot; returns a boolean
value. The operator is bistable, like a flip-flop, and
emulates the line-range (comma) operator of sed, awk, and
various editors. Each &quot;..&quot; operator maintains its
own boolean state. It is false as long as its left operand
is false. Once the left operand is true, the range operator
stays true until the right operand is true, AFTER which the
range operator becomes false again. It doesnt become false
till the next time the range operator is evaluated. It can
test the right operand and become false on the same
evaluation it became true (as in awk), but it still returns
true once. If you dont want it to test the right operand
till the next evaluation, as in sed, just use three dots
(&quot;...&quot;) instead of two. In all other regards,
&quot;...&quot; behaves just like &quot;..&quot; does.</p>

<p>The right operand is not evaluated while the operator is
in the &quot;false&quot; state, and the left operand is not
evaluated while the operator is in the &quot;true&quot;
state. The precedence is a little lower than || and
&amp;&amp;. The value returned is either the empty string
for false, or a sequence number (beginning with 1) for true.
The sequence number is reset for each range encountered. The
final sequence number in a range has the string
&quot;E0&quot; appended to it, which doesn t affect its
numeric value, but gives you something to search for if you
want to exclude the endpoint. You can exclude the beginning
point by waiting for the sequence number to be greater than
1.</p>

<p>If either operand of scalar &quot;..&quot; is a constant
expression, that operand is considered true if it is equal
(&quot;==&quot;) to the current input line number (the $.
variable).</p>

<p>To be pedantic, the comparison is actually
&quot;int(EXPR) == int(EXPR)&quot;, but that is only an
issue if you use a floating point expression; when
implicitly using $. as described in the previous paragraph,
the comparison is &quot;int(EXPR) == int($.)&quot; which is
only an issue when $. is set to a floating point value and
you are not reading from a file. Furthermore,
&quot;span&quot; .. &quot;spat&quot; or &quot;2.18 ..
3.14&quot; will not do what you want in scalar context
because each of the operands are evaluated using their
integer representation.</p>

<p>Examples:</p>

<p>As a scalar operator:</p>

<p>if (101 .. 200) { print; } # print 2nd hundred lines,
short for # if ($. == 101 .. $. == 200) { print; }</p>

<p>next LINE if (1 .. /^$/); # skip header lines, short for
# next LINE if ($. == 1 .. /^$/); # (typically in a loop
labeled LINE)</p>

<p>s/^/&gt; / if (/^$/ .. eof()); # quote body</p>

<p># parse mail messages while (&lt;&gt;) { $in_header = 1
.. /^$/; $in_body = /^$/ .. eof; if ($in_header) { # do
something } else { # in body # do something else } }
continue { close ARGV if eof; # reset $. each file }</p>

<p>Here s a simple example to illustrate the difference
between the two range operators:</p>

<p>@lines = (&quot; - Foo&quot;, &quot;01 - Bar&quot;,
&quot;1 - Baz&quot;, &quot; - Quux&quot;);</p>

<p>foreach (@lines) { if (/0/ .. /1/) { print &quot;$_0; }
}</p>

<p>This program will print only the line containing
&quot;Bar&quot;. If the range operator is changed to
&quot;...&quot;, it will also print the &quot;Baz&quot;
line.</p>

<p>And now some examples as a list operator:</p>

<p>for (101 .. 200) { print; } # print $_ 100 times @foo =
@foo[0 .. $#foo]; # an expensive no-op @foo = @foo[$#foo-4
.. $#foo]; # slice last 5 items</p>

<p>The range operator (in list context) makes use of the
magical auto- increment algorithm if the operands are
strings. You can say</p>

<p>@alphabet = (&rsquo;A&rsquo; .. &rsquo;Z&rsquo;);</p>

<p>to get all normal letters of the English alphabet,
or</p>

<p>$hexdigit = (0 .. 9, &rsquo;a&rsquo; ..
&rsquo;f&rsquo;)[$num &amp; 15];</p>

<p>to get a hexadecimal digit, or</p>

<p>@z2 = (&rsquo;01&rsquo; .. &rsquo;31&rsquo;); print
$z2[$mday];</p>

<p>to get dates with leading zeros.</p>

<p>If the final value specified is not in the sequence that
the magical increment would produce, the sequence goes until
the next value would be longer than the final value
specified.</p>

<p>If the initial value specified isnt part of a magical
increment sequence (that is, a non-empty string matching
&quot;/^[a-zA-Z]*[0-9]*&quot;), only the initial value will
be returned. So the following will only return an alpha:</p>

<p>use charnames &rsquo;greek&rsquo;; my @greek_small =
(&quot;lpha}&quot; .. &quot;mega}&quot;);</p>

<p>To get lower-case greek letters, use this instead:</p>

<p>my @greek_small = map { chr } ( ord(&quot;lpha}&quot;)
.. ord(&quot;mega}&quot;) );</p>

<p>Because each operand is evaluated in integer form,
&quot;2.18 .. 3.14&quot; will return two elements in list
context.</p>

<p>@list = (2.18 .. 3.14); # same as @list = (2 .. 3);</p>

<p>Conditional Operator Ternary &quot;?:&quot; is the
conditional operator, just as in C. It works much like an
if-then-else. If the argument before the ? is true, the
argument before the : is returned, otherwise the argument
after the : is returned. For example:</p>

<p>printf &quot;I have %d dog%s.0, $n, ($n == 1) ?
&rsquo;&rsquo; : &quot;s&quot;;</p>

<p>Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.</p>

<p>$a = $ok ? $b : $c; # get a scalar @a = $ok ? @b : @c; #
get an array $a = $ok ? @b : @c; # oops, that&rsquo;s just a
count!</p>

<p>The operator may be assigned to if both the 2nd and 3rd
arguments are legal lvalues (meaning that you can assign to
them):</p>

<p>($a_or_b ? $a : $b) = $c;</p>

<p>Because this operator produces an assignable result,
using assignments without parentheses will get you in
trouble. For example, this:</p>

<p>$a % 2 ? $a += 10 : $a += 2</p>

<p>Really means this:</p>

<p>(($a % 2) ? ($a += 10) : $a) += 2</p>

<p>Rather than this:</p>

<p>($a % 2) ? ($a += 10) : ($a += 2)</p>

<p>That should probably be written more simply as:</p>

<p>$a += ($a % 2) ? 10 : 2;</p>

<p>Assignment Operators &quot;=&quot; is the ordinary
assignment operator.</p>

<p>Assignment operators work as in C. That is,</p>

<p>$a += 2;</p>

<p>is equivalent to</p>

<p>$a = $a + 2;</p>

<p>although without duplicating any side effects that
dereferencing the lvalue might trigger, such as from tie().
Other assignment operators work similarly. The following are
recognized:</p>

<p>**= += *= &amp;= &lt;&lt;= &amp;&amp;= -= /= |=
&gt;&gt;= ||= .= %= ^= //= x=</p>

<p>Although these are grouped by family, they all have the
precedence of assignment.</p>

<p>Unlike in C, the scalar assignment operator produces a
valid lvalue. Modifying an assignment is equivalent to doing
the assignment and then modifying the variable that was
assigned to. This is useful for modifying a copy of
something, like this:</p>

<p>($tmp = $global) =~ tr [A-Z] [a-z];</p>

<p>Likewise,</p>

<p>($a += 2) *= 3;</p>

<p>is equivalent to</p>

<p>$a += 2; $a *= 3;</p>

<p>Similarly, a list assignment in list context produces
the list of lvalues assigned to, and a list assignment in
scalar context returns the number of elements produced by
the expression on the right hand side of the assignment.</p>

<p>Comma Operator Binary &quot;,&quot; is the comma
operator. In scalar context it evaluates its left argument,
throws that value away, then evaluates its right argument
and returns that value. This is just like C s comma
operator.</p>

<p>In list context, its just the list argument separator,
and inserts both its arguments into the list. These
arguments are also evaluated from left to right.</p>

<p>The &quot;=&gt;&quot; operator is a synonym for the
comma except that it causes its left operand to be
interpreted as a string if it begins with a letter or
underscore and is composed only of letters, digits and
underscores. This includes operands that might otherwise be
interpreted as operators, constants, single number v-strings
or function calls. If in doubt about this behaviour, the
left operand can be quoted explicitly.</p>

<p>Otherwise, the &quot;=&gt;&quot; operator behaves
exactly as the comma operator or list argument separator,
according to context.</p>

<p>For example:</p>

<p>use constant FOO =&gt; &quot;something&quot;;</p>

<p>my %h = ( FOO =&gt; 23 );</p>

<p>is equivalent to:</p>

<p>my %h = (&quot;FOO&quot;, 23);</p>

<p>It is NOT:</p>

<p>my %h = (&quot;something&quot;, 23);</p>

<p>The &quot;=&gt;&quot; operator is helpful in documenting
the correspondence between keys and values in hashes, and
other paired elements in lists.</p>

<p>%hash = ( $key =&gt; $value ); login( $username =&gt;
$password );</p>

<p>List Operators (Rightward) On the right side of a list
operator, it has very low precedence, such that it controls
all comma-separated expressions found there. The only
operators with lower precedence are the logical operators
&quot;and&quot;, &quot;or&quot;, and &quot;not&quot;, which
may be used to evaluate calls to list operators without the
need for extra parentheses:</p>

<p>open HANDLE, &quot;filename&quot; or die
&quot;Can&rsquo;t open: $!0;</p>

<p>See also discussion of list operators in &quot;Terms and
List Operators (Leftward)&quot;.</p>

<p>Logical Not Unary &quot;not&quot; returns the logical
negation of the expression to its right. Its the equivalent
of &quot;!&quot; except for the very low precedence.</p>

<p>Logical And Binary &quot;and&quot; returns the logical
conjunction of the two surrounding expressions. Its
equivalent to &amp;&amp; except for the very low precedence.
This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is
true.</p>

<p>Logical or, Defined or, and Exclusive Or Binary
&quot;or&quot; returns the logical disjunction of the two
surrounding expressions. Its equivalent to || except for the
very low precedence. This makes it useful for control
flow</p>

<p>print FH $data or die &quot;Can&rsquo;t write to FH:
$!&quot;;</p>

<p>This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is
false. Due to its precedence, you should probably avoid
using this for assignment, only for control flow.</p>

<p>$a = $b or $c; # bug: this is wrong ($a = $b) or $c; #
really means this $a = $b || $c; # better written this
way</p>

<p>However, when its a list-context assignment and you re
trying to use &quot;||&quot; for control flow, you probably
need &quot;or&quot; so that the assignment takes higher
precedence.</p>

<p>@info = stat($file) || die; # oops, scalar sense of
stat! @info = stat($file) or die; # better, now @info gets
its due</p>

<p>Then again, you could always use parentheses.</p>

<p>Binary &quot;xor&quot; returns the exclusive-OR of the
two surrounding expressions. It cannot short circuit, of
course.</p>

<p>C Operators Missing From Perl Here is what C has that
Perl doesnt:</p>

<p>unary &amp; Address-of operator. (But see the &quot;
reference.)</p>

<p>unary * Dereference-address operator. (Perl s prefix
dereferencing operators are typed: $, @, %, and &amp;.)</p>

<p>(TYPE) Type-casting operator.</p>

<p>Quote and Quote-like Operators While we usually think of
quotes as literal values, in Perl they function as
operators, providing various kinds of interpolating and
pattern matching capabilities. Perl provides customary quote
characters for these behaviors, but also provides a way for
you to choose your quote character for any of them. In the
following table, a &quot;{}&quot; represents any pair of
delimiters you choose.</p>

<p>Customary Generic Meaning Interpolates &rsquo;&rsquo;
q{} Literal no &quot;&quot; qq{} Literal yes &lsquo;&lsquo;
qx{} Command yes* qw{} Word list no // m{} Pattern match
yes* qr{} Pattern yes* s{}{} Substitution yes* tr{}{}
Transliteration no (but see below) &lt;&lt;EOF here-doc
yes*</p>

<p>* unless the delimiter is &rsquo;&rsquo;.</p>

<p>Non-bracketing delimiters use the same character fore
and aft, but the four sorts of brackets (round, angle,
square, curly) will all nest, which means that</p>

<p>q{foo{bar}baz}</p>

<p>is the same as</p>

<p>&rsquo;foo{bar}baz&rsquo;</p>

<p>Note, however, that this does not always work for
quoting Perl code:</p>

<p>$s = q{ if($a eq &quot;}&quot;) ... }; # WRONG</p>

<p>is a syntax error. The &quot;Text::Balanced&quot; module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) is able to do this properly.</p>

<p>There can be whitespace between the operator and the
quoting characters, except when &quot;#&quot; is being used
as the quoting character. &quot;q#foo#&quot; is parsed as
the string &quot;foo&quot;, while &quot;q #foo#&quot; is the
operator &quot;q&quot; followed by a comment. Its argument
will be taken from the next line. This allows you to
write:</p>

<p>s {foo} # Replace foo {bar} # with bar.</p>

<p>The following escape sequences are available in
constructs that interpolate and in transliterations.</p>

<p>tab (HT, TAB) newline (NL)return (CR) form feed (FF)
backspace (BS) alarm (bell) (BEL) \ escape (ESC) 33 octal
char (example: ESC) b hex char (example: ESC) } wide hex
char (example: SMILEY) ame} named Unicode character</p>

<p>The character following &quot; converting letters to
upper case and then (on ASCII systems) by inverting the 7th
bit (0x40). The most interesting range is from @ to _ (0x40
through 0x5F), resulting in a control character from 0x00
through 0x1F. A ? maps to the DEL character. On EBCDIC
systems only @, the letters, [, , ], ^, _ and ? will work,
resulting in 0x00 through 0x1F and 0x7F.</p>

<p>NOTE: Unlike C and other languages, Perl has no escape
sequence for the vertical tab (VT - ASCII 11), but you may
use &quot; The following escape sequences are available in
constructs that interpolate but not in transliterations.</p>

<p>lowercase next char uppercase next char lowercase till U
uppercase till end case modification Q quote non-word
characters till If &quot;use locale&quot; is in effect, the
case map used by &quot; &quot; &quot;&quot; and
&quot;U&quot; is taken from the current locale. See
perllocale. If Unicode (for example, &quot;&quot; or wide
hex characters of 0x100 or beyond) is being used, the case
map used by &quot; &quot; &quot;&quot; and &quot;U&quot; is
as defined by Unicode. For documentation of
&quot;ame}&quot;, see charnames.</p>

<p>All systems use the virtual &quot;0 to represent a line
terminator, called a &quot;newline&quot;. There is no such
thing as an unvarying, physical newline character. It is
only an illusion that the operating system, device drivers,
C libraries, and Perl all conspire to preserve. Not all
&quot; as ASCII CR and &quot;0 as ASCII LF. For systems read
&quot; example, on a Mac, these are reversed, and on systems
without line terminator, printing &quot;0 may emit no actual
data. In general, use &quot;0 when you mean a
&quot;newline&quot; for your system, but use the literal
ASCII when you need an exact character. For example, most
networking protocols expect and prefer a CR+LF (&quot; 15
12&quot; or &quot; although they often accept just &quot;
12&quot;, they seldom tolerate just &quot; 15&quot;. If you
get in the habit of using &quot;0 for networking, you may be
burned some day.</p>

<p>For constructs that do interpolate, variables beginning
with &quot;&quot;$&quot;&quot; or &quot;&quot;@&quot;&quot;
are interpolated. Subscripted variables such as $a[3] or
&quot;$href-&gt;{key}[0]&quot; are also interpolated, as are
array and hash slices. But method calls such as
&quot;$obj-&gt;meth&quot; are not.</p>

<p>Interpolating an array or slice interpolates the
elements in order, separated by the value of $&quot;, so is
equivalent to interpolating &quot;join $&quot;,
@array&quot;. &quot;Punctuation&quot; arrays such as
&quot;@*&quot; are only interpolated if the name is enclosed
in braces &quot;@{*}&quot;, but special arrays @_,
&quot;@+&quot;, and &quot;@-&quot; are interpolated, even
without braces.</p>

<p>You cannot include a literal &quot;$&quot; or
&quot;@&quot; within a &quot;Q&quot; sequence. An unescaped
&quot;$&quot; or &quot;@&quot; interpolates the
corresponding variable, while escaping will cause the
literal string &quot; to be inserted. Youll need to write
something like &quot;m/Quser\@Qhost/&quot;.</p>

<p>Patterns are subject to an additional level of
interpretation as a regular expression. This is done as a
second pass, after variables are interpolated, so that
regular expressions may be incorporated into the pattern
from the variables. If this is not what you want, use
&quot;Q&quot; to interpolate a variable literally.</p>

<p>Apart from the behavior described above, Perl does not
expand multiple levels of interpolation. In particular,
contrary to the expectations of shell programmers,
back-quotes do NOT interpolate within double quotes, nor do
single quotes impede evaluation of variables when used
within double quotes.</p>

<p>Regexp Quote-Like Operators Here are the quote-like
operators that apply to pattern matching and related
activities.</p>

<p>qr/STRING/msixpo This operator quotes (and possibly
compiles) its STRING as a regular expression. STRING is
interpolated the same way as PATTERN in
&quot;m/PATTERN/&quot;. If &quot;&quot; is used as the
delimiter, no interpolation is done. Returns a Perl value
which may be used instead of the corresponding
&quot;/STRING/msixpo&quot; expression. The returned value is
a normalized version of the original pattern. It magically
differs from a string containing the same characters:
&quot;ref(qr/x/)&quot; returns &quot;Regexp&quot;, even
though dereferencing the result returns undef.</p>

<p>For example,</p>

<p>$rex = qr/my.STRING/is; print $rex; # prints
(?si-xm:my.STRING) s/$rex/foo/;</p>

<p>is equivalent to</p>

<p>s/my.STRING/foo/is;</p>

<p>The result may be used as a subpattern in a match:</p>

<p>$re = qr/$pattern/; $string =~ /foo${re}bar/; # can be
interpolated in other patterns $string =~ $re; # or used
standalone $string =~ /$re/; # or this way</p>

<p>Since Perl may compile the pattern at the moment of
execution of qr() operator, using qr() may have speed
advantages in some situations, notably if the result of qr()
is used standalone:</p>

<p>sub match { my $patterns = shift; my @compiled = map
qr/$_/i, @$patterns; grep { my $success = 0; foreach my $pat
(@compiled) { $success = 1, last if /$pat/; } $success; }
@_; }</p>

<p>Precompilation of the pattern into an internal
representation at the moment of qr() avoids a need to
recompile the pattern every time a match &quot;/$pat/&quot;
is attempted. (Perl has many other internal optimizations,
but none would be triggered in the above example if we did
not use qr() operator.)</p>

<p>Options are:</p>

<p>m Treat string as multiple lines. s Treat string as
single line. (Make . match a newline) i Do case-insensitive
pattern matching. x Use extended regular expressions. p When
matching preserve a copy of the matched string so that
${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined. o
Compile pattern only once.</p>

<p>If a precompiled pattern is embedded in a larger pattern
then the effect of msixp will be propagated appropriately.
The effect of the o modifier has is not propagated, being
restricted to those patterns explicitly using it.</p>

<p>See perlre for additional information on valid syntax
for STRING, and for a detailed look at the semantics of
regular expressions.</p>

<p>m/PATTERN/msixpogc /PATTERN/msixpogc Searches a string
for a pattern match, and in scalar context returns true if
it succeeds, false if it fails. If no string is specified
via the &quot;=~&quot; or &quot;!~&quot; operator, the $_
string is searched. (The string specified with
&quot;=~&quot; need not be an lvalue--it may be the result
of an expression evaluation, but remember the &quot;=~&quot;
binds rather tightly.) See also perlre. See perllocale for
discussion of additional considerations that apply when
&quot;use locale&quot; is in effect.</p>

<p>Options are as described in &quot;qr//&quot;; in
addition, the following match process modifiers are
available:</p>

<p>g Match globally, i.e., find all occurrences. c Do not
reset search position on a failed match when /g is in
effect.</p>

<p>If &quot;/&quot; is the delimiter then the initial
&quot;m&quot; is optional. With the &quot;m&quot; you can
use any pair of non-alphanumeric, non- whitespace characters
as delimiters. This is particularly useful for matching path
names that contain &quot;/&quot;, to avoid LTS (leaning
toothpick syndrome). If &quot;?&quot; is the delimiter, then
the match-only-once rule of &quot;?PATTERN?&quot; applies.
If &quot;&quot; is the delimiter, no interpolation is
performed on the PATTERN.</p>

<p>PATTERN may contain variables, which will be
interpolated (and the pattern recompiled) every time the
pattern search is evaluated, except for when the delimiter
is a single quote. (Note that $(, $), and $| are not
interpolated because they look like end-of-string tests.) If
you want such a pattern to be compiled only once, add a
&quot;/o&quot; after the trailing delimiter. This avoids
expensive run-time recompilations, and is useful when the
value you are interpolating wont change over the life of the
script. However, mentioning &quot;/o&quot; constitutes a
promise that you wont change the variables in the pattern.
If you change them, Perl won t even notice. See also
&quot;STRING/msixpo&quot;&quot; in &quot;qr.</p>

<p>The empty pattern // If the PATTERN evaluates to the
empty string, the last successfully matched regular
expression is used instead. In this case, only the
&quot;g&quot; and &quot;c&quot; flags on the empty pattern
is honoured - the other flags are taken from the original
pattern. If no match has previously succeeded, this will
(silently) act instead as a genuine empty pattern (which
will always match).</p>

<p>Note that it s possible to confuse Perl into thinking
&quot;//&quot; (the empty regex) is really &quot;//&quot;
(the defined-or operator). Perl is usually pretty good about
this, but some pathological cases might trigger this, such
as &quot;$a///&quot; (is that &quot;($a) / (//)&quot; or
&quot;$a // /&quot;?) and &quot;print $fh //&quot;
(&quot;print $fh(//&quot; or &quot;print($fh //&quot;?). In
all of these examples, Perl will assume you meant
defined-or. If you meant the empty regex, just use
parentheses or spaces to disambiguate, or even prefix the
empty regex with an &quot;m&quot; (so &quot;//&quot; becomes
&quot;m//&quot;).</p>

<p>Matching in list context If the &quot;/g&quot; option is
not used, &quot;m//&quot; in list context returns a list
consisting of the subexpressions matched by the parentheses
in the pattern, i.e., ($1, $2, $3...). (Note that here $1
etc. are also set, and that this differs from Perl 4s
behavior.) When there are no parentheses in the pattern, the
return value is the list &quot;(1)&quot; for success. With
or without parentheses, an empty list is returned upon
failure.</p>

<p>Examples:</p>

<p>open(TTY, &rsquo;/dev/tty&rsquo;); &lt;TTY&gt; =~ /^y/i
&amp;&amp; foo(); # do foo if desired</p>

<p>if (/Version: *([0-9.]*)/) { $version = $1; }</p>

<p>next if m#^/usr/spool/uucp#;</p>

<p># poor man&rsquo;s grep $arg = shift; while (&lt;&gt;) {
print if /$arg/o; # compile only once }</p>

<p>if (($F1, $F2, $Etc) = ($foo =~ /^()(.*)/))</p>

<p>This last example splits $foo into the first two words
and the remainder of the line, and assigns those three
fields to $F1, $F2, and $Etc. The conditional is true if any
variables were assigned, i.e., if the pattern matched.</p>

<p>The &quot;/g&quot; modifier specifies global pattern
matching--that is, matching as many times as possible within
the string. How it behaves depends on the context. In list
context, it returns a list of the substrings matched by any
capturing parentheses in the regular expression. If there
are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole
pattern.</p>

<p>In scalar context, each execution of &quot;m//g&quot;
finds the next match, returning true if it matches, and
false if there is no further match. The position after the
last match can be read or set using the pos() function; see
&quot;pos&quot; in perlfunc. A failed match normally resets
the search position to the beginning of the string, but you
can avoid that by adding the &quot;/c&quot; modifier (e.g.
&quot;m//gc&quot;). Modifying the target string also resets
the search position.</p>

<p>G assertion You can intermix &quot;m//g&quot; matches
with &quot;m/G.../g&quot;, where &quot;G&quot; is a
zero-width assertion that matches the exact position where
the previous &quot;m//g&quot;, if any, left off. Without the
&quot;/g&quot; modifier, the &quot;G&quot; assertion still
anchors at pos(), but the match is of course only attempted
once. Using &quot;G&quot; without &quot;/g&quot; on a target
string that has not previously had a &quot;/g&quot; match
applied to it is the same as using the &quot;0 match the
beginning of the string. Note also that, currently,
&quot;G&quot; is only properly supported when anchored at
the very beginning of the pattern.</p>

<p>Examples:</p>

<p># list context ($one,$five,$fifteen) =
(&lsquo;uptime&lsquo; =~ /(+.+)/g);</p>

<p># scalar context $/ = &quot;&quot;; while
(defined($paragraph = &lt;&gt;)) { while ($paragraph =~
/[a-z][&rsquo;&quot;)]*[.!?]+[&rsquo;&quot;)]*g) {
$sentences++; } } print &quot;$sentences0;</p>

<p># using m//gc with G $_ = &quot;ppooqppqq&quot;; while
($i++ &lt; 2) { print &quot;1: &rsquo;&quot;; print $1 while
/(o)/gc; print &quot;&rsquo;, pos=&quot;, pos, &quot;0;
print &quot;2: &rsquo;&quot;; print $1 if /G(q)/gc; print
&quot;&rsquo;, pos=&quot;, pos, &quot;0; print &quot;3:
&rsquo;&quot;; print $1 while /(p)/gc; print &quot;&rsquo;,
pos=&quot;, pos, &quot;0; } print &quot;Final:
&rsquo;$1&rsquo;, pos=&quot;,pos,&quot;0 if /G(.)/;</p>

<p>The last example should print:</p>

<p>1: &rsquo;oo&rsquo;, pos=4 2: &rsquo;q&rsquo;, pos=5 3:
&rsquo;pp&rsquo;, pos=7 1: &rsquo;&rsquo;, pos=7 2:
&rsquo;q&rsquo;, pos=8 3: &rsquo;&rsquo;, pos=8 Final:
&rsquo;q&rsquo;, pos=8</p>

<p>Notice that the final match matched &quot;q&quot;
instead of &quot;p&quot;, which a match without the
&quot;G&quot; anchor would have done. Also note that the
final match did not update &quot;pos&quot; --
&quot;pos&quot; is only updated on a &quot;/g&quot; match.
If the final match did indeed match &quot;p&quot;, its a
good bet that youre running an older (pre-5.6.0) Perl.</p>

<p>A useful idiom for &quot;lex&quot;-like scanners is
&quot;/G.../gc&quot;. You can combine several regexps like
this to process a string part-by- part, doing different
actions depending on which regexp matched. Each regexp tries
to match where the previous one leaves off.</p>

<p>$_ = &lt;&lt;&rsquo;EOL&rsquo;; $url = URI::URL-&gt;new(
&quot;http://www/&quot; ); die if $url eq &quot;xXx&quot;;
EOL LOOP: { , . ; ] print(&quot; digits&quot;), redo LOOP if
/G+? / g c ; print(&quot; lowercase&quot;), redo LOOP if , .
; ] /G[a-z]+? / g c ; print(&quot; UPPERCASE&quot;), redo
LOOP if , . ; ] /G[A-Z]+? / g c ; print(&quot;
Capitalized&quot;), redo LOOP if , . ; ] /G[A-Z][a-z]+? / g
c ; print(&quot; MiXeD&quot;), redo LOOP if , . ; ]
/G[A-Za-z]+? / g c ; print(&quot; alphanumeric&quot;), redo
LOOP if , . ; ] /G[A-Za-z0-9]+? / g c ; print(&quot;
line-noise&quot;), redo LOOP if /G[^A-Za-z0-9]+/gc; print
&quot;. That&rsquo;s all!0; }</p>

<p>Here is the output (split into several lines):</p>

<p>line-noise lowercase line-noise lowercase UPPERCASE
line-noise UPPERCASE line-noise lowercase line-noise
lowercase line-noise lowercase lowercase line-noise
lowercase lowercase line-noise MiXeD line-noise.
That&rsquo;s all!</p>

<p>?PATTERN? This is just like the &quot;/pattern/&quot;
search, except that it matches only once between calls to
the reset() operator. This is a useful optimization when you
want to see only the first occurrence of something in each
file of a set of files, for instance. Only &quot;??&quot;
patterns local to the current package are reset.</p>

<p>while (&lt;&gt;) { if (?^$?) { # blank line between
header and body } } continue { reset if eof; # clear ??
status for next file }</p>

<p>This usage is vaguely deprecated, which means it just
might possibly be removed in some distant future version of
Perl, perhaps somewhere around the year 2168.</p>

<p>s/PATTERN/REPLACEMENT/msixpogce Searches a string for a
pattern, and if found, replaces that pattern with the
replacement text and returns the number of substitutions
made. Otherwise it returns false (specifically, the empty
string).</p>

<p>If no string is specified via the &quot;=~&quot; or
&quot;!~&quot; operator, the $_ variable is searched and
modified. (The string specified with &quot;=~&quot; must be
scalar variable, an array element, a hash element, or an
assignment to one of those, i.e., an lvalue.)</p>

<p>If the delimiter chosen is a single quote, no
interpolation is done on either the PATTERN or the
REPLACEMENT. Otherwise, if the PATTERN contains a $ that
looks like a variable rather than an end-of-string test, the
variable will be interpolated into the pattern at run-time.
If you want the pattern compiled only once the first time
the variable is interpolated, use the &quot;/o&quot; option.
If the pattern evaluates to the empty string, the last
successfully executed regular expression is used instead.
See perlre for further explanation on these. See perllocale
for discussion of additional considerations that apply when
&quot;use locale&quot; is in effect.</p>

<p>Options are as with m// with the addition of the
following replacement specific options:</p>

<p>e Evaluate the right side as an expression. ee Evaluate
the right side as a string then eval the result</p>

<p>Any non-alphanumeric, non-whitespace delimiter may
replace the slashes. If single quotes are used, no
interpretation is done on the replacement string (the
&quot;/e&quot; modifier overrides this, however). Unlike
Perl 4, Perl 5 treats backticks as normal delimiters; the
replacement text is not evaluated as a command. If the
PATTERN is delimited by bracketing quotes, the REPLACEMENT
has its own pair of quotes, which may or may not be
bracketing quotes, e.g., &quot;s(foo)(bar)&quot; or
&quot;s&lt;foo&gt;/bar/&quot;. A &quot;/e&quot; will cause
the replacement portion to be treated as a full-fledged Perl
expression and evaluated right then and there. It is,
however, syntax checked at compile-time. A second
&quot;e&quot; modifier will cause the replacement portion to
be &quot;eval&quot;ed before being run as a Perl
expression.</p>

<p>Examples:</p>

<p>r e s/e; # don&rsquo;t change wintergreen n</p>

<p>$path =~ s|/usr/bin|/usr/local/bin|;</p>

<p>s/Login: $foo/Login: $bar/; # run-time pattern</p>

<p>($foo = $bar) =~ s/this/that/; # copy first, then
change</p>

<p>M $count = ($paragraph =~ s/Misterrg); # get
.change-count</p>

<p>$_ = &rsquo;abc123xyz&rsquo;; s/+/$&amp;*2/e; # yields
&rsquo;abc246xyz&rsquo;
s/+/sprintf(&quot;%5d&quot;,$&amp;)/e; # yields &rsquo;abc
246xyz&rsquo; s/144eg; # yields &rsquo;aabbcc
224466xxyyzz&rsquo;</p>

<p>s/%(.)/$percent{$1}/g; # change percent escapes; no /e
s/%(.)/$percent{$1} || $&amp;/ge; # expr now, so /e
s/^=(936</p>

<p># expand variables in $_, but dynamics only, using #
symbolic dereferencing s/+)/${$1}/g;</p>

<p># Add one to the value of any numbers in the string
s/(+)/1 + $1/eg;</p>

<p># This will expand any embedded scalar variable #
(including lexicals) in $_ : First $1 is interpolated # to
the variable name, and then evaluated s/(w+)/$1/eeg;</p>

<p># Delete (most) C comments. $program =~ s { / # Match
the opening delimiter. .*? # Match a minimal number of
characters. # Match the closing delimiter. } []gsx;</p>

<p>s/^(.*?)$/$1/; # trim whitespace in $_, expensively</p>

<p>for ($variable) { # trim whitespace in $variable, cheap
s/^/; s/; }</p>

<p>s/([^ ]*) *([^ ]*)/$2 $1/; # reverse 1st two fields</p>

<p>Note the use of $ instead of in the last example. Unlike
sed, we use the &lt;digit&gt; form in only the left hand
side. Anywhere else its $&lt;digit&gt;.</p>

<p>Occasionally, you cant use just a &quot;/g&quot; to get
all the changes to occur that you might want. Here are two
common cases:</p>

<p># put commas in the right places in an integer 1 while
s/()()(?!)/$1,$2/g;</p>

<p># expand tabs to 8-column spacing 1 while s/+/&rsquo;
&rsquo; x (length($&amp;)*8 - length($&lsquo;)%8)/e;</p>

<p>Quote-Like Operators q/STRING/ STRING A single-quoted,
literal string. A backslash represents a backslash unless
followed by the delimiter or another backslash, in which
case the delimiter or backslash is interpolated.</p>

<p>$foo = q!I said, &quot;You said, &rsquo;She said
it.&rsquo;&quot;!; $bar = q(&rsquo;This is it.&rsquo;); $baz
= &rsquo;0; # a two-character string</p>

<p>qq/STRING/ &quot;STRING&quot; A double-quoted,
interpolated string.</p>

<p>$_ .= qq (*** The previous line contains the naughty
word &quot;$1&quot;.0 t c l | j a v a if /| p y t h o n )
$baz = &quot;0; # a one-character string</p>

<p>qx/STRING/ STRING A string which is (possibly)
interpolated and then executed as a system command with
&quot;/bin/sh&quot; or its equivalent. Shell wildcards,
pipes, and redirections will be honored. The collected
standard output of the command is returned; standard error
is unaffected. In scalar context, it comes back as a single
(potentially multi- line) string, or undef if the command
failed. In list context, returns a list of lines (however
youve defined lines with $/ or $INPUT_RECORD_SEPARATOR), or
an empty list if the command failed.</p>

<p>Because backticks do not affect standard error, use
shell file descriptor syntax (assuming the shell supports
this) if you care to address this. To capture a commands
STDERR and STDOUT together:</p>

<p>$output = &lsquo;cmd 2&gt;&amp;1&lsquo;;</p>

<p>To capture a commands STDOUT but discard its STDERR:</p>

<p>$output = &lsquo;cmd 2&gt;/dev/null&lsquo;;</p>

<p>To capture a commands STDERR but discard its STDOUT
(ordering is important here):</p>

<p>$output = &lsquo;cmd 2&gt;&amp;1
1&gt;/dev/null&lsquo;;</p>

<p>To exchange a commands STDOUT and STDERR in order to
capture the STDERR but leave its STDOUT to come out the old
STDERR:</p>

<p>$output = &lsquo;cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3
3&gt;&amp;-&lsquo;;</p>

<p>To read both a command s STDOUT and its STDERR
separately, its easiest to redirect them separately to
files, and then read from those files when the program is
done:</p>

<p>system(&quot;program args 1&gt;program.stdout
2&gt;program.stderr&quot;);</p>

<p>The STDIN filehandle used by the command is inherited
from Perls STDIN. For example:</p>

<p>open BLAM, &quot;blam&quot; || die &quot;Can&rsquo;t
open: $!&quot;; open STDIN, &quot;&lt;&amp;BLAM&quot;; print
&lsquo;sort&lsquo;;</p>

<p>will print the sorted contents of the file
&quot;blam&quot;.</p>

<p>Using single-quote as a delimiter protects the command
from Perls double-quote interpolation, passing it on to the
shell instead:</p>

<p>$perl_info = qx(ps $$); # that&rsquo;s Perl&rsquo;s $$
$shell_info = qx&rsquo;ps $$&rsquo;; # that&rsquo;s the new
shell&rsquo;s $$</p>

<p>How that string gets evaluated is entirely subject to
the command interpreter on your system. On most platforms,
you will have to protect shell metacharacters if you want
them treated literally. This is in practice difficult to do,
as its unclear how to escape which characters. See perlsec
for a clean and safe example of a manual fork() and exec()
to emulate backticks safely.</p>

<p>On some platforms (notably DOS-like ones), the shell may
not be capable of dealing with multiline commands, so
putting newlines in the string may not get you what you
want. You may be able to evaluate multiple commands in a
single line by separating them with the command separator
character, if your shell supports that (e.g. &quot;;&quot;
on many Unix shells; &quot;&amp;&quot; on the Windows NT
&quot;cmd&quot; shell).</p>

<p>Beginning with v5.6.0, Perl will attempt to flush all
files opened for output before starting the child process,
but this may not be supported on some platforms (see
perlport). To be safe, you may need to set $| ($AUTOFLUSH in
English) or call the &quot;autoflush()&quot; method of
&quot;IO::Handle&quot; on any open handles.</p>

<p>Beware that some command shells may place restrictions
on the length of the command line. You must ensure your
strings dont exceed this limit after any necessary
interpolations. See the platform-specific release notes for
more details about your particular environment.</p>

<p>Using this operator can lead to programs that are
difficult to port, because the shell commands called vary
between systems, and may in fact not be present at all. As
one example, the &quot;type&quot; command under the POSIX
shell is very different from the &quot;type&quot; command
under DOS. That doesnt mean you should go out of your way to
avoid backticks when theyre the right way to get something
done. Perl was made to be a glue language, and one of the
things it glues together is commands. Just understand what
youre getting yourself into.</p>

<p>See &quot;I/O Operators&quot; for more discussion.</p>

<p>qw/STRING/ Evaluates to a list of the words extracted
out of STRING, using embedded whitespace as the word
delimiters. It can be understood as being roughly equivalent
to:</p>

<p>split(&rsquo; &rsquo;, q/STRING/);</p>

<p>the differences being that it generates a real list at
compile time, and in scalar context it returns the last
element in the list. So this expression:</p>

<p>qw(foo bar baz)</p>

<p>is semantically equivalent to the list:</p>

<p>&rsquo;foo&rsquo;, &rsquo;bar&rsquo;,
&rsquo;baz&rsquo;</p>

<p>Some frequently seen examples:</p>

<p>use POSIX qw( setlocale localeconv ) @EXPORT = qw( foo
bar baz );</p>

<p>A common mistake is to try to separate the words with
comma or to put comments into a multi-line
&quot;qw&quot;-string. For this reason, the &quot;use
warnings&quot; pragma and the -w switch (that is, the $^W
variable) produces warnings if the STRING contains the
&quot;,&quot; or the &quot;#&quot; character.</p>

<p>tr/SEARCHLIST/REPLACEMENTLIST/cds
y/SEARCHLIST/REPLACEMENTLIST/cds Transliterates all
occurrences of the characters found in the search list with
the corresponding character in the replacement list. It
returns the number of characters replaced or deleted. If no
string is specified via the =~ or !~ operator, the $_ string
is transliterated. (The string specified with =~ must be a
scalar variable, an array element, a hash element, or an
assignment to one of those, i.e., an lvalue.)</p>

<p>A character range may be specified with a hyphen, so
&quot;tr/A-J/0-9/&quot; does the same replacement as
&quot;tr/ACEGIBDFHJ/0246813579/&quot;. For sed devotees,
&quot;y&quot; is provided as a synonym for &quot;tr&quot;.
If the SEARCHLIST is delimited by bracketing quotes, the
REPLACEMENTLIST has its own pair of quotes, which may or may
not be bracketing quotes, e.g., &quot;tr[A-Z][a-z]&quot; or
&quot;tr(+&minus;*/)/ABCD/&quot;.</p>

<p>Note that &quot;tr&quot; does not do regular expression
character classes such as &quot;&quot; or
&quot;[:lower:]&quot;. The &quot;tr&quot; operator is not
equivalent to the tr(1) utility. If you want to map strings
between lower/upper cases, see &quot;lc&quot; in perlfunc
and &quot;uc&quot; in perlfunc, and in general consider
using the &quot;s&quot; operator if you need regular
expressions.</p>

<p>Note also that the whole range idea is rather unportable
between character sets--and even within character sets they
may cause results you probably didnt expect. A sound
principle is to use only ranges that begin from and end at
either alphabets of equal case (a-e, A-E), or digits (0-4).
Anything else is unsafe. If in doubt, spell out the
character sets in full.</p>

<p>Options:</p>

<p>c Complement the SEARCHLIST. d Delete found but
unreplaced characters. s Squash duplicate replaced
characters.</p>

<p>If the &quot;/c&quot; modifier is specified, the
SEARCHLIST character set is complemented. If the
&quot;/d&quot; modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are
deleted. (Note that this is slightly more flexible than the
behavior of some tr programs, which delete anything they
find in the SEARCHLIST, period.) If the &quot;/s&quot;
modifier is specified, sequences of characters that were
transliterated to the same character are squashed down to a
single instance of the character.</p>

<p>If the &quot;/d&quot; modifier is used, the
REPLACEMENTLIST is always interpreted exactly as specified.
Otherwise, if the REPLACEMENTLIST is shorter than the
SEARCHLIST, the final character is replicated till it is
long enough. If the REPLACEMENTLIST is empty, the SEARCHLIST
is replicated. This latter is useful for counting characters
in a class or for squashing character sequences in a
class.</p>

<p>Examples:</p>

<p>$ARGV[1] =~ tr/A-Z/a-z/; # canonicalize to lower
case</p>

<p>$cnt = tr/*/*/; # count the stars in $_</p>

<p>$cnt = $sky =~ tr/*/*/; # count the stars in $sky</p>

<p>$cnt = tr/0-9//; # count the digits in $_</p>

<p>tr/a-zA-Z//s; # bookkeeper -&gt; bokeper</p>

<p>($HOST = $host) =~ tr/a-z/A-Z/;</p>

<p>tr/a-zA-Z/ /cs; # change non-alphas to single space</p>

<p>tr [200-377] [ 00-177]; # delete 8th bit</p>

<p>If multiple transliterations are given for a character,
only the first one is used:</p>

<p>tr/AAA/XYZ/</p>

<p>will transliterate any A to X.</p>

<p>Because the transliteration table is built at compile
time, neither the SEARCHLIST nor the REPLACEMENTLIST are
subjected to double quote interpolation. That means that if
you want to use variables, you must use an eval():</p>

<p>eval &quot;tr/$oldlist/$newlist/&quot;; die $@ if
$@;</p>

<p>eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</p>

<p>&lt;&lt;EOF A line-oriented form of quoting is based on
the shell &quot;here- document&quot; syntax. Following a
&quot;&lt;&lt;&quot; you specify a string to terminate the
quoted material, and all lines following the current line
down to the terminating string are the value of the
item.</p>

<p>The terminating string may be either an identifier (a
word), or some quoted text. An unquoted identifier works
like double quotes. There may not be a space between the
&quot;&lt;&lt;&quot; and the identifier, unless the
identifier is explicitly quoted. (If you put a space it will
be treated as a null identifier, which is valid, and matches
the first empty line.) The terminating string must appear by
itself (unquoted and with no surrounding whitespace) on the
terminating line.</p>

<p>If the terminating string is quoted, the type of quotes
used determine the treatment of the text.</p>

<p>Double Quotes Double quotes indicate that the text will
be interpolated using exactly the same rules as normal
double quoted strings.</p>

<p>print &lt;&lt;EOF; The price is $Price. EOF</p>

<p>print &lt;&lt; &quot;EOF&quot;; # same as above The
price is $Price. EOF</p>

<p>Single Quotes Single quotes indicate the text is to be
treated literally with no interpolation of its content. This
is similar to single quoted strings except that backslashes
have no special meaning, with &quot;\&quot; being treated as
two backslashes and not one as they would in every other
quoting construct.</p>

<p>This is the only form of quoting in perl where there is
no need to worry about escaping content, something that code
generators can and do make good use of.</p>

<p>Backticks The content of the here doc is treated just as
it would be if the string were embedded in backticks. Thus
the content is interpolated as though it were double quoted
and then executed via the shell, with the results of the
execution returned.</p>

<p>print &lt;&lt; &lsquo;EOC&lsquo;; # execute command and
get results echo hi there EOC</p>

<p>It is possible to stack multiple here-docs in a row:</p>

<p>print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;;
# you can stack them I said foo. foo I said bar. bar</p>

<p>myfunc(&lt;&lt; &quot;THIS&quot;, 23,
&lt;&lt;&rsquo;THAT&rsquo;); Here&rsquo;s a line or two.
THIS and here&rsquo;s another. THAT</p>

<p>Just dont forget that you have to put a semicolon on the
end to finish the statement, as Perl doesnt know youre not
going to try to do this:</p>

<p>print &lt;&lt;ABC 179231 ABC + 20;</p>

<p>If you want to remove the line terminator from your
here-docs, use &quot;chomp()&quot;.</p>

<p>chomp($string = &lt;&lt;&rsquo;END&rsquo;); This is a
string. END</p>

<p>If you want your here-docs to be indented with the rest
of the code, youll need to remove leading whitespace from
each line manually:</p>

<p>($quote = &lt;&lt;&rsquo;FINIS&rsquo;) =~ s/^/gm; The
Road goes ever on and on, down from the door where it began.
FINIS</p>

<p>If you use a here-doc within a delimited construct, such
as in &quot;s///eg&quot;, the quoted material must come on
the lines following the final delimiter. So instead of</p>

<p>s/this/&lt;&lt;E . &rsquo;that&rsquo; the other E .
&rsquo;more &rsquo;/eg;</p>

<p>you have to write</p>

<p>s/this/&lt;&lt;E . &rsquo;that&rsquo; . &rsquo;more
&rsquo;/eg; the other E</p>

<p>If the terminating identifier is on the last line of the
program, you must be sure there is a newline after it;
otherwise, Perl will give the warning Can t find string
terminator &quot;END&quot; anywhere before EOF....</p>

<p>Additionally, the quoting rules for the end of string
identifier are not related to Perl s quoting rules --
&quot;q()&quot;, &quot;qq()&quot;, and the like are not
supported in place of &rsquo;&rsquo; and &quot;&quot;, and
the only interpolation is for backslashing the quoting
character:</p>

<p>print &lt;&lt; &quot;abc testing... abc&quot;def</p>

<p>Finally, quoted strings cannot span multiple lines. The
general rule is that the identifier must be a string
literal. Stick with that, and you should be safe.</p>

<p>Gory details of parsing quoted constructs When presented
with something that might have several different
interpretations, Perl uses the DWIM (thats &quot;Do What I
Mean&quot;) principle to pick the most probable
interpretation. This strategy is so successful that Perl
programmers often do not suspect the ambivalence of what
they write. But from time to time, Perls notions differ
substantially from what the author honestly meant.</p>

<p>This section hopes to clarify how Perl handles quoted
constructs. Although the most common reason to learn this is
to unravel labyrinthine regular expressions, because the
initial steps of parsing are the same for all quoting
operators, they are all discussed together.</p>

<p>The most important Perl parsing rule is the first one
discussed below: when processing a quoted construct, Perl
first finds the end of that construct, then interprets its
contents. If you understand this rule, you may skip the rest
of this section on the first reading. The other rules are
likely to contradict the users expectations much less
frequently than this first one.</p>

<p>Some passes discussed below are performed concurrently,
but because their results are the same, we consider them
individually. For different quoting constructs, Perl
performs different numbers of passes, from one to four, but
these passes are always performed in the same order.</p>

<p>Finding the end The first pass is finding the end of the
quoted construct, where the information about the delimiters
is used in parsing. During this search, text between the
starting and ending delimiters is copied to a safe location.
The text copied gets delimiter- independent.</p>

<p>If the construct is a here-doc, the ending delimiter is
a line that has a terminating string as the content.
Therefore &quot;&lt;&lt;EOF&quot; is terminated by
&quot;EOF&quot; immediately followed by &quot;0 and starting
from the first column of the terminating line. When
searching for the terminating line of a here-doc, nothing is
skipped. In other words, lines after the here-doc syntax are
compared with the terminating string line by line.</p>

<p>For the constructs except here-docs, single characters
are used as starting and ending delimiters. If the starting
delimiter is an opening punctuation (that is &quot;(&quot;,
&quot;[&quot;, &quot;{&quot;, or &quot;&lt;&quot;), the
ending delimiter is the corresponding closing punctuation
(that is &quot;)&quot;, &quot;]&quot;, &quot;}&quot;, or
&quot;&gt;&quot;). If the starting delimiter is an unpaired
character like &quot;/&quot; or a closing punctuation, the
ending delimiter is same as the starting delimiter.
Therefore a &quot;/&quot; terminates a &quot;qq//&quot;
construct, while a &quot;]&quot; terminates &quot;qq[]&quot;
and &quot;qq]]&quot; constructs.</p>

<p>When searching for single-character delimiters, escaped
delimiters and &quot;\&quot; are skipped. For example, while
searching for terminating &quot;/&quot;, combinations of
&quot;\&quot; and &quot;&quot; are skipped. If the
delimiters are bracketing, nested pairs are also skipped.
For example, while searching for closing &quot;]&quot;
paired with the opening &quot;[&quot;, combinations of
&quot;\&quot;, &quot;]&quot;, and &quot;are all skipped, and
nested &quot;[&quot; and &quot;]&quot; are skipped as well.
However, when backslashes are used as the delimiters (like
&quot;qq\&quot; and &quot;tr\ the search for the end,
backslashes that escape delimiters are removed (exactly
speaking, they are not copied to the safe location).</p>

<p>For constructs with three-part delimiters
(&quot;s///&quot;, &quot;y///&quot;, and &quot;tr///&quot;),
the search is repeated once more. If the first delimiter is
not an opening punctuation, three delimiters must be same
such as &quot;s!!!&quot; and &quot;tr)))&quot;, in which
case the second delimiter terminates the left part and
starts the right part at once. If the left part is delimited
by bracketing punctuations (that is &quot;()&quot;,
&quot;[]&quot;, &quot;{}&quot;, or &quot;&lt;&gt;&quot;),
the right part needs another pair of delimiters such as
&quot;s(){}&quot; and &quot;tr[]//&quot;. In these cases,
whitespaces and comments are allowed between both parts,
though the comment must follow at least one whitespace;
otherwise a character expected as the start of the comment
may be regarded as the starting delimiter of the right
part.</p>

<p>During this search no attention is paid to the semantics
of the construct. Thus:</p>

<p>&quot;$hash{&quot;$foo/$bar&quot;}&quot;</p>

<p>or:</p>

<p>m/ bar # NOT a comment, this slash / terminated m//!
/x</p>

<p>do not form legal quoted expressions. The quoted part
ends on the first &quot;&quot;&quot; and &quot;/&quot;, and
the rest happens to be a syntax error. Because the slash
that terminated &quot;m//&quot; was followed by a
&quot;SPACE&quot;, the example above is not
&quot;m//x&quot;, but rather &quot;m//&quot; with no
&quot;/x&quot; modifier. So the embedded &quot;#&quot; is
interpreted as a literal &quot;#&quot;.</p>

<p>Also no attention is paid to &quot; during this search.
Thus the second &quot; as a part of &quot;&quot;, and the
following &quot;/&quot; is not recognized as a delimiter.
Instead, use &quot; 34&quot; or &quot;c&quot; at the end of
quoted constructs.</p>

<p>Interpolation The next step is interpolation in the text
obtained, which is now delimiter-independent. There are
multiple cases.</p>

<p>&quot;&lt;&lt;&rsquo;EOF&rsquo;&quot; No interpolation
is performed. Note that the combination &quot;\&quot; is
left intact, since escaped delimiters are not available for
here-docs.</p>

<p>&quot;m&rsquo;&rsquo;&quot;, the pattern of
&quot;s&rsquo;&rsquo;&rsquo;&quot; No interpolation is
performed at this stage. Any backslashed sequences including
&quot;\&quot; are treated at the stage to &quot;parsing
regular expressions&quot;.</p>

<p>&rsquo;&rsquo;, &quot;q//&quot;,
&quot;tr&rsquo;&rsquo;&rsquo;&quot;,
&quot;y&rsquo;&rsquo;&rsquo;&quot;, the replacement of
&quot;s&rsquo;&rsquo;&rsquo;&quot; The only interpolation is
removal of &quot; Therefore &quot;-&quot; in
&quot;tr&rsquo;&rsquo;&rsquo;&quot; and
&quot;y&rsquo;&rsquo;&rsquo;&quot; is treated literally as a
hyphen and no character range is available. &quot;1&quot; in
the replacement of &quot;s&rsquo;&rsquo;&rsquo;&quot; does
not work as $1.</p>

<p>&quot;tr///&quot;, &quot;y///&quot; No variable
interpolation occurs. String modifying combinations for case
and quoting such as &quot;Q&quot;, &quot;U&quot;, and &quot;
are not recognized. The other escape sequences such as
&quot;200&quot; and &quot;&quot; and backslashed characters
such as &quot;\&quot; and &quot;&minus;&quot; are converted
to appropriate literals. The character &quot;-&quot; is
treated specially and therefore &quot;&minus;&quot; is
treated as a literal &quot;-&quot;.</p>

<p>&quot;&quot;, &quot;&lsquo;&lsquo;&quot;,
&quot;qq//&quot;, &quot;qx//&quot;,
&quot;&lt;file*glob&gt;&quot;,
&quot;&lt;&lt;&quot;EOF&quot;&quot; &quot;Q&quot;,
&quot;U&quot;, &quot;&quot;, &quot; &quot;ssibly paired with
&quot; converted to corresponding Perl constructs. Thus,
&quot;$fooQbaz$bar&quot; is converted to &quot;$foo .
(quotemeta(&quot;baz&quot; . $bar))&quot; internally. The
other escape sequences such as &quot;200&quot; and
&quot;&quot; and backslashed characters such as
&quot;\&quot; and &quot;&minus;&quot; are replaced with
appropriate expansions.</p>

<p>Let it be stressed that whatever falls between
&quot;Q&quot; and &quot;E&quot; is interpolated in the usual
way. Something like &quot;Q\E&quot; has no &quot; result is
the same as for &quot;\\E&quot;. As a general rule,
backslashes between &quot;Q&quot; and &quot; results. So,
&quot;Q is the same as &quot;\&quot; (since TAB is not
alphanumeric). Note also that:</p>

<p>$str = &rsquo;&rsquo;; return &quot;Q$str&quot;;</p>

<p>may be closer to the conjectural intention of the writer
of &quot;Q</p>

<p>Interpolated scalars and arrays are converted internally
to the &quot;join&quot; and &quot;.&quot; catenation
operations. Thus, &quot;$foo XXX &rsquo;@arr&rsquo;&quot;
becomes:</p>

<p>$foo . &quot; XXX &rsquo;&quot; . (join $&quot;, @arr) .
&quot;&rsquo;&quot;;</p>

<p>All operations above are performed simultaneously, left
to right.</p>

<p>Because the result of &quot;Q STRING quoted, there is no
way to insert a literal &quot;$&quot; or &quot;@&quot;
inside a &quot;Q &quot;\; if not, it is interpreted as the
start of an interpolated scalar.</p>

<p>Note also that the interpolation code needs to make a
decision on where the interpolated scalar ends. For
instance, whether &quot;a $b -&gt; {c}&quot; really
means:</p>

<p>&quot;a &quot; . $b . &quot; -&gt; {c}&quot;;</p>

<p>or:</p>

<p>&quot;a &quot; . $b -&gt; {c};</p>

<p>Most of the time, the longest possible text that does
not include spaces between components and which contains
matching braces or brackets. because the outcome may be
determined by voting based on heuristic estimators, the
result is not strictly predictable. Fortunately, it s
usually correct for ambiguous cases.</p>

<p>the replacement of &quot;s///&quot; Processing of
&quot;Q&quot;, &quot;U&quot;, &quot;&quot;, &quot; &quot;
and interpolation happens as with &quot;qq//&quot;
constructs.</p>

<p>It is at this step that &quot;1&quot; is begrudgingly
converted to $1 in the replacement text of &quot;s///&quot;,
in order to correct the incorrigible sed hackers who havent
picked up the saner idiom yet. A warning is emitted if the
&quot;use warnings&quot; pragma or the -w command-line flag
(that is, the $^W variable) was set.</p>

<p>&quot;RE&quot; in &quot;?RE?&quot;, &quot;/RE/&quot;,
&quot;m/RE/&quot;, &quot;s/RE/foo/&quot;, Processing of
&quot;Q&quot;, &quot;U&quot;, &quot;&quot;, &quot; &quot;
&quot; interpolation happens (almost) as with
&quot;qq//&quot; constructs.</p>

<p>However any other combinations of &quot; are not
substituted but only skipped, in order to parse them as
regular expressions at the following step. As &quot; at this
step, &quot;@&quot; of &quot; array symbol (for example
@foo), even though the same text in &quot;qq//&quot; gives
interpolation of &quot; Moreover, inside
&quot;(?{BLOCK})&quot;, &quot;(?# comment )&quot;, and a
&quot;#&quot;-comment in a &quot;//x&quot;-regular
expression, no processing is performed whatsoever. This is
the first step at which the presence of the &quot;//x&quot;
modifier is relevant.</p>

<p>Interpolation in patterns has several quirks: $|, $(,
$), &quot;@+&quot; and &quot;@-&quot; are not interpolated,
and constructs $var[SOMETHING] are voted (by several
different estimators) to be either an array element or $var
followed by an RE alternative. This is where the notation
&quot;${arr[$bar]}&quot; comes handy:
&quot;/${arr[0-9]}/&quot; is interpreted as array element
&quot;-9&quot;, not as a regular expression from the
variable $arr followed by a digit, which would be the
interpretation of &quot;/$arr[0-9]/&quot;. Since voting
among different estimators may occur, the result is not
predictable.</p>

<p>The lack of processing of &quot;\&quot; creates specific
restrictions on the post-processed text. If the delimiter is
&quot;/&quot;, one cannot get the combination &quot;&quot;
into the result of this step. &quot;/&quot; will finish the
regular expression, &quot;&quot; will be stripped to
&quot;/&quot; on the previous step, and &quot;\/&quot; will
be left as is. Because &quot;/&quot; is equivalent to
&quot;&quot; inside a regular expression, this does not
matter unless the delimiter happens to be character special
to the RE engine, such as in &quot;s*foo*bar*&quot;,
&quot;m[foo]&quot;, or &quot;?foo?&quot;; or an alphanumeric
char, as in:</p>

<p>m m ^ a b mmx;</p>

<p>In the RE above, which is intentionally obfuscated for
illustration, the delimiter is &quot;m&quot;, the modifier
is &quot;mx&quot;, and after delimiter-removal the RE is the
same as for &quot;m/ ^ a b /mx&quot;. There s more than one
reason you re encouraged to restrict your delimiters to
non-alphanumeric, non-whitespace choices.</p>

<p>This step is the last one for all constructs except
regular expressions, which are processed further.</p>

<p>parsing regular expressions Previous steps were
performed during the compilation of Perl code, but this one
happens at run time--although it may be optimized to be
calculated at compile time if appropriate. After
preprocessing described above, and possibly after evaluation
if concatenation, joining, casing translation, or
metaquoting are involved, the resulting string is passed to
the RE engine for compilation.</p>

<p>Whatever happens in the RE engine might be better
discussed in perlre, but for the sake of continuity, we
shall do so here.</p>

<p>This is another step where the presence of the
&quot;//x&quot; modifier is relevant. The RE engine scans
the string from left to right and converts it to a finite
automaton.</p>

<p>Backslashed characters are either replaced with
corresponding literal strings (as with &quot;&quot;), or
else they generate special nodes ) . C h a r a c t e r s in
the finite automaton (as with &quot;s p e c i a l t o t h e
RE engine (such as &quot;|&quot;) generate corresponding
nodes or groups of nodes. &quot;(?#...)&quot; comments are
ignored. All the rest is either converted to literal strings
to match, or else is ignored (as is whitespace and
&quot;#&quot;-style comments if &quot;//x&quot; is
present).</p>

<p>Parsing of the bracketed character class construct,
&quot;[...]&quot;, is rather different than the rule used
for the rest of the pattern. The terminator of this
construct is found using the same rules as for finding the
terminator of a &quot;{}&quot;-delimited construct, the only
exception being that &quot;]&quot; immediately following
&quot;[&quot; is treated as though preceded by a backslash.
Similarly, the terminator of &quot;(?{...})&quot; is found
using the same rules as for finding the terminator of a
&quot;{}&quot;-delimited construct.</p>

<p>It is possible to inspect both the string given to RE
engine and the resulting finite automaton. See the arguments
&quot;debug&quot;/&quot;debugcolor&quot; in the &quot;use
re&quot; pragma, as well as Perls -Dr command-line switch
documented in &quot;Command Switches&quot; in perlrun.</p>

<p>Optimization of regular expressions This step is listed
for completeness only. Since it does not change semantics,
details of this step are not documented and are subject to
change without notice. This step is performed over the
finite automaton that was generated during the previous
pass.</p>

<p>It is at this stage that &quot;split()&quot; silently
optimizes &quot;/^/&quot; to mean &quot;/^/m&quot;.</p>

<p>I/O Operators There are several I/O operators you should
know about.</p>

<p>A string enclosed by backticks (grave accents) first
undergoes double- quote interpolation. It is then
interpreted as an external command, and the output of that
command is the value of the backtick string, like in a
shell. In scalar context, a single string consisting of all
output is returned. In list context, a list of values is
returned, one per line of output. (You can set $/ to use a
different line terminator.) The command is executed each
time the pseudo-literal is evaluated. The status value of
the command is returned in $? (see perlvar for the
interpretation of $?). Unlike in csh, no translation is done
on the return data--newlines remain newlines. Unlike in any
of the shells, single quotes do not hide variable names in
the command from interpretation. To pass a literal
dollar-sign through to the shell you need to hide it with a
backslash. The generalized form of backticks is
&quot;qx//&quot;. (Because backticks always undergo shell
expansion as well, see perlsec for security concerns.)</p>

<p>In scalar context, evaluating a filehandle in angle
brackets yields the next line from that file (the newline,
if any, included), or &quot;undef&quot; at end-of-file or on
error. When $/ is set to &quot;undef&quot; (sometimes known
as file-slurp mode) and the file is empty, it returns
&rsquo;&rsquo; the first time, followed by &quot;undef&quot;
subsequently.</p>

<p>Ordinarily you must assign the returned value to a
variable, but there is one situation where an automatic
assignment happens. If and only if the input symbol is the
only thing inside the conditional of a &quot;while&quot;
statement (even if disguised as a &quot;for(;;)&quot; loop),
the value is automatically assigned to the global variable
$_, destroying whatever was there previously. (This may seem
like an odd thing to you, but youll use the construct in
almost every Perl script you write.) The $_ variable is not
implicitly localized. Youll have to put a &quot;local
$_;&quot; before the loop if you want that to happen.</p>

<p>The following lines are equivalent:</p>

<p>while (defined($_ = &lt;STDIN&gt;)) { print; } while ($_
= &lt;STDIN&gt;) { print; } while (&lt;STDIN&gt;) { print; }
for (;&lt;STDIN&gt;;) { print; } print while defined($_ =
&lt;STDIN&gt;); print while ($_ = &lt;STDIN&gt;); print
while &lt;STDIN&gt;;</p>

<p>This also behaves similarly, but avoids $_ :</p>

<p>while (my $line = &lt;STDIN&gt;) { print $line }</p>

<p>In these loop constructs, the assigned value (whether
assignment is automatic or explicit) is then tested to see
whether it is defined. The defined test avoids problems
where line has a string value that would be treated as false
by Perl, for example a &quot;&quot; or a &quot;0&quot; with
no trailing newline. If you really mean for such values to
terminate the loop, they should be tested for
explicitly:</p>

<p>while (($_ = &lt;STDIN&gt;) ne &rsquo;0&rsquo;) { ... }
while (&lt;STDIN&gt;) { last unless $_; ... }</p>

<p>In other boolean contexts,
&quot;&lt;I&lt;filehandle&gt;&gt;&quot; without an explicit
&quot;defined&quot; test or comparison elicit a warning if
the &quot;use warnings&quot; pragma or the -w command-line
switch (the $^W variable) is in effect.</p>

<p>The filehandles STDIN, STDOUT, and STDERR are
predefined. (The filehandles &quot;stdin&quot;,
&quot;stdout&quot;, and &quot;stderr&quot; will also work
except in packages, where they would be interpreted as local
identifiers rather than global.) Additional filehandles may
be created with the open() function, amongst others. See
perlopentut and &quot;open&quot; in perlfunc for details on
this.</p>

<p>If a &lt;FILEHANDLE&gt; is used in a context that is
looking for a list, a list comprising all input lines is
returned, one line per list element. Its easy to grow to a
rather large data space this way, so use with care.</p>

<p>&lt;FILEHANDLE&gt; may also be spelled
&quot;readline(*FILEHANDLE)&quot;. See &quot;readline&quot;
in perlfunc.</p>

<p>The null filehandle &lt;&gt; is special: it can be used
to emulate the behavior of sed and awk. Input from &lt;&gt;
comes either from standard input, or from each file listed
on the command line. Here s how it works: the first time
&lt;&gt; is evaluated, the @ARGV array is checked, and if it
is empty, $ARGV[0] is set to &quot;-&quot;, which when
opened gives you standard input. The @ARGV array is then
processed as a list of filenames. The loop</p>

<p>while (&lt;&gt;) { ... # code for each line }</p>

<p>is equivalent to the following Perl-like pseudo
code:</p>

<p>unshift(@ARGV, &rsquo;-&rsquo;) unless @ARGV; while
($ARGV = shift) { open(ARGV, $ARGV); while (&lt;ARGV&gt;) {
... # code for each line } }</p>

<p>except that it isn t so cumbersome to say, and will
actually work. It really does shift the @ARGV array and put
the current filename into the $ARGV variable. It also uses
filehandle ARGV internally--&lt;&gt; is just a synonym for
&lt;ARGV&gt;, which is magical. (The pseudo code above
doesnt work because it treats &lt;ARGV&gt; as
non-magical.)</p>

<p>Since the null filehandle uses the two argument form of
&quot;open&quot; in perlfunc it interprets special
characters, so if you have a script like this:</p>

<p>while (&lt;&gt;) { print; }</p>

<p>and call it with &quot;perl dangerous.pl &rsquo;rm -rfv
*|&rsquo;&quot;, it actually opens a pipe, executes the
&quot;rm&quot; command and reads &quot;rm&quot; s output
from that pipe. If you want all items in @ARGV to be
interpreted as file names, you can use the module
&quot;ARGV::readonly&quot; from CPAN.</p>

<p>You can modify @ARGV before the first &lt;&gt; as long
as the array ends up containing the list of filenames you
really want. Line numbers ($.) continue as though the input
were one big happy file. See the example in &quot;eof&quot;
in perlfunc for how to reset line numbers on each file.</p>

<p>If you want to set @ARGV to your own list of files, go
right ahead. This sets @ARGV to all plain text files if no
@ARGV was given:</p>

<p>@ARGV = grep { -f &amp;&amp; -T } glob(&rsquo;*&rsquo;)
unless @ARGV;</p>

<p>You can even set them to pipe commands. For example,
this automatically filters compressed arguments through
gzip:</p>

<p>@ARGV = map { /.(gz|Z)$/ ? &quot;gzip -dc &lt; $_
|&quot; : $_ } @ARGV;</p>

<p>If you want to pass switches into your script, you can
use one of the Getopts modules or put a loop on the front
like this:</p>

<p>while ($_ = $ARGV[0], /^-/) { shift; last if /^--$/; if
(/^-D(.*)/) { $debug = $1 } if (/^-v/) { $verbose++ } # ...
# other switches }</p>

<p>while (&lt;&gt;) { # ... # code for each line }</p>

<p>The &lt;&gt; symbol will return &quot;undef&quot; for
end-of-file only once. If you call it again after this, it
will assume you are processing another @ARGV list, and if
you havent set @ARGV, will read input from STDIN.</p>

<p>If what the angle brackets contain is a simple scalar
variable (e.g., &lt;$foo&gt;), then that variable contains
the name of the filehandle to input from, or its typeglob,
or a reference to the same. For example:</p>

<p>$fh = TDIN; $line = &lt;$fh&gt;;</p>

<p>If whats within the angle brackets is neither a
filehandle nor a simple scalar variable containing a
filehandle name, typeglob, or typeglob reference, it is
interpreted as a filename pattern to be globbed, and either
a list of filenames or the next filename in the list is
returned, depending on context. This distinction is
determined on syntactic grounds alone. That means
&quot;&lt;$x&gt;&quot; is always a readline() from an
indirect handle, but &quot;&lt;$hash{key}&gt;&quot; is
always a glob(). Thats because $x is a simple scalar
variable, but $hash{key} is not--its a hash element. Even
&quot;&lt;$x &gt;&quot; (note the extra space) is treated as
&quot;glob(&quot;$x &quot;)&quot;, not
&quot;readline($x)&quot;.</p>

<p>One level of double-quote interpretation is done first,
but you cant say &quot;&lt;$foo&gt;&quot; because that s an
indirect filehandle as explained in the previous paragraph.
(In older versions of Perl, programmers would insert curly
brackets to force interpretation as a filename glob:
&quot;&lt;${foo}&gt;&quot;. These days, its considered
cleaner to call the internal function directly as
&quot;glob($foo)&quot;, which is probably the right way to
have done it in the first place.) For example:</p>

<p>while (&lt;*.c&gt;) { chmod 0644, $_; }</p>

<p>is roughly equivalent to:</p>

<p>&rsquo;\012\012\012\012&rsquo;|&quot;); open(FOO,
&quot;echo *.c | tr -s &rsquo; while (&lt;FOO&gt;) { chomp;
chmod 0644, $_; }</p>

<p>except that the globbing is actually done internally
using the standard &quot;File::Glob&quot; extension. Of
course, the shortest way to do the above is:</p>

<p>chmod 0644, &lt;*.c&gt;;</p>

<p>A (file)glob evaluates its (embedded) argument only when
it is starting a new list. All values must be read before it
will start over. In list context, this isn t important
because you automatically get them all anyway. However, in
scalar context the operator returns the next value each time
its called, or &quot;undef&quot; when the list has run out.
As with filehandle reads, an automatic &quot;defined&quot;
is generated when the glob occurs in the test part of a
&quot;while&quot;, because legal glob returns (e.g. a file
called 0) would otherwise terminate the loop. Again,
&quot;undef&quot; is returned only once. So if you re
expecting a single value from a glob, it is much better to
say</p>

<p>($file) = &lt;blurch*&gt;;</p>

<p>than</p>

<p>$file = &lt;blurch*&gt;;</p>

<p>because the latter will alternate between returning a
filename and returning false.</p>

<p>If you re trying to do variable interpolation, it s
definitely better to use the glob() function, because the
older notation can cause people to become confused with the
indirect filehandle notation.</p>

<p>@files = glob(&quot;$dir/*.[ch]&quot;); @files =
glob($files[$i]);</p>

<p>Constant Folding Like C, Perl does a certain amount of
expression evaluation at compile time whenever it determines
that all arguments to an operator are static and have no
side effects. In particular, string concatenation happens at
compile time between literals that don t do variable
substitution. Backslash interpolation also happens at
compile time. You can say</p>

<p>&rsquo;Now is the time for all&rsquo; . &quot;0 .
&rsquo;good men to come to.&rsquo;</p>

<p>and this all reduces to one string internally. Likewise,
if you say</p>

<p>foreach $file (@filenames) { if (-s $file &gt; 5 + 100 *
2**16) { } }</p>

<p>the compiler will precompute the number which that
expression represents so that the interpreter wont have
to.</p>

<p>No-ops Perl doesnt officially have a no-op operator, but
the bare constants 0 and 1 are special-cased to not produce
a warning in a void context, so you can for example safely
do</p>

<p>1 while foo();</p>

<p>Bitwise String Operators Bitstrings of any size may be
manipulated by the bitwise operators (&quot;~ | &amp;
^&quot;).</p>

<p>If the operands to a binary bitwise op are strings of
different sizes, | and ^ ops act as though the shorter
operand had additional zero bits on the right, while the
&amp; op acts as though the longer operand were truncated to
the length of the shorter. The granularity for such
extension or truncation is one or more bytes.</p>

<p># ASCII-based examples print &quot;j p 0 ^ &quot; a
h&quot;; # prints &quot;JAPH0 print &quot;JA&quot; | &quot;
ph0; # prints &quot;japh0 print &quot;japh0unk&quot; &amp;
&rsquo;_____&rsquo;; # prints &quot;JAPH0; print &rsquo;p
N$&rsquo; ^ &quot; E&lt;H0; # prints &quot;Perl0;</p>

<p>If you are intending to manipulate bitstrings, be
certain that youre supplying bitstrings: If an operand is a
number, that will imply a numeric bitwise operation. You may
explicitly show which type of operation you intend by using
&quot;&quot; or &quot;0+&quot;, as in the examples
below.</p>

<p>$foo = 150 | 105; # yields 255 (0x96 | 0x69 is 0xFF)
$foo = &rsquo;150&rsquo; | 105; # yields 255 $foo = 150 |
&rsquo;105&rsquo;; # yields 255 $foo = &rsquo;150&rsquo; |
&rsquo;105&rsquo;; # yields string &rsquo;155&rsquo; (under
ASCII)</p>

<p>$baz = 0+$foo &amp; 0+$bar; # both ops explicitly
numeric $biz = &quot;$foo&quot; ^ &quot;$bar&quot;; # both
ops explicitly stringy</p>

<p>See &quot;vec&quot; in perlfunc for information on how
to manipulate individual bits in a bit vector.</p>

<p>Integer Arithmetic By default, Perl assumes that it must
do most of its arithmetic in floating point. But by
saying</p>

<p>use integer;</p>

<p>you may tell the compiler that its okay to use integer
operations (if it feels like it) from here to the end of the
enclosing BLOCK. An inner BLOCK may countermand this by
saying</p>

<p>no integer;</p>

<p>which lasts until the end of that BLOCK. Note that this
doesnt mean everything is only an integer, merely that Perl
may use integer operations if it is so inclined. For
example, even under &quot;use integer&quot;, if you take the
sqrt(2), you ll still get 1.4142135623731 or so.</p>

<p>Used on numbers, the bitwise operators
(&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;,
&quot;~&quot;, &quot;&lt;&lt;&quot;, and
&quot;&gt;&gt;&quot;) always produce integral results. (But
see also &quot;Bitwise String Operators&quot;.) However,
&quot;use integer&quot; still has meaning for them. By
default, their results are interpreted as unsigned integers,
but if &quot;use integer&quot; is in effect, their results
are interpreted as signed integers. For example,
&quot;~0&quot; usually evaluates to a large integral value.
However, &quot;use integer; ~0&quot; is &quot;-1&quot; on
two s-complement machines.</p>

<p>Floating-point Arithmetic While &quot;use integer&quot;
provides integer-only arithmetic, there is no analogous
mechanism to provide automatic rounding or truncation to a
certain number of decimal places. For rounding to a certain
number of digits, sprintf() or printf() is usually the
easiest route. See perlfaq4.</p>

<p>Floating-point numbers are only approximations to what a
mathematician would call real numbers. There are infinitely
more reals than floats, so some corners must be cut. For
example:</p>

<p>printf &quot;%.20g0, 123456789123456789; # produces
123456789123456784</p>

<p>Testing for exact equality of floating-point equality or
inequality is not a good idea. Here s a (relatively
expensive) work-around to compare whether two floating-point
numbers are equal to a particular number of decimal places.
See Knuth, volume II, for a more robust treatment of this
topic.</p>

<p>sub fp_equal { my ($X, $Y, $POINTS) = @_; my ($tX, $tY);
$tX = sprintf(&quot;%.${POINTS}g&quot;, $X); $tY =
sprintf(&quot;%.${POINTS}g&quot;, $Y); return $tX eq $tY;
}</p>

<p>The POSIX module (part of the standard perl
distribution) implements ceil(), floor(), and other
mathematical and trigonometric functions. The Math::Complex
module (part of the standard perl distribution) defines
mathematical functions that work on both the reals and the
imaginary numbers. Math::Complex not as efficient as POSIX,
but POSIX cant work with complex numbers.</p>

<p>Rounding in financial applications can have serious
implications, and the rounding method used should be
specified precisely. In these cases, it probably pays not to
trust whichever system rounding is being used by Perl, but
to instead implement the rounding function you need
yourself.</p>

<p>Bigger Numbers The standard Math::BigInt and
Math::BigFloat modules provide variable- precision
arithmetic and overloaded operators, although theyre
currently pretty slow. At the cost of some space and
considerable speed, they avoid the normal pitfalls
associated with limited-precision representations.</p>

<p>use Math::BigInt; $x =
Math::BigInt-&gt;new(&rsquo;123456789123456789&rsquo;);
print $x * $x;</p>

<p># prints +15241578780673678515622620750190521</p>

<p>There are several modules that let you calculate with
(bound only by memory and cpu-time) unlimited or fixed
precision. There are also some non-standard modules that
provide faster implementations via external C libraries.</p>

<p>Here is a short, but incomplete summary:</p>

<p>Math::Fraction big, unlimited fractions like 9973 /
12967 Math::String treat string sequences like numbers
Math::FixedPrecision calculate with a fixed precision
Math::Currency for currency calculations Bit::Vector
manipulate bit vectors fast (uses C) Math::BigIntFast
Bit::Vector wrapper for big numbers Math::Pari provides
access to the Pari C library Math::BigInteger uses an
external C library Math::Cephes uses external Cephes C
library (no big numbers) Math::Cephes::Fraction fractions
via the Cephes library Math::GMP another one using an
external C library</p>

<p>Choose wisely.</p>

<p>perl v5.10.1 2009-08-11 PERLOP(1)</p>
<hr>
</body>
</html>
