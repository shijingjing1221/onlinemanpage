<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:49:56 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ZSHMISC(1) ZSHMISC(1)</p>

<p>NAME zshmisc - everything and then some</p>

<p>SIMPLE COMMANDS &amp; PIPELINES A simple command is a
sequence of optional parameter assignments fol- lowed by
blank-separated words, with optional redirections inter-
spersed. The first word is the command to be executed, and
the remain- ing words, if any, are arguments to the command.
If a command name is given, the parameter assignments modify
the environment of the command when it is executed. The
value of a simple command is its exit status, or 128 plus
the signal number if terminated by a signal. For
example,</p>

<p>echo foo</p>

<p>is a simple command with arguments.</p>

<p>A pipeline is either a simple command, or a sequence of
two or more simple commands where each command is separated
from the next by | or |&amp; . Where commands are separated
by |, the standard output of the first command is connected
to the standard input of the next. |&amp; is shorthand for
2&gt;&amp;1 |, which connects both the standard output and
the standard error of the command to the standard input of
the next. The value of a pipeline is the value of the last
command, unless the pipeline is preceded by ! in which case
the value is the logical inverse of the value of the last
command. For example,</p>

<p>echo foo | seds/foo/bar/</p>

<p>is a pipeline, where the output (foo plus a newline) of
the first command will be passed to the input of the
second.</p>

<p>If a pipeline is preceded by coproc, it is executed as a
coprocess; a two-way pipe is established between it and the
parent shell. The shell can read from or write to the
coprocess by means of the &gt;&amp;p and &lt;&amp;p
redirection operators or with print -p and read -p. A
pipeline cannot be preceded by both coproc and !. If job
control is active, the coprocess can be treated in other
than input and output as an ordi- nary background job.</p>

<p>A sublist is either a single pipeline, or a sequence of
two or more pipelines separated by &amp;&amp; or ||. If two
pipelines are separated by &amp;&amp;, the second pipeline
is executed only if the first succeeds (returns a zero
status). If two pipelines are separated by ||, the second is
executed only if the first fails (returns a nonzero status).
Both operators have equal precedence and are left
associative. The value of the sublist is the value of the
last pipeline executed. For example,</p>

<p>dmesg | grep panic &amp;&amp; print yes</p>

<p>is a sublist consisting of two pipelines, the second
just a simple com- mand which will be executed if and only
if the grep command returns a zero status. If it does not,
the value of the sublist is that return status, else it is
the status returned by the print (almost certainly
zero).</p>

<p>A list is a sequence of zero or more sublists, in which
each sublist is terminated by ;, &amp;, &amp;|, &amp;!, or a
newline. This terminator may optionally be omitted from the
last sublist in the list when the list appears as a complex
command inside (...) or {...}. When a sublist is terminated
by ; or newline, the shell waits for it to finish before
executing the next sublist. If a sublist is terminated by a
&amp;, &amp;|, or &amp;!, the shell executes the last
pipeline in it in the background, and does not wait for it
to finish (note the difference from other shells which
execute the whole sublist in the background). A backgrounded
pipeline returns a status of zero.</p>

<p>More generally, a list can be seen as a set of any shell
commands what- soever, including the complex commands below;
this is implied wherever the word list appears in later
descriptions. For example, the com- mands in a shell
function form a special sort of list.</p>

<p>PRECOMMAND MODIFIERS A simple command may be preceded by
a precommand modifier, which will alter how the command is
interpreted. These modifiers are shell builtin commands with
the exception of nocorrect which is a reserved word.</p>

<p>- The command is executed with a - prepended to its
argv[0] string.</p>

<p>builtin The command word is taken to be the name of a
builtin command, rather than a shell function or external
command.</p>

<p>command [ -pvV ] The command word is taken to be the
name of an external command, rather than a shell function or
builtin. If the POSIX_BUILTINS option is set, builtins will
also be executed but certain spe- cial properties of them
are suppressed. The -p flag causes a default path to be
searched instead of that in $path. With the -v flag, command
is similar to whence and with -V, it is equiva- lent to
whence -v.</p>

<p>exec [ -cl ] [ -a argv0 ] The following command together
with any arguments is run in place of the current process,
rather than as a sub-process. The shell does not fork and is
replaced. The shell does not invoke TRAPEXIT, nor does it
source zlogout files. The options are provided for
compatibility with other shells.</p>

<p>The -c option clears the environment.</p>

<p>The -l option is equivalent to the - precommand
modifier, to treat the replacement command as a login shell;
the command is executed with a - prepended to its argv[0]
string. This flag has no effect if used together with the -a
option.</p>

<p>The -a option is used to specify explicitly the argv[0]
string (the name of the command as seen by the process
itself) to be used by the replacement command and is
directly equivalent to setting a value for the ARGV0
environment variable.</p>

<p>nocorrect Spelling correction is not done on any of the
words. This must appear before any other precommand
modifier, as it is inter- preted immediately, before any
parsing is done. It has no effect in non-interactive
shells.</p>

<p>noglob Filename generation (globbing) is not performed
on any of the words.</p>

<p>COMPLEX COMMANDS A complex command in zsh is one of the
following:</p>

<p>if list then list [ elif list then list ] ... [ else
list ] fi The if list is executed, and if it returns a zero
exit status, the then list is executed. Otherwise, the elif
list is executed and if its status is zero, the then list is
executed. If each elif list returns nonzero status, the else
list is executed.</p>

<p>for name ... [ in word ... ] term do list done where
term is at least one newline or ;. Expand the list of words,
and set the parameter name to each of them in turn, exe-
cuting list each time. If the in word is omitted, use the
posi- tional parameters instead of the words.</p>

<p>More than one parameter name can appear before the list
of words. If N names are given, then on each execution of
the loop the next N words are assigned to the corresponding
parameters. If there are more names than remaining words,
the remaining parameters are each set to the empty string.
Execution of the loop ends when there is no remaining word
to assign to the first name. It is only possible for in to
appear as the first name in the list, else it will be
treated as marking the end of the list.</p>

<p>for (( [expr1] ; [expr2] ; [expr3] )) do list done The
arithmetic expression expr1 is evaluated first (see the sec-
tion Arithmetic Evaluation ). The arithmetic expression
expr2 is repeatedly evaluated until it evaluates to zero and
when non-zero, list is executed and the arithmetic
expression expr3 evaluated. If any expression is omitted,
then it behaves as if it evaluated to 1.</p>

<p>while list do list done Execute the do list as long as
the while list returns a zero exit status.</p>

<p>until list do list done Execute the do list as long as
until list returns a nonzero exit status.</p>

<p>repeat word do list done word is expanded and treated as
an arithmetic expression, which must evaluate to a number n.
list is then executed n times.</p>

<p>The repeat syntax is disabled by default when the shell
starts in a mode emulating another shell. It can be enabled
with the command enable -r repeat</p>

<p>case word in [ [(] pattern [ | pattern ] ... ) list
(;;|;&amp;|;|) ] ... esac Execute the list associated with
the first pattern that matches word, if any. The form of the
patterns is the same as that used for filename generation.
See the section Filename Generation.</p>

<p>If the list that is executed is terminated with ;&amp;
rather than ;;, the following list is also executed. The
rule for the ter- minator of the following list ;;, ;&amp;
or ;| is applied unless the esac is reached.</p>

<p>If the list that is executed is terminated with ;| the
shell continues to scan the patterns looking for the next
match, exe- cuting the corresponding list, and applying the
rule for the corresponding terminator ;;, ;&amp; or ;|. Note
that word is not re-expanded; all applicable patterns are
tested with the same word.</p>

<p>select name [ in word ... term ] do list done where term
is one or more newline or ; to terminate the words. Print
the set of words, each preceded by a number. If the in word
is omitted, use the positional parameters. The PROMPT3
prompt is printed and a line is read from the line editor if
the shell is interactive and that is active, or else
standard input. If this line consists of the number of one
of the listed words, then the parameter name is set to the
word corresponding to this number. If this line is empty,
the selection list is printed again. Otherwise, the value of
the parameter name is set to null. The contents of the line
read from standard input is saved in the parameter REPLY.
list is executed for each selec- tion until a break or
end-of-file is encountered.</p>

<p>( list ) Execute list in a subshell. Traps set by the
trap builtin are reset to their default values while
executing list.</p>

<p>{ list } Execute list.</p>

<p>{ try-list } always { always-list } First execute
try-list. Regardless of errors, or break, con- tinue, or
return commands encountered within try-list, execute
always-list. Execution then continues from the result of the
execution of try-list; in other words, any error, or break,
con- tinue, or return command is treated in the normal way,
as if always-list were not present. The two chunks of code
are referred to as the try block and the always block .</p>

<p>Optional newlines or semicolons may appear after the
always; note, however, that they may not appear between the
preceding closing brace and the always.</p>

<p>An error in this context is a condition such as a syntax
error which causes the shell to abort execution of the
current func- tion, script, or list. Syntax errors
encountered while the shell is parsing the code do not cause
the always-list to be executed. For example, an erroneously
constructed if block in try-list would cause the shell to
abort during parsing, so that always-list would not be
executed, while an erroneous substitu- tion such as ${*foo*}
would cause a run-time error, after which always-list would
be executed.</p>

<p>An error condition can be tested and reset with the
special integer variable TRY_BLOCK_ERROR. Outside an
always-list the value is irrelevant, but it is initialised
to -1. Inside always-list, the value is 1 if an error
occurred in the try-list, else 0. If TRY_BLOCK_ERROR is set
to 0 during the always-list, the error condition caused by
the try-list is reset, and shell execution continues
normally after the end of always-list. Altering the value
during the try-list is not use- ful (unless this forms part
of an enclosing always block).</p>

<p>Regardless of TRY_BLOCK_ERROR, after the end of
always-list the normal shell status $? is the value returned
from always-list. This will be non-zero if there was an
error, even if TRY_BLOCK_ERROR was set to zero.</p>

<p>The following executes the given code, ignoring any
errors it causes. This is an alternative to the usual
convention of pro- tecting code by executing it in a
subshell.</p>

<p>{ # code which may cause an error } always { # This code
is executed regardless of the error. (( TRY_BLOCK_ERROR = 0
)) } # The error condition has been reset.</p>

<p>An exit command (or a return command executed at the
outermost function level of a script) encountered in
try-list does not cause the execution of always-list.
Instead, the shell exits immediately after any EXIT trap has
been executed.</p>

<p>function word ... [ () ] [ term ] { list } word ... () [
term ] { list } word ... () [ term ] command where term is
one or more newline or ;. Define a function which is
referenced by any one of word. Normally, only one word is
provided; multiple words are usually only useful for setting
traps. The body of the function is the list between the {
and }. See the section Functions.</p>

<p>If the option SH_GLOB is set for compatibility with
other shells, then whitespace may appear between between the
left and right parentheses when there is a single word;
otherwise, the parentheses will be treated as forming a
globbing pattern in that case.</p>

<p>time [ pipeline ] The pipeline is executed, and timing
statistics are reported on the standard error in the form
specified by the TIMEFMT parame- ter. If pipeline is
omitted, print statistics about the shell process and its
children.</p>

<p>[[ exp ]] Evaluates the conditional expression exp and
return a zero exit status if it is true. See the section
Conditional Expressions for a description of exp.</p>

<p>ALTERNATE FORMS FOR COMPLEX COMMANDS Many of zshs
complex commands have alternate forms. These are
non-standard and are likely not to be obvious even to
seasoned shell programmers; they should not be used anywhere
that portability of shell code is a concern.</p>

<p>The short versions below only work if sublist is of the
form { list } or if the SHORT_LOOPS option is set. For the
if, while and until com- mands, in both these cases the test
part of the loop must also be suit- ably delimited, such as
by [[ ... ]] or (( ... )), else the end of the test will not
be recognized. For the for, repeat, case and select commands
no such special form for the arguments is necessary, but the
other condition (the special form of sublist or use of the
SHORT_LOOPS option) still applies.</p>

<p>if list { list } [ elif list { list } ] ... [ else {
list } ] An alternate form of if. The rules mean that</p>

<p>if [[ -o ignorebraces ]] { print yes }</p>

<p>works, but</p>

<p>if true { # Does not work! print yes }</p>

<p>does not, since the test is not suitably delimited.</p>

<p>if list sublist A short form of the alternate if . The
same limitations on the form of list apply as for the
previous form.</p>

<p>for name ... ( word ... ) sublist A short form of
for.</p>

<p>for name ... [ in word ... ] term sublist where term is
at least one newline or ;. Another short form of for.</p>

<p>for (( [expr1] ; [expr2] ; [expr3] )) sublist A short
form of the arithmetic for command.</p>

<p>foreach name ... ( word ... ) list end Another form of
for.</p>

<p>while list { list } An alternative form of while. Note
the limitations on the form of list mentioned above.</p>

<p>until list { list } An alternative form of until. Note
the limitations on the form of list mentioned above.</p>

<p>repeat word sublist This is a short form of repeat.</p>

<p>case word { [ [(] pattern [ | pattern ] ... ) list
(;;|;&amp;|;|) ] ... } An alternative form of case.</p>

<p>select name [ in word term ] sublist where term is at
least one newline or ;. A short form of select.</p>

<p>RESERVED WORDS The following words are recognized as
reserved words when used as the first word of a command
unless quoted or disabled using disable -r:</p>

<p>do done esac then elif else fi for case if while
function repeat time until select coproc nocorrect foreach
end ! [[ { }</p>

<p>Additionally, } is recognized in any position if the
IGNORE_BRACES option is not set.</p>

<p>COMMENTS In non-interactive shells, or in interactive
shells with the INTERAC- TIVE_COMMENTS option set, a word
beginning with the third character of the histchars
parameter (# by default) causes that word and all the
following characters up to a newline to be ignored.</p>

<p>ALIASING Every token in the shell input is checked to
see if there is an alias defined for it. If so, it is
replaced by the text of the alias if it is in command
position (if it could be the first word of a simple com-
mand), or if the alias is global. If the text ends with a
space, the next word in the shell input is treated as though
it were in command position for purposes of alias expansion.
An alias is defined using the alias builtin; global aliases
may be defined using the -g option to that builtin.</p>

<p>Alias expansion is done on the shell input before any
other expansion except history expansion. Therefore, if an
alias is defined for the word foo, alias expansion may be
avoided by quoting part of the word, e.g. foo. Any form of
quoting works, although there is nothing to prevent an alias
being defined for the quoted form such as foo as well. For
use with completion, which would remove an initial backslash
followed by a character that isnt special, it may be more
convenient to quote the word by starting with a single
quote, i.e. foo; comple- tion will automatically add the
trailing single quote.</p>

<p>There is a commonly encountered problem with aliases
illustrated by the following code:</p>

<p>alias echobarecho ba; echobar</p>

<p>This prints a message that the command echobar could not
be found. This happens because aliases are expanded when the
code is read in; the entire line is read in one go, so that
when echobar is executed it is too late to expand the newly
defined alias. This is often a problem in shell scripts,
functions, and code executed with source or .. Con-
sequently, use of functions rather than aliases is
recommended in non-interactive code.</p>

<p>Note also the unhelpful interaction of aliases and
function defini- tions:</p>

<p>alias funcnoglob func func() { echo Do something with $*
}</p>

<p>Because aliases are expanded in function defintions,
this causes the following command to be executed:</p>

<p>noglob func() { echo Do something with $* }</p>

<p>which defines noglob as well as func as functions with
the body given. To avoid this, either quote the name func or
use the alternative func- tion definition form function
func. Ensuring the alias is defined after the function works
but is problematic if the code fragment might be
re-executed.</p>

<p>QUOTING A character may be quoted (that is, made to
stand for itself) by pre- ceding it with a. followed by a
newline is ignored.</p>

<p>A string enclosed between $and is processed the same way
as the string arguments of the print builtin, and the
resulting string is con- sidered to be entirely quoted. A
literal character can be included in the string by using
theescape.</p>

<p>All characters enclosed between a pair of single quotes
( ) that is not preceded by a $ are quoted. A single quote
cannot appear within single quotes unless the option
RC_QUOTES is set, in which case a pair of single quotes are
turned into a single quote. For example,</p>

<p>print</p>

<p>outputs nothing apart from a newline if RC_QUOTES is not
set, but one single quote if it is set.</p>

<p>Inside double quotes (&quot;&quot;), parameter and
command substitution occur, and quotes the characters,,
&quot;, and $.</p>

<p>REDIRECTION If a command is followed by &amp; and job
control is not active, then the default standard input for
the command is the empty file /dev/null. Otherwise, the
environment for the execution of a command contains the file
descriptors of the invoking shell as modified by
input/output specifications.</p>

<p>The following may appear anywhere in a simple command or
may precede or follow a complex command. Expansion occurs
before word or digit is used except as noted below. If the
result of substitution on word pro- duces more than one
filename, redirection occurs for each separate filename in
turn.</p>

<p>&lt; word Open file word for reading as standard
input.</p>

<p>&lt;&gt; word Open file word for reading and writing as
standard input. If the file does not exist then it is
created.</p>

<p>&gt; word Open file word for writing as standard output.
If the file does not exist then it is created. If the file
exists, and the CLOB- BER option is unset, this causes an
error; otherwise, it is truncated to zero length.</p>

<p>&gt;| word &gt;! word Same as &gt;, except that the file
is truncated to zero length if it exists, even if CLOBBER is
unset.</p>

<p>&gt;&gt; word Open file word for writing in append mode
as standard output. If the file does not exist, and the
CLOBBER option is unset, this causes an error; otherwise,
the file is created.</p>

<p>&gt;&gt;| word &gt;&gt;! word Same as &gt;&gt;, except
that the file is created if it does not exist, even if
CLOBBER is unset.</p>

<p>&lt;&lt;[-] word The shell input is read up to a line
that is the same as word, or to an end-of-file. No parameter
expansion, command substitu- tion or filename generation is
performed on word. The resulting document, called a
here-document, becomes the standard input.</p>

<p>If any character of word is quoted with single or double
quotes or a , no interpretation is placed upon the
characters of the document. Otherwise, parameter and command
substitution occurs, followed by a newline is removed, and
must be used to quote the characters , $, and the first
character of word.</p>

<p>Note that word itself does not undergo shell expansion.
Back- quotes in word do not have their usual effect; instead
they behave similarly to double quotes, except that the
backquotes themselves are passed through unchanged. (This
information is given for completeness and it is not
recommended that backquotes be used.) Quotes in the form
$...have their standard effect of expanding backslashed
references to special characters.</p>

<p>If &lt;&lt;- is used, then all leading tabs are stripped
from word and from the document.</p>

<p>&lt;&lt;&lt; word Perform shell expansion on word and
pass the result to standard input. This is known as a
here-string. Compare the use of word in here-documents
above, where word does not undergo shell expansion.</p>

<p>&lt;&amp; number &gt;&amp; number The standard
input/output is duplicated from file descriptor number (see
dup2(2)).</p>

<p>&lt;&amp; - &gt;&amp; - Close the standard
input/output.</p>

<p>&lt;&amp; p &gt;&amp; p The input/output from/to the
coprocess is moved to the standard input/output.</p>

<p>&gt;&amp; word &amp;&gt; word (Except where &gt;&amp;
word matches one of the above syntaxes; &amp;&gt; can always
be used to avoid this ambiguity.) Redirects both standard
output and standard error (file descriptor 2) in the manner
of &gt; word. Note that this does not have the same effect
as &gt; word 2&gt;&amp;1 in the presence of multios (see the
sec- tion below).</p>

<p>&gt;&amp;| word &gt;&amp;! word &amp;&gt;| word
&amp;&gt;! word Redirects both standard output and standard
error (file descrip- tor 2) in the manner of &gt;| word.</p>

<p>&gt;&gt;&amp; word &amp;&gt;&gt; word Redirects both
standard output and standard error (file descrip- tor 2) in
the manner of &gt;&gt; word.</p>

<p>&gt;&gt;&amp;| word &gt;&gt;&amp;! word &amp;&gt;&gt;|
word &amp;&gt;&gt;! word Redirects both standard output and
standard error (file descrip- tor 2) in the manner of
&gt;&gt;| word.</p>

<p>If one of the above is preceded by a digit, then the
file descriptor referred to is that specified by the digit
instead of the default 0 or 1. The order in which
redirections are specified is significant. The shell
evaluates each redirection in terms of the (file descriptor,
file) association at the time of evaluation. For
example:</p>

<p>... 1&gt;fname 2&gt;&amp;1</p>

<p>first associates file descriptor 1 with file fname. It
then associates file descriptor 2 with the file associated
with file descriptor 1 (that is, fname). If the order of
redirections were reversed, file descrip- tor 2 would be
associated with the terminal (assuming file descriptor 1 had
been) and then file descriptor 1 would be associated with
file fname.</p>

<p>If instead of a digit one of the operators above is
preceded by a valid identifier enclosed in braces, the shell
will open a new file descrip- tor that is guaranteed to be
at least 10 and set the parameter named by the identifier to
the file descriptor opened. No whitespace is allowed between
the closing brace and the redirection character. The option
IGNORE_BRACES must not be set. For example:</p>

<p>... {myfd}&gt;&amp;1</p>

<p>This opens a new file descriptor that is a duplicate of
file descriptor 1 and sets the parameter myfd to the number
of the file descriptor, which will be at least 10. The new
file descriptor can be written to using the syntax
&gt;&amp;$myfd.</p>

<p>The syntax {varid}&gt;&amp;-, for example
{myfd}&gt;&amp;-, may be used to close a file descriptor
opened in this fashion. Note that the parameter given by
varid must previously be set to a file descriptor in this
case.</p>

<p>It is an error to open or close a file descriptor in
this fashion when the parameter is readonly. However, it is
not an error to read or write a file descriptor using
&lt;&amp;$param or &gt;&amp;$param if param is read-
only.</p>

<p>If the option CLOBBER is unset, it is an error to open a
file descrip- tor using a parameter that is already set to
an open file descriptor previously allocated by this
mechanism. Unsetting the parameter before using it for
allocating a file descriptor avoids the error.</p>

<p>Note that this mechanism merely allocates or closes a
file descriptor; it does not perform any redirections from
or to it. It is usually con- venient to allocate a file
descriptor prior to use as an argument to exec. The
following shows a typical sequence of allocation, use, and
closing of a file descriptor:</p>

<p>integer myfd exec {myfd}&gt;~/logs/mylogfile.txt print
This is a log message. &gt;&amp;$myfd exec
{myfd}&gt;&amp;-</p>

<p>Note that the expansion of the variable in the
expression &gt;&amp;$myfd occurs at the point the
redirection is opened. This is after the expansion of
command arguments and after any redirections to the left on
the command line have been processed.</p>

<p>The |&amp; command separator described in Simple
Commands &amp; Pipelines in zshmisc(1) is a shorthand for
2&gt;&amp;1 |.</p>

<p>The various forms of process substitution, &lt;(list),
and =(list()) for input and &gt;(list) for output, are often
used together with redi- rection. For example, if word in an
output redirection is of the form &gt;(list) then the output
is piped to the command represented by list. See Process
Substitution in zshexpn(1).</p>

<p>MULTIOS If the user tries to open a file descriptor for
writing more than once, the shell opens the file descriptor
as a pipe to a process that copies its input to all the
specified outputs, similar to tee, provided the MULTIOS
option is set, as it is by default. Thus:</p>

<p>date &gt;foo &gt;bar</p>

<p>writes the date to two files, named foo and bar . Note
that a pipe is an implicit redirection; thus</p>

<p>date &gt;foo | cat</p>

<p>writes the date to the file foo, and also pipes it to
cat.</p>

<p>If the MULTIOS option is set, the word after a
redirection operator is also subjected to filename
generation (globbing). Thus</p>

<p>: &gt; *</p>

<p>will truncate all files in the current directory,
assuming theres at least one. (Without the MULTIOS option,
it would create an empty file called *.) Similarly, you can
do</p>

<p>echo exit 0 &gt;&gt; *.sh</p>

<p>If the user tries to open a file descriptor for reading
more than once, the shell opens the file descriptor as a
pipe to a process that copies all the specified inputs to
its output in the order specified, similar to cat, provided
the MULTIOS option is set. Thus</p>

<p>sort &lt;foo &lt;fubar</p>

<p>or even</p>

<p>sort &lt;f{oo,ubar}</p>

<p>is equivalent to cat foo fubar | sort.</p>

<p>Expansion of the redirection argument occurs at the
point the redirec- tion is opened, at the point described
above for the expansion of the variable in
&gt;&amp;$myfd.</p>

<p>Note that a pipe is an implicit redirection; thus</p>

<p>cat bar | sort &lt;foo</p>

<p>is equivalent to cat bar foo | sort (note the order of
the inputs).</p>

<p>If the MULTIOS option is unset, each redirection
replaces the previous redirection for that file descriptor.
However, all files redirected to are actually opened, so</p>

<p>echo foo &gt; bar &gt; baz</p>

<p>when MULTIOS is unset will truncate bar, and write foo
into baz.</p>

<p>There is a problem when an output multio is attached to
an external program. A simple example shows this:</p>

<p>cat file &gt;file1 &gt;file2 cat file1 file2</p>

<p>Here, it is possible that the second cat will not
display the full contents of file1 and file2 (i.e. the
original contents of file repeated twice).</p>

<p>The reason for this is that the multios are spawned
after the cat pro- cess is forked from the parent shell, so
the parent shell does not wait for the multios to finish
writing data. This means the command as shown can exit
before file1 and file2 are completely written. As a
workaround, it is possible to run the cat process as part of
a job in the current shell:</p>

<p>{ cat file } &gt;file &gt;file2</p>

<p>Here, the {...} job will pause to wait for both files to
be written.</p>

<p>REDIRECTIONS WITH NO COMMAND When a simple command
consists of one or more redirection operators and zero or
more parameter assignments, but no command name, zsh can
behave in several ways.</p>

<p>If the parameter NULLCMD is not set or the option
CSH_NULLCMD is set, an error is caused. This is the csh
behavior and CSH_NULLCMD is set by default when emulating
csh.</p>

<p>If the option SH_NULLCMD is set, the builtin : is
inserted as a com- mand with the given redirections. This is
the default when emulating sh or ksh.</p>

<p>Otherwise, if the parameter NULLCMD is set, its value
will be used as a command with the given redirections. If
both NULLCMD and READNULLCMD are set, then the value of the
latter will be used instead of that of the former when the
redirection is an input. The default for NULLCMD is cat and
for READNULLCMD is more. Thus</p>

<p>&lt; file</p>

<p>shows the contents of file on standard output, with
paging if that is a terminal. NULLCMD and READNULLCMD may
refer to shell functions.</p>

<p>COMMAND EXECUTION If a command name contains no slashes,
the shell attempts to locate it. If there exists a shell
function by that name, the function is invoked as described
in the section Functions . If there exists a shell builtin
by that name, the builtin is invoked.</p>

<p>Otherwise, the shell searches each element of $path for
a directory containing an executable file by that name. If
the search is unsuc- cessful, the shell prints an error
message and returns a nonzero exit status.</p>

<p>If execution fails because the file is not in executable
format, and the file is not a directory, it is assumed to be
a shell script. /bin/sh is spawned to execute it. If the
program is a file beginning with #!, the remainder of the
first line specifies an interpreter for the program. The
shell will execute the specified interpreter on oper- ating
systems that do not handle this executable format in the
kernel.</p>

<p>If no external command is found but a function
command_not_found_han- dler exists the shell executes this
function with all command line arguments. The function
should return status zero if it successfully handled the
command, or non-zero status if it failed. In the latter case
the standard handling is applied: command not found is
printed to standard error and the shell exits with status
127. Note that the handler is executed in a subshell forked
to execute an external com- mand, hence changes to
directories, shell parameters, etc. have no effect on the
main shell.</p>

<p>FUNCTIONS Shell functions are defined with the function
reserved word or the spe- cial syntax funcname (). Shell
functions are read in and stored internally. Alias names are
resolved when the function is read. Func- tions are executed
like commands with the arguments passed as posi- tional
parameters. (See the section Command Execution.)</p>

<p>Functions execute in the same process as the caller and
share all files and present working directory with the
caller. A trap on EXIT set inside a function is executed
after the function completes in the envi- ronment of the
caller.</p>

<p>The return builtin is used to return from function
calls.</p>

<p>Function identifiers can be listed with the functions
builtin. Func- tions can be undefined with the unfunction
builtin.</p>

<p>AUTOLOADING FUNCTIONS A function can be marked as
undefined using the autoload builtin (or functions -u or
typeset -fu). Such a function has no body. When the function
is first executed, the shell searches for its definition
using the elements of the fpath variable. Thus to define
functions for autoloading, a typical sequence is:</p>

<p>fpath=(~/myfuncs $fpath) autoload myfunc1 myfunc2
...</p>

<p>The usual alias expansion during reading will be
suppressed if the autoload builtin or its equivalent is
given the option -U. This is rec- ommended for the use of
functions supplied with the zsh distribution. Note that for
functions precompiled with the zcompile builtin command the
flag -U must be provided when the .zwc file is created, as
the cor- responding information is compiled into the
latter.</p>

<p>For each element in fpath, the shell looks for three
possible files, the newest of which is used to load the
definition for the function:</p>

<p>element.zwc A file created with the zcompile builtin
command, which is expected to contain the definitions for
all functions in the directory named element. The file is
treated in the same manner as a directory containing files
for functions and is searched for the definition of the
function. If the definition is not found, the search for a
definition proceeds with the other two possibilities
described below.</p>

<p>If element already includes a .zwc extension (i.e. the
extension was explicitly given by the user), element is
searched for the definition of the function without
comparing its age to that of other files; in fact, there
does not need to be any directory named element without the
suffix. Thus including an element such as
/usr/local/funcs.zwc in fpath will speed up the search for
functions, with the disadvantage that functions included
must be explicitly recompiled by hand before the shell
notices any changes.</p>

<p>element/function.zwc A file created with zcompile, which
is expected to contain the definition for function. It may
include other function defini- tions as well, but those are
neither loaded nor executed; a file found in this way is
searched only for the definition of func- tion.</p>

<p>element/function A file of zsh command text, taken to be
the definition for func- tion.</p>

<p>In summary, the order of searching is, first, in the
parents of direc- tories in fpath for the newer of either a
compiled directory or a directory in fpath; second, if more
than one of these contains a defi- nition for the function
that is sought, the leftmost in the fpath is chosen; and
third, within a directory, the newer of either a compiled
function or an ordinary function definition is used.</p>

<p>If the KSH_AUTOLOAD option is set, or the file contains
only a simple definition of the function, the file s
contents will be executed. This will normally define the
function in question, but may also perform initialization,
which is executed in the context of the function execu-
tion, and may therefore define local parameters. It is an
error if the function is not defined by loading the
file.</p>

<p>Otherwise, the function body (with no surrounding
funcname() {...}) is taken to be the complete contents of
the file. This form allows the file to be used directly as
an executable shell script. If processing of the file
results in the function being re-defined, the function
itself is not re-executed. To force the shell to perform
initializa- tion and then call the function defined, the
file should contain ini- tialization code (which will be
executed then discarded) in addition to a complete function
definition (which will be retained for subsequent calls to
the function), and a call to the shell function, including
any arguments, at the end.</p>

<p>For example, suppose the autoload file func contains</p>

<p>func() { print This is func; } print func is
initialized</p>

<p>then func; func with KSH_AUTOLOAD set will produce both
messages on the first call, but only the message This is
func on the second and subsequent calls. Without
KSH_AUTOLOAD set, it will produce the ini- tialization
message on the first call, and the other message on the
second and subsequent calls.</p>

<p>It is also possible to create a function that is not
marked as autoloaded, but which loads its own definition by
searching fpath, by using autoload -X within a shell
function. For example, the follow- ing are equivalent:</p>

<p>myfunc() { autoload -X } myfunc args...</p>

<p>and</p>

<p>unfunction myfunc # if myfunc was defined autoload
myfunc myfunc args...</p>

<p>In fact, the functions command outputs builtin autoload
-X as the body of an autoloaded function. This is done so
that</p>

<p>eval &quot;$(functions)&quot;</p>

<p>produces a reasonable result. A true autoloaded function
can be iden- tified by the presence of the comment #
undefined in the body, because all comments are discarded
from defined functions.</p>

<p>To load the definition of an autoloaded function myfunc
without execut- ing myfunc, use:</p>

<p>autoload +X myfunc</p>

<p>ANONYMOUS FUNCTIONS If no name is given for a function,
it is anonymous and is handled specially. Either form of
function definition may be used: a () with no preceding
name, or a function with an immediately following open
brace. The function is executed immediately at the point of
definition and is not stored for future use. The function
name is set to (anon) and the parameter list passed to the
function is empty. Note that this means the argument list of
any enclosing script or function is hidden. Redirections may
be applied to the anonymous function in the same man- ner as
to a current-shell structure enclosed in braces. The main
use of anonymous functions is to provide a scope for local
variables. This is particularly convenient in start-up files
as these do not provide their own local variable scope.</p>

<p>For example,</p>

<p>variable=outside function { local variable=inside print
&quot;I am $variable&quot; } print &quot;I am
$variable&quot;</p>

<p>outputs the following:</p>

<p>I am inside I am outside</p>

<p>Note that function definitions with arguments that
expand to nothing, for example name=; function $name { ...
}, are not treated as anony- mous functions. Instead, they
are treated as normal function defini- tions where the
definition is silently discarded.</p>

<p>SPECIAL FUNCTIONS Certain functions, if defined, have
special meaning to the shell.</p>

<p>Hook Functions For the functions below, it is possible
to define an array that has the same name as the function
with _functions appended. Any element in such an array is
taken as the name of a function to execute; it is exe- cuted
in the same context and with the same arguments as the basic
function. For example, if $chpwd_functions is an array
containing the values mychpwd , chpwd_save_dirstack, then
the shell attempts to execute the functions chpwd , mychpwd
and chpwd_save_dirstack, in that order. Any function that
does not exist is silently ignored. A function found by this
mechanism is referred to elsewhere as a hook function . An
error in any function causes subsequent functions not to be
run. Note further that an error in a precmd hook causes an
immedi- ately following periodic function not to run (though
it may run at the next opportunity).</p>

<p>chpwd Executed whenever the current working directory is
changed.</p>

<p>periodic If the parameter PERIOD is set, this function
is executed every $PERIOD seconds, just before a prompt.
Note that if multiple functions are defined using the array
periodic_functions only one period is applied to the
complete set of functions, and the scheduled time is not
reset if the list of functions is altered. Hence the set of
functions is always called together.</p>

<p>precmd Executed before each prompt. Note that precommand
functions are not re-executed simply because the command
line is redrawn, as happens, for example, when a
notification about an exiting job is displayed.</p>

<p>preexec Executed just after a command has been read and
is about to be executed. If the history mechanism is active
(and the line was not discarded from the history buffer),
the string that the user typed is passed as the first
argument, otherwise it is an empty string. The actual
command that will be executed (including expanded aliases)
is passed in two different forms: the second argument is a
single-line, size-limited version of the command (with
things like function bodies elided); the third argument
contains the full text that is being executed.</p>

<p>zshaddhistory Executed when a history line has been read
interactively, but before it is executed. The sole argument
is the complete his- tory line (so that any terminating
newline will still be present).</p>

<p>If any of the hook functions return a non-zero value the
history line will not be saved, although it lingers in the
history until the next line is executed allow you to reuse
or edit it immedi- ately.</p>

<p>A hook function may call fc -p ... to switch the history
con- text so that the history is saved in a different file
from the that in the global HISTFILE parameter. This is
handled spe- cially: the history context is automatically
restored after the processing of the history line is
finished.</p>

<p>The following example function first adds the history
line to the normal history with the newline stripped, which
is usually the correct behaviour. Then it switches the
history context so that the line will be written to a
history file in the current directory.</p>

<p>zshaddhistory() { print -sr -- ${1%%} fc -p
.zsh_local_history }</p>

<p>zshexit Executed at the point where the main shell is
about to exit nor- mally. This is not called by exiting
subshells, nor when the exec precommand modifier is used
before an external command. Also, unlike TRAPEXIT, it is not
called when functions exit.</p>

<p>Trap Functions The functions below are treated specially
but do not have corresponding hook arrays.</p>

<p>TRAPNAL If defined and non-null, this function will be
executed whenever the shell catches a signal SIGNAL, where
NAL is a signal name as specified for the kill builtin. The
signal number will be passed as the first parameter to the
function.</p>

<p>If a function of this form is defined and null, the
shell and processes spawned by it will ignore SIGNAL.</p>

<p>The return status from the function is handled
specially. If it is zero, the signal is assumed to have been
handled, and execu- tion continues normally. Otherwise, the
shell will behave as interrupted except that the return
status of the trap is retained.</p>

<p>Programs terminated by uncaught signals typically return
the status 128 plus the signal number. Hence the following
causes the handler for SIGINT to print a message, then mimic
the usual effect of the signal.</p>

<p>TRAPINT() { print &quot;Caught SIGINT, aborting.&quot;
return $(( 128 + $1 )) }</p>

<p>The functions TRAPZERR, TRAPDEBUG and TRAPEXIT are never
exe- cuted inside other traps.</p>

<p>TRAPDEBUG If the option DEBUG_BEFORE_CMD is set (as it
is by default), executed before each command; otherwise
executed after each com- mand. See the description of the
trap builtin in zshbuiltins(1) for details of additional
features provided in debug traps.</p>

<p>TRAPEXIT Executed when the shell exits, or when the
current function exits if defined inside a function. The
value of $? at the start of execution is the exit status of
the shell or the return status of the function exiting.</p>

<p>TRAPZERR Executed whenever a command has a non-zero exit
status. How- ever, the function is not executed if the
command occurred in a sublist followed by &amp;&amp; or || ;
only the final command in a sublist of this type causes the
trap to be executed. The func- tion TRAPERR acts the same as
TRAPZERR on systems where there is no SIGERR (this is the
usual case).</p>

<p>The functions beginning TRAP may alternatively be
defined with the trap builtin: this may be preferable for
some uses, as they are then run in the environment of the
calling process, rather than in their own function
environment. Apart from the difference in calling procedure
and the fact that the function form appears in lists of
functions, the forms</p>

<p>TRAPNAL() { # code }</p>

<p>and</p>

<p>trap # code NAL</p>

<p>are equivalent.</p>

<p>JOBS If the MONITOR option is set, an interactive shell
associates a job with each pipeline. It keeps a table of
current jobs, printed by the jobs command, and assigns them
small integer numbers. When a job is started asynchronously
with &amp;, the shell prints a line to standard error which
looks like:</p>

<p>[1] 1234</p>

<p>indicating that the job which was started asynchronously
was job number 1 and had one (top-level) process, whose
process ID was 1234.</p>

<p>If a job is started with &amp;| or &amp;!, then that job
is immediately disowned. After startup, it does not have a
place in the job table, and is not subject to the job
control features described here.</p>

<p>If you are running a job and wish to do something else
you may hit the key ^Z (control-Z) which sends a TSTP signal
to the current job: this key may be redefined by the susp
option of the external stty command. The shell will then
normally indicate that the job has been sus- pended, and
print another prompt. You can then manipulate the state of
this job, putting it in the background with the bg command,
or run some other commands and then eventually bring the job
back into the foreground with the foreground command fg. A
^Z takes effect immedi- ately and is like an interrupt in
that pending output and unread input are discarded when it
is typed.</p>

<p>A job being run in the background will suspend if it
tries to read from the terminal. Background jobs are
normally allowed to produce output, but this can be disabled
by giving the command stty tostop. If you set this tty
option, then background jobs will suspend when they try to
produce output like they do when they try to read input.</p>

<p>When a command is suspended and continued later with the
fg or wait builtins, zsh restores tty modes that were in
effect when it was sus- pended. This (intentionally) does
not apply if the command is contin- ued via kill -CONT, nor
when it is continued with bg.</p>

<p>There are several ways to refer to jobs in the shell. A
job can be referred to by the process ID of any process of
the job or by one of the following:</p>

<p>%number The job with the given number. %string Any job
whose command line begins with string. %?string Any job
whose command line contains string. %% Current job. %+
Equivalent to %%. %- Previous job.</p>

<p>The shell learns immediately whenever a process changes
state. It nor- mally informs you whenever a job becomes
blocked so that no further progress is possible. If the
NOTIFY option is not set, it waits until just before it
prints a prompt before it informs you. All such notifi-
cations are sent directly to the terminal, not to the
standard output or standard error.</p>

<p>When the monitor mode is on, each background job that
completes trig- gers any trap set for CHLD.</p>

<p>When you try to leave the shell while jobs are running
or suspended, you will be warned that You have suspended
(running) jobs. You may use the jobs command to see what
they are. If you do this or immedi- ately try to exit again,
the shell will not warn you a second time; the suspended
jobs will be terminated, and the running jobs will be sent a
SIGHUP signal, if the HUP option is set.</p>

<p>To avoid having the shell terminate the running jobs,
either use the nohup command (see nohup(1)) or the disown
builtin.</p>

<p>SIGNALS The INT and QUIT signals for an invoked command
are ignored if the com- mand is followed by &amp; and the
MONITOR option is not active. The shell itself always
ignores the QUIT signal. Otherwise, signals have the values
inherited by the shell from its parent (but see the TRAPNAL
special functions in the section Functions).</p>

<p>ARITHMETIC EVALUATION The shell can perform integer and
floating point arithmetic, either using the builtin let, or
via a substitution of the form $((...)). For integers, the
shell is usually compiled to use 8-byte precision where this
is available, otherwise precision is 4 bytes. This can be
tested, for example, by giving the command print - $((
12345678901 )); if the number appears unchanged, the
precision is at least 8 bytes. Floating point arithmetic
always uses the double type with whatever corresponding
precision is provided by the compiler and the library.</p>

<p>The let builtin command takes arithmetic expressions as
arguments; each is evaluated separately. Since many of the
arithmetic operators, as well as spaces, require quoting, an
alternative form is provided: for any command which begins
with a (( , all the characters until a match- ing )) are
treated as a quoted expression and arithmetic expansion
performed as for an argument of let. More precisely, ((...))
is equivalent to let &quot;...&quot;. The return status is 0
if the arithmetic value of the expression is non-zero, 1 if
it is zero, and 2 if an error occurred.</p>

<p>For example, the following statement</p>

<p>(( val = 2 + 1 ))</p>

<p>is equivalent to</p>

<p>let &quot;val = 2 + 1&quot;</p>

<p>both assigning the value 3 to the shell variable val and
returning a zero status.</p>

<p>Integers can be in bases other than 10. A leading 0x or
0X denotes hexadecimal. Integers may also be of the form
base#n, where base is a decimal number between two and
thirty-six representing the arithmetic base and n is a
number in that base (for example, 16#ff is 255 in
hexadecimal). The base# may also be omitted, in which case
base 10 is used. For backwards compatibility the form
[base]n is also accepted.</p>

<p>It is also possible to specify a base to be used for
output in the form [#base] , for example [#16] . This is
used when outputting arith- metical substitutions or when
assigning to scalar parameters, but an explicitly defined
integer or floating point parameter will not be affected. If
an integer variable is implicitly defined by an arith- metic
expression, any base specified in this way will be set as
the variables output arithmetic base as if the option -i
base to the typeset builtin had been used. The expression
has no precedence and if it occurs more than once in a
mathematical expression, the last encoun- tered is used. For
clarity it is recommended that it appear at the beginning of
an expression. As an example:</p>

<p>typeset -i 16 y print $(( [#8] x = 32, y = 32 )) print
$x $y</p>

<p>outputs first 8#40, the rightmost value in the given
output base, and then 8#40 16#20, because y has been
explicitly declared to have out- put base 16, while x
(assuming it does not already exist) is implicitly typed by
the arithmetic evaluation, where it acquires the output base
8.</p>

<p>If the C_BASES option is set, hexadecimal numbers in the
standard C format, for example 0xFF instead of the usual
16#FF. If the option OCTAL_ZEROES is also set (it is not by
default), octal numbers will be treated similarly and hence
appear as 077 instead of 8#77. This option has no effect on
the output of bases other than hexadecimal and octal, and
these formats are always understood on input.</p>

<p>When an output base is specified using the [#base]
syntax, an appro- priate base prefix will be output if
necessary, so that the value out- put is valid syntax for
input. If the # is doubled, for example [##16], then no base
prefix is output.</p>

<p>Floating point constants are recognized by the presence
of a decimal point or an exponent. The decimal point may be
the first character of the constant, but the exponent
character e or E may not, as it will be taken for a
parameter name.</p>

<p>An arithmetic expression uses nearly the same syntax and
associativity of expressions as in C.</p>

<p>In the native mode of operation, the following operators
are supported (listed in decreasing order of
precedence):</p>

<p>+ - ! ~ ++ -- unary plus/minus, logical NOT, complement,
{pre,post}{in,de}cre- ment &lt;&lt; &gt;&gt; bitwise shift
left, right &amp; bitwise AND ^ bitwise XOR | bitwise OR **
exponentiation * / % multiplication, division, modulus
(remainder) + - addition, subtraction &lt; &gt; &lt;= &gt;=
comparison == != equality and inequality &amp;&amp; logical
AND || ^^ logical OR, XOR ? : ternary operator = += -= *= /=
%= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &amp;&amp;= ||= ^^= **=
assignment , comma operator</p>

<p>The operators &amp;&amp;, ||, &amp;&amp;=, and ||= are
short-circuiting, and only one of the latter two expressions
in a ternary operator is evalu- ated. Note the precedence of
the bitwise AND, OR, and XOR operators.</p>

<p>With the option C_PRECEDENCES the precedences (but no
other properties) of the operators are altered to be the
same as those in most other lan- guages that support the
relevant operators:</p>

<p>+ - ! ~ ++ -- unary plus/minus, logical NOT, complement,
{pre,post}{in,de}cre- ment ** exponentiation * / %
multiplication, division, modulus (remainder) + - addition,
subtraction &lt;&lt; &gt;&gt; bitwise shift left, right &lt;
&gt; &lt;= &gt;= comparison == != equality and inequality
&amp; bitwise AND ^ bitwise XOR | bitwise OR &amp;&amp;
logical AND ^^ logical XOR || logical OR ? : ternary
operator = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=
&amp;&amp;= ||= ^^= **= assignment , comma operator</p>

<p>Note the precedence of exponentiation in both cases is
below that of unary operators, hence -3**2 evaluates as 9,
not -9. Use parenthe- ses where necessary: -(3**2). This is
for compatibility with other shells.</p>

<p>Mathematical functions can be called with the syntax
func(args), where the function decides if the args is used
as a string or a comma-separated list of arithmetic
expressions. The shell currently defines no mathematical
functions by default, but the module zsh/math- func may be
loaded with the zmodload builtin to provide standard float-
ing point mathematical functions.</p>

<p>An expression of the form ##x where x is any character
sequence such as a, ^A, orM-x gives the value of this
character and an expression of the form #foo gives the value
of the first character of the contents of the parameter foo.
Character values are according to the character set used in
the current locale; for multibyte character handling the
option MULTIBYTE must be set. Note that this form is dif-
ferent from $#foo , a standard parameter substitution which
gives the length of the parameter foo. #is accepted instead
of ##, but its use is deprecated.</p>

<p>Named parameters and subscripted arrays can be
referenced by name within an arithmetic expression without
using the parameter expansion syntax. For example,</p>

<p>((val2 = val1 * 2))</p>

<p>assigns twice the value of $val1 to the parameter named
val2.</p>

<p>An internal integer representation of a named parameter
can be speci- fied with the integer builtin. Arithmetic
evaluation is performed on the value of each assignment to a
named parameter declared integer in this manner. Assigning a
floating point number to an integer results in rounding down
to the next integer.</p>

<p>Likewise, floating point numbers can be declared with
the float builtin; there are two types, differing only in
their output format, as described for the typeset builtin.
The output format can be bypassed by using arithmetic
substitution instead of the parameter substitution, i.e.
${float} uses the defined format, but $((float)) uses a
generic floating point format.</p>

<p>Promotion of integer to floating point values is
performed where neces- sary. In addition, if any operator
which requires an integer (~, &amp;, |, ^, % , &lt;&lt; ,
&gt;&gt; and their equivalents with assignment) is given a
floating point argument, it will be silently rounded down to
the next integer.</p>

<p>Scalar variables can hold integer or floating point
values at different times; there is no memory of the numeric
type in this case.</p>

<p>If a variable is first assigned in a numeric context
without previously being declared, it will be implicitly
typed as integer or float and retain that type either until
the type is explicitly changed or until the end of the
scope. This can have unforeseen consequences. For example,
in the loop</p>

<p>for (( f = 0; f &lt; 1; f += 0.1 )); do # use $f
done</p>

<p>if f has not already been declared, the first assignment
will cause it to be created as an integer, and consequently
the operation f += 0.1 will always cause the result to be
truncated to zero, so that the loop will fail. A simple fix
would be to turn the initialization into f = 0.0. It is
therefore best to declare numeric variables with explicit
types.</p>

<p>CONDITIONAL EXPRESSIONS A conditional expression is used
with the [[ compound command to test attributes of files and
to compare strings. Each expression can be constructed from
one or more of the following unary or binary expres-
sions:</p>

<p>-a file true if file exists.</p>

<p>-b file true if file exists and is a block special
file.</p>

<p>-c file true if file exists and is a character special
file.</p>

<p>-d file true if file exists and is a directory.</p>

<p>-e file true if file exists.</p>

<p>-f file true if file exists and is a regular file.</p>

<p>-g file true if file exists and has its setgid bit
set.</p>

<p>-h file true if file exists and is a symbolic link.</p>

<p>-k file true if file exists and has its sticky bit
set.</p>

<p>-n string true if length of string is non-zero.</p>

<p>-o option true if option named option is on. option may
be a single char- acter, in which case it is a single letter
option name. (See the section Specifying Options.)</p>

<p>-p file true if file exists and is a FIFO special file
(named pipe).</p>

<p>-r file true if file exists and is readable by current
process.</p>

<p>-s file true if file exists and has size greater than
zero.</p>

<p>-t fd true if file descriptor number fd is open and
associated with a terminal device. (note: fd is not
optional)</p>

<p>-u file true if file exists and has its setuid bit
set.</p>

<p>-w file true if file exists and is writable by current
process.</p>

<p>-x file true if file exists and is executable by current
process. If file exists and is a directory, then the current
process has permission to search in the directory.</p>

<p>-z string true if length of string is zero.</p>

<p>-L file true if file exists and is a symbolic link.</p>

<p>-O file true if file exists and is owned by the
effective user ID of this process.</p>

<p>-G file true if file exists and its group matches the
effective group ID of this process.</p>

<p>-S file true if file exists and is a socket.</p>

<p>-N file true if file exists and its access time is not
newer than its modification time.</p>

<p>file1 -nt file2 true if file1 exists and is newer than
file2.</p>

<p>file1 -ot file2 true if file1 exists and is older than
file2.</p>

<p>file1 -ef file2 true if file1 and file2 exist and refer
to the same file.</p>

<p>string = pattern string == pattern true if string
matches pattern. The == form is the preferred one. The =
form is for backward compatibility and should be considered
obsolete.</p>

<p>string != pattern true if string does not match
pattern.</p>

<p>string =~ regexp true if string matches the regular
expression regexp. If the option RE_MATCH_PCRE is set regexp
is tested as a PCRE regular expression using the zsh/pcre
module, else it is tested as a POSIX extended regular
expression using the zsh/regex module. Upon successful
match, some variables will be updated; no vari- ables are
changed if the matching fails.</p>

<p>If the option BASH_REMATCH is not set the scalar
parameter MATCH is set to the substring that matched the
pattern and the integer parameters MBEGIN and MEND to the
index of the start and end, respectively, of the match in
string, such that if string is contained in variable var the
expression ${var[$MBEGIN,$MEND]} is identical to $MATCH. The
setting of the option KSH_ARRAYS is respected. Likewise, the
array match is set to the sub- strings that matched
parenthesised subexpressions and the arrays mbegin and mend
to the indices of the start and end positions, respectively,
of the substrings within string. The arrays are not set if
there were no parenthesised subexpresssions. For example, if
the string a short string is matched against the regular
expression s(...)t , then (assuming the option KSH_ARRAYS is
not set) MATCH, MBEGIN and MEND are short, 3 and 7,
respectively, while match, mbegin and mend are single entry
arrays containing the strings hor , 4 and 6,
respectively.</p>

<p>If the option BASH_REMATCH is set the array BASH_REMATCH
is set to the substring that matched the pattern followed by
the sub- strings that matched parenthesised subexpressions
within the pattern.</p>

<p>string1 &lt; string2 true if string1 comes before
string2 based on ASCII value of their characters.</p>

<p>string1 &gt; string2 true if string1 comes after string2
based on ASCII value of their characters.</p>

<p>exp1 -eq exp2 true if exp1 is numerically equal to
exp2.</p>

<p>exp1 -ne exp2 true if exp1 is numerically not equal to
exp2.</p>

<p>exp1 -lt exp2 true if exp1 is numerically less than
exp2.</p>

<p>exp1 -gt exp2 true if exp1 is numerically greater than
exp2.</p>

<p>exp1 -le exp2 true if exp1 is numerically less than or
equal to exp2.</p>

<p>exp1 -ge exp2 true if exp1 is numerically greater than
or equal to exp2.</p>

<p>( exp ) true if exp is true.</p>

<p>! exp true if exp is false.</p>

<p>exp1 &amp;&amp; exp2 true if exp1 and exp2 are both
true.</p>

<p>exp1 || exp2 true if either exp1 or exp2 is true.</p>

<p>Normal shell expansion is performed on the file, string
and pattern arguments, but the result of each expansion is
constrained to be a sin- gle word, similar to the effect of
double quotes. File generation is not performed on any form
of argument to conditions. However, pattern metacharacters
are active for the pattern arguments; the patterns are the
same as those used for filename generation, see zshexpn(1),
but there is no special behaviour of / nor initial dots, and
no glob qualifiers are allowed.</p>

<p>In each of the above expressions, if file is of the form
/dev/fd/n, where n is an integer, then the test applied to
the open file whose descriptor number is n, even if the
underlying system does not support the /dev/fd
directory.</p>

<p>In the forms which do numeric comparison, the
expressions exp undergo arithmetic expansion as if they were
enclosed in $((...)).</p>

<p>For example, the following:</p>

<p>[[ ( -f foo || -f bar ) &amp;&amp; $report = y* ]]
&amp;&amp; print File exists.</p>

<p>tests if either file foo or file bar exists, and if so,
if the value of the parameter report begins with y ; if the
complete condition is true, the message File exists. is
printed.</p>

<p>EXPANSION OF PROMPT SEQUENCES Prompt sequences undergo a
special form of expansion. This type of expansion is also
available using the -P option to the print builtin.</p>

<p>If the PROMPT_SUBST option is set, the prompt string is
first subjected to parameter expansion, command substitution
and arithmetic expansion. See zshexpn(1).</p>

<p>Certain escape sequences may be recognised in the prompt
string.</p>

<p>If the PROMPT_BANG option is set, a ! in the prompt is
replaced by the current history event number. A literal !
may then be repre- sented as !!.</p>

<p>If the PROMPT_PERCENT option is set, certain escape
sequences that start with % are expanded. Many escapes are
followed by a single character, although some of these take
an optional integer argument that should appear between the
% and the next character of the sequence. More complicated
escape sequences are available to provide conditional
expansion.</p>

<p>SIMPLE PROMPT ESCAPES Special characters %% A %.</p>

<p>%) A ).</p>

<p>Login information %l The line (tty) the user is logged
in on, without /dev/ prefix. If the name starts with
/dev/tty, that prefix is stripped.</p>

<p>%M The full machine hostname.</p>

<p>%m The hostname up to the first .. An integer may follow
the % to specify how many components of the hostname are
desired. With a negative integer, trailing components of the
hostname are shown.</p>

<p>%n $USERNAME.</p>

<p>%y The line (tty) the user is logged in on, without
/dev/ prefix. This does not treat /dev/tty names
specially.</p>

<p>Shell state %# A # if the shell is running with
privileges, a % if not. Equivalent to %(!.#.%%) . The
definition of privileged, for these purposes, is that either
the effective user ID is zero, or, if POSIX.1e capabilities
are supported, that at least one capability is raised in
either the Effective or Inheritable capability vectors.</p>

<p>%? The return status of the last command executed just
before the prompt.</p>

<p>%_ The status of the parser, i.e. the shell constructs
(like if and for) that have been started on the command
line. If given an integer number that many strings will be
printed; zero or negative or no integer means print as many
as there are. This is most useful in prompts PS2 for
continuation lines and PS4 for debugging with the XTRACE
option; in the latter case it will also work
non-interactively.</p>

<p>%d / Current working directory. If an integer follows
the %, it specifies a number of trailing components of the
current working directory to show; zero means the whole
path. A negative inte- ger specifies leading components,
i.e. %-1d specifies the first component.</p>

<p>%~ As %d and %/, but if the current working directory
has a named directory as its prefix, that part is replaced
by a ~ followed by the name of the directory. If it starts
with $HOME, that part is replaced by a ~.</p>

<p>%h %! Current history event number.</p>

<p>%i The line number currently being executed in the
script, sourced file, or shell function given by %N. This is
most useful for debugging as part of $PS4.</p>

<p>%I The line number currently being executed in the file
%x. This is similar to %i, but the line number is always a
line number in the file where the code was defined, even if
the code is a shell function.</p>

<p>%j The number of jobs.</p>

<p>%L The current value of $SHLVL.</p>

<p>%N The name of the script, sourced file, or shell
function that zsh is currently executing, whichever was
started most recently. If there is none, this is equivalent
to the parameter $0. An inte- ger may follow the % to
specify a number of trailing path com- ponents to show; zero
means the full path. A negative integer specifies leading
components.</p>

<p>%x The name of the file containing the source code
currently being executed. This behaves as %N except that
function and eval com- mand names are not shown, instead the
file where they were defined.</p>

<p>%c %. %C Trailing component of the current working
directory. An integer may follow the % to get more than one
component. Unless %C is used, tilde contraction is performed
first. These are depre- cated as %c and %C are equivalent to
%1~ and %1/, respectively, while explicit positive integers
have the same effect as for the latter two sequences.</p>

<p>Date and time %D The date in yy-mm-dd format.</p>

<p>%T Current time of day, in 24-hour format.</p>

<p>%t %@ Current time of day, in 12-hour, am/pm format.</p>

<p>%* Current time of day in 24-hour format, with
seconds.</p>

<p>%w The date in day-dd format.</p>

<p>%W The date in mm/dd/yy format.</p>

<p>%D{string} string is formatted using the strftime
function. See strf- time(3) for more details. Various zsh
extensions provide num- bers with no leading zero or space
if the number is a single digit:</p>

<p>%f a day of the month %K the hour of the day on the
24-hour clock %L the hour of the day on the 12-hour
clock</p>

<p>The GNU extension that a - between the % and the format
char- acter causes a leading zero or space to be stripped is
handled directly by the shell for the format characters d,
f, H, k, l, m, M, S and y; any other format characters are
provided to strf- time() with any leading -, present, so the
handling is system dependent. Further GNU extensions are not
supported at present.</p>

<p>Visual effects %B (%b) Start (stop) boldface mode.</p>

<p>%E Clear to end of line.</p>

<p>%U (%u) Start (stop) underline mode.</p>

<p>%S (%s) Start (stop) standout mode.</p>

<p>%F (%f) Start (stop) using a different foreground
colour, if supported by the terminal. The colour may be
specified two ways: either as a numeric argument, as normal,
or by a sequence in braces following the %F, for example
%F{red}. In the latter case the values allowed are as
described for the fg zle_highlight attribute; see Character
Highlighting in zshzle(1). This means that numeric colours
are allowed in the second format also.</p>

<p>%K (%k) Start (stop) using a different bacKground
colour. The syntax is identical to that for %F and %f.</p>

<p>%{...%} Include a string as a literal escape sequence.
The string within the braces should not change the cursor
position. Brace pairs can nest.</p>

<p>A positive numeric argument between the % and the { is
treated as described for %G below.</p>

<p>%G Within a %{...%} sequence, include a glitch: that is,
assume that a single character width will be output. This is
useful when outputting characters that otherwise cannot be
correctly handled by the shell, such as the alternate
character set on some terminals. The characters in question
can be included within a %{...%} sequence together with the
appropriate number of %G sequences to indicate the correct
width. An integer between the % and G indicates a character
width other than one. Hence %{seq%2G%} outputs seq and
assumes it takes up the width of two standard
characters.</p>

<p>Multiple uses of %G accumulate in the obvious fashion;
the posi- tion of the %G is unimportant. Negative integers
are not han- dled.</p>

<p>Note that when prompt truncation is in use it is
advisable to divide up output into single characters within
each %{...%} group so that the correct truncation point can
be found.</p>

<p>CONDITIONAL SUBSTRINGS IN PROMPTS %v The value of the
first element of the psvar array parameter. Following the %
with an integer gives that element of the array. Negative
integers count from the end of the array.</p>

<p>%(x.true-text.false-text) Specifies a ternary
expression. The character following the x is arbitrary; the
same character is used to separate the text for the true
result from that for the false result. This separator may
not appear in the true-text, except as part of a %-escape
sequence. A ) may appear in the false-text as %). true-text
and false-text may both contain arbitrarily-nested escape
sequences, including further ternary expressions.</p>

<p>The left parenthesis may be preceded or followed by a
positive integer n, which defaults to zero. A negative
integer will be multiplied by -1. The test character x may
be any of the fol- lowing:</p>

<p>! True if the shell is running with privileges. # True
if the effective uid of the current process is n. ? True if
the exit status of the last command was n. _ True if at
least n shell constructs were started. C / True if the
current absolute path has at least n elements relative to
the root directory, hence / is counted as 0 elements. c . ~
True if the current path, with prefix replacement, has at
least n elements relative to the root directory, hence / is
counted as 0 elements. D True if the month is equal to n
(January = 0). d True if the day of the month is equal to n.
g True if the effective gid of the current process is n. j
True if the number of jobs is at least n. L True if the
SHLVL parameter is at least n. l True if at least n
characters have already been printed on the current line. S
True if the SECONDS parameter is at least n. T True if the
time in hours is equal to n. t True if the time in minutes
is equal to n. v True if the array psvar has at least n
elements. V True if element n of the array psvar is set and
non-empty. w True if the day of the week is equal to n
(Sunday = 0).</p>

<p>%&lt;string&lt; %&gt;string&gt; %[xstring] Specifies
truncation behaviour for the remainder of the prompt string.
The third, deprecated, form is equivalent to %xstringx, i.e.
x may be &lt; or &gt; . The numeric argument, which in the
third form may appear immediately after the [, specifies the
maximum permitted length of the various strings that can be
displayed in the prompt. The string will be dis- played in
place of the truncated portion of any string; note this does
not undergo prompt expansion.</p>

<p>The forms with &lt; truncate at the left of the string,
and the forms with &gt; truncate at the right of the string.
For example, if the current directory is /home/pike, the
prompt %8&lt;..&lt;%/ will expand to ..e/pike. In this
string, the ter- minating character ( &lt; , &gt; or ]), or
in fact any character, may be quoted by a preceding; note
when using print -P, how- ever, that this must be doubled as
the string is also subject to standard print processing, in
addition to any backslashes removed by a double quoted
string: the worst case is therefore print -P
&quot;%&lt;&lt;...&quot;.</p>

<p>If the string is longer than the specified truncation
length, it will appear in full, completely replacing the
truncated string.</p>

<p>The part of the prompt string to be truncated runs to
the end of the string, or to the end of the next enclosing
group of the %( construct, or to the next truncation
encountered at the same grouping level (i.e. truncations
inside a %( are sepa- rate), which ever comes first. In
particular, a truncation with argument zero (e.g. %&lt;&lt;)
marks the end of the range of the string to be truncated
while turning off truncation from there on. For example, the
prompt %10&lt;...&lt;%~%&lt;&lt;%# will print a truncated
representation of the current directory, followed by a % or
#, followed by a space. Without the %&lt;&lt;, those two
characters would be included in the string to be
truncated.</p>

<p>zsh 4.3.11 December 20, 2010 ZSHMISC(1)</p>
<hr>
</body>
</html>
