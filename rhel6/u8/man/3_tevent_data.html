<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:40:40 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>tevent_data(3) tevent tevent_data(3)</p>

<p>NAME tevent_data - Chapter 3: Accessing data</p>

<p>Accessing data with tevent A tevent request is (usually)
created together with a structure for storing the data
necessary for an asynchronous computation. For these private
data, tevent library uses void (generic) pointers, therefore
any data type can be very simply pointed at. However, this
attitude requires clear and guaranteed knowledge of the data
type that will be handled, in advance. Private data can be
of 2 types: connected with a request itself or given as an
individual argument to a callback. It is necessary to
differentiate these types, because there is a slightly
different method of data access for each. There are two
possibilities how to access data that is given as an
argument directly to a callback. The difference lies in the
pointer that is returned. In one case it is the data type
specified in the functions argument, in another void* is
returned.</p>

<p>void tevent_req_callback_data (struct tevent_req *req,
#type) void tevent_req_callback_data_void (struct tevent_req
*req)</p>

<p>To obtain data that are strictly bound to a request,
this function is the only direct procedure.</p>

<p>void *tevent_req_data (struct tevent_req *req,
#type)</p>

<p>Example with both calls which differs between private
data within tevent request and data handed over as an
argument.</p>

<p>#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;
#include &lt;tevent.h&gt;</p>

<p>struct foo_state { int x; };</p>

<p>struct testA { int y; };</p>

<p>static void foo_done(struct tevent_req *req) { //
a-&gt;x contains 10 since it came from foo_send struct
foo_state *a = tevent_req_data(req, struct foo_state);</p>

<p>// b-&gt;y contains 9 since it came from run struct
testA *b = tevent_req_callback_data(req, struct testA);</p>

<p>// c-&gt;y contains 9 since it came from run we just
used a different way // of getting it. struct testA *c =
(struct testA *)tevent_req_callback_data_void(req);</p>

<p>printf(a-&gt;x: %d0, a-&gt;x); printf(b-&gt;y: %d0,
b-&gt;y); printf(c-&gt;y: %d0, c-&gt;y); }</p>

<p>struct tevent_req * foo_send(TALLOC_CTX *mem_ctx, struct
tevent_context *event_ctx) {</p>

<p>printf(_send0); struct tevent_req *req; struct foo_state
*state;</p>

<p>req = tevent_req_create(event_ctx, &amp;state, struct
foo_state); state-&gt;x = 10;</p>

<p>return req; }</p>

<p>static void run(struct tevent_context *ev, struct
tevent_timer *te, struct timeval current_time, void
*private_data) { struct tevent_req *req; struct testA *tmp =
talloc(ev, struct testA);</p>

<p>// Note that we did not use the private data passed
in</p>

<p>tmp-&gt;y = 9; req = foo_send(ev, ev);</p>

<p>tevent_req_set_callback(req, foo_done, tmp);
tevent_req_done(req);</p>

<p>}</p>

<p>int main (int argc, char **argv) {</p>

<p>struct tevent_context *event_ctx; struct testA *data;
TALLOC_CTX *mem_ctx; struct tevent_timer *time_event;</p>

<p>mem_ctx = talloc_new(NULL); //parent if (mem_ctx ==
NULL) return EXIT_FAILURE;</p>

<p>event_ctx = tevent_context_init(mem_ctx); if (event_ctx
== NULL) return EXIT_FAILURE;</p>

<p>data = talloc(mem_ctx, struct testA); data-&gt;y =
11;</p>

<p>time_event = tevent_add_timer(event_ctx, mem_ctx,
tevent_timeval_current(), run, data); if (time_event ==
NULL) { fprintf(stderr, FAILED0); return EXIT_FAILURE; }</p>

<p>tevent_loop_once(event_ctx);</p>

<p>talloc_free(mem_ctx);</p>

<p>printf(Quit0); return EXIT_SUCCESS; }</p>

<p>Output of this example is:</p>

<p>a-&gt;x: 10 b-&gt;y: 9 c-&gt;y: 9</p>

<p>Version 0.9.8 4 Apr 2016 tevent_data(3)</p>
<hr>
</body>
</html>
