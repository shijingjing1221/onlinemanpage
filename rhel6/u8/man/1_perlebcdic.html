<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:34 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLEBCDIC(1) Perl Programmers Reference Guide
PERLEBCDIC(1)</p>

<p>NAME perlebcdic - Considerations for running Perl on
EBCDIC platforms</p>

<p>DESCRIPTION An exploration of some of the issues facing
Perl programmers on EBCDIC based computers. We do not cover
localization, internationalization, or multi byte character
set issues other than some discussion of UTF-8 and
UTF-EBCDIC.</p>

<p>Portions that are still incomplete are marked with
XXX.</p>

<p>COMMON CHARACTER CODE SETS ASCII The American Standard
Code for Information Interchange (ASCII or US- ASCII) is a
set of integers running from 0 to 127 (decimal) that imply
character interpretation by the display and other systems of
computers. The range 0..127 can be covered by setting the
bits in a 7-bit binary digit, hence the set is sometimes
referred to as a &quot;7-bit ASCII&quot;. ASCII was
described by the American National Standards Institute
document ANSI X3.4-1986. It was also described by ISO
646:1991 (with localization for currency symbols). The full
ASCII set is given in the table below as the first 128
elements. Languages that can be written adequately with the
characters in ASCII include English, Hawaiian, Indonesian,
Swahili and some Native American languages.</p>

<p>There are many character sets that extend the range of
integers from 0..2**7-1 up to 2**8-1, or 8 bit bytes (octets
if you prefer). One common one is the ISO 8859-1 character
set.</p>

<p>ISO 8859 The ISO 8859-$n are a collection of character
code sets from the International Organization for
Standardization (ISO) each of which adds characters to the
ASCII set that are typically found in European languages
many of which are based on the Roman, or Latin,
alphabet.</p>

<p>Latin 1 (ISO 8859-1) A particular 8-bit extension to
ASCII that includes grave and acute accented Latin
characters. Languages that can employ ISO 8859-1 include all
the languages covered by ASCII as well as Afrikaans,
Albanian, Basque, Catalan, Danish, Faroese, Finnish,
Norwegian, Portuguese, Spanish, and Swedish. Dutch is
covered albeit without the ij ligature. French is covered
too but without the oe ligature. German can use ISO 8859-1
but must do so without German-style quotation marks. This
set is based on Western European extensions to ASCII and is
commonly encountered in world wide web work. In IBM
character code set identification terminology ISO 8859-1 is
also known as CCSID 819 (or sometimes 0819 or even
00819).</p>

<p>EBCDIC The Extended Binary Coded Decimal Interchange
Code refers to a large collection of slightly different
single and multi byte coded character sets that are
different from ASCII or ISO 8859-1 and typically run on host
computers. The EBCDIC encodings derive from 8 bit byte
extensions of Hollerith punched card encodings. The layout
on the cards was such that high bits were set for the upper
and lower case alphabet characters [a-z] and [A-Z], but
there were gaps within each Latin alphabet range.</p>

<p>Some IBM EBCDIC character sets may be known by character
code set identification numbers (CCSID numbers) or code page
numbers. Leading zero digits in CCSID numbers within this
document are insignificant. E.g. CCSID 0037 may be referred
to as 37 in places.</p>

<p>Perl can be compiled on platforms that run any of three
commonly used EBCDIC character sets, listed below.</p>

<p>The 13 variant characters Among IBM EBCDIC character
code sets there are 13 characters that are often mapped to
different integer values. Those characters are known as the
13 &quot;variant&quot; characters and are:</p>

<p>[ ] { } ^ ~ ! # | $ @ &lsquo;</p>

<p>When Perl is compiled for a platform, it looks at some
of these characters to guess which EBCDIC character set the
platform uses, and adapts itself accordingly to that
platform. If the platform uses a character set that is not
one of the three Perl knows about, Perl will either fail to
compile, or mistakenly and silently choose one of the three.
They are:</p>

<p>0037 Character code set ID 0037 is a mapping of the
ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC
set. 0037 is used in North American English locales on the
OS/400 operating system that runs on AS/400 computers. CCSID
37 differs from ISO 8859-1 in 237 places, in other words
they agree on only 19 code point values.</p>

<p>1047 Character code set ID 1047 is also a mapping of the
ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC
set. 1047 is used under Unix System Services for OS/390 or
z/OS, and OpenEdition for VM/ESA. CCSID 1047 differs from
CCSID 0037 in eight places.</p>

<p>POSIX-BC The EBCDIC code page in use on Siemens BS2000
system is distinct from 1047 and 0037. It is identified
below as the POSIX-BC set.</p>

<p>Unicode code points versus EBCDIC code points In Unicode
terminology a code point is the number assigned to a
character: for example, in EBCDIC the character
&quot;A&quot; is usually assigned the number 193. In Unicode
the character &quot;A&quot; is assigned the number 65. This
causes a problem with the semantics of the pack/unpack
&quot;U&quot;, which are supposed to pack Unicode code
points to characters and back to numbers. The problem is:
which code points to use for code points less than 256? (for
256 and over theres no problem: Unicode code points are
used) In EBCDIC, for the low 256 the EBCDIC code points are
used. This means that the equivalences</p>

<p>pack(&quot;U&quot;, ord($character)) eq $character
unpack(&quot;U&quot;, $character) == ord $character</p>

<p>will hold. (If Unicode code points were applied
consistently over all the possible code points,
pack(&quot;U&quot;,ord(&quot;A&quot;)) would in EBCDIC equal
A with acute or chr(101), and unpack(&quot;U&quot;,
&quot;A&quot;) would equal 65, or non- breaking space, not
193, or ord &quot;A&quot;.)</p>

<p>Remaining Perl Unicode problems in EBCDIC &middot; Many
of the remaining problems seem to be related to case-
insensitive matching</p>

<p>&middot; The extensions Unicode::Collate and
Unicode::Normalized are not supported under EBCDIC, likewise
for the encoding pragma.</p>

<p>Unicode and UTF UTF stands for &quot;Unicode
Transformation Format&quot;. UTF-8 is an encoding of Unicode
into a sequence of 8-bit byte chunks, based on ASCII and
Latin-1. The length of a sequence required to represent a
Unicode code point depends on the ordinal number of that
code point, with larger numbers requiring more bytes.
UTF-EBCDIC is like UTF-8, but based on EBCDIC.</p>

<p>You may see the term &quot;invariant&quot; character or
code point. This simply means that the character has the
same numeric value when encoded as when not. (Note that this
is a very different concept from &quot;The 13 variant
characters&quot; mentioned above.) For example, the ordinal
value of A is 193 in most EBCDIC code pages, and also is 193
when encoded in UTF-EBCDIC. All other code points occupy at
least two bytes when encoded. In UTF-8, the code points
corresponding to the lowest 128 ordinal numbers (0 - 127:
the ASCII characters) are invariant. In UTF- EBCDIC, there
are 160 invariant characters. (If you care, the EBCDIC
invariants are those characters which have ASCII
equivalents, plus those that correspond to the C1 controls
(80..9f on ASCII platforms).)</p>

<p>A string encoded in UTF-EBCDIC may be longer (but never
shorter) than one encoded in UTF-8.</p>

<p>Using Encode Starting from Perl 5.8 you can use the
standard new module Encode to translate from EBCDIC to
Latin-1 code points. Encode knows about more EBCDIC
character sets than Perl can currently be compiled to run
on.</p>

<p>use Encode &rsquo;from_to&rsquo;;</p>

<p>my %ebcdic = ( 176 =&gt; &rsquo;cp37&rsquo;, 95 =&gt;
&rsquo;cp1047&rsquo;, 106 =&gt; &rsquo;posix-bc&rsquo;
);</p>

<p># $a is in EBCDIC code points from_to($a, $ebcdic{ord
&rsquo;^&rsquo;}, &rsquo;latin1&rsquo;); # $a is ISO 8859-1
code points</p>

<p>and from Latin-1 code points to EBCDIC code points</p>

<p>use Encode &rsquo;from_to&rsquo;;</p>

<p>my %ebcdic = ( 176 =&gt; &rsquo;cp37&rsquo;, 95 =&gt;
&rsquo;cp1047&rsquo;, 106 =&gt; &rsquo;posix-bc&rsquo;
);</p>

<p># $a is ISO 8859-1 code points from_to($a,
&rsquo;latin1&rsquo;, $ebcdic{ord &rsquo;^&rsquo;}); # $a is
in EBCDIC code points</p>

<p>For doing I/O it is suggested that you use the
autotranslating features of PerlIO, see perluniintro.</p>

<p>Since version 5.8 Perl uses the new PerlIO I/O library.
This enables you to use different encodings per IO channel.
For example you may use</p>

<p>use Encode; open($f, &quot;&gt;:encoding(ascii)&quot;,
&quot;test.ascii&quot;); print $f &quot;Hello World!0;
open($f, &quot;&gt;:encoding(cp37)&quot;,
&quot;test.ebcdic&quot;); print $f &quot;Hello World!0;
open($f, &quot;&gt;:encoding(latin1)&quot;,
&quot;test.latin1&quot;); print $f &quot;Hello World!0;
open($f, &quot;&gt;:encoding(utf8)&quot;,
&quot;test.utf8&quot;); print $f &quot;Hello World!0;</p>

<p>to get four files containing &quot;Hello World!0 in
ASCII, CP 37 EBCDIC, ISO 8859-1 (Latin-1) (in this example
identical to ASCII since only ASCII characters were
printed), and UTF-EBCDIC (in this example identical to
normal EBCDIC since only characters that dont differ between
EBCDIC and UTF-EBCDIC were printed). See the documentation
of Encode::PerlIO for details.</p>

<p>As the PerlIO layer uses raw IO (bytes) internally, all
this totally ignores things like the type of your filesystem
(ASCII or EBCDIC).</p>

<p>SINGLE OCTET TABLES The following tables list the ASCII
and Latin 1 ordered sets including the subsets: C0 controls
(0..31), ASCII graphics (32..7e), delete (7f), C1 controls
(80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the
table non-printing control character names as well as the
Latin 1 extensions to ASCII have been labelled with
character names roughly corresponding to The Unicode
Standard, Version 3.0 albeit with substitutions such as
s/LATIN// and s/VULGAR// in all cases, s/CAPITAL LETTER// in
some cases, and s/SMALL LETTER ([A-Z])/in some other cases
(the &quot;charnames&quot; pragma names unfortunately do not
list explicit names for the C0 or C1 control characters).
The &quot;names&quot; of the C1 control set (128..159 in ISO
8859-1) listed here are somewhat arbitrary. The differences
between the 0037 and 1047 sets are flagged with ***. The
differences between the 1047 and POSIX-BC sets are flagged
with ###. All ord() numbers listed are decimal. If you would
rather see this table listing octal values then run the
table (that is, the pod version of this document since this
recipe may not work with a pod2_other_format translation)
through:</p>

<p>recipe 0</p>

<p>perl -ne &rsquo;if(/(.{33})(+)+)+)+)/)&rsquo; -e
&rsquo;{printf(&quot;%s%-9o%-9o%-9o%o0,$1,$2,$3,$4,$5)}&rsquo;
perlebcdic.pod</p>

<p>If you want to retain the UTF-x code points then in
script form you might want to write:</p>

<p>recipe 1</p>

<p>open(FH,&quot;&lt;perlebcdic.pod&quot;) or die
&quot;Could not open perlebcdic.pod: $!&quot;; while
(&lt;FH&gt;) { if (/(.{33})(+)+)+)+)+).?(*)+).?(*)/) { if
($7 ne &rsquo;&rsquo; &amp;&amp; $9 ne &rsquo;&rsquo;) {
printf(&quot;%s%-9o%-9o%-9o%-9o%-3o.%-5o%-3o.%o0,$1,$2,$3,$4,$5,$6,$7,$8,$9);
} elsif ($7 ne &rsquo;&rsquo;) {
printf(&quot;%s%-9o%-9o%-9o%-9o%-3o.%-5o%o0,$1,$2,$3,$4,$5,$6,$7,$8);
} else {
printf(&quot;%s%-9o%-9o%-9o%-9o%-9o%o0,$1,$2,$3,$4,$5,$6,$8);
} } }</p>

<p>If you would rather see this table listing hexadecimal
values then run the table through:</p>

<p>recipe 2</p>

<p>perl -ne &rsquo;if(/(.{33})(+)+)+)+)/)&rsquo; -e
&rsquo;{printf(&quot;%s%-9X%-9X%-9X%X0,$1,$2,$3,$4,$5)}&rsquo;
perlebcdic.pod</p>

<p>Or, in order to retain the UTF-x code points in
hexadecimal:</p>

<p>recipe 3</p>

<p>open(FH,&quot;&lt;perlebcdic.pod&quot;) or die
&quot;Could not open perlebcdic.pod: $!&quot;; while
(&lt;FH&gt;) { if (/(.{33})(+)+)+)+)+).?(*)+).?(*)/) { if
($7 ne &rsquo;&rsquo; &amp;&amp; $9 ne &rsquo;&rsquo;) {
printf(&quot;%s%-9X%-9X%-9X%-9X%-2X.%-6X%-2X.%X0,$1,$2,$3,$4,$5,$6,$7,$8,$9);
} elsif ($7 ne &rsquo;&rsquo;) {
printf(&quot;%s%-9X%-9X%-9X%-9X%-2X.%-6X%X0,$1,$2,$3,$4,$5,$6,$7,$8);
} else {
printf(&quot;%s%-9X%-9X%-9X%-9X%-9X%X0,$1,$2,$3,$4,$5,$6,$8);
} } }</p>

<p>incomp- incomp- 8859-1 lete lete chr 0819 0037 1047
POSIX-BC UTF-8 UTF-EBCDIC
------------------------------------------------------------------------------------
&lt;NULL&gt; 0 0 0 0 0 0 &lt;START OF HEADING&gt; 1 1 1 1 1
1 &lt;START OF TEXT&gt; 2 2 2 2 2 2 &lt;END OF TEXT&gt; 3 3
3 3 3 3 &lt;END OF TRANSMISSION&gt; 4 55 55 55 4 55
&lt;ENQUIRY&gt; 5 45 45 45 5 45 &lt;ACKNOWLEDGE&gt; 6 46 46
46 6 46 &lt;BELL&gt; 7 47 47 47 7 47 &lt;BACKSPACE&gt; 8 22
22 22 8 22 &lt;HORIZONTAL TABULATION&gt; 9 5 5 5 9 5
&lt;LINE FEED&gt; 10 37 21 21 10 21 *** &lt;VERTICAL
TABULATION&gt; 11 11 11 11 11 11 &lt;FORM FEED&gt; 12 12 12
12 12 12 &lt;CARRIAGE RETURN&gt; 13 13 13 13 13 13 &lt;SHIFT
OUT&gt; 14 14 14 14 14 14 &lt;SHIFT IN&gt; 15 15 15 15 15 15
&lt;DATA LINK ESCAPE&gt; 16 16 16 16 16 16 &lt;DEVICE
CONTROL ONE&gt; 17 17 17 17 17 17 &lt;DEVICE CONTROL TWO&gt;
18 18 18 18 18 18 &lt;DEVICE CONTROL THREE&gt; 19 19 19 19
19 19 &lt;DEVICE CONTROL FOUR&gt; 20 60 60 60 20 60
&lt;NEGATIVE ACKNOWLEDGE&gt; 21 61 61 61 21 61
&lt;SYNCHRONOUS IDLE&gt; 22 50 50 50 22 50 &lt;END OF
TRANSMISSION BLOCK&gt; 23 38 38 38 23 38 &lt;CANCEL&gt; 24
24 24 24 24 24 &lt;END OF MEDIUM&gt; 25 25 25 25 25 25
&lt;SUBSTITUTE&gt; 26 63 63 63 26 63 &lt;ESCAPE&gt; 27 39 39
39 27 39 &lt;FILE SEPARATOR&gt; 28 28 28 28 28 28 &lt;GROUP
SEPARATOR&gt; 29 29 29 29 29 29 &lt;RECORD SEPARATOR&gt; 30
30 30 30 30 30 &lt;UNIT SEPARATOR&gt; 31 31 31 31 31 31
&lt;SPACE&gt; 32 64 64 64 32 64 ! 33 90 90 90 33 90 &quot;
34 127 127 127 34 127 # 35 123 123 123 35 123 $ 36 91 91 91
36 91 % 37 108 108 108 37 108 &amp; 38 80 80 80 38 80
&rsquo; 39 125 125 125 39 125 ( 40 77 77 77 40 77 ) 41 93 93
93 41 93 * 42 92 92 92 42 92 + 43 78 78 78 43 78 , 44 107
107 107 44 107 - 45 96 96 96 45 96 . 46 75 75 75 46 75 / 47
97 97 97 47 97 0 48 240 240 240 48 240 1 49 241 241 241 49
241 2 50 242 242 242 50 242 3 51 243 243 243 51 243 4 52 244
244 244 52 244 5 53 245 245 245 53 245 6 54 246 246 246 54
246 7 55 247 247 247 55 247 8 56 248 248 248 56 248 9 57 249
249 249 57 249 : 58 122 122 122 58 122 ; 59 94 94 94 59 94
&lt; 60 76 76 76 60 76 = 61 126 126 126 61 126 &gt; 62 110
110 110 62 110 ? 63 111 111 111 63 111 @ 64 124 124 124 64
124 A 65 193 193 193 65 193 B 66 194 194 194 66 194 C 67 195
195 195 67 195 D 68 196 196 196 68 196 E 69 197 197 197 69
197 F 70 198 198 198 70 198 G 71 199 199 199 71 199 H 72 200
200 200 72 200 I 73 201 201 201 73 201 J 74 209 209 209 74
209 K 75 210 210 210 75 210 L 76 211 211 211 76 211 M 77 212
212 212 77 212 N 78 213 213 213 78 213 O 79 214 214 214 79
214 P 80 215 215 215 80 215 Q 81 216 216 216 81 216 R 82 217
217 217 82 217 S 83 226 226 226 83 226 T 84 227 227 227 84
227 U 85 228 228 228 85 228 V 86 229 229 229 86 229 W 87 230
230 230 87 230 X 88 231 231 231 88 231 Y 89 232 232 232 89
232 Z 90 233 233 233 90 233 [ 91 186 173 187 91 173 *** ###
92 224 224 188 92 224 ### ] 93 187 189 189 93 189 *** ^ 94
176 95 106 94 95 *** ### _ 95 109 109 109 95 109 &lsquo; 96
121 121 74 96 121 ### a 97 129 129 129 97 129 b 98 130 130
130 98 130 c 99 131 131 131 99 131 d 100 132 132 132 100 132
e 101 133 133 133 101 133 f 102 134 134 134 102 134 g 103
135 135 135 103 135 h 104 136 136 136 104 136 i 105 137 137
137 105 137 j 106 145 145 145 106 145 k 107 146 146 146 107
146 l 108 147 147 147 108 147 m 109 148 148 148 109 148 n
110 149 149 149 110 149 o 111 150 150 150 111 150 p 112 151
151 151 112 151 q 113 152 152 152 113 152 r 114 153 153 153
114 153 s 115 162 162 162 115 162 t 116 163 163 163 116 163
u 117 164 164 164 117 164 v 118 165 165 165 118 165 w 119
166 166 166 119 166 x 120 167 167 167 120 167 y 121 168 168
168 121 168 z 122 169 169 169 122 169 { 123 192 192 251 123
192 ### | 124 79 79 79 124 79 } 125 208 208 253 125 208 ###
~ 126 161 161 255 126 161 ### &lt;DELETE&gt; 127 7 7 7 127 7
&lt;C1 0&gt; 128 32 32 32 194.128 32 &lt;C1 1&gt; 129 33 33
33 194.129 33 &lt;C1 2&gt; 130 34 34 34 194.130 34 &lt;C1
3&gt; 131 35 35 35 194.131 35 &lt;C1 4&gt; 132 36 36 36
194.132 36 &lt;C1 5&gt; 133 21 37 37 194.133 37 *** &lt;C1
6&gt; 134 6 6 6 194.134 6 &lt;C1 7&gt; 135 23 23 23 194.135
23 &lt;C1 8&gt; 136 40 40 40 194.136 40 &lt;C1 9&gt; 137 41
41 41 194.137 41 &lt;C1 10&gt; 138 42 42 42 194.138 42
&lt;C1 11&gt; 139 43 43 43 194.139 43 &lt;C1 12&gt; 140 44
44 44 194.140 44 &lt;C1 13&gt; 141 9 9 9 194.141 9 &lt;C1
14&gt; 142 10 10 10 194.142 10 &lt;C1 15&gt; 143 27 27 27
194.143 27 &lt;C1 16&gt; 144 48 48 48 194.144 48 &lt;C1
17&gt; 145 49 49 49 194.145 49 &lt;C1 18&gt; 146 26 26 26
194.146 26 &lt;C1 19&gt; 147 51 51 51 194.147 51 &lt;C1
20&gt; 148 52 52 52 194.148 52 &lt;C1 21&gt; 149 53 53 53
194.149 53 &lt;C1 22&gt; 150 54 54 54 194.150 54 &lt;C1
23&gt; 151 8 8 8 194.151 8 &lt;C1 24&gt; 152 56 56 56
194.152 56 &lt;C1 25&gt; 153 57 57 57 194.153 57 &lt;C1
26&gt; 154 58 58 58 194.154 58 &lt;C1 27&gt; 155 59 59 59
194.155 59 &lt;C1 28&gt; 156 4 4 4 194.156 4 &lt;C1 29&gt;
157 20 20 20 194.157 20 &lt;C1 30&gt; 158 62 62 62 194.158
62 &lt;C1 31&gt; 159 255 255 95 194.159 255 ###
&lt;NON-BREAKING SPACE&gt; 160 65 65 65 194.160 128.65
&lt;INVERTED EXCLAMATION MARK&gt; 161 170 170 170 194.161
128.66 &lt;CENT SIGN&gt; 162 74 74 176 194.162 128.67 ###
&lt;POUND SIGN&gt; 163 177 177 177 194.163 128.68
&lt;CURRENCY SIGN&gt; 164 159 159 159 194.164 128.69 &lt;YEN
SIGN&gt; 165 178 178 178 194.165 128.70 &lt;BROKEN BAR&gt;
166 106 106 208 194.166 128.71 ### &lt;SECTION SIGN&gt; 167
181 181 181 194.167 128.72 &lt;DIAERESIS&gt; 168 189 187 121
194.168 128.73 *** ### &lt;COPYRIGHT SIGN&gt; 169 180 180
180 194.169 128.74 &lt;FEMININE ORDINAL INDICATOR&gt; 170
154 154 154 194.170 128.81 &lt;LEFT POINTING GUILLEMET&gt;
171 138 138 138 194.171 128.82 &lt;NOT SIGN&gt; 172 95 176
186 194.172 128.83 *** ### &lt;SOFT HYPHEN&gt; 173 202 202
202 194.173 128.84 &lt;REGISTERED TRADE MARK SIGN&gt; 174
175 175 175 194.174 128.85 &lt;MACRON&gt; 175 188 188 161
194.175 128.86 ### &lt;DEGREE SIGN&gt; 176 144 144 144
194.176 128.87 &lt;PLUS-OR-MINUS SIGN&gt; 177 143 143 143
194.177 128.88 &lt;SUPERSCRIPT TWO&gt; 178 234 234 234
194.178 128.89 &lt;SUPERSCRIPT THREE&gt; 179 250 250 250
194.179 128.98 &lt;ACUTE ACCENT&gt; 180 190 190 190 194.180
128.99 &lt;MICRO SIGN&gt; 181 160 160 160 194.181 128.100
&lt;PARAGRAPH SIGN&gt; 182 182 182 182 194.182 128.101
&lt;MIDDLE DOT&gt; 183 179 179 179 194.183 128.102
&lt;CEDILLA&gt; 184 157 157 157 194.184 128.103
&lt;SUPERSCRIPT ONE&gt; 185 218 218 218 194.185 128.104
&lt;MASC. ORDINAL INDICATOR&gt; 186 155 155 155 194.186
128.105 &lt;RIGHT POINTING GUILLEMET&gt; 187 139 139 139
194.187 128.106 &lt;FRACTION ONE QUARTER&gt; 188 183 183 183
194.188 128.112 &lt;FRACTION ONE HALF&gt; 189 184 184 184
194.189 128.113 &lt;FRACTION THREE QUARTERS&gt; 190 185 185
185 194.190 128.114 &lt;INVERTED QUESTION MARK&gt; 191 171
171 171 194.191 128.115 &lt;A WITH GRAVE&gt; 192 100 100 100
195.128 138.65 &lt;A WITH ACUTE&gt; 193 101 101 101 195.129
138.66 &lt;A WITH CIRCUMFLEX&gt; 194 98 98 98 195.130 138.67
&lt;A WITH TILDE&gt; 195 102 102 102 195.131 138.68 &lt;A
WITH DIAERESIS&gt; 196 99 99 99 195.132 138.69 &lt;A WITH
RING ABOVE&gt; 197 103 103 103 195.133 138.70 &lt;CAPITAL
LIGATURE AE&gt; 198 158 158 158 195.134 138.71 &lt;C WITH
CEDILLA&gt; 199 104 104 104 195.135 138.72 &lt;E WITH
GRAVE&gt; 200 116 116 116 195.136 138.73 &lt;E WITH
ACUTE&gt; 201 113 113 113 195.137 138.74 &lt;E WITH
CIRCUMFLEX&gt; 202 114 114 114 195.138 138.81 &lt;E WITH
DIAERESIS&gt; 203 115 115 115 195.139 138.82 &lt;I WITH
GRAVE&gt; 204 120 120 120 195.140 138.83 &lt;I WITH
ACUTE&gt; 205 117 117 117 195.141 138.84 &lt;I WITH
CIRCUMFLEX&gt; 206 118 118 118 195.142 138.85 &lt;I WITH
DIAERESIS&gt; 207 119 119 119 195.143 138.86 &lt;CAPITAL
LETTER ETH&gt; 208 172 172 172 195.144 138.87 &lt;N WITH
TILDE&gt; 209 105 105 105 195.145 138.88 &lt;O WITH
GRAVE&gt; 210 237 237 237 195.146 138.89 &lt;O WITH
ACUTE&gt; 211 238 238 238 195.147 138.98 &lt;O WITH
CIRCUMFLEX&gt; 212 235 235 235 195.148 138.99 &lt;O WITH
TILDE&gt; 213 239 239 239 195.149 138.100 &lt;O WITH
DIAERESIS&gt; 214 236 236 236 195.150 138.101
&lt;MULTIPLICATION SIGN&gt; 215 191 191 191 195.151 138.102
&lt;O WITH STROKE&gt; 216 128 128 128 195.152 138.103 &lt;U
WITH GRAVE&gt; 217 253 253 224 195.153 138.104 ### &lt;U
WITH ACUTE&gt; 218 254 254 254 195.154 138.105 &lt;U WITH
CIRCUMFLEX&gt; 219 251 251 221 195.155 138.106 ### &lt;U
WITH DIAERESIS&gt; 220 252 252 252 195.156 138.112 &lt;Y
WITH ACUTE&gt; 221 173 186 173 195.157 138.113 *** ###
&lt;CAPITAL LETTER THORN&gt; 222 174 174 174 195.158 138.114
&lt;SMALL LETTER SHARP S&gt; 223 89 89 89 195.159 138.115
&lt;a WITH GRAVE&gt; 224 68 68 68 195.160 139.65 &lt;a WITH
ACUTE&gt; 225 69 69 69 195.161 139.66 &lt;a WITH
CIRCUMFLEX&gt; 226 66 66 66 195.162 139.67 &lt;a WITH
TILDE&gt; 227 70 70 70 195.163 139.68 &lt;a WITH
DIAERESIS&gt; 228 67 67 67 195.164 139.69 &lt;a WITH RING
ABOVE&gt; 229 71 71 71 195.165 139.70 &lt;SMALL LIGATURE
ae&gt; 230 156 156 156 195.166 139.71 &lt;c WITH CEDILLA&gt;
231 72 72 72 195.167 139.72 &lt;e WITH GRAVE&gt; 232 84 84
84 195.168 139.73 &lt;e WITH ACUTE&gt; 233 81 81 81 195.169
139.74 &lt;e WITH CIRCUMFLEX&gt; 234 82 82 82 195.170 139.81
&lt;e WITH DIAERESIS&gt; 235 83 83 83 195.171 139.82 &lt;i
WITH GRAVE&gt; 236 88 88 88 195.172 139.83 &lt;i WITH
ACUTE&gt; 237 85 85 85 195.173 139.84 &lt;i WITH
CIRCUMFLEX&gt; 238 86 86 86 195.174 139.85 &lt;i WITH
DIAERESIS&gt; 239 87 87 87 195.175 139.86 &lt;SMALL LETTER
eth&gt; 240 140 140 140 195.176 139.87 &lt;n WITH TILDE&gt;
241 73 73 73 195.177 139.88 &lt;o WITH GRAVE&gt; 242 205 205
205 195.178 139.89 &lt;o WITH ACUTE&gt; 243 206 206 206
195.179 139.98 &lt;o WITH CIRCUMFLEX&gt; 244 203 203 203
195.180 139.99 &lt;o WITH TILDE&gt; 245 207 207 207 195.181
139.100 &lt;o WITH DIAERESIS&gt; 246 204 204 204 195.182
139.101 &lt;DIVISION SIGN&gt; 247 225 225 225 195.183
139.102 &lt;o WITH STROKE&gt; 248 112 112 112 195.184
139.103 &lt;u WITH GRAVE&gt; 249 221 221 192 195.185 139.104
### &lt;u WITH ACUTE&gt; 250 222 222 222 195.186 139.105
&lt;u WITH CIRCUMFLEX&gt; 251 219 219 219 195.187 139.106
&lt;u WITH DIAERESIS&gt; 252 220 220 220 195.188 139.112
&lt;y WITH ACUTE&gt; 253 141 141 141 195.189 139.113
&lt;SMALL LETTER thorn&gt; 254 142 142 142 195.190 139.114
&lt;y WITH DIAERESIS&gt; 255 223 223 223 195.191 139.115</p>

<p>If you would rather see the above table in CCSID 0037
order rather than ASCII + Latin-1 order then run the table
through:</p>

<p>recipe 4</p>

<p>perl -ne
&rsquo;if(/.{33}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,42,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p>If you would rather see it in CCSID 1047 order then
change the digit 42 in the last line to 51, like this:</p>

<p>recipe 5</p>

<p>perl -ne
&rsquo;if(/.{33}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,51,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p>If you would rather see it in POSIX-BC order then change
the digit 51 in the last line to 60, like this:</p>

<p>recipe 6</p>

<p>perl -ne
&rsquo;if(/.{33}{1,3}8}{1,3}8}{1,3}8}{1,3}/)&rsquo; -e
&rsquo;{push(@l,$_)}&rsquo; -e &rsquo;END{print
map{$_-&gt;[0]}&rsquo; -e &rsquo; sort{$a-&gt;[1] &lt;=&gt;
$b-&gt;[1]}&rsquo; -e &rsquo;
map{[$_,substr($_,60,3)]}@l;}&rsquo; perlebcdic.pod</p>

<p>IDENTIFYING CHARACTER CODE SETS To determine the
character set you are running under from perl one could use
the return value of ord() or chr() to test one or more
character values. For example:</p>

<p>$is_ascii = &quot;A&quot; eq chr(65); $is_ebcdic =
&quot;A&quot; eq chr(193);</p>

<p>Also, &quot;&quot; is a &quot;HORIZONTAL
TABULATION&quot; character so that:</p>

<p>$is_ascii = ord(&quot;&quot;) == 9; $is_ebcdic =
ord(&quot;&quot;) == 5;</p>

<p>To distinguish EBCDIC code pages try looking at one or
more of the characters that differ between them. For
example:</p>

<p>$is_ebcdic_37 = &quot;0 eq chr(37); $is_ebcdic_1047 =
&quot;0 eq chr(21);</p>

<p>Or better still choose a character that is uniquely
encoded in any of the code sets, e.g.:</p>

<p>$is_ascii = ord(&rsquo;[&rsquo;) == 91; $is_ebcdic_37 =
ord(&rsquo;[&rsquo;) == 186; $is_ebcdic_1047 =
ord(&rsquo;[&rsquo;) == 173; $is_ebcdic_POSIX_BC =
ord(&rsquo;[&rsquo;) == 187;</p>

<p>However, it would be unwise to write tests such as:</p>

<p>&quot; ne chr(13); # WRONG $is_ascii = &quot; $is_ascii
= &quot;0 ne chr(10); # ILL ADVISED</p>

<p>Obviously the first of these will fail to distinguish
most ASCII platforms from either a CCSID 0037, a 1047, or a
POSIX-BC EBCDIC &quot; eq chr(13) under all of those coded
platform since &quot; character sets. &quot; is chr(10) But
note too that because &quot;0 is chr(13) and &quot; on the
MacIntosh (which is an ASCII platform) the second $is_ascii
test will lead to trouble there.</p>

<p>To determine whether or not perl was built under an
EBCDIC code page you can use the Config module like so:</p>

<p>use Config; $is_ebcdic = $Config{&rsquo;ebcdic&rsquo;}
eq &rsquo;define&rsquo;;</p>

<p>CONVERSIONS tr/// In order to convert a string of
characters from one character set to another a simple list
of numbers, such as in the right columns in the above table,
along with perls tr/// operator is all that is needed. The
data in the table are in ASCII order hence the EBCDIC
columns provide easy to use ASCII to EBCDIC operations that
are also easily reversed.</p>

<p>For example, to convert ASCII to code page 037 take the
output of the second column from the output of recipe 0
(modified to add \ characters) and use it in tr/// like
so:</p>

<p>$cp_037 = &rsquo; 00 01 02 03234 11206177227215216 13 14
15 16 17&rsquo; . &rsquo; 20 21 22 23235205 10207 30
31222217 34 35 36 37&rsquo; . &rsquo;200201202203204 12 27
33210211212213214 05 06 07&rsquo; . &rsquo;220221
26223224225226 04230231232233 24 25236 32&rsquo; . &rsquo;
40240342344340341343345347361242 56 74 50 53174&rsquo; .
&rsquo; 46351352353350355356357354337 41 44 52 51
73254&rsquo; . &rsquo; 55 57302304300301303305307321246 54
45137 76 77&rsquo; . &rsquo;370311312313310315316317314140
72 43100 47 75 42&rsquo; .
&rsquo;330141142143144145146147150151253273360375376261&rsquo;
.
&rsquo;260152153154155156157160161162252272346270306244&rsquo;
.
&rsquo;265176163164165166167170171172241277320335336256&rsquo;
.
&rsquo;136243245267251247266274275276133135257250264327&rsquo;
.
&rsquo;173101102103104105106107110111255364366362363365&rsquo;
.
&rsquo;175112113114115116117120121122271373374371372377&rsquo;
.
&rsquo;134367123124125126127130131132262324326322323325&rsquo;
. &rsquo; 60 61 62 63 64 65 66 67 70
71263333334331332237&rsquo; ;</p>

<p>my $ebcdic_string = $ascii_string; eval
&rsquo;$ebcdic_string =~ tr/&rsquo; . $cp_037 . &rsquo;/
00-377/&rsquo;;</p>

<p>To convert from EBCDIC 037 to ASCII just reverse the
order of the tr/// arguments like so:</p>

<p>my $ascii_string = $ebcdic_string; eval
&rsquo;$ascii_string =~ tr/ 00-377/&rsquo; . $cp_037 .
&rsquo;/&rsquo;;</p>

<p>Similarly one could take the output of the third column
from recipe 0 to obtain a $cp_1047 table. The fourth column
of the output from recipe 0 could provide a $cp_posix_bc
table suitable for transcoding as well.</p>

<p>iconv XPG operability often implies the presence of an
iconv utility available from the shell or from the C
library. Consult your systems documentation for information
on iconv.</p>

<p>On OS/390 or z/OS see the iconv(1) manpage. One way to
invoke the iconv shell utility from within perl would be
to:</p>

<p># OS/390 or z/OS example $ascii_data = &lsquo;echo
&rsquo;$ebcdic_data&rsquo;| iconv -f IBM-1047 -t
ISO8859-1&lsquo;</p>

<p>or the inverse map:</p>

<p># OS/390 or z/OS example $ebcdic_data = &lsquo;echo
&rsquo;$ascii_data&rsquo;| iconv -f ISO8859-1 -t
IBM-1047&lsquo;</p>

<p>For other perl based conversion options see the
Convert::* modules on CPAN.</p>

<p>C RTL The OS/390 and z/OS C run time libraries provide
_atoe() and _etoa() functions.</p>

<p>OPERATOR DIFFERENCES The &quot;..&quot; range operator
treats certain character ranges with care on EBCDIC
platforms. For example the following array will have twenty
six elements on either an EBCDIC platform or an ASCII
platform:</p>

<p>@alphabet = (&rsquo;A&rsquo;..&rsquo;Z&rsquo;); #
$#alphabet == 25</p>

<p>The bitwise operators such as &amp; ^ | may return
different results when operating on string or character data
in a perl program running on an EBCDIC platform than when
run on an ASCII platform. Here is an example adapted from
the one in perlop:</p>

<p># EBCDIC-based examples print &quot;j p 0 ^ &quot; a
h&quot;; # prints &quot;JAPH0 print &quot;JA&quot; | &quot;
ph0; # prints &quot;japh0 print &quot;JAPH0unk&quot; &amp;
&quot;277277277277277&quot;; # prints &quot;japh0; print
&rsquo;p N$&rsquo; ^ &quot; E&lt;H0; # prints
&quot;Perl0;</p>

<p>An interesting property of the 32 C0 control characters
in the ASCII table is that they can &quot;literally&quot; be
constructed as control characters in perl, e.g.
&quot;(chr(0) eq &quot; on EBCDIC platforms has been ported
to take &quot; to chr(1) as well, but the thirty three
characters that result depend on which code page you are
using. The table below uses the character names from the
previous table but with substitutions such as s/START
OF/S.O./; s/END OF /E.O./; s/TRANSMISSION/TRANS./;
s/TABULATION/TAB./; s/VERTICAL/VERT./; s/HORIZONTAL/HORIZ./;
s/DEVICE CONTROL/D.C./; s/SEPARATOR/SEP./; s/NEGATIVE
ACKNOWLEDGE/NEG. ACK./;. The POSIX-BC and 1047 sets are
identical throughout this range and differ from the 0037 set
at only one spot (21 decimal). Note that the &quot;LINE
FEED&quot; character may be generated by &quot; 1047 or
POSIX-BC platforms and cannot be generated as a &quot;
control character on 0037 platforms. Note also that &quot;
characters not one.</p>

<p>chr ord 8859-1 0037 1047 &amp;&amp; POSIX-BC
------------------------------------------------------------------------
&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;
&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;
&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;
&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;
FUNCTION DIFFERENCES chr() chr() must be given an EBCDIC
code number argument to yield a desired character return
value on an EBCDIC platform. For example:</p>

<p>$CAPITAL_LETTER_A = chr(193);</p>

<p>ord() ord() will return EBCDIC code number values on an
EBCDIC platform. For example:</p>

<p>$the_number_193 = ord(&quot;A&quot;);</p>

<p>pack() The c and C templates for pack() are dependent
upon character set encoding. Examples of usage on EBCDIC
include:</p>

<p>$foo = pack(&quot;CCCC&quot;,193,194,195,196); # $foo eq
&quot;ABCD&quot; $foo =
pack(&quot;C4&quot;,193,194,195,196); # same thing</p>

<p>$foo = pack(&quot;ccxxcc&quot;,193,194,195,196); # $foo
eq &quot;AB CD&quot;</p>

<p>print() One must be careful with scalars and strings
that are passed to print that contain ASCII encodings. One
common place for this to occur is in the output of the MIME
type header for CGI script writing. For example, many perl
programming guides recommend something similar to:</p>

<p>print &quot;Content-type:text/html 15 12 15 12&quot;; #
this may be wrong on EBCDIC</p>

<p>Under the IBM OS/390 USS Web Server or WebSphere on z/OS
for example you should instead write that as:</p>

<p>0r0; # OK for DGW print &quot;Content-type:text/html et
alia</p>

<p>That is because the translation from EBCDIC to ASCII is
done by the web server in this case (such code will not be
appropriate for the Macintosh however). Consult your web
servers documentation for further details.</p>

<p>printf() The formats that can convert characters to
numbers and vice versa will be different from their ASCII
counterparts when executed on an EBCDIC platform. Examples
include:</p>

<p>printf(&quot;%c%c%c&quot;,193,194,195); # prints ABC</p>

<p>sort() EBCDIC sort results may differ from ASCII sort
results especially for mixed case strings. This is discussed
in more detail below.</p>

<p>sprintf() See the discussion of printf() above. An
example of the use of sprintf would be:</p>

<p>$CAPITAL_LETTER_A = sprintf(&quot;%c&quot;,193);</p>

<p>unpack() See the discussion of pack() above.</p>

<p>REGULAR EXPRESSION DIFFERENCES As of perl 5.005_03 the
letter range regular expression such as [A-Z] and [a-z] have
been especially coded to not pick up gap characters. For
example, characters such as o &quot;o WITH CIRCUMFLEX&quot;
that lie between I and J would not be matched by the regular
expression range &quot;/[H-K]/&quot;. This works in the
other direction, too, if either of the range end points is
explicitly numeric: &quot;[9-1]&quot; will match
&quot;e&quot;, even though &quot;9&quot; is &quot;i&quot;
and &quot;1 &quot; is &quot;j&quot;, and &quot;e&quot; is a
gap character from the alphabetic viewpoint.</p>

<p>If you do want to match the alphabet gap characters in a
single octet regular expression try matching the hex or
octal code such as &quot;/313/&quot; on EBCDIC or
&quot;/364/&quot; on ASCII platforms to have your regular
expression match &quot;o WITH CIRCUMFLEX&quot;.</p>

<p>Another construct to be wary of is the inappropriate use
of hex or octal constants in regular expressions. Consider
the following set of subs:</p>

<p>sub is_c0 { my $char = substr(shift,0,1); $char =~ /[
00- 37]/; }</p>

<p>sub is_print_ascii { my $char = substr(shift,0,1); $char
=~ /[ 40-176]/; }</p>

<p>sub is_delete { my $char = substr(shift,0,1); $char eq
&quot;177&quot;; }</p>

<p>sub is_c1 { my $char = substr(shift,0,1); $char =~
/[200-237]/; }</p>

<p>sub is_latin_1 { my $char = substr(shift,0,1); $char =~
/[240-377]/; }</p>

<p>The above would be adequate if the concern was only with
numeric code points. However, the concern may be with
characters rather than code points and on an EBCDIC platform
it may be desirable for constructs such as &quot;if
(is_print_ascii(&quot;A&quot;)) {print &quot;A is a
printable character0;}&quot; to print out the expected
message. One way to represent the above collection of
character classification subs that is capable of working
across the four coded character sets discussed in this
document is as follows:</p>

<p>sub Is_c0 { my $char = substr(shift,0,1); if
(ord(&rsquo;^&rsquo;)==94) { # ascii return $char =~ /[ 00-
37]/; } if (ord(&rsquo;^&rsquo;)==176) { # 37 return $char
=~ /[ 00- 03 67 55- 57 26 05 45 13- 23 74 75 62 46 30 31 77
47 34- 37]/; } if (ord(&rsquo;^&rsquo;)==95 ||
ord(&rsquo;^&rsquo;)==106) { # 1047 || posix-bc return $char
=~ /[ 00- 03 67 55- 57 26 05 25 13- 23 74 75 62 46 30 31 77
47 34- 37]/; } }</p>

<p>sub Is_print_ascii { my $char = substr(shift,0,1); $char
=~ /[ !&quot; }</p>

<p>sub Is_delete { my $char = substr(shift,0,1); if
(ord(&rsquo;^&rsquo;)==94) { # ascii return $char eq
&quot;177&quot;; } else { # ebcdic return $char eq &quot;
07&quot;; } }</p>

<p>sub Is_c1 { my $char = substr(shift,0,1); if
(ord(&rsquo;^&rsquo;)==94) { # ascii return $char =~
/[200-237]/; } if (ord(&rsquo;^&rsquo;)==176) { # 37 return
$char =~ /[ 40- 44 25 06 27 50- 54 11 12 33 60 61 32 63- 66
10 70- 73 40 24 76377]/; } if (ord(&rsquo;^&rsquo;)==95) { #
1047 return $char =~ /[ 40- 45 06 27 50- 54 11 12 33 60 61
32 63- 66 10 70- 73 40 24 76377]/; } if
(ord(&rsquo;^&rsquo;)==106) { # posix-bc return $char =~ /[
40- 45 06 27 50- 54 11 12 33 60 61 32 63- 66 10 70- 73 40 24
76137]/; } }</p>

<p>sub Is_latin_1 { my $char = substr(shift,0,1); if
(ord(&rsquo;^&rsquo;)==94) { # ascii return $char =~
/[240-377]/; } if (ord(&rsquo;^&rsquo;)==176) { # 37 return
$char =~
/[101252112261237262152265275264232212137312257274220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200375376373374255256131104105102106103107234110124121-123130125-127214111315316313317314341160335336333334215216337]/;
} if (ord(&rsquo;^&rsquo;)==95) { # 1047 return $char =~
/[101252112261237262152265273264232212260312257274220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200375376373374272256131104105102106103107234110124121-123130125-127214111315316313317314341160335336333334215216337]/;
} if (ord(&rsquo;^&rsquo;)==106) { # posix-bc return $char
=~
/[101252260261237262320265171264232212272312257241220217352372276240266263235332233213267270271253144145142146143147236150164161-163170165-167254151355356353357354277200340376335374255256131104105102106103107234110124121-123130125-127214111315316313317314341160300336333334215216337]/;
} }</p>

<p>Note however that only the &quot;Is_ascii_print()&quot;
sub is really independent of coded character set. Another
way to write &quot;Is_latin_1()&quot; would be to use the
characters in the range explicitly:</p>

<p>sub Is_latin_1 { my $char = substr(shift,0,1); $char =~
/[A
AXAXAXAXAXAXAXAXAXAXAXAXAAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXAXA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~
A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X]/;
}</p>

<p>Although that form may run into trouble in network
transit (due to the presence of 8 bit characters) or on non
ISO-Latin character sets.</p>

<p>SOCKETS Most socket programming assumes ASCII character
encodings in network byte order. Exceptions can include CGI
script writing under a host web server where the server may
take care of translation for you. Most host web servers
convert EBCDIC data to ISO-8859-1 or Unicode on output.</p>

<p>SORTING One big difference between ASCII based character
sets and EBCDIC ones are the relative positions of upper and
lower case letters and the letters compared to the digits.
If sorted on an ASCII based platform the two letter
abbreviation for a physician comes before the two letter for
drive, that is:</p>

<p>@sorted = sort(qw(Dr. dr.)); # @sorted holds
(&rsquo;Dr.&rsquo;,&rsquo;dr.&rsquo;) on ASCII, # but
(&rsquo;dr.&rsquo;,&rsquo;Dr.&rsquo;) on EBCDIC</p>

<p>The property of lower case before uppercase letters in
EBCDIC is even carried to the Latin 1 EBCDIC pages such as
0037 and 1047. An example would be that Ee &quot;E WITH
DIAERESIS&quot; (203) comes before ee &quot;e WITH
DIAERESIS&quot; (235) on an ASCII platform, but the latter
(83) comes before the former (115) on an EBCDIC platform.
(Astute readers will note that the upper case version of ss
&quot;SMALL LETTER SHARP S&quot; is simply &quot;SS&quot;
and that the upper case version of ye &quot;y WITH
DIAERESIS&quot; is not in the 0..255 range but it is at
U+x0178 in Unicode, or &quot;&quot; in a Unicode enabled
Perl).</p>

<p>The sort order will cause differences between results
obtained on ASCII platforms versus EBCDIC platforms. What
follows are some suggestions on how to deal with these
differences.</p>

<p>Ignore ASCII vs. EBCDIC sort differences. This is the
least computationally expensive strategy. It may require
some user education.</p>

<p>MONO CASE then sort data. In order to minimize the
expense of mono casing mixed test try to &quot;tr///&quot;
towards the character set case most employed within the
data. If the data are primarily UPPERCASE non Latin 1 then
apply tr/[a-z]/[A-Z]/ then sort(). If the data are primarily
lowercase non Latin 1 then apply tr/[A-Z]/[a-z]/ before
sorting. If the data are primarily UPPERCASE and include
Latin-1 characters then apply:</p>

<p>tr/[a-z]/[A-Z]/; tr/[A~
A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X]/[A~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~XA~X]/;
s/A~X/SS/g;</p>

<p>then sort(). Do note however that such Latin-1
manipulation does not address the ye &quot;y WITH
DIAERESIS&quot; character that will remain at code point 255
on ASCII platforms, but 223 on most EBCDIC platforms where
it will sort to a place less than the EBCDIC numerals. With
a Unicode enabled Perl you might try:</p>

<p>tr/^?//;</p>

<p>The strategy of mono casing data before sorting does not
preserve the case of the data and may not be acceptable for
that reason.</p>

<p>Convert, sort data, then re convert. This is the most
expensive proposition that does not employ a network
connection.</p>

<p>Perform sorting on one type of platform only. This
strategy can employ a network connection. As such it would
be computationally expensive.</p>

<p>TRANSFORMATION FORMATS There are a variety of ways of
transforming data with an intra character set mapping that
serve a variety of purposes. Sorting was discussed in the
previous section and a few of the other more popular mapping
techniques are discussed next.</p>

<p>URL decoding and encoding Note that some URLs have
hexadecimal ASCII code points in them in an attempt to
overcome character or protocol limitation issues. For
example the tilde character is not on every keyboard hence a
URL of the form:</p>

<p>http://www.pvhp.com/~pvhp/</p>

<p>may also be expressed as either of:</p>

<p>http://www.pvhp.com/%7Epvhp/</p>

<p>http://www.pvhp.com/%7epvhp/</p>

<p>where 7E is the hexadecimal ASCII code point for ~. Here
is an example of decoding such a URL under CCSID 1047:</p>

<p>$url = &rsquo;http://www.pvhp.com/%7Epvhp/&rsquo;; #
this array assumes code page 1047 my @a2e_1047 = ( 0, 1, 2,
3, 55, 45, 46, 47, 22, 5, 21, 11, 12, 13, 14, 15, 16, 17,
18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31, 64,
90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
240,241,242,243,244,245,246,247,248,249,122, 94,
76,126,110,111,
124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
215,216,217,226,227,228,229,230,231,232,233,173,224,189,
95,109,
121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,
7, 32, 33, 34, 35, 36, 37, 6, 23, 40, 41, 42, 43, 44, 9, 10,
27, 48, 49, 26, 51, 52, 53, 54, 8, 56, 57, 58, 59, 4, 20,
62,255, 65,170,
74,177,159,178,106,181,187,180,154,138,176,202,175,188,
144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
100,101, 98,102,
99,103,158,104,116,113,114,115,120,117,118,119,
172,105,237,238,235,239,236,191,128,253,254,251,252,186,174,
89, 68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85,
86, 87, 140,
73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
); $url =~
s/%([0-9a-fA-F]{2})/pack(&quot;c&quot;,$a2e_1047[hex($1)])/ge;</p>

<p>Conversely, here is a partial solution for the task of
encoding such a URL under the 1047 code page:</p>

<p>$url = &rsquo;http://www.pvhp.com/~pvhp/&rsquo;; # this
array assumes code page 1047 my @e2a_1047 = ( 0, 1, 2,
3,156, 9,134,127,151,141,142, 11, 12, 13, 14, 15, 16, 17,
18, 19,157, 10, 8,135, 24, 25,146,143, 28, 29, 30, 31,
128,129,130,131,132,133, 23, 27,136,137,138,139,140, 5, 6,
7, 144,145, 22,147,148,149,150, 4,152,153,154,155, 20,
21,158, 26, 32,160,226,228,224,225,227,229,231,241,162, 46,
60, 40, 43,124, 38,233,234,235,232,237,238,239,236,223, 33,
36, 42, 41, 59, 94, 45,
47,194,196,192,193,195,197,199,209,166, 44, 37, 95, 62, 63,
248,201,202,203,200,205,206,207,204, 96, 58, 35, 64, 39, 61,
34, 216, 97, 98,
99,100,101,102,103,104,105,171,187,240,253,254,177,
176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,
181,126,115,116,117,118,119,120,121,122,161,191,208,
91,222,174,
172,163,165,183,169,167,182,188,189,190,221,168,175,
93,180,215, 123, 65, 66, 67, 68, 69, 70, 71, 72,
73,173,244,246,242,243,245, 125, 74, 75, 76, 77, 78, 79, 80,
81, 82,185,251,252,249,250,255, 92,247, 83, 84, 85, 86, 87,
88, 89, 90,178,212,214,210,211,213, 48, 49, 50, 51, 52, 53,
54, 55, 56, 57,179,219,220,217,218,159 ); # The following
regular expression does not address the # mappings for:
(&rsquo;.&rsquo; =&gt; &rsquo;%2E&rsquo;, &rsquo;/&rsquo;
=&gt; &rsquo;%2F&rsquo;, &rsquo;:&rsquo; =&gt;
&rsquo;%3A&rsquo;) $url =~ s/([ &quot;#%&amp;;&lt;=&gt;
where a more complete solution would split the URL into
components and apply a full s/// substitution only to the
appropriate parts.</p>

<p>In the remaining examples a @e2a or @a2e array may be
employed but the assignment will not be shown explicitly.
For code page 1047 you could use the @a2e_1047 or @e2a_1047
arrays just shown.</p>

<p>uu encoding and decoding The &quot;u&quot; template to
pack() or unpack() will render EBCDIC data in EBCDIC
characters equivalent to their ASCII counterparts. For
example, the following will print &quot;Yes indeed0 on
either an ASCII or EBCDIC computer:</p>

<p>$all_byte_chrs = &rsquo;&rsquo;; for (0..255) {
$all_byte_chrs .= chr($_); } $uuencode_byte_chrs =
pack(&rsquo;u&rsquo;, $all_byte_chrs); ($uu =
&lt;&lt;&rsquo;ENDOFHEREDOC&rsquo;) =~ s/^//gm;
M&lsquo;&lsquo;$&quot;&lsquo;P0%!@&lt;(&quot;0H+#&lsquo;T.#Q&lsquo;1$A,4%187&amp;!D:&amp;QP=&rsquo;A@(2(C)&quot;4F)R@I*BLL
M+2XO,#$R,S0U-C&lt;X.3H[/#T^/T!!0D-$149&rsquo;2$E*2TQ-3D]045)35%565UA9
M6EM&lt;75Y?8&amp;%B8V1E9F=H:6IK;&amp;UN;W!Q&lt;G-T=79W&gt;&rsquo;EZ&gt;WQ]?G^&lsquo;@8*#A(6&amp;
MAXB)BHN,C8Z/D)&amp;2DY25EI&gt;8F9J;G)V&gt;GZ&quot;AHJ.DI::GJ*FJJZRMKJ^PL;*S
MM+6VM[BYNKNZ_P,&rsquo;&quot;P3%QL?(R&lt;K+S,W.S]#1TM/4U=;7V-G:V]S=WM_@
?X&gt;+CY.7FY^CIZNOL[&gt;[O&rsquo;R_3U]O?X^?K[_/W^_P&lsquo;&lsquo;
ENDOFHEREDOC if ($uuencode_byte_chrs eq $uu) { print
&quot;Yes &quot;; } $uudecode_byte_chrs =
unpack(&rsquo;u&rsquo;, $uuencode_byte_chrs); if
($uudecode_byte_chrs eq $all_byte_chrs) { print
&quot;indeed0; }</p>

<p>Here is a very spartan uudecoder that will work on
EBCDIC provided that the @e2a array is filled in
appropriately:</p>

<p>#!/usr/local/bin/perl @e2a = ( # this must be filled in
); $_ = &lt;&gt; until ($mode,$file) = /^begin(*)()/;
open(OUT, &quot;&gt; $file&quot;) if $file ne &quot;&quot;;
while(&lt;&gt;) { last if /^end/; next if /[a-z]/; next
unless int(((($e2a[ord()] - 32 ) &amp; 077) + 2) / 3) ==
int(length() / 4); print OUT unpack(&quot;u&quot;, $_); }
close(OUT); chmod oct($mode), $file;</p>

<p>Quoted-Printable encoding and decoding On ASCII encoded
platforms it is possible to strip characters outside of the
printable set using:</p>

<p># This QP encoder works on ASCII only $qp_string =~
s/([=0-F0-])/sprintf(&quot;=%02X&quot;,ord($1))/ge;</p>

<p>Whereas a QP encoder that works on both ASCII and EBCDIC
platforms would look somewhat like the following (where the
EBCDIC branch @e2a array is omitted for brevity):</p>

<p>if (ord(&rsquo;A&rsquo;) == 65) { # ASCII $delete =
&quot;F&quot;; # ASCII @e2a = (0 .. 255) # ASCII to ASCII
identity map } else { # EBCDIC $delete = &quot;7&quot;; #
EBCDIC @e2a = # EBCDIC to ASCII map (as shown above) }
$qp_string =~ s/([^ !&quot; (although in production code the
substitutions might be done in the EBCDIC branch with the
@e2a array and separately in the ASCII branch without the
expense of the identity map).</p>

<p>Such QP strings can be decoded with:</p>

<p># This QP decoder is limited to ASCII only $string =~
s/=([0-9A-Fa-f][0-9A-Fa-f])/chr hex $1/ge; $string =~
s/=[0r]+$//;</p>

<p>Whereas a QP decoder that works on both ASCII and EBCDIC
platforms would look somewhat like the following (where the
@a2e array is omitted for brevity):</p>

<p>$string =~ s/=([0-9A-Fa-f][0-9A-Fa-f])/chr $a2e[hex
$1]/ge; $string =~ s/=[0r]+$//;</p>

<p>Caesarian ciphers The practice of shifting an alphabet
one or more characters for encipherment dates back thousands
of years and was explicitly detailed by Gaius Julius Caesar
in his Gallic Wars text. A single alphabet shift is
sometimes referred to as a rotation and the shift amount is
given as a number $n after the string rot or
&quot;rot$n&quot;. Rot0 and rot26 would designate identity
maps on the 26 letter English version of the Latin alphabet.
Rot13 has the interesting property that alternate subsequent
invocations are identity maps (thus rot13 is its own non-
trivial inverse in the group of 26 alphabet rotations).
Hence the following is a rot13 encoder and decoder that will
work on ASCII and EBCDIC platforms:</p>

<p>#!/usr/local/bin/perl</p>

<p>while(&lt;&gt;){ tr/n-za-mN-ZA-M/a-zA-Z/; print; }</p>

<p>In one-liner form:</p>

<p>perl -ne &rsquo;tr/n-za-mN-ZA-M/a-zA-Z/;print&rsquo;</p>

<p>Hashing order and checksums To the extent that it is
possible to write code that depends on hashing order there
may be differences between hashes as stored on an ASCII
based platform and hashes stored on an EBCDIC based
platform. XXX</p>

<p>I18N AND L10N Internationalization(I18N) and
localization(L10N) are supported at least in principle even
on EBCDIC platforms. The details are system dependent and
discussed under the &quot;OS ISSUES&quot; in perlebcdic
section below.</p>

<p>MULTI OCTET CHARACTER SETS Perl may work with an
internal UTF-EBCDIC encoding form for wide characters on
EBCDIC platforms in a manner analogous to the way that it
works with the UTF-8 internal encoding form on ASCII based
platforms.</p>

<p>Legacy multi byte EBCDIC code pages XXX.</p>

<p>OS ISSUES There may be a few system dependent issues of
concern to EBCDIC Perl programmers.</p>

<p>OS/400 PASE The PASE environment is runtime environment
for OS/400 that can run executables built for PowerPC AIX in
OS/400, see perlos400. PASE is ASCII-based, not EBCDIC-based
as the ILE.</p>

<p>IFS access XXX.</p>

<p>OS/390, z/OS Perl runs under Unix Systems Services or
USS.</p>

<p>chcp chcp is supported as a shell utility for displaying
and changing ones code page. See also chcp.</p>

<p>dataset access For sequential data set access try:</p>

<p>my @ds_records = &lsquo;cat //DSNAME&lsquo;;</p>

<p>or:</p>

<p>my @ds_records = &lsquo;cat
//&rsquo;HLQ.DSNAME&rsquo;&lsquo;;</p>

<p>See also the OS390::Stdio module on CPAN.</p>

<p>OS/390, z/OS iconv iconv is supported as both a shell
utility and a C RTL routine. See also the iconv(1) and
iconv(3) manual pages.</p>

<p>locales On OS/390 or z/OS see locale for information on
locales. The L10N files are in /usr/nls/locale.
$Config{d_setlocale} is define on OS/390 or z/OS.</p>

<p>VM/ESA? XXX.</p>

<p>POSIX-BC? XXX.</p>

<p>BUGS This pod document contains literal Latin 1
characters and may encounter translation difficulties. In
particular one popular nroff implementation was known to
strip accented characters to their unaccented counterparts
while attempting to view this document through the pod2man
program (for example, you may see a plain &quot;y&quot;
rather than one with a diaeresis as in ye). Another nroff
truncated the resultant manpage at the first occurrence of 8
bit characters.</p>

<p>Not all shells will allow multiple &quot;-e&quot; string
arguments to perl to be concatenated together properly as
recipes 0, 2, 4, 5, and 6 might seem to imply.</p>

<p>SEE ALSO perllocale, perlfunc, perlunicode, utf8.</p>

<p>REFERENCES
&lt;http://anubis.dkuug.dk/i18n/charmaps&gt;</p>

<p>&lt;http://www.unicode.org/&gt;</p>


<p>&lt;http://www.unicode.org/unicode/reports/tr16/&gt;</p>

<p>&lt;http://www.wps.com/texts/codes/&gt; ASCII: American
Standard Code for Information Infiltration Tom Jennings,
September 1999.</p>

<p>The Unicode Standard, Version 3.0 The Unicode
Consortium, Lisa Moore ed., ISBN 0-201-61633-5, Addison
Wesley Developers Press, February 2000.</p>

<p>CDRA: IBM - Character Data Representation Architecture -
Reference and Registry, IBM SC09-2190-00, December 1996.</p>

<p>&quot;Demystifying Character Sets&quot;, Andrea Vine,
Multilingual Computing &amp; Technology, #26 Vol. 10 Issue
4, August/September 1999; ISSN 1523-0309; Multilingual
Computing Inc. Sandpoint ID, USA.</p>

<p>Codes, Ciphers, and Other Cryptic and Clandestine
Communication Fred B. Wrixon, ISBN 1-57912-040-7, Black Dog
&amp; Leventhal Publishers, 1998.</p>

<p>&lt;http://www.bobbemer.com/P-BIT.HTM&gt; IBM - EBCDIC
and the P-bit; The biggest Computer Goof Ever Robert
Bemer.</p>

<p>HISTORY 15 April 2001: added UTF-8 and UTF-EBCDIC to
main table, pvhp.</p>

<p>AUTHOR Peter Prymmer pvhp@best.com wrote this in 1999
and 2000 with CCSID 0819 and 0037 help from Chris Leach and
Andre Pirard A.Pirard@ulg.ac.be as well as POSIX-BC help
from Thomas Dorner Thomas.Dorner@start.de. Thanks also to
Vickie Cooper, Philip Newton, William Raffloer, and Joe
Smith. Trademarks, registered trademarks, service marks and
registered service marks used in this document are the
property of their respective owners.</p>

<p>perl v5.10.1 2009-04-11 PERLEBCDIC(1)</p>
<hr>
</body>
</html>
