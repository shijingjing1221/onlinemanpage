<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:21:14 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LATRACE(1) [FIXME: manual] LATRACE(1)</p>

<p>NAME latrace - LD_AUDIT 2.4+ libc frontend</p>

<p>SYNOPSIS latrace [-ltfsbcCpADaoyIiBdvTFELVh] command
[arg ... ]</p>

<p>DESCRIPTION latrace is able to run a command and display
its dynamic library calls using a LD_AUDIT libc feature
(available from libc version 2.4 onward - see the section
called DISCUSSION ). It is also capable to measure and
display various statistics of dynamic calls.</p>

<p>If the config file is provided, latrace will display
symbols arguments with detailed output for structures. The
config file syntax is similar to the C language, with
several exceptions (see the section called CONFIG).</p>

<p>The latrace by default fully operates inside of the
traced program. However another pipe mode is available, to
move the main work to the latrace binary (see the section
called PIPE mode).</p>

<p>Its use is very similar to strace(1) and ltrace(1).</p>

<p>OPTIONS -l, --libs lib1[,lib2,...] audit from and to
lib1, lib2 ...</p>

<p>-t, --libs-to lib1[,lib2,...] audit to lib1, lib2
...</p>

<p>-f, --libs-from lib1[,lib2,...] audit from lib1, lib2
...</p>

<p>-s, --sym sym1[,sym2,...] audit symbols sym1, sym2
...</p>

<p>-S, --timestamp display timestamp for each symbol</p>

<p>-b, --flow-below sym1[,sym2,...] display flow for sym1,
sym2 ...</p>

<p>-c, --counts display statistics counts of symbols -
implies pipe mode (see the section called PIPE mode ) an no
symbol output is displayed</p>

<p>-C, --sort-counts stat implies -c, plus sort the
statistics by stat with following values:
time,per,call,ucall,lib,sym (default is call)</p>

<p>-p, --pipe use pipe to latrace process to send audit
data (see the section called PIPE mode)</p>

<p>-o, --output file store output to file</p>

<p>-A, --enable-args enable arguments output (definitions
from /etc/latrace.conf)</p>

<p>-D, --detail-args display struct arguments in more
detail</p>

<p>-a, --args file specify arguments definition file,
implies -A (without the default definition file of
course)</p>

<p>-y, --framesize number framesize for storing the stack
before pltexit (default 100)</p>

<p>-I, --no-indent-sym do no indent symbols based on the
their stack depth</p>

<p>-i, --indent-sym indent_size indent size specification
in indent_size</p>

<p>-B, --braces allways display { } for the around the
symbol body</p>

<p>-d, --demangle C++ demangle symbols on the output</p>

<p>-v, --verbose verbose output</p>

<p>-T, --hide-tid dont display thread id</p>

<p>-F, --not-follow-fork dont follow fork calls (childs).
This is just supressing the latrace output from new childs.
The nature of the LD_AUDIT feature prevents to disable it
completely.</p>

<p>-E, --not-follow-exec dont follow exec calls</p>

<p>-R, --ctl-config controled config feature</p>

<p>-q, --disable run with disabled auditing (enabled
-R)</p>

<p>EXAMPLES &middot; The simplest way to run latrace is
like this:</p>

<p>&middot; latrace cat**</p>

<p>&middot; To see the argument values specified by default
config file run:</p>

<p>&middot; latrace -A cat**</p>

<p>&middot; Same as above but using the pipe mode to get
all the end symbols printed:</p>

<p>&middot; latrace -Ap cat**</p>

<p>&middot; To see the argument values specified by
specified config file run:</p>

<p>&middot; latrace -a latrace.conf cat**</p>

<p>&middot; To get output only for specified symbol (eg.
read and write) run:</p>

<p>&middot; latrace -A -s read,write cat**</p>

<p>&middot; To get flow under the specified symbol (eg.
sysconf) run:</p>

<p>&middot; latrace -b sysconf kill**</p>

<p>&middot; To get output only for specified library (eg.
libproc) run:</p>

<p>&middot; latrace -Al libproc w**</p>

<p>&middot; To get symbol statistics run:</p>

<p>&middot; latrace -c ls**</p>

<p>&middot; To get symbol statistics sorted by time
run:</p>

<p>&middot; latrace -C time ls**</p>

<p>&middot; To get output stored to the text file run:</p>

<p>&middot; latrace -o output.latrace ls**</p>

<p>&middot; To change the libkrava1.so dependency to the
libkrava2.so run one of these:</p>

<p>&middot; latrace -L krava1%krava2 ex**</p>

<p>&middot; latrace -L krava1~libkrava2.so ex**</p>

<p>&middot; latrace -L libkrava1.so=libkrava2.so ex**</p>

<p>DISCUSSION LD_AUDIT This is just a brief and vague
description of the LD_AUDIT feature. For more information
look to rtld-audit(7) man done by Petr Baudis or study the
glibc/latrace source code. Very brief explanation
follows.</p>

<p>The libc dynamic linker audit feature allows to
trace/audit programs symbols/libraries. The feature is
enabled by the LD_AUDIT environment variable. This variable
must contain path to the audit shared library. This audit
library needs to follow specific interface. The interface
functions will be then called by the dynamic linker
appropriatelly.</p>

<p>The audit library needs to export following symbols (the
&quot;la_PLTENTER&quot; and &quot;la_PLTEXIT&quot; names are
architecture dependent).</p>

<p>&quot;la_activity&quot; &quot;la_objsearch&quot;
&quot;la_objopen&quot; &quot;la_preinit&quot;
&quot;la_symbind32&quot; &quot;la_symbind64&quot;
&quot;la_PLTENTER&quot; &quot;la_PLTEXIT&quot;
&quot;la_objclose&quot;</p>

<p>+</p>

<p>As for the latrace package the audit shared library is
called libltaudit.so.</p>

<p>OBJSEARCH The objsearch LD_AUDIT interface provide means
for changing traced program shared object names/locations.
The -L option argument should have following form:</p>

<p>-L s1[,s2,...] where sN is src [=%~] dst</p>

<p>The src is the source pattern/name and dst is the
destination name/pattern.</p>

<p>= Comparing src with the library name. If matched,
replace the library name with dst. library name -
/lib/krava1.so src - /lib/krava1.so dst - /lib/krava2.so</p>

<p>final library name - /lib/krava2.so</p>

<p>% Looking for the src in the library name. If found,
replace the src with dst part. library name - /lib/krava1.so
src - krava1 dst - krava2</p>

<p>final library name - /lib/krava2.so</p>

<p>~ Looking for the src in the library name. If found,
replace the library name with dst. library name -
/lib/krava1.so src - krava1 dst - /lib/krava2.so</p>

<p>final library name - /lib/krava2.so</p>

<p>PIPE mode The latrace can work in two modes. The first
one native does does the output directly in the traced
program process. The other one, pipe mode use the IPC fifo
mechanism to send the data from the traced process to the
latrace process. The latrace process is then responsible for
the output. Using the pipe mode you loose the traced program
standard output context with printed symbols.</p>

<p>By using the pipe mode, the latrace is not dependent on
the trace program usage/manipulation of the standard output
descriptor. Also the symbol statistics counts -c, -C options
use the pipe mode to transfer symbol information to the
latrace binary, and the latrace binary does the counts at
the end.</p>

<p>CONFIG The latrace config file allows user to define
symbols as an classic C functions with arguments. Argument
names will be display together with values as the latrace
output. The more arguments are defined, the more performance
and memory penalties should be expected.</p>

<p>The package is delivered with several config files for
the most commonly used functions. List of the glibc header
files used follows (the list mostly follows the ltrace
header files list, and author is willing to update it
according to the needs.</p>

<p>/usr/include/arpa/inet.h /usr/include/ctype.h
/usr/include/stdlib.h /usr/include/string.h
/usr/include/ctype.h /usr/include/ncurses.h
/usr/include/stdio.h /usr/include/dirent.h
/usr/include/unistd.h /usr/include/libintl.h
/usr/include/dlfcn.h /usr/include/fcntl.h
/usr/include/getopt.h /usr/include/signal.h
/usr/include/sys/ioctl.h /usr/include/sys/socket.h
/usr/include/netdb.h /usr/include/pthread.h
/usr/include/sys/resource.h /usr/include/sys/mman.h</p>

<p>+</p>

<p>The config file structure consists of /etc/latrace.conf
file, which is the default one read by latrace. This config
file includes other config files placed in the
/etc/latrace.d directory. This directory contain all the
config files for the above mentioned header files.</p>

<p>As already mentioned, the latrace config file syntax
lightly follows the C language syntax. Following part
describes the latrace config file language.</p>

<p>&middot; Several POD types (plain old data), are
hardcoded in latrace. Size of those arguments is determined
by the sizeof macro. The list follows.</p>

<p>void char u_char short u_short int u_int long u_long
llong u_llong # (long long) float double</p>

<p>&middot; The typedef keyword allows to specify new type
based on the already existing one (POD or typedefed).
Eventhough theres a way for multiple pointer layers in the
type definition (*), only one is taken.</p>

<p>typedef base_type new_type; typedef base_type *
new_type; typedef base_type ** new_type;</p>

<p>&middot; Comments follow the C style / logic.</p>

<p>/comments</p>

<p>&middot; The include keyword allows to include another
config file.</p>

<p>#include &quot;filename&quot;</p>

<p>&middot; The struct keyword allows to define the
structure. The syntax folows following grammar rules.</p>

<p>START:: struct NAME { STRUCT_DEF }; STRUCT_DEF:: DEF |
EMPTY DEF:: NAME NAME | NAME &acute;*&acute; NAME | struct
NAME NAME | struct NAME &acute;*&acute; NAME NAME::
[-0-9a-zA-Z_]+</p>

<p>&middot; The function definition follows following
syntax (DEF and NAME are the same as for struct
definition).</p>

<p>START:: DEF &acute;(&acute; ARGS &acute;)&acute;
&acute;;&acute; ARGS:: ARGS &acute;,&acute; DEF | DEF |
EMPTY</p>

<p>&middot; The enum definition follows following syntax
(NAME is same as for struct definition).</p>

<p>START:: ENUM NAME &acute;{&acute; ENUM_DEF
&acute;}&acute; &acute;;&acute; ENUM_DEF:: ENUM_DEF
&acute;,&acute; ENUM_ELEM | ENUM_ELEM ENUM_ELEM:: NAME
&acute;=&acute; NAME | NAME</p>

<p>&middot; Example of a simple latrace config file.</p>

<p>---[ cut here ]----------------------------- enum krava
{ krava1 = 1, krava2, krava3 = 100 };</p>

<p>#include &quot;krava.conf&quot;</p>

<p>typedef u_int pid_t;</p>

<p>struct ex_st { pid_t p; int cnt; char *name; };</p>

<p>int f1(pid_t p, struct ex_st *k); int f2(char* name,
struct ex_st k, int k = krava); struct ex_st* f3(pid_t *p,
struct ex_st k); ---[ cut here
]-----------------------------</p>

<p>&middot; Arrays are not supported yet, so theres no way
to define some structures. For such a structures use void*
type where the structure argu- ment is passed by pointer. If
it is passed by value, theres no workaround so far (aside
from filling the structure body with POD types up to the
actual length of the structure :).</p>

<p>&middot; Variable argument lists (va_list/...) are not
supported yet. The function definition needs to stop before
the first variable argument list argument.</p>

<p>PORTS Author is willing to port the latrace to any
architecture, as long as he got an access to corresponding
system. Currently functional ports are:</p>

<p>x86 ok</p>

<p>x86_64 ok</p>

<p>arm ok (contributed and maintained by Akos Pasztory)</p>

<p>LD_AUDIT related glibc bugs:</p>

<p>&middot; Bug 7055 (no longer reproducible) LD_AUDIT -
gettimeofday function segfaults if called from interface
http://sources.redhat.com/bugzilla/show_bug.cgi?id=7055</p>

<p>&middot; Bug 9893 (FIXED in 2.10) LD_AUDIT - misaligned
_dl_call_pltexit parameter causing crash in audit library
http://sources.redhat.com/bugzilla/show_bug.cgi?id=9893</p>

<p>&middot; Bug 3924 (FIXED in 2.7-2) LD_AUDIT
implementation causing process segfaulting
http://sourceware.org/bugzilla/show_bug.cgi?id=3924</p>

<p>BUGS MANY, plz report bugs to
&lt;olsajiri@gmail.com[1]&gt;. You can also visit the
latrace.sf.net page to see the latest release notes
information.</p>

<p>AUTHOR Jiri Olsa &lt;olsajiri@gmail.com[1]&gt;</p>

<p>CONTRIBUTORS &middot; Nix
&lt;nix@esperi.org.uk[2]&gt;</p>

<p>&middot; Akos Pasztory
&lt;akos.pasztory@gmail.com[3]&gt;</p>

<p>LICENSE This is free software, distributed under the
GPLv3 license.</p>

<p>SEE ALSO strace(1), ltrace(1)</p>

<p>NOTES 1. olsajiri@gmail.com
mailto:olsajiri@gmail.com</p>

<p>2. nix@esperi.org.uk mailto:nix@esperi.org.uk</p>

<p>3. akos.pasztory@gmail.com
mailto:akos.pasztory@gmail.com</p>

<p>[FIXME: source] 06/04/2010 LATRACE(1)</p>
<hr>
</body>
</html>
