<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:40 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>jar(1) Basic Tools jar(1)</p>

<p>NAME jar - Manipulates Java Archive (JAR) files.</p>

<p>SYNOPSIS Create JAR file</p>

<p>jar c[efmMnv0] [entrypoint] [jarfile] [manifest] [-C
dir] file ... [-Joption ...] [@arg-file ...]</p>

<p>Update JAR file</p>

<p>jar u[efmMnv0] [entrypoint] [jarfile] [manifest] [-C
dir] file ... [-Joption ...] [@arg-file ...]</p>

<p>Extract JAR file</p>

<p>jar x[vf] [jarfile] file ... [-Joption ...] [@arg-file
...]</p>

<p>List Contents of JAR file</p>

<p>jar t[vf] [jarfile] file ... [-Joption ...] [@arg-file
...]</p>

<p>Add Index to JAR file</p>

<p>jar i jarfile [-Joption ...] [@arg-file ...]</p>

<p>DESCRIPTION The jar command is a general-purpose
archiving and compression tool, based on ZIP and the ZLIB
compression format. However, the jar command was designed
mainly to package Java applets or applications into a single
archive. When the components of an applet or application
(files, images and sounds) are combined into a single
archive, they can be downloaded by a Java agent (such as a
browser) in a single HTTP transaction, rather than requiring
a new connection for each piece. This dramatically improves
download times. The jar command also compresses files, which
further improves download time. The jar command also allows
individual entries in a file to be signed by the applet
author so that their origin can be authenticated. A JAR file
can be used as a class path entry, whether or not it is
compressed.</p>

<p>The syntax for the jar command resembles the syntax for
the tar command. It has several operation modes, defined by
one of the mandatory operation arguments. Other arguments
are either options that modify the behavior of the
operation, or operands required to perform the
operation.</p>

<p>OPERATION ARGUMENTS When using the jar command, you have
to select an operation to be performed by specifying one of
the following operation arguments. You can mix them up with
other one-letter options on the command line, but usually
the operation argument is the first argument specified.</p>

<p>c Create a new JAR archive.</p>

<p>i Generate index information for a JAR archive.</p>

<p>t List the contents of a JAR archive.</p>

<p>u Update a JAR archive.</p>

<p>x Extract files from a JAR archive.</p>

<p>OPTIONS Use the following options to customize how the
JAR file is created, updated, extracted, or viewed:</p>

<p>e Sets the class specified by the entrypoint operand to
be the entry point for a standalone Java application bundled
into an executable JAR file. The use of this option creates
or overrides the Main-Class attribute value in the manifest
file. The e option can be used when creating (c) or updating
(u) the JAR file.</p>

<p>For example, the following command creates the Main.jar
archive with the Main.class file where the Main-Class
attribute value in the manifest is set to Main:</p>

<p>jar cfe Main.jar Main Main.class</p>

<p>The Java Runtime Environment (JRE) can directly call
this application by running the following command:</p>

<p>java -jar Main.jar</p>

<p>If the entry point class name is in a package, then it
could use either the dot (.) or slash (/) as the delimiter.
For example, if Main.class is in a package called mydir,
then the entry point can be specified in one of the
following ways:</p>

<p>jar -cfe Main.jar mydir/Main mydir/Main.class jar -cfe
Main.jar mydir.Main mydir/Main.class</p>

<p>Note</p>

<p>Specifying both m and e options together when a
particular manifest also contains the Main-Class attribute
results in an ambiguous Main-Class specification. The
ambiguity leads to an error and the jar command creation or
update operation is terminated.</p>

<p>f Sets the file specified by the jarfile operand to be
the name of the JAR file that is created (c), updated (u),
extracted (x) from, or viewed (t). Omitting the f option and
the jarfile operand instructs the jar command to accept the
JAR file name from stdin (for x and t) or send the JAR file
to stdout (for c and u).</p>

<p>m Includes names and values of attributes from the file
specified by the manifest operand in the manifest file of
the jar command (located in the archive at
META-INF/MANIFEST.MF). The jar command adds the attributes
name and value to the JAR file unless an entry already
exists with the same name, in which case the jar command
updates the value of the attribute. The m option can be used
when creating (c) or updating (u) the JAR file.</p>

<p>You can add special-purpose name-value attribute pairs
to the manifest that are not contained in the default
manifest file. For example, you can add attributes that
specify vendor information, release information, package
sealing, or to make JAR-bundled applications executable. For
examples of using the m option, see Packaging Programs at
http://docs.oracle.com/javase/tutorial/deployment/jar/index.html</p>

<p>M Does not create a manifest file entry (for c and u),
or delete a manifest file entry when one exists (for u). The
M option can be used when creating (c) or updating (u) the
JAR file.</p>

<p>n When creating (c) a JAR file, this option normalizes
the archive so that the content is not affected by the
packing and unpacking operations of the pack200(1) command.
Without this normalization, the signature of a signed JAR
can become invalid.</p>

<p>v Generates verbose output to standard output. See
Examples.</p>

<p>0 (Zero) Creates (c) or updates (u) the JAR file without
using ZIP compression.</p>

<p>-C dir When creating (c) or updating (u) a JAR file,
this option temporarily changes the directory while
processing files specified by the file operands. Its
operation is intended to be similar to the -C option of the
UNIX tar utility.For example, the following command changes
to the classes directory and adds the Bar.class file from
that directory to my.jar:</p>

<p>jar uf my.jar -C classes Bar.class</p>

<p>The following command changes to the classes directory
and adds to my.jar all files within the classes directory
(without creating a classes directory in the JAR file), then
changes back to the original directory before changing to
the bin directory to add Xyz.class to my.jar.</p>

<p>jar uf my.jar -C classes . -C bin Xyz.class</p>

<p>If classes contained files bar1 and bar2, then the JAR
file will contain the following after running the previous
command:</p>

<p>% jar tf my.jar META-INF/ META-INF/MANIFEST.MF bar1 bar2
Xyz.class</p>

<p>-Joption Sets the specified JVM option to be used when
the JRE runs the JAR file. JVM options are described on the
reference page for the java(1) command. For example,
-J-Xms48m sets the startup memory to 48 MB.</p>

<p>OPERANDS The following operands are recognized by the
jar command.</p>

<p>file When creating (c) or updating (u) a JAR file, the
file operand defines the path and name of the file or
directory that should be added to the archive. When
extracting (x) or listing the contents (t) of a JAR file,
the file operand defines the path and name of the file to be
extrated or listed. At least one valid file or directory
must be specified. Separate multiple file operands with
spaces. If the entrypoint, jarfile, or manifest operands are
used, the file operands must be specified after them.</p>

<p>entrypoint When creating (c) or updating (u) a JAR file,
the entrypoint operand defines the name of the class that
should be the entry point for a standalone Java application
bundled into an executable JAR file. The entrypoint operand
must be specified if the e option is present.</p>

<p>jarfile Defines the name of the file to be created (c),
updated (u), extracted (x), or viewed (t). The jarfile
operand must be specified if the f option is present.
Omitting the f option and the jarfile operand instructs the
jar command to accept the JAR file name from stdin (for x
and t) or send the JAR file to stdout (for c and u).</p>

<p>When indexing (i) a JAR file, specify the jarfile
operand without the f option.</p>

<p>manifest When creating (c) or updating (u) a JAR file,
the manifest operand defines the preexisting manifest files
with names and values of attributes to be included in
MANIFEST.MF in the JAR file. The manifest operand must be
specified if the f option is present.</p>

<p>@arg-file To shorten or simplify the jar command, you
can specify arguments in a separate text file and pass it to
the jar command with the at sign (@) as a prefix. When the
jar command encounters an argument beginning with the at
sign, it expands the contents of that file into the argument
list.</p>

<p>An argument file can include options and arguments of
the jar command (except the -J options, because they are
passed to the launcher, which does not support argument
files). The arguments within a file can be separated by
spaces or newline characters. File names within an argument
file are relative to the current directory from which you
run the jar command, not relative to the location of the
argument file. Wild cards, such as the asterisk (*), that
might otherwise be expanded by the operating system shell,
are not expanded.</p>

<p>The following example, shows how to create a
classes.list file with names of files from the current
directory output by the find command:</p>

<p>find . -name*.class-print &gt; classes.list</p>

<p>You can then execute the jar command and pass the
classes.list file to it using the @arg-file syntax:</p>

<p>jar cf my.jar @classes.list</p>

<p>An argument file can be specified with a path, but any
file names inside the argument file that have relative paths
are relative to the current working directory of the jar
command, not to the path passed in, for example:</p>

<p>jar @dir/classes.list</p>

<p>NOTES The e, f, and m options must appear in the same
order on the command line as the entrypoint, jarfile, and
manifest operands, for example:</p>

<p>jar cmef myManifestFile MyMainClass myFile.jar
*.class</p>

<p>EXAMPLES Example 1 Adding All Files From the Current
Directory With Verbose Output</p>

<p>% ls 1.au Animator.class monkey.jpg 2.au Wave.class
spacemusic.au 3.au at_work.gif</p>

<p>% jar cvf bundle.jar * added manifest adding: 1.au(in =
2324) (out= 67)(deflated 97%) adding: 2.au(in = 6970) (out=
90)(deflated 98%) adding: 3.au(in = 11616) (out=
108)(deflated 99%) adding: Animator.class(in = 2266) (out=
66)(deflated 97%) adding: Wave.class(in = 3778) (out=
81)(deflated 97%) adding: at_work.gif(in = 6621) (out=
89)(deflated 98%) adding: monkey.jpg(in = 7667) (out=
91)(deflated 98%) adding: spacemusic.au(in = 3079) (out=
73)(deflated 97%)</p>

<p>Example 2 Adding Files From Subdirectories</p>

<p>% ls -F audio/ classes/ images/ % jar cvf bundle.jar
audio classes images added manifest adding: audio/(in = 0)
(out= 0)(stored 0%) adding: audio/1.au(in = 2324) (out=
67)(deflated 97%) adding: audio/2.au(in = 6970) (out=
90)(deflated 98%) adding: audio/3.au(in = 11616) (out=
108)(deflated 99%) adding: audio/spacemusic.au(in = 3079)
(out= 73)(deflated 97%) adding: classes/(in = 0) (out=
0)(stored 0%) adding: classes/Animator.class(in = 2266)
(out= 66)(deflated 97%) adding: classes/Wave.class(in =
3778) (out= 81)(deflated 97%) adding: images/(in = 0) (out=
0)(stored 0%) adding: images/monkey.jpg(in = 7667) (out=
91)(deflated 98%) adding: images/at_work.gif(in = 6621)
(out= 89)(deflated 98%)</p>

<p>% ls -F audio/ bundle.jar classes/ images/</p>

<p>Example 3 Listing the Contents of JAR</p>

<p>% jar tf bundle.jar</p>

<p>META-INF/ META-INF/MANIFEST.MF audio/1.au audio/2.au
audio/3.au audio/spacemusic.au classes/Animator.class
classes/Wave.class images/monkey.jpg images/at_work.gif</p>

<p>Example 4 Adding an Index</p>

<p>Use the i option when you split the interdependent
classes for a stock trade application into three JAR files:
main.jar, buy.jar, and sell.jar. If you specify the
Class-Path attribute in the main.jar manifest, then you can
use the i option to speed up the class loading time for your
application:</p>

<p>Class-Path: buy.jar sell.jar jar i main.jar</p>

<p>An INDEX.LIST file is inserted to the META-INF
directory. This enables the application class loader to
download the specified JAR files when it is searching for
classes or resources.</p>

<p>The application class loader uses the information stored
in this file for efficient class loading. To copy
directories, first compress files in dir1 to stdout, then
pipeline and extract from stdin to dir2 (omitting the -f
option from both jar commands):</p>

<p>(cd dir1; jar c .) | (cd dir2; jar x)</p>

<p>SEE ALSO &middot; pack200(1).</p>

<p>&middot; The JAR section of The Java Tutorials at
http://docs.oracle.com/javase/tutorial/deployment/jar/index.html</p>

<p>JDK 8 21 November 2013 jar(1)</p>
<hr>
</body>
</html>
