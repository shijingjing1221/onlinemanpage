<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:33:37 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>selinux_set_mapping(3) SELinux API documentation
selinux_set_mapping(3)</p>

<p>NAME selinux_set_mapping - establish dynamic object
class and permission mapping.</p>

<p>SYNOPSIS #include &lt;selinux/selinux.h&gt;</p>

<p>struct security_class_mapping { const char *name; const
char *perms[]; };</p>

<p>int selinux_set_mapping(struct security_class_mapping
*map);</p>

<p>DESCRIPTION selinux_set_mapping establishes a mapping
from a user-provided ordering of object classes and
permissions to the numbers actually used by the loaded
system policy. Use of this function is highly preferred over
the generated constants in the libselinux header files, as
this method allows the policys class and permission values
to change over time.</p>

<p>After the mapping is established, all libselinux
functions that operate on class and permission values take
the user-provided numbers, which are determined as
follows:</p>

<p>The map argument consists of an array of
security_class_mapping struc- tures, which must be
terminated by a structure having a NULL name field. Except
for this last structure, the name field should refer to the
string name of an object class, and the corresponding perms
field should refer to an array of permission bit names
terminated by a NULL string.</p>

<p>The object classes named in the mapping and the bit
indexes of each set of permission bits named in the mapping
are numbered in order starting from 1. These numbers are the
values that should be passed to subse- quent libselinux
calls.</p>

<p>RETURN VALUE Zero is returned on success. On error, -1
is returned and errno is set appropriately.</p>

<p>ERRORS EINVAL One of the class or permission names
requested in the mapping is not present in the loaded
policy.</p>

<p>ENOMEM An attempt to allocate memory failed.</p>

<p>EXAMPLE struct security_class_mapping map[] = { {
&quot;file&quot;, { &quot;create&quot;, &quot;unlink&quot;,
&quot;read&quot;, &quot;write&quot;, NULL } }, {
&quot;socket&quot;, { &quot;bind&quot;, NULL } }, {
&quot;process&quot;, { &quot;signal&quot;, NULL } }, { NULL
} };</p>

<p>if (selinux_set_mapping(map) &lt; 0) exit(1);</p>

<p>In this example, after the call has succeeded, classes
file, socket, and process will be identified by 1, 2 and 3,
respectively. Permis- sions create, unlink, read, and write
(for the file class) will be identified by 1, 2, 4, and 8
respectively. Classes and permissions not listed in the
mapping cannot be used.</p>

<p>AUTHOR Eamon Walsh &lt;ewalsh@tycho.nsa.gov&gt;</p>

<p>SEE ALSO avc_open(8), selinux(8)</p>

<p>12 Jun 2008 selinux_set_mapping(3)</p>
<hr>
</body>
</html>
