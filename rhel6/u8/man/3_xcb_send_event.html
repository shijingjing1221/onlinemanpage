<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:45:02 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>xcb_send_event(3) XCB Requests xcb_send_event(3)</p>

<p>NAME xcb_send_event - send an event</p>

<p>SYNOPSIS #include &lt;xcb/xproto.h&gt;</p>

<p>Request function xcb_void_cookie_t
xcb_send_event(xcb_connection_t *conn, uint8_t propagate,
xcb_window_t destination, uint32_t event_mask, const char
*event);</p>

<p>REQUEST ARGUMENTS conn The XCB connection to X11.</p>

<p>propagate If propagate is true and no clients have
selected any event on destination, the destination is
replaced with the closest ancestor of destination for which
some client has selected a type in event_mask and for which
no intervening window has that type in its
do-not-propagate-mask. If no such window ex- ists or if the
window is an ancestor of the focus window and InputFocus was
originally specified as the destination, the event is not
sent to any clients. Otherwise, the event is re- ported to
every client selecting on the final destination any of the
types specified in event_mask.</p>

<p>destination The window to send this event to. Every
client which selects any event within event_mask on
destination will get the event.</p>

<p>The special value XCB_SEND_EVENT_DEST_POINTER_WINDOW
refers to the window that contains the mouse pointer.</p>

<p>The special value XCB_SEND_EVENT_DEST_ITEM_FOCUS refers
to the window which has the keyboard focus.</p>

<p>event_mask Event_mask for determining which clients
should receive the specified event. See destination and
propagate.</p>

<p>event The event to send to the specified
destination.</p>

<p>DESCRIPTION Identifies the destination window,
determines which clients should re- ceive the specified
event and ignores any active grabs.</p>

<p>The event must be one of the core events or an event
defined by an ex- tension, so that the X server can
correctly byte-swap the contents as necessary. The contents
of event are otherwise unaltered and unchecked except for
the send_event field which is forced to true.</p>

<p>RETURN VALUE Returns an xcb_void_cookie_t. Errors (if
any) have to be handled in the event loop.</p>

<p>If you want to handle errors directly with
xcb_request_check instead, use xcb_send_event_checked. See
xcb-requests(3) for details.</p>

<p>ERRORS xcb_value_error_t The given event is neither a
core event nor an event defined by an extension.</p>

<p>xcb_window_error_t The specified destination window does
not exist.</p>

<p>EXAMPLE /* * Tell the given window that it was
configured to a size of 800x600 pixels. * */ void
my_example(xcb_connection_t *conn, xcb_window_t window) { /*
Every X11 event is 32 bytes long. Therefore, XCB will copy
32 bytes. * In order to properly initialize these bytes, we
allocate 32 bytes even * though we only need less for an
xcb_configure_notify_event_t */ xcb_configure_notify_event_t
*event = calloc(32, 1);</p>

<p>event-&gt;event = window; event-&gt;window = window;
event-&gt;response_type = XCB_CONFIGURE_NOTIFY;</p>

<p>event-&gt;x = 0; event-&gt;y = 0; event-&gt;width = 800;
event-&gt;height = 600;</p>

<p>event-&gt;border_width = 0; event-&gt;above_sibling =
XCB_NONE; event-&gt;override_redirect = false;</p>

<p>xcb_send_event(conn, false, window,
XCB_EVENT_MASK_STRUCTURE_NOTIFY, (char*)event);
xcb_flush(conn); free(event); }</p>

<p>SEE ALSO xcb-requests(3), xcb-examples(3),
xcb_configure_notify_event_t(3)</p>

<p>AUTHOR Generated from xproto.xml. Contact
xcb@lists.freedesktop.org for cor- rections and
improvements.</p>

<p>X Version 11 libxcb 1.11 xcb_send_event(3)</p>
<hr>
</body>
</html>
