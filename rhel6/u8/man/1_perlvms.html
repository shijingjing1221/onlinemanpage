<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:54 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLVMS(1) Perl Programmers Reference Guide
PERLVMS(1)</p>

<p>NAME perlvms - VMS-specific documentation for Perl</p>

<p>DESCRIPTION Gathered below are notes describing details
of Perl 5 s behavior on VMS. They are a supplement to the
regular Perl 5 documentation, so we have focussed on the
ways in which Perl 5 functions differently under VMS than it
does under Unix, and on the interactions between Perl and
the rest of the operating system. We haven t tried to
duplicate complete descriptions of Perl features from the
main Perl documentation, which can be found in the [.pod]
subdirectory of the Perl distribution.</p>

<p>We hope these notes will save you from confusion and
lost sleep when writing Perl scripts on VMS. If you find
weve missed something you think should appear here, please
dont hesitate to drop a line to vmsperl@perl.org.</p>

<p>Installation Directions for building and installing Perl
5 can be found in the file README.vms in the main source
directory of the Perl distribution..</p>

<p>Organization of Perl Images Core Images During the
installation process, three Perl images are produced.
Miniperl.Exe is an executable image which contains all of
the basic functionality of Perl, but cannot take advantage
of Perl extensions. It is used to generate several files
needed to build the complete Perl and various extensions.
Once youve finished installing Perl, you can delete this
image.</p>

<p>Most of the complete Perl resides in the shareable image
PerlShr.Exe, which provides a core to which the Perl
executable image and all Perl extensions are linked. You
should place this image in Sys$Share, or define the logical
name PerlShr to translate to the full file specification of
this image. It should be world readable. (Remember that if a
user has execute only access to PerlShr, VMS will treat it
as if it were a privileged shareable image, and will
therefore require all downstream shareable images to be
INSTALLed, etc.)</p>

<p>Finally, Perl.Exe is an executable image containing the
main entry point for Perl, as well as some initialization
code. It should be placed in a public directory, and made
world executable. In order to run Perl with command line
arguments, you should define a foreign command to invoke
this image.</p>

<p>Perl Extensions Perl extensions are packages which
provide both XS and Perl code to add new functionality to
perl. (XS is a meta-language which simplifies writing C code
which interacts with Perl, see perlxs for more details.) The
Perl code for an extension is treated like any other library
module - it s made available in your script through the
appropriate &quot;use&quot; or &quot;require&quot;
statement, and usually defines a Perl package containing the
extension.</p>

<p>The portion of the extension provided by the XS code may
be connected to the rest of Perl in either of two ways. In
the static configuration, the object code for the extension
is linked directly into PerlShr.Exe, and is initialized
whenever Perl is invoked. In the dynamic configuration, the
extension s machine code is placed into a separate shareable
image, which is mapped by Perl s DynaLoader when the
extension is &quot;use&quot;d or &quot;require&quot;d in
your script. This allows you to maintain the extension as a
separate entity, at the cost of keeping track of the
additional shareable image. Most extensions can be set up as
either static or dynamic.</p>

<p>The source code for an extension usually resides in its
own directory. At least three files are generally provided:
Extshortname.xs (where Extshortname is the portion of the
extension s name following the last &quot;::&quot;),
containing the XS code, Extshortname.pm, the Perl library
module for the extension, and Makefile.PL, a Perl script
which uses the &quot;MakeMaker&quot; library modules
supplied with Perl to generate a Descrip.MMS file for the
extension.</p>

<p>Installing static extensions Since static extensions are
incorporated directly into PerlShr.Exe, youll have to
rebuild Perl to incorporate a new extension. You should edit
the main Descrip.MMS or Makefile you use to build Perl,
adding the extensions name to the &quot;ext&quot; macro, and
the extension s object file to the &quot;extobj&quot; macro.
You ll also need to build the extensions object file, either
by adding dependencies to the main Descrip.MMS, or using a
separate Descrip.MMS for the extension. Then, rebuild
PerlShr.Exe to incorporate the new code.</p>

<p>Finally, youll need to copy the extension s Perl library
module to the [.Extname] subdirectory under one of the
directories in @INC, where Extname is the name of the
extension, with all &quot;::&quot; replaced by &quot;.&quot;
(e.g. the library module for extension Foo::Bar would be
copied to a [.Foo.Bar] subdirectory).</p>

<p>Installing dynamic extensions In general, the
distributed kit for a Perl extension includes a file named
Makefile.PL, which is a Perl program which is used to create
a Descrip.MMS file which can be used to build and install
the files required by the extension. The kit should be
unpacked into a directory tree not under the main Perl
source directory, and the procedure for building the
extension is simply</p>

<p>$ perl Makefile.PL ! Create Descrip.MMS $ mmk ! Build
necessary files $ mmk test ! Run test code, if supplied $
mmk install ! Install into public Perl tree</p>

<p>N.B. The procedure by which extensions are built and
tested creates several levels (at least 4) under the
directory in which the extension s source files live. For
this reason if you are running a version of VMS prior to
V7.1 you shouldnt nest the source directory too deeply in
your directory structure lest you exceed RMS maximum of 8
levels of subdirectory in a filespec. (You can use rooted
logical names to get another 8 levels of nesting, if you
cant place the files near the top of the physical directory
structure.)</p>

<p>VMS support for this process in the current release of
Perl is sufficient to handle most extensions. However, it
does not yet recognize extra libraries required to build
shareable images which are part of an extension, so these
must be added to the linker options file for the extension
by hand. For instance, if the PGPLOT extension to Perl
requires the PGPLOTSHR.EXE shareable image in order to
properly link the Perl extension, then the line
&quot;PGPLOTSHR/Share&quot; must be added to the linker
options file PGPLOT.Opt produced during the build process
for the Perl extension.</p>

<p>By default, the shareable image for an extension is
placed in the [.lib.site_perl.autoArch.Extname] directory of
the installed Perl directory tree (where Arch is VMS_VAX or
VMS_AXP, and Extname is the name of the extension, with each
&quot;::&quot; translated to &quot;.&quot;). (See the
MakeMaker documentation for more details on installation
options for extensions.) However, it can be manually placed
in any of several locations:</p>

<p>&middot; the [.Lib.Auto.Arch$PVersExtname] subdirectory
of one of the directories in @INC (where PVers is the
version of Perl youre using, as supplied in $], with .
converted to _), or</p>

<p>&middot; one of the directories in @INC, or</p>

<p>&middot; a directory which the extensions Perl library
module passes to the DynaLoader when asking it to map the
shareable image, or</p>

<p>&middot; Sys$Share or Sys$Library.</p>

<p>If the shareable image isnt in any of these places, you
ll need to define a logical name Extshortname, where
Extshortname is the portion of the extension s name after
the last &quot;::&quot;, which translates to the full file
specification of the shareable image.</p>

<p>File specifications Syntax We have tried to make Perl
aware of both VMS-style and Unix-style file specifications
wherever possible. You may use either style, or both, on the
command line and in scripts, but you may not combine the two
styles within a single file specification. VMS Perl
interprets Unix pathnames in much the same way as the CRTL
(e.g. the first component of an absolute path is read as the
device name for the VMS file specification). There are a set
of functions provided in the &quot;VMS::Filespec&quot;
package for explicit interconversion between VMS and Unix
syntax; its documentation provides more details.</p>

<p>We ve tried to minimize the dependence of Perl library
modules on Unix syntax, but you may find that some of these,
as well as some scripts written for Unix systems, will
require that you use Unix syntax, since they will assume
that / is the directory separator, etc. If you find
instances of this in the Perl distribution itself, please
let us know, so we can try to work around them.</p>

<p>Also when working on Perl programs on VMS, if you need a
syntax in a specific operating system format, then you need
either to check the appropriate DECC$ feature logical, or
call a conversion routine to force it to that format.</p>

<p>The feature logical name DECC$FILENAME_UNIX_REPORT
modifies traditional Perl behavior in the conversion of file
specifications from UNIX to VMS format in order to follow
the extended character handling rules now expected by the
CRTL. Specifically, when this feature is in effect, the
&quot;./.../&quot; in a UNIX path is now translated to
&quot;[.^.^.^.]&quot; instead of the traditional VMS
&quot;[...]&quot;. To be compatible with what MakeMaker
expects, if a VMS path cannot be translated to a UNIX path,
it is passed through unchanged, so
&quot;unixify(&quot;[...]&quot;)&quot; will return
&quot;[...]&quot;.</p>

<p>The handling of extended characters is largely complete
in the VMS- specific C infrastructure of Perl, but more work
is still needed to fully support extended syntax filenames
in several core modules. In particular, at this writing
PathTools has only partial support for directories
containing some extended characters.</p>

<p>There are several ambiguous cases where a conversion
routine cannot determine whether an input filename is in
UNIX format or in VMS format, since now both VMS and UNIX
file specifications may have characters in them that could
be mistaken for syntax delimiters of the other type. So some
pathnames simply cannot be used in a mode that allows either
type of pathname to be present. Perl will tend to assume
that an ambiguous filename is in UNIX format.</p>

<p>Allowing &quot;.&quot; as a version delimiter is simply
incompatible with determining whether a pathname is in VMS
format or in UNIX format with extended file syntax. There is
no way to know whether &quot;perl-5.8.6&quot; is a UNIX
&quot;perl-5.8.6&quot; or a VMS &quot;perl-5.8;6&quot; when
passing it to unixify() or vmsify().</p>

<p>The DECC$FILENAME_UNIX_REPORT logical name controls how
Perl interprets filenames to the extent that Perl uses the
CRTL internally for many purposes, and attempts to follow
CRTL conventions for reporting filenames. The
DECC$FILENAME_UNIX_ONLY feature differs in that it expects
all filenames passed to the C run-time to be already in UNIX
format. This feature is not yet supported in Perl since Perl
uses traditional OpenVMS file specifications internally and
in the test harness, and it is not yet clear whether this
mode will be useful or useable. The feature logical name
DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic
Link SDK and included with OpenVMS v8.3, but is not yet
supported in Perl.</p>

<p>Filename Case Perl follows VMS defaults and override
settings in preserving (or not preserving) filename case.
Case is not preserved on ODS-2 formatted volumes on any
architecture. On ODS-5 volumes, filenames may be case
preserved depending on process and feature settings. Perl
now honors DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE
on those systems where the CRTL supports these features.
When these features are not enabled or the CRTL does not
support them, Perl follows the traditional CRTL behavior of
downcasing command-line arguments and returning file
specifications in lower case only.</p>

<p>N. B. It is very easy to get tripped up using a mixture
of other programs, external utilities, and Perl scripts that
are in varying states of being able to handle case
preservation. For example, a file created by an older
version of an archive utility or a build utility such as MMK
or MMS may generate a filename in all upper case even on an
ODS-5 volume. If this filename is later retrieved by a Perl
script or module in a case preserving environment, that
upper case name may not match the mixed-case or lower-case
expections of the Perl code. Your best bet is to follow an
all-or-nothing approach to case preservation: either dont
use it at all, or make sure your entire toolchain and
application environment support and use it.</p>

<p>OpenVMS Alpha v7.3-1 and later and all version of
OpenVMS I64 support case sensitivity as a process setting
(see &quot;SET PROCESS /CASE_LOOKUP=SENSITIVE&quot;). Perl
does not currently suppport case sensitivity on VMS, but it
may in the future, so Perl programs should use the
&quot;File::Spec-&quot;case_tolerant&gt; method to determine
the state, and not the $^O variable.</p>

<p>Symbolic Links When built on an ODS-5 volume with
symbolic links enabled, Perl by default supports symbolic
links when the requisite support is available in the
filesystem and CRTL (generally 64-bit OpenVMS v8.3 and
later). There are a number of limitations and caveats to be
aware of when working with symbolic links on VMS. Most
notably, the target of a valid symbolic link must be
expressed as a UNIX-style path and it must exist on a volume
visible from your POSIX root (see the &quot;SHOW ROOT&quot;
command in DCL help). For further details on symbolic link
capabilities and requirements, see chapter 12 of the CRTL
manual that ships with OpenVMS v8.3 or later.</p>

<p>Wildcard expansion File specifications containing
wildcards are allowed both on the command line and within
Perl globs (e.g. &quot;&lt;*.c&gt;&quot;). If the wildcard
filespec uses VMS syntax, the resultant filespecs will
follow VMS syntax; if a Unix-style filespec is passed in,
Unix-style filespecs will be returned. Similar to the
behavior of wildcard globbing for a Unix shell, one can
escape command line wildcards with double quotation marks
&quot;&quot;&quot; around a perl program command line
argument. However, owing to the stripping of
&quot;&quot;&quot; characters carried out by the C handling
of argv you will need to escape a construct such as this one
(in a directory containing the files PERL.C, PERL.EXE,
PERL.H, and PERL.OBJ):</p>

<p>$ perl -e &quot;print join(&rsquo; &rsquo;,@ARGV)&quot;
perl.* perl.c perl.exe perl.h perl.obj</p>

<p>in the following triple quoted manner:</p>

<p>$ perl -e &quot;print join(&rsquo; &rsquo;,@ARGV)&quot;
&quot;&quot;&quot;perl.*&quot;&quot;&quot; perl.*</p>

<p>In both the case of unquoted command line arguments or
in calls to &quot;glob()&quot; VMS wildcard expansion is
performed. (csh-style wildcard expansion is available if you
use &quot;File::Glob::glob&quot;.) If the wildcard filespec
contains a device or directory specification, then the
resultant filespecs will also contain a device and
directory; otherwise, device and directory information are
removed. VMS-style resultant filespecs will contain a full
device and directory, while Unix-style resultant filespecs
will contain only as much of a directory path as was present
in the input filespec. For example, if your default
directory is Perl_Root:[000000], the expansion of
&quot;[.t]*.*&quot; will yield filespecs like
&quot;perl_root:[t]base.dir&quot;, while the expansion of
&quot;t/*/*&quot; will yield filespecs like
&quot;t/base.dir&quot;. (This is done to match the behavior
of glob expansion performed by Unix shells.)</p>

<p>Similarly, the resultant filespec will contain the file
version only if one was present in the input filespec.</p>

<p>Pipes Input and output pipes to Perl filehandles are
supported; the &quot;file name&quot; is passed to
lib$spawn() for asynchronous execution. You should be
careful to close any pipes you have opened in a Perl script,
lest you leave any &quot;orphaned&quot; subprocesses around
when Perl exits.</p>

<p>You may also use backticks to invoke a DCL subprocess,
whose output is used as the return value of the expression.
The string between the backticks is handled as if it were
the argument to the &quot;system&quot; operator (see below).
In this case, Perl will wait for the subprocess to complete
before continuing.</p>

<p>The mailbox (MBX) that perl can create to communicate
with a pipe defaults to a buffer size of 512. The default
buffer size is adjustable via the logical name PERL_MBX_SIZE
provided that the value falls between 128 and the SYSGEN
parameter MAXBUF inclusive. For example, to double the MBX
size from the default within a Perl program, use
&quot;$ENV{&rsquo;PERL_MBX_SIZE&rsquo;} = 1024;&quot; and
then open and use pipe constructs. An alternative would be
to issue the command:</p>

<p>$ Define PERL_MBX_SIZE 1024</p>

<p>before running your wide record pipe program. A larger
value may improve performance at the expense of the BYTLM
UAF quota.</p>

<p>PERL5LIB and PERLLIB The PERL5LIB and PERLLIB logical
names work as documented in perl, except that the element
separator is | instead of :. The directory specifications
may use either VMS or Unix syntax.</p>

<p>The Perl Forked Debugger The Perl forked debugger places
the debugger commands and output in a separate X-11 terminal
window so that commands and output from multiple processes
are not mixed together.</p>

<p>Perl on VMS supports an emulation of the forked debugger
when Perl is run on a VMS system that has X11 support
installed.</p>

<p>To use the forked debugger, you need to have the default
display set to an X-11 Server and some environment variables
set that Unix expects.</p>

<p>The forked debugger requires the environment variable
&quot;TERM&quot; to be &quot;xterm&quot;, and the
environment variable &quot;DISPLAY&quot; to exist.
&quot;xterm&quot; must be in lower case.</p>

<p>$define TERM &quot;xterm&quot;</p>

<p>$define DISPLAY &quot;hostname:0.0&quot;</p>

<p>Currently the value of &quot;DISPLAY&quot; is ignored.
It is recommended that it be set to be the hostname of the
display, the server and screen in UNIX notation. In the
future the value of DISPLAY may be honored by Perl instead
of using the default display.</p>

<p>It may be helpful to always use the forked debugger so
that script I/O is separated from debugger I/O. You can
force the debugger to be forked by assigning a value to the
logical name &lt;PERLDB_PIDS&gt; that is not a process
identification number.</p>

<p>$define PERLDB_PIDS XXXX</p>

<p>PERL_VMS_EXCEPTION_DEBUG The PERL_VMS_EXCEPTION_DEBUG
being defined as &quot;ENABLE&quot; will cause the VMS
debugger to be invoked if a fatal exception that is not
otherwise handled is raised. The purpose of this is to allow
debugging of internal Perl problems that would cause such a
condition.</p>

<p>This allows the programmer to look at the execution
stack and variables to find out the cause of the exception.
As the debugger is being invoked as the Perl interpreter is
about to do a fatal exit, continuing the execution in debug
mode is usally not practical.</p>

<p>Starting Perl in the VMS debugger may change the program
execution profile in a way that such problems are not
reproduced.</p>

<p>The &quot;kill&quot; function can be used to test this
functionality from within a program.</p>

<p>In typical VMS style, only the first letter of the value
of this logical name is actually checked in a case
insensitive mode, and it is considered enabled if it is the
value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</p>

<p>This logical name must be defined before Perl is
started.</p>

<p>Command line I/O redirection and backgrounding Perl for
VMS supports redirection of input and output on the command
line, using a subset of Bourne shell syntax:</p>

<p>&middot; &quot;&lt;file&quot; reads stdin from
&quot;file&quot;,</p>

<p>&middot; &quot;&gt;file&quot; writes stdout to
&quot;file&quot;,</p>

<p>&middot; &quot;&gt;&gt;file&quot; appends stdout to
&quot;file&quot;,</p>

<p>&middot; &quot;2&gt;file&quot; writes stderr to
&quot;file&quot;,</p>

<p>&middot; &quot;2&gt;&gt;file&quot; appends stderr to
&quot;file&quot;, and</p>

<p>&middot; &quot;2&gt;&amp;1&quot; redirects stderr to
stdout.</p>

<p>In addition, output may be piped to a subprocess, using
the character |. Anything after this character on the
command line is passed to a subprocess for execution; the
subprocess takes the output of Perl as its input.</p>

<p>Finally, if the command line ends with &amp; , the
entire command is run in the background as an asynchronous
subprocess.</p>

<p>Command line switches The following command line
switches behave differently under VMS than described in
perlrun. Note also that in order to pass uppercase switches
to Perl, you need to enclose them in double-quotes on the
command line, since the CRTL downcases all unquoted
strings.</p>

<p>On newer 64 bit versions of OpenVMS, a process setting
now controls if the quoting is needed to preserve the case
of command line arguments.</p>

<p>-i If the &quot;-i&quot; switch is present but no
extension for a backup copy is given, then inplace editing
creates a new version of a file; the existing copy is not
deleted. (Note that if an extension is given, an existing
file is renamed to the backup file, as is the case under
other operating systems, so it does not remain as a previous
version under the original filename.)</p>

<p>-S If the &quot;-S&quot; or &quot;-&quot;S&quot;&quot;
switch is present and the script name does not contain a
directory, then Perl translates the logical name DCL$PATH as
a searchlist, using each translation as a directory in which
to look for the script. In addition, if no file type is
specified, Perl looks in each directory for a file matching
the name specified, with a blank type, a type of .pl, and a
type of .com, in that order.</p>

<p>-u The &quot;-u&quot; switch causes the VMS debugger to
be invoked after the Perl program is compiled, but before it
has run. It does not create a core dump file.</p>

<p>Perl functions As of the time this document was last
revised, the following Perl functions were implemented in
the VMS port of Perl (functions marked with * are discussed
in more detail below):</p>

<p>file tests*, abs, alarm, atan, backticks*, binmode*,
bless, caller, chdir, chmod, chown, chomp, chop, chr, close,
closedir, cos, crypt*, defined, delete, die, do, dump*,
each, endgrent, endpwent, eof, eval, exec*, exists, exit,
exp, fileno, flock getc, getgrent*, getgrgid*, getgrnam,
getlogin, getppid, getpwent*, getpwnam*, getpwuid*, glob,
gmtime*, goto, grep, hex, ioctl, import, index, int, join,
keys, kill*, last, lc, lcfirst, lchown*, length, link*,
local, localtime, log, lstat, m//, map, mkdir, my, next, no,
oct, open, opendir, ord, pack, pipe, pop, pos, print,
printf, push, q//, qq//, qw//, qx//*, quotemeta, rand, read,
readdir, readlink*, redo, ref, rename, require, reset,
return, reverse, rewinddir, rindex, rmdir, s///, scalar,
seek, seekdir, select(internal), select (system call)*,
setgrent, setpwent, shift, sin, sleep, socketpair, sort,
splice, split, sprintf, sqrt, srand, stat, study, substr,
symlink*, sysread, system*, syswrite, tell, telldir, tie,
time, times*, tr///, uc, ucfirst, umask, undef, unlink*,
unpack, untie, unshift, use, utime*, values, vec, wait,
waitpid*, wantarray, warn, write, y///</p>

<p>The following functions were not implemented in the VMS
port, and calling them produces a fatal error (usually) or
undefined behavior (rarely, we hope):</p>

<p>chroot, dbmclose, dbmopen, fork*, getpgrp, getpriority,
msgctl, msgget, msgsend, msgrcv, semctl, semget, semop,
setpgrp, setpriority, shmctl, shmget, shmread, shmwrite,
syscall</p>

<p>The following functions are available on Perls compiled
with Dec C 5.2 or greater and running VMS 7.0 or
greater:</p>

<p>truncate</p>

<p>The following functions are available on Perls built on
VMS 7.2 or greater:</p>

<p>fcntl (without locking)</p>

<p>The following functions may or may not be implemented,
depending on what type of socket support youve built into
your copy of Perl:</p>

<p>accept, bind, connect, getpeername, gethostbyname,
getnetbyname, getprotobyname, getservbyname, gethostbyaddr,
getnetbyaddr, getprotobynumber, getservbyport, gethostent,
getnetent, getprotoent, getservent, sethostent, setnetent,
setprotoent, setservent, endhostent, endnetent, endprotoent,
endservent, getsockname, getsockopt, listen, recv,
select(system call)*, send, setsockopt, shutdown, socket</p>

<p>The following function is available on Perls built on 64
bit OpenVMS v8.2 with hard links enabled on an ODS-5
formatted build disk. CRTL support is in principle available
as of OpenVMS v7.3-1, and better configuration support could
detect this.</p>

<p>link</p>

<p>The following functions are available on Perls built on
64 bit OpenVMS v8.2 and later. CRTL support is in principle
available as of OpenVMS v7.3-2, and better configuration
support could detect this.</p>

<p>getgrgid, getgrnam, getpwnam, getpwuid, setgrent,
ttyname</p>

<p>The following functions are available on Perls built on
64 bit OpenVMS v8.2 and later.</p>

<p>statvfs, socketpair</p>

<p>File tests The tests &quot;-b&quot;, &quot;-B&quot;,
&quot;-c&quot;, &quot;-C&quot;, &quot;-d&quot;,
&quot;-e&quot;, &quot;-f&quot;, &quot;-o&quot;,
&quot;-M&quot;, &quot;-s&quot;, &quot;-S&quot;,
&quot;-t&quot;, &quot;-T&quot;, and &quot;-z&quot; work as
advertised. The return values for &quot;-r&quot;,
&quot;-w&quot;, and &quot;-x&quot; tell you whether you can
actually access the file; this may not reflect the UIC-based
file protections. Since real and effective UIC dont differ
under VMS, &quot;-O&quot;, &quot;-R&quot;, &quot;-W&quot;,
and &quot;-X&quot; are equivalent to &quot;-o&quot;,
&quot;-r&quot;, &quot;-w&quot;, and &quot;-x&quot;.
Similarly, several other tests, including &quot;-A&quot;,
&quot;-g&quot;, &quot;-k&quot;, &quot;-l&quot;,
&quot;-p&quot;, and &quot;-u&quot;, aren t particularly
meaningful under VMS, and the values returned by these tests
reflect whatever your CRTL &quot;stat()&quot; routine does
to the equivalent bits in the st_mode field. Finally,
&quot;-d&quot; returns true if passed a device specification
without an explicit directory (e.g. &quot;DUA1:&quot;), as
well as if passed a directory.</p>

<p>There are DECC feature logical names AND ODS-5 volume
attributes that also control what values are returned for
the date fields.</p>

<p>Note: Some sites have reported problems when using the
file-access tests (&quot;-r&quot;, &quot;-w&quot;, and
&quot;-x&quot;) on files accessed via DEC s DFS.
Specifically, since DFS does not currently provide access to
the extended file header of files on remote volumes,
attempts to examine the ACL fail, and the file tests will
return false, with $! indicating that the file does not
exist. You can use &quot;stat&quot; on these files, since
that checks UIC-based protection only, and then manually
check the appropriate bits, as defined by your C compilers
stat.h, in the mode value it returns, if you need an
approximation of the files protections.</p>

<p>backticks Backticks create a subprocess, and pass the
enclosed string to it for execution as a DCL command. Since
the subprocess is created directly via
&quot;lib$spawn()&quot;, any valid DCL command string may be
specified.</p>

<p>binmode FILEHANDLE The &quot;binmode&quot; operator will
attempt to insure that no translation of carriage control
occurs on input from or output to this filehandle. Since
this involves reopening the file and then restoring its file
position indicator, if this function returns FALSE, the
underlying filehandle may no longer point to an open file,
or may point to a different position in the file than before
&quot;binmode&quot; was called.</p>

<p>Note that &quot;binmode&quot; is generally not necessary
when using normal filehandles; it is provided so that you
can control I/O to existing record-structured files when
necessary. You can also use the &quot;vmsfopen&quot;
function in the VMS::Stdio extension to gain finer control
of I/O to files and devices with different record
structures.</p>

<p>crypt PLAINTEXT, USER The &quot;crypt&quot; operator
uses the &quot;sys$hash_password&quot; system service to
generate the hashed representation of PLAINTEXT. If USER is
a valid username, the algorithm and salt values are taken
from that user s UAF record. If it is not, then the
preferred algorithm and a salt of 0 are used. The quadword
encrypted value is returned as an 8-character string.</p>

<p>The value returned by &quot;crypt&quot; may be compared
against the encrypted password from the UAF returned by the
&quot;getpw*&quot; functions, in order to authenticate
users. If youre going to do this, remember that the
encrypted password in the UAF was generated using uppercase
username and password strings; youll have to upcase the
arguments to &quot;crypt&quot; to insure that youll get the
proper value:</p>

<p>sub validate_passwd { my($user,$passwd) = @_;
my($pwdhash); if ( !($pwdhash = (getpwnam($user))[1]) ||
$pwdhash ne crypt(&quot;U$passwd&quot;,&quot;U$name&quot;) )
{ intruder_alert($name); } return 1; }</p>

<p>die &quot;die&quot; will force the native VMS exit
status to be an SS$_ABORT code if neither of the $! or $?
status values are ones that would cause the native status to
be interpreted as being what VMS classifies as SEVERE_ERROR
severity for DCL error handling.</p>

<p>When &quot;PERL_VMS_POSIX_EXIT&quot; is active (see
&quot;$?&quot; below), the native VMS exit status value will
have either one of the $! or $? or $^E or the UNIX value 255
encoded into it in a way that the effective original value
can be decoded by other programs written in C, including
Perl and the GNV package. As per the normal non-VMS behavior
of &quot;die&quot; if either $! or $? are non-zero, one of
those values will be encoded into a native VMS status value.
If both of the UNIX status values are 0, and the $^E value
is set one of ERROR or SEVERE_ERROR severity, then the $^E
value will be used as the exit code as is. If none of the
above apply, the UNIX value of 255 will be encoded into a
native VMS exit status value.</p>

<p>Please note a significant difference in the behavior of
&quot;die&quot; in the &quot;PERL_VMS_POSIX_EXIT&quot; mode
is that it does not force a VMS SEVERE_ERROR status on exit.
The UNIX exit values of 2 through 255 will be encoded in VMS
status values with severity levels of SUCCESS. The UNIX exit
value of 1 will be encoded in a VMS status value with a
severity level of ERROR. This is to be compatible with how
the VMS C library encodes these values.</p>

<p>The minimum severity level set by &quot;die&quot; in
&quot;PERL_VMS_POSIX_EXIT&quot; mode may be changed to be
ERROR or higher in the future depending on the results of
testing and further review.</p>

<p>See &quot;$?&quot; for a description of the encoding of
the UNIX value to produce a native VMS status containing
it.</p>

<p>dump Rather than causing Perl to abort and dump core,
the &quot;dump&quot; operator invokes the VMS debugger. If
you continue to execute the Perl program under the debugger,
control will be transferred to the label specified as the
argument to &quot;dump&quot;, or, if no label was specified,
back to the beginning of the program. All other state of the
program (e.g. values of variables, open file handles) are
not affected by calling &quot;dump&quot;.</p>

<p>exec LIST A call to &quot;exec&quot; will cause Perl to
exit, and to invoke the command given as an argument to
&quot;exec&quot; via &quot;lib$do_command&quot;. If the
argument begins with @ or $ (other than as part of a
filespec), then it is executed as a DCL command. Otherwise,
the first token on the command line is treated as the
filespec of an image to run, and an attempt is made to
invoke it (using .Exe and the process defaults to expand the
filespec) and pass the rest of &quot;exec&quot;s argument to
it as parameters. If the token has no file type, and matches
a file with null type, then an attempt is made to determine
whether the file is an executable image which should be
invoked using &quot;MCR&quot; or a text file which should be
passed to DCL as a command procedure.</p>

<p>fork While in principle the &quot;fork&quot; operator
could be implemented via (and with the same rather severe
limitations as) the CRTL &quot;vfork()&quot; routine, and
while some internal support to do just that is in place, the
implementation has never been completed, making
&quot;fork&quot; currently unavailable. A true kernel
&quot;fork()&quot; is expected in a future version of VMS,
and the pseudo-fork based on interpreter threads may be
available in a future version of Perl on VMS (see perlfork).
In the meantime, use &quot;system&quot;, backticks, or piped
filehandles to create subprocesses.</p>

<p>getpwent getpwnam getpwuid These operators obtain the
information described in perlfunc, if you have the
privileges necessary to retrieve the named users UAF
information via &quot;sys$getuai&quot;. If not, then only
the $name, $uid, and $gid items are returned. The $dir item
contains the login directory in VMS syntax, while the
$comment item contains the login directory in Unix syntax.
The $gcos item contains the owner field from the UAF record.
The $quota item is not used.</p>

<p>gmtime The &quot;gmtime&quot; operator will function
properly if you have a working CRTL &quot;gmtime()&quot;
routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is
defined as the number of seconds which must be added to UTC
to yield local time. (This logical name is defined
automatically if you are running a version of VMS with
built-in UTC support.) If neither of these cases is true, a
warning message is printed, and &quot;undef&quot; is
returned.</p>

<p>kill In most cases, &quot;kill&quot; is implemented via
the undocumented system service &lt;$SIGPRC&gt;, which has
the same calling sequence as &lt;$FORCEX&gt;, but throws an
exception in the target process rather than forcing it to
call $EXIT. Generally speaking, &quot;kill&quot; follows the
behavior of the CRTL s &quot;kill()&quot; function, but
unlike that function can be called from within a signal
handler. Also, unlike the &quot;kill&quot; in some versions
of the CRTL, Perls &quot;kill&quot; checks the validity of
the signal passed in and returns an error rather than
attempting to send an unrecognized signal.</p>

<p>Also, negative signal values dont do anything special
under VMS; theyre just converted to the corresponding
positive value.</p>

<p>qx// See the entry on &quot;backticks&quot; above.</p>

<p>select (system call) If Perl was not built with socket
support, the system call version of &quot;select&quot; is
not available at all. If socket support is present, then the
system call version of &quot;select&quot; functions only for
file descriptors attached to sockets. It will not provide
information about regular files or pipes, since the CRTL
&quot;select()&quot; routine does not provide this
functionality.</p>

<p>stat EXPR Since VMS keeps track of files according to a
different scheme than Unix, it s not really possible to
represent the files ID in the &quot;st_dev&quot; and
&quot;st_ino&quot; fields of a &quot;struct stat&quot;. Perl
tries its best, though, and the values it uses are pretty
unlikely to be the same for two different files. We cant
guarantee this, though, so caveat scriptor.</p>

<p>system LIST The &quot;system&quot; operator creates a
subprocess, and passes its arguments to the subprocess for
execution as a DCL command. Since the subprocess is created
directly via &quot;lib$spawn()&quot;, any valid DCL command
string may be specified. If the string begins with @, it is
treated as a DCL command unconditionally. Otherwise, if the
first token contains a character used as a delimiter in file
specification (e.g. &quot;:&quot; or &quot;]&quot;), an
attempt is made to expand it using a default type of .Exe
and the process defaults, and if successful, the resulting
file is invoked via &quot;MCR&quot;. This allows you to
invoke an image directly simply by passing the file
specification to &quot;system&quot;, a common Unixish idiom.
If the token has no file type, and matches a file with null
type, then an attempt is made to determine whether the file
is an executable image which should be invoked using
&quot;MCR&quot; or a text file which should be passed to DCL
as a command procedure.</p>

<p>If LIST consists of the empty string, &quot;system&quot;
spawns an interactive DCL subprocess, in the same fashion as
typing SPAWN at the DCL prompt.</p>

<p>Perl waits for the subprocess to complete before
continuing execution in the current process. As described in
perlfunc, the return value of &quot;system&quot; is a fake
&quot;status&quot; which follows POSIX semantics unless the
pragma &quot;use vmsish &rsquo;status&rsquo;&quot; is in
effect; see the description of $? in this document for more
detail.</p>

<p>time The value returned by &quot;time&quot; is the
offset in seconds from 01-JAN-1970 00:00:00 (just like the
CRTLs times() routine), in order to make life easier for
code coming in from the POSIX/Unix world.</p>

<p>times The array returned by the &quot;times&quot;
operator is divided up according to the same rules the CRTL
&quot;times()&quot; routine. Therefore, the &quot;system
time&quot; elements will always be 0, since there is no
difference between &quot;user time&quot; and
&quot;system&quot; time under VMS, and the time accumulated
by a subprocess may or may not appear separately in the
&quot;child time&quot; field, depending on whether times
keeps track of subprocesses separately. Note especially that
the VAXCRTL (at least) keeps track only of subprocesses
spawned using fork and exec; it will not accumulate the
times of subprocesses spawned via pipes, system, or
backticks.</p>

<p>unlink LIST &quot;unlink&quot; will delete the highest
version of a file only; in order to delete all versions, you
need to say</p>

<p>1 while unlink LIST;</p>

<p>You may need to make this change to scripts written for
a Unix system which expect that after a call to
&quot;unlink&quot;, no files with the names passed to
&quot;unlink&quot; will exist. (Note: This can be changed at
compile time; if you &quot;use Config&quot; and
$Config{&rsquo;d_unlink_all_versions&rsquo;} is
&quot;define&quot;, then &quot;unlink&quot; will delete all
versions of a file on the first call.)</p>

<p>&quot;unlink&quot; will delete a file if at all
possible, even if it requires changing file protection
(though it wont try to change the protection of the parent
directory). You can tell whether youve got explicit delete
access to a file by using the
&quot;VMS::Filespec::candelete&quot; operator. For instance,
in order to delete only files to which you have delete
access, you could say something like</p>

<p>sub safe_unlink { my($file,$num); foreach $file (@_) {
next unless VMS::Filespec::candelete($file); $num += unlink
$file; } $num; }</p>

<p>(or you could just use &quot;VMS::Stdio::remove&quot;,
if youve installed the VMS::Stdio extension distributed with
Perl). If &quot;unlink&quot; has to change the file
protection to delete the file, and you interrupt it in
midstream, the file may be left intact, but with a changed
ACL allowing you delete access.</p>

<p>This behavior of &quot;unlink&quot; is to be compatible
with POSIX behavior and not traditional VMS behavior.</p>

<p>utime LIST This operator changes only the modification
time of the file (VMS revision date) on ODS-2 volumes and
ODS-5 volumes without access dates enabled. On ODS-5 volumes
with access dates enabled, the true access time is
modified.</p>

<p>waitpid PID,FLAGS If PID is a subprocess started by a
piped &quot;open()&quot; (see open), &quot;waitpid&quot;
will wait for that subprocess, and return its final status
value in $?. If PID is a subprocess created in some other
way (e.g. SPAWNed before Perl was invoked),
&quot;waitpid&quot; will simply check once per second
whether the process has completed, and return when it has.
(If PID specifies a process that isnt a subprocess of the
current process, and you invoked Perl with the
&quot;-w&quot; switch, a warning will be issued.)</p>

<p>Returns PID on success, -1 on error. The FLAGS argument
is ignored in all cases.</p>

<p>Perl variables The following VMS-specific information
applies to the indicated &quot;special&quot; Perl variables,
in addition to the general information in perlvar. Where
there is a conflict, this information takes precedence.</p>

<p>%ENV The operation of the %ENV array depends on the
translation of the logical name PERL_ENV_TABLES. If defined,
it should be a search list, each element of which specifies
a location for %ENV elements. If you tell Perl to read or
set the element &quot;$ENV{&quot;name&quot;}&quot;, then
Perl uses the translations of PERL_ENV_TABLES as
follows:</p>

<p>CRTL_ENV This string tells Perl to consult the CRTLs
internal &quot;environ&quot; array of key-value pairs, using
name as the key. In most cases, this contains only a few
keys, but if Perl was invoked via the C
&quot;exec[lv]e()&quot; function, as is the case for CGI
processing by some HTTP servers, then the
&quot;environ&quot; array may have been populated by the
calling program.</p>

<p>CLISYM_[LOCAL] A string beginning with
&quot;CLISYM_&quot;tells Perl to consult the CLI s symbol
tables, using name as the name of the symbol. When reading
an element of %ENV, the local symbol table is scanned first,
followed by the global symbol table.. The characters
following &quot;CLISYM_&quot; are significant when an
element of %ENV is set or deleted: if the complete string is
&quot;CLISYM_LOCAL&quot;, the change is made in the local
symbol table; otherwise the global symbol table is
changed.</p>

<p>Any other string If an element of PERL_ENV_TABLES
translates to any other string, that string is used as the
name of a logical name table, which is consulted using name
as the logical name. The normal search order of access modes
is used.</p>

<p>PERL_ENV_TABLES is translated once when Perl starts up;
any changes you make while Perl is running do not affect the
behavior of %ENV. If PERL_ENV_TABLES is not defined, then
Perl defaults to consulting first the logical name tables
specified by LNM$FILE_DEV, and then the CRTL
&quot;environ&quot; array.</p>

<p>In all operations on %ENV, the key string is treated as
if it were entirely uppercase, regardless of the case
actually specified in the Perl expression.</p>

<p>When an element of %ENV is read, the locations to which
PERL_ENV_TABLES points are checked in order, and the value
obtained from the first successful lookup is returned. If
the name of the %ENV element contains a semi-colon, it and
any characters after it are removed. These are ignored when
the CRTL &quot;environ&quot; array or a CLI symbol table is
consulted. However, the name is looked up in a logical name
table, the suffix after the semi-colon is treated as the
translation index to be used for the lookup. This lets you
look up successive values for search list logical names. For
instance, if you say</p>

<p>$ Define STORY once,upon,a,time,there,was $ perl -e
&quot;for ($i = 0; $i &lt;= 6; $i++) &quot; - _$ -e &quot;{
print $ENV{&rsquo;story;&rsquo;.$i},&rsquo;
&rsquo;}&quot;</p>

<p>Perl will print &quot;ONCE UPON A TIME THERE WAS&quot;,
assuming, of course, that PERL_ENV_TABLES is set up so that
the logical name &quot;story&quot; is found, rather than a
CLI symbol or CRTL &quot;environ&quot; element with the same
name.</p>

<p>When an element of %ENV is set to a defined string, the
corresponding definition is made in the location to which
the first translation of PERL_ENV_TABLES points. If this
causes a logical name to be created, it is defined in
supervisor mode. (The same is done if an existing logical
name was defined in executive or kernel mode; an existing
user or supervisor mode logical name is reset to the new
value.) If the value is an empty string, the logical name s
translation is defined as a single NUL (ASCII 00) character,
since a logical name cannot translate to a zero-length
string. (This restriction does not apply to CLI symbols or
CRTL &quot;environ&quot; values; they are set to the empty
string.) An element of the CRTL &quot;environ&quot; array
can be set only if your copy of Perl knows about the CRTLs
&quot;setenv()&quot; function. (This is present only in some
versions of the DECCRTL; check $Config{d_setenv} to see
whether your copy of Perl was built with a CRTL that has
this function.)</p>

<p>When an element of %ENV is set to &quot;undef&quot;, the
element is looked up as if it were being read, and if it is
found, it is deleted. (An item &quot;deleted&quot; from the
CRTL &quot;environ&quot; array is set to the empty string;
this can only be done if your copy of Perl knows about the
CRTL &quot;setenv()&quot; function.) Using
&quot;delete&quot; to remove an element from %ENV has a
similar effect, but after the element is deleted, another
attempt is made to look up the element, so an inner-mode
logical name or a name in another location will replace the
logical name just deleted. In either case, only the first
value found searching PERL_ENV_TABLES is altered. It is not
possible at present to define a search list logical name via
%ENV.</p>

<p>The element $ENV{DEFAULT} is special: when read, it
returns Perls current default device and directory, and when
set, it resets them, regardless of the definition of
PERL_ENV_TABLES. It cannot be cleared or deleted; attempts
to do so are silently ignored.</p>

<p>Note that if you want to pass on any elements of the
C-local environ array to a subprocess which isnt started by
fork/exec, or isnt running a C program, you can
&quot;promote&quot; them to logical names in the current
process, which will then be inherited by all subprocesses,
by saying</p>

<p>foreach my $key (qw[C-local keys you want promoted]) {
my $temp = $ENV{$key}; # read from C-local array $ENV{$key}
= $temp; # and define as logical name }</p>

<p>(You cant just say $ENV{$key} = $ENV{$key}, since the
Perl optimizer is smart enough to elide the expression.)</p>

<p>Dont try to clear %ENV by saying &quot;%ENV = ();&quot;,
it will throw a fatal error. This is equivalent to doing the
following from DCL:</p>

<p>DELETE/LOGICAL *</p>

<p>You can imagine how bad things would be if, for example,
the SYS$MANAGER or SYS$SYSTEM logical names were
deleted.</p>

<p>At present, the first time you iterate over %ENV using
&quot;keys&quot;, or &quot;values&quot;, you will incur a
time penalty as all logical names are read, in order to
fully populate %ENV. Subsequent iterations will not reread
logical names, so they wont be as slow, but they also wont
reflect any changes to logical name tables caused by other
programs.</p>

<p>You do need to be careful with the logical names
representing process-permanent files, such as
&quot;SYS$INPUT&quot; and &quot;SYS$OUTPUT&quot;. The
translations for these logical names are prepended with a
two-byte binary value (0x1B 0x00) that needs to be stripped
off if you wantto use it. (In previous versions of Perl it
wasnt possible to get the values of these logical names, as
the null byte acted as an end-of-string marker)</p>

<p>$! The string value of $! is that returned by the CRTLs
strerror() function, so it will include the VMS message for
VMS-specific errors. The numeric value of $! is the value of
&quot;errno&quot;, except if errno is EVMSERR, in which case
$! contains the value of vaxc$errno. Setting $! always sets
errno to the value specified. If this value is EVMSERR, it
also sets vaxc$errno to 4 (NONAME-F- NOMSG), so that the
string value of $! wont reflect the VMS error message from
before $! was set.</p>

<p>$^E This variable provides direct access to VMS status
values in vaxc$errno, which are often more specific than the
generic Unix- style error messages in $!. Its numeric value
is the value of vaxc$errno, and its string value is the
corresponding VMS message string, as retrieved by
sys$getmsg(). Setting $^E sets vaxc$errno to the value
specified.</p>

<p>While Perl attempts to keep the vaxc$errno value to be
current, if errno is not EVMSERR, it may not be from the
current operation.</p>

<p>$? The &quot;status value&quot; returned in $? is
synthesized from the actual exit status of the subprocess in
a way that approximates POSIX wait(5) semantics, in order to
allow Perl programs to portably test for successful
completion of subprocesses. The low order 8 bits of $? are
always 0 under VMS, since the termination status of a
process may or may not have been generated by an
exception.</p>

<p>The next 8 bits contain the termination status of the
program.</p>

<p>If the child process follows the convention of C
programs compiled with the _POSIX_EXIT macro set, the status
value will contain the actual value of 0 to 255 returned by
that program on a normal exit.</p>

<p>With the _POSIX_EXIT macro set, the UNIX exit value of
zero is represented as a VMS native status of 1, and the
UNIX values from 2 to 255 are encoded by the equation:</p>

<p>VMS_status = 0x35a000 + (unix_value * 8) + 1.</p>

<p>And in the special case of unix value 1 the encoding
is:</p>

<p>VMS_status = 0x35a000 + 8 + 2 + 0x10000000.</p>

<p>For other termination statuses, the severity portion of
the subprocess exit status is used: if the severity was
success or informational, these bits are all 0; if the
severity was warning, they contain a value of 1; if the
severity was error or fatal error, they contain the actual
severity bits, which turns out to be a value of 2 for error
and 4 for severe_error. Fatal is another term for the
severe_error status.</p>

<p>As a result, $? will always be zero if the subprocess
exit status indicated successful completion, and non-zero if
a warning or error occurred or a program compliant with
encoding _POSIX_EXIT values was run and set a status.</p>

<p>How can you tell the difference between a non-zero
status that is the result of a VMS native error status or an
encoded UNIX status? You can not unless you look at the
${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE}
value returns the actual VMS status value and check the
severity bits. If the severity bits are equal to 1, then if
the numeric value for $? is between 2 and 255 or 0, then $?
accurately reflects a value passed back from a UNIX
application. If $? is 1, and the severity bits indicate a
VMS error (2), then $? is from a UNIX application exit
value.</p>

<p>In practice, Perl scripts that call programs that return
_POSIX_EXIT type status values will be expecting those
values, and programs that call traditional VMS programs will
either be expecting the previous behavior or just checking
for a non-zero status.</p>

<p>And success is always the value 0 in all behaviors.</p>

<p>When the actual VMS termination status of the child is
an error, internally the $! value will be set to the closest
UNIX errno value to that error so that Perl scripts that
test for error messages will see the expected UNIX style
error message instead of a VMS message.</p>

<p>Conversely, when setting $? in an END block, an attempt
is made to convert the POSIX value into a native status
intelligible to the operating system upon exiting Perl. What
this boils down to is that setting $? to zero results in the
generic success value SS$_NORMAL, and setting $? to a
non-zero value results in the generic failure status
SS$_ABORT. See also &quot;exit&quot; in perlport.</p>

<p>With the &quot;PERL_VMS_POSIX_EXIT&quot; logical name
defined as &quot;ENABLE&quot;, setting $? will cause the new
value to be encoded into $^E so that either the original
parent or child exit status values 0 to 255 can be
automatically recovered by C programs expecting _POSIX_EXIT
behavior. If both a parent and a child exit value are
non-zero, then it will be assumed that this is actually a
VMS native status value to be passed through. The special
value of 0xFFFF is almost a NOOP as it will cause the
current native VMS status in the C library to become the
current native Perl VMS status, and is handled this way as
it is known to not be a valid native VMS status value. It is
recommend that only values in the range of normal UNIX
parent or child status numbers, 0 to 255 are used.</p>

<p>The pragma &quot;use vmsish &rsquo;status&rsquo;&quot;
makes $? reflect the actual VMS exit status instead of the
default emulation of POSIX status described above. This
pragma also disables the conversion of non- zero values to
SS$_ABORT when setting $? in an END block (but zero will
still be converted to SS$_NORMAL).</p>

<p>Do not use the pragma &quot;use vmsish
&rsquo;status&rsquo;&quot; with
&quot;PERL_VMS_POSIX_EXIT&quot; enabled, as they are at
times requesting conflicting actions and the consequence of
ignoring this advice will be undefined to allow future
improvements in the POSIX exit handling.</p>

<p>In general, with &quot;PERL_VMS_POSIX_EXIT&quot;
enabled, more detailed information will be availble in the
exit status for DCL scripts or other native VMS tools, and
will give the expected information for Posix programs. It
has not been made the default in order to preserve backward
compatibility.</p>

<p>N.B. Setting &quot;DECC$FILENAME_UNIX_REPORT&quot;
implicitly enables &quot;PERL_VMS_POSIX_EXIT&quot;.</p>

<p>$| Setting $| for an I/O stream causes data to be
flushed all the way to disk on each write (i.e. not just to
the underlying RMS buffers for a file). In other words, it s
equivalent to calling fflush() and fsync() from C.</p>

<p>Standard modules with VMS-specific differences SDBM_File
SDBM_File works properly on VMS. It has, however, one minor
difference. The database directory file created has a
.sdbm_dir extension rather than a .dir extension. .dir files
are VMS filesystem directory files, and using them for other
purposes could cause unacceptable problems.</p>

<p>Revision date Please see the git repository for revision
history.</p>

<p>AUTHOR Charles Bailey bailey@cor.newman.upenn.edu Craig
Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John
Malmberg wb8tyw@qsl.net</p>

<p>perl v5.10.1 2009-07-17 PERLVMS(1)</p>
<hr>
</body>
</html>
