<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:40:34 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TEE(2) Linux Programmer s Manual TEE(2)</p>

<p>NAME tee - duplicating pipe content</p>

<p>SYNOPSIS #define _GNU_SOURCE #include
&lt;fcntl.h&gt;</p>

<p>long tee(int fd_in, int fd_out, size_t len, unsigned int
flags);</p>

<p>DESCRIPTION tee() duplicates up to len bytes of data
from the pipe referred to by the file descriptor fd_in to
the pipe referred to by the file descrip- tor fd_out. It
does not consume the data that is duplicated from fd_in;
therefore, that data can be copied by a subsequent
splice(2).</p>

<p>flags is a series of modifier flags, which share the
name space with splice(2) and vmsplice(2):</p>

<p>SPLICE_F_MOVE Currently has no effect for tee(); see
splice(2).</p>

<p>SPLICE_F_NONBLOCK Do not block on I/O; see splice(2) for
further details.</p>

<p>SPLICE_F_MORE Currently has no effect for tee(), but may
be imple- mented in the future; see splice(2).</p>

<p>SPLICE_F_GIFT Unused for tee(); see vmsplice(2).</p>

<p>RETURN VALUE Upon successful completion, tee() returns
the number of bytes that were duplicated between the input
and output. A return value of 0 means that there was no data
to transfer, and it would not make sense to block, because
there are no writers connected to the write end of the pipe
referred to by fd_in.</p>

<p>On error, tee() returns -1 and errno is set to indicate
the error.</p>

<p>ERRORS EINVAL fd_in or fd_out does not refer to a pipe;
or fd_in and fd_out refer to the same pipe.</p>

<p>ENOMEM Out of memory.</p>

<p>VERSIONS The tee() system call first appeared in Linux
2.6.17.</p>

<p>CONFORMING TO This system call is Linux-specific.</p>

<p>NOTES Conceptually, tee() copies the data between the
two pipes. In reality no real data copying takes place
though: under the covers, tee() assigns data in the output
by merely grabbing a reference to the input.</p>

<p>EXAMPLE The following example implements a basic tee(1)
program using the tee() system call.</p>

<p>#define _GNU_SOURCE #include &lt;fcntl.h&gt; #include
&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include
&lt;unistd.h&gt; #include &lt;assert.h&gt; #include
&lt;errno.h&gt; #include &lt;limits.h&gt;</p>

<p>int main(int argc, char *argv[]) { int fd; int len,
slen;</p>

<p>assert(argc == 2);</p>

<p>fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd == -1) { perror(&quot;open&quot;);
exit(EXIT_FAILURE); }</p>

<p>do { /* * tee stdin to stdout. */ len =
tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX,
SPLICE_F_NONBLOCK);</p>

<p>if (len &lt; 0) { if (errno == EAGAIN) continue;
perror(&quot;tee&quot;); exit(EXIT_FAILURE); } else if (len
== 0) break;</p>

<p>/* * Consume stdin by splicing it to a file. */ while
(len &gt; 0) { slen = splice(STDIN_FILENO, NULL, fd, NULL,
len, SPLICE_F_MOVE); if (slen &lt; 0) {
perror(&quot;splice&quot;); break; } len -= slen; } } while
(1);</p>

<p>close(fd); exit(EXIT_SUCCESS); }</p>

<p>SEE ALSO splice(2), vmsplice(2),
feature_test_macros(7)</p>

<p>COLOPHON This page is part of release 3.22 of the Linux
man-pages project. A description of the project, and
information about reporting bugs, can be found at
http://www.kernel.org/doc/man-pages/.</p>

<p>Linux 2006-04-28 TEE(2)</p>
<hr>
</body>
</html>
