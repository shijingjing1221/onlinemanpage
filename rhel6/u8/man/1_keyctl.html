<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>KEYCTL(1) Linux Key Management Utilities KEYCTL(1)</p>

<p>NAME keyctl - Key management facility control</p>

<p>SYNOPSIS keyctl show keyctl add &lt;type&gt;
&lt;desc&gt; &lt;data&gt; &lt;keyring&gt; keyctl padd
&lt;type&gt; &lt;desc&gt; &lt;keyring&gt; keyctl request
&lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;] keyctl
request2 &lt;type&gt; &lt;desc&gt; &lt;info&gt;
[&lt;dest_keyring&gt;] keyctl prequest2 &lt;type&gt;
&lt;desc&gt; [&lt;dest_keyring&gt;] keyctl update
&lt;key&gt; &lt;data&gt; keyctl pupdate &lt;key&gt; keyctl
newring &lt;name&gt; &lt;keyring&gt; keyctl revoke
&lt;key&gt; keyctl clear &lt;keyring&gt; keyctl link
&lt;key&gt; &lt;keyring&gt; keyctl unlink &lt;key&gt;
&lt;keyring&gt; keyctl search &lt;keyring&gt; &lt;type&gt;
&lt;desc&gt; [&lt;dest_keyring&gt;] keyctl read &lt;key&gt;
keyctl pipe &lt;key&gt; keyctl print &lt;key&gt; keyctl list
&lt;keyring&gt; keyctl rlist &lt;keyring&gt; keyctl describe
&lt;keyring&gt; keyctl rdescribe &lt;keyring&gt; [sep]
keyctl chown &lt;key&gt; &lt;uid&gt; keyctl chgrp
&lt;key&gt; &lt;gid&gt; keyctl setperm &lt;key&gt;
&lt;mask&gt; keyctl session keyctl session - [&lt;prog&gt;
&lt;arg1&gt; &lt;arg2&gt; ...] keyctl session &lt;name&gt;
[&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...] keyctl
instantiate &lt;key&gt; &lt;data&gt; &lt;keyring&gt; keyctl
pinstantiate &lt;key&gt; &lt;keyring&gt; keyctl negate
&lt;key&gt; &lt;timeout&gt; &lt;keyring&gt; keyctl timeout
&lt;key&gt; &lt;timeout&gt; keyctl security &lt;key&gt;</p>

<p>DESCRIPTION This program is used to control the key
management facility in various ways using a variety of
subcommands.</p>

<p>KEY IDENTIFIERS The key identifiers passed to or
returned from keyctl are, in general, positive integers.
There are, however, some special values with special
meanings that can be passed as arguments:</p>

<p>(*) No key: 0</p>

<p>(*) Thread keyring: @t or -1</p>

<p>Each thread may have its own keyring. This is searched
first, before all others. The thread keyring is replaced by
(v)fork, exec and clone.</p>

<p>(*) Process keyring: @p or -2</p>

<p>Each process (thread group) may have its own keyring.
This is shared between all members of a group and will be
searched after the thread keyring. The process keyring is
replaced by (v)fork and exec.</p>

<p>(*) Session keyring: @s or -3</p>

<p>Each process subscribes to a session keyring that is
inherited across (v)fork, exec and clone. This is searched
after the process keyring. Session keyrings can be named and
an extant keyring can be joined in place of a processs
current session keyring.</p>

<p>(*) User specific keyring: @u or -4</p>

<p>This keyring is shared between all the processes owned
by a particular user. It isnt searched directly, but is
normally linked to from the session keyring.</p>

<p>(*) User default session keyring: @us or -5</p>

<p>This is the default session keyring for a particular
user. Login pro- cesses that change to a particular user
will bind to this session until another session is set.</p>

<p>(*) Group specific keyring: @g or -6</p>

<p>This is a place holder for a group specific keyring, but
is not actu- ally implemented yet in the kernel.</p>

<p>(*) Assumed request_key authorisation key: @a or -7</p>

<p>This selects the authorisation key provided to the
request_key() helper to permit it to access the callers
keyrings and instantiate the target key.</p>

<p>COMMAND SYNTAX Any non-ambiguous shortening of a command
name may be used in lieu of the full command name. This
facility should not be used in scripting as new commands may
be added in future that then cause ambiguity.</p>

<p>(*) Show process keyrings</p>

<p>keyctl show</p>

<p>This command recursively shows what keyrings a process
is subscribed to and what keys and keyrings they
contain.</p>

<p>(*) Add a key to a keyring</p>

<p>keyctl add &lt;type&gt; &lt;desc&gt; &lt;data&gt;
&lt;keyring&gt; keyctl padd &lt;type&gt; &lt;desc&gt;
&lt;keyring&gt;</p>

<p>This command creates a key of the specified type and
description; instantiates it with the given data and
attaches it to the specified keyring. It then prints the new
keys ID on stdout:</p>

<p>testbox&gt;keyctl add user mykey stuff @u 26</p>

<p>The padd variant of the command reads the data from
stdin rather than taking it from the command line:</p>

<p>testbox&gt;echo -n stuff | keyctl padd user mykey @u
26</p>

<p>(*) Request a key</p>

<p>keyctl request &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;] keyctl request2 &lt;type&gt;
&lt;desc&gt; &lt;info&gt; [&lt;dest_keyring&gt;] keyctl
prequest2 &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;]</p>

<p>These three commands request the lookup of a key of the
given type and description. The processs keyrings will be
searched, and if a match is found the matching keys ID will
be printed to stdout; and if a destination keyring is given,
the key will be added to that keyring also.</p>

<p>If there is no key, the first command will simply return
the error ENOKEY and fail. The second and third commands
will create a partial key with the type and description, and
call out to /sbin/request-key with that key and the extra
information supplied. This will then attempt to instantiate
the key in some manner, such that a valid key is
obtained.</p>

<p>The third command is like the second, except that the
callout informa- tion is read from stdin rather than being
passed on the command line.</p>

<p>If a valid key is obtained, the ID will be printed and
the key attached as if the original search had
succeeded.</p>

<p>If there wasnt a valid key obtained, a temporary
negative key will be attached to the destination keyring if
given and the error &quot;Requested key not available&quot;
will be given.</p>

<p>testbox&gt;keyctl request2 user debug:hello wibble 23
testbox&gt;echo -n wibble | keyctl prequest2 user
debug:hello 23 testbox&gt;keyctl request user debug:hello
23</p>

<p>(*) Update a key</p>

<p>keyctl update &lt;key&gt; &lt;data&gt; keyctl pupdate
&lt;key&gt;</p>

<p>This command replaces the data attached to a key with a
new set of data. If the type of the key doesnt support
update then error &quot;Opera- tion not supported&quot; will
be returned.</p>

<p>testbox&gt;keyctl update 23 zebra</p>

<p>The pupdate variant of the command reads the data from
stdin rather than taking it from the command line:</p>

<p>testbox&gt;echo -n zebra | keyctl pupdate 23</p>

<p>(*) Create a keyring</p>

<p>keyctl newring &lt;name&gt; &lt;keyring&gt;</p>

<p>This command creates a new keyring of the specified name
and attaches it to the specified keyring. The ID of the new
keyring will be printed to stdout if successful.</p>

<p>testbox&gt;keyctl newring squelch @us 27</p>

<p>(*) Revoke a key</p>

<p>keyctl revoke &lt;key&gt;</p>

<p>This command marks a key as being revoked. Any further
operations on that key (apart from unlinking it) will return
error &quot;Key has been revoked&quot;.</p>

<p>testbox&gt;keyctl revoke 26 testbox&gt;keyctl describe
26 keyctl_describe: Key has been revoked</p>

<p>(*) Clear a keyring</p>

<p>keyctl clear &lt;keyring&gt;</p>

<p>This command unlinks all the keys attached to the
specified keyring. Error &quot;Not a directory&quot; will be
returned if the key specified is not a keyring.</p>

<p>testbox&gt;keyctl clear 27</p>

<p>(*) Link a key to a keyring</p>

<p>keyctl link &lt;key&gt; &lt;keyring&gt;</p>

<p>This command makes a link from the key to the keyring if
theres enough capacity to do so. Error &quot;Not a
directory&quot; will be returned if the des- tination is not
a keyring. Error &quot;Permission denied&quot; will be
returned if the key doesnt have link permission or the
keyring doesnt have write permission. Error &quot;File table
overflow&quot; will be returned if the keyring is full.
Error &quot;Resource deadlock avoided&quot; will be returned
if an attempt was made to introduce a recursive link.</p>

<p>testbox&gt;keyctl link 23 27 testbox&gt;keyctl link 27
27 keyctl_link: Resource deadlock avoided</p>

<p>(*) Unlink a key from a keyring</p>

<p>keyctl unlink &lt;key&gt; &lt;keyring&gt;</p>

<p>This command removes a link to the key from the keyring.
Error &quot;Not a directory&quot; will be returned if the
destination is not a keyring. Error &quot;Permission
denied&quot; will be returned if the keyring doesnt have
write permission. Error &quot;No such file or
directory&quot; will be returned if the key is not linked to
by the keyring.</p>

<p>Note that this only removes one key link from the
keyring; any further links to the same key are not
deleted.</p>

<p>testbox&gt;keyctl unlink 23 27</p>

<p>(*) Search a keyring</p>

<p>keyctl search &lt;keyring&gt; &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;]</p>

<p>This command non-recursively searches a keyring for a
key of a particu- lar type and description. If found, the ID
of the key will be printed on stdout and the key will be
attached to the destination keyring if present. Error
&quot;Requested key not available&quot; will be returned if
the key is not found.</p>

<p>testbox&gt;keyctl search @us user debug:hello 23
testbox&gt;keyctl search @us user debug:bye keyctl_search:
Requested key not available</p>

<p>(*) Read a key</p>

<p>keyctl read &lt;key&gt; keyctl pipe &lt;key&gt; keyctl
print &lt;key&gt;</p>

<p>These commands read the payload of a key.
&quot;read&quot; prints it on stdout as a hex dump,
&quot;pipe&quot; dumps the raw data to stdout and
&quot;print&quot; dumps it to stdout directly if its
entirely printable or as a hexdump preceded by
&quot;:hex:&quot; if not.</p>

<p>If the key type does not support reading of the payload,
then error &quot;Operation not supported&quot; will be
returned.</p>

<p>testbox&gt;keyctl read 26 1 bytes of data in key: 62
testbox&gt;keyctl print 26 b testbox&gt;keyctl pipe 26
btestbox&gt;</p>

<p>(*) List a keyring</p>

<p>keyctl list &lt;keyring&gt; keyctl rlist
&lt;keyring&gt;</p>

<p>These commands list the contents of a key as a keyring.
&quot;list&quot; pretty prints the contents and
&quot;rlist&quot; just produces a space-separated list of
key IDs.</p>

<p>No attempt is made to check that the specified keyring
is a keyring.</p>

<p>testbox&gt;keyctl list @us 2 keys in keyring: 22:
vrwsl---------- 4043 -1 keyring: _uid.4043 23:
vrwsl---------- 4043 4043 user: debug:hello
testbox&gt;keyctl rlist @us 22 23</p>

<p>(*) Describe a key</p>

<p>keyctl describe &lt;keyring&gt; keyctl rdescribe
&lt;keyring&gt; [sep]</p>

<p>These commands fetch a description of a keyring.
&quot;describe&quot; pretty prints the description in the
same fashion as the &quot;list&quot; command; &quot;rde-
scribe&quot; prints the raw data returned from the
kernel.</p>

<p>testbox&gt;keyctl describe @us -5: vrwsl---------- 4043
-1 keyring: _uid_ses.4043 testbox&gt;keyctl rdescribe @us
keyring;4043;-1;3f1f0000;_uid_ses.4043</p>

<p>The raw string is
&quot;&lt;type&gt;;&lt;uid&gt;;&lt;gid&gt;;&lt;perms&gt;;&lt;description&gt;&quot;,
where uid and gid are the decimal user and group IDs, perms
is the permissions mask in hex, type and description are the
type name and description strings (neither of which will
contain semicolons).</p>

<p>(*) Change the access controls on a key</p>

<p>keyctl chown &lt;key&gt; &lt;uid&gt; keyctl chgrp
&lt;key&gt; &lt;gid&gt;</p>

<p>These two commands change the UID and GID associated
with evaluating a key s permissions mask. The UID also
governs which quota a key is taken out of.</p>

<p>The chown command is not currently supported; attempting
it will earn the error &quot;Operation not supported&quot;
at best.</p>

<p>For non-superuser users, the GID may only be set to the
processs GID or a GID in the processs groups list. The
superuser may set any GID it likes.</p>

<p>testbox&gt;sudo keyctl chown 27 0 keyctl_chown:
Operation not supported testbox&gt;sudo keyctl chgrp 27
0</p>

<p>(*) Set the permissions mask on a key</p>

<p>keyctl setperm &lt;key&gt; &lt;mask&gt;</p>

<p>This command changes the permission control mask on a
key. The mask may be specified as a hex number if it begins
&quot;0x&quot;, an octal number if it begins &quot;0&quot;
or a decimal number otherwise.</p>

<p>The hex numbers are a combination of:</p>

<p>Possessor UID GID Other Permission Granted ========
======== ======== ======== ================== 01000000
00010000 00000100 00000001 View 02000000 00020000 00000200
00000002 Read 04000000 00040000 00000400 00000004 Write
08000000 00080000 00000800 00000008 Search 10000000 00100000
00001000 00000010 Link 20000000 00200000 00002000 00000020
Set Attribute 3f000000 003f0000 00003f00 0000003f All</p>

<p>View permits the type, description and other parameters
of a key to be viewed.</p>

<p>Read permits the payload (or keyring list) to be read if
supported by the type.</p>

<p>Write permits the payload (or keyring list) to be
modified or updated.</p>

<p>Search on a key permits it to be found when a keyring to
which it is linked is searched.</p>

<p>Link permits a key to be linked to a keyring.</p>

<p>Set Attribute permits a key to have its owner, group
membership, per- missions mask and timeout changed.</p>

<p>testbox&gt;keyctl setperm 27 0x1f1f1f00</p>

<p>(*) Start a new session with fresh keyrings</p>

<p>keyctl session keyctl session - [&lt;prog&gt;
&lt;arg1&gt; &lt;arg2&gt; ...] keyctl session &lt;name&gt;
[&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]</p>

<p>These commands join or create a new keyring and then run
a shell or other program with that keyring as the session
key.</p>

<p>The variation with no arguments just creates an
anonymous session keyring and attaches that as the session
keyring; it then execs $SHELL.</p>

<p>The variation with a dash in place of a name creates an
anonymous ses- sion keyring and attaches that as the session
keyring; it then execs the supplied command, or $SHELL if
one isnt supplied.</p>

<p>The variation with a name supplied creates or joins the
named keyring and attaches that as the session keyring; it
then execs the supplied command, or $SHELL if one isnt
supplied.</p>

<p>testbox&gt;keyctl rdescribe @s
keyring;4043;-1;3f1f0000;_uid_ses.4043</p>

<p>testbox&gt;keyctl session Joined session keyring: 28
testbox&gt;keyctl rdescribe @s
keyring;4043;4043;3f1f0000;_ses.24082</p>

<p>testbox&gt;keyctl session - Joined session keyring: 29
testbox&gt;keyctl rdescribe @s
keyring;4043;4043;3f1f0000;_ses.24139</p>

<p>testbox&gt;keyctl session - keyctl rdescribe @s Joined
session keyring: 30
keyring;4043;4043;3f1f0000;_ses.24185</p>

<p>testbox&gt;keyctl session fish Joined session keyring:
34 testbox&gt;keyctl rdescribe @s
keyring;4043;4043;3f1f0000;fish</p>

<p>testbox&gt;keyctl session fish keyctl rdesc @s Joined
session keyring: 35 keyring;4043;4043;3f1f0000;fish</p>

<p>(*) Instantiate a key</p>

<p>keyctl instantiate &lt;key&gt; &lt;data&gt;
&lt;keyring&gt; keyctl pinstantiate &lt;key&gt;
&lt;keyring&gt; keyctl negate &lt;key&gt; &lt;timeout&gt;
&lt;keyring&gt;</p>

<p>These commands are used to attach data to a partially
set up key (as created by the kernel and passed to
/sbin/request-key). &quot;instantiate&quot; marks a key as
being valid and attaches the data as the payload.
&quot;negate&quot; marks a key as invalid and sets a timeout
on it so that itll go away after a while. This prevents a
lot of quickly sequential requests from slowing the system
down overmuch when they all fail, as all subsequent requests
will then fail with error &quot;Requested key not
found&quot; until the negative key has expired.</p>

<p>The newly instantiated key will be attached to the
specified keyring.</p>

<p>These commands may only be run from the program run by
request-key - a special authorisation key is set up by the
kernel and attached to the request-keys session keyring.
This special key is revoked once the key to which it refers
has been instantiated one way or another.</p>

<p>testbox&gt;keyctl instantiate $1 &quot;Debug $3&quot; $4
testbox&gt;keyctl negate $1 30 $4</p>

<p>The pinstantiate variant of the command reads the data
from stdin rather than taking it from the command line:</p>

<p>testbox&gt;echo -n &quot;Debug $3&quot; | keyctl
pinstantiate $1 $4</p>

<p>(*) Set the expiry time on a key</p>

<p>keyctl timeout &lt;key&gt; &lt;timeout&gt;</p>

<p>This command is used to set the timeout on a key, or
clear an existing timeout if the value specified is zero.
The timeout is given as a num- ber of seconds into the
future.</p>

<p>testbox&gt;keyctl timeout $1 45</p>

<p>(*) Retrieve a kes security context</p>

<p>keyctl security &lt;key&gt;</p>

<p>This command is used to retrieve a key s LSM security
context. The label is printed on stdout.</p>

<p>testbox&gt;keyctl security @s
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</p>

<p>(*) Give the parent process a new session keyring</p>

<p>keyctl new_session</p>

<p>This command is used to give the invoking process
(typically a shell) a new session keyring, discarding its
old session keyring.</p>

<p>testbox&gt; keyctl session foo Joined session keyring:
723488146 testbox&gt; keyctl show Session Keyring -3
--alswrv 0 0 keyring: foo testbox&gt; keyctl new_session
490511412 testbox&gt; keyctl show Session Keyring -3
--alswrv 0 0 keyring: _ses</p>

<p>Note that this affects the parent of the process that
invokes the sys- tem call, and so may only affect processes
with matching credentials. Furthermore, the change does not
take effect till the parent process next transitions from
kernel space to user space - typically when the wait()
system call returns.</p>

<p>ERRORS There are a number of common errors returned by
this program:</p>

<p>&quot;Not a directory&quot; - a key wasnt a keyring.</p>

<p>&quot;Requested key not found&quot; - the looked for key
isn t available.</p>

<p>&quot;Key has been revoked&quot; - a revoked key was
accessed.</p>

<p>&quot;Key has expired&quot; - an expired key was
accessed.</p>

<p>&quot;Permission denied&quot; - permission was denied by
a UID/GID/mask combina- tion.</p>

<p>SEE ALSO keyctl(1), request-key.conf(5)</p>

<p>Linux 17 Nov 2005 KEYCTL(1)</p>
<hr>
</body>
</html>
