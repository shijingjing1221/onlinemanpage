<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:32:18 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RUBY(1) Ruby Programmers Reference Guide RUBY(1)</p>

<p>NAME ruby - Interpreted object-oriented scripting
language</p>

<p>SYNOPSIS ruby [--copyright] [--version] [-Sacdlnpswvy]
[-0[octal]] [-C directory] [-F pattern] [-I directory] [-K
c] [-T[level]] [-e command] [-i[extension]] [-r library]
[-x[directory]] [--] [program_file] [argument ...]</p>

<p>DESCRIPTION Ruby is an interpreted scripting language
for quick and easy object-ori- ented programming. It has
many features to process text files and to do system
management tasks (as in Perl). It is simple,
straight-forward, and extensible.</p>

<p>If you want a language for easy object-oriented
programming, or you dont like the Perl ugliness, or you do
like the concept of LISP, but dont like too much
parentheses, Ruby may be the language of your choice.</p>

<p>FEATURES Rubys features are as follows:</p>

<p>Interpretive Ruby is an interpreted language, so you
dont have to recompile programs written in Ruby to execute
them.</p>

<p>Variables have no type (dynamic typing) Variables in
Ruby can contain data of any type. You dont have to worry
about variable typing. Consequently, it has a weaker compile
time check.</p>

<p>No declaration needed You can use variables in your Ruby
programs without any declara- tions. Variable names denote
their scope, local, global, instance, etc.</p>

<p>Simple syntax Ruby has a simple syntax influenced
slightly from Eiffel.</p>

<p>No user-level memory management Ruby has automatic
memory management. Objects no longer refer- enced from
anywhere are automatically collected by the garbage
collector built into the interpreter.</p>

<p>Everything is an object Ruby is the purely
object-oriented language, and was so since its creation.
Even such basic data as integers are seen as objects.</p>

<p>Class, inheritance, and methods Of course, as an
object-oriented language, Ruby has such basic features like
classes, inheritance, and methods.</p>

<p>Singleton methods Ruby has the ability to define methods
for certain objects. For example, you can define a
press-button action for certain widget by defining a
singleton method for the button. Or, you can make up your
own prototype based object system using singleton meth- ods,
if you want to.</p>

<p>Mix-in by modules Ruby intentionally does not have the
multiple inheritance as it is a source of confusion.
Instead, Ruby has the ability to share implementations
across the inheritance tree. This is often called
Mix-in.</p>

<p>Iterators Ruby has iterators for loop abstraction.</p>

<p>Closures In Ruby, you can objectify the procedure.</p>

<p>Text processing and regular expression Ruby has a bunch
of text processing features like in Perl.</p>

<p>Bignums With built-in bignums, you can for example
calculate facto- rial(400).</p>

<p>Exception handling As in Java(tm).</p>

<p>Direct access to the OS Ruby can use most UNIX system
calls, often used in system pro- gramming.</p>

<p>Dynamic loading On most UNIX systems, you can load
object files into the Ruby interpreter on-the-fly.</p>

<p>OPTIONS Ruby interpreter accepts following command-line
options (switches). They are quite similar to those of
perl(1).</p>

<p>--copyright Prints the copyright notice.</p>

<p>--version Prints the version of Ruby interpreter.</p>

<p>-0[octal] (The digit zero.) Specifies the input record
separator ($/) as an octal number. If no digit is given, the
null character is taken as the separator. Other switches may
follow the digits. -00 turns Ruby into paragraph mode. -0777
makes Ruby read whole file at once as a single string since
there is no legal character with that value.</p>

<p>-C directory Causes Ruby to switch to the directory.</p>

<p>-F pattern Specifies input field separator ($;).</p>

<p>-I directory Used to tell Ruby where to load the library
scripts. Directory path will be added to the load-path
variable ($:).</p>

<p>-K kcode Specifies KANJI (Japanese) encoding.</p>

<p>-S Makes Ruby use the PATH environment variable to
search for script, unless if its name begins with a slash.
This is used to emulate #! on machines that don t support
it, in the following manner:</p>

<p>#! /usr/local/bin/ruby # This line makes the next one a
comment in Ruby exec /usr/local/bin/ruby -S $0 $*</p>

<p>-T[level] Turns on taint checks at the specified level
(default 1).</p>

<p>-a Turns on auto-split mode when used with -n or -p. In
auto-split mode, Ruby executes $F = $_.split at beginning of
each loop.</p>

<p>-c Causes Ruby to check the syntax of the script and
exit without executing. If there are no syntax errors, Ruby
will print Syntax OK to the standard output.</p>

<p>-d --debug Turns on debug mode. $DEBUG will be set to
true.</p>

<p>-e command Specifies script from command-line while
telling Ruby not to search the rest of arguments for a
script file name.</p>

<p>-h --help Prints a summary of the options.</p>

<p>-i extension Specifies in-place-edit mode. The
extension, if speci- fied, is added to old file name to make
a backup copy. For example:</p>

<p>% echo matz &gt; /tmp/junk % cat /tmp/junk matz % ruby
-p -i.bak -e $_.upcase! /tmp/junk % cat /tmp/junk MATZ % cat
/tmp/junk.bak matz</p>

<p>-l (The lowercase letter ell .) Enables automatic
line-end- ing processing, which means to firstly set $ to
the value of $/, and secondly chops every line read using
chop!.</p>

<p>-n Causes Ruby to assume the following loop around your
script, which makes it iterate over file name arguments
somewhat like sed -n or awk.</p>

<p>while gets ... end</p>

<p>-p Acts mostly same as -n switch, but print the value of
variable $_ at the each end of the loop. For example:</p>

<p>% echo matz | ruby -p -e $_.tr! &quot;a-z&quot;,
&quot;A-Z&quot; MATZ</p>

<p>-r library Causes Ruby to load the library using
require. It is use- ful when using -n or -p.</p>

<p>-s Enables some switch parsing for switches after script
name but before any file name arguments (or before a --).
Any switches found there are removed from ARGV and set the
corresponding variable in the script. For example:</p>

<p>#! /usr/local/bin/ruby -s # prints &quot;true&quot; if
invoked with -xyz switch. print &quot;true0 if $xyz</p>

<p>On some systems $0 does not always contain the full
path- name, so you need the -S switch to tell Ruby to search
for the script if necessary. To handle embedded spaces or
such. A better construct than $* would be
${1+&quot;$@&quot;}, but it does not work if the script is
being interpreted by csh(1).</p>

<p>-v --verbose Enables verbose mode. Ruby will print its
version at the beginning, and set the variable $VERBOSE to
true. Some methods print extra messages if this variable is
true. If this switch is given, and no other switches are
present, Ruby quits after printing its version.</p>

<p>-w Enables verbose mode without printing version message
at the beginning. It sets the $VERBOSE variable to true.</p>

<p>-x[directory] Tells Ruby that the script is embedded in
a message. Leading garbage will be discarded until the first
that starts with #! and contains the string, ruby. Any
meaningful switches on that line will applied. The end of
script must be specified with either EOF, ^D (control-D), ^Z
(control-Z), or reserved word __END__. If the direc- tory
name is specified, Ruby will switch to that directory before
executing script.</p>

<p>-y --yydebug Turns on compiler debug mode. Ruby will
print a bunch of internal state messages during compiling
scripts. You dont have to specify this switch, unless you
are going to debug the Ruby interpreter.</p>

<p>ENVIRONMENT RUBYLIB A colon-separated list of
directories that are added to Rubys library load path ($:).
Directories from this environment variable are searched
before the standard load path is searched.</p>

<p>e.g.:
RUBYLIB=&quot;$HOME/lib/ruby:$HOME/lib/rubyext&quot;</p>

<p>RUBYOPT Additional Ruby options.</p>

<p>e.g. RUBYOPT=&quot;-w -Ke&quot;</p>

<p>RUBYPATH A colon-separated list of directories that Ruby
searches for Ruby programs when the -S flag is specified.
This variable precedes the PATH environment variable.</p>

<p>RUBYSHELL The path to the system shell command. This
environment variable is enabled for only mswin32, mingw32,
and OS/2 platforms. If this variable is not defined, Ruby
refers to COMSPEC.</p>

<p>PATH Ruby refers to the PATH environment variable on
calling Kernel#system.</p>

<p>RUBYLIB_PREFIX This variable is obsolete.</p>

<p>AUTHORS Ruby is designed and implemented by Yukihiro
Matsumoto matz@netlab.jp.</p>

<p>UNIX December 31, 2002 UNIX</p>
<hr>
</body>
</html>
