<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:22:09 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LL_RW_BLOCK(9) The Linux VFS LL_RW_BLOCK(9)</p>

<p>NAME ll_rw_block - level access to block devices
(DEPRECATED)</p>

<p>SYNOPSIS void ll_rw_block(int rw, int nr, struct
buffer_head * bhs[]);</p>

<p>ARGUMENTS rw whether to READ or WRITE or maybe READA
(readahead)</p>

<p>nr number of struct buffer_heads in the array</p>

<p>bhs[] array of pointers to struct buffer_head</p>

<p>DESCRIPTION ll_rw_block takes an array of pointers to
struct buffer_heads, and requests an I/O operation on them,
either a READ or a WRITE. The third READA option is
described in the documentation for generic_make_request
which ll_rw_block calls.</p>

<p>This function drops any buffer that it cannot get a lock
on (with the BH_Lock state bit), any buffer that appears to
be clean when doing a write request, and any buffer that
appears to be up-to-date when doing read request. Further it
marks as clean buffers that are processed for writing (the
buffer cache won&acute;t assume that they are actually clean
until the buffer gets unlocked).</p>

<p>ll_rw_block sets b_end_io to simple completion handler
that marks the buffer up-to-date (if approriate), unlocks
the buffer and wakes any waiters.</p>

<p>All of the buffers must be for the same device, and must
also be a multiple of the current approved size for the
device.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
LL_RW_BLOCK(9)</p>
<hr>
</body>
</html>
