<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:45 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLRE(1) Perl Programmers Reference Guide PERLRE(1)</p>

<p>NAME perlre - Perl regular expressions</p>

<p>DESCRIPTION This page describes the syntax of regular
expressions in Perl.</p>

<p>If you haven t used regular expressions before, a
quick-start introduction is available in perlrequick, and a
longer tutorial introduction is available in perlretut.</p>

<p>For reference on how regular expressions are used in
matching operations, plus various examples of the same, see
discussions of &quot;m//&quot;, &quot;s///&quot;,
&quot;qr//&quot; and &quot;??&quot; in &quot;Regexp
Quote-Like Operators&quot; in perlop.</p>

<p>Modifiers Matching operations can have various
modifiers. Modifiers that relate to the interpretation of
the regular expression inside are listed below. Modifiers
that alter the way a regular expression is used by Perl are
detailed in &quot;Regexp Quote-Like Operators&quot; in
perlop and &quot;Gory details of parsing quoted
constructs&quot; in perlop.</p>

<p>m Treat string as multiple lines. That is, change
&quot;^&quot; and &quot;$&quot; from matching the start or
end of the string to matching the start or end of any line
anywhere within the string.</p>

<p>s Treat string as single line. That is, change
&quot;.&quot; to match any character whatsoever, even a
newline, which normally it would not match.</p>

<p>Used together, as /ms, they let the &quot;.&quot; match
any character whatsoever, while still allowing &quot;^&quot;
and &quot;$&quot; to match, respectively, just after and
just before newlines within the string.</p>

<p>i Do case-insensitive pattern matching.</p>

<p>If &quot;use locale&quot; is in effect, the case map is
taken from the current locale. See perllocale.</p>

<p>x Extend your pattern s legibility by permitting
whitespace and comments.</p>

<p>p Preserve the string matched such that ${^PREMATCH},
{$^MATCH}, and ${^POSTMATCH} are available for use after
matching.</p>

<p>g and c Global matching, and keep the Current position
after failed matching. Unlike i, m, s and x, these two flags
affect the way the regex is used rather than the regex
itself. See &quot;Using regular expressions in Perl&quot; in
perlretut for further explanation of the g and c
modifiers.</p>

<p>These are usually written as &quot;the &quot;/x&quot;
modifier&quot;, even though the delimiter in question might
not really be a slash. Any of these modifiers may also be
embedded within the regular expression itself using the
&quot;(?...)&quot; construct. See below.</p>

<p>The &quot;/x&quot; modifier itself needs a little more
explanation. It tells the regular expression parser to
ignore whitespace that is neither backslashed nor within a
character class. You can use this to break up your regular
expression into (slightly) more readable parts. The
&quot;#&quot; character is also treated as a metacharacter
introducing a comment, just as in ordinary Perl code. This
also means that if you want real whitespace or &quot;#&quot;
characters in the pattern (outside a character class, where
they are unaffected by &quot;/x&quot;), then youll either
have to escape them (using backslashes or &quot;Q...
escapes. Taken together, these features go a long way
towards making Perls regular expressions more readable. Note
that you have to be careful not to include the pattern
delimiter in the comment--perl has no way of knowing you did
not intend to close the pattern early. See the C-comment
deletion code in perlop. Also note that anything inside a
&quot;Q...</p>

<p>Regular Expressions Metacharacters</p>

<p>The patterns used in Perl pattern matching evolved from
those supplied in the Version 8 regex routines. (The
routines are derived (distantly) from Henry Spencer s freely
redistributable reimplementation of the V8 routines.) See
&quot;Version 8 Regular Expressions&quot; for details.</p>

<p>In particular the following metacharacters have their
standard egrep-ish meanings:</p>

<p>Quote the next metacharacter ^ Match the beginning of
the line . Match any character (except newline) $ Match the
end of the line (or before newline at the end) | Alternation
() Grouping [] Character class</p>

<p>By default, the &quot;^&quot; character is guaranteed to
match only the beginning of the string, the &quot;$&quot;
character only the end (or before the newline at the end),
and Perl does certain optimizations with the assumption that
the string contains only one line. Embedded newlines will
not be matched by &quot;^&quot; or &quot;$&quot;. You may,
however, wish to treat a string as a multi-line buffer, such
that the &quot;^&quot; will match after any newline within
the string (except if the newline is the last character in
the string), and &quot;$&quot; will match before any
newline. At the cost of a little more overhead, you can do
this by using the /m modifier on the pattern match operator.
(Older programs did this by setting $*, but this practice
has been removed in perl 5.9.)</p>

<p>To simplify multi-line substitutions, the &quot;.&quot;
character never matches a newline unless you use the
&quot;/s&quot; modifier, which in effect tells Perl to
pretend the string is a single line--even if it isnt.</p>

<p>Quantifiers</p>

<p>The following standard quantifiers are recognized:</p>

<p>* Match 0 or more times + Match 1 or more times ? Match
1 or 0 times {n} Match exactly n times {n,} Match at least n
times {n,m} Match at least n but not more than m times</p>

<p>(If a curly bracket occurs in any other context, it is
treated as a regular character. In particular, the lower
bound is not optional.) The &quot;*&quot; quantifier is
equivalent to &quot;{0,}&quot;, the &quot;+&quot; quantifier
to &quot;{1,}&quot;, and the &quot;?&quot; quantifier to
&quot;{0,1}&quot;. n and m are limited to integral values
less than a preset limit defined when perl is built. This is
usually 32766 on the most common platforms. The actual limit
can be seen in the error message generated by code such as
this:</p>

<p>$_ **= $_ , / {$_} / for 2 .. 42;</p>

<p>By default, a quantified subpattern is
&quot;greedy&quot;, that is, it will match as many times as
possible (given a particular starting location) while still
allowing the rest of the pattern to match. If you want it to
match the minimum number of times possible, follow the
quantifier with a &quot;?&quot;. Note that the meanings dont
change, just the &quot;greediness&quot;:</p>

<p>*? Match 0 or more times, not greedily +? Match 1 or
more times, not greedily ?? Match 0 or 1 time, not greedily
{n}? Match exactly n times, not greedily {n,}? Match at
least n times, not greedily {n,m}? Match at least n but not
more than m times, not greedily</p>

<p>By default, when a quantified subpattern does not allow
the rest of the overall pattern to match, Perl will
backtrack. However, this behaviour is sometimes undesirable.
Thus Perl provides the &quot;possessive&quot; quantifier
form as well.</p>

<p>*+ Match 0 or more times and give nothing back ++ Match
1 or more times and give nothing back ?+ Match 0 or 1 time
and give nothing back {n}+ Match exactly n times and give
nothing back (redundant) {n,}+ Match at least n times and
give nothing back {n,m}+ Match at least n but not more than
m times and give nothing back</p>

<p>For instance,</p>

<p>&rsquo;aaaa&rsquo; =~ /a++a/</p>

<p>will never match, as the &quot;a++&quot; will gobble up
all the &quot;a&quot;s in the string and won t leave any for
the remaining part of the pattern. This feature can be
extremely useful to give perl hints about where it shouldn t
backtrack. For instance, the typical &quot;match a
double-quoted string&quot; problem can be most efficiently
performed when written as:</p>

<p>/&quot;(?:[^&quot;\]++|\.)*+&quot;/</p>

<p>as we know that if the final quote does not match,
backtracking will not help. See the independent
subexpression &quot;(?&gt;...)&quot; for more details;
possessive quantifiers are just syntactic sugar for that
construct. For instance the above example could also be
written as follows:</p>

<p>/&quot;(?&gt;(?:(?&gt;[^&quot;\]+)|\.)*)&quot;/</p>

<p>Escape sequences</p>

<p>Because patterns are processed as double quoted strings,
the following also work:</p>

<p>tab (HT, TAB) newline (LF, NL)return (CR) form feed (FF)
alarm (bell) (BEL) \ escape (think troff) (ESC) 33 octal
char (example: ESC) B hex char (example: ESC) } long hex
char (example: Unicode SMILEY) ame} named Unicode character
lowercase next char (think vi) uppercase next char (think
vi) lowercase till (think vi) U uppercase till (think vi)
end case modification (think vi) Q quote (disable) pattern
metacharacters till If &quot;use locale&quot; is in effect,
the case map used by &quot; &quot; &quot;&quot; and
&quot;U&quot; is taken from the current locale. See
perllocale. For documentation of &quot;ame}&quot;, see
charnames.</p>

<p>You cannot include a literal &quot;$&quot; or
&quot;@&quot; within a &quot;Q&quot; sequence. An unescaped
&quot;$&quot; or &quot;@&quot; interpolates the
corresponding variable, while escaping will cause the
literal string &quot; to be matched. Youll need to write
something like &quot;m/Quser\@Qhost/&quot;.</p>

<p>Character Classes and other Special Escapes</p>

<p>In addition, Perl defines the following:</p>

<p>0 Match a &quot;word&quot; character (alphanumeric plus
&quot;_&quot;) W Match a non-&quot;word&quot; character
Match a whitespace character Match a non-whitespace
character Match a digit character Match a non-digit
character P Match P, named property. Use {Prop} for longer
names. PP Match non-P Match eXtended Unicode &quot;combining
character sequence&quot;, equivalent to (?&gt;PMM*) Match a
single C char (octet) even under Unicode. NOTE: breaks up
characters into their UTF-8 bytes, so you may end up with
malformed pieces of UTF-8. Unsupported in lookbehind. 1
Backreference to a specific group. &rsquo;1&rsquo; may
actually be any positive integer. Backreference to a
specific or previous group, -1} number may be negative
indicating a previous buffer and may optionally be wrapped
in curly brackets for safer parsing. name} Named
backreference name&gt; Named backreference K Keep the stuff
left of the K, don&rsquo;t include it in $&amp; Vertical
whitespace Not vertical whitespace Horizontal whitespace Not
horizontal whitespace Linebreak</p>

<p>A &quot;1320 character, or a decimal digit) or
&quot;_&quot;, not a whole word. Use &quot;96 match a string
of Perl-identifier characters (which isn t the same as
matching an English word). If &quot;use locale&quot; is in
effect, the list of alphabetic characters generated by
&quot;624 locale. See perllocale. You may use
&quot;48W&quot;, &quot; &quot; &quot;&quot;, and &quot; a
range. If any of them precedes or follows a &quot;-&quot;,
the &quot;-&quot; is understood literally. If Unicode is in
effect, &quot;atches also &quot;&quot;, &quot;&quot;, and
&quot;&quot;. See perlunicode for more details about
&quot;P&quot;, &quot;PP&quot;, &quot;&quot; and
&quot;P&quot; properties, and perluniintro about Unicode in
general.</p>

<p>&quot;tomically match a linebreak, including the network
line- ending &quot;DA&quot;. Specifically, is exactly
equivalent to</p>

<p>(?&gt;DA?|[A-C5])</p>

<p>Note: &quot;o special meaning inside of a character
class; use &quot; instead (vertical whitespace).</p>

<p>The POSIX character class syntax</p>

<p>[:class:]</p>

<p>is also available. Note that the &quot;[&quot; and
&quot;]&quot; brackets are literal; they must always be used
within a character class expression.</p>

<p># this is correct: $string =~ /[[:alpha:]]/;</p>

<p># this is not, and will generate a warning: $string =~
/[:alpha:]/;</p>

<p>The available classes and their backslash equivalents
(if available) are as follows:</p>

<p>alpha alnum ascii blank [1] cntrl digit graph lower
print punct space [2] upper word 0 [3] xdigit</p>

<p>[1] A GNU extension equivalent to &quot;[ ]&quot;,
&quot;all horizontal whitespace&quot;.</p>

<p>[2] Not exactly equivalent to &quot;ince the
&quot;[[:space:]]&quot; includes also the (very rare)
&quot;vertical tabulator&quot;, &quot; ASCII.</p>

<p>[3] A Perl extension, see above.</p>

<p>For example use &quot;[:upper:]&quot; to match all the
uppercase characters. Note that the &quot;[]&quot; are part
of the &quot;[::]&quot; construct, not part of the whole
character class. For example:</p>

<p>[01[:alpha:]%]</p>

<p>matches zero, one, any alphabetic character, and the
percent sign.</p>

<p>The following equivalences to Unicode {} constructs and
equivalent backslash character classes (if available), will
hold:</p>

<p>[[:...:]] {...} backslash</p>

<p>alpha IsAlpha alnum IsAlnum ascii IsASCII blank cntrl
IsCntrl digit IsDigit graph IsGraph lower IsLower print
IsPrint (but see [2] below) punct IsPunct (but see [3]
below) space IsSpace IsSpacePerl upper IsUpper word IsWord
744</p>

<p>For example &quot;[[:lower:]]&quot; and
&quot;{IsLower}&quot; are equivalent.</p>

<p>However, the equivalence between &quot;[[:xxxxx:]]&quot;
and &quot;{IsXxxxx}&quot; is not exact.</p>

<p>[1] If the &quot;utf8&quot; pragma is not used but the
&quot;locale&quot; pragma is, the classes correlate with the
usual isalpha(3) interface (except for &quot;word&quot; and
&quot;blank&quot;).</p>

<p>But if the &quot;locale&quot; or &quot;encoding&quot;
pragmas are not used and the string is not &quot;utf8&quot;,
then &quot;[[:xxxxx:]]&quot; (and &quot;408 match characters
0x80-0xff; whereas &quot;{IsXxxxx}&quot; will force the
string to &quot;utf8&quot; and can match these characters
(as Unicode).</p>

<p>[2] &quot;{IsPrint}&quot; matches characters 0x09-0x0d
but &quot;[[:print:]]&quot; does not.</p>

<p>[3] &quot;[[:punct::]]&quot; matches the following but
&quot;{IsPunct}&quot; does not, because they are classed as
symbols (not punctuation) in Unicode.</p>

<p>&quot;$&quot; Currency symbol</p>

<p>&quot;+&quot; &quot;&lt;&quot; &quot;=&quot;
&quot;&gt;&quot; &quot;|&quot; &quot;~&quot; Mathematical
symbols</p>

<p>&quot;^&quot; &quot;&lsquo;&quot; Modifier symbols
(accents)</p>

<p>The other named classes are:</p>

<p>cntrl Any control character. Usually characters that
dont produce output as such but instead control the terminal
somehow: for example newline and backspace are control
characters. All characters with ord() less than 32 are
usually classified as control characters (assuming ASCII,
the ISO Latin character sets, and Unicode), as is the
character with the ord() value of 127 (&quot;DEL&quot;).</p>

<p>graph Any alphanumeric or punctuation (special)
character.</p>

<p>print Any alphanumeric or punctuation (special)
character or the space character.</p>

<p>punct Any punctuation (special) character.</p>

<p>xdigit Any hexadecimal digit. Though this may feel silly
([0-9A-Fa-f] would work just fine) it is included for
completeness.</p>

<p>You can negate the [::] character classes by prefixing
the class name with a ^. This is a Perl extension. For
example:</p>

<p>POSIX traditional Unicode</p>

<p>[[:^digit:]] P{IsDigit} [[:^space:]] P{IsSpace}
[[:^word:]] W P{IsWord}</p>

<p>Perl respects the POSIX standard in that POSIX character
classes are only supported within a character class. The
POSIX character classes [.cc.] and [=cc=] are recognized but
not supported and trying to use them will cause an
error.</p>

<p>Assertions</p>

<p>Perl defines the following zero-width assertions:</p>

<p>Match a word boundary 0 Match except at a word boundary
0Match only at beginning of string Match only at end of
string, or before newline at the end Match only at end of
string G Match only at pos() (e.g. at the end-of-match
position of prior m//g)</p>

<p>) i s a s p o t b e t w e e n t w o A word boundary
(&quot;c0 h a r a c t e r s t h a t h a s a on one side of
it and a &quot;W&quot; on the other side of it (in either
order), counting the imaginary characters off the beginning
and end of the r e p r e string as matching a &quot;W&quot;.
(Within character classes &quot;s e n t s backspace rather
than a word boundary, just as it normally does in any
double-quoted string.) The &quot;0
areandjust&quot;$&quot;,lik^&quot; except that they wont
match multiple times when the &quot;/m&quot; modifier is
used, while &quot;^&quot; and &quot;$&quot; will match at
every internal line boundary. To match the actual end of the
string and not ignore an optional trailing newline, use
&quot;.</p>

<p>The &quot;G&quot; assertion can be used to chain global
matches (using &quot;m//g&quot;), as described in
&quot;Regexp Quote-Like Operators&quot; in perlop. It is
also useful when writing &quot;lex&quot;-like scanners, when
you have several patterns that you want to match against
consequent substrings of your string, see the previous
reference. The actual location where &quot;G&quot; will
match can also be influenced by using &quot;pos()&quot; as
an lvalue: see &quot;pos&quot; in perlfunc. Note that the
rule for zero-length matches is modified somewhat, in that
contents to the left of &quot;G&quot; is not counted when
determining the length of the match. Thus the following will
not match forever:</p>

<p>$str = &rsquo;ABC&rsquo;; pos($str) = 1; while (/.G/g) {
print $&amp;; }</p>

<p>It will print A and then terminate, as it considers the
match to be zero-width, and thus will not match at the same
position twice in a row.</p>

<p>It is worth noting that &quot;G&quot; improperly used
can result in an infinite loop. Take care when using
patterns that include &quot;G&quot; in an alternation.</p>

<p>Capture buffers</p>

<p>The bracketing construct &quot;( ... )&quot; creates
capture buffers. To refer to the current contents of a
buffer later on, within the same pattern, use 1 for the
first, 2 for the second, and so on. Outside the match use
&quot;$&quot; instead of &quot; circumstances outside the
match. See the warning below about 1 vs $1 for details.)
Referring back to another part of the match is called a
backreference.</p>

<p>There is no limit to the number of captured substrings
that you may use. However Perl also uses 10, 11, etc. as
aliases for 10, 11, etc. (Recall that 0 means octal, so 11
is the character at number 9 in your coded character set;
which would be the 10th character, a horizontal tab under
ASCII.) Perl resolves this ambiguity by interpreting 10 as a
backreference only if at least 10 left parentheses have
opened before it. Likewise 11 is a backreference only if at
least 11 left parentheses have opened before it. And so on.
1 through 9 are always interpreted as backreferences.</p>

<p>In order to provide a safer and easier way to construct
patterns using backreferences, Perl provides the
&quot;N}&quot; notation (starting with perl 5.10.0). The
curly brackets are optional, however omitting them is less
safe as the meaning of the pattern can be changed by text
(such as digits) following it. When N is a positive integer
the &quot;N}&quot; notation is exactly equivalent to using
normal backreferences. When N is a negative integer then it
is a relative backreference referring to the previous N th
capturing group. When the bracket form is used and N is not
an integer, it is treated as a reference to a named
buffer.</p>

<p>Thus &quot;-1}&quot; refers to the last buffer,
&quot;-2}&quot; refers to the buffer before that. For
example:</p>

<p>/ (Y) # buffer 1 ( # buffer 2 (X) # buffer 3 -1} #
backref to buffer 3 -3} # backref to buffer 1 ) /x</p>

<p>and would match the same as &quot;/(Y) ( (X) 3 1
)/x&quot;.</p>

<p>Additionally, as of Perl 5.10.0 you may use named
capture buffers and named backreferences. The notation is
&quot;(?&lt;name&gt;...)&quot; to declare and
&quot;name&gt;&quot; to reference. You may also use
apostrophes instead of angle brackets to delimit the name;
and you may use the bracketed &quot;name}&quot;
backreference syntax. Its possible to refer to a named
capture buffer by absolute and relative number as well.
Outside the pattern, a named capture buffer is available via
the &quot;%+&quot; hash. When different buffers within the
same pattern have the same name, $+{name} and
&quot;name&gt;&quot; refer to the leftmost defined group.
(Thus its possible to do things with named capture buffers
that would otherwise require &quot;(??{})&quot; code to
accomplish.)</p>

<p>Examples:</p>

<p>s/^([^ ]*) *([^ ]*)/$2 $1/; # swap first two words</p>

<p>/(.)1/ # find first doubled char and print
&quot;&rsquo;$1&rsquo; is the first doubled character0;</p>

<p>/(?&lt;char&gt;.)char&gt;/ # ... a different way and
print &quot;&rsquo;$+{char}&rsquo; is the first doubled
character0;</p>

<p>/(?&rsquo;char&rsquo;.)1/ # ... mix and match and print
&quot;&rsquo;$1&rsquo; is the first doubled character0;</p>

<p>if (/Time: (..):(..):(..)/) { # parse out values $hours
= $1; $minutes = $2; $seconds = $3; }</p>

<p>Several special variables also refer back to portions of
the previous match. $+ returns whatever the last bracket
match matched. $&amp; returns the entire matched string. (At
one point $0 did also, but now it returns the name of the
program.) &quot;$&lsquo;&quot; returns everything before the
matched string. &quot;$&rsquo;&quot; returns everything
after the matched string. And $^N contains whatever was
matched by the most-recently closed group (submatch). $^N
can be used in extended patterns (see below), for example to
assign a submatch to a variable.</p>

<p>The numbered match variables ($1, $2, $3, etc.) and the
related punctuation set ($+, $&amp;, &quot;$&lsquo;&quot;,
&quot;$&rsquo;&quot;, and $^N) are all dynamically scoped
until the end of the enclosing block or until the next
successful match, whichever comes first. (See &quot;Compound
Statements&quot; in perlsyn.)</p>

<p>NOTE: Failed matches in Perl do not reset the match
variables, which makes it easier to write code that tests
for a series of more specific cases and remembers the best
match.</p>

<p>WARNING: Once Perl sees that you need one of $&amp;,
&quot;$&lsquo;&quot;, or &quot;$&rsquo;&quot; anywhere in
the program, it has to provide them for every pattern match.
This may substantially slow your program. Perl uses the same
mechanism to produce $1, $2, etc, so you also pay a price
for each pattern that contains capturing parentheses. (To
avoid this cost while retaining the grouping behaviour, use
the extended regular expression &quot;(?: ... )&quot;
instead.) But if you never use $&amp;, &quot;$&lsquo;&quot;
or &quot;$&rsquo;&quot;, then patterns without capturing
parentheses will not be penalized. So avoid $&amp;,
&quot;$&rsquo;&quot;, and &quot;$&lsquo;&quot; if you can,
but if you can t (and some algorithms really appreciate
them), once youve used them once, use them at will, because
youve already paid the price. As of 5.005, $&amp; is not so
costly as the other two.</p>

<p>As a workaround for this problem, Perl 5.10.0 introduces
&quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot; and
&quot;${^POSTMATCH}&quot;, which are equivalent to
&quot;$&lsquo;&quot;, $&amp; and &quot;$&rsquo;&quot;,
except that they are only guaranteed to be defined after a
successful match that was executed with the &quot;/p&quot;
(preserve) modifier. The use of these variables incurs no
global performance penalty, unlike their punctuation char
equivalents, however at the trade-off that you have to tell
perl when you want to use them.</p>

<p>Backslashed metacharacters in Perl are alphanumeric,
such as &quot;, &quot;480. Unlike some other regular
expression languages, there are no backslashed symbols that
aren t alphanumeric. So anything that looks like \, , &lt;,
&gt;, , or is always interpreted as a literal character, not
a metacharacter. This was once used in a common idiom to
disable or quote the special meanings of regular expression
metacharacters in a string that you want to use for a
pattern. Simply quote all non-&quot;word&quot;
characters:</p>

<p>$pattern =~ s/(W)/\$1/g;</p>

<p>(If &quot;use locale&quot; is set, then this depends on
the current locale.) Today it is more common to use the
quotemeta() function or the &quot;Q&quot; metaquoting escape
sequence to disable all metacharacters special meanings like
this:</p>

<p>/$unquotedQ$quotednquoted/</p>

<p>Beware that if you put literal backslashes (those not
inside interpolated variables) between &quot;Q&quot; and
&quot; interpolation may lead to confusing results. If you
need to use literal backslashes within &quot;Q... quoted
constructs&quot; in perlop.</p>

<p>Extended Patterns Perl also defines a consistent
extension syntax for features not found in standard tools
like awk and lex. The syntax is a pair of parentheses with a
question mark as the first thing within the parentheses. The
character after the question mark indicates the
extension.</p>

<p>The stability of these extensions varies widely. Some
have been part of the core language for many years. Others
are experimental and may change without warning or be
completely removed. Check the documentation on an individual
feature to verify its current status.</p>

<p>A question mark was chosen for this and for the
minimal-matching construct because 1) question marks are
rare in older regular expressions, and 2) whenever you see
one, you should stop and &quot;question&quot; exactly what
is going on. Thats psychology...</p>

<p>&quot;(?#text)&quot; A comment. The text is ignored. If
the &quot;/x&quot; modifier enables whitespace formatting, a
simple &quot;#&quot; will suffice. Note that Perl closes the
comment as soon as it sees a &quot;)&quot;, so there is no
way to put a literal &quot;)&quot; in the comment.</p>

<p>&quot;(?pimsx-imsx)&quot; One or more embedded
pattern-match modifiers, to be turned on (or turned off, if
preceded by &quot;-&quot;) for the remainder of the pattern
or the remainder of the enclosing pattern group (if any).
This is particularly useful for dynamic patterns, such as
those read in from a configuration file, taken from an
argument, or specified in a table somewhere. Consider the
case where some patterns want to be case sensitive and some
do not: The case insensitive ones merely need to include
&quot;(?i)&quot; at the front of the pattern. For
example:</p>

<p>$pattern = &quot;foobar&quot;; if ( /$pattern/i ) {
}</p>

<p># more flexible:</p>

<p>$pattern = &quot;(?i)foobar&quot;; if ( /$pattern/ ) {
}</p>

<p>These modifiers are restored at the end of the enclosing
group. For example,</p>

<p>( (?i) blah ) 1</p>

<p>will match &quot;blah&quot; in any case, some spaces,
and an exact (including the case!) repetition of the
previous word, assuming the &quot;/x&quot; modifier, and no
&quot;/i&quot; modifier outside this group.</p>

<p>Note that the &quot;p&quot; modifier is special in that
it can only be enabled, not disabled, and that its presence
anywhere in a pattern has a global effect. Thus
&quot;(?-p)&quot; and &quot;(?-p:...)&quot; are meaningless
and will warn when executed under &quot;use
warnings&quot;.</p>

<p>&quot;(?:pattern)&quot; &quot;(?imsx-imsx:pattern)&quot;
This is for clustering, not capturing; it groups
subexpressions like &quot;()&quot;, but doesn t make
backreferences as &quot;()&quot; does. So</p>

<p>? : a | @fields = split(/b | c )</p>

<p>is like</p>

<p>a | b @fields = split(/| c )</p>

<p>but doesn t spit out extra fields. Its also cheaper not
to capture characters if you dont need to.</p>

<p>Any letters between &quot;?&quot; and &quot;:&quot; act
as flags modifiers as with &quot;(?imsx-imsx)&quot;. For
example,</p>

<p>/(?s-i:more.*than).*million/i</p>

<p>is equivalent to the more verbose</p>

<p>/(?:(?s-i)more.*than).*million/i</p>

<p>&quot;(?|pattern)&quot; This is the &quot;branch
reset&quot; pattern, which has the special property that the
capture buffers are numbered from the same starting point in
each alternation branch. It is available starting from perl
5.10.0.</p>

<p>Capture buffers are numbered from left to right, but
inside this construct the numbering is restarted for each
branch.</p>

<p>The numbering within each branch will be as normal, and
any buffers following this construct will be numbered as
though the construct contained only one branch, that being
the one with the most capture buffers in it.</p>

<p>This construct will be useful when you want to capture
one of a number of alternative matches.</p>

<p>Consider the following pattern. The numbers underneath
show in which buffer the captured content will be
stored.</p>

<p># before ---------------branch-reset----------- after /
( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x # 1 2
2 3 2 3 4</p>

<p>Note: as of Perl 5.10.0, branch resets interfere with
the contents of the &quot;%+&quot; hash, that holds named
captures. Consider using &quot;%-&quot; instead.</p>

<p>Look-Around Assertions Look-around assertions are zero
width patterns which match a specific pattern without
including it in $&amp;. Positive assertions match when their
subpattern matches, negative assertions match when their
subpattern fails. Look-behind matches text up to the current
match position, look-ahead matches text following the
current match position.</p>

<p>&quot;(?=pattern)&quot; A zero-width positive look-ahead
assertion. For example, &quot;/1152 including the tab in
$&amp;.</p>

<p>&quot;(?!pattern)&quot; A zero-width negative look-ahead
assertion. For example &quot;/foo(?!bar)/&quot; matches any
occurrence of &quot;foo&quot; that isnt followed by
&quot;bar&quot;. Note however that look-ahead and
look-behind are NOT the same thing. You cannot use this for
look-behind.</p>

<p>If you are looking for a &quot;bar&quot; that isn t
preceded by a &quot;foo&quot;, &quot;/(?!foo)bar/&quot; will
not do what you want. Thats because the &quot;(?!foo)&quot;
is just saying that the next thing cannot be
&quot;foo&quot;--and its not, its a &quot;bar&quot;, so
&quot;foobar&quot; will match. You would have to do
something like &quot;/(?!foo)...bar/&quot; for that. We say
&quot;like&quot; because theres the case of your
&quot;bar&quot; not having three characters before it. You
could cover that this way:
&quot;/(?:(?!foo)...|^.{0,2})bar/&quot;. Sometimes it s
still easier just to say:</p>

<p>if (/bar/ &amp;&amp; $&lsquo; !~ /foo$/)</p>

<p>For look-behind see below.</p>

<p>&quot;(?&lt;=pattern)&quot; &quot;K&quot; A zero-width
positive look-behind assertion. For example,
&quot;/(?&lt;=)768 tab, without including the tab in $&amp;.
Works only for fixed-width look-behind.</p>

<p>There is a special form of this construct, called
&quot;K&quot;, which causes the regex engine to
&quot;keep&quot; everything it had matched prior to the
&quot;K&quot; and not include it in $&amp;. This effectively
provides variable length look-behind. The use of
&quot;K&quot; inside of another look-around assertion is
allowed, but the behaviour is currently not well
defined.</p>

<p>For various reasons &quot;K&quot; may be significantly
more efficient than the equivalent &quot;(?&lt;=...)&quot;
construct, and it is especially useful in situations where
you want to efficiently remove something following something
else in a string. For instance</p>

<p>s/(foo)bar/$1/g;</p>

<p>can be rewritten as the much more efficient</p>

<p>s/fooKbar//g;</p>

<p>&quot;(?&lt;!pattern)&quot; A zero-width negative
look-behind assertion. For example
&quot;/(?&lt;!bar)foo/&quot; matches any occurrence of
&quot;foo&quot; that does not follow &quot;bar&quot;. Works
only for fixed-width look- behind.</p>

<p>&quot;(?&rsquo;NAME&rsquo;pattern)&quot;
&quot;(?&lt;NAME&gt;pattern)&quot; A named capture buffer.
Identical in every respect to normal capturing parentheses
&quot;()&quot; but for the additional fact that
&quot;%+&quot; or &quot;%-&quot; may be used after a
successful match to refer to a named buffer. See
&quot;perlvar&quot; for more details on the &quot;%+&quot;
and &quot;%-&quot; hashes.</p>

<p>If multiple distinct capture buffers have the same name
then the $+{NAME} will refer to the leftmost defined buffer
in the match.</p>

<p>The forms &quot;(?&rsquo;NAME&rsquo;pattern)&quot; and
&quot;(?&lt;NAME&gt;pattern)&quot; are equivalent.</p>

<p>NOTE: While the notation of this construct is the same
as the similar function in .NET regexes, the behavior is
not. In Perl the buffers are numbered sequentially
regardless of being named or not. Thus in the pattern</p>

<p>/(x)(?&lt;foo&gt;y)(z)/</p>

<p>$+{foo} will be the same as $2, and $3 will contain z
instead of the opposite which is what a .NET regex hacker
might expect.</p>

<p>Currently NAME is restricted to simple identifiers only.
In other words, it must match
&quot;/^[_A-Za-z][_A-Za-z0-9]*&quot; or its Unicode
extension (see utf8), though it isnt extended by the locale
(see perllocale).</p>

<p>NOTE: In order to make things easier for programmers
with experience with the Python or PCRE regex engines, the
pattern &quot;(?PE&lt;lt&gt;NAMEE&lt;gt&gt;pattern)&quot;
may be used instead of &quot;(?&lt;NAME&gt;pattern)&quot;;
however this form does not support the use of single quotes
as a delimiter for the name.</p>

<p>&quot;NAME&gt;&quot; &quot;NAME&rsquo;&quot; Named
backreference. Similar to numeric backreferences, except
that the group is designated by name and not number. If
multiple groups have the same name then it refers to the
leftmost defined group in the current match.</p>

<p>It is an error to refer to a name not defined by a
&quot;(?&lt;NAME&gt;)&quot; earlier in the pattern.</p>

<p>Both forms are equivalent.</p>

<p>NOTE: In order to make things easier for programmers
with experience with the Python or PCRE regex engines, the
pattern &quot;(?P=NAME)&quot; may be used instead of
&quot;NAME&gt;&quot;.</p>

<p>&quot;(?{ code })&quot; WARNING: This extended regular
expression feature is considered experimental, and may be
changed without notice. Code executed that has side effects
may not perform identically from version to version due to
the effect of future optimisations in the regex engine.</p>

<p>This zero-width assertion evaluates any embedded Perl
code. It always succeeds, and its &quot;code&quot; is not
interpolated. Currently, the rules to determine where the
&quot;code&quot; ends are somewhat convoluted.</p>

<p>This feature can be used together with the special
variable $^N to capture the results of submatches in
variables without having to keep track of the number of
nested parentheses. For example:</p>

<p>$_ = &quot;The brown fox jumps over the lazy dog&quot;;
/the ()(?{ $color = $^N }) ()(?{ $animal = $^N })/i; print
&quot;color = $color, animal = $animal0;</p>

<p>Inside the &quot;(?{...})&quot; block, $_ refers to the
string the regular expression is matching against. You can
also use &quot;pos()&quot; to know what is the current
position of matching within this string.</p>

<p>The &quot;code&quot; is properly scoped in the following
sense: If the assertion is backtracked (compare
&quot;Backtracking&quot;), all changes introduced after
&quot;local&quot;ization are undone, so that</p>

<p>$_ = &rsquo;a&rsquo; x 8; m&lt; (?{ $cnt = 0 }) #
Initialize $cnt. ( a (?{ local $cnt = $cnt + 1; # Update
$cnt, backtracking-safe. }) )* aaaa (?{ $res = $cnt }) # On
success copy to non-localized # location. &gt;x;</p>

<p>will set &quot;$res = 4&quot;. Note that after the
match, $cnt returns to the globally introduced value,
because the scopes that restrict &quot;local&quot; operators
are unwound.</p>

<p>This assertion may be used as a
&quot;(?(condition)yes-pattern|no-pattern)&quot; switch. If
not used in this way, the result of evaluation of
&quot;code&quot; is put into the special variable $^R. This
happens immediately, so $^R can be used from other &quot;(?{
code })&quot; assertions inside the same regular
expression.</p>

<p>The assignment to $^R above is properly localized, so
the old value of $^R is restored if the assertion is
backtracked; compare &quot;Backtracking&quot;.</p>

<p>Due to an unfortunate implementation issue, the Perl
code contained in these blocks is treated as a compile time
closure that can have seemingly bizarre consequences when
used with lexically scoped variables inside of subroutines
or loops. There are various workarounds for this, including
simply using global variables instead. If you are using this
construct and strange results occur then check for the use
of lexically scoped variables.</p>

<p>For reasons of security, this construct is forbidden if
the regular expression involves run-time interpolation of
variables, unless the perilous &quot;use re
&rsquo;eval&rsquo;&quot; pragma has been used (see re), or
the variables contain results of &quot;qr//&quot; operator
(see &quot;qr/STRING/imosx&quot; in perlop).</p>

<p>This restriction is due to the wide-spread and
remarkably convenient custom of using run-time determined
strings as patterns. For example:</p>

<p>$re = &lt;&gt;; chomp $re; $string =~ /$re/;</p>

<p>Before Perl knew how to execute interpolated code within
a pattern, this operation was completely safe from a
security point of view, although it could raise an exception
from an illegal pattern. If you turn on the &quot;use re
&rsquo;eval&rsquo;&quot;, though, it is no longer secure, so
you should only do so if you are also using taint checking.
Better yet, use the carefully constrained evaluation within
a Safe compartment. See perlsec for details about both these
mechanisms.</p>

<p>Because Perl s regex engine is currently not re-entrant,
interpolated code may not invoke the regex engine either
directly with &quot;m//&quot; or &quot;s///&quot;), or
indirectly with functions such as &quot;split&quot;.</p>

<p>&quot;(??{ code })&quot; WARNING: This extended regular
expression feature is considered experimental, and may be
changed without notice. Code executed that has side effects
may not perform identically from version to version due to
the effect of future optimisations in the regex engine.</p>

<p>This is a &quot;postponed&quot; regular subexpression.
The &quot;code&quot; is evaluated at run time, at the moment
this subexpression may match. The result of evaluation is
considered as a regular expression and matched as if it were
inserted instead of this construct. Note that this means
that the contents of capture buffers defined inside an
evaled pattern are not available outside of the pattern, and
vice versa, there is no way for the inner pattern to refer
to a capture buffer defined outside. Thus,</p>

<p>(&rsquo;a&rsquo; x 100)=~/(??{&rsquo;(.)&rsquo; x
100})/</p>

<p>will match, it will not set $1.</p>

<p>The &quot;code&quot; is not interpolated. As before, the
rules to determine where the &quot;code&quot; ends are
currently somewhat convoluted.</p>

<p>The following pattern matches a parenthesized group:</p>

<p>$re = qr{ (?: (?&gt; [^()]+ ) # Non-parens without
backtracking | (??{ $re }) # Group with matching parens )*
}x;</p>

<p>See also &quot;(?PARNO)&quot; for a different, more
efficient way to accomplish the same task.</p>

<p>Because perls regex engine is not currently re-entrant,
delayed code may not invoke the regex engine either directly
with &quot;m//&quot; or &quot;s///&quot;), or indirectly
with functions such as &quot;split&quot;.</p>

<p>Recursing deeper than 50 times without consuming any
input string will result in a fatal error. The maximum depth
is compiled into perl, so changing it requires a custom
build.</p>

<p>&quot;(?PARNO)&quot; &quot;(?-PARNO)&quot;
&quot;(?+PARNO)&quot; &quot;(?R)&quot; &quot;(?0)&quot;
Similar to &quot;(??{ code })&quot; except it does not
involve compiling any code, instead it treats the contents
of a capture buffer as an independent pattern that must
match at the current position. Capture buffers contained by
the pattern will have the value as determined by the
outermost recursion.</p>

<p>PARNO is a sequence of digits (not starting with 0)
whose value reflects the paren-number of the capture buffer
to recurse to. &quot;(?R)&quot; recurses to the beginning of
the whole pattern. &quot;(?0)&quot; is an alternate syntax
for &quot;(?R)&quot;. If PARNO is preceded by a plus or
minus sign then it is assumed to be relative, with negative
numbers indicating preceding capture buffers and positive
ones following. Thus &quot;(?-1)&quot; refers to the most
recently declared buffer, and &quot;(?+1)&quot; indicates
the next buffer to be declared. Note that the counting for
relative recursion differs from that of relative
backreferences, in that with recursion unclosed buffers are
included.</p>

<p>The following pattern matches a function foo() which may
contain balanced parentheses as the argument.</p>

<p>$re = qr{ ( # paren group 1 (full function) foo ( #
paren group 2 (parens) ( # paren group 3 (contents of
parens) (?: (?&gt; [^()]+ ) # Non-parens without
backtracking | (?2) # Recurse to start of paren group 2 )* )
) ) }x;</p>

<p>If the pattern was used as follows</p>

<p>&rsquo;foo(bar(baz)+baz(bop))&rsquo;=~/$re/ and print
&quot; = $10, &quot; = $20, &quot; = $30;</p>

<p>the output produced should be the following:</p>

<p>$1 = foo(bar(baz)+baz(bop)) $2 = (bar(baz)+baz(bop)) $3
= bar(baz)+baz(bop)</p>

<p>If there is no corresponding capture buffer defined,
then it is a fatal error. Recursing deeper than 50 times
without consuming any input string will also result in a
fatal error. The maximum depth is compiled into perl, so
changing it requires a custom build.</p>

<p>The following shows how using negative indexing can make
it easier to embed recursive patterns inside of a
&quot;qr//&quot; construct for later use:</p>

<p>my $parens = qr/(:[^()]++|(?-1))*+)/; if (/foo $parens +
bar $parens/x) { # do something here... }</p>

<p>Note that this pattern does not behave the same way as
the equivalent PCRE or Python construct of the same form. In
Perl you can backtrack into a recursed group, in PCRE and
Python the recursed into group is treated as atomic. Also,
modifiers are resolved at compile time, so constructs like
(?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern
will be processed.</p>

<p>&quot;(?&amp;NAME)&quot; Recurse to a named subpattern.
Identical to &quot;(?PARNO)&quot; except that the
parenthesis to recurse to is determined by name. If multiple
parentheses have the same name, then it recurses to the
leftmost.</p>

<p>It is an error to refer to a name that is not declared
somewhere in the pattern.</p>

<p>NOTE: In order to make things easier for programmers
with experience with the Python or PCRE regex engines the
pattern &quot;(?P&gt;NAME)&quot; may be used instead of
&quot;(?&amp;NAME)&quot;.</p>

<p>&quot;(?(condition)yes-pattern|no-pattern)&quot;
&quot;(?(condition)yes-pattern)&quot; Conditional
expression. &quot;(condition)&quot; should be either an
integer in parentheses (which is valid if the corresponding
pair of parentheses matched), a
look-ahead/look-behind/evaluate zero-width assertion, a name
in angle brackets or single quotes (which is valid if a
buffer with the given name matched), or the special symbol
(R) (true when evaluated inside of recursion or eval).
Additionally the R may be followed by a number, (which will
be true when evaluated when recursing inside of the
appropriate group), or by &amp;NAME, in which case it will
be true only when evaluated during recursion in the named
group.</p>

<p>Heres a summary of the possible predicates:</p>

<p>(1) (2) ... Checks if the numbered capturing buffer has
matched something.</p>

<p>(&lt;NAME&gt;) (NAME) Checks if a buffer with the given
name has matched something.</p>

<p>(?{ CODE }) Treats the code block as the condition.</p>

<p>(R) Checks if the expression has been evaluated inside
of recursion.</p>

<p>(R1) (R2) ... Checks if the expression has been
evaluated while executing directly inside of the n-th
capture group. This check is the regex equivalent of</p>

<p>if ((caller(0))[3] eq &rsquo;subname&rsquo;) { ... }</p>

<p>In other words, it does not check the full recursion
stack.</p>

<p>(R&amp;NAME) Similar to &quot;(R1)&quot;, this predicate
checks to see if were executing directly inside of the
leftmost group with a given name (this is the same logic
used by &quot;(?&amp;NAME)&quot; to disambiguate). It does
not check the full stack, but only the name of the innermost
active recursion.</p>

<p>(DEFINE) In this case, the yes-pattern is never directly
executed, and no no-pattern is allowed. Similar in spirit to
&quot;(?{0})&quot; but more efficient. See below for
details.</p>

<p>For example:</p>

<p>m{ ( )? [^()]+ (?(1) ) }x</p>

<p>matches a chunk of non-parentheses, possibly included in
parentheses themselves.</p>

<p>A special form is the &quot;(DEFINE)&quot; predicate,
which never executes directly its yes-pattern, and does not
allow a no- pattern. This allows to define subpatterns which
will be executed only by using the recursion mechanism. This
way, you can define a set of regular expression rules that
can be bundled into any pattern you choose.</p>

<p>It is recommended that for this usage you put the DEFINE
block at the end of the pattern, and that you name any
subpatterns defined within it.</p>

<p>Also, its worth noting that patterns defined this way
probably will not be as efficient, as the optimiser is not
very clever about handling them.</p>

<p>An example of how this might be used is as follows:</p>


<p>/(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
(?(DEFINE) (?&lt;NAME_PAT&gt;....) (?&lt;ADRESS_PAT&gt;....)
)/x</p>

<p>Note that capture buffers matched inside of recursion
are not accessible after the recursion returns, so the extra
layer of capturing buffers is necessary. Thus $+{NAME_PAT}
would not be defined even though $+{NAME} would be.</p>

<p>&quot;(?&gt;pattern)&quot; An &quot;independent&quot;
subexpression, one which matches the substring that a
standalone &quot;pattern&quot; would match if anchored at
the given position, and it matches nothing other than this
substring. This construct is useful for optimizations of
what would otherwise be &quot;eternal&quot; matches, because
it will not backtrack (see &quot;Backtracking&quot;). It may
also be useful in places where the &quot;grab all you can,
and do not give anything back&quot; semantic is
desirable.</p>

<p>For example: &quot;^(?&gt;a*)ab&quot; will never match,
since &quot;(?&gt;a*)&quot; (anchored at the beginning of
string, as above) will match all characters &quot;a&quot; at
the beginning of string, leaving no &quot;a&quot; for
&quot;ab&quot; to match. In contrast, &quot;a*ab&quot; will
match the same as &quot;a+b&quot;, since the match of the
subgroup &quot;a*&quot; is influenced by the following group
&quot;ab&quot; (see &quot;Backtracking&quot;). In
particular, &quot;a*&quot; inside &quot;a*ab&quot; will
match fewer characters than a standalone &quot;a*&quot;,
since this makes the tail match.</p>

<p>An effect similar to &quot;(?&gt;pattern)&quot; may be
achieved by writing &quot;(?=(pattern))1&quot;. This matches
the same substring as a standalone &quot;a+&quot;, and the
following &quot;1&quot; eats the matched string; it
therefore makes a zero-length assertion into an analogue of
&quot;(?&gt;...)&quot;. (The difference between these two
constructs is that the second one uses a capturing group,
thus shifting ordinals of backreferences in the rest of a
regular expression.)</p>

<p>Consider this pattern:</p>

<p>m{ ( [^()]+ # x+ | [^()]* )+ }x</p>

<p>That will efficiently match a nonempty group with
matching parentheses two levels deep or less. However, if
there is no such group, it will take virtually forever on a
long string. Thats because there are so many different ways
to split a long string into several substrings. This is what
&quot;(.+)+&quot; is doing, and &quot;(.+)+&quot; is similar
to a subpattern of the above pattern. Consider how the
pattern above detects no-match on
&quot;((()aaaaaaaaaaaaaaaaaa&quot; in several seconds, but
that each extra letter doubles this time. This exponential
performance will make it appear that your program has hung.
However, a tiny change to this pattern</p>

<p>m{ ( (?&gt; [^()]+ ) # change x+ above to (?&gt; x+ ) |
[^()]* )+ }x</p>

<p>which uses &quot;(?&gt;...)&quot; matches exactly when
the one above does (verifying this yourself would be a
productive exercise), but finishes in a fourth the time when
used on a similar string with 1000000 &quot;a&quot;s. Be
aware, however, that this pattern currently triggers a
warning message under the &quot;use warnings&quot; pragma or
-w switch saying it &quot;matches null string many times in
regex&quot;.</p>

<p>On simple groups, such as the pattern &quot;(?&gt;
[^()]+ )&quot;, a comparable effect may be achieved by
negative look-ahead, as in &quot;[^()]+ (?! [^()] )&quot;.
This was only 4 times slower on a string with 1000000
&quot;a&quot;s.</p>

<p>The &quot;grab all you can, and do not give anything
back&quot; semantic is desirable in many situations where on
the first sight a simple &quot;()*&quot; looks like the
correct solution. Suppose we parse text with comments being
delimited by &quot;#&quot; followed by some optional
(horizontal) whitespace. Contrary to its appearance,
&quot;#[ ]*&quot; is not the correct subexpression to match
the comment delimiter, because it may &quot;give up&quot;
some whitespace if the remainder of the pattern can be made
to match that way. The correct answer is either one of
these:</p>

<p>(?&gt;#[ ]*) #[ ]*(?![ ])</p>

<p>For example, to grab non-empty comments into $1, one
should use either one of these:</p>

<p>/ (?&gt; / Which one you pick depends on which of these
expressions better reflects the above specification of
comments.</p>

<p>In some literature this construct is called &quot;atomic
matching&quot; or &quot;possessive matching&quot;.</p>

<p>Possessive quantifiers are equivalent to putting the
item they are applied to inside of one of these constructs.
The following equivalences apply:</p>

<p>Quantifier Form Bracketing Form ---------------
--------------- PAT*+ (?&gt;PAT*) PAT++ (?&gt;PAT+) PAT?+
(?&gt;PAT?) PAT{min,max}+ (?&gt;PAT{min,max})</p>

<p>Special Backtracking Control Verbs WARNING: These
patterns are experimental and subject to change or removal
in a future version of Perl. Their usage in production code
should be noted to avoid problems during upgrades.</p>

<p>These special patterns are generally of the form
&quot;(*VERB:ARG)&quot;. Unless otherwise stated the ARG
argument is optional; in some cases, it is forbidden.</p>

<p>Any pattern containing a special backtracking verb that
allows an argument has the special behaviour that when
executed it sets the current packages $REGERROR and $REGMARK
variables. When doing so the following rules apply:</p>

<p>On failure, the $REGERROR variable will be set to the
ARG value of the verb pattern, if the verb was involved in
the failure of the match. If the ARG part of the pattern was
omitted, then $REGERROR will be set to the name of the last
&quot;(*MARK:NAME)&quot; pattern executed, or to TRUE if
there was none. Also, the $REGMARK variable will be set to
FALSE.</p>

<p>On a successful match, the $REGERROR variable will be
set to FALSE, and the $REGMARK variable will be set to the
name of the last &quot;(*MARK:NAME)&quot; pattern executed.
See the explanation for the &quot;(*MARK:NAME)&quot; verb
below for more details.</p>

<p>NOTE: $REGERROR and $REGMARK are not magic variables
like $1 and most other regex related variables. They are not
local to a scope, nor readonly, but instead are volatile
package variables similar to $AUTOLOAD. Use
&quot;local&quot; to localize changes to them to a specific
scope if necessary.</p>

<p>If a pattern does not contain a special backtracking
verb that allows an argument, then $REGERROR and $REGMARK
are not touched at all.</p>

<p>Verbs that take an argument &quot;(*PRUNE)&quot;
&quot;(*PRUNE:NAME)&quot; This zero-width pattern prunes the
backtracking tree at the current point when backtracked into
on failure. Consider the pattern &quot;A (*PRUNE) B&quot;,
where A and B are complex patterns. Until the
&quot;(*PRUNE)&quot; verb is reached, A may backtrack as
necessary to match. Once it is reached, matching continues
in B, which may also backtrack as necessary; however, should
B not match, then no further backtracking will take place,
and the pattern will fail outright at the current starting
position.</p>

<p>The following example counts all the possible matching
strings in a pattern (without actually matching any of
them).</p>

<p>&rsquo;aaab&rsquo; =~ /a+b?(?{print &quot;$&amp;0;
$count++})(*FAIL)/; print &quot;Count=$count0;</p>

<p>which produces:</p>

<p>aaab aaa aa a aab aa a ab a Count=9</p>

<p>If we add a &quot;(*PRUNE)&quot; before the count like
the following</p>

<p>&rsquo;aaab&rsquo; =~ /a+b?(*PRUNE)(?{print
&quot;$&amp;0; $count++})(*FAIL)/; print
&quot;Count=$count0;</p>

<p>we prevent backtracking and find the count of the
longest matching at each matching starting point like
so:</p>

<p>aaab aab ab Count=3</p>

<p>Any number of &quot;(*PRUNE)&quot; assertions may be
used in a pattern.</p>

<p>See also &quot;(?&gt;pattern)&quot; and possessive
quantifiers for other ways to control backtracking. In some
cases, the use of &quot;(*PRUNE)&quot; can be replaced with
a &quot;(?&gt;pattern)&quot; with no functional difference;
however, &quot;(*PRUNE)&quot; can be used to handle cases
that cannot be expressed using a &quot;(?&gt;pattern)&quot;
alone.</p>

<p>&quot;(*SKIP)&quot; &quot;(*SKIP:NAME)&quot; This
zero-width pattern is similar to &quot;(*PRUNE)&quot;,
except that on failure it also signifies that whatever text
that was matched leading up to the &quot;(*SKIP)&quot;
pattern being executed cannot be part of any match of this
pattern. This effectively means that the regex engine
&quot;skips&quot; forward to this position on failure and
tries to match again, (assuming that there is sufficient
room to match).</p>

<p>The name of the &quot;(*SKIP:NAME)&quot; pattern has
special significance. If a &quot;(*MARK:NAME)&quot; was
encountered while matching, then it is that position which
is used as the &quot;skip point&quot;. If no
&quot;(*MARK)&quot; of that name was encountered, then the
&quot;(*SKIP)&quot; operator has no effect. When used
without a name the &quot;skip point&quot; is where the match
point was when executing the (*SKIP) pattern.</p>

<p>Compare the following to the examples in
&quot;(*PRUNE)&quot;, note the string is twice as long:</p>

<p>&rsquo;aaabaaab&rsquo; =~ /a+b?(*SKIP)(?{print
&quot;$&amp;0; $count++})(*FAIL)/; print
&quot;Count=$count0;</p>

<p>outputs</p>

<p>aaab aaab Count=2</p>

<p>Once the aaab at the start of the string has matched,
and the &quot;(*SKIP)&quot; executed, the next starting
point will be where the cursor was when the
&quot;(*SKIP)&quot; was executed.</p>

<p>&quot;(*MARK:NAME)&quot; &quot;(*:NAME)&quot;
&quot;(*MARK:NAME)&quot; &quot;(*:NAME)&quot; This
zero-width pattern can be used to mark the point reached in
a string when a certain part of the pattern has been
successfully matched. This mark may be given a name. A later
&quot;(*SKIP)&quot; pattern will then skip forward to that
point if backtracked into on failure. Any number of
&quot;(*MARK)&quot; patterns are allowed, and the NAME
portion is optional and may be duplicated.</p>

<p>In addition to interacting with the &quot;(*SKIP)&quot;
pattern, &quot;(*MARK:NAME)&quot; can be used to
&quot;label&quot; a pattern branch, so that after matching,
the program can determine which branches of the pattern were
involved in the match.</p>

<p>When a match is successful, the $REGMARK variable will
be set to the name of the most recently executed
&quot;(*MARK:NAME)&quot; that was involved in the match.</p>

<p>This can be used to determine which branch of a pattern
was matched without using a separate capture buffer for each
branch, which in turn can result in a performance
improvement, as perl cannot optimize
&quot;/(?:(x)|(y)|(z))/&quot; as efficiently as something
like &quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;.</p>

<p>When a match has failed, and unless another verb has
been involved in failing the match and has provided its own
name to use, the $REGERROR variable will be set to the name
of the most recently executed &quot;(*MARK:NAME)&quot;.</p>

<p>See &quot;(*SKIP)&quot; for more details.</p>

<p>As a shortcut &quot;(*MARK:NAME)&quot; can be written
&quot;(*:NAME)&quot;.</p>

<p>&quot;(*THEN)&quot; &quot;(*THEN:NAME)&quot; This is
similar to the &quot;cut group&quot; operator &quot;::&quot;
from Perl 6. Like &quot;(*PRUNE)&quot;, this verb always
matches, and when backtracked into on failure, it causes the
regex engine to try the next alternation in the innermost
enclosing group (capturing or otherwise).</p>

<p>Its name comes from the observation that this operation
combined with the alternation operator (&quot;|&quot;) can
be used to create what is essentially a pattern-based
if/then/else block:</p>

<p>( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN)
BAZ )</p>

<p>Note that if this operator is used and NOT inside of an
alternation then it acts exactly like the
&quot;(*PRUNE)&quot; operator.</p>

<p>/ A (*PRUNE) B /</p>

<p>is the same as</p>

<p>/ A (*THEN) B /</p>

<p>but</p>

<p>/ ( A (*THEN) B | C (*THEN) D ) /</p>

<p>is not the same as</p>

<p>/ ( A (*PRUNE) B | C (*PRUNE) D ) /</p>

<p>as after matching the A but failing on the B the
&quot;(*THEN)&quot; verb will backtrack and try C; but the
&quot;(*PRUNE)&quot; verb will simply fail.</p>

<p>&quot;(*COMMIT)&quot; This is the Perl 6 &quot;commit
pattern&quot; &quot;&lt;commit&gt;&quot; or &quot;:::&quot;.
Its a zero-width pattern similar to &quot;(*SKIP)&quot;,
except that when backtracked into on failure it causes the
match to fail outright. No further attempts to find a valid
match by advancing the start pointer will occur again. For
example,</p>

<p>&rsquo;aaabaaab&rsquo; =~ /a+b?(*COMMIT)(?{print
&quot;$&amp;0; $count++})(*FAIL)/; print
&quot;Count=$count0;</p>

<p>outputs</p>

<p>aaab Count=1</p>

<p>In other words, once the &quot;(*COMMIT)&quot; has been
entered, and if the pattern does not match, the regex engine
will not try any further matching on the rest of the
string.</p>

<p>Verbs without an argument &quot;(*FAIL)&quot;
&quot;(*F)&quot; This pattern matches nothing and always
fails. It can be used to force the engine to backtrack. It
is equivalent to &quot;(?!)&quot;, but easier to read. In
fact, &quot;(?!)&quot; gets optimised into
&quot;(*FAIL)&quot; internally.</p>

<p>It is probably useful only when combined with
&quot;(?{})&quot; or &quot;(??{})&quot;.</p>

<p>&quot;(*ACCEPT)&quot; WARNING: This feature is highly
experimental. It is not recommended for production code.</p>

<p>This pattern matches nothing and causes the end of
successful matching at the point at which the
&quot;(*ACCEPT)&quot; pattern was encountered, regardless of
whether there is actually more to match in the string. When
inside of a nested pattern, such as recursion, or in a
subpattern dynamically generated via &quot;(??{})&quot;,
only the innermost pattern is ended immediately.</p>

<p>If the &quot;(*ACCEPT)&quot; is inside of capturing
buffers then the buffers are marked as ended at the point at
which the &quot;(*ACCEPT)&quot; was encountered. For
instance:</p>

<p>&rsquo;AB&rsquo; =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;</p>

<p>will match, and $1 will be &quot;AB&quot; and $2 will be
&quot;B&quot;, $3 will not be set. If another branch in the
inner parentheses were matched, such as in the string ACDE,
then the &quot;D&quot; and &quot;E&quot; would have to be
matched as well.</p>

<p>Backtracking NOTE: This section presents an abstract
approximation of regular expression behavior. For a more
rigorous (and complicated) view of the rules involved in
selecting a match among possible alternatives, see
&quot;Combining RE Pieces&quot;.</p>

<p>A fundamental feature of regular expression matching
involves the notion called backtracking, which is currently
used (when needed) by all regular non-possessive expression
quantifiers, namely &quot;*&quot;, &quot;*?&quot;,
&quot;+&quot;, &quot;+?&quot;, &quot;{n,m}&quot;, and
&quot;{n,m}?&quot;. Backtracking is often optimized
internally, but the general principle outlined here is
valid.</p>

<p>For a regular expression to match, the entire regular
expression must match, not just part of it. So if the
beginning of a pattern containing a quantifier succeeds in a
way that causes later parts in the pattern to fail, the
matching engine backs up and recalculates the beginning
part--thats why its called backtracking.</p>

<p>Here is an example of backtracking: Lets say you want to
find the word following &quot;foo&quot; in the string
&quot;Food is on the foo table.&quot;:</p>

<p>$_ = &quot;Food is on the foo table.&quot;; f o if ( /o
<big><big><big><big>8</big></big></big></big> <sup>)
<big><big><big><big>print &quot;$2 follows $1.0;
}</big></big></big></big></sup></p>

<p><big><big><big><big>When the match runs, the first part
of the regular expression (&quot; e h t f o g n i n n i g e
b e h t t a t h g i r h c t a m e l b i s s o p a s d n i f
) &quot; ) o o f string, and loads up $1 with
&quot;Foo&quot;. However, as soon as the matching engine
sees that there s no whitespace following the
&quot;Foo&quot; that it had saved in $1, it realizes its
mistake and starts over again one character after where it
had the tentative match. This time it goes all the way until
the next occurrence of &quot;foo&quot;. The complete regular
expression matches this time, and you get the expected
output of &quot;table follows
foo.&quot;</big></big></big></big></p>

<p><big><big><big><big>Sometimes minimal matching can help
a lot. Imagine youd like to match everything between
&quot;foo&quot; and &quot;bar&quot;. Initially, you write
something like this:</big></big></big></big></p>

<p><big><big><big><big>$_ = &quot;The food is under the bar
in the barn.&quot;; if ( /foo(.*)bar/ ) { print &quot;got
&lt;$1&gt;0; }</big></big></big></big></p>

<p><big><big><big><big>Which perhaps unexpectedly
yields:</big></big></big></big></p>

<p><big><big><big><big>got &lt;d is under the bar in the
&gt;</big></big></big></big></p>

<p><big><big><big><big>That s because &quot;.*&quot; was
greedy, so you get everything between the _first
&quot;foo&quot; and the _last &quot;bar&quot;. Here it s
more effective to use minimal matching to make sure you get
the text between a &quot;foo&quot; and the first
&quot;bar&quot; thereafter.</big></big></big></big></p>

<p><big><big><big><big>if ( /foo(.*?)bar/ ) { print
&quot;got &lt;$1&gt;0 } got &lt;d is under the
&gt;</big></big></big></big></p>

<p><big><big><big><big>Here s another example. Lets say you
d like to match a number at the end of a string, and you
also want to keep the preceding part of the match. So you
write this:</big></big></big></big></p>

<p><big><big><big><big>$_ = &quot;I have 2 numbers:
53147&quot;; if ( /(.*)( *)/ ) {# Wrong! print
&quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.0;
}</big></big></big></big></p>

<p><big><big><big><big>That won t work at all, because
&quot;.*&quot; was greedy and gobbled up the whole string.
As &quot; *&quot; canmatch on an empty string the complete
regular expression matched
successfully.</big></big></big></big></p>

<p><big><big><big><big>Beginning is &lt;I have 2 numbers:
53147&gt;, number is &lt;&gt;.</big></big></big></big></p>

<p><big><big><big><big>Here are some variants, most of
which dont work:</big></big></big></big></p>

<p><big><big><big><big>$_ = &quot;I have 2 numbers:
53147&quot;; @pats = qw{ (.*)( *)(.*)( +)(.*?)( *)(.*?)(
+)(.*)( +)$(.*?)( +)$(.*) $ ) + (.*$
};</big></big></big></big></p>

<p><big><big><big><big>for $pat (@pats) { printf
&quot;%-12s &quot;, $pat; if ( /$pat/ ) { print
&quot;&lt;$1&gt; &lt;$2&gt;0; } else { print &quot;FAIL0; }
}</big></big></big></big></p>

<p><big><big><big><big>That will print
out:</big></big></big></big></p>

<p><big><big><big><big>(.*)( *) &lt;I have 2numbers:
53147&gt; &lt;&gt; (.*)( +) &lt;I have 2numbers: 5314&gt;
&lt;7&gt; (.*?)( *) &lt;&gt; &lt;&gt;(.*?)( +) &lt;I have
&gt;&lt;2&gt; (.*)( +)$ &lt;I have 2numbers: 5314&gt;
&lt;7&gt; (.*?)( +)$ &lt;I have 2numbers: &gt; &lt;53147&gt;
(.*) &gt; 7 4 1 3 5 &lt; &gt; : s r e b m u n 2 e v a h I
&lt; $ ) + (.*$ &lt;I have 2 numbers: &gt;
&lt;53147&gt;</big></big></big></big></p>

<p><big><big><big><big>As you see, this can be a bit
tricky. It s important to realize that a regular expression
is merely a set of assertions that gives a definition of
success. There may be 0, 1, or several different ways that
the definition might succeed against a particular string.
And if there are multiple ways it might succeed, you need to
understand backtracking to know which variety of success you
will achieve.</big></big></big></big></p>

<p><big><big><big><big>When using look-ahead assertions and
negations, this can all get even trickier. Imagine you d
like to find a sequence of non-digits not followed by
&quot;123&quot;. You might try to write that
as</big></big></big></big></p>

<p><big><big><big><big>$_ = &quot;ABC123&quot;; if ( /^
print &quot;Yup, no 123 in $_0;
}</big></big></big></big></p>

<p><big><big><big><big>But that isn t going to match; at
least, not the way you re hoping. It claims that there is no
123 in the string. Here s a clearer picture of why that
pattern matches, contrary to popular
expectations:</big></big></big></big></p>

<p><big><big><big><big>$x = &rsquo;ABC123&rsquo;; $y =
&rsquo;ABC445&rsquo;;</big></big></big></big></p>

<p><big><big><big><big>print &quot;1: got $10 if $x =~
/^(ABC)(?!123)/; print &quot;2: got $10 if $y =~
/^(ABC)(?!123)/;</big></big></big></big></p>

<p><big><big><big><big>print &quot;3: got $10 if $x =~ /^(
print &quot;4: got $10 if $y =~ /^( This
prints</big></big></big></big></p>

<p><big><big><big><big>2: got ABC 3: got AB 4: got
ABC</big></big></big></big></p>

<p><big><big><big><big>You might have expected test 3 to
fail because it seems to a more general purpose version of
test 1. The important difference between them is that test 3
contains a quantifier (&quot; backtracking, whereas test 1
will not. What s happening is that youve asked &quot;Is it
true that at the start of $x, following 0 or more non-
digits, you have something that s not 123?&quot; If the
pattern matcher had let &quot;
fail.</big></big></big></big></p>

<p><big><big><big><big>The search engine will initially
match &quot; try to match &quot;(?!123&quot; with
&quot;123&quot;, which fails. But because a quantifier
(&quot; engine can backtrack and retry the match differently
in the hope of matching the complete regular
expression.</big></big></big></big></p>

<p><big><big><big><big>The pattern really, really wants to
succeed, so it uses the standard pattern back-off-and-retry
and lets &quot; time. Now there s indeed something following
&quot;AB&quot; that is not &quot;123&quot;. It s
&quot;C123&quot;, which
suffices.</big></big></big></big></p>

<p><big><big><big><big>We can deal with this by using both
an assertion and a negation. Well say that the first part in
$1 must be followed both by a digit and by something that s
not &quot;123&quot;. Remember that the look-aheads are zero-
width expressions--they only look, but don t consume any of
the string in their match. So rewriting this way produces
what youd expect; that is, case 5 will fail, but case 6
succeeds:</big></big></big></big></p>

<p><big><big><big><big>print &quot;5: got $10 if $x =~ /^(
print &quot;6: got $10 if $y =~ /^( 6: got
ABC</big></big></big></big></p>

<p><big><big><big><big>In other words, the two zero-width
assertions next to each other work as though they re ANDed
together, just as you d use any built-in assertions:
&quot;/^$/&quot; matches only if you re at the beginning of
the line AND the end of the line simultaneously. The deeper
underlying truth is that juxtaposition in regular
expressions always means AND, except when you write an
explicit OR using the vertical bar. &quot;/ab/&quot; means
match &quot;a&quot; AND (then) match &quot;b&quot;, although
the attempted matches are made at different positions
because &quot;a&quot; is not a zero-width assertion, but a
one-width assertion.</big></big></big></big></p>

<p><big><big><big><big>WARNING: Particularly complicated
regular expressions can take exponential time to solve
because of the immense number of possible ways they can use
backtracking to try for a match. For example, without
internal optimizations done by the regular expression
engine, this will take a painfully long time to
run:</big></big></big></big></p>

<p><big><big><big><big>&rsquo;aaaaaaaaaaaa&rsquo; =~
/((a{0,5}){0,5})*[c]/</big></big></big></big></p>

<p><big><big><big><big>And if you used &quot;*&quot; s in
the internal groups instead of limiting them to 0 through 5
matches, then it would take forever--or until you ran out of
stack space. Moreover, these internal optimizations are not
always applicable. For example, if you put &quot;{0,5}&quot;
instead of &quot;*&quot; on the external group, no current
optimization is applicable, and the match takes a long time
to finish.</big></big></big></big></p>

<p><big><big><big><big>A powerful tool for optimizing such
beasts is what is known as an &quot;independent group&quot;,
which does not backtrack (see &quot;(?&gt;pattern)&quot;).
Note also that zero-length look-ahead/look-behind assertions
will not backtrack to make the tail match, since they are in
&quot;logical&quot; context: only whether they match is
considered relevant. For an example where side-effects of
look-ahead _might have influenced the following match, see
&quot;(?&gt;pattern)&quot;.</big></big></big></big></p>

<p><big><big><big><big>Version 8 Regular Expressions In
case you re not familiar with the &quot;regular&quot;
Version 8 regex routines, here are the pattern-matching
rules not described above.</big></big></big></big></p>

<p><big><big><big><big>Any single character matches itself,
unless it is a metacharacter with a special meaning
described here or above. You can cause characters that
normally function as metacharacters to be interpreted
literally by prefixing them with a &quot; &quot;\&quot;
matches a &quot; character used as the pattern
delimiter.</big></big></big></big></p>

<p><big><big><big><big>A series of characters matches that
series of characters in the target string, so the pattern
&quot;blurfl&quot; would match &quot;blurfl&quot; in the
target string.</big></big></big></big></p>

<p><big><big><big><big>You can specify a character class,
by enclosing a list of characters in &quot;[]&quot;, which
will match any character from the list. If the first
character after the &quot;[&quot; is &quot;^&quot;, the
class matches any character not in the list. Within a list,
the &quot;-&quot; character specifies a range, so that
&quot;a-z&quot; represents all characters between
&quot;a&quot; and &quot;z&quot;, inclusive. If you want
either &quot;-&quot; or &quot;]&quot; itself to be a member
of a class, put it at the start of the list (possibly after
a &quot;^&quot;), or escape it with a backslash.
&quot;-&quot; is also taken literally when it is at the end
of the list, just before the closing &quot;]&quot;. (The
following all specify the same class of three characters:
&quot;[-az]&quot;, &quot;[az-]&quot;, and
&quot;[a&minus;z]&quot;. All are different from
&quot;[a-z]&quot;, which specifies a class containing
twenty-six characters, even on EBCDIC-based character sets.)
Also, if you try to use the character classes
&quot;96W&quot;, &quot; &quot; &quot; &quot;, or
&quot;endpoints of a range, the &quot;-&quot; is understood
literally.</big></big></big></big></p>

<p><big><big><big><big>Note also that the whole range idea
is rather unportable between character sets--and even within
character sets they may cause results you probably didn t
expect. A sound principle is to use only ranges that begin
from and end at either alphabetics of equal case ([a-e],
[A-E]), or digits ([0-9]). Anything else is unsafe. If in
doubt, spell out the character sets in
full.</big></big></big></big></p>

<p><big><big><big><big>Characters may be specified using a
metacharacter syntax much like that used in C: &quot;0
matches a newline, &quot;&quot; a tab, &quot; &quot; a
carriage return, &quot; a form feed, etc. More generally,
n_nn, where _nnn is a string of octal digits, matches the
character whose coded character set value is nnn. Similarly,
n_n, where _nn are hexadecimal digits, matches the character
whose numeric value is _nn. The expression character
control-_ x. Finally, the &quot;.&quot; metacharacter
matches any character except &quot;0 (unless you use
&quot;/s&quot;).</big></big></big></big></p>

<p><big><big><big><big>You can specify a series of
alternatives for a pattern using &quot;|&quot; to separate
them, so that &quot;fee|fie|foe&quot; will match any of
&quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the
target string (as would &quot;f(e|i|o)e&quot;). The first
alternative includes everything from the last pattern
delimiter (&quot;(&quot;, &quot;[&quot;, or the beginning of
the pattern) up to the first &quot;|&quot;, and the last
alternative contains everything from the last &quot;|&quot;
to the next pattern delimiter. Thats why its common practice
to include alternatives in parentheses: to minimize
confusion about where they start and
end.</big></big></big></big></p>

<p><big><big><big><big>Alternatives are tried from left to
right, so the first alternative found for which the entire
expression matches, is the one that is chosen. This means
that alternatives are not necessarily greedy. For example:
when matching &quot;foo|foot&quot; against
&quot;barefoot&quot;, only the &quot;foo&quot; part will
match, as that is the first alternative tried, and it
successfully matches the target string. (This might not seem
important, but it is important when you are capturing
matched text using parentheses.)</big></big></big></big></p>

<p><big><big><big><big>Also remember that &quot;|&quot; is
interpreted as a literal within square brackets, so if you
write &quot;[fee|fie|foe]&quot; you re really only matching
&quot;[feio|]&quot;.</big></big></big></big></p>

<p><big><big><big><big>Within a pattern, you may designate
subpatterns for later reference by enclosing them in
parentheses, and you may refer back to the _nth subpattern
later in the pattern using the metacharacter n. Subpatterns
are numbered based on the left to right order of their
opening parenthesis. A backreference matches whatever
actually matched the subpattern in the string being
examined, not the rules for that subpattern. Therefore,
&quot;(0|0x) **&quot; will match &quot;0x12340x4321&quot;,
but not &quot;0x1234 01234&quot;, because subpattern 1
matched &quot;0x&quot;, even though the rule
&quot;0|0x&quot; could potentially match the leading 0 in
the second number.</big></big></big></big></p>

<p><big><big><big><big>Warning on1 Instead of $1 Some
people get too used to writing things
like:</big></big></big></big></p>

<p><big><big><big><big>$pattern =~
s/(W)/\1/g;</big></big></big></big></p>

<p><big><big><big><big>This is grandfathered for the RHS of
a substitute to avoid shocking the sed addicts, but it s a
dirty habit to get into. That s because in PerlThink, the
righthand side of an &quot;s///&quot; is a double-quoted
string. &quot;1&quot; in the usual double-quoted string
means a control-A. The customary Unix meaning of
&quot;1&quot; is kludged in for &quot;s///&quot;. However,
if you get into the habit of doing that, you get yourself
into trouble if you then add an &quot;/e&quot;
modifier.</big></big></big></big></p>

<p><big><big><big><big>s/( +)/ 1 + 1 /eg;# causes warning
under -w</big></big></big></big></p>

<p><big><big><big><big>Or if you try to
do</big></big></big></big></p>

<p><big><big><big><big>s/(
+)/1000/;</big></big></big></big></p>

<p><big><big><big><big>You can t disambiguate that by
saying &quot;1}000&quot;, whereas you can fix it with
&quot;${1}000&quot;. The operation of interpolation should
not be confused with the operation of matching a
backreference. Certainly they mean two different things on
the left side of the
&quot;s///&quot;.</big></big></big></big></p>

<p><big><big><big><big>Repeated Patterns Matching a
Zero-length Substring WARNING: Difficult material (and
prose) ahead. This section needs a
rewrite.</big></big></big></big></p>

<p><big><big><big><big>Regular expressions provide a terse
and powerful programming language. As with most other power
tools, power comes together with the ability to wreak
havoc.</big></big></big></big></p>

<p><big><big><big><big>A common abuse of this power stems
from the ability to make infinite loops using regular
expressions, with something as innocuous
as:</big></big></big></big></p>

<p><big><big><big><big>&rsquo;foo&rsquo; =~ m{ ( o? )*
}x;</big></big></big></big></p>

<p><big><big><big><big>The &quot;o?&quot; matches at the
beginning of &rsquo;foo&rsquo;, and since the position in
the string is not moved by the match, &quot;o?&quot; would
match again and again because of the &quot;*&quot;
quantifier. Another common way to create a similar cycle is
with the looping modifier
&quot;//g&quot;:</big></big></big></big></p>

<p><big><big><big><big>@matches = ( &rsquo;foo&rsquo; =~ m{
o? }xg );</big></big></big></big></p>

<p><big><big><big><big>or</big></big></big></big></p>

<p><big><big><big><big>print &quot;match: &lt;$&amp;&gt;0
while &rsquo;foo&rsquo; =~ m{ o?
}xg;</big></big></big></big></p>

<p><big><big><big><big>or the loop implied by
split().</big></big></big></big></p>

<p><big><big><big><big>However, long experience has shown
that many programming tasks may be significantly simplified
by using repeated subexpressions that may match zero-length
substrings. Here s a simple example
being:</big></big></big></big></p>

<p><big><big><big><big>@chars = split //, $string; # // is
not magic in split ($whitewashed = $string) =~ s/()/ /g; #
parens avoid magic s// /</big></big></big></big></p>

<p><big><big><big><big>Thus Perl allows such constructs, by
_forcefully breaking the infinite loop. The rules for this
are different for lower-level loops given by the greedy
quantifiers &quot;*+{}&quot;, and for higher-level ones like
the &quot;/g&quot; modifier or _split()
operator.</big></big></big></big></p>

<p><big><big><big><big>The lower-level loops are
interrupted (that is, the loop is broken) when Perl detects
that a repeated expression matched a zero-length substring.
Thus</big></big></big></big></p>

<p><big><big><big><big>m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH
)* }x;</big></big></big></big></p>

<p><big><big><big><big>is made equivalent
to</big></big></big></big></p>

<p><big><big><big><big>m{ (?: NON_ZERO_LENGTH )* | (?:
ZERO_LENGTH )? }x;</big></big></big></big></p>

<p><big><big><big><big>The higher level-loops preserve an
additional state between iterations: whether the last match
was zero-length. To break the loop, the following match
after a zero-length match is prohibited to have a length of
zero. This prohibition interacts with backtracking (see
&quot;Backtracking&quot;), and so the second best match is
chosen if the _best match is of zero
length.</big></big></big></big></p>

<p><big><big><big><big>For
example:</big></big></big></big></p>

<p><big><big><big><big>$_ = &rsquo;bar&rsquo;;
s/0/&lt;$&amp;&gt;/g;</big></big></big></big></p>

<p><big><big><big><big>results in
&quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;.
At each position of the string the best match given by
non-greedy &quot;??&quot; is the zero-length match, and the
second best match is what is matched by &quot;1296 alternate
with one-character-long matches.</big></big></big></big></p>

<p><big><big><big><big>Similarly, for repeated
&quot;m/()/g&quot; the second-best match is the match at the
position one notch further in the
string.</big></big></big></big></p>

<p><big><big><big><big>The additional state of being
_matched with zero-length is associated with the matched
string, and is reset by each assignment to pos().
Zero-length matches at the end of the previous match are
ignored during
&quot;split&quot;.</big></big></big></big></p>

<p><big><big><big><big>Combining RE Pieces Each of the
elementary pieces of regular expressions which were
described before (such as &quot;ab&quot; or &quot;) could
match at mostat theonsubstring given position of the input
string. However, in a typical regular expression these
elementary pieces are combined into more complicated
patterns using combining operators &quot;ST&quot;,
&quot;S|T&quot;, &quot;S*&quot; etc (in these examples
&quot;S&quot; and &quot;T&quot; are regular
subexpressions).</big></big></big></big></p>

<p><big><big><big><big>Such combinations can include
alternatives, leading to a problem of choice: if we match a
regular expression &quot;a|ab&quot; against &quot;abc&quot;,
will it match substring &quot;a&quot; or &quot;ab&quot;? One
way to describe which substring is actually matched is the
concept of backtracking (see &quot;Backtracking&quot;).
However, this description is too low-level and makes you
think in terms of a particular
implementation.</big></big></big></big></p>

<p><big><big><big><big>Another description starts with
notions of &quot;better&quot;/&quot;worse&quot;. All the
substrings which may be matched by the given regular
expression can be sorted from the &quot;best&quot; match to
the &quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen. This substitutes the question of
&quot;what is chosen?&quot; by the question of &quot;which
matches are better, and which are
worse?&quot;.</big></big></big></big></p>

<p><big><big><big><big>Again, for elementary pieces there
is no such question, since at most one match at a given
position is possible. This section describes the notion of
better/worse for combining operators. In the description
below &quot;S&quot; and &quot;T&quot; are regular
subexpressions.</big></big></big></big></p>

<p><big><big><big><big>&quot;ST&quot; Consider two possible
matches, &quot;AB&quot; and &quot;A&rsquo;B&rsquo;&quot;,
&quot;A&quot; and &quot;A&rsquo;&quot; are substrings which
can be matched by &quot;S&quot;, &quot;B&quot; and
&quot;B&rsquo;&quot; are substrings which can be matched by
&quot;T&quot;.</big></big></big></big></p>

<p><big><big><big><big>If &quot;A&quot; is better match for
&quot;S&quot; than &quot;A&rsquo;&quot;, &quot;AB&quot; is a
better match than
&quot;A&rsquo;B&rsquo;&quot;.</big></big></big></big></p>

<p><big><big><big><big>If &quot;A&quot; and
&quot;A&rsquo;&quot; coincide: &quot;AB&quot; is a better
match than &quot;AB&rsquo;&quot; if &quot;B&quot; is better
match for &quot;T&quot; than
&quot;B&rsquo;&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;S|T&quot; When &quot;S&quot;
can match, it is a better match than when only &quot;T&quot;
can match.</big></big></big></big></p>

<p><big><big><big><big>Ordering of two matches for
&quot;S&quot; is the same as for &quot;S&quot;. Similar for
two matches for &quot;T&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;S{REPEAT_COUNT}&quot; Matches
as &quot;SSS...S&quot; (repeated as many times as
necessary).</big></big></big></big></p>

<p><big><big><big><big>&quot;S{min,max}&quot; Matches as
&quot;S{max}|S{max-1}|...|S{min+1}|S{min}&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;S{min,max}?&quot; Matches as
&quot;S{min}|S{min+1}|...|S{max-1}|S{max}&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;S?&quot;, &quot;S*&quot;,
&quot;S+&quot; Same as &quot;S{0,1}&quot;,
&quot;S{0,BIG_NUMBER}&quot;, &quot;S{1,BIG_NUMBER}&quot;
respectively.</big></big></big></big></p>

<p><big><big><big><big>&quot;S??&quot;, &quot;S*?&quot;,
&quot;S+?&quot; Same as &quot;S{0,1}?&quot;,
&quot;S{0,BIG_NUMBER}?&quot;, &quot;S{1,BIG_NUMBER}?&quot;
respectively.</big></big></big></big></p>

<p><big><big><big><big>&quot;(?&gt;S)&quot; Matches the
best match for &quot;S&quot; and only
that.</big></big></big></big></p>

<p><big><big><big><big>&quot;(?=S)&quot;,
&quot;(?&lt;=S)&quot; Only the best match for &quot;S&quot;
is considered. (This is important only if &quot;S&quot; has
capturing parentheses, and backreferences are used somewhere
else in the whole regular
expression.)</big></big></big></big></p>

<p><big><big><big><big>&quot;(?!S)&quot;,
&quot;(?&lt;!S)&quot; For this grouping operator there is no
need to describe the ordering, since only whether or not
&quot;S&quot; can match is
important.</big></big></big></big></p>

<p><big><big><big><big>&quot;(??{ EXPR })&quot;,
&quot;(?PARNO)&quot; The ordering is the same as for the
regular expression which is the result of EXPR, or the
pattern contained by capture buffer
PARNO.</big></big></big></big></p>


<p><big><big><big><big>&quot;(?(condition)yes-pattern|no-pattern)&quot;
Recall that which of &quot;yes-pattern&quot; or
&quot;no-pattern&quot; actually matches is already
determined. The ordering of the matches is the same as for
the chosen subexpression.</big></big></big></big></p>

<p><big><big><big><big>The above recipes describe the
ordering of matches at a given position. One more rule is
needed to understand how a match is determined for the whole
regular expression: a match at an earlier position is always
better than a match at a later
position.</big></big></big></big></p>

<p><big><big><big><big>Creating Custom RE Engines
Overloaded constants (see overload) provide a simple way to
extend the functionality of the RE
engine.</big></big></big></big></p>

<p><big><big><big><big>Suppose that we want to enable a new
RE escape-sequence &quot; which matches at a boundary
between whitespace characters and non-whitespace characters.
Note that &quot;(?=(?&lt;!|(?!(?&lt;=&quot; matches exactly
at these positions, so we want to have each &quot; in the
place of the more complicated version. We can create a
module &quot;customre&quot; to do
this:</big></big></big></big></p>

<p><big><big><big><big>package customre; use
overload;</big></big></big></big></p>

<p><big><big><big><big>sub import { shift; die &quot;No
argument to customre::import allowed&quot; if @_;
overload::constant &rsquo;qr&rsquo; =&gt; convert;
}</big></big></big></big></p>

<p><big><big><big><big>sub invalid { die &quot;/$_[0]/:
invalid escape
&rsquo;\$_[1]&rsquo;&quot;}</big></big></big></big></p>

<p><big><big><big><big># We must also take care of not
escaping the legitimate \Y| # sequence, hence the presence
of &rsquo;\&rsquo; in the conversion rules. my %rules = (
&rsquo;\&rsquo; =&gt; &rsquo;\\&rsquo;, &rsquo;Y|&rsquo;
=&gt; qr/(?=(?&lt;!|(?!(?&lt;=/ ); sub convert { my $re =
shift; $re =~ s{ \ ( \ | Y . ) } { $rules{$1} or
invalid($re,$1) }sgex; return $re;
}</big></big></big></big></p>

<p><big><big><big><big>Now &quot;use customre&quot; enables
the new escape in constant regular expressions, i.e., those
without any runtime variable interpolations. As documented
in overload, this conversion will work only over literal
parts of regular expressions. For &quot; the variable part
of this regular expression needs to be converted explicitly
(but only if the special meaning of &quot; should be enabled
inside $re):</big></big></big></big></p>

<p><big><big><big><big>use customre; $re = &lt;&gt;; chomp
$re; $re = customre::convert $re;
/</big></big></big></big></p>

<p><big><big><big><big>PCRE/Python Support As of Perl
5.10.0, Perl supports several Python/PCRE specific
extensions to the regex syntax. While Perl programmers are
encouraged to use the Perl specific syntax, the following
are also accepted:</big></big></big></big></p>


<p><big><big><big><big>&quot;(?PE&lt;lt&gt;NAMEE&lt;gt&gt;pattern)&quot;
Define a named capture buffer. Equivalent to
&quot;(?&lt;NAME&gt;pattern)&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;(?P=NAME)&quot; Backreference
to a named capture buffer. Equivalent to
&quot;NAME}&quot;.</big></big></big></big></p>

<p><big><big><big><big>&quot;(?P&gt;NAME)&quot; Subroutine
call to a named capture buffer. Equivalent to
&quot;(?&amp;NAME)&quot;.</big></big></big></big></p>

<p><big><big><big><big>BUGS This document varies from
difficult to understand to completely and utterly opaque.
The wandering prose riddled with jargon is hard to fathom in
several places.</big></big></big></big></p>

<p><big><big><big><big>This document needs a rewrite that
separates the tutorial content from the reference
content.</big></big></big></big></p>

<p><big><big><big><big>SEE ALSO
perlrequick.</big></big></big></big></p>


<p><big><big><big><big>perlretut.</big></big></big></big></p>

<p><big><big><big><big>&quot;Regexp Quote-Like
Operators&quot; in perlop.</big></big></big></big></p>

<p><big><big><big><big>&quot;Gory details of parsing quoted
constructs&quot; in perlop.</big></big></big></big></p>


<p><big><big><big><big>perlfaq6.</big></big></big></big></p>

<p><big><big><big><big>&quot;pos&quot; in
perlfunc.</big></big></big></big></p>


<p><big><big><big><big>perllocale.</big></big></big></big></p>


<p><big><big><big><big>perlebcdic.</big></big></big></big></p>

<p><big><big><big><big>Mastering Regular Expressions by
Jeffrey Friedl, published by OReilly and
Associates.</big></big></big></big></p>

<p><big><big><big><big>perl v5.10.1 2009-02-12
PERLRE(1)</big></big></big></big></p>
<hr>
</body>
</html>
