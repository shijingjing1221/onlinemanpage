<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERF-RECORD(1) perf Manual PERF-RECORD(1)</p>

<p>NAME perf-record - Run a command and record its profile
into perf.data</p>

<p>SYNOPSIS perf record [-e &lt;EVENT&gt; | --event=EVENT]
[-l] [-a] &lt;command&gt; perf record [-e &lt;EVENT&gt; |
--event=EVENT] [-l] [-a] &lt;command&gt;
[&lt;options&gt;]</p>

<p>DESCRIPTION This command runs a command and gathers a
performance counter profile from it, into perf.data -
without displaying anything.</p>

<p>This file can then be inspected later on, using perf
report.</p>

<p>OPTIONS &lt;command&gt;... Any command you can specify
in a shell.</p>

<p>-e, --event= Select the PMU event. Selection can be:</p>

<p>&middot; a symbolic event name (use perf list to list
all events)</p>

<p>&middot; a raw PMU event (eventsel+umask) in the form of
rNNN where NNN is a hexadecimal event descriptor.</p>

<p>&middot; a symbolically formed PMU event like
pmu/param1=0x3,param2/ where param1, param2, etc are defined
as formats for the PMU in
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/*.</p>

<p>&middot; a symbolically formed event like
pmu/config=M,config1=N,config3=K/</p>

<p>where M, N, K are numbers (in decimal, hex, octal
format). Acceptable values for each of &acute;config&acute;,
&acute;config1&acute; and &acute;config2&acute; are defined
by corresponding entries in
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/* param1
and param2 are defined as formats for the PMU in:
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/*</p>

<p>&middot; a group of events surrounded by a pair of brace
(&quot;{event1,event2,...}&quot;). Each event is separated
by commas and the group should be quoted to prevent the
shell interpretation. You also need to use --group on
&quot;perf report&quot; to view group events together.</p>

<p>--filter=&lt;filter&gt; Event filter.</p>

<p>-a, --all-cpus System-wide collection from all CPUs.</p>

<p>-p, --pid= Record events on existing process ID (comma
separated list).</p>

<p>-t, --tid= Record events on existing thread ID (comma
separated list). This option also disables inheritance by
default. Enable it by adding --inherit.</p>

<p>-u, --uid= Record events in threads owned by uid. Name
or number.</p>

<p>-r, --realtime= Collect data with this RT SCHED_FIFO
priority.</p>

<p>--no-buffering Collect data without buffering.</p>

<p>-c, --count= Event period to sample.</p>

<p>-o, --output= Output file name.</p>

<p>-i, --no-inherit Child tasks do not inherit
counters.</p>

<p>-F, --freq= Profile at this frequency.</p>

<p>-m, --mmap-pages= Number of mmap data pages (must be a
power of two) or size specification with appended unit
character - B/K/M/G. The size is rounded up to have nearest
pages power of two value.</p>

<p>--group Put all events in a single event group. This
precedes the --event option and remains only for backward
compatibility. See --event.</p>

<p>-g Enables call-graph (stack chain/backtrace)
recording.</p>

<p>--call-graph Setup and enable call-graph (stack
chain/backtrace) recording, implies -g.</p>

<p>Allows specifying &quot;fp&quot; (frame pointer) or
&quot;dwarf&quot; (DWARF&acute;s CFI - Call Frame
Information) or &quot;lbr&quot; (Hardware Last Branch Record
facility) as the method to collect the information used to
show the call graphs.</p>

<p>In some systems, where binaries are build with gcc
--fomit-frame-pointer, using the &quot;fp&quot; method will
produce bogus call graphs, using &quot;dwarf&quot;, if
available (perf tools linked to the libunwind library)
should be used instead. Using the &quot;lbr&quot; method
doesn&acute;t require any compiler options. It will produce
call graphs from the hardware LBR registers. The main
limition is that it is only available on new Intel
platforms, such as Haswell. It can only get user call chain.
It doesn&acute;t work with branch stack sampling at the same
time.</p>

<p>-q, --quiet Dont print any message, useful for
scripting.</p>

<p>-v, --verbose Be more verbose (show counter open errors,
etc).</p>

<p>-s, --stat Per thread counts.</p>

<p>-d, --data Sample addresses.</p>

<p>-T, --timestamp Sample timestamps. Use it with perf
report -D to see the timestamps, for instance.</p>

<p>-n, --no-samples Dont sample.</p>

<p>-R, --raw-samples Collect raw sample records from all
opened counters (default for tracepoint counters).</p>

<p>-C, --cpu Collect samples only on the list of CPUs
provided. Multiple CPUs can be provided as a comma-separated
list with no space: 0,1. Ranges of CPUs are specified with
-: 0-2. In per-thread mode with inheritance mode on
(default), samples are captured only when the thread
executes on the designated CPUs. Default is to monitor all
CPUs.</p>

<p>-N, --no-buildid-cache Do not update the buildid cache.
This saves some overhead in situations where the information
in the perf.data file (which includes buildids) is
sufficient.</p>

<p>-G name,..., --cgroup name,... monitor only in the
container (cgroup) called &quot;name&quot;. This option is
available only in per-cpu mode. The cgroup filesystem must
be mounted. All threads belonging to container
&quot;name&quot; are monitored when they run on the
monitored CPUs. Multiple cgroups can be provided. Each
cgroup is applied to the corresponding event, i.e., first
cgroup to first event, second cgroup to second event and so
on. It is possible to provide an empty cgroup (monitor all
the time) using, e.g., -G foo,,bar. Cgroups must have
corresponding events, i.e., they always refer to events
defined earlier on the command line.</p>

<p>-b, --branch-any Enable taken branch stack sampling. Any
type of taken branch may be sampled. This is a shortcut for
--branch-filter any. See --branch-filter for more infos.</p>

<p>-j, --branch-filter Enable taken branch stack sampling.
Each sample captures a series of consecutive taken branches.
The number of branches captured with each sample depends on
the underlying hardware, the type of branches of interest,
and the executed code. It is possible to select the types of
branches captured by enabling filters. The following filters
are defined:</p>

<p>&middot; any: any type of branches</p>

<p>&middot; any_call: any function call or system call</p>

<p>&middot; any_ret: any function return or system call
return</p>

<p>&middot; ind_call: any indirect branch</p>

<p>&middot; u: only when the branch target is at the user
level</p>

<p>&middot; k: only when the branch target is in the
kernel</p>

<p>&middot; hv: only when the target is at the hypervisor
level</p>

<p>&middot; in_tx: only when the target is in a hardware
transaction</p>

<p>&middot; no_tx: only when the target is not in a
hardware transaction</p>

<p>&middot; abort_tx: only when the target is a hardware
transaction abort The option requires at least one branch
type among any, any_call, any_ret, ind_call. The privilege
levels may be omitted, in which case, the privilege levels
of the associated event are applied to the branch filter.
Both kernel (k) and hypervisor (hv) privilege levels are
subject to permissions. When sampling on multiple events,
branch stack sampling is enabled for all the sampling
events. The sampled branch type is the same for all events.
The various filters must be specified as a comma separated
list: --branch-filter any_ret,u,k Note that this feature may
not be available on all processors.</p>

<p>--weight Enable weightened sampling. An additional
weight is recorded per sample and can be displayed with the
weight and local_weight sort keys. This currently works for
TSX abort events and some memory events in precise mode on
modern Intel CPUs.</p>

<p>--transaction Record transaction flags for transaction
related events.</p>

<p>--per-thread Use per-thread mmaps. By default per-cpu
mmaps are created. This option overrides that and uses
per-thread mmaps. A side-effect of that is that inheritance
is automatically disabled. --per-thread is ignored with a
warning if combined with -a or -C options.</p>

<p>-D, --delay= After starting the program, wait msecs
before measuring. This is useful to filter out the startup
phase of the program, which is often very different.</p>

<p>-I, --intr-regs Capture machine state (registers) at
interrupt, i.e., on counter overflows for each sample. List
of captured registers depends on the architecture. This
option is off by default.</p>

<p>--running-time Record running and enabled time for read
events (:S)</p>

<p>SEE ALSO perf-stat(1), perf-list(1)</p>

<p>perf 04/13/2016 PERF-RECORD(1)</p>
<hr>
</body>
</html>
