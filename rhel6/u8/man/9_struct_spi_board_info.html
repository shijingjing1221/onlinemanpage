<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:36:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRUCT SPI_BOARD_INF(9) Serial Peripheral Interface (S
STRUCT SPI_BOARD_INF(9)</p>

<p>NAME struct_spi_board_info - board-specific template for
a SPI device</p>

<p>SYNOPSIS struct spi_board_info { char
modalias[SPI_NAME_SIZE]; const void * platform_data; void *
controller_data; int irq; u32 max_speed_hz; u16 bus_num; u16
chip_select; u8 mode; };</p>

<p>MEMBERS modalias[SPI_NAME_SIZE] Initializes
spi_device.modalias; identifies the driver.</p>

<p>platform_data Initializes spi_device.platform_data; the
particular data stored there is driver-specific.</p>

<p>controller_data Initializes spi_device.controller_data;
some controllers need hints about hardware setup, e.g. for
DMA.</p>

<p>irq Initializes spi_device.irq; depends on how the board
is wired.</p>

<p>max_speed_hz Initializes spi_device.max_speed_hz; based
on limits from the chip datasheet and board-specific signal
quality issues.</p>

<p>bus_num Identifies which spi_master parents the
spi_device; unused by spi_new_device, and otherwise depends
on board wiring.</p>

<p>chip_select Initializes spi_device.chip_select; depends
on how the board is wired.</p>

<p>mode Initializes spi_device.mode; based on the chip
datasheet, board wiring (some devices support both 3WIRE and
standard modes), and possibly presence of an inverter in the
chipselect path.</p>

<p>DESCRIPTION When adding new SPI devices to the device
tree, these structures serve as a partial device template.
They hold information which can&acute;t always be determined
by drivers. Information that probe can establish (such as
the default transfer wordsize) is not included here.</p>

<p>These structures are used in two places. Their primary
role is to be stored in tables of board-specific device
descriptors, which are declared early in board
initialization and then used (much later) to populate a
controller&acute;s device tree after the that
controller&acute;s driver initializes. A secondary (and
atypical) role is as a parameter to spi_new_device call,
which happens after those controller drivers are active in
some dynamic board configuration models.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016 STRUCT
SPI_BOARD_INF(9)</p>
<hr>
</body>
</html>
