<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:48 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLSYN(1) Perl Programmers Reference Guide
PERLSYN(1)</p>

<p>NAME perlsyn - Perl syntax</p>

<p>DESCRIPTION A Perl program consists of a sequence of
declarations and statements which run from the top to the
bottom. Loops, subroutines and other control structures
allow you to jump around within the code.</p>

<p>Perl is a free-form language, you can format and indent
it however you like. Whitespace mostly serves to separate
tokens, unlike languages like Python where it is an
important part of the syntax.</p>

<p>Many of Perl s syntactic elements are optional. Rather
than requiring you to put parentheses around every function
call and declare every variable, you can often leave such
explicit elements off and Perl will figure out what you
meant. This is known as Do What I Mean, abbreviated DWIM. It
allows programmers to be lazy and to code in a style with
which they are comfortable.</p>

<p>Perl borrows syntax and concepts from many languages:
awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English.
Other languages have borrowed syntax from Perl, particularly
its regular expression extensions. So if you have programmed
in another language you will see familiar pieces in Perl.
They often work the same, but see perltrap for information
about how they differ.</p>

<p>Declarations The only things you need to declare in Perl
are report formats and subroutines (and sometimes not even
subroutines). A variable holds the undefined value
(&quot;undef&quot;) until it has been assigned a defined
value, which is anything other than &quot;undef&quot;. When
used as a number, &quot;undef&quot; is treated as 0; when
used as a string, it is treated as the empty string,
&quot;&quot;; and when used as a reference that isn t being
assigned to, it is treated as an error. If you enable
warnings, youll be notified of an uninitialized value
whenever you treat &quot;undef&quot; as a string or a
number. Well, usually. Boolean contexts, such as:</p>

<p>my $a; if ($a) {}</p>

<p>are exempt from warnings (because they care about truth
rather than definedness). Operators such as &quot;++&quot;,
&quot;--&quot;, &quot;+=&quot;, &quot;-=&quot;, and
&quot;.=&quot;, that operate on undefined left values such
as:</p>

<p>my $a; $a++;</p>

<p>are also always exempt from such warnings.</p>

<p>A declaration can be put anywhere a statement can, but
has no effect on the execution of the primary sequence of
statements--declarations all take effect at compile time.
Typically all the declarations are put at the beginning or
the end of the script. However, if youre using
lexically-scoped private variables created with
&quot;my()&quot;, youll have to make sure your format or
subroutine definition is within the same block scope as the
my if you expect to be able to access those private
variables.</p>

<p>Declaring a subroutine allows a subroutine name to be
used as if it were a list operator from that point forward
in the program. You can declare a subroutine without
defining it by saying &quot;sub name&quot;, thus:</p>

<p>sub myname; $me = myname $0 or die &quot;can&rsquo;t get
myname&quot;;</p>

<p>Note that myname() functions as a list operator, not as
a unary operator; so be careful to use &quot;or&quot;
instead of &quot;||&quot; in this case. However, if you were
to declare the subroutine as &quot;sub myname ($)&quot;,
then &quot;myname&quot; would function as a unary operator,
so either &quot;or&quot; or &quot;||&quot; would work.</p>

<p>Subroutines declarations can also be loaded up with the
&quot;require&quot; statement or both loaded and imported
into your namespace with a &quot;use&quot; statement. See
perlmod for details on this.</p>

<p>A statement sequence may contain declarations of
lexically-scoped variables, but apart from declaring a
variable name, the declaration acts like an ordinary
statement, and is elaborated within the sequence of
statements as if it were an ordinary statement. That means
it actually has both compile-time and run-time effects.</p>

<p>Comments Text from a &quot;#&quot; character until the
end of the line is a comment, and is ignored. Exceptions
include &quot;#&quot; inside a string or regular
expression.</p>

<p>Simple Statements The only kind of simple statement is
an expression evaluated for its side effects. Every simple
statement must be terminated with a semicolon, unless it is
the final statement in a block, in which case the semicolon
is optional. (A semicolon is still encouraged if the block
takes up more than one line, because you may eventually add
another line.) Note that there are some operators like
&quot;eval {}&quot; and &quot;do {}&quot; that look like
compound statements, but aren t (theyre just TERMs in an
expression), and thus need an explicit termination if used
as the last item in a statement.</p>

<p>Truth and Falsehood The number 0, the strings
&rsquo;0&rsquo; and &rsquo;&rsquo;, the empty list
&quot;()&quot;, and &quot;undef&quot; are all false in a
boolean context. All other values are true. Negation of a
true value by &quot;!&quot; or &quot;not&quot; returns a
special false value. When evaluated as a string it is
treated as &rsquo;&rsquo;, but as a number, it is treated as
0.</p>

<p>Statement Modifiers Any simple statement may optionally
be followed by a SINGLE modifier, just before the
terminating semicolon (or block ending). The possible
modifiers are:</p>

<p>if EXPR unless EXPR while EXPR until EXPR foreach
LIST</p>

<p>The &quot;EXPR&quot; following the modifier is referred
to as the &quot;condition&quot;. Its truth or falsehood
determines how the modifier will behave.</p>

<p>&quot;if&quot; executes the statement once if and only
if the condition is true. &quot;unless&quot; is the
opposite, it executes the statement unless the condition is
true (i.e., if the condition is false).</p>

<p>print &quot;Basset hounds got long ears&quot; if length
$ear &gt;= 10; go_outside() and play() unless
$is_raining;</p>

<p>The &quot;foreach&quot; modifier is an iterator: it
executes the statement once for each item in the LIST (with
$_ aliased to each item in turn).</p>

<p>print &quot;Hello $_!0 foreach qw(world Dolly
nurse);</p>

<p>&quot;while&quot; repeats the statement while the
condition is true. &quot;until&quot; does the opposite, it
repeats the statement until the condition is true (or while
the condition is false):</p>

<p># Both of these count from 0 to 10. print $i++ while $i
&lt;= 10; print $j++ until $j &gt; 10;</p>

<p>The &quot;while&quot; and &quot;until&quot; modifiers
have the usual &quot;&quot;while&quot; loop&quot; semantics
(conditional evaluated first), except when applied to a
&quot;do&quot;-BLOCK (or to the deprecated
&quot;do&quot;-SUBROUTINE statement), in which case the
block executes once before the conditional is evaluated.
This is so that you can write loops like:</p>

<p>do { $line = &lt;STDIN&gt;; ... } until $line eq
&quot;.0;</p>

<p>See &quot;do&quot; in perlfunc. Note also that the loop
control statements described later will NOT work in this
construct, because modifiers dont take loop labels. Sorry.
You can always put another block inside of it (for
&quot;next&quot;) or around it (for &quot;last&quot;) to do
that sort of thing. For &quot;next&quot;, just double the
braces:</p>

<p>do {{ next if $x == $y; # do something here }} until
$x++ &gt; $z;</p>

<p>For &quot;last&quot;, you have to be more elaborate:</p>

<p>LOOP: { do { last if $x = $y**2; # do something here }
while $x++ &lt;= $z; }</p>

<p>NOTE: The behaviour of a &quot;my&quot; statement
modified with a statement modifier conditional or loop
construct (e.g. &quot;my $x if ...&quot;) is undefined. The
value of the &quot;my&quot; variable may be
&quot;undef&quot;, any previously assigned value, or
possibly anything else. Don t rely on it. Future versions of
perl might do something different from the version of perl
you try it out on. Here be dragons.</p>

<p>Compound Statements In Perl, a sequence of statements
that defines a scope is called a block. Sometimes a block is
delimited by the file containing it (in the case of a
required file, or the program as a whole), and sometimes a
block is delimited by the extent of a string (in the case of
an eval).</p>

<p>But generally, a block is delimited by curly brackets,
also known as braces. We will call this syntactic construct
a BLOCK.</p>

<p>The following compound statements may be used to control
flow:</p>

<p>if (EXPR) BLOCK if (EXPR) BLOCK else BLOCK if (EXPR)
BLOCK elsif (EXPR) BLOCK ... else BLOCK LABEL while (EXPR)
BLOCK LABEL while (EXPR) BLOCK continue BLOCK LABEL until
(EXPR) BLOCK LABEL until (EXPR) BLOCK continue BLOCK LABEL
for (EXPR; EXPR; EXPR) BLOCK LABEL foreach VAR (LIST) BLOCK
LABEL foreach VAR (LIST) BLOCK continue BLOCK LABEL BLOCK
continue BLOCK</p>

<p>Note that, unlike C and Pascal, these are defined in
terms of BLOCKs, not statements. This means that the curly
brackets are required--no dangling statements allowed. If
you want to write conditionals without curly brackets there
are several other ways to do it. The following all do the
same thing:</p>

<p>if (!open(FOO)) { die &quot;Can&rsquo;t open $FOO:
$!&quot;; } die &quot;Can&rsquo;t open $FOO: $!&quot; unless
open(FOO); open(FOO) or die &quot;Can&rsquo;t open $FOO:
$!&quot;; # FOO or bust! open(FOO) ? &rsquo;hi mom&rsquo; :
die &quot;Can&rsquo;t open $FOO: $!&quot;; # a bit exotic,
that last one</p>

<p>The &quot;if&quot; statement is straightforward. Because
BLOCKs are always bounded by curly brackets, there is never
any ambiguity about which &quot;if&quot; an &quot;else&quot;
goes with. If you use &quot;unless&quot; in place of
&quot;if&quot;, the sense of the test is reversed.</p>

<p>The &quot;while&quot; statement executes the block as
long as the expression is true. The &quot;until&quot;
statement executes the block as long as the expression is
false. The LABEL is optional, and if present, consists of an
identifier followed by a colon. The LABEL identifies the
loop for the loop control statements &quot;next&quot;,
&quot;last&quot;, and &quot;redo&quot;. If the LABEL is
omitted, the loop control statement refers to the innermost
enclosing loop. This may include dynamically looking back
your call- stack at run time to find the LABEL. Such
desperate behavior triggers a warning if you use the
&quot;use warnings&quot; pragma or the -w flag.</p>

<p>If there is a &quot;continue&quot; BLOCK, it is always
executed just before the conditional is about to be
evaluated again. Thus it can be used to increment a loop
variable, even when the loop has been continued via the
&quot;next&quot; statement.</p>

<p>Loop Control The &quot;next&quot; command starts the
next iteration of the loop:</p>

<p>LINE: while (&lt;STDIN&gt;) { next LINE if /^#/; #
discard comments ... }</p>

<p>The &quot;last&quot; command immediately exits the loop
in question. The &quot;continue&quot; block, if any, is not
executed:</p>

<p>LINE: while (&lt;STDIN&gt;) { last LINE if /^$/; # exit
when done with header ... }</p>

<p>The &quot;redo&quot; command restarts the loop block
without evaluating the conditional again. The
&quot;continue&quot; block, if any, is not executed. This
command is normally used by programs that want to lie to
themselves about what was just input.</p>

<p>For example, when processing a file like /etc/termcap.
If your input lines might end in backslashes to indicate
continuation, you want to skip ahead and get the next
record.</p>

<p>while (&lt;&gt;) { chomp; if (s/\$//) { $_ .= &lt;&gt;;
redo unless eof(); } # now process $_ }</p>

<p>which is Perl short-hand for the more explicitly written
version:</p>

<p>LINE: while (defined($line = &lt;ARGV&gt;)) {
chomp($line); if ($line =~ s/\$//) { $line .= &lt;ARGV&gt;;
redo LINE unless eof(); # not eof(ARGV)! } # now process
$line }</p>

<p>Note that if there were a &quot;continue&quot; block on
the above code, it would get executed only on lines
discarded by the regex (since redo skips the continue
block). A continue block is often used to reset line
counters or &quot;?pat?&quot; one-time matches:</p>

<p># inspired by :1,$g/fred/s//WILMA/ while (&lt;&gt;) {
?(fred)? &amp;&amp; s//WILMA $1 WILMA/; ?(barney)?
&amp;&amp; s//BETTY $1 BETTY/; ?(homer)? &amp;&amp; s//MARGE
$1 MARGE/; } continue { print &quot;$ARGV $.: $_&quot;;
close ARGV if eof(); # reset $. reset if eof(); # reset
?pat? }</p>

<p>If the word &quot;while&quot; is replaced by the word
&quot;until&quot;, the sense of the test is reversed, but
the conditional is still tested before the first
iteration.</p>

<p>The loop control statements don t work in an
&quot;if&quot; or &quot;unless&quot;, since they arent
loops. You can double the braces to make them such,
though.</p>

<p>if (/pattern/) {{ last if /fred/; next if /barney/; #
same effect as &quot;last&quot;, but doesn&rsquo;t document
as well # do something here }}</p>

<p>This is caused by the fact that a block by itself acts
as a loop that executes once, see &quot;Basic
BLOCKs&quot;.</p>

<p>The form &quot;while/if BLOCK BLOCK&quot;, available in
Perl 4, is no longer available. Replace any occurrence of
&quot;if BLOCK&quot; by &quot;if (do BLOCK)&quot;.</p>

<p>For Loops Perl s C-style &quot;for&quot; loop works like
the corresponding &quot;while&quot; loop; that means that
this:</p>

<p>for ($i = 1; $i &lt; 10; $i++) { ... }</p>

<p>is the same as this:</p>

<p>$i = 1; while ($i &lt; 10) { ... } continue { $i++;
}</p>

<p>There is one minor difference: if variables are declared
with &quot;my&quot; in the initialization section of the
&quot;for&quot;, the lexical scope of those variables is
exactly the &quot;for&quot; loop (the body of the loop and
the control sections).</p>

<p>Besides the normal array index looping, &quot;for&quot;
can lend itself to many other interesting applications.
Heres one that avoids the problem you get into if you
explicitly test for end-of-file on an interactive file
descriptor causing your program to appear to hang.</p>

<p>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT; sub prompt {
print &quot;yes? &quot; if $on_a_tty } for ( prompt();
&lt;STDIN&gt;; prompt() ) { # do something }</p>

<p>Using &quot;readline&quot; (or the operator form,
&quot;&lt;EXPR&gt;&quot;) as the conditional of a
&quot;for&quot; loop is shorthand for the following. This
behaviour is the same as a &quot;while&quot; loop
conditional.</p>

<p>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt()
) { # do something }</p>

<p>Foreach Loops The &quot;foreach&quot; loop iterates over
a normal list value and sets the variable VAR to be each
element of the list in turn. If the variable is preceded
with the keyword &quot;my&quot;, then it is lexically
scoped, and is therefore visible only within the loop.
Otherwise, the variable is implicitly local to the loop and
regains its former value upon exiting the loop. If the
variable was previously declared with &quot;my&quot;, it
uses that variable instead of the global one, but it s still
localized to the loop. This implicit localisation occurs
only in a &quot;foreach&quot; loop.</p>

<p>The &quot;foreach&quot; keyword is actually a synonym
for the &quot;for&quot; keyword, so you can use
&quot;foreach&quot; for readability or &quot;for&quot; for
brevity. (Or because the Bourne shell is more familiar to
you than csh, so writing &quot;for&quot; comes more
naturally.) If VAR is omitted, $_ is set to each value.</p>

<p>If any element of LIST is an lvalue, you can modify it
by modifying VAR inside the loop. Conversely, if any element
of LIST is NOT an lvalue, any attempt to modify that element
will fail. In other words, the &quot;foreach&quot; loop
index variable is an implicit alias for each item in the
list that youre looping over.</p>

<p>If any part of LIST is an array, &quot;foreach&quot;
will get very confused if you add or remove elements within
the loop body, for example with &quot;splice&quot;. So dont
do that.</p>

<p>&quot;foreach&quot; probably wont do what you expect if
VAR is a tied or other special variable. Dont do that
either.</p>

<p>Examples:</p>

<p>for (@ary) { s/foo/bar/ }</p>

<p>for my $elem (@elements) { $elem *= 2; }</p>

<p>for $count (10,9,8,7,6,5,4,3,2,1,&rsquo;BOOM&rsquo;) {
print $count, &quot;0; sleep(1); }</p>

<p>for (1..15) { print &quot;Merry Christmas0; }</p>

<p>foreach $item (split(/:[\0]*/, $ENV{TERMCAP})) { print
&quot;Item: $item0; }</p>

<p>Here s how a C programmer might code up a particular
algorithm in Perl:</p>

<p>for (my $i = 0; $i &lt; @ary1; $i++) { for (my $j = 0;
$j &lt; @ary2; $j++) { if ($ary1[$i] &gt; $ary2[$j]) { last;
# can&rsquo;t go to outer :-( } $ary1[$i] += $ary2[$j]; } #
this is where that last takes me }</p>

<p>Whereas heres how a Perl programmer more comfortable
with the idiom might do it:</p>

<p>OUTER: for my $wid (@ary1) { INNER: for my $jet (@ary2)
{ next OUTER if $wid &gt; $jet; $wid += $jet; } }</p>

<p>See how much easier this is? Its cleaner, safer, and
faster. Its cleaner because its less noisy. Its safer
because if code gets added between the inner and outer loops
later on, the new code wont be accidentally executed. The
&quot;next&quot; explicitly iterates the other loop rather
than merely terminating the inner one. And its faster
because Perl executes a &quot;foreach&quot; statement more
rapidly than it would the equivalent &quot;for&quot;
loop.</p>

<p>Basic BLOCKs A BLOCK by itself (labeled or not) is
semantically equivalent to a loop that executes once. Thus
you can use any of the loop control statements in it to
leave or restart the block. (Note that this is NOT true in
&quot;eval{}&quot;, &quot;sub{}&quot;, or contrary to
popular belief &quot;do{}&quot; blocks, which do NOT count
as loops.) The &quot;continue&quot; block is optional.</p>

<p>The BLOCK construct can be used to emulate case
structures.</p>

<p>SWITCH: { if (/^abc/) { $abc = 1; last SWITCH; } if
(/^def/) { $def = 1; last SWITCH; } if (/^xyz/) { $xyz = 1;
last SWITCH; } $nothing = 1; }</p>

<p>Such constructs are quite frequently used, because older
versions of Perl had no official &quot;switch&quot;
statement.</p>

<p>Switch statements Starting from Perl 5.10, you can
say</p>

<p>use feature &quot;switch&quot;;</p>

<p>which enables a switch feature that is closely based on
the Perl 6 proposal.</p>

<p>The keywords &quot;given&quot; and &quot;when&quot; are
analogous to &quot;switch&quot; and &quot;case&quot; in
other languages, so the code above could be written as</p>

<p>given($_) { when (/^abc/) { $abc = 1; } when (/^def/) {
$def = 1; } when (/^xyz/) { $xyz = 1; } default { $nothing =
1; } }</p>

<p>This construct is very flexible and powerful. For
example:</p>

<p>use feature &quot;:5.10&quot;; given($foo) { when
(undef) { say &rsquo;$foo is undefined&rsquo;; } when
(&quot;foo&quot;) { say &rsquo;$foo is the string
&quot;foo&quot;&rsquo;; } when ([1,3,5,7,9]) { say
&rsquo;$foo is an odd digit&rsquo;; continue; # Fall through
} when ($_ &lt; 100) { say &rsquo;$foo is numerically less
than 100&rsquo;; } when (complicated_check) { say &rsquo;a
complicated check for $foo is true&rsquo;; } default { die
q(I don&rsquo;t know what to do with $foo); } }</p>

<p>&quot;given(EXPR)&quot; will assign the value of EXPR to
$_ within the lexical scope of the block, so its similar
to</p>

<p>do { my $_ = EXPR; ... }</p>

<p>except that the block is automatically broken out of by
a successful &quot;when&quot; or an explicit
&quot;break&quot;.</p>

<p>Most of the power comes from implicit smart
matching:</p>

<p>when($foo)</p>

<p>is exactly equivalent to</p>

<p>when($_ ~~ $foo)</p>

<p>Most of the time, &quot;when(EXPR)&quot; is treated as
an implicit smart match of $_, i.e. &quot;$_ ~~ EXPR&quot;.
(See &quot;Smart matching in detail&quot; for more
information on smart matching.) But when EXPR is one of the
below exceptional cases, it is used directly as a
boolean:</p>

<p>&middot; a subroutine or method call</p>

<p>&middot; a regular expression match, i.e.
&quot;/REGEX/&quot; or &quot;$foo =~ /REGEX/&quot;, or a
negated regular expression match (&quot;!/REGEX/&quot; or
&quot;$foo !~ /REGEX/&quot;).</p>

<p>&middot; a comparison such as &quot;$_ &lt; 10&quot; or
&quot;$x eq &quot;abc&quot;&quot; (or of course &quot;$_ ~~
$c&quot;)</p>

<p>&middot; &quot;defined(...)&quot;,
&quot;exists(...)&quot;, or &quot;eof(...)&quot;</p>

<p>&middot; a negated expression &quot;!(...)&quot; or
&quot;not (...)&quot;, or a logical exclusive-or &quot;(...)
xor (...)&quot;.</p>

<p>&middot; a filetest operator, with the exception of
&quot;-s&quot;, &quot;-M&quot;, &quot;-A&quot;, and
&quot;-C&quot;, that return numerical values, not boolean
ones.</p>

<p>&middot; the &quot;..&quot; and &quot;...&quot;
flip-flop operators.</p>

<p>In those cases the value of EXPR is used directly as a
boolean.</p>

<p>Furthermore:</p>

<p>&middot; If EXPR is &quot;... &amp;&amp; ...&quot; or
&quot;... and ...&quot;, the test is applied recursively to
both arguments. If both arguments pass the test, then the
argument is treated as boolean.</p>

<p>&middot; If EXPR is &quot;... || ...&quot;, &quot;... //
...&quot; or &quot;... or ...&quot;, the test is applied
recursively to the first argument.</p>

<p>These rules look complicated, but usually they will do
what you want. For example you could write:</p>

<p>when (/^+$/ &amp;&amp; $_ &lt; 75) { ... }</p>

<p>Another useful shortcut is that, if you use a literal
array or hash as the argument to &quot;given&quot;, it is
turned into a reference. So &quot;given(@foo)&quot; is the
same as &quot;given(@foo)&quot;, for example.</p>

<p>&quot;default&quot; behaves exactly like &quot;when(1 ==
1)&quot;, which is to say that it always matches.</p>

<p>Breaking out</p>

<p>You can use the &quot;break&quot; keyword to break out
of the enclosing &quot;given&quot; block. Every
&quot;when&quot; block is implicitly ended with a
&quot;break&quot;.</p>

<p>Fall-through</p>

<p>You can use the &quot;continue&quot; keyword to fall
through from one case to the next:</p>

<p>given($foo) { when (/x/) { say &rsquo;$foo contains an
x&rsquo;; continue } when (/y/) { say &rsquo;$foo contains a
y&rsquo; } default { say &rsquo;$foo does not contain a
y&rsquo; } }</p>

<p>Switching in a loop</p>

<p>Instead of using &quot;given()&quot;, you can use a
&quot;foreach()&quot; loop. For example, here s one way to
count how many times a particular string occurs in an
array:</p>

<p>my $count = 0; for (@array) { when (&quot;foo&quot;) {
++$count } } print &quot;@array contains $count copies of
&rsquo;foo&rsquo;0;</p>

<p>On exit from the &quot;when&quot; block, there is an
implicit &quot;next&quot;. You can override that with an
explicit &quot;last&quot; if you re only interested in the
first match.</p>

<p>This doesn t work if you explicitly specify a loop
variable, as in &quot;for $item (@array)&quot;. You have to
use the default variable $_. (You can use &quot;for my $_
(@array)&quot;.)</p>

<p>Smart matching in detail</p>

<p>The behaviour of a smart match depends on what type of
thing its arguments are. The behaviour is determined by the
following table: the first row that applies determines the
match behaviour (which is thus mostly determined by the type
of the right operand). Note that the smart match implicitly
dereferences any non-blessed hash or array ref, so the
&quot;Hash&quot; and &quot;Array&quot; entries apply in
those cases. (For blessed references, the &quot;Object&quot;
entries apply.)</p>

<p>Note that the &quot;Matching Code&quot; column is not
always an exact rendition. For example, the smart match
operator short-circuits whenever possible, but
&quot;grep&quot; does not.</p>

<p>$a $b Type of Match Implied Matching Code ====== =====
===================== ============= Any undef undefined
!defined $a</p>

<p>Any Object invokes ~~ overloading on $object, or
dies</p>

<p>Hash CodeRef sub truth for each key[1] !grep {
!$b-&gt;($_) } keys %$a Array CodeRef sub truth for each
elt[1] !grep { !$b-&gt;($_) } @$a Any CodeRef scalar sub
truth $b-&gt;($a)</p>

<p>Hash Hash hash keys identical (every key is found in
both hashes) Array Hash hash slice existence grep { exists
$b-&gt;{$_} } @$a Regex Hash hash key grep grep /$a/, keys
%$b undef Hash always false (undef can&rsquo;t be a key) Any
Hash hash entry existence exists $b-&gt;{$a}</p>

<p>Hash Array hash slice existence grep { exists
$a-&gt;{$_} } @$b Array Array arrays are comparable[2] Regex
Array array grep grep /$a/, @$b undef Array array contains
undef grep !defined, @$b Any Array match against an array
element[3] grep $a ~~ $_, @$b</p>

<p>Hash Regex hash key grep grep /$b/, keys %$a Array Regex
array grep grep /$b/, @$a Any Regex pattern match $a =~
/$b/</p>

<p>Object Any invokes ~~ overloading on $object, or falls
back: Any Num numeric equality $a == $b Num numish[4]
numeric equality $a == $b undef Any undefined !defined($b)
Any Any string equality $a eq $b</p>

<p>1 - empty hashes or arrays will match. 2 - that is, each
element smart-matches the element of same index in the other
array. [3] 3 - If a circular reference is found, we fall
back to referential equality. 4 - either a real number, or a
string that looks like a number</p>

<p>Custom matching via overloading</p>

<p>You can change the way that an object is matched by
overloading the &quot;~~&quot; operator. This may alter the
usual smart match semantics.</p>

<p>It should be noted that &quot;~~&quot; will refuse to
work on objects that dont overload it (in order to avoid
relying on the objects underlying structure).</p>

<p>Note also that smart matchs matching rules take
precedence over overloading, so if $obj has smart match
overloading, then</p>

<p>$obj ~~ X</p>

<p>will not automatically invoke the overload method with X
as an argument; instead the table above is consulted as
normal, and based in the type of X, overloading may or may
not be invoked.</p>

<p>See overload.</p>

<p>Differences from Perl 6</p>

<p>The Perl 5 smart match and
&quot;given&quot;/&quot;when&quot; constructs are not
absolutely identical to their Perl 6 analogues. The most
visible difference is that, in Perl 5, parentheses are
required around the argument to &quot;given()&quot; and
&quot;when()&quot;. Parentheses in Perl 6 are always
optional in a control construct such as &quot;if()&quot;,
&quot;while()&quot;, or &quot;when()&quot;; they cant be
made optional in Perl 5 without a great deal of potential
confusion, because Perl 5 would parse the expression</p>

<p>given $foo { ... }</p>

<p>as though the argument to &quot;given&quot; were an
element of the hash %foo, interpreting the braces as
hash-element syntax.</p>

<p>The table of smart matches is not identical to that
proposed by the Perl 6 specification, mainly due to the
differences between Perl 6s and Perl 5s data models.</p>

<p>In Perl 6, &quot;when()&quot; will always do an implicit
smart match with its argument, whilst it is convenient in
Perl 5 to suppress this implicit smart match in certain
situations, as documented above. (The difference is largely
because Perl 5 does not, even internally, have a boolean
type.)</p>

<p>Goto Although not for the faint of heart, Perl does
support a &quot;goto&quot; statement. There are three forms:
&quot;goto&quot;-LABEL, &quot;goto&quot;-EXPR, and
&quot;goto&quot;-&amp;NAME. A loops LABEL is not actually a
valid target for a &quot;goto&quot;; its just the name of
the loop.</p>

<p>The &quot;goto&quot;-LABEL form finds the statement
labeled with LABEL and resumes execution there. It may not
be used to go into any construct that requires
initialization, such as a subroutine or a
&quot;foreach&quot; loop. It also cant be used to go into a
construct that is optimized away. It can be used to go
almost anywhere else within the dynamic scope, including out
of subroutines, but its usually better to use some other
construct such as &quot;last&quot; or &quot;die&quot;. The
author of Perl has never felt the need to use this form of
&quot;goto&quot; (in Perl, that is--C is another
matter).</p>

<p>The &quot;goto&quot;-EXPR form expects a label name,
whose scope will be resolved dynamically. This allows for
computed &quot;goto&quot;s per FORTRAN, but isnt necessarily
recommended if you re optimizing for maintainability:</p>

<p>goto((&quot;FOO&quot;, &quot;BAR&quot;,
&quot;GLARCH&quot;)[$i]);</p>

<p>The &quot;goto&quot;-&amp;NAME form is highly magical,
and substitutes a call to the named subroutine for the
currently running subroutine. This is used by
&quot;AUTOLOAD()&quot; subroutines that wish to load another
subroutine and then pretend that the other subroutine had
been called in the first place (except that any
modifications to @_ in the current subroutine are propagated
to the other subroutine.) After the &quot;goto&quot;, not
even &quot;caller()&quot; will be able to tell that this
routine was called first.</p>

<p>In almost all cases like this, its usually a far, far
better idea to use the structured control flow mechanisms of
&quot;next&quot;, &quot;last&quot;, or &quot;redo&quot;
instead of resorting to a &quot;goto&quot;. For certain
applications, the catch and throw pair of &quot;eval{}&quot;
and die() for exception processing can also be a prudent
approach.</p>

<p>PODs: Embedded Documentation Perl has a mechanism for
intermixing documentation with source code. While its
expecting the beginning of a new statement, if the compiler
encounters a line that begins with an equal sign and a word,
like this</p>

<p>=head1 Here There Be Pods!</p>

<p>Then that text and all remaining text up through and
including a line beginning with &quot;=cut&quot; will be
ignored. The format of the intervening text is described in
perlpod.</p>

<p>This allows you to intermix your source code and your
documentation text freely, as in</p>

<p>=item snazzle($)</p>

<p>The snazzle() function will behave in the most
spectacular form that you can possibly imagine, not even
excepting cybernetic pyrotechnics.</p>

<p>=cut back to the compiler, nuff of this pod stuff!</p>

<p>sub snazzle($) { my $thingie = shift; ......... }</p>

<p>Note that pod translators should look at only paragraphs
beginning with a pod directive (it makes parsing easier),
whereas the compiler actually knows to look for pod escapes
even in the middle of a paragraph. This means that the
following secret stuff will be ignored by both the compiler
and the translators.</p>

<p>$a=3; =secret stuff warn &quot;Neither POD nor
CODE!?&quot; =cut back print &quot;got $a0;</p>

<p>You probably shouldnt rely upon the &quot;warn()&quot;
being podded out forever. Not all pod translators are
well-behaved in this regard, and perhaps the compiler will
become pickier.</p>

<p>One may also use pod directives to quickly comment out a
section of code.</p>

<p>Plain Old Comments (Not!) Perl can process line
directives, much like the C preprocessor. Using this, one
can control Perls idea of filenames and line numbers in
error or warning messages (especially for strings that are
processed with &quot;eval()&quot;). The syntax for this
mechanism is the same as for most C preprocessors: it
matches the regular expression</p>

<p># example: &rsquo;# line 42
&quot;new_filename.plx&quot;&rsquo; /^ line (+)
(?:?)([^&quot;]+)2)? $/x</p>

<p>with $1 being the line number for the next line, and $3
being the optional filename (specified with or without
quotes).</p>

<p>There is a fairly obvious gotcha included with the line
directive: Debuggers and profilers will only show the last
source line to appear at a particular line number in a given
file. Care should be taken not to cause line number
collisions in code youd like to debug later.</p>

<p>Here are some examples that you should be able to type
into your command shell:</p>

<p>% perl # line 200 &quot;bzzzt&quot; # the
&lsquo;#&rsquo; on the previous line must be the first char
on line die &rsquo;foo&rsquo;; __END__ foo at bzzzt line
201.</p>

<p>% perl # line 200 &quot;bzzzt&quot; eval qq[0line 2001
&quot;&quot;0ie &rsquo;foo&rsquo;]; print $@; __END__ foo at
- line 2001.</p>

<p>% perl eval qq[0line 200 &quot;foo bar&quot;0ie
&rsquo;foo&rsquo;]; print $@; __END__ foo at foo bar line
200.</p>

<p>% perl # line 345 &quot;goop&quot; eval &quot;0line
&quot; . __LINE__ . &rsquo; &quot;&rsquo; . __FILE__ .&quot;
print $@; __END__ foo at goop line 345.</p>

<p>perl v5.10.1 2009-08-22 PERLSYN(1)</p>
<hr>
</body>
</html>
