<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:27:53 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLUNIFAQ(1) Perl Programmers Reference Guide
PERLUNIFAQ(1)</p>

<p>NAME perlunifaq - Perl Unicode FAQ</p>

<p>Q and A This is a list of questions and answers about
Unicode in Perl, intended to be read after perlunitut.</p>

<p>perlunitut ist really a Unicode tutorial, is it? No, and
this isnt really a Unicode FAQ.</p>

<p>Perl has an abstracted interface for all supported
character encodings, so they is actually a generic
&quot;Encode&quot; tutorial and &quot;Encode&quot; FAQ. But
many people think that Unicode is special and magical, and I
didnt want to disappoint them, so I decided to call the
document a Unicode tutorial.</p>

<p>What character encodings does Perl support? To find out
which character encodings your Perl supports, run:</p>

<p>perl -MEncode -le &quot;print for
Encode-&gt;encodings(&rsquo;:all&rsquo;)&quot;</p>

<p>Which version of perl should I use? Well, if you can,
upgrade to the most recent, but certainly 5.8.1 or newer.
The tutorial and FAQ are based on the status quo as of
5.8.8.</p>

<p>You should also check your modules, and upgrade them if
necessary. For example, HTML::Entities requires version
&gt;= 1.32 to function correctly, even though the changelog
is silent about this.</p>

<p>What about binary data, like images? Well, apart from a
bare &quot;binmode $fh&quot;, you shouldnt treat them
specially. (The binmode is needed because otherwise Perl may
convert line endings on Win32 systems.)</p>

<p>Be careful, though, to never combine text strings with
binary strings. If you need text in a binary stream, encode
your text strings first using the appropriate encoding, then
join them with binary strings. See also: &quot;What if I
dont encode?&quot;.</p>

<p>When should I decode or encode? Whenever youre
communicating text with anything that is external to your
perl process, like a database, a text file, a socket, or
another program. Even if the thing you re communicating with
is also written in Perl.</p>

<p>What if I dot decode? Whenever your encoded, binary
string is used together with a text string, Perl will assume
that your binary string was encoded with ISO-8859-1, also
known as latin-1. If it wasnt latin-1, then your data is
unpleasantly converted. For example, if it was UTF-8, the
individual bytes of multibyte characters are seen as
separate characters, and then again converted to UTF-8. Such
double encoding can be compared to double HTML encoding
(&quot;&amp;amp;gt;&quot;), or double URI encoding
(%253E).</p>

<p>This silent implicit decoding is known as
&quot;upgrading&quot;. That may sound positive, but its best
to avoid it.</p>

<p>What if I dot encode? Your text string will be sent
using the bytes in Perls internal format. In some cases,
Perl will warn you that youre doing something wrong, with a
friendly warning:</p>

<p>Wide character in print at example.pl line 2.</p>

<p>Because the internal format is often UTF-8, these bugs
are hard to spot, because UTF-8 is usually the encoding you
wanted! But dont be lazy, and dont use the fact that Perls
internal format is UTF-8 to your advantage. Encode
explicitly to avoid weird bugs, and to show to maintenance
programmers that you thought this through.</p>

<p>Is there a way to automatically decode or encode? If all
data that comes from a certain handle is encoded in exactly
the same way, you can tell the PerlIO system to
automatically decode everything, with the
&quot;encoding&quot; layer. If you do this, you cant
accidentally forget to decode or encode anymore, on things
that use the layered handle.</p>

<p>You can provide this layer when &quot;open&quot;ing the
file:</p>

<p>open my $fh, &rsquo;&gt;:encoding(UTF-8)&rsquo;,
$filename; # auto encoding on write open my $fh,
&rsquo;&lt;:encoding(UTF-8)&rsquo;, $filename; # auto
decoding on read</p>

<p>Or if you already have an open filehandle:</p>

<p>binmode $fh, &rsquo;:encoding(UTF-8)&rsquo;;</p>

<p>Some database drivers for DBI can also automatically
encode and decode, but that is sometimes limited to the
UTF-8 encoding.</p>

<p>What if I dot know which encoding was used? Do whatever
you can to find out, and if you have to: guess. (Dont forget
to document your guess with a comment.)</p>

<p>You could open the document in a web browser, and change
the character set or character encoding until you can
visually confirm that all characters look the way they
should.</p>

<p>There is no way to reliably detect the encoding
automatically, so if people keep sending you data without
charset indication, you may have to educate them.</p>

<p>Can I use Unicode in my Perl sources? Yes, you can! If
your sources are UTF-8 encoded, you can indicate that with
the &quot;use utf8&quot; pragma.</p>

<p>use utf8;</p>

<p>This doesnt do anything to your input, or to your
output. It only influences the way your sources are read.
You can use Unicode in string literals, in identifiers (but
they still have to be &quot;word characters&quot; according
to &quot;792</p>

<p>Data::Dumper doest restore the UTF8 flag; is it broken?
No, Data::Dumpers Unicode abilities are as they should be.
There have been some complaints that it should restore the
UTF8 flag when the data is read again with &quot;eval&quot;.
However, you should really not look at the flag, and nothing
indicates that Data::Dumper should break this rule.</p>

<p>Here s what happens: when Perl reads in a string
literal, it sticks to 8 bit encoding as long as it can. (But
perhaps originally it was internally encoded as UTF-8, when
you dumped it.) When it has to give that up because other
characters are added to the text string, it silently
upgrades the string to UTF-8.</p>

<p>If you properly encode your strings for output, none of
this is of your concern, and you can just &quot;eval&quot;
dumped data as always.</p>

<p>Why do regex character classes sometimes match only in
the ASCII range? Why do some characters not uppercase or
lowercase correctly? It seemed like a good idea at the time,
to keep the semantics the same for standard strings, when
Perl got Unicode support. While it might be repaired in the
future, we now have to deal with the fact that Perl treats
equal strings differently, depending on the internal
state.</p>

<p>Affected are &quot;uc&quot;, &quot;lc&quot;,
&quot;ucfirst&quot;, &quot;lcfirst&quot;, &quot;U&quot;,
&quot; &quot;&quot;, &quot; &quot;&quot;, &quot; &quot;48
&quot;W&quot;, &quot;/.../i&quot;, &quot;(?i:...)&quot;,
&quot;/[[:posix:]]/&quot;, and &quot;quotemeta&quot; (though
this last should not cause any real problems).</p>

<p>To force Unicode semantics, you can upgrade the internal
representation to by doing
&quot;utf8::upgrade($string)&quot;. This can be used safely
on any string, as it checks and does not change strings that
have already been upgraded.</p>

<p>For a more detailed discussion, see Unicode::Semantics
on CPAN.</p>

<p>How can I determine if a string is a text string or a
binary string? You cant. Some use the UTF8 flag for this,
but that s misuse, and makes well behaved modules like
Data::Dumper look bad. The flag is useless for this purpose,
because its off when an 8 bit encoding (by default
ISO-8859-1) is used to store the string.</p>

<p>This is something you, the programmer, has to keep track
of; sorry. You could consider adopting a kind of
&quot;Hungarian notation&quot; to help with this.</p>

<p>How do I convert from encoding FOO to encoding BAR? By
first converting the FOO-encoded byte string to a text
string, and then the text string to a BAR-encoded byte
string:</p>

<p>my $text_string = decode(&rsquo;FOO&rsquo;,
$foo_string); my $bar_string = encode(&rsquo;BAR&rsquo;,
$text_string);</p>

<p>or by skipping the text string part, and going directly
from one binary encoding to the other:</p>

<p>use Encode qw(from_to); from_to($string,
&rsquo;FOO&rsquo;, &rsquo;BAR&rsquo;); # changes contents of
$string</p>

<p>or by letting automatic decoding and encoding do all the
work:</p>

<p>open my $foofh, &rsquo;&lt;:encoding(FOO)&rsquo;,
&rsquo;example.foo.txt&rsquo;; open my $barfh,
&rsquo;&gt;:encoding(BAR)&rsquo;,
&rsquo;example.bar.txt&rsquo;; print { $barfh } $_ while
&lt;$foofh&gt;;</p>

<p>What are &quot;decode_utf8&quot; and
&quot;encode_utf8&quot;? These are alternate syntaxes for
&quot;decode(&rsquo;utf8&rsquo;, ...)&quot; and
&quot;encode(&rsquo;utf8&rsquo;, ...)&quot;.</p>

<p>What is a &quot;wide character&quot;? This is a term
used both for characters with an ordinal value greater than
127, characters with an ordinal value greater than 255, or
any character occupying than one byte, depending on the
context.</p>

<p>The Perl warning &quot;Wide character in ...&quot; is
caused by a character with an ordinal value greater than
255. With no specified encoding layer, Perl tries to fit
things in ISO-8859-1 for backward compatibility reasons.
When it cant, it emits this warning (if warnings are
enabled), and outputs UTF-8 encoded data instead.</p>

<p>To avoid this warning and to avoid having different
output encodings in a single stream, always specify an
encoding explicitly, for example with a PerlIO layer:</p>

<p>binmode STDOUT, &quot;:encoding(UTF-8)&quot;;</p>

<p>INTERNALS What is &quot;the UTF8 flag&quot;? Please,
unless youre hacking the internals, or debugging weirdness,
dont think about the UTF8 flag at all. That means that you
very probably shouldnt use &quot;is_utf8&quot;,
&quot;_utf8_on&quot; or &quot;_utf8_off&quot; at all.</p>

<p>The UTF8 flag, also called SvUTF8, is an internal flag
that indicates that the current internal representation is
UTF-8. Without the flag, it is assumed to be ISO-8859-1.
Perl converts between these automatically.</p>

<p>One of Perl s internal formats happens to be UTF-8.
Unfortunately, Perl cant keep a secret, so everyone knows
about this. That is the source of much confusion. Its better
to pretend that the internal format is some unknown
encoding, and that you always have to encode and decode
explicitly.</p>

<p>What about the &quot;use bytes&quot; pragma? Don t use
it. It makes no sense to deal with bytes in a text string,
and it makes no sense to deal with characters in a byte
string. Do the proper conversions (by decoding/encoding),
and things will work out well: you get character counts for
decoded data, and byte counts for encoded data.</p>

<p>&quot;use bytes&quot; is usually a failed attempt to do
something useful. Just forget about it.</p>

<p>What about the &quot;use encoding&quot; pragma? Dont use
it. Unfortunately, it assumes that the programmer s
environment and that of the user will use the same encoding.
It will use the same encoding for the source code and for
STDIN and STDOUT. When a program is copied to another
machine, the source code does not change, but the STDIO
environment might.</p>

<p>If you need non-ASCII characters in your source code,
make it a UTF-8 encoded file and &quot;use utf8&quot;.</p>

<p>If you need to set the encoding for STDIN, STDOUT, and
STDERR, for example based on the users locale, &quot;use
open&quot;.</p>

<p>What is the difference between &quot;:encoding&quot; and
&quot;:utf8&quot;? Because UTF-8 is one of Perls internal
formats, you can often just skip the encoding or decoding
step, and manipulate the UTF8 flag directly.</p>

<p>Instead of &quot;:encoding(UTF-8)&quot;, you can simply
use &quot;:utf8&quot;, which skips the encoding step if the
data was already represented as UTF8 internally. This is
widely accepted as good behavior when youre writing, but it
can be dangerous when reading, because it causes internal
inconsistency when you have invalid byte sequences. Using
&quot;:utf8&quot; for input can sometimes result in security
breaches, so please use &quot;:encoding(UTF-8)&quot;
instead.</p>

<p>Instead of &quot;decode&quot; and &quot;encode&quot;,
you could use &quot;_utf8_on&quot; and
&quot;_utf8_off&quot;, but this is considered bad style.
Especially &quot;_utf8_on&quot; can be dangerous, for the
same reason that &quot;:utf8&quot; can.</p>

<p>There are some shortcuts for oneliners; see
&quot;-C&quot; in perlrun.</p>

<p>Whas the difference between &quot;UTF-8&quot; and
&quot;utf8&quot;? &quot;UTF-8&quot; is the official
standard. &quot;utf8&quot; is Perls way of being liberal in
what it accepts. If you have to communicate with things that
arent so liberal, you may want to consider using
&quot;UTF-8&quot;. If you have to communicate with things
that are too liberal, you may have to use &quot;utf8&quot;.
The full explanation is in Encode.</p>

<p>&quot;UTF-8&quot; is internally known as
&quot;utf-8-strict&quot;. The tutorial uses UTF-8
consistently, even where utf8 is actually used internally,
because the distinction can be hard to make, and is mostly
irrelevant.</p>

<p>For example, utf8 can be used for code points that don t
exist in Unicode, like 9999999, but if you encode that to
UTF-8, you get a substitution character (by default; see
&quot;Handling Malformed Data&quot; in Encode for more ways
of dealing with this.)</p>

<p>Okay, if you insist: the &quot;internal format&quot; is
utf8, not UTF-8. (When its not some other encoding.)</p>

<p>I lost track; what encoding is the internal format
really? Its good that you lost track, because you shouldnt
depend on the internal format being any specific encoding.
But since you asked: by default, the internal format is
either ISO-8859-1 (latin-1), or utf8, depending on the
history of the string. On EBCDIC platforms, this may be
different even.</p>

<p>Perl knows how it stored the string internally, and will
use that knowledge when you &quot;encode&quot;. In other
words: dont try to find out what the internal encoding for a
certain string is, but instead just encode it into the
encoding that you want.</p>

<p>AUTHOR Juerd Waalboer &lt;#####@juerd.nl&gt;</p>

<p>SEE ALSO perlunicode, perluniintro, Encode</p>

<p>perl v5.10.1 2009-02-25 PERLUNIFAQ(1)</p>
<hr>
</body>
</html>
