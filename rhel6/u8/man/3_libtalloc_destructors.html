<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:21:58 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>libtalloc_destructors(3) talloc
libtalloc_destructors(3)</p>

<p>NAME libtalloc_destructors - Chapter 4: Using
destructors</p>

<p>Using destructors Destructors are well known methods in
the world of object oriented programming. A destructor is a
method of an object that is automatically run when the
object is destroyed. It is usually used to return resources
taken by the object back to the system (e.g. closing file
descriptors, terminating connection to a database,
deallocating memory).</p>

<p>With talloc we can take the advantage of destructors
even in C. We can easily attach our own destructor to a
talloc context. When the context is freed, the destructor
will run automatically.</p>

<p>To attach/detach a destructor to a talloc context use:
talloc_set_destructor().</p>

<p>Example Imagine that we have a dynamically created
linked list. Before we deallocate an element of the list, we
need to make sure that we have successfully removed it from
the list. Normally, this would be done by two commands in
the exact order: remove it from the list and then free the
element. With talloc, we can do this at once by setting a
destructor on the element which will remove it from the list
and talloc_free() will do the rest.</p>

<p>The destructor would be:</p>

<p>int list_remove(void *ctx) { struct list_el *el = NULL;
el = talloc_get_type_abort(ctx, struct list_el); /* remove
element from the list */ }</p>

<p>GCC version 3 and newer can check for the types during
the compilation. So if it is our major compiler, we can use
a more advanced destructor:</p>

<p>int list_remove(struct list_el *el) { /* remove element
from the list */ }</p>

<p>Now we will assign the destructor to the list element.
We can do this directly in the function that inserts it.</p>

<p>struct list_el* list_insert(TALLOC_CTX *mem_ctx, struct
list_el *where, void *ptr) { struct list_el *el =
talloc(mem_ctx, struct list_el); el-&gt;data = ptr; /*
insert into list */</p>

<p>talloc_set_destructor(el, list_remove); return el; }</p>

<p>Because talloc is a hierarchical memory allocator, we
can go a step further and free the data with the element as
well:</p>

<p>struct list_el* list_insert_free(TALLOC_CTX *mem_ctx,
struct list_el *where, void *ptr) { struct list_el *el =
NULL; el = list_insert(mem_ctx, where, ptr);</p>

<p>talloc_steal(el, ptr);</p>

<p>return el; }</p>

<p>Version 2.0 1 Apr 2016 libtalloc_destructors(3)</p>
<hr>
</body>
</html>
