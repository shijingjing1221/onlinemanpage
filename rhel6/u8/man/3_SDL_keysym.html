<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:33:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SDL_keysym(3) SDL API Reference SDL_keysym(3)</p>

<p>NAME SDL_keysym - Keysym structure</p>

<p>STRUCTURE DEFINITION typedef struct{ Uint8 scancode;
SDLKey sym; SDLMod mod; Uint16 unicode; } SDL_keysym;</p>

<p>STRUCTURE DATA scancode Hardware specific scancode</p>

<p>sym SDL virtual keysym</p>

<p>mod Current key modifiers</p>

<p>unicode Translated character</p>

<p>DESCRIPTION The SDL_keysym structure is used by
reporting key presses and releases since it is a part of the
SDL_KeyboardEvent.</p>

<p>The scancode field should generally be left alone, it is
the hardware dependent scancode returned by the keyboard.
The sym field is extremely useful. It is the SDL-defined
value of the key (see SDL Key Syms. This field is very
useful when you are checking for certain key presses, like
so:</p>

<p>. . while(SDL_PollEvent(&amp;event)){
switch(event.type){ case SDL_KEYDOWN:
if(event.key.keysym.sym==SDLK_LEFT) move_left(); break; . .
. } } . .</p>

<p>mod stores the current state of the keyboard modifiers
as explained in SDL_GetModState. The unicode is only used
when UNICODE translation is enabled with SDL_EnableUNICODE.
If unicode is non-zero then this a the UNICODE character
corresponding to the keypress. If the high 9 bits of the
character are 0, then this maps to the equivalent ASCII
character:</p>

<p>char ch; if ( (keysym.unicode &amp; 0xFF80) == 0 ) { ch
= keysym.unicode &amp; 0x7F; } else { printf(&quot;An
International Character. &quot;); }</p>

<p>UNICODE translation does have a slight overhead so dont
enable it unless its needed.</p>

<p>SEE ALSO SDLKey</p>

<p>SDL Tue 11 Sep 2001, 23:00 SDL_keysym(3)</p>
<hr>
</body>
</html>
