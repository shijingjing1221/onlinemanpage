<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ipmi_cmdlang(7) Shell interface to an IPMI system
ipmi_cmdlang(7)</p>

<p>NAME ipmi_cmdlang - A command language interface to the
IPMI library</p>

<p>DESCRIPTION ipmi_cmdlang is a command language designed
to supply the full power of OpenIPMI on a command line. It
has a large number of commands and well-formed responses to
each command. Note that this assumes some knowledge of
OpenIPMI and how it works; you can get that from the IPMI
document that comes with OpenIPMI.</p>

<p>ipmish starts up with no connections or anything of that
nature. You must enter commands to make connections to
domains. Then you can enter commands to manipulate those
domains or objects inside those domains.</p>

<p>Note that you may use quotes, either or to contain
parameters with spaces.</p>

<p>COMMENTS Lines with a # character in the first column
are ignored.</p>

<p>OBJECTS In the command language, you will deal with
various objects like sen- sors, controls, domains, and
entities. Each of these has a name. The name of the domain
is assigned by the user in the domain new command, all the
other names are based on the domain name of the domain they
belong to and various attributes about the object. These
names are all well-formed. They are</p>

<p>&lt;domain&gt; - A name of a domain. Each registered
domain in a system has a name assigned by the user.</p>

<p>&lt;entity&gt; - Entity names are in the form:
[&lt;domain&gt;[(&lt;entity spec&gt;)]] Notice that the
&lt;entity spec&gt; is optional. If it is not listed, then
the operation is done on all entities in the domain. The
whole thing is optional, too, if nothing is given then the
operation is done on every entity in every domain.</p>

<p>The &lt;entity spec&gt; is either &lt;entity
id&gt;.&lt;entity instance&gt; for system-relative entities,
or: r&lt;channel&gt;.&lt;IPMB&gt;.&lt;entity
id&gt;.&lt;entity instance-0x60&gt; for device-relative
entities. In IPMI, device-relative entity instances always
start at 0x60; the specification suggests that you subtract
off the 0x60 from the entity instance when displaying these;
the command language follows this suggestion.</p>

<p>&lt;sensor&gt; - These come in the form
[&lt;entity&gt;[.name]] As with entities, only listing a
domain will cause the operation to be done on every sensor
in the domain, just listing an entity will cause it to be
done to every sensor in that entity. An empty sensor entry
will cause an operation to be done on every sensor in every
domain.</p>

<p>&lt;control&gt; - These come in the form
[&lt;entity&gt;[.name]] These work exactly like sensors.</p>

<p>&lt;mc&gt; - A management controller. These come in the
form [&lt;domain&gt;[(&lt;channel&gt;.&lt;IPMB&gt;)]] As
usual, the parts left empty will cause defaulting to all
things in the previously specified parts.</p>

<p>&lt;connection&gt; - A connection number, in the form
[&lt;domain&gt;[.&lt;integer&gt;]] The number is the
connection number of the domain.</p>

<p>&lt;pet&gt; - A platform event trap id, in the form
[&lt;domain&gt;[.&lt;integer&gt;]] The number is arbitrarily
assigned by the system.</p>

<p>&lt;lanparm&gt; - A LAN parameter id, in the form
[&lt;domain&gt;[.&lt;integer&gt;]] The number is arbitrarily
assigned by the system.</p>

<p>&lt;pef&gt; - A PEF id, in the form
[&lt;domain&gt;[.&lt;integer&gt;]] The number is arbitrarily
assigned by the system.</p>

<p>&lt;fru&gt; - A FRU id, in the form
[&lt;domain&gt;[.&lt;integer&gt;]] The number is arbitrarily
assigned by the system.</p>

<p>In all cases, the object names have parts that are
optional, and the entire object name is optional. If a part
is left empty, then all objects that are part of the
specified parts are operated on. For instance, if the system
has a sensor named d1(7.1).temp then specifying d1 would
operation on all sensors in the domain named d1. Specifying
d1(7.1) Would operation on all sensors in that entity.
Specifying an empty name, either with or by just entering
nothing if the object is the last thing in the commands
parameters.</p>

<p>Note this optionality gives a lot of power, but can be
very dangerous. Entering domain close will close every
domain, for instance.</p>

<p>In commands, every object operated on will generate a
response for that object. If no object is operated on, the
command will produce an error.</p>

<p>OTHER PARAMETERS The commands and displays use a variety
of other parameters for speci- fying various IPMI
things.</p>

<p>&lt;guid&gt; - a 16-byte globally unique ID, all globbed
together in one big hexadecimal thing.</p>

<p>&lt;threshold&gt; is a threshold for a sensor; the value
it must go over/under to generate an event. It is always
displayed as one of lower non-critical lower critical lower
non-recoverable upper non-crit- ical upper critical upper
non-recoverable. It may be entered as one of the above, or
as ln, lc, lr, un, uc, ur as a short form.</p>

<p>&lt;threshold enable&gt; is the enable for a threshold.
It is like &lt;thresh- old&gt; above, but also has a
going-high or going-low and an assertion or deassertion
appended to the end of the name. The short form will have a
l or h for going-low and going high and then a a or d
appended for assertion and deassertion So for instance, urld
is upper non-recover- able going-low deassertion.</p>

<p>&lt;discrete enable&gt; is the enable or disable for a
discrete sensor and is specified with the sensor offset. The
long form is &lt;integer&gt; assertion or &lt;integer&gt;
deassertion and the short form is &lt;integer&gt;[ad] where
the number is the offset and [ad] means assertion or
deassertion.</p>

<p>&lt;hot-swap state&gt; is one of not_present, inactive
activation_requested activation_in_progress active
deactivation_requested deactiva- tion_in_progress or
out_of_con.</p>

<p>&lt;color&gt; is one of black, white, red, green blue
yellow or orange.</p>

<p>&lt;bool&gt; is one of true, on, t, or 1 for true and
one of false, off, f, or 0 for false. Output is always true
or false.</p>

<p>COMMANDS The command language is hierarchical, meaning
that commands may have subcommands, and subcommands may have
subsubcommands, etc. So, for instance, the command to create
a domain is domain new. The command to list all sensors in a
domain named domain1 is sensor list domain1.</p>

<p>Each command has a reponse for each object operated on,
which is listed after the command description. In those
responses, anything that begins with a % is optional.
Entries of the form **name** refer to object info
descriptions that are listed in the object info section. If
an entry has two . indented one space below it, then that
entry may occur zero or more times.</p>

<p>Each section below defines the unique subcommands of a
main command.</p>

<p>Help for any command is available with:</p>

<p>help command [subcommand [...]] - Help for any
command.</p>

<p>Some commands are common to almost all subcommands.
These are:</p>

<p>list &lt;containing object&gt; - List all objects of the
specified type that are contained in the specified object.
For instance, control list &lt;entity&gt; will list all
controls in the given entity.</p>

<p>Response: &lt;containing object type&gt; Name:
&lt;name&gt; . .</p>

<p>info &lt;object&gt; - List static information about the
given object.</p>

<p>Response: &lt;object type&gt; Name: &lt;name&gt;
**object info**</p>

<p>domain These commands deal with domain objects.</p>

<p>new &lt;domain&gt; &lt;options&gt; &lt;parms&gt;
[&lt;parms&gt;] - Open a connection to a new domain.
&lt;parms&gt; are either: lan &lt;IP&gt; &lt;port&gt;
[&lt;IP&gt; &lt;port&gt;] &lt;enc&gt; &lt;auth&gt;
&lt;name&gt; &lt;password&gt; for a RMCP LAN connection or
smi &lt;smi num&gt; for a system interface connection. Note
that &lt;parms&gt; is listed twice (second one is optional);
if the system support it you can make two connections to two
independent management controllers in the system. Note that
this is not for multiple IP addresses to the same BMC. For
that, notice that the LAN connection has an options extra IP
and port for the second IP address. OpenIPMI supports these
IP addresses and connection, detecting failures, switching
between addresses, and other fault-tolerant things. It does
this transparently to the user. Mutiple connections may
require special OEM support, read the documen- tation about
your specific system if you need this.</p>

<p>The &lt;IP&gt; is the IP address or host name of the
LAN-capable BMC to con- nect with. The &lt;port&gt; is
generally 623. &lt;enc&gt; is the authentication type,
either md5, md2, straight, or none. &lt;auth&gt; is the
authentication level, either admin, operator or user.
&lt;name&gt; and &lt;password&gt; are the user name and
password of the IPMI user to use for the connection. The
&lt;smi num&gt; is the driver number, generally 0. Options
enable and dis- able various automitic processing and are:
-[no]all - all automatic handling. This will override the
other pro- cessing options and turn them all on. This is
true by default. -[no]sdrs - sdr fetching. This turns on
fetching SDRs when they are found. This is false by default.
-[no]frus - FRU fetching This turns on fetching FRU
information when it is found. This is false by default.
-[no]sel - SEL fetching. This turns on fetching SELs when
they are found. This is false by default. -[no]ipmbscan -
IPMB bus scanning. This turns on scanning IPMB busses when
they are found. This is false by default. -[no]oeminit -
enable or disable special OEM processing (like ATCA).
-[no]seteventrcvr - setting event receivers. Note that
setting event receivers and waiting til up is not affected
by the -all option. If this is true (the default) then
OpenIPMI will attempt to set the event receiver for an MC it
finds that does not have it set to a valid destination.
-wait_til_up - wait until the domain is up before returning
Note that if you specify this and the domain never comes up,
you will never get a prompt. This is not affected by the
-all option. By default -all and -seteventrcvr are true,
which turns every- thing on.</p>

<p>Response: Domain Created: &lt;domain&gt;</p>

<p>open &lt;domain&gt; &lt;options&gt; &lt;parms&gt;
[&lt;parms&gt;] - Open a connection to a new domain.
&lt;parms&gt; are either: lan [-U &lt;username&gt;] [-P
&lt;password&gt;] [-A &lt;authtype&gt;] [-L
&lt;privilege&gt;] [-s] [-p[2] &lt;port number&gt;] [-Ra
&lt;auth alg&gt;] [-Ri &lt;integ alg&gt;] [-Rc &lt;conf
algo&gt;] [-Rl] [-Rk &lt;bmc key&gt;] [-H &lt;hackname&gt;]
[-M &lt;max oustanding msgs&gt;] &lt;IP&gt; [&lt;IP&gt;] for
a RMCP/RMCP+ LAN connection or smi &lt;smi num&gt; for a
system interface connection. Note that &lt;parms&gt; is
listed twice (second one is optional); if the system support
it you can make two connections to two independent
management controllers in the system. Note that this is not
for multiple IP addresses to the same BMC. For that, use the
-s option and the second IP (and -p2) for the second IP
address. OpenIPMI supports these IP addresses and
connections, detect- ing failures, switching between
addresses, and other fault-tolerant things. It does this
transparently to the user. Multiple connections may require
special OEM support, read the documentation about your spe-
cific system if you need this.</p>

<p>The &lt;IP&gt; is the IP address or host name of the
LAN-capable BMC to con- nect with. The &lt;port&gt; defaults
623. &lt;authtype&gt; is the authentication type, either
rmcp+, md5, md2, straight, or none. It defaults to the best
authentication supported by the server. &lt;auth&gt; is the
authentica- tion level, either admin, operator or user. It
defaults to admin. &lt;username&gt; and &lt;password&gt; are
the user name and password of the IPMI user to use for the
connection. For RMCP+ connections, the authentica- tion
algorithms supported (-Ra) are: bmcpick, rakp_none,
rakp_hmac_sha1, and rakp_hmac_md5. The integrity algorithms
(-Ri) sup- ported are: bmcpick, none, hmac_sha1, hmac_md5,
and md5. The confiden- tiality algorithms (-Rc) are:
bmcpick, aes_cbc_128, xrc4_128, and xrc_40. The defaults are
rackp_hmac_sha1, hmac_sha1, and aes_cb_128. -Rl turns on
lookup up names by the name and the privilege level
(allowing the same name with different privileges and
different pass- words), the default is straight name lookup.
-Rk sets the BMC key, needed if the system does two-key
lookups.</p>

<p>For SMI types, the &lt;smi num&gt; is the driver number,
generally 0.</p>

<p>The &lt;hackname&gt; enables certain hacks for broken
platforms. This may be listed multiple times to enable
multiple hacks. The currently avail- able hacks are:
intelplus - For Intel platforms that have broken RMCP+.
rakp3_wrong_rolem - For systems that truncate role(m) in the
RAKP3 msg. rmcpp_integ_sik - For systems that use SIK
instead of K(1) for integrity.</p>

<p>The -M option sets the maximum outstanding messages. The
default is 2, ranges 1-63.</p>

<p>Options enable and disable various automitic processing
and are: -[no]all - all automatic handling. This will
override the other pro- cessing options and turn them all
on. This is true by default. -[no]sdrs - sdr fetching. This
turns on fetching SDRs when they are found. This is false by
default. -[no]frus - FRU fetching This turns on fetching FRU
information when it is found. This is false by default.
-[no]sel - SEL fetching. This turns on fetching SELs when
they are found. This is false by default. -[no]ipmbscan -
IPMB bus scanning. This turns on scanning IPMB busses when
they are found. This is false by default. -[no]oeminit -
enable or disable special OEM processing (like ATCA).
-[no]seteventrcvr - setting event receivers. Note that
setting event receivers is not affected by the -all option.
If this is true (the default) then OpenIPMI will attempt to
set the event receiver for an MC it finds that does not have
it set to a valid destination. -[no]setseltime - set SEL
time. Note that setting the SEL time is not affected by the
-all option. If this is true (the default) then OpenIPMI
will attempt to set the time in the SELs it finds. It will
set it to the current system time. -wait_til_up - wait until
the domain is up before returning Note that if you specify
this and the domain never comes up, you will never get a
prompt. This is not affected by the -all option. By default
-all and -seteventrcvr are true, which turns every- thing
on.</p>

<p>Response: Domain Created: &lt;domain&gt;</p>

<p>fru &lt;domain&gt; &lt;is_logical&gt;
&lt;device_address&gt; &lt;device_id&gt; &lt;lun&gt;
&lt;pri- vate_bus&gt; &lt;channel&gt; - dump a fru given all
it s insundry information.</p>

<p>Response: Domain Name: &lt;domain&gt; FRU **FRU
INFO**</p>

<p>msg &lt;domain&gt; &lt;channel&gt; &lt;ipmb&gt;
&lt;LUN&gt; &lt;NetFN&gt; &lt;Cmd&gt; [data...] - Send a
command to the given IPMB address on the given channel and
display the response. Note that this does not require the
existance of an MC in OpenIPMI.</p>

<p>Response: Domain: &lt;domain&gt; channel: &lt;chan&gt;
ipmb: &lt;ipmb&gt; LUN: &lt;lun&gt; NetFN: &lt;netfn&gt;
command: &lt;cmd&gt; Data: &lt;data bytes&gt;</p>

<p>scan &lt;domain&gt; &lt;ipmb addr&gt; [ipmb addr] - scan
an IPMB to add or remove it. If a range is given, then scan
all IPMBs in the range.</p>

<p>Response: Scan done: &lt;domain&gt;</p>

<p>rescan_sels &lt;domain&gt; - Rescan all the SELs in the
domain.</p>

<p>Response: SEL Rescan done: &lt;domain&gt;</p>

<p>presence &lt;domain&gt; - Audit the presence of all
enities in the domain. Note that this just starts the
process; it will run in the background.</p>

<p>Response is: Presence check started: &lt;domain&gt;</p>

<p>close &lt;domain&gt; - close the given domain.</p>

<p>Response: Domain closed: &lt;domain&gt;</p>

<p>sel_rescan_time &lt;domain&gt; &lt;time in seconds&gt; -
Set the time between SEL rescans for all. It affects all
current SELs and SELs that are discov- ered in the future.
Zero disables scans.</p>

<p>Response: Domain SEL rescan time set: &lt;domain&gt;</p>

<p>ipmb_rescan_time &lt;domain&gt; &lt;time in seconds&gt;
- Set the time between IPMB rescans for this domain. zero
disables scans.</p>

<p>Response: Domain IPMB rescan time set:
&lt;domain&gt;</p>

<p>fru These commands deal with FRU objects. Note that FRU
objects are allo- cated by the domain fru command, and are
not allocated here.</p>

<p>list - List all the frus in the system</p>

<p>Response: Domain Name: &lt;domain&gt; FRUs Name:
&lt;fru&gt; . . . .</p>

<p>info &lt;fru&gt; - Dump information about a FRU</p>

<p>Response: **FRU INFO**</p>

<p>areainfo &lt;fru&gt; - Dump the info about the FRUs
areas</p>

<p>Response: FRU Name: &lt;fru&gt; FRU Length:
&lt;integer&gt; Area Name: &lt;area name&gt; Number:
&lt;integer&gt; Offset: &lt;integer&gt; Length:
&lt;integer&gt; Used Length: &lt;Integer&gt; . .</p>

<p>write &lt;fru&gt; - Write the local FRU data out into
the FRU</p>

<p>Response: FRU written: &lt;fru&gt;</p>

<p>close &lt;fru&gt; - Delete the FRU</p>

<p>Response: FRU deleted: &lt;fru&gt;</p>

<p>setval &lt;fru&gt; &lt;name&gt; [num] value - Set the
value of a FRU element. The name is the record name, or
multi-record. The number is required for fields that need it
(custom and multi-record). The value is an a sin- gle value
for integers. For strings it is a string type (either
binary, ascii, or unicode) and the info. Binary and unicode
data is specified as numbers. ascii data is specified in a
string. Note that setting a ascii value with no string will
clear the value. Zero length strings and data is valid.</p>

<p>Response: FRU value set: &lt;fru&gt;</p>

<p>area_offset &lt;fru&gt; &lt;area name&gt; &lt;offset&gt;
- Set the offset of the given area to the given value. Area
names are internal_data, chassis_info, board_info,
product_info, and multi_record.</p>

<p>Response: FRU area offset set: &lt;fru&gt;</p>

<p>area_length &lt;fru&gt; &lt;area name&gt; &lt;length&gt;
- Set the length of the given area to the given value. Area
names are internal_data, chassis_info board_info,
product_info, and multi_record</p>

<p>Response: FRU area length set: &lt;fru&gt;</p>

<p>area_add &lt;fru&gt; &lt;area name&gt; &lt;offset&gt;
&lt;length&gt; - Add the given area to the FRU.</p>

<p>Response: FRU area added: &lt;fru&gt;</p>

<p>area_delete &lt;fru&gt; &lt;area name&gt; - Delete the
given area from the FRU</p>

<p>Response: FRU area deleted: &lt;fru&gt;</p>

<p>entity These commands deal with entity objects.</p>

<p>list &lt;entity&gt; - List all the entities that meed
the criteria</p>

<p>Response: Domain Name: &lt;domain&gt; Entities Name:
&lt;entity&gt; . . . .</p>

<p>info &lt;entity&gt; - Dump information about an
entity.</p>

<p>Reponse: Entity Name: &lt;entity&gt; **ENTITY INFO** .
.</p>

<p>fru &lt;entity&gt; - Dump the FRU information about the
given entity.</p>

<p>Reponse: Entity Name: &lt;entity&gt; FRU **FRU
INFO**</p>

<p>entity hs These commands deal with hot-swap of entities.
Note that there is no info or list command for this
subcommand.</p>

<p>get_act_time &lt;entity&gt; - Get the hot-swap
auto-activate time.</p>

<p>Response: Entity Name: &lt;entity&gt; Auto-Activation
Time: &lt;integer&gt;</p>

<p>set_act_time &lt;entity&gt; - Set the hot-swap
auto-activate time.</p>

<p>Reponse: Set act time: &lt;entity&gt;</p>

<p>get_deact_time &lt;entity&gt; - Get the hot-swap
auto-deactivate time Response: Entity Name: &lt;entity&gt;
Auto-Deactivation Time: &lt;integer&gt;</p>

<p>set_deact_time &lt;entity&gt; - Set the hot-swap
auto-deactivate time</p>

<p>Response: Set deact time: &lt;entity&gt;</p>

<p>activation_request &lt;entity&gt; - Act like a user
requested an activation of the entity. This is generally
equivalent to closing the handle latch or something like
that.</p>

<p>Response: Activation requested: &lt;entity&gt;</p>

<p>activate &lt;entity&gt; - activate the given entity</p>

<p>Response: Activated: &lt;entity&gt;</p>

<p>deactivate &lt;entity&gt; - deactivate the given
entity</p>

<p>Response: Deactivated: &lt;entity&gt;</p>

<p>state &lt;entity&gt; - Return the current hot-swap state
of the given entity.</p>

<p>Response: Entity Name: &lt;entity&gt; State:
&lt;hot-swap state&gt;</p>

<p>check &lt;entity&gt; - Audit the entitys hot-swap
state</p>

<p>Response: Check started: &lt;entity&gt;</p>

<p>sensor get &lt;sensor&gt; - Get the sensors current
reading.</p>

<p>Response: Sensor Name: &lt;sensor&gt; Event Messages
Enabled: &lt;bool&gt; Sensor Scanning Enabled: &lt;bool&gt;
Initial Update In Progress: &lt;bool&gt; For threshold
sensors, the following will be output: %Value:
&lt;double&gt; %Raw Value: &lt;integer&gt; Threshold Name:
&lt;threshold&gt; Out Of Range: &lt;bool&gt; For discrete
sensors, the following will be output: Event Offset:
&lt;integer&gt; %Name: &lt;string name of event offset&gt;
Set: &lt;bool&gt; The name field may be custom and is not
explicitly specified.</p>

<p>rearm &lt;sensor&gt; global | &lt;threshold enable&gt;
[&lt;threshold enable&gt; ..] | &lt;discrete enable&gt;
[&lt;discrete enable&gt; ..] - Rearm the sensor. If global
is specified, then rearm all events in the sensor.
Otherwise, if it is a threshold sensor, then put in a list
of threshold enables. If it is a discrete sensor, then put
in a list of discrete enables.</p>

<p>Response: Rearm done: &lt;sensor&gt;</p>

<p>get_thresholds &lt;sensor&gt; - Get the sensors
thresholds</p>

<p>Response: Sensor Name: &lt;sensor&gt; Threshold Name:
&lt;threshold&gt; Value: &lt;double&gt;</p>

<p>set_thresholds &lt;sensor&gt; &lt;threshold&gt;
&lt;value&gt; ... - Set the sensors thresholds to the given
values. If a threshold is not specified, it will not be
modified. Thresholds are un, uc, ur, lr, lc, ln. The u
stands for upper, l for lower, n for non-critical, c for
critical, and r for non-recoverable. The value is floating
point.</p>

<p>Response: Thresholds set: &lt;sensor&gt;</p>

<p>get_hysteresis &lt;sensor&gt; - Get the sensor s
hysteresis values</p>

<p>Response: Sensor Name: &lt;sensor&gt; Positivie
Hysteresis: &lt;integer&gt; Negative Hysteresis:
&lt;integer&gt;</p>

<p>set_hysteresis &lt;sensor&gt; &lt;pos hyst&gt; &lt;neg
hyst&gt; - Set the sensors hys- teresis to the given values.
These are raw integer value; hystersis is specified as a raw
value and it cannot be converted to floating point because
the function may be non-linear.</p>

<p>Response: Hysteresis set: &lt;sensor&gt;</p>

<p>get_event_enables &lt;sensor&gt; - Get the sensors event
enable values</p>

<p>Response: Sensor Name: &lt;sensor&gt; Event Messages
Enabled: &lt;bool&gt; Sensor Scanning Enabled: &lt;bool&gt;
Busy: &lt;bool&gt; Threshold sensors report: Threshold Name:
&lt;threshold&gt; Enabled: &lt;bool&gt; . . only supported
thresholds are listed. Discrete sensors report: Event
Offset: &lt;integer&gt; Name: &lt;event offset name for
sensor&gt; %Assertion Enabled: &lt;bool&gt; %Deassertion
Enabled: &lt;bool&gt; only supported offsets are listed. The
assertion and deassertion enables are listed only if the
offset support them.</p>

<p>set_event_enables &lt;sensor&gt; msg|nomsg scan|noscan
[&lt;enable&gt; [&lt;enable&gt; ...]] - Set the sensors
event enable values. This turns sensor mes- sages and
scanning on and off and will enable all the listed enables
and disable all over ones. The enables are either a
&lt;threshold enable&gt; or a &lt;discrete enable&gt;.</p>

<p>Response: Event enables set: &lt;sensor&gt;</p>

<p>enable_events &lt;sensor&gt; msg|nomsg scan|noscan
[&lt;enable&gt; [&lt;enable&gt; ...]] - Enable event enable
values. This turns sensor messages and scanning on and off
and will enable all the listed enables. All other enables
will be left alone. The enables are either a &lt;threshold
enable&gt; or a &lt;discrete enable&gt;.</p>

<p>Response: Event enables set: &lt;sensor&gt;</p>

<p>disable_events &lt;sensor&gt; msg|nomsg scan|noscan
[&lt;enable&gt; [&lt;enable&gt; ...]] - Disable event enable
values. This turns sensor messages and scanning on and off
and will disable all the listed enable. All other enables
will be left alone. The enables are either a &lt;threshold
enable&gt; or a &lt;discrete enable&gt;.</p>

<p>Response: Event enables set: &lt;sensor&gt;</p>

<p>control Commands dealing with controls.</p>

<p>set &lt;control&gt; &lt;value&gt; [&lt;value&gt; ..] -
Set the value of a control. The settings depend on control
type, most take one or more integer values depending on the
number of physical things the control contains. An
identifier type takes one or more unsigned characters. A
light set with settings take the form lc|nolc &lt;color&gt;
&lt;on time&gt; &lt;off time&gt; lc and nolc turn on or of
local control, the over values should be obvious. Note all
lights support local control, you need to see if it supports
the value.</p>

<p>Response: Set done: &lt;control&gt;</p>

<p>get &lt;control&gt; - Get the value of a control. The
reponse depends on the control type.</p>

<p>Response: Control Name: &lt;control&gt; Response for
setting lights is: Light Num: 0 Local Control: &lt;bool&gt;
%Color: &lt;color&gt; %On Time: &lt;integer&gt; %Off Time:
&lt;integer&gt; Note that multiple lights may be present if
the control supports multi- ple lights. The options values
(marked with % ) will not be present if local control is set
to true. Local control means that the LED takes whatever
default function it does on the device (like disk activity,
ethernet activity, hot-swap LED, etc.). Response for id
control: Data: &lt;byte1&gt; &lt;byte2&gt; ... Response for
other controls: Value Num: &lt;integer&gt; Value:
&lt;integer&gt; There will be one Value for each value the
control supports.</p>

<p>mc Commands dealing with MC objects.</p>

<p>reset &lt;warm | cold&gt; &lt;mc&gt; - Do a warm or cold
reset on the given MC</p>

<p>Response: Reset done: &lt;mc&gt;</p>

<p>msg &lt;mc&gt; &lt;LUN&gt; &lt;NetFN&gt; &lt;Cmd&gt;
[data...] - Send the given command to the management
controller and display the response.</p>

<p>Response: MC: &lt;mc&gt; LUN: &lt;lun&gt; NetFN:
&lt;netfn&gt; command: &lt;cmd&gt; Data: &lt;data
bytes&gt;</p>

<p>set_events_enable &lt;mc&gt; &lt;enable | disable&gt; -
enables or disables events on the MC.</p>

<p>Response: Events enable done: &lt;mc&gt;</p>

<p>get_events_enable &lt;mc&gt; - Prints out if the events
are enabled for the given MC.</p>

<p>Response: Events Enable: &lt;bool&gt;</p>

<p>sdrs &lt;mc&gt; &lt;main | sensor&gt; - list the SDRs
for the mc. Either gets the main SDR repository or the
sensor SDR repository.</p>

<p>Response: MC Name: &lt;mc&gt; SDR Record ID:
&lt;integer&gt; Type: &lt;integer&gt; Version:
&lt;integer&gt;.&lt;integer&gt; Data: &lt;data bytes&gt; One
SDR will be present for each SDR in the repository.</p>

<p>get_sel_time &lt;mc&gt; - Get the time in the SEL for
the given MC.</p>

<p>Response: MC Name: &lt;mc&gt; SEL Time:
&lt;integer&gt;</p>

<p>set_sel_time &lt;mc&gt; &lt;time&gt; - Set the time in
the SEL for the given MC.</p>

<p>Response: MC SEL time set Name: &lt;mc&gt;</p>

<p>rescan_sel &lt;mc&gt; - Rescan the SEL in the MC.</p>

<p>Response: SEL Rescan done: &lt;mc&gt;</p>

<p>sel_rescan_time &lt;mc&gt; &lt;time in seconds&gt; - Set
the time between SEL res- cans for the SEL on this MC. Zero
disables scans.</p>

<p>Response: MC SEL rescan time set: &lt;domain&gt;</p>

<p>sel_info &lt;mc&gt; - Dump information about the MCs
SEL.</p>

<p>Response: MC Name: &lt;mc&gt; SEL Version:
&lt;integer&gt;.&lt;integer&gt; SEL Count: &lt;integer&gt;
SEL Slots Used: &lt;integer&gt; SEL Free Bytes:
&lt;integer&gt; SEL Last Addition Timestamp: &lt;integer&gt;
SEL overflow: &lt;bool&gt; SEL Supports Delete: &lt;bool&gt;
SEL Supports Partial Add: &lt;bool&gt; SEL Supports Reserve:
&lt;bool&gt; SEL Supports Get SEL Allocation:
&lt;bool&gt;</p>

<p>chan info &lt;mc&gt; &lt;channel&gt; - Dump information
about the MCs channel.</p>

<p>Response: Channel Info MC: &lt;mc&gt; Number:
&lt;integer&gt; Medium: &lt;integer&gt; Protocol Type:
&lt;integer&gt; Session Support:
session-less|single-session|multi-session|session-based
Vendor ID: &lt;data bytes&gt; Aux Info: &lt;data
bytes&gt;</p>

<p>chan get_access &lt;mc&gt; &lt;channel&gt;
non-volatile|present|both - Dump infor- mation about the MC
s channel access. There are two different places where this
is stored, the present in-use values (volatile) and the non-
volatile storage that is loaded at startup. Note if you
specify chan- nel 0xe, the response channel will be
different; it will be the current channel.</p>

<p>Response: Channel Access MC: &lt;mc&gt; Channel:
&lt;integer&gt; Type: non-volatile|present Alerting Enabled:
&lt;bool&gt; Per-Message Auth: &lt;bool&gt; User Auth:
&lt;bool&gt; Access Mode: disable|pre-boot|always|shared
Privilege Limit: callback|user|operator|admin|oem</p>

<p>chan set_access &lt;mc&gt; &lt;channel&gt;
non-volatile|present|both &lt;parm&gt; &lt;value&gt; ... -
Set information about the MC s channel access. There are two
different places where this is stored, the present in-use
values (volatile) and the non-volatile storage that is
loaded at startup. Note if you specify channel 0xe, the
modified channel will be the cur- rent channel. Parms are:
alert true|false msg_auth true|false user_auth true|false
access_mode disabled|pre-boot|always|shared privilege_limit
callback|user|operator|admin|oem</p>

<p>Response: Channel Access Set MC: &lt;mc&gt; Channel:
&lt;integer&gt;</p>

<p>chan user list &lt;mc&gt; &lt;channel&gt; [&lt;user
num&gt;] - List users associated with the channel. Each user
number has an associated name and password that is global in
the MC (not associated with a channel). There is also
channel-specific information for each user. This command
lists the global user information and the channel-specific
information for the channel specified. If no user number is
listed, then all users for the channel are listed. Otherwise
only the given user is listed.</p>

<p>Response: Channel Access Set MC: &lt;mc&gt; Channel:
&lt;integer&gt; Max User: &lt;integer&gt; Enabled Users:
&lt;integer&gt; Fixed Users: &lt;integer&gt; User Number:
&lt;integer&gt; *String Name: &lt;string&gt; *Binary Name:
&lt;data bytes&gt; Link Auth Enabled: &lt;bool&gt; Msg Auth
Enabled: &lt;bool&gt; Access CB Only: &lt;bool&gt; Privilege
Limit: &lt;integer&gt; Session Limit: &lt;integer&gt; . .
All the users are listed. One of string name or binary name
is present, if the name is not a printable string, then the
binary data is dumped.</p>

<p>chan user set &lt;mc&gt; &lt;channel&gt; &lt;user
num&gt; &lt;parm&gt; &lt;value&gt; ... - Set information
about the user number. Only the specified values are modi-
fied. The name and password are global values, all other are
channel- specific. The parms are: are: link_enabled
true|false msg_enabled true|false cb_only true|false
privilege_limit callback|user|operator|admin|oem|no_access
session_limit &lt;integer&gt; name &lt;user name string&gt;
password &lt;password string, &lt;= 16 characters&gt;
password2 &lt;password string, &lt;= 20 characters&gt;
enable disable The password is the 16-byte IPMI 1.5
passwords., the password2 is for 20-byte IPMI 2.0 passwords.
Note that setting the session limit to zero means there is
no session limit. Also note that some systems have a bug
where the session limit is not optional (as the spec says it
is). If you get C7 errors back from this command, you will
have to always specify the session limit. Note that you must
enable the user for it to work, but there seems to be no way
to get if the user is enabled or not.</p>

<p>Response: User Info Set: &lt;mc&gt;</p>

<p>sel Commands dealing with the system event log. Note
that there is no info command.</p>

<p>list &lt;domain&gt; - The list command is unique in this
object, so it is specified explicitly here. List the local
copy of the system event log for the entire domain.</p>

<p>Response: Domain Name: &lt;domain&gt; Entries:
&lt;integer&gt; Slots in use: &lt;integer&gt; Event **EVENT
INFO** . .</p>

<p>mc_list &lt;domain&gt; - List the local copy of the
system event log on the given MC.</p>

<p>Response: MC Name: &lt;mc&gt; Entries: &lt;integer&gt;
Slots in use: &lt;integer&gt; Event **EVENT INFO** . .</p>

<p>delete &lt;mc&gt; &lt;record #&gt; - Delete the given
event number from the SEL</p>

<p>Response: Event deleted MC: &lt;mc&gt; Record:
&lt;integer&gt;</p>

<p>add &lt;mc&gt; &lt;type&gt; &lt;13 bytes of data&gt; -
Add the event data to the SEL.</p>

<p>Response: MC Name: &lt;mc&gt; Record ID:
&lt;integer&gt;</p>

<p>clear &lt;domain&gt; - clear the system event log</p>

<p>Response: SEL Clear done: &lt;domain&gt;</p>

<p>con Commands dealing with connections.</p>

<p>activate &lt;connection&gt; - Activate the given
connection</p>

<p>Response: Connection activated: &lt;connection&gt;</p>

<p>pet Commands dealing with platform event traps.</p>

<p>new &lt;domain&gt; &lt;connection&gt; &lt;channel&gt;
&lt;ip addr&gt; &lt;mac_addr&gt; &lt;eft selector&gt;
&lt;policy num&gt; &lt;apt selector&gt; &lt;lan dest
selector&gt; - Set up the domain to send PET traps from the
given connection to the given IP/MAC address over the given
channel.</p>

<p>Response: PET Created: &lt;pet&gt;</p>

<p>mcnew &lt;mc&gt; &lt;channel&gt; &lt;ip addr&gt;
&lt;mac_addr&gt; &lt;eft selector&gt; &lt;policy num&gt;
&lt;apt selector&gt; &lt;lan dest selector&gt; - Set up the
domain to send PET traps from the given connection to the
given IP/MAC address over the given channel. This takes an
MC instead of a connection.</p>

<p>Response: PET Created: &lt;pet&gt;</p>

<p>close &lt;pet&gt; - Close the pet.</p>

<p>Response: PET destroyed: &lt;pet&gt;</p>

<p>pef commands dealing with platform even filters. These
are basically con- nections to the PEF configuration
parameters in an MC. You use a pef to fetch a pef config,
which you can then modify and write back to the MC. Note
that when you get a pef config, you claim a lock on the MC
that must be unlocked.</p>

<p>new &lt;mc&gt; - Create a pef for the given MC.</p>

<p>Response: PEF: &lt;pef&gt;</p>

<p>unlock_mc &lt;mc&gt; - Unlock the PEF lock on the given
MC.</p>

<p>Response: PEF unlocked: &lt;mc&gt;</p>

<p>close &lt;pef&gt; - Free the given pef</p>

<p>Response: PEF destroyed: &lt;pef&gt;</p>

<p>pef config Commands dealing with PEF configurations.
These are the actual PEF data items.</p>

<p>get &lt;pef&gt; - Fetch the pef data items from the pef
and create a pef con- fig.</p>

<p>Response: PEF Config Name: &lt;pef config&gt; **PEF
CONFIG**</p>

<p>update &lt;pef config&gt; &lt;parm&gt; [selector]
&lt;value&gt; - Set the given parameter in the pef config to
the given value. If the parameter has a selector of some
type, the selector must be given, otherwise no selector
should be given.</p>

<p>Response: PEF config updated: &lt;pef config&gt;</p>

<p>set &lt;pef&gt; &lt;pef config&gt; - Write the pef data
back to the pef. Note that this must be the same pef used to
create the config.</p>

<p>Response: PEF config set: &lt;pef config&gt;</p>

<p>unlock &lt;pef&gt; &lt;pef config&gt; - Unlock the lock
in the MC and mark the pef config as unlocked.</p>

<p>Response: PEF config unlocked: &lt;pef config&gt;</p>

<p>close &lt;pef config&gt; - Free the pef config.</p>

<p>Response: PEF config destroyed: &lt;pef config&gt;</p>

<p>lanparm Commands dealing with lanparms. These are
basically connections to the LAN configuration parameters in
an MC. You use a lanparm to fetch a lanparm config, which
you can then modify and write back to the MC. Note that when
you get a lanparm config, you claim a lock on the MC that
must be unlocked.</p>

<p>new &lt;mc&gt; &lt;channel&gt; - Create a lanparm for
the given MC and channel.</p>

<p>Response: LANPARM: &lt;lanparm&gt;</p>

<p>unlock_mc &lt;mc&gt; &lt;channel&gt; - Unlock the
lanparm lock on the given MC and channel.</p>

<p>Response: LANPARM unlocked: &lt;mc&gt;</p>

<p>close &lt;lanparm&gt; - Free the given lanparm</p>

<p>Response: LANPARM destroyed: &lt;lanparm&gt;</p>

<p>lanparm config Commands dealing with lanparm
configurations. These are the actual lanparm data items.</p>

<p>get &lt;lanparm&gt; - Fetch the lanparm data items from
the lanparm and cre- ate a lanparm config.</p>

<p>Response: LANPARM Config Name: &lt;lanparm config&gt;
**LANPARM CONFIG**</p>

<p>set &lt;lanparm&gt; &lt;lanparm config&gt; - Write the
lanparm data back to the lanparm. Note that this must be the
same lanparm used to create the config.</p>

<p>Response: LANPARM config set: &lt;lanparm config&gt;</p>

<p>unlock &lt;lanparm&gt; &lt;lanparm config&gt; - Unlock
the lock in the MC and mark the lanparm config as
unlocked.</p>

<p>Response: LANPARM config unlocked: &lt;lanparm
config&gt;</p>

<p>close &lt;lanparm config&gt; - Free the lanparm
config.</p>

<p>Response: LANPARM config destroyed: &lt;lanparm
config&gt;</p>

<p>OTHER COMMANDS A few general commands exist.</p>

<p>evinfo &lt;bool&gt; - Turn on or off dumping object
information when an event comes in. This is false by
default.</p>

<p>debug &lt;type&gt; &lt;bool&gt; - Turn the given
debugging type on or off</p>

<p>EVENTS The command language will output events to the
console when they hap- pen. Events all occur in the format:
Event **EVENT INFO**</p>

<p>The event info varies on the type of events. The defined
events are listed below. Note that the output of some events
depends on the set- ting of the evinfo command; the
information about the object itself may or may not be
output.</p>

<p>Some events have another event container; this is the
IPMI event that caused the event to be output.</p>

<p>The following event is output when the domain is
completely up and operational and finished all it SDR, FRU,
and bus scans: EVENT Object Type: Domain Name:
&lt;domain&gt; Operation: Domain fully up Connection Number:
&lt;integer&gt; Port Number: &lt;integer&gt; Any Connection
Up: &lt;bool&gt; Error: &lt;integer&gt;</p>

<p>The following comes out when domain connection
infomration changes: EVENT Object Type: Domain Name:
&lt;domain&gt; Operation: Connection Change</p>

<p>The following comes out when domains are added: EVENT
Object Type: Domain Name: &lt;domain&gt; Operation: Add
%**DOMAIN INFO**</p>

<p>The following comes out when domains are destroyed:
EVENT Object Type: Domain Name: &lt;domain&gt; Operation:
Delete</p>

<p>The following comes out when the domain gets an event
that does not have a handler: EVENT Object Type: Event
**EVENT INFO**</p>

<p>The following comes out when an entity is added: EVENT
Object Type: Entity Name: &lt;entity&gt; Operation: Add
%**ENTITY INFO**</p>

<p>The following comes out when an entity is deleted: EVENT
Object Type: Entity Name: &lt;entity&gt; Operation:
Delete</p>

<p>The following comes out when an entity is changed: EVENT
Object Type: Entity Name: &lt;entity&gt; Operation: Change
%**ENTITY INFO**</p>

<p>The following comes out when an entitys FRU is added:
EVENT Object Type: Entity FRU Name: &lt;entity&gt;
Operation: Add %**FRU INFO**</p>

<p>The following comes out when an entitys FRU is deleted:
EVENT Object Type: Entity FRU Name: &lt;entity&gt;
Operation: Delete</p>

<p>The following comes out when an entitys FRU is changed:
EVENT Object Type: Entity FRU Name: &lt;entity&gt;
Operation: Change %**FRU INFO**</p>

<p>The following comes out when an entitys presence
changes: EVENT Object Type: Entity Name: &lt;entity&gt;
Operation: Presence Change Present: &lt;bool&gt; %Event
**EVENT INFO**</p>

<p>The following comes out when an entitys hot-swap state
changes: EVENT Object Type: Entity Name: &lt;entity&gt;
Operation: Hot-Swap Change Last State: &lt;hot-swap
state&gt; State: &lt;hot-swap state&gt; %Event **EVENT
INFO**</p>

<p>The following comes out when an MC is added: EVENT
Object Type: MC Name: &lt;mc&gt; Operation: Add %**MC
INFO**</p>

<p>The following comes out when an MC is removed: EVENT
Object Type: MC Name: &lt;mc&gt; Operation: Delete</p>

<p>The following comes out when an MC is changed: EVENT
Object Type: MC Name: &lt;mc&gt; Operation: Change %**MC
INFO**</p>

<p>The following comes out when an MC changes active state:
EVENT Object Type: MC Name: &lt;mc&gt; Operation: Active
Changed Active: &lt;bool&gt;</p>

<p>The following comes out when a discrete sensor gets an
event: EVENT Object Type: Sensor Name: &lt;sensor&gt;
Operation: Event Offset: &lt;integer&gt; Direction:
assertion | deassertion Severity: &lt;integer&gt; Previous
Severity: &lt;integer&gt; %Event **EVENT INFO**</p>

<p>The following comes out when a threshold sensor gets an
event: EVENT Object Type: Sensor Name: &lt;sensor&gt;
Operation: Event Threshold: &lt;threshold&gt; High/Low:
going-high | going-low Direction: assertion | deassertion
%Value: &lt;double&gt; %Raw Value: &lt;integer&gt; %Event
**EVENT INFO**</p>

<p>The following comes out when a sensor is added: EVENT
Object Type: Sensor Name: &lt;sensor&gt; Operation: Add
%**SENSOR INFO**</p>

<p>The following comes out when a sensor is deleted: EVENT
Object Type: Sensor Name: &lt;sensor&gt; Operation:
Delete</p>

<p>The following comes out when a sensor is changed: EVENT
Object Type: Sensor Name: &lt;sensor&gt; Operation: Change
%**SENSOR INFO**</p>

<p>The following comes out when a control gets an event:
EVENT Object Type: Control Name: &lt;control&gt; Operation:
Event Value Number: &lt;integer&gt; Value: &lt;integer&gt;
%Event **EVENT INFO**</p>

<p>The following comes out when a control is added: EVENT
Object Type: Control Name: &lt;control&gt; Operation: Add
%**CONTROL INFO**</p>

<p>The following comes out when a control is deleted: EVENT
Object Type: Control Name: &lt;control&gt; Operation:
Delete</p>

<p>The following comes out when a control is changed: EVENT
Object Type: Control Name: &lt;control&gt; Operation: Change
%**CONTROL INFO**</p>

<p>OBJECT INFO Many of the command responses and events
contain information about an objects. The definitions of
this information output is done here.</p>

<p>**EVENT INFO** MC: &lt;mc&gt; Record ID: &lt;integer&gt;
Event type: &lt;integer&gt; Timestamp: &lt;integer&gt; Data:
&lt;data bytes&gt;</p>

<p>**DOMAIN INFO** Type: &lt;domain type&gt; GUID: &lt;hex
string&gt; SEL Rescan Time: &lt;time&gt; IPMB Rescan Time:
&lt;time&gt;</p>

<p>**ENTITY INFO** Type: unknown | mc | fru | generic
Present: &lt;bool&gt; Presence sensor always there:
&lt;bool&gt; Hot swappable: &lt;bool&gt; %Supports managed
hot swap: &lt;bool&gt; %Parents Name: &lt;entity&gt; Name:
&lt;entity&gt; . . %Children Name: &lt;entity&gt; Name:
&lt;entity&gt; . . %Physical Slot: &lt;integer&gt; %Id:
&lt;string&gt; Entity ID String: &lt;string&gt;</p>

<p>Note that Parents and Children fields will not be
present if the entity has no parents or children. Each
entity type except unknown will have its own output info.
These are:</p>

<p>mc Channel: &lt;channel&gt; LUN: &lt;lun&gt; OEM:
&lt;oem field from SDR&gt; Slave Address: &lt;ipmb&gt;
ACPI_system_power_notify_required: &lt;bool&gt;
ACPI_device_power_notify_required: &lt;bool&gt;
controller_logs_init_agent_errors: &lt;bool&gt;
log_init_agent_errors_accessing: &lt;bool&gt; global_init:
&lt;bool&gt; chassis_device: &lt;bool&gt; bridge:
&lt;bool&gt; IPMB_event_generator: &lt;bool&gt;
IPMB_event_receiver: &lt;bool&gt; FRU_inventory_device:
&lt;bool&gt; SEL_device: &lt;bool&gt; SDR_repository_device:
&lt;bool&gt; sensor_device: &lt;bool&gt;</p>

<p>fru Channel: &lt;channel&gt; LUN: &lt;lun&gt; OEM:
&lt;oem field from SDR&gt; Slave Address: &lt;ipmb&gt;
access_address: &lt;ipmb&gt; private_bus_id: &lt;integer&gt;
device_type: &lt;integer&gt; device_modifier:
&lt;integer&gt; is_logical_fru: &lt;bool&gt; fru_device_id:
&lt;integer&gt;</p>

<p>generic Channel: &lt;channel&gt; LUN: &lt;lun&gt; OEM:
&lt;oem field from SDR&gt; access_address: &lt;ipmb&gt;
private_bus_id: &lt;integer&gt; device_type: &lt;integer&gt;
device_modifier: &lt;integer&gt; slave_address: &lt;ipmb&gt;
address_span: &lt;integer&gt;</p>

<p>**MC INFO** Active: &lt;bool&gt; GUID: &lt;hex
string&gt; SEL Rescan Time: &lt;integer&gt;
provides_device_sdrs: &lt;bool&gt; device_available:
&lt;bool&gt; chassis_support: &lt;bool&gt; bridge_support:
&lt;bool&gt; ipmb_event_generator: &lt;bool&gt;
ipmb_event_receiver: &lt;bool&gt; fru_inventory_support:
&lt;bool&gt; sel_device_support: &lt;bool&gt;
sdr_repository_support: &lt;bool&gt; sensor_device_support:
&lt;bool&gt; device_id: &lt;ipmb&gt; device_revision:
&lt;integer&gt; fw_revision: &lt;integer&gt;.&lt;integer&gt;
version: &lt;integer&gt;.&lt;integer&gt; manufacturer_id:
&lt;integer&gt; product_id: &lt;integer&gt; aux_fw_revision:
&lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
&lt;integer&gt;</p>

<p>*SENSOR INFO** LUN: &lt;integer&gt; Number:
&lt;integer&gt; Event Reading Type: &lt;integer&gt; Event
Reading Type Name: one of: unspecified threshold
discrete_usage discrete_state discrete_predictive_failure
discrete_limit_exceeded discrete_performance_met
discrete_severity discrete_device_presense
discrete_device_enable discrete_availability
discrete_redundancy discrete_acpi_power Type:
&lt;integer&gt; Type Name: &lt;sensor type (a generic
string)&gt; %Direction: input | output %Event Support: per
state | entire sensor | global Init Scanning: &lt;bool&gt;
Init Events: &lt;bool&gt; Init Thresholds: &lt;bool&gt; Init
Hysteresis: &lt;bool&gt; Init Type: &lt;bool&gt; Init Power
Up Events: &lt;bool&gt; Init Power Up Scanning: &lt;bool&gt;
Ignore If No Entity: &lt;bool&gt; Auto Rearm: &lt;bool&gt;
OEM1: &lt;integer&gt; Id: &lt;string&gt;</p>

<p>For threshold sensors, the following exist: Threshold
Access: none | readable | settable | fixed Threshold Name:
&lt;threshold&gt; Readable: &lt;bool&gt; Settable:
&lt;bool&gt; Supports: going high assertion | going low
assertion | going high deassertion | going low deassertion .
. Hysteresis Support: none | readable | settable | fixed
%Nominal Reading: &lt;float&gt; %Normal Max: &lt;float&gt;
%Normal Min: &lt;float&gt; %Sensor Max: &lt;float&gt;
%Sensor Min: &lt;float&gt; Base Unit: &lt;integer&gt; Base
Unit Name: &lt;string&gt; %Rate Unit: &lt;integer&gt; %Rate
Unit Name: &lt;string&gt; %Modifier Use: / | * %Modifier
Unit: &lt;integer&gt; %Modifier Unit Name:
&lt;string&gt;</p>

<p>For discrete sensors, the following exist: Event Offset:
&lt;integer&gt; Supports: assertion | deassertion . .</p>

<p>**CONTROL INFO** Type: &lt;control type&gt; Generates
Events: &lt;bool&gt; Settable: &lt;bool&gt; Readable:
&lt;bool&gt; Num Values: &lt;integer&gt; Id:
&lt;string&gt;</p>

<p>Controls of type light that are set with settings have
the following: Set with: settings Local Control:
&lt;bool&gt; Color: &lt;color&gt; . . One color is listed
for each supported color</p>

<p>Controls of type light that are set with transitions
have the follow- ing: Light Number: &lt;integer&gt; Num
Values: &lt;integer&gt; Value Number: &lt;integer&gt; Num
Transitions: &lt;integer&gt; Transition Number:
&lt;integer&gt; Color: &lt;color&gt; Time: &lt;integer&gt; .
. . .</p>

<p>Controls of type identifier have the following: Max
Length: &lt;integer&gt;</p>

<p>**FRU INFO** Name: &lt;fru&gt; record Name: &lt;name&gt;
Type: binary | ascii | unicode | integer %Number:
&lt;integer&gt; Data: data depending on type . .
Multi-record Number: &lt;integer&gt; Type: binary | ascii |
unicode Data: &lt;data in the above format&gt; . .</p>

<p>**LANPARM CONFIG** support_auth_oem: &lt;bool&gt;
support_auth_straight: &lt;bool&gt; support_auth_md5:
&lt;bool&gt; support_auth_md2: &lt;bool&gt;
support_auth_none: &lt;bool&gt; ip_addr_source:
&lt;integer&gt; num_alert_destinations: &lt;integer&gt;
%ipv4_ttl: &lt;integer&gt; %ipv4_flags: &lt;integer&gt;
%ipv4_precedence: &lt;integer&gt; %ipv4_tos: &lt;integer&gt;
%ip_addr: &lt;ip addr&gt; %mac_addr: &lt;mac addr&gt;
%subnet_mask: &lt;ip addr&gt; %primary_rmcp_port
&lt;integer&gt; %secondary_rmcp_port &lt;integer&gt;
%bmc_generated_arps: &lt;bool&gt; %bmc_generated_garps:
&lt;bool&gt; %garp_interval: &lt;integer&gt;
%default_gateway_ip_addr: &lt;ip addr&gt;
%default_gateway_mac_addr: &lt;mac addr&gt;
%backup_gateway_ip_addr: &lt;ip addr&gt;
%backup_gateway_mac_addr: &lt;mac addr&gt; community_string:
&lt;string&gt; User Name: callback enable_auth_oem:
&lt;bool&gt; enable_auth_straight: &lt;bool&gt;
enable_auth_md5: &lt;bool&gt; enable_auth_md2: &lt;bool&gt;
enable_auth_none: &lt;bool&gt; User Name: user
enable_auth_oem: &lt;bool&gt; enable_auth_straight:
&lt;bool&gt; enable_auth_md5: &lt;bool&gt; enable_auth_md2:
&lt;bool&gt; enable_auth_none: &lt;bool&gt; User Name:
operator enable_auth_oem: &lt;bool&gt; enable_auth_straight:
&lt;bool&gt; enable_auth_md5: &lt;bool&gt; enable_auth_md2:
&lt;bool&gt; enable_auth_none: &lt;bool&gt; User Name: admin
enable_auth_oem: &lt;bool&gt; enable_auth_straight:
&lt;bool&gt; enable_auth_md5: &lt;bool&gt; enable_auth_md2:
&lt;bool&gt; enable_auth_none: &lt;bool&gt; User Name: oem
enable_auth_oem: &lt;bool&gt; enable_auth_straight:
&lt;bool&gt; enable_auth_md5: &lt;bool&gt; enable_auth_md2:
&lt;bool&gt; enable_auth_none: &lt;bool&gt; Alert
Destination Number: &lt;integer&gt; alert_ack: &lt;bool&gt;
dest_type: &lt;integer&gt; alert_retry_interval:
&lt;integer&gt; max_alert_retries: &lt;integer&gt;
dest_format: &lt;integer&gt; gw_to_use: &lt;integer&gt;
dest_ip_addr: &lt;ip addr&gt; dest_mac_addr: &lt;mac
addr&gt; . .</p>

<p>**PEF CONFIG** alert_startup_delay_enabled: &lt;bool&gt;
startup_delay_enabled: &lt;bool&gt; event_messages_enabled:
&lt;bool&gt; pef_enabled: &lt;bool&gt;
diagnostic_interrupt_enabled: &lt;bool&gt;
oem_action_enabled: &lt;bool&gt; power_cycle_enabled:
&lt;bool&gt; reset_enabled: &lt;bool&gt; power_down_enabled:
&lt;bool&gt; alert_enabled: &lt;bool&gt; %startup_delay:
&lt;integer&gt; %alert_startup_delay: &lt;integer&gt;
guid_enabled: &lt;bool&gt; guid_val: &lt;guid&gt;
num_event_filters: &lt;integer&gt; num_alert_policies:
&lt;integer&gt; num_alert_strings: &lt;integer&gt; Event
Filter Number: &lt;integer&gt; enable_filter: &lt;bool&gt;
filter_type: &lt;integer&gt; diagnostic_interrupt:
&lt;bool&gt; oem_action: &lt;bool&gt; power_cycle:
&lt;bool&gt; reset: &lt;bool&gt; power_down: &lt;bool&gt;
alert: &lt;bool&gt; alert_policy_number: &lt;integer&gt;
event_severity: &lt;integer&gt; generator_id_addr:
&lt;integer&gt; generator_id_channel_lun: &lt;integer&gt;
sensor_type: &lt;integer&gt; sensor_number: &lt;integer&gt;
event_trigger: &lt;integer&gt; data1_offset_mask:
&lt;integer&gt; data1_mask: &lt;integer&gt; data1_compare1:
&lt;integer&gt; data1_compare2: &lt;integer&gt; data2_mask:
&lt;integer&gt; data2_compare1: &lt;integer&gt;
data2_compare2: &lt;integer&gt; data3_mask: &lt;integer&gt;
data3_compare1: &lt;integer&gt; data3_compare2:
&lt;integer&gt; . . Alert Policy Number: &lt;integer&gt;
policy_num: &lt;integer&gt; enabled: &lt;bool&gt; policy:
&lt;integer&gt; channel: &lt;integer&gt;
destination_selector: &lt;integer&gt;
alert_string_event_specific: &lt;bool&gt;
alert_string_selector: &lt;integer&gt; . . Alert String
event_filter: &lt;integer&gt; alert_string_set:
&lt;integer&gt; alert_string: &lt;string&gt; . .</p>

<p>**CONNECTION INFO** Active: &lt;bool&gt; Up:
&lt;bool&gt; Port Number: &lt;integer&gt; Info: &lt;info
string&gt; Up: &lt;bool&gt; . .</p>

<p>**PEF INFO** MC: &lt;mc&gt;</p>

<p>**PET INFO** MC: &lt;mc&gt; Channel: &lt;channel&gt; IP
Address: &lt;ip address&gt; MAC Address: &lt;mac address&gt;
EFT Selector: &lt;eft selector&gt; Policy Number: &lt;policy
number&gt; APT Selector: &lt;apt selector&gt; LAN Dest
Selector: &lt;lan dest selector&gt;</p>

<p>**LANPARM INFO** MC: &lt;mc&gt; Channel:
&lt;integer&gt;</p>

<p>SEE ALSO ipmish(1)</p>

<p>KNOWN PROBLEMS None</p>

<p>AUTHOR Corey Minyard &lt;cminyard@mvista.org&gt;</p>

<p>OpenIPMI 05/13/03 ipmi_cmdlang(7)</p>
<hr>
</body>
</html>
