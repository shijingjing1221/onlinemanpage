<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:20:55 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>KEYCTL_INSTANTIATE(3) Linux Key Management Calls
KEYCTL_INSTANTIATE(3)</p>

<p>NAME keyctl_assume_authority - Assume the authority to
instantiate a key keyctl_instantiate - Instantiate a key
keyctl_negate - Negatively instantiate a key</p>

<p>SYNOPSIS #include &lt;keyutils.h&gt;</p>

<p>long keyctl_assume_authority(key_serial_t key);</p>

<p>long keyctl_instantiate(key_serial_t key, const char
*payload, size_t plen, key_serial_t keyring);</p>

<p>long keyctl_negate(key_serial_t key, unsigned timeout,
key_serial_t keyring);</p>

<p>DESCRIPTION keyctl_assume_authority() assumes the
authority for the calling thread to deal with and
instantiate the specified uninstantiated key.</p>

<p>The calling thread must have the appopriate
authorisation key resident in one of its keyrings for this
to succeed, and that authority must not have been
revoked.</p>

<p>The authorising key is allocated by request_key() when
it needs to invoke userspace to generate a key for the
requesting process. This is then attached to one of the
keyrings of the userspace process to which the task of
instantiating the key is given:</p>

<p>requester -&gt; request_key() -&gt; instantiator</p>

<p>Calling this function modifies the way request_key()
works when called thereafter by the calling (instantiator)
thread; once the authority is assumed, the keyrings of the
initial process are added to the search path, using the
initial processs UID, GID, groups and security con-
text.</p>

<p>If a thread has multiple instantiations to deal with, it
may call this function to change the authorisation key
currently in effect. Supply- ing a zero key de-assumes the
currently assumed authority.</p>

<p>NOTE! This is a per-thread setting and not a per-process
setting so that a multithreaded process can be used to
instantiate several keys at once.</p>

<p>keyctl_instantiate() instantiates the payload of an
uninstantiated key from the data specified. payload and plen
specify the data for the new payload. payload may be NULL
and plen may be zero if the key type per- mits that. The key
type may reject the data if its in the wrong for- mat or in
some other way invalid.</p>

<p>keyctl_negate() marks a key as negatively instantiated
and sets the expiration timer on it. timeout specifies the
lifetime of the key in seconds.</p>

<p>Only a key for which authority has been assumed may be
instantiated or negatively instantiated, and once
instantiated, the authorisation key will be revoked and the
requesting process will be able to resume.</p>

<p>The destination keyring, if given, is assumed to belong
to the initial requester, and not the instantiating process.
Therefore, the special keyring IDs refer to the requesting
process s keyrings, not the caller s, and the requester s
UID, etc. will be used to access them.</p>

<p>The destination keyring can be zero if no extra link is
desired.</p>

<p>The requester, not the caller, must have write
permission on the desti- nation for a link to be made
there.</p>

<p>RETURN VALUE On success keyctl_instantiate() returns 0.
On error, the value -1 will be returned and errno will have
been set to an appropriate error.</p>

<p>ERRORS ENOKEY The key or keyring specified is
invalid.</p>

<p>EKEYEXPIRED The keyring specified has expired.</p>

<p>EKEYREVOKED The key or keyring specified had been
revoked, or the authorisa- tion has been revoked.</p>

<p>EINVAL The payload data was invalid.</p>

<p>ENOMEM Insufficient memory to store the new payload or
to expand the destination keyring.</p>

<p>EDQUOT The key quota for the keys user would be exceeded
by increasing the size of the key to accommodate the new
payload or the key quota for the keyrings user would be
exceeded by expanding the destination keyring.</p>

<p>EACCES The key exists, but is not writable by the
requester.</p>

<p>LINKING This is a library function that can be found in
libkeyutils. When linking, -lkeyutils should be specified to
the linker.</p>

<p>SEE ALSO keyctl(1), add_key(2), keyctl(2),
request_key(2), keyctl(3), request-key(8)</p>

<p>Linux 4 May 2006 KEYCTL_INSTANTIATE(3)</p>
<hr>
</body>
</html>
