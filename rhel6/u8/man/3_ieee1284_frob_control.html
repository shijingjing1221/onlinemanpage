<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:19:28 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>IEEE1284_CONTROL(3) Functions IEEE1284_CONTROL(3)</p>

<p>NAME ieee1284_read_control, ieee1284_write_control,
ieee1284_frob_control, ieee1284_do_nack_handshake -
manipulate control lines</p>

<p>SYNOPSIS #include &lt;ieee1284.h&gt;</p>

<p>int ieee1284_read_control(struct parport *port);</p>

<p>void ieee1284_write_control(struct parport *port,
unsigned char ct);</p>

<p>void ieee1284_frob_control(struct parport *port,
unsigned char mask, unsigned char val);</p>

<p>int ieee1284_do_nack_handshake(struct parport *port,
unsigned char ct_before, unsigned char ct_after, struct
timeval *timeout);</p>

<p>DESCRIPTION There are four control lines, three of which
are usually inverted on PC-style ports. Where they differ,
libieee1284 operates on the IEEE 1284 values, not the
PC-style inverted values. The control lines are represented
by the following enumeration:</p>

<p>enum ieee1284_control_bits { C1284_NSTROBE = 0x01,
C1284_NAUTOFD = 0x02, C1284_NINIT = 0x04, C1284_NSELECTIN =
0x08, /* To convert those values into PC-style register
values, use this: */ C1284_INVERTED = (C1284_NSTROBE|
C1284_NAUTOFD| C1284_NSELECTIN), };</p>

<p>These functions all act on the parallel port associated
with port, which must be claimed.</p>

<p>The current values on the control lines are available by
calling ieee1284_read_control, and may be set by calling
ieee1284_write_control.</p>

<p>To adjust the values on a set of control lines, use
ieee1284_frob_control. The effect of this can be expressed
by: ctr = ((ctr &amp; ~mask) ^ val); that is, the bits in
mask are unset, and then those in val are inverted.</p>

<p>The special function ieee1284_do_nack_handshake is for
responding very quickly in a protocol where the peripheral
sets nAck and the host must respond by setting a control
line. Its operation, which relies on the host machine
knowing which interrupt nAck generates, is as follows:</p>

<p>1. Set the control lines as indicated in ct_before.</p>

<p>2. Wait for nAck interrupt. If timeout elapses, return
E1284_TIMEDOUT.</p>

<p>3. Set the control lines as indicated in ct_after.</p>

<p>On Linux using the ppdev driver, this is performed by
the device driver in the kernel, and so is faster than
normally possible in a user-space library.</p>

<p>RETURN VALUE The return value of ieee1284_read_control,
if non-negative, is a number representing the value on the
control lines.</p>

<p>Possible error codes for ieee1284_read_control:</p>

<p>E1284_NOTAVAIL The control lines of this port are not
accessible by the application.</p>

<p>E1284_INVALIDPORT The port parameter is invalid (for
instance, perhaps it is not claimed).</p>

<p>Possible error codes for ieee1284_do_nack_handshake:</p>

<p>E1284_OK The handshake was successful.</p>

<p>E1284_NOTAVAIL This operation is not available on this
port type or system. This could be because port interrupts
are not available, or because the underlying device driver
does not support the operation.</p>

<p>E1284_INVALIDPORT The port parameter is invalid (for
instance, perhaps it is not claimed).</p>

<p>AUTHOR Tim Waugh &lt;twaugh@redhat.com&gt; Author.</p>

<p>COPYRIGHT Copyright &copy; 2001-2003 Tim Waugh</p>

<p>[FIXME: source] 06/23/2010 IEEE1284_CONTROL(3)</p>
<hr>
</body>
</html>
