<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:10:20 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>D_LOOKUP(9) The Linux VFS D_LOOKUP(9)</p>

<p>NAME d_lookup - search for a dentry</p>

<p>SYNOPSIS struct dentry * d_lookup(struct dentry *
parent, struct qstr * name);</p>

<p>ARGUMENTS parent parent dentry</p>

<p>name qstr of name we wish to find</p>

<p>DESCRIPTION Searches the children of the parent dentry
for the name in question. If the dentry is found its
reference count is incremented and the dentry is returned.
The caller must use dput to free the entry when it has
finished using it. NULL is returned on failure.</p>

<p>__d_lookup is dcache_lock free. The hash list is
protected using RCU. Memory barriers are used while updating
and doing lockless traversal. To avoid races with d_move
while rename is happening, d_lock is used.</p>

<p>Overflows in memcmp, while d_move, are avoided by
keeping the length and name pointer in one structure pointed
by d_qstr.</p>

<p>rcu_read_lock and rcu_read_unlock are used to disable
preemption while lookup is going on.</p>

<p>The dentry unused LRU is not updated even if lookup
finds the required dentry in there. It is updated in places
such as prune_dcache, shrink_dcache_sb, select_parent and
__dget_locked. This laziness saves lookup from dcache_lock
acquisition.</p>

<p>d_lookup is protected against the concurrent renames in
some unrelated directory using the seqlockt_t
rename_lock.</p>

<p>COPYRIGHT Kernel Hackers Manual 2.6. April 2016
D_LOOKUP(9)</p>
<hr>
</body>
</html>
