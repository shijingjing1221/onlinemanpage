<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:30:24 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PTHREAD_CREATE(3P) POSIX Programmer s Manual
PTHREAD_CREATE(3P)</p>

<p>PROLOG This manual page is part of the POSIX Programmer
s Manual. The Linux implementation of this interface may
differ (consult the corresponding Linux manual page for
details of Linux behavior), or the interface may not be
implemented on Linux.</p>

<p>NAME pthread_create - thread creation</p>

<p>SYNOPSIS #include &lt;pthread.h&gt;</p>

<p>int pthread_create(pthread_t *restrict thread, const
pthread_attr_t *restrict attr, void
*(*start_routine)(void*), void *restrict arg);</p>

<p>DESCRIPTION The pthread_create() function shall create a
new thread, with attributes specified by attr, within a
process. If attr is NULL, the default attributes shall be
used. If the attributes specified by attr are modified
later, the threads attributes shall not be affected. Upon
successful completion, pthread_create() shall store the ID
of the cre- ated thread in the location referenced by
thread.</p>

<p>The thread is created executing start_routine with arg
as its sole argument. If the start_routine returns, the
effect shall be as if there was an implicit call to
pthread_exit() using the return value of start_routine as
the exit status. Note that the thread in which main() was
originally invoked differs from this. When it returns from
main(), the effect shall be as if there was an implicit call
to exit() using the return value of main() as the exit
status.</p>

<p>The signal state of the new thread shall be initialized
as follows:</p>

<p>* The signal mask shall be inherited from the creating
thread.</p>

<p>* The set of signals pending for the new thread shall be
empty.</p>

<p>The alternate stack shall not be inherited.</p>

<p>The floating-point environment shall be inherited from
the creating thread.</p>

<p>If pthread_create() fails, no new thread is created and
the contents of the location referenced by thread are
undefined.</p>

<p>If _POSIX_THREAD_CPUTIME is defined, the new thread
shall have a CPU- time clock accessible, and the initial
value of this clock shall be set to zero.</p>

<p>RETURN VALUE If successful, the pthread_create()
function shall return zero; other- wise, an error number
shall be returned to indicate the error.</p>

<p>ERRORS The pthread_create() function shall fail if:</p>

<p>EAGAIN The system lacked the necessary resources to
create another thread, or the system-imposed limit on the
total number of threads in a process {PTHREAD_THREADS_MAX}
would be exceeded.</p>

<p>EINVAL The value specified by attr is invalid.</p>

<p>EPERM The caller does not have appropriate permission to
set the required scheduling parameters or scheduling
policy.</p>

<p>The pthread_create() function shall not return an error
code of [EINTR].</p>

<p>The following sections are informative.</p>

<p>EXAMPLES None.</p>

<p>APPLICATION USAGE None.</p>

<p>RATIONALE A suggested alternative to pthread_create()
would be to define two sep- arate operations: create and
start. Some applications would find such behavior more
natural. Ada, in particular, separates the
&quot;creation&quot; of a task from its
&quot;activation&quot;.</p>

<p>Splitting the operation was rejected by the standard
developers for many reasons:</p>

<p>* The number of calls required to start a thread would
increase from one to two and thus place an additional burden
on applications that do not require the additional
synchronization. The second call, how- ever, could be
avoided by the additional complication of a start-up state
attribute.</p>

<p>* An extra state would be introduced: &quot;created but
not started&quot;. This would require the standard to
specify the behavior of the thread operations when the
target has not yet started executing.</p>

<p>* For those applications that require such behavior, it
is possible to simulate the two separate steps with the
facilities that are cur- rently provided. The
start_routine() can synchronize by waiting on a condition
variable that is signaled by the start operation.</p>

<p>An Ada implementor can choose to create the thread at
either of two points in the Ada program: when the task
object is created, or when the task is activated (generally
at a &quot;begin&quot;). If the first approach is adopted,
the start_routine() needs to wait on a condition variable to
receive the order to begin &quot;activation&quot;. The
second approach requires no such condition variable or extra
synchronization. In either approach, a separate Ada task
control block would need to be created when the task object
is created to hold rendezvous queues, and so on.</p>

<p>An extension of the preceding model would be to allow
the state of the thread to be modified between the create
and start. This would allow the thread attributes object to
be eliminated. This has been rejected because:</p>

<p>* All state in the thread attributes object has to be
able to be set for the thread. This would require the
definition of functions to modify thread attributes. There
would be no reduction in the number of function calls
required to set up the thread. In fact, for an application
that creates all threads using identical attributes, the
number of function calls required to set up the threads
would be dramatically increased. Use of a thread attributes
object permits the application to make one set of attribute
setting function calls. Otherwise, the set of attribute
setting function calls needs to be made for each thread
creation.</p>

<p>* Depending on the implementation architecture,
functions to set thread state would require kernel calls, or
for other implementation reasons would not be able to be
implemented as macros, thereby increasing the cost of thread
creation.</p>

<p>* The ability for applications to segregate threads by
class would be lost.</p>

<p>Another suggested alternative uses a model similar to
that for process creation, such as &quot;thread fork&quot;.
The fork semantics would provide more flexibility and the
&quot;create&quot; function can be implemented simply by
doing a thread fork followed immediately by a call to the
desired &quot;start routine&quot; for the thread. This
alternative has these problems:</p>

<p>* For many implementations, the entire stack of the
calling thread would need to be duplicated, since in many
architectures there is no way to determine the size of the
calling frame.</p>

<p>* Efficiency is reduced since at least some part of the
stack has to be copied, even though in most cases the thread
never needs the copied context, since it merely calls the
desired start routine.</p>

<p>FUTURE DIRECTIONS None.</p>

<p>SEE ALSO fork(), pthread_exit(), pthread_join(), the
Base Definitions volume of IEEE Std 1003.1-2001,
&lt;pthread.h&gt;</p>

<p>COPYRIGHT Portions of this text are reprinted and
reproduced in electronic form from IEEE Std 1003.1, 2003
Edition, Standard for Information Technology -- Portable
Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the
Institute of Electrical and Electronics Engineers, Inc and
The Open Group. In the event of any discrepancy between this
version and the original IEEE and The Open Group Standard,
the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at
http://www.opengroup.org/unix/online.html .</p>

<p>IEEE/The Open Group 2003 PTHREAD_CREATE(3P)</p>
<hr>
</body>
</html>
