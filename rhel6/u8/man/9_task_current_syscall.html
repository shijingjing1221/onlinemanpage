<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Sat Nov 12 06:37:26 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TASK_CURRENT_SYSCALL(9) Machine State
TASK_CURRENT_SYSCALL(9)</p>

<p>NAME task_current_syscall - Discover what a blocked task
is doing.</p>

<p>SYNOPSIS int task_current_syscall(struct task_struct *
target, long * callno, unsigned long args[6], unsigned int
maxargs, unsigned long * sp, unsigned long * pc);</p>

<p>ARGUMENTS target thread to examine</p>

<p>callno filled with system call number or -1</p>

<p>args[6] filled with maxargs system call arguments</p>

<p>maxargs number of elements in args to fill</p>

<p>sp filled with user stack pointer</p>

<p>pc filled with user PC</p>

<p>DESCRIPTION If target is blocked in a system call,
returns zero with *callno set to the the call&acute;s number
and args filled in with its arguments. Registers not used
for system call arguments may not be available and it is not
kosher to use struct user_regset calls while the system call
is still in progress. Note we may get this result if target
has finished its system call but not yet returned to user
mode, such as when it&acute;s stopped for signal handling or
syscall exit tracing.</p>

<p>If target is blocked in the kernel during a fault or
exception, returns zero with *callno set to -1 and does not
fill in args. If so, it&acute;s now safe to examine target
using struct user_regset get calls as long as we&acute;re
sure target won&acute;t return to user mode.</p>

<p>Returns -EAGAIN if target does not remain blocked.</p>

<p>Returns -EINVAL if maxargs is too large (maximum is
six).</p>

<p>Kernel Hackers Manual 2.6. April 2016
TASK_CURRENT_SYSCALL(9)</p>
<hr>
</body>
</html>
