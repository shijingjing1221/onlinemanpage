<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:11:43 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>getnameinfo(3) UNIX Programmer s Manual
getnameinfo(3)</p>

<p>NAME getnameinfo - address-to-name translation in
protocol-independent man- ner</p>

<p>SYNOPSIS #include &lt;sys/socket.h&gt; #include
&lt;netdb.h&gt;</p>

<p>int getnameinfo(const struct sockaddr *sa, socklen_t
salen, char *host, size_t hostlen, char *serv, size_t
servlen, int flags);</p>

<p>DESCRIPTION The getnameinfo(3) function is defined for
protocol-independent address-to-nodename translation. It
combines the functionality of gethostbyaddr(3) and
getservbyport(3) and is the inverse of getad- drinfo(3). The
sa argument is a pointer to a generic socket address
structure (of type sockaddr_in or sockaddr_in6) of size
salen that holds the input IP address and port number. The
arguments host and serv are pointers to buffers (of size
hostlen and servlen respectively) to hold the return
values.</p>

<p>The caller can specify that no hostname (or no service
name) is required by providing a NULL host (or serv)
argument or a zero hostlen (or servlen) parameter. However,
at least one of hostname or service name must be
requested.</p>

<p>The flags argument modifies the behaviour of
getnameinfo(3) as follows:</p>

<p>NI_NOFQDN If set, return only the hostname part of the
FQDN for local hosts.</p>

<p>NI_NUMERICHOST If set, then the numeric form of the
hostname is returned. (When not set, this will still happen
in case the nodes name cannot be looked up.)</p>

<p>NI_NAMEREQD If set, then a error is returned if the
hostname cannot be looked up.</p>

<p>NI_NUMERICSERV If set, then the service address is
returned in numeric form, for example by its port
number.</p>

<p>NI_DGRAM If set, then the service is datagram (UDP)
based rather than stream (TCP) based. This is required for
the few ports (512-514) that have different services for UDP
and TCP.</p>

<p>RETURN VALUE On success 0 is returned, and node and
service names, if requested, are filled with null-terminated
strings, possibly truncated to fit the specified buffer
lengths. On error one of the following non-zero error codes
is returned:</p>

<p>EAI_AGAIN The name could not be resolved at this time.
Try again later.</p>

<p>EAI_BADFLAGS The flags parameter has an invalid
value.</p>

<p>EAI_FAIL A non-recoverable error occurred.</p>

<p>EAI_FAMILY The address family was not recognized, or the
address length was invalid for the specified family.</p>

<p>EAI_MEMORY Out of memory.</p>

<p>EAI_NONAME The name does not resolve for the supplied
parameters. NI_NAMEREQD is set and the hosts name cannot be
located, or neither hostname nor service name were
requested.</p>

<p>EAI_OVERFLOW The buffer pointed to by host or serv was
too small.</p>

<p>EAI_SYSTEM A system error occurred. The error code can
be found in errno.</p>

<p>The gai_strerror(3) function translates these error
codes to a human readable string, suitable for error
reporting.</p>

<p>FILES /etc/hosts /etc/nsswitch.conf /etc/resolv.conf</p>

<p>NOTE In order to assist the programmer in choosing
reasonable sizes for the supplied buffers, &lt;netdb.h&gt;
defines the constants # define NI_MAXHOST 1025 # define
NI_MAXSERV 32 The former is the constant MAXDNAME in recent
versions of BINDs &lt;arpa/nameser.h&gt; header file. The
latter is a guess based on the ser- vices listed in the
current Assigned Numbers RFC.</p>

<p>EXAMPLE The following code tries to get the numeric
hostname and service name, for a given socket address. Note
that there is no hardcoded reference to a particular address
family.</p>

<p>struct sockaddr *sa; /* input */ char hbuf[NI_MAXHOST],
sbuf[NI_MAXSERV];</p>

<p>if (getnameinfo(sa, sa-&gt;sa_len, hbuf, sizeof(hbuf),
sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)
printf(&quot;host=%s, serv=%s0, hbuf, sbuf);</p>

<p>The following version checks if the socket address has a
reverse address mapping.</p>

<p>struct sockaddr *sa; /* input */ char
hbuf[NI_MAXHOST];</p>

<p>if (getnameinfo(sa, sa-&gt;sa_len, hbuf, sizeof(hbuf),
NULL, 0, NI_NAMEREQD)) printf(&quot;could not resolve
hostname&quot;); else printf(&quot;host=%s0, hbuf);</p>

<p>CONFORMING TO RFC 2553, POSIX.1-2001.</p>

<p>SEE ALSO getaddrinfo(3), gethostbyaddr(3),
getservbyname(3), getservbyport(3), inet_ntop(3), socket(3),
hosts(5), services(5), hostname(7), named(8)</p>

<p>R. Gilligan, S. Thomson, J. Bound and W. Stevens, Basic
Socket Inter- face Extensions for IPv6, RFC 2553, March
1999.</p>

<p>Tatsuya Jinmei and Atsushi Onoe, An Extension of Format
for IPv6 Scoped Addresses, internet draft, work in progress.
ftp://ftp.ietf.org/inter-
net-drafts/draft-ietf-ipngwg-scopedaddr-format-02.txt</p>

<p>Craig Metz, Protocol Independence Using the Sockets API,
Proceedings of the freenix track: 2000 USENIX annual
technical conference, June 2000.
http://www.usenix.org/publications/library/proceed-
ings/usenix2000/freenix/metzprotocol.html</p>

<p>Linux Man Page 2000-12-11 getnameinfo(3)</p>
<hr>
</body>
</html>
