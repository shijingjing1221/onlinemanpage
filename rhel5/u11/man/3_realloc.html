<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:21:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MALLOC(3) Linux Programmer s Manual MALLOC(3)</p>

<p>NAME calloc, malloc, free, realloc - Allocate and free
dynamic memory</p>

<p>SYNOPSIS #include &lt;stdlib.h&gt;</p>

<p>void *calloc(size_t nmemb, size_t size); void
*malloc(size_t size); void free(void *ptr); void
*realloc(void *ptr, size_t size);</p>

<p>DESCRIPTION calloc() allocates memory for an array of
nmemb elements of size bytes each and returns a pointer to
the allocated memory. The memory is set to zero.</p>

<p>malloc() allocates size bytes and returns a pointer to
the allocated memory. The memory is not cleared.</p>

<p>free() frees the memory space pointed to by ptr, which
must have been returned by a previous call to malloc(),
calloc() or realloc(). Other- wise, or if free(ptr) has
already been called before, undefined behaviour occurs. If
ptr is NULL, no operation is performed.</p>

<p>realloc() changes the size of the memory block pointed
to by ptr to size bytes. The contents will be unchanged to
the minimum of the old and new sizes; newly allocated memory
will be uninitialized. If ptr is NULL, the call is
equivalent to malloc(size); if size is equal to zero, the
call is equivalent to free(ptr). Unless ptr is NULL, it must
have been returned by an earlier call to malloc(), calloc()
or realloc(). If the area pointed to was moved, a free(ptr)
is done.</p>

<p>RETURN VALUE For calloc() and malloc(), the value
returned is a pointer to the allo- cated memory, which is
suitably aligned for any kind of variable, or NULL if the
request fails.</p>

<p>free() returns no value.</p>

<p>realloc() returns a pointer to the newly allocated
memory, which is suitably aligned for any kind of variable
and may be different from ptr, or NULL if the request fails.
If size was equal to 0, either NULL or a pointer suitable to
be passed to free() is returned. If realloc() fails the
original block is left untouched; it is not freed or
moved.</p>

<p>CONFORMING TO C89, C99.</p>

<p>SEE ALSO brk(2), posix_memalign(3)</p>

<p>NOTES The Unix98 standard requires malloc(), calloc(),
and realloc() to set errno to ENOMEM upon failure. Glibc
assumes that this is done (and the glibc versions of these
routines do this); if you use a private malloc
implementation that does not set errno, then certain library
routines may fail without having a reason in errno.</p>

<p>Crashes in malloc(), free() or realloc() are almost
always related to heap corruption, such as overflowing an
allocated chunk or freeing the same pointer twice.</p>

<p>Recent versions of Linux libc (later than 5.4.23) and
GNU libc (2.x) include a malloc implementation which is
tunable via environment vari- ables. When MALLOC_CHECK_ is
set, a special (less efficient) implemen- tation is used
which is designed to be tolerant against simple errors, such
as double calls of free() with the same argument, or
overruns of a single byte (off-by-one bugs). Not all such
errors can be protected against, however, and memory leaks
can result. If MALLOC_CHECK_ is set to 0, any detected heap
corruption is silently ignored and an error message is not
generated; if set to 1, the error message is printed on
stderr, but the program is not aborted; if set to 2, abort()
is called immediately, but the error message is not
generated; if set to 3, the error message is printed on
stderr and program is aborted. This can be useful because
otherwise a crash may happen much later, and the true cause
for the problem is then very hard to track down.</p>

<p>BUGS By default, Linux follows an optimistic memory
allocation strategy. This means that when malloc() returns
non-NULL there is no guarantee that the memory really is
available. This is a really bad bug. In case it turns out
that the system is out of memory, one or more processes will
be killed by the infamous OOM killer. In case Linux is
employed under circumstances where it would be less
desirable to suddenly lose some randomly picked processes,
and moreover the kernel version is suf- ficiently recent,
one can switch off this overcommitting behavior using a
command like # echo 2 &gt; /proc/sys/vm/overcommit_memory
See also the kernel Documentation directory, files
vm/overcommit- accounting and sysctl/vm.txt.</p>

<p>GNU 1993-04-04 MALLOC(3)</p>
<hr>
</body>
</html>
