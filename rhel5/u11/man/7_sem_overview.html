<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:22:38 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SEM_OVERVIEW(7) Linux Programmer s Manual
SEM_OVERVIEW(7)</p>

<p>NAME sem_overview - Overview of POSIX semaphores</p>

<p>DESCRIPTION POSIX semaphores allow processes and threads
to synchronise their actions.</p>

<p>A semaphore is an integer whose value is never allowed
to fall below zero. Two operations can be performed on
semaphores: increment the semaphore value by one
(sem_post(3)); and decrement the semaphore value by one
(sem_wait(3)). If the value of a semaphore is currently
zero, then a sem_wait(3) operation will block until the
value becomes greater than zero.</p>

<p>POSIX semaphores come in two forms: named semaphores and
unnamed semaphores.</p>

<p>Named semaphores A named semaphore is identified by a
name of the form /somename. Two processes can operate on the
same named semaphore by passing the same name to
sem_open(3).</p>

<p>The sem_open(3) function creates a new named semaphore
or opens an existing named semaphore. After the semaphore
has been opened, it can be operated on using sem_post(3) and
sem_wait(3). When a process has finished using the
semaphore, it can use sem_close(3) to close the semaphore.
When all processes have finished using the semaphore, it can
be removed from the system using sem_unlink(3).</p>

<p>Unnamed semaphores (memory-based semaphores) An unnamed
semaphore does not have a name. Instead the semaphore is
placed in a region of memory that is shared between multiple
threads (a thread-shared semaphore) or processes (a
process-shared semaphore). A thread-shared semaphore is
placed in an area of memory shared between by the threads of
a process, for example, a global variable. A pro-
cess-shared semaphore must be placed in a shared memory
region (e.g., a System V shared memory segment created using
semget(2), or a POSIX shared memory object built created
using shm_open(3)).</p>

<p>Before being used, an unnamed semaphore must be
initialised using sem_init(3). It can then be operated on
using sem_post(3) and sem_wait(3). When the semaphore is no
longer required, and before the memory in which it is
located is deallocated, the semaphore should be destroyed
using sem_destroy(3).</p>

<p>LINUX SPECIFIC DETAILS Versions Prior to kernel 2.6,
Linux only supported unnamed, thread-shared semaphores. On a
system with Linux 2.6 and a glibc that provides the NPTL
threading implementation, a complete implementation of POSIX
semaphores is provided.</p>

<p>Persistence POSIX named semaphores have kernel
persistence: if not removed by sem_unlink(), a semaphore
will exist until the system is shut down.</p>

<p>Linking Programs using the POSIX semaphores API must be
compiled with cc -lrt to link against the real-time library,
librt.</p>

<p>Accessing named semaphores via the file system On Linux,
named semaphores are created in a virtual file system, nor-
mally mounted under /dev/shm, with names of the form
sem.name.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>NOTES System V semaphores (semget(2), semop(2), etc.)
are an older semaphore API. POSIX semaphores provide a
simpler, and better designed interface than System V
semaphores; on the other hand POSIX semaphores are less
widely available (especially on older systems) than System V
semaphores.</p>

<p>EXAMPLE An example of the use of various POSIX semaphore
functions is shown in sem_wait(3).</p>

<p>SEE ALSO sem_close(3), sem_destroy(3), sem_init(3),
sem_getvalue(3), sem_open(3), sem_post(3), sem_unlink(3),
sem_wait(3), pthreads(7)</p>

<p>Linux 2.6.16 2006-03-25 SEM_OVERVIEW(7)</p>
<hr>
</body>
</html>
