<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:06:51 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>BIND(2) Linux Programmer s Manual BIND(2)</p>

<p>NAME bind - bind a name to a socket</p>

<p>SYNOPSIS #include &lt;sys/types.h&gt; #include
&lt;sys/socket.h&gt;</p>

<p>int bind(int sockfd, const struct sockaddr *my_addr,
socklen_t addrlen);</p>

<p>DESCRIPTION bind() gives the socket sockfd the local
address my_addr. my_addr is addrlen bytes long.
Traditionally, this is called assigning a name to a socket.
When a socket is created with socket(2), it exists in a name
space (address family) but has no name assigned.</p>

<p>It is normally necessary to assign a local address using
bind() before a SOCK_STREAM socket may receive connections
(see accept(2)).</p>

<p>The rules used in name binding vary between address
families. Consult the manual entries in Section 7 for
detailed information. For AF_INET see ip(7), for AF_INET6
see ipv6(7), for AF_UNIX see unix(7), for AF_APPLETALK see
ddp(7), for AF_PACKET see packet(7), for AF_X25 see x25(7)
and for AF_NETLINK see netlink(7).</p>

<p>The actual structure passed for the my_addr argument
will depend on the address family. The sockaddr structure is
defined as something like:</p>

<p>struct sockaddr { sa_family_t sa_family; char
sa_data[14]; }</p>

<p>The only purpose of this structure is to cast the
structure pointer passed in my_addr in order to avoid
compiler warnings. The following example shows how this is
done when binding a socket in the Unix (AF_UNIX) domain:</p>

<p>#include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt;
#include &lt;stdlib.h&gt; #include &lt;stdlio.h&gt;</p>

<p>#define MY_SOCK_PATH &quot;/somepath&quot;</p>

<p>int main(int argc, char *argv[]) { int sfd; struct
sockaddr_un addr;</p>

<p>sfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sfd == -1) {
perror(&quot;socket&quot;); exit(EXIT_FAILURE); }</p>

<p>memset(&amp;addr, 0, sizeof(struct sockaddr_un)); /*
Clear structure */ addr.sun_family = AF_UNIX;
strncpy(addr.sun_path, MY_SOCK_PATH, sizeof(addr.sun_path) -
1);</p>

<p>if (bind(sfd, (struct sockaddr *) &amp;addr,
sizeof(struct sockaddr_un)) == -1) {
perror(&quot;bind&quot;); exit(EXIT_FAILURE); } ... }</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS EACCES The address is protected, and the user is
not the superuser.</p>

<p>EADDRINUSE The given address is already in use.</p>

<p>EBADF sockfd is not a valid descriptor.</p>

<p>EINVAL The socket is already bound to an address.</p>

<p>ENOTSOCK sockfd is a descriptor for a file, not a
socket.</p>

<p>The following errors are specific to UNIX domain
(AF_UNIX) sockets:</p>

<p>EACCES Search permission is denied on a component of the
path prefix. (See also path_resolution(2).)</p>

<p>EADDRNOTAVAIL A non-existent interface was requested or
the requested address was not local.</p>

<p>EFAULT my_addr points outside the users accessible
address space.</p>

<p>EINVAL The addrlen is wrong, or the socket was not in
the AF_UNIX fam- ily.</p>

<p>ELOOP Too many symbolic links were encountered in
resolving my_addr.</p>

<p>ENAMETOOLONG my_addr is too long.</p>

<p>ENOENT The file does not exist.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ENOTDIR A component of the path prefix is not a
directory.</p>

<p>EROFS The socket inode would reside on a read-only file
system.</p>

<p>BUGS The transparent proxy options are not
described.</p>

<p>CONFORMING TO SVr4, 4.4BSD (the bind() function first
appeared in 4.2BSD).</p>

<p>NOTE The third argument of bind() is in reality an int
(and this is what 4.x BSD and libc4 and libc5 have). Some
POSIX confusion resulted in the present socklen_t, also used
by glibc. See also accept(2).</p>

<p>SEE ALSO accept(2), connect(2), getsockname(2),
listen(2), path_resolution(2), socket(2), getaddrinfo(3),
ip(7), ipv6(7), socket(7), unix(7)</p>

<p>Linux 2.6.7 2004-06-23 BIND(2)</p>
<hr>
</body>
</html>
