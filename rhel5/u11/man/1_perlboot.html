<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLBOOT(1) Perl Programmers Reference Guide
PERLBOOT(1)</p>

<p>NAME perlboot - Beginner&rsquo;s Object-Oriented
Tutorial</p>

<p>DESCRIPTION If youre not familiar with objects from
other languages, some of the other Perl object documentation
may be a little daunting, such as per- lobj, a basic
reference in using objects, and perltoot, which intro- duces
readers to the peculiarities of Perls object system in a
tuto- rial way.</p>

<p>So, lets take a different approach, presuming no prior
object experi- ence. It helps if you know about subroutines
(perlsub), references (perlref et. seq.), and packages
(perlmod), so become familiar with those first if you havent
already.</p>

<p>If we could talk to the animals...</p>

<p>Lets let the animals talk for a moment:</p>

<p>sub Cow::speak { print &quot;a Cow goes moooo!0; } sub
Horse::speak { print &quot;a Horse goes neigh!0; } sub
Sheep::speak { print &quot;a Sheep goes baaaah!0 }</p>

<p>Cow::speak; Horse::speak; Sheep::speak;</p>

<p>This results in:</p>

<p>a Cow goes moooo! a Horse goes neigh! a Sheep goes
baaaah!</p>

<p>Nothing spectacular here. Simple subroutines, albeit
from separate packages, and called using the full package
name. So lets create an entire pasture:</p>

<p># Cow::speak, Horse::speak, Sheep::speak as before
@pasture = qw(Cow Cow Horse Sheep Sheep); foreach $animal
(@pasture) { &amp;{$animal.&quot;::speak&quot;}; }</p>

<p>This results in:</p>

<p>a Cow goes moooo! a Cow goes moooo! a Horse goes neigh!
a Sheep goes baaaah! a Sheep goes baaaah!</p>

<p>Wow. That symbolic coderef de-referencing there is
pretty nasty. Were counting on &quot;no strict subs&quot;
mode, certainly not recommended for larger programs. And why
was that necessary? Because the name of the package seems to
be inseparable from the name of the subroutine we want to
invoke within that package.</p>

<p>Or is it?</p>

<p>Introducing the method invocation arrow</p>

<p>For now, lets say that &quot;Class-&gt;method&quot;
invokes subroutine &quot;method&quot; in package
&quot;Class&quot;. (Here, &quot;Class&quot; is used in its
&quot;category&quot; meaning, not its &quot;scholastic&quot;
meaning.) Thats not completely accurate, but well do this
one step at a time. Now lets use it like so:</p>

<p># Cow::speak, Horse::speak, Sheep::speak as before
Cow-&gt;speak; Horse-&gt;speak; Sheep-&gt;speak;</p>

<p>And once again, this results in:</p>

<p>a Cow goes moooo! a Horse goes neigh! a Sheep goes
baaaah!</p>

<p>Thats not fun yet. Same number of characters, all
constant, no vari- ables. But yet, the parts are separable
now. Watch:</p>

<p>$a = &quot;Cow&quot;; $a-&gt;speak; # invokes
Cow-&gt;speak</p>

<p>Ahh! Now that the package name has been parted from the
subroutine name, we can use a variable package name. And
this time, weve got something that works even when &quot;use
strict refs&quot; is enabled.</p>

<p>Invoking a barnyard</p>

<p>Lets take that new arrow invocation and put it back in
the barnyard example:</p>

<p>sub Cow::speak { print &quot;a Cow goes moooo!0; } sub
Horse::speak { print &quot;a Horse goes neigh!0; } sub
Sheep::speak { print &quot;a Sheep goes baaaah!0 }</p>

<p>@pasture = qw(Cow Cow Horse Sheep Sheep); foreach
$animal (@pasture) { $animal-&gt;speak; }</p>

<p>There! Now we have the animals all talking, and safely
at that, with- out the use of symbolic coderefs.</p>

<p>But look at all that common code. Each of the
&quot;speak&quot; routines has a similar structure: a
&quot;print&quot; operator and a string that contains common
text, except for two of the words. It d be nice if we could
factor out the commonality, in case we decide later to
change it all to &quot;says&quot; instead of
&quot;goes&quot;.</p>

<p>And we actually have a way of doing that without much
fuss, but we have to hear a bit more about what the method
invocation arrow is actually doing for us.</p>

<p>The extra parameter of method invocation</p>

<p>The invocation of:</p>

<p>Class-&gt;method(@args)</p>

<p>attempts to invoke subroutine &quot;Class::method&quot;
as:</p>

<p>Class::method(&quot;Class&quot;, @args);</p>

<p>(If the subroutine cant be found,
&quot;inheritance&quot; kicks in, but well get to that
later.) This means that we get the class name as the first
parameter (the only parameter, if no arguments are given).
So we can rewrite the &quot;Sheep&quot; speaking subroutine
as:</p>

<p>sub Sheep::speak { my $class = shift; print &quot;a
$class goes baaaah!0; }</p>

<p>And the other two animals come out similarly:</p>

<p>sub Cow::speak { my $class = shift; print &quot;a $class
goes moooo!0; } sub Horse::speak { my $class = shift; print
&quot;a $class goes neigh!0; }</p>

<p>In each case, $class will get the value appropriate for
that subrou- tine. But once again, we have a lot of similar
structure. Can we fac- tor that out even further? Yes, by
calling another method in the same class.</p>

<p>Calling a second method to simplify things</p>

<p>Lets call out from &quot;speak&quot; to a helper method
called &quot;sound&quot;. This method provides the constant
text for the sound itself.</p>

<p>{ package Cow; sub sound { &quot;moooo&quot; } sub speak
{ my $class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0 } }</p>

<p>Now, when we call &quot;Cow-&gt;speak&quot;, we get a
$class of &quot;Cow&quot; in &quot;speak&quot;. This in turn
selects the &quot;Cow-&gt;sound&quot; method, which returns
&quot;moooo&quot;. But how different would this be for the
&quot;Horse&quot;?</p>

<p>{ package Horse; sub sound { &quot;neigh&quot; } sub
speak { my $class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0 } }</p>

<p>Only the name of the package and the specific sound
change. So can we somehow share the definition for
&quot;speak&quot; between the Cow and the Horse? Yes, with
inheritance!</p>

<p>Inheriting the windpipes</p>

<p>We ll define a common subroutine package called
&quot;Animal&quot;, with the definition for
&quot;speak&quot;:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0 }
}</p>

<p>Then, for each animal, we say it &quot;inherits&quot;
from &quot;Animal&quot;, along with the animal-specific
sound:</p>

<p>{ package Cow; @ISA = qw(Animal); sub sound {
&quot;moooo&quot; } }</p>

<p>Note the added @ISA array. Well get to that in a
minute.</p>

<p>But what happens when we invoke
&quot;Cow-&gt;speak&quot; now?</p>

<p>First, Perl constructs the argument list. In this case,
its just &quot;Cow&quot;. Then Perl looks for
&quot;Cow::speak&quot;. But thats not there, so Perl checks
for the inheritance array @Cow::ISA. It s there, and con-
tains the single name &quot;Animal&quot;.</p>

<p>Perl next checks for &quot;speak&quot; inside
&quot;Animal&quot; instead, as in &quot;Ani-
mal::speak&quot;. And that s found, so Perl invokes that
subroutine with the already frozen argument list.</p>

<p>Inside the &quot;Animal::speak&quot; subroutine, $class
becomes &quot;Cow&quot; (the first argument). So when we get
to the step of invoking &quot;$class-&gt;sound&quot;, it ll
be looking for &quot;Cow-&gt;sound&quot;, which gets it on
the first try with- out looking at @ISA. Success!</p>

<p>A few notes about @ISA</p>

<p>This magical @ISA variable (pronounced &quot;is a&quot;
not &quot;ice-uh&quot;), has declared that &quot;Cow&quot;
&quot;is a&quot; &quot;Animal&quot;. Note that its an array,
not a simple single value, because on rare occasions, it
makes sense to have more than one parent class searched for
the missing methods.</p>

<p>If &quot;Animal&quot; also had an @ISA, then wed check
there too. The search is recursive, depth-first,
left-to-right in each @ISA. Typically, each @ISA has only
one element (multiple elements means multiple inheritance
and multiple headaches), so we get a nice tree of
inheritance.</p>

<p>When we turn on &quot;use strict&quot;, well get
complaints on @ISA, since its not a variable containing an
explicit package name, nor is it a lexical (&quot;my&quot;)
variable. We can t make it a lexical variable though (it has
to belong to the package to be found by the inheritance
mechanism), so theres a couple of straightforward ways to
handle that.</p>

<p>The easiest is to just spell the package name out:</p>

<p>@Cow::ISA = qw(Animal);</p>

<p>Or allow it as an implicitly named package variable:</p>

<p>package Cow; use vars qw(@ISA); @ISA = qw(Animal);</p>

<p>If youre bringing in the class from outside, via an
object-oriented module, you change:</p>

<p>package Cow; use Animal; use vars qw(@ISA); @ISA =
qw(Animal);</p>

<p>into just:</p>

<p>package Cow; use base qw(Animal);</p>

<p>And thats pretty darn compact.</p>

<p>Overriding the methods</p>

<p>Lets add a mouse, which can barely be heard:</p>

<p># Animal package from before { package Mouse; @ISA =
qw(Animal); sub sound { &quot;squeak&quot; } sub speak { my
$class = shift; print &quot;a $class goes &quot;,
$class-&gt;sound, &quot;!0; print &quot;[but you can barely
hear it!]0; } }</p>

<p>Mouse-&gt;speak;</p>

<p>which results in:</p>

<p>a Mouse goes squeak! [but you can barely hear it!]</p>

<p>Here, &quot;Mouse&quot; has its own speaking routine, so
&quot;Mouse-&gt;speak&quot; doesnt immediately invoke
&quot;Animal-&gt;speak&quot;. This is known as
&quot;overriding&quot;. In fact, we didn t even need to say
that a &quot;Mouse&quot; was an &quot;Animal&quot; at all,
since all of the methods needed for &quot;speak&quot; are
completely defined with &quot;Mouse&quot;.</p>

<p>But we ve now duplicated some of the code from
&quot;Animal-&gt;speak&quot;, and this can once again be a
maintenance headache. So, can we avoid that? Can we say
somehow that a &quot;Mouse&quot; does everything any other
&quot;Animal&quot; does, but add in the extra comment?
Sure!</p>

<p>First, we can invoke the &quot;Animal::speak&quot;
method directly:</p>

<p># Animal package from before { package Mouse; @ISA =
qw(Animal); sub sound { &quot;squeak&quot; } sub speak { my
$class = shift; Animal::speak($class); print &quot;[but you
can barely hear it!]0; } }</p>

<p>Note that we have to include the $class parameter
(almost surely the value of &quot;Mouse&quot;) as the first
parameter to &quot;Animal::speak&quot;, since weve stopped
using the method arrow. Why did we stop? Well, if we invoke
&quot;Animal-&gt;speak&quot; there, the first parameter to
the method will be &quot;Animal&quot; not &quot;Mouse&quot;,
and when time comes for it to call for the
&quot;sound&quot;, it wont have the right class to come back
to this package.</p>

<p>Invoking &quot;Animal::speak&quot; directly is a mess,
however. What if &quot;Animal::speak&quot; didn t exist
before, and was being inherited from a class mentioned in
@Animal::ISA? Because we are no longer using the method
arrow, we get one and only one chance to hit the right
subrou- tine.</p>

<p>Also note that the &quot;Animal&quot; classname is now
hardwired into the subrou- tine selection. This is a mess if
someone maintains the code, changing @ISA for &lt;Mouse&gt;
and didn t notice &quot;Animal&quot; there in
&quot;speak&quot;. So, this is probably not the right way to
go.</p>

<p>Starting the search from a different place</p>

<p>A better solution is to tell Perl to search from a
higher place in the inheritance chain:</p>

<p># same Animal as before { package Mouse; # same @ISA,
&amp;sound as before sub speak { my $class = shift;
$class-&gt;Animal::speak; print &quot;[but you can barely
hear it!]0; } }</p>

<p>Ahh. This works. Using this syntax, we start with
&quot;Animal&quot; to find &quot;speak&quot;, and use all of
&quot;Animal&quot;s inheritance chain if not found imme-
diately. And yet the first parameter will be $class, so the
found &quot;speak&quot; method will get &quot;Mouse&quot; as
its first entry, and eventually work its way back to
&quot;Mouse::sound&quot; for the details.</p>

<p>But this isnt the best solution. We still have to keep
the @ISA and the initial search package coordinated. Worse,
if &quot;Mouse&quot; had multiple entries in @ISA, we
wouldnt necessarily know which one had actually defined
&quot;speak&quot;. So, is there an even better way?</p>

<p>The SUPER way of doing things</p>

<p>By changing the &quot;Animal&quot; class to the
&quot;SUPER&quot; class in that invocation, we get a search
of all of our super classes (classes listed in @ISA)
automatically:</p>

<p># same Animal as before { package Mouse; # same @ISA,
&amp;sound as before sub speak { my $class = shift;
$class-&gt;SUPER::speak; print &quot;[but you can barely
hear it!]0; } }</p>

<p>So, &quot;SUPER::speak&quot; means look in the current
packages @ISA for &quot;speak&quot;, invoking the first one
found. Note that it does not look in the @ISA of $class.</p>

<p>Where wre at so far...</p>

<p>So far, weve seen the method arrow syntax:</p>

<p>Class-&gt;method(@args);</p>

<p>or the equivalent:</p>

<p>$a = &quot;Class&quot;; $a-&gt;method(@args);</p>

<p>which constructs an argument list of:</p>

<p>(&quot;Class&quot;, @args)</p>

<p>and attempts to invoke</p>

<p>Class::method(&quot;Class&quot;, @Args);</p>

<p>However, if &quot;Class::method&quot; is not found, then
@Class::ISA is examined (recursively) to locate a package
that does indeed contain &quot;method&quot;, and that
subroutine is invoked instead.</p>

<p>Using this simple syntax, we have class methods,
(multiple) inheri- tance, overriding, and extending. Using
just what we ve seen so far, we ve been able to factor out
common code, and provide a nice way to reuse implementations
with variations. This is at the core of what objects
provide, but objects also provide instance data, which we
havent even begun to cover.</p>

<p>A horse is a horse, of course of course -- or is it?</p>

<p>Lets start with the code for the &quot;Animal&quot;
class and the &quot;Horse&quot; class:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0 } } {
package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } }</p>

<p>This lets us invoke &quot;Horse-&gt;speak&quot; to
ripple upward to &quot;Animal::speak&quot;, calling back to
&quot;Horse::sound&quot; to get the specific sound, and the
out- put of:</p>

<p>a Horse goes neigh!</p>

<p>But all of our Horse objects would have to be absolutely
identical. If I add a subroutine, all horses automatically
share it. Thats great for making horses the same, but how do
we capture the distinctions about an individual horse? For
example, suppose I want to give my first horse a name.
Theres got to be a way to keep its name separate from the
other horses.</p>

<p>We can do that by drawing a new distinction, called an
&quot;instance&quot;. An &quot;instance&quot; is generally
created by a class. In Perl, any reference can be an
instance, so lets start with the simplest reference that can
hold a horses name: a scalar reference.</p>

<p>my $name = &quot;Mr. Ed&quot;; my $talking = ame;</p>

<p>So now $talking is a reference to what will be the
instance-specific data (the name). The final step in turning
this into a real instance is with a special operator called
&quot;bless&quot;:</p>

<p>bless $talking, Horse;</p>

<p>This operator stores information about the package named
&quot;Horse&quot; into the thing pointed at by the
reference. At this point, we say $talking is an instance of
&quot;Horse&quot;. That is, its a specific horse. The refer-
ence is otherwise unchanged, and can still be used with
traditional dereferencing operators.</p>

<p>Invoking an instance method</p>

<p>The method arrow can be used on instances, as well as
names of packages (classes). So, lets get the sound that
$talking makes:</p>

<p>my $noise = $talking-&gt;sound;</p>

<p>To invoke &quot;sound&quot;, Perl first notes that
$talking is a blessed refer- ence (and thus an instance). It
then constructs an argument list, in this case from just
&quot;($talking)&quot;. (Later we ll see that arguments will
take their place following the instance variable, just like
with classes.)</p>

<p>Now for the fun part: Perl takes the class in which the
instance was blessed, in this case &quot;Horse&quot;, and
uses that to locate the subroutine to invoke the method. In
this case, &quot;Horse::sound&quot; is found directly
(without using inheritance), yielding the final subroutine
invocation:</p>

<p>Horse::sound($talking)</p>

<p>Note that the first parameter here is still the
instance, not the name of the class as before. Well get
&quot;neigh&quot; as the return value, and thatll end up as
the $noise variable above.</p>

<p>If Horse::sound had not been found, wed be wandering up
the @Horse::ISA list to try to find the method in one of the
superclasses, just as for a class method. The only
difference between a class method and an instance method is
whether the first parameter is an instance (a blessed
reference) or a class name (a string).</p>

<p>Accessing the instance data</p>

<p>Because we get the instance as the first parameter, we
can now access the instance-specific data. In this case,
lets add a way to get at the name:</p>

<p>{ package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } sub name { my $self = shift; $$self; }
}</p>

<p>Now we call for the name:</p>

<p>print $talking-&gt;name, &quot; says &quot;,
$talking-&gt;sound, &quot;0;</p>

<p>Inside &quot;Horse::name&quot;, the @_ array contains
just $talking, which the &quot;shift&quot; stores into
$self. (Its traditional to shift the first param- eter off
into a variable named $self for instance methods, so stay
with that unless you have strong reasons otherwise.) Then,
$self gets de- referenced as a scalar ref, yielding
&quot;Mr. Ed&quot;, and we re done with that. The result
is:</p>

<p>Mr. Ed says neigh.</p>

<p>How to build a horse</p>

<p>Of course, if we constructed all of our horses by hand,
we d most likely make mistakes from time to time. We re also
violating one of the properties of object-oriented
programming, in that the &quot;inside guts&quot; of a Horse
are visible. That s good if you re a veterinarian, but not
if you just like to own horses. So, lets let the Horse class
build a new horse:</p>

<p>{ package Horse; @ISA = qw(Animal); sub sound {
&quot;neigh&quot; } sub name { my $self = shift; $$self; }
sub named { my $class = shift; my $name = shift; bless ame,
$class; } }</p>

<p>Now with the new &quot;named&quot; method, we can build
a horse:</p>

<p>my $talking = Horse-&gt;named(&quot;Mr. Ed&quot;);</p>

<p>Notice were back to a class method, so the two arguments
to &quot;Horse::named&quot; are &quot;Horse&quot; and
&quot;Mr. Ed&quot;. The &quot;bless&quot; operator not only
blesses $name, it also returns the reference to $name, so
thats fine as a return value. And thats how to build a
horse.</p>

<p>We ve called the constructor &quot;named&quot; here, so
that it quickly denotes the constructors argument as the
name for this particular &quot;Horse&quot;. You can use
different constructors with different names for different
ways of &quot;giving birth&quot; to the object (like maybe
recording its pedigree or date of birth). However, youll
find that most people coming to Perl from more limited
languages use a single constructor named &quot;new&quot;,
with various ways of interpreting the arguments to
&quot;new&quot;. Either style is fine, as long as you
document your particular way of giving birth to an object.
(And you were going to do that, right?)</p>

<p>Inheriting the constructor</p>

<p>But was there anything specific to &quot;Horse&quot; in
that method? No. There- fore, its also the same recipe for
building anything else that inher- ited from
&quot;Animal&quot;, so lets put it there:</p>

<p>{ package Animal; sub speak { my $class = shift; print
&quot;a $class goes &quot;, $class-&gt;sound, &quot;!0 } sub
name { my $self = shift; $$self; } sub named { my $class =
shift; my $name = shift; bless ame, $class; } } { package
Horse; @ISA = qw(Animal); sub sound { &quot;neigh&quot; }
}</p>

<p>Ahh, but what happens if we invoke &quot;speak&quot; on
an instance?</p>

<p>my $talking = Horse-&gt;named(&quot;Mr. Ed&quot;);
$talking-&gt;speak;</p>

<p>We get a debugging value:</p>

<p>a Horse=SCALAR(0xaca42ac) goes neigh!</p>

<p>Why? Because the &quot;Animal::speak&quot; routine is
expecting a classname as its first parameter, not an
instance. When the instance is passed in, well end up using
a blessed scalar reference as a string, and that shows up as
we saw it just now.</p>

<p>Making a method work with either classes or
instances</p>

<p>All we need is for a method to detect if it is being
called on a class or called on an instance. The most
straightforward way is with the &quot;ref&quot; operator.
This returns a string (the classname) when used on a blessed
reference, and &quot;undef&quot; when used on a string (like
a class- name). Lets modify the &quot;name&quot; method
first to notice the change:</p>

<p>sub name { my $either = shift; ref $either ? $$either #
its an instance, return name : &quot;an unnamed
$either&quot;; # it s a class, return generic }</p>

<p>Here, the &quot;?:&quot; operator comes in handy to
select either the dereference or a derived string. Now we
can use this with either an instance or a class. Note that
Ive changed the first parameter holder to $either to show
that this is intended:</p>

<p>my $talking = Horse-&gt;named(&quot;Mr. Ed&quot;); print
Horse-&gt;name, &quot;0; # prints &quot;an unnamed Horse0
print $talking-&gt;name, &quot;0; # prints &quot;Mr Ed.0</p>

<p>and now well fix &quot;speak&quot; to use this:</p>

<p>sub speak { my $either = shift; print $either-&gt;name,
&quot; goes &quot;, $either-&gt;sound, &quot;0; }</p>

<p>And since &quot;sound&quot; already worked with either a
class or an instance, were done!</p>

<p>Adding parameters to a method</p>

<p>Lets train our animals to eat:</p>

<p>{ package Animal; sub named { my $class = shift; my
$name = shift; bless ame, $class; } sub name { my $either =
shift; ref $either ? $$either # its an instance, return name
: &quot;an unnamed $either&quot;; # its a class, return
generic } sub speak { my $either = shift; print
$either-&gt;name, &quot; goes &quot;, $either-&gt;sound,
&quot;0; } sub eat { my $either = shift; my $food = shift;
print $either-&gt;name, &quot; eats $food.0; } } { package
Horse; @ISA = qw(Animal); sub sound { &quot;neigh&quot; } }
{ package Sheep; @ISA = qw(Animal); sub sound {
&quot;baaaah&quot; } }</p>

<p>And now try it out:</p>

<p>my $talking = Horse-&gt;named(&quot;Mr. Ed&quot;);
$talking-&gt;eat(&quot;hay&quot;);
Sheep-&gt;eat(&quot;grass&quot;);</p>

<p>which prints:</p>

<p>Mr. Ed eats hay. an unnamed Sheep eats grass.</p>

<p>An instance method with parameters gets invoked with the
instance, and then the list of parameters. So that first
invocation is like:</p>

<p>Animal::eat($talking, &quot;hay&quot;);</p>

<p>More interesting instances</p>

<p>What if an instance needs more data? Most interesting
instances are made of many items, each of which can in turn
be a reference or even another object. The easiest way to
store these is often in a hash. The keys of the hash serve
as the names of parts of the object (often called
&quot;instance variables&quot; or &quot;member
variables&quot;), and the correspond- ing values are, well,
the values.</p>

<p>But how do we turn the horse into a hash? Recall that an
object was any blessed reference. We can just as easily make
it a blessed hash reference as a blessed scalar reference,
as long as everything that looks at the reference is changed
accordingly.</p>

<p>Lets make a sheep that has a name and a color:</p>

<p>my $bad = bless { Name =&gt; &quot;Evil&quot;, Color
=&gt; &quot;black&quot; }, Sheep;</p>

<p>so &quot;$bad-&gt;{Name}&quot; has &quot;Evil&quot;, and
&quot;$bad-&gt;{Color}&quot; has &quot;black&quot;. But we
want to make &quot;$bad-&gt;name&quot; access the name, and
that s now messed up because it s expecting a scalar
reference. Not to worry, because thats pretty easy to fix
up:</p>

<p>## in Animal sub name { my $either = shift; ref $either
? $either-&gt;{Name} : &quot;an unnamed $either&quot;; }</p>

<p>And of course &quot;named&quot; still builds a scalar
sheep, so lets fix that as well:</p>

<p>## in Animal sub named { my $class = shift; my $name =
shift; my $self = { Name =&gt; $name, Color =&gt;
$class-&gt;default_color }; bless $self, $class; }</p>

<p>Whats this &quot;default_color&quot;? Well, if
&quot;named&quot; has only the name, we still need to set a
color, so well have a class-specific initial color. For a
sheep, we might define it as white:</p>

<p>## in Sheep sub default_color { &quot;white&quot; }</p>

<p>And then to keep from having to define one for each
additional class, we ll define a &quot;backstop&quot; method
that serves as the &quot;default default&quot;, directly in
&quot;Animal&quot;:</p>

<p>## in Animal sub default_color { &quot;brown&quot; }</p>

<p>Now, because &quot;name&quot; and &quot;named&quot; were
the only methods that referenced the &quot;structure&quot;
of the object, the rest of the methods can remain the same,
so &quot;speak&quot; still works as before.</p>

<p>A horse of a different color</p>

<p>But having all our horses be brown would be boring. So
lets add a method or two to get and set the color.</p>

<p>## in Animal sub color { $_[0]-&gt;{Color} } sub
set_color { $_[0]-&gt;{Color} = $_[1]; }</p>

<p>Note the alternate way of accessing the arguments: $_[0]
is used in-place, rather than with a &quot;shift&quot;.
(This saves us a bit of time for something that may be
invoked frequently.) And now we can fix that color for Mr.
Ed:</p>

<p>my $talking = Horse-&gt;named(&quot;Mr. Ed&quot;);
$talking-&gt;set_color(&quot;black-and-white&quot;); print
$talking-&gt;name, &quot; is colored &quot;,
$talking-&gt;color, &quot;0;</p>

<p>which results in:</p>

<p>Mr. Ed is colored black-and-white</p>

<p>Summary</p>

<p>So, now we have class methods, constructors, instance
methods, instance data, and even accessors. But that s still
just the beginning of what Perl has to offer. We havent even
begun to talk about accessors that double as getters and
setters, destructors, indirect object notation, subclasses
that add instance data, per-class data, overloading,
&quot;isa&quot; and &quot;can&quot; tests,
&quot;UNIVERSAL&quot; class, and so on. Thats for the rest
of the Perl documentation to cover. Hopefully, this gets you
started, though.</p>

<p>SEE ALSO For more information, see perlobj (for all the
gritty details about Perl objects, now that youve seen the
basics), perltoot (the tutorial for those who already know
objects), perltooc (dealing with class data), perlbot (for
some more tricks), and books such as Damian Con- ways
excellent Object Oriented Perl.</p>

<p>Some modules which might prove interesting are
Class::Accessor, Class::Class, Class::Contract,
Class::Data::Inheritable, Class::Method- Maker and
Tie::SecureHash</p>

<p>COPYRIGHT Copyright (c) 1999, 2000 by Randal L. Schwartz
and Stonehenge Consult- ing Services, Inc. Permission is
hereby granted to distribute this document intact with the
Perl distribution, and in accordance with the licenses of
the Perl distribution; derived documents must include this
copyright notice intact.</p>

<p>Portions of this text have been derived from Perl
Training materials originally appearing in the Packages,
References, Objects, and Modules course taught by
instructors for Stonehenge Consulting Services, Inc. and
used with permission.</p>

<p>Portions of this text have been derived from materials
originally appearing in Linux Magazine and used with
permission.</p>

<p>perl v5.8.8 2014-02-11 PERLBOOT(1)</p>
<hr>
</body>
</html>
