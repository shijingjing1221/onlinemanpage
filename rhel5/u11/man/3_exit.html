<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:09:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>EXIT(3) Linux Programmer s Manual EXIT(3)</p>

<p>NAME exit - cause normal process termination</p>

<p>SYNOPSIS #include &lt;stdlib.h&gt;</p>

<p>void exit(int status);</p>

<p>DESCRIPTION The exit() function causes normal process
termination and the value of status &amp; 0377 is returned
to the parent (see wait(2)).</p>

<p>All functions registered with atexit() and on_exit() are
called, in the reverse order of their registration. (It is
possible for one of these functions to use atexit() or
on_exit() to register an additional func- tion to be
executed during exit processing; the new registration is
added to the front of the list of functions that remain to
be called.)</p>

<p>All open streams are flushed and closed. Files created
by tmpfile() are removed.</p>

<p>The C standard specifies two constants, EXIT_SUCCESS and
EXIT_FAILURE, that may be passed to exit() to indicate
successful or unsuccessful termination, respectively.</p>

<p>RETURN VALUE The exit() function does not return.</p>

<p>CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001.</p>

<p>NOTES It is undefined what happens if one of the
functions registered using atexit() and on_exit() calls
either exit() or longjmp().</p>

<p>The use of EXIT_SUCCESS and EXIT_FAILURE is slightly
more portable (to non-Unix environments) than that of 0 and
some non-zero value like 1 or -1. In particular, VMS uses a
different convention.</p>

<p>BSD has attempted to standardize exit codes; see the
file &lt;sysexits.h&gt;.</p>

<p>After exit(), the exit status must be transmitted to the
parent pro- cess. There are three cases. If the parent has
set SA_NOCLDWAIT, or has set the SIGCHLD handler to SIG_IGN,
the status is discarded. If the parent was waiting on the
child it is notified of the exit status. In both cases the
exiting process dies immediately. If the parent has not
indicated that it is not interested in the exit status, but
is not waiting, the exiting process turns into a
&quot;zombie&quot; process (which is nothing but a container
for the single byte representing the exit sta- tus) so that
the parent can learn the exit status when it later calls one
of the wait() functions.</p>

<p>If the implementation supports the SIGCHLD signal, this
signal is sent to the parent. If the parent has set
SA_NOCLDWAIT, it is undefined whether a SIGCHLD signal is
sent.</p>

<p>If the process is a session leader and its controlling
terminal is the controlling terminal of the session, then
each process in the fore- ground process group of this
controlling terminal is sent a SIGHUP sig- nal, and the
terminal is disassociated from this session, allowing it to
be acquired by a new controlling process.</p>

<p>If the exit of the process causes a process group to
become orphaned, and if any member of the newly orphaned
process group is stopped, then a SIGHUP signal followed by a
SIGCONT signal will be sent to each pro- cess in this
process group.</p>

<p>SEE ALSO _exit(2), wait(2), atexit(3), on_exit(3),
tmpfile(3)</p>

<p>2001-11-17 EXIT(3)</p>
<hr>
</body>
</html>
