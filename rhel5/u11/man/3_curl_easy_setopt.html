<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:08:16 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>curl_easy_setopt(3) libcurl Manual
curl_easy_setopt(3)</p>

<p>NAME curl_easy_setopt - set options for a curl easy
handle</p>

<p>SYNOPSIS #include &lt;curl/curl.h&gt;</p>

<p>CURLcode curl_easy_setopt(CURL *handle, CURLoption
option, parameter);</p>

<p>DESCRIPTION curl_easy_setopt() is used to tell libcurl
how to behave. By using the appropriate options to
curl_easy_setopt, you can change libcurls behavior. All
options are set with the option followed by a parameter.
That parameter can be a long, a function pointer, an object
pointer or a curl_off_t, depending on what the specific
option expects. Read this manual carefully as bad input
values may cause libcurl to behave badly! You can only set
one option in each function call. A typical applica- tion
uses many curl_easy_setopt() calls in the setup phase.</p>

<p>Options set with this function call are valid for all
forthcoming transfers performed using this handle. The
options are not in any way reset between transfers, so if
you want subsequent transfers with dif- ferent options, you
must change them between the transfers. You can optionally
reset all options back to internal default with
curl_easy_reset(3).</p>

<p>Strings passed to libcurl as char * arguments, will not
be copied by the library. Instead you should keep them
available until libcurl no longer needs them. Failing to do
so will cause very odd behavior or even crashes. libcurl
will need them until you call curl_easy_cleanup(3) or you
set the same option again to use a differ- ent pointer.</p>

<p>The handle is the return code from a curl_easy_init(3)
or curl_easy_duphandle(3) call.</p>

<p>BEHAVIOR OPTIONS CURLOPT_VERBOSE Set the parameter to
non-zero to get the library to display a lot of verbose
information about its operations. Very useful for libcurl
and/or protocol debugging and understanding. The verbose
information will be sent to stderr, or the stream set with
CUR- LOPT_STDERR.</p>

<p>You hardly ever want this set in production use, you
will almost always want this when you debug/report problems.
Another neat option for debugging is the
CURLOPT_DEBUGFUNCTION.</p>

<p>CURLOPT_HEADER A non-zero parameter tells the library to
include the header in the body output. This is only relevant
for protocols that actu- ally have headers preceding the
data (like HTTP).</p>

<p>CURLOPT_NOPROGRESS A non-zero parameter tells the
library to shut off the built-in progress meter
completely.</p>

<p>Future versions of libcurl is likely to not have any
built-in progress meter at all.</p>

<p>CURLOPT_NOSIGNAL Pass a long. If it is non-zero, libcurl
will not use any func- tions that install signal handlers or
any functions that cause signals to be sent to the process.
This option is mainly here to allow multi-threaded unix
applications to still set/use all timeout options etc,
without risking getting signals. (Added in 7.10)</p>

<p>Consider building libcurl with ares support to enable
asyn- chronous DNS lookups. It enables nice timeouts for
name resolves without signals.</p>

<p>CALLBACK OPTIONS CURLOPT_WRITEFUNCTION Function pointer
that should match the following prototype: size_t function(
void *ptr, size_t size, size_t nmemb, void *stream); This
function gets called by libcurl as soon as there is data
received that needs to be saved. The size of the data
pointed to by ptr is size multiplied with nmemb, it will not
be zero terminated. Return the number of bytes actually
taken care of. If that amount differs from the amount passed
to your func- tion, it ll signal an error to the library and
it will abort the transfer and return CURLE_WRITE_ERROR.</p>

<p>This function may be called with zero bytes data if the
trans- fered file is empty.</p>

<p>Set this option to NULL to get the internal default
function. The internal default function will write the data
to the FILE * given with CURLOPT_WRITEDATA.</p>

<p>Set the stream argument with the CURLOPT_WRITEDATA
option.</p>

<p>The callback function will be passed as much data as
possible in all invokes, but you cannot possibly make any
assumptions. It may be one byte, it may be thousands. The
maximum amount of data that can be passed to the write
callback is defined in the curl.h header file:
CURL_MAX_WRITE_SIZE.</p>

<p>CURLOPT_WRITEDATA Data pointer to pass to the file write
function. If you use the CURLOPT_WRITEFUNCTION option, this
is the pointer youll get as input. If you dont use a
callback, you must pass a FILE * as libcurl will pass this
to fwrite() when writing data.</p>

<p>The internal CURLOPT_WRITEFUNCTION will write the data
to the FILE * given with this option, or to stdout if this
option hasnt been set.</p>

<p>If youre using libcurl as a win32 DLL, you MUST use the
CUR- LOPT_WRITEFUNCTION if you set this option or you will
experience crashes.</p>

<p>This option is also known with the older name
CURLOPT_FILE, the name CURLOPT_WRITEDATA was introduced in
7.9.7.</p>

<p>CURLOPT_READFUNCTION Function pointer that should match
the following prototype: size_t function( void *ptr, size_t
size, size_t nmemb, void *stream); This function gets called
by libcurl as soon as it needs to read data in order to send
it to the peer. The data area pointed at by the pointer ptr
may be filled with at most size multiplied with nmemb number
of bytes. Your function must return the actual number of
bytes that you stored in that memory area. Returning 0 will
signal end-of-file to the library and cause it to stop the
current transfer.</p>

<p>If you stop the current transfer by returning 0
&quot;pre-maturely&quot; (i.e before the server expected it,
like when you ve told you will upload N bytes and you upload
less than N bytes), you may experience that the server
&quot;hangs&quot; waiting for the rest of the data that wont
come.</p>

<p>The read callback may return CURL_READFUNC_ABORT to stop
the current operation immediately, resulting in a
CURLE_ABORTED_BY_CALLBACK error code from the transfer
(Added in 7.12.1)</p>

<p>If you set the callback pointer to NULL, or doesn t set
it at all, the default internal read function will be used.
It is sim- ply doing an fread() on the FILE * stream set
with CURLOPT_READ- DATA.</p>

<p>CURLOPT_READDATA Data pointer to pass to the file read
function. If you use the CURLOPT_READFUNCTION option, this
is the pointer youll get as input. If you don t specify a
read callback but instead rely on the default internal read
function, this data must be a valid readable FILE *.</p>

<p>If you re using libcurl as a win32 DLL, you MUST use a
CUR- LOPT_READFUNCTION if you set this option.</p>

<p>This option is also known with the older name
CURLOPT_INFILE, the name CURLOPT_READDATA was introduced in
7.9.7.</p>

<p>CURLOPT_IOCTLFUNCTION Function pointer that should match
the curl_ioctl_callback pro- totype found in
&lt;curl/curl.h&gt;. This function gets called by libcurl
when something special I/O-related needs to be done that the
library cant do by itself. For now, rewinding the read data
stream is the only action it can request. The rewinding of
the read data stream may be necessary when doing a HTTP PUT
or POST with a multi-pass authentication method. (Opion
added in 7.12.3)</p>

<p>CURLOPT_IOCTLDATA Pass a pointer that will be untouched
by libcurl and passed as the 3rd argument in the ioctl
callback set with CURLOPT_IOCTL- FUNCTION. (Option added in
7.12.3)</p>

<p>CURLOPT_PROGRESSFUNCTION Function pointer that should
match the curl_progress_callback prototype found in
&lt;curl/curl.h&gt;. This function gets called by libcurl
instead of its internal equivalent with a frequent interval
during operation (roughly once per second) no matter if data
is being transfered or not. Unknown/unused argument values
passed to the callback will be set to zero (like if you only
download data, the upload size will remain 0). Returning a
non- zero value from this callback will cause libcurl to
abort the transfer and return CURLE_ABORTED_BY_CALLBACK.</p>

<p>If you transfer data with the multi interface, this
function will not be called during periods of idleness
unless you call the appropriate libcurl function that
performs transfers. Usage of the CURLOPT_PROGRESSFUNCTION
callback is not recommended when using the multi
interface.</p>

<p>CURLOPT_NOPROGRESS must be set to FALSE to make this
function actually get called.</p>

<p>CURLOPT_PROGRESSDATA Pass a pointer that will be
untouched by libcurl and passed as the first argument in the
progress callback set with CURLOPT_PROGRESSFUNCTION.</p>

<p>CURLOPT_HEADERFUNCTION Function pointer that should
match the following prototype: size_t function( void *ptr,
size_t size, size_t nmemb, void *stream);. This function
gets called by libcurl as soon as it has received header
data. The header callback will be called once for each
header and only complete header lines are passed on to the
callback. Parsing headers should be easy enough using this.
The size of the data pointed to by ptr is size multiplied
with nmemb. Do not assume that the header line is zero
termi- nated! The pointer named stream is the one you set
with the CUR- LOPT_WRITEHEADER option. The callback function
must return the number of bytes actually taken care of, or
return -1 to signal error to the library (it will cause it
to abort the transfer with a CURLE_WRITE_ERROR return
code).</p>

<p>Since 7.14.1: When a server sends a chunked encoded
transfer, it may contain a trailer. That trailer is
identical to a HTTP header and if such a trailer is received
it is passed to the application using this callback as well.
There are several ways to detect it being a trailer and not
an ordinary header: 1) it comes after the response-body. 2)
it comes after the final header line (CR LF) 3) a Trailer:
header among the response- headers mention what header to
expect in the trailer.</p>

<p>CURLOPT_WRITEHEADER (This option is also known as
CURLOPT_HEADERDATA) Pass a pointer to be used to write the
header part of the received data to. If you dont use your
own callback to take care of the writing, this must be a
valid FILE *. See also the CURLOPT_HEADERFUNCTION option
above on how to set a custom get-all-headers callback.</p>

<p>CURLOPT_DEBUGFUNCTION Function pointer that should match
the following prototype: int curl_debug_callback (CURL *,
curl_infotype, char *, size_t, void *);
CURLOPT_DEBUGFUNCTION replaces the standard debug function
used when CURLOPT_VERBOSE is in effect. This callback
receives debug information, as specified with the
curl_infotype argument. This function must return 0. The
data pointed to by the char * passed to this function WILL
NOT be zero terminated, but will be exactly of the size as
told by the size_t argument.</p>

<p>Available curl_infotype values:</p>

<p>CURLINFO_TEXT The data is informational text.</p>

<p>CURLINFO_HEADER_IN The data is header (or header-like)
data received from the peer.</p>

<p>CURLINFO_HEADER_OUT The data is header (or header-like)
data sent to the peer.</p>

<p>CURLINFO_DATA_IN The data is protocol data received from
the peer.</p>

<p>CURLINFO_DATA_OUT The data is protocol data sent to the
peer.</p>

<p>CURLOPT_DEBUGDATA Pass a pointer to whatever you want
passed in to your CUR- LOPT_DEBUGFUNCTION in the last void *
argument. This pointer is not used by libcurl, it is only
passed to the callback.</p>

<p>CURLOPT_SSL_CTX_FUNCTION Function pointer that should
match the following prototype: CURLcode sslctxfun(CURL
*curl, void *sslctx, void *parm); This function gets called
by libcurl just before the initialization of an SSL
connection after having processed all other SSL related
options to give a last chance to an application to mod- ify
the behaviour of openssls ssl initialization. The sslctx
parameter is actually a pointer to an openssl SSL_CTX. If an
error is returned no attempt to establish a connection is
made and the perform operation will return the error code
from this callback function. Set the parm argument with the
CUR- LOPT_SSL_CTX_DATA option. This option was introduced in
7.11.0.</p>

<p>This function will get called on all new connections
made to a server, during the SSL negotiation. The SSL_CTX
pointer will be a new one every time.</p>

<p>To use this properly, a non-trivial amount of knowledge
of the openssl libraries is necessary. Using this function
allows for example to use openssl callbacks to add
additional validation code for certificates, and even to
change the actual URI of an HTTPS request (example used in
the lib509 test case). See also the example section for a
replacement of the key, certificate and trust file
settings.</p>

<p>CURLOPT_SSL_CTX_DATA Data pointer to pass to the ssl
context callback set by the option CURLOPT_SSL_CTX_FUNCTION,
this is the pointer youll get as third parameter, otherwise
NULL. (Added in 7.11.0)</p>

<p>CURLOPT_CONV_TO_NETWORK_FUNCTION</p>

<p>CURLOPT_CONV_FROM_NETWORK_FUNCTION</p>

<p>CURLOPT_CONV_FROM_UTF8_FUNCTION Function pointers that
should match the following prototype: CURLcode function(char
*ptr, size_t length);</p>

<p>These three options apply to non-ASCII platforms only.
They are available only if CURL_DOES_CONVERSIONS was defined
when libcurl was built. When this is the case,
curl_version_info(3) will return the CURL_VERSION_CONV
feature bit set.</p>

<p>The data to be converted is in a buffer pointed to by
the ptr parameter. The amount of data to convert is
indicated by the length parameter. The converted data
overlays the input data in the buffer pointed to by the ptr
parameter. CURLE_OK should be returned upon successful
conversion. A CURLcode return value defined by curl.h, such
as CURLE_CONV_FAILED, should be returned if an error was
encountered.</p>

<p>CURLOPT_CONV_TO_NETWORK_FUNCTION and
CURLOPT_CONV_FROM_NET- WORK_FUNCTION convert between the
host encoding and the network encoding. They are used when
commands or ASCII data are sent/received over the
network.</p>

<p>CURLOPT_CONV_FROM_UTF8_FUNCTION is called to convert
from UTF8 into the host encoding. It is required only for
SSL processing.</p>

<p>If you set a callback pointer to NULL, or dont set it at
all, the built-in libcurl iconv functions will be used. If
HAVE_ICONV was not defined when libcurl was built, and no
call- back has been established, conversion will return the
CURLE_CONV_REQD error code.</p>

<p>If HAVE_ICONV is defined, CURL_ICONV_CODESET_OF_HOST
must also be defined. For example:</p>

<p>#define CURL_ICONV_CODESET_OF_HOST
&quot;IBM-1047&quot;</p>

<p>The iconv code in libcurl will default the network and
UTF8 codeset names as follows:</p>

<p>#define CURL_ICONV_CODESET_OF_NETWORK
&quot;ISO8859-1&quot;</p>

<p>#define CURL_ICONV_CODESET_FOR_UTF8
&quot;UTF-8&quot;</p>

<p>You will need to override these definitions if they are
differ- ent on your system.</p>

<p>ERROR OPTIONS CURLOPT_ERRORBUFFER Pass a char * to a
buffer that the libcurl may store human read- able error
messages in. This may be more helpful than just the return
code from curl_easy_perform. The buffer must be at least
CURL_ERROR_SIZE big.</p>

<p>Use CURLOPT_VERBOSE and CURLOPT_DEBUGFUNCTION to better
debug/trace why errors happen.</p>

<p>If the library does not return an error, the buffer may
not have been touched. Do not rely on the contents in those
cases.</p>

<p>CURLOPT_STDERR Pass a FILE * as parameter. Tell libcurl
to use this stream instead of stderr when showing the
progress meter and displaying CURLOPT_VERBOSE data.</p>

<p>CURLOPT_FAILONERROR A non-zero parameter tells the
library to fail silently if the HTTP code returned is equal
to or larger than 400. The default action would be to return
the page normally, ignoring that code.</p>

<p>NETWORK OPTIONS CURLOPT_URL The actual URL to deal with.
The parameter should be a char * to a zero terminated
string. The string must remain present until curl no longer
needs it, as it doesnt copy the string.</p>

<p>If the given URL lacks the protocol part
(&quot;http://&quot; or &quot;ftp://&quot; etc), it will
attempt to guess which protocol to use based on the given
host name. If the given protocol of the set URL is not
supported, libcurl will return on error
(CURLE_UNSUPPORTED_PRO- TOCOL) when you call
curl_easy_perform(3) or curl_multi_per- form(3). Use
curl_version_info(3) for detailed info on which protocols
that are supported.</p>

<p>The string given to CURLOPT_URL must be url-encoded and
follow- ing the RFC 2396
(http://curl.haxx.se/rfc/rfc2396.txt).</p>

<p>CURLOPT_URL is the only option that must be set before
curl_easy_perform(3) is called.</p>

<p>CURLOPT_PROTOCOLS can be used to limit what protocols
libcurl will use for this transfer, independent of what
libcurl has been compiled to support. That may be useful if
you accept the URL from an external source and want to limit
the accessibility.</p>

<p>CURLOPT_PROTOCOLS Pass a long that holds a bitmask of
CURLPROTO_* defines. If used, this bitmask limits what
protocols libcurl may use in the transfer. This allows you
to have a libcurl built to support a wide range of protocols
but still limit specific transfers to only be allowed to use
a subset of them. By default libcurl will accept all
protocols it supports. See also CURLOPT_REDIR_PROTO- COLS.
(Added in 7.19.4)</p>

<p>CURLOPT_REDIR_PROTOCOLS Pass a long that holds a bitmask
of CURLPROTO_* defines. If used, this bitmask limits what
protocols libcurl may use in a transfer that it follows to
in a redirect when CURLOPT_FOLLOWLO- CATION is enabled. This
allows you to limit specific transfers to only be allowed to
use a subset of protocols in redirections. By default
libcurl will allow all protocols except for FILE and SCP.
This is a difference compared to pre-7.19.4 versions which
unconditionally would follow to all protocols supported.
(Added in 7.19.4)</p>

<p>CURLOPT_PROXY Set HTTP proxy to use. The parameter
should be a char * to a zero terminated string holding the
host name or dotted IP address. To specify port number in
this string, append :[port] to the end of the host name. The
proxy string may be prefixed with [protocol]:// since any
such prefix will be ignored. The proxys port number may
optionally be specified with the sepa- rate option
CURLOPT_PROXYPORT.</p>

<p>When you tell the library to use an HTTP proxy, libcurl
will transparently convert operations to HTTP even if you
specify an FTP URL etc. This may have an impact on what
other features of the library you can use, such as
CURLOPT_QUOTE and similar FTP specifics that don t work
unless you tunnel through the HTTP proxy. Such tunneling is
activated with CURLOPT_HTTPPROXYTUNNEL.</p>

<p>libcurl respects the environment variables http_proxy,
ftp_proxy, all_proxy etc, if any of those is set. The CUR-
LOPT_PROXY option does however override any possibly set
envi- ronment variables.</p>

<p>Starting with 7.14.1, the proxy host string can be
specified the exact same way as the proxy environment
variables, include pro- tocol prefix (http://) and embedded
user + password.</p>

<p>CURLOPT_PROXYPORT Pass a long with this option to set
the proxy port to connect to unless it is specified in the
proxy string CURLOPT_PROXY.</p>

<p>CURLOPT_PROXYTYPE Pass a long with this option to set
type of the proxy. Available options for this are
CURLPROXY_HTTP, CURLPROXY_SOCKS4 (added in 7.15.2)
CURLPROXY_SOCKS5. The HTTP type is default. (Added in
7.10)</p>

<p>CURLOPT_HTTPPROXYTUNNEL Set the parameter to non-zero to
get the library to tunnel all operations through a given
HTTP proxy. There is a big difference between using a proxy
and to tunnel through it. If you dont know what this means,
you probably dont want this tunneling option.</p>

<p>CURLOPT_INTERFACE Pass a char * as parameter. This set
the interface name to use as outgoing network interface. The
name can be an interface name, an IP address or a host
name.</p>

<p>CURLOPT_LOCALPORT Pass a long. This sets the local port
number of the socket used for connection. This can be used
in combination with CURLOPT_INTERFACE and you are
recommended to use CURLOPT_LOCAL- PORTRANGE as well when
this is set. Note that port numbers are only valid 1 -
65535. (Added in 7.15.2)</p>

<p>CURLOPT_LOCALPORTRANGE Pass a long. This is the number
of attempts libcurl should do to find a working local port
number. It starts with the given CUR- LOPT_LOCALPORT and
adds one to the number for each retry. Set- ting this value
to 1 or below will make libcurl do only one try for exact
port number. Note that port numbers by nature is a scarce
resource that will be busy at times so setting this value to
something too low might cause unnecessary connection setup
failures. (Added in 7.15.2)</p>

<p>CURLOPT_DNS_CACHE_TIMEOUT Pass a long, this sets the
timeout in seconds. Name resolves will be kept in memory for
this number of seconds. Set to zero (0) to completely
disable caching, or set to -1 to make the cached entries
remain forever. By default, libcurl caches this info for 60
seconds.</p>

<p>CURLOPT_DNS_USE_GLOBAL_CACHE Pass a long. If the value
is non-zero, it tells curl to use a global DNS cache that
will survive between easy handle creations and deletions.
This is not thread-safe and this will use a global
variable.</p>

<p>WARNING: this option is considered obsolete. Stop using
it. Switch over to using the share interface instead! See
CUR- LOPT_SHARE and curl_share_init(3).</p>

<p>CURLOPT_BUFFERSIZE Pass a long specifying your preferred
size (in bytes) for the receive buffer in libcurl. The main
point of this would be that the write callback gets called
more often and with smaller chunks. This is just treated as
a request, not an order. You cannot be guaranteed to
actually get the given size. (Added in 7.10)</p>

<p>This size is by default set as big as possible
(CURL_MAX_WRITE_SIZE), so it only makse sense to use this
option if you want it smaller.</p>

<p>CURLOPT_PORT Pass a long specifying what remote port
number to connect to, instead of the one specified in the
URL or the default port for the used protocol.</p>

<p>CURLOPT_TCP_NODELAY Pass a long specifying whether the
TCP_NODELAY option should be set or cleared (1 = set, 0 =
clear). The option is cleared by default. This will have no
effect after the connection has been established.</p>

<p>Setting this option will disable TCP s Nagle algorithm.
The pur- pose of this algorithm is to try to minimize the
number of small packets on the network (where &quot;small
packets&quot; means TCP segments less than the Maximum
Segment Size (MSS) for the network).</p>

<p>Maximizing the amount of data sent per TCP segment is
good because it amortizes the overhead of the send. However,
in some cases (most notably telnet or rlogin) small segments
may need to be sent without delay. This is less efficient
than sending larger amounts of data at a time, and can
contribute to conges- tion on the network if overdone.</p>

<p>NAMES and PASSWORDS OPTIONS (Authentication)
CURLOPT_NETRC This parameter controls the preference of
libcurl between using user names and passwords from your
~/.netrc file, relative to user names and passwords in the
URL supplied with CURLOPT_URL.</p>

<p>libcurl uses a user name (and supplied or prompted
password) supplied with CURLOPT_USERPWD in preference to any
of the options controlled by this parameter.</p>

<p>Pass a long, set to one of the values described
below.</p>

<p>CURL_NETRC_OPTIONAL The use of your ~/.netrc file is
optional, and informa- tion in the URL is to be preferred.
The file will be scanned with the host and user name (to
find the password only) or with the host only, to find the
first user name and password after that machine, which ever
information is not specified in the URL.</p>

<p>Undefined values of the option will have this
effect.</p>

<p>CURL_NETRC_IGNORED The library will ignore the file and
use only the infor- mation in the URL.</p>

<p>This is the default.</p>

<p>CURL_NETRC_REQUIRED This value tells the library that
use of the file is required, to ignore the information in
the URL, and to search the file with the host only. Only
machine name, user name and password are taken into account
(init macros and similar things arent supported).</p>

<p>libcurl does not verify that the file has the correct
properties set (as the standard Unix ftp client does). It
should only be readable by user.</p>

<p>CURLOPT_NETRC_FILE Pass a char * as parameter, pointing
to a zero terminated string containing the full path name to
the file you want libcurl to use as .netrc file. If this
option is omitted, and CURLOPT_NETRC is set, libcurl will
attempt to find the a .netrc file in the current users home
directory. (Added in 7.10.9)</p>

<p>CURLOPT_USERPWD Pass a char * as parameter, which should
be [user name]:[pass- word] to use for the connection. Use
CURLOPT_HTTPAUTH to decide authentication method.</p>

<p>When using NTLM, you can set domain by prepending it to
the user name and separating the domain and name with a
forward (/) or backward slash (. Like this:
&quot;domain/user:password&quot; or
&quot;domainser:password&quot;. Some HTTP servers (on
Windows) support this style even for Basic
authentication.</p>

<p>When using HTTP and CURLOPT_FOLLOWLOCATION, libcurl
might per- form several requests to possibly different
hosts. libcurl will only send this user and password
information to hosts using the initial host name (unless
CURLOPT_UNRESTRICTED_AUTH is set), so if libcurl follows
locations to other hosts it will not send the user and
password to those. This is enforced to prevent acciden- tal
information leakage.</p>

<p>CURLOPT_PROXYUSERPWD Pass a char * as parameter, which
should be [user name]:[pass- word] to use for the connection
to the HTTP proxy. Use CUR- LOPT_PROXYAUTH to decide
authentication method.</p>

<p>CURLOPT_HTTPAUTH Pass a long as parameter, which is set
to a bitmask, to tell libcurl what authentication method(s)
you want it to use. The available bits are listed below. If
more than one bit is set, libcurl will first query the site
to see what authentication methods it supports and then pick
the best one you allow it to use. For some methods, this
will induce an extra network round- trip. Set the actual
name and password with the CURLOPT_USERPWD option. (Added in
7.10.6)</p>

<p>CURLAUTH_BASIC HTTP Basic authentication. This is the
default choice, and the only method that is in wide-spread
use and sup- ported virtually everywhere. This is sending
the user name and password over the network in plain text,
easily captured by others.</p>

<p>CURLAUTH_DIGEST HTTP Digest authentication. Digest
authentication is defined in RFC2617 and is a more secure
way to do authen- tication over public networks than the
regular old-fash- ioned Basic method.</p>

<p>CURLAUTH_GSSNEGOTIATE HTTP GSS-Negotiate authentication.
The GSS-Negotiate (also known as plain
&quot;Negotiate&quot;) method was designed by Microsoft and
is used in their web applications. It is primarily meant as
a support for Kerberos5 authentication but may be also used
along with another authentication methods. For more
information see IETF draft draft-
brezak-spnego-http-04.txt.</p>

<p>You need to build libcurl with a suitable GSS-API
library for this to work.</p>

<p>CURLAUTH_NTLM HTTP NTLM authentication. A proprietary
protocol invented and used by Microsoft. It uses a
challenge-response and hash concept similar to Digest, to
prevent the password from being eavesdropped.</p>

<p>You need to build libcurl with OpenSSL support for this
option to work, or build libcurl on Windows.</p>

<p>CURLAUTH_ANY This is a convenience macro that sets all
bits and thus makes libcurl pick any it finds suitable.
libcurl will automatically select the one it finds most
secure.</p>

<p>CURLAUTH_ANYSAFE This is a convenience macro that sets
all bits except Basic and thus makes libcurl pick any it
finds suitable. libcurl will automatically select the one it
finds most secure.</p>

<p>CURLOPT_PROXYAUTH Pass a long as parameter, which is set
to a bitmask, to tell libcurl what authentication method(s)
you want it to use for your proxy authentication. If more
than one bit is set, libcurl will first query the site to
see what authentication methods it supports and then pick
the best one you allow it to use. For some methods, this
will induce an extra network round-trip. Set the actual name
and password with the CURLOPT_PROXYUSERPWD option. The
bitmask can be constructed by or ing together the bits
listed above for the CURLOPT_HTTPAUTH option. As of this
writing, only Basic, Digest and NTLM work. (Added in
7.10.7)</p>

<p>HTTP OPTIONS CURLOPT_AUTOREFERER Pass a non-zero
parameter to enable this. When enabled, libcurl will
automatically set the Referer: field in requests where it
follows a Location: redirect.</p>

<p>CURLOPT_ENCODING Sets the contents of the
Accept-Encoding: header sent in an HTTP request, and enables
decoding of a response when a Content- Encoding: header is
received. Three encodings are supported: identity, which
does nothing, deflate which requests the server to compress
its response using the zlib algorithm, and gzip which
requests the gzip algorithm. If a zero-length string is set,
then an Accept-Encoding: header containing all supported
encodings is sent.</p>

<p>This is a request, not an order; the server may or may
not do it. This option must be set (to any non-NULL value)
or else any unsolicited encoding done by the server is
ignored. See the spe- cial file lib/README.encoding for
details.</p>

<p>CURLOPT_FOLLOWLOCATION A non-zero parameter tells the
library to follow any Location: header that the server sends
as part of an HTTP header.</p>

<p>This means that the library will re-send the same
request on the new location and follow new Location: headers
all the way until no more such headers are returned.
CURLOPT_MAXREDIRS can be used to limit the number of
redirects libcurl will follow.</p>

<p>NOTE: since 7.19.4, libcurl can limit to what protocols
it will automatically follow. The accepted protocols are set
with CUR- LOPT_REDIR_PROTOCOLS and it excludes the FILE
protocol by default.</p>

<p>CURLOPT_UNRESTRICTED_AUTH A non-zero parameter tells the
library it can continue to send authentication
(user+password) when following locations, even when hostname
changed. This option is meaningful only when set- ting
CURLOPT_FOLLOWLOCATION.</p>

<p>CURLOPT_MAXREDIRS Pass a long. The set number will be
the redirection limit. If that many redirections have been
followed, the next redirect will cause an error
(CURLE_TOO_MANY_REDIRECTS). This option only makes sense if
the CURLOPT_FOLLOWLOCATION is used at the same time. Added
in 7.15.1: Setting the limit to 0 will make libcurl refuse
any redirect. Set it to -1 for an infinite number of
redirects (which is the default)</p>

<p>CURLOPT_PUT A non-zero parameter tells the library to
use HTTP PUT to trans- fer data. The data should be set with
CURLOPT_READDATA and CUR- LOPT_INFILESIZE.</p>

<p>This option is deprecated and starting with version
7.12.1 you should instead use CURLOPT_UPLOAD.</p>

<p>CURLOPT_POST A non-zero parameter tells the library to
do a regular HTTP post. This will also make the library use
the a &quot;Content-Type:
application/x-www-form-urlencoded&quot; header. (This is by
far the most commonly used POST method).</p>

<p>Use the CURLOPT_POSTFIELDS option to specify what data
to post and CURLOPT_POSTFIELDSIZE to set the data size.</p>

<p>Optionally, you can provide data to POST using the
CURLOPT_READ- FUNCTION and CURLOPT_READDATA options but then
you must make sure to not set CURLOPT_POSTFIELDS to anything
but NULL. When providing data with a callback, you must
transmit it using chun- ked transfer-encoding or you must
set the size of the data with the CURLOPT_POSTFIELDSIZE
option.</p>

<p>You can override the default POST Content-Type: header
by set- ting your own with CURLOPT_HTTPHEADER.</p>

<p>Using POST with HTTP 1.1 implies the use of a
&quot;Expect: 100-con- tinue&quot; header. You can disable
this header with CURLOPT_HTTP- HEADER as usual.</p>

<p>If you use POST to a HTTP 1.1 server, you can send data
without knowing the size before starting the POST if you use
chunked encoding. You enable this by adding a header like
&quot;Transfer- Encoding: chunked&quot; with
CURLOPT_HTTPHEADER. With HTTP 1.0 or without chunked
transfer, you must specify the size in the request.</p>

<p>When setting CURLOPT_POST to a non-zero value, it will
automati- cally set CURLOPT_NOBODY to 0 (since 7.14.1).</p>

<p>If you issue a POST request and then want to make a HEAD
or GET using the same re-used handle, you must explictly set
the new request type using CURLOPT_NOBODY or CURLOPT_HTTPGET
or similar.</p>

<p>CURLOPT_POSTFIELDS Pass a char * as parameter, which
should be the full data to post in an HTTP POST operation.
You must make sure that the data is formatted the way you
want the server to receive it. libcurl will not convert or
encode it for you. Most web servers will assume this data to
be url-encoded. Take note.</p>

<p>This POST is a normal application/x-www-form-urlencoded
kind (and libcurl will set that Content-Type by default when
this option is used), which is the most commonly used one by
HTML forms. See also the CURLOPT_POST. Using
CURLOPT_POSTFIELDS implies CURLOPT_POST.</p>

<p>Using POST with HTTP 1.1 implies the use of a
&quot;Expect: 100-con- tinue&quot; header. You can disable
this header with CURLOPT_HTTP- HEADER as usual.</p>

<p>To make multipart/formdata posts (aka rfc1867-posts),
check out the CURLOPT_HTTPPOST option.</p>

<p>CURLOPT_POSTFIELDSIZE If you want to post data to the
server without letting libcurl do a strlen() to measure the
data size, this option must be used. When this option is
used you can post fully binary data, which otherwise is
likely to fail. If this size is set to -1, the library will
use strlen() to get the size.</p>

<p>CURLOPT_POSTFIELDSIZE_LARGE Pass a curl_off_t as
parameter. Use this to set the size of the
CURLOPT_POSTFIELDS data to prevent libcurl from doing
strlen() on the data to figure out the size. This is the
large file ver- sion of the CURLOPT_POSTFIELDSIZE option.
(Added in 7.11.1)</p>

<p>CURLOPT_HTTPPOST Tells libcurl you want a
multipart/formdata HTTP POST to be made and you instruct
what data to pass on to the server. Pass a pointer to a
linked list of curl_httppost structs as parameter. . The
easiest way to create such a list, is to use curl_for-
madd(3) as documented. The data in this list must remain
intact until you close this curl handle again with
curl_easy_cleanup(3).</p>

<p>Using POST with HTTP 1.1 implies the use of a
&quot;Expect: 100-con- tinue&quot; header. You can disable
this header with CURLOPT_HTTP- HEADER as usual.</p>

<p>When setting CURLOPT_HTTPPOST, it will automatically set
CUR- LOPT_NOBODY to 0 (since 7.14.1).</p>

<p>CURLOPT_REFERER Pass a pointer to a zero terminated
string as parameter. It will be used to set the Referer:
header in the http request sent to the remote server. This
can be used to fool servers or scripts. You can also set any
custom header with CURLOPT_HTTPHEADER.</p>

<p>CURLOPT_USERAGENT Pass a pointer to a zero terminated
string as parameter. It will be used to set the User-Agent:
header in the http request sent to the remote server. This
can be used to fool servers or scripts. You can also set any
custom header with CURLOPT_HTTP- HEADER.</p>

<p>CURLOPT_HTTPHEADER Pass a pointer to a linked list of
HTTP headers to pass to the server in your HTTP request. The
linked list should be a fully valid list of struct
curl_slist structs properly filled in. Use
curl_slist_append(3) to create the list and
curl_slist_free_all(3) to clean up an entire list. If you
add a header that is otherwise generated and used by libcurl
inter- nally, your added one will be used instead. If you
add a header with no contents as in Accept: (no data on the
right side of the colon), the internally used header will
get disabled. Thus, using this option you can add new
headers, replace internal headers and remove internal
headers. To add a header with no contents, make the contents
be two quotes: &quot;&quot;. The headers included in the
linked list must not be CRLF-terminated, because curl adds
CRLF after each header item. Failure to comply with this
will result in strange bugs because the server will most
likely ignore part of the headers you specified.</p>

<p>The first line in a request (containing the method,
usually a GET or POST) is not a header and cannot be
replaced using this option. Only the lines following the
request-line are headers. Adding this method line in this
list of headers will only cause your request to send an
invalid header.</p>

<p>Pass a NULL to this to reset back to no custom
headers.</p>

<p>The most commonly replaced headers have
&quot;shortcuts&quot; in the options CURLOPT_COOKIE,
CURLOPT_USERAGENT and CURLOPT_REFERER.</p>

<p>CURLOPT_HTTP200ALIASES Pass a pointer to a linked list
of aliases to be treated as valid HTTP 200 responses. Some
servers respond with a custom header response line. For
example, IceCast servers respond with &quot;ICY 200
OK&quot;. By including this string in your list of aliases,
the response will be treated as a valid HTTP header line
such as &quot;HTTP/1.0 200 OK&quot;. (Added in 7.10.3)</p>

<p>The linked list should be a fully valid list of struct
curl_slist structs, and be properly filled in. Use
curl_slist_append(3) to create the list and
curl_slist_free_all(3) to clean up an entire list.</p>

<p>The alias itself is not parsed for any version strings.
So if your alias is &quot;MYHTTP/9.9&quot;, Libcurl will not
treat the server as responding with HTTP version 9.9.
Instead Libcurl will use the value set by option
CURLOPT_HTTP_VERSION.</p>

<p>CURLOPT_COOKIE Pass a pointer to a zero terminated
string as parameter. It will be used to set a cookie in the
http request. The format of the string should be
NAME=CONTENTS, where NAME is the cookie name and CONTENTS is
what the cookie should contain.</p>

<p>If you need to set multiple cookies, you need to set
them all using a single option and thus you need to
concatenate them all in one single string. Set multiple
cookies in one string like this: &quot;name1=content1;
name2=content2;&quot; etc.</p>

<p>Using this option multiple times will only make the
latest string override the previously ones.</p>

<p>CURLOPT_COOKIEFILE Pass a pointer to a zero terminated
string as parameter. It should contain the name of your file
holding cookie data to read. The cookie data may be in
Netscape / Mozilla cookie data format or just regular
HTTP-style headers dumped to a file.</p>

<p>Given an empty or non-existing file or by passing the
empty string (&quot;&quot;), this option will enable cookies
for this curl han- dle, making it understand and parse
received cookies and then use matching cookies in future
request.</p>

<p>If you use this option multiple times, you just add more
files to read. Subsequent files will add more cookies.</p>

<p>CURLOPT_COOKIEJAR Pass a file name as char *, zero
terminated. This will make libcurl write all internally
known cookies to the specified file when
curl_easy_cleanup(3) is called. If no cookies are known, no
file will be created. Specify &quot;-&quot; to instead have
the cookies written to stdout. Using this option also
enables cookies for this session, so if you for example
follow a location it will make matching cookies get sent
accordingly.</p>

<p>If the cookie jar file cant be created or written to
(when the curl_easy_cleanup(3) is called), libcurl will not
and cannot report an error for this. Using CURLOPT_VERBOSE
or CUR- LOPT_DEBUGFUNCTION will get a warning to display,
but that is the only visible feedback you get about this
possibly lethal situation.</p>

<p>CURLOPT_COOKIESESSION Pass a long set to non-zero to
mark this as a new cookie &quot;ses- sion&quot;. It will
force libcurl to ignore all cookies it is about to load that
are &quot;session cookies&quot; from the previous session.
By default, libcurl always stores and loads all cookies,
indepen- dent if they are session cookies are not. Session
cookies are cookies without expiry date and they are meant
to be alive and existing for this &quot;session&quot;
only.</p>

<p>CURLOPT_COOKIELIST Pass a char * to a cookie string.
Cookie can be either in Netscape / Mozilla format or just
regular HTTP-style header (Set-Cookie: ...) format. If cURL
cookie engine was not enabled it will enable its cookie
engine. Passing a magic string &quot;ALL&quot; will erase
all cookies known by cURL. (Added in 7.14.1) Passing the
special string &quot;SESS&quot; will only erase all session
cookies known by cURL. (Added in 7.15.4)</p>

<p>CURLOPT_HTTPGET Pass a long. If the long is non-zero,
this forces the HTTP request to get back to GET. usable if a
POST, HEAD, PUT or a custom request have been used
previously using the same curl handle.</p>

<p>When setting CURLOPT_HTTPGET to a non-zero value, it
will auto- matically set CURLOPT_NOBODY to 0 (since
7.14.1).</p>

<p>CURLOPT_HTTP_VERSION Pass a long, set to one of the
values described below. They force libcurl to use the
specific HTTP versions. This is not sensible to do unless
you have a good reason.</p>

<p>CURL_HTTP_VERSION_NONE We don t care about what version
the library uses. libcurl will use whatever it thinks
fit.</p>

<p>CURL_HTTP_VERSION_1_0 Enforce HTTP 1.0 requests.</p>

<p>CURL_HTTP_VERSION_1_1 Enforce HTTP 1.1 requests.</p>

<p>CURLOPT_IGNORE_CONTENT_LENGTH Ignore the Content-Length
header. This is useful for Apache 1.x (and similar servers)
which will report incor- rect content length for files over
2 gigabytes. If this option is used, curl will not be able
to accurately report progress, and will simply stop the
download when the server ends the connection. (added in
7.14.1)</p>

<p>FTP OPTIONS CURLOPT_FTPPORT Pass a pointer to a zero
terminated string as parameter. It will be used to get the
IP address to use for the ftp PORT instruc- tion. The PORT
instruction tells the remote server to connect to our
specified IP address. The string may be a plain IP address,
a host name, an network interface name (under Unix) or just
a - letter to let the library use your systems default IP
address. Default FTP operations are passive, and thus wont
use PORT.</p>

<p>You disable PORT again and go back to using the passive
version by setting this option to NULL.</p>

<p>CURLOPT_QUOTE Pass a pointer to a linked list of FTP
commands to pass to the server prior to your ftp request.
This will be done before any other FTP commands are issued
(even before the CWD command). The linked list should be a
fully valid list of to append strings (commands) to the
list, and clear the entire list afterwards with
curl_slist_free_all(3). Disable this operation again by
setting a NULL to this option.</p>

<p>CURLOPT_POSTQUOTE Pass a pointer to a linked list of FTP
commands to pass to the server after your ftp transfer
request. The linked list should be a fully valid list of
struct curl_slist structs properly filled in as described
for CURLOPT_QUOTE. Disable this operation again by setting a
NULL to this option.</p>

<p>CURLOPT_PREQUOTE Pass a pointer to a linked list of FTP
commands to pass to the server after the transfer type is
set. The linked list should be a fully valid list of struct
curl_slist structs properly filled in as described for
CURLOPT_QUOTE. Disable this operation again by setting a
NULL to this option.</p>

<p>CURLOPT_FTPLISTONLY A non-zero parameter tells the
library to just list the names of an ftp directory, instead
of doing a full directory listing that would include file
sizes, dates etc.</p>

<p>This causes an FTP NLST command to be sent. Beware that
some FTP servers list only files in their response to NLST;
they might not include subdirectories and symbolic
links.</p>

<p>CURLOPT_FTPAPPEND A non-zero parameter tells the library
to append to the remote file instead of overwrite it. This
is only useful when uploading to an ftp site.</p>

<p>CURLOPT_FTP_USE_EPRT Pass a long. If the value is
non-zero, it tells curl to use the EPRT (and LPRT) command
when doing active FTP downloads (which is enabled by
CURLOPT_FTPPORT). Using EPRT means that it will first
attempt to use EPRT and then LPRT before using PORT, but if
you pass FALSE (zero) to this option, it will not try using
EPRT or LPRT, only plain PORT. (Added in 7.10.5)</p>

<p>If the server is an IPv6 host, this option will have no
effect as of 7.12.3.</p>

<p>CURLOPT_FTP_USE_EPSV Pass a long. If the value is
non-zero, it tells curl to use the EPSV command when doing
passive FTP downloads (which it always does by default).
Using EPSV means that it will first attempt to use EPSV
before using PASV, but if you pass FALSE (zero) to this
option, it will not try using EPSV, only plain PASV.</p>

<p>If the server is an IPv6 host, this option will have no
effect as of 7.12.3.</p>

<p>CURLOPT_FTP_CREATE_MISSING_DIRS Pass a long. If the
value is non-zero, curl will attempt to cre- ate any remote
directory that it fails to CWD into. CWD is the command that
changes working directory. (Added in 7.10.7)</p>

<p>CURLOPT_FTP_RESPONSE_TIMEOUT Pass a long. Causes curl to
set a timeout period (in seconds) on the amount of time that
the server is allowed to take in order to generate a
response message for a command before the session is
considered hung. While curl is waiting for a response, this
value overrides CURLOPT_TIMEOUT. It is recom- mended that if
used in conjunction with CURLOPT_TIMEOUT, you set
CURLOPT_FTP_RESPONSE_TIMEOUT to a value smaller than CUR-
LOPT_TIMEOUT. (Added in 7.10.8)</p>

<p>CURLOPT_FTP_ALTERNATIVE_TO_USER Pass a char * as
parameter, pointing to a string which will be used to
authenticate if the usual FTP &quot;USER user&quot; and
&quot;PASS password&quot; negotiation fails. This is
currently only known to be required when connecting to
Tumbleweed s Secure Transport FTPS server using client
certificates for authentication. (Added in 7.15.5)</p>

<p>CURLOPT_FTP_SKIP_PASV_IP Pass a long. If set to a
non-zero value, it instructs libcurl to not use the IP
address the server suggests in its 227-response to libcurls
PASV command when libcurl connects the data connec- tion.
Instead libcurl will re-use the same IP address it already
uses for the control connection. But it will use the port
number from the 227-response. (Added in 7.14.2)</p>

<p>This option has no effect if PORT, EPRT or EPSV is used
instead of PASV.</p>

<p>CURLOPT_FTP_SSL Pass a long using one of the values from
below, to make libcurl use your desired level of SSL for the
ftp transfer. (Added in 7.11.0)</p>

<p>CURLFTPSSL_NONE Dont attempt to use SSL.</p>

<p>CURLFTPSSL_TRY Try using SSL, proceed as normal
otherwise.</p>

<p>CURLFTPSSL_CONTROL Require SSL for the control
connection or fail with CURLE_FTP_SSL_FAILED.</p>

<p>CURLFTPSSL_ALL Require SSL for all communication or fail
with CURLE_FTP_SSL_FAILED.</p>

<p>CURLOPT_FTPSSLAUTH Pass a long using one of the values
from below, to alter how libcurl issues &quot;AUTH TLS&quot;
or &quot;AUTH SSL&quot; when FTP over SSL is activated (see
CURLOPT_FTP_SSL). (Added in 7.12.2)</p>

<p>CURLFTPAUTH_DEFAULT Allow libcurl to decide</p>

<p>CURLFTPAUTH_SSL Try &quot;AUTH SSL&quot; first, and only
if that fails try &quot;AUTH TLS&quot;</p>

<p>CURLFTPAUTH_TLS Try &quot;AUTH TLS&quot; first, and only
if that fails try &quot;AUTH SSL&quot;</p>

<p>CURLOPT_SOURCE_URL When set, it enables a FTP third
party transfer, using the set URL as source, while
CURLOPT_URL is the target.</p>

<p>CURLOPT_SOURCE_USERPWD Set &quot;username:password&quot;
to use for the source connection when doing FTP third party
transfers.</p>

<p>CURLOPT_SOURCE_QUOTE Exactly like CURLOPT_QUOTE, but for
the source host.</p>

<p>CURLOPT_SOURCE_PREQUOTE Exactly like CURLOPT_PREQUOTE,
but for the source host.</p>

<p>CURLOPT_SOURCE_POSTQUOTE Exactly like CURLOPT_POSTQUOTE,
but for the source host.</p>

<p>CURLOPT_FTP_ACCOUNT Pass a pointer to a zero-terminated
string (or NULL to disable). When an FTP server asks for
&quot;account data&quot; after user name and password has
been provided, this data is sent off using the ACCT command.
(Added in 7.13.0)</p>

<p>CURLOPT_FTP_FILEMETHOD Pass a long that should have one
of the following values. This option controls what method
libcurl should use to reach a file on a FTP(S) server. The
argument should be one of the following alternatives:</p>

<p>CURLFTPMETHOD_MULTICWD libcurl does a single CWD
operation for each path part in the given URL. For deep
hierarchies this means very many commands. This is how
RFC1738 says it should be done. This is the default but the
slowest behavior.</p>

<p>CURLFTPMETHOD_NOCWD libcurl does no CWD at all. libcurl
will do SIZE, RETR, STOR etc and give a full path to the
server for all these commands. This is the fastest
behavior.</p>

<p>CURLFTPMETHOD_SINGLECWD libcurl does one CWD with the
full target directory and then operates on the file
&quot;normally&quot; (like in the multi- cwd case). This is
somewhat more standards compliant than nocwd but without the
full penalty of multicwd.</p>

<p>PROTOCOL OPTIONS CURLOPT_TRANSFERTEXT A non-zero
parameter tells the library to use ASCII mode for ftp
transfers, instead of the default binary transfer. For win32
systems it does not set the stdout to binary mode. This
option can be usable when transferring text data between
systems with different views on certain characters, such as
newlines or simi- lar.</p>

<p>libcurl does not do a complete ASCII conversion when
doing ASCII transfers over FTP. This is a known
limitation/flaw that nobody has rectified. libcurl simply
sets the mode to ascii and per- forms a standard
transfer.</p>

<p>CURLOPT_CRLF Convert Unix newlines to CRLF newlines on
transfers.</p>

<p>CURLOPT_RANGE Pass a char * as parameter, which should
contain the specified range you want. It should be in the
format &quot;X-Y&quot;, where X or Y may be left out. HTTP
transfers also support several intervals, separated with
commas as in &quot;X-Y,N-M&quot;. Using this kind of multi-
ple intervals will cause the HTTP server to send the
response document in pieces (using standard MIME separation
techniques). Pass a NULL to this option to disable the use
of ranges.</p>

<p>CURLOPT_RESUME_FROM Pass a long as parameter. It
contains the offset in number of bytes that you want the
transfer to start from. Set this option to 0 to make the
transfer start from the beginning (effectively disabling
resume).</p>

<p>CURLOPT_RESUME_FROM_LARGE Pass a curl_off_t as
parameter. It contains the offset in number of bytes that
you want the transfer to start from. (Added in 7.11.0)</p>

<p>CURLOPT_CUSTOMREQUEST Pass a pointer to a zero
terminated string as parameter. It will be user instead of
GET or HEAD when doing an HTTP request, or instead of LIST
or NLST when doing an ftp directory listing. This is useful
for doing DELETE or other more or less obscure HTTP
requests. Dont do this at will, make sure your server sup-
ports the command first.</p>

<p>Restore to the internal default by setting this to
NULL.</p>

<p>Many people have wrongly used this option to replace the
entire request with their own, including multiple headers
and POST con- tents. While that might work in many cases, it
will cause libcurl to send invalid requests and it could
possibly confuse the remote server badly. Use CURLOPT_POST
and CURLOPT_POSTFIELDS to set POST data. Use
CURLOPT_HTTPHEADER to replace or extend the set of headers
sent by libcurl. Use CURLOPT_HTTP_VERSION to change HTTP
version.</p>

<p>CURLOPT_FILETIME Pass a long. If it is a non-zero value,
libcurl will attempt to get the modification date of the
remote document in this opera- tion. This requires that the
remote server sends the time or replies to a time querying
command. The curl_easy_getinfo(3) function with the
CURLINFO_FILETIME argument can be used after a transfer to
extract the received time (if any).</p>

<p>CURLOPT_NOBODY A non-zero parameter tells the library to
not include the body- part in the output. This is only
relevant for protocols that have separate header and body
parts. On HTTP(S) servers, this will make libcurl do a HEAD
request.</p>

<p>To change request to GET, you should use
CURLOPT_HTTPGET. Change request to POST with CURLOPT_POST
etc.</p>

<p>CURLOPT_INFILESIZE When uploading a file to a remote
site, this option should be used to tell libcurl what the
expected size of the infile is. This value should be passed
as a long. See also CURLOPT_INFILE- SIZE_LARGE.</p>

<p>CURLOPT_INFILESIZE_LARGE When uploading a file to a
remote site, this option should be used to tell libcurl what
the expected size of the infile is. This value should be
passed as a curl_off_t. (Added in 7.11.0)</p>

<p>CURLOPT_UPLOAD A non-zero parameter tells the library to
prepare for an upload. The CURLOPT_READDATA and
CURLOPT_INFILESIZEE or CURLOPT_INFILE- SIZE_LARGE are also
interesting for uploads. If the protocol is HTTP, uploading
means using the PUT request unless you tell libcurl
otherwise.</p>

<p>Using PUT with HTTP 1.1 implies the use of a
&quot;Expect: 100-con- tinue&quot; header. You can disable
this header with CURLOPT_HTTP- HEADER as usual.</p>

<p>If you use PUT to a HTTP 1.1 server, you can upload data
without knowing the size before starting the transfer if you
use chunked encoding. You enable this by adding a header
like &quot;Transfer- Encoding: chunked&quot; with
CURLOPT_HTTPHEADER. With HTTP 1.0 or without chunked
transfer, you must specify the size.</p>

<p>CURLOPT_MAXFILESIZE Pass a long as parameter. This
allows you to specify the maximum size (in bytes) of a file
to download. If the file requested is larger than this
value, the transfer will not start and
CURLE_FILESIZE_EXCEEDED will be returned.</p>

<p>The file size is not always known prior to download, and
for such files this option has no effect even if the file
transfer ends up being larger than this given limit. This
concerns both FTP and HTTP transfers.</p>

<p>CURLOPT_MAXFILESIZE_LARGE Pass a curl_off_t as
parameter. This allows you to specify the maximum size (in
bytes) of a file to download. If the file requested is
larger than this value, the transfer will not start and
CURLE_FILESIZE_EXCEEDED will be returned. (Added in
7.11.0)</p>

<p>The file size is not always known prior to download, and
for such files this option has no effect even if the file
transfer ends up being larger than this given limit. This
concerns both FTP and HTTP transfers.</p>

<p>CURLOPT_TIMECONDITION Pass a long as parameter. This
defines how the CURLOPT_TIMEVALUE time value is treated. You
can set this parameter to CURL_TIME- COND_IFMODSINCE or
CURL_TIMECOND_IFUNMODSINCE. This feature applies to HTTP and
FTP.</p>

<p>The last modification time of a file is not always known
and in such instances this feature will have no effect even
if the given time condition would have not been met.</p>

<p>CURLOPT_TIMEVALUE Pass a long as parameter. This should
be the time in seconds since 1 jan 1970, and the time will
be used in a condition as specified with
CURLOPT_TIMECONDITION.</p>

<p>CONNECTION OPTIONS CURLOPT_TIMEOUT Pass a long as
parameter containing the maximum time in seconds that you
allow the libcurl transfer operation to take. Normally, name
lookups can take a considerable time and limiting opera-
tions to less than a few minutes risk aborting perfectly
normal operations. This option will cause curl to use the
SIGALRM to enable time-outing system calls.</p>

<p>In unix-like systems, this might cause signals to be
used unless CURLOPT_NOSIGNAL is set.</p>

<p>CURLOPT_LOW_SPEED_LIMIT Pass a long as parameter. It
contains the transfer speed in bytes per second that the
transfer should be below during CUR- LOPT_LOW_SPEED_TIME
seconds for the library to consider it too slow and
abort.</p>

<p>CURLOPT_LOW_SPEED_TIME Pass a long as parameter. It
contains the time in seconds that the transfer should be
below the CURLOPT_LOW_SPEED_LIMIT for the library to
consider it too slow and abort.</p>

<p>CURLOPT_MAX_SEND_SPEED_LARGE Pass a curl_off_t as
parameter. If an upload exceeds this speed on cumulative
average during the transfer, the transfer will pause to keep
the average rate less than or equal to the parame- ter
value. (default: 0, unlimited)</p>

<p>CURLOPT_MAX_RECV_SPEED_LARGE Pass a curl_off_t as
parameter. If an upload exceeds this speed on cumulative
average during the transfer, the transfer will pause to keep
the average rate less than or equal to the parame- ter
value. (default: 0, unlimited)</p>

<p>CURLOPT_MAXCONNECTS Pass a long. The set number will be
the persistent connection cache size. The set amount will be
the maximum amount of simul- taneously open connections that
libcurl may cache. Default is 5, and there isnt much point
in changing this value unless you are perfectly aware of how
this work and changes libcurls behaviour. This concerns
connection using any of the protocols that support
persistent connections.</p>

<p>When reaching the maximum limit, curl uses the
CURLOPT_CLOSEPOL- ICY to figure out which of the existing
connections to close to prevent the number of open
connections to increase.</p>

<p>If you already have performed transfers with this curl
handle, setting a smaller MAXCONNECTS than before may cause
open connec- tions to get closed unnecessarily.</p>

<p>CURLOPT_CLOSEPOLICY Pass a long. This option sets what
policy libcurl should use when the connection cache is
filled and one of the open connec- tions has to be closed to
make room for a new connection. This must be one of the
CURLCLOSEPOLICY_* defines. Use CURLCLOSEPOL-
ICY_LEAST_RECENTLY_USED to make libcurl close the connection
that was least recently used, that connection is also least
likely to be capable of re-use. Use CURLCLOSEPOLICY_OLDEST
to make libcurl close the oldest connection, the one that
was cre- ated first among the ones in the connection cache.
The other close policies are not support yet.</p>

<p>CURLOPT_FRESH_CONNECT Pass a long. Set to non-zero to
make the next transfer use a new (fresh) connection by
force. If the connection cache is full before this
connection, one of the existing connections will be closed
as according to the selected or default policy. This option
should be used with caution and only if you understand what
it does. Set this to 0 to have libcurl attempt re-using an
existing connection (default behavior).</p>

<p>CURLOPT_FORBID_REUSE Pass a long. Set to non-zero to
make the next transfer explic- itly close the connection
when done. Normally, libcurl keep all connections alive when
done with one transfer in case there comes a succeeding one
that can re-use them. This option should be used with
caution and only if you understand what it does. Set to 0 to
have libcurl keep the connection open for possibly later
re-use (default behavior).</p>

<p>CURLOPT_CONNECTTIMEOUT Pass a long. It should contain
the maximum time in seconds that you allow the connection to
the server to take. This only lim- its the connection phase,
once it has connected, this option is of no more use. Set to
zero to disable connection timeout (it will then only
timeout on the systems internal timeouts). See also the
CURLOPT_TIMEOUT option.</p>

<p>In unix-like systems, this might cause signals to be
used unless CURLOPT_NOSIGNAL is set.</p>

<p>CURLOPT_IPRESOLVE Allows an application to select what
kind of IP addresses to use when resolving host names. This
is only interesting when using host names that resolve
addresses using more than one version of IP. The allowed
values are:</p>

<p>CURL_IPRESOLVE_WHATEVER Default, resolves addresses to
all IP versions that your system allows.</p>

<p>CURL_IPRESOLVE_V4 Resolve to ipv4 addresses.</p>

<p>CURL_IPRESOLVE_V6 Resolve to ipv6 addresses.</p>

<p>CURLOPT_CONNECT_ONLY Pass a long. A non-zero parameter
tells the library to perform any required proxy
authentication and connection setup, but no data
transfer.</p>

<p>This option is useful with the CURLINFO_LASTSOCKET
option to curl_easy_getinfo(3). The library can set up the
connection and then the application can obtain the most
recently used socket for special data transfers. (Added in
7.15.2)</p>

<p>SSL and SECURITY OPTIONS CURLOPT_SSLCERT Pass a pointer
to a zero terminated string as parameter. The string should
be the file name of your certificate. The default format is
&quot;PEM&quot; and can be changed with
CURLOPT_SSLCERTTYPE.</p>

<p>CURLOPT_SSLCERTTYPE Pass a pointer to a zero terminated
string as parameter. The string should be the format of your
certificate. Supported for- mats are &quot;PEM&quot; and
&quot;DER&quot;. (Added in 7.9.3)</p>

<p>CURLOPT_SSLCERTPASSWD Pass a pointer to a zero
terminated string as parameter. It will be used as the
password required to use the CURLOPT_SSLCERT cer-
tificate.</p>

<p>This option is replaced by CURLOPT_SSLKEYPASSWD and
should only be used for backward compatibility. You never
needed a pass phrase to load a certificate but you need one
to load your pri- vate key.</p>

<p>CURLOPT_SSLKEY Pass a pointer to a zero terminated
string as parameter. The string should be the file name of
your private key. The default format is &quot;PEM&quot; and
can be changed with CURLOPT_SSLKEYTYPE.</p>

<p>CURLOPT_SSLKEYTYPE Pass a pointer to a zero terminated
string as parameter. The string should be the format of your
private key. Supported for- mats are &quot;PEM&quot;,
&quot;DER&quot; and &quot;ENG&quot;.</p>

<p>The format &quot;ENG&quot; enables you to load the
private key from a crypto engine. In this case
CURLOPT_SSLKEY is used as an identi- fier passed to the
engine. You have to set the crypto engine with
CURLOPT_SSLENGINE. &quot;DER&quot; format key file currently
does not work because of a bug in OpenSSL.</p>

<p>CURLOPT_SSLKEYPASSWD Pass a pointer to a zero terminated
string as parameter. It will be used as the password
required to use the CURLOPT_SSLKEY pri- vate key.</p>

<p>CURLOPT_SSLENGINE Pass a pointer to a zero terminated
string as parameter. It will be used as the identifier for
the crypto engine you want to use for your private key.</p>

<p>If the crypto device cannot be loaded,
CURLE_SSL_ENGINE_NOTFOUND is returned.</p>

<p>CURLOPT_SSLENGINE_DEFAULT Sets the actual crypto engine
as the default for (asymmetric) crypto operations.</p>

<p>If the crypto device cannot be set,
CURLE_SSL_ENGINE_SETFAILED is returned.</p>

<p>CURLOPT_SSLVERSION Pass a long as parameter to control
what version of SSL/TLS to attempt to use. The available
options are:</p>

<p>CURL_SSLVERSION_DEFAULT The default action. When libcurl
built with OpenSSL, this will attempt to figure out the
remote SSL protocol ver- sion. Unfortunately there are a lot
of ancient and broken servers in use which cannot handle
this technique and will fail to connect. When libcurl is
built with GnuTLS, this will mean SSLv3.</p>

<p>CURL_SSLVERSION_TLSv1 Force TLSv1</p>

<p>CURL_SSLVERSION_SSLv2 Force SSLv2</p>

<p>CURL_SSLVERSION_SSLv3 Force SSLv3</p>

<p>CURLOPT_SSL_VERIFYPEER Pass a long as parameter.</p>

<p>This option determines whether curl verifies the
authenticity of the peer s certificate. A nonzero value
means curl verifies; zero means it doesnt. The default is
nonzero, but before 7.10, it was zero.</p>

<p>When negotiating an SSL connection, the server sends a
certifi- cate indicating its identity. Curl verifies whether
the cer- tificate is authentic, i.e. that you can trust that
the server is who the certificate says it is. This trust is
based on a chain of digital signatures, rooted in
certification authority (CA) certificates you supply. As of
7.10, curl installs a default bundle of CA certificates and
you can specify alternate certificates with the
CURLOPT_CAINFO option or the CURLOPT_CAP- ATH option.</p>

<p>When CURLOPT_SSL_VERIFYPEER is nonzero, and the
verification fails to prove that the certificate is
authentic, the connection fails. When the option is zero,
the connection succeeds regard- less.</p>

<p>Authenticating the certificate is not by itself very
useful. You typically want to ensure that the server, as
authentically identified by its certificate, is the server
you mean to be talking to. Use CURLOPT_SSL_VERIFYHOST to
control that.</p>

<p>CURLOPT_CAINFO Pass a char * to a zero terminated string
naming a file holding one or more certificates to verify the
peer with. This makes sense only when used in combination
with the CURLOPT_SSL_VERI- FYPEER option. If
CURLOPT_SSL_VERIFYPEER is zero, CUR- LOPT_CAINFO need not
even indicate an accessible file.</p>

<p>Note that option is by default set to the system path
where libcurls cacert bundle is assumed to be stored, as
established at build time.</p>

<p>CURLOPT_CAPATH Pass a char * to a zero terminated string
naming a directory holding multiple CA certificates to
verify the peer with. The certificate directory must be
prepared using the openssl c_rehash utility. This makes
sense only when used in combination with the
CURLOPT_SSL_VERIFYPEER option. If CURLOPT_SSL_VERI- FYPEER
is zero, CURLOPT_CAPATH need not even indicate an acces-
sible path. The CURLOPT_CAPATH function apparently does not
work in Windows due to some limitation in openssl. (Added in
7.9.8)</p>

<p>CURLOPT_CRLFILE Pass a char * to a zero terminated
string naming a file with the concatenation of CRL (in PEM
format) to use in the certificate validation that occurs
during the SSL exchange.</p>

<p>When curl is built to use NSS or GnuTLS, there is no way
to influence the use of CRL passed to help in the
verification pro- cess. When libcurl is built with OpenSSL
support, X509_V_FLAG_CRL_CHECK and X509_V_FLAG_CRL_CHECK_ALL
are both set, requiring CRL check against all the elements
of the cer- tificate chain if a CRL file is passed.</p>

<p>This option makes sense only when used in combination
with the CURLOPT_SSL_VERIFYPEER option.</p>

<p>A specific error code (CURLE_SSL_CRL_BADFILE) is defined
with the option. It is returned when the SSL exchange fails
because the CRL file cannot be loaded. Note that a failure
in certifi- cate verification due to a revocation
information found in the CRL does not trigger this specific
error.</p>

<p>CURLOPT_RANDOM_FILE Pass a char * to a zero terminated
file name. The file will be used to read from to seed the
random engine for SSL. The more random the specified file
is, the more secure the SSL connection will become.</p>

<p>CURLOPT_EGDSOCKET Pass a char * to the zero terminated
path name to the Entropy Gathering Daemon socket. It will be
used to seed the random engine for SSL.</p>

<p>CURLOPT_SSL_VERIFYHOST Pass a long as parameter.</p>

<p>This option determines whether libcurl verifies that the
server cert is for the server it is known as.</p>

<p>When negotiating an SSL connection, the server sends a
certifi- cate indicating its identity.</p>

<p>When CURLOPT_SSL_VERIFYHOST is 2, that certificate must
indicate that the server is the server to which you meant to
connect, or the connection fails.</p>

<p>Curl considers the server the intended one when the
Common Name field or a Subject Alternate Name field in the
certificate matches the host name in the URL to which you
told Curl to con- nect.</p>

<p>When the value is 1, the certificate must contain a
Common Name field, but it doesnt matter what name it says.
(This is not ordinarily a useful setting).</p>

<p>When the value is 0, the connection succeeds regardless
of the names in the certificate.</p>

<p>The default, since 7.10, is 2.</p>

<p>The checking this option controls is of the identity
that the server claims. The server could be lying. To
control lying, see CURLOPT_SSL_VERIFYPEER.</p>

<p>CURLOPT_SSL_CIPHER_LIST Pass a char *, pointing to a
zero terminated string holding the list of ciphers to use
for the SSL connection. The list must be syntactically
correct, it consists of one or more cipher strings separated
by colons. Commas or spaces are also acceptable sepa- rators
but colons are normally used, , - and + can be used as
operators. Valid examples of cipher lists include RC4-SHA,
&acute;SHA1+DES&acute;, TLSv1 and DEFAULT. The default list
is normally set when you compile OpenSSL.</p>

<p>You ll find more details about cipher lists on this URL:
http://www.openssl.org/docs/apps/ciphers.html</p>

<p>CURLOPT_KRB4LEVEL Pass a char * as parameter. Set the
krb4 security level, this also enables krb4 awareness. This
is a string, clear, safe, confidential or private. If the
string is set but doesnt match one of these, private will be
used. Set the string to NULL to disable kerberos4. The
kerberos support only works for FTP.</p>

<p>CURLOPT_GSSAPI_DELEGATION Set the parameter to
CURLGSSAPI_DELEGATION_FLAG to allow uncon- ditional GSSAPI
credential delegation. The delegation is dis- abled by
default since 7.21.7. Set the parameter to CURLGSS-
API_DELEGATION_POLICY_FLAG to delegate only if the OK-AS-
DELEGATE flag is set in the service ticket in case this
feature is supported by the GSSAPI implementation and the
definition of GSS_C_DELEG_POLICY_FLAG was available at
compile-time. (Added in 7.21.8)</p>

<p>OTHER OPTIONS CURLOPT_PRIVATE Pass a char * as
parameter, pointing to data that should be associated with
this curl handle. The pointer can subsequently be retrieved
using curl_easy_getinfo(3) with the CURLINFO_PRI- VATE
option. libcurl itself does nothing with this data. (Added
in 7.10.3)</p>

<p>CURLOPT_SHARE Pass a share handle as a parameter. The
share handle must have been created by a previous call to
curl_share_init(3). Setting this option, will make this curl
handle use the data from the shared handle instead of
keeping the data to itself. This enables several curl
handles to share data. If the curl handles are used
simultaneously, you MUST use the locking methods in the
share handle. See curl_share_setopt(3) for details.</p>

<p>TELNET OPTIONS CURLOPT_TELNETOPTIONS Provide a pointer
to a curl_slist with variables to pass to the telnet
negotiations. The variables should be in the format
&lt;option=value&gt;. libcurl supports the options TTYPE,
XDISPLOC and NEW_ENV. See the TELNET standard for
details.</p>

<p>RETURN VALUE CURLE_OK (zero) means that the option was
set properly, non-zero means an error occurred as
&lt;curl/curl.h&gt; defines. See the libcurl-errors(3) man
page for the full list with descriptions.</p>

<p>If you try to set an option that libcurl doesn t know
about, perhaps because the library is too old to support it
or the option was removed in a recent version, this function
will return CURLE_FAILED_INIT.</p>

<p>SEE ALSO curl_easy_init(3), curl_easy_cleanup(3),
curl_easy_reset(3),</p>

<p>libcurl 7.15.4 19 Apr 2006 curl_easy_setopt(3)</p>
<hr>
</body>
</html>
