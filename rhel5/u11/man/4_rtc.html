<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:21:48 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RTC(4) Linux Programmer s Manual RTC(4)</p>

<p>NAME rtc - real-time clock</p>

<p>SYNOPSIS #include &lt;linux/rtc.h&gt;</p>

<p>DESCRIPTION This is the driver for the real-time clock
(RTC).</p>

<p>Most computers have a built-in hardware clock, usually
called the real- time clock. This clock is normally battery
powered so that it keeps the time even while the computer is
switched off. It represents the current time as year, month,
day of month, hour, minute, and second.</p>

<p>The RTC is a chip that maintains the time and date and
is able to gen- erate interrupts at specified times. This
chip typically used to be a Motorola MC146818, a Dallas
DS12887, or similar, but today it is usu- ally implemented
in the mainboards chipset.</p>

<p>The RTC should not be confused with the system time
which is an inde- pendent, interrupt-driven software clock
maintained by the kernel. The software clock is maintained
by an interrupt routine that typically has a frequency of
100, 250, or 1000 Hz. The software clock counts seconds and
microsecond since the POSIX Epoch, i.e., Jan 1, 1970, 0:00
UTC. This clock does not involve any special hardware.</p>

<p>The RTC can be read and set with hwclock(8).</p>

<p>The RTC is almost never used by the Linux kernel.
Instead, the kernel uses the software clock time for
time(2), gettimeofday(2), timestamps on files, etc. However,
at boot time the kernel initializes its soft- ware clock by
reading the RTC.</p>

<p>Besides counting the date and time, the RTC can also
generate inter- rupts</p>

<p>* on every clock update (i.e. once per second);</p>

<p>* at periodic intervals with a frequency that can be set
to any power-of-2 multiple in the range 2 Hz to 8192 Hz;</p>

<p>* on reaching a previously specified alarm time.</p>

<p>Each of these interrupt sources can be enabled or
disabled separately.</p>

<p>The /dev/rtc device can be opened only once
simultaneously and it is read-only. On read(2) and select(2)
the calling process is blocked until the next interrupt from
the RTC is received. Following the interrupt, the process
can read a long integer, of which the least sig- nificant
byte contains the type of interrupt that occurred, while the
remaining 3 bytes contain the number of interrupts since the
last read(2).</p>

<p>The following ioctl(2) operations are provided:</p>

<p>RTC_RD_TIME Returns the RTC time in the following
structure:</p>

<p>struct rtc_time { int tm_sec; int tm_min; int tm_hour;
int tm_mday; int tm_mon; int tm_year; int tm_wday; /* unused
*/ int tm_yday; /* unused */ int tm_isdst; /* unused */
};</p>

<p>The fields in this structure have the same meaning and
ranges as for the tm structure described in gmtime(3). A
pointer to this structure should be passed as the third
ioctl() argument.</p>

<p>RTC_SET_TIME Sets the RTC time to the time specified by
the rtc_time struc- ture pointed to by the third ioctl()
argument. To set the RTC time the process must be privileged
(i.e., have the CAP_SYS_TIME capability).</p>

<p>RTC_ALM_READ, RTC_ALM_SET Read and set the alarm time.
The third ioctl() argument is a pointer to an rtc_time
structure. Only the tm_sec, tm_min, and tm_hour fields of
this structure are used.</p>

<p>RTC_IRQP_READ, RTC_IRQP_SET Read and set the frequency
for periodic interrupts. The third ioctl() argument is a
long * or a long, respectively. The value is the frequency
in interrupts per second. The set of allowable frequencies
is the multiples of two in the range 2 to 8192. Only a
privileged process (i.e., one having the CAP_SYS_RESOURCE
capability) can set frequencies above the value specified in
/proc/sys/dev/rtc/max-user-freq. (This file contains the
value 64 by default.)</p>

<p>RTC_AIE_ON, RTC_AIE_OFF Enable or disable the alarm
interrupt. The third ioctl() argu- ment is ignored.</p>

<p>RTC_UIE_ON, RTC_UIE_OFF Enable or disable the interrupt
on every clock update. The third ioctl() argument is
ignored.</p>

<p>RTC_PIE_ON, RTC_PIE_OFF Enable or disable the periodic
interrupt. The third ioctl() argument is ignored. Only a
privileged process (i.e., one hav- ing the CAP_SYS_RESOURCE
capability) can enable the periodic interrupt if the
frequency is currently set above the value specified in
/proc/sys/dev/rtc/max-user-freq.</p>

<p>RTC_EPOCH_READ, RTC_EPOCH_SET The RTC encodes the year
in an 8-bit register which is either interpreted as an 8-bit
binary number or as a BCD number. In both cases, the number
is interpreted relative to the RTC Epoch. The RTC Epoch is
initialized to 1900 on most systems but on Alpha and Mips it
might also be initialized to 1952, 1980, or 2000, depending
on the value of RTC register for the year. These operations
can be used to read or to set the RTC Epoch, respectively.
To set the RTC Epoch the process must be privi- leged (i.e.,
have the CAP_SYS_TIME capability).</p>

<p>FILES /dev/rtc: the RTC special character device
file.</p>

<p>/proc/driver/rtc: status of the RTC.</p>

<p>NOTES When the kernel s system time is synchronized with
an external refer- ence using adjtimex(2) it will update the
RTC periodically every 11 minutes. To do so, the kernel has
to briefly turn off periodic inter- rupts; this might affect
programs using the RTC.</p>

<p>The RTC Epoch has nothing to do with the POSIX Epoch
which is only used for the system clock.</p>

<p>If the year according to the RTC Epoch and the RTCs year
register is less than 1970 it is assumed to be 100 years
later, i.e. between 2000 and 2069.</p>

<p>SEE ALSO hwclock(8), date(1), time(2), stime(2),
gettimeofday(2), settimeof- day(2), adjtimex(2), gmtime(3),
time(7), /usr/share/doc/kernel-
doc-2.6.18/Documentation/rtc.txt</p>

<p>Linux 2005-12-05 RTC(4)</p>
<hr>
</body>
</html>
