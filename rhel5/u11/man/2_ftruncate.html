<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:10:40 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>TRUNCATE(2) Linux Programmer s Manual TRUNCATE(2)</p>

<p>NAME truncate, ftruncate - truncate a file to a
specified length</p>

<p>SYNOPSIS #include &lt;unistd.h&gt; #include
&lt;sys/types.h&gt;</p>

<p>int truncate(const char *path, off_t length); int
ftruncate(int fd, off_t length);</p>

<p>DESCRIPTION The truncate() and ftruncate() functions
cause the regular file named by path or referenced by fd to
be truncated to a size of precisely length bytes.</p>

<p>If the file previously was larger than this size, the
extra data is lost. If the file previously was shorter, it
is extended, and the extended part reads as null bytes (
).</p>

<p>The file offset is not changed.</p>

<p>If the size changed, then the st_ctime and st_mtime
fields (respec- tively, time of last status change and time
of last modification; see stat(2)) for the file are updated,
and the set-user-ID and set-group-ID permission bits may be
cleared.</p>

<p>With ftruncate(), the file must be open for writing;
with truncate(), the file must be writable.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS For truncate():</p>

<p>EACCES Search permission is denied for a component of
the path prefix, or the named file is not writable by the
user. (See also path_resolution(2).)</p>

<p>EFAULT Path points outside the processs allocated
address space.</p>

<p>EFBIG The argument length is larger than the maximum
file size. (XSI)</p>

<p>EINTR A signal was caught during execution.</p>

<p>EINVAL The argument length is negative or larger than
the maximum file size.</p>

<p>EIO An I/O error occurred updating the inode.</p>

<p>EISDIR The named file is a directory.</p>

<p>ELOOP Too many symbolic links were encountered in
translating the pathname.</p>

<p>ENAMETOOLONG A component of a pathname exceeded 255
characters, or an entire pathname exceeded 1023
characters.</p>

<p>ENOENT The named file does not exist.</p>

<p>ENOTDIR A component of the path prefix is not a
directory.</p>

<p>EPERM The underlying file system does not support
extending a file beyond its current size.</p>

<p>EROFS The named file resides on a read-only file
system.</p>

<p>ETXTBSY The file is a pure procedure (shared text) file
that is being executed.</p>

<p>For ftruncate() the same errors apply, but instead of
things that can be wrong with path, we now have things that
can be wrong with fd:</p>

<p>EBADF The fd is not a valid descriptor.</p>

<p>EBADF or EINVAL The fd is not open for writing.</p>

<p>EINVAL The fd does not reference a regular file.</p>

<p>CONFORMING TO 4.4BSD, SVr4, POSIX.1-2001 (these calls
first appeared in 4.2BSD).</p>

<p>NOTES The above description is for XSI-compliant
systems. For non-XSI-com- pliant systems, the POSIX standard
allows two behaviours for ftrun- cate() when length exceeds
the file length (note that truncate() is not specified at
all in such an environment): either returning an error, or
extending the file. Like most Unix implementations, Linux
follows the XSI requirement when dealing with native file
systems. However, some non-native file systems do not permit
truncate() and ftruncate() to be used to extend a file
beyond its current length: a notable example on Linux is
VFAT.</p>

<p>SEE ALSO open(2), path_resolution(2), stat(2)</p>

<p>Linux 2.6.7 2004-06-23 TRUNCATE(2)</p>
<hr>
</body>
</html>
