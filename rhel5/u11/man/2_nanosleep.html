<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:16:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>NANOSLEEP(2) Linux Programmer s Manual NANOSLEEP(2)</p>

<p>NAME nanosleep - pause execution for a specified
time</p>

<p>SYNOPSIS #define _POSIX_C_SOURCE 199309 #include
&lt;time.h&gt;</p>

<p>int nanosleep(const struct timespec *req, struct
timespec *rem);</p>

<p>DESCRIPTION nanosleep() delays the execution of the
program for at least the time specified in *req. The
function can return earlier if a signal has been delivered
to the process. In this case, it returns -1, sets errno to
EINTR, and writes the remaining time into the structure
pointed to by rem unless rem is NULL. The value of *rem can
then be used to call nanosleep() again and complete the
specified pause.</p>

<p>The structure timespec is used to specify intervals of
time with nanosecond precision. It is specified in
&lt;time.h&gt; and has the form</p>

<p>struct timespec { time_t tv_sec; /* seconds */ long
tv_nsec; /* nanoseconds */ };</p>

<p>The value of the nanoseconds field must be in the range
0 to 999999999.</p>

<p>Compared to sleep(3) and usleep(3), nanosleep() has the
advantage of not affecting any signals, it is standardized
by POSIX, it provides higher timing resolution, and it
allows to continue a sleep that has been interrupted by a
signal more easily.</p>

<p>RETURN VALUE On successfully sleeping for the requested
interval, nanosleep() returns 0. If the call is interrupted
by a signal handler or encoun- ters an error, then it
returns -1, with errno set to indicate the error.</p>

<p>ERRORS EFAULT Problem with copying information from user
space.</p>

<p>EINTR The pause has been interrupted by a non-blocked
signal that was delivered to the process. The remaining
sleep time has been written into *rem so that the process
can easily call nanosleep() again and continue with the
pause.</p>

<p>EINVAL The value in the tv_nsec field was not in the
range 0 to 999999999 or tv_sec was negative.</p>

<p>BUGS The current implementation of nanosleep() is based
on the normal kernel timer mechanism, which has a resolution
of 1/HZ s (see time(7)). Therefore, nanosleep() pauses
always for at least the specified time, however it can take
up to 10 ms longer than specified until the process becomes
runnable again. For the same reason, the value returned in
case of a delivered signal in *rem is usually rounded to the
next larger multiple of 1/HZ s.</p>

<p>Old behaviour In order to support applications requiring
much more precise pauses (e.g., in order to control some
time-critical hardware), nanosleep() would handle pauses of
up to 2 ms by busy waiting with microsecond pre- cision when
called from a process scheduled under a real-time policy
like SCHED_FIFO or SCHED_RR. This special extension was
removed in kernel 2.5.39, hence is still present in current
2.4 kernels, but not in 2.6 kernels.</p>

<p>In Linux 2.4, if nanosleep() is stopped by a signal
(e.g., SIGTSTP), then the call fails with the error EINTR
after the process is resumed by a SIGCONT signal. If the
system call is subsequently restarted, then the time that
the process spent in the stopped state is not counted
against the sleep interval.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>SEE ALSO sched_setscheduler(2), timer_create(2),
sleep(3), usleep(3)</p>

<p>Linux 2.6.9 2004-10-24 NANOSLEEP(2)</p>
<hr>
</body>
</html>
