<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:17:30 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>FMEMOPEN(3) glibc function FMEMOPEN(3)</p>

<p>NAME fmemopen, open_memstream - open memory as
stream</p>

<p>SYNOPSIS #define _GNU_SOURCE #include
&lt;stdio.h&gt;</p>

<p>FILE *fmemopen(void *buf, size_t size, const char
*mode);</p>

<p>FILE *open_memstream(char ** ptr, size_t *sizeloc)</p>

<p>DESCRIPTION The fmemopen() function opens a stream that
permits the access speci- fied by mode. The stream allows
I/O to be performed on the string or memory buffer pointed
to by buf. This buffer must be at least size bytes long.</p>

<p>The argument mode is the same as for fopen(3). If mode
specifies an append mode, then the initial file position is
set to location of the first null byte ( ) in the buffer;
otherwise the initial file posi- tion is set to the start of
the buffer.</p>

<p>When a stream that has been opened for writing is
flushed (fflush(3)) or closed (fclose(3)), a null byte is
written at the end of the buffer if there is space. The
caller should ensure that an extra byte is available in the
buffer (and that size counts that byte) to allow for
this.</p>

<p>Attempts to write more than size bytes to the buffer
result in an error. (By default, such errors will only be
visible when the stdio buffer is flushed. Disabling
buffering with setbuf(fp, NULL) may be useful to detect
errors at the time of an output operation. Alterna- tively,
the caller can explicitly set buf as the stdio stream
buffer, at the same time informing stdio of the buffers
size, using set- buffer(fp, buf, size).)</p>

<p>In a stream opened for reading, null bytes ( ) in the
buffer do not cause read operations to return an end-of-file
indication. A read from the buffer will only indicate
end-of-file when the file pointer advances size bytes past
the start of the buffer.</p>

<p>If buf is specified as NULL, then fmemopen() dynamically
allocates a buffer size bytes long. This is useful for an
application that wants to write data to a temporary buffer
and then read it back again. The buffer is automatically
freed when the stream is closed. Note that the caller has no
way to obtain a pointer to the temporary buffer allocated by
this call (but see open_memstream() below).</p>

<p>The open_memstream() opens a stream for writing to a
buffer. The buffer is dynamically allocated (as with
malloc(3)), and automatically grows as required. After
closing the stream, the caller should free(3) this
buffer.</p>

<p>When the stream is closed (fclose(3)) or flushed
(fflush(3)), the loca- tions pointed to by ptr and sizeloc
are updated to contain, respec- tively, a pointer to the
buffer and the current size of the buffer. These values
remain valid only as long as the caller performs no fur-
ther output on the stream. If further output is performed,
then the stream must again be flushed before trying to
access these variables.</p>

<p>A null byte is maintained at the end of the buffer. This
byte is not included in the size value stored at
sizeloc.</p>

<p>RETURN VALUE Upon successful completion fmemopen() and
open_memstream() return a FILE pointer. Otherwise, NULL is
returned and the global variable errno is set to indicate
the error.</p>

<p>EXAMPLE The program below uses fmemopen() to open an
input buffer, and open_memstream() to open a dynamically
sized output buffer. The pro- gram scans its input string
(taken from the program s first command- line argument)
reading integers, and writes the squares of these inte- gers
to the output buffer. An example of the output produced by
this program is the following:</p>

<p>$ ./a.out &quot;1 23 43&quot; size=11; ptr=1 529
1849</p>

<p>#define _GNU_SOURCE #include &lt;assert.h&gt; #include
&lt;string.h&gt; #include &lt;stdio.h&gt; #include
&lt;stdlib.h&gt;</p>

<p>int main(int argc, char *argv[]) { FILE *out, *in; int
v, s; size_t size; char *ptr;</p>

<p>assert(argc == 2);</p>

<p>in = fmemopen(argv[1], strlen(argv[1]), &quot;r&quot;);
if (in == NULL) { perror(&quot;fmemopen&quot;);
exit(EXIT_FAILURE);}</p>

<p>out = open_memstream(&amp;ptr, &amp;size); if (out ==
NULL) { perror(&quot;fmemopen&quot;);
exit(EXIT_FAILURE);}</p>

<p>for (;;) { s = fscanf(in, &quot;%d&quot;, &amp;v); if (s
&lt;= 0) break;</p>

<p>s = fprintf(out, &quot;%d &quot;, v * v); if (s == -1) {
perror(&quot;fprintf&quot;); exit(EXIT_FAILURE); } }
fclose(in); fclose(out); printf(&quot;size=%ld; ptr=%s0,
(long) size, ptr); free(ptr); exit(EXIT_SUCCESS); }</p>

<p>CONFORMING TO These functions are GNU extensions.</p>

<p>SEE ALSO open(3)</p>

<p>GNU 2005-12-08 FMEMOPEN(3)</p>
<hr>
</body>
</html>
