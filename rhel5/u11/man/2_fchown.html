<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:10:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CHOWN(2) Linux Programmer s Manual CHOWN(2)</p>

<p>NAME chown, fchown, lchown - change ownership of a
file</p>

<p>SYNOPSIS #include &lt;sys/types.h&gt; #include
&lt;unistd.h&gt;</p>

<p>int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group); int
lchown(const char *path, uid_t owner, gid_t group);</p>

<p>DESCRIPTION These system calls change the owner and
group of the file specified by path or by fd. Only a
privileged process (Linux: one with the CAP_CHOWN
capability) may change the owner of a file. The owner of a
file may change the group of the file to any group of which
that owner is a member. A privileged process (Linux: with
CAP_CHOWN) may change the group arbitrarily.</p>

<p>If the owner or group is specified as -1, then that ID
is not changed.</p>

<p>When the owner or group of an executable file are
changed by a non- superuser, the S_ISUID and S_ISGID mode
bits are cleared. POSIX does not specify whether this also
should happen when root does the chown(); the Linux
behaviour depends on the kernel version. In case of a non-
group-executable file (with clear S_IXGRP bit) the S_ISGID
bit indi- cates mandatory locking, and is not cleared by a
chown().</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS Depending on the file system, other errors can be
returned. The more general errors for chown() are listed
below.</p>

<p>EACCES Search permission is denied on a component of the
path prefix. (See also path_resolution(2).)</p>

<p>EFAULT path points outside your accessible address
space.</p>

<p>ELOOP Too many symbolic links were encountered in
resolving path.</p>

<p>ENAMETOOLONG path is too long.</p>

<p>ENOENT The file does not exist.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ENOTDIR A component of the path prefix is not a
directory.</p>

<p>EPERM The calling process did not have the required
permissions (see above) to change owner and/or group.</p>

<p>EROFS The named file resides on a read-only file
system.</p>

<p>The general errors for fchown() are listed below:</p>

<p>EBADF The descriptor is not valid.</p>

<p>EIO A low-level I/O error occurred while modifying the
inode.</p>

<p>ENOENT See above.</p>

<p>EPERM See above.</p>

<p>EROFS See above.</p>

<p>NOTES In versions of Linux prior to 2.1.81 (and distinct
from 2.1.46), chown() did not follow symbolic links. Since
Linux 2.1.81, chown() does follow symbolic links, and there
is a new system call lchown() that does not follow symbolic
links. Since Linux 2.1.86, this new call (that has the same
semantics as the old chown()) has got the same syscall
number, and chown() got the newly introduced number.</p>

<p>The prototype for fchown() is only available if
_BSD_SOURCE is defined.</p>

<p>CONFORMING TO 4.4BSD, SVr4, POSIX.1-2001.</p>

<p>The 4.4BSD version can only be used by the superuser
(that is, ordinary users cannot give away files).</p>

<p>RESTRICTIONS The chown() semantics are deliberately
violated on NFS file systems which have UID mapping enabled.
Additionally, the semantics of all system calls which access
the file contents are violated, because chown() may cause
immediate access revocation on already open files. Client
side caching may lead to a delay between the time where
owner- ship have been changed to allow access for a user and
the time where the file can actually be accessed by the user
on other clients.</p>

<p>SEE ALSO chmod(2), fchownat(2), flock(2),
path_resolution(2)</p>

<p>Linux 2.6.7 2004-06-23 CHOWN(2)</p>
<hr>
</body>
</html>
