<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:14:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RPM(8) Red Hat Linux RPM(8)</p>

<p>NAME rpm - RPM Package Manager</p>

<p>SYNOPSIS QUERYING AND VERIFYING PACKAGES: rpm
{-q|--query} [select-options] [query-options]</p>

<p>rpm {-V|--verify} [select-options] [verify-options]</p>

<p>rpm --import PUBKEY ...</p>

<p>rpm {-K|--checksig} [--nosignature] [--nodigest]
PACKAGE_FILE ...</p>

<p>INSTALLING, UPGRADING, AND REMOVING PACKAGES: rpm
{-i|--install} [install-options] PACKAGE_FILE ...</p>

<p>rpm {-U|--upgrade} [install-options] PACKAGE_FILE
...</p>

<p>rpm {-F|--freshen} [install-options] PACKAGE_FILE
...</p>

<p>rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts]
[--notriggers] [--repackage] [--test] PACKAGE_NAME ...</p>

<p>MISCELLANEOUS: rpm {--initdb|--rebuilddb}</p>

<p>rpm {--addsign|--resign} PACKAGE_FILE ...</p>

<p>rpm {--querytags|--showrc}</p>

<p>rpm {--setperms|--setugids} PACKAGE_NAME ...</p>

<p>select-options [PACKAGE_NAME] [-a,--all] [-f,--file
FILE] [-g,--group GROUP] {-p,--package PACKAGE_FILE]
[--fileid MD5] [--hdrid SHA1] [--pkgid MD5] [--tid TID]
[--querybynumber HDRNUM] [--triggeredby PACKAGE_NAME]
[--whatprovides CAPABILITY] [--whatrequires CAPABILITY]</p>

<p>query-options [--changelog] [-c,--configfiles]
[-d,--docfiles] [--dump] [--filesbypkg] [-i,--info] [--last]
[-l,--list] [--provides] [--qf,--queryformat QUERYFMT]
[-R,--requires] [--scripts] [-s,--state]
[--triggers,--triggerscripts]</p>

<p>verify-options [--nodeps] [--nofiles] [--noscripts]
[--nodigest] [--nosignature] [--nolinkto] [--nomd5]
[--nosize] [--nouser] [--nogroup] [--nomtime] [--nomode]
[--nordev]</p>

<p>install-options [--aid] [--allfiles] [--badreloc]
[--excludepath OLDPATH] [--excludedocs] [--force]
[-h,--hash] [--ignoresize] [--ignorearch] [--ignoreos]
[--includedocs] [--justdb] [--nodeps] [--nodigest]
[--nosignature] [--nosuggest] [--noorder] [--noscripts]
[--notriggers] [--oldpackage] [--percent] [--prefix NEWPATH]
[--relocate OLDPATH=NEWPATH] [--repackage] [--replacefiles]
[--replacepkgs] [--test]</p>

<p>DESCRIPTION rpm is a powerful Package Manager, which can
be used to build, install, query, verify, update, and erase
individual software packages. A pack- age consists of an
archive of files and meta-data used to install and erase the
archive files. The meta-data includes helper scripts, file
attributes, and descriptive information about the package.
Packages come in two varieties: binary packages, used to
encapsulate software to be installed, and source packages,
containing the source code and recipe necessary to produce
binary packages.</p>

<p>One of the following basic modes must be selected:
Query, Verify, Sig- nature Check, Install/Upgrade/Freshen,
Uninstall, Initialize Database, Rebuild Database, Resign,
Add Signature, Set Owners/Groups, Show Query- tags, and Show
Configuration.</p>

<p>GENERAL OPTIONS These options can be used in all the
different modes.</p>

<p>-?, --help Print a longer usage message then normal.</p>

<p>--version Print a single line containing the version
number of rpm being used.</p>

<p>--quiet Print as little as possible - normally only
error messages will be displayed.</p>

<p>-v Print verbose information - normally routine progress
messages will be displayed.</p>

<p>-vv Print lots of ugly debugging information.</p>

<p>--rcfile FILELIST Each of the files in the colon
separated FILELIST is read sequentially by rpm for
configuration information. Only the first file in the list
must exist, and tildes will be expanded to the value of
$HOME. The default FILELIST is
/usr/lib/rpm/rpmrc:/usr/lib/rpm/red-
hat/rpmrc:/etc/rpmrc:~/.rpmrc.</p>

<p>--pipe CMD Pipes the output of rpm to the command
CMD.</p>

<p>--dbpath DIRECTORY Use the database in DIRECTORY rather
than the default path /var/lib/rpm</p>

<p>--root DIRECTORY Use the file system tree rooted at
DIRECTORY for all operations. Note that this means the
database within DIRECTORY will be used for dependency checks
and any scriptlet(s) (e.g. %post if installing, or %prep if
building, a package) will be run after a chroot(2) to
DIRECTORY.</p>

<p>-D, --defineMACRO EXPR Defines MACRO with value
EXPR.</p>

<p>-E, --evalEXPR Prints macro expansion of EXPR.</p>

<p>INSTALL AND UPGRADE OPTIONS The general form of an rpm
install command is</p>

<p>rpm {-i|--install} [install-options] PACKAGE_FILE
...</p>

<p>This installs a new package.</p>

<p>The general form of an rpm upgrade command is</p>

<p>rpm {-U|--upgrade} [install-options] PACKAGE_FILE
...</p>

<p>This upgrades or installs the package currently
installed to a newer version. This is the same as install,
except all other version(s) of the package are removed after
the new package is installed.</p>

<p>rpm {-F|--freshen} [install-options] PACKAGE_FILE
...</p>

<p>This will upgrade packages, but only if an earlier
version currently exists. The PACKAGE_FILE may be specified
as an ftp or http URL, in which case the package will be
downloaded before being installed. See FTP/HTTP OPTIONS for
information on rpms internal ftp and http client
support.</p>

<p>--aid Add suggested packages to the transaction set when
needed.</p>

<p>--allfiles Installs or upgrades all the missingok files
in the package, regardless if they exist.</p>

<p>--badreloc Used with --relocate, permit relocations on
all file paths, not just those OLDPATHs included in the
binary package relocation hint(s).</p>

<p>--excludepath OLDPATH Dont install files whose name
begins with OLDPATH.</p>

<p>--excludedocs Don t install any files which are marked
as documentation (which includes man pages and texinfo
documents).</p>

<p>--force Same as using --replacepkgs, --replacefiles, and
--oldpackage.</p>

<p>-h, --hash Print 50 hash marks as the package archive is
unpacked. Use with -v|--verbose for a nicer display.</p>

<p>--ignoresize Dont check mount file systems for
sufficient disk space before installing this package.</p>

<p>--ignorearch Allow installation or upgrading even if the
architectures of the binary package and host dont match.</p>

<p>--ignoreos Allow installation or upgrading even if the
operating systems of the binary package and host dont
match.</p>

<p>--includedocs Install documentation files. This is the
default behavior.</p>

<p>--justdb Update only the database, not the
filesystem.</p>

<p>--nodigest Dont verify package or header digests when
reading.</p>

<p>--nosignature Don t verify package or header signatures
when reading.</p>

<p>--nodeps Dont do a dependency check before installing or
upgrading a package.</p>

<p>--nosuggest Don t suggest package(s) that provide a
missing dependency.</p>

<p>--noorder Dont reorder the packages for an install. The
list of packages would normally be reordered to satisfy
dependencies.</p>

<p>--noscripts</p>

<p>--nopre</p>

<p>--nopost</p>

<p>--nopreun</p>

<p>--nopostun Dont execute the scriptlet of the same name.
The --noscripts option is equivalent to</p>

<p>--nopre --nopost --nopreun --nopostun</p>

<p>and turns off the execution of the corresponding %pre,
%post, %preun, and %postun scriptlet(s).</p>

<p>--notriggers</p>

<p>--notriggerin</p>

<p>--notriggerun</p>

<p>--notriggerpostun Dont execute any trigger scriptlet of
the named type. The --notriggers option is equivalent to</p>

<p>--notriggerin --notriggerun --notriggerpostun</p>

<p>and turns off execution of the corresponding %triggerin,
%trig- gerun, and %triggerpostun scriptlet(s).</p>

<p>--oldpackage Allow an upgrade to replace a newer package
with an older one.</p>

<p>--percent Print percentages as files are unpacked from
the package archive. This is intended to make rpm easy to
run from other tools.</p>

<p>--prefix NEWPATH For relocatable binary packages,
translate all file paths that start with the installation
prefix in the package relocation hint(s) to NEWPATH.</p>

<p>--relocate OLDPATH=NEWPATH For relocatable binary
packages, translate all file paths that start with OLDPATH
in the package relocation hint(s) to NEWPATH. This option
can be used repeatedly if several OLDPATHs in the package
are to be relocated.</p>

<p>--repackage Re-package the files before erasing. The
previously installed package will be named according to the
macro %_repack- age_name_fmt and will be created in the
directory named by the macro %_repackage_dir (default value
is /var/spool/repackage).</p>

<p>--replacefiles Install the packages even if they replace
files from other, already installed, packages.</p>

<p>--replacepkgs Install the packages even if some of them
are already installed on this system.</p>

<p>--test Do not install the package, simply check for and
report poten- tial conflicts.</p>

<p>ERASE OPTIONS The general form of an rpm erase command
is</p>

<p>rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts]
[--notriggers] [--repackage] [--test] PACKAGE_NAME ...</p>

<p>The following options may also be used:</p>

<p>--allmatches Remove all versions of the package which
match PACKAGE_NAME. Normally an error is issued if
PACKAGE_NAME matches multiple packages.</p>

<p>--nodeps Dont check dependencies before uninstalling the
packages.</p>

<p>--noscripts</p>

<p>--nopreun</p>

<p>--nopostun Don t execute the scriptlet of the same name.
The --noscripts option during package erase is equivalent
to</p>

<p>--nopreun --nopostun</p>

<p>and turns off the execution of the corresponding %preun,
and %postun scriptlet(s).</p>

<p>--notriggers</p>

<p>--notriggerun</p>

<p>--notriggerpostun Don t execute any trigger scriptlet of
the named type. The --notriggers option is equivalent to</p>

<p>--notriggerun --notriggerpostun</p>

<p>and turns off execution of the corresponding %triggerun,
and %triggerpostun scriptlet(s).</p>

<p>--repackage Re-package the files before erasing. The
previously installed package will be named according to the
macro %_repack- age_name_fmt and will be created in the
directory named by the macro %_repackage_dir (default value
is /var/spool/repackage).</p>

<p>--test Dont really uninstall anything, just go through
the motions. Useful in conjunction with the -vv option for
debugging.</p>

<p>QUERY OPTIONS The general form of an rpm query command
is</p>

<p>rpm {-q|--query} [select-options] [query-options]</p>

<p>You may specify the format that package information
should be printed in. To do this, you use the</p>

<p>--qf|--queryformat QUERYFMT</p>

<p>option, followed by the QUERYFMT format string. Query
formats are mod- ified versions of the standard printf(3)
formatting. The format is made up of static strings (which
may include standard C character escapes for newlines, tabs,
and other special characters) and printf(3) type formatters.
As rpm already knows the type to print, the type specifier
must be omitted however, and replaced by the name of the
header tag to be printed, enclosed by {} characters. Tag
names are case insensitive, and the leading RPMTAG_ portion
of the tag name may be omitted as well.</p>

<p>Alternate output formats may be requested by following
the tag with :typetag. Currently, the following types are
supported:</p>

<p>:armor Wrap a public key in ASCII armor.</p>

<p>:base64 Encode binary data using base64.</p>

<p>:date Use strftime(3) &quot;%c&quot; format.</p>

<p>:day Use strftime(3) &quot;%a %b %d %Y&quot; format.</p>

<p>:depflags Format dependency flags.</p>

<p>:fflags Format file flags.</p>

<p>:hex Format in hexadecimal.</p>

<p>:octal Format in octal.</p>

<p>:perms Format file permissions.</p>

<p>:shescape Escape single quotes for use in a script.</p>

<p>:triggertype Display trigger suffix.</p>

<p>For example, to print only the names of the packages
queried, you could use %{NAME} as the format string. To
print the packages name and dis- tribution information in
two columns, you could use %-30{NAME}%{DISTRI- BUTION}. rpm
will print a list of all of the tags it knows about when it
is invoked with the --querytags argument.</p>

<p>There are two subsets of options for querying: package
selection, and information selection.</p>

<p>PACKAGE SELECTION OPTIONS: PACKAGE_NAME Query installed
package named PACKAGE_NAME.</p>

<p>-a, --all Query all installed packages.</p>

<p>-f, --file FILE Query package owning FILE.</p>

<p>--fileid MD5 Query package that contains a given file
identifier, i.e. the MD5 digest of the file contents.</p>

<p>-g, --group GROUP Query packages with the group of
GROUP.</p>

<p>--hdrid SHA1 Query package that contains a given header
identifier, i.e. the SHA1 digest of the immutable header
region.</p>

<p>-p, --package PACKAGE_FILE Query an (uninstalled)
package PACKAGE_FILE. The PACKAGE_FILE may be specified as
an ftp or http style URL, in which case the package header
will be downloaded and queried. See FTP/HTTP OPTIONS for
information on rpms internal ftp and http client support.
The PACKAGE_FILE argument(s), if not a binary package, will
be interpreted as an ASCII package manifest. Comments are
permitted, starting with a #, and each line of a package
mani- fest file may include white space separated glob
expressions, including URLs with remote glob expressions,
that will be expanded to paths that are substituted in place
of the package manifest as additional PACKAGE_FILE arguments
to the query.</p>

<p>--pkgid MD5 Query package that contains a given package
identifier, i.e. the MD5 digest of the combined header and
payload contents.</p>

<p>--querybynumber HDRNUM Query the HDRNUMth database entry
directly; this is useful only for debugging.</p>

<p>--specfile SPECFILE Parse and query SPECFILE as if it
were a package. Although not all the information (e.g. file
lists) is available, this type of query permits rpm to be
used to extract information from spec files without having
to write a specfile parser.</p>

<p>--tid TID Query package(s) that have a given TID
transaction identifier. A unix time stamp is currently used
as a transaction identifier. All package(s) installed or
erased within a single transaction have a common
identifier.</p>

<p>--triggeredby PACKAGE_NAME Query packages that are
triggered by package(s) PACKAGE_NAME.</p>

<p>--whatprovides CAPABILITY Query all packages that
provide the CAPABILITY capability.</p>

<p>--whatrequires CAPABILITY Query all packages that
requires CAPABILITY for proper function- ing.</p>

<p>PACKAGE QUERY OPTIONS: --changelog Display change
information for the package.</p>

<p>-c, --configfiles List only configuration files (implies
-l).</p>

<p>-d, --docfiles List only documentation files (implies
-l).</p>

<p>--dump Dump file information as follows (implies
-l):</p>

<p>path size mtime md5sum mode owner group isconfig isdoc
rdev symlink</p>

<p>--filesbypkg List all the files in each selected
package.</p>

<p>-i, --info Display package information, including name,
version, and description. This uses the --queryformat if one
was specified.</p>

<p>--last Orders the package listing by install time such
that the latest packages are at the top.</p>

<p>-l, --list List files in package.</p>

<p>--provides List capabilities this package provides.</p>

<p>-R, --requires List packages on which this package
depends.</p>

<p>--scripts List the package specific scriptlet(s) that
are used as part of the installation and uninstallation
processes.</p>

<p>-s, --state Display the states of files in the package
(implies -l). The state of each file is one of normal, not
installed, or replaced.</p>

<p>--triggers, --triggerscripts Display the trigger
scripts, if any, which are contained in the package.</p>

<p>VERIFY OPTIONS The general form of an rpm verify command
is</p>

<p>rpm {-V|--verify} [select-options] [verify-options]</p>

<p>Verifying a package compares information about the
installed files in the package with information about the
files taken from the package metadata stored in the rpm
database. Among other things, verifying compares the size,
MD5 sum, permissions, type, owner and group of each file.
Any discrepancies are displayed. Files that were not
installed from the package, for example, documentation files
excluded on instal- lation using the
&quot;--excludedocs&quot; option, will be silently
ignored.</p>

<p>The package selection options are the same as for
package querying (including package manifest files as
arguments). Other options unique to verify mode are:</p>

<p>--nodeps Dont verify dependencies of packages.</p>

<p>--nodigest Dont verify package or header digests when
reading.</p>

<p>--nofiles Dont verify any attributes of package
files.</p>

<p>--noscripts Don t execute the %verifyscript scriptlet
(if any).</p>

<p>--nosignature Dont verify package or header signatures
when reading.</p>

<p>--nolinkto</p>

<p>--nomd5</p>

<p>--nosize</p>

<p>--nouser</p>

<p>--nogroup</p>

<p>--nomtime</p>

<p>--nomode</p>

<p>--nordev Dont verify the corresponding file
attribute.</p>

<p>The format of the output is a string of 8 characters, a
possible attribute marker:</p>

<p>c %config configuration file. d %doc documentation file.
g %ghost file (i.e. the file contents are not included in
the package payload). l %license license file. r %readme
readme file.</p>

<p>from the package header, followed by the file name. Each
of the 8 characters denotes the result of a comparison of
attribute(s) of the file to the value of those attribute(s)
recorded in the database. A single &quot;.&quot; (period)
means the test passed, while a single &quot;?&quot;
(question mark) indicates the test could not be performed
(e.g. file permissions prevent reading). Otherwise, the
(mnemonically emBoldened) character denotes failure of the
corresponding --verify test:</p>

<p>S file Size differs M Mode differs (includes permissions
and file type) 5 MD5 sum differs D Device major/minor number
mismatch L readLink(2) path mismatch U User ownership
differs G Group ownership differs T mTime differs</p>

<p>DIGITAL SIGNATURE AND DIGEST VERIFICATION The general
forms of rpm digital signature commands are</p>

<p>rpm --import PUBKEY ...</p>

<p>rpm {--checksig} [--nosignature] [--nodigest]
PACKAGE_FILE ...</p>

<p>The --checksig option checks all the digests and
signatures contained in PACKAGE_FILE to ensure the integrity
and origin of the package. Note that signatures are now
verified whenever a package is read, and --checksig is
useful to verify all of the digests and signatures asso-
ciated with a package.</p>

<p>Digital signatures cannot be verified without a public
key. An ASCII armored public key can be added to the rpm
database using --import. An imported public key is carried
in a header, and key ring management is performed exactly
like package management. For example, all currently imported
public keys can be displayed by:</p>

<p>rpm -qa gpg-pubkey*</p>

<p>Details about a specific public key, when imported, can
be displayed by querying. Heres information about the Red
Hat GPG/DSA key:</p>

<p>rpm -qi gpg-pubkey-db42a60e</p>

<p>Finally, public keys can be erased after importing just
like packages. Heres how to remove the Red Hat GPG/DSA
key</p>

<p>rpm -e gpg-pubkey-db42a60e</p>

<p>SIGNING A PACKAGE rpm --addsign|--resign PACKAGE_FILE
...</p>

<p>Both of the --addsign and --resign options generate and
insert new sig- natures for each package PACKAGE_FILE given,
replacing any existing signatures. There are two options for
historical reasons, there is no difference in behavior
currently.</p>

<p>USING GPG TO SIGN PACKAGES In order to sign packages
using GPG, rpm must be configured to run GPG and be able to
find a key ring with the appropriate keys. By default, rpm
uses the same conventions as GPG to find key rings, namely
the $GNUPGHOME environment variable. If your key rings are
not located where GPG expects them to be, you will need to
configure the macro %_gpg_path to be the location of the GPG
key rings to use.</p>

<p>For compatibility with older versions of GPG, PGP, and
rpm, only V3 OpenPGP signature packets should be configured.
Either DSA or RSA ver- ification algorithms can be used, but
DSA is preferred.</p>

<p>If you want to be able to sign packages you create
yourself, you also need to create your own public and secret
key pair (see the GPG man- ual). You will also need to
configure the rpm macros</p>

<p>%_signature The signature type. Right now only gpg and
pgp are supported.</p>

<p>%_gpg_name The name of the &quot;user&quot; whose key
you wish to use to sign your packages.</p>

<p>For example, to be able to use GPG to sign packages as
the user &quot;John Doe &lt;jdoe@foo.com&gt;&quot; from the
key rings located in /etc/rpm/.gpg using the executable
/usr/bin/gpg you would include</p>

<p>%_signature gpg %_gpg_path /etc/rpm/.gpg %_gpg_name John
Doe &lt;jdoe@foo.com&gt; %_gpgbin /usr/bin/gpg</p>

<p>in a macro configuration file. Use /etc/rpm/macros for
per-system con- figuration and ~/.rpmmacros for per-user
configuration.</p>

<p>REBUILD DATABASE OPTIONS The general form of an rpm
rebuild database command is</p>

<p>rpm {--initdb|--rebuilddb} [-v] [--dbpath DIRECTORY]
[--root DIRECTORY]</p>

<p>Use --initdb to create a new database if one doesnt
already exist (existing database is not overwritten), use
--rebuilddb to rebuild the database indices from the
installed package headers.</p>

<p>SHOWRC The command</p>

<p>rpm --showrc</p>

<p>shows the values rpm will use for all of the options are
currently set in rpmrc and macros configuration file(s).</p>

<p>FTP/HTTP OPTIONS rpm can act as an FTP and/or HTTP
client so that packages can be queried or installed from the
internet. Package files for install, upgrade, and query
operations may be specified as an ftp or http style URL:</p>

<p>ftp://USER:PASSWORD@HOST:PORT/path/to/package.rpm</p>

<p>If the :PASSWORD portion is omitted, the password will
be prompted for (once per user/hostname pair). If both the
user and password are omit- ted, anonymous ftp is used. In
all cases, passive (PASV) ftp transfers are performed.</p>

<p>rpm allows the following options to be used with ftp
URLs:</p>

<p>--ftpproxy HOST The host HOST will be used as a proxy
server for all ftp trans- fers, which allows users to ftp
through firewall machines which use proxy systems. This
option may also be specified by config- uring the macro
%_ftpproxy.</p>

<p>--ftpport PORT The TCP PORT number to use for the ftp
connection on the proxy ftp server instead of the default
port. This option may also be specified by configuring the
macro %_ftpport.</p>

<p>rpm allows the following options to be used with http
URLs:</p>

<p>--httpproxy HOST The host HOST will be used as a proxy
server for all http trans- fers. This option may also be
specified by configuring the macro %_httpproxy.</p>

<p>--httpport PORT The TCP PORT number to use for the http
connection on the proxy http server instead of the default
port. This option may also be specified by configuring the
macro %_httpport.</p>

<p>LEGACY ISSUES Executing rpmbuild The build modes of rpm
are now resident in the /usr/bin/rpmbuild exe- cutable.
Although legacy compatibility provided by the popt aliases
below has been adequate, the compatibility is not perfect;
hence build mode compatibility through popt aliases is being
removed from rpm. Install the package containing rpmbuild
(usually rpm-build) and see rpmbuild(8) for documentation of
all the rpm build modes previously documented here in
rpm(8).</p>

<p>Add the following lines to /etc/popt if you wish to
continue invoking rpmbuild from the rpm command line:</p>

<p>rpm exec --bp rpmb -bp rpm exec --bc rpmb -bc rpm exec
--bi rpmb -bi rpm exec --bl rpmb -bl rpm exec --ba rpmb -ba
rpm exec --bb rpmb -bb rpm exec --bs rpmb -bs rpm exec --tp
rpmb -tp rpm exec --tc rpmb -tc rpm exec --ti rpmb -ti rpm
exec --tl rpmb -tl rpm exec --ta rpmb -ta rpm exec --tb rpmb
-tb rpm exec --ts rpmb -ts rpm exec --rebuild rpmb --rebuild
rpm exec --recompile rpmb --recompile rpm exec --clean rpmb
--clean rpm exec --rmsource rpmb --rmsource rpm exec
--rmspec rpmb --rmspec rpm exec --target rpmb --target rpm
exec --short-circuit rpmb --short-circuit</p>

<p>FILES rpmrc Configuration /usr/lib/rpm/rpmrc
/usr/lib/rpm/redhat/rpmrc /etc/rpmrc ~/.rpmrc</p>

<p>Macro Configuration /usr/lib/rpm/macros
/usr/lib/rpm/redhat/macros /etc/rpm/macros ~/.rpmmacros</p>

<p>Database /var/lib/rpm/Basenames
/var/lib/rpm/Conflictname /var/lib/rpm/Dirnames
/var/lib/rpm/Filemd5s /var/lib/rpm/Group
/var/lib/rpm/Installtid /var/lib/rpm/Name
/var/lib/rpm/Packages /var/lib/rpm/Providename
/var/lib/rpm/Provideversion /var/lib/rpm/Pubkeys
/var/lib/rpm/Removed /var/lib/rpm/Requirename
/var/lib/rpm/Requireversion /var/lib/rpm/Sha1header
/var/lib/rpm/Sigmd5 /var/lib/rpm/Triggername</p>

<p>Temporary /var/tmp/rpm*</p>

<p>SEE ALSO popt(3), rpm2cpio(8), rpmbuild(8),</p>

<p>rpm --help - as rpm supports customizing the options via
popt aliases its impossible to guarantee that whats
described in the manual matches whats available.</p>

<p>http://www.rpm.org/ &lt;URL:http://www.rpm.org/&gt;</p>

<p>AUTHORS Marc Ewing &lt;marc@redhat.com&gt; Jeff Johnson
&lt;jbj@redhat.com&gt; Erik Troan &lt;ewt@redhat.com&gt;</p>

<p>Red Hat, Inc. 09 June 2002 RPM(8) KSH(1) KSH(1)</p>

<p>NAME ksh, rksh, pfksh - KornShell, a standard/restricted
command and pro- gramming language</p>

<p>SYNOPSIS ksh [ &plusmn;abcefhiknoprstuvxBCDP ] [ -R file
] [ &plusmn;o option ] ... [ - ] [ arg ... ]</p>

<p>DESCRIPTION Ksh is a command and programming language
that executes commands read from a terminal or a file. Rksh
is a restricted version of the command interpreter ksh; it
is used to set up login names and execution envi- ronments
whose capabilities are more controlled than those of the
stan- dard shell. Rpfksh is a profile shell version of the
command inter- preter ksh; it is used to to execute commands
with the attributes spec- ified by the user s profiles (see
pfexec(1)). See Invocation below for the meaning of
arguments to the shell.</p>

<p>NOTE: Pfksh, Rpfksh and pfexec parts are not related to
Linux systems. Rksh can be used as rksh symlink to ksh93 or
as ksh -r.</p>

<p>Definitions. A metacharacter is one of the following
characters:</p>

<p>; &amp; ( ) &lt; &gt; new-line space tab</p>

<p>A blank is a tab or a space. An identifier is a sequence
of letters, digits, or underscores starting with a letter or
underscore. Identi- fiers are used as components of variable
names. A vname is a sequence of one or more identifiers
separated by a . and optionally preceded by a .. Vnames are
used as function and variable names. A word is a sequence of
characters from the character set defined by the current
locale, excluding non-quoted metacharacters.</p>

<p>A command is a sequence of characters in the syntax of
the shell lan- guage. The shell reads each command and
carries out the desired action either directly or by
invoking separate utilities. A built-in command is a command
that is carried out by the shell itself without creating a
separate process. Some commands are built-in purely for
convenience and are not documented here. Built-ins that
cause side effects in the shell environment and built-ins
that are found before performing a path search (see
Execution below) are documented here. For historical rea-
sons, some of these built-ins behave differently than other
built-ins and are called special built-ins.</p>

<p>Commands. A simple-command is a list of variable
assignments (see Variable Assignments below) or a sequence
of blank separated words which may be preceded by a list of
variable assignments (see Environment below). The first word
specifies the name of the command to be executed. Except as
specified below, the remaining words are passed as arguments
to the invoked command. The command name is passed as
argument 0 (see exec(2)). The value of a simple-command is
its exit status; 0-255 if it terminates normally; 256+signum
if it terminates abnormally (the name of the signal
corresponding to the exit status can be obtained via the -l
option of the kill built-in utility).</p>

<p>A pipeline is a sequence of one or more commands
separated by. The standard output of each command but the
last is connected by a pipe(2) to the standard input of the
next command. Each command, except possi- bly the last, is
run as a separate process; the shell waits for the last
command to terminate. The exit status of a pipeline is the
exit status of the last command unless the pipefail option
is enabled. Each pipeline can be preceded by the reserved
word ! which causes the exit status of the pipeline to
become 0 if the exit status of the last com- mand is
non-zero, and 1 if the exit status of the last command is
0.</p>

<p>A list is a sequence of one or more pipelines separated
by ;, &amp;,&amp;, &amp;&amp;, o, and optionally terminated
by ;, &amp;, or &amp;. Of these five symbols, ;, &amp;, and
&amp; have equal precedence, which is lower than that of
&amp;&amp; and. The symbols &amp;&amp; and also have equal
precedence. A semicolon (;) causes sequential execution of
the preceding pipeline; an ampersand (&amp;) causes
asynchronous execution of the preceding pipeline (i.e., the
shell does not wait for that pipeline to finish). The sym-
bol &amp; causes asynchronous execution of the preceding
pipeline with a two-way pipe established to the parent
shell; the standard input and output of the spawned pipeline
can be written to and read from by the parent shell by
applying the redirection operators &lt;&amp; and &gt;&amp;
with arg p to commands and by using -p option of the
built-in commands read and print described later. The symbol
&amp;&amp; ) causes the list following it to be executed
only if the preceding pipeline returns a zero (non-zero)
value. One or more new-lines may appear in a list instead of
a semi- colon, to delimit a command. The first item of the
first pipeline of a list that is a simple command not
beginning with a redirection, and not occurring within a
while, until, or if list, can be preceded by a semicolon.
This semicolon is ignored unless the showme option is
enabled as described with the set built-in below.</p>

<p>A command is either a simple-command or one of the
following. Unless otherwise stated, the value returned by a
command is that of the last simple-command executed in the
command.</p>

<p>for vname [ in word ... ] ;do list ;done Each time a for
command is executed, vname is set to the next word taken
from the in word list. If in word ... is omitted, then the
for command executes the do list once for each posi- tional
parameter that is set starting from 1 (see Parameter
Expansion below). Execution ends when there are no more
words in the list.</p>

<p>for (( [expr1] ; [expr2] ; [expr3] )) ;do list ;done The
arithmetic expression expr1 is evaluated first (see Arith-
metic evaluation below). The arithmetic expression expr2 is
repeatedly evaluated until it evaluates to zero and when
non- zero, list is executed and the arithmetic expression
expr3 eval- uated. If any expression is omitted, then it
behaves as if it evaluated to 1.</p>

<p>select vname [ in word ... ] ;do list ;done A select
command prints on standard error (file descriptor 2) the set
of words, each preceded by a number. If in word ... is
omitted, then the positional parameters starting from 1 are
used instead (see Parameter Expansion below). The PS3 prompt
is printed and a line is read from the standard input. If
this line consists of the number of one of the listed words,
then the value of the variable vname is set to the word
corresponding to this number. If this line is empty, the
selection list is printed again. Otherwise the value of the
variable vname is set to null. The contents of the line read
from standard input is saved in the variable REPLY. The list
is executed for each selection until a break or end-of-file
is encountered. If the REPLY variable is set to null by the
execution of list, then the selection list is printed before
displaying the PS3 prompt for the next selection.</p>

<p>case word in [ [(]pattern [ pattern ] ... ) list ;; ]
... esac A case command executes the list associated with
the first pat- tern that matches word. The form of the
patterns is the same as that used for file-name generation
(see File Name Generation below). The ;; operator causes
execution of case to terminate. If ;&amp; is used in place
of ;; the next subsequent list, if any, is executed.</p>

<p>if list ;then list [ ;elif list ;then list ] ... [ ;else
list ] ;fi The list following if is executed and, if it
returns a zero exit status, the list following the first
then is executed. Other- wise, the list following elif is
executed and, if its value is zero, the list following the
next then is executed. Failing each successive elif list,
the else list is executed. If the if list has non-zero exit
status and there is no else list, then the if command
returns a zero exit status.</p>

<p>while list ;do list ;done until list ;do list ;done A
while command repeatedly executes the while list and, if the
exit status of the last command in the list is zero,
executes the do list; otherwise the loop terminates. If no
commands in the do list are executed, then the while command
returns a zero exit status; until may be used in place of
while to negate the loop termination test.</p>

<p>((expression)) The expression is evaluated using the
rules for arithmetic eval- uation described below. If the
value of the arithmetic expres- sion is non-zero, the exit
status is 0, otherwise the exit sta- tus is 1.</p>

<p>(list) Execute list in a separate environment. Note,
that if two adja- cent open parentheses are needed for
nesting, a space must be inserted to avoid evaluation as an
arithmetic command as described above.</p>

<p>{ list;} list is simply executed. Note that unlike the
metacharacters ( and ), { and } are reserved words and must
occur at the begin- ning of a line or after a ; in order to
be recognized.</p>

<p>[[ expression ]] Evaluates expression and returns a zero
exit status when expres- sion is true. See Conditional
Expressions below, for a descrip- tion of expression.</p>

<p>function varname { list ;} varname () { list ;} Define a
function which is referenced by varname. A function whose
varname contains a . is called a discipline function and the
portion of the varname preceding the last . must refer to an
existing variable. The body of the function is the list of
commands between { and }. A function defined with the
function varname syntax can also be used as an argument to
the . special built-in command to get the equivalent
behavior as if the var- name() syntax were used to define
it. (See Functions below.)</p>

<p>time [ pipeline ] If pipeline is omitted the user and
system time for the current shell and completed child
processes is printed on standard error. Otherwise, pipeline
is executed and the elapsed time as well as the user and
system time are printed on standard error. The TIMEFORMAT
variable may be set to a format string that spec- ifies how
the timing information should be displayed. See Shell
Variables below for a description of the TIMEFORMAT
variable.</p>

<p>The following reserved words are recognized as reserved
only when they are the first word of a command and are not
quoted:</p>

<p>if then else elif fi case esac for while until do done {
} function select time [[ ]] !</p>

<p>Variable Assignments. One or more variable assignments
can start a simple command or can be arguments to the
typeset, enum, export, or readonly special built-in commands
as well as to other declaration commands created as types.
The syntax for an assignment is of the form:</p>

<p>varname=word varname[word]=word No space is permitted
between varname and the = or between = and word.</p>

<p>varname=(assign_list) No space is permitted between
varname and the =. An assign_list can be one of the
following: word ... Indexed array assignment. [word]=word
... Associative array assignment. If preceded by typeset -a
this will create an indexed array instead. assignment ...
Compound variable assignment. This creates a compound
variable varname with sub-variables of the form
varname.name, where name is the name portion of assignment.
The value of varname will contain all the assignment
elements. Additional assignments made to sub-variables of
varname will also be displayed as part of the value of var-
name. If no assignments are specified, varname will be a
compound variable allowing subsequence child elements to be
defined. typeset [options] assignment ... Nested variable
assignment. Multiple assignments can be specified by
separating each of them with a ;. The previous value is
unset before the assignment. Other declaration commands such
as readonly, enum, and other declaration commands can be
used in place of typeset. . filename Include the assignment
commands contained in filename.</p>

<p>In addition, a += can be used in place of the = to
signify adding to or appending to the previous value. When
+= is applied to an arithmetic type, word is evaluated as an
arithmetic expression and added to the current value. When
applied to a string variable, the value defined by word is
appended to the value. For compound assignments, the
previous value is not unset and the new values are appended
to the current ones provided that the types are
compatible.</p>

<p>The right hand side of a variable assignment undergoes
all the expan- sion listed below except word splitting,
brace expansion, and file name generation. When the left
hand side is an assignment is a compound variable and the
right hand is the name of a compound variable, the compound
variable on the right will be copied or appended to the com-
pound variable on the left.</p>

<p>Comments. A word beginning with # causes that word and
all the following charac- ters up to a new-line to be
ignored. Aliasing. The first word of each command is
replaced by the text of an alias if an alias for this word
has been defined. An alias name consists of any number of
characters excluding metacharacters, quoting characters,
file expansion characters, parameter expansion and command
substitution characters, and =. The replacement string can
contain any valid shell script including the metacharacters
listed above. The first word of each command in the replaced
text, other than any that are in the pro- cess of being
replaced, will be tested for aliases. If the last char-
acter of the alias value is a blank then the word following
the alias will also be checked for alias substitution.
Aliases can be used to redefine built-in commands but cannot
be used to redefine the reserved words listed above. Aliases
can be created and listed with the alias command and can be
removed with the unalias command. Aliasing is performed when
scripts are read, not while they are exe- cuted. Therefore,
for an alias to take effect, the alias definition command
has to be executed before the command which references the
alias is read. The following aliases are compiled into the
shell but can be unset or redefined: autoloadtypeset -fu
commandcommand compoundtypeset -C fc=hist floattypeset -lE
functionstypeset -f hashalias -t -- historyhist -l
integertypeset -li namereftypeset -n nohupnohup rhist -s
redirectcommand exec sourcecommand . stopkill -s STOP
suspendkill -s STOP $$ times{ { time;} 2&gt;&amp;1;}
typewhence -v</p>

<p>Tilde Substitution. After alias substitution is
performed, each word is checked to see if it begins with an
unquoted. For tilde substitution, word also refers to the
word portion of parameter expansion (see Parameter Expansion
below). If it does, then the word up to a / is checked to
see if it matches a user name in the password database (See
getpwname(3).) If a match is found, the and the matched
login name are replaced by the login directory of the
matched user. If no match is found, the origi- nal text is
left unchanged. A by itself, or in front of a /, is replaced
by $HOME. A followed by a + or - is replaced by the value of
$PWD and $OLDPWD respectively.</p>

<p>In addition, when expanding a variable assignment, tilde
substitution is attempted when the value of the assignment
begins with a, and when a appears after a :. The : also
terminates a login name.</p>

<p>Command Substitution. The standard output from a command
list enclosed in parentheses pre- ceded by a dollar sign (
$(list) ), or in a brace group preceded by a dollar sign (
${ list;} ), or in a pair of grave accents (&lsquo;&lsquo;)
may be used as part or all of a word; trailing new-lines are
removed. In the second case, the { and } are treated as a
reserved words so that { must be followed by a blank and }
must appear at the beginning of the line or follow a ;. In
the third (obsolete) form, the string between the quotes is
processed for special quoting characters before the command
is executed (see Quoting below). The command substitution
$(cat file) can be replaced by the equivalent but faster
$(&lt;file). The command substitution $(n&lt;#) will expand
to the current byte offset for file descriptor n. Except for
the second form, the command list is run in a subshell so
that no side effects are possible. For the second form, the
final } will be recognized as a reserved word after any
token.</p>

<p>Arithmetic Substitution. An arithmetic expression
enclosed in double parentheses preceded by a dollar sign (
$(()) ) is replaced by the value of the arithmetic
expression within the double parentheses.</p>

<p>Process Substitution. This feature is only available on
versions of the UNIX operating system that support the
/dev/fd directory for naming open files. Each command
argument of the form &lt;(list) or &gt;(list) will run
process list asyn- chronously connected to some file in
/dev/fd. The name of this file will become the argument to
the command. If the form with &gt; is selected then writing
on this file will provide input for list. If &lt; is used,
then the file passed as an argument will contain the output
of the list process. For example,</p>

<p>paste &lt;(cut -f1 file1) &lt;(cut -f3 file2) | tee
&gt;(process1) &gt;(pro- cess2)</p>

<p>cuts fields 1 and 3 from the files file1 and file2
respectively, pastes the results together, and sends it to
the processes process1 and pro- cess2, as well as putting it
onto the standard output. Note that the file, which is
passed as an argument to the command, is a UNIX pipe(2) so
programs that expect to lseek(2) on the file will not
work.</p>

<p>Process substitution of the form &lt;(list) can also be
used with the &lt; redirection operator which causes the
output of list to be standard input or the input for
whatever file descriptor is specified.</p>

<p>Parameter Expansion. A parameter is a variable, one or
more digits, or any of the characters , @, #, ?, -, $, and
!. A variable is denoted by a vname. To create a variable
whose vname contains a ., a variable whose vname consists of
everything before the last . must already exist. A variable
has a value and zero or more attributes. Variables can be
assigned values and attributes by using the typeset special
built-in command. The attributes supported by the shell are
described later with the typeset special built-in command.
Exported variables pass values and attributes to the
environment.</p>

<p>The shell supports both indexed and associative arrays.
An element of an array variable is referenced by a
subscript. A subscript for an indexed array is denoted by an
arithmetic expression (see Arithmetic evaluation below)
between a [ and a ]. To assign values to an indexed array,
use vname=(value ...) or set -A vname value ... . The value
of all non-negative subscripts must be in the range of 0
through 4,194,303. A negative subscript is treated as an
offset from the maxi- mum current index +1 so that -1 refers
to the last element. Indexed arrays can be declared with the
-a option to typeset. Indexed arrays need not be declared.
Any reference to a variable with a valid sub- script is
legal and an array will be created if necessary.</p>

<p>An associative array is created with the -A option to
typeset. A sub- script for an associative array is denoted
by a string enclosed between [ and ].</p>

<p>Referencing any array without a subscript is equivalent
to referencing the array with subscript 0.</p>

<p>The value of a variable may be assigned by writing:</p>

<p>vname=value [ vname=value ] ...</p>

<p>or vname[subscript]=value [ vname[subscript]=value ] ...
Note that no space is allowed before or after the =. A
nameref is a variable that is a reference to another
variable. A nameref is created with the -n attribute of
typeset. The value of the variable at the time of the
typeset command becomes the variable that will be referenced
whenever the nameref variable is used. The name of a nameref
cannot contain a .. When a variable or function name con-
tains a ., and the portion of the name up to the first .
matches the name of a nameref, the variable referred to is
obtained by replacing the nameref portion with the name of
the variable referenced by the nameref. If a nameref is used
as the index of a for loop, a name ref- erence is
established for each item in the list. A nameref provides a
convenient way to refer to the variable inside a function
whose name is passed as an argument to a function. For
example, if the name of a variable is passed as the first
argument to a function, the command typeset -n var=$1 inside
the function causes references and assignments to var to be
ref- erences and assignments to the variable whose name has
been passed to the function. If any of the floating point
attributes, -E, -F, or -X, or the integer attribute, -i, is
set for vname, then the value is subject to arith- metic
evaluation as described below. Positional parameters,
parameters denoted by a number, may be assigned values with
the set special built-in command. Parameter $0 is set from
argument zero when the shell is invoked. The character $ is
used to introduce substitutable parameters. ${parameter} The
shell reads all the characters from ${ to the matching } as
part of the same word even if it contains braces or
metacharac- ters. The value, if any, of the parameter is
substituted. The braces are required when parameter is
followed by a letter, digit, or underscore that is not to be
interpreted as part of its name, when the variable name
contains a .. The braces are also required when a variable
is subscripted unless it is part of an Arithmetic Expression
or a Conditional Expression. If parameter is one or more
digits then it is a positional parame- ter. A positional
parameter of more than one digit must be enclosed in braces.
If parameter is or @, then all the posi- tional parameters,
starting with $1, are substituted (separated by a field
separator character). If an array vname with sub- script @,
or of the form sub1 .. sub2. is used, then the value for
each of the elements between sub1 and sub2 inclusive (or all
elements for and @) is substituted, separated by the first
character of the value of IFS. ${#parameter} If parameter is
or @, the number of positional parameters is substituted.
Otherwise, the length of the value of the parame- ter is
substituted. ${#vname[*]} ${#vname[@]} The number of
elements in the array vname is substituted.</p>

<p>${@vname} Expands to the type name (See Type Variables
below) or attributes of the variable referred to by vname.
${!vname} Expands to the name of the variable referred to by
vname. This will be vname except when vname is a name
reference. ${!vname[subscript]} Expands to name of the
subscript unless subscript is *, @. or of the form sub1 ..
sub2. When subscript is *, the list of array subscripts for
vname is generated. For a variable that is not an array, the
value is 0 if the variable is set. Otherwise it is null.
When subscript is @, same as above, except that when used in
double quotes, each array subscript yields a sepa- rate
argument. When subscript is of the form sub1 .. sub2 it
expands to the list of subscripts between sub1 and sub2
inclu- sive using the same quoting rules as @. ${!prefix*}
Expands to the names of the variables whose names begin with
prefix. ${parameter:-word} If parameter is set and is
non-null then substitute its value; otherwise substitute
word. ${parameter:=word} If parameter is not set or is null
then set it to word; the value of the parameter is then
substituted. Positional parame- ters may not be assigned to
in this way. ${parameter:?word} If parameter is set and is
non-null then substitute its value; otherwise, print word
and exit from the shell (if not interac- tive). If word is
omitted then a standard message is printed.
${parameter:+word} If parameter is set and is non-null then
substitute word; other- wise substitute nothing. In the
above, word is not evaluated unless it is to be used as the
sub- stituted string, so that, in the following example, pwd
is executed only if d is not set or is null: print
${d:-$(pwd)} If the colon ( : ) is omitted from the above
expressions, then the shell only checks whether parameter is
set or not. ${parameter:offset:length} ${parameter:offset}
Expands to the portion of the value of parameter starting at
the character (counting from 0) determined by expanding
offset as an arithmetic expression and consisting of the
number of characters determined by the arithmetic expression
defined by length. In the second form, the remainder of the
value is used. If A nega- tive offset counts backwards from
the end of parameter. Note that one or more blanks is
required in front of a minus sign to prevent the shell from
interpreting the operator as :-. If parameter is or @, or is
an array name indexed by or @, then offset and length refer
to the array index and number of ele- ments respectively. A
negative offset is taken relative to one greater than the
highest subscript for indexed arrays. The order for
associate arrays is unspecified. ${parameter#pattern}
${parameter##pattern} If the shell pattern matches the
beginning of the value of parameter, then the value of this
expansion is the value of the parameter with the matched
portion deleted; otherwise the value of this parameter is
substituted. In the first form the small- est matching
pattern is deleted and in the second form the largest
matching pattern is deleted. When parameter is @, *, or an
array variable with subscript @ or *, the substring
operation is applied to each element in turn.</p>

<p>${parameter%pattern} ${parameter%%pattern} If the shell
pattern matches the end of the value of parameter, then the
value of this expansion is the value of the parameter with
the matched part deleted; otherwise substitute the value of
parameter. In the first form the smallest matching pattern
is deleted and in the second form the largest matching
pattern is deleted. When parameter is @, *, or an array
variable with sub- script @ or *, the substring operation is
applied to each ele- ment in turn.</p>

<p>${parameter/pattern/string} ${parameter//pattern/string}
${parameter/#pattern/string} ${parameter/%pattern/string}
Expands parameter and replaces the longest match of pattern
with the given string. Each occurrence ofn in string is
replaced by the portion of parameter that matches the n-th
sub-pattern. In the first form, only the first occurrence of
pattern is replaced. In the second form, each match for
pattern is replaced by the given string. The third form
restricts the pat- tern match to the beginning of the string
while the fourth form restricts the pattern match to the end
of the string. When string is null, the pattern will be
deleted and the / in front of string may be omitted. When
parameter is @, *, or an array variable with subscript @ or
*, the substitution operation is applied to each element in
turn. In this case, the string por- tion of word will be
re-evaluated for each element.</p>

<p>The following parameters are automatically set by the
shell: # The number of positional parameters in decimal. -
Options supplied to the shell on invocation or by the set
command. ? The decimal value returned by the last executed
command. $ The process number of this shell. _ Initially,
the value of _ is an absolute pathname of the shell or
script being executed as passed in the environ- ment.
Subsequently it is assigned the last argument of the
previous command. This parameter is not set for com- mands
which are asynchronous. This parameter is also used to hold
the name of the matching MAIL file when checking for mail.
While defining a compound variable or a type, _ is
initialized as a reference to the compound variable or type.
When a discipline function is invoked, _ is initialized as a
reference to the variable associ- ated with the call to this
function. Finally when _ is used as the name of the first
variable of a type defini- tion, the new type is derived
from the type of the first variable (See Type Variables
below.). ! The process number of the last background command
invoked or the most recent job put in the background with
the bg built-in command. .sh.command When processing a DEBUG
trap, this variable contains the current command line that
is about to run. .sh.edchar This variable contains the value
of the keyboard charac- ter (or sequence of characters if
the first character is an ESC, ascii 033) that has been
entered when processing a KEYBD trap (see Key Bindings
below). If the value is changed as part of the trap action,
then the new value replaces the key (or key sequence) that
caused the trap. .sh.edcol The character position of the
cursor at the time of the most recent KEYBD trap. .sh.edmode
The value is set to ESC when processing a KEYBD trap while
in vi insert mode. (See Vi Editing Mode below.) Otherwise,
.sh.edmode is null when processing a KEYBD trap. .sh.edtext
The characters in the input buffer at the time of the most
recent KEYBD trap. The value is null when not pro- cessing a
KEYBD trap. .sh.file The pathname of the file than contains
the current com- mand. .sh.fun The name of the current
function that is being executed. .sh.level Set to the
current function depth. This can be changed inside a DEBUG
trap and will set the context to the spec- ified level.
.sh.lineno Set during a DEBUG trap to the line number for
the caller of each function. .sh.match An indexed array
which stores the most recent match and sub-pattern matches
after conditional pattern matches that match and after
variables expansions using the oper- ators #, %, or /. The
0-th element stores the complete match and the i-th. element
stores the i-th submatch. The .sh.match variable becomes
unset when the variable that has expanded is assigned a new
value. .sh.name Set to the name of the variable at the time
that a disci- pline function is invoked. .sh.subscript Set
to the name subscript of the variable at the time that a
discipline function is invoked. .sh.subshell The current
depth for subshells and command substitution. .sh.value Set
to the value of the variable at the time that the set or
append discipline function is invoked. .sh.version Set to a
value that identifies the version of this shell. KSH_VERSION
A name reference to .sh.version. LINENO The current line
number within the script or function being executed. OLDPWD
The previous working directory set by the cd command. OPTARG
The value of the last option argument processed by the
getopts built-in command. OPTIND The index of the last
option argument processed by the getopts built-in command.
PPID The process number of the parent of the shell. PWD The
present working directory set by the cd command. RANDOM Each
time this variable is referenced, a random integer,
uniformly distributed between 0 and 32767, is generated. The
sequence of random numbers can be initialized by assigning a
numeric value to RANDOM. REPLY This variable is set by the
select statement and by the read built-in command when no
arguments are supplied. SECONDS Each time this variable is
referenced, the number of sec- onds since shell invocation
is returned. If this vari- able is assigned a value, then
the value returned upon reference will be the value that was
assigned plus the number of seconds since the assignment.
SHLVL An integer variable the is incremented each time the
shell is invoked and is exported. If SHLVL is not in the
environment when the shell is invoked, it is set to 1.</p>

<p>The following variables are used by the shell: CDPATH
The search path for the cd command. COLUMNS If this variable
is set, the value is used to define the width of the edit
window for the shell edit modes and for printing select
lists. EDITOR If the VISUAL variable is not set, the value
of this variable will be checked for the patterns as
described with VISUAL below and the corresponding editing
option (see Special Command set below) will be turned on.
ENV If this variable is set, then parameter expansion, com-
mand substitution, and arithmetic substitution are per-
formed on the value to generate the pathname of the script
that will be executed when the shell is invoked
interactively (see Invocation below). This file is typi-
cally used for alias and function definitions. The default
value is $HOME/.kshrc. On systems that support a system wide
/etc/ksh.kshrc initialization file, if the filename
generated by the expansion of ENV begins with /./ or ././
the system wide initialization file will not be executed.
FCEDIT Obsolete name for the default editor name for the
hist command. FCEDIT is not used when HISTEDIT is set.
FIGNORE A pattern that defines the set of filenames that
will be ignored when performing filename matching. FPATH The
search path for function definitions. The directo- ries in
this path are searched for a file with the same name as the
function or command when a function with the -u attribute is
referenced and when a command is not found. If an executable
file with the name of that com- mand is found, then it is
read and executed in the cur- rent environment. Unlike PATH,
the current directory must be represented explicitly by .
rather than by adjacent : characters or a beginning or
ending :. HISTCMD Number of the current command in the
history file. HISTEDIT Name for the default editor name for
the hist command. HISTFILE If this variable is set when the
shell is invoked, then the value is the pathname of the file
that will be used to store the command history (see Command
Re-entry below). HISTSIZE If this variable is set when the
shell is invoked, then the number of previously entered
commands that are acces- sible by this shell will be greater
than or equal to this number. The default is 512. HOME The
default argument (home directory) for the cd command. IFS
Internal field separators, normally space, tab, and new-
line that are used to separate the results of command
substitution or parameter expansion and to separate fields
with the built-in command read. The first charac- ter of the
IFS variable is used to separate arguments for the &quot;$
&quot; substitution (see Quoting below). Each single
occurrence of an IFS character in the string to be split,
that is not in the isspace character class, and any adja-
cent characters in IFS that are in the isspace character
class, delimit a field. One or more characters in IFS that
belong to the isspace character class, delimit a field. In
addition, if the same isspace character appears
consecutively inside IFS, this character is treated as if it
were not in the isspace class, so that if IFS consists of
two tab characters, then two adjacent tab characters delimit
a null field. JOBMAX This variable defines the maximum
number running back- ground jobs that can run at a time.
When this limit is reached, the shell will wait for a job to
complete before staring a new job. LANG This variable
determines the locale category for any cat- egory not
specifically selected with a variable starting with LC_ or
LANG. LC_ALL This variable overrides the value of the LANG
variable and any other LC_ variable. LC_COLLATE This
variable determines the locale category for charac- ter
collation information. LC_CTYPE This variable determines the
locale category for charac- ter handling functions. It
determines the character classes for pattern matching (see
File Name Generation below). LC_NUMERIC This variable
determines the locale category for the dec- imal point
character. LINES If this variable is set, the value is used
to determine the column length for printing select lists.
Select lists will print vertically until about two-thirds of
LINES lines are filled. MAIL If this variable is set to the
name of a mail file and the MAILPATH variable is not set,
then the shell informs the user of arrival of mail in the
specified file. MAILCHECK This variable specifies how often
(in seconds) the shell will check for changes in the
modification time of any of the files specified by the
MAILPATH or MAIL variables. The default value is 600
seconds. When the time has elapsed the shell will check
before issuing the next prompt. MAILPATH A colon ( : )
separated list of file names. If this variable is set, then
the shell informs the user of any modifications to the
specified files that have occurred within the last MAILCHECK
seconds. Each file name can be followed by a ? and a message
that will be printed. The message will undergo parameter
expansion, command substi- tution, and arithmetic
substitution with the variable $_ defined as the name of the
file that has changed. The default message is you have mail
in $_. PATH The search path for commands (see Execution
below). The user may not change PATH if executing under rksh
(except in .profile). PS1 The value of this variable is
expanded for parameter expansion, command substitution, and
arithmetic substitu- tion to define the primary prompt
string which by default is $. The character ! in the primary
prompt string is replaced by the command number (see Command
Re-entry below). Two successive occurrences of ! will
produce a single ! when the prompt string is printed. PS2
Secondary prompt string, by default &gt; . PS3 Selection
prompt string used within a select loop, by default #? . PS4
The value of this variable is expanded for parameter
evaluation, command substitution, and arithmetic substi-
tution and precedes each line of an execution trace. By
default, PS4 is + . In addition when PS4 is unset, the
execution trace prompt is also + . SHELL The pathname of the
shell is kept in the environment. At invocation, if the
basename of this variable is rsh, rksh, or krsh, then the
shell becomes restricted. If it is pfsh or pfksh, then the
shell becomes a profile shell (see pfexec(1)). TIMEFORMAT
The value of this parameter is used as a format string
specifying how the timing information for pipelines pre-
fixed with the time reserved word should be displayed. The %
character introduces a format sequence that is expanded to a
time value or other information. The for- mat sequences and
their meanings are as follows. %% A literal %. %[p][l]R The
elapsed time in seconds. %[p][l]U The number of CPU seconds
spent in user mode. %[p][l]S The number of CPU seconds spent
in system mode. %P The CPU percentage, computed as (U + S) /
R.</p>

<p>The brackets denote optional portions. The optional p is
a digit specifying the precision, the number of frac- tional
digits after a decimal point. A value of 0 causes no decimal
point or fraction to be output. At most three places after
the decimal point can be displayed; values of p greater than
3 are treated as 3. If p is not speci- fied, the value 3 is
used.</p>

<p>The optional l specifies a longer format, including
hours if greater than zero, minutes, and seconds of the form
HHhMMmSS.FFs. The value of p determines whether or not the
fraction is included.</p>

<p>All other characters are output without change and a
trailing newline is added. If unset, the default value,
nreat%2lnuset%2lnsys%2l, is used. If the value is null, no
timing information is displayed.</p>

<p>TMOUT If set to a value greater than zero, TMOUT will be
the default timeout value for the read built-in command. The
select compound command terminates after TMOUT seconds when
input is from a terminal. Otherwise, the shell will
terminate if a line is not entered within the prescribed
number of seconds while reading from a terminal. (Note that
the shell can be compiled with a maximum bound for this
value which cannot be exceeded.)</p>

<p>VISUAL If the value of this variable matches the pattern
*[Vv][Ii]*, then the vi option (see Special Command set
below) is turned on. If the value matches the pattern
*gmacs* , the gmacs option is turned on. If the value
matches the pattern *macs*, then the emacs option will be
turned on. The value of VISUAL overrides the value of
EDITOR.</p>

<p>The shell gives default values to PATH, PS1, PS2, PS3,
PS4, MAILCHECK, FCEDIT, TMOUT and IFS, while HOME, SHELL,
ENV, and MAIL are not set at all by the shell (although HOME
is set by login(1)). On some systems MAIL and SHELL are also
set by login(1).</p>

<p>Field Splitting. After parameter expansion and command
substitution, the results of sub- stitutions are scanned for
the field separator characters (those found in IFS) and
split into distinct fields where such characters are found.
Explicit null fields (&quot;&quot; o) are retained. Implicit
null fields (those resulting from parameters that have no
values or command substi- tutions with no output) are
removed.</p>

<p>If the braceexpand (-B) option is set then each of the
fields resulting from IFS are checked to see if they contain
one or more of the brace patterns {*,*}, {l1..l2} , {n1..n2}
, {n1..n2% fmt} , {n1..n2 ..n3} , or {n1..n2 ..n3%fmt} ,
where * represents any character, l1,l2 are let- ters and
n1,n2,n3 are signed numbers and fmt is a format specified as
used by printf. In each case, fields are created by
prepending the characters before the { and appending the
characters after the } to each of the strings generated by
the characters between the { and }. The resulting fields are
checked to see if they have any brace pat- terns.</p>

<p>In the first form, a field is created for each string
between { and ,, between , and ,, and between , and }. The
string represented by * can contain embedded matching { and
} without quoting. Otherwise, each { and } with * must be
quoted.</p>

<p>In the seconds form, l1 and l2 must both be either upper
case or both be lower case characters in the C locale. In
this case a field is cre- ated for each character from l1
thru l2.</p>

<p>In the remaining forms, a field is created for each
number starting at n1 and continuing until it reaches n2
incrementing n1 by n3. The cases where n3 is not specified
behave as if n3 where 1 if n1&lt;=n2 and -1 oth- erwise. If
forms which specify %fmt any format flags, widths and pre-
cisions can be specified and fmt can end in any of the
specifiers cdiouxX. For example, {a,z}{1..5..3%02d}{b..c}x
expands to the 8 fields, a01bx, a01cx, a04bx, a04cx, z01bx,
z01cx, z04bx and z4cx.</p>

<p>File Name Generation. Following splitting, each field is
scanned for the characters, ?, (, and [ unless the -f option
has been set. If one of these characters appears, then the
word is regarded as a pattern. Each file name compo- nent
that contains any pattern character is replaced with a
lexico- graphically sorted set of names that matches the
pattern from that directory. If no file name is found that
matches the pattern, then that component of the filename is
left unchanged unless the pattern is prefixed with(N) in
which case it is removed as described below. If FIGNORE is
set, then each file name component that matches the pattern
defined by the value of FIGNORE is ignored when generating
the matching filenames. The names . and .. are also ignored.
If FIGNORE is not set, the character . at the start of each
file name component will be ignored unless the first
character of the pattern corresponding to this component is
the character . itself. Note, that for other uses of pattern
matching the / and . are not treated specially.</p>

<p>Matches any string, including the null string. When used
for filename expansion, if the globstar option is on, two
adjacent s by itself will match all files and zero or more
directories and subdirectories. If followed by a / then only
directories and subdirectories will match. ? Matches any
single character. [...] Matches any one of the enclosed
characters. A pair of characters separated by - matches any
character lexically between the pair, inclusive. If the
first character fol- lowing the opening [ is a ! then any
character not enclosed is matched. A - can be included in
the charac- ter set by putting it as the first or last
character. Within [ and ], character classes can be
specified with the syntax [:class:] where class is one of
the following classes defined in the ANSI-C standard: (Note
that word is equivalent to alnum plus the character _).
alnum alpha blank cntrl digit graph lower print punct space
upper word xdigit Within [ and ], an equivalence class can
be specified with the syntax [=c=] which matches all
characters with the same primary collation weight (as
defined by the current locale) as the char- acter c. Within
[ and ], [.symbol.] matches the collating symbol symbol. A
pattern-list is a list of one or more patterns separated
from each other with a &amp; or. A &amp; signifies that all
patterns must be matched whereas requires that only one
pattern be matched. Composite pat- terns can be formed with
one or more of the following sub-patterns: ?(pattern-list)
Optionally matches any one of the given patterns.
*(pattern-list) Matches zero or more occurrences of the
given patterns. +(pattern-list) Matches one or more
occurrences of the given patterns. {n}(pattern-list) Matches
n occurrences of the given patterns. {m,n}(pattern-list)
Matches from m to n occurrences of the given patterns. If m
is omitted, 0 will be used. If n is omitted at least m
occurrences will be matched. @(pattern-list) Matches exactly
one of the given patterns. !(pattern-list) Matches anything
except one of the given patterns. By default, each pattern,
or sub-pattern will match the longest string possible
consistent with generating the longest overall match. If
more than one match is possible, the one starting closest to
the beginning of the string will be chosen. However, for
each of the above compound patterns a - can be inserted in
front of the ( to cause the shortest match to the specified
pattern-list to be used.</p>

<p>When pattern-list is contained within parentheses, the
backslash char- acter is treated specially even when inside
a character class. All ANSI-C character escapes are
recognized and match the specified charac- ter. In addition
the following escape sequences are recognized: d Matches any
character in the digit class. digit class. Matches any
character in the space class. Matches any character not in
the space class. 864word class. W Matches any character not
in the word class.</p>

<p>A pattern of the form %(pattern-pair(s)) is a
sub-pattern that can be used to match nested character
expressions. Each pattern-pair is a two character sequence
which cannot contain &amp; or. The first pattern-pair
specifies the starting and ending characters for the match.
Each sub- sequent pattern-pair represents the beginning and
ending characters of a nested group that will be skipped
over when counting starting and ending character matches.
The behavior is unspecified when the first character of a
pattern-pair is alpha-numeric except for the following: D
Causes the ending character to terminate the search for this
pattern without finding a match. E Causes the ending
character to be interpreted as an escape character. L Causes
the ending character to be interpreted as a quote character
causing all characters to be ignored when look- ing for a
match. Q Causes the ending character to be interpreted as a
quote character causing all characters other than any escape
character to be ignored when looking for a match. Thus,
%({}Q&quot;), matches characters starting at { until the
matching } is found not counting any { or } that is inside a
double quoted string or preceded by the escape character.
Without the {} this pattern matches any C language
string.</p>

<p>Each sub-pattern in a composite pattern is numbered,
starting at 1, by the location of the ( within the pattern.
The sequencen, where n is a single digit andn comes after
the n-th. sub-pattern, matches the same string as the
sub-pattern itself.</p>

<p>Finally a pattern can contain sub-patterns of the form
(options:pat- tern-list), where either options or
:pattern-list can be omitted. Unlike the other compound
patterns, these sub-patterns are not counted in the numbered
sub-patterns. If options is present, it can consist of one
or more of the following: + Enable the following options.
This is the default. - Disable the following options. E The
remainder of the pattern uses extended regular expression
syntax like the egrep(1) command. F The remainder of the
pattern uses fgrep(1) expression syntax. G The remainder of
the pattern uses basic regular expres- sion syntax like the
grep(1) command. K The remainder of the pattern uses shell
pattern syntax. This is the default. N This is ignored.
However, when it is the first letter and is used with file
name generation, and no matches occur, the file pattern
expands to the empty string. i Treat the match as case
insensitive. g File the longest match (greedy). This is the
default. l Left anchor the pattern. This is the default for
K style patterns. r Right anchor the pattern. This is the
default for K style patterns. If both options and
:pattern-list are specified, then the options apply only to
pattern-list. Otherwise, these options remain in effect
until they are disabled by a subsequent(...) or at the end
of the sub-pat- tern containing(...).</p>

<p>Quoting. Each of the metacharacters listed earlier (see
Definitions above) has a special meaning to the shell and
causes termination of a word unless quoted. A character may
be quoted (i.e., made to stand for itself) by preceding it
with a. The pairnew-line is removed. All characters enclosed
between a pair of single quote marks ) that is not preceded
by a $ are quoted. A single quote cannot appear within the
single quotes. A single quoted string preceded by an
unquoted $ is processed as an ANSI-C string except for the
following: 0 Causes the remainder of the string to be
ignored. E Equivalent to the escape character (ascii 033), e
Equivalent to the escape character (ascii 033), [.name.]
Expands to the collating element name.</p>

<p>Inside double quote marks (&quot;&quot;), parameter and
command substitution occur and quotes the characters
&lsquo;, &quot;, and $. A $ in front of a double quoted
string will be ignored in the &quot;C&quot; or
&quot;POSIX&quot; locale, and may cause the string to be
replaced by a locale specific string other- wise. The
meaning of $ and $@ is identical when not quoted or when
used as a variable assignment value or as a file name.
However, when used as a command argument, &quot;$ &quot; is
equivalent to &quot;$1d$2d...&quot;, where d is the first
character of the IFS variable, whereas &quot;$@&quot; is
equivalent to &quot;$1&quot; &quot;$2&quot; .... Inside
grave quote marks (&lsquo;&lsquo;), quotes the charac- ters
&lsquo;, and $. If the grave quotes occur within double
quotes, then also quotes the character &quot;.</p>

<p>The special meaning of reserved words or aliases can be
removed by quoting any character of the reserved word. The
recognition of func- tion names or built-in command names
listed below cannot be altered by quoting them.</p>

<p>Arithmetic Evaluation. The shell performs arithmetic
evaluation for arithmetic substitution, to evaluate an
arithmetic command, to evaluate an indexed array sub-
script, and to evaluate arguments to the built-in commands
shift and let. Evaluations are performed using double
precision floating point arithmetic or long double precision
floating point for systems that provide this data type.
Floating point constants follow the ANSI-C programming
language floating point conventions. Integer constants
follow the ANSI-C programming language integer constant
conventions although only single byte character constants
are recognized and char- acter casts are not recognized. In
addition constants can be of the form [base#]n where base is
a decimal number between two and sixty-four representing the
arithmetic base and n is a number in that base. The digits
above 9 are represented by the lower case letters, the upper
case letters, @, and _ respectively. For bases less than or
equal to 36, upper and lower case characters can be used
interchangeably.</p>

<p>An arithmetic expression uses the same syntax,
precedence, and associa- tivity of expression as the C
language. All the C language operators that apply to
floating point quantities can be used. In addition, the
operator ** can be used for exponentiation. It has higher
precedence than multiplication and is left associative. In
addition, when the value of an arithmetic variable or
sub-expression can be represented as a long integer, all C
language integer arithmetic operations can be performed.
Variables can be referenced by name within an arithmetic
expression without using the parameter expansion syntax.
When a vari- able is referenced, its value is evaluated as
an arithmetic expression.</p>

<p>Any of the following math library functions that are in
the C math library can be used within an arithmetic
expression:</p>

<p>abs acos acosh asin asinh atan atan2 atanh cbrt copysign
cos cosh erf erfc exp exp2 expm1 fabs fdim finite floor fma
fmax fmod hypot ilogb int isinf isnan j0 j1 jn lgamma log
log2 logb nearbyint nextafter next- toward pow remainder
rint round sin sinh sqrt tan tanh tgamma trunc y0 y1 yn</p>

<p>An internal representation of a variable as a double
precision floating point can be specified with the -E [n],
-F [n], or -X [n] option of the typeset special built-in
command. The -E option causes the expansion of the value to
be represented using scientific notation when it is
expanded. The optional option argument n defines the number
of signif- icant figures. The -F option causes the expansion
to be represented as a floating decimal number when it is
expanded. The -X option cause the expansion to be
represented using the %a format defined by ISO C-99. The
optional option argument n defines the number of places
after the decimal (or radix) point in this case.</p>

<p>An internal integer representation of a variable can be
specified with the -i [n] option of the typeset special
built-in command. The optional option argument n specifies
an arithmetic base to be used when expanding the variable.
If you do not specify an arithmetic base, base 10 will be
used.</p>

<p>Arithmetic evaluation is performed on the value of each
assignment to a variable with the -E, -F, -X, or -i
attribute. Assigning a floating point number to a variable
whose type is an integer causes the frac- tional part to be
truncated.</p>

<p>Prompting. When used interactively, the shell prompts
with the value of PS1 after expanding it for parameter
expansion, command substitution, and arith- metic
substitution, before reading a command. In addition, each
single ! in the prompt is replaced by the command number. A
!! is required to place ! in the prompt. If at any time a
new-line is typed and fur- ther input is needed to complete
a command, then the secondary prompt (i.e., the value of
PS2) is issued.</p>

<p>Conditional Expressions. A conditional expression is
used with the [[ compound command to test attributes of
files and to compare strings. Field splitting and file name
generation are not performed on the words between [[ and ]].
Each expression can be constructed from one or more of the
following unary or binary expressions: string True, if
string is not null. -a file Same as -e below. This is
obsolete. -b file True, if file exists and is a block
special file. -c file True, if file exists and is a
character special file. -d file True, if file exists and is
a directory. -e file True, if file exists. -f file True, if
file exists and is an ordinary file. -g file True, if file
exists and it has its setgid bit set. -k file True, if file
exists and it has its sticky bit set. -n string True, if
length of string is non-zero. -o ?option True, if option
named option is a valid option name. -o option True, if
option named option is on. -p file True, if file exists and
is a fifo special file or a pipe. -r file True, if file
exists and is readable by current process. -s file True, if
file exists and has size greater than zero. -t fildes True,
if file descriptor number fildes is open and associated with
a terminal device. -u file True, if file exists and it has
its setuid bit set. -w file True, if file exists and is
writable by current process. -x file True, if file exists
and is executable by current process. If file exists and is
a directory, then true if the current process has permission
to search in the directory. -z string True, if length of
string is zero. -L file True, if file exists and is a
symbolic link. -h file True, if file exists and is a
symbolic link. -N file True, if file exists and the
modification time is greater than the last access time. -O
file True, if file exists and is owned by the effective user
id of this process. -G file True, if file exists and its
group matches the effective group id of this process. -S
file True, if file exists and is a socket. file1 -nt file2
True, if file1 exists and file2 does not, or file1 is newer
than file2. file1 -ot file2 True, if file2 exists and file1
does not, or file1 is older than file2. file1 -ef file2
True, if file1 and file2 exist and refer to the same file.
string == pattern True, if string matches pattern. Any part
of pattern can be quoted to cause it to be matched as a
string. With a successful match to a pattern, the .sh.match
array variable will contain the match and sub-pattern
matches. string = pattern Same as == above, but is obsolete.
string != pattern True, if string does not match pattern.
When the string matches the pattern the .sh.match array
variable will contain the match and sub-pattern matches.
string =ere True if string matches the pattern (E)ere where
ere is an extended regular expression. string1 &lt; string2
True, if string1 comes before string2 based on ASCII value
of their characters. string1 &gt; string2 True, if string1
comes after string2 based on ASCII value of their
characters. The following obsolete arithmetic comparisons
are also permitted: exp1 -eq exp2 True, if exp1 is equal to
exp2. exp1 -ne exp2 True, if exp1 is not equal to exp2. exp1
-lt exp2 True, if exp1 is less than exp2. exp1 -gt exp2
True, if exp1 is greater than exp2. exp1 -le exp2 True, if
exp1 is less than or equal to exp2. exp1 -ge exp2 True, if
exp1 is greater than or equal to exp2.</p>

<p>In each of the above expressions, if file is of the form
/dev/fd/n, where n is an integer, then the test is applied
to the open file whose descriptor number is n.</p>

<p>A compound expression can be constructed from these
primitives by using any of the following, listed in
decreasing order of precedence. (expression) True, if
expression is true. Used to group expressions. ! expression
True if expression is false. expression1 &amp;&amp;
expression2 True, if expression1 and expression2 are both
true. expression1expression2 True, if either expression1 or
expression2 is true.</p>

<p>Input/Output. Before a command is executed, its input
and output may be redirected using a special notation
interpreted by the shell. The following may appear anywhere
in a simple-command or may precede or follow a command and
are not passed on to the invoked command. Command
substitution, parameter expansion, and arithmetic
substitution occur before word or digit is used except as
noted below. File name generation occurs only if the shell
is interactive and the pattern matches a single file. Field
splitting is not performed.</p>

<p>In each of the following redirections, if file is of the
form /dev/sctp/host/port, /dev/tcp/host/port, or
/dev/udp/host/port, where host is a hostname or host
address, and port is a service given by name or an integer
port number, then the redirection attempts to make a tcp,
sctp or udp connection to the corresponding socket.</p>

<p>No intervening space is allowed between the characters
of redirection operators.</p>

<p>&lt;word Use file word as standard input (file
descriptor 0).</p>

<p>&gt;word Use file word as standard output (file
descriptor 1). If the file does not exist then it is
created. If the file exists, and the noclobber option is on,
this causes an error; otherwise, it is truncated to zero
length.</p>

<p>&gt;|word Sames as &gt;, except that it overrides the
noclobber option.</p>

<p>&gt;;word Write output to a temporary file. If the
command com- pletes successfully rename it to word,
otherwise, delete the temporary file. &gt;;word cannot be
used with the exec(2). built-in.</p>

<p>&gt;&gt;word Use file word as standard output. If the
file exists, then output is appended to it (by first seeking
to the end-of-file); otherwise, the file is created.</p>

<p>&lt;&gt;word Open file word for reading and writing as
standard out- put.</p>

<p>&lt;&gt;;word The same as &lt;&gt;word except that if
the command completes successfully, word is truncated to the
offset at command completion. &lt;&gt;;word cannot be used
with the exec(2). built-in.</p>

<p>&lt;&lt;[-]word The shell input is read up to a line
that is the same as word after any quoting has been removed,
or to an end-of- file. No parameter substitution, command
substitution, arithmetic substitution or file name
generation is per- formed on word. The resulting document,
called a here- document, becomes the standard input. If any
character of word is quoted, then no interpretation is
placed upon the characters of the document; otherwise,
parameter expansion, command substitution, and arithmetic
substitu- tion occur, new-line is ignored, and must be used
to quote the characters $, &lsquo;. If - is appended to
&lt;&lt;, then all leading tabs are stripped from word and
from the document. If # is appended to &lt;&lt;, then
leading spaces and tabs will be stripped off the first line
of the docu- ment and up to an equivalent indentation will
be stripped from the remaining lines and from word. A tab
stop is assumed to occur at every 8 columns for the purposes
of determining the indentation.</p>

<p>&lt;&lt;&lt;word A short form of here document in which
word becomes the contents of the here-document after any
parameter expan- sion, command substitution, and arithmetic
substitution occur.</p>

<p>&lt;&amp;digit The standard input is duplicated from
file descriptor digit (see dup(2)). Similarly for the
standard output using &gt;&amp;digit.</p>

<p>&lt;&amp;digit- The file descriptor given by digit is
moved to standard input. Similarly for the standard output
using &gt;&amp;digit-.</p>

<p>&lt;&amp;- The standard input is closed. Similarly for
the standard output using &gt;&amp;-.</p>

<p>&lt;&amp;p The input from the co-process is moved to
standard input.</p>

<p>&gt;&amp;p The output to the co-process is moved to
standard output.</p>

<p>&lt;#((expr)) Evaluate arithmetic expression expr and
position file descriptor 0 to the resulting value bytes from
the start of the file. The variables CUR and EOF evaluate to
the current offset and end-of-file offset respectively when
evaluating expr.</p>

<p>&gt;#((offset)) The same as &lt;# except applies to file
descriptor 1.</p>

<p>&lt;#pattern Seeks forward to the beginning of the next
line contain- ing pattern.</p>

<p>&lt;##pattern The same as &lt;# except that the portion
of the file that is skipped is copied to standard
output.</p>

<p>If one of the above is preceded by a digit, with no
intervening space, then the file descriptor number referred
to is that specified by the digit (instead of the default 0
or 1). If one of the above, other than &gt;&amp;- and the
&gt;# and &lt;# forms, is preceded by {varname} with no
intervening space, then a file descriptor number &gt; 10
will be selected by the shell and stored in the variable
varname. If &gt;&amp;- or the any of the &gt;# and &lt;#
forms is preceded by {varname} the value of varname defines
the file descriptor to close or position. For example:</p>

<p>... 2&gt;&amp;1</p>

<p>means file descriptor 2 is to be opened for writing as a
duplicate of file descriptor 1 and</p>

<p>exec {n}&lt;file</p>

<p>means open file named file for reading and store the
file descriptor number in variable n.</p>

<p>The order in which redirections are specified is
significant. The shell evaluates each redirection in terms
of the (file descriptor, file) association at the time of
evaluation. For example:</p>

<p>... 1&gt;fname 2&gt;&amp;1</p>

<p>first associates file descriptor 1 with file fname. It
then associates file descriptor 2 with the file associated
with file descriptor 1 (i.e. fname). If the order of
redirections were reversed, file descriptor 2 would be
associated with the terminal (assuming file descriptor 1 had
been) and then file descriptor 1 would be associated with
file fname.</p>

<p>If a command is followed by &amp; and job control is not
active, then the default standard input for the command is
the empty file /dev/null. Otherwise, the environment for the
execution of a command contains the file descriptors of the
invoking shell as modified by input/output
specifications.</p>

<p>Environment. The environment (see environ(7)) is a list
of name-value pairs that is passed to an executed program in
the same way as a normal argument list. The names must be
identifiers and the values are character strings. The shell
interacts with the environment in several ways. On
invocation, the shell scans the environment and creates a
variable for each name found, giving it the corresponding
value and attributes and marking it export. Executed
commands inherit the environment. If the user modifies the
values of these variables or creates new ones, using the
export or typeset -x commands, they become part of the
environment. The environment seen by any executed command is
thus composed of any name-value pairs originally inherited
by the shell, whose values may be modified by the current
shell, plus any additions which must be noted in export or
typeset -x commands.</p>

<p>The environment for any simple-command or function may
be augmented by prefixing it with one or more variable
assignments. A variable assign- ment argument is a word of
the form identifier=value. Thus:</p>

<p>TERM=450 cmd args and (export TERM; TERM=450; cmd
args)</p>

<p>are equivalent (as far as the above execution of cmd is
concerned except for special built-in commands listed below
- those that are pre- ceded with a dagger).</p>

<p>If the obsolete -k option is set, all variable
assignment arguments are placed in the environment, even if
they occur after the command name. The following first
prints a=b c and then c:</p>

<p>echo a=b c set -k echo a=b c This feature is intended
for use with scripts written for early ver- sions of the
shell and its use in new scripts is strongly discouraged. It
is likely to disappear someday.</p>

<p>Functions. For historical reasons, there are two ways to
define functions, the name() syntax and the function name
syntax, described in the Commands section above. Shell
functions are read in and stored internally. Alias names are
resolved when the function is read. Functions are exe- cuted
like commands with the arguments passed as positional
parameters. (See Execution below.)</p>

<p>Functions defined by the function name syntax and called
by name exe- cute in the same process as the caller and
share all files and present working directory with the
caller. Traps caught by the caller are reset to their
default action inside the function. A trap condition that is
not caught or ignored by the function causes the function to
terminate and the condition to be passed on to the caller. A
trap on EXIT set inside a function is executed in the
environment of the caller after the function completes.
Ordinarily, variables are shared between the calling program
and the function. However, the typeset special built-in
command used within a function defines local variables whose
scope includes the current function. They can be passed to
functions that they call in the variable assignment list
that precedes the call or as arguments passed as name
references. Errors within functions return control to the
caller.</p>

<p>Functions defined with the name() syntax and functions
defined with the function name syntax that are invoked with
the . special built-in are executed in the caller s
environment and share all variables and traps with the
caller. Errors within these function executions cause the
script that contains them to abort.</p>

<p>The special built-in command return is used to return
from function calls.</p>

<p>Function names can be listed with the -f or +f option of
the typeset special built-in command. The text of functions,
when available, will also be listed with -f. Functions can
be undefined with the -f option of the unset special
built-in command.</p>

<p>Ordinarily, functions are unset when the shell executes
a shell script. Functions that need to be defined across
separate invocations of the shell should be placed in a
directory and the FPATH variable should contain the name of
this directory. They may also be specified in the ENV
file.</p>

<p>Discipline Functions. Each variable can have zero or
more discipline functions associated with it. The shell
initially understands the discipline names get, set, append,
and unset but can be added when defining new types. On most
systems others can be added at run time via the C
programming interface extension provided by the builtin
built-in utility. If the get discipline is defined for a
variable, it is invoked whenever the given variable is
referenced. If the variable .sh.value is assigned a value
inside the discipline function, the referenced variable will
evaluate to this value instead. If the set discipline is
defined for a variable, it is invoked whenever the given
variable is assigned a value. If the append discipline is
defined for a variable, it is invoked whenever a value is
appended to the given variable. The vari- able .sh.value is
given the value of the variable before invoking the
discipline, and the variable will be assigned the value of
.sh.value after the discipline completes. If .sh.value is
unset inside the dis- cipline, then that value is unchanged.
If the unset discipline is defined for a variable, it is
invoked whenever the given variable is unset. The variable
will not be unset unless it is unset explicitly from within
this discipline function.</p>

<p>The variable .sh.name contains the name of the variable
for which the discipline function is called, .sh.subscript
is the subscript of the variable, and .sh.value will contain
the value being assigned inside the set discipline function.
The variable _ is a reference to the variable including the
subscript if any. For the set discipline, changing .sh.value
will change the value that gets assigned. Finally, the
expansion ${var.name}, when name is the name of a
discipline, and there is no variable of this name, is
equivalent to the command substi- tution ${ var.name;}.</p>

<p>Type Variables. Typed variables provide a way to create
data structure and objects. A type can be defined either by
a shared library, by the enum built-in command described
below, or by using the new -T option of the typeset built-in
command. With the -T option of typeset, the type name,
speci- fied as an option argument to -T, is set with a
compound variable assignment that defines the type. Function
definitions can appear inside the compound variable
assignment and these become discipline functions for this
type and can be invoked or redefined by each instance of the
type. The function name create is treated specially. It is
invoked for each instance of the type that is created but is
not inherited and cannot be redefined for each instance.</p>

<p>When a type is defined a special built-in command of
that name is added. These built-ins are declaration commands
and follow the same expansion rules as all the special
built-in commands defined below that are preceded by . These
commands can subsequently be used inside further type
definitions. The man page for these commands can be gen-
erated by using the --man option or any of the other --
options described with getopts. The -r, -a, -A, -h, and -S
options of typeset are permitted with each of these new
built-ins.</p>

<p>An instance of a type is created by invoking the type
name followed by one or more instance names. Each instance
of the type is initialized with a copy of the sub-variables
except for sub-variables that are defined with the -S
option. Variables defined with the -S are shared by all
instances of the type. Each instance can change the value of
any sub-variable and can also define new discipline
functions of the same names as those defined by the type
definition as well as any stan- dard discipline names. No
additional sub-variables can be defined for any
instance.</p>

<p>When defining a type, if the value of a sub-variable is
not set and the -r attribute is specified, it causes the
sub-variable to be a required sub-variable. Whenever an
instance of a type is created, all required sub-variables
must be specified. These sub-variables become readonly in
each instance.</p>

<p>When unset is invoked on a sub-variable within a type,
and the -r attribute has not been specified for this field,
the value is reset to the default value associative with the
type. Invoking unset on a type instance not contained within
another type deletes all sub-variables and the variable
itself.</p>

<p>A type definition can be derived from another type
definition by defin- ing the first sub-variable name as _
and defining its type as the base type. Any remaining
definitions will be additions and modifications that apply
to the new type. If the new type name is the same is that of
the base type, the type will be replaced and the original
type will no longer be accessible.</p>

<p>Jobs. If the monitor option of the set command is turned
on, an interactive shell associates a job with each
pipeline. It keeps a table of current jobs, printed by the
jobs command, and assigns them small integer num- bers. When
a job is started asynchronously with &amp;, the shell prints
a line which looks like:</p>

<p>[1] 1234</p>

<p>indicating that the job which was started asynchronously
was job number 1 and had one (top-level) process, whose
process id was 1234.</p>

<p>This paragraph and the next require features that are
not in all ver- sions of UNIX and may not apply. If you are
running a job and wish to do something else you may hit the
key ^Z (control-Z) which sends a STOP signal to the current
job. The shell will then normally indicate that the job has
been Stopped, and print another prompt. You can then
manipulate the state of this job, putting it in the
background with the bg command, or run some other commands
and then eventually bring the job back into the foreground
with the foreground command fg. A ^Z takes effect
immediately and is like an interrupt in that pending out-
put and unread input are discarded when it is typed.</p>

<p>A job being run in the background will stop if it tries
to read from the terminal. Background jobs are normally
allowed to produce output, but this can be disabled by
giving the command stty tostop. If you set this tty option,
then background jobs will stop when they try to pro- duce
output like they do when they try to read input.</p>

<p>There are several ways to refer to jobs in the shell. A
job can be referred to by the process id of any process of
the job or by one of the following: %number The job with the
given number. %string Any job whose command line begins with
string. %?string Any job whose command line contains string.
%% Current job. %+ Equivalent to %%. %- Previous job.</p>

<p>The shell learns immediately whenever a process changes
state. It nor- mally informs you whenever a job becomes
blocked so that no further progress is possible, but only
just before it prints a prompt. This is done so that it does
not otherwise disturb your work. The notify option of the
set command causes the shell to print these job change
messages as soon as they occur.</p>

<p>When the monitor option is on, each background job that
completes trig- gers any trap set for CHLD.</p>

<p>When you try to leave the shell while jobs are running
or stopped, you will be warned that You have
stopped(running) jobs. You may use the jobs command to see
what they are. If you immediately try to exit again, the
shell will not warn you a second time, and the stopped jobs
will be terminated. When a login shell receives a HUP
signal, it sends a HUP signal to each job that has not been
disowned with the disown built-in command described
below.</p>

<p>Signals. The INT and QUIT signals for an invoked command
are ignored if the com- mand is followed by &amp; and the
monitor option is not active. Otherwise, signals have the
values inherited by the shell from its parent (but see also
the trap built-in command below).</p>

<p>Execution. Each time a command is read, the above
substitutions are carried out. If the command name matches
one of the Special Built-in Commands listed below, it is
executed within the current shell process. Next, the com-
mand name is checked to see if it matches a user defined
function. If it does, the positional parameters are saved
and then reset to the arguments of the function call. A
function is also executed in the current shell process. When
the function completes or issues a return, the positional
parameter list is restored. For functions defined with the
function name syntax, any trap set on EXIT within the
function is executed. The exit value of a function is the
value of the last com- mand executed. If a command name is
not a special built-in command or a user defined function,
but it is one of the built-in commands listed below, it is
executed in the current shell process.</p>

<p>The shell variable PATH defines the search path for the
directory con- taining the command. Alternative directory
names are separated by a colon (:). The default path is
equal to getconf PATH output. The cur- rent directory can be
specified by two or more adjacent colons, or by a colon at
the beginning or end of the path list. If the command name
contains a /, then the search path is not used. Otherwise,
each direc- tory in the path is searched for an executable
file of the given name that is not a directory. If found,
and if the shell determines that there is a built-in version
of a command corresponding to a given path- name, this
built-in is invoked in the current process. If found, and
this directory is also contained in the value of the FPATH
variable, then this file is loaded into the current shell
environment as if it were the argument to the . command
except that only preset aliases are expanded, and a function
of the given name is executed as described above. If not
found, and the file .paths is found, and this file con-
tains a line of the form FPATH=path where path names an
existing direc- tory, and this directory contains a file of
the given name, then this file is loaded into the current
shell environment as if it were the argument to the .
special built-in command and a function of the given name is
executed. Otherwise, if found, a process is created and an
attempt is made to execute the command via exec(2).</p>

<p>When an executable is found, the directory where it is
found in is searched for a file named .paths. If this file
is found and it con- tains a line of the form
BUILTIN_LIB=value , then the library named by value will be
searched for as if it were an option argument to builtin -f,
and if it contains a built-in of the specified name this
will be executed instead of a command by this name.
Otherwise, if this file is found and it contains a line of
the form name=value in the first or second line, then the
environment variable name is modified by prepend- ing the
directory specified by value to the directory list. If value
is not an absolute directory, then it specifies a directory
relative to the directory that the executable was found. If
the environment vari- able name does not already exist it
will be added to the environment list for the specified
command.</p>

<p>If the file has execute permission but is not an a.out
file, it is assumed to be a file containing shell commands.
A separate shell is spawned to read it. All non-exported
variables are removed in this case. If the shell command
file doesn t have read permission, or if the setuid and/or
setgid bits are set on the file, then the shell exe- cutes
an agent whose job it is to set up the permissions and
execute the shell with the shell command file passed down as
an open file. A parenthesized command is executed in a
sub-shell without removing non- exported variables.</p>

<p>Command Re-entry. The text of the last HISTSIZE (default
512) commands entered from a terminal device is saved in a
history file. The file $HOME/.sh_history is used if the
HISTFILE variable is not set or if the file it names is not
writable. A shell can access the commands of all interactive
shells which use the same named HISTFILE. The built-in
command hist is used to list or edit a portion of this file.
The portion of the file to be edited or listed can be
selected by number or by giving the first character or
characters of the command. A single command or range of
commands can be specified. If you do not specify an editor
program as an argument to hist then the value of the
variable HISTEDIT is used. If HISTEDIT is unset, the
obsolete variable FCEDIT is used. If FCEDIT is not defined,
then /bin/ed is used. The edited command(s) is printed and
re-executed upon leaving the editor unless you quit without
writ- ing. The -s option (and in obsolete versions, the
editor name -) is used to skip the editing phase and to
re-execute the command. In this case a substitution
parameter of the form old=new can be used to modify the
command before execution. For example, with the preset alias
r, which is aliased tohist -, typing r bad=good c will
re-execute the most recent command which starts with the
letter c, replacing the first occurrence of the string bad
with the string good.</p>

<p>In-line Editing Options. Normally, each command line
entered from a terminal device is simply typed followed by a
new-line (RETURN or LINE FEED). If either the emacs, gmacs,
or vi option is active, the user can edit the command line.
To be in either of these edit modes set the corresponding
option. An editing option is automatically selected each
time the VISUAL or EDITOR variable is assigned a value
ending in either of these option names.</p>

<p>The editing features require that the user s terminal
accept RETURN as carriage return without line feed and that
a space ( ) must over- write the current character on the
screen.</p>

<p>Unless the multiline option is on, the editing modes
implement a con- cept where the user is looking through a
window at the current line. The window width is the value of
COLUMNS if it is defined, otherwise 80. If the window width
is too small to display the prompt and leave at least 8
columns to enter input, the prompt is truncated from the
left. If the line is longer than the window width minus two,
a mark is displayed at the end of the window to notify the
user. As the cursor moves and reaches the window boundaries
the window will be centered about the cursor. The mark is a
&gt; (&lt;, *) if the line extends on the right (left, both)
side(s) of the window.</p>

<p>The search commands in each edit mode provide access to
the history file. Only strings are matched, not patterns,
although a leading ^ in the string restricts the match to
begin at the first character in the line.</p>

<p>Each of the edit modes has an operation to list the
files or commands that match a partially entered word. When
applied to the first word on the line, or the first word
after a ;,, &amp;, or (, and the word does not begin with or
contain a /, the list of aliases, functions, and executable
commands defined by the PATH variable that could match the
partial word is displayed. Otherwise, the list of files that
match the given word is displayed. If the partially entered
word does not con- tain any file expansion characters, a *
is appended before generating these lists. After displaying
the generated list, the input line is redrawn. These
operations are called command name listing and file name
listing, respectively. There are additional operations,
referred to as command name completion and file name
completion, which compute the list of matching commands or
files, but instead of printing the list, replace the current
word with a complete or partial match. For file name
completion, if the match is unique, a / is appended if the
file is a directory and a space is appended if the file is
not a direc- tory. Otherwise, the longest common prefix for
all the matching files replaces the word. For command name
completion, only the portion of the file names after the
last / are used to find the longest command prefix. If only
a single name matches this prefix, then the word is replaced
with the command name followed by a space. When using a tab
for completion that does not yield a unique match, a
subsequent tab will provide a numbered list of matching
alternatives. A specific selection can be made by entering
the selection number followed by a tab.</p>

<p>Key Bindings. The KEYBD trap can be used to intercept
keys as they are typed and change the characters that are
actually seen by the shell. This trap is executed after each
character (or sequence of characters when the first
character is ESC) is entered while reading from a terminal.
The variable .sh.edchar contains the character or character
sequence which generated the trap. Changing the value of
.sh.edchar in the trap action causes the shell to behave as
if the new value were entered from the keyboard rather than
the original value.</p>

<p>The variable .sh.edcol is set to the input column number
of the cursor at the time of the input. The variable
.sh.edmode is set to ESC when in vi insert mode (see below)
and is null otherwise. By prepending ${.sh.editmode} to a
value assigned to .sh.edchar it will cause the shell to
change to control mode if it is not already in this
mode.</p>

<p>This trap is not invoked for characters entered as
arguments to editing directives, or while reading input for
a character search.</p>

<p>Emacs Editing Mode. This mode is entered by enabling
either the emacs or gmacs option. The only difference
between these two modes is the way they handle ^T. To edit,
the user moves the cursor to the point needing correction
and then inserts or deletes characters or words as needed.
All the editing commands are control characters or escape
sequences. The notation for control characters is caret (^)
followed by the character. For exam- ple, ^F is the notation
for control F. This is entered by depressing f while holding
down the CTRL (control) key. The SHIFT key is not depressed.
(The notation ^? indicates the DEL (delete) key.)</p>

<p>The notation for escape sequences is M- followed by a
character. For example, M-f (pronounced Meta f) is entered
by depressing ESC (ascii 033) followed by f. (M-F would be
the notation for ESC followed by SHIFT (capital) F.)</p>

<p>All edit commands operate from any place on the line
(not just at the beginning). Neither the RETURN nor the LINE
FEED key is entered after edit commands except when
noted.</p>

<p>^F Move cursor forward (right) one character. M-[C Move
cursor forward (right) one character. M-f Move cursor
forward one word. (The emacs editors idea of a word is a
string of characters consisting of only letters, digits and
underscores.) ^B Move cursor backward (left) one character.
M-[D Move cursor backward (left) one character. M-b Move
cursor backward one word. ^A Move cursor to start of line.
M-[H Move cursor to start of line. ^E Move cursor to end of
line. M-[Y Move cursor to end of line. ^]char Move cursor
forward to character char on current line. M-^]char Move
cursor backward to character char on current line. ^X^X
Interchange the cursor and mark. erase (User defined erase
character as defined by the stty(1) com- mand, usually ^H or
#.) Delete previous character. lnext (User defined literal
next character as defined by the stty(1) command, or ^V if
not defined.) Removes the next characters editing features
(if any). ^D Delete current character. M-d Delete current
word. M-^H (Meta-backspace) Delete previous word. M-h Delete
previous word. M-^? (Meta-DEL) Delete previous word (if your
interrupt character is ^? (DEL, the default) then this
command will not work). ^T Transpose current character with
previous character and advance the cursor in emacs mode.
Transpose two previous characters in gmacs mode. ^C
Capitalize current character. M-c Capitalize current word.
M-l Change the current word to lower case. ^K Delete from
the cursor to the end of the line. If preceded by a
numerical parameter whose value is less than the current
cursor position, then delete from given position up to the
cursor. If preceded by a numerical parameter whose value is
greater than the current cursor position, then delete from
cursor up to given cursor position. ^W Kill from the cursor
to the mark. M-p Push the region from the cursor to the mark
on the stack. kill (User defined kill character as defined
by the stty command, usually ^G or @.) Kill the entire
current line. If two kill characters are entered in
succession, all kill characters from then on cause a line
feed (useful when using paper ter- minals). ^Y Restore last
item removed from line. (Yank item back to the line.) ^L
Line feed and print current line. M-^L Clear the screen. ^@
(Null character) Set mark. M-space (Meta space) Set mark. ^J
(New line) Execute the current line. ^M (Return) Execute the
current line. eof End-of-file character, normally ^D, is
processed as an End- of-file only if the current line is
null. ^P Fetch previous command. Each time ^P is entered the
previous command back in time is accessed. Moves back one
line when not on the first line of a multi-line command.
M-[A If the cursor is at the end of the line, it is
equivalent to ^R with string set to the contents of the
current line. Oth- erwise, it is equivalent to ^P. M-&lt;
Fetch the least recent (oldest) history line. M-&gt; Fetch
the most recent (youngest) history line. ^N Fetch next
command line. Each time ^N is entered the next command line
forward in time is accessed. M-[B Equivalent to ^N. ^Rstring
Reverse search history for a previous command line
containing string. If a parameter of zero is given, the
search is for- ward. String is terminated by a RETURN or NEW
LINE. If string is preceded by a ^, the matched line must
begin with string. If string is omitted, then the next
command line containing the most recent string is accessed.
In this case a parameter of zero reverses the direction of
the search. ^O Operate - Execute the current line and fetch
the next line relative to current line from the history
file. M-digits (Escape) Define numeric parameter, the digits
are taken as a parameter to the next command. The commands
that accept a parameter are ^F, ^B, erase, ^C, ^D, ^K, ^R,
^P, ^N, ^], M-., M-^], M-_, M-=, M-b, M-c, M-d, M-f, M-h,
M-l and M-^H. M-letter Soft-key - Your alias list is
searched for an alias by the name _letter and if an alias of
this name is defined, its value will be inserted on the
input queue. The letter must not be one of the above
meta-functions. M-[letter Soft-key - Your alias list is
searched for an alias by the name __letter and if an alias
of this name is defined, its value will be inserted on the
input queue. This can be used to program function keys on
many terminals. M-. The last word of the previous command is
inserted on the line. If preceded by a numeric parameter,
the value of this parameter determines which word to insert
rather than the last word. M-_ Same as M-.. M-* Attempt file
name generation on the current word. An aster- isk is
appended if the word doesn t match any file or contain any
special pattern characters. M-ESC Command or file name
completion as described above. ^I tab Attempts command or
file name completion as described above. If a partial
completion occurs, repeating this will behave as if M-= were
entered. If no match is found or entered after space, a tab
is inserted. M-= If not preceded by a numeric parameter, it
generates the list of matching commands or file names as
described above. Otherwise, the word under the cursor is
replaced by the item corresponding to the value of the
numeric parameter from the most recently generated command
or file list. If the cursor is not on a word, it is inserted
instead. ^U Multiply parameter of next command by 4. Escape
next character. Editing characters, the users erase, kill
and interrupt (normally ^?) characters may be entered in a
command line or in a search string if preceded by a . The
removes the next characters editing features (if any). M-^V
Display version of the shell. M-# If the line does not begin
with a #, a # is inserted at the beginning of the line and
after each new-line, and the line is entered. This causes a
comment to be inserted in the his- tory file. If the line
begins with a #, the # is deleted and one # after each
new-line is also deleted.</p>

<p>Vi Editing Mode. There are two typing modes. Initially,
when you enter a command you are in the input mode. To edit,
the user enters control mode by typing ESC (033) and moves
the cursor to the point needing correction and then inserts
or deletes characters or words as needed. Most control com-
mands accept an optional repeat count prior to the
command.</p>

<p>When in vi mode on most systems, canonical processing is
initially enabled and the command will be echoed again if
the speed is 1200 baud or greater and it contains any
control characters or less than one sec- ond has elapsed
since the prompt was printed. The ESC character termi- nates
canonical processing for the remainder of the command and
the user can then modify the command line. This scheme has
the advantages of canonical processing with the type-ahead
echoing of raw mode.</p>

<p>If the option viraw is also set, the terminal will
always have canoni- cal processing disabled. This mode is
implicit for systems that do not support two alternate end
of line delimiters, and may be helpful for certain
terminals.</p>

<p>Input Edit Commands By default the editor is in input
mode. erase (User defined erase character as defined by the
stty command, usually ^H or #.) Delete previous character.
^W Delete the previous blank separated word. On some systems
the viraw option may be required for this to work. eof As
the first character of the line causes the shell to
terminate unless the ignoreeof option is set. Other- wise
this character is ignored. lnext (User defined literal next
character as defined by the stty(1) or ^V if not defined.)
Removes the next char- acter s editing features (if any). On
some systems the viraw option may be required for this to
work. Escape the next erase or kill character. ^I tab
Attempts command or file name completion as described above
and returns to input mode. If a partial comple- tion occurs,
repeating this will behave as if = were entered from control
mode. If no match is found or entered after space, a tab is
inserted. Motion Edit Commands These commands will move the
cursor. [count]l Cursor forward (right) one character.
[count][C Cursor forward (right) one character. [count]w
Cursor forward one alpha-numeric word. [count]W Cursor to
the beginning of the next word that follows a blank.
[count]e Cursor to end of word. [count]E Cursor to end of
the current blank delimited word. [count]h Cursor backward
(left) one character. [count][D Cursor backward (left) one
character. [count]b Cursor backward one word. [count]B
Cursor to preceding blank separated word. [count] Cursor to
column count. [count]fc Find the next character c in the
current line. [count]Fc Find the previous character c in the
current line. [count]tc Equivalent to f followed by h.
[count]Tc Equivalent to F followed by l. [count]; Repeats
count times, the last single character find command, f, F,
t, or T. [count], Reverses the last single character find
command count times. 0 Cursor to start of line. ^ Cursor to
start of line. [H Cursor to first non-blank character in
line. $ Cursor to end of line. [Y Cursor to end of line. %
Moves to balancing (, ), {, }, [, or ]. If cursor is not on
one of the above characters, the remainder of the line is
searched for the first occurrence of one of the above
characters first. Search Edit Commands These commands access
your command history. [count]k Fetch previous command. Each
time k is entered the previous command back in time is
accessed. [count]- Equivalent to k. [count][A If cursor is
at the end of the line it is equivalent to / with string^set
to the contents of the current line. Otherwise, it is
equivalent to k. [count]j Fetch next command. Each time j is
entered the next command forward in time is accessed.
[count]+ Equivalent to j. [count][B Equivalent to j.
[count]G The command number count is fetched. The default is
the least recent history command. /string Search backward
through history for a previous command containing string.
String is terminated by a RETURN or NEW LINE. If string is
preceded by a ^, the matched line must begin with string. If
string is null, the previous string will be used. ?string
Same as / except that search will be in the forward
direction. n Search for next match of the last pattern to /
or ? commands. N Search for next match of the last pattern
to / or ?, but in reverse direction. Text Modification Edit
Commands These commands will modify the line. a Enter input
mode and enter text after the current character. A Append
text to the end of the line. Equivalent to $a.
[count]cmotion c[count]motion Delete current character
through the character that motion would move the cursor to
and enter input mode. If motion is c, the entire line will
be deleted and input mode entered. C Delete the current
character through the end of line and enter input mode.
Equivalent to c$. S Equivalent to cc. [count]s Replace
characters under the cursor in input mode. D Delete the
current character through the end of line. Equivalent to d$.
[count]dmotion d[count]motion Delete current character
through the character that motion would move to. If motion
is d , the entire line will be deleted. i Enter input mode
and insert text before the current character. I Insert text
before the beginning of the line. Equiva- lent to 0i.
[count]P Place the previous text modification before the
cur- sor. [count]p Place the previous text modification
after the cursor. R Enter input mode and replace characters
on the screen with characters you type overlay fashion.
[count]rc Replace the count character(s) starting at the
current cursor position with c, and advance the cursor.
[count]x Delete current character. [count]X Delete preceding
character. [count]. Repeat the previous text modification
command. [count] Invert the case of the count character(s)
starting at the current cursor position and advance the
cursor. [count]_ Causes the count word of the previous
command to be appended and input mode entered. The last word
is used if count is omitted. * Causes an * to be appended to
the current word and file name generation attempted. If no
match is found, it rings the bell. Otherwise, the word is
replaced by the matching pattern and input mode is entered.
Command or file name completion as described above. Other
Edit Commands Miscellaneous commands. [count]ymotion
y[count]motion Yank current character through character that
motion would move the cursor to and puts them into the
delete buffer. The text and cursor are unchanged. yy Yanks
the entire line. Y Yanks from current position to end of
line. Equiva- lent to y$. u Undo the last text modifying
command. U Undo all the text modifying commands performed on
the line. [count]v Returns the command hist -e
${VISUAL:-${EDITOR:-vi}} count in the input buffer. If count
is omitted, then the current line is used. ^L Line feed and
print current line. Has effect only in control mode. ^J (New
line) Execute the current line, regardless of mode. ^M
(Return) Execute the current line, regardless of mode. # If
the first character of the command is a #, then this command
deletes this # and each # that follows a newline. Otherwise,
sends the line after inserting a # in front of each line in
the command. Useful for causing the current line to be
inserted in the history as a comment and uncommenting
previously commented commands in the history file. [count]=
If count is not specified, it generates the list of matching
commands or file names as described above. Otherwise, the
word under the the cursor is replaced by the count item from
the most recently generated command or file list. If the
cursor is not on a word, it is inserted instead. @letter
Your alias list is searched for an alias by the name _letter
and if an alias of this name is defined, its value will be
inserted on the input queue for process- ing. ^V Display
version of the shell.</p>

<p>Built-in Commands. The following simple-commands are
executed in the shell process. Input/Output redirection is
permitted. Unless otherwise indicated, the output is written
on file descriptor 1 and the exit status, when there is no
syntax error, is zero. Except for :, true, false, echo,
newgrp, and login, all built-in commands accept -- to
indicate end of options. They also interpret the option
--man as a request to display the man page onto standard
error and -? as a help request which prints a usage message
on standard error. Commands that are preceded by one or two
symbols are special built-in commands and are treated
specially in the following ways: 1. Variable assignment
lists preceding the command remain in effect when the
command completes. 2. I/O redirections are processed after
variable assignments. 3. Errors cause a script that contains
them to abort. 4. They are not valid function names. 5.
Words following a command preceded by that are in the format
of a variable assignment are expanded with the same rules as
a variable assignment. This means that tilde substitution is
per- formed after the = sign and field splitting and file
name gener- ation are not performed. These are called
declaration built- ins.</p>

<p>: [ arg ... ] The command only expands parameters.</p>

<p>. name [ arg ... ] If name is a function defined with
the function name reserved word syntax, the function is
executed in the current environment (as if it had been
defined with the name() syntax.) Otherwise if name refers to
a file, the file is read in its entirety and the commands
are executed in the current shell environment. The search
path specified by PATH is used to find the directory con-
taining the file. If any arguments arg are given, they
become the positional parameters while processing the .
command and the original positional parameters are restored
upon completion. Otherwise the positional parameters are
unchanged. The exit status is the exit status of the last
command executed.</p>

<p>alias [ -ptx ] [ name[ =value ] ] ... alias with no
arguments prints the list of aliases in the form name=value
on standard output. The -p option causes the word alias to
be inserted before each one. When one or more argu- ments
are given, an alias is defined for each name whose value is
given. A trailing space in value causes the next word to be
checked for alias substitution. The obsolete -t option is
used to set and list tracked aliases. The value of a tracked
alias is the full pathname corresponding to the given name.
The value becomes undefined when the value of PATH is reset
but the alias remains tracked. Without the -t option, for
each name in the argument list for which no value is given,
the name and value of the alias is printed. The obsolete -x
option has no effect. The exit status is non-zero if a name
is given, but no value, and no alias has been defined for
the name.</p>

<p>bg [ job... ] This command is only on systems that
support job control. Puts each specified job into the
background. The current job is put in the background if job
is not specified. See Jobs for a description of the format
of job.</p>

<p>break [ n ] Exit from the enclosing for, while, until,
or select loop, if any. If n is specified, then break n
levels.</p>

<p>builtin [ -ds ] [ -f file ] [ name ... ] If name is not
specified, and no -f option is specified, the built-ins are
printed on standard output. The -s option prints only the
special built-ins. Otherwise, each name represents the
pathname whose basename is the name of the built-in. The
entry point function name is determined by prepending b_ to
the built- in name. The ISO C/C++ prototype is
b_mycommand(int argc, char *argv[], void *context) for the
builtin command mycommand where argv is array an of argc
elements and context is an optional pointer to a Shell_t
structure as described in &lt;ast/shell.h&gt;. Special
built-ins cannot be bound to a pathname or deleted. The -d
option deletes each of the given built-ins. On systems that
support dynamic loading, the -f option names a shared
library containing the code for built-ins. The shared
library prefix and/or suffix, which depend on the system,
can be omitted. Once a library is loaded, its symbols become
available for subsequent invocations of builtin. Multiple
libraries can be specified with separate invocations of the
builtin command. Libraries are searched in the reverse order
in which they are specified. When a library is loaded, it
looks for a function in the library whose name is lib_init()
and invokes this function with an argu- ment of 0.</p>

<p>cd [ -LP ] [ arg ] cd [ -LP ] old new This command can
be in either of two forms. In the first form it changes the
current directory to arg. If arg is - the direc- tory is
changed to the previous directory. The shell variable HOME
is the default arg. The variable PWD is set to the current
directory. The shell variable CDPATH defines the search path
for the directory containing arg. Alternative directory
names are separated by a colon (:). The default path is
&lt;null&gt; (spec- ifying the current directory). Note that
the current directory is specified by a null path name,
which can appear immediately after the equal sign or between
the colon delimiters anywhere else in the path list. If arg
begins with a / then the search path is not used. Otherwise,
each directory in the path is searched for arg. The second
form of cd substitutes the string new for the string old in
the current directory name, PWD, and tries to change to this
new directory. By default, symbolic link names are treated
literally when find- ing the directory name. This is
equivalent to the -L option. The -P option causes symbolic
links to be resolved when deter- mining the directory. The
last instance of -L or -P on the com- mand line determines
which method is used. The cd command may not be executed by
rksh. rksh93.</p>

<p>command [ -pvxV ] name [ arg ... ] Without the -v or -V
options, command executes name with the arguments given by
arg. The -p option causes a default path to be searched
rather than the one defined by the value of PATH. Functions
will not be searched for when finding name. In addi- tion,
if name refers to a special built-in, none of the special
properties associated with the leading daggers will be
honored. (For example, the predefined alias redirectcommand
execpre- vents a script from terminating when an invalid
redirection is given.) With the -x option, if command
execution would result in a failure because there are too
many arguments, errno E2BIG, the shell will invoke command
name multiple times with a subset of the arguments on each
invocation. Arguments that occur prior to the first word
that expands to multiple arguments and after the last word
that expands to multiple arguments will be passed on each
invocation. The exit status will be the maximum invoca- tion
exit status. With the -v option, command is equivalent to
the built-in whence command described below. The -V option
causes command to act like whence -v.</p>

<p>continue [ n ] Resume the next iteration of the
enclosing for, while, until, or select loop. If n is
specified, then resume at the n-th enclos- ing loop.</p>

<p>disown [ job... ] Causes the shell not to send a HUP
signal to each given job, or all active jobs if job is
omitted, when a login shell termi- nates.</p>

<p>echo [ arg ... ] When the first arg does not begin with
a -, and none of the arguments contain a then echo prints
each of its arguments separated by a space and terminated by
a new-line. Otherwise, the behavior of echo is system
dependent and print or printf described below should be
used. See echo(1) for usage and description.</p>

<p>enum [ -i ] type[=(value ...) ] Creates a declaration
command named type that is an integer type that allows one
of the specified values as enumeration names. If =(value
...) is omitted, then type must be an indexed array variable
with at least two elements and the values are taken from
this array variable. If -i is specified the values are case
insensitive.</p>

<p>eval [ arg ... ] The arguments are read as input to the
shell and the resulting command(s) executed.</p>

<p>exec [ -c ] [ -a name ] [ arg ... ] If arg is given, the
command specified by the arguments is exe- cuted in place of
this shell without creating a new process. The -c option
causes the environment to be cleared before apply- ing
variable assignments associated with the exec invocation.
The -a option causes name rather than the first arg, to
become argv[0] for the new process. Input/output arguments
may appear and affect the current process. If arg is not
given, the effect of this command is to modify file
descriptors as prescribed by the input/output redirection
list. In this case, any file descriptor numbers greater than
2 that are opened with this mechanism are closed when
invoking another program.</p>

<p>exit [ n ] Causes the shell to exit with the exit status
specified by n. The value will be the least significant 8
bits of the specified status. If n is omitted, then the exit
status is that of the last command executed. An end-of-file
will also cause the shell to exit except for a shell which
has the ignoreeof option (see set below) turned on.</p>

<p>export [ -p ] [ name[=value] ] ... If name is not given,
the names and values of each variable with the export
attribute are printed with the values quoted in a manner
that allows them to be re-input. The -p option causes the
word export to be inserted before each one. Otherwise, the
given names are marked for automatic export to the
environment of subsequently-executed commands.</p>

<p>false Does nothing, and exits 1. Used with until for
infinite loops.</p>

<p>fg [ job... ] This command is only on systems that
support job control. Each job specified is brought to the
foreground and waited for in the specified order. Otherwise,
the current job is brought into the foreground. See Jobs for
a description of the format of job.</p>

<p>getconf [ name [ pathname ] ] Prints the current value
of the configuration parameter given by name. The
configuration parameters are defined by the IEEE POSIX
1003.1 and IEEE POSIX 1003.2 standards. (See pathconf(2) and
sysconf(2).) The pathname argument is required for parame-
ters whose value depends on the location in the file system.
If no arguments are given, getconf prints the names and
values of the current configuration parameters. The pathname
/ is used for each of the parameters that requires
pathname.</p>

<p>getopts [ -a name ] optstring vname [ arg ... ] Checks
arg for legal options. If arg is omitted, the positional
parameters are used. An option argument begins with a + or a
-. An option not beginning with + or - or the argument --
ends the options. Options beginning with + are only
recognized when opt- string begins with a +. optstring
contains the letters that getopts recognizes. If a letter is
followed by a :, that option is expected to have an
argument. The options can be separated from the argument by
blanks. The option -? causes getopts to generate a usage
message on standard error. The -a argument can be used to
specify the name to use for the usage message, which
defaults to $0. getopts places the next option letter it
finds inside variable vname each time it is invoked. The
option letter will be prepended with a + when arg begins
with a +. The index of the next arg is stored in OPTIND. The
option argument, if any, gets stored in OPTARG. A leading :
in optstring causes getopts to store the letter of an
invalid option in OPTARG, and to set vname to ? for an
unknown option and to : when a required option argument is
miss- ing. Otherwise, getopts prints an error message. The
exit sta- tus is non-zero when there are no more options.
There is no way to specify any of the options :, +, -, ?, [,
and ]. The option # can only be specified as the first
option.</p>

<p>hist [ -e ename ] [ -nlr ] [ first [ last ] ] hist -s [
old=new ] [ command ] In the first form, a range of commands
from first to last is selected from the last HISTSIZE
commands that were typed at the terminal. The arguments
first and last may be specified as a number or as a string.
A string is used to locate the most recent command starting
with the given string. A negative num- ber is used as an
offset to the current command number. If the -l option is
selected, the commands are listed on standard out- put.
Otherwise, the editor program ename is invoked on a file
containing these keyboard commands. If ename is not
supplied, then the value of the variable HISTEDIT is used.
If HISTEDIT is not set, then FCEDIT (default /bin/ed) is
used as the editor. When editing is complete, the edited
command(s) is executed if the changes have been saved. If
last is not specified, then it will be set to first. If
first is not specified, the default is the previous command
for editing and -16 for listing. The option -r reverses the
order of the commands and the option -n suppresses command
numbers when listing. In the second form, command is
interpreted as first described above and defaults to the
last command executed. The resulting command is executed
after the optional substitution old=new is performed.</p>

<p>jobs [ -lnp ] [ job ... ] Lists information about each
given job; or all active jobs if job is omitted. The -l
option lists process ids in addition to the normal
information. The -n option only displays jobs that have
stopped or exited since last notified. The -p option causes
only the process group to be listed. See Jobs for a
description of the format of job.</p>

<p>kill [ -s signame ] job ... kill [ -n signum ] job ...
kill -l [ sig ... ] Sends either the TERM (terminate) signal
or the specified signal to the specified jobs or processes.
Signals are either given by number with the -n option or by
name with the -s option (as given in &lt;signal.h&gt;,
stripped of the prefix SIG with the exception that SIGCLD is
named CHLD). For backward compatibil- ity, the n and s can
be omitted and the number or name placed immediately after
the -. If the signal being sent is TERM (ter- minate) or HUP
(hangup), then the job or process will be sent a CONT
(continue) signal if it is stopped. The argument job can be
the process id of a process that is not a member of one of
the active jobs. See Jobs for a description of the format of
job. In the third form, kill -l, if sig is not specified,
the signal names are listed. Otherwise, for each sig that is
a name, the corresponding signal number is listed. For each
sig that is a number, the signal name corresponding to the
least significant 8 bits of sig is listed.</p>

<p>let arg ... Each arg is a separate arithmetic expression
to be evaluated. See Arithmetic Evaluation above, for a
description of arithmetic expression evaluation. The exit
status is 0 if the value of the last expression is non-
zero, and 1 otherwise.</p>

<p>newgrp [ arg ... ] Equivalent to exec /bin/newgrp arg
....</p>

<p>print [ -CRenprsv ] [ -u unit] [ -f format ] [ arg ... ]
With no options or with option - or --, each arg is printed
on standard output. The -f option causes the arguments to be
printed as described by printf. In this case, any e, n, r, R
options are ignored. Otherwise, unless the -C, -R, -r, or -v
are specified, the following escape conventions will be
applied: a The alert character (ascii 07). b T h e b a c k s
p a c e c h010). a r a c t e r ( a s c i i 0 not adding a
new-line. f The formfeed character (ascii 014). n The
new-line character (ascii 012).r The carriage return
character (ascii 015). t The tab character (ascii 011). The
vertical tab character (ascii 013). E The escape character
(ascii 033). \ The backslash character . 0x The character
defined by the 1, 2, or 3-digit octal string given by x.</p>

<p>The -R option will print all subsequent arguments and
options other than -n. The -e causes the above escape
conventions to be applied. This is the default behavior. It
reverses the effect of an earlier -r. The -p option causes
the arguments to be written onto the pipe of the process
spawned with&amp; instead of standard output. The -v option
treats each arg as a variable name and writes the value in
the printf %B format. The -C option treats each arg as a
variable name and writes the value in the printf %#B format.
The -s option causes the arguments to be written onto the
history file instead of standard output. The -u option can
be used to specify a one digit file descriptor unit number
unit on which the output will be placed. The default is 1.
If the option -n is used, no new-line is added to the
output.</p>

<p>printf format [ arg ... ] The arguments arg are printed
on standard output in accordance with the ANSI-C formatting
rules associated with the format string format. If the
number of arguments exceeds the number of format
specifications, the format string is reused to format
remaining arguments. The following extensions can also be
used: %b A %b format can be used instead of %s to cause
escape sequences in the corresponding arg to be expanded as
described in print. %B A %B option causes each of the
arguments to be treated as variable names and the binary
value of variable will be printed. The alternate flag #
causes a compound variable to be output on a single line.
This is most useful for compound variables and variables
whose attribute is -b. %H A %H format can be used instead of
%s to cause characters in arg that are special in HTML and
XML to be output as their entity name. %P A %P format can be
used instead of %s to cause arg to be interpreted as an
extended regular expression and be printed as a shell
pattern. %R A %R format can be used instead of %s to cause
arg to be interpreted as a shell pattern and to be printed
as an extended regular expression. %q A %q format can be
used instead of %s to cause the resulting string to be
quoted in a manner than can be reinput to the shell.
%(date-format)T A %(date-format)T format can be use to treat
an argument as a date/time string and to format the
date/time accord- ing to the date-format as defined for the
date(1) com- mand. %Z A %Z format will output a byte whose
value is 0. %d The precision field of the %d format can be
followed by a . and the output base. In this case, the #
flag charac- ter causes base# to be prepended. # The # flag
when used with the d specifier without an out- put base,
causes the output to be displayed in thousands units with
one of the suffixes k M G T P E to indicate the unit. The #
flag when used with the i specifier causes the output to be
displayed in 1024 with one of the suffixes Ki Mi Gi Ti Pi Ei
to indicate the unit. = The = flag has been added to center
the output within the specified field width.</p>

<p>pwd [ -LP ] Outputs the value of the current working
directory. The -L option is the default; it prints the
logical name of the current directory. If the -P option is
given, all symbolic links are resolved from the name. The
last instance of -L or -P on the command line determines
which method is used.</p>

<p>read [ -ACprsv ] [ -d delim] [ -n n] [ [ -N n] [ [ -t
timeout] [ -u unit] [ vname?prompt ] [ vname ... ] The shell
input mechanism. One line is read and is broken up into
fields using the characters in IFS as separators. The escape
character, is used to remove any special meaning for the
next character and for line continuation. The -d option
causes the read to continue to the first character of delim
rather than new-line. The -n option causes at most n bytes
to read rather a full line but will return when reading from
a slow device as soon as any characters have been read. The
-N option causes exactly n to be read unless an end-of-file
has been encountered or the read times out because of the -t
option. In raw mode, -r, the character is not treated
specially. The first field is assigned to the first vname,
the second field to the second vname, etc., with leftover
fields assigned to the last vname. When vname has the binary
attribute and -n or -N is specified, the bytes that are read
are stored directly into the variable. If the -v is
specified, then the value of the first vname will be used as
a default value when reading from a termi- nal device. The
-A option causes the variable vname to be unset and each
field that is read to be stored in successive elements of
the indexed array vname. The -C option causes the variable
vname to be read as a compound variable. Blanks will be
ignored when finding the beginning open parenthesis. The -p
option causes the input line to be taken from the input pipe
of a pro- cess spawned by the shell using &amp;. If the -s
option is present, the input will be saved as a command in
the history file. The option -u can be used to specify a one
digit file descriptor unit unit to read from. The file
descriptor can be opened with the exec special built-in
command. The default value of unit n is 0. The option -t is
used to specify a time- out in seconds when reading from a
terminal or pipe. If vname is omitted, then REPLY is used as
the default vname. An end-of- file with the -p option causes
cleanup for this process so that another can be spawned. If
the first argument contains a ?, the remainder of this word
is used as a prompt on standard error when the shell is
interactive. The exit status is 0 unless an end-of-file is
encountered or read has timed out.</p>

<p>readonly [ -p ] [ vname[=value] ] ... If vname is not
given, the names and values of each variable with the
readonly attribute is printed with the values quoted in a
manner that allows them to be re-inputted. The -p option
causes the word readonly to be inserted before each one.
Other- wise, the given vnames are marked readonly and these
names can- not be changed by subsequent assignment. When
defining a type, if the value of a readonly sub-variable is
not defined the value is required when creating each
instance.</p>

<p>return [ n ] Causes a shell function or . script to
return to the invoking script with the exit status specified
by n. The value will be the least significant 8 bits of the
specified status. If n is omitted, then the return status is
that of the last command exe- cuted. If return is invoked
while not in a function or a . script, then it behaves the
same as exit.</p>

<p>set [ &plusmn;BCGabefhkmnoprstuvx ] [ &plusmn;o [ option
] ] ... [ &plusmn;A vname ] [ arg ... ] The options for this
command have meaning as follows: -A Array assignment. Unset
the variable vname and assign values sequentially from the
arg list. If +A is used, the variable vname is not unset
first. -B Enable brace pattern field generation. This is the
default behavior. -B Enable brace group expansion. On by
default. -C Prevents redirection &gt; from truncating
existing files. Files that are created are opened with the
O_EXCL mode. Requires &gt;to truncate a file when turned on.
-G Causes the patternby itself to match files and zero or
more directories and sub-directories when used for file name
generation. If followed by a / only directo- ries and
sub-directories are matched. -a All subsequent variables
that are defined are automati- cally exported. -b Prints job
completion messages as soon as a background job changes
state rather than waiting for the next prompt. -e Unless
contained in aor &amp;&amp; command, or the command
following an if while or until command or in the pipeline
following !, if a command has a non-zero exit status,
execute the ERR trap, if set, and exit. This mode is
disabled while reading profiles. -f Disables file name
generation. -h Each command becomes a tracked alias when
first encoun- tered. -k (Obsolete). All variable assignment
arguments are placed in the environment for a command, not
just those that precede the command name. -m Background jobs
will run in a separate process group and a line will print
upon completion. The exit status of background jobs is
reported in a completion message. On systems with job
control, this option is turned on auto- matically for
interactive shells. -n Read commands and check them for
syntax errors, but do not execute them. Ignored for
interactive shells. -o The following argument can be one of
the following option names: allexport Same as -a. errexit
Same as -e. bgnice All background jobs are run at a lower
priority. This is the default mode. braceexpand Same as -B.
emacs Puts you in an emacs style in-line editor for command
entry. globstar Same as -G. gmacs Puts you in a gmacs style
in-line editor for command entry. ignoreeof The shell will
not exit on end-of-file. The command exit must be used.
keyword Same as -k. markdirs All directory names resulting
from file name generation have a trailing / appended.
monitor Same as -m. multiline The built-in editors will use
multiple lines on the screen for lines that are longer than
the width of the screen. This may not work for all
terminals. noclobber Same as -C. noexec Same as -n. noglob
Same as -f. nolog Do not save function definitions in the
history file. notify Same as -b. nounset Same as -u.
pipefail A pipeline will not complete until all compo- nents
of the pipeline have completed, and the return value will be
the value of the last non- zero command to fail or zero if
no command has failed. showme When enabled, simple commands
or pipelines pre- ceded by a semicolon (;) will be displayed
as if the xtrace option were enabled but will not be
executed. Otherwise, the leading ; will be ignored.
privileged Same as -p. verbose Same as -v. trackall Same as
-h. vi Puts you in insert mode of a vi style in-line editor
until you hit the escape character 033. This puts you in
control mode. A return sends the line. viraw Each character
is processed as it is typed in vi mode. xtrace Same as -x.
If no option name is supplied, then the current option
settings are printed. -p Disables processing of the
$HOME/.profile file and uses the file /etc/suid_profile
instead of the ENV file. This mode is on whenever the
effective uid (gid) is not equal to the real uid (gid).
Turning this off causes the effective uid and gid to be set
to the real uid and gid. -r Enables the restricted shell.
This option cannot be unset once set. -s Sort the positional
parameters lexicographically. -t (Obsolete). Exit after
reading and executing one com- mand. -u Treat unset
parameters as an error when substituting. -v Print shell
input lines as they are read. -x Print commands and their
arguments as they are executed. -- Do not change any of the
options; useful in setting $1 to a value beginning with -.
If no arguments follow this option then the positional
parameters are unset.</p>

<p>As an obsolete feature, if the first arg is - then the
-x and -v options are turned off and the next arg is treated
as the first argument. Using + rather than - causes these
options to be turned off. These options can also be used
upon invocation of the shell. The current set of options may
be found in $-. Unless -A is specified, the remaining
arguments are positional parameters and are assigned, in
order, to $1 $2 .... If no arguments are given, then the
names and values of all variables are printed on the
standard output.</p>

<p>shift [ n ] The positional parameters from $n+1 ... are
renamed $1 ... , default n is 1. The parameter n can be any
arithmetic expres- sion that evaluates to a non-negative
number less than or equal to $#.</p>

<p>sleep seconds Suspends execution for the number of
decimal seconds or frac- tions of a second given by
seconds.</p>

<p>trap [ -p ] [ action ] [ sig ] ... The -p option causes
the trap action associated with each trap as specified by
the arguments to be printed with appropriate quoting.
Otherwise, action will be processed as if it were an
argument to eval when the shell receives signal(s) sig. Each
sig can be given as a number or as the name of the signal.
Trap commands are executed in order of signal number. Any
attempt to set a trap on a signal that was ignored on entry
to the current shell is ineffective. If action is omitted
and the first sig is a number, or if action is -, then the
trap(s) for each sig are reset to their original values. If
action is the null string then this signal is ignored by the
shell and by the commands it invokes. If sig is ERR then
action will be executed whenever a command has a non-zero
exit status. If sig is DEBUG then action will be executed
before each command. The variable .sh.command will contain
the contents of the current command line when action is
running. If the exit status of the trap is 2 the com- mand
will not be executed. If the exit status of the trap is 255
and inside a function or a dot script, the function or dot
script will return. If sig is 0 or EXIT and the trap
statement is executed inside the body of a function defined
with the func- tion name syntax, then the command action is
executed after the function completes. If sig is 0 or EXIT
for a trap set outside any function then the command action
is executed on exit from the shell. If sig is KEYBD, then
action will be executed when- ever a key is read while in
emacs, gmacs, or vi mode. The trap command with no arguments
prints a list of commands associated with each signal
number.</p>

<p>An exit or return without an argument in a trap action
will preserve the exit status of the command that invoked
the trap.</p>

<p>true Does nothing, and exits 0. Used with while for
infinite loops.</p>

<p>true Does nothing, and exits 0. Used with while for
infinite loops.</p>

<p>typeset [ &plusmn;ACHSflbnprtux ] [ &plusmn;EFLRXZi[n] ]
[ -T tname=(assign_list) ] [ -h str ] [ -a [type] ] [
vname[=value ] ] ... Sets attributes and values for shell
variables and functions. When invoked inside a function
defined with the function name syntax, a new instance of the
variable vname is created, and the variables value and type
are restored when the function com- pletes. The following
list of attributes may be specified: -A Declares vname to be
an associative array. Subscripts are strings rather than
arithmetic expressions. -C causes each vname to be a
compound variable. value names a compound variable it is
copied into vname. Otherwise, it unsets each vname. -a
Declares vname to be an indexed array. If type is speci-
fied, it must be the name of an enumeration type created
with the enum command and it allows enumeration constants to
be used as subscripts. -E Declares vname to be a double
precision floating point number. If n is non-zero, it
defines the number of sig- nificant figures that are used
when expanding vname. Otherwise, ten significant figures
will be used. -F Declares vname to be a double precision
floating point number. If n is non-zero, it defines the
number of places after the decimal point that are used when
expand- ing vname. Otherwise ten places after the decimal
point will be used. -H This option provides UNIX to
host-name file mapping on non-UNIX machines. -L Left justify
and remove leading blanks from value. If n is non-zero, it
defines the width of the field, otherwise it is determined
by the width of the value of first assignment. When the
variable is assigned to, it is filled on the right with
blanks or truncated, if neces- sary, to fit into the field.
The -R option is turned off. -R Right justify and fill with
leading blanks. If n is non- zero, it defines the width of
the field, otherwise it is determined by the width of the
value of first assignment. The field is left filled with
blanks or truncated from the end if the variable is
reassigned. The -L option is turned off. -S When used within
the assign_list of a type definition, it causes the
specified sub-variable to be shared by all instances of the
type. When used inside a function defined with the function
reserved word, the specified variables will have function
static scope. Otherwise, the variable is unset prior to
processing the assignment list. -T Creates a type named by
tname using the compound assign- ment assign_list to tname.
-X Declares vname to be a double precision floating point
number and expands using the %a format of ISO-C99. If n is
non-zero, it defines the number of hex digits after the
radix point that is used when expanding vname. The default
is 10. -Z Right justify and fill with leading zeros if the
first non-blank character is a digit and the -L option has
not been set. Remove leading zeros if the -L option is also
set. If n is non-zero, it defines the width of the field,
otherwise it is determined by the width of the value of
first assignment. -f The names refer to function names
rather than variable names. No assignments can be made and
the only other valid options are -t, -u and -x. The -t
option turns on execution tracing for this function. The -u
option causes this function to be marked undefined. The
FPATH variable will be searched to find the function
definition when the function is referenced. If no options
other than -f is specified, then the function definition
will be displayed on standard output. If +f is specified,
then a line containing the function name followed by a shell
comment containing the line number and path name of the file
where this function was defined, if any, is dis- played. -b
The variable can hold any number of bytes of data. The data
can be text or binary. The value is represented by the
base64 encoding of the data. If -Z is also speci- fied, the
size in bytes of the data in the buffer will be determined
by the size associated with the -Z. If the base64 string
assigned results in more data, it will be truncated.
Otherwise, it will be filled with bytes whose value is zero.
The printf format %B can be used to out- put the actual data
in this buffer instead of the base64 encoding of the data.
-h Used within type definitions to add information when gen-
erating information about the sub-variable on the man page.
It is ignored when used outside of a type defini- tion. When
used with -f the information is associated with the
corresponding discipline function. -i Declares vname to be
represented internally as integer. The right hand side of an
assignment is evaluated as an arithmetic expression when
assigning to an integer. If n is non-zero, it defines the
output arithmetic base, oth- erwise the output base will be
ten. -l All upper-case characters are converted to
lower-case. The upper-case option, -u, is turned off. -n
Declares vname to be a reference to the variable whose name
is defined by the value of variable vname. This is usually
used to reference a variable inside a function whose name
has been passed as an argument. -p The name, attributes and
values for the given vnames are written on standard output
in a form that can be used as shell input. If +p is
specified, then the values are not displayed. -r The given
vnames are marked readonly and these names can- not be
changed by subsequent assignment. -t Tags the variables.
Tags are user definable and have no special meaning to the
shell. -u All lower-case characters are converted to
upper-case. The lower-case option, -l, is turned off. -x The
given vnames are marked for automatic export to the
environment of subsequently-executed commands. Variables
whose names contain a . cannot be exported.</p>

<p>The -i attribute cannot be specified along with -R, -L,
-Z, or -f.</p>

<p>Using + rather than - causes these options to be turned
off. If no vname arguments are given, a list of vnames (and
optionally the values) of the variables is printed. (Using +
rather than - keeps the values from being printed.) The -p
option causes typeset followed by the option letters to be
printed before each name rather than the names of the
options. If any option other than -p is given, only those
variables which have all of the given options are printed.
Otherwise, the vnames and attributes of all variables that
have attributes are printed.</p>

<p>ulimit [ -HSacdfmnpstv ] [ limit ] Set or display a
resource limit. The available resource limits are listed
below. Many systems do not support one or more of these
limits. The limit for a specified resource is set when limit
is specified. The value of limit can be a number in the unit
specified below with each resource, or the value unlimited.
The -H and -S options specify whether the hard limit or the
soft limit for the given resource is set. A hard limit
cannot be increased once it is set. A soft limit can be
increased up to the value of the hard limit. If neither the
H nor S option is specified, the limit applies to both. The
current resource limit is printed when limit is omitted. In
this case, the soft limit is printed unless H is specified.
When more than one resource is specified, then the limit
name and unit is printed before the value. -a Lists all of
the current resource limits. -c The number of 512-byte
blocks on the size of core dumps. -d The number of K-bytes
on the size of the data area. -f The number of 512-byte
blocks on files that can be writ- ten by the current process
or by child processes (files of any size may be read). -m
The number of K-bytes on the size of physical memory. -n The
number of file descriptors plus 1. -p The number of 512-byte
blocks for pipe buffering. -s The number of K-bytes on the
size of the stack area. -t The number of CPU seconds to be
used by each process. -v The number of K-bytes for virtual
memory.</p>

<p>If no option is given, -f is assumed.</p>

<p>umask [ -S ] [ mask ] The user file-creation mask is set
to mask (see umask(2)). mask can either be an octal number
or a symbolic value as described in chmod(1). If a symbolic
value is given, the new umask value is the complement of the
result of applying mask to the comple- ment of the previous
umask value. If mask is omitted, the cur- rent value of the
mask is printed. The -S option causes the mode to be printed
as a symbolic value. Otherwise, the mask is printed in
octal.</p>

<p>unalias [ -a ] name ... The aliases given by the list of
names are removed from the alias list. The -a option causes
all the aliases to be unset.</p>

<p>unset [ -fnv ] vname ... The variables given by the list
of vnames are unassigned, i.e., except for sub-variables
within a type, their values and attributes are erased. For
sub-variables of a type, the values are reset to the default
value from the type definition. Read- only variables cannot
be unset. If the -f option is set, then the names refer to
function names. If the -v option is set, then the names
refer to variable names. The -f option overrides -v. If -n
is set and name is a name reference, then name will be unset
rather than the variable that it references. The default is
equivalent to -v. Unsetting LINENO, MAILCHECK, OPTARG,
OPTIND, RANDOM, SECONDS, TMOUT, and _ removes their spe-
cial meaning even if they are subsequently assigned to.</p>

<p>wait [ job ... ] Wait for the specified job and report
its termination status. If job is not given, then all
currently active child processes are waited for. The exit
status from this command is that of the last process waited
for if job is specified; otherwise it is zero. See Jobs for
a description of the format of job.</p>

<p>whence [ -afpv ] name ... For each name, indicate how it
would be interpreted if used as a command name. The -v
option produces a more verbose report. The -f option skips
the search for functions. The -p option does a path search
for name even if name is an alias, a function, or a reserved
word. The -p option turns off the -v option. The -a option
is similar to the -v option but causes all interpreta- tions
of the given name to be reported.</p>

<p>Invocation. If the shell is invoked by exec(2), and the
first character of argument zero ($0) is -, then the shell
is assumed to be a login shell and com- mands are read from
/etc/profile and then from either .profile in the current
directory or $HOME/.profile, if either file exists. Next,
for interactive shells, commands are read from the file
named by performing parameter expansion, command
substitution, and arithmetic substitution on the value of
the environment variable ENV if the file exists. If the -s
option is not present and arg and a file by the name of arg
exists, then it reads and executes this script. Otherwise,
if the first arg does not contain a /, a path search is
performed on the first arg to determine the name of the
script to execute. The script arg must have execute
permission and any setuid and setgid settings will be
ignored. If the script is not found on the path, arg is
processed as if it named a built-in command or function.
Commands are then read as described below; the following
options are interpreted by the shell when it is invoked:</p>

<p>-D Do not execute the script, but output the set of
double quoted strings preceded by a $. These strings are
needed for local- ization of the script to different
locales. -E Reads the file named by the ENV variable or by
$HOME/.kshrc if not defined after the profiles. -c If the -c
option is present, then commands are read from the first
arg. Any remaining arguments become positional parame- ters
starting at 0. -s If the -s option is present or if no
arguments remain, then commands are read from the standard
input. Shell output, except for the output of the Special
Commands listed above, is written to file descriptor 2. -i
If the -i option is present or if the shell input and error
output are attached to a terminal (as told by tcgetattr(2)),
then this shell is interactive. In this case TERM is ignored
(so that kill 0 does not kill an interactive shell) and INTR
is caught and ignored (so that wait is interruptible). In
all cases, QUIT is ignored by the shell. -r If the -r option
is present, the shell is a restricted shell. -D A list of
all double quoted strings that are preceded by a $ will be
printed on standard output and the shell will exit. This set
of strings will be subject to language translation when the
locale is not C or POSIX. No commands will be exe-
cuted.</p>

<p>-P If -P or -o profile is present, the shell is a
profile shell (see pfexec(1)).</p>

<p>-R filename The -R filename option is used to generate a
cross reference database that can be used by a separate
utility to find defi- nitions and references for variables
and commands. The file- name argument specifies the
generated database. A script file must be provided on the
command line as well.</p>

<p>The remaining options and arguments are described under
the set command above. An optional - as the first argument
is ignored.</p>

<p>Rksh Only. Rksh is used to set up login names and
execution environments whose capabilities are more
controlled than those of the standard shell. The actions of
rksh are identical to those of ksh, except that the follow-
ing are disallowed: Unsetting the restricted option.
changing directory (see cd(1)), setting or unsetting the
value or attributes of SHELL, ENV, FPATH, or PATH,
specifying path or command names containing /, redirecting
output (&gt;, &gt;|, &lt;&gt;, and &gt;&gt;). adding or
deleting built-in commands. using command -p to invoke a
command.</p>

<p>The restrictions above are enforced after .profile and
the ENV files are interpreted.</p>

<p>When a command to be executed is found to be a shell
procedure, rksh invokes ksh to execute it. Thus, it is
possible to provide to the end- user shell procedures that
have access to the full power of the stan- dard shell, while
imposing a limited menu of commands; this scheme assumes
that the end-user does not have write and execute
permissions in the same directory.</p>

<p>The net effect of these rules is that the writer of the
.profile has complete control over user actions, by
performing guaranteed setup actions and leaving the user in
an appropriate directory (probably not the login
directory).</p>

<p>The system administrator often sets up a directory of
commands (e.g., /usr/rbin) that can be safely invoked by
rksh.</p>

<p>EXIT STATUS Errors detected by the shell, such as syntax
errors, cause the shell to return a non-zero exit status. If
the shell is being used non-interac- tively, then execution
of the shell file is abandoned unless the error occurs
inside a subshell in which case the subshell is abandoned.
Oth- erwise, the shell returns the exit status of the last
command executed (see also the exit command above). Run time
errors detected by the shell are reported by printing the
command or function name and the error condition. If the
line number that the error occurred on is greater than one,
then the line number is also printed in square brack- ets
([]) after the command or function name.</p>

<p>FILES /etc/profile The system wide initialization file,
executed for login shells.</p>

<p>$HOME/.profile The personal initialization file,
executed for login shells after /etc/profile.</p>

<p>$HOME/..kshrc Default personal initialization file,
executed for interactive shells when ENV is not set.</p>

<p>/etc/suid_profile Alternative initialization file,
executed instead of the per- sonal initialization file when
the real and effective user or group id do not match.</p>

<p>/dev/null NULL device</p>

<p>SEE ALSO cat(1), cd(1), chmod(1), cut(1), egrep(1),
echo(1), emacs(1), env(1), fgrep(1), gmacs(1), grep(1),
newgrp(1), pfexec(1), stty(1), test(1), umask(1), vi(1),
dup(2), exec(2), fork(2), getpwnam(3), ioctl(2), lseek(2),
paste(1), pathconf(2), pipe(2), sysconf(2), umask(2),
ulimit(2), wait(2), rand(3), a.out(5), profile(5),
environ(7).</p>

<p>Morris I. Bolsky and David G. Korn, The New KornShell
Command and Pro- gramming Language, Prentice Hall, 1995.</p>

<p>POSIX - Part 2: Shell and Utilities, IEEE Std
1003.2-1992, ISO/IEC 9945-2, IEEE, 1993.</p>

<p>CAVEATS If a command is executed, and then a command
with the same name is installed in a directory in the search
path before the directory where the original command was
found, the shell will continue to exec the original command.
Use the -t option of the alias command to correct this
situation.</p>

<p>Some very old shell scripts contain a ^ as a synonym for
the pipe char- acter.</p>

<p>Using the hist built-in command within a compound
command will cause the whole command to disappear from the
history file.</p>

<p>The built-in command . file reads the whole file before
any commands are executed. Therefore, alias and unalias
commands in the file will not apply to any commands defined
in the file.</p>

<p>Traps are not processed while a job is waiting for a
foreground pro- cess. Thus, a trap on CHLD wont be executed
until the foreground job terminates.</p>

<p>It is a good idea to leave a space after the comma
operator in arith- metic expressions to prevent the comma
from being interpreted as the decimal point character in
certain locales.</p>

<p>RDS Standard User Environment Utilities KSH(1)</p>
<hr>
</body>
</html>
