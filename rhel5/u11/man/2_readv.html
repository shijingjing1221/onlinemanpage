<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:21:13 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>READV(2) Linux Programmer s Manual READV(2)</p>

<p>NAME readv, writev - read or write data into multiple
buffers</p>

<p>SYNOPSIS #include &lt;sys/uio.h&gt;</p>

<p>ssize_t readv(int fd, const struct iovec *vector, int
count);</p>

<p>ssize_t writev(int fd, const struct iovec *vector, int
count);</p>

<p>DESCRIPTION The readv() function reads count blocks from
the file associated with the file descriptor fd into the
multiple buffers described by vector.</p>

<p>The writev() function writes at most count blocks
described by vector to the file associated with the file
descriptor fd.</p>

<p>The pointer vector points to a struct iovec defined in
&lt;sys/uio.h&gt; as</p>

<p>struct iovec { void *iov_base; /* Starting address */
size_t iov_len; /* Number of bytes */ };</p>

<p>Buffers are processed in the order specified.</p>

<p>The readv() function works just like read(2) except that
multiple buffers are filled.</p>

<p>The writev() function works just like write(2) except
that multiple buffers are written out.</p>

<p>RETURN VALUE On success, the readv() function returns
the number of bytes read; the writev() function returns the
number of bytes written. On error, -1 is returned, and errno
is set appropriately.</p>

<p>ERRORS The errors are as given for read(2) and write(2).
Additionally the following error is defined:</p>

<p>EINVAL The sum of the iov_len values overflows an
ssize_t value. Or, the vector count count is less than zero
or greater than the permitted maximum.</p>

<p>CONFORMING TO 4.4BSD (the readv() and writev() functions
first appeared in 4.2BSD), POSIX.1-2001. Linux libc5 used
size_t as the type of the count parame- ter, and int as
return type for these functions.</p>

<p>LINUX NOTES POSIX.1-2001 allows an implementation to
place a limit on the number of items that can be passed in
vector. An implementation can advertise its limit by
defining IOV_MAX in &lt;limits.h&gt; or at run time via the
return value from sysconf(_SC_IOV_MAX). On Linux, the limit
advertised by these mechanisms is 1024, which is the true
kernel limit. However, the glibc wrapper functions do some
extra work if they detect that the underlying kernel system
call failed because this limit was exceeded. In the case of
readv() the wrapper function allocates a temporary buffer
large enough for all of the items specified by vector,
passes that buffer in a call to read(), copies data from the
buffer to the locations specified by the iov_base fields of
the elements of vector, and then frees the buffer. The
wrapper function for writev() performs the analogous task
using a temporary buffer and a call to write().</p>

<p>BUGS It is not advisable to mix calls to functions like
readv() or writev(), which operate on file descriptors, with
the functions from the stdio library; the results will be
undefined and probably not what you want.</p>

<p>SEE ALSO read(2), write(2)</p>

<p>2002-10-17 READV(2)</p>
<hr>
</body>
</html>
