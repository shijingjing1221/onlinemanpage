<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:10:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>CHMOD(2) Linux Programmer s Manual CHMOD(2)</p>

<p>NAME chmod, fchmod - change permissions of a file</p>

<p>SYNOPSIS #include &lt;sys/types.h&gt; #include
&lt;sys/stat.h&gt;</p>

<p>int chmod(const char *path, mode_t mode); int fchmod(int
fildes, mode_t mode);</p>

<p>DESCRIPTION The mode of the file given by path or
referenced by fildes is changed.</p>

<p>Modes are specified by oring the following:</p>

<p>S_ISUID 04000 set user ID on execution</p>

<p>S_ISGID 02000 set group ID on execution</p>

<p>S_ISVTX 01000 sticky bit</p>

<p>S_IRUSR 00400 read by owner</p>

<p>S_IWUSR 00200 write by owner</p>

<p>S_IXUSR 00100 execute/search by owner</p>

<p>S_IRGRP 00040 read by group</p>

<p>S_IWGRP 00020 write by group</p>

<p>S_IXGRP 00010 execute/search by group</p>

<p>S_IROTH 00004 read by others</p>

<p>S_IWOTH 00002 write by others</p>

<p>S_IXOTH 00001 execute/search by others</p>

<p>The effective UID of the calling process must match the
owner of the file, or the process must be privileged (Linux:
it must have the CAP_FOWNER capability).</p>

<p>If the calling process is not privileged (Linux: does
not have the CAP_FSETID capability), and the group of the
file does not match the effective group ID of the process or
one of its supplementary group IDs, the S_ISGID bit will be
turned off, but this will not cause an error to be
returned.</p>

<p>As a security measure, depending on the file system, the
set-user-ID and set-group-ID execution bits may be turned
off if a file is written. (On Linux this occurs if the
writing process does not have the CAP_FSETID capability.) On
some file systems, only the superuser can set the sticky
bit, which may have a special meaning. For the sticky bit,
and for set-user-ID and set-group-ID bits on directories,
see stat(2).</p>

<p>On NFS file systems, restricting the permissions will
immediately influence already open files, because the access
control is done on the server, but open files are maintained
by the client. Widening the permissions may be delayed for
other clients if attribute caching is enabled on them.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS Depending on the file system, other errors can be
returned. The more general errors for chmod() are listed
below:</p>

<p>EACCES Search permission is denied on a component of the
path prefix. (See also path_resolution(2).)</p>

<p>EFAULT path points outside your accessible address
space.</p>

<p>EIO An I/O error occurred.</p>

<p>ELOOP Too many symbolic links were encountered in
resolving path.</p>

<p>ENAMETOOLONG path is too long.</p>

<p>ENOENT The file does not exist.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ENOTDIR A component of the path prefix is not a
directory.</p>

<p>EPERM The effective UID does not match the owner of the
file, and the process is not privileged (Linux: it does not
have the CAP_FOWNER capability).</p>

<p>EROFS The named file resides on a read-only file
system.</p>

<p>The general errors for fchmod() are listed below:</p>

<p>EBADF The file descriptor fildes is not valid.</p>

<p>EIO See above.</p>

<p>EPERM See above.</p>

<p>EROFS See above.</p>

<p>CONFORMING TO 4.4BSD, SVr4, POSIX.1-2001.</p>

<p>SEE ALSO chown(2), execve(2), fchmodat(2), open(2),
path_resolution(2), stat(2)</p>

<p>Linux 2.6.7 2004-06-23 CHMOD(2)</p>
<hr>
</body>
</html>
