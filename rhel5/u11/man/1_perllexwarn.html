<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:36 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLLEXWARN(1) Perl Programmers Reference Guide
PERLLEXWARN(1)</p>

<p>NAME perllexwarn - Perl Lexical Warnings</p>

<p>DESCRIPTION The &quot;use warnings&quot; pragma is a
replacement for both the command line flag -w and the
equivalent Perl variable, $^W.</p>

<p>The pragma works just like the existing
&quot;strict&quot; pragma. This means that the scope of the
warning pragma is limited to the enclosing block. It also
means that the pragma setting will not leak across files
(via &quot;use&quot;, &quot;require&quot; or
&quot;do&quot;). This allows authors to independently define
the degree of warning checks that will be applied to their
module.</p>

<p>By default, optional warnings are disabled, so any
legacy code that doesn t attempt to control the warnings
will work unchanged.</p>

<p>All warnings are enabled in a block by either of
these:</p>

<p>use warnings; use warnings all;</p>

<p>Similarly all warnings are disabled in a block by either
of these:</p>

<p>no warnings; no warnings all;</p>

<p>For example, consider the code below:</p>

<p>use warnings; my @a; { no warnings; my $b = @a[0]; } my
$c = @a[0];</p>

<p>The code in the enclosing block has warnings enabled,
but the inner block has them disabled. In this case that
means the assignment to the scalar $c will trip the
&quot;Scalar value @a[0] better written as $a[0]&quot;
warning, but the assignment to the scalar $b will not.</p>

<p>Default Warnings and Optional Warnings</p>

<p>Before the introduction of lexical warnings, Perl had
two classes of warnings: mandatory and optional.</p>

<p>As its name suggests, if your code tripped a mandatory
warning, you would get a warning whether you wanted it or
not. For example, the code below would always produce an
&quot;isn&rsquo;t numeric&quot; warning about the
&quot;2:&quot;.</p>

<p>my $a = &quot;2:&quot; + 3;</p>

<p>With the introduction of lexical warnings, mandatory
warnings now become default warnings. The difference is that
although the previously mandatory warnings are still enabled
by default, they can then be sub- sequently enabled or
disabled with the lexical warning pragma. For example, in
the code below, an &quot;isn&rsquo;t numeric&quot; warning
will only be reported for the $a variable.</p>

<p>my $a = &quot;2:&quot; + 3; no warnings; my $b =
&quot;2:&quot; + 3;</p>

<p>Note that neither the -w flag or the $^W can be used to
disable/enable default warnings. They are still mandatory in
this case.</p>

<p>Whas wrong with -w and $^W</p>

<p>Although very useful, the big problem with using -w on
the command line to enable warnings is that it is all or
nothing. Take the typical sce- nario when you are writing a
Perl program. Parts of the code you will write yourself, but
its very likely that you will make use of pre- written Perl
modules. If you use the -w flag in this case, you end up
enabling warnings in pieces of code that you havent
written.</p>

<p>Similarly, using $^W to either disable or enable blocks
of code is fun- damentally flawed. For a start, say you want
to disable warnings in a block of code. You might expect
this to be enough to do the trick:</p>

<p>{ local ($^W) = 0; my $a =+ 2; my $b; chop $b; }</p>

<p>When this code is run with the -w flag, a warning will
be produced for the $a line -- &quot;Reversed +=
operator&quot;.</p>

<p>The problem is that Perl has both compile-time and
run-time warnings. To disable compile-time warnings you need
to rewrite the code like this:</p>

<p>{ BEGIN { $^W = 0 } my $a =+ 2; my $b; chop $b; }</p>

<p>The other big problem with $^W is the way you can
inadvertently change the warning setting in unexpected
places in your code. For example, when the code below is run
(without the -w flag), the second call to &quot;doit&quot;
will trip a &quot;Use of uninitialized value&quot; warning,
whereas the first will not.</p>

<p>sub doit { my $b; chop $b; }</p>

<p>doit();</p>

<p>{ local ($^W) = 1; doit() }</p>

<p>This is a side-effect of $^W being dynamically
scoped.</p>

<p>Lexical warnings get around these limitations by
allowing finer control over where warnings can or cant be
tripped.</p>

<p>Controlling Warnings from the Command Line</p>

<p>There are three Command Line flags that can be used to
control when warnings are (or arent) produced:</p>

<p>-w This is the existing flag. If the lexical warnings
pragma is not used in any of you code, or any of the modules
that you use, this flag will enable warnings everywhere. See
&quot;Backward Compatibility&quot; for details of how this
flag interacts with lexical warnings.</p>

<p>-W If the -W flag is used on the command line, it will
enable all warnings throughout the program regardless of
whether warnings were disabled locally using &quot;no
warnings&quot; or &quot;$^W =0&quot;. This includes all
files that get included via &quot;use&quot;,
&quot;require&quot; or &quot;do&quot;. Think of it as the
Perl equivalent of the &quot;lint&quot; command.</p>

<p>-X Does the exact opposite to the -W flag, i.e. it
disables all warn- ings.</p>

<p>Backward Compatibility</p>

<p>If you are used with working with a version of Perl
prior to the intro- duction of lexically scoped warnings, or
have code that uses both lexi- cal warnings and $^W, this
section will describe how they interact.</p>

<p>How Lexical Warnings interact with -w/$^W:</p>

<p>1. If none of the three command line flags (-w, -W or
-X) that con- trol warnings is used and neither $^W or the
&quot;warnings&quot; pragma are used, then default warnings
will be enabled and optional warnings disabled. This means
that legacy code that doesn t attempt to control the
warnings will work unchanged.</p>

<p>2. The -w flag just sets the global $^W variable as in
5.005 -- this means that any legacy code that currently
relies on manipulating $^W to control warning behavior will
still work as is.</p>

<p>3. Apart from now being a boolean, the $^W variable
operates in exactly the same horrible uncontrolled global
way, except that it cannot disable/enable default
warnings.</p>

<p>4. If a piece of code is under the control of the
&quot;warnings&quot; pragma, both the $^W variable and the
-w flag will be ignored for the scope of the lexical
warning.</p>

<p>5. The only way to override a lexical warnings setting
is with the -W or -X command line flags.</p>

<p>The combined effect of 3 &amp; 4 is that it will allow
code which uses the &quot;warnings&quot; pragma to control
the warning behavior of $^W-type code (using a &quot;local
$^W=0&quot;) if it really wants to, but not vice-versa.</p>

<p>Category Hierarchy</p>

<p>A hierarchy of &quot;categories&quot; have been defined
to allow groups of warn- ings to be enabled/disabled in
isolation.</p>

<p>The current hierarchy is:</p>

<p>all -+ +- closure +- deprecated +- exiting +- glob +- io
-----------+ +- closed +- exec +- layer +- newline +- pipe
+- unopened +- misc +- numeric +- once +- overflow +- pack
+- portable +- recursion +- redefine +- regexp +- severe
-------+ +- debugging +- inplace +- internal +- malloc +-
signal +- substr +- syntax -------+ +- ambiguous +- bareword
+- digit +- parenthesis +- precedence +- printf +- prototype
+- qw +- reserved +- semicolon +- taint +- threads +-
uninitialized +- unpack +- untie +- utf8 +- void +- y2k</p>

<p>Just like the &quot;strict&quot; pragma any of these
categories can be combined</p>

<p>use warnings qw(void redefine); no warnings qw(io syntax
untie);</p>

<p>Also like the &quot;strict&quot; pragma, if there is
more than one instance of the &quot;warnings&quot; pragma in
a given scope the cumulative effect is addi- tive.</p>

<p>use warnings qw(void); # only &quot;void&quot; warnings
enabled ... use warnings qw(io); # only &quot;void&quot;
&amp; &quot;io&quot; warnings enabled ... no warnings
qw(void); # only &quot;io&quot; warnings enabled</p>

<p>To determine which category a specific warning has been
assigned to see perldiag.</p>

<p>Note: In Perl 5.6.1, the lexical warnings category
&quot;deprecated&quot; was a sub-category of the
&quot;syntax&quot; category. It is now a top-level category
in its own right.</p>

<p>Fatal Warnings</p>

<p>The presence of the word &quot;FATAL&quot; in the
category list will escalate any warnings detected from the
categories specified in the lexical scope into fatal errors.
In the code below, the use of &quot;time&quot;,
&quot;length&quot; and &quot;join&quot; can all produce a
&quot;Useless use of xxx in void context&quot; warning.</p>

<p>use warnings;</p>

<p>time;</p>

<p>{ use warnings FATAL =&gt; qw(void); length
&quot;abc&quot;; }</p>

<p>join &quot;&quot;, 1,2,3;</p>

<p>print &quot;done0;</p>

<p>When run it produces this output</p>

<p>Useless use of time in void context at fatal line 3.
Useless use of length in void context at fatal line 7.</p>

<p>The scope where &quot;length&quot; is used has escalated
the &quot;void&quot; warnings cat- egory into a fatal error,
so the program terminates immediately it encounters the
warning.</p>

<p>To explicitly turn off a &quot;FATAL&quot; warning you
just disable the warning it is associated with. So, for
example, to disable the &quot;void&quot; warning in the
example above, either of these will do the trick:</p>

<p>no warnings qw(void); no warnings FATAL =&gt;
qw(void);</p>

<p>If you want to downgrade a warning that has been
escalated into a fatal error back to a normal warning, you
can use the &quot;NONFATAL&quot; keyword. For example, the
code below will promote all warnings into fatal errors,
except for those in the &quot;syntax&quot; category.</p>

<p>use warnings FATAL =&gt; all, NONFATAL =&gt; syntax;</p>

<p>Reporting Warnings from a Module</p>

<p>The &quot;warnings&quot; pragma provides a number of
functions that are useful for module authors. These are used
when you want to report a module- specific warning to a
calling module has enabled warnings via the
&quot;warnings&quot; pragma.</p>

<p>Consider the module &quot;MyMod::Abc&quot; below.</p>

<p>package MyMod::Abc;</p>

<p>use warnings::register;</p>

<p>sub open { my $path = shift; if ($path !~ m#^/#) {
warnings::warn(&quot;changing relative path to
/var/abc&quot;) if warnings::enabled(); $path =
&quot;/var/abc/$path&quot;; } }</p>

<p>1;</p>

<p>The call to &quot;warnings::register&quot; will create a
new warnings category called &quot;MyMod::abc&quot;, i.e.
the new category name matches the current package name. The
&quot;open&quot; function in the module will display a
warning message if it gets given a relative path as a
parameter. This warnings will only be displayed if the code
that uses &quot;MyMod::Abc&quot; has actually enabled them
with the &quot;warnings&quot; pragma like below.</p>

<p>use MyMod::Abc; use warnings MyMod::Abc; ...
abc::open(&quot;../fred.txt&quot;);</p>

<p>It is also possible to test whether the pre-defined
warnings categories are set in the calling module with the
&quot;warnings::enabled&quot; function. Consider this
snippet of code:</p>

<p>package MyMod::Abc;</p>

<p>sub open { warnings::warnif(&quot;deprecated&quot;,
&quot;open is deprecated, use new instead&quot;); new(@_);
}</p>

<p>sub new ... 1;</p>

<p>The function &quot;open&quot; has been deprecated, so
code has been included to display a warning message whenever
the calling module has (at least) the &quot;deprecated&quot;
warnings category enabled. Something like this, say.</p>

<p>use warnings deprecated; use MyMod::Abc; ...
MyMod::Abc::open($filename);</p>

<p>Either the &quot;warnings::warn&quot; or
&quot;warnings::warnif&quot; function should be used to
actually display the warnings message. This is because they
can make use of the feature that allows warnings to be
escalated into fatal errors. So in this case</p>

<p>use MyMod::Abc; use warnings FATAL =&gt; MyMod::Abc; ...
MyMod::Abc::open(../fred.txt);</p>

<p>the &quot;warnings::warnif&quot; function will detect
this and die after display- ing the warning message.</p>

<p>The three warnings functions,
&quot;warnings::warn&quot;, &quot;warnings::warnif&quot; and
&quot;warnings::enabled&quot; can optionally take an object
reference in place of a category name. In this case the
functions will use the class name of the object as the
warnings category.</p>

<p>Consider this example:</p>

<p>package Original;</p>

<p>no warnings; use warnings::register;</p>

<p>sub new { my $class = shift; bless [], $class; }</p>

<p>sub check { my $self = shift; my $value = shift;</p>

<p>if ($value % 2 &amp;&amp; warnings::enabled($self)) {
warnings::warn($self, &quot;Odd numbers are unsafe&quot;) }
}</p>

<p>sub doit { my $self = shift; my $value = shift;
$self-&gt;check($value); # ... }</p>

<p>1;</p>

<p>package Derived;</p>

<p>use warnings::register; use Original; our @ISA = qw(
Original ); sub new { my $class = shift; bless [], $class;
}</p>

<p>1;</p>

<p>The code below makes use of both modules, but it only
enables warnings from &quot;Derived&quot;.</p>

<p>use Original; use Derived; use warnings Derived; my $a =
new Original; $a-&gt;doit(1); my $b = new Derived;
$a-&gt;doit(1);</p>

<p>When this code is run only the &quot;Derived&quot;
object, $b, will generate a warning.</p>

<p>Odd numbers are unsafe at main.pl line 7</p>

<p>Notice also that the warning is reported at the line
where the object is first used.</p>

<p>TODO perl5db.pl The debugger saves and restores
C&lt;$^W&gt; at runtime. I havent checked whether the
debugger will still work with the lexical warnings patch
applied.</p>

<p>diagnostics.pm I *think* Ive got diagnostics to work
with the lexical warnings patch, but there were design
decisions made in diagnostics to work around the limitations
of C&lt;$^W&gt;. Now that those limitations are gone, the
module should be revisited.</p>

<p>document calling the warnings::* functions from XS</p>

<p>SEE ALSO warnings, perldiag.</p>

<p>AUTHOR Paul Marquess</p>

<p>perl v5.8.8 2014-02-11 PERLLEXWARN(1)</p>
<hr>
</body>
</html>
