<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:21:22 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RENAME(2) Linux Programmer s Manual RENAME(2)</p>

<p>NAME rename - change the name or location of a file</p>

<p>SYNOPSIS #include &lt;stdio.h&gt;</p>

<p>int rename(const char *oldpath, const char
*newpath);</p>

<p>DESCRIPTION rename() renames a file, moving it between
directories if required.</p>

<p>Any other hard links to the file (as created using
link(2)) are unaf- fected.</p>

<p>If newpath already exists it will be atomically replaced
(subject to a few conditions; see ERRORS below), so that
there is no point at which another process attempting to
access newpath will find it missing.</p>

<p>If newpath exists but the operation fails for some
reason rename() guarantees to leave an instance of newpath
in place.</p>

<p>However, when overwriting there will probably be a
window in which both oldpath and newpath refer to the file
being renamed.</p>

<p>If oldpath refers to a symbolic link the link is
renamed; if newpath refers to a symbolic link the link will
be overwritten.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS EACCES Write permission is denied for the
directory containing oldpath or newpath, or, search
permission is denied for one of the directories in the path
prefix of oldpath or newpath, or oldpath is a directory and
does not allow write permission (needed to update the ..
entry). (See also path_resolution(2).)</p>

<p>EBUSY The rename fails because oldpath or newpath is a
directory that is in use by some process (perhaps as current
working directory, or as root directory, or because it was
open for reading) or is in use by the system (for example as
mount point), while the system considers this an error.
(Note that there is no require- ment to return EBUSY in such
cases there is nothing wrong with doing the rename anyway
but it is allowed to return EBUSY if the system cannot
otherwise handle such situations.)</p>

<p>EFAULT oldpath or newpath points outside your accessible
address space.</p>

<p>EINVAL The new pathname contained a path prefix of the
old, or, more generally, an attempt was made to make a
directory a subdirec- tory of itself.</p>

<p>EISDIR newpath is an existing directory, but oldpath is
not a direc- tory.</p>

<p>ELOOP Too many symbolic links were encountered in
resolving oldpath or newpath.</p>

<p>EMLINK oldpath already has the maximum number of links
to it, or it was a directory and the directory containing
newpath has the maximum number of links.</p>

<p>ENAMETOOLONG oldpath or newpath was too long.</p>

<p>ENOENT A directory component in oldpath or newpath does
not exist or is a dangling symbolic link.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ENOSPC The device containing the file has no room for
the new directory entry.</p>

<p>ENOTDIR A component used as a directory in oldpath or
newpath is not, in fact, a directory. Or, oldpath is a
directory, and newpath exists but is not a directory.</p>

<p>ENOTEMPTY or EEXIST newpath is a non-empty directory,
i.e., contains entries other than &quot;.&quot; and
&quot;..&quot;.</p>

<p>EPERM or EACCES The directory containing oldpath has the
sticky bit (S_ISVTX) set and the processs effective user ID
is neither the user ID of the file to be deleted nor that of
the directory containing it, and the process is not
privileged (Linux: does not have the CAP_FOWNER capability);
or newpath is an existing file and the directory containing
it has the sticky bit set and the processs effective user ID
is neither the user ID of the file to be replaced nor that
of the directory containing it, and the pro- cess is not
privileged (Linux: does not have the CAP_FOWNER capability);
or the filesystem containing pathname does not sup- port
renaming of the type requested.</p>

<p>EROFS The file is on a read-only filesystem.</p>

<p>EXDEV oldpath and newpath are not on the same mounted
filesystem. (Linux permits a filesystem to be mounted at
multiple points, but rename(2) does not work across
different mount points, even if the same filesystem is
mounted on both.)</p>

<p>CONFORMING TO 4.3BSD, C89, POSIX.1-2001.</p>

<p>BUGS On NFS filesystems, you can not assume that if the
operation failed the file was not renamed. If the server
does the rename operation and then crashes, the
retransmitted RPC which will be processed when the server is
up again causes a failure. The application is expected to
deal with this. See link(2) for a similar problem.</p>

<p>SEE ALSO mv(1), chmod(2), link(2), path_resolution(2),
renameat(2), symlink(2), unlink(2)</p>

<p>Linux 2.0 1998-06-04 RENAME(2)</p>
<hr>
</body>
</html>
