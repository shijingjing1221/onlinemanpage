<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:10:23 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>FLOCK(2) Linux Programmer s Manual FLOCK(2)</p>

<p>NAME flock - apply or remove an advisory lock on an open
file</p>

<p>SYNOPSIS #include &lt;sys/file.h&gt;</p>

<p>int flock(int fd, int operation);</p>

<p>DESCRIPTION Apply or remove an advisory lock on the open
file specified by fd. The parameter operation is one of the
following:</p>

<p>LOCK_SH Place a shared lock. More than one process may
hold a shared lock for a given file at a given time.</p>

<p>LOCK_EX Place an exclusive lock. Only one process may
hold an exclusive lock for a given file at a given time.</p>

<p>LOCK_UN Remove an existing lock held by this
process.</p>

<p>A call to flock() may block if an incompatible lock is
held by another process. To make a non-blocking request,
include LOCK_NB (by ORing) with any of the above
operations.</p>

<p>A single file may not simultaneously have both shared
and exclusive locks.</p>

<p>Locks created by flock() are associated with an open
file table entry. This means that duplicate file descriptors
(created by, for example, fork(2) or dup(2)) refer to the
same lock, and this lock may be modi- fied or released using
any of these descriptors. Furthermore, the lock is released
either by an explicit LOCK_UN operation on any of these
duplicate descriptors, or when all such descriptors have
been closed.</p>

<p>If a process uses open(2) (or similar) to obtain more
than one descrip- tor for the same file, these descriptors
are treated independently by flock(). An attempt to lock the
file using one of these file descrip- tors may be denied by
a lock that the calling process has already placed via
another descriptor.</p>

<p>A process may only hold one type of lock (shared or
exclusive) on a file. Subsequent flock() calls on an already
locked file will convert an existing lock to the new lock
mode.</p>

<p>Locks created by flock() are preserved across an
execve(2).</p>

<p>A shared or exclusive lock can be placed on a file
regardless of the mode in which the file was opened.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS EBADF fd is not a not an open file
descriptor.</p>

<p>EINTR While waiting to acquire a lock, the call was
interrupted by delivery of a signal caught by a handler.</p>

<p>EINVAL operation is invalid.</p>

<p>ENOLCK The kernel ran out of memory for allocating lock
records.</p>

<p>EWOULDBLOCK The file is locked and the LOCK_NB flag was
selected.</p>

<p>CONFORMING TO 4.4BSD (the flock(2) call first appeared
in 4.2BSD). A version of flock(2), possibly implemented in
terms of fcntl(2), appears on most Unices.</p>

<p>NOTES flock(2) does not lock files over NFS. Use
fcntl(2) instead: that does work over NFS, given a
sufficiently recent version of Linux and a server which
supports locking.</p>

<p>Since kernel 2.0, flock(2) is implemented as a system
call in its own right rather than being emulated in the GNU
C library as a call to fcntl(2). This yields true BSD
semantics: there is no interaction between the types of lock
placed by flock(2) and fcntl(2), and flock(2) does not
detect deadlock.</p>

<p>flock(2) places advisory locks only; given suitable
permissions on a file, a process is free to ignore the use
of flock(2) and perform I/O on the file.</p>

<p>flock(2) and fcntl(2) locks have different semantics
with respect to forked processes and dup(2). On systems that
implement flock() using fcntl(), the semantics of flock()
will be different from those described in this manual
page.</p>

<p>Converting a lock (shared to exclusive, or vice versa)
is not guaran- teed to be atomic: the existing lock is first
removed, and then a new lock is established. Between these
two steps, a pending lock request by another process may be
granted, with the result that the conversion either blocks,
or fails if LOCK_NB was specified. (This is the origi- nal
BSD behaviour, and occurs on many other
implementations.)</p>

<p>SEE ALSO close(2), dup(2), execve(2), fcntl(2), fork(2),
open(2), lockf(3)</p>

<p>There are also locks.txt and mandatory.txt in
/usr/share/doc/kernel- doc-2.6.18/Documentation.</p>

<p>Linux 2002-04-24 FLOCK(2)</p>
<hr>
</body>
</html>
