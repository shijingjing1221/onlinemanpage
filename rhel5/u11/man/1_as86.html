<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:06:17 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>as86(1) as86(1)</p>

<p>NAME as86 - Assembler for 8086..80386 processors</p>

<p>SYNOPSIS as86 [-0123agjuw] [-lm[list]] [-n name] [-o
obj] [-b[bin]] [-s sym] [-t textseg] src</p>

<p>as86_encap prog.s prog.v [prefix_] [as86_options]</p>

<p>DESCRIPTION as86 is an assembler for the 8086..80386
processors, its syntax is closer to the intel/microsoft form
rather than the more normal generic form of the unix system
assembler.</p>

<p>The src file can be - to assemble the standard
input.</p>

<p>This assembler can be compiled to support the 6809 cpu
and may even work.</p>

<p>as86_encap is a shell script to call as86 and convert
the created binary into a C file prog.v to be included in or
linked with programs like boot block installers. The prefix_
argument is a prefix to be added to all variables defined by
the source, it defaults to the name of the source file. The
variables defined include prefix_start prefix_size and
prefix_data to define and contain the code, plus integers
containing the values of all exported labels. Either or both
the prog.s and prog.v arguments can be - for standard
in/out.</p>

<p>OPTIONS -0 start with 16-bit code segment, warn for all
instructions &gt; 8086</p>

<p>-1 start with 16-bit code segment, warn for all
instructions &gt; 80186</p>

<p>-2 start with 16-bit code segment, warn for all
instructions &gt; 80286</p>

<p>-3 start with 32-bit code segment, dont warn for any
instructions. (not even 486 or 586)</p>

<p>-a enable partial compatibility with Minix asld. This
swaps the interpretation of round brackets and square
brackets as well as making alterations to the code
generation and syntax for 16bit jumps and calls. (&quot;jmp
@(bx)&quot; is then a valid instruction)</p>

<p>-g only put global symbols in object or symbol file</p>

<p>-j replace all short jumps with similar 16 or 32 bit
jumps, the 16 bit conditional branches are encoded as a
short conditional and a long unconditional branch.</p>

<p>-O this causes the assembler to add extra passes to try
to use forward references to reduce the bytes needed for
some instructions. If the labels move on the last pass the
assembler will keep adding passes until the labels all
stabilise (to a maximum of 30 passes) Its probably not a
good idea to use this with hand written assembler use the
explicit br bmi bcc style opcodes for 8086 code or the jmp
near style for conditional i386 instructions and make sure
all variables are defined before they are used.</p>

<p>-l produce list file, filename may follow</p>

<p>-m print macro expansions in listing</p>

<p>-n name of module follows (goes in object instead of
source name)</p>

<p>-o produce object file, filename follows</p>

<p>-b produce a raw binary file, filename may follow. This
is a raw binary file with no header, if there s no -s option
the file starts at location 0.</p>

<p>-s produce an ASCII symbol file, filename follows. The
format of this table is designed to be easy to parse for
encapsulation and related activities in relation to binary
files created with the -b option. If a binary file doesn t
start at location zero the first two items in the table are
the start and end addresses of the binary file.</p>

<p>-u assume undefined symbols are
imported-with-unspecified segment.</p>

<p>-w- allow the assembler to print warning messages.</p>

<p>-t n move all text segment data in segment n+3.</p>

<p>AS86 SOURCE Special characters</p>

<p>* Address of the start of the current line.</p>

<p>; ! Either of these marks the start of a comment. In
addition any unexpected character at the start of a line is
assumed to be a comment (but its also displayed to the
terminal).</p>

<p>$ Prefix for hexadecimal numbers, the C syntax, eg
0x1234, is also accepted.</p>

<p>% Prefix for binary numbers.</p>

<p># Prefix for immediate operands.</p>

<p>[ ] Specifies an indirect operand. Unlike MASM the
assembler has no type information on labels just a segment
and offset. This means that the way this operator and the
immediate prefix work are like traditional assemblers.</p>

<p>Examples: mov ax,bx jmp bx Direct register addressing,
the jump copies BX into PC.</p>

<p>mov ax,[bx] jmp [bx] Simple indirect register
addressing, the jump moves the contents of the location
specified by BX into the PC.</p>

<p>mov ax,#1234 Immediate value, ax becomes 1234.</p>

<p>mov ax,1234 mov ax,_hello mov ax,[_hello] Absolute
addressing, ax is set to contents of location 1234. Note the
third option is not strictly consistant but is in place
mainly for asld compatibility.</p>

<p>mov ax,_table[bx] mov ax,_table[bx+si] mov
eax,_table[ebx*4]</p>

<p>mov ax,[bx+_table] mov ax,[bx+si+_table] mov
eax,[ebx*4+_table] Indexed addressing, both formats are ok,
I think the first is more correct but I tend to used the
second. :-)</p>

<p>Conditionals</p>

<p>IF, ELSE, ELSEIF, ENDIF Numeric condition</p>

<p>IFC, ELSEIFC String compare (str1,str2)</p>

<p>FAIL .FAIL Generate user error.</p>

<p>Segment related</p>

<p>.TEXT .ROM .DATA .BSS Set current segment. These can be
preceded by the keyword .SECT</p>

<p>LOC Set numeric segment 0=TEXT, 3=DATA,ROM,BSS, 14=MAX.
The segment order set by the linker is now
0,4,5,6,7,8,9,A,B,C,D,E,1,2,3. Segment 0 and all segments
above 3 are assumed to be text segment. Note the 64k size
restrictions are not imposed for segments 3-14.</p>

<p>Label type definition</p>

<p>EXPORT PUBLIC .DEFINE Export label defined in this
object</p>

<p>ENTRY Force linker to include the specified label in
a.out</p>

<p>.GLOBL .GLOBAL Define label as external and force import
even if it isnt used.</p>

<p>EXTRN EXTERN IMPORT .EXTERN Import list of externally
defined labels NB: It doesn t make sense to use imports for
raw binary files.</p>

<p>.ENTER Mark entry for old binary file (obs)</p>

<p>Data definition</p>

<p>DB .DATA1 .BYTE FCB List of 1 byte objects.</p>

<p>DW .DATA2 .SHORT FDB .WORD List of 2 byte objects.</p>

<p>DD .DATA4 .LONG List of 4 byte objects.</p>

<p>.ASCII FCC Ascii string copied to output.</p>

<p>.ASCIZ Ascii string copied to output with trailing nul
byte.</p>

<p>Space definition</p>

<p>.BLKB RMB .SPACE Space is counted in bytes.</p>

<p>.BLKW .ZEROW Space is counted in words. (2 bytes
each)</p>

<p>COMM .COMM LCOMM .LCOMM Common area data definition</p>

<p>Other useful pseudo operations.</p>

<p>.ALIGN .EVEN Alignment</p>

<p>EQU Define label</p>

<p>SET Define re-definable label</p>

<p>ORG .ORG Set assemble location</p>

<p>BLOCK Set assemble location and stack old one</p>

<p>ENDB Return to stacked assemble location</p>

<p>GET INCLUDE Insert new file (no quotes on name)</p>

<p>USE16 [cpu] Define default operand size as 16 bit,
argument is cpu type the code is expected to run on (86,
186, 286, 386, 486, 586) instructions for cpus later than
specified give a warning.</p>

<p>USE32 [cpu] Define default operand size as 32 bit,
argument is cpu type the code is expected to run on (86,
186, 286, 386, 486, 586) instructions for cpus later than
specified give a warning. If the cpu is not mentioned the
assembler ensures it is &gt;= 80386.</p>

<p>END End of compilation for this file.</p>

<p>.WARN Switch warnings</p>

<p>.LIST Listings on/off (1,-1)</p>

<p>.MACLIST Macro listings on/off (1,-1)</p>

<p>Macros, now working, the general form is like this.</p>

<p>MACRO sax mov ax,#?1 MEND sax(1)</p>

<p>Unimplemented/unused.</p>

<p>IDENT Define object identity string.</p>

<p>SETDP Set DP value on 6809</p>

<p>MAP Set binary symbol table map number.</p>

<p>Registers BP BX DI SI EAX EBP EBX ECX EDI EDX ESI ESP AX
CX DX SP AH AL BH BL CH CL DH DL CS DS ES FS GS SS CR0 CR2
CR3 DR0 DR1 DR2 DR3 DR6 DR7 TR3 TR4 TR5 TR6 TR7 ST</p>

<p>Operand type specifiers BYTE DWORD FWORD FAR PTR PWORD
QWORD TBYTE WORD NEAR</p>

<p>The near and far do not allow multi-segment programming,
all far operations are specified explicitly through the use
of the instructions: jmpi, jmpf, callf, retf, etc. The Near
operator can be used to force the use of 80386 16bit
conditional branches. The Dword and word operators can
control the size of operands on far jumps and calls.</p>

<p>General instructions. These are in general the same as
the instructions found in any 8086 assembler, the main
exceptions being a few Bcc (BCC, BNE, BGE, etc) instructions
which are shorthands for a short branch plus a long jump and
BR which is the longest unconditional jump (16 or 32
bit).</p>

<p>Long branches BCC BCS BEQ BGE BGT BHI BHIS BLE BLO BLOS
BLT BMI BNE BPC BPL BPS BVC BVS BR</p>

<p>Intersegment CALLI CALLF JMPI JMPF</p>

<p>Segment modifier instructions ESEG FSEG GSEG SSEG</p>

<p>Byte operation instructions ADCB ADDB ANDB CMPB DECB
DIVB IDIVB IMULB INB INCB MOVB MULB NEGB NOTB ORB OUTB RCLB
RCRB ROLB RORB SALB SARB SHLB SHRB SBBB SUBB TESTB XCHGB
XORB</p>

<p>Standard instructions AAA AAD AAM AAS ADC ADD AND ARPL
BOUND BSF BSR BSWAP BT BTC BTR BTS CALL CBW CDQ CLC CLD CLI
CLTS CMC CMP CMPS CMPSB CMPSD CMPSW CMPW CMPXCHG CSEG CWD
CWDE DAA DAS DEC DIV DSEG ENTER HLT IDIV IMUL IN INC INS
INSB INSD INSW INT INTO INVD INVLPG INW IRET IRETD J JA JAE
JB JBE JC JCXE JCXZ JE JECXE JECXZ JG JGE JL JLE JMP JNA
JNAE JNB JNBE JNC JNE JNG JNGE JNL JNLE JNO JNP JNS JNZ JO
JP JPE JPO JS JZ LAHF LAR LDS LEA LEAVE LES LFS LGDT LGS
LIDT LLDT LMSW LOCK LODB LODS LODSB LODSD LODSW LODW LOOP
LOOPE LOOPNE LOOPNZ LOOPZ LSL LSS LTR MOV MOVS MOVSB MOVSD
MOVSW MOVSX MOVW MOVZX MUL NEG NOP NOT OR OUT OUTS OUTSB
OUTSD OUTSW OUTW POP POPA POPAD POPF POPFD PUSH PUSHA PUSHAD
PUSHF PUSHFD RCL RCR RDMSR REP REPE REPNE REPNZ REPZ RET
RETF RETI ROL ROR SAHF SAL SAR SBB SCAB SCAS SCASB SCASD
SCASW SCAW SEG SETA SETAE SETB SETBE SETC SETE SETG SETGE
SETL SETLE SETNA SETNAE SETNB SETNBE SETNC SETNE SETNG
SETNGE SETNL SETNLE SETNO SETNP SETNS SETNZ SETO SETP SETPE
SETPO SETS SETZ SGDT SHL SHLD SHR SHRD SIDT SLDT SMSW STC
STD STI STOB STOS STOSB STOSD STOSW STOW STR SUB TEST VERR
VERW WAIT WBINVD WRMSR XADD XCHG XLAT XLATB XOR</p>

<p>Floating point F2XM1 FABS FADD FADDP FBLD FBSTP FCHS
FCLEX FCOM FCOMP FCOMPP FCOS FDECSTP FDISI FDIV FDIVP FDIVR
FDIVRP FENI FFREE FIADD FICOM FICOMP FIDIV FIDIVR FILD FIMUL
FINCSTP FINIT FIST FISTP FISUB FISUBR FLD FLD1 FLDL2E FLDL2T
FLDCW FLDENV FLDLG2 FLDLN2 FLDPI FLDZ FMUL FMULP FNCLEX
FNDISI FNENI FNINIT FNOP FNSAVE FNSTCW FNSTENV FNSTSW FPATAN
FPREM FPREM1 FPTAN FRNDINT FRSTOR FSAVE FSCALE FSETPM FSIN
FSINCOS FSQRT FST FSTCW FSTENV FSTP FSTSW FSUB FSUBP FSUBR
FSUBRP FTST FUCOM FUCOMP FUCOMPP FWAIT FXAM FXCH FXTRACT
FYL2X FYL2XP1</p>

<p>Using GASP The Gnu assembler preprocessor provides some
reasonable implementations of user biased pseudo
opcodes.</p>

<p>It can be invoked in a form similar to:</p>

<p>gasp [-a...] file.s [file2.s] | as86 [...] - [-o obj]
[-b bin]</p>

<p>Be aware though that Gasp generates an error for .org
commands, if you re not using alternate syntax you can use
org instead, otherwise use block and endb. The directive
export is translated into .global, which forces an import,
if you are making a file using -b use public or .define
instead.</p>

<p>The GASP list options have no support in as86.</p>

<p>SEE ALSO as(1), ld86(1), bcc(1)</p>

<p>BUGS The 6809 version does not support -0, -3, -a or
-j.</p>

<p>If this assembler is compiled with BCC this is classed
as a small compiler, so there is a maximum input line length
of 256 characters and the instruction to cpu checking is not
included.</p>

<p>The checking for instructions that work on specific cpus
is probably not complete, the distinction between 80186 and
80286 is especially problematic.</p>

<p>The .text and .data pseudo operators are not useful for
raw binary files.</p>

<p>When using the org directive the assembler can generate
object files that may break ld86(1).</p>

<p>Mar, 1999 as86(1)</p>
<hr>
</body>
</html>
