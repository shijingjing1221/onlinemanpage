<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:15:01 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>libsensors(3) Linux Programmer s Manual
libsensors(3)</p>

<p>NAME libsensors - publicly accessible functions provided
by the sensors library</p>

<p>SYNOPSIS #include &lt;sensors/sensors.h&gt;</p>

<p>int sensors_init(FILE *input); void
sensors_cleanup(void); int sensors_parse_chip_name(const
char *orig_name, sensors_chip_name *res); int
sensors_match_chip(sensors_chip_name chip1,
sensors_chip_name chip2); int
sensors_chip_name_has_wildcards(sensors_chip_name chip);
const char *sensors_get_adapter_name(int bus_nr); int
sensors_get_label(sensors_chip_name name, int feature, char
**result); int sensors_get_feature(sensors_chip_name name,
int feature, double *result); int
sensors_set_feature(sensors_chip_name name, int feature,
double value); int sensors_do_chip_sets(sensors_chip_name
name); extern int sensors_do_all_sets(void); const
sensors_chip_name *sensors_get_detected_chips(int *nr);
const sensors_feature_data *sensors_get_all_features
(sensors_chip_name name, int *nr1,int *nr2);</p>

<p>DESCRIPTION int sensors_init(FILE *input); (Re)load the
configuration file and the detected chips list. If this
returns a value unequal to zero, you are in trouble; you can
not assume anything will be initialized properly.</p>

<p>void sensors_cleanup(void); Clean-up function: You cant
access anything after this, until the next sensors_init()
call!</p>

<p>int sensors_parse_chip_name(const char *orig_name,
sensors_chip_name *res); Parse a chip name to the internal
representation. Return 0 on succes, &lt;0 on error.</p>

<p>int sensors_match_chip(sensors_chip_name chip1,
sensors_chip_name chip2); Compare two chips name
descriptions, to see whether they could match. Return 0 if
it does not match, return 1 if it does match.</p>

<p>int sensors_chip_name_has_wildcards (sensors_chip_name
chip); Check whether the chip name is an absolute name,
which can only match one chip, or whether it has wildcards.
Returns 0 if it is absolute, 1 if there are wildcards.</p>

<p>const char *sensors_get_adapter_name(int bus_nr); This
function returns the adapter name of a bus number, as used
within the sensors_chip_name structure. If it could not be
found, it returns NULL.</p>

<p>const char *sensors_get_algorithm_name(int bus_nr); This
function used to return the algorithm name of a bus number.
It is now deprecated and returns an arbitrary string. It
will be dropped in a later version of the library so you
should stop using it.</p>

<p>int sensors_get_label(sensors_chip_name name, int
feature, char **result); Look up the label which belongs to
this chip. Note that chip should not contain wildcard
values! *result is newly allocated (free it yourself). This
function will return 0 on success, and &lt;0 on failure.</p>

<p>int sensors_get_feature(sensors_chip_name name, int
feature, double *result); Read the value of a feature of a
certain chip. Note that chip should not contain wildcard
values! This function will return 0 on success, and &lt;0 on
failure.</p>

<p>int sensors_set_feature(sensors_chip_name name, int
feature, double value); Set the value of a feature of a
certain chip. Note that chip should not contain wildcard
values! This function will return 0 on success, and &lt;0 on
failure.</p>

<p>int sensors_do_chip_sets(sensors_chip_name name);
Execute all set statements for this particular chip. The
chip may con- tain wildcards! This function will return 0 on
success, and &lt;0 on failure.</p>

<p>int sensors_do_all_sets(void); Execute all set
statements for all detected chips. This is the same as
calling sensors_do_chip_sets with an all wildcards chip
name</p>

<p>const sensors_chip_name *sensors_get_detected_chips (int
*nr); This function returns all detected chips, one by one.
To start at the beginning of the list, use 0 for nr; NULL is
returned if we are at the end of the list. Do not try to
change these chip names, as they point to internal
structures! Do not use nr for anything else.</p>

<p>This structure is used when you want to get all features
of a specific chip. typedef struct sensors_feature_data {
int number; const char *name; int mapping; int unused; int
mode; } sensors_feature_data; The mode field can be one of:
SENSORS_MODE_NO_RW, SENSORS_MODE_R, SENSORS_MODE_W or
SENSORS_MODE_RW.</p>

<p>const sensors_feature_data *sensors_get_all_features
(sensors_chip_name name, int *nr1,int *nr2); This returns
all features of a specific chip. They are returned in
bunches: everything with the same mapping is returned just
after each other, with the master feature in front (that
feature does not map to itself, but has SENSORS_NO_MAPPING
as mapping field). nr1 and nr2 are two internally used
variables. Set both to zero to start again at the begin of
the list. If no more features are found NULL is returned. Do
not try to change the returned structure; you will corrupt
internal data structures.</p>

<p>CONFORMING TO lm_sensors-2.x</p>

<p>SEE ALSO sensors.conf(5)</p>

<p>AUTHOR Frodo Looijaard and the lm_sensors group
http://www.lm-sensors.org/</p>

<p>October 2006 libsensors(3)</p>
<hr>
</body>
</html>
