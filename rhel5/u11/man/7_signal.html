<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:23:16 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SIGNAL(7) Linux Programmer s Manual SIGNAL(7)</p>

<p>NAME signal - list of available signals</p>

<p>DESCRIPTION Linux supports both POSIX reliable signals
(hereinafter &quot;standard sig- nals&quot;) and POSIX
real-time signals.</p>

<p>Signal Dispositions Each signal has a current
disposition, which determines how the process behaves when
it is delivered the signal.</p>

<p>The entries in the &quot;Action&quot; column of the
tables below specify the default disposition for each
signal, as follows:</p>

<p>Term Default action is to terminate the process.</p>

<p>Ign Default action is to ignore the signal.</p>

<p>Core Default action is to terminate the process and dump
core (see core(5)).</p>

<p>Stop Default action is to stop the process.</p>

<p>Cont Default action is to continue the process if it is
currently stopped.</p>

<p>A process can change the disposition of a signal using
sigaction(2) or (less portably) signal(2). Using these
system calls, a process can elect one of the following
behaviours to occur on delivery of the sig- nal: perform the
default action; ignore the signal; or catch the signal with
a signal handler, a programmer-defined function that is
automati- cally invoked when the signal is delivered.</p>

<p>The signal disposition is a per-process attribute: in a
multithreaded application, the disposition of a particular
signal is the same for all threads.</p>

<p>Signal Mask and Pending Signals A signal may be blocked,
which means that it will not be delivered until it is later
unblocked. Between the time when it is generated and when it
is delivered a signal is said to be pending.</p>

<p>Each thread in a process has an independent signal mask,
which indi- cates the set of signals that the thread is
currently blocking. A thread can manipulate its signal mask
using pthread_sigmask(3). In a traditional single-threaded
application, sigprocmask(2) can be used to manipulate the
signal mask.</p>

<p>A signal may be generated (and thus pending) for a
process as a whole (e.g., when sent using kill(2)) or for a
specific thread (e.g., certain signals, such as SIGSEGV and
SIGFPE, generated as a consequence of exe- cuting a specific
machine-language instruction are thread directed, as are
signals targeted at a specific thread using
pthread_kill(2)). A process-directed signal may be delivered
to any one of the threads that does not currently have the
signal blocked. If more than one of the threads has the
signal unblocked, then the kernel chooses an arbitrary
thread to which to deliver the signal.</p>

<p>A thread can obtain the set of signals that it currently
has pending using sigpending(2). This set will consist of
the union of the set of pending process-directed signals and
the set of signals pending for the calling thread.</p>

<p>Standard Signals Linux supports the standard signals
listed below. Several signal num- bers are architecture
dependent, as indicated in the &quot;Value&quot; column.
(Where three values are given, the first one is usually
valid for alpha and sparc, the middle one for i386, ppc and
sh, and the last one for mips. A - denotes that a signal is
absent on the corresponding archi- tecture.)</p>

<p>First the signals described in the original POSIX.1-1990
standard.</p>

<p>Signal Value Action Comment
-------------------------------------------------------------------------
SIGHUP 1 Term Hangup detected on controlling terminal or
death of controlling process SIGINT 2 Term Interrupt from
keyboard SIGQUIT 3 Core Quit from keyboard SIGILL 4 Core
Illegal Instruction SIGABRT 6 Core Abort signal from
abort(3) SIGFPE 8 Core Floating point exception SIGKILL 9
Term Kill signal SIGSEGV 11 Core Invalid memory reference
SIGPIPE 13 Term Broken pipe: write to pipe with no readers
SIGALRM 14 Term Timer signal from alarm(2) SIGTERM 15 Term
Termination signal SIGUSR1 30,10,16 Term User-defined signal
1 SIGUSR2 31,12,17 Term User-defined signal 2 SIGCHLD
20,17,18 Ign Child stopped or terminated SIGCONT 19,18,25
Cont Continue if stopped SIGSTOP 17,19,23 Stop Stop process
SIGTSTP 18,20,24 Stop Stop typed at tty SIGTTIN 21,21,26
Stop tty input for background process SIGTTOU 22,22,27 Stop
tty output for background process</p>

<p>The signals SIGKILL and SIGSTOP cannot be caught,
blocked, or ignored.</p>

<p>Next the signals not in the POSIX.1-1990 standard but
described in SUSv2 and POSIX.1-2001.</p>

<p>Signal Value Action Comment
-------------------------------------------------------------------------
SIGBUS 10,7,10 Core Bus error (bad memory access) SIGPOLL
Term Pollable event (Sys V). Synonym of SIGIO SIGPROF
27,27,29 Term Profiling timer expired SIGSYS 12,-,12 Core
Bad argument to routine (SVr4) SIGTRAP 5 Core
Trace/breakpoint trap SIGURG 16,23,21 Ign Urgent condition
on socket (4.2BSD) SIGVTALRM 26,26,28 Term Virtual alarm
clock (4.2BSD) SIGXCPU 24,24,30 Core CPU time limit exceeded
(4.2BSD) SIGXFSZ 25,25,31 Core File size limit exceeded
(4.2BSD)</p>

<p>Up to and including Linux 2.2, the default behaviour for
SIGSYS, SIGX- CPU, SIGXFSZ, and (on architectures other than
SPARC and MIPS) SIGBUS was to terminate the process (without
a core dump). (On some other Unices the default action for
SIGXCPU and SIGXFSZ is to terminate the process without a
core dump.) Linux 2.4 conforms to the POSIX.1-2001
requirements for these signals, terminating the process with
a core dump.</p>

<p>Next various other signals.</p>

<p>Signal Value Action Comment
--------------------------------------------------------------------
SIGIOT 6 Core IOT trap. A synonym for SIGABRT SIGEMT 7,-,7
Term</p>

<p>SIGSTKFLT -,16,- Term Stack fault on coprocessor
(unused) SIGIO 23,29,22 Term I/O now possible (4.2BSD)
SIGCLD -,-,18 Ign A synonym for SIGCHLD SIGPWR 29,30,19 Term
Power failure (System V) SIGINFO 29,-,- A synonym for SIGPWR
SIGLOST -,-,- Term File lock lost SIGWINCH 28,28,20 Ign
Window resize signal (4.3BSD, Sun) SIGUNUSED -,31,- Term
Unused signal (will be SIGSYS)</p>

<p>(Signal 29 is SIGINFO / SIGPWR on an alpha but SIGLOST
on a sparc.)</p>

<p>SIGEMT is not specified in POSIX.1-2001, but
nevertheless appears on most other Unices, where its default
action is typically to terminate the process with a core
dump.</p>

<p>SIGPWR (which is not specified in POSIX.1-2001) is
typically ignored by default on those other Unices where it
appears.</p>

<p>SIGIO (which is not specified in POSIX.1-2001) is
ignored by default on several other Unices.</p>

<p>Real-time Signals Linux supports real-time signals as
originally defined in the POSIX.1b real-time extensions (and
now included in POSIX.1-2001). Linux sup- ports 32 real-time
signals, numbered from 32 (SIGRTMIN) to 63 (SIGRT- MAX).
(Programs should always refer to real-time signals using
nota- tion SIGRTMIN+n, since the range of real-time signal
numbers varies across Unices.)</p>

<p>Unlike standard signals, real-time signals have no
predefined meanings: the entire set of real-time signals can
be used for application-defined purposes. (Note, however,
that the LinuxThreads implementation uses the first three
real-time signals.)</p>

<p>The default action for an unhandled real-time signal is
to terminate the receiving process.</p>

<p>Real-time signals are distinguished by the
following:</p>

<p>1. Multiple instances of real-time signals can be
queued. By con- trast, if multiple instances of a standard
signal are delivered while that signal is currently blocked,
then only one instance is queued.</p>

<p>2. If the signal is sent using sigqueue(2), an
accompanying value (either an integer or a pointer) can be
sent with the signal. If the receiving process establishes a
handler for this signal using the SA_SIGINFO flag to
sigaction(2) then it can obtain this data via the si_value
field of the siginfo_t structure passed as the second
argument to the handler. Furthermore, the si_pid and si_uid
fields of this structure can be used to obtain the PID and
real user ID of the process sending the signal.</p>

<p>3. Real-time signals are delivered in a guaranteed
order. Multiple real-time signals of the same type are
delivered in the order they were sent. If different
real-time signals are sent to a process, they are delivered
starting with the lowest-numbered signal. (I.e.,
low-numbered signals have highest priority.)</p>

<p>If both standard and real-time signals are pending for a
process, POSIX leaves it unspecified which is delivered
first. Linux, like many other implementations, gives
priority to standard signals in this case.</p>

<p>According to POSIX, an implementation should permit at
least _POSIX_SIGQUEUE_MAX (32) real-time signals to be
queued to a process. However, Linux does things differently.
In kernels up to and including 2.6.7, Linux imposes a
system-wide limit on the number of queued real- time signals
for all processes. This limit can be viewed and (with
privilege) changed via the /proc/sys/kernel/rtsig-max file.
A related file, /proc/sys/kernel/rtsig-nr, can be used to
find out how many real- time signals are currently queued.
In Linux 2.6.8, these /proc inter- faces were replaced by
the RLIMIT_SIGPENDING resource limit, which specifies a
per-user limit for queued signals; see setrlimit(2) for
further details.</p>

<p>CONFORMING TO POSIX.1</p>

<p>BUGS SIGIO and SIGLOST have the same value. The latter
is commented out in the kernel source, but the build process
of some software still thinks that signal 29 is SIGLOST.</p>

<p>SEE ALSO kill(1), kill(2), killpg(2), setitimer(2),
setrlimit(2), sigaction(2), signal(2), sigpending(2),
sigprocmask(2), sigqueue(2), sigsuspend(2), sigwaitinfo(2),
raise(3), sigvec(3), sigset(3), strsignal(3), core(5),
proc(5), pthreads(7)</p>

<p>Linux 2.4.18 2002-06-13 SIGNAL(7)</p>
<hr>
</body>
</html>
