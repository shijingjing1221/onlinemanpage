<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:21:14 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RECV(2) Linux Programmer s Manual RECV(2)</p>

<p>NAME recv, recvfrom, recvmsg - receive a message from a
socket</p>

<p>SYNOPSIS #include &lt;sys/types.h&gt; #include
&lt;sys/socket.h&gt;</p>

<p>ssize_t recv(int s, void *buf, size_t len, int
flags);</p>

<p>ssize_t recvfrom(int s, void *buf, size_t len, int
flags, struct sockaddr *from, socklen_t *fromlen);</p>

<p>ssize_t recvmsg(int s, struct msghdr *msg, int
flags);</p>

<p>DESCRIPTION The recvfrom() and recvmsg() calls are used
to receive messages from a socket, and may be used to
receive data on a socket whether or not it is
connection-oriented.</p>

<p>If from is not NULL, and the underlying protocol
provides the source address, this source address is filled
in. The argument fromlen is a value-result parameter,
initialized to the size of the buffer associ- ated with
from, and modified on return to indicate the actual size of
the address stored there.</p>

<p>The recv() call is normally used only on a connected
socket (see con- nect(2)) and is identical to recvfrom()
with a NULL from parameter.</p>

<p>All three routines return the length of the message on
successful com- pletion. If a message is too long to fit in
the supplied buffer, excess bytes may be discarded depending
on the type of socket the mes- sage is received from.</p>

<p>If no messages are available at the socket, the receive
calls wait for a message to arrive, unless the socket is
nonblocking (see fcntl(2)), in which case the value -1 is
returned and the external variable errno set to EAGAIN. The
receive calls normally return any data available, up to the
requested amount, rather than waiting for receipt of the
full amount requested.</p>

<p>The select(2) or poll(2) call may be used to determine
when more data arrives.</p>

<p>The flags argument to a recv() call is formed by OR ing
one or more of the following values:</p>

<p>MSG_DONTWAIT Enables non-blocking operation; if the
operation would block, EAGAIN is returned (this can also be
enabled using the O_NON- BLOCK with the F_SETFL
fcntl(2)).</p>

<p>MSG_ERRQUEUE This flag specifies that queued errors
should be received from the socket error queue. The error is
passed in an ancillary message with a type dependent on the
protocol (for IPv4 IP_RECVERR). The user should supply a
buffer of sufficient size. See cmsg(3) and ip(7) for more
information. The payload of the original packet that caused
the error is passed as normal data via msg_iovec. The
original destination address of the datagram that caused the
error is supplied via msg_name.</p>

<p>For local errors, no address is passed (this can be
checked with the cmsg_len member of the cmsghdr). For error
receives, the MSG_ERRQUEUE is set in the msghdr. After an
error has been passed, the pending socket error is
regenerated based on the next queued error and will be
passed on the next socket opera- tion.</p>

<p>The error is supplied in a sock_extended_err
structure:</p>

<p>#define SO_EE_ORIGIN_NONE 0 #define SO_EE_ORIGIN_LOCAL 1
#define SO_EE_ORIGIN_ICMP 2 #define SO_EE_ORIGIN_ICMP6 3</p>

<p>struct sock_extended_err { u_int32_t ee_errno; /* error
number */ u_int8_t ee_origin; /* where the error originated
*/ u_int8_t ee_type; /* type */ u_int8_t ee_code; /* code */
u_int8_t ee_pad; u_int32_t ee_info; /* additional
information */ u_int32_t ee_data; /* other data */ /* More
data may follow */ };</p>

<p>struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err
*);</p>

<p>ee_errno contains the errno number of the queued error.
ee_ori- gin is the origin code of where the error
originated. The other fields are protocol specific. The
macro SOCK_EE_OFFENDER returns a pointer to the address of
the network object where the error originated from given a
pointer to the ancillary message. If this address is not
known, the sa_family member of the sockaddr contains
AF_UNSPEC and the other fields of the sockaddr are
undefined. The payload of the packet that caused the error
is passed as normal data.</p>

<p>For local errors, no address is passed (this can be
checked with the cmsg_len member of the cmsghdr). For error
receives, the MSG_ERRQUEUE is set in the msghdr. After an
error has been passed, the pending socket error is
regenerated based on the next queued error and will be
passed on the next socket opera- tion.</p>

<p>MSG_OOB This flag requests receipt of out-of-band data
that would not be received in the normal data stream. Some
protocols place expe- dited data at the head of the normal
data queue, and thus this flag cannot be used with such
protocols.</p>

<p>MSG_PEEK This flag causes the receive operation to
return data from the beginning of the receive queue without
removing that data from the queue. Thus, a subsequent
receive call will return the same data.</p>

<p>MSG_TRUNC Return the real length of the packet, even
when it was longer than the passed buffer. Only valid for
packet sockets.</p>

<p>MSG_WAITALL This flag requests that the operation block
until the full request is satisfied. However, the call may
still return less data than requested if a signal is caught,
an error or discon- nect occurs, or the next data to be
received is of a different type than that returned.</p>

<p>The recvmsg() call uses a msghdr structure to minimize
the number of directly supplied parameters. This structure
has the following form, as defined in
&lt;sys/socket.h&gt;:</p>

<p>struct msghdr { void *msg_name; /* optional address */
socklen_t msg_namelen; /* size of address */ struct iovec
*msg_iov; /* scatter/gather array */ size_t msg_iovlen; /* #
elements in msg_iov */ void *msg_control; /* ancillary data,
see below */ socklen_t msg_controllen; /* ancillary data
buffer len */ int msg_flags; /* flags on received message */
};</p>

<p>Here msg_name and msg_namelen specify the source address
if the socket is unconnected; msg_name may be given as a
null pointer if no names are desired or required. The fields
msg_iov and msg_iovlen describe scat- ter-gather locations,
as discussed in readv(2). The field msg_control, which has
length msg_controllen, points to a buffer for other protocol
control related messages or miscellaneous ancillary data.
When recvmsg() is called, msg_controllen should contain the
length of the available buffer in msg_control; upon return
from a successful call it will contain the length of the
control message sequence.</p>

<p>The messages are of the form:</p>

<p>struct cmsghdr { socklen_t cmsg_len; /* data byte count,
including hdr */ int cmsg_level; /* originating protocol */
int cmsg_type; /* protocol-specific type */ /* followed by
u_char cmsg_data[]; */ };</p>

<p>Ancillary data should only be accessed by the macros
defined in cmsg(3).</p>

<p>As an example, Linux uses this auxiliary data mechanism
to pass extended errors, IP options or file descriptors over
Unix sockets.</p>

<p>The msg_flags field in the msghdr is set on return of
recvmsg(). It can contain several flags:</p>

<p>MSG_EOR indicates end-of-record; the data returned
completed a record (generally used with sockets of type
SOCK_SEQPACKET).</p>

<p>MSG_TRUNC indicates that the trailing portion of a
datagram was discarded because the datagram was larger than
the buffer supplied.</p>

<p>MSG_CTRUNC indicates that some control data were
discarded due to lack of space in the buffer for ancillary
data.</p>

<p>MSG_OOB is returned to indicate that expedited or
out-of-band data were received.</p>

<p>MSG_ERRQUEUE indicates that no data was received but an
extended error from the socket error queue.</p>

<p>RETURN VALUE These calls return the number of bytes
received, or -1 if an error occurred. The return value will
be 0 when the peer has performed an orderly shutdown.</p>

<p>ERRORS These are some standard errors generated by the
socket layer. Addi- tional errors may be generated and
returned from the underlying proto- col modules; see their
manual pages.</p>

<p>EAGAIN The socket is marked non-blocking and the receive
operation would block, or a receive timeout had been set and
the timeout expired before data was received.</p>

<p>EBADF The argument s is an invalid descriptor.</p>

<p>ECONNREFUSED A remote host refused to allow the network
connection (typically because it is not running the
requested service).</p>

<p>EFAULT The receive buffer pointer(s) point outside the
processs address space.</p>

<p>EINTR The receive was interrupted by delivery of a
signal before any data were available.</p>

<p>EINVAL Invalid argument passed.</p>

<p>ENOMEM Could not allocate memory for recvmsg().</p>

<p>ENOTCONN The socket is associated with a
connection-oriented protocol and has not been connected (see
connect(2) and accept(2)).</p>

<p>ENOTSOCK The argument s does not refer to a socket.</p>

<p>CONFORMING TO 4.4BSD (these function calls first
appeared in 4.2BSD), POSIX.1-2001.</p>

<p>POSIX.1-2001 only describes the MSG_OOB, MSG_PEEK, and
MSG_WAITALL flags.</p>

<p>NOTES The prototypes given above follow glibc2. The
Single Unix Specifica- tion agrees, except that it has
return values of type ssize_t (while 4.x BSD and libc4 and
libc5 all have int). The flags argument is int in 4.x BSD,
but unsigned int in libc4 and libc5. The len argu- ment is
int in 4.x BSD, but size_t in libc4 and libc5. The fromlen
argument is int * in 4.x BSD, libc4 and libc5. The present
socklen_t * was invented by POSIX. See also accept(2).</p>

<p>According to POSIX.1-2001, the msg_controllen field of
the msghdr structure should be typed as socklen_t, but glibc
currently (2.4) types it as size_t.</p>

<p>SEE ALSO fcntl(2), getsockopt(2), read(2), select(2),
shutdown(2), socket(2), cmsg(3), sockatmark(3)</p>

<p>Linux Man Page 2002-12-31 RECV(2)</p>
<hr>
</body>
</html>
