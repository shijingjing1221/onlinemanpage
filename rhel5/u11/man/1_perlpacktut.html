<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:41 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLPACKTUT(1) Perl Programmers Reference Guide
PERLPACKTUT(1)</p>

<p>NAME perlpacktut - tutorial on &quot;pack&quot; and
&quot;unpack&quot;</p>

<p>DESCRIPTION &quot;pack&quot; and &quot;unpack&quot; are
two functions for transforming data according to a
user-defined template, between the guarded way Perl stores
values and some well-defined representation as might be
required in the envi- ronment of a Perl program.
Unfortunately, theyre also two of the most misunderstood and
most often overlooked functions that Perl provides. This
tutorial will demystify them for you.</p>

<p>The Basic Principle Most programming languages dont
shelter the memory where variables are stored. In C, for
instance, you can take the address of some variable, and the
&quot;sizeof&quot; operator tells you how many bytes are
allocated to the variable. Using the address and the size,
you may access the storage to your hearts content.</p>

<p>In Perl, you just cant access memory at random, but the
structural and representational conversion provided by
&quot;pack&quot; and &quot;unpack&quot; is an excellent
alternative. The &quot;pack&quot; function converts values
to a byte sequence containing representations according to a
given specification, the so-called &quot;template&quot;
argument. &quot;unpack&quot; is the reverse process,
deriving some values from the contents of a string of bytes.
(Be cau- tioned, however, that not all that has been packed
together can be neatly unpacked - a very common experience
as seasoned travellers are likely to confirm.)</p>

<p>Why, you may ask, would you need a chunk of memory
containing some val- ues in binary representation? One good
reason is input and output accessing some file, a device, or
a network connection, whereby this binary representation is
either forced on you or will give you some benefit in
processing. Another cause is passing data to some system
call that is not available as a Perl function:
&quot;syscall&quot; requires you to provide parameters
stored in the way it happens in a C program. Even text
processing (as shown in the next section) may be simplified
with judicious usage of these two functions.</p>

<p>To see how (un)packing works, well start with a simple
template code where the conversion is in low gear: between
the contents of a byte sequence and a string of hexadecimal
digits. Lets use &quot;unpack&quot;, since this is likely to
remind you of a dump program, or some desperate last message
unfortunate programs are wont to throw at you before they
expire into the wild blue yonder. Assuming that the variable
$mem holds a sequence of bytes that we d like to inspect
without assuming anything about its meaning, we can
write</p>

<p>my( $hex ) = unpack( H*, $mem ); print &quot;$hex0;</p>

<p>whereupon we might see something like this, with each
pair of hex dig- its corresponding to a byte:</p>


<p>41204d414e204120504c414e20412043414e414c2050414e414d41</p>

<p>What was in this chunk of memory? Numbers, characters,
or a mixture of both? Assuming that were on a computer where
ASCII (or some similar) encoding is used: hexadecimal values
in the range 0x40 - 0x5A indicate an uppercase letter, and
0x20 encodes a space. So we might assume it is a piece of
text, which some are able to read like a tabloid; but others
will have to get hold of an ASCII table and relive that
firstgrader feeling. Not caring too much about which way to
read this, we note that &quot;unpack&quot; with the template
code &quot;H&quot; converts the contents of a sequence of
bytes into the customary hexadecimal notation. Since &quot;a
sequence of&quot; is a pretty vague indication of quantity,
&quot;H&quot; has been defined to con- vert just a single
hexadecimal digit unless it is followed by a repeat count.
An asterisk for the repeat count means to use whatever
remains.</p>

<p>The inverse operation - packing byte contents from a
string of hexadec- imal digits - is just as easily written.
For instance:</p>

<p>my $s = pack( H2 x 10, map { &quot;3$_&quot; } ( 0..9 )
); print &quot;$s0;</p>

<p>Since we feed a list of ten 2-digit hexadecimal strings
to &quot;pack&quot;, the pack template should contain ten
pack codes. If this is run on a com- puter with ASCII
character coding, it will print 0123456789.</p>

<p>Packing Text Lets suppose youve got to read in a data
file like this:</p>

<p>Date Description Income Expenditure 01/24/2001 Ahmed s
Camel Emporium 1147.99 01/28/2001 Flea spray 24.99
01/29/2001 Camel rides to tourists 235.00</p>

<p>How do we do it? You might think first to use
&quot;split&quot;; however, since &quot;split&quot;
collapses blank fields, youll never know whether a record
was income or expenditure. Oops. Well, you could always use
&quot;substr&quot;:</p>

<p>while (&lt;&gt;) { my $date = substr($_, 0, 11); my
$desc = substr($_, 12, 27); my $income = substr($_, 40, 7);
my $expend = substr($_, 52, 7); ... }</p>

<p>It s not really a barrel of laughs, is it? In fact, its
worse than it may seem; the eagle-eyed may notice that the
first field should only be 10 characters wide, and the error
has propagated right through the other numbers - which weve
had to count by hand. So it s error-prone as well as
horribly unfriendly.</p>

<p>Or maybe we could use regular expressions:</p>

<p>while (&lt;&gt;) { my($date, $desc, $income, $expend) =
m(//{4}) (.{27}) (.{7})(.*); ... }</p>

<p>Urgh. Well, its a bit better, but - well, would you want
to maintain that?</p>

<p>Hey, isnt Perl supposed to make this sort of thing easy?
Well, it does, if you use the right tools. &quot;pack&quot;
and &quot;unpack&quot; are designed to help you out when
dealing with fixed-width data like the above. Lets have a
look at a solution with &quot;unpack&quot;:</p>

<p>while (&lt;&gt;) { my($date, $desc, $income, $expend) =
unpack(&quot;A10xA27xA7A*&quot;, $_); ... }</p>

<p>That looks a bit nicer; but weve got to take apart that
weird tem- plate. Where did I pull that out of?</p>

<p>OK, let s have a look at some of our data again; in
fact, well include the headers, and a handy ruler so we can
keep track of where we are.</p>

<p>1 2 3 4 5
1234567890123456789012345678901234567890123456789012345678
Date Description Income Expenditure 01/28/2001 Flea spray
24.99 01/29/2001 Camel rides to tourists 235.00</p>

<p>From this, we can see that the date column stretches
from column 1 to column 10 - ten characters wide. The
&quot;pack&quot;-ese for &quot;character&quot; is
&quot;A&quot;, and ten of them are &quot;A10&quot;. So if we
just wanted to extract the dates, we could say this:</p>

<p>my($date) = unpack(&quot;A10&quot;, $_);</p>

<p>OK, whats next? Between the date and the description is
a blank col- umn; we want to skip over that. The
&quot;x&quot; template means &quot;skip forward&quot;, so we
want one of those. Next, we have another batch of
characters, from 12 to 38. Thats 27 more characters, hence
&quot;A27&quot;. (Don t make the fencepost error - there are
27 characters between 12 and 38, not 26. Count em!)</p>

<p>Now we skip another character and pick up the next 7
characters:</p>

<p>my($date,$description,$income) =
unpack(&quot;A10xA27xA7&quot;, $_);</p>

<p>Now comes the clever bit. Lines in our ledger which are
just income and not expenditure might end at column 46.
Hence, we dont want to tell our &quot;unpack&quot; pattern
that we need to find another 12 characters; well just say
&quot;if theres anything left, take it&quot;. As you might
guess from regular expressions, that s what the
&quot;*&quot; means: &quot;use everything remain-
ing&quot;.</p>

<p>&middot; Be warned, though, that unlike regular
expressions, if the &quot;unpack&quot; template doesnt match
the incoming data, Perl will scream and die.</p>

<p>Hence, putting it all together:</p>

<p>my($date,$description,$income,$expend) =
unpack(&quot;A10xA27xA7xA*&quot;, $_);</p>

<p>Now, thats our data parsed. I suppose what we might want
to do now is total up our income and expenditure, and add
another line to the end of our ledger - in the same format -
saying how much we ve brought in and how much weve
spent:</p>

<p>while (&lt;&gt;) { my($date, $desc, $income, $expend) =
unpack(&quot;A10xA27xA7xA*&quot;, $_); $tot_income +=
$income; $tot_expend += $expend; }</p>

<p>$tot_income = sprintf(&quot;%.2f&quot;, $tot_income); #
Get them into $tot_expend = sprintf(&quot;%.2f&quot;,
$tot_expend); # &quot;financial&quot; format</p>

<p>$date = POSIX::strftime(&quot;%m/%d/%Y&quot;,
localtime);</p>

<p># OK, lets go:</p>

<p>print pack(&quot;A10xA27xA7xA*&quot;, $date,
&quot;Totals&quot;, $tot_income, $tot_expend);</p>

<p>Oh, hmm. That didnt quite work. Lets see what
happened:</p>

<p>01/24/2001 Ahmed s Camel Emporium 1147.99 01/28/2001
Flea spray 24.99 01/29/2001 Camel rides to tourists 1235.00
03/23/2001Totals 1235.001172.98</p>

<p>OK, it s a start, but what happened to the spaces? We
put &quot;x&quot;, didnt we? Shouldnt it skip forward? Lets
look at what &quot;pack&quot; in perlfunc says:</p>

<p>x A null byte.</p>

<p>Urgh. No wonder. Theres a big difference between &quot;a
null byte&quot;, char- acter zero, and &quot;a space&quot;,
character 32. Perl s put something between the date and the
description - but unfortunately, we cant see it!</p>

<p>What we actually need to do is expand the width of the
fields. The &quot;A&quot; format pads any non-existent
characters with spaces, so we can use the additional spaces
to line up our fields, like this:</p>

<p>print pack(&quot;A11 A28 A8 A*&quot;, $date,
&quot;Totals&quot;, $tot_income, $tot_expend);</p>

<p>(Note that you can put spaces in the template to make it
more readable, but they dont translate to spaces in the
output.) Here s what we got this time:</p>

<p>01/24/2001 Ahmed s Camel Emporium 1147.99 01/28/2001
Flea spray 24.99 01/29/2001 Camel rides to tourists 1235.00
03/23/2001 Totals 1235.00 1172.98</p>

<p>Thats a bit better, but we still have that last column
which needs to be moved further over. Theres an easy way to
fix this up: unfortu- nately, we cant get &quot;pack&quot;
to right-justify our fields, but we can get
&quot;sprintf&quot; to do it:</p>

<p>$tot_income = sprintf(&quot;%.2f&quot;, $tot_income);
$tot_expend = sprintf(&quot;%12.2f&quot;, $tot_expend);
$date = POSIX::strftime(&quot;%m/%d/%Y&quot;, localtime);
print pack(&quot;A11 A28 A8 A*&quot;, $date,
&quot;Totals&quot;, $tot_income, $tot_expend);</p>

<p>This time we get the right answer:</p>

<p>01/28/2001 Flea spray 24.99 01/29/2001 Camel rides to
tourists 1235.00 03/23/2001 Totals 1235.00 1172.98</p>

<p>So thats how we consume and produce fixed-width data.
Lets recap what weve seen of &quot;pack&quot; and
&quot;unpack&quot; so far:</p>

<p>&middot; Use &quot;pack&quot; to go from several pieces
of data to one fixed-width ver- sion; use &quot;unpack&quot;
to turn a fixed-width-format string into several pieces of
data.</p>

<p>&middot; The pack format &quot;A&quot; means &quot;any
character&quot;; if youre &quot;pack&quot;ing and youve run
out of things to pack, &quot;pack&quot; will fill the rest
up with spaces.</p>

<p>&middot; &quot;x&quot; means &quot;skip a byte&quot;
when &quot;unpack&quot;ing; when &quot;pack&quot;ing, it
means &quot;introduce a null byte&quot; - thats probably not
what you mean if youre dealing with plain text.</p>

<p>&middot; You can follow the formats with numbers to say
how many characters should be affected by that format:
&quot;A12&quot; means &quot;take 12 characters&quot;;
&quot;x6&quot; means &quot;skip 6 bytes&quot; or
&quot;character 0, 6 times&quot;.</p>

<p>&middot; Instead of a number, you can use &quot;*&quot;
to mean &quot;consume everything else left&quot;.</p>

<p>Warning: when packing multiple pieces of data,
&quot;*&quot; only means &quot;consume all of the current
piece of data&quot;. Thats to say</p>

<p>pack(&quot;A*A*&quot;, $one, $two)</p>

<p>packs all of $one into the first &quot;A*&quot; and then
all of $two into the second. This is a general principle:
each format character corre- sponds to one piece of data to
be &quot;pack&quot;ed.</p>

<p>Packing Numbers So much for textual data. Lets get onto
the meaty stuff that &quot;pack&quot; and &quot;unpack&quot;
are best at: handling binary formats for numbers. There is,
of course, not just one binary format - life would be too
simple - but Perl will do all the finicky labor for you.</p>

<p>Integers</p>

<p>Packing and unpacking numbers implies conversion to and
from some spe- cific binary representation. Leaving floating
point numbers aside for the moment, the salient properties
of any such representation are:</p>

<p>&middot; the number of bytes used for storing the
integer,</p>

<p>&middot; whether the contents are interpreted as a
signed or unsigned num- ber,</p>

<p>&middot; the byte ordering: whether the first byte is
the least or most sig- nificant byte (or: little-endian or
big-endian, respectively).</p>

<p>So, for instance, to pack 20302 to a signed 16 bit
integer in your com- puters representation you write</p>

<p>my $ps = pack( s, 20302 );</p>

<p>Again, the result is a string, now containing 2 bytes.
If you print this string (which is, generally, not
recommended) you might see &quot;ON&quot; or &quot;NO&quot;
(depending on your systems byte ordering) - or something
entirely different if your computer doesn t use ASCII
character encod- ing. Unpacking $ps with the same template
returns the original integer value:</p>

<p>my( $s ) = unpack( s, $ps );</p>

<p>This is true for all numeric template codes. But dont
expect miracles: if the packed value exceeds the allotted
byte capacity, high order bits are silently discarded, and
unpack certainly wont be able to pull them back out of some
magic hat. And, when you pack using a signed template code
such as &quot;s&quot;, an excess value may result in the
sign bit getting set, and unpacking this will smartly return
a negative value.</p>

<p>16 bits wont get you too far with integers, but there is
&quot;l&quot; and &quot;L&quot; for signed and unsigned
32-bit integers. And if this is not enough and your system
supports 64 bit integers you can push the limits much closer
to infinity with pack codes &quot;q&quot; and &quot;Q&quot;.
A notable exception is provided by pack codes &quot;i&quot;
and &quot;I&quot; for signed and unsigned integers of the
&quot;local custom&quot; variety: Such an integer will take
up as many bytes as a local C compiler returns for
&quot;sizeof(int)&quot;, but itll use at least 32 bits.</p>

<p>Each of the integer pack codes &quot;sSlLqQ&quot;
results in a fixed number of bytes, no matter where you
execute your program. This may be useful for some
applications, but it does not provide for a portable way to
pass data structures between Perl and C programs (bound to
happen when you call XS extensions or the Perl function
&quot;syscall&quot;), or when you read or write binary
files. What you ll need in this case are template codes that
depend on what your local C compiler compiles when you code
&quot;short&quot; or &quot;unsigned long&quot;, for
instance. These codes and their corresponding byte lengths
are shown in the table below. Since the C standard leaves
much leeway with respect to the relative sizes of these data
types, actual values may vary, and that s why the values are
given as expressions in C and Perl. (If youd like to use
values from %Config in your program you have to import it
with &quot;use Config&quot;.)</p>

<p>signed unsigned byte length in C byte length in Perl s!
S! sizeof(short) $Config{shortsize} i! I! sizeof(int)
$Config{intsize} l! L! sizeof(long) $Config{longsize} q! Q!
sizeof(long long) $Config{longlongsize}</p>

<p>The &quot;i!&quot; and &quot;I!&quot; codes arent
different from &quot;i&quot; and &quot;I&quot;; they are
tolerated for completeness sake.</p>

<p>Unpacking a Stack Frame</p>

<p>Requesting a particular byte ordering may be necessary
when you work with binary data coming from some specific
architecture whereas your program could run on a totally
different system. As an example, assume you have 24 bytes
containing a stack frame as it happens on an Intel 8086:</p>

<p>+---------+ +----+----+ +---------+ TOS: IP TOS+4: FL FH
FLAGS TOS+14: SI +---------+ +----+----+ +---------+ CS AL
AH AX DI +---------+ +----+----+ +---------+ BL BH BX BP
+----+----+ +---------+ CL CH CX DS +----+----+ +---------+
DL DH DX ES +----+----+ +---------+</p>

<p>First, we note that this time-honored 16-bit CPU uses
little-endian order, and thats why the low order byte is
stored at the lower address. To unpack such a (signed) short
well have to use code &quot;v&quot;. A repeat count unpacks
all 12 shorts:</p>

<p>my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp,
$ds, $es ) = unpack( v12, $frame );</p>

<p>Alternatively, we could have used &quot;C&quot; to
unpack the individually acces- sible byte registers FL, FH,
AL, AH, etc.:</p>

<p>my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
unpack( C10, substr( $frame, 4, 10 ) );</p>

<p>It would be nice if we could do this in one fell swoop:
unpack a short, back up a little, and then unpack 2 bytes.
Since Perl is nice, it prof- fers the template code
&quot;X&quot; to back up one byte. Putting this all
together, we may now write:</p>

<p>my( $ip, $cs, $flags,$fl,$fh, $ax,$al,$ah, $bx,$bl,$bh,
$cx,$cl,$ch, $dx,$dl,$dh, $si, $di, $bp, $ds, $es ) =
unpack( v2 . (vXXCC x 5) . v5, $frame );</p>

<p>(The clumsy construction of the template can be avoided
- just read on!)</p>

<p>Weve taken some pains to construct the template so that
it matches the contents of our frame buffer. Otherwise we d
either get undefined val- ues, or &quot;unpack&quot; could
not unpack all. If &quot;pack&quot; runs out of items, it
will supply null strings (which are coerced into zeroes
whenever the pack code says so).</p>

<p>How to Eat an Egg on a Net</p>

<p>The pack code for big-endian (high order byte at the
lowest address) is &quot;n&quot; for 16 bit and
&quot;N&quot; for 32 bit integers. You use these codes if
you know that your data comes from a compliant architecture,
but, surpris- ingly enough, you should also use these pack
codes if you exchange binary data, across the network, with
some system that you know next to nothing about. The simple
reason is that this order has been chosen as the network
order, and all standard-fearing programs ought to follow
this convention. (This is, of course, a stern backing for
one of the Lilliputian parties and may well influence the
political development there.) So, if the protocol expects
you to send a message by sending the length first, followed
by just so many bytes, you could write:</p>

<p>my $buf = pack( N, length( $msg ) ) . $msg;</p>

<p>or even:</p>

<p>my $buf = pack( NA*, length( $msg ), $msg );</p>

<p>and pass $buf to your send routine. Some protocols
demand that the count should include the length of the count
itself: then just add 4 to the data length. (But make sure
to read &quot;Lengths and Widths&quot; before you really
code this!)</p>

<p>Floating point Numbers</p>

<p>For packing floating point numbers you have the choice
between the pack codes &quot;f&quot; and &quot;d&quot; which
pack into (or unpack from) single-precision or
double-precision representation as it is provided by your
system. (There is no such thing as a network representation
for reals, so if you want to send your real numbers across
computer boundaries, youd better stick to ASCII
representation, unless you re absolutely sure whats on the
other end of the line.)</p>

<p>Exotic Templates Bit Strings</p>

<p>Bits are the atoms in the memory world. Access to
individual bits may have to be used either as a last resort
or because it is the most con- venient way to handle your
data. Bit string (un)packing converts between strings
containing a series of 0 and 1 characters and a sequence of
bytes each containing a group of 8 bits. This is almost as
simple as it sounds, except that there are two ways the
contents of a byte may be written as a bit string. Lets have
a look at an annotated byte:</p>

<p>7 6 5 4 3 2 1 0 +-----------------+ 1 0 0 0 1 1 0 0
+-----------------+ MSB LSB</p>

<p>Its egg-eating all over again: Some think that as a bit
string this should be written &quot;10001100&quot; i.e.
beginning with the most significant bit, others insist on
&quot;00110001&quot;. Well, Perl isnt biased, so thats why
we have two bit string codes:</p>

<p>$byte = pack( B8, 10001100 ); # start with MSB $byte =
pack( b8, 00110001 ); # start with LSB</p>

<p>It is not possible to pack or unpack bit fields - just
integral bytes. &quot;pack&quot; always starts at the next
byte boundary and &quot;rounds up&quot; to the next multiple
of 8 by adding zero bits as required. (If you do want bit
fields, there is &quot;vec&quot; in perlfunc. Or you could
implement bit field handling at the character string level,
using split, substr, and con- catenation on unpacked bit
strings.)</p>

<p>To illustrate unpacking for bit strings, well decompose
a simple sta- tus register (a &quot;-&quot; stands for a
&quot;reserved&quot; bit):</p>

<p>+-----------------+-----------------+ S Z - A - P - C -
- - - O D I T +-----------------+-----------------+ MSB LSB
MSB LSB</p>

<p>Converting these two bytes to a string can be done with
the unpack tem- plate &rsquo;b16&rsquo;. To obtain the
individual bit values from the bit string we use
&quot;split&quot; with the &quot;empty&quot; separator
pattern which dissects into individual characters. Bit
values from the &quot;reserved&quot; positions are simply
assigned to &quot;undef&quot;, a convenient notation for
&quot;I dont care where this goes&quot;.</p>

<p>($carry, undef, $parity, undef, $auxcarry, undef, $zero,
$sign, $trace, $interrupt, $direction, $overflow) = split(
//, unpack( b16, $status ) );</p>

<p>We could have used an unpack template &rsquo;b12&rsquo;
just as well, since the last 4 bits can be ignored
anyway.</p>

<p>Uuencoding</p>

<p>Another odd-man-out in the template alphabet is
&quot;u&quot;, which packs an &quot;uuencoded string&quot;.
(&quot;uu&quot; is short for Unix-to-Unix.) Chances are that
you wont ever need this encoding technique which was
invented to over- come the shortcomings of old-fashioned
transmission mediums that do not support other than simple
ASCII data. The essential recipe is simple: Take three
bytes, or 24 bits. Split them into 4 six-packs, adding a
space (0x20) to each. Repeat until all of the data is
blended. Fold groups of 4 bytes into lines no longer than 60
and garnish them in front with the original byte count
(incremented by 0x20) and a &quot;0 at the end. - The
&quot;pack&quot; chef will prepare this for you, a la
minute, when you select pack code &quot;u&quot; on the
menu:</p>

<p>my $uubuf = pack( u, $bindat );</p>

<p>A repeat count after &quot;u&quot; sets the number of
bytes to put into an uuen- coded line, which is the maximum
of 45 by default, but could be set to some (smaller) integer
multiple of three. &quot;unpack&quot; simply ignores the
repeat count.</p>

<p>Doing Sums</p>

<p>An even stranger template code is
&quot;%&quot;&lt;number&gt;. First, because its used as a
prefix to some other template code. Second, because it
cannot be used in &quot;pack&quot; at all, and third, in
&quot;unpack&quot;, doesnt return the data as defined by the
template code it precedes. Instead it ll give you an integer
of number bits that is computed from the data value by doing
sums. For numeric unpack codes, no big feat is achieved:</p>

<p>my $buf = pack( iii, 100, 20, 3 ); print unpack( %32i3,
$buf ), &quot;0; # prints 123</p>

<p>For string values, &quot;%&quot; returns the sum of the
byte values saving you the trouble of a sum loop with
&quot;substr&quot; and &quot;ord&quot;:</p>

<p>print unpack( %32A*, &quot;10&quot; ), &quot;0; # prints
17</p>

<p>Although the &quot;%&quot; code is documented as
returning a &quot;checksum&quot;: dont put your trust in
such values! Even when applied to a small number of bytes,
they wont guarantee a noticeable Hamming distance.</p>

<p>In connection with &quot;b&quot; or &quot;B&quot;,
&quot;%&quot; simply adds bits, and this can be put to good
use to count set bits efficiently:</p>

<p>my $bitcount = unpack( %32b*, $mask );</p>

<p>And an even parity bit can be determined like this:</p>

<p>my $evenparity = unpack( %1b*, $mask );</p>

<p>Unicode</p>

<p>Unicode is a character set that can represent most
characters in most of the worlds languages, providing room
for over one million different characters. Unicode 3.1
specifies 94,140 characters: The Basic Latin characters are
assigned to the numbers 0 - 127. The Latin-1 Supplement with
characters that are used in several European languages is in
the next range, up to 255. After some more Latin extensions
we find the character sets from languages using non-Roman
alphabets, interspersed with a variety of symbol sets such
as currency symbols, Zapf Dingbats or Braille. (You might
want to visit www.unicode.org for a look at some of them -
my personal favourites are Telugu and Kannada.)</p>

<p>The Unicode character sets associates characters with
integers. Encod- ing these numbers in an equal number of
bytes would more than double the requirements for storing
texts written in Latin alphabets. The UTF-8 encoding avoids
this by storing the most common (from a western point of
view) characters in a single byte while encoding the rarer
ones in three or more bytes.</p>

<p>So what has this got to do with &quot;pack&quot;? Well,
if you want to convert between a Unicode number and its
UTF-8 representation you can do so by using template code
&quot;U&quot;. As an example, lets produce the UTF-8 repre-
sentation of the Euro currency symbol (code number
0x20AC):</p>

<p>$UTF8{Euro} = pack( U, 0x20AC );</p>

<p>Inspecting $UTF8{Euro} shows that it contains 3 bytes:
&quot;. The round trip can be completed with
&quot;unpack&quot;:</p>

<p>$Unicode{Euro} = unpack( U, $UTF8{Euro} );</p>

<p>Usually youll want to pack or unpack UTF-8 strings:</p>

<p># pack and unpack the Hebrew alphabet my $alefbet =
pack( U*, 0x05d0..0x05ea ); my @hebrew = unpack( U*, $utf
);</p>

<p>Another Portable Binary Encoding</p>

<p>The pack code &quot;w&quot; has been added to support a
portable binary data encoding scheme that goes way beyond
simple integers. (Details can be found at Casbah.org, the
Scarab project.) A BER (Binary Encoded Repre- sentation)
compressed unsigned integer stores base 128 digits, most
significant digit first, with as few digits as possible. Bit
eight (the high bit) is set on each byte except the last.
There is no size limit to BER encoding, but Perl wont go to
extremes.</p>

<p>my $berbuf = pack( w*, 1, 128, 128+1, 128*128+127 );</p>

<p>A hex dump of $berbuf, with spaces inserted at the right
places, shows 01 8100 8101 81807F. Since the last byte is
always less than 128, &quot;unpack&quot; knows where to
stop.</p>

<p>Template Grouping Prior to Perl 5.8, repetitions of
templates had to be made by &quot;x&quot;-mul- tiplication
of template strings. Now there is a better way as we may use
the pack codes &quot;(&quot; and &quot;)&quot; combined with
a repeat count. The &quot;unpack&quot; template from the
Stack Frame example can simply be written like this:</p>

<p>unpack( v2 (vXXCC)5 v5, $frame )</p>

<p>Let s explore this feature a little more. Well begin
with the equiva- lent of</p>

<p>join( , map( substr( $_, 0, 1 ), @str ) )</p>

<p>which returns a string consisting of the first character
from each string. Using pack, we can write</p>

<p>pack( (A).@str, @str )</p>

<p>or, because a repeat count &quot;*&quot; means
&quot;repeat as often as required&quot;, simply</p>

<p>pack( (A)*, @str )</p>

<p>(Note that the template &quot;A*&quot; would only have
packed $str[0] in full length.)</p>

<p>To pack dates stored as triplets ( day, month, year ) in
an array @dates into a sequence of byte, byte, short integer
we can write</p>

<p>$pd = pack( (CCS)*, map( @$_, @dates ) );</p>

<p>To swap pairs of characters in a string (with even
length) one could use several techniques. First, lets use
&quot;x&quot; and &quot;X&quot; to skip forward and
back:</p>

<p>$s = pack( (A)*, unpack( (xAXXAx)*, $s ) );</p>

<p>We can also use &quot;@&quot; to jump to an offset, with
0 being the position where we were when the last
&quot;(&quot; was encountered:</p>

<p>$s = pack( (A)*, unpack( (@1A @0A @2)*, $s ) );</p>

<p>Finally, there is also an entirely different approach by
unpacking big endian shorts and packing them in the reverse
byte order:</p>

<p>$s = pack( (v)*, unpack( (n)*, $s );</p>

<p>Lengths and Widths String Lengths</p>

<p>In the previous section weve seen a network message that
was con- structed by prefixing the binary message length to
the actual message. Youll find that packing a length
followed by so many bytes of data is a frequently used
recipe since appending a null byte won t work if a null byte
may be part of the data. Here is an example where both tech-
niques are used: after two null terminated strings with
source and des- tination address, a Short Message (to a
mobile phone) is sent after a length byte:</p>

<p>my $msg = pack( Z*Z*CA*, $src, $dst, length( $sm ), $sm
);</p>

<p>Unpacking this message can be done with the same
template:</p>

<p>( $src, $dst, $len, $sm ) = unpack( Z*Z*CA*, $msg );</p>

<p>Theres a subtle trap lurking in the offing: Adding
another field after the Short Message (in variable $sm) is
all right when packing, but this cannot be unpacked
naively:</p>

<p># pack a message my $msg = pack( Z*Z*CA*C, $src, $dst,
length( $sm ), $sm, $prio );</p>

<p># unpack fails - $prio remains undefined! ( $src, $dst,
$len, $sm, $prio ) = unpack( Z*Z*CA*C, $msg );</p>

<p>The pack code &quot;A*&quot; gobbles up all remaining
bytes, and $prio remains undefined! Before we let
disappointment dampen the morale: Perls got the trump card
to make this trick too, just a little further up the sleeve.
Watch this:</p>

<p># pack a message: ASCIIZ, ASCIIZ, length/string, byte my
$msg = pack( Z* Z* C/A* C, $src, $dst, $sm, $prio );</p>

<p># unpack ( $src, $dst, $sm, $prio ) = unpack( Z* Z* C/A*
C, $msg );</p>

<p>Combining two pack codes with a slash (&quot;/&quot;)
associates them with a sin- gle value from the argument
list. In &quot;pack&quot;, the length of the argument is
taken and packed according to the first code while the
argument itself is added after being converted with the
template code after the slash. This saves us the trouble of
inserting the &quot;length&quot; call, but it is in
&quot;unpack&quot; where we really score: The value of the
length byte marks the end of the string to be taken from the
buffer. Since this combination doesnt make sense except when
the second pack code isnt &quot;a*&quot;, &quot;A*&quot; or
&quot;Z*&quot;, Perl wont let you.</p>

<p>The pack code preceding &quot;/&quot; may be anything
thats fit to represent a number: All the numeric binary pack
codes, and even text codes such as &quot;A4&quot; or
&quot;Z*&quot;:</p>

<p># pack/unpack a string preceded by its length in ASCII
my $buf = pack( A4/A*, &quot;Humpty-Dumpty&quot; ); # unpack
$buf: 13 Humpty-Dumpty my $txt = unpack( A4/A*, $buf );</p>

<p>&quot;/&quot; is not implemented in Perls before 5.6, so
if your code is required to work on older Perls youll need
to &quot;unpack( &rsquo;Z* Z* C&rsquo;)&quot; to get the
length, then use it to make a new unpack string. For
example</p>

<p># pack a message: ASCIIZ, ASCIIZ, length, string, byte
(5.005 compatible) my $msg = pack( Z* Z* C A* C, $src, $dst,
length $sm, $sm, $prio );</p>

<p># unpack ( undef, undef, $len) = unpack( Z* Z* C, $msg
); ($src, $dst, $sm, $prio) = unpack ( &quot;Z* Z* x A$len
C&quot;, $msg );</p>

<p>But that second &quot;unpack&quot; is rushing ahead. It
isnt using a simple lit- eral string for the template. So
maybe we should introduce...</p>

<p>Dynamic Templates</p>

<p>So far, weve seen literals used as templates. If the
list of pack items doesnt have fixed length, an expression
constructing the tem- plate is required (whenever, for some
reason, &quot;()*&quot; cannot be used). Heres an example:
To store named string values in a way that can be
conveniently parsed by a C program, we create a sequence of
names and null terminated ASCII strings, with &quot;=&quot;
between the name and the value, followed by an additional
delimiting null byte. Heres how:</p>

<p>my $env = pack( (A*A*Z*) . keys( %Env ) . C, map( { (
$_, =, $Env{$_} ) } keys( %Env ) ), 0 );</p>

<p>Lets examine the cogs of this byte mill, one by one.
There s the &quot;map&quot; call, creating the items we
intend to stuff into the $env buffer: to each key (in $_) it
adds the &quot;=&quot; separator and the hash entry value.
Each triplet is packed with the template code sequence
&quot;A*A*Z*&quot; that is repeated according to the number
of keys. (Yes, thats what the &quot;keys&quot; function
returns in scalar context.) To get the very last null byte,
we add a 0 at the end of the &quot;pack&quot; list, to be
packed with &quot;C&quot;. (Atten- tive readers may have
noticed that we could have omitted the 0.)</p>

<p>For the reverse operation, we ll have to determine the
number of items in the buffer before we can let
&quot;unpack&quot; rip it apart:</p>

<p>my $n = $env =~ tr/ // - 1; my %env = map( split( /=/,
$_ ), unpack( &quot;(Z*)$n&quot;, $env ) );</p>

<p>The &quot;tr&quot; counts the null bytes. The
&quot;unpack&quot; call returns a list of name-value pairs
each of which is taken apart in the &quot;map&quot;
block.</p>

<p>Counting Repetitions</p>

<p>Rather than storing a sentinel at the end of a data item
(or a list of items), we could precede the data with a
count. Again, we pack keys and values of a hash, preceding
each with an unsigned short length count, and up front we
store the number of pairs:</p>

<p>my $env = pack( S(S/A* S/A*)*, scalar keys( %Env ), %Env
);</p>

<p>This simplifies the reverse operation as the number of
repetitions can be unpacked with the &quot;/&quot; code:</p>

<p>my %env = unpack( S/(S/A* S/A*), $env );</p>

<p>Note that this is one of the rare cases where you cannot
use the same template for &quot;pack&quot; and
&quot;unpack&quot; because &quot;pack&quot; cant determine a
repeat count for a &quot;()&quot;-group.</p>

<p>Packing and Unpacking C Structures In previous sections
we have seen how to pack numbers and character strings. If
it were not for a couple of snags we could conclude this
section right away with the terse remark that C structures
dont con- tain anything else, and therefore you already know
all there is to it. Sorry, no: read on, please.</p>

<p>The Alignment Pit</p>

<p>In the consideration of speed against memory
requirements the balance has been tilted in favor of faster
execution. This has influenced the way C compilers allocate
memory for structures: On architectures where a 16-bit or
32-bit operand can be moved faster between places in mem-
ory, or to or from a CPU register, if it is aligned at an
even or mul- tiple-of-four or even at a multiple-of eight
address, a C compiler will give you this speed benefit by
stuffing extra bytes into structures. If you don t cross the
C shoreline this is not likely to cause you any grief
(although you should care when you design large data
structures, or you want your code to be portable between
architectures (you do want that, dont you?)).</p>

<p>To see how this affects &quot;pack&quot; and
&quot;unpack&quot;, well compare these two C structures:</p>

<p>typedef struct { char c1; short s; char c2; long l; }
gappy_t;</p>

<p>typedef struct { long l; short s; char c1; char c2; }
dense_t;</p>

<p>Typically, a C compiler allocates 12 bytes to a
&quot;gappy_t&quot; variable, but requires only 8 bytes for
a &quot;dense_t&quot;. After investigating this fur- ther,
we can draw memory maps, showing where the extra 4 bytes are
hid- den:</p>

<p>0 +4 +8 +12 +--+--+--+--+--+--+--+--+--+--+--+--+ c1xx s
c2xxxxxx l xx = fill byte
+--+--+--+--+--+--+--+--+--+--+--+--+ gappy_t</p>

<p>0 +4 +8 +--+--+--+--+--+--+--+--+ l h c1c2
+--+--+--+--+--+--+--+--+ dense_t</p>

<p>And thats where the first quirk strikes:
&quot;pack&quot; and &quot;unpack&quot; templates have to be
stuffed with &quot;x&quot; codes to get those extra fill
bytes.</p>

<p>The natural question: &quot;Why cant Perl compensate for
the gaps?&quot; war- rants an answer. One good reason is
that C compilers might provide (non-ANSI) extensions
permitting all sorts of fancy control over the way
structures are aligned, even at the level of an individual
struc- ture field. And, if this were not enough, there is an
insidious thing called &quot;union&quot; where the amount of
fill bytes cannot be derived from the alignment of the next
item alone.</p>

<p>OK, so lets bite the bullet. Heres one way to get the
alignment right by inserting template codes &quot;x&quot;,
which don t take a corresponding item from the list:</p>

<p>my $gappy = pack( cxs cxxx l!, $c1, $s, $c2, $l );</p>

<p>Note the &quot;!&quot; after &quot;l&quot;: We want to
make sure that we pack a long inte- ger as it is compiled by
our C compiler. And even now, it will only work for the
platforms where the compiler aligns things as above. And
somebody somewhere has a platform where it doesn t.
[Probably a Cray, where &quot;short&quot;s, &quot;int&quot;s
and &quot;long&quot;s are all 8 bytes. :-)]</p>

<p>Counting bytes and watching alignments in lengthy
structures is bound to be a drag. Isnt there a way we can
create the template with a sim- ple program? Heres a C
program that does the trick:</p>

<p>#include &lt;stdio.h&gt; #include &lt;stddef.h&gt;</p>

<p>typedef struct { char fc1; short fs; char fc2; long fl;
} gappy_t;</p>

<p>#define Pt(struct,field,tchar) printf( &quot;@%d%s
&quot;, offsetof(struct,field), # tchar );</p>

<p>int main() { Pt( gappy_t, fc1, c ); Pt( gappy_t, fs, s!
); Pt( gappy_t, fc2, c ); Pt( gappy_t, fl, l! ); printf(
&quot;0 ); }</p>

<p>The output line can be used as a template in a
&quot;pack&quot; or &quot;unpack&quot; call:</p>

<p>my $gappy = pack( @0c @2s! @4c @8l!, $c1, $s, $c2, $l
);</p>

<p>Gee, yet another template code - as if we hadnt plenty.
But &quot;@&quot; saves our day by enabling us to specify
the offset from the beginning of the pack buffer to the next
item: This is just the value the &quot;offsetof&quot; macro
(defined in &quot;&lt;stddef.h&gt;&quot;) returns when given
a &quot;struct&quot; type and one of its field names
(&quot;member-designator&quot; in C standardese).</p>

<p>Neither using offsets nor adding &quot;x&quot;s to
bridge the gaps is satisfac- tory. (Just imagine what
happens if the structure changes.) What we really need is a
way of saying &quot;skip as many bytes as required to the
next multiple of N&quot;. In fluent Templatese, you say this
with &quot;x!N&quot; where N is replaced by the appropriate
value. Here s the next version of our struct packaging:</p>

<p>my $gappy = pack( c x!2 s c x!4 l!, $c1, $s, $c2, $l
);</p>

<p>Thats certainly better, but we still have to know how
long all the integers are, and portability is far away.
Rather than 2, for instance, we want to say &quot;however
long a short is&quot;. But this can be done by enclosing the
appropriate pack code in brackets: &quot;[s]&quot;. So,
heres the very best we can do:</p>

<p>my $gappy = pack( c x![s] s c x![l!] l!, $c1, $s, $c2,
$l );</p>

<p>Alignment, Take 2</p>

<p>Im afraid that were not quite through with the alignment
catch yet. The hydra raises another ugly head when you pack
arrays of structures:</p>

<p>typedef struct { short count; char glyph; } cell_t;</p>

<p>typedef cell_t buffer_t[BUFLEN];</p>

<p>Wheres the catch? Padding is neither required before the
first field &quot;count&quot;, nor between this and the next
field &quot;glyph&quot;, so why cant we simply pack like
this:</p>

<p># something goes wrong here: pack( s!a x @buffer, map{ (
$_-&gt;{count}, $_-&gt;{glyph} ) } @buffer );</p>

<p>This packs &quot;3*@buffer&quot; bytes, but it turns out
that the size of &quot;buffer_t&quot; is four times
&quot;BUFLEN&quot;! The moral of the story is that the
required alignment of a structure or array is propagated to
the next higher level where we have to consider padding at
the end of each com- ponent as well. Thus the correct
template is:</p>

<p>pack( s!ax x @buffer, map{ ( $_-&gt;{count},
$_-&gt;{glyph} ) } @buffer );</p>

<p>Alignment, Take 3</p>

<p>And even if you take all the above into account, ANSI
still lets this:</p>

<p>typedef struct { char foo[2]; } foo_t;</p>

<p>vary in size. The alignment constraint of the structure
can be greater than any of its elements. [And if you think
that this doesnt affect anything common, dismember the next
cellphone that you see. Many have ARM cores, and the ARM
structure rules make &quot;sizeof (foo_t)&quot; == 4]</p>

<p>Pointers for How to Use Them</p>

<p>The title of this section indicates the second problem
you may run into sooner or later when you pack C structures.
If the function you intend to call expects a, say,
&quot;void *&quot; value, you cannot simply take a refer-
ence to a Perl variable. (Although that value certainly is a
memory address, its not the address where the variables
contents are stored.)</p>

<p>Template code &quot;P&quot; promises to pack a
&quot;pointer to a fixed length string&quot;. Isnt this what
we want? Lets try:</p>

<p># allocate some storage and pack a pointer to it my
$memory = &quot;0&quot; x $size; my $memptr = pack( P,
$memory );</p>

<p>But wait: doesnt &quot;pack&quot; just return a sequence
of bytes? How can we pass this string of bytes to some C
code expecting a pointer which is, after all, nothing but a
number? The answer is simple: We have to obtain the numeric
address from the bytes returned by &quot;pack&quot;.</p>

<p>my $ptr = unpack( L!, $memptr );</p>

<p>Obviously this assumes that it is possible to typecast a
pointer to an unsigned long and vice versa, which frequently
works but should not be taken as a universal law. - Now that
we have this pointer the next question is: How can we put it
to good use? We need a call to some C function where a
pointer is expected. The read(2) system call comes to
mind:</p>

<p>ssize_t read(int fd, void *buf, size_t count);</p>

<p>After reading perlfunc explaining how to use
&quot;syscall&quot; we can write this Perl function copying
a file to standard output:</p>

<p>require syscall.ph; sub cat($){ my $path = shift(); my
$size = -s $path; my $memory = &quot;0&quot; x $size; #
allocate some memory my $ptr = unpack( L, pack( P, $memory )
); open( F, $path ) die( &quot;$path: cannot open ($!)0 );
my $fd = fileno(F); my $res = syscall( &amp;SYS_read,
fileno(F), $ptr, $size ); print $memory; close( F ); }</p>

<p>This is neither a specimen of simplicity nor a paragon
of portability but it illustrates the point: We are able to
sneak behind the scenes and access Perls otherwise
well-guarded memory! (Important note: Perls
&quot;syscall&quot; does not require you to construct
pointers in this roundabout way. You simply pass a string
variable, and Perl forwards the address.)</p>

<p>How does &quot;unpack&quot; with &quot;P&quot; work?
Imagine some pointer in the buffer about to be unpacked: If
it isnt the null pointer (which will smartly produce the
&quot;undef&quot; value) we have a start address - but then
what? Perl has no way of knowing how long this &quot;fixed
length string&quot; is, so its up to you to specify the
actual size as an explicit length after &quot;P&quot;.</p>

<p>my $mem = &quot;abcdefghijklmn&quot;; print unpack( P5,
pack( P, $mem ) ); # prints &quot;abcde&quot;</p>

<p>As a consequence, &quot;pack&quot; ignores any number or
&quot;*&quot; after &quot;P&quot;.</p>

<p>Now that we have seen &quot;P&quot; at work, we might as
well give &quot;p&quot; a whirl. Why do we need a second
template code for packing pointers at all? The answer lies
behind the simple fact that an &quot;unpack&quot; with
&quot;p&quot; promises a null-terminated string starting at
the address taken from the buffer, and that implies a length
for the data item to be returned:</p>

<p>my $buf = pack( p, &quot;abc0efhijklmn&quot; ); print
unpack( p, $buf ); # prints &quot;abc&quot;</p>

<p>Albeit this is apt to be confusing: As a consequence of
the length being implied by the strings length, a number
after pack code &quot;p&quot; is a repeat count, not a
length as after &quot;P&quot;.</p>

<p>Using &quot;pack(..., $x)&quot; with &quot;P&quot; or
&quot;p&quot; to get the address where $x is actually stored
must be used with circumspection. Perl s internal machinery
considers the relation between a variable and that address
as its very own private matter and doesnt really care that
we have obtained a copy. Therefore:</p>

<p>&middot; Do not use &quot;pack&quot; with &quot;p&quot;
or &quot;P&quot; to obtain the address of variable thats
bound to go out of scope (and thereby freeing its memory)
before you are done with using the memory at that
address.</p>

<p>&middot; Be very careful with Perl operations that
change the value of the variable. Appending something to the
variable, for instance, might require reallocation of its
storage, leaving you with a pointer into no-mans land.</p>

<p>&middot; Don t think that you can get the address of a
Perl variable when it is stored as an integer or double
number! &quot;pack(&rsquo;P&rsquo;, $x)&quot; will force the
variables internal representation to string, just as if you
had written something like &quot;$x .=
&rsquo;&rsquo;&quot;.</p>

<p>Its safe, however, to P- or p-pack a string literal,
because Perl sim- ply allocates an anonymous variable.</p>

<p>Pack Recipes Here are a collection of (possibly) useful
canned recipes for &quot;pack&quot; and
&quot;unpack&quot;:</p>

<p># Convert IP address for socket functions pack(
&quot;C4&quot;, split /./, &quot;123.4.5.6&quot; );</p>

<p># Count the bits in a chunk of memory (e.g. a select
vector) unpack( %32b*, $mask );</p>

<p># Determine the endianness of your system
$is_little_endian = unpack( c, pack( s, 1 ) );
$is_big_endian = unpack( xc, pack( s, 1 ) );</p>

<p># Determine the number of bits in a native integer $bits
= unpack( %32I!, ~0 );</p>

<p># Prepare argument for the nanosleep system call my
$timespec = pack( L!L!, $secs, $nanosecs );</p>

<p>For a simple memory dump we unpack some bytes into just
as many pairs of hex digits, and use &quot;map&quot; to
handle the traditional spacing - 16 bytes to a line:</p>

<p>my $i; print map( ++$i % 16 ? &quot;$_ &quot; :
&quot;$_0, unpack( H2 x length( $mem ), $mem ) ), length(
$mem ) % 16 ? &quot;0 : ;</p>

<p>Funnies Section # Pulling digits out of nowhere... print
unpack( C, pack( x ) ), unpack( %B*, pack( A ) ), unpack( H,
pack( A ) ), unpack( A, unpack( C, pack( A ) ) ),
&quot;0;</p>

<p># One for the road ;-) my $advice = pack( all u can in a
van );</p>

<p>Authors Simon Cozens and Wolfgang Laun.</p>

<p>perl v5.8.8 2014-02-11 PERLPACKTUT(1)</p>
<hr>
</body>
</html>
