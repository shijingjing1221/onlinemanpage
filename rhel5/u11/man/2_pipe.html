<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:58 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PIPE(2) Linux Programmer s Manual PIPE(2)</p>

<p>NAME pipe - create pipe</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int pipe(int filedes[2]);</p>

<p>DESCRIPTION pipe() creates a pair of file descriptors,
pointing to a pipe inode, and places them in the array
pointed to by filedes. filedes[0] is for reading, filedes[1]
is for writing.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS EFAULT filedes is not valid.</p>

<p>EMFILE Too many file descriptors are in use by the
process.</p>

<p>ENFILE The system limit on the total number of open
files has been reached.</p>

<p>CONFORMING TO POSIX.1-2001.</p>

<p>EXAMPLE The following program creates a pipe, and then
fork(2)s to create a child process. After the fork(2), each
process closes the descriptors that it doesnt need for the
pipe (see pipe(7)). The parent then writes the string
contained in the program s command-line argument to the
pipe, and the child reads this string a byte at a time from
the pipe and echoes it on standard output.</p>

<p>#include &lt;sys/wait.h&gt; #include &lt;assert.h&gt;
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include
&lt;unistd.h&gt; #include &lt;string.h&gt;</p>

<p>int main(int argc, char *argv[]) { int pfd[2]; pid_t
cpid; char buf;</p>

<p>assert(argc == 2);</p>

<p>if (pipe(pfd) == -1) { perror(&quot;pipe&quot;);
exit(EXIT_FAILURE); }</p>

<p>cpid = fork(); if (cpid == -1) {
perror(&quot;fork&quot;); exit(EXIT_FAILURE); }</p>

<p>if (cpid == 0) { /* Child reads from pipe */
close(pfd[1]); /* Close unused write end */</p>

<p>while (read(pfd[0], &amp;buf, 1) &gt; 0)
write(STDOUT_FILENO, &amp;buf, 1);</p>

<p>write(STDOUT_FILENO, &quot;0, 1); close(pfd[0]);
_exit(EXIT_SUCCESS);</p>

<p>} else { /* Parent writes argv[1] to pipe */
close(pfd[0]); /* Close unused read end */ write(pfd[1],
argv[1], strlen(argv[1])); close(pfd[1]); /* Reader will see
EOF */ wait(NULL); /* Wait for child */ exit(EXIT_SUCCESS);
} }</p>

<p>SEE ALSO fork(2), read(2), socketpair(2), write(2),
popen(3), pipe(7)</p>

<p>Linux 2.6.7 2004-06-17 PIPE(2)</p>
<hr>
</body>
</html>
