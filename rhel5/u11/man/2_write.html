<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:27:35 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>WRITE(2) Linux Programmer s Manual WRITE(2)</p>

<p>NAME write - write to a file descriptor</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>ssize_t write(int fd, const void *buf, size_t
count);</p>

<p>DESCRIPTION write() writes up to count bytes to the file
referenced by the file descriptor fd from the buffer
starting at buf. POSIX requires that a read() which can be
proved to occur after a write() has returned returns the new
data. Note that not all file systems are POSIX con-
forming.</p>

<p>RETURN VALUE On success, the number of bytes written are
returned (zero indicates nothing was written). On error, -1
is returned, and errno is set appropriately. If count is
zero and the file descriptor refers to a regular file, 0 may
be returned, or an error could be detected. For a special
file, the results are not portable.</p>

<p>ERRORS EAGAIN Non-blocking I/O has been selected using
O_NONBLOCK and the write would block.</p>

<p>EBADF fd is not a valid file descriptor or is not open
for writing.</p>

<p>EFAULT buf is outside your accessible address space.</p>

<p>EFBIG An attempt was made to write a file that exceeds
the implementa- tion-defined maximum file size or the
process file size limit, or to write at a position past the
maximum allowed offset.</p>

<p>EINTR The call was interrupted by a signal before any
data was writ- ten.</p>

<p>EINVAL fd is attached to an object which is unsuitable
for writing; or the file was opened with the O_DIRECT flag,
and either the address specified in buf, the value specified
in count, or the current file offset is not suitably
aligned.</p>

<p>EIO A low-level I/O error occurred while modifying the
inode.</p>

<p>ENOSPC The device containing the file referred to by fd
has no room for the data.</p>

<p>EPIPE fd is connected to a pipe or socket whose reading
end is closed. When this happens the writing process will
also receive a SIG- PIPE signal. (Thus, the write return
value is seen only if the program catches, blocks or ignores
this signal.)</p>

<p>Other errors may occur, depending on the object
connected to fd.</p>

<p>CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001.</p>

<p>Under SVr4 a write may be interrupted and return EINTR
at any point, not just before any data is written.</p>

<p>NOTES A successful return from write() does not make any
guarantee that data has been committed to disk. In fact, on
some buggy implementations, it does not even guarantee that
space has successfully been reserved for the data. The only
way to be sure is to call fsync(2) after you are done
writing all your data.</p>

<p>SEE ALSO close(2), fcntl(2), fsync(2), ioctl(2),
lseek(2), open(2), pwrite(2), read(2), select(2), writev(3),
fwrite(3)</p>

<p>Linux 2.0.32 2001-12-13 WRITE(2)</p>
<hr>
</body>
</html>
