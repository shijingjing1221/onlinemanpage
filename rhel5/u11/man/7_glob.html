<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:12:00 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GLOB(7) Linux Programmer s Manual GLOB(7)</p>

<p>NAME glob - Globbing pathnames</p>

<p>DESCRIPTION Long ago, in Unix V6, there was a program
/etc/glob that would expand wildcard patterns. Soon
afterwards this became a shell built-in.</p>

<p>These days there is also a library routine glob(3) that
will perform this function for a user program.</p>

<p>The rules are as follows (POSIX.2, 3.13).</p>

<p>WILDCARD MATCHING A string is a wildcard pattern if it
contains one of the characters ?, * or [. Globbing is the
operation that expands a wildcard pat- tern into the list of
pathnames matching the pattern. Matching is defined by:</p>

<p>A ? (not between brackets) matches any single
character.</p>

<p>A * (not between brackets) matches any string, including
the empty string.</p>

<p>Character classes An expression [...] where the first
character after the leading [ is not an ! matches a single
character, namely any of the characters enclosed by the
brackets. The string enclosed by the brackets cannot be
empty; therefore ] can be allowed between the brackets,
provided that it is the first character. (Thus, [][!]
matches the three char- acters [, ] and !.)</p>

<p>Ranges There is one special convention: two characters
separated by - denote a range. (Thus, [A-Fa-f0-9] is
equivalent to [ABCDE- Fabcdef0123456789].) One may include -
in its literal meaning by making it the first or last
character between the brackets. (Thus, []-] matches just the
two characters ] and -, and [--0] matches the three
characters -, ., 0, since / cannot be matched.)</p>

<p>Complementation An expression [!...] matches a single
character, namely any character that is not matched by the
expression obtained by removing the first ! from it. (Thus,
[!]a-] matches any single character except ], a and -.)</p>

<p>One can remove the special meaning of ?, * and [ by
preceding them by a backslash, or, in case this is part of a
shell command line, enclosing them in quotes. Between
brackets these characters stand for themselves. Thus, [[?*]
matches the four characters [ , ?, * and .</p>

<p>PATHNAMES Globbing is applied on each of the components
of a pathname separately. A / in a pathname cannot be
matched by a ? or * wildcard, or by a range like [.-0]. A
range cannot contain an explicit / character; this would
lead to a syntax error.</p>

<p>If a filename starts with a ., this character must be
matched explicitly. (Thus, rm * will not remove .profile,
and tar c * will not archive all your files; tar c . is
better.)</p>

<p>EMPTY LISTS The nice and simple rule given above: expand
a wildcard pattern into the list of matching pathnames was
the original Unix definition. It allowed one to have
patterns that expand into an empty list, as in xv -wait 0
*.gif *.jpg where perhaps no *.gif files are present (and
this is not an error). However, POSIX requires that a
wildcard pattern is left unchanged when it is syntactically
incorrect, or the list of matching pathnames is empty. With
bash one can force the classical behaviour by setting
allow_null_glob_expansion=true.</p>

<p>(Similar problems occur elsewhere. E.g., where old
scripts have rm find . -name &quot;*~&quot; new scripts
require rm -f nosuchfile find . -name &quot;*~&quot; to
avoid error messages from rm called with an empty argument
list.)</p>

<p>NOTES Regular expressions Note that wildcard patterns
are not regular expressions, although they are a bit
similar. First of all, they match filenames, rather than
text, and secondly, the conventions are not the same: e.g.,
in a regu- lar expression * means zero or more copies of the
preceding thing.</p>

<p>Now that regular expressions have bracket expressions
where the nega- tion is indicated by a ^, POSIX has declared
the effect of a wildcard pattern [^...] to be undefined.</p>

<p>Character classes and Internationalization Of course
ranges were originally meant to be ASCII ranges, so that [
-%] stands for [ !&quot;#$%] and [a-z] stands for &quot;any
lowercase letter&quot;. Some Unix implementations
generalized this so that a range X-Y stands for the set of
characters with code between the codes for X and for Y.
However, this requires the user to know the character cod-
ing in use on the local system, and moreover, is not
convenient if the collating sequence for the local alphabet
differs from the ordering of the character codes. Therefore,
POSIX extended the bracket notation greatly, both for
wildcard patterns and for regular expressions. In the above
we saw three types of items that can occur in a bracket
expression: namely (i) the negation, (ii) explicit single
characters, and (iii) ranges. POSIX specifies ranges in an
internationally more useful way and adds three more
types:</p>

<p>(iii) Ranges X-Y comprise all characters that fall
between X and Y (inclusive) in the current collating
sequence as defined by the LC_COL- LATE category in the
current locale.</p>

<p>(iv) Named character classes, like [:alnum:] [:alpha:]
[:blank:] [:cntrl:] [:digit:] [:graph:] [:lower:] [:print:]
[:punct:] [:space:] [:upper:] [:xdigit:] so that one can say
[[:lower:]] instead of [a-z], and have things work in
Denmark, too, where there are three letters past z in the
alphabet. These character classes are defined by the
LC_CTYPE category in the current locale.</p>

<p>(v) Collating symbols, like [.ch.] or [.a-acute.] ,
where the string between [. and .] is a collating element
defined for the current locale. Note that this may be a
multi-character element.</p>

<p>(vi) Equivalence class expressions, like [=a=], where
the string between [= and =] is any collating element from
its equivalence class, as defined for the current locale.
For example, [[=a=]] might be equivalent to
[a&aacute;&agrave;&auml;&acirc;] (warning: Latin-1 here),
that is, to [a[.a-
acute.][.a-grave.][.a-umlaut.][.a-circumflex.]].</p>

<p>SEE ALSO sh(1), fnmatch(3), glob(3), locale(7),
regex(7)</p>

<p>Unix 2003-08-24 GLOB(7)</p>
<hr>
</body>
</html>
