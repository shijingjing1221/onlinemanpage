<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:46 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLSYN(1) Perl Programmers Reference Guide
PERLSYN(1)</p>

<p>NAME perlsyn - Perl syntax</p>

<p>DESCRIPTION A Perl program consists of a sequence of
declarations and statements which run from the top to the
bottom. Loops, subroutines and other control structures
allow you to jump around within the code.</p>

<p>Perl is a free-form language, you can format and indent
it however you like. Whitespace mostly serves to separate
tokens, unlike languages like Python where it is an
important part of the syntax.</p>

<p>Many of Perl s syntactic elements are optional. Rather
than requiring you to put parentheses around every function
call and declare every variable, you can often leave such
explicit elements off and Perl will figure out what you
meant. This is known as Do What I Mean, abbrevi- ated DWIM.
It allows programmers to be lazy and to code in a style with
which they are comfortable.</p>

<p>Perl borrows syntax and concepts from many languages:
awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English.
Other languages have borrowed syntax from Perl, particularly
its regular expression exten- sions. So if you have
programmed in another language you will see familiar pieces
in Perl. They often work the same, but see perltrap for
information about how they differ.</p>

<p>Declarations</p>

<p>The only things you need to declare in Perl are report
formats and sub- routines (and sometimes not even
subroutines). A variable holds the undefined value
(&quot;undef&quot;) until it has been assigned a defined
value, which is anything other than &quot;undef&quot;. When
used as a number, &quot;undef&quot; is treated as 0; when
used as a string, it is treated as the empty string,
&quot;&quot;; and when used as a reference that isn t being
assigned to, it is treated as an error. If you enable
warnings, youll be notified of an uninitialized value
whenever you treat &quot;undef&quot; as a string or a
number. Well, usually. Boolean contexts, such as:</p>

<p>my $a; if ($a) {}</p>

<p>are exempt from warnings (because they care about truth
rather than definedness). Operators such as &quot;++&quot;,
&quot;--&quot;, &quot;+=&quot;, &quot;-=&quot;, and
&quot;.=&quot;, that operate on undefined left values such
as:</p>

<p>my $a; $a++;</p>

<p>are also always exempt from such warnings.</p>

<p>A declaration can be put anywhere a statement can, but
has no effect on the execution of the primary sequence of
statements--declarations all take effect at compile time.
Typically all the declarations are put at the beginning or
the end of the script. However, if youre using lexi-
cally-scoped private variables created with
&quot;my()&quot;, youll have to make sure your format or
subroutine definition is within the same block scope as the
my if you expect to be able to access those private vari-
ables.</p>

<p>Declaring a subroutine allows a subroutine name to be
used as if it were a list operator from that point forward
in the program. You can declare a subroutine without
defining it by saying &quot;sub name&quot;, thus:</p>

<p>sub myname; $me = myname $0 or die &quot;cant get
myname&quot;;</p>

<p>Note that myname() functions as a list operator, not as
a unary opera- tor; so be careful to use &quot;or&quot;
instead of &quot;&quot; in this case. However, if you were
to declare the subroutine as &quot;sub myname ($)&quot;,
then &quot;myname&quot; would function as a unary operator,
so either &quot;or&quot; or &quot;&quot; would work.</p>

<p>Subroutines declarations can also be loaded up with the
&quot;require&quot; statement or both loaded and imported
into your namespace with a &quot;use&quot; statement. See
perlmod for details on this.</p>

<p>A statement sequence may contain declarations of
lexically-scoped vari- ables, but apart from declaring a
variable name, the declaration acts like an ordinary
statement, and is elaborated within the sequence of
statements as if it were an ordinary statement. That means
it actually has both compile-time and run-time effects.</p>

<p>Comments</p>

<p>Text from a &quot;#&quot; character until the end of the
line is a comment, and is ignored. Exceptions include
&quot;#&quot; inside a string or regular expres- sion.</p>

<p>Simple Statements</p>

<p>The only kind of simple statement is an expression
evaluated for its side effects. Every simple statement must
be terminated with a semi- colon, unless it is the final
statement in a block, in which case the semicolon is
optional. (A semicolon is still encouraged if the block
takes up more than one line, because you may eventually add
another line.) Note that there are some operators like
&quot;eval {}&quot; and &quot;do {}&quot; that look like
compound statements, but arent (theyre just TERMs in an
expression), and thus need an explicit termination if used
as the last item in a statement.</p>

<p>Truth and Falsehood</p>

<p>The number 0, the strings &rsquo;0&rsquo; and
&rsquo;&rsquo;, the empty list &quot;()&quot;, and
&quot;undef&quot; are all false in a boolean context. All
other values are true. Nega- tion of a true value by
&quot;!&quot; or &quot;not&quot; returns a special false
value. When evaluated as a string it is treated as
&rsquo;&rsquo;, but as a number, it is treated as 0.</p>

<p>Statement Modifiers</p>

<p>Any simple statement may optionally be followed by a
SINGLE modifier, just before the terminating semicolon (or
block ending). The possible modifiers are:</p>

<p>if EXPR unless EXPR while EXPR until EXPR foreach
LIST</p>

<p>The &quot;EXPR&quot; following the modifier is referred
to as the &quot;condition&quot;. Its truth or falsehood
determines how the modifier will behave.</p>

<p>&quot;if&quot; executes the statement once if and only
if the condition is true. &quot;unless&quot; is the
opposite, it executes the statement unless the condi- tion
is true (i.e., if the condition is false).</p>

<p>print &quot;Basset hounds got long ears&quot; if length
$ear &gt;= 10; go_outside() and play() unless
$is_raining;</p>

<p>The &quot;foreach&quot; modifier is an iterator: it
executes the statement once for each item in the LIST (with
$_ aliased to each item in turn).</p>

<p>print &quot;Hello $_!0 foreach qw(world Dolly
nurse);</p>

<p>&quot;while&quot; repeats the statement while the
condition is true. &quot;until&quot; does the opposite, it
repeats the statement until the condition is true (or while
the condition is false):</p>

<p># Both of these count from 0 to 10. print $i++ while $i
&lt;= 10; print $j++ until $j &gt; 10;</p>

<p>The &quot;while&quot; and &quot;until&quot; modifiers
have the usual &quot;&quot;while&quot; loop&quot; seman-
tics (conditional evaluated first), except when applied to a
&quot;do&quot;-BLOCK (or to the deprecated
&quot;do&quot;-SUBROUTINE statement), in which case the
block executes once before the conditional is evaluated.
This is so that you can write loops like:</p>

<p>do { $line = &lt;STDIN&gt;; ... } until $line eq
&quot;.0;</p>

<p>See &quot;do&quot; in perlfunc. Note also that the loop
control statements described later will NOT work in this
construct, because modifiers dont take loop labels. Sorry.
You can always put another block inside of it (for
&quot;next&quot;) or around it (for &quot;last&quot;) to do
that sort of thing. For &quot;next&quot;, just double the
braces:</p>

<p>do {{ next if $x == $y; # do something here }} until
$x++ &gt; $z;</p>

<p>For &quot;last&quot;, you have to be more elaborate:</p>

<p>LOOP: { do { last if $x = $y**2; # do something here }
while $x++ &lt;= $z; }</p>

<p>NOTE: The behaviour of a &quot;my&quot; statement
modified with a statement modi- fier conditional or loop
construct (e.g. &quot;my $x if ...&quot;) is undefined. The
value of the &quot;my&quot; variable may be
&quot;undef&quot;, any previously assigned value, or
possibly anything else. Don t rely on it. Future versions of
perl might do something different from the version of perl
you try it out on. Here be dragons.</p>

<p>Compound Statements</p>

<p>In Perl, a sequence of statements that defines a scope
is called a block. Sometimes a block is delimited by the
file containing it (in the case of a required file, or the
program as a whole), and sometimes a block is delimited by
the extent of a string (in the case of an eval).</p>

<p>But generally, a block is delimited by curly brackets,
also known as braces. We will call this syntactic construct
a BLOCK.</p>

<p>The following compound statements may be used to control
flow:</p>

<p>if (EXPR) BLOCK if (EXPR) BLOCK else BLOCK if (EXPR)
BLOCK elsif (EXPR) BLOCK ... else BLOCK LABEL while (EXPR)
BLOCK LABEL while (EXPR) BLOCK continue BLOCK LABEL until
(EXPR) BLOCK LABEL until (EXPR) BLOCK continue BLOCK LABEL
for (EXPR; EXPR; EXPR) BLOCK LABEL foreach VAR (LIST) BLOCK
LABEL foreach VAR (LIST) BLOCK continue BLOCK LABEL BLOCK
continue BLOCK</p>

<p>Note that, unlike C and Pascal, these are defined in
terms of BLOCKs, not statements. This means that the curly
brackets are required--no dangling statements allowed. If
you want to write conditionals without curly brackets there
are several other ways to do it. The following all do the
same thing:</p>

<p>if (!open(FOO)) { die &quot;Cant open $FOO: $!&quot;; }
die &quot;Cant open $FOO: $!&quot; unless open(FOO);
open(FOO) or die &quot;Cant open $FOO: $!&quot;; # FOO or
bust! open(FOO) ? hi mom : die &quot;Cant open $FOO:
$!&quot;; # a bit exotic, that last one</p>

<p>The &quot;if&quot; statement is straightforward. Because
BLOCKs are always bounded by curly brackets, there is never
any ambiguity about which &quot;if&quot; an &quot;else&quot;
goes with. If you use &quot;unless&quot; in place of
&quot;if&quot;, the sense of the test is reversed.</p>

<p>The &quot;while&quot; statement executes the block as
long as the expression is true (does not evaluate to the
null string &quot;&quot; or 0 or &quot;0&quot;). The
&quot;until&quot; statement executes the block as long as
the expression is false. The LABEL is optional, and if
present, consists of an identi- fier followed by a colon.
The LABEL identifies the loop for the loop control
statements &quot;next&quot;, &quot;last&quot;, and
&quot;redo&quot;. If the LABEL is omit- ted, the loop
control statement refers to the innermost enclosing loop.
This may include dynamically looking back your call-stack at
run time to find the LABEL. Such desperate behavior triggers
a warning if you use the &quot;use warnings&quot; pragma or
the -w flag.</p>

<p>If there is a &quot;continue&quot; BLOCK, it is always
executed just before the conditional is about to be
evaluated again. Thus it can be used to increment a loop
variable, even when the loop has been continued via the
&quot;next&quot; statement.</p>

<p>Loop Control</p>

<p>The &quot;next&quot; command starts the next iteration
of the loop:</p>

<p>LINE: while (&lt;STDIN&gt;) { next LINE if /^#/; #
discard comments ... }</p>

<p>The &quot;last&quot; command immediately exits the loop
in question. The &quot;con- tinue&quot; block, if any, is
not executed:</p>

<p>LINE: while (&lt;STDIN&gt;) { last LINE if /^$/; # exit
when done with header ... }</p>

<p>The &quot;redo&quot; command restarts the loop block
without evaluating the con- ditional again. The
&quot;continue&quot; block, if any, is not executed. This
command is normally used by programs that want to lie to
themselves about what was just input.</p>

<p>For example, when processing a file like /etc/termcap.
If your input lines might end in backslashes to indicate
continuation, you want to skip ahead and get the next
record.</p>

<p>while (&lt;&gt;) { chomp; if (s/\$//) { $_ .= &lt;&gt;;
redo unless eof(); } # now process $_ }</p>

<p>which is Perl short-hand for the more explicitly written
version:</p>

<p>LINE: while (defined($line = &lt;ARGV&gt;)) {
chomp($line); if ($line =~ s/\$//) { $line .= &lt;ARGV&gt;;
redo LINE unless eof(); # not eof(ARGV)! } # now process
$line }</p>

<p>Note that if there were a &quot;continue&quot; block on
the above code, it would get executed only on lines
discarded by the regex (since redo skips the continue
block). A continue block is often used to reset line
counters or &quot;?pat?&quot; one-time matches:</p>

<p># inspired by :1,$g/fred/s//WILMA/ while (&lt;&gt;) {
?(fred)? &amp;&amp; s//WILMA $1 WILMA/; ?(barney)?
&amp;&amp; s//BETTY $1 BETTY/; ?(homer)? &amp;&amp; s//MARGE
$1 MARGE/; } continue { print &quot;$ARGV $.: $_&quot;;
close ARGV if eof(); # reset $. reset if eof(); # reset
?pat? }</p>

<p>If the word &quot;while&quot; is replaced by the word
&quot;until&quot;, the sense of the test is reversed, but
the conditional is still tested before the first
iteration.</p>

<p>The loop control statements don t work in an
&quot;if&quot; or &quot;unless&quot;, since they arent
loops. You can double the braces to make them such,
though.</p>

<p>if (/pattern/) {{ last if /fred/; next if /barney/; #
same effect as &quot;last&quot;, but doesnt document as well
# do something here }}</p>

<p>This is caused by the fact that a block by itself acts
as a loop that executes once, see &quot;Basic BLOCKs and
Switch Statements&quot;.</p>

<p>The form &quot;while/if BLOCK BLOCK&quot;, available in
Perl 4, is no longer available. Replace any occurrence of
&quot;if BLOCK&quot; by &quot;if (do BLOCK)&quot;.</p>

<p>For Loops</p>

<p>Perls C-style &quot;for&quot; loop works like the
corresponding &quot;while&quot; loop; that means that
this:</p>

<p>for ($i = 1; $i &lt; 10; $i++) { ... }</p>

<p>is the same as this:</p>

<p>$i = 1; while ($i &lt; 10) { ... } continue { $i++;
}</p>

<p>There is one minor difference: if variables are declared
with &quot;my&quot; in the initialization section of the
&quot;for&quot;, the lexical scope of those variables is
exactly the &quot;for&quot; loop (the body of the loop and
the con- trol sections).</p>

<p>Besides the normal array index looping, &quot;for&quot;
can lend itself to many other interesting applications.
Heres one that avoids the problem you get into if you
explicitly test for end-of-file on an interactive file
descriptor causing your program to appear to hang.</p>

<p>$on_a_tty = -t STDIN &amp;&amp; -t STDOUT; sub prompt {
print &quot;yes? &quot; if $on_a_tty } for ( prompt();
&lt;STDIN&gt;; prompt() ) { # do something }</p>

<p>Using &quot;readline&quot; (or the operator form,
&quot;&lt;EXPR&gt;&quot;) as the conditional of a
&quot;for&quot; loop is shorthand for the following. This
behaviour is the same as a &quot;while&quot; loop
conditional.</p>

<p>for ( prompt(); defined( $_ = &lt;STDIN&gt; ); prompt()
) { # do something }</p>

<p>Foreach Loops</p>

<p>The &quot;foreach&quot; loop iterates over a normal list
value and sets the vari- able VAR to be each element of the
list in turn. If the variable is preceded with the keyword
&quot;my&quot;, then it is lexically scoped, and is
therefore visible only within the loop. Otherwise, the
variable is implicitly local to the loop and regains its
former value upon exiting the loop. If the variable was
previously declared with &quot;my&quot;, it uses that
variable instead of the global one, but its still localized
to the loop. This implicit localisation occurs only in a
&quot;foreach&quot; loop.</p>

<p>The &quot;foreach&quot; keyword is actually a synonym
for the &quot;for&quot; keyword, so you can use
&quot;foreach&quot; for readability or &quot;for&quot; for
brevity. (Or because the Bourne shell is more familiar to
you than csh, so writing &quot;for&quot; comes more
naturally.) If VAR is omitted, $_ is set to each value.</p>

<p>If any element of LIST is an lvalue, you can modify it
by modifying VAR inside the loop. Conversely, if any element
of LIST is NOT an lvalue, any attempt to modify that element
will fail. In other words, the &quot;foreach&quot; loop
index variable is an implicit alias for each item in the
list that youre looping over.</p>

<p>If any part of LIST is an array, &quot;foreach&quot;
will get very confused if you add or remove elements within
the loop body, for example with &quot;splice&quot;. So dont
do that.</p>

<p>&quot;foreach&quot; probably won t do what you expect if
VAR is a tied or other special variable. Dont do that
either.</p>

<p>Examples:</p>

<p>for (@ary) { s/foo/bar/ }</p>

<p>for my $elem (@elements) { $elem *= 2; }</p>

<p>for $count (10,9,8,7,6,5,4,3,2,1,BOOM) { print $count,
&quot;0; sleep(1); }</p>

<p>for (1..15) { print &quot;Merry Christmas0; }</p>

<p>foreach $item (split(/:[\0]*/, $ENV{TERMCAP})) { print
&quot;Item: $item0; }</p>

<p>Heres how a C programmer might code up a particular
algorithm in Perl:</p>

<p>for (my $i = 0; $i &lt; @ary1; $i++) { for (my $j = 0;
$j &lt; @ary2; $j++) { if ($ary1[$i] &gt; $ary2[$j]) { last;
# cant go to outer :-( } $ary1[$i] += $ary2[$j]; } # this is
where that last takes me }</p>

<p>Whereas heres how a Perl programmer more comfortable
with the idiom might do it:</p>

<p>OUTER: for my $wid (@ary1) { INNER: for my $jet (@ary2)
{ next OUTER if $wid &gt; $jet; $wid += $jet; } }</p>

<p>See how much easier this is? It s cleaner, safer, and
faster. Its cleaner because its less noisy. Its safer
because if code gets added between the inner and outer loops
later on, the new code wont be acci- dentally executed. The
&quot;next&quot; explicitly iterates the other loop rather
than merely terminating the inner one. And it s faster
because Perl executes a &quot;foreach&quot; statement more
rapidly than it would the equivalent &quot;for&quot;
loop.</p>

<p>Basic BLOCKs and Switch Statements</p>

<p>A BLOCK by itself (labeled or not) is semantically
equivalent to a loop that executes once. Thus you can use
any of the loop control state- ments in it to leave or
restart the block. (Note that this is NOT true in
&quot;eval{}&quot;, &quot;sub{}&quot;, or contrary to
popular belief &quot;do{}&quot; blocks, which do NOT count
as loops.) The &quot;continue&quot; block is optional.</p>

<p>The BLOCK construct is particularly nice for doing case
structures.</p>

<p>SWITCH: { if (/^abc/) { $abc = 1; last SWITCH; } if
(/^def/) { $def = 1; last SWITCH; } if (/^xyz/) { $xyz = 1;
last SWITCH; } $nothing = 1; }</p>

<p>There is no official &quot;switch&quot; statement in
Perl, because there are already several ways to write the
equivalent.</p>

<p>However, starting from Perl 5.8 to get switch and case
one can use the Switch extension and say:</p>

<p>use Switch;</p>

<p>after which one has switch and case. It is not as fast
as it could be because it s not really part of the language
(its done using source filters) but it is available, and its
very flexible.</p>

<p>In addition to the above BLOCK construct, you could
write</p>

<p>SWITCH: { $abc = 1, last SWITCH if /^abc/; $def = 1,
last SWITCH if /^def/; $xyz = 1, last SWITCH if /^xyz/;
$nothing = 1; }</p>

<p>(Thats actually not as strange as it looks once you
realize that you can use loop control &quot;operators&quot;
within an expression. Thats just the binary comma operator
in scalar context. See &quot;Comma Operator&quot; in per-
lop.)</p>

<p>or</p>

<p>SWITCH: { /^abc/ &amp;&amp; do { $abc = 1; last SWITCH;
}; /^def/ &amp;&amp; do { $def = 1; last SWITCH; }; /^xyz/
&amp;&amp; do { $xyz = 1; last SWITCH; }; $nothing = 1;
}</p>

<p>or formatted so it stands out more as a
&quot;proper&quot; &quot;switch&quot; statement:</p>

<p>SWITCH: { /^abc/ &amp;&amp; do { $abc = 1; last SWITCH;
};</p>

<p>/^def/ &amp;&amp; do { $def = 1; last SWITCH; };</p>

<p>/^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };
$nothing = 1; }</p>

<p>or</p>

<p>SWITCH: { /^abc/ and $abc = 1, last SWITCH; /^def/ and
$def = 1, last SWITCH; /^xyz/ and $xyz = 1, last SWITCH;
$nothing = 1; }</p>

<p>or even, horrors,</p>

<p>if (/^abc/) { $abc = 1 } elsif (/^def/) { $def = 1 }
elsif (/^xyz/) { $xyz = 1 } else { $nothing = 1 }</p>

<p>A common idiom for a &quot;switch&quot; statement is to
use &quot;foreach&quot;s aliasing to make a temporary
assignment to $_ for convenient matching:</p>

<p>SWITCH: for ($where) { /In Card Names/ &amp;&amp; do {
push @flags, -e; last; }; /Anywhere/ &amp;&amp; do { push
@flags, -h; last; }; /In Rulings/ &amp;&amp; do { last; };
die &quot;unknown value for form variable where:
$where&quot;; }</p>

<p>Another interesting approach to a switch statement is
arrange for a &quot;do&quot; block to return the proper
value:</p>

<p>$amode = do { if ($flag &amp; O_RDONLY) { &quot;r&quot;
} # XXX: isn t this 0? elsif ($flag &amp; O_WRONLY) { ($flag
&amp; O_APPEND) ? &quot;a&quot; : &quot;w&quot; } elsif
($flag &amp; O_RDWR) { if ($flag &amp; O_CREAT) {
&quot;w+&quot; } else { ($flag &amp; O_APPEND) ?
&quot;a+&quot; : &quot;r+&quot; } } };</p>

<p>Or</p>

<p>print do { ($flags &amp; O_WRONLY) ?
&quot;write-only&quot; : ($flags &amp; O_RDWR) ?
&quot;read-write&quot; : &quot;read-only&quot;; };</p>

<p>Or if you are certain that all the
&quot;&amp;&amp;&quot; clauses are true, you can use
something like this, which &quot;switches&quot; on the value
of the &quot;HTTP_USER_AGENT&quot; environment variable.</p>

<p>#!/usr/bin/perl # pick out jargon file page based on
browser $dir = http://www.wins.uva.nl/~mes/jargon; for
($ENV{HTTP_USER_AGENT}) { $page = /Mac/ &amp;&amp;
m/Macintrash.html /Win(dows )?NT/ &amp;&amp;
e/evilandrude.html /Win MSIE WebTV/ &amp;&amp;
m/MicroslothWindows.html /Linux/ &amp;&amp; l/Linux.html
/HP-UX/ &amp;&amp; h/HP-SUX.html /SunOS/ &amp;&amp;
s/ScumOS.html a/AppendixB.html; } print &quot;Location:
$dir/$page 15 12 15 12&quot;;</p>

<p>That kind of switch statement only works when you know
the &quot;&amp;&amp;&quot; clauses will be true. If you
dont, the previous &quot;?:&quot; example should be
used.</p>

<p>You might also consider writing a hash of subroutine
references instead of synthesizing a &quot;switch&quot;
statement.</p>

<p>Goto</p>

<p>Although not for the faint of heart, Perl does support a
&quot;goto&quot; statement. There are three forms:
&quot;goto&quot;-LABEL, &quot;goto&quot;-EXPR, and
&quot;goto&quot;-&amp;NAME. A loop s LABEL is not actually a
valid target for a &quot;goto&quot;; its just the name of
the loop.</p>

<p>The &quot;goto&quot;-LABEL form finds the statement
labeled with LABEL and resumes execution there. It may not
be used to go into any construct that requires
initialization, such as a subroutine or a
&quot;foreach&quot; loop. It also can t be used to go into a
construct that is optimized away. It can be used to go
almost anywhere else within the dynamic scope, including out
of subroutines, but its usually better to use some other
construct such as &quot;last&quot; or &quot;die&quot;. The
author of Perl has never felt the need to use this form of
&quot;goto&quot; (in Perl, that is--C is another
matter).</p>

<p>The &quot;goto&quot;-EXPR form expects a label name,
whose scope will be resolved dynamically. This allows for
computed &quot;goto&quot;s per FORTRAN, but isnt necessarily
recommended if you re optimizing for maintainability:</p>

<p>goto((&quot;FOO&quot;, &quot;BAR&quot;,
&quot;GLARCH&quot;)[$i]);</p>

<p>The &quot;goto&quot;-&amp;NAME form is highly magical,
and substitutes a call to the named subroutine for the
currently running subroutine. This is used by
&quot;AUTOLOAD()&quot; subroutines that wish to load another
subroutine and then pretend that the other subroutine had
been called in the first place (except that any
modifications to @_ in the current subroutine are propagated
to the other subroutine.) After the &quot;goto&quot;, not
even &quot;caller()&quot; will be able to tell that this
routine was called first.</p>

<p>In almost all cases like this, it s usually a far, far
better idea to use the structured control flow mechanisms of
&quot;next&quot;, &quot;last&quot;, or &quot;redo&quot;
instead of resorting to a &quot;goto&quot;. For certain
applications, the catch and throw pair of &quot;eval{}&quot;
and die() for exception processing can also be a prudent
approach.</p>

<p>PODs: Embedded Documentation</p>

<p>Perl has a mechanism for intermixing documentation with
source code. While it s expecting the beginning of a new
statement, if the compiler encounters a line that begins
with an equal sign and a word, like this</p>

<p>=head1 Here There Be Pods!</p>

<p>Then that text and all remaining text up through and
including a line beginning with &quot;=cut&quot; will be
ignored. The format of the intervening text is described in
perlpod.</p>

<p>This allows you to intermix your source code and your
documentation text freely, as in</p>

<p>=item snazzle($)</p>

<p>The snazzle() function will behave in the most
spectacular form that you can possibly imagine, not even
excepting cybernetic pyrotechnics.</p>

<p>=cut back to the compiler, nuff of this pod stuff!</p>

<p>sub snazzle($) { my $thingie = shift; ......... }</p>

<p>Note that pod translators should look at only paragraphs
beginning with a pod directive (it makes parsing easier),
whereas the compiler actu- ally knows to look for pod
escapes even in the middle of a paragraph. This means that
the following secret stuff will be ignored by both the
compiler and the translators.</p>

<p>$a=3; =secret stuff warn &quot;Neither POD nor
CODE!?&quot; =cut back print &quot;got $a0;</p>

<p>You probably shouldnt rely upon the &quot;warn()&quot;
being podded out forever. Not all pod translators are
well-behaved in this regard, and perhaps the compiler will
become pickier.</p>

<p>One may also use pod directives to quickly comment out a
section of code.</p>

<p>Plain Old Comments (Not!)</p>

<p>Perl can process line directives, much like the C
preprocessor. Using this, one can control Perls idea of
filenames and line numbers in error or warning messages
(especially for strings that are processed with
&quot;eval()&quot;). The syntax for this mechanism is the
same as for most C preprocessors: it matches the regular
expression</p>

<p># example: # line 42 &quot;new_filename.plx&quot; /^
line (+) (?:?)([^&quot;]+)2)? $/x</p>

<p>with $1 being the line number for the next line, and $3
being the optional filename (specified with or without
quotes).</p>

<p>There is a fairly obvious gotcha included with the line
directive: Debuggers and profilers will only show the last
source line to appear at a particular line number in a given
file. Care should be taken not to cause line number
collisions in code youd like to debug later.</p>

<p>Here are some examples that you should be able to type
into your com- mand shell:</p>

<p>% perl # line 200 &quot;bzzzt&quot; # the # on the
previous line must be the first char on line die foo;
__END__ foo at bzzzt line 201.</p>

<p>% perl # line 200 &quot;bzzzt&quot; eval qq[0line 2001
&quot;&quot;0ie foo]; print $@; __END__ foo at - line
2001.</p>

<p>% perl eval qq[0line 200 &quot;foo bar&quot;0ie foo];
print $@; __END__ foo at foo bar line 200.</p>

<p>% perl # line 345 &quot;goop&quot; eval &quot;0line
&quot; . __LINE__ . &quot; . __FILE__ .&quot; print $@;
__END__ foo at goop line 345.</p>

<p>perl v5.8.8 2014-02-11 PERLSYN(1)</p>
<hr>
</body>
</html>
