<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:23:11 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>SIGACTION(2) Linux Programmer s Manual SIGACTION(2)</p>

<p>NAME sigaction - examine and change a signal action</p>

<p>SYNOPSIS #include &lt;signal.h&gt;</p>

<p>int sigaction(int signum, const struct sigaction *act,
struct sigaction *oldact);</p>

<p>DESCRIPTION The sigaction() system call is used to
change the action taken by a process on receipt of a
specific signal.</p>

<p>signum specifies the signal and can be any valid signal
except SIGKILL and SIGSTOP.</p>

<p>If act is non-null, the new action for signal signum is
installed from act. If oldact is non-null, the previous
action is saved in oldact.</p>

<p>The sigaction structure is defined as something like</p>

<p>struct sigaction { void (*sa_handler)(int); void
(*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask;
int sa_flags; void (*sa_restorer)(void); }</p>

<p>On some architectures a union is involved: do not assign
to both sa_handler and sa_sigaction.</p>

<p>The sa_restorer element is obsolete and should not be
used. POSIX does not specify a sa_restorer element.</p>

<p>sa_handler specifies the action to be associated with
signum and may be SIG_DFL for the default action, SIG_IGN to
ignore this signal, or a pointer to a signal handling
function. This function receives the sig- nal number as its
only argument.</p>

<p>If SA_SIGINFO is specified in sa_flags, then
sa_sigaction (instead of sa_handler) specifies the
signal-handling function for signum. This function receives
the signal number as its first argument, a pointer to a
siginfo_t as its second argument and a pointer to a
ucontext_t (cast to void *) as its third argument.</p>

<p>sa_mask gives a mask of signals which should be blocked
during execu- tion of the signal handler. In addition, the
signal which triggered the handler will be blocked, unless
the SA_NODEFER flag is used.</p>

<p>sa_flags specifies a set of flags which modify the
behaviour of the signal handling process. It is formed by
the bitwise OR of zero or more of the following:</p>

<p>SA_NOCLDSTOP If signum is SIGCHLD, do not receive
notification when child processes stop (i.e., when they
receive one of SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU) or
resume (i.e., they receive SIGCONT) (see wait(2)).</p>

<p>SA_NOCLDWAIT (Linux 2.6 and later) If signum is SIGCHLD,
do not trans- form children into zombies when they
terminate. See also waitpid(2).</p>

<p>SA_RESETHAND Restore the signal action to the default
state once the signal handler has been called. SA_ONESHOT is
an obso- lete, non-standard synonym for this flag.</p>

<p>SA_ONSTACK Call the signal handler on an alternate
signal stack pro- vided by sigaltstack(2). If an alternate
stack is not available, the default stack will be used.</p>

<p>SA_RESTART Provide behaviour compatible with BSD signal
semantics by making certain system calls restartable across
signals.</p>

<p>SA_NODEFER Do not prevent the signal from being received
from within its own signal handler. SA_NOMASK is an
obsolete, non- standard synonym for this flag.</p>

<p>SA_SIGINFO The signal handler takes 3 arguments, not
one. In this case, sa_sigaction should be set instead of
sa_handler. (The sa_sigaction field was added in Linux
2.1.86.)</p>

<p>The siginfo_t parameter to sa_sigaction is a struct with
the following elements</p>

<p>siginfo_t { int si_signo; /* Signal number */ int
si_errno; /* An errno value */ int si_code; /* Signal code
*/ pid_t si_pid; /* Sending process ID */ uid_t si_uid; /*
Real user ID of sending process */ int si_status; /* Exit
value or signal */ clock_t si_utime; /* User time consumed
*/ clock_t si_stime; /* System time consumed */ sigval_t
si_value; /* Signal value */ int si_int; /* POSIX.1b signal
*/ void * si_ptr; /* POSIX.1b signal */ void * si_addr; /*
Memory location which caused fault */ int si_band; /* Band
event */ int si_fd; /* File descriptor */ }</p>

<p>si_signo, si_errno and si_code are defined for all
signals. (si_signo is unused on Linux.) The rest of the
struct may be a union, so that one should only read the
fields that are meaningful for the given sig- nal. POSIX.1b
signals and SIGCHLD fill in si_pid and si_uid. SIGCHLD also
fills in si_status, si_utime and si_stime. si_int and si_ptr
are specified by the sender of the POSIX.1b signal. SIGILL,
SIGFPE, SIGSEGV, and SIGBUS fill in si_addr with the address
of the fault. SIGPOLL fills in si_band and si_fd.</p>

<p>si_code indicates why this signal was sent. It is a
value, not a bit- mask. The values which are possible for
any signal are listed in this table:</p>


<p>+-------------------------------------------------------------------+
| si_code |
+-----------+-------------------------------------------------------+
|Value | Signal origin |
+-----------+-------------------------------------------------------+
|SI_USER | kill(), sigsend(), or raise() |
+-----------+-------------------------------------------------------+
|SI_KERNEL | The kernel |
+-----------+-------------------------------------------------------+
|SI_QUEUE | sigqueue() |
+-----------+-------------------------------------------------------+
|SI_TIMER | POSIX timer expired |
+-----------+-------------------------------------------------------+
|SI_MESGQ | POSIX message queue state changed (since Linux
2.6.6) |
+-----------+-------------------------------------------------------+
|SI_ASYNCIO | AIO completed |
+-----------+-------------------------------------------------------+
|SI_SIGIO | queued SIGIO |
+-----------+-------------------------------------------------------+
|SI_TKILL | tkill() or tgkill() (since Linux 2.4.19) |
+-----------+-------------------------------------------------------+</p>

<p>+-------------------------------------+ | SIGILL |
+-----------+-------------------------+ |ILL_ILLOPC |
illegal opcode | +-----------+-------------------------+
|ILL_ILLOPN | illegal operand |
+-----------+-------------------------+ |ILL_ILLADR |
illegal addressing mode |
+-----------+-------------------------+ |ILL_ILLTRP |
illegal trap | +-----------+-------------------------+
|ILL_PRVOPC | privileged opcode |
+-----------+-------------------------+ |ILL_PRVREG |
privileged register |
+-----------+-------------------------+ |ILL_COPROC |
coprocessor error | +-----------+-------------------------+
|ILL_BADSTK | internal stack error |
+-----------+-------------------------+</p>

<p>+----------------------------------------------+ |
SIGFPE | +-----------+----------------------------------+
|FPE_INTDIV | integer divide by zero |
+-----------+----------------------------------+ |FPE_INTOVF
| integer overflow |
+-----------+----------------------------------+ |FPE_FLTDIV
| floating point divide by zero |
+-----------+----------------------------------+ |FPE_FLTOVF
| floating point overflow |
+-----------+----------------------------------+ |FPE_FLTUND
| floating point underflow |
+-----------+----------------------------------+ |FPE_FLTRES
| floating point inexact result |
+-----------+----------------------------------+ |FPE_FLTINV
| floating point invalid operation |
+-----------+----------------------------------+ |FPE_FLTSUB
| subscript out of range |
+-----------+----------------------------------+</p>

<p>+----------------------------------------------------+ |
SIGSEGV |
+------------+---------------------------------------+
|SEGV_MAPERR | address not mapped to object |
+------------+---------------------------------------+
|SEGV_ACCERR | invalid permissions for mapped object |
+------------+---------------------------------------+</p>

<p>+--------------------------------------------+ | SIGBUS
| +-----------+--------------------------------+ |BUS_ADRALN
| invalid address alignment |
+-----------+--------------------------------+ |BUS_ADRERR |
non-existent physical address |
+-----------+--------------------------------+ |BUS_OBJERR |
object specific hardware error |
+-----------+--------------------------------+</p>

<p>+--------------------------------+ | SIGTRAP |
+-----------+--------------------+ |TRAP_BRKPT | process
breakpoint | +-----------+--------------------+ |TRAP_TRACE
| process trace trap |
+-----------+--------------------+</p>


<p>+----------------------------------------------------------------+
| SIGCHLD |
+--------------+-------------------------------------------------+
|CLD_EXITED | child has exited |
+--------------+-------------------------------------------------+
|CLD_KILLED | child was killed |
+--------------+-------------------------------------------------+
|CLD_DUMPED | child terminated abnormally |
+--------------+-------------------------------------------------+
|CLD_TRAPPED | traced child has trapped |
+--------------+-------------------------------------------------+
|CLD_STOPPED | child has stopped |
+--------------+-------------------------------------------------+
|CLD_CONTINUED | stopped child has continued (since Linux
2.6.9) |
+--------------+-------------------------------------------------+</p>

<p>+-----------------------------------------+ | SIGPOLL |
+---------+-------------------------------+ |POLL_IN | data
input available |
+---------+-------------------------------+ |POLL_OUT |
output buffers available |
+---------+-------------------------------+ |POLL_MSG |
input message available |
+---------+-------------------------------+ |POLL_ERR | i/o
error | +---------+-------------------------------+
|POLL_PRI | high priority input available |
+---------+-------------------------------+ |POLL_HUP |
device disconnected |
+---------+-------------------------------+</p>

<p>RETURN VALUE sigaction() returns 0 on success and -1 on
error.</p>

<p>ERRORS EFAULT act or oldact points to memory which is
not a valid part of the process address space.</p>

<p>EINVAL An invalid signal was specified. This will also
be generated if an attempt is made to change the action for
SIGKILL or SIGSTOP, which cannot be caught or ignored.</p>

<p>NOTES According to POSIX, the behaviour of a process is
undefined after it ignores a SIGFPE, SIGILL, or SIGSEGV
signal that was not generated by kill() or raise(). Integer
division by zero has undefined result. On some architectures
it will generate a SIGFPE signal. (Also dividing the most
negative integer by -1 may generate SIGFPE.) Ignoring this
signal might lead to an endless loop.</p>

<p>POSIX.1-1990 disallowed setting the action for SIGCHLD
to SIG_IGN. POSIX.1-2001 allows this possibility, so that
ignoring SIGCHLD can be used to prevent the creation of
zombies (see wait(2)). Nevertheless, the historical BSD and
System V behaviours for ignoring SIGCHLD differ, so that the
only completely portable method of ensuring that terminated
children do not become zombies is to catch the SIGCHLD
signal and per- form a wait(2) or similar.</p>

<p>POSIX.1-1990 only specified SA_NOCLDSTOP. POSIX.1-2001
added SA_NOCLD- WAIT, SA_RESETHAND, SA_NODEFER, and
SA_SIGINFO. Use of these latter values in sa_flags may be
less portable in applications intended for older Unix
implementations.</p>

<p>Support for SA_SIGINFO was added in Linux 2.2.</p>

<p>The SA_RESETHAND flag is compatible with the SVr4 flag
of the same name.</p>

<p>The SA_NODEFER flag is compatible with the SVr4 flag of
the same name under kernels 1.3.9 and newer. On older
kernels the Linux implementa- tion allowed the receipt of
any signal, not just the one we are installing (effectively
overriding any sa_mask settings).</p>

<p>sigaction() can be called with a null second argument to
query the cur- rent signal handler. It can also be used to
check whether a given sig- nal is valid for the current
machine by calling it with null second and third
arguments.</p>

<p>It is not possible to block SIGKILL or SIGSTOP (by
specifying them in sa_mask). Attempts to do so are silently
ignored.</p>

<p>See sigsetops(3) for details on manipulating signal
sets.</p>

<p>BUGS In kernels up to and including 2.6.13, specifying
SA_NODEFER in sa_flags preventing not only the delivered
signal from being masked during execution of the handler,
but also the signals specified in sa_mask. This bug is was
fixed in kernel 2.6.14.</p>

<p>CONFORMING TO POSIX.1-2001, SVr4.</p>

<p>UNDOCUMENTED Before the introduction of SA_SIGINFO it
was also possible to get some additional information, namely
by using a sa_handler with second argu- ment of type struct
sigcontext. See the relevant kernel sources for details.
This use is obsolete now.</p>

<p>SEE ALSO kill(1), kill(2), pause(2), sigaltstack(2),
signal(2), sigpending(2), sigprocmask(2), sigqueue(2),
sigsuspend(2), wait(2), killpg(3), raise(3),
siginterrupt(3), sigsetops(3), sigvec(3), core(5),
signal(7)</p>

<p>Linux 2.6.14 2005-09-15 SIGACTION(2)</p>
<hr>
</body>
</html>
