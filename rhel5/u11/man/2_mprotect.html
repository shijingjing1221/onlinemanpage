<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:16:29 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MPROTECT(2) Linux Programmer s Manual MPROTECT(2)</p>

<p>NAME mprotect - control allowable accesses to a region
of memory</p>

<p>SYNOPSIS #include &lt;sys/mman.h&gt;</p>

<p>int mprotect(const void *addr, size_t len, int
prot);</p>

<p>DESCRIPTION The function mprotect() specifies the
desired protection for the memory page(s) containing part or
all of the interval [addr,addr+len-1]. If an access is
disallowed by the protection given it, the program receives
a SIGSEGV.</p>

<p>prot is a bitwise-or of the following values:</p>

<p>PROT_NONE The memory cannot be accessed at all.</p>

<p>PROT_READ The memory can be read.</p>

<p>PROT_WRITE The memory can be written to.</p>

<p>PROT_EXEC The memory can contain executing code.</p>

<p>The new protection replaces any existing protection. For
example, if the memory had previously been marked PROT_READ,
and mprotect() is then called with prot PROT_WRITE, it will
no longer be readable.</p>

<p>RETURN VALUE On success, mprotect() returns zero. On
error, -1 is returned, and errno is set appropriately.</p>

<p>ERRORS EACCES The memory cannot be given the specified
access. This can hap- pen, for example, if you mmap(2) a
file to which you have read- only access, then ask
mprotect() to mark it PROT_WRITE.</p>

<p>EFAULT The memory cannot be accessed.</p>

<p>EINVAL addr is not a valid pointer, or not a multiple of
PAGESIZE.</p>

<p>ENOMEM Internal kernel structures could not be
allocated. Or: addresses in the range [addr, addr+len] are
invalid for the address space of the process, or specify one
or more pages that are not mapped.</p>

<p>EXAMPLE #include &lt;stdio.h&gt; #include
&lt;stdlib.h&gt; #include &lt;errno.h&gt; #include
&lt;sys/mman.h&gt;</p>

<p>#include &lt;limits.h&gt; /* for PAGESIZE */ #ifndef
PAGESIZE #define PAGESIZE 4096 #endif</p>

<p>int main(void) { char *p; char c;</p>

<p>/* Allocate a buffer; it will have the default
protection of PROT_READ|PROT_WRITE. */ p =
malloc(1024+PAGESIZE-1); if (!p) { perror(&quot;Couldnt
malloc(1024)&quot;); exit(errno); }</p>

<p>/* Align to a multiple of PAGESIZE, assumed to be a
power of two */ p = (char *)(((int) p + PAGESIZE-1) &amp;
~(PAGESIZE-1));</p>

<p>c = p[666]; /* Read; ok */ p[666] = 42; /* Write; ok
*/</p>

<p>/* Mark the buffer read-only. */ if (mprotect(p, 1024,
PROT_READ)) { perror(&quot;Couldnt mprotect&quot;);
exit(errno); }</p>

<p>c = p[666]; /* Read; ok */ p[666] = 42; /* Write;
program dies on SIGSEGV */</p>

<p>exit(0); }</p>

<p>CONFORMING TO SVr4, POSIX.1-2001. POSIX says that
mprotect() can be used only on regions of memory obtained
from mmap(2).</p>

<p>NOTES On Linux it is always legal to call mprotect() on
any address in a pro- cess address space (except for the
kernel vsyscall area). In particu- lar it can be used to
change existing code mappings to be writable.</p>

<p>Whether PROT_EXEC has any effect different from
PROT_READ is architec- ture and kernel version
dependent.</p>

<p>SEE ALSO mmap(2)</p>

<p>Linux 2.4 2003-08-24 MPROTECT(2)</p>
<hr>
</body>
</html>
