<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:14:57 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>User manual for old pbm functions(3) User manual for old
pbm functions(3)</p>

<p>NAME libpbm - libnetpbm functions to read and write PBM
image files</p>

<p>SYNOPSIS #include &lt;netpbm/pbm.h&gt;</p>

<p>bit **pbm_allocarray(int cols, int rows);</p>

<p>bit *pbm_allocrow(int cols);</p>

<p>pbm_freearray(bit **bits, int rows);</p>

<p>pbm_freerow(bit *bitrow);</p>

<p>void pbm_readpbminit(FILE * fp, int *colsP, int *rowsP,
int *formatP);</p>

<p>void pbm_readpbmrow(FILE * fp, bit *bitrow, int cols,
int format);</p>

<p>void pbm_readpbmrow_packed(FILE * fp, unsigned char *
const packed_bits, const int cols, const int format);</p>

<p>void bit** pbm_readpbm(FILE * fp, int *colsP, int
*rowsP);</p>

<p>void pbm_writepbminit(FILE * fp, int cols, int rows, int
forceplain);</p>

<p>void pbm_writepbmrow(FILE * fp, bit *bitrow, int cols,
int forceplain);</p>

<p>void pbm_writepbmrow_packed(FILE * fp, unsigned char *
const packed_bits, const int cols, const int
forceplain);</p>

<p>void pbm_writepbm(FILE * fp, bit **bits, int cols, int
rows, int force- plain);</p>

<p>#define pbm_packed_bytes(cols) ...</p>

<p>void pbm_nextimage( FILE *file, int * const eofP);</p>

<p>void pbm_check( FILE * file, const enum pm_check_type
check_type, const int format, const int cols, const int
rows, enum pm_check_code * const retval);</p>

<p>DESCRIPTION These library functions are part of
Netpbm(1).</p>

<p>TYPES AND CONSTANTS typedef ... bit;</p>

<p>#define PBM_WHITE ...</p>

<p>#define PBM_BLACK ...</p>

<p>Each bit should contain only the values of PBM_WHITE or
PBM_BLACK.</p>

<p>#define PBM_FORMAT ...</p>

<p>#define RPBM_FORMAT ...</p>

<p>#define PBM_TYPE PBM_FORMAT</p>

<p>#define PBM_FORMAT_TYPE(f) ...</p>

<p>These are for distinguishing different file formats and
types.</p>

<p>INITIALIZATION pbm_init() is identical to
pm_proginit.</p>

<p>pbm_init() is obsolete. Use pm_proginit() instead.</p>

<p>MEMORY MANAGEMENT pbm_allocarray() allocates an array of
bits. pbm_allocrow() allocates a row of the given number of
bits. pbm_freearray() frees the array allocated with
pbm_allocarray() containing the given number of rows.
pbm_freerow() frees a row of bits.</p>

<p>READING PBM IMAGE FILES pbm_readpbminit() reads the
header from a PBM image in a PBM file, filling in the rows,
cols and format variables. pbm_readpbmrow() reads a row of
bits into the bitrow array. Format and cols were filled in
by pbm_readpbminit().</p>

<p>pbm_readpbmrow_packed() is like pbm_readpbmrow() except
instead of returning a bits array, it returns an array
packed_bits of bytes with the pixels of the image row packed
into them. The pixels are in order from left to right across
the row and from the beginning of the array to the end.
Within a byte, the bits are in order from the most signif-
icant bit to the least significant bit. If the number of
pixels in the row is not a multiple of 8, the last byte
returned is padded on the least signficant bit side with
undefined bits. White is represented by a PBM_WHITE bit;
black by PBM_BLACK.</p>

<p>pbm_readpbm() reads an entire bitmap file into memory,
returning the allocated array and filling in the rows and
cols variables. This func- tion combines pbm_readpbminit(),
pbm_allocarray() and pbm_readpbmrow().</p>

<p>pbm_readpbminit() and pbm_readpbm abort the program with
a message to Standard Error if the PBM image header is not
syntactically valid, including if it contains a number too
large to be processed using the systems normal data
structures (to wit, a number that wont fit in a C int).</p>

<p>ppm_readppminit() and ppm_readppm abort the program with
a message to Standard Error if the PPM image header is not
syntactically valid, including if it contains a number too
large to be processed using the systems normal data
structures (to wit, a number that wont fit in a C int).</p>

<p>WRITING PBM IMAGE FILES pbm_writepbminit() writes the
header for a PBM image in a PBM file. forceplain is a
boolean value specifying that a plain format (text) file to
be written, as opposed to a raw format (binary) one.
pbm_writepbmrow() writes a row to a PBM file.
pbm_writepbmrow_packed() is the same as pbm_writepbmrow()
except that you supply the row to write as an array of bytes
packed with bits instead of as a bits array. The format of
packed_bits is the same as that returned by pbm_readpbm-
row().</p>

<p>pbm_writepbm() writes the header and all data for a PBM
image to a PBM file. This function combines
pbm_writepbminit() and pbm_writepbmrow().</p>

<p>MISCELLANEOUS pbm_nextimage() positions a PBM input file
to the next image in it (so that a subsequent
pbm_readpbminit() reads its header).</p>

<p>Immediately before a call to pbm_nextimage(), the file
must be posi- tioned either at its beginning (i.e. nothing
has been read from the file yet) or just after an image
(i.e. as left by a pbm_readpbmrow() of the last row in the
image).</p>

<p>Note that in the raw PNM and PAM format, the next image
always starts immediately after the previous image, so all
pbm_nextimage() really does is test whether there is a next
image or the file is positioned at end-of-file. In plain
PNM, though, there may be white space between images.</p>

<p>If pbm_nextimage() successfully positions to the next
image, it returns *eofP false (0). If there is no next image
in the file, it returns *eofP true . If it cant position or
determine the file status due to a file error, it throws an
error .</p>

<p>pbm_check() checks for the common file integrity error
where the file is the wrong size to contain all the image
data. pbm_check() assumes the file is positioned after an
image header (as if pbm_readpbminit() was the last operation
on the file). It checks the file size to see if the number
of bytes left in the file are the number required to contain
the image raster. If the file is too short, pbm_check()
causes the program t throws an error . Otherwise, it returns
one of the following values (enumerations of the enum
pm_check_code type) as *retval:</p>

<p>PM_CHECK_OK The files size is exactly what is required
to hold the image raster.</p>

<p>PM_CHECK_UNKNOWN_TYPE format is not a format whose size
pbm_check() can anticipate. The only format with which
pbm_check() can deal is raw PBM for- mat.</p>

<p>PM_CHECK_TOO_LONG The file is longer than it needs to be
to contain the image raster. The extra data might be another
image.</p>

<p>PM_CHECK_UNCHECKABLE The file is not a kind that has a
predictable size, so there is no simple way for pbm_check()
to know if it is the right size. Only a regular file has
predictable size. A pipe is a common example of a file that
does not.</p>

<p>check_type must have the value PM_CHECK_BASIC (an
enumerated value of the pm_check_type enumerated type).
Otherwise, the effect of pbm_check() is unpredictable. This
argument exists for future backward compatible expansion of
the function of pbm_check().</p>

<p>SEE ALSO libpgm(1), libppm(1), libpnm(1), pbm(1)</p>

<p>AUTHOR Copyright (C) 1989, 1991 by Tony Hansen and Jef
Poskanzer.</p>

<p>netpbm documentation 8 SeptemberUser7manual for old pbm
functions(3)</p>
<hr>
</body>
</html>
