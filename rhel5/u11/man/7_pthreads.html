<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:20:45 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PTHREADS(7) Linux Programmer s Manual PTHREADS(7)</p>

<p>NAME pthreads - POSIX threads</p>

<p>DESCRIPTION POSIX.1 specifies a set of interfaces
(functions, header files) for threaded programming commonly
known as POSIX threads, or Pthreads. A single process can
contain multiple threads, all of which are executing the
same program. These threads share the same global memory
(data and heap segments), but each thread has its own stack
(automatic vari- ables).</p>

<p>POSIX.1 also requires that threads share a range of
other attributes (i.e., these attributes are process-wide
rather than per-thread):</p>

<p>- process ID</p>

<p>- parent process ID</p>

<p>- process group ID and session ID</p>

<p>- controlling terminal</p>

<p>- user and group IDs</p>

<p>- open file descriptors</p>

<p>- record locks (see fcntl(2))</p>

<p>- signal dispositions</p>

<p>- file mode creation mask (umask(2))</p>

<p>- current directory (chdir(2)) and root directory
(chroot(2))</p>

<p>- interval timers (setitimer(2)) and POSIX timers
(timer_create())</p>

<p>- nice value (setpriority(2))</p>

<p>- resource limits (setrlimit(2))</p>

<p>- measurements of the consumption of CPU time (times(2))
and resources (getrusage(2))</p>

<p>As well as the stack, POSIX.1 specifies that various
other attributes are distinct for each thread,
including:</p>

<p>- thread ID (the pthread_t data type)</p>

<p>- signal mask (pthread_sigmask())</p>

<p>- the errno variable</p>

<p>- alternate signal stack (sigaltstack(2))</p>

<p>- real-time scheduling policy and priority
(sched_setscheduler(2) and sched_setparam(2))</p>

<p>The following Linux-specific features are also
per-thread:</p>

<p>- capabilities (see capabilities(7))</p>

<p>- CPU affinity (sched_setaffinity(2))</p>

<p>Compiling on Linux On Linux, programs that use the
Pthreads API should be compiled using cc -pthread.</p>

<p>Linux Implementations of POSIX Threads Over time, two
threading implementations have been provided by the GNU C
library on Linux:</p>

<p>- LinuxThreads This is the original (now obsolete)
Pthreads implemen- tation.</p>

<p>- NPTL (Native POSIX Threads Library) This is the modern
Pthreads implementation. By comparison with LinuxThreads,
NPTL provides closer conformance to the requirements of the
POSIX.1 specification and better performance when creating
large numbers of threads. NPTL requires features that are
present in the Linux 2.6 kernel.</p>

<p>Both of these are so-called 1:1 implementations, meaning
that each thread maps to a kernel scheduling entity.</p>

<p>Both threading implementations employ the Linux clone(2)
system call. In NPTL, thread synchronisation primitives
(mutexes, thread joining, etc.) are implemented using the
Linux futex(2) system call.</p>

<p>Modern GNU C libraries provide both LinuxThreads and
NPTL, with the latter being the default (if supported by the
underlying kernel).</p>

<p>LinuxThreads The notable features of this implementation
are the following:</p>

<p>- In addition to the main (initial) thread, and the
threads that the program creates using pthread_create(), the
implementation creates a &quot;manager&quot; thread. This
thread handles thread creation and termina- tion. (Problems
can result if this thread is inadvertently killed.)</p>

<p>- Signals are used internally by the implementation. On
Linux 2.2 and later, the first three real-time signals are
used. On older Linux kernels, SIGUSR1 and SIGUSR2 are used.
Applications must avoid the use of whichever set of signals
is employed by the implementation.</p>

<p>- Threads do not share process IDs. (In effect,
LinuxThreads threads are implemented as processes which
share more information than usual, but which do not share a
common process ID.) LinuxThreads threads (including the
manager thread) are visible as separate pro- cesses using
ps(1).</p>

<p>The LinuxThreads implementation deviates from the
POSIX.1 specification in a number of ways, including the
following:</p>

<p>- Calls to getpid(2) return a different value in each
thread.</p>

<p>- Calls to getppid(2) in threads other than the main
thread return the process ID of the manager thread; instead
getppid(2) in these threads should return the same value as
getppid(2) in the main thread.</p>

<p>- When one thread creates a new child process using
fork(2), any thread should be able to wait(2) on the child.
However, the imple- mentation only allows the thread that
created the child to wait(2) on it.</p>

<p>- When a thread calls execve(2), all other threads are
terminated (as required by POSIX.1). However, the resulting
process has the same PID as the thread that called
execve(2): it should have the same PID as the main
thread.</p>

<p>- Threads do not share user and group IDs. This can
cause complica- tions with set-user-ID programs and can
cause failures in Pthreads functions if an application
changes its credentials using seteuid(2) or similar.</p>

<p>- Threads do not share a common session ID and process
group ID.</p>

<p>- Threads do not share record locks created using
fcntl(2).</p>

<p>- The information returned by times(2) and getrusage(2)
is per-thread rather than process-wide.</p>

<p>- Threads do not share semaphore undo values (see
semop(2)).</p>

<p>- Threads do not share interval timers.</p>

<p>- Threads do not share a common nice value.</p>

<p>- POSIX.1 distinguishes the notions of signals that are
directed to the process as a whole and signals are directed
to individual threads. According to POSIX.1, a
process-directed signal (sent using kill(2), for example)
should be handled by a single, arbitrar- ily selected thread
within the process. LinuxThreads does not sup- port the
notion of process-directed signals: signals may only be sent
to specific threads.</p>

<p>- Threads have distinct alternate signal stack settings.
However, a new thread s alternate signal stack settings are
copied from the thread that created it, so that the threads
initially share an alternate signal stack. (A new thread
should start with no alter- nate signal stack defined. If
two threads handle signals on their shared alternate signal
stack at the same time, unpredictable pro- gram failures are
likely to occur.)</p>

<p>NPTL With NPTL, all of the threads in a process are
placed in the same thread group; all members of a thread
groups share the same PID. NPTL does not employ a manager
thread. NPTL makes internal use of the first two real-time
signals; these signals cannot be used in applications.</p>

<p>NPTL still has a few non-conformances with POSIX.1:</p>

<p>- Threads do not share a common nice value.</p>

<p>Some NPTL non-conformances only occur with older
kernels:</p>

<p>- The information returned by times(2) and getrusage(2)
is per-thread rather than process-wide (fixed in kernel
2.6.9).</p>

<p>- Threads do not share resource limits (fixed in kernel
2.6.10).</p>

<p>- Threads do not share interval timers (fixed in kernel
2.6.12).</p>

<p>- Only the main thread is permitted to start a new
session using set- sid(2) (fixed in kernel 2.6.16).</p>

<p>- Only the main thread is permitted to make the process
into a process group leader using setpgid(2) (fixed in
kernel 2.6.16).</p>

<p>- Threads have distinct alternate signal stack settings.
However, a new thread s alternate signal stack settings are
copied from the thread that created it, so that the threads
initially share an alternate signal stack (fixed in kernel
2.6.16).</p>

<p>Determining the Threading Implementation Since glibc
2.3.2, the getconf(1) command can be used to determine the
systems default threading implementation, for example:</p>

<p>bash$ getconf GNU_LIBPTHREAD_VERSION NPTL 2.3.4</p>

<p>With older glibc versions, a command such as the
following should be sufficient to determine the default
threading implementation:</p>

<p>bash$ $( ldd /bin/ls | grep libc.so | awk {print $3} ) |
egrep -i threads|ntpl Native POSIX Threads Library by Ulrich
Drepper et al</p>

<p>Selecting the Threading Implementation: LD_ASSUME_KERNEL
On systems with a glibc that supports both LinuxThreads and
NPTL, the LD_ASSUME_KERNEL environment variable can be used
to override the dynamic linker s default choice of threading
implementation. This variable tells the dynamic linker to
assume that it is running on top of a particular kernel
version. By specifying a kernel version that does not
provide the support required by NPTL, we can force the use
of LinuxThreads. (The most likely reason for doing this is
to run a (bro- ken) application that depends on some
non-conformant behavior in Linux- Threads.) For example:</p>

<p>bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep
libc.so | awk {print $3} ) | egrep -i threads|ntpl
linuxthreads-0.10 by Xavier Leroy</p>

<p>SEE ALSO clone(2), futex(2), gettid(2), futex(7), and
various Pthreads manual pages, for example:
pthread_atfork(3), pthread_cleanup_push(3),
pthread_cond_signal(3), pthread_cond_wait(3),
pthread_create(3), pthread_detach(3), pthread_equal(3),
pthread_exit(3), pthread_key_cre- ate(3), pthread_kill(3),
pthread_mutex_lock(3), pthread_mutex_unlock(3),
pthread_once(3), pthread_setcancelstate(3),
pthread_setcanceltype(3), pthread_setspecific(3),
pthread_sigmask(3), and pthread_testcancel(3).</p>

<p>Linux 2.6.12 2005-06-07 PTHREADS(7)</p>
<hr>
</body>
</html>
