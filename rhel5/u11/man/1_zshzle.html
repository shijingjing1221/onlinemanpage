<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:28:37 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ZSHZLE(1) ZSHZLE(1)</p>

<p>NAME zshzle - zsh command line editor</p>

<p>DESCRIPTION If the ZLE option is set (which it is by
default in interactive shells) and the shell input is
attached to the terminal, the user is able to edit command
lines.</p>

<p>There are two display modes. The first, multiline mode,
is the default. It only works if the TERM parameter is set
to a valid termi- nal type that can move the cursor up. The
second, single line mode, is used if TERM is invalid or
incapable of moving the cursor up, or if the SINGLE_LINE_ZLE
option is set. This mode is similar to ksh, and uses no
termcap sequences. If TERM is &quot;emacs&quot;, the ZLE
option will be unset by default.</p>

<p>The parameters BAUD, COLUMNS, and LINES are also used by
the line edi- tor. See Parameters Used By The Shell in
zshparam(1).</p>

<p>KEYMAPS A keymap in ZLE contains a set of bindings
between key sequences and ZLE commands. The empty key
sequence cannot be bound.</p>

<p>There can be any number of keymaps at any time, and each
keymap has one or more names. If all of a keymaps names are
deleted, it disappears. bindkey can be used to manipulate
keymap names.</p>

<p>Initially, there are four keymaps:</p>

<p>emacs EMACS emulation viins vi emulation - insert mode
vicmd vi emulation - command mode .safe fallback keymap</p>

<p>The .safe keymap is special. It can never be altered,
and the name can never be removed. However, it can be linked
to other names, which can be removed. In the future other
special keymaps may be added; users should avoid using names
beginning with . for their own keymaps.</p>

<p>In addition to these four names, either emacs or viins
is also linked to the name main. If one of the VISUAL or
EDITOR environment variables contain the string vi when the
shell starts up then it will be viins, otherwise it will be
emacs. bindkeys -e and -v options provide a convenient way
to override this default choice.</p>

<p>When the editor starts up, it will select the main
keymap. If that keymap doesnt exist, it will use .safe
instead.</p>

<p>In the .safe keymap, each single key is bound to
self-insert, except for ^J (line feed) and ^M (return) which
are bound to accept-line. This is deliberately not pleasant
to use; if you are using it, it means you deleted the main
keymap, and you should put it back.</p>

<p>Reading Commands When ZLE is reading a command from the
terminal, it may read a sequence that is bound to some
command and is also a prefix of a longer bound string. In
this case ZLE will wait a certain time to see if more char-
acters are typed, and if not (or they don t match any longer
string) it will execute the binding. This timeout is defined
by the KEYTIMEOUT parameter; its default is 0.4 sec. There
is no timeout if the prefix string is not itself bound to a
command.</p>

<p>As well as ZLE commands, key sequences can be bound to
other strings, by using bindkey -s. When such a sequence is
read, the replacement string is pushed back as input, and
the command reading process starts again using these fake
keystrokes. This input can itself invoke fur- ther
replacement strings, but in order to detect loops the
process will be stopped if there are twenty such
replacements without a real command being read.</p>

<p>ZLE BUILTINS The ZLE module contains three related
builtin commands. The bindkey command manipulates keymaps
and key bindings; the vared command invokes ZLE on the value
of a shell parameter; and the zle command manipulates
editing widgets and allows command line access to ZLE
commands from within shell functions.</p>

<p>bindkey [ options ] -l bindkey [ options ] -d bindkey [
options ] -D keymap ... bindkey [ options ] -A old-keymap
new-keymap bindkey [ options ] -N new-keymap [ old-keymap ]
bindkey [ options ] -m bindkey [ options ] -r in-string ...
bindkey [ options ] -s in-string out-string ... bindkey [
options ] in-string command ... bindkey [ options ] [
in-string ] bindkey s options can be divided into three
categories: keymap selection, operation selection, and
others. The keymap selec- tion options are:</p>

<p>-e Selects keymap emacs, and also links it to main.</p>

<p>-v Selects keymap viins, and also links it to main.</p>

<p>-a Selects keymap vicmd.</p>

<p>-M keymap The keymap specifies a keymap name.</p>

<p>If a keymap selection is required and none of the
options above are used, the main keymap is used. Some
operations do not permit a keymap to be selected,
namely:</p>

<p>-l List all existing keymap names. If the -L option is
also used, list in the form of bindkey commands to create
the keymaps.</p>

<p>-d Delete all existing keymaps and reset to the default
state.</p>

<p>-D keymap ... Delete the named keymaps.</p>

<p>-A old-keymap new-keymap Make the new-keymap name an
alias for old-keymap, so that both names refer to the same
keymap. The names have equal standing; if either is deleted,
the other remains. If there is already a keymap with the
new-keymap name, it is deleted.</p>

<p>-N new-keymap [ old-keymap ] Create a new keymap, named
new-keymap. If a keymap already has that name, it is
deleted. If an old-keymap name is given, the new keymap is
initialized to be a duplicate of it, otherwise the new
keymap will be empty.</p>

<p>To use a newly created keymap, it should be linked to
main. Hence the sequence of commands to create and use a new
keymap mymap initialized from the emacs keymap (which
remains unchanged) is:</p>

<p>bindkey -N mymap emacs bindkey -A mymap main</p>

<p>Note that while bindkey -A newmap main will work when
newmap is emacs or viins, it will not work for vicmd, as
switching from vi insert to command mode becomes
impossible.</p>

<p>The following operations act on the main keymap if no
keymap selection option was given:</p>

<p>-m Add the built-in set of meta-key bindings to the
selected keymap. Only keys that are unbound or bound to
self-insert are affected.</p>

<p>-r in-string ... Unbind the specified in-strings in the
selected keymap. This is exactly equivalent to binding the
strings to undefined-key.</p>

<p>When -R is also used, interpret the in-strings as
ranges.</p>

<p>When -p is also used, the in-strings specify prefixes.
Any binding that has the given in-string as a prefix, not
including the binding for the in-string itself, if any, will
be removed. For example,</p>

<p>bindkey -rpM viins^[</p>

<p>will remove all bindings in the vi-insert keymap begin-
ning with an escape character (probably cursor keys), but
leave the binding for the escape character itself (proba-
bly vi-cmd-mode). This is incompatible with the option
-R.</p>

<p>-s in-string out-string ... Bind each in-string to each
out-string. When in-string is typed, out-string will be
pushed back and treated as input to the line editor. When -R
is also used, inter- pret the in-strings as ranges.</p>

<p>in-string command ... Bind each in-string to each
command. When -R is used, interpret the in-strings as
ranges.</p>

<p>[ in-string ] List key bindings. If an in-string is
specified, the binding of that string in the selected keymap
is dis- played. Otherwise, all key bindings in the selected
keymap are displayed. (As a special case, if the -e or -v
option is used alone, the keymap is not displayed - the
implicit linking of keymaps is the only thing that
happens.)</p>

<p>When the option -p is used, the in-string must be
present. The listing shows all bindings which have the given
key sequence as a prefix, not including any bind- ings for
the key sequence itself.</p>

<p>When the -L option is used, the list is in the form of
bindkey commands to create the key bindings.</p>

<p>When the -R option is used as noted above, a valid range
consists of two characters, with an optional - between them.
All characters between the two specified, inclusive, are
bound as specified.</p>

<p>For either in-string or out-string, the following escape
sequences are recognised:</p>

<p>a bell character b b a c k s p a c e eE escape f form
feed n linefeed (newline)r carriage return t horizontal tab
vertical tab NNN character code in octal NN character code
in hexadecimal M[-]X character with meta bit set -]X control
character ^X control character</p>

<p>In all other cases, escapes the following character.
Delete is written as ^?. Note thatM^? and M? are not the
same, and that (unlike emacs), the bindingsM-X andeX are
entirely dis- tinct, although they are initialized to the
same bindings by bindkey -m.</p>

<p>vared [ -Aache ] [ -p prompt ] [ -r rprompt ] [ -M
main-keymap ] [ -m vicmd-keymap ] name The value of the
parameter name is loaded into the edit buffer, and the line
editor is invoked. When the editor exits, name is set to the
string value returned by the editor. When the -c flag is
given, the parameter is created if it doesnt already exist.
The -a flag may be given with -c to create an array
parameter, or the -A flag to create an associative array. If
the type of an existing parameter does not match the type to
be created, the parameter is unset and recreated.</p>

<p>If an array or array slice is being edited, separator
characters as defined in $IFS will be shown quoted with a
backslash, as will backslashes themselves. Conversely, when
the edited text is split into an array, a backslash quotes
an immediately fol- lowing separator character or backslash;
no other special han- dling of backslashes, or any handling
of quotes, is performed.</p>

<p>Individual elements of existing array or associative
array parameters may be edited by using subscript syntax on
name. New elements are created automatically, even without
-c.</p>

<p>If the -p flag is given, the following string will be
taken as the prompt to display at the left. If the -r flag
is given, the following string gives the prompt to display
at the right. If the -h flag is specified, the history can
be accessed from ZLE. If the -e flag is given, typing ^D
(Control-D) on an empty line causes vared to exit
immediately with a non-zero return value.</p>

<p>The -M option gives a keymap to link to the main keymap
during editing, and the -m option gives a keymap to link to
the vicmd keymap during editing. For vi-style editing, this
allows a pair of keymaps to override viins and vicmd. For
emacs-style edit- ing, only -M is normally needed but the -m
option may still be used. On exit, the previous keymaps will
be restored.</p>

<p>zle zle -l [ -L | -a ] [ string ... ] zle -D widget ...
zle -A old-widget new-widget zle -N widget [ function ] zle
-C widget completion-widget function zle -R [ -c ] [
display-string ] [ string ... ] zle -M string zle -U string
zle -K keymap zle -F [ -L ] [ fd [ handler ] ] zle -I zle
widget [ -n num ] [ -N ] args ... The zle builtin performs a
number of different actions concern- ing ZLE.</p>

<p>With no options and no arguments, only the return status
will be set. It is zero if ZLE is currently active and
widgets could be invoked using this builtin command and
non-zero otherwise. Note that even if non-zero status is
returned, zle may still be active as part of the completion
system; this does not allow direct calls to ZLE widgets.</p>

<p>Otherwise, which operation it performs depends on its
options:</p>

<p>-l [ -L | -a ] List all existing user-defined widgets.
If the -L option is used, list in the form of zle commands
to create the widgets.</p>

<p>When combined with the -a option, all widget names are
listed, including the builtin ones. In this case the -L
option is ignored.</p>

<p>If at least one string is given, nothing will be printed
but the return status will be zero if all strings are names
of existing widgets (or of user-defined widgets if the -a
flag is not given) and non-zero if at least one string is
not a name of an defined widget.</p>

<p>-D widget ... Delete the named widgets.</p>

<p>-A old-widget new-widget Make the new-widget name an
alias for old-widget, so that both names refer to the same
widget. The names have equal standing; if either is deleted,
the other remains. If there is already a widget with the
new-widget name, it is deleted.</p>

<p>-N widget [ function ] Create a user-defined widget. If
there is already a wid- get with the specified name, it is
overwritten. When the new widget is invoked from within the
editor, the speci- fied shell function is called. If no
function name is specified, it defaults to the same name as
the widget. For further information, see the section Widgets
in zsh- zle(1).</p>

<p>-C widget completion-widget function Create a
user-defined completion widget named widget. The completion
widget will behave like the built-in comple- tion-widget
whose name is given as completion-widget. To generate the
completions, the shell function function will be called. For
further information, see zshcomp- wid(1).</p>

<p>-R [ -c ] [ display-string ] [ string ... ] Redisplay
the command line; this is to be called from within a
user-defined widget to allow changes to become visible. If a
display-string is given and not empty, this is shown in the
status line (immediately below the line being edited).</p>

<p>If the optional strings are given they are listed below
the prompt in the same way as completion lists are printed.
If no strings are given but the -c option is used such a
list is cleared.</p>

<p>Note that this option is only useful for widgets that do
not exit immediately after using it because the strings
displayed will be erased immediately after return from the
widget.</p>

<p>This command can safely be called outside user defined
widgets; if zle is active, the display will be refreshed,
while if zle is not active, the command has no effect. In
this case there will usually be no other arguments.</p>

<p>The status is zero if zle was active, else one.</p>

<p>-M string As with the -R option, the string will be
displayed below the command line; unlike the -R option, the
string will not be put into the status line but will instead
be printed normally below the prompt. This means that the
string will still be displayed after the widget returns
(until it is overwritten by subsequent commands).</p>

<p>-U string This pushes the characters in the string onto
the input stack of ZLE. After the widget currently executed
fin- ishes ZLE will behave as if the characters in the
string were typed by the user.</p>

<p>As ZLE uses a stack, if this option is used repeatedly
the last string pushed onto the stack will be processed
first. However, the characters in each string will be
processed in the order in which they appear in the
string.</p>

<p>-K keymap Selects the keymap named keymap. An error
message will be displayed if there is no such keymap.</p>

<p>This keymap selection affects the interpretation of fol-
lowing keystrokes within this invocation of ZLE. Any
following invocation (e.g., the next command line) will
start as usual with the main keymap selected.</p>

<p>-F [ -L ] [ fd [ handler ] ] Only available if your
system supports one of the poll or select system calls; most
modern systems do.</p>

<p>Installs handler (the name of a shell function) to
handle input from file descriptor fd. When zle is attempting
to read data, it will examine both the terminal and the list
of handled fds. If data becomes available on a handled fd,
zle will call handler with the fd which is ready for reading
as the only argument. If the handler produces output to the
terminal, it should call zle -I before doing so (see below).
The handler should not attempt to read from the terminal.
Note that zle makes no attempt to check whether this fd is
actually readable when installing the handler. The user must
make their own arrangements for handling the file descriptor
when zle is not active.</p>

<p>Any number of handlers for any number of readable file
descriptors may be installed. Installing a handler for an fd
which is already handled causes the existing han- dler to be
replaced.</p>

<p>If no handler is given, but an fd is present, any
handler for that fd is removed. If there is none, an error
mes- sage is printed and status 1 is returned.</p>

<p>If no arguments are given, or the -L option is supplied,
a list of handlers is printed in a form which can be stored
for later execution.</p>

<p>An fd (but not a handler) may optionally be given with
the -L option; in this case, the function will list the
handler if any, else silently return status 1.</p>

<p>Note that this feature should be used with care. Activ-
ity on one of the fds which is not properly handled can
cause the terminal to become unusable.</p>

<p>Here is a simple example of using this feature. A con-
nection to a remote TCP port is created using the ztcp
command; see the description of the zsh/net/tcp module in
zshmodules(1). Then a handler is installed which simply
prints out any data which arrives on this connection. Note
that select will indicate that the file descriptor needs
handling if the remote side has closed the connec- tion; we
handle that by testing for a failed read. if ztcp pwspc
2811; then tcpfd=$REPLY handler() { zle -I local line if !
read -r line &lt;&amp;$1; then # select marks this fd if we
reach EOF, # so handle this specially. print &quot;[Read on
fd $1 failed, removing.]&quot; &gt;&amp;2 zle -F $1 return 1
fi print -r - $line } zle -F $tcpfd handler fi</p>

<p>-I Unusually, this option is most useful outside
ordinary widget functions, though it may be used within if
normal output to the terminal is required. It invalidates
the current zle display in preparation for output; typically
this will be from a trap function. It has no effect if zle
is not active. When a trap exits, the shell checks to see if
the display needs restoring, hence the follow- ing will
print output in such a way as not to disturb the line being
edited:</p>

<p>TRAPUSR1() { # Invalidate zle display [[ -o zle ]]
&amp;&amp; zle -I # Show output print Hello }</p>

<p>In general, the trap function may need to test whether
zle is active before using this method (as shown in the
example), since the zsh/zle module may not even be loaded;
if it is not, the command can be skipped.</p>

<p>It is possible to call zle -I several times before con-
trol is returned to the editor; the display will only be
invalidated the first time to minimise disruption.</p>

<p>Note that there are normally better ways of manipulating
the display from within zle widgets; see, for example, zle
-R above.</p>

<p>The returned status is zero if zle was invalidated, even
though this may have been by a previous call to zle -I or by
a system notification. To test if a zle widget may be called
at this point, execute zle with no arguments and examine the
return status.</p>

<p>widget [ -n num ] [ -N ] args ... Invoke the specified
widget. This can only be done when ZLE is active; normally
this will be within a user-defined widget.</p>

<p>With the options -n and -N, the current numerical argu-
ment will be saved and then restored after the call to
widget; -n num sets the numerical argument temporarily to
num, while -N sets it to the default, i.e. as if there were
none.</p>

<p>Any further arguments will be passed to the widget. If
it is a shell function, these are passed down as posi-
tional parameters; for builtin widgets it is up to the
widget in question what it does with them. Currently
arguments are only handled by the incremental-search com-
mands, the history-search-forward and -backward and the
corresponding functions prefixed by vi-, and by univer-
sal-argument. No error is flagged if the command does not
use the arguments, or only uses some of them.</p>

<p>The return status reflects the success or failure of the
operation carried out by the widget, or if it is a
user-defined widget the return status of the shell func-
tion.</p>

<p>A non-zero return status causes the shell to beep when
the widget exits, unless the BEEP options was unset or the
widget was called via the zle command. Thus if a user
defined widget requires an immediate beep, it should call
the beep widget directly.</p>

<p>WIDGETS All actions in the editor are performed by
widgets. A widgets job is simply to perform some small
action. The ZLE commands that key sequences in keymaps are
bound to are in fact widgets. Widgets can be user-defined or
built in.</p>

<p>The standard widgets built in to ZLE are listed in
Standard Widgets below. Other built-in widgets can be
defined by other modules (see zshmodules(1)). Each built-in
widget has two names: its normal canoni- cal name, and the
same name preceded by a .. The . name is spe- cial: it cant
be rebound to a different widget. This makes the widget
available even when its usual name has been redefined.</p>

<p>User-defined widgets are defined using zle -N, and
implemented as shell functions. When the widget is executed,
the corresponding shell function is executed, and can
perform editing (or other) actions. It is recommended that
user-defined widgets should not have names starting with
..</p>

<p>USER-DEFINED WIDGETS User-defined widgets, being
implemented as shell functions, can execute any normal shell
command. They can also run other widgets (whether built-in
or user-defined) using the zle builtin command. The standard
input of the function is closed to prevent external commands
from unin- tentionally blocking ZLE by reading from the
terminal, but read -k or read -q can be used to read
characters. Finally, they can examine and edit the ZLE
buffer being edited by reading and setting the special
parameters described below.</p>

<p>These special parameters are always available in widget
functions, but are not in any way special outside ZLE. If
they have some normal value outside ZLE, that value is
temporarily inaccessible, but will return when the widget
function exits. These special parameters in fact have local
scope, like parameters created in a function using
local.</p>

<p>Inside completion widgets and traps called while ZLE is
active, these parameters are available read-only.</p>

<p>BUFFER (scalar) The entire contents of the edit buffer.
If it is written to, the cursor remains at the same offset,
unless that would put it outside the buffer.</p>

<p>BUFFERLINES (integer) The number of screen lines needed
for the edit buffer currently displayed on screen (i.e.
without any changes to the preceding parameters done after
the last redisplay); read-only.</p>

<p>CONTEXT (scalar) The context in which zle was called to
read a line; read-only. One of the values: start The start
of a command line (at prompt PS1).</p>

<p>cont A continuation to a command line (at prompt
PS2).</p>

<p>select In a select loop.</p>

<p>vared Editing a variable in vared.</p>

<p>CURSOR (integer) The offset of the cursor, within the
edit buffer. This is in the range 0 to $#BUFFER, and is by
definition equal to $#LBUFFER. Attempts to move the cursor
outside the buffer will result in the cursor being moved to
the appropriate end of the buffer.</p>

<p>CUTBUFFER (scalar) The last item to be cut using one of
the kill- commands; the string which the next yank would
insert in the line.</p>

<p>HISTNO (integer) The current history number. Setting
this has the same effect as moving up or down in the history
to the corresponding history line. An attempt to set it is
ignored if the line is not stored in the history. Note this
is not the same as the parameter HISTCMD, which always gives
the number of the history line being added to the main
shells history. HISTNO refers to the line being retrieved
within zle.</p>

<p>KEYMAP (scalar) The name of the currently selected
keymap; read-only.</p>

<p>KEYS (scalar) The keys typed to invoke this widget, as a
literal string; read-only.</p>

<p>killring (array) The array of previously killed items,
with the most recently killed first. This gives the items
that would be retrieved by a yank-pop in the same order.</p>

<p>The default size for the kill ring is eight, however the
length may be changed by normal array operations. Any empty
string in the kill ring is ignored by the yank-pop command,
hence the size of the array effectively sets the maximum
length of the kill ring, while the number of non-zero
strings gives the current length, both as seen by the user
at the command line.</p>

<p>LASTSEARCH (scalar) The last search string used by an
interactive search ; read-only.</p>

<p>LASTWIDGET (scalar) The name of the last widget that was
executed; read-only.</p>

<p>LBUFFER (scalar) The part of the buffer that lies to the
left of the cursor posi- tion. If it is assigned to, only
that part of the buffer is replaced, and the cursor remains
between the new $LBUFFER and the old $RBUFFER.</p>

<p>MARK (integer) Like CURSOR, but for the mark.</p>

<p>NUMERIC (integer) The numeric argument. If no numeric
argument was given, this parameter is unset. When this is
set inside a widget function, builtin widgets called with
the zle builtin command will use the value assigned. If it
is unset inside a widget function, builtin widgets called
behave as if no numeric argument was given.</p>

<p>PENDING (integer) The number of bytes pending for input,
i.e. the number of bytes which have already been typed and
can immediately be read. On systems where the shell is not
able to get this information, this parameter will always
have a value of zero. Read-only.</p>

<p>PREBUFFER (scalar) In a multi-line input at the
secondary prompt, this read-only parameter contains the
contents of the lines before the one the cursor is currently
in.</p>

<p>PREDISPLAY (scalar) Text to be displayed before the
start of the editable text buffer. This does not have to be
a complete line; to display a complete line, a newline must
be appended explicitly. The text is reset on each new
invocation (but not recursive invoca- tion) of zle.</p>

<p>POSTDISPLAY (scalar) Text to be displayed after the end
of the editable text buffer. This does not have to be a
complete line; to display a complete line, a newline must be
prepended explicitly. The text is reset on each new
invocation (but not recursive invocation) of zle.</p>

<p>RBUFFER (scalar) The part of the buffer that lies to the
right of the cursor position. If it is assigned to, only
that part of the buffer is replaced, and the cursor remains
between the old $LBUFFER and the new $RBUFFER.</p>

<p>WIDGET (scalar) The name of the widget currently being
executed; read-only.</p>

<p>WIDGETFUNC (scalar) The name of the shell function that
implements a widget defined with either zle -N or zle -C. In
the former case, this is the second argument to the zle -N
command that defined the widget, or the first argument if
there was no second argument. In the latter case this is the
the third argument to the zle -C command that defined the
widget. Read-only.</p>

<p>WIDGETSTYLE (scalar) Describes the implementation behind
the completion widget cur- rently being executed; the second
argument that followed zle -C when the widget was defined.
This is the name of a builtin com- pletion widget. For
widgets defined with zle -N this is set to the empty string.
Read-only.</p>

<p>Special Widget There is one user-defined widget which is
special to the shell. If it does not exist, no special
action is taken. The environment provided is identical to
that for any other editing widget.</p>

<p>zle-line-init Executed every time the line editor is
started to read a new line of input. The following example
puts the line editor into vi command mode when it starts
up.</p>

<p>zle-line-init() { zle -K vicmd; } zle -N
zle-line-init</p>

<p>(The command inside the function sets the keymap
directly; it is equivalent to zle vi-cmd-mode.)</p>

<p>STANDARD WIDGETS The following is a list of all the
standard widgets, and their default bindings in emacs mode,
vi command mode and vi insert mode (the emacs, vicmd and
viins keymaps, respectively).</p>

<p>Note that cursor keys are bound to movement keys in all
three keymaps; the shell assumes that the cursor keys send
the key sequences reported by the terminal-handling library
(termcap or terminfo). The key sequences shown in the list
are those based on the VT100, common on many modern
terminals, but in fact these are not necessarily bound. In
the case of the viins keymap, the initial escape character
of the sequences serves also to return to the vicmd keymap:
whether this hap- pens is determined by the KEYTIMEOUT
parameter, see zshparam(1).</p>

<p>Movement vi-backward-blank-word (unbound) (B) (unbound)
Move backward one word, where a word is defined as a series
of non-blank characters.</p>

<p>backward-char (^B ESC-[D) (unbound) (unbound) Move
backward one character.</p>

<p>vi-backward-char (unbound) (^H h ^?) (ESC-[D) Move
backward one character, without changing lines.</p>

<p>backward-word (ESC-B ESC-b) (unbound) (unbound) Move to
the beginning of the previous word.</p>

<p>emacs-backward-word Move to the beginning of the
previous word.</p>

<p>vi-backward-word (unbound) (b) (unbound) Move to the
beginning of the previous word, vi-style.</p>

<p>beginning-of-line (^A) (unbound) (unbound) Move to the
beginning of the line. If already at the beginning of the
line, move to the beginning of the previous line, if
any.</p>

<p>vi-beginning-of-line Move to the beginning of the line,
without changing lines.</p>

<p>end-of-line (^E) (unbound) (unbound) Move to the end of
the line. If already at the end of the line, move to the end
of the next line, if any.</p>

<p>vi-end-of-line (unbound) ($) (unbound) Move to the end
of the line. If an argument is given to this command, the
cursor will be moved to the end of the line (argu- ment - 1)
lines down.</p>

<p>vi-forward-blank-word (unbound) (W) (unbound) Move
forward one word, where a word is defined as a series of
non-blank characters.</p>

<p>vi-forward-blank-word-end (unbound) (E) (unbound) Move
to the end of the current word, or, if at the end of the
current word, to the end of the next word, where a word is
defined as a series of non-blank characters.</p>

<p>forward-char (^F ESC-[C) (unbound) (unbound) Move
forward one character.</p>

<p>vi-forward-char (unbound) (space l) (ESC-[C) Move
forward one character.</p>

<p>vi-find-next-char (^X^F) (f) (unbound) Read a character
from the keyboard, and move to the next occur- rence of it
in the line.</p>

<p>vi-find-next-char-skip (unbound) (t) (unbound) Read a
character from the keyboard, and move to the position just
before the next occurrence of it in the line.</p>

<p>vi-find-prev-char (unbound) (F) (unbound) Read a
character from the keyboard, and move to the previous
occurrence of it in the line.</p>

<p>vi-find-prev-char-skip (unbound) (T) (unbound) Read a
character from the keyboard, and move to the position just
after the previous occurrence of it in the line.</p>

<p>vi-first-non-blank (unbound) (^) (unbound) Move to the
first non-blank character in the line.</p>

<p>vi-forward-word (unbound) (w) (unbound) Move forward one
word, vi-style.</p>

<p>forward-word (ESC-F ESC-f) (unbound) (unbound) Move to
the beginning of the next word. The editors idea of a word
is specified with the WORDCHARS parameter.</p>

<p>emacs-forward-word Move to the end of the next word.</p>

<p>vi-forward-word-end (unbound) (e) (unbound) Move to the
end of the next word.</p>

<p>vi-goto-column (ESC-|) (|) (unbound) Move to the column
specified by the numeric argument.</p>

<p>vi-goto-mark (unbound) () (unbound) Move to the
specified mark.</p>

<p>vi-goto-mark-line (unbound) () (unbound) Move to
beginning of the line containing the specified mark.</p>

<p>vi-repeat-find (unbound) (;) (unbound) Repeat the last
vi-find command.</p>

<p>vi-rev-repeat-find (unbound) (,) (unbound) Repeat the
last vi-find command in the opposite direction.</p>

<p>History Control beginning-of-buffer-or-history
(ESC-&lt;) (unbound) (unbound) Move to the beginning of the
buffer, or if already there, move to the first event in the
history list.</p>

<p>beginning-of-line-hist Move to the beginning of the
line. If already at the beginning of the buffer, move to the
previous history line.</p>

<p>beginning-of-history Move to the first event in the
history list.</p>

<p>down-line-or-history (^N ESC-[B) (j) (ESC-[B) Move down
a line in the buffer, or if already at the bottom line, move
to the next event in the history list.</p>

<p>vi-down-line-or-history (unbound) (+) (unbound) Move
down a line in the buffer, or if already at the bottom line,
move to the next event in the history list. Then move to the
first non-blank character on the line.</p>

<p>down-line-or-search Move down a line in the buffer, or
if already at the bottom line, search forward in the history
for a line beginning with the first word in the buffer.</p>

<p>If called from a function by the zle command with
arguments, the first argument is taken as the string for
which to search, rather than the first word in the
buffer.</p>

<p>down-history (unbound) (^N) (unbound) Move to the next
event in the history list.</p>

<p>history-beginning-search-backward Search backward in the
history for a line beginning with the current line up to the
cursor. This leaves the cursor in its original position.</p>

<p>end-of-buffer-or-history (ESC-&gt;) (unbound) (unbound)
Move to the end of the buffer, or if already there, move to
the last event in the history list.</p>

<p>end-of-line-hist Move to the end of the line. If already
at the end of the buffer, move to the next history line.</p>

<p>end-of-history Move to the last event in the history
list.</p>

<p>vi-fetch-history (unbound) (G) (unbound) Fetch the
history line specified by the numeric argument. This
defaults to the current history line (i.e. the one that isnt
history yet).</p>

<p>history-incremental-search-backward (^R ^Xr) (unbound)
(unbound) Search backward incrementally for a specified
string. The search is case-insensitive if the search string
does not have uppercase letters and no numeric argument was
given. The string may begin with ^ to anchor the search to
the beginning of the line.</p>

<p>A restricted set of editing functions is available in
the mini-buffer. An interrupt signal, as defined by the stty
set- ting, will stop the search and go back to the original
line. An undefined key will have the same effect. The
supported functions are: backward-delete-char,
vi-backward-delete-char, clear-screen, redisplay,
quoted-insert, vi-quoted-insert, accept-and-hold,
accept-and-infer-next-history, accept-line and
accept-line-and-down-history.</p>

<p>magic-space just inserts a space. vi-cmd-mode toggles
between the main and vicmd keymaps; the main keymap (insert
mode) will be selected initially.
history-incremental-search-backward will get the next
occurrence of the contents of the mini-buffer.
history-incremental-search-forward inverts the sense of the
search. vi-repeat-search and vi-rev-repeat-search are
similarly supported. The direction of the search is
indicated in the mini-buffer.</p>

<p>Any multi-character string that is not bound to one of
the above functions will beep and interrupt the search,
leaving the last found line in the buffer. Any single
character that is not bound to one of the above functions,
or self-insert or self-insert-unmeta, will have the same
effect but the function will be executed.</p>

<p>When called from a widget function by the zle command,
the incremental search commands can take a string argument.
This will be treated as a string of keys, as for arguments
to the bindkey command, and used as initial input for the
command. Any characters in the string which are unused by
the incremental search will be silently ignored. For
example,</p>

<p>zle history-incremental-search-backward forceps</p>

<p>will search backwards for forceps, leaving the
minibuffer con- taining the string forceps.</p>

<p>history-incremental-search-forward (^S ^Xs) (unbound)
(unbound) Search forward incrementally for a specified
string. The search is case-insensitive if the search string
does not have uppercase letters and no numeric argument was
given. The string may begin with ^ to anchor the search to
the beginning of the line. The functions available in the
mini-buffer are the same as for his-
tory-incremental-search-backward.</p>

<p>history-search-backward (ESC-P ESC-p) (unbound)
(unbound) Search backward in the history for a line
beginning with the first word in the buffer.</p>

<p>If called from a function by the zle command with
arguments, the first argument is taken as the string for
which to search, rather than the first word in the
buffer.</p>

<p>vi-history-search-backward (unbound) (/) (unbound)
Search backward in the history for a specified string. The
string may begin with ^ to anchor the search to the
beginning of the line.</p>

<p>A restricted set of editing functions is available in
the mini-buffer. An interrupt signal, as defined by the stty
set- ting, will stop the search. The functions available in
the mini-buffer are: accept-line, backward-delete-char,
vi-back- ward-delete-char, backward-kill-word,
vi-backward-kill-word, clear-screen, redisplay,
quoted-insert and vi-quoted-insert.</p>

<p>vi-cmd-mode is treated the same as accept-line, and
magic-space is treated as a space. Any other character that
is not bound to self-insert or self-insert-unmeta will beep
and be ignored. If the function is called from vi command
mode, the bindings of the current insert mode will be
used.</p>

<p>If called from a function by the zle command with
arguments, the first argument is taken as the string for
which to search, rather than the first word in the
buffer.</p>

<p>history-search-forward (ESC-N ESC-n) (unbound) (unbound)
Search forward in the history for a line beginning with the
first word in the buffer.</p>

<p>If called from a function by the zle command with
arguments, the first argument is taken as the string for
which to search, rather than the first word in the
buffer.</p>

<p>vi-history-search-forward (unbound) (?) (unbound) Search
forward in the history for a specified string. The string
may begin with ^ to anchor the search to the beginning of
the line. The functions available in the mini-buffer are the
same as for vi-history-search-backward. Argument handling is
also the same as for that command.</p>

<p>infer-next-history (^X^N) (unbound) (unbound) Search in
the history list for a line matching the current one and
fetch the event following it.</p>

<p>insert-last-word (ESC-_ ESC-.) (unbound) (unbound)
Insert the last word from the previous history event at the
cur- sor position. If a positive numeric argument is given,
insert that word from the end of the previous history event.
If the argument is zero or negative insert that word from
the left (zero inserts the previous command word). Repeating
this com- mand replaces the word just inserted with the last
word from the history event prior to the one just used;
numeric arguments can be used in the same way to pick a word
from that event.</p>

<p>When called from a shell function invoked from a
user-defined widget, the command can take one to three
arguments. The first argument specifies a history offset
which applies to successive calls to this widget: if is -1,
the default behaviour is used, while if it is 1, successive
calls will move forwards through the history. The value 0
can be used to indicate that the his- tory line examined by
the previous execution of the command will be reexamined.
Note that negative numbers should be preceded with a --
argument to avoid confusing them with options.</p>

<p>If two arguments are given, the second specifies the
word on the command line in normal array index notation (as
a more natural alternative to the prefix argument). Hence 1
is the first word, and -1 (the default) is the last
word.</p>

<p>If a third argument is given, its value is ignored, but
it is used to signify that the history offset is relative to
the current history line, rather than the one remembered
after the previous invocations of insert-last-word.</p>

<p>For example, the default behaviour of the command
corresponds to</p>

<p>zle insert-last-word -- -1 -1</p>

<p>while the command</p>

<p>zle insert-last-word -- -1 1 -</p>

<p>always copies the first word of the line in the history
immedi- ately before the line being edited. This has the
side effect that later invocations of the widget will be
relative to that line.</p>

<p>vi-repeat-search (unbound) (n) (unbound) Repeat the last
vi history search.</p>

<p>vi-rev-repeat-search (unbound) (N) (unbound) Repeat the
last vi history search, but in reverse.</p>

<p>up-line-or-history (^P ESC-[A) (k) (ESC-[A) Move up a
line in the buffer, or if already at the top line, move to
the previous event in the history list.</p>

<p>vi-up-line-or-history (unbound) (-) (unbound) Move up a
line in the buffer, or if already at the top line, move to
the previous event in the history list. Then move to the
first non-blank character on the line.</p>

<p>up-line-or-search Move up a line in the buffer, or if
already at the top line, search backward in the history for
a line beginning with the first word in the buffer.</p>

<p>If called from a function by the zle command with
arguments, the first argument is taken as the string for
which to search, rather than the first word in the
buffer.</p>

<p>up-history (unbound) (^P) (unbound) Move to the previous
event in the history list.</p>

<p>history-beginning-search-forward Search forward in the
history for a line beginning with the cur- rent line up to
the cursor. This leaves the cursor in its orig- inal
position.</p>

<p>Modifying Text vi-add-eol (unbound) (A) (unbound) Move
to the end of the line and enter insert mode.</p>

<p>vi-add-next (unbound) (a) (unbound) Enter insert mode
after the current cursor position, without changing
lines.</p>

<p>backward-delete-char (^H ^?) (unbound) (unbound) Delete
the character behind the cursor.</p>

<p>vi-backward-delete-char (unbound) (X) (^H) Delete the
character behind the cursor, without changing lines. If in
insert mode, this wont delete past the point where insert
mode was last entered.</p>

<p>backward-delete-word Delete the word behind the
cursor.</p>

<p>backward-kill-line Kill from the beginning of the line
to the cursor position.</p>

<p>backward-kill-word (^W ESC-^H ESC-^?) (unbound)
(unbound) Kill the word behind the cursor.</p>

<p>vi-backward-kill-word (unbound) (unbound) (^W) Kill the
word behind the cursor, without going past the point where
insert mode was last entered.</p>

<p>capitalize-word (ESC-C ESC-c) (unbound) (unbound)
Capitalize the current word and move past it.</p>

<p>vi-change (unbound) (c) (unbound) Read a movement
command from the keyboard, and kill from the cursor position
to the endpoint of the movement. Then enter insert mode. If
the command is vi-change, change the current line.</p>

<p>vi-change-eol (unbound) (C) (unbound) Kill to the end of
the line and enter insert mode.</p>

<p>vi-change-whole-line (unbound) (S) (unbound) Kill the
current line and enter insert mode.</p>

<p>copy-region-as-kill (ESC-W ESC-w) (unbound) (unbound)
Copy the area from the cursor to the mark to the kill
buffer.</p>

<p>copy-prev-word (ESC-^_) (unbound) (unbound) Duplicate
the word to the left of the cursor.</p>

<p>copy-prev-shell-word Like copy-prev-word, but the word
is found by using shell pars- ing, whereas copy-prev-word
looks for blanks. This makes a dif- ference when the word is
quoted and contains spaces.</p>

<p>vi-delete (unbound) (d) (unbound) Read a movement
command from the keyboard, and kill from the cursor position
to the endpoint of the movement. If the command is
vi-delete, kill the current line.</p>

<p>delete-char Delete the character under the cursor.</p>

<p>vi-delete-char (unbound) (x) (unbound) Delete the
character under the cursor, without going past the end of
the line.</p>

<p>delete-word Delete the current word.</p>

<p>down-case-word (ESC-L ESC-l) (unbound) (unbound) Convert
the current word to all lowercase and move past it.</p>

<p>kill-word (ESC-D ESC-d) (unbound) (unbound) Kill the
current word.</p>

<p>gosmacs-transpose-chars Exchange the two characters
behind the cursor.</p>

<p>vi-indent (unbound) (&gt;) (unbound) Indent a number of
lines.</p>

<p>vi-insert (unbound) (i) (unbound) Enter insert mode.</p>

<p>vi-insert-bol (unbound) (I) (unbound) Move to the first
non-blank character on the line and enter insert mode.</p>

<p>vi-join (^X^J) (J) (unbound) Join the current line with
the next one.</p>

<p>kill-line (^K) (unbound) (unbound) Kill from the cursor
to the end of the line. If already on the end of the line,
kill the newline character.</p>

<p>vi-kill-line (unbound) (unbound) (^U) Kill from the
cursor back to wherever insert mode was last entered.</p>

<p>vi-kill-eol (unbound) (D) (unbound) Kill from the cursor
to the end of the line.</p>

<p>kill-region Kill from the cursor to the mark.</p>

<p>kill-buffer (^X^K) (unbound) (unbound) Kill the entire
buffer.</p>

<p>kill-whole-line (^U) (unbound) (unbound) Kill the
current line.</p>

<p>vi-match-bracket (^X^B) (%) (unbound) Move to the
bracket character (one of {}, () or []) that matches the one
under the cursor. If the cursor is not on a bracket
character, move forward without going past the end of the
line to find one, and then go to the matching bracket.</p>

<p>vi-open-line-above (unbound) (O) (unbound) Open a line
above the cursor and enter insert mode.</p>

<p>vi-open-line-below (unbound) (o) (unbound) Open a line
below the cursor and enter insert mode.</p>

<p>vi-oper-swap-case Read a movement command from the
keyboard, and swap the case of all characters from the
cursor position to the endpoint of the movement. If the
movement command is vi-oper-swap-case, swap the case of all
characters on the current line.</p>

<p>overwrite-mode (^X^O) (unbound) (unbound) Toggle between
overwrite mode and insert mode.</p>

<p>vi-put-before (unbound) (P) (unbound) Insert the
contents of the kill buffer before the cursor. If the kill
buffer contains a sequence of lines (as opposed to
characters), paste it above the current line.</p>

<p>vi-put-after (unbound) (p) (unbound) Insert the contents
of the kill buffer after the cursor. If the kill buffer
contains a sequence of lines (as opposed to charac- ters),
paste it below the current line.</p>

<p>quoted-insert (^V) (unbound) (unbound) Insert the next
character typed into the buffer literally. An interrupt
character will not be inserted.</p>

<p>vi-quoted-insert (unbound) (unbound) (^Q ^V) Display a ^
at the cursor position, and insert the next char- acter
typed into the buffer literally. An interrupt character will
not be inserted.</p>

<p>quote-line (ESC-) (unbound) (unbound) Quote the current
line; that is, put a character at the beginning and the end,
and convert all characters t.</p>

<p>quote-region (ESC-&quot;) (unbound) (unbound) Quote the
region from the cursor to the mark.</p>

<p>vi-replace (unbound) (R) (unbound) Enter overwrite
mode.</p>

<p>vi-repeat-change (unbound) (.) (unbound) Repeat the last
vi mode text modification. If a count was used with the
modification, it is remembered. If a count is given to this
command, it overrides the remembered count, and is remem-
bered for future uses of this command. The cut buffer
specifi- cation is similarly remembered.</p>

<p>vi-replace-chars (unbound) (r) (unbound) Replace the
character under the cursor with a character read from the
keyboard.</p>

<p>self-insert (printable characters) (unbound) (printable
characters and some control characters) Insert a character
into the buffer at the cursor position.</p>

<p>self-insert-unmeta (ESC-^I ESC-^J ESC-^M) (unbound)
(unbound) Insert a character into the buffer after stripping
the meta bit and converting ^M to ^J.</p>

<p>vi-substitute (unbound) (s) (unbound) Substitute the
next character(s).</p>

<p>vi-swap-case (unbound) (~) (unbound) Swap the case of
the character under the cursor and move past it.</p>

<p>transpose-chars (^T) (unbound) (unbound) Exchange the
two characters to the left of the cursor if at end of line,
else exchange the character under the cursor with the
character to the left.</p>

<p>transpose-words (ESC-T ESC-t) (unbound) (unbound)
Exchange the current word with the one before it.</p>

<p>vi-unindent (unbound) (&lt;) (unbound) Unindent a number
of lines.</p>

<p>up-case-word (ESC-U ESC-u) (unbound) (unbound) Convert
the current word to all caps and move past it.</p>

<p>yank (^Y) (unbound) (unbound) Insert the contents of the
kill buffer at the cursor position.</p>

<p>yank-pop (ESC-y) (unbound) (unbound) Remove the text
just yanked, rotate the kill-ring, and yank the new top.
Only works following yank or yank-pop.</p>

<p>vi-yank (unbound) (y) (unbound) Read a movement command
from the keyboard, and copy the region from the cursor
position to the endpoint of the movement into the kill
buffer. If the command is vi-yank, copy the current
line.</p>

<p>vi-yank-whole-line (unbound) (Y) (unbound) Copy the
current line into the kill buffer.</p>

<p>vi-yank-eol Copy the region from the cursor position to
the end of the line into the kill buffer. Arguably, this is
what Y should do in vi, but it isnt what it actually
does.</p>

<p>Arguments digit-argument (ESC-0..ESC-9) (1-9) (unbound)
Start a new numeric argument, or add to the current one. See
also vi-digit-or-beginning-of-line. This only works if bound
to a key sequence ending in a decimal digit.</p>

<p>Inside a widget function, a call to this function treats
the last key of the key sequence which called the widget as
the digit.</p>

<p>neg-argument (ESC--) (unbound) (unbound) Changes the
sign of the following argument.</p>

<p>universal-argument Multiply the argument of the next
command by 4. Alternatively, if this command is followed by
an integer (positive or nega- tive), use that as the
argument for the next command. Thus dig- its cannot be
repeated using this command. For example, if this command
occurs twice, followed immediately by forward-char, move
forward sixteen spaces; if instead it is followed by -2,
then forward-char, move backward two spaces.</p>

<p>Inside a widget function, if passed an argument, i.e.
zle uni- versal-argument num, the numerical argument will be
set to num; this is equivalent to NUMERIC=num.</p>

<p>Completion accept-and-menu-complete In a menu
completion, insert the current completion into the buffer,
and advance to the next possible completion.</p>

<p>complete-word Attempt completion on the current
word.</p>

<p>delete-char-or-list (^D) (unbound) (unbound) Delete the
character under the cursor. If the cursor is at the end of
the line, list possible completions for the current
word.</p>

<p>expand-cmd-path Expand the current command to its full
pathname.</p>

<p>expand-or-complete (TAB) (unbound) (TAB) Attempt shell
expansion on the current word. If that fails, attempt
completion.</p>

<p>expand-or-complete-prefix Attempt shell expansion on the
current word up to cursor.</p>

<p>expand-history (ESC-space ESC-!) (unbound) (unbound)
Perform history expansion on the edit buffer.</p>

<p>expand-word (^X*) (unbound) (unbound) Attempt shell
expansion on the current word.</p>

<p>list-choices (ESC-^D) (^D =) (^D) List possible
completions for the current word.</p>

<p>list-expand (^Xg ^XG) (^G) (^G) List the expansion of
the current word.</p>

<p>magic-space Perform history expansion and insert a space
into the buffer. This is intended to be bound to space.</p>

<p>menu-complete Like complete-word, except that menu
completion is used. See the MENU_COMPLETE option.</p>

<p>menu-expand-or-complete Like expand-or-complete, except
that menu completion is used.</p>

<p>reverse-menu-complete Perform menu completion, like
menu-complete, except that if a menu completion is already
in progress, move to the previous completion rather than the
next.</p>

<p>end-of-list When a previous completion displayed a list
below the prompt, this widget can be used to move the prompt
below the list.</p>

<p>Miscellaneous accept-and-hold (ESC-A ESC-a) (unbound)
(unbound) Push the contents of the buffer on the buffer
stack and execute it.</p>

<p>accept-and-infer-next-history Execute the contents of
the buffer. Then search the history list for a line matching
the current one and push the event fol- lowing onto the
buffer stack.</p>

<p>accept-line (^J ^M) (^J ^M) (^J ^M) Finish editing the
buffer. Normally this causes the buffer to be executed as a
shell command.</p>

<p>accept-line-and-down-history (^O) (unbound) (unbound)
Execute the current line, and push the next history event on
the the buffer stack.</p>

<p>beep Beep, unless the BEEP option is unset.</p>

<p>vi-cmd-mode (^X^V) (unbound) (^[) Enter command mode;
that is, select the vicmd keymap. Yes, this is bound by
default in emacs mode.</p>

<p>vi-caps-lock-panic Hang until any lowercase key is
pressed. This is for vi users without the mental capacity to
keep track of their caps lock key (like the author).</p>

<p>clear-screen (^L ESC-^L) (^L) (^L) Clear the screen and
redraw the prompt.</p>

<p>describe-key-briefly Reads a key sequence, then prints
the function bound to that sequence.</p>

<p>exchange-point-and-mark (^X^X) (unbound) (unbound)
Exchange the cursor position with the position of the
mark.</p>

<p>execute-named-cmd (ESC-x) (unbound) (unbound) Read the
name of an editor command and execute it. A restricted set
of editing functions is available in the mini-buffer. An
interrupt signal, as defined by the stty setting, will abort
the function. The allowed functions are:
backward-delete-char, vi-backward-delete-char, clear-screen,
redisplay, quoted-insert, vi-quoted-insert,
backward-kill-word, vi-backward-kill-word, kill-whole-line,
vi-kill-line, backward-kill-line, list-choices,
delete-char-or-list, complete-word, accept-line,
expand-or-com- plete and expand-or-complete-prefix.</p>

<p>kill-region kills the last word, and vi-cmd-mode is
treated the same as accept-line. The space and tab
characters, if not bound to one of these functions, will
complete the name and then list the possibilities if the
AUTO_LIST option is set. Any other character that is not
bound to self-insert or self-insert-unmeta will beep and be
ignored. The bindings of the current insert mode will be
used.</p>

<p>Currently this command may not be redefined or called by
name.</p>

<p>execute-last-named-cmd (ESC-z) (unbound) (unbound) Redo
the last function executed with execute-named-cmd.</p>

<p>Currently this command may not be redefined or called by
name.</p>

<p>get-line (ESC-G ESC-g) (unbound) (unbound) Pop the top
line off the buffer stack and insert it at the cur- sor
position.</p>

<p>pound-insert (unbound) (#) (unbound) If there is no #
character at the beginning of the buffer, add one to the
beginning of each line. If there is one, remove a # from
each line that has one. In either case, accept the current
line. The INTERACTIVE_COMMENTS option must be set for this
to have any usefulness.</p>

<p>vi-pound-insert If there is no # character at the
beginning of the current line, add one. If there is one,
remove it. The INTERACTIVE_COMMENTS option must be set for
this to have any usefulness.</p>

<p>push-input Push the entire current multiline construct
onto the buffer stack and return to the top-level (PS1)
prompt. If the current parser construct is only a single
line, this is exactly like push-line. Next time the editor
starts up or is popped with get-line, the construct will be
popped off the top of the buffer stack and loaded into the
editing buffer.</p>

<p>push-line (^Q ESC-Q ESC-q) (unbound) (unbound) Push the
current buffer onto the buffer stack and clear the buffer.
Next time the editor starts up, the buffer will be popped
off the top of the buffer stack and loaded into the edit-
ing buffer.</p>

<p>push-line-or-edit At the top-level (PS1) prompt,
equivalent to push-line. At a secondary (PS2) prompt, move
the entire current multiline con- struct into the editor
buffer. The latter is equivalent to push-input followed by
get-line.</p>

<p>recursive-edit Only useful from a user-defined widget.
At this point in the function, the editor regains control
until one of the standard widgets which would normally cause
zle to exit (typically an accept-line caused by hitting the
return key) is executed. Instead, control returns to the
user-defined widget. The status returned is non-zero if the
return was caused by an error, but the function still
continues executing and hence may tidy up. This makes it
safe for the user-defined widget to alter the com- mand line
or key bindings temporarily.</p>

<p>The following widget, caps-lock, serves as an example.
self-insert-ucase() { LBUFFER+=${(U)KEYS[-1]} }</p>

<p>integer stat</p>

<p>zle -N self-insert self-insert-ucase zle -A caps-lock
save-caps-lock zle -A accept-line caps-lock</p>

<p>zle recursive-edit stat=$?</p>

<p>zle -A .self-insert self-insert zle -A save-caps-lock
caps-lock zle -D save-caps-lock</p>

<p>(( stat )) &amp;&amp; zle send-break</p>

<p>return $stat This causes typed letters to be inserted
capitalised until either accept-line (i.e. typically the
return key) is typed or the caps-lock widget is invoked
again; the later is handled by saving the old definition of
caps-lock as save-caps-lock and then rebinding it to invoke
accept-line. Note that an error from the recursive edit is
detected as a non-zero return status and propagated by using
the send-break widget.</p>

<p>redisplay (unbound) (^R) (^R) Redisplays the edit
buffer.</p>

<p>reset-prompt (unbound) (unbound) (unbound) Force the
prompts on both the left and right of the screen to be
re-expanded, then redisplay the edit buffer. This reflects
changes both to the prompt variables themselves and changes
in the expansion of the values (for example, changes in time
or directory, or changes to the value of variables referred
to by the prompt).</p>

<p>Otherwise, the prompt is only expanded each time zle
starts, and when the display as been interrupted by output
from another part of the shell (such as a job notification)
which causes the com- mand line to be reprinted.</p>

<p>send-break (^G ESC-^G) (unbound) (unbound) Abort the
current editor function, e.g. execute-named-command, or the
editor itself, e.g. if you are in vared. Otherwise abort the
parsing of the current line.</p>

<p>run-help (ESC-H ESC-h) (unbound) (unbound) Push the
buffer onto the buffer stack, and execute the command
run-help cmd , where cmd is the current command. run-help is
normally aliased to man.</p>

<p>vi-set-buffer (unbound) (&quot;) (unbound) Specify a
buffer to be used in the following command. There are 35
buffers that can be specified: the 26 named buffers &quot;a
to &quot;z and the nine queued buffers &quot;1 to &quot;9.
The named buffers can also be specified as &quot;A to
&quot;Z.</p>

<p>When a buffer is specified for a cut command, the text
being cut replaces the previous contents of the specified
buffer. If a named buffer is specified using a capital, the
newly cut text is appended to the buffer instead of
overwriting it.</p>

<p>If no buffer is specified for a cut command, &quot;1 is
used, and the contents of &quot;1 to &quot;8 are each
shifted along one buffer; the con- tents of &quot;9 is
lost.</p>

<p>vi-set-mark (unbound) (m) (unbound) Set the specified
mark at the cursor position.</p>

<p>set-mark-command (^@) (unbound) (unbound) Set the mark
at the cursor position.</p>

<p>spell-word (ESC-$ ESC-S ESC-s) (unbound) (unbound)
Attempt spelling correction on the current word.</p>

<p>undefined-key This command is executed when a key
sequence that is not bound to any command is typed. By
default it beeps.</p>

<p>undo (^_ ^Xu ^X^U) (unbound) (unbound) Incrementally
undo the last text modification.</p>

<p>redo Incrementally redo undone text modifications.</p>

<p>vi-undo-change (unbound) (u) (unbound) Undo the last
text modification. If repeated, redo the modifi- cation.</p>

<p>what-cursor-position (^X=) (unbound) (unbound) Print the
character under the cursor, its code as an octal, dec- imal
and hexadecimal number, the current cursor position within
the buffer and the column of the cursor in the current
line.</p>

<p>where-is Read the name of an editor command and and
print the listing of key sequences that invoke the specified
command.</p>

<p>which-command (ESC-?) (unbound) (unbound) Push the
buffer onto the buffer stack, and execute the command
which-command cmd. where cmd is the current command.
which-command is normally aliased to whence.</p>

<p>vi-digit-or-beginning-of-line (unbound) (0) (unbound) If
the last command executed was a digit as part of an
argument, continue the argument. Otherwise, execute
vi-beginning-of-line.</p>

<p>zsh 4.2.6 November 28, 2005 ZSHZLE(1)</p>
<hr>
</body>
</html>
