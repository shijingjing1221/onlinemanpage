<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:23 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLCOMPILE(1) Perl Programmers Reference Guide
PERLCOMPILE(1)</p>

<p>NAME perlcompile - Introduction to the Perl
Compiler-Translator</p>

<p>DESCRIPTION Perl has always had a compiler: your source
is compiled into an inter- nal form (a parse tree) which is
then optimized before being run. Since version 5.005, Perl
has shipped with a module capable of inspect- ing the
optimized parse tree (&quot;B&quot;), and this has been used
to write many useful utilities, including a module that lets
you turn your Perl into C source code that can be compiled
into a native executable.</p>

<p>The &quot;B&quot; module provides access to the parse
tree, and other modules (&quot;back ends&quot;) do things
with the tree. Some write it out as bytecode, C source code,
or a semi-human-readable text. Another traverses the parse
tree to build a cross-reference of which subroutines,
formats, and variables are used where. Another checks your
code for dubious constructs. Yet another back end dumps the
parse tree back out as Perl source, acting as a source code
beautifier or deobfuscator.</p>

<p>Because its original purpose was to be a way to produce
C code corre- sponding to a Perl program, and in turn a
native executable, the &quot;B&quot; module and its
associated back ends are known as &quot;the compiler&quot;,
even though they dont really compile anything. Different
parts of the com- piler are more accurately a
&quot;translator&quot;, or an &quot;inspector&quot;, but
people want Perl to have a &quot;compiler option&quot; not
an &quot;inspector gadget&quot;. What can you do?</p>

<p>This document covers the use of the Perl compiler: which
modules it comprises, how to use the most important of the
back end modules, what problems there are, and how to work
around them.</p>

<p>Layout</p>

<p>The compiler back ends are in the &quot;B::&quot;
hierarchy, and the front-end (the module that you, the user
of the compiler, will sometimes interact with) is the O
module. Some back ends (e.g., &quot;B::C&quot;) have
programs (e.g., perlcc) to hide the modules complexity.</p>

<p>Here are the important back ends to know about, with
their status expressed as a number from 0 (outline for later
implementation) to 10 (if theres a bug in it, were very
surprised):</p>

<p>B::Bytecode Stores the parse tree in a
machine-independent format, suitable for later reloading
through the ByteLoader module. Status: 5 (some things work,
some things don t, some things are untested).</p>

<p>B::C Creates a C source file containing code to rebuild
the parse tree and resume the interpreter. Status: 6 (many
things work ade- quately, including programs using Tk).</p>

<p>B::CC Creates a C source file corresponding to the run
time code path in the parse tree. This is the closest to a
Perl-to-C translator there is, but the code it generates is
almost incomprehensible because it translates the parse tree
into a giant switch structure that manipulates Perl
structures. Eventual goal is to reduce (given sufficient
type information in the Perl program) some of the Perl data
structure manipulations into manipulations of C-level ints,
floats, etc. Status: 5 (some things work, including uncom-
plicated Tk examples).</p>

<p>B::Lint Complains if it finds dubious constructs in your
source code. Sta- tus: 6 (it works adequately, but only has
a very limited number of areas that it checks).</p>

<p>B::Deparse Recreates the Perl source, making an attempt
to format it coher- ently. Status: 8 (it works nicely, but a
few obscure things are missing).</p>

<p>B::Xref Reports on the declaration and use of
subroutines and variables. Status: 8 (it works nicely, but
still has a few lingering bugs).</p>

<p>Using The Back Ends The following sections describe how
to use the various compiler back ends. They re presented
roughly in order of maturity, so that the most stable and
proven back ends are described first, and the most experi-
mental and incomplete back ends are described last.</p>

<p>The O module automatically enabled the -c flag to Perl,
which prevents Perl from executing your code once it has
been compiled. This is why all the back ends print:</p>

<p>myperlprogram syntax OK</p>

<p>before producing any other output.</p>

<p>The Cross Referencing Back End</p>

<p>The cross referencing back end (B::Xref) produces a
report on your pro- gram, breaking down declarations and
uses of subroutines and variables (and formats) by file and
subroutine. For instance, heres part of the report from the
pod2man program that comes with Perl:</p>

<p>Subroutine clear_noremap Package (lexical)
$ready_to_print i1069, 1079 Package main $&amp; 1086 $. 1086
$0 1086 $1 1087 $2 1085, 1085 $3 1085, 1085 $ARGV 1086
%HTML_Escapes 1085, 1085</p>

<p>This shows the variables used in the subroutine
&quot;clear_noremap&quot;. The variable $ready_to_print is a
my() (lexical) variable, introduced (first declared with
my()) on line 1069, and used on line 1079. The variable
$&amp; from the main package is used on 1086, and so on.</p>

<p>A line number may be prefixed by a single letter:</p>

<p>i Lexical variable introduced (declared with my()) for
the first time.</p>

<p>&amp; Subroutine or method call.</p>

<p>s Subroutine defined.</p>

<p>r Format defined.</p>

<p>The most useful option the cross referencer has is to
save the report to a separate file. For instance, to save
the report on myperlprogram to the file report:</p>

<p>$ perl -MO=Xref,-oreport myperlprogram</p>

<p>The Decompiling Back End</p>

<p>The Deparse back end turns your Perl source back into
Perl source. It can reformat along the way, making it useful
as a de-obfuscator. The most basic way to use it is:</p>

<p>$ perl -MO=Deparse myperlprogram</p>

<p>You ll notice immediately that Perl has no idea of how
to paragraph your code. Youll have to separate chunks of
code from each other with newlines by hand. However, watch
what it will do with one-liners:</p>

<p>$ perl -MO=Deparse -e $op=shiftdie &quot;usage: $0 code
[...]&quot;;chomp(@ARGV=&lt;&gt;)unless@ARGV;
for(@ARGV){$was=$_;eval$op; die$@ if$@; rename$was,$_
unless$was eq $_} -e syntax OK $op = shift @ARGV
die(&quot;usage: $0 code [...]&quot;); chomp(@ARGV =
&lt;ARGV&gt;) unless @ARGV; foreach $_ (@ARGV) { $was = $_;
eval $op; die $@ if $@; rename $was, $_ unless $was eq $_;
}</p>

<p>The decompiler has several options for the code it
generates. For instance, you can set the size of each indent
from 4 (as above) to 2 with:</p>

<p>$ perl -MO=Deparse,-si2 myperlprogram</p>

<p>The -p option adds parentheses where normally they are
omitted:</p>

<p>$ perl -MO=Deparse -e print &quot;Hello, world0 -e
syntax OK print &quot;Hello, world0; $ perl -MO=Deparse,-p
-e print &quot;Hello, world0 -e syntax OK print(&quot;Hello,
world0);</p>

<p>See B::Deparse for more information on the formatting
options.</p>

<p>The Lint Back End</p>

<p>The lint back end (B::Lint) inspects programs for poor
style. One pro- grammers bad style is another programmers
useful tool, so options let you select what is complained
about.</p>

<p>To run the style checker across your source code:</p>

<p>$ perl -MO=Lint myperlprogram</p>

<p>To disable context checks and undefined subroutines:</p>

<p>$ perl -MO=Lint,-context,-undefined-subs
myperlprogram</p>

<p>See B::Lint for information on the options.</p>

<p>The Simple C Back End</p>

<p>This module saves the internal compiled state of your
Perl program to a C source file, which can be turned into a
native executable for that particular platform using a C
compiler. The resulting program links against the Perl
interpreter library, so it will not save you disk space
(unless you build Perl with a shared library) or program
size. It may, however, save you startup time.</p>

<p>The &quot;perlcc&quot; tool generates such executables
by default.</p>

<p>perlcc myperlprogram.pl</p>

<p>The Bytecode Back End</p>

<p>This back end is only useful if you also have a way to
load and execute the bytecode that it produces. The
ByteLoader module provides this functionality.</p>

<p>To turn a Perl program into executable byte code, you
can use &quot;perlcc&quot; with the &quot;-B&quot;
switch:</p>

<p>perlcc -B myperlprogram.pl</p>

<p>The byte code is machine independent, so once you have a
compiled mod- ule or program, it is as portable as Perl
source (assuming that the user of the module or program has
a modern-enough Perl interpreter to decode the byte
code).</p>

<p>See B::Bytecode for information on options to control
the optimization and nature of the code generated by the
Bytecode module.</p>

<p>The Optimized C Back End</p>

<p>The optimized C back end will turn your Perl programs
run time code- path into an equivalent (but optimized) C
program that manipulates the Perl data structures directly.
The program will still link against the Perl interpreter
library, to allow for eval(), &quot;s///e&quot;,
&quot;require&quot;, etc.</p>

<p>The &quot;perlcc&quot; tool generates such executables
when using the -O switch. To compile a Perl program (ending
in &quot;.pl&quot; or &quot;.p&quot;):</p>

<p>perlcc -O myperlprogram.pl</p>

<p>To produce a shared library from a Perl module (ending
in &quot;.pm&quot;):</p>

<p>perlcc -O Myperlmodule.pm</p>

<p>For more information, see perlcc and B::CC.</p>

<p>Module List for the Compiler Suite B This module is the
introspective (&quot;reflective&quot; in Java terms) mod-
ule, which allows a Perl program to inspect its innards. The
back end modules all use this module to gain access to the
compiled parse tree. You, the user of a back end module,
will not need to interact with B.</p>

<p>O This module is the front-end to the compilers back
ends. Normally called something like this:</p>

<p>$ perl -MO=Deparse myperlprogram</p>

<p>This is like saying &quot;use O
&rsquo;Deparse&rsquo;&quot; in your Perl program.</p>

<p>B::Asmdata This module is used by the B::Assembler
module, which is in turn used by the B::Bytecode module,
which stores a parse-tree as byte- code for later loading.
Its not a back end itself, but rather a component of a back
end.</p>

<p>B::Assembler This module turns a parse-tree into data
suitable for storing and later decoding back into a
parse-tree. Its not a back end itself, but rather a
component of a back end. Its used by the assemble program
that produces bytecode.</p>

<p>B::Bblock This module is used by the B::CC back end. It
walks &quot;basic blocks&quot;. A basic block is a series of
operations which is known to execute from start to finish,
with no possibility of branching or halting.</p>

<p>B::Bytecode This module is a back end that generates
bytecode from a programs parse tree. This bytecode is
written to a file, from where it can later be reconstructed
back into a parse tree. The goal is to do the expensive
program compilation once, save the interpreters state into a
file, and then restore the state from the file when the
program is to be executed. See &quot;The Bytecode Back
End&quot; for details about usage.</p>

<p>B::C This module writes out C code corresponding to the
parse tree and other interpreter internal structures. You
compile the correspond- ing C file, and get an executable
file that will restore the inter- nal structures and the
Perl interpreter will begin running the pro- gram. See
&quot;The Simple C Back End&quot; for details about
usage.</p>

<p>B::CC This module writes out C code corresponding to
your programs oper- ations. Unlike the B::C module, which
merely stores the inter- preter and its state in a C
program, the B::CC module makes a C program that does not
involve the interpreter. As a consequence, programs
translated into C by B::CC can execute faster than normal
interpreted programs. See &quot;The Optimized C Back
End&quot; for details about usage.</p>

<p>B::Concise This module prints a concise (but complete)
version of the Perl parse tree. Its output is more
customizable than the one of B::Terse or B::Debug (and it
can emulate them). This module useful for people who are
writing their own back end, or who are learning about the
Perl internals. It s not useful to the average program-
mer.</p>

<p>B::Debug This module dumps the Perl parse tree in
verbose detail to STDOUT. It s useful for people who are
writing their own back end, or who are learning about the
Perl internals. Its not useful to the average
programmer.</p>

<p>B::Deparse This module produces Perl source code from
the compiled parse tree. It is useful in debugging and
deconstructing other peoples code, also as a pretty-printer
for your own source. See &quot;The Decompiling Back
End&quot; for details about usage.</p>

<p>B::Disassembler This module turns bytecode back into a
parse tree. It s not a back end itself, but rather a
component of a back end. Its used by the disassemble program
that comes with the bytecode.</p>

<p>B::Lint This module inspects the compiled form of your
source code for things which, while some people frown on
them, arent necessarily bad enough to justify a warning. For
instance, use of an array in scalar context without
explicitly saying &quot;scalar(@array)&quot; is some- thing
that Lint can identify. See &quot;The Lint Back End&quot;
for details about usage.</p>

<p>B::Showlex This module prints out the my() variables
used in a function or a file. To get a list of the my()
variables used in the subroutine mysub() defined in the file
myperlprogram:</p>

<p>$ perl -MO=Showlex,mysub myperlprogram</p>

<p>To get a list of the my() variables used in the file
myperlprogram:</p>

<p>$ perl -MO=Showlex myperlprogram</p>

<p>[BROKEN]</p>

<p>B::Stackobj This module is used by the B::CC module. It
s not a back end itself, but rather a component of a back
end.</p>

<p>B::Stash This module is used by the perlcc program,
which compiles a module into an executable. B::Stash prints
the symbol tables in use by a program, and is used to
prevent B::CC from producing C code for the B::* and O
modules. Its not a back end itself, but rather a com- ponent
of a back end.</p>

<p>B::Terse This module prints the contents of the parse
tree, but without as much information as B::Debug. For
comparison, &quot;print &quot;Hello, world.&quot;&quot;
produced 96 lines of output from B::Debug, but only 6 from
B::Terse.</p>

<p>This module is useful for people who are writing their
own back end, or who are learning about the Perl internals.
It s not useful to the average programmer.</p>

<p>B::Xref This module prints a report on where the
variables, subroutines, and formats are defined and used
within a program and the modules it loads. See &quot;The
Cross Referencing Back End&quot; for details about
usage.</p>

<p>KNOWN PROBLEMS The simple C backend currently only saves
typeglobs with alphanumeric names.</p>

<p>The optimized C backend outputs code for more modules
than it should (e.g., DirHandle). It also has little hope of
properly handling &quot;goto LABEL&quot; outside the running
subroutine (&quot;goto &amp;sub&quot; is okay). &quot;goto
LABEL&quot; currently does not work at all in this backend.
It also creates a huge initialization function that gives C
compilers headaches. Splitting the initialization function
gives better results. Other problems include: unsigned math
does not work correctly; some opcodes are handled
incorrectly by default opcode handling mechanism.</p>

<p>BEGIN{} blocks are executed while compiling your code.
Any external state that is initialized in BEGIN{}, such as
opening files, initiating database connections etc., do not
behave properly. To work around this, Perl has an INIT{}
block that corresponds to code being executed before your
program begins running but after your program has finished
being compiled. Execution order: BEGIN{}, (possible save of
state through compiler back-end), INIT{}, program runs,
END{}.</p>

<p>AUTHOR This document was originally written by Nathan
Torkington, and is now maintained by the perl5-porters
mailing list perl5-porters@perl.org.</p>

<p>perl v5.8.8 2014-02-11 PERLCOMPILE(1)</p>
<hr>
</body>
</html>
