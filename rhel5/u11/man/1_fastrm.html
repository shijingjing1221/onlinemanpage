<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:09:51 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>FASTRM(1) InterNetNews Documentation FASTRM(1)</p>

<p>NAME fastrm - Quickly remove a list of files</p>

<p>SYNOPSIS fastrm [-de] [-u-uN] [-s-sM] [-c-cI]
base-directory</p>

<p>DESCRIPTION fastrm reads a list of either file names or
storage API tokens, one per line, from its standard input
and removes them. Storage API tokens are removed via the
SMcancel() interface. fastrm does not delete files safely or
with an eye to security, but rather cuts every corner it can
to delete files as fast as it can. It should therefore never
be run on publically writable directories, or in any other
environment where a hostile party may control the directory
structure in which it is work- ing.</p>

<p>If a file name is not an absolute path name, it is
considered to be relative to base-directory as given on the
command line. The base- directory parameter must be a simple
absolute pathname (it must not contain multiple consecutive
slashes or references to the special directories
&quot;.&quot; or &quot;..&quot;).</p>

<p>fastrm is designed to be faster than the typical &quot;
xargs rm&quot; pipeline when given a sorted list of file
names as input. For example, fastrm will usually chdir(2)
into a directory before removing files from it, meaning that
if its input is sorted, most names passed to unlink(2) will
be simple names. This can substantially reduce the operating
sys- tem overhead from directory lookups.</p>

<p>fastrm assumes that its input is valid and that it is
safe to call unlink(2) on every file name it is given. As a
safety measure, how- ever, fastrm when running as root will
check with stat(2) that a file name doesn t specify a
directory before removing it. (In some operat- ing systems,
root is allowed to unlink directories, even directories
which aren t empty, which can cause file system
corruption.)</p>

<p>The input to fastrm should always be sorted -- or even
better be in the order file names are output by find(1) --
if speed is an issue and the input isnt solely storage API
tokens. (It deals fine with unsorted input, but is unlikely
to be any faster in that case than a simple &quot;xargs
rm&quot; command.) Sorting may even slightly speed up the
removal of storage API tokens due to caching effects, since
sorting will tend to keep all of the tokens from a
particular storage method together.</p>

<p>Various additional optimizations for removing files can
be turned on and/or tuned with options (see below). Which
options will be most effective depends heavily on the
underlying structure of the file sys- tem, the way in which
directories are stored and searched, and similar, often
underdocumented, operating system implementation details.
The more sophisticated the underlying operating system and
file system, the more likely that it will already perform
the equivalent of these opti- mizations internally.</p>

<p>OPTIONS -d Dont remove any files. Instead, print a list
of the files that would be removed to standard output. Each
line contains either the current directory of fastrm at the
time it would do the unlink and the relative path name it
would pass to unlink(2) as two fields separated by
whitespace and a &quot;/&quot;, the absolute path name (as a
single field) that would be passed to unlink(2), or the
string &quot;Token&quot; and the storage API token that
would be removed.</p>

<p>-e Treat an empty input file as an error. This is most
useful when fastrm is last in a pipeline after a preceding
sort(1) command, ensuring that fastrm will fail if the sort
fails.</p>

<p>-cI Controls when fastrm calls chdir(2). If the number
of files to be unlinked from a given directory is at least
I, then fastrm will change to that directory before
unlinking those files. Otherwise, it will use either the
absolute path names or a path name relative to the current
directory (whichever is likely more efficient). The I
parameter is optional; if just -c is given, -c1 is assumed,
which will cause fastrm to always chdir before calling
unlink(2). The default is -c3. Use -c0 to prevent fastrm
from ever using chdir(2).</p>

<p>-sM When -s is given and the number of files to remove
in a directory is greater than M, rather than remove files
in the order given, fastrm will open the directory and read
it, unlinking files in the order that they appear in the
directory. On systems with a per- process directory cache or
that use a linear search to find files in a directory, this
should make directory lookups faster. The M parameter is
optional; if just -s is given, -s5 is assumed.</p>

<p>When this option is in effect, fastrm wont attempt to
remove files that it doesn t see in the directory, possibly
significantly speed- ing it up if most of the files to be
removed have already been deleted. However, using this
option requires fastrm to do more internal work and it also
assumes that the order of directory list- ings is stable in
the presence of calls to unlink(2) between calls to
readdir(3). This may be a dangerous assumption with some
sophisticated file systems (and in general this option is
only use- ful with file systems that use unindexed linear
searches to find files in directories or when most of the
files to be removed have already been deleted).</p>

<p>This optimization is off by default.</p>

<p>-uN Specifying this option promises that there are no
symbolic links in the directory tree from which files are
being removed. This allows fastrm to make an additional
optimization to its calls to chdir(2), constructing a
relative path using &quot;../..&quot; and the like to pass
to chdir(2) rather than always using absolute paths. Since
this reduces the number of directory lookups needed with
deeply nested directory structures (such as that typically
created by traditional news spool storage), it can be a
significant optimization, but it breaks horribly in the
presence of symbolic links to directories.</p>

<p>When -u is given, fastrm will use at most N levels of
&quot;..&quot; seg- ments to construct paths. N is optional;
if just -u is given, -u1 is assumed.</p>

<p>This optimization is off by default.</p>

<p>fastrm also accepts -a and -r options, which do nothing
at all except allow you to say &quot;fastrm -usa&quot;,
&quot;fastrm -ussr&quot;, or &quot;fastrm -user&quot;. These
happen to often be convenient sets of options to use.</p>

<p>EXIT STATUS fastrm exits with a status of zero if there
were no problems, and an exit status of 1 if something went
wrong. Attempting to remove a file that does not exist is
not considered a problem.</p>

<p>EXAMPLES fastrm is typically invoked by INN via
expirerm(8) using a command like:</p>

<p>fastrm -e /usr/local/news/spool/articles &lt;
expire.list</p>

<p>To enable all optimizations and see the affect on the
order of removal caused by -s, use:</p>

<p>fastrm -d -s -e -u ~news/spool/articles &lt;
expire.list</p>

<p>If your file system has indexed directory lookups, but
you have a deeply nested directory structure, you may want
to use a set of flags like:</p>

<p>fastrm -e -u3 ~news/spool/articles &lt; expire.list</p>

<p>to strongly prefer relative paths but not to use
readdir(2) to order the calls to unlink(2).</p>

<p>You may want to edit expirerm(8) to change the flags
passed to fastrm.</p>

<p>WARNINGS fastrm cuts corners and does not worry about
security, so it does not use chdir(2) safely and could be
tricked into removing files other than those that were
intended if run on a specially constructed file tree or a
file tree that is being modified while it is running. It
should therefore never be used with world-writable
directories or any other directory that might be controlled
or modified by an attacker.</p>

<p>NOTES fastrm defers opening the storage subsystem or
attempting to parse any INN configuration files until it
encounters a token in the list of files to remove. It s
therefore possible to use fastrm outside of INN as a general
fast file removal program.</p>

<p>HISTORY fastrm was originally written by
kre@munnari.oz.au. This manual page rewritten in POD by Russ
Allbery &lt;rra@stanford.edu&gt; for InterNetNews.</p>

<p>$Id: fastrm.1 7429 2005-12-11 20:42:43Z eagle $</p>

<p>SEE ALSO expirerm(8)</p>

<p>INN 2.4.3 2005-10-08 FASTRM(1)</p>
<hr>
</body>
</html>
