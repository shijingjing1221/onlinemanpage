<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:15:12 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>LINK(2) Linux Programmer s Manual LINK(2)</p>

<p>NAME link - make a new name for a file</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int link(const char *oldpath, const char *newpath);</p>

<p>DESCRIPTION link() creates a new link (also known as a
hard link) to an existing file.</p>

<p>If newpath exists it will not be overwritten.</p>

<p>This new name may be used exactly as the old one for any
operation; both names refer to the same file (and so have
the same permissions and ownership) and it is impossible to
tell which name was the &lsquo;original.</p>

<p>RETURN VALUE On success, zero is returned. On error, -1
is returned, and errno is set appropriately.</p>

<p>ERRORS EACCES Write access to the directory containing
newpath is denied, or search permission is denied for one of
the directories in the path prefix of oldpath or newpath.
(See also path_resolu- tion(2).)</p>

<p>EEXIST newpath already exists.</p>

<p>EFAULT oldpath or newpath points outside your accessible
address space.</p>

<p>EIO An I/O error occurred.</p>

<p>ELOOP Too many symbolic links were encountered in
resolving oldpath or newpath.</p>

<p>EMLINK The file referred to by oldpath already has the
maximum number of links to it.</p>

<p>ENAMETOOLONG oldpath or newpath was too long.</p>

<p>ENOENT A directory component in oldpath or newpath does
not exist or is a dangling symbolic link.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ENOSPC The device containing the file has no room for
the new directory entry.</p>

<p>ENOTDIR A component used as a directory in oldpath or
newpath is not, in fact, a directory.</p>

<p>EPERM oldpath is a directory.</p>

<p>EPERM The filesystem containing oldpath and newpath does
not support the creation of hard links.</p>

<p>EROFS The file is on a read-only filesystem.</p>

<p>EXDEV oldpath and newpath are not on the same mounted
filesystem. (Linux permits a filesystem to be mounted at
multiple points, but link(2) does not work across different
mount points, even if the same filesystem is mounted on
both.)</p>

<p>NOTES Hard links, as created by link(), cannot span
filesystems. Use sym- link() if this is required.</p>

<p>POSIX.1-2001 says that link() should dereference oldpath
if it is a symbolic link. However, Linux does not do so: if
oldpath is a symbolic link, then newpath is created as a
(hard) link to the same symbolic link file (i.e., newpath
becomes a symbolic link to the same file that oldpath refers
to). Some other implementations behave in the same man- ner
as Linux.</p>

<p>CONFORMING TO SVr4, 4.3BSD, POSIX.1-2001 (except as
noted above).</p>

<p>BUGS On NFS file systems, the return code may be wrong
in case the NFS server performs the link creation and dies
before it can say so. Use stat(2) to find out if the link
got created.</p>

<p>SEE ALSO ln(1), linkat(2), open(2), path_resolution(2),
rename(2), stat(2), sym- link(2), unlink(2)</p>

<p>Linux 2.6.7 2004-06-23 LINK(2)</p>
<hr>
</body>
</html>
