<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:40 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLOPENTUT(1) Perl Programmers Reference Guide
PERLOPENTUT(1)</p>

<p>NAME perlopentut - tutorial on opening things in
Perl</p>

<p>DESCRIPTION Perl has two simple, built-in ways to open
files: the shell way for convenience, and the C way for
precision. The shell way also has 2- and 3-argument forms,
which have different semantics for handling the filename.
The choice is yours.</p>

<p>Open A la shell Perl s &quot;open&quot; function was
designed to mimic the way command-line redi- rection in the
shell works. Here are some basic examples from the
shell:</p>

<p>$ myprogram file1 file2 file3 $ myprogram &lt; inputfile
$ myprogram &gt; outputfile $ myprogram &gt;&gt; outputfile
$ myprogram otherprogram $ otherprogram myprogram</p>

<p>And here are some more advanced examples:</p>

<p>$ otherprogram myprogram f1 - f2 $ otherprogram
2&gt;&amp;1 myprogram - $ myprogram &lt;&amp;3 $ myprogram
&gt;&amp;4</p>

<p>Programmers accustomed to constructs like those above
can take comfort in learning that Perl directly supports
these familiar constructs using virtually the same syntax as
the shell.</p>

<p>Simple Opens</p>

<p>The &quot;open&quot; function takes two arguments: the
first is a filehandle, and the second is a single string
comprising both what to open and how to open it.
&quot;open&quot; returns true when it works, and when it
fails, returns a false value and sets the special variable
$! to reflect the system error. If the filehandle was
previously opened, it will be implicitly closed first.</p>

<p>For example:</p>

<p>open(INFO, &quot;datafile&quot;) die(&quot;cant open
datafile: $!&quot;); open(INFO, &quot;&lt; datafile&quot;)
die(&quot;cant open datafile: $!&quot;);
open(RESULTS,&quot;&gt; runstats&quot;) die(&quot;cant open
runstats: $!&quot;); open(LOG, &quot;&gt;&gt; logfile
&quot;) die(&quot;cant open logfile: $!&quot;);</p>

<p>If you prefer the low-punctuation version, you could
write that this way:</p>

<p>open INFO, &quot;&lt; datafile&quot; or die &quot;can t
open datafile: $!&quot;; open RESULTS,&quot;&gt;
runstats&quot; or die &quot;can t open runstats: $!&quot;;
open LOG, &quot;&gt;&gt; logfile &quot; or die &quot;cant
open logfile: $!&quot;;</p>

<p>A few things to notice. First, the leading less-than is
optional. If omitted, Perl assumes that you want to open the
file for reading.</p>

<p>Note also that the first example uses the &quot; &quot;
logical operator, and the second uses &quot;or&quot;, which
has lower precedence. Using &quot; &quot; in the latter
examples would effectively mean</p>

<p>open INFO, ( &quot;&lt; datafile&quot; die &quot;cant
open datafile: $!&quot; );</p>

<p>which is definitely not what you want.</p>

<p>The other important thing to notice is that, just as in
the shell, any whitespace before or after the filename is
ignored. This is good, because you wouldnt want these to do
different things:</p>

<p>open INFO, &quot;&lt;datafile&quot; open INFO,
&quot;&lt; datafile&quot; open INFO, &quot;&lt;
datafile&quot;</p>

<p>Ignoring surrounding whitespace also helps for when you
read a filename in from a different file, and forget to trim
it before opening:</p>

<p>$filename = &lt;INFO&gt;; # oops, still there
open(EXTRA, &quot;&lt; $filename&quot;) die &quot;cant open
$filename: $!&quot;;</p>

<p>This is not a bug, but a feature. Because
&quot;open&quot; mimics the shell in its style of using
redirection arrows to specify how to open the file, it also
does so with respect to extra whitespace around the filename
itself as well. For accessing files with naughty names, see
&quot;Dis- pelling the Dweomer&quot;.</p>

<p>There is also a 3-argument version of &quot;open&quot;,
which lets you put the special redirection characters into
their own argument:</p>

<p>open( INFO, &quot;&gt;&quot;, $datafile ) die &quot;Cant
create $datafile: $!&quot;;</p>

<p>In this case, the filename to open is the actual string
in $datafile, so you don t have to worry about $datafile
containing characters that might influence the open mode, or
whitespace at the beginning of the filename that would be
absorbed in the 2-argument version. Also, any reduction of
unnecessary string interpolation is a good thing.</p>

<p>Indirect Filehandles</p>

<p>&quot;open&quot;s first argument can be a reference to a
filehandle. As of perl 5.6.0, if the argument is
uninitialized, Perl will automatically create a filehandle
and put a reference to it in the first argument, like
so:</p>

<p>open( my $in, $infile ) or die &quot;Couldn t read
$infile: $!&quot;; while ( &lt;$in&gt; ) { # do something
with $_ } close $in;</p>

<p>Indirect filehandles make namespace management easier.
Since filehan- dles are global to the current package, two
subroutines trying to open &quot;INFILE&quot; will clash.
With two functions opening indirect filehandles like
&quot;my $infile&quot;, theres no clash and no need to worry
about future conflicts.</p>

<p>Another convenient behavior is that an indirect
filehandle automati- cally closes when it goes out of scope
or when you undefine it:</p>

<p>sub firstline { open( my $in, shift ) &amp;&amp; return
scalar &lt;$in&gt;; # no close() required }</p>

<p>Pipe Opens</p>

<p>In C, when you want to open a file using the standard
I/O library, you use the &quot;fopen&quot; function, but
when opening a pipe, you use the &quot;popen&quot; function.
But in the shell, you just use a different redirection
character. Thats also the case for Perl. The
&quot;open&quot; call remains the same--just its argument
differs.</p>

<p>If the leading character is a pipe symbol,
&quot;open&quot; starts up a new com- mand and opens a
write-only filehandle leading into that command. This lets
you write into that handle and have what you write show up
on that commands standard input. For example:</p>

<p>open(PRINTER, &quot; lpr -Plp1&quot;) die &quot;can t
run lpr: $!&quot;; print PRINTER &quot;stuff0;
close(PRINTER) die &quot;cant close lpr: $!&quot;;</p>

<p>If the trailing character is a pipe, you start up a new
command and open a read-only filehandle leading out of that
command. This lets whatever that command writes to its
standard output show up on your handle for reading. For
example:</p>

<p>open(NET, &quot;netstat -i -n &quot;) die &quot;cant
fork netstat: $!&quot;; while (&lt;NET&gt;) { } # do
something with input close(NET) die &quot;can t close
netstat: $!&quot;;</p>

<p>What happens if you try to open a pipe to or from a
non-existent com- mand? If possible, Perl will detect the
failure and set $! as usual. But if the command contains
special shell characters, such as &quot;&gt;&quot; or
&quot;*&quot;, called metacharacters , Perl does not execute
the command directly. Instead, Perl runs the shell, which
then tries to run the command. This means that it s the
shell that gets the error indica- tion. In such a case, the
&quot;open&quot; call will only indicate failure if Perl can
t even run the shell. See &quot;How can I capture STDERR
from an external command?&quot; in perlfaq8 to see how to
cope with this. Theres also an explanation in perlipc.</p>

<p>If you would like to open a bidirectional pipe, the
IPC::Open2 library will handle this for you. Check out
&quot;Bidirectional Communication with Another Process&quot;
in perlipc</p>

<p>The Minus File</p>

<p>Again following the lead of the standard shell
utilities, Perls &quot;open&quot; function treats a file
whose name is a single minus, &quot;-&quot;, in a special
way. If you open minus for reading, it really means to
access the standard input. If you open minus for writing, it
really means to access the standard output.</p>

<p>If minus can be used as the default input or default
output, what hap- pens if you open a pipe into or out of
minus? What s the default com- mand it would run? The same
script as youre currently running! This is actually a
stealth &quot;fork&quot; hidden inside an &quot;open&quot;
call. See &quot;Safe Pipe Opens&quot; in perlipc for
details.</p>

<p>Mixing Reads and Writes</p>

<p>It is possible to specify both read and write access.
All you do is add a &quot;+&quot; symbol in front of the
redirection. But as in the shell, using a less-than on a
file never creates a new file; it only opens an existing
one. On the other hand, using a greater-than always clobbers
(truncates to zero length) an existing file, or creates a
brand-new one if there isnt an old one. Adding a
&quot;+&quot; for read-write doesnt affect whether it only
works on existing files or always clobbers existing
ones.</p>

<p>open(WTMP, &quot;+&lt; /usr/adm/wtmp&quot;) die
&quot;cant open /usr/adm/wtmp: $!&quot;;</p>

<p>open(SCREEN, &quot;+&gt; lkscreen&quot;) die &quot;cant
open lkscreen: $!&quot;;</p>

<p>open(LOGFILE, &quot;+&gt;&gt; /var/log/applog&quot; die
&quot;cant open /var/log/applog: $!&quot;;</p>

<p>The first one wont create a new file, and the second one
will always clobber an old one. The third one will create a
new file if necessary and not clobber an old one, and it
will allow you to read at any point in the file, but all
writes will always go to the end. In short, the first case
is substantially more common than the second and third
cases, which are almost always wrong. (If you know C, the
plus in Perls &quot;open&quot; is historically derived from
the one in C s fopen(3S), which it ultimately calls.)</p>

<p>In fact, when it comes to updating a file, unless youre
working on a binary file as in the WTMP case above, you
probably don t want to use this approach for updating.
Instead, Perls -i flag comes to the res- cue. The following
command takes all the C, C++, or yacc source or header files
and changes all their foos to bars, leaving the old ver-
sion in the original filename with a &quot;.orig&quot;
tacked on the end:</p>

<p>o o g * . $ perl -i.orig -pe s/[ C c h y ]</p>

<p>This is a short cut for some renaming games that are
really the best way to update textfiles. See the second
question in perlfaq5 for more details.</p>

<p>Filters</p>

<p>One of the most common uses for &quot;open&quot; is one
you never even notice. When you process the ARGV filehandle
using &quot;&lt;ARGV&gt;&quot;, Perl actually does an
implicit open on each file in @ARGV. Thus a program called
like this:</p>

<p>$ myprogram file1 file2 file3</p>

<p>Can have all its files opened and processed one at a
time using a con- struct no more complex than:</p>

<p>while (&lt;&gt;) { # do something with $_ }</p>

<p>If @ARGV is empty when the loop first begins, Perl
pretends youve opened up minus, that is, the standard input.
In fact, $ARGV, the cur- rently open file during
&quot;&lt;ARGV&gt;&quot; processing, is even set to
&quot;-&quot; in these circumstances.</p>

<p>You are welcome to pre-process your @ARGV before
starting the loop to make sure its to your liking. One
reason to do this might be to remove command options
beginning with a minus. While you can always roll the simple
ones by hand, the Getopts modules are good for this:</p>

<p>use Getopt::Std;</p>

<p># -v, -D, -o ARG, sets $opt_v, $opt_D, $opt_o
getopts(&quot;vDo:&quot;);</p>

<p># -v, -D, -o ARG, sets $args{v}, $args{D}, $args{o}
getopts(&quot;vDo:&quot;, args);</p>

<p>Or the standard Getopt::Long module to permit named
arguments:</p>

<p>use Getopt::Long; GetOptions( &quot;verbose&quot; =&gt;
erbose, # --verbose &quot;Debug&quot; =&gt; ebug, # --Debug
&quot;output=s&quot; =&gt; utput ); # --output=somestring or
--output somestring</p>

<p>Another reason for preprocessing arguments is to make an
empty argument list default to all files:</p>

<p>@ARGV = glob(&quot;*&quot;) unless @ARGV;</p>

<p>You could even filter out all but plain, text files.
This is a bit silent, of course, and you might prefer to
mention them on the way.</p>

<p>@ARGV = grep { -f &amp;&amp; -T } @ARGV;</p>

<p>If youre using the -n or -p command-line options, you
should put changes to @ARGV in a &quot;BEGIN{}&quot;
block.</p>

<p>Remember that a normal &quot;open&quot; has special
properties, in that it might call fopen(3S) or it might
called popen(3S), depending on what its argument looks like;
thats why its sometimes called &quot;magic open&quot;. Heres
an example:</p>

<p>$pwdinfo = domainname =~ /^(&not;ne)?$/ ? &lt;
/etc/passwd : ypcat passwd ;</p>

<p>open(PWD, $pwdinfo) or die &quot;cant open $pwdinfo:
$!&quot;;</p>

<p>This sort of thing also comes into play in filter
processing. Because &quot;&lt;ARGV&gt;&quot; processing
employs the normal, shell-style Perl &quot;open&quot;, it
respects all the special things weve already seen:</p>

<p>$ myprogram f1 &quot;cmd1&quot; - f2 &quot;cmd2&quot; f3
&lt; tmpfile</p>

<p>That program will read from the file f1, the process
cmd1, standard input (tmpfile in this case), the f2 file,
the cmd2 command, and finally the f3 file.</p>

<p>Yes, this also means that if you have files named
&quot;-&quot; (and so on) in your directory, they wont be
processed as literal files by &quot;open&quot;. Youll need
to pass them as &quot;./-&quot;, much as you would for the
rm pro- gram, or you could use &quot;sysopen&quot; as
described below.</p>

<p>One of the more interesting applications is to change
files of a cer- tain name into pipes. For example, to
autoprocess gzipped or com- pressed files by decompressing
them with gzip:</p>

<p>@ARGV = map { /^.(gz Z)$/ ? &quot;gzip -dc $_ &quot; :
$_ } @ARGV;</p>

<p>Or, if you have the GET program installed from LWP, you
can fetch URLs before processing them:</p>

<p>@ARGV = map { m#^720</p>

<p>It s not for nothing that this is called magic
&quot;&lt;ARGV&gt;&quot;. Pretty nifty, eh?</p>

<p>Open A la C If you want the convenience of the shell,
then Perl s &quot;open&quot; is defi- nitely the way to go.
On the other hand, if you want finer precision than Cs
simplistic fopen(3S) provides you should look to Perls
&quot;sysopen&quot;, which is a direct hook into the open(2)
system call. That does mean its a bit more involved, but
thats the price of precision.</p>

<p>&quot;sysopen&quot; takes 3 (or 4) arguments.</p>

<p>sysopen HANDLE, PATH, FLAGS, [MASK]</p>

<p>The HANDLE argument is a filehandle just as with
&quot;open&quot;. The PATH is a literal path, one that doesn
t pay attention to any greater-thans or less-thans or pipes
or minuses, nor ignore whitespace. If its there, its part of
the path. The FLAGS argument contains one or more values
derived from the Fcntl module that have been ord together
using the bitwise &quot;&quot; operator. The final argument,
the MASK, is optional; if present, it is combined with the
users current umask for the creation mode of the file. You
should usually omit this.</p>

<p>Although the traditional values of read-only,
write-only, and read- write are 0, 1, and 2 respectively,
this is known not to hold true on some systems. Instead, it
s best to load in the appropriate constants first from the
Fcntl module, which supplies the following standard
flags:</p>

<p>O_RDONLY Read only O_WRONLY Write only O_RDWR Read and
write O_CREAT Create the file if it doesnt exist O_EXCL Fail
if the file already exists O_APPEND Append to the file
O_TRUNC Truncate the file O_NONBLOCK Non-blocking access</p>

<p>Less common flags that are sometimes available on some
operating sys- tems include &quot;O_BINARY&quot;,
&quot;O_TEXT&quot;, &quot;O_SHLOCK&quot;,
&quot;O_EXLOCK&quot;, &quot;O_DEFER&quot;,
&quot;O_SYNC&quot;, &quot;O_ASYNC&quot;,
&quot;O_DSYNC&quot;, &quot;O_RSYNC&quot;,
&quot;O_NOCTTY&quot;, &quot;O_NDELAY&quot; and
&quot;O_LARGEFILE&quot;. Consult your open(2) manpage or its
local equivalent for details. (Note: starting from Perl
release 5.6 the &quot;O_LARGEFILE&quot; flag, if available,
is automatically added to the sysopen() flags because large
files are the default.)</p>

<p>Here s how to use &quot;sysopen&quot; to emulate the
simple &quot;open&quot; calls we had before. Well omit the
&quot; die $!&quot; checks for clarity, but make sure you
always check the return values in real code. These arent
quite the same, since &quot;open&quot; will trim leading and
trailing whitespace, but youll get the idea.</p>

<p>To open a file for reading:</p>

<p>open(FH, &quot;&lt; $path&quot;); sysopen(FH, $path,
O_RDONLY);</p>

<p>To open a file for writing, creating a new file if
needed or else trun- cating an old file:</p>

<p>open(FH, &quot;&gt; $path&quot;); sysopen(FH, $path,
O_WRONLY O_TRUNC O_CREAT);</p>

<p>To open a file for appending, creating one if
necessary:</p>

<p>open(FH, &quot;&gt;&gt; $path&quot;); sysopen(FH, $path,
O_WRONLY O_APPEND O_CREAT);</p>

<p>To open a file for update, where the file must already
exist:</p>

<p>open(FH, &quot;+&lt; $path&quot;); sysopen(FH, $path,
O_RDWR);</p>

<p>And here are things you can do with &quot;sysopen&quot;
that you cannot do with a regular &quot;open&quot;. As youll
see, it s just a matter of controlling the flags in the
third argument.</p>

<p>To open a file for writing, creating a new file which
must not previ- ously exist:</p>

<p>sysopen(FH, $path, O_WRONLY O_EXCL O_CREAT);</p>

<p>To open a file for appending, where that file must
already exist:</p>

<p>sysopen(FH, $path, O_WRONLY O_APPEND);</p>

<p>To open a file for update, creating a new file if
necessary:</p>

<p>sysopen(FH, $path, O_RDWR O_CREAT);</p>

<p>To open a file for update, where that file must not
already exist:</p>

<p>sysopen(FH, $path, O_RDWR O_EXCL O_CREAT);</p>

<p>To open a file without blocking, creating one if
necessary:</p>

<p>sysopen(FH, $path, O_WRONLY O_NONBLOCK O_CREAT);</p>

<p>Permissions A la mode</p>

<p>If you omit the MASK argument to &quot;sysopen&quot;,
Perl uses the octal value 0666. The normal MASK to use for
executables and directories should be 0777, and for anything
else, 0666.</p>

<p>Why so permissive? Well, it isnt really. The MASK will
be modified by your process s current &quot;umask&quot;. A
umask is a number representing disabled permissions bits;
that is, bits that will not be turned on in the created
files permissions field.</p>

<p>For example, if your &quot;umask&quot; were 027, then
the 020 part would disable the group from writing, and the
007 part would disable others from reading, writing, or
executing. Under these conditions, passing
&quot;sysopen&quot; 0666 would create a file with mode 0640,
since &quot;0666 &amp; ~027&quot; is 0640.</p>

<p>You should seldom use the MASK argument to
&quot;sysopen()&quot;. That takes away the users freedom to
choose what permission new files will have. Denying choice
is almost always a bad thing. One exception would be for
cases where sensitive or private data is being stored, such
as with mail folders, cookie files, and internal temporary
files.</p>

<p>Obscure Open Tricks Re-Opening Files (dups)</p>

<p>Sometimes you already have a filehandle open, and want
to make another handle thats a duplicate of the first one.
In the shell, we place an ampersand in front of a file
descriptor number when doing redirections. For example,
&quot;2&gt;&amp;1&quot; makes descriptor 2 (thats STDERR in
Perl) be redi- rected into descriptor 1 (which is usually
Perls STDOUT). The same is essentially true in Perl: a
filename that begins with an ampersand is treated instead as
a file descriptor if a number, or as a filehandle if a
string.</p>

<p>open(SAVEOUT, &quot;&gt;&amp;SAVEERR&quot;) die
&quot;couldnt dup SAVEERR: $!&quot;; open(MHCONTEXT,
&quot;&lt;&amp;4&quot;) die &quot;couldnt dup fd4:
$!&quot;;</p>

<p>That means that if a function is expecting a filename,
but you dont want to give it a filename because you already
have the file open, you can just pass the filehandle with a
leading ampersand. It s best to use a fully qualified handle
though, just in case the function happens to be in a
different package:</p>

<p>somefunction(&quot;&amp;main::LOGFILE&quot;);</p>

<p>This way if somefunction() is planning on opening its
argument, it can just use the already opened handle. This
differs from passing a han- dle, because with a handle, you
dont open the file. Here you have something you can pass to
open.</p>

<p>If you have one of those tricky, newfangled I/O objects
that the C++ folks are raving about, then this doesnt work
because those arent a proper filehandle in the native Perl
sense. Youll have to use fileno() to pull out the proper
descriptor number, assuming you can:</p>

<p>use IO::Socket; $handle =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); $fd =
$handle-&gt;fileno; somefunction(&quot;&amp;$fd&quot;); #
not an indirect function call</p>

<p>It can be easier (and certainly will be faster) just to
use real file- handles though:</p>

<p>use IO::Socket; local *REMOTE =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;); die
&quot;cant connect&quot; unless defined(fileno(REMOTE));
somefunction(&quot;&amp;main::REMOTE&quot;);</p>

<p>If the filehandle or descriptor number is preceded not
just with a sim- ple &quot;&amp;&quot; but rather with a
&quot;&amp;=&quot; combination, then Perl will not create a
completely new descriptor opened to the same place using the
dup(2) system call. Instead, it will just make something of
an alias to the existing one using the fdopen(3S) library
call This is slightly more parsimonious of systems
resources, although this is less a concern these days. Heres
an example of that:</p>

<p>$fd = $ENV{&quot;MHCONTEXTFD&quot;}; open(MHCONTEXT,
&quot;&lt;&amp;=$fd&quot;) or die &quot;couldnt fdopen $fd:
$!&quot;;</p>

<p>If youre using magic &quot;&lt;ARGV&gt;&quot;, you could
even pass in as a command line argument in @ARGV something
like &quot;&lt;&amp;=$MHCONTEXTFD&quot;, but weve never seen
anyone actually do this.</p>

<p>Dispelling the Dweomer</p>

<p>Perl is more of a DWIMmer language than something like
Java--where DWIM is an acronym for &quot;do what I
mean&quot;. But this principle sometimes leads to more
hidden magic than one knows what to do with. In this way,
Perl is also filled with dweomer, an obscure word meaning an
enchantment. Sometimes, Perls DWIMmer is just too much like
dweomer for comfort.</p>

<p>If magic &quot;open&quot; is a bit too magical for you,
you dont have to turn to &quot;sysopen&quot;. To open a file
with arbitrary weird characters in it, its necessary to
protect any leading and trailing whitespace. Leading
whitespace is protected by inserting a &quot;./&quot; in
front of a filename that starts with whitespace. Trailing
whitespace is protected by appending an ASCII NUL byte
(&quot; &quot;) at the end of the string.</p>

<p>$file =~ s#^(#./$1#; open(FH, &quot;&lt; $file &quot;)
die &quot;cant open $file: $!&quot;;</p>

<p>This assumes, of course, that your system considers dot
the current working directory, slash the directory
separator, and disallows ASCII NULs within a valid filename.
Most systems follow these conventions, including all POSIX
systems as well as proprietary Microsoft systems. The only
vaguely popular system that doesnt work this way is the
&quot;Classic&quot; Macintosh system, which uses a colon
where the rest of us use a slash. Maybe &quot;sysopen&quot;
isnt such a bad idea after all.</p>

<p>If you want to use &quot;&lt;ARGV&gt;&quot; processing
in a totally boring and non-mag- ical way, you could do this
first:</p>

<p># &quot;Sam sat on the ground and put his head in his
hands. # I wish I had never come here, and I dont want to
see # no more magic, he said, and fell silent.&quot; for
(@ARGV) { s#^([^./])#./$1#; $_ .= &quot; &quot;; } while
(&lt;&gt;) { # now process $_ }</p>

<p>But be warned that users will not appreciate being
unable to use &quot;-&quot; to mean standard input, per the
standard convention.</p>

<p>Paths as Opens</p>

<p>You ve probably noticed how Perl s &quot;warn&quot; and
&quot;die&quot; functions can pro- duce messages like:</p>

<p>Some warning at scriptname line 29, &lt;FH&gt; line
7.</p>

<p>Thats because you opened a filehandle FH, and had read
in seven records from it. But what was the name of the file,
rather than the handle?</p>

<p>If you arent running with &quot;strict refs&quot;, or if
you ve turned them off temporarily, then all you have to do
is this:</p>

<p>open($path, &quot;&lt; $path&quot;) die &quot;cant open
$path: $!&quot;; while (&lt;$path&gt;) { # whatever }</p>

<p>Since youre using the pathname of the file as its
handle, youll get warnings more like</p>

<p>Some warning at scriptname line 29, &lt;/etc/motd&gt;
line 7.</p>

<p>Single Argument Open</p>

<p>Remember how we said that Perls open took two arguments?
That was a passive prevarication. You see, it can also take
just one argument. If and only if the variable is a global
variable, not a lexical, you can pass &quot;open&quot; just
one argument, the filehandle, and it will get the path from
the global scalar variable of the same name.</p>

<p>$FILE = &quot;/etc/motd&quot;; open FILE or die
&quot;cant open $FILE: $!&quot;; while (&lt;FILE&gt;) { #
whatever }</p>

<p>Why is this here? Someone has to cater to the hysterical
porpoises. Its something thats been in Perl since the very
beginning, if not before.</p>

<p>Playing with STDIN and STDOUT</p>

<p>One clever move with STDOUT is to explicitly close it
when youre done with the program.</p>

<p>END { close(STDOUT) die &quot;cant close stdout:
$!&quot; }</p>

<p>If you dont do this, and your program fills up the disk
partition due to a command line redirection, it wont report
the error exit with a failure status.</p>

<p>You dont have to accept the STDIN and STDOUT you were
given. You are welcome to reopen them if youd like.</p>

<p>open(STDIN, &quot;&lt; datafile&quot;) die &quot;cant
open datafile: $!&quot;;</p>

<p>open(STDOUT, &quot;&gt; output&quot;) die &quot;cant
open output: $!&quot;;</p>

<p>And then these can be accessed directly or passed on to
subprocesses. This makes it look as though the program were
initially invoked with those redirections from the command
line.</p>

<p>It s probably more interesting to connect these to
pipes. For example:</p>

<p>$pager = $ENV{PAGER} &quot;(less more)&quot;;
open(STDOUT, &quot; $pager&quot;) die &quot;cant fork a
pager: $!&quot;;</p>

<p>This makes it appear as though your program were called
with its stdout already piped into your pager. You can also
use this kind of thing in conjunction with an implicit fork
to yourself. You might do this if you would rather handle
the post processing in your own program, just in a different
process:</p>

<p>head(100); while (&lt;&gt;) { print; }</p>

<p>sub head { my $lines = shift 20; return if $pid =
open(STDOUT, &quot;-&quot;); # return if parent die
&quot;cannot fork: $!&quot; unless defined $pid; while
(&lt;STDIN&gt;) { last if --$lines &lt; 0; print; } exit;
}</p>

<p>This technique can be applied to repeatedly push as many
filters on your output stream as you wish.</p>

<p>Other I/O Issues These topics arent really arguments
related to &quot;open&quot; or &quot;sysopen&quot;, but they
do affect what you do with your open files.</p>

<p>Opening Non-File Files</p>

<p>When is a file not a file? Well, you could say when it
exists but isnt a plain file. Well check whether it s a
symbolic link first, just in case.</p>

<p>if (-l $file ! -f _) { print &quot;$file is not a plain
file0; }</p>

<p>What other kinds of files are there than, well, files?
Directories, symbolic links, named pipes, Unix-domain
sockets, and block and charac- ter devices. Those are all
files, too--just not plain files. This isnt the same issue
as being a text file. Not all text files are plain files.
Not all plain files are text files. Thats why there are
sepa- rate &quot;-f&quot; and &quot;-T&quot; file tests.</p>

<p>To open a directory, you should use the
&quot;opendir&quot; function, then pro- cess it with
&quot;readdir&quot;, carefully restoring the directory name
if nec- essary:</p>

<p>opendir(DIR, $dirname) or die &quot;cant opendir
$dirname: $!&quot;; while (defined($file = readdir(DIR))) {
# do something with &quot;$dirname/$file&quot; }
closedir(DIR);</p>

<p>If you want to process directories recursively, its
better to use the File::Find module. For example, this
prints out all files recursively and adds a slash to their
names if the file is a directory.</p>

<p>@ARGV = qw(.) unless @ARGV; use File::Find; find sub {
print $File::Find::name, -d &amp;&amp; / , &quot;0 },
@ARGV;</p>

<p>This finds all bogus symbolic links beneath a particular
directory:</p>

<p>find sub { print &quot;$File::Find::name0 if -l
&amp;&amp; !-e }, $dir;</p>

<p>As you see, with symbolic links, you can just pretend
that it is what it points to. Or, if you want to know what
it points to, then &quot;read- link&quot; is called for:</p>

<p>if (-l $file) { if (defined($whither = readlink($file)))
{ print &quot;$file points to $whither0; } else { print
&quot;$file points nowhere: $!0; } }</p>

<p>Opening Named Pipes</p>

<p>Named pipes are a different matter. You pretend theyre
regular files, but their opens will normally block until
there is both a reader and a writer. You can read more about
them in &quot;Named Pipes&quot; in perlipc. Unix-domain
sockets are rather different beasts as well; theyre
described in &quot;Unix-Domain TCP Clients and Servers&quot;
in perlipc.</p>

<p>When it comes to opening devices, it can be easy and it
can be tricky. We ll assume that if youre opening up a block
device, you know what youre doing. The character devices are
more interesting. These are typically used for modems, mice,
and some kinds of printers. This is described in &quot;How
do I read and write the serial port?&quot; in perlfaq8 Its
often enough to open them carefully:</p>

<p>sysopen(TTYIN, &quot;/dev/ttyS1&quot;, O_RDWR O_NDELAY
O_NOCTTY) # (O_NOCTTY no longer needed on POSIX systems) or
die &quot;cant open /dev/ttyS1: $!&quot;; open(TTYOUT,
&quot;+&gt;&amp;TTYIN&quot;) or die &quot;cant dup TTYIN:
$!&quot;;</p>

<p>$ofh = select(TTYOUT); $ = 1; select($ofh);</p>

<p>print TTYOUT &quot;+++at 15&quot;; $answer =
&lt;TTYIN&gt;;</p>

<p>With descriptors that you havent opened using
&quot;sysopen&quot;, such as sock- ets, you can set them to
be non-blocking using &quot;fcntl&quot;:</p>

<p>use Fcntl; my $old_flags = fcntl($handle, F_GETFL, 0) or
die &quot;cant get flags: $!&quot;; fcntl($handle, F_SETFL,
$old_flags O_NONBLOCK) or die &quot;cant set non blocking:
$!&quot;;</p>

<p>Rather than losing yourself in a morass of twisting,
turning &quot;ioctl&quot;s, all dissimilar, if you re going
to manipulate ttys, its best to make calls out to the
stty(1) program if you have it, or else use the portable
POSIX interface. To figure this all out, youll need to read
the termios(3) manpage, which describes the POSIX interface
to tty devices, and then POSIX, which describes Perls
interface to POSIX. There are also some high-level modules
on CPAN that can help you with these games. Check out
Term::ReadKey and Term::ReadLine.</p>

<p>Opening Sockets</p>

<p>What else can you open? To open a connection using
sockets, you wont use one of Perl s two open functions. See
&quot;Sockets: Client/Server Com- munication&quot; in
perlipc for that. Heres an example. Once you have it, you
can use FH as a bidirectional filehandle.</p>

<p>use IO::Socket; local *FH =
IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);</p>

<p>For opening up a URL, the LWP modules from CPAN are just
what the doc- tor ordered. Theres no filehandle interface,
but it s still easy to get the contents of a document:</p>

<p>use LWP::Simple; $doc =
get(http://www.linpro.no/lwp/);</p>

<p>Binary Files</p>

<p>On certain legacy systems with what could charitably be
called termi- nally convoluted (some would say broken) I/O
models, a file isnt a file--at least, not with respect to
the C standard I/O library. On these old systems whose
libraries (but not kernels) distinguish between text and
binary streams, to get files to behave properly youll have
to bend over backwards to avoid nasty problems. On such
infelicitous sys- tems, sockets and pipes are already opened
in binary mode, and there is currently no way to turn that
off. With files, you have more options.</p>

<p>Another option is to use the &quot;binmode&quot;
function on the appropriate han- dles before doing regular
I/O on them:</p>

<p>binmode(STDIN); binmode(STDOUT); while (&lt;STDIN&gt;) {
print }</p>

<p>Passing &quot;sysopen&quot; a non-standard flag option
will also open the file in binary mode on those systems that
support it. This is the equivalent of opening the file
normally, then calling &quot;binmode&quot; on the
handle.</p>

<p>sysopen(BINDAT, &quot;records.data&quot;, O_RDWR
O_BINARY) die &quot;cant open records.data: $!&quot;;</p>

<p>Now you can use &quot;read&quot; and &quot;print&quot;
on that handle without worrying about the non-standard
system I/O library breaking your data. Its not a pretty
picture, but then, legacy systems seldom are. CP/M will be
with us until the end of days, and after.</p>

<p>On systems with exotic I/O systems, it turns out that,
astonishingly enough, even unbuffered I/O using
&quot;sysread&quot; and &quot;syswrite&quot; might do sneaky
data mutilation behind your back.</p>

<p>while (sysread(WHENCE, $buf, 1024)) { syswrite(WHITHER,
$buf, length($buf)); }</p>

<p>Depending on the vicissitudes of your runtime system,
even these calls may need &quot;binmode&quot; or
&quot;O_BINARY&quot; first. Systems known to be free of such
difficulties include Unix, the Mac OS, Plan 9, and
Inferno.</p>

<p>File Locking</p>

<p>In a multitasking environment, you may need to be
careful not to col- lide with other processes who want to do
I/O on the same files as you are working on. You ll often
need shared or exclusive locks on files for reading and
writing respectively. You might just pretend that only
exclusive locks exist.</p>

<p>Never use the existence of a file &quot;-e $file&quot;
as a locking indication, because there is a race condition
between the test for the existence of the file and its
creation. It s possible for another process to create a file
in the slice of time between your existence check and your
attempt to create the file. Atomicity is critical.</p>

<p>Perl s most portable locking interface is via the
&quot;flock&quot; function, whose simplicity is emulated on
systems that dont directly support it such as SysV or
Windows. The underlying semantics may affect how it all
works, so you should learn how &quot;flock&quot; is
implemented on your sys- tems port of Perl.</p>

<p>File locking does not lock out another process that
would like to do I/O. A file lock only locks out others
trying to get a lock, not pro- cesses trying to do I/O.
Because locks are advisory, if one process uses locking and
another doesnt, all bets are off.</p>

<p>By default, the &quot;flock&quot; call will block until
a lock is granted. A request for a shared lock will be
granted as soon as there is no exclu- sive locker. A request
for an exclusive lock will be granted as soon as there is no
locker of any kind. Locks are on file descriptors, not file
names. You cant lock a file until you open it, and you cant
hold on to a lock once the file has been closed.</p>

<p>Here s how to get a blocking shared lock on a file,
typically used for reading:</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); open(FH,
&quot;&lt; filename&quot;) or die &quot;can t open filename:
$!&quot;; flock(FH, LOCK_SH) or die &quot;cant lock
filename: $!&quot;; # now read from FH</p>

<p>You can get a non-blocking lock by using
&quot;LOCK_NB&quot;.</p>

<p>flock(FH, LOCK_SH LOCK_NB) or die &quot;cant lock
filename: $!&quot;;</p>

<p>This can be useful for producing more user-friendly
behaviour by warn- ing if youre going to be blocking:</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); open(FH,
&quot;&lt; filename&quot;) or die &quot;cant open filename:
$!&quot;; unless (flock(FH, LOCK_SH LOCK_NB)) { $ = 1; print
&quot;Waiting for lock...&quot;; flock(FH, LOCK_SH) or die
&quot;can t lock filename: $!&quot;; print &quot;got it.0 }
# now read from FH</p>

<p>To get an exclusive lock, typically used for writing,
you have to be careful. We &quot;sysopen&quot; the file so
it can be locked before it gets emp- tied. You can get a
nonblocking version using &quot;LOCK_EX LOCK_NB&quot;.</p>

<p>use 5.004; use Fcntl qw(:DEFAULT :flock); sysopen(FH,
&quot;filename&quot;, O_WRONLY O_CREAT) or die &quot;cant
open filename: $!&quot;; flock(FH, LOCK_EX) or die
&quot;cant lock filename: $!&quot;; truncate(FH, 0) or die
&quot;cant truncate filename: $!&quot;; # now write to
FH</p>

<p>Finally, due to the uncounted millions who cannot be
dissuaded from wasting cycles on useless vanity devices
called hit counters, heres how to increment a number in a
file safely:</p>

<p>use Fcntl qw(:DEFAULT :flock);</p>

<p>sysopen(FH, &quot;numfile&quot;, O_RDWR O_CREAT) or die
&quot;cant open numfile: $!&quot;; # autoflush FH $ofh =
select(FH); $ = 1; select ($ofh); flock(FH, LOCK_EX) or die
&quot;cant write-lock numfile: $!&quot;;</p>

<p>$num = &lt;FH&gt; 0; seek(FH, 0, 0) or die &quot;cant
rewind numfile : $!&quot;; print FH $num+1, &quot;0 or die
&quot;cant write numfile: $!&quot;;</p>

<p>truncate(FH, tell(FH)) or die &quot;cant truncate
numfile: $!&quot;; close(FH) or die &quot;cant close
numfile: $!&quot;;</p>

<p>IO Layers</p>

<p>In Perl 5.8.0 a new I/O framework called
&quot;PerlIO&quot; was introduced. This is a new
&quot;plumbing&quot; for all the I/O happening in Perl; for
the most part everything will work just as it did, but
PerlIO also brought in some new features such as the ability
to think of I/O as &quot;layers&quot;. One I/O layer may in
addition to just moving the data also do transforma- tions
on the data. Such transformations may include compression
and decompression, encryption and decryption, and
transforming between var- ious character encodings.</p>

<p>Full discussion about the features of PerlIO is out of
scope for this tutorial, but here is how to recognize the
layers being used:</p>

<p>&middot; The three-(or more)-argument form of
&quot;open&quot; is being used and the second argument
contains something else in addition to the usual
&rsquo;&lt;&rsquo;, &rsquo;&gt;&rsquo;,
&rsquo;&gt;&gt;&rsquo;, &rsquo;&rsquo; and their variants,
for example:</p>

<p>open(my $fh, &quot;&lt;:utf8&quot;, $fn);</p>

<p>&middot; The two-argument form of &quot;binmode&quot; is
being used, for example</p>

<p>binmode($fh, &quot;:encoding(utf16)&quot;);</p>

<p>For more detailed discussion about PerlIO see PerlIO;
for more detailed discussion about Unicode and I/O see
perluniintro.</p>

<p>SEE ALSO The &quot;open&quot; and &quot;sysopen&quot;
functions in perlfunc(1); the system open(2), dup(2),
fopen(3), and fdopen(3) manpages; the POSIX
documentation.</p>

<p>AUTHOR and COPYRIGHT Copyright 1998 Tom
Christiansen.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
these files are hereby placed into the public domain. You
are permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>HISTORY First release: Sat Jan 9 08:09:11 MST 1999</p>

<p>perl v5.8.8 2014-02-11 PERLOPENTUT(1)</p>
<hr>
</body>
</html>
