<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:24:26 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>STRTOUL(3) Linux Programmer s Manual STRTOUL(3)</p>

<p>NAME strtoul, strtoull, strtouq - convert a string to an
unsigned long inte- ger</p>

<p>SYNOPSIS #include &lt;stdlib.h&gt;</p>

<p>unsigned long int strtoul(const char *nptr, char
**endptr, int base);</p>

<p>unsigned long long int strtoull(const char *nptr, char
**endptr, int base);</p>

<p>DESCRIPTION The strtoul() function converts the initial
part of the string in nptr to an unsigned long integer value
according to the given base, which must be between 2 and 36
inclusive, or be the special value 0.</p>

<p>The string may begin with an arbitrary amount of white
space (as deter- mined by isspace(3)) followed by a single
optional + or - sign. If base is zero or 16, the string may
then include a 0x prefix, and the number will be read in
base 16; otherwise, a zero base is taken as 10 (decimal)
unless the next character is 0, in which case it is taken as
8 (octal).</p>

<p>The remainder of the string is converted to an unsigned
long int value in the obvious manner, stopping at the first
character which is not a valid digit in the given base. (In
bases above 10, the letter A in either upper or lower case
represents 10, B represents 11, and so forth, with Z
representing 35.)</p>

<p>If endptr is not NULL, strtoul() stores the address of
the first invalid character in *endptr. If there were no
digits at all, str- toul() stores the original value of nptr
in *endptr (and returns 0). In particular, if *nptr is not
but **endptr is on return, the entire string is valid.</p>

<p>The strtoull() function works just like the strtoul()
function but returns an unsigned long long integer
value.</p>

<p>RETURN VALUE The strtoul() function returns either the
result of the conversion or, if there was a leading minus
sign, the negation of the result of the conversion
represented as an unsigned value, unless the original (non-
negated) value would overflow; in the latter case, strtoul()
returns ULONG_MAX and sets the global variable errno to
ERANGE. Precisely the same holds for strtoull() (with
ULLONG_MAX instead of ULONG_MAX).</p>

<p>ERRORS EINVAL (not in C99) The given base contains an
unsupported value.</p>

<p>ERANGE The resulting value was out of range.</p>

<p>The implementation may also set errno to EINVAL in case
no conversion was performed (no digits seen, and 0
returned).</p>

<p>NOTES Since strtoul() can legitimately return 0 or
LONG_MAX (LLONG_MAX for strtoull()) on both success and
failure, the calling program should set errno to 0 before
the call, and then determine if an error occurred by
checking whether errno has a non-zero value after the
call.</p>

<p>In locales other than the &quot;C&quot; locale, other
strings may be accepted. (For example, the thousands
separator of the current locale may be sup- ported.)</p>

<p>BSD also has</p>

<p>u_quad_t strtouq(const char *nptr, char **endptr, int
base);</p>

<p>with completely analogous definition. Depending on the
wordsize of the current architecture, this may be equivalent
to strtoull() or to str- toul().</p>

<p>Negative values are considered valid input and are
silently converted to the equivalent unsigned long
value.</p>

<p>CONFORMING TO strtoul() conforms to SVr4, C99 and
POSIX-2001, and strtoull() to C99 and POSIX.1-2001.</p>

<p>EXAMPLE See the example on the strtol(3) manual page;
the use of the functions described in this manual page is
similar.</p>

<p>SEE ALSO atof(3), atoi(3), atol(3), strtod(3),
strtol(3)</p>

<p>GNU 2002-05-30 STRTOUL(3)</p>
<hr>
</body>
</html>
