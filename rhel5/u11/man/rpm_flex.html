<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:10:23 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>RPM(8) Red Hat Linux RPM(8)</p>

<p>NAME rpm - RPM Package Manager</p>

<p>SYNOPSIS QUERYING AND VERIFYING PACKAGES: rpm
{-q|--query} [select-options] [query-options]</p>

<p>rpm {-V|--verify} [select-options] [verify-options]</p>

<p>rpm --import PUBKEY ...</p>

<p>rpm {-K|--checksig} [--nosignature] [--nodigest]
PACKAGE_FILE ...</p>

<p>INSTALLING, UPGRADING, AND REMOVING PACKAGES: rpm
{-i|--install} [install-options] PACKAGE_FILE ...</p>

<p>rpm {-U|--upgrade} [install-options] PACKAGE_FILE
...</p>

<p>rpm {-F|--freshen} [install-options] PACKAGE_FILE
...</p>

<p>rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts]
[--notriggers] [--repackage] [--test] PACKAGE_NAME ...</p>

<p>MISCELLANEOUS: rpm {--initdb|--rebuilddb}</p>

<p>rpm {--addsign|--resign} PACKAGE_FILE ...</p>

<p>rpm {--querytags|--showrc}</p>

<p>rpm {--setperms|--setugids} PACKAGE_NAME ...</p>

<p>select-options [PACKAGE_NAME] [-a,--all] [-f,--file
FILE] [-g,--group GROUP] {-p,--package PACKAGE_FILE]
[--fileid MD5] [--hdrid SHA1] [--pkgid MD5] [--tid TID]
[--querybynumber HDRNUM] [--triggeredby PACKAGE_NAME]
[--whatprovides CAPABILITY] [--whatrequires CAPABILITY]</p>

<p>query-options [--changelog] [-c,--configfiles]
[-d,--docfiles] [--dump] [--filesbypkg] [-i,--info] [--last]
[-l,--list] [--provides] [--qf,--queryformat QUERYFMT]
[-R,--requires] [--scripts] [-s,--state]
[--triggers,--triggerscripts]</p>

<p>verify-options [--nodeps] [--nofiles] [--noscripts]
[--nodigest] [--nosignature] [--nolinkto] [--nomd5]
[--nosize] [--nouser] [--nogroup] [--nomtime] [--nomode]
[--nordev]</p>

<p>install-options [--aid] [--allfiles] [--badreloc]
[--excludepath OLDPATH] [--excludedocs] [--force]
[-h,--hash] [--ignoresize] [--ignorearch] [--ignoreos]
[--includedocs] [--justdb] [--nodeps] [--nodigest]
[--nosignature] [--nosuggest] [--noorder] [--noscripts]
[--notriggers] [--oldpackage] [--percent] [--prefix NEWPATH]
[--relocate OLDPATH=NEWPATH] [--repackage] [--replacefiles]
[--replacepkgs] [--test]</p>

<p>DESCRIPTION rpm is a powerful Package Manager, which can
be used to build, install, query, verify, update, and erase
individual software packages. A pack- age consists of an
archive of files and meta-data used to install and erase the
archive files. The meta-data includes helper scripts, file
attributes, and descriptive information about the package.
Packages come in two varieties: binary packages, used to
encapsulate software to be installed, and source packages,
containing the source code and recipe necessary to produce
binary packages.</p>

<p>One of the following basic modes must be selected:
Query, Verify, Sig- nature Check, Install/Upgrade/Freshen,
Uninstall, Initialize Database, Rebuild Database, Resign,
Add Signature, Set Owners/Groups, Show Query- tags, and Show
Configuration.</p>

<p>GENERAL OPTIONS These options can be used in all the
different modes.</p>

<p>-?, --help Print a longer usage message then normal.</p>

<p>--version Print a single line containing the version
number of rpm being used.</p>

<p>--quiet Print as little as possible - normally only
error messages will be displayed.</p>

<p>-v Print verbose information - normally routine progress
messages will be displayed.</p>

<p>-vv Print lots of ugly debugging information.</p>

<p>--rcfile FILELIST Each of the files in the colon
separated FILELIST is read sequentially by rpm for
configuration information. Only the first file in the list
must exist, and tildes will be expanded to the value of
$HOME. The default FILELIST is
/usr/lib/rpm/rpmrc:/usr/lib/rpm/red-
hat/rpmrc:/etc/rpmrc:~/.rpmrc.</p>

<p>--pipe CMD Pipes the output of rpm to the command
CMD.</p>

<p>--dbpath DIRECTORY Use the database in DIRECTORY rather
than the default path /var/lib/rpm</p>

<p>--root DIRECTORY Use the file system tree rooted at
DIRECTORY for all operations. Note that this means the
database within DIRECTORY will be used for dependency checks
and any scriptlet(s) (e.g. %post if installing, or %prep if
building, a package) will be run after a chroot(2) to
DIRECTORY.</p>

<p>-D, --defineMACRO EXPR Defines MACRO with value
EXPR.</p>

<p>-E, --evalEXPR Prints macro expansion of EXPR.</p>

<p>INSTALL AND UPGRADE OPTIONS The general form of an rpm
install command is</p>

<p>rpm {-i|--install} [install-options] PACKAGE_FILE
...</p>

<p>This installs a new package.</p>

<p>The general form of an rpm upgrade command is</p>

<p>rpm {-U|--upgrade} [install-options] PACKAGE_FILE
...</p>

<p>This upgrades or installs the package currently
installed to a newer version. This is the same as install,
except all other version(s) of the package are removed after
the new package is installed.</p>

<p>rpm {-F|--freshen} [install-options] PACKAGE_FILE
...</p>

<p>This will upgrade packages, but only if an earlier
version currently exists. The PACKAGE_FILE may be specified
as an ftp or http URL, in which case the package will be
downloaded before being installed. See FTP/HTTP OPTIONS for
information on rpms internal ftp and http client
support.</p>

<p>--aid Add suggested packages to the transaction set when
needed.</p>

<p>--allfiles Installs or upgrades all the missingok files
in the package, regardless if they exist.</p>

<p>--badreloc Used with --relocate, permit relocations on
all file paths, not just those OLDPATHs included in the
binary package relocation hint(s).</p>

<p>--excludepath OLDPATH Dont install files whose name
begins with OLDPATH.</p>

<p>--excludedocs Don t install any files which are marked
as documentation (which includes man pages and texinfo
documents).</p>

<p>--force Same as using --replacepkgs, --replacefiles, and
--oldpackage.</p>

<p>-h, --hash Print 50 hash marks as the package archive is
unpacked. Use with -v|--verbose for a nicer display.</p>

<p>--ignoresize Dont check mount file systems for
sufficient disk space before installing this package.</p>

<p>--ignorearch Allow installation or upgrading even if the
architectures of the binary package and host dont match.</p>

<p>--ignoreos Allow installation or upgrading even if the
operating systems of the binary package and host dont
match.</p>

<p>--includedocs Install documentation files. This is the
default behavior.</p>

<p>--justdb Update only the database, not the
filesystem.</p>

<p>--nodigest Dont verify package or header digests when
reading.</p>

<p>--nosignature Don t verify package or header signatures
when reading.</p>

<p>--nodeps Dont do a dependency check before installing or
upgrading a package.</p>

<p>--nosuggest Don t suggest package(s) that provide a
missing dependency.</p>

<p>--noorder Dont reorder the packages for an install. The
list of packages would normally be reordered to satisfy
dependencies.</p>

<p>--noscripts</p>

<p>--nopre</p>

<p>--nopost</p>

<p>--nopreun</p>

<p>--nopostun Dont execute the scriptlet of the same name.
The --noscripts option is equivalent to</p>

<p>--nopre --nopost --nopreun --nopostun</p>

<p>and turns off the execution of the corresponding %pre,
%post, %preun, and %postun scriptlet(s).</p>

<p>--notriggers</p>

<p>--notriggerin</p>

<p>--notriggerun</p>

<p>--notriggerpostun Dont execute any trigger scriptlet of
the named type. The --notriggers option is equivalent to</p>

<p>--notriggerin --notriggerun --notriggerpostun</p>

<p>and turns off execution of the corresponding %triggerin,
%trig- gerun, and %triggerpostun scriptlet(s).</p>

<p>--oldpackage Allow an upgrade to replace a newer package
with an older one.</p>

<p>--percent Print percentages as files are unpacked from
the package archive. This is intended to make rpm easy to
run from other tools.</p>

<p>--prefix NEWPATH For relocatable binary packages,
translate all file paths that start with the installation
prefix in the package relocation hint(s) to NEWPATH.</p>

<p>--relocate OLDPATH=NEWPATH For relocatable binary
packages, translate all file paths that start with OLDPATH
in the package relocation hint(s) to NEWPATH. This option
can be used repeatedly if several OLDPATHs in the package
are to be relocated.</p>

<p>--repackage Re-package the files before erasing. The
previously installed package will be named according to the
macro %_repack- age_name_fmt and will be created in the
directory named by the macro %_repackage_dir (default value
is /var/spool/repackage).</p>

<p>--replacefiles Install the packages even if they replace
files from other, already installed, packages.</p>

<p>--replacepkgs Install the packages even if some of them
are already installed on this system.</p>

<p>--test Do not install the package, simply check for and
report poten- tial conflicts.</p>

<p>ERASE OPTIONS The general form of an rpm erase command
is</p>

<p>rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts]
[--notriggers] [--repackage] [--test] PACKAGE_NAME ...</p>

<p>The following options may also be used:</p>

<p>--allmatches Remove all versions of the package which
match PACKAGE_NAME. Normally an error is issued if
PACKAGE_NAME matches multiple packages.</p>

<p>--nodeps Dont check dependencies before uninstalling the
packages.</p>

<p>--noscripts</p>

<p>--nopreun</p>

<p>--nopostun Don t execute the scriptlet of the same name.
The --noscripts option during package erase is equivalent
to</p>

<p>--nopreun --nopostun</p>

<p>and turns off the execution of the corresponding %preun,
and %postun scriptlet(s).</p>

<p>--notriggers</p>

<p>--notriggerun</p>

<p>--notriggerpostun Don t execute any trigger scriptlet of
the named type. The --notriggers option is equivalent to</p>

<p>--notriggerun --notriggerpostun</p>

<p>and turns off execution of the corresponding %triggerun,
and %triggerpostun scriptlet(s).</p>

<p>--repackage Re-package the files before erasing. The
previously installed package will be named according to the
macro %_repack- age_name_fmt and will be created in the
directory named by the macro %_repackage_dir (default value
is /var/spool/repackage).</p>

<p>--test Dont really uninstall anything, just go through
the motions. Useful in conjunction with the -vv option for
debugging.</p>

<p>QUERY OPTIONS The general form of an rpm query command
is</p>

<p>rpm {-q|--query} [select-options] [query-options]</p>

<p>You may specify the format that package information
should be printed in. To do this, you use the</p>

<p>--qf|--queryformat QUERYFMT</p>

<p>option, followed by the QUERYFMT format string. Query
formats are mod- ified versions of the standard printf(3)
formatting. The format is made up of static strings (which
may include standard C character escapes for newlines, tabs,
and other special characters) and printf(3) type formatters.
As rpm already knows the type to print, the type specifier
must be omitted however, and replaced by the name of the
header tag to be printed, enclosed by {} characters. Tag
names are case insensitive, and the leading RPMTAG_ portion
of the tag name may be omitted as well.</p>

<p>Alternate output formats may be requested by following
the tag with :typetag. Currently, the following types are
supported:</p>

<p>:armor Wrap a public key in ASCII armor.</p>

<p>:base64 Encode binary data using base64.</p>

<p>:date Use strftime(3) &quot;%c&quot; format.</p>

<p>:day Use strftime(3) &quot;%a %b %d %Y&quot; format.</p>

<p>:depflags Format dependency flags.</p>

<p>:fflags Format file flags.</p>

<p>:hex Format in hexadecimal.</p>

<p>:octal Format in octal.</p>

<p>:perms Format file permissions.</p>

<p>:shescape Escape single quotes for use in a script.</p>

<p>:triggertype Display trigger suffix.</p>

<p>For example, to print only the names of the packages
queried, you could use %{NAME} as the format string. To
print the packages name and dis- tribution information in
two columns, you could use %-30{NAME}%{DISTRI- BUTION}. rpm
will print a list of all of the tags it knows about when it
is invoked with the --querytags argument.</p>

<p>There are two subsets of options for querying: package
selection, and information selection.</p>

<p>PACKAGE SELECTION OPTIONS: PACKAGE_NAME Query installed
package named PACKAGE_NAME.</p>

<p>-a, --all Query all installed packages.</p>

<p>-f, --file FILE Query package owning FILE.</p>

<p>--fileid MD5 Query package that contains a given file
identifier, i.e. the MD5 digest of the file contents.</p>

<p>-g, --group GROUP Query packages with the group of
GROUP.</p>

<p>--hdrid SHA1 Query package that contains a given header
identifier, i.e. the SHA1 digest of the immutable header
region.</p>

<p>-p, --package PACKAGE_FILE Query an (uninstalled)
package PACKAGE_FILE. The PACKAGE_FILE may be specified as
an ftp or http style URL, in which case the package header
will be downloaded and queried. See FTP/HTTP OPTIONS for
information on rpms internal ftp and http client support.
The PACKAGE_FILE argument(s), if not a binary package, will
be interpreted as an ASCII package manifest. Comments are
permitted, starting with a #, and each line of a package
mani- fest file may include white space separated glob
expressions, including URLs with remote glob expressions,
that will be expanded to paths that are substituted in place
of the package manifest as additional PACKAGE_FILE arguments
to the query.</p>

<p>--pkgid MD5 Query package that contains a given package
identifier, i.e. the MD5 digest of the combined header and
payload contents.</p>

<p>--querybynumber HDRNUM Query the HDRNUMth database entry
directly; this is useful only for debugging.</p>

<p>--specfile SPECFILE Parse and query SPECFILE as if it
were a package. Although not all the information (e.g. file
lists) is available, this type of query permits rpm to be
used to extract information from spec files without having
to write a specfile parser.</p>

<p>--tid TID Query package(s) that have a given TID
transaction identifier. A unix time stamp is currently used
as a transaction identifier. All package(s) installed or
erased within a single transaction have a common
identifier.</p>

<p>--triggeredby PACKAGE_NAME Query packages that are
triggered by package(s) PACKAGE_NAME.</p>

<p>--whatprovides CAPABILITY Query all packages that
provide the CAPABILITY capability.</p>

<p>--whatrequires CAPABILITY Query all packages that
requires CAPABILITY for proper function- ing.</p>

<p>PACKAGE QUERY OPTIONS: --changelog Display change
information for the package.</p>

<p>-c, --configfiles List only configuration files (implies
-l).</p>

<p>-d, --docfiles List only documentation files (implies
-l).</p>

<p>--dump Dump file information as follows (implies
-l):</p>

<p>path size mtime md5sum mode owner group isconfig isdoc
rdev symlink</p>

<p>--filesbypkg List all the files in each selected
package.</p>

<p>-i, --info Display package information, including name,
version, and description. This uses the --queryformat if one
was specified.</p>

<p>--last Orders the package listing by install time such
that the latest packages are at the top.</p>

<p>-l, --list List files in package.</p>

<p>--provides List capabilities this package provides.</p>

<p>-R, --requires List packages on which this package
depends.</p>

<p>--scripts List the package specific scriptlet(s) that
are used as part of the installation and uninstallation
processes.</p>

<p>-s, --state Display the states of files in the package
(implies -l). The state of each file is one of normal, not
installed, or replaced.</p>

<p>--triggers, --triggerscripts Display the trigger
scripts, if any, which are contained in the package.</p>

<p>VERIFY OPTIONS The general form of an rpm verify command
is</p>

<p>rpm {-V|--verify} [select-options] [verify-options]</p>

<p>Verifying a package compares information about the
installed files in the package with information about the
files taken from the package metadata stored in the rpm
database. Among other things, verifying compares the size,
MD5 sum, permissions, type, owner and group of each file.
Any discrepancies are displayed. Files that were not
installed from the package, for example, documentation files
excluded on instal- lation using the
&quot;--excludedocs&quot; option, will be silently
ignored.</p>

<p>The package selection options are the same as for
package querying (including package manifest files as
arguments). Other options unique to verify mode are:</p>

<p>--nodeps Dont verify dependencies of packages.</p>

<p>--nodigest Dont verify package or header digests when
reading.</p>

<p>--nofiles Dont verify any attributes of package
files.</p>

<p>--noscripts Don t execute the %verifyscript scriptlet
(if any).</p>

<p>--nosignature Dont verify package or header signatures
when reading.</p>

<p>--nolinkto</p>

<p>--nomd5</p>

<p>--nosize</p>

<p>--nouser</p>

<p>--nogroup</p>

<p>--nomtime</p>

<p>--nomode</p>

<p>--nordev Dont verify the corresponding file
attribute.</p>

<p>The format of the output is a string of 8 characters, a
possible attribute marker:</p>

<p>c %config configuration file. d %doc documentation file.
g %ghost file (i.e. the file contents are not included in
the package payload). l %license license file. r %readme
readme file.</p>

<p>from the package header, followed by the file name. Each
of the 8 characters denotes the result of a comparison of
attribute(s) of the file to the value of those attribute(s)
recorded in the database. A single &quot;.&quot; (period)
means the test passed, while a single &quot;?&quot;
(question mark) indicates the test could not be performed
(e.g. file permissions prevent reading). Otherwise, the
(mnemonically emBoldened) character denotes failure of the
corresponding --verify test:</p>

<p>S file Size differs M Mode differs (includes permissions
and file type) 5 MD5 sum differs D Device major/minor number
mismatch L readLink(2) path mismatch U User ownership
differs G Group ownership differs T mTime differs</p>

<p>DIGITAL SIGNATURE AND DIGEST VERIFICATION The general
forms of rpm digital signature commands are</p>

<p>rpm --import PUBKEY ...</p>

<p>rpm {--checksig} [--nosignature] [--nodigest]
PACKAGE_FILE ...</p>

<p>The --checksig option checks all the digests and
signatures contained in PACKAGE_FILE to ensure the integrity
and origin of the package. Note that signatures are now
verified whenever a package is read, and --checksig is
useful to verify all of the digests and signatures asso-
ciated with a package.</p>

<p>Digital signatures cannot be verified without a public
key. An ASCII armored public key can be added to the rpm
database using --import. An imported public key is carried
in a header, and key ring management is performed exactly
like package management. For example, all currently imported
public keys can be displayed by:</p>

<p>rpm -qa gpg-pubkey*</p>

<p>Details about a specific public key, when imported, can
be displayed by querying. Heres information about the Red
Hat GPG/DSA key:</p>

<p>rpm -qi gpg-pubkey-db42a60e</p>

<p>Finally, public keys can be erased after importing just
like packages. Heres how to remove the Red Hat GPG/DSA
key</p>

<p>rpm -e gpg-pubkey-db42a60e</p>

<p>SIGNING A PACKAGE rpm --addsign|--resign PACKAGE_FILE
...</p>

<p>Both of the --addsign and --resign options generate and
insert new sig- natures for each package PACKAGE_FILE given,
replacing any existing signatures. There are two options for
historical reasons, there is no difference in behavior
currently.</p>

<p>USING GPG TO SIGN PACKAGES In order to sign packages
using GPG, rpm must be configured to run GPG and be able to
find a key ring with the appropriate keys. By default, rpm
uses the same conventions as GPG to find key rings, namely
the $GNUPGHOME environment variable. If your key rings are
not located where GPG expects them to be, you will need to
configure the macro %_gpg_path to be the location of the GPG
key rings to use.</p>

<p>For compatibility with older versions of GPG, PGP, and
rpm, only V3 OpenPGP signature packets should be configured.
Either DSA or RSA ver- ification algorithms can be used, but
DSA is preferred.</p>

<p>If you want to be able to sign packages you create
yourself, you also need to create your own public and secret
key pair (see the GPG man- ual). You will also need to
configure the rpm macros</p>

<p>%_signature The signature type. Right now only gpg and
pgp are supported.</p>

<p>%_gpg_name The name of the &quot;user&quot; whose key
you wish to use to sign your packages.</p>

<p>For example, to be able to use GPG to sign packages as
the user &quot;John Doe &lt;jdoe@foo.com&gt;&quot; from the
key rings located in /etc/rpm/.gpg using the executable
/usr/bin/gpg you would include</p>

<p>%_signature gpg %_gpg_path /etc/rpm/.gpg %_gpg_name John
Doe &lt;jdoe@foo.com&gt; %_gpgbin /usr/bin/gpg</p>

<p>in a macro configuration file. Use /etc/rpm/macros for
per-system con- figuration and ~/.rpmmacros for per-user
configuration.</p>

<p>REBUILD DATABASE OPTIONS The general form of an rpm
rebuild database command is</p>

<p>rpm {--initdb|--rebuilddb} [-v] [--dbpath DIRECTORY]
[--root DIRECTORY]</p>

<p>Use --initdb to create a new database if one doesnt
already exist (existing database is not overwritten), use
--rebuilddb to rebuild the database indices from the
installed package headers.</p>

<p>SHOWRC The command</p>

<p>rpm --showrc</p>

<p>shows the values rpm will use for all of the options are
currently set in rpmrc and macros configuration file(s).</p>

<p>FTP/HTTP OPTIONS rpm can act as an FTP and/or HTTP
client so that packages can be queried or installed from the
internet. Package files for install, upgrade, and query
operations may be specified as an ftp or http style URL:</p>

<p>ftp://USER:PASSWORD@HOST:PORT/path/to/package.rpm</p>

<p>If the :PASSWORD portion is omitted, the password will
be prompted for (once per user/hostname pair). If both the
user and password are omit- ted, anonymous ftp is used. In
all cases, passive (PASV) ftp transfers are performed.</p>

<p>rpm allows the following options to be used with ftp
URLs:</p>

<p>--ftpproxy HOST The host HOST will be used as a proxy
server for all ftp trans- fers, which allows users to ftp
through firewall machines which use proxy systems. This
option may also be specified by config- uring the macro
%_ftpproxy.</p>

<p>--ftpport PORT The TCP PORT number to use for the ftp
connection on the proxy ftp server instead of the default
port. This option may also be specified by configuring the
macro %_ftpport.</p>

<p>rpm allows the following options to be used with http
URLs:</p>

<p>--httpproxy HOST The host HOST will be used as a proxy
server for all http trans- fers. This option may also be
specified by configuring the macro %_httpproxy.</p>

<p>--httpport PORT The TCP PORT number to use for the http
connection on the proxy http server instead of the default
port. This option may also be specified by configuring the
macro %_httpport.</p>

<p>LEGACY ISSUES Executing rpmbuild The build modes of rpm
are now resident in the /usr/bin/rpmbuild exe- cutable.
Although legacy compatibility provided by the popt aliases
below has been adequate, the compatibility is not perfect;
hence build mode compatibility through popt aliases is being
removed from rpm. Install the package containing rpmbuild
(usually rpm-build) and see rpmbuild(8) for documentation of
all the rpm build modes previously documented here in
rpm(8).</p>

<p>Add the following lines to /etc/popt if you wish to
continue invoking rpmbuild from the rpm command line:</p>

<p>rpm exec --bp rpmb -bp rpm exec --bc rpmb -bc rpm exec
--bi rpmb -bi rpm exec --bl rpmb -bl rpm exec --ba rpmb -ba
rpm exec --bb rpmb -bb rpm exec --bs rpmb -bs rpm exec --tp
rpmb -tp rpm exec --tc rpmb -tc rpm exec --ti rpmb -ti rpm
exec --tl rpmb -tl rpm exec --ta rpmb -ta rpm exec --tb rpmb
-tb rpm exec --ts rpmb -ts rpm exec --rebuild rpmb --rebuild
rpm exec --recompile rpmb --recompile rpm exec --clean rpmb
--clean rpm exec --rmsource rpmb --rmsource rpm exec
--rmspec rpmb --rmspec rpm exec --target rpmb --target rpm
exec --short-circuit rpmb --short-circuit</p>

<p>FILES rpmrc Configuration /usr/lib/rpm/rpmrc
/usr/lib/rpm/redhat/rpmrc /etc/rpmrc ~/.rpmrc</p>

<p>Macro Configuration /usr/lib/rpm/macros
/usr/lib/rpm/redhat/macros /etc/rpm/macros ~/.rpmmacros</p>

<p>Database /var/lib/rpm/Basenames
/var/lib/rpm/Conflictname /var/lib/rpm/Dirnames
/var/lib/rpm/Filemd5s /var/lib/rpm/Group
/var/lib/rpm/Installtid /var/lib/rpm/Name
/var/lib/rpm/Packages /var/lib/rpm/Providename
/var/lib/rpm/Provideversion /var/lib/rpm/Pubkeys
/var/lib/rpm/Removed /var/lib/rpm/Requirename
/var/lib/rpm/Requireversion /var/lib/rpm/Sha1header
/var/lib/rpm/Sigmd5 /var/lib/rpm/Triggername</p>

<p>Temporary /var/tmp/rpm*</p>

<p>SEE ALSO popt(3), rpm2cpio(8), rpmbuild(8),</p>

<p>rpm --help - as rpm supports customizing the options via
popt aliases its impossible to guarantee that whats
described in the manual matches whats available.</p>

<p>http://www.rpm.org/ &lt;URL:http://www.rpm.org/&gt;</p>

<p>AUTHORS Marc Ewing &lt;marc@redhat.com&gt; Jeff Johnson
&lt;jbj@redhat.com&gt; Erik Troan &lt;ewt@redhat.com&gt;</p>

<p>Red Hat, Inc. 09 June 2002 RPM(8) FLEX(1) FLEX(1)</p>

<p>NAME flex - fast lexical analyzer generator</p>

<p>SYNOPSIS flex [-bcdfhilnpstvwBFILTV78+? -C[aefFmr]
-ooutput -Pprefix -Sskeleton] [--help --version] [filename
...]</p>

<p>OVERVIEW This manual describes flex, a tool for
generating programs that perform pattern-matching on text.
The manual includes both tutorial and refer- ence
sections:</p>

<p>Description a brief overview of the tool</p>

<p>Some Simple Examples</p>

<p>Format Of The Input File</p>

<p>Patterns the extended regular expressions used by
flex</p>

<p>How The Input Is Matched the rules for determining what
has been matched</p>

<p>Actions how to specify what to do when a pattern is
matched</p>

<p>The Generated Scanner details regarding the scanner that
flex produces; how to control the input source</p>

<p>Start Conditions introducing context into your scanners,
and managing &quot;mini-scanners&quot;</p>

<p>Multiple Input Buffers how to manipulate multiple input
sources; how to scan from strings instead of files</p>

<p>End-of-file Rules special rules for matching the end of
the input</p>

<p>Miscellaneous Macros a summary of macros available to
the actions</p>

<p>Values Available To The User a summary of values
available to the actions</p>

<p>Interfacing With Yacc connecting flex scanners together
with yacc parsers</p>

<p>Options flex command-line options, and the
&quot;%option&quot; directive</p>

<p>Performance Considerations how to make your scanner go
as fast as possible</p>

<p>Generating C++ Scanners the (experimental) facility for
generating C++ scanner classes</p>

<p>Incompatibilities With Lex And POSIX how flex differs
from AT&amp;T lex and the POSIX lex standard</p>

<p>Diagnostics those error messages produced by flex (or
scanners it generates) whose meanings might not be
apparent</p>

<p>Files files used by flex</p>

<p>Deficiencies / Bugs known problems with flex</p>

<p>See Also other documentation, related tools</p>

<p>Author includes contact information</p>

<p>DESCRIPTION flex is a tool for generating scanners:
programs which recognized lexi- cal patterns in text. flex
reads the given input files, or its stan- dard input if no
file names are given, for a description of a scanner to
generate. The description is in the form of pairs of regular
expressions and C code, called rules. flex generates as
output a C source file, lex.yy.c, which defines a routine
yylex(). This file is compiled and linked with the -lfl
library to produce an executable. When the executable is
run, it analyzes its input for occurrences of the regular
expressions. Whenever it finds one, it executes the corre-
sponding C code.</p>

<p>SOME SIMPLE EXAMPLES First some simple examples to get
the flavor of how one uses flex. The following flex input
specifies a scanner which whenever it encounters the string
&quot;username&quot; will replace it with the users login
name:</p>

<p>%% username printf( &quot;%s&quot;, getlogin() );</p>

<p>By default, any text not matched by a flex scanner is
copied to the output, so the net effect of this scanner is
to copy its input file to its output with each occurrence of
&quot;username&quot; expanded. In this input, there is just
one rule. &quot;username&quot; is the pattern and the
&quot;printf&quot; is the action. The &quot;%%&quot; marks
the beginning of the rules.</p>

<p>Heres another simple example:</p>

<p>int num_lines = 0, num_chars = 0;</p>

<p>%% ++num_lines; ++num_chars; . ++num_chars;</p>

<p>%% main() { yylex(); printf( &quot;# of lines = %d, # of
chars = %d0, num_lines, num_chars ); }</p>

<p>This scanner counts the number of characters and the
number of lines in its input (it produces no output other
than the final report on the counts). The first line
declares two globals, &quot;num_lines&quot; and
&quot;num_chars&quot;, which are accessible both inside
yylex() and in the main() routine declared after the second
&quot;%%&quot;. There are two rules, one which matches a
newline (&quot;0) and increments both the line count and the
character count, and one which matches any character other
than a new- line (indicated by the &quot;.&quot; regular
expression).</p>

<p>A somewhat more complicated example:</p>

<p>/* scanner for a toy Pascal-like language */</p>

<p>%{ /* need this for the call to atof() below */ #include
&lt;math.h&gt; %}</p>

<p>DIGIT [0-9] ID [a-z][a-z0-9]*</p>

<p>%%</p>

<p>{DIGIT}+ { printf( &quot;An integer: %s (%d)0, yytext,
atoi( yytext ) ); }</p>

<p>{DIGIT}+&quot;.&quot;{DIGIT}* { printf( &quot;A float:
%s (%g)0, yytext, atof( yytext ) ); }</p>

<p>if|then|begin|end|procedure|function { printf( &quot;A
keyword: %s0, yytext ); }</p>

<p>{ID} printf( &quot;An identifier: %s0, yytext );</p>

<p>&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;
printf( &quot;An operator: %s0, yytext );</p>

<p>&quot;{&quot;[^}0*&quot;}&quot; /* eat up one-line
comments */</p>

<p>[ 0+ /* eat up whitespace */</p>

<p>. printf( &quot;Unrecognized character: %s0, yytext
);</p>

<p>%%</p>

<p>main( argc, argv ) int argc; char **argv; { ++argv,
--argc; /* skip over program name */ if ( argc &gt; 0 ) yyin
= fopen( argv[0], &quot;r&quot; ); else yyin = stdin;</p>

<p>yylex(); }</p>

<p>This is the beginnings of a simple scanner for a
language like Pascal. It identifies different types of
tokens and reports on what it has seen.</p>

<p>The details of this example will be explained in the
following sec- tions.</p>

<p>FORMAT OF THE INPUT FILE The flex input file consists of
three sections, separated by a line with just %% in it:</p>

<p>definitions %% rules %% user code</p>

<p>The definitions section contains declarations of simple
name defini- tions to simplify the scanner specification,
and declarations of start conditions, which are explained in
a later section.</p>

<p>Name definitions have the form:</p>

<p>name definition</p>

<p>The &quot;name&quot; is a word beginning with a letter
or an underscore (_) followed by zero or more letters,
digits, _, or - (dash). The def- inition is taken to begin
at the first non-white-space character fol- lowing the name
and continuing to the end of the line. The definition can
subsequently be referred to using &quot;{name}&quot;, which
will expand to &quot;(definition)&quot;. For example,</p>

<p>DIGIT [0-9] ID [a-z][a-z0-9]*</p>

<p>defines &quot;DIGIT&quot; to be a regular expression
which matches a single digit, and &quot;ID&quot; to be a
regular expression which matches a letter fol- lowed by
zero-or-more letters-or-digits. A subsequent reference
to</p>

<p>{DIGIT}+&quot;.&quot;{DIGIT}*</p>

<p>is identical to</p>

<p>([0-9])+&quot;.&quot;([0-9])*</p>

<p>and matches one-or-more digits followed by a . followed
by zero-or- more digits.</p>

<p>The rules section of the flex input contains a series of
rules of the form:</p>

<p>pattern action</p>

<p>where the pattern must be unindented and the action must
begin on the same line.</p>

<p>See below for a further description of patterns and
actions.</p>

<p>Finally, the user code section is simply copied to
lex.yy.c verbatim. It is used for companion routines which
call or are called by the scan- ner. The presence of this
section is optional; if it is missing, the second %% in the
input file may be skipped, too.</p>

<p>In the definitions and rules sections, any indented text
or text enclosed in %{ and %} is copied verbatim to the
output (with the %{}s removed). The %{} s must appear
unindented on lines by themselves.</p>

<p>In the rules section, any indented or %{} text appearing
before the first rule may be used to declare variables which
are local to the scanning routine and (after the
declarations) code which is to be exe- cuted whenever the
scanning routine is entered. Other indented or %{} text in
the rule section is still copied to the output, but its
meaning is not well-defined and it may well cause
compile-time errors (this feature is present for POSIX
compliance; see below for other such fea- tures).</p>

<p>In the definitions section (but not in the rules
section), an unin- dented comment (i.e., a line beginning
with &quot;/*&quot;) is also copied verba- tim to the output
up to the next &quot;*/&quot;.</p>

<p>PATTERNS The patterns in the input are written using an
extended set of regular expressions. These are:</p>

<p>x match the character x . any character (byte) except
newline [xyz] a &quot;character class&quot;; in this case,
the pattern matches either an x, a y, or a z [abj-oZ] a
&quot;character class&quot; with a range in it; matches an
a, a b, any letter from j through o, or a Z [^A-Z] a
&quot;negated character class&quot;, i.e., any character but
those in the class. In this case, any character EXCEPT an
uppercase letter. [^A-Z0 any character EXCEPT an uppercase
letter or a newline r* zero or more rs, where r is any
regular expression r+ one or more rs r? zero or one rs (that
is, &quot;an optional r&quot;) r{2,5} anywhere from two to
five rs r{2,} two or more rs r{4} exactly 4 rs {name} the
expansion of the &quot;name&quot; definition (see above)
&quot;[xyz] the literal string: [xyz]&quot;foo if X is an a,
b, f, n, r, t, or v, then the ANSI-C interpretation of
Otherwise, a literal X (used to escape operators such as *)
a NUL character (ASCII code 0) 123 the character with octal
value 123 a the character with hexadecimal value 2a (r)
match an r; parentheses are used to override precedence (see
below)</p>

<p>rs the regular expression r followed by the regular
expression s; called &quot;concatenation&quot;</p>

<p>r|s either an r or an s</p>

<p>r/s an r but only if it is followed by an s. The text
matched by s is included when determining whether this rule
is the &quot;longest match&quot;, but is then returned to
the input before the action is executed. So the action only
sees the text matched by r. This type of pattern is called
trailing context&quot;. (There are some combinations of r/s
that flex cannot match correctly; see notes in the
Deficiencies / Bugs section below regarding &quot;dangerous
trailing context&quot;.) ^r an r, but only at the beginning
of a line (i.e., which just starting to scan, or right after
a newline has been scanned). r$ an r, but only at the end of
a line (i.e., just before a newline). Equivalent to
&quot;r/0.</p>

<p>Note that flex s notion of &quot;newline&quot; is
exactly whatever the C compiler used to compile flex as; in
particular, on some DOS interprets 0 systemss in the you
must either filter out for input yourself, or explicitly use
r/ &quot;r$&quot;.</p>

<p>&lt;s&gt;r an r, but only in start condition s (see
below for discussion of start conditions) &lt;s1,s2,s3&gt;r
same, but in any of start conditions s1, s2, or s3
&lt;*&gt;r an r in any start condition, even an exclusive
one.</p>

<p>&lt;&lt;EOF&gt;&gt; an end-of-file
&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt; an end-of-file when in
start condition s1 or s2</p>

<p>Note that inside of a character class, all regular
expression operators lose their special meaning except
escape ( ) and the character class operators, -, ], and, at
the beginning of the class, ^.</p>

<p>The regular expressions listed above are grouped
according to prece- dence, from highest precedence at the
top to lowest at the bottom. Those grouped together have
equal precedence. For example,</p>

<p>foo|bar*</p>

<p>is the same as</p>

<p>(foo)|(ba(r*))</p>

<p>since the * operator has higher precedence than
concatenation, and concatenation higher than alternation
(|). This pattern therefore matches either the string
&quot;foo&quot; or the string &quot;ba&quot; followed by
zero-or- more rs. To match &quot;foo&quot; or zero-or-more
&quot;bar&quot;s, use:</p>

<p>foo|(bar)*</p>

<p>and to match zero-or-more
&quot;foo&quot;s-or-&quot;bar&quot;s:</p>

<p>(foo|bar)*</p>

<p>In addition to characters and ranges of characters,
character classes can also contain character class
expressions. These are expressions enclosed inside [: and :]
delimiters (which themselves must appear between the [ and ]
of the character class; other elements may occur inside the
character class, too). The valid expressions are:</p>

<p>[:alnum:] [:alpha:] [:blank:] [:cntrl:] [:digit:]
[:graph:] [:lower:] [:print:] [:punct:] [:space:] [:upper:]
[:xdigit:]</p>

<p>These expressions all designate a set of characters
equivalent to the corresponding standard C isXXX function.
For example, [:alnum:] desig- nates those characters for
which isalnum() returns true - i.e., any alphabetic or
numeric. Some systems don t provide isblank(), so flex
defines [:blank:] as a blank or a tab.</p>

<p>For example, the following character classes are all
equivalent:</p>

<p>[[:alnum:]] [[:alpha:][:digit:] [[:alpha:]0-9]
[a-zA-Z0-9]</p>

<p>If your scanner is case-insensitive (the -i flag), then
[:upper:] and [:lower:] are equivalent to [:alpha:].</p>

<p>Some notes on patterns:</p>

<p>- A negated character class such as the example
&quot;[^A-Z]&quot; above will match a newline unless &quot;0
(or an equivalent escape sequence) is one of the characters
explicitly present in the negated character class (e.g.,
&quot;[^A-Z0&quot;). This is unlike how many other regular
expression tools treat negated character classes, but
unfortunately the inconsistency is historically entrenched.
Matching newlines means that a pattern like [^&quot;]* can
match the entire input unless theres another quote in the
input.</p>

<p>- A rule can have at most one instance of trailing
context (the / operator or the $ operator). The start
condition, ^, and &quot;&lt;&lt;EOF&gt;&gt;&quot; patterns
can only occur at the beginning of a pat- tern, and, as well
as with / and $, cannot be grouped inside parentheses. A ^
which does not occur at the beginning of a rule or a $ which
does not occur at the end of a rule loses its special
properties and is treated as a normal character.</p>

<p>The following are illegal:</p>

<p>foo/bar$ &lt;sc1&gt;foo&lt;sc2&gt;bar</p>

<p>Note that the first of these, can be written
&quot;foo/bar0.</p>

<p>The following will result in $ or ^ being treated as a
nor- mal character:</p>

<p>foo|(bar$) foo|^bar</p>

<p>If what s wanted is a &quot;foo&quot; or a
bar-followed-by-a-newline, the following could be used (the
special | action is explained below):</p>

<p>foo | bar$ /* action goes here */</p>

<p>A similar trick will work for matching a foo or a
bar-at-the- beginning-of-a-line.</p>

<p>HOW THE INPUT IS MATCHED When the generated scanner is
run, it analyzes its input looking for strings which match
any of its patterns. If it finds more than one match, it
takes the one matching the most text (for trailing context
rules, this includes the length of the trailing part, even
though it will then be returned to the input). If it finds
two or more matches of the same length, the rule listed
first in the flex input file is chosen.</p>

<p>Once the match is determined, the text corresponding to
the match (called the token) is made available in the global
character pointer yytext, and its length in the global
integer yyleng. The action corre- sponding to the matched
pattern is then executed (a more detailed description of
actions follows), and then the remaining input is scanned
for another match.</p>

<p>If no match is found, then the default rule is executed:
the next char- acter in the input is considered matched and
copied to the standard output. Thus, the simplest legal flex
input is:</p>

<p>%%</p>

<p>which generates a scanner that simply copies its input
(one character at a time) to its output.</p>

<p>Note that yytext can be defined in two different ways:
either as a character pointer or as a character array. You
can control which defi- nition flex uses by including one of
the special directives %pointer or %array in the first
(definitions) section of your flex input. The default is
%pointer, unless you use the -l lex compatibility option, in
which case yytext will be an array. The advantage of using
%pointer is substantially faster scanning and no buffer
overflow when matching very large tokens (unless you run out
of dynamic memory). The disadvantage is that you are
restricted in how your actions can modify yytext (see the
next section), and calls to the unput() function destroys
the present contents of yytext, which can be a considerable
porting headache when moving between different lex
versions.</p>

<p>The advantage of %array is that you can then modify
yytext to your hearts content, and calls to unput() do not
destroy yytext (see below). Furthermore, existing lex
programs sometimes access yytext externally using
declarations of the form: extern char yytext[]; This
definition is erroneous when used with %pointer, but correct
for %array.</p>

<p>%array defines yytext to be an array of YYLMAX
characters, which defaults to a fairly large value. You can
change the size by simply #define ing YYLMAX to a different
value in the first section of your flex input. As mentioned
above, with %pointer yytext grows dynamically to accommodate
large tokens. While this means your %pointer scanner can
accommodate very large tokens (such as matching entire
blocks of comments), bear in mind that each time the scanner
must resize yytext it also must rescan the entire token from
the beginning, so matching such tokens can prove slow.
yytext presently does not dynamically grow if a call to
unput() results in too much text being pushed back; instead,
a run-time error results.</p>

<p>Also note that you cannot use %array with C++ scanner
classes (the c++ option; see below).</p>

<p>ACTIONS Each pattern in a rule has a corresponding
action, which can be any arbitrary C statement. The pattern
ends at the first non-escaped whitespace character; the
remainder of the line is its action. If the action is empty,
then when the pattern is matched the input token is simply
discarded. For example, here is the specification for a
program which deletes all occurrences of &quot;zap me&quot;
from its input:</p>

<p>%% &quot;zap me&quot;</p>

<p>(It will copy all other characters in the input to the
output since they will be matched by the default rule.)</p>

<p>Here is a program which compresses multiple blanks and
tabs down to a single blank, and throws away whitespace
found at the end of a line:</p>

<p>%% [ ]+ putchar( ); [ ]+$ /* ignore this token */</p>

<p>If the action contains a {, then the action spans till
the balancing } is found, and the action may cross multiple
lines. flex knows about C strings and comments and wont be
fooled by braces found within them, but also allows actions
to begin with %{ and will consider the action to be all the
text up to the next %} (regardless of ordinary braces inside
the action).</p>

<p>An action consisting solely of a vertical bar (|) means
&quot;same as the action for the next rule.&quot; See below
for an illustration.</p>

<p>Actions can include arbitrary C code, including return
statements to return a value to whatever routine called
yylex(). Each time yylex() is called it continues processing
tokens from where it last left off until it either reaches
the end of the file or executes a return.</p>

<p>Actions are free to modify yytext except for lengthening
it (adding characters to its end--these will overwrite later
characters in the input stream). This however does not apply
when using %array (see above); in that case, yytext may be
freely modified in any way.</p>

<p>Actions are free to modify yyleng except they should not
do so if the action also includes use of yymore() (see
below).</p>

<p>There are a number of special directives which can be
included within an action:</p>

<p>- ECHO copies yytext to the scanners output.</p>

<p>- BEGIN followed by the name of a start condition places
the scan- ner in the corresponding start condition (see
below).</p>

<p>- REJECT directs the scanner to proceed on to the
&quot;second best&quot; rule which matched the input (or a
prefix of the input). The rule is chosen as described above
in &quot;How the Input is Matched&quot;, and yytext and
yyleng set up appropriately. It may either be one which
matched as much text as the originally chosen rule but came
later in the flex input file, or one which matched less
text. For example, the following will both count the words
in the input and call the routine special() whenever
&quot;frob&quot; is seen:</p>

<p>int word_count = 0; %%</p>

<p>frob special(); REJECT; [^ 0+ ++word_count;</p>

<p>Without the REJECT, any &quot;frob&quot;s in the input
would not be counted as words, since the scanner normally
executes only one action per token. Multiple REJECs are
allowed, each one find- ing the next best choice to the
currently active rule. For example, when the following
scanner scans the token &quot;abcd&quot;, it will write
&quot;abcdabcaba&quot; to the output:</p>

<p>%% a | ab | abc | abcd ECHO; REJECT; .| /* eat up any
unmatched character */</p>

<p>(The first three rules share the fourth s action since
they use the special | action.) REJECT is a particularly
expensive feature in terms of scanner performance; if it is
used in any of the scanner s actions it will slow down all
of the scanners matching. Furthermore, REJECT cannot be used
with the -Cf or -CF options (see below).</p>

<p>Note also that unlike the other special actions, REJECT
is a branch; code immediately following it in the action
will not be executed.</p>

<p>- yymore() tells the scanner that the next time it
matches a rule, the corresponding token should be appended
onto the current value of yytext rather than replacing it.
For example, given the input &quot;mega-kludge&quot; the
following will write &quot;mega-mega- kludge&quot; to the
output:</p>

<p>%% mega- ECHO; yymore(); kludge ECHO;</p>

<p>First &quot;mega-&quot; is matched and echoed to the
output. Then &quot;kludge&quot; is matched, but the previous
&quot;mega-&quot; is still hanging around at the beginning
of yytext so the ECHO for the &quot;kludge&quot; rule will
actually write &quot;mega-kludge&quot;.</p>

<p>Two notes regarding use of yymore(). First, yymore()
depends on the value of yyleng correctly reflecting the size
of the current token, so you must not modify yyleng if you
are using yymore(). Second, the presence of yymore() in the
scanners action entails a minor perfor- mance penalty in the
scanners matching speed.</p>

<p>- yyless(n) returns all but the first n characters of
the current token back to the input stream, where they will
be rescanned when the scanner looks for the next match.
yytext and yyleng are adjusted appropriately (e.g., yyleng
will now be equal to n ). For example, on the input
&quot;foobar&quot; the following will write out
&quot;foobarbar&quot;:</p>

<p>%% foobar ECHO; yyless(3); [a-z]+ ECHO;</p>

<p>An argument of 0 to yyless will cause the entire current
input string to be scanned again. Unless you ve changed how
the scan- ner will subsequently process its input (using
BEGIN, for exam- ple), this will result in an endless
loop.</p>

<p>Note that yyless is a macro and can only be used in the
flex input file, not from other source files.</p>

<p>- unput(c) puts the character c back onto the input
stream. It will be the next character scanned. The following
action will take the current token and cause it to be
rescanned enclosed in parentheses.</p>

<p>{ int i; /* Copy yytext because unput() trashes yytext
*/ char *yycopy = strdup( yytext ); unput( ) ); for ( i =
yyleng - 1; i &gt;= 0; --i ) unput( yycopy[i] ); unput( ( );
free( yycopy ); }</p>

<p>Note that since each unput() puts the given character
back at the beginning of the input stream, pushing back
strings must be done back-to-front.</p>

<p>An important potential problem when using unput() is
that if you are using %pointer (the default), a call to
unput() destroys the contents of yytext, starting with its
rightmost character and devouring one character to the left
with each call. If you need the value of yytext preserved
after a call to unput() (as in the above example), you must
either first copy it elsewhere, or build your scanner using
%array instead (see How The Input Is Matched).</p>

<p>Finally, note that you cannot put back EOF to attempt to
mark the input stream with an end-of-file.</p>

<p>- input() reads the next character from the input
stream. For example, the following is one way to eat up C
comments:</p>

<p>%% &quot;/*&quot; { register int c;</p>

<p>for ( ; ; ) { while ( (c = input()) != * &amp;&amp; c !=
EOF ) ; /* eat up text of comment */</p>

<p>if ( c == * ) { while ( (c = input()) == * ) ; if ( c ==
/ ) break; /* found the end */ }</p>

<p>if ( c == EOF ) { error( &quot;EOF in comment&quot; );
break; } } }</p>

<p>(Note that if the scanner is compiled using C++, then
input() is instead referred to as yyinput(), in order to
avoid a name clash with the C++ stream by the name of
input.)</p>

<p>- YY_FLUSH_BUFFER flushes the scanner s internal buffer
so that the next time the scanner attempts to match a token,
it will first refill the buffer using YY_INPUT (see The
Generated Scan- ner, below). This action is a special case
of the more general yy_flush_buffer() function, described
below in the section Mul- tiple Input Buffers.</p>

<p>- yyterminate() can be used in lieu of a return
statement in an action. It terminates the scanner and
returns a 0 to the scan- ners caller, indicating &quot;all
done&quot;. By default, yyterminate() is also called when an
end-of-file is encountered. It is a macro and may be
redefined.</p>

<p>THE GENERATED SCANNER The output of flex is the file
lex.yy.c, which contains the scanning routine yylex(), a
number of tables used by it for matching tokens, and a
number of auxiliary routines and macros. By default, yylex()
is declared as follows:</p>

<p>int yylex() { ... various definitions and the actions in
here ... }</p>

<p>(If your environment supports function prototypes, then
it will be &quot;int yylex( void )&quot;.) This definition
may be changed by defining the &quot;YY_DECL&quot; macro.
For example, you could use:</p>

<p>#define YY_DECL float lexscan( a, b ) float a, b;</p>

<p>to give the scanning routine the name lexscan, returning
a float, and taking two floats as arguments. Note that if
you give arguments to the scanning routine using a
K&amp;R-style/non-prototyped function declaration, you must
terminate the definition with a semi-colon (;).</p>

<p>Whenever yylex() is called, it scans tokens from the
global input file yyin (which defaults to stdin). It
continues until it either reaches an end-of-file (at which
point it returns the value 0) or one of its actions executes
a return statement.</p>

<p>If the scanner reaches an end-of-file, subsequent calls
are undefined unless either yyin is pointed at a new input
file (in which case scan- ning continues from that file), or
yyrestart() is called. yyrestart() takes one argument, a
FILE * pointer (which can be nil, if youve set up YY_INPUT
to scan from a source other than yyin), and initializes yyin
for scanning from that file. Essentially there is no
difference between just assigning yyin to a new input file
or using yyrestart() to do so; the latter is available for
compatibility with previous versions of flex, and because it
can be used to switch input files in the middle of scanning.
It can also be used to throw away the current input buffer,
by calling it with an argument of yyin; but better is to use
YY_FLUSH_BUFFER (see above). Note that yyrestart() does not
reset the start condition to INITIAL (see Start Conditions,
below).</p>

<p>If yylex() stops scanning due to executing a return
statement in one of the actions, the scanner may then be
called again and it will resume scanning where it left
off.</p>

<p>By default (and for purposes of efficiency), the scanner
uses block- reads rather than simple getc() calls to read
characters from yyin. The nature of how it gets its input
can be controlled by defining the YY_INPUT macro. YY_INPUT s
calling sequence is
&quot;YY_INPUT(buf,result,max_size)&quot;. Its action is to
place up to max_size characters in the character array buf
and return in the integer vari- able result either the
number of characters read or the constant YY_NULL (0 on Unix
systems) to indicate EOF. The default YY_INPUT reads from
the global file-pointer &quot;yyin&quot;.</p>

<p>A sample definition of YY_INPUT (in the definitions
section of the input file):</p>

<p>%{ #define YY_INPUT(buf,result,max_size) { int c =
getchar(); result = (c == EOF) ? YY_NULL : (buf[0] = c, 1);
} %}</p>

<p>This definition will change the input processing to
occur one character at a time.</p>

<p>When the scanner receives an end-of-file indication from
YY_INPUT, it then checks the yywrap() function. If yywrap()
returns false (zero), then it is assumed that the function
has gone ahead and set up yyin to point to another input
file, and scanning continues. If it returns true (non-zero),
then the scanner terminates, returning 0 to its caller. Note
that in either case, the start condition remains unchanged;
it does not revert to INITIAL.</p>

<p>If you do not supply your own version of yywrap(), then
you must either use %option noyywrap (in which case the
scanner behaves as though yywrap() returned 1), or you must
link with -lfl to obtain the default version of the routine,
which always returns 1.</p>

<p>Three routines are available for scanning from in-memory
buffers rather than files: yy_scan_string(),
yy_scan_bytes(), and yy_scan_buffer(). See the discussion of
them below in the section Multiple Input Buffers.</p>

<p>The scanner writes its ECHO output to the yyout global
(default, std- out), which may be redefined by the user
simply by assigning it to some other FILE pointer.</p>

<p>START CONDITIONS flex provides a mechanism for
conditionally activating rules. Any rule whose pattern is
prefixed with &quot;&lt;sc&gt;&quot; will only be active
when the scanner is in the start condition named
&quot;sc&quot;. For example,</p>

<p>&lt;STRING&gt;[^&quot;]* { /* eat up the string body ...
*/ ... }</p>

<p>will be active only when the scanner is in the
&quot;STRING&quot; start condi- tion, and</p>

<p>&lt;INITIAL,STRING,QUOTE&gt;. { /* handle an escape ...
*/ ... }</p>

<p>will be active only when the current start condition is
either &quot;INI- TIAL&quot;, &quot;STRING&quot;, or
&quot;QUOTE&quot;.</p>

<p>Start conditions are declared in the definitions (first)
section of the input using unindented lines beginning with
either %s or %x followed by a list of names. The former
declares inclusive start conditions, the latter exclusive
start conditions. A start condition is activated using the
BEGIN action. Until the next BEGIN action is executed, rules
with the given start condition will be active and rules with
other start conditions will be inactive. If the start
condition is inclu- sive, then rules with no start
conditions at all will also be active. If it is exclusive,
then only rules qualified with the start condition will be
active. A set of rules contingent on the same exclusive
start condition describe a scanner which is independent of
any of the other rules in the flex input. Because of this,
exclusive start conditions make it easy to specify
&quot;mini-scanners&quot; which scan portions of the input
that are syntactically different from the rest (e.g.,
comments).</p>

<p>If the distinction between inclusive and exclusive start
conditions is still a little vague, heres a simple example
illustrating the connec- tion between the two. The set of
rules:</p>

<p>%s example %%</p>

<p>&lt;example&gt;foo do_something();</p>

<p>bar something_else();</p>

<p>is equivalent to</p>

<p>%x example %%</p>

<p>&lt;example&gt;foo do_something();</p>

<p>&lt;INITIAL,example&gt;bar something_else();</p>

<p>Without the &lt;INITIAL,example&gt; qualifier, the bar
pattern in the second example wouldn t be active (i.e.,
couldnt match) when in start condi- tion example. If we just
used &lt;example&gt; to qualify bar, though, then it would
only be active in example and not in INITIAL, while in the
first example its active in both, because in the first
example the example startion condition is an inclusive (%s)
start condition.</p>

<p>Also note that the special start-condition specifier
&lt;*&gt; matches every start condition. Thus, the above
example could also have been written;</p>

<p>%x example %%</p>

<p>&lt;example&gt;foo do_something();</p>

<p>&lt;*&gt;bar something_else();</p>

<p>The default rule (to ECHO any unmatched character)
remains active in start conditions. It is equivalent to:</p>

<p>&lt;*&gt;.| ECHO;</p>

<p>BEGIN(0) returns to the original state where only the
rules with no start conditions are active. This state can
also be referred to as the start-condition
&quot;INITIAL&quot;, so BEGIN(INITIAL) is equivalent to
BEGIN(0). (The parentheses around the start condition name
are not required but are considered good style.)</p>

<p>BEGIN actions can also be given as indented code at the
beginning of the rules section. For example, the following
will cause the scanner to enter the &quot;SPECIAL&quot;
start condition whenever yylex() is called and the global
variable enter_special is true:</p>

<p>int enter_special;</p>

<p>%x SPECIAL %% if ( enter_special ) BEGIN(SPECIAL);</p>

<p>&lt;SPECIAL&gt;blahblahblah ...more rules follow...</p>

<p>To illustrate the uses of start conditions, here is a
scanner which provides two different interpretations of a
string like &quot;123.456&quot;. By default it will treat it
as three tokens, the integer &quot;123&quot;, a dot (.), and
the integer &quot;456&quot;. But if the string is preceded
earlier in the line by the string &quot;expect-floats&quot;
it will treat it as a single token, the floating-point
number 123.456:</p>

<p>%{ #include &lt;math.h&gt; %} %s expect</p>

<p>%% expect-floats BEGIN(expect);</p>

<p>&lt;expect&gt;[0-9]+&quot;.&quot;[0-9]+ { printf(
&quot;found a float, = %f0, atof( yytext ) ); }
&lt;expect&gt; { /* thats the end of the line, so * we need
another &quot;expect-number&quot; * before well recognize
any more * numbers */ BEGIN(INITIAL); }</p>

<p>[0-9]+ { printf( &quot;found an integer, = %d0, atoi(
yytext ) ); }</p>

<p>&quot;.&quot; printf( &quot;found a dot0 );</p>

<p>Here is a scanner which recognizes (and discards) C
comments while maintaining a count of the current input
line.</p>

<p>%x comment %% int line_num = 1;</p>

<p>&quot;/*&quot; BEGIN(comment);</p>

<p>&lt;comment&gt;[^*0* /* eat anything thats not a * */
&lt;comment&gt;&quot;*&quot;+[^*/0* /* eat up *s not
followed by /s */ &lt;comment&gt; ++line_num;
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p>This scanner goes to a bit of trouble to match as much
text as possible with each rule. In general, when attempting
to write a high-speed scanner try to match as much possible
in each rule, as it s a big win.</p>

<p>Note that start-conditions names are really integer
values and can be stored as such. Thus, the above could be
extended in the following fashion:</p>

<p>%x comment foo %% int line_num = 1; int
comment_caller;</p>

<p>&quot;/*&quot; { comment_caller = INITIAL;
BEGIN(comment); }</p>

<p>...</p>

<p>&lt;foo&gt;&quot;/*&quot; { comment_caller = foo;
BEGIN(comment); }</p>

<p>&lt;comment&gt;[^*0* /* eat anything thats not a * */
&lt;comment&gt;&quot;*&quot;+[^*/0* /* eat up *s not
followed by / s */ &lt;comment&gt; ++line_num;
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(comment_caller);</p>

<p>Furthermore, you can access the current start condition
using the integer-valued YY_START macro. For example, the
above assignments to comment_caller could instead be
written</p>

<p>comment_caller = YY_START;</p>

<p>Flex provides YYSTATE as an alias for YY_START (since
that is whats used by AT&amp;T lex).</p>

<p>Note that start conditions do not have their own
name-space; %ss and %xs declare names in the same fashion as
#defines.</p>

<p>Finally, here s an example of how to match C-style
quoted strings using exclusive start conditions, including
expanded escape sequences (but not including checking for a
string thats too long):</p>

<p>%x str</p>

<p>%% char string_buf[MAX_STR_CONST]; char
*string_buf_ptr;</p>

<p>&lt;str&gt; BEGIN(INITIAL); *string_buf_ptr = ; /*
return string constant token type and * value to parser */
}</p>

<p>&lt;str&gt; { /* error - unterminated string constant */
/* generate error message */ }</p>

<p>&lt;str&gt;\[0-7]{1,3} { /* octal escape sequence */ int
result;</p>

<p>(void) sscanf( yytext + 1, &quot;%o&quot;, &amp;result
);</p>

<p>if ( result &gt; 0xff ) /* error, constant is
out-of-bounds */</p>

<p>*string_buf_ptr++ = result; }</p>

<p>&lt;str&gt;\[0-9]+ { /* generate error - bad escape
sequence; something * like 48 or 777777 */ }</p>

<p>; &lt;str&gt;\n *string_buf_ptr++ = 0 &lt;str&gt;\t
*string_buf_ptr++ = ; ; &lt;str&gt;\r *string_buf_ptr++ =
&lt;str&gt;\b *string_buf_ptr++ = ; ; &lt;str&gt;\f
*string_buf_ptr++ = &lt;str&gt;\(.|0 *string_buf_ptr++ =
yytext[1];</p>

<p>&lt;str&gt;[^\ char *yptr = yytext;</p>

<p>while ( *yptr ) *string_buf_ptr++ = *yptr++; }</p>

<p>Often, such as in some of the examples above, you wind
up writing a whole bunch of rules all preceded by the same
start condition(s). Flex makes this a little easier and
cleaner by introducing a notion of start condition scope. A
start condition scope is begun with:</p>

<p>&lt;SCs&gt;{</p>

<p>where SCs is a list of one or more start conditions.
Inside the start condition scope, every rule automatically
has the prefix &lt;SCs&gt; applied to it, until a }_which
matches the initial {. So, for example,</p>

<p>&lt;ESC&gt;{ ; ; &quot;\n&quot; return 0 &quot;\r&quot;
return ; &quot;\f&quot; return &quot;\0&quot; return ; }</p>

<p>is equivalent to:</p>

<p>; ; &lt;ESC&gt;&quot;\n&quot; return 0
&lt;ESC&gt;&quot;\r&quot; return ; &lt;ESC&gt;&quot;\f&quot;
return &lt;ESC&gt;&quot;\0&quot; return ;</p>

<p>Start condition scopes may be nested.</p>

<p>Three routines are available for manipulating stacks of
start condi- tions:</p>

<p>void yy_push_state(int new_state) pushes the current
start condition onto the top of the start condition stack
and switches to new_state as though you had used BEGIN
new_state (recall that start condition names are also
integers).</p>

<p>void yy_pop_state() pops the top of the stack and
switches to it via BEGIN.</p>

<p>int yy_top_state() returns the top of the stack without
altering the stacks con- tents.</p>

<p>The start condition stack grows dynamically and so has
no built-in size limitation. If memory is exhausted, program
execution aborts.</p>

<p>To use start condition stacks, your scanner must include
a %option stack directive (see Options below).</p>

<p>MULTIPLE INPUT BUFFERS Some scanners (such as those
which support &quot;include&quot; files) require reading
from several input streams. As flex scanners do a large
amount of buffering, one cannot control where the next input
will be read from by simply writing a YY_INPUT which is
sensitive to the scanning con- text. YY_INPUT is only called
when the scanner reaches the end of its buffer, which may be
a long time after scanning a statement such as an
&quot;include&quot; which requires switching the input
source.</p>

<p>To negotiate these sorts of problems, flex provides a
mechanism for creating and switching between multiple input
buffers. An input buffer is created by using:</p>

<p>YY_BUFFER_STATE yy_create_buffer( FILE *file, int size
)</p>

<p>which takes a FILE pointer and a size and creates a
buffer associated with the given file and large enough to
hold size characters (when in doubt, use YY_BUF_SIZE for the
size). It returns a YY_BUFFER_STATE handle, which may then
be passed to other routines (see below). The YY_BUFFER_STATE
type is a pointer to an opaque struct yy_buffer_state
structure, so you may safely initialize YY_BUFFER_STATE
variables to ((YY_BUFFER_STATE) 0) if you wish, and also
refer to the opaque struc- ture in order to correctly
declare input buffers in source files other than that of
your scanner. Note that the FILE pointer in the call to
yy_create_buffer is only used as the value of yyin seen by
YY_INPUT; if you redefine YY_INPUT so it no longer uses
yyin, then you can safely pass a nil FILE pointer to
yy_create_buffer. You select a particular buffer to scan
from using:</p>

<p>void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer
)</p>

<p>switches the scanner s input buffer so subsequent tokens
will come from new_buffer. Note that yy_switch_to_buffer()
may be used by yywrap() to set things up for continued
scanning, instead of opening a new file and pointing yyin at
it. Note also that switching input sources via either
yy_switch_to_buffer() or yywrap() does not change the start
condition.</p>

<p>void yy_delete_buffer( YY_BUFFER_STATE buffer )</p>

<p>is used to reclaim the storage associated with a buffer.
( buffer can be nil, in which case the routine does
nothing.) You can also clear the current contents of a
buffer using:</p>

<p>void yy_flush_buffer( YY_BUFFER_STATE buffer )</p>

<p>This function discards the buffers contents, so the next
time the scanner attempts to match a token from the buffer,
it will first fill the buffer anew using YY_INPUT.</p>

<p>yy_new_buffer() is an alias for yy_create_buffer(),
provided for com- patibility with the C++ use of new and
delete for creating and destroy- ing dynamic objects.</p>

<p>Finally, the YY_CURRENT_BUFFER macro returns a
YY_BUFFER_STATE handle to the current buffer.</p>

<p>Here is an example of using these features for writing a
scanner which expands include files (the &lt;&lt;EOF&gt;&gt;
feature is discussed below):</p>

<p>/* the &quot;incl&quot; state is used for picking up the
name * of an include file */ %x incl</p>

<p>%{ #define MAX_INCLUDE_DEPTH 10 YY_BUFFER_STATE
include_stack[MAX_INCLUDE_DEPTH]; int include_stack_ptr = 0;
%}</p>

<p>%% include BEGIN(incl);</p>

<p>[a-z]+ ECHO; [^a-z0*0 ECHO;</p>

<p>&lt;incl&gt;[ ]* /* eat the whitespace */ &lt;incl&gt;[^
0+ { /* got the include file name */ if ( include_stack_ptr
&gt;= MAX_INCLUDE_DEPTH ) { fprintf( stderr, &quot;Includes
nested too deeply&quot; ); exit( 1 ); }</p>

<p>include_stack[include_stack_ptr++] =
YY_CURRENT_BUFFER;</p>

<p>yyin = fopen( yytext, &quot;r&quot; );</p>

<p>if ( ! yyin ) error( ... );</p>

<p>yy_switch_to_buffer( yy_create_buffer( yyin, YY_BUF_SIZE
) );</p>

<p>BEGIN(INITIAL); }</p>

<p>&lt;&lt;EOF&gt;&gt; { if ( --include_stack_ptr &lt; 0 )
{ yyterminate(); }</p>

<p>else { yy_delete_buffer( YY_CURRENT_BUFFER );
yy_switch_to_buffer( include_stack[include_stack_ptr] ); }
}</p>

<p>Three routines are available for setting up input
buffers for scanning in-memory strings instead of files. All
of them create a new input buffer for scanning the string,
and return a corresponding YY_BUFFER_STATE handle (which you
should delete with yy_delete_buffer() when done with it).
They also switch to the new buffer using
yy_switch_to_buffer(), so the next call to yylex() will
start scanning the string.</p>

<p>yy_scan_string(const char *str) scans a NUL-terminated
string.</p>

<p>yy_scan_bytes(const char *bytes, int len) scans len
bytes (including possibly NULs) starting at location
bytes.</p>

<p>Note that both of these functions create and scan a copy
of the string or bytes. (This may be desirable, since
yylex() modifies the contents of the buffer it is scanning.)
You can avoid the copy by using:</p>

<p>yy_scan_buffer(char *base, yy_size_t size) which scans
in place the buffer starting at base, consisting of size
bytes, the last two bytes of which must be
YY_END_OF_BUFFER_CHAR (ASCII NUL). These last two bytes are
not scanned; thus, scanning consists of base[0] through
base[size-2], inclusive.</p>

<p>If you fail to set up base in this manner (i.e., forget
the final two YY_END_OF_BUFFER_CHAR bytes), then
yy_scan_buffer() returns a nil pointer instead of creating a
new input buffer.</p>

<p>The type yy_size_t is an integral type to which you can
cast an integer expression reflecting the size of the
buffer.</p>

<p>END-OF-FILE RULES The special rule
&quot;&lt;&lt;EOF&gt;&gt;&quot; indicates actions which are
to be taken when an end-of-file is encountered and yywrap()
returns non-zero (i.e., indicates no further files to
process). The action must finish by doing one of four
things:</p>

<p>- assigning yyin to a new input file (in previous
versions of flex, after doing the assignment you had to call
the special action YY_NEW_FILE; this is no longer
necessary);</p>

<p>- executing a return statement;</p>

<p>- executing the special yyterminate() action;</p>

<p>- or, switching to a new buffer using
yy_switch_to_buffer() as shown in the example above.</p>

<p>&lt;&lt;EOF&gt;&gt; rules may not be used with other
patterns; they may only be qualified with a list of start
conditions. If an unqualified &lt;&lt;EOF&gt;&gt; rule is
given, it applies to all start conditions which do not
already have &lt;&lt;EOF&gt;&gt; actions. To specify an
&lt;&lt;EOF&gt;&gt; rule for only the initial start
condition, use</p>

<p>&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;</p>

<p>These rules are useful for catching things like unclosed
comments. An example:</p>

<p>%x quote %%</p>

<p>...other rules for dealing with quotes...</p>

<p>&lt;quote&gt;&lt;&lt;EOF&gt;&gt; { error(
&quot;unterminated quote&quot; ); yyterminate(); }
&lt;&lt;EOF&gt;&gt; { if ( *++filelist ) yyin = fopen(
*filelist, &quot;r&quot; ); else yyterminate(); }</p>

<p>MISCELLANEOUS MACROS The macro YY_USER_ACTION can be
defined to provide an action which is always executed prior
to the matched rules action. For example, it could be
#defined to call a routine to convert yytext to lower-case.
When YY_USER_ACTION is invoked, the variable yy_act gives
the number of the matched rule (rules are numbered starting
with 1). Suppose you want to profile how often each of your
rules is matched. The following would do the trick:</p>

<p>#define YY_USER_ACTION ++ctr[yy_act]</p>

<p>where ctr is an array to hold the counts for the
different rules. Note that the macro YY_NUM_RULES gives the
total number of rules (including the default rule, even if
you use -s), so a correct declaration for ctr is:</p>

<p>int ctr[YY_NUM_RULES];</p>

<p>The macro YY_USER_INIT may be defined to provide an
action which is always executed before the first scan (and
before the scanners inter- nal initializations are done).
For example, it could be used to call a routine to read in a
data table or open a logging file.</p>

<p>The macro yy_set_interactive(is_interactive) can be used
to control whether the current buffer is considered
interactive. An interactive buffer is processed more slowly,
but must be used when the scanners input source is indeed
interactive to avoid problems due to waiting to fill buffers
(see the discussion of the -I flag below). A non-zero value
in the macro invocation marks the buffer as interactive, a
zero value as non-interactive. Note that use of this macro
overrides %option always-interactive or %option
never-interactive (see Options below). yy_set_interactive()
must be invoked prior to beginning to scan the buffer that
is (or is not) to be considered interactive.</p>

<p>The macro yy_set_bol(at_bol) can be used to control
whether the current buffer s scanning context for the next
token match is done as though at the beginning of a line. A
non-zero macro argument makes rules anchored with</p>

<p>The macro YY_AT_BOL() returns true if the next token
scanned from the current buffer will have ^ rules active,
false otherwise.</p>

<p>In the generated scanner, the actions are all gathered
in one large switch statement and separated using YY_BREAK,
which may be redefined. By default, it is simply a
&quot;break&quot;, to separate each rules action from the
following rules. Redefining YY_BREAK allows, for example,
C++ users to #define YY_BREAK to do nothing (while being
very careful that every rule ends with a &quot;break&quot;
or a &quot;return&quot;!) to avoid suffering from
unreachable statement warnings where because a rules action
ends with &quot;return&quot;, the YY_BREAK is
inaccessible.</p>

<p>VALUES AVAILABLE TO THE USER This section summarizes the
various values available to the user in the rule
actions.</p>

<p>- char *yytext holds the text of the current token. It
may be modified but not lengthened (you cannot append
characters to the end).</p>

<p>If the special directive %array appears in the first
section of the scanner description, then yytext is instead
declared char yytext[YYLMAX], where YYLMAX is a macro
definition that you can redefine in the first section if you
don t like the default value (generally 8KB). Using %array
results in somewhat slower scanners, but the value of yytext
becomes immune to calls to input() and unput(), which
potentially destroy its value when yytext is a character
pointer. The opposite of %array is %pointer, which is the
default.</p>

<p>You cannot use %array when generating C++ scanner
classes (the -+ flag).</p>

<p>- int yyleng holds the length of the current token.</p>

<p>- FILE *yyin is the file which by default flex reads
from. It may be redefined but doing so only makes sense
before scanning begins or after an EOF has been encountered.
Changing it in the midst of scanning will have unexpected
results since flex buffers its input; use yyrestart()
instead. Once scanning ter- minates because an end-of-file
has been seen, you can assign yyin at the new input file and
then call the scanner again to continue scanning.</p>

<p>- void yyrestart( FILE *new_file ) may be called to
point yyin at the new input file. The switch-over to the new
file is immediate (any previously buffered-up input is
lost). Note that calling yyrestart() with yyin as an
argument thus throws away the current input buffer and
continues scanning the same input file.</p>

<p>- FILE *yyout is the file to which ECHO actions are
done. It can be reassigned by the user.</p>

<p>- YY_CURRENT_BUFFER returns a YY_BUFFER_STATE handle to
the cur- rent buffer.</p>

<p>- YY_START returns an integer value corresponding to the
current start condition. You can subsequently use this value
with BEGIN to return to that start condition.</p>

<p>INTERFACING WITH YACC One of the main uses of flex is as
a companion to the yacc parser-gen- erator. yacc parsers
expect to call a routine named yylex() to find the next
input token. The routine is supposed to return the type of
the next token as well as putting any associated value in
the global yylval. To use flex with yacc, one specifies the
-d option to yacc to instruct it to generate the file
y.tab.h containing definitions of all the %tokens appearing
in the yacc input. This file is then included in the flex
scanner. For example, if one of the tokens is
&quot;TOK_NUMBER&quot;, part of the scanner might look
like:</p>

<p>%{ #include &quot;y.tab.h&quot; %}</p>

<p>%%</p>

<p>[0-9]+ yylval = atoi( yytext ); return TOK_NUMBER;</p>

<p>OPTIONS flex has the following options:</p>

<p>-b Generate backing-up information to lex.backup. This
is a list of scanner states which require backing up and the
input charac- ters on which they do so. By adding rules one
can remove back- ing-up states. If all backing-up states are
eliminated and -Cf or -CF is used, the generated scanner
will run faster (see the -p flag). Only users who wish to
squeeze every last cycle out of their scanners need worry
about this option. (See the sec- tion on Performance
Considerations below.)</p>

<p>-c is a do-nothing, deprecated option included for POSIX
compli- ance.</p>

<p>-d makes the generated scanner run in debug mode.
Whenever a pat- tern is recognized and the global
yy_flex_debug is non-zero (which is the default), the
scanner will write to stderr a line of the form:</p>

<p>--accepting rule at line 53 (&quot;the matched
text&quot;)</p>

<p>The line number refers to the location of the rule in
the file defining the scanner (i.e., the file that was fed
to flex). Messages are also generated when the scanner backs
up, accepts the default rule, reaches the end of its input
buffer (or encounters a NUL; at this point, the two look the
same as far as the scanners concerned), or reaches an
end-of-file.</p>

<p>-f specifies fast scanner. No table compression is done
and stdio is bypassed. The result is large but fast. This
option is equivalent to -Cfr (see below).</p>

<p>-h generates a &quot;help&quot; summary of flexs options
to stdout and then exits. -? and --help are synonyms for
-h.</p>

<p>-i instructs flex to generate a case-insensitive
scanner. The case of letters given in the flex input
patterns will be ignored, and tokens in the input will be
matched regardless of case. The matched text given in yytext
will have the preserved case (i.e., it will not be
folded).</p>

<p>-l turns on maximum compatibility with the original
AT&amp;T lex imple- mentation. Note that this does not mean
full compatibility. Use of this option costs a considerable
amount of performance, and it cannot be used with the -+,
-f, -F, -Cf, or -CF options. For details on the
compatibilities it provides, see the section
&quot;Incompatibilities With Lex And POSIX&quot; below. This
option also results in the name YY_FLEX_LEX_COMPAT being
#defined in the generated scanner.</p>

<p>-n is another do-nothing, deprecated option included
only for POSIX compliance.</p>

<p>-p generates a performance report to stderr. The report
consists of comments regarding features of the flex input
file which will cause a serious loss of performance in the
resulting scanner. If you give the flag twice, you will also
get comments regarding features that lead to minor
performance losses.</p>

<p>Note that the use of REJECT, %option yylineno, and
variable trailing context (see the Deficiencies / Bugs
section below) entails a substantial performance penalty;
use of yymore(), the ^ operator, and the -I flag entail
minor performance penalties.</p>

<p>-s causes the default rule (that unmatched scanner input
is echoed to stdout) to be suppressed. If the scanner
encounters input that does not match any of its rules, it
aborts with an error. This option is useful for finding
holes in a scanners rule set.</p>

<p>-t instructs flex to write the scanner it generates to
standard output instead of lex.yy.c.</p>

<p>-v specifies that flex should write to stderr a summary
of statis- tics regarding the scanner it generates. Most of
the statistics are meaningless to the casual flex user, but
the first line identifies the version of flex (same as
reported by -V), and the next line the flags used when
generating the scanner, including those that are on by
default.</p>

<p>-w suppresses warning messages.</p>

<p>-B instructs flex to generate a batch scanner, the
opposite of interactive scanners generated by -I (see
below). In general, you use -B when you are certain that
your scanner will never be used interactively, and you want
to squeeze a little more per- formance out of it. If your
goal is instead to squeeze out a lot more performance, you
should be using the -Cf or -CF options (discussed below),
which turn on -B automatically any- way.</p>

<p>-F specifies that the fast scanner table representation
should be used (and stdio bypassed). This representation is
about as fast as the full table representation (-f), and for
some sets of pat- terns will be considerably smaller (and
for others, larger). In general, if the pattern set contains
both &quot;keywords&quot; and a catch-all,
&quot;identifier&quot; rule, such as in the set:</p>

<p>&quot;case&quot; return TOK_CASE; &quot;switch&quot;
return TOK_SWITCH; ... &quot;default&quot; return
TOK_DEFAULT; [a-z]+ return TOK_ID;</p>

<p>then you re better off using the full table
representation. If only the &quot;identifier&quot; rule is
present and you then use a hash table or some such to detect
the keywords, you re better off using -F.</p>

<p>This option is equivalent to -CFr (see below). It cannot
be used with -+.</p>

<p>-I instructs flex to generate an interactive scanner. An
interac- tive scanner is one that only looks ahead to decide
what token has been matched if it absolutely must. It turns
out that always looking one extra character ahead, even if
the scanner has already seen enough text to disambiguate the
current token, is a bit faster than only looking ahead when
necessary. But scanners that always look ahead give dreadful
interactive per- formance; for example, when a user types a
newline, it is not recognized as a newline token until they
enter another token, which often means typing in another
whole line.</p>

<p>Flex scanners default to interactive unless you use the
-Cf or -CF table-compression options (see below). That s
because if you re looking for high-performance you should be
using one of these options, so if you didnt, flex assumes
you d rather trade off a bit of run-time performance for
intuitive interactive behavior. Note also that you cannot
use -I in conjunction with -Cf or -CF. Thus, this option is
not really needed; it is on by default for all those cases
in which it is allowed.</p>

<p>You can force a scanner to not be interactive by using
-B (see above).</p>

<p>-L instructs flex not to generate #line directives.
Without this option, flex peppers the generated scanner with
#line directives so error messages in the actions will be
correctly located with respect to either the original flex
input file (if the errors are due to code in the input
file), or lex.yy.c (if the errors are flexs fault -- you
should report these sorts of errors to the email address
given below).</p>

<p>-T makes flex run in trace mode. It will generate a lot
of mes- sages to stderr concerning the form of the input and
the resul- tant non-deterministic and deterministic finite
automata. This option is mostly for use in maintaining
flex.</p>

<p>-V prints the version number to stdout and exits.
--version is a synonym for -V.</p>

<p>-7 instructs flex to generate a 7-bit scanner, i.e., one
which can only recognized 7-bit characters in its input. The
advantage of using -7 is that the scanners tables can be up
to half the size of those generated using the -8 option (see
below). The disad- vantage is that such scanners often hang
or crash if their input contains an 8-bit character.</p>

<p>Note, however, that unless you generate your scanner
using the -Cf or -CF table compression options, use of -7
will save only a small amount of table space, and make your
scanner considerably less portable. Flex_s default behavior
is to generate an 8-bit scanner unless you use the -Cf or
-CF, in which case flex defaults to generating 7-bit
scanners unless your site was always configured to generate
8-bit scanners (as will often be the case with non-USA
sites). You can tell whether flex generated a 7-bit or an
8-bit scanner by inspecting the flag summary in the -v
output as described above.</p>

<p>Note that if you use -Cfe or -CFe (those table
compression options, but also using equivalence classes as
discussed see below), flex still defaults to generating an
8-bit scanner, since usually with these compression options
full 8-bit tables are not much more expensive than 7-bit
tables.</p>

<p>-8 instructs flex to generate an 8-bit scanner, i.e.,
one which can recognize 8-bit characters. This flag is only
needed for scan- ners generated using -Cf or -CF, as
otherwise flex defaults to generating an 8-bit scanner
anyway.</p>

<p>See the discussion of -7 above for flexs default
behavior and the tradeoffs between 7-bit and 8-bit
scanners.</p>

<p>-+ specifies that you want flex to generate a C++
scanner class. See the section on Generating C++ Scanners
below for details.</p>

<p>-C[aefFmr] controls the degree of table compression and,
more generally, trade-offs between small scanners and fast
scanners.</p>

<p>-Ca (&quot;align&quot;) instructs flex to trade off
larger tables in the generated scanner for faster
performance because the elements of the tables are better
aligned for memory access and computation. On some RISC
architectures, fetching and manipulating longwords is more
efficient than with smaller-sized units such as short-
words. This option can double the size of the tables used by
your scanner.</p>

<p>-Ce directs flex to construct equivalence classes, i.e.,
sets of characters which have identical lexical properties
(for example, if the only appearance of digits in the flex
input is in the character class &quot;[0-9]&quot; then the
digits 0, 1, ..., 9 will all be put in the same equivalence
class). Equivalence classes usually give dramatic reductions
in the final table/object file sizes (typically a factor of
2-5) and are pretty cheap perfor- mance-wise (one array
look-up per character scanned).</p>

<p>-Cf specifies that the full scanner tables should be
generated - flex should not compress the tables by taking
advantages of sim- ilar transition functions for different
states.</p>

<p>-CF specifies that the alternate fast scanner
representation (described above under the -F flag) should be
used. This option cannot be used with -+.</p>

<p>-Cm directs flex to construct meta-equivalence classes,
which are sets of equivalence classes (or characters, if
equivalence classes are not being used) that are commonly
used together. Meta-equivalence classes are often a big win
when using com- pressed tables, but they have a moderate
performance impact (one or two &quot;if&quot; tests and one
array look-up per character scanned).</p>

<p>-Cr causes the generated scanner to bypass use of the
standard I/O library (stdio) for input. Instead of calling
fread() or getc(), the scanner will use the read() system
call, resulting in a performance gain which varies from
system to system, but in general is probably negligible
unless you are also using -Cf or -CF. Using -Cr can cause
strange behavior if, for example, you read from yyin using
stdio prior to calling the scanner (because the scanner will
miss whatever text your previous reads left in the stdio
input buffer).</p>

<p>-Cr has no effect if you define YY_INPUT (see The
Generated Scanner above).</p>

<p>A lone -C specifies that the scanner tables should be
compressed but neither equivalence classes nor
meta-equivalence classes should be used.</p>

<p>The options -Cf or -CF and -Cm do not make sense
together - there is no opportunity for meta-equivalence
classes if the ta- ble is not being compressed. Otherwise
the options may be freely mixed, and are cumulative.</p>

<p>The default setting is -Cem, which specifies that flex
should generate equivalence classes and meta-equivalence
classes. This setting provides the highest degree of table
compression. You can trade off faster-executing scanners at
the cost of larger tables with the following generally being
true:</p>

<p>slowest &amp; smallest -Cem -Cm -Ce -C -C{f,F}e -C{f,F}
-C{f,F}a fastest &amp; largest</p>

<p>Note that scanners with the smallest tables are usually
gener- ated and compiled the quickest, so during development
you will usually want to use the default, maximal
compression.</p>

<p>-Cfe is often a good compromise between speed and size
for pro- duction scanners.</p>

<p>-ooutput directs flex to write the scanner to the file
output instead of lex.yy.c. If you combine -o with the -t
option, then the scan- ner is written to stdout but its
#line directives (see the -L option above) refer to the file
output.</p>

<p>-Pprefix changes the default yy prefix used by flex for
all globally-vis- ible variable and function names to
instead be prefix. For example, -Pfoo changes the name of
yytext to footext. It also changes the name of the default
output file from lex.yy.c to lex.foo.c. Here are all of the
names affected:</p>

<p>yy_create_buffer yy_delete_buffer yy_flex_debug
yy_init_buffer yy_flush_buffer yy_load_buffer_state
yy_switch_to_buffer yyin yyleng yylex yylineno yyout
yyrestart yytext yywrap</p>

<p>(If you are using a C++ scanner, then only yywrap and
yyFlexLexer are affected.) Within your scanner itself, you
can still refer to the global variables and functions using
either version of their name; but externally, they have the
modified name.</p>

<p>This option lets you easily link together multiple flex
programs into the same executable. Note, though, that using
this option also renames yywrap(), so you now must either
provide your own (appropriately-named) version of the
routine for your scanner, or use %option noyywrap, as
linking with -lfl no longer provides one for you by
default.</p>

<p>-Sskeleton_file overrides the default skeleton file from
which flex constructs its scanners. You ll never need this
option unless you are doing flex maintenance or
development.</p>

<p>flex also provides a mechanism for controlling options
within the scan- ner specification itself, rather than from
the flex command-line. This is done by including %option
directives in the first section of the scanner
specification. You can specify multiple options with a
single %option directive, and multiple directives in the
first section of your flex input file.</p>

<p>Most options are given simply as names, optionally
preceded by the word &quot;no&quot; (with no intervening
whitespace) to negate their meaning. A num- ber are
equivalent to flex flags or their negation:</p>

<p>7bit -7 option 8bit -8 option align -Ca option backup -b
option batch -B option c++ -+ option</p>

<p>caseful or case-sensitive opposite of -i (default)</p>

<p>case-insensitive or caseless -i option</p>

<p>debug -d option default opposite of -s option ecs -Ce
option fast -F option full -f option interactive -I option
lex-compat -l option meta-ecs -Cm option perf-report -p
option read -Cr option stdout -t option verbose -v option
warn opposite of -w option (use &quot;%option nowarn&quot;
for -w)</p>

<p>array equivalent to &quot;%array&quot; pointer
equivalent to &quot;%pointer&quot; (default)</p>

<p>Some %optios provide features otherwise not
available:</p>

<p>always-interactive instructs flex to generate a scanner
which always considers its input &quot;interactive&quot;.
Normally, on each new input file the scan- ner calls
isatty() in an attempt to determine whether the scan- ners
input source is interactive and thus should be read a
character at a time. When this option is used, however, then
no such call is made.</p>

<p>main directs flex to provide a default main() program
for the scan- ner, which simply calls yylex(). This option
implies noyywrap (see below).</p>

<p>never-interactive instructs flex to generate a scanner
which never considers its input &quot;interactive&quot;
(again, no call made to isatty()). This is the opposite of
always-interactive.</p>

<p>stack enables the use of start condition stacks (see
Start Conditions above).</p>

<p>stdinit if set (i.e., %option stdinit) initializes yyin
and yyout to stdin and stdout, instead of the default of
nil. Some existing lex programs depend on this behavior,
even though it is not com- pliant with ANSI C, which does
not require stdin and stdout to be compile-time
constant.</p>

<p>yylineno directs flex to generate a scanner that
maintains the number of the current line read from its input
in the global variable yylineno. This option is implied by
%option lex-compat.</p>

<p>yywrap if unset (i.e., %option noyywrap), makes the
scanner not call yywrap() upon an end-of-file, but simply
assume that there are no more files to scan (until the user
points yyin at a new file and calls yylex() again).</p>

<p>flex scans your rule actions to determine whether you
use the REJECT or yymore() features. The reject and yymore
options are available to override its decision as to whether
you use the options, either by set- ting them (e.g., %option
reject) to indicate the feature is indeed used, or unsetting
them to indicate it actually is not used (e.g., %option
noyymore).</p>

<p>Three options take string-delimited values, offset with
=:</p>

<p>%option outfile=&quot;ABC&quot;</p>

<p>is equivalent to -oABC, and</p>

<p>%option prefix=&quot;XYZ&quot;</p>

<p>is equivalent to -PXYZ. Finally,</p>

<p>%option yyclass=&quot;foo&quot;</p>

<p>only applies when generating a C++ scanner ( -+ option).
It informs flex that you have derived foo as a subclass of
yyFlexLexer, so flex will place your actions in the member
function foo::yylex() instead of yyFlexLexer::yylex(). It
also generates a yyFlexLexer::yylex() member function that
emits a run-time error (by invoking yyFlexLexer::Lexer-
Error()) if called. See Generating C++ Scanners, below, for
additional information.</p>

<p>A number of options are available for lint purists who
want to suppress the appearance of unneeded routines in the
generated scanner. Each of the following, if unset (e.g.,
%option nounput ), results in the corre- sponding routine
not appearing in the generated scanner:</p>

<p>input, unput yy_push_state, yy_pop_state, yy_top_state
yy_scan_buffer, yy_scan_bytes, yy_scan_string</p>

<p>(though yy_push_state() and friends won t appear anyway
unless you use %option stack).</p>

<p>PERFORMANCE CONSIDERATIONS The main design goal of flex
is that it generate high-performance scan- ners. It has been
optimized for dealing well with large sets of rules. Aside
from the effects on scanner speed of the table compression
-C options outlined above, there are a number of
options/actions which degrade performance. These are, from
most expensive to least:</p>

<p>REJECT %option yylineno arbitrary trailing context</p>

<p>pattern sets that require backing up %array %option
interactive %option always-interactive</p>

<p>^ beginning-of-line operator yymore()</p>

<p>with the first three all being quite expensive and the
last two being quite cheap. Note also that unput() is
implemented as a routine call that potentially does quite a
bit of work, while yyless() is a quite- cheap macro; so if
just putting back some excess text you scanned, use
yyless().</p>

<p>REJECT should be avoided at all costs when performance
is important. It is a particularly expensive option.</p>

<p>Getting rid of backing up is messy and often may be an
enormous amount of work for a complicated scanner. In
principal, one begins by using the -b flag to generate a
lex.backup file. For example, on the input</p>

<p>%% foo return TOK_KEYWORD; foobar return
TOK_KEYWORD;</p>

<p>the file looks like:</p>

<p>State #6 is non-accepting - associated rule line
numbers: 2 3 out-transitions: [ o ] jam-transitions: EOF [
01-n p-177 ]</p>

<p>State #8 is non-accepting - associated rule line
numbers: 3 out-transitions: [ a ] jam-transitions: EOF [ 01-
b-177 ]</p>

<p>State #9 is non-accepting - associated rule line
numbers: 3 out-transitions: [ r ] jam-transitions: EOF [
01-q s-177 ]</p>

<p>Compressed tables always back up.</p>

<p>The first few lines tell us that theres a scanner state
in which it can make a transition on an o but not on any
other character, and that in that state the currently
scanned text does not match any rule. The state occurs when
trying to match the rules found at lines 2 and 3 in the
input file. If the scanner is in that state and then reads
something other than an o, it will have to back up to find a
rule which is matched. With a bit of headscratching one can
see that this must be the state its in when it has seen
&quot;fo&quot;. When this has hap- pened, if anything other
than another o is seen, the scanner will have to back up to
simply match the f (by the default rule).</p>

<p>The comment regarding State #8 indicates theres a
problem when &quot;foob&quot; has been scanned. Indeed, on
any character other than an a, the scanner will have to back
up to accept &quot;foo&quot;. Similarly, the comment for
State #9 concerns when &quot;fooba&quot; has been scanned
and an r does not follow.</p>

<p>The final comment reminds us that there s no point going
to all the trouble of removing backing up from the rules
unless were using -Cf or -CF, since theres no performance
gain doing so with compressed scan- ners.</p>

<p>The way to remove the backing up is to add
&quot;error&quot; rules:</p>

<p>%% foo return TOK_KEYWORD; foobar return
TOK_KEYWORD;</p>

<p>fooba | foob | fo { /* false alarm, not really a keyword
*/ return TOK_ID; }</p>

<p>Eliminating backing up among a list of keywords can also
be done using a &quot;catch-all&quot; rule:</p>

<p>%% foo return TOK_KEYWORD; foobar return
TOK_KEYWORD;</p>

<p>[a-z]+ return TOK_ID;</p>

<p>This is usually the best solution when appropriate.</p>

<p>Backing up messages tend to cascade. With a complicated
set of rules it s not uncommon to get hundreds of messages.
If one can decipher them, though, it often only takes a
dozen or so rules to eliminate the backing up (though its
easy to make a mistake and have an error rule accidentally
match a valid token. A possible future flex feature will be
to automatically add rules to eliminate backing up).</p>

<p>It s important to keep in mind that you gain the
benefits of eliminat- ing backing up only if you eliminate
every instance of backing up. Leaving just one means you
gain nothing.</p>

<p>Variable trailing context (where both the leading and
trailing parts do not have a fixed length) entails almost
the same performance loss as REJECT (i.e., substantial). So
when possible a rule like:</p>

<p>%% mouse|rat/(cat|dog) run();</p>

<p>is better written:</p>

<p>%% mouse/cat|dog run(); rat/cat|dog run();</p>

<p>or as</p>

<p>%% mouse|rat/cat run(); mouse|rat/dog run();</p>

<p>Note that here the special | action does not provide any
savings, and can even make things worse (see Deficiencies /
Bugs below).</p>

<p>Another area where the user can increase a scanner s
performance (and one thats easier to implement) arises from
the fact that the longer the tokens matched, the faster the
scanner will run. This is because with long tokens the
processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go
through the additional work of setting up the scanning
environment (e.g., yytext) for the action. Recall the
scanner for C comments:</p>

<p>%x comment %% int line_num = 1;</p>

<p>&quot;/*&quot; BEGIN(comment);</p>

<p>&lt;comment&gt;[^*0* &lt;comment&gt;&quot;*&quot;+[^*/0*
&lt;comment&gt; ++line_num;
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p>This could be sped up by writing it as:</p>

<p>%x comment %% int line_num = 1;</p>

<p>&quot;/*&quot; BEGIN(comment);</p>

<p>&lt;comment&gt;[^*0* &lt;comment&gt;[^*0* ++line_num;
&lt;comment&gt;&quot;*&quot;+[^*/0*
&lt;comment&gt;&quot;*&quot;+[^*/0*++line_num;
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;
BEGIN(INITIAL);</p>

<p>Now instead of each newline requiring the processing of
another action, recognizing the newlines is
&quot;distributed&quot; over the other rules to keep the
matched text as long as possible. Note that adding rules
does not slow down the scanner! The speed of the scanner is
independent of the number of rules or (modulo the
considerations given at the beginning of this section) how
complicated the rules are with regard to operators such as *
and |.</p>

<p>A final example in speeding up a scanner: suppose you
want to scan through a file containing identifiers and
keywords, one per line and with no other extraneous
characters, and recognize all the keywords. A natural first
approach is:</p>

<p>%% asm | auto | break | ... etc ... volatile | while /*
its a keyword */</p>

<p>.| /* its not a keyword */</p>

<p>To eliminate the back-tracking, introduce a catch-all
rule:</p>

<p>%% asm | auto | break | ... etc ... volatile | while /*
its a keyword */</p>

<p>[a-z]+ | .| /* its not a keyword */</p>

<p>Now, if it s guaranteed that theres exactly one word per
line, then we can reduce the total number of matches by a
half by merging in the recognition of newlines with that of
the other tokens:</p>

<p>%% asm | auto | break | ... etc ... volatile| while /*
its a keyword */</p>

<p>[a-z]+| .| /* its not a keyword */</p>

<p>One has to be careful here, as we have now reintroduced
backing up into the scanner. In particular, while we know
that there will never be any characters in the input stream
other than letters or newlines, flex cant figure this out,
and it will plan for possibly needing to back up when it has
scanned a token like &quot;auto&quot; and then the next
character is something other than a newline or a letter.
Previously it would then just match the &quot;auto&quot;
rule and be done, but now it has no &quot;auto&quot; rule,
only a &quot;auto0 rule. To eliminate the possibility of
backing up, we could either duplicate all rules but without
final newlines, or, since we never expect to encounter such
an input and therefore dont how its classified, we can
introduce one more catch-all rule, this one which doesnt
include a newline:</p>

<p>%% asm | auto | break | ... etc ... volatile| while /*
its a keyword */</p>

<p>[a-z]+| [a-z]+ | .| /* its not a keyword */</p>

<p>Compiled with -Cf, this is about as fast as one can get
a flex scanner to go for this particular problem.</p>

<p>A final note: flex is slow when matching NUL s,
particularly when a token contains multiple NULs. Its best
to write rules which match short amounts of text if its
anticipated that the text will often include NULs.</p>

<p>Another final note regarding performance: as mentioned
above in the section How the Input is Matched, dynamically
resizing yytext to accom- modate huge tokens is a slow
process because it presently requires that the (huge) token
be rescanned from the beginning. Thus if performance is
vital, you should attempt to match &quot;large&quot;
quantities of text but not &quot;huge&quot; quantities,
where the cutoff between the two is at about 8K
characters/token.</p>

<p>GENERATING C++ SCANNERS flex provides two different ways
to generate scanners for use with C++. The first way is to
simply compile a scanner generated by flex using a C++
compiler instead of a C compiler. You should not encounter
any compilations errors (please report any you find to the
email address given in the Author section below). You can
then use C++ code in your rule actions instead of C code.
Note that the default input source for your scanner remains
yyin, and default echoing is still done to yyout. Both of
these remain FILE * variables and not C++ streams.</p>

<p>You can also use flex to generate a C++ scanner class,
using the -+ option (or, equivalently, %option c++), which
is automatically speci- fied if the name of the flex
executable ends in a +, such as flex++. When using this
option, flex defaults to generating the scanner to the file
lex.yy.cc instead of lex.yy.c. The generated scanner
includes the header file FlexLexer.h, which defines the
interface to two C++ classes.</p>

<p>The first class, FlexLexer, provides an abstract base
class defining the general scanner class interface. It
provides the following member functions:</p>

<p>const char* YYText() returns the text of the most
recently matched token, the equiva- lent of yytext.</p>

<p>int YYLeng() returns the length of the most recently
matched token, the equivalent of yyleng.</p>

<p>int lineno() const returns the current input line number
(see %option yylineno), or 1 if %option yylineno was not
used.</p>

<p>void set_debug( int flag ) sets the debugging flag for
the scanner, equivalent to assigning to yy_flex_debug (see
the Options section above). Note that you must build the
scanner using %option debug to include debugging information
in it.</p>

<p>int debug() const returns the current setting of the
debugging flag.</p>

<p>Also provided are member functions equivalent to
yy_switch_to_buffer(), yy_create_buffer() (though the first
argument is an istream* object pointer and not a FILE*),
yy_flush_buffer(), yy_delete_buffer(), and yyrestart()
(again, the first argument is a istream* object
pointer).</p>

<p>The second class defined in FlexLexer.h is yyFlexLexer,
which is derived from FlexLexer. It defines the following
additional member functions:</p>

<p>yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout =
0 ) constructs a yyFlexLexer object using the given streams
for input and output. If not specified, the streams default
to cin and cout, respectively.</p>

<p>virtual int yylex() performs the same role is yylex()
does for ordinary flex scan- ners: it scans the input
stream, consuming tokens, until a rules action returns a
value. If you derive a subclass S from yyFlexLexer and want
to access the member functions and vari- ables of S inside
yylex(), then you need to use %option yyclass=&quot;S&quot;
to inform flex that you will be using that subclass instead
of yyFlexLexer. In this case, rather than generating
yyFlexLexer::yylex(), flex generates S::yylex() (and also
gener- ates a dummy yyFlexLexer::yylex() that calls
yyFlexLexer::Lexer- Error() if called).</p>

<p>virtual void switch_streams(istream* new_in = 0,
ostream* new_out = 0) reassigns yyin to new_in (if non-nil)
and yyout to new_out (ditto), deleting the previous input
buffer if yyin is reassigned.</p>

<p>int yylex( istream* new_in, ostream* new_out = 0 ) first
switches the input streams via switch_streams( new_in,
new_out ) and then returns the value of yylex().</p>

<p>In addition, yyFlexLexer defines the following protected
virtual func- tions which you can redefine in derived
classes to tailor the scanner:</p>

<p>virtual int LexerInput( char* buf, int max_size ) reads
up to max_size characters into buf and returns the number of
characters read. To indicate end-of-input, return 0 charac-
ters. Note that &quot;interactive&quot; scanners (see the -B
and -I flags) define the macro YY_INTERACTIVE. If you
redefine Lex- erInput() and need to take different actions
depending on whether or not the scanner might be scanning an
interactive input source, you can test for the presence of
this name via #ifdef.</p>

<p>virtual void LexerOutput( const char* buf, int size )
writes out size characters from the buffer buf, which, while
NUL-terminated, may also contain &quot;internal&quot; NULs
if the scan- ners rules can match text with NULs in
them.</p>

<p>virtual void LexerError( const char* msg ) reports a
fatal error message. The default version of this function
writes the message to the stream cerr and exits.</p>

<p>Note that a yyFlexLexer object contains its entire
scanning state. Thus you can use such objects to create
reentrant scanners. You can instantiate multiple instances
of the same yyFlexLexer class, and you can also combine
multiple C++ scanner classes together in the same pro- gram
using the -P option discussed above.</p>

<p>Finally, note that the %array feature is not available
to C++ scanner classes; you must use %pointer (the
default).</p>

<p>Here is an example of a simple C++ scanner:</p>

<p>// An example of using the flex C++ scanner class.</p>

<p>%{ int mylineno = 0; %}</p>

<p>string</p>

<p>ws [ ]+</p>

<p>alpha [A-Za-z] dig [0-9] name
({alpha}|{dig}|({alpha}|{dig}|[_.&minus;/$])* num1
[-+]?{dig}+.?([eE][-+]?{dig}+)? num2
[-+]?{dig}*.{dig}+([eE][-+]?{dig}+)? number
{num1}|{num2}</p>

<p>%%</p>

<p>{ws} /* skip blanks and tabs */</p>

<p>&quot;/*&quot; { int c;</p>

<p>while((c = yyinput()) != 0) { ) if(c == 0
++mylineno;</p>

<p>else if(c == *) { if((c = yyinput()) == /) break; else
unput(c); } } }</p>

<p>; {number} cout &lt;&lt; &quot;number &quot; &lt;&lt;
YYText() &lt;&lt; 0 mylineno++;</p>

<p>; {name} cout &lt;&lt; &quot;name &quot; &lt;&lt;
YYText() &lt;&lt; 0 ; {string} cout &lt;&lt; &quot;string
&quot; &lt;&lt; YYText() &lt;&lt; 0 %%</p>

<p>int main( int /* argc */, char** /* argv */ ) {
FlexLexer* lexer = new yyFlexLexer; while(lexer-&gt;yylex()
!= 0) ; return 0; } If you want to create multiple
(different) lexer classes, you use the -P flag (or the
prefix= option) to rename each yyFlexLexer to some other
xxFlexLexer. You then can include &lt;FlexLexer.h&gt; in
your other sources once per lexer class, first renaming
yyFlexLexer as follows:</p>

<p>#undef yyFlexLexer #define yyFlexLexer xxFlexLexer
#include &lt;FlexLexer.h&gt;</p>

<p>#undef yyFlexLexer #define yyFlexLexer zzFlexLexer
#include &lt;FlexLexer.h&gt;</p>

<p>if, for example, you used %option prefix=&quot;xx&quot;
for one of your scanners and %option prefix=&quot;zz&quot;
for the other.</p>

<p>IMPORTANT: the present form of the scanning class is
experimental and may change considerably between major
releases.</p>

<p>INCOMPATIBILITIES WITH LEX AND POSIX flex is a rewrite
of the AT&amp;T Unix lex tool (the two implementations do
not share any code, though), with some extensions and
incompatibili- ties, both of which are of concern to those
who wish to write scanners acceptable to either
implementation. Flex is fully compliant with the POSIX lex
specification, except that when using %pointer (the
default), a call to unput() destroys the contents of yytext,
which is counter to the POSIX specification.</p>

<p>In this section we discuss all of the known areas of
incompatibility between flex, AT&amp;T lex, and the POSIX
specification.</p>

<p>flex_s -l option turns on maximum compatibility with the
original AT&amp;T lex implementation, at the cost of a major
loss in the generated scan- ner s performance. We note below
which incompatibilities can be over- come using the -l
option.</p>

<p>flex is fully compatible with lex with the following
exceptions:</p>

<p>- The undocumented lex scanner internal variable
yylineno is not supported unless -l or %option yylineno is
used.</p>

<p>yylineno should be maintained on a per-buffer basis,
rather than a per-scanner (single global variable)
basis.</p>

<p>yylineno is not part of the POSIX specification.</p>

<p>- The input() routine is not redefinable, though it may
be called to read characters following whatever has been
matched by a rule. If input() encounters an end-of-file the
normal yywrap() processing is done. A real end-of-file is
returned by input() as EOF.</p>

<p>Input is instead controlled by defining the YY_INPUT
macro.</p>

<p>The flex restriction that input() cannot be redefined is
in accordance with the POSIX specification, which simply
does not specify any way of controlling the scanner s input
other than by making an initial assignment to yyin.</p>

<p>- The unput() routine is not redefinable. This
restriction is in accordance with POSIX.</p>

<p>- flex scanners are not as reentrant as lex scanners. In
particu- lar, if you have an interactive scanner and an
interrupt handler which long-jumps out of the scanner, and
the scanner is subse- quently called again, you may get the
following message:</p>

<p>fatal flex scanner internal error--end of buffer
missed</p>

<p>To reenter the scanner, first use</p>

<p>yyrestart( yyin );</p>

<p>Note that this call will throw away any buffered input;
usually this isnt a problem with an interactive scanner.</p>

<p>Also note that flex C++ scanner classes are reentrant,
so if using C++ is an option for you, you should use them
instead. See &quot;Generating C++ Scanners&quot; above for
details.</p>

<p>- output() is not supported. Output from the ECHO macro
is done to the file-pointer yyout (default stdout).</p>

<p>output() is not part of the POSIX specification.</p>

<p>- lex does not support exclusive start conditions (%x),
though they are in the POSIX specification.</p>

<p>- When definitions are expanded, flex encloses them in
parenthe- ses. With lex, the following:</p>

<p>NAME [A-Z][A-Z0-9]* %% foo{NAME}? printf( &quot;Found
it0 ); %%</p>

<p>will not match the string &quot;foo&quot; because when
the macro is expanded the rule is equivalent to
&quot;foo[A-Z][A-Z0-9]*?&quot; and the precedence is such
that the ? is associated with &quot;[A-Z0-9]*&quot;. With
flex, the rule will be expanded to
&quot;foo([A-Z][A-Z0-9]*)?&quot; and so the string
&quot;foo&quot; will match.</p>

<p>Note that if the definition begins with ^ or ends with $
then it is not expanded with parentheses, to allow these
operators to appear in definitions without losing their
special meanings. But the &lt;s&gt;, /, and
&lt;&lt;EOF&gt;&gt; operators cannot be used in a flex
definition.</p>

<p>Using -l results in the lex behavior of no parentheses
around the definition.</p>

<p>The POSIX specification is that the definition be
enclosed in parentheses.</p>

<p>- Some implementations of lex allow a rules action to
begin on a separate line, if the rules pattern has trailing
whitespace:</p>

<p>%% foo|bar&lt;space here&gt; { foobar_action(); }</p>

<p>flex does not support this feature.</p>

<p>- The lex %r (generate a Ratfor scanner) option is not
supported. It is not part of the POSIX specification.</p>

<p>- After a call to unput(), yytext is undefined until the
next token is matched, unless the scanner was built using
%array. This is not the case with lex or the POSIX
specification. The -l option does away with this
incompatibility.</p>

<p>- The precedence of the {} (numeric range) operator is
different. lex interprets &quot;abc{1,3}&quot; as
&quot;match one, two, or three occur- rences of abc &quot;,
whereas flex interprets it as &quot;match ab fol- lowed by
one, two, or three occurrences of c &quot;. The latter is in
agreement with the POSIX specification.</p>

<p>- The precedence of the ^ operator is different. lex
interprets &quot;^foo|bar&quot; as &quot;match either foo at
the beginning of a line, or bar anywhere&quot;, whereas flex
interprets it as &quot;match either foo or bar if they come
at the beginning of a line&quot;. The latter is in agreement
with the POSIX specification.</p>

<p>- The special table-size declarations such as %a
supported by lex are not required by flex scanners; flex
ignores them.</p>

<p>- The name FLEX_SCANNER is #define d so scanners may be
written for use with either flex or lex. Scanners also
include YY_FLEX_MAJOR_VERSION and YY_FLEX_MINOR_VERSION
indicating which version of flex generated the scanner (for
example, for the 2.5 release, these defines would be 2 and 5
respectively).</p>

<p>The following flex features are not included in lex or
the POSIX speci- fication:</p>

<p>C++ scanners %option start condition scopes start
condition stacks interactive/non-interactive scanners
yy_scan_string() and friends yyterminate()
yy_set_interactive() yy_set_bol() YY_AT_BOL()
&lt;&lt;EOF&gt;&gt; &lt;*&gt; YY_DECL YY_START
YY_USER_ACTION YY_USER_INIT #line directives %{}s around
actions multiple actions on a line</p>

<p>plus almost all of the flex flags. The last feature in
the list refers to the fact that with flex you can put
multiple actions on the same line, separated with
semi-colons, while with lex, the following</p>

<p>foo handle_foo(); ++num_foos_seen;</p>

<p>is (rather surprisingly) truncated to</p>

<p>foo handle_foo();</p>

<p>flex does not truncate the action. Actions that are not
enclosed in braces are simply terminated at the end of the
line.</p>

<p>DIAGNOSTICS warning, rule cannot be matched indicates
that the given rule cannot be matched because it follows
other rules that will always match the same text as it. For
example, in the following &quot;foo&quot; cannot be matched
because it comes after an identifier &quot;catch-all&quot;
rule:</p>

<p>[a-z]+ got_identifier(); foo got_foo();</p>

<p>Using REJECT in a scanner suppresses this warning.</p>

<p>warning, -s option given but default rule can be matched
means that it is possible (perhaps only in a particular
start condition) that the default rule (match any single
character) is the only one that will match a particular
input. Since -s was given, presumably this is not
intended.</p>

<p>reject_used_but_not_detected undefined or
yymore_used_but_not_detected undefined - These errors can
occur at compile time. They indicate that the scanner uses
REJECT or yymore() but that flex failed to notice the fact,
meaning that flex scanned the first two sections looking for
occurrences of these actions and failed to find any, but
somehow you snuck some in (via a #include file, for
example). Use %option reject or %option yymore to indicate
to flex that you really do use these fea- tures.</p>

<p>flex scanner jammed - a scanner compiled with -s has
encountered an input string which wasn t matched by any of
its rules. This error can also occur due to internal
problems.</p>

<p>token too large, exceeds YYLMAX - your scanner uses
%array and one of its rules matched a string longer than the
YYLMAX constant (8K bytes by default). You can increase the
value by #defineing YYLMAX in the def- initions section of
your flex input.</p>

<p>scanner requires -8 flag to use the character x_- Your
scanner speci- fication includes recognizing the 8-bit
character x_ and you did not specify the -8 flag, and your
scanner defaulted to 7-bit because you used the -Cf or -CF
table compression options. See the discussion of the -7 flag
for details.</p>

<p>flex scanner push-back overflow - you used unput() to
push back so much text that the scanners buffer could not
hold both the pushed-back text and the current token in
yytext. Ideally the scanner should dynami- cally resize the
buffer in this case, but at present it does not.</p>

<p>input buffer overflow, cant enlarge buffer because
scanner uses REJECT - the scanner was working on matching an
extremely large token and needed to expand the input buffer.
This doesnt work with scanners that use REJECT.</p>

<p>fatal flex scanner internal error--end of buffer missed
- This can occur in an scanner which is reentered after a
long-jump has jumped out (or over) the scanner s activation
frame. Before reentering the scan- ner, use:</p>

<p>yyrestart( yyin );</p>

<p>or, as noted above, switch to using the C++ scanner
class.</p>

<p>too many start conditions in &lt;&gt; construct! - you
listed more start con- ditions in a &lt;&gt; construct than
exist (so you must have listed at least one of them
twice).</p>

<p>FILES -lfl library with which scanners must be
linked.</p>

<p>lex.yy.c generated scanner (called lexyy.c on some
systems).</p>

<p>lex.yy.cc generated C++ scanner class, when using
-+.</p>

<p>&lt;FlexLexer.h&gt; header file defining the C++ scanner
base class, FlexLexer, and its derived class,
yyFlexLexer.</p>

<p>flex.skl skeleton scanner. This file is only used when
building flex, not when flex executes.</p>

<p>lex.backup backing-up information for -b flag (called
lex.bck on some sys- tems).</p>

<p>DEFICIENCIES / BUGS Some trailing context patterns
cannot be properly matched and generate warning messages
(&quot;dangerous trailing context&quot;). These are patterns
where the ending of the first part of the rule matches the
beginning of the second part, such as &quot;zx*/xy*&quot;,
where the x* matches the x at the beginning of the trailing
context. (Note that the POSIX draft states that the text
matched by such patterns is undefined.)</p>

<p>For some trailing context rules, parts which are
actually fixed-length are not recognized as such, leading to
the abovementioned performance loss. In particular, parts
using | or {n} (such as &quot;foo{3}&quot;) are always
considered variable-length.</p>

<p>Combining trailing context with the special | action can
result in fixed trailing context being turned into the more
expensive variable trailing context. For example, in the
following:</p>

<p>%% abc | xyz/def</p>

<p>Use of unput() invalidates yytext and yyleng, unless the
%array direc- tive or the -l option has been used.</p>

<p>Pattern-matching of NULs is substantially slower than
matching other characters.</p>

<p>Dynamic resizing of the input buffer is slow, as it
entails rescanning all the text matched so far by the
current (generally huge) token.</p>

<p>Due to both buffering of input and read-ahead, you
cannot intermix calls to &lt;stdio.h&gt; routines, such as,
for example, getchar(), with flex rules and expect it to
work. Call input() instead.</p>

<p>The total table entries listed by the -v flag excludes
the number of table entries needed to determine what rule
has been matched. The num- ber of entries is equal to the
number of DFA states if the scanner does not use REJECT, and
somewhat greater than the number of states if it does.</p>

<p>REJECT cannot be used with the -f or -F options.</p>

<p>The flex internal algorithms need documentation.</p>

<p>SEE ALSO lex(1), yacc(1), sed(1), awk(1).</p>

<p>John Levine, Tony Mason, and Doug Brown, Lex &amp; Yacc,
O Reilly and Asso- ciates. Be sure to get the 2nd
edition.</p>

<p>M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer
Generator</p>

<p>Alfred Aho, Ravi Sethi and Jeffrey Ullman, Compilers:
Principles, Tech- niques and Tools, Addison-Wesley (1986).
Describes the pattern-match- ing techniques used by flex
(deterministic finite automata).</p>

<p>AUTHOR Vern Paxson, with the help of many ideas and much
inspiration from Van Jacobson. Original version by Jef
Poskanzer. The fast table represen- tation is a partial
implementation of a design done by Van Jacobson. The
implementation was done by Kevin Gong and Vern Paxson.</p>

<p>Thanks to the many flex beta-testers, feedbackers, and
contributors, especially Francois Pinard, Casey Leedom,
Robert Abramovitz, Stan Ader- mann, Terry Allen, David
Barker-Plummer, John Basrai, Neal Becker, Nel- son H.F.
Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, Simon
Blan- chard, Keith Bostic, Frederic Brehm, Ian Brockbank,
Kin Cho, Nick Christopher, Brian Clapper, J.T. Conklin,
Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, Scott
David Daniels, Chris G. Demetriou, Theo Deraadt, Mike
Donahue, Chuck Doucette, Tom Epperly, Leo Eskin, Chris
Faylor, Chris Flatters, Jon Forrest, Jeffrey Friedl, Joe
Gayda, Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman,
Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan
Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi,
Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes, John
Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari
Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf,
Jonathan I. Kamens, Ter- rence O Kane, Amir Katz,
ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch, Winfried
Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard,
Craig Leres, John Levine, Steve Liddle, David Loffredo, Mike
Long, Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall,
Bengt Martensson, Chris Metcalf, Luke Mewburn, Jim Meyering,
R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon Noll,
James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke,
Sven Panne, Roland Pesch, Wal- ter Pelissero, Gaumond
Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha,
Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin
Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini,
Andreas Scherer, Darrell Schiebel, Raf Schietekat, Doug
Schmidt, Philippe Schnoebelen, Andreas Schwab, Larry
Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist,
Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor,
Chris Thewalt, Richard M. Timoney, Jodi Tsai, Paul Tuinenga,
Gary Weik, Frank Whaley, Gerhard Wilhelms, Kent Williams,
Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and those
whose names have slipped my marginal mail-archiving skills
but whose contributions are appreciated all the same.</p>

<p>Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John
Gilmore, Craig Leres, John Levine, Bob Mulcahy, G.T. Nicol,
Francois Pinard, Rich Salz, and Richard Stallman for help
with various distribution headaches.</p>

<p>Thanks to Esmond Pitt and Earle Horton for 8-bit
character support; to Benson Margulies and Fred Burke for
C++ support; to Kent Williams and Tom Epperly for C++ class
support; to Ove Ewerlid for support of NULs; and to Eric
Hughes for support of multiple buffers.</p>

<p>This work was primarily done when I was with the Real
Time Systems Group at the Lawrence Berkeley Laboratory in
Berkeley, CA. Many thanks to all there for the support I
received.</p>

<p>Send comments to vern@ee.lbl.gov.</p>

<p>Version 2.5 April 1995 FLEX(1)</p>
<hr>
</body>
</html>
