<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:49 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLUNICODE(1) Perl Programmers Reference Guide
PERLUNICODE(1)</p>

<p>NAME perlunicode - Unicode support in Perl</p>

<p>DESCRIPTION Important Caveats</p>

<p>Unicode support is an extensive requirement. While Perl
does not imple- ment the Unicode standard or the
accompanying technical reports from cover to cover, Perl
does support many Unicode features.</p>

<p>Input and Output Layers Perl knows when a filehandle
uses Perl s internal Unicode encodings (UTF-8, or UTF-EBCDIC
if in EBCDIC) if the filehandle is opened with the
&quot;:utf8&quot; layer. Other encodings can be converted to
Perls encoding on input or from Perls encoding on output by
use of the &quot;:encoding(...)&quot; layer. See open.</p>

<p>To indicate that Perl source itself is using a
particular encoding, see encoding.</p>

<p>Regular Expressions The regular expression compiler
produces polymorphic opcodes. That is, the pattern adapts to
the data and automatically switches to the Unicode character
scheme when presented with Unicode data--or instead uses a
traditional byte scheme when presented with byte data.</p>

<p>&quot;use utf8&quot; still needed to enable
UTF-8/UTF-EBCDIC in scripts As a compatibility measure, the
&quot;use utf8&quot; pragma must be explic- itly included to
enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identi-
fier names) on ASCII-based machines or to recognize
UTF-EBCDIC on EBCDIC-based machines. These are the only
times when an explicit &quot;use utf8&quot; is needed. See
utf8.</p>

<p>You can also use the &quot;encoding&quot; pragma to
change the default encod- ing of the data in your script;
see encoding.</p>

<p>BOM-marked scripts and UTF-16 scripts autodetected If a
Perl script begins marked with the Unicode BOM (UTF-16LE,
UTF16-BE, or UTF-8), or if the script looks like
non-BOM-marked UTF-16 of either endianness, Perl will
correctly read in the script as Unicode. (BOMless UTF-8
cannot be effectively recognized or differentiated from ISO
8859-1 or other eight-bit encodings.)</p>

<p>&quot;use encoding&quot; needed to upgrade non-Latin-1
byte strings By default, there is a fundamental asymmetry in
Perls unicode model: implicit upgrading from byte strings to
Unicode strings assumes that they were encoded in ISO 8859-1
(Latin-1), but Unicode strings are downgraded with UTF-8
encoding. This happens because the first 256 codepoints in
Unicode happens to agree with Latin-1.</p>

<p>If you wish to interpret byte strings as UTF-8 instead,
use the &quot;encoding&quot; pragma:</p>

<p>use encoding utf8;</p>

<p>See &quot;Byte and Character Semantics&quot; for more
details.</p>

<p>Byte and Character Semantics</p>

<p>Beginning with version 5.6, Perl uses logically-wide
characters to represent strings internally.</p>

<p>In future, Perl-level operations will be expected to
work with charac- ters rather than bytes.</p>

<p>However, as an interim compatibility measure, Perl aims
to provide a safe migration path from byte semantics to
character semantics for pro- grams. For operations where
Perl can unambiguously decide that the input data are
characters, Perl switches to character semantics. For
operations where this determination cannot be made without
additional information from the user, Perl decides in favor
of compatibility and chooses to use byte semantics.</p>

<p>This behavior preserves compatibility with earlier
versions of Perl, which allowed byte semantics in Perl
operations only if none of the program s inputs were marked
as being as source of Unicode character data. Such data may
come from filehandles, from calls to external pro- grams,
from information provided by the system (such as %ENV), or
from literals and constants in the source text.</p>

<p>The &quot;bytes&quot; pragma will always, regardless of
platform, force byte semantics in a particular lexical
scope. See bytes.</p>

<p>The &quot;utf8&quot; pragma is primarily a compatibility
device that enables recognition of UTF-(8EBCDIC) in literals
encountered by the parser. Note that this pragma is only
required while Perl defaults to byte semantics; when
character semantics become the default, this pragma may
become a no-op. See utf8.</p>

<p>Unless explicitly stated, Perl operators use character
semantics for Unicode data and byte semantics for
non-Unicode data. The decision to use character semantics is
made transparently. If input data comes from a Unicode
source--for example, if a character encoding layer is added
to a filehandle or a literal Unicode string constant appears
in a program--character semantics apply. Otherwise, byte
semantics are in effect. The &quot;bytes&quot; pragma should
be used to force byte semantics on Unicode data.</p>

<p>If strings operating under byte semantics and strings
with Unicode character data are concatenated, the new string
will be created by decoding the byte strings as ISO 8859-1
(Latin-1), even if the old Uni- code string used EBCDIC.
This translation is done without regard to the systems
native 8-bit encoding. To change this for systems with
non-Latin-1 and non-EBCDIC native encodings, use the
&quot;encoding&quot; pragma. See encoding.</p>

<p>Under character semantics, many operations that formerly
operated on bytes now operate on characters. A character in
Perl is logically just a number ranging from 0 to 2**31 or
so. Larger characters may encode into longer sequences of
bytes internally, but this internal detail is mostly hidden
for Perl code. See perluniintro for more.</p>

<p>Effects of Character Semantics</p>

<p>Character semantics have the following effects:</p>

<p>&middot; Strings--including hash keys--and regular
expression patterns may contain characters that have an
ordinal value larger than 255.</p>

<p>If you use a Unicode editor to edit your program,
Unicode charac- ters may occur directly within the literal
strings in one of the various Unicode encodings (UTF-8,
UTF-EBCDIC, UCS-2, etc.), but will be recognized as such and
converted to Perls internal repre- sentation only if the
appropriate encoding is specified.</p>

<p>Unicode characters can also be added to a string by
using the &quot;.}&quot; notation. The Unicode code for the
desired character, in hexadecimal, should be placed in the
braces. For instance, a smiley face is &quot;}&quot;. This
encoding scheme only works for characters with a code of
0x100 or above.</p>

<p>Additionally, if you</p>

<p>use charnames :full;</p>

<p>you can use the &quot;.}&quot; notation and put the
official Unicode character name within the braces, such as
&quot;HITE SMILING FACE}&quot;.</p>

<p>&middot; If an appropriate encoding is specified,
identifiers within the Perl script may contain Unicode
alphanumeric characters, including ideographs. Perl does not
currently attempt to canonicalize vari- able names.</p>

<p>&middot; Regular expressions match characters instead of
bytes. &quot;.&quot; matches a character instead of a byte.
The &quot;pattern is provided to force a match a single
byte--a &quot;char&quot; in C, hence &quot; &middot;
Character classes in regular expressions match characters
instead of bytes and match against the character properties
specified in the Unicode properties database. &quot;552
Japanese ideograph, for instance.</p>

<p>(However, and as a limitation of the current
implementation, using &quot;96W&quot; inside a
&quot;[...]&quot; character class will still match with byte
semantics.)</p>

<p>&middot; Named Unicode properties, scripts, and block
ranges may be used like character classes via the
&quot;{}&quot; &quot;matches property&quot; construct and
the &quot;P{}&quot; negation, &quot;doesnt match
property&quot;.</p>

<p>For instance, &quot;{Lu}&quot; matches any character
with the Unicode &quot;Lu&quot; (Letter, uppercase)
property, while &quot;{M}&quot; matches any character with
an &quot;M&quot; (mark--accents and such) property. Brackets
are not required for single letter properties, so
&quot;{M}&quot; is equivalent to &quot;M&quot;. Many
predefined properties are available, such as &quot;{Mir-
rored}&quot; and &quot;{Tibetan}&quot;.</p>

<p>The official Unicode script and block names have spaces
and dashes as separators, but for convenience you can use
dashes, spaces, or underbars, and case is unimportant. It is
recommended, however, that for consistency you use the
following naming: the official Unicode script, property, or
block name (see below for the addi- tional rules that apply
to block names) with whitespace and dashes removed, and the
words &quot;uppercase-first-lowercase-rest&quot;.
&quot;Latin-1 Supplement&quot; thus becomes
&quot;Latin1Supplement&quot;.</p>

<p>You can also use negation in both &quot;{}&quot; and
&quot;P{}&quot; by introducing a caret (^) between the first
brace and the property name: &quot;{^Tamil}&quot; is equal
to &quot;P{Tamil}&quot;.</p>

<p>NOTE: the properties, scripts, and blocks listed here
are as of Unicode 3.2.0, March 2002, or Perl 5.8.0, July
2002. Unicode 4.0.0 came out in April 2003, and Perl 5.8.1
in September 2003.</p>

<p>Here are the basic Unicode General Category properties,
followed by their long form. You can use either;
&quot;{Lu}&quot; and &quot;{Uppercase- Letter}&quot;, for
instance, are identical.</p>

<p>Short Long</p>

<p>L Letter LC CasedLetter Lu UppercaseLetter Ll
LowercaseLetter Lt TitlecaseLetter Lm ModifierLetter Lo
OtherLetter</p>

<p>M Mark Mn NonspacingMark Mc SpacingMark Me
EnclosingMark</p>

<p>N Number Nd DecimalNumber Nl LetterNumber No
OtherNumber</p>

<p>P Punctuation Pc ConnectorPunctuation Pd DashPunctuation
Ps OpenPunctuation Pe ClosePunctuation Pi InitialPunctuation
(may behave like Ps or Pe depending on usage) Pf
FinalPunctuation (may behave like Ps or Pe depending on
usage) Po OtherPunctuation</p>

<p>S Symbol Sm MathSymbol Sc CurrencySymbol Sk
ModifierSymbol So OtherSymbol</p>

<p>Z Separator Zs SpaceSeparator Zl LineSeparator Zp
ParagraphSeparator</p>

<p>C Other Cc Control Cf Format Cs Surrogate (not usable)
Co PrivateUse Cn Unassigned</p>

<p>Single-letter properties match all characters in any of
the two- letter sub-properties starting with the same
letter. &quot;LC&quot; and &quot;L&amp;&quot; are special
cases, which are aliases for the set of &quot;Ll&quot;,
&quot;Lu&quot;, and &quot;Lt&quot;.</p>

<p>Because Perl hides the need for the user to understand
the internal representation of Unicode characters, there is
no need to implement the somewhat messy concept of
surrogates. &quot;Cs&quot; is therefore not supported.</p>

<p>Because scripts differ in their directionality--Hebrew
is written right to left, for example--Unicode supplies
these properties in the BidiClass class:</p>

<p>Property Meaning</p>

<p>L Left-to-Right LRE Left-to-Right Embedding LRO
Left-to-Right Override R Right-to-Left AL Right-to-Left
Arabic RLE Right-to-Left Embedding RLO Right-to-Left
Override PDF Pop Directional Format EN European Number ES
European Number Separator ET European Number Terminator AN
Arabic Number CS Common Number Separator NSM Non-Spacing
Mark BN Boundary Neutral B Paragraph Separator S Segment
Separator WS Whitespace ON Other Neutrals</p>

<p>For example, &quot;{BidiClass:R}&quot; matches
characters that are normally written right to left.</p>

<p>Scripts</p>

<p>The script names which can be used by &quot;{...}&quot;
and &quot;P{...}&quot;, such as in &quot;{Latin}&quot; or
&quot;{Cyrillic}&quot;, are as follows:</p>

<p>Arabic Armenian Bengali Bopomofo Buhid
CanadianAboriginal Cherokee Cyrillic Deseret Devanagari
Ethiopic Georgian Gothic Greek Gujarati Gurmukhi Han Hangul
Hanunoo Hebrew Hiragana Inherited Kannada Katakana Khmer Lao
Latin Malayalam Mongolian Myanmar Ogham OldItalic Oriya
Runic Sinhala Syriac Tagalog Tagbanwa Tamil Telugu Thaana
Thai Tibetan Yi</p>

<p>Extended property classes can supplement the basic
properties, defined by the PropList Unicode database:</p>

<p>ASCIIHexDigit BidiControl Dash Deprecated Diacritic
Extender GraphemeLink HexDigit Hyphen Ideographic
IDSBinaryOperator IDSTrinaryOperator JoinControl
LogicalOrderException NoncharacterCodePoint OtherAlphabetic
OtherDefaultIgnorableCodePoint OtherGraphemeExtend
OtherLowercase OtherMath OtherUppercase QuotationMark
Radical SoftDotted TerminalPunctuation UnifiedIdeograph
WhiteSpace</p>

<p>and there are further derived properties:</p>

<p>Alphabetic Lu + Ll + Lt + Lm + Lo + OtherAlphabetic
Lowercase Ll + OtherLowercase Uppercase Lu + OtherUppercase
Math Sm + OtherMath</p>

<p>ID_Start Lu + Ll + Lt + Lm + Lo + Nl ID_Continue
ID_Start + Mn + Mc + Nd + Pc</p>

<p>Any Any character Assigned Any non-Cn character (i.e.
synonym for P{Cn}) Unassigned Synonym for {Cn} Common Any
character (or unassigned code point) not explicitly assigned
to a script</p>

<p>For backward compatibility (with Perl 5.6), all
properties mentioned so far may have &quot;Is&quot;
prepended to their name, so &quot;P{IsLu}&quot;, for
example, is equal to &quot;P{Lu}&quot;.</p>

<p>Blocks</p>

<p>In addition to scripts, Unicode also defines blocks of
characters. The difference between scripts and blocks is
that the concept of scripts is closer to natural languages,
while the concept of blocks is more of an artificial
grouping based on groups of 256 Unicode characters. For
example, the &quot;Latin&quot; script contains letters from
many blocks but does not contain all the characters from
those blocks. It does not, for example, contain digits,
because digits are shared across many scripts. Digits and
similar groups, like punctuation, are in a category called
&quot;Common&quot;.</p>

<p>For more about scripts, see the UTR #24:</p>

<p>http://www.unicode.org/unicode/reports/tr24/</p>

<p>For more about blocks, see:</p>

<p>http://www.unicode.org/Public/UNIDATA/Blocks.txt</p>

<p>Block names are given with the &quot;In&quot; prefix.
For example, the Katakana block is referenced via
&quot;{InKatakana}&quot;. The &quot;In&quot; prefix may be
omit- ted if there is no naming conflict with a script or
any other property, but it is recommended that
&quot;In&quot; always be used for block tests to avoid
confusion.</p>

<p>These block names are supported:</p>

<p>InAlphabeticPresentationForms InArabic
InArabicPresentationFormsA InArabicPresentationFormsB
InArmenian InArrows InBasicLatin InBengali InBlockElements
InBopomofo InBopomofoExtended InBoxDrawing InBraillePatterns
InBuhid InByzantineMusicalSymbols InCJKCompatibility
InCJKCompatibilityForms InCJKCompatibilityIdeographs
InCJKCompatibilityIdeographsSupplement
InCJKRadicalsSupplement InCJKSymbolsAndPunctuation
InCJKUnifiedIdeographs InCJKUnifiedIdeographsExtensionA
InCJKUnifiedIdeographsExtensionB InCherokee
InCombiningDiacriticalMarks
InCombiningDiacriticalMarksforSymbols InCombiningHalfMarks
InControlPictures InCurrencySymbols InCyrillic
InCyrillicSupplementary InDeseret InDevanagari InDingbats
InEnclosedAlphanumerics InEnclosedCJKLettersAndMonths
InEthiopic InGeneralPunctuation InGeometricShapes InGeorgian
InGothic InGreekExtended InGreekAndCoptic InGujarati
InGurmukhi InHalfwidthAndFullwidthForms
InHangulCompatibilityJamo InHangulJamo InHangulSyllables
InHanunoo InHebrew InHighPrivateUseSurrogates
InHighSurrogates InHiragana InIPAExtensions
InIdeographicDescriptionCharacters InKanbun InKangxiRadicals
InKannada InKatakana InKatakanaPhoneticExtensions InKhmer
InLao InLatin1Supplement InLatinExtendedA
InLatinExtendedAdditional InLatinExtendedB
InLetterlikeSymbols InLowSurrogates InMalayalam
InMathematicalAlphanumericSymbols InMathematicalOperators
InMiscellaneousMathematicalSymbolsA
InMiscellaneousMathematicalSymbolsB InMiscellaneousSymbols
InMiscellaneousTechnical InMongolian InMusicalSymbols
InMyanmar InNumberForms InOgham InOldItalic
InOpticalCharacterRecognition InOriya InPrivateUseArea
InRunic InSinhala InSmallFormVariants
InSpacingModifierLetters InSpecials
InSuperscriptsAndSubscripts InSupplementalArrowsA
InSupplementalArrowsB InSupplementalMathematicalOperators
InSupplementaryPrivateUseAreaA
InSupplementaryPrivateUseAreaB InSyriac InTagalog InTagbanwa
InTags InTamil InTelugu InThaana InThai InTibetan
InUnifiedCanadianAboriginalSyllabics InVariationSelectors
InYiRadicals InYiSyllables</p>

<p>&middot; The special pattern &quot;a combining character
sequence&quot; in Standardese--where the first char- acter
is a base character and subsequent characters are mark char-
acters that apply to the base character. &quot;
&quot;(?:PMM*)&quot;.</p>

<p>&middot; The &quot;tr///&quot; operator translates
characters instead of bytes. Note that the
&quot;tr///CU&quot; functionality has been removed. For
similar functionality see pack(U0, ...) and pack(C0,
...).</p>

<p>&middot; Case translation operators use the Unicode case
translation tables when character input is provided. Note
that &quot;uc()&quot;, or &quot;U&quot; in interpolated
strings, translates to uppercase, while &quot;ucfirst&quot;,
or &quot;&quot; in interpolated strings, translates to
titlecase in languages that make the distinction.</p>

<p>&middot; Most operators that deal with positions or
lengths in a string will automatically switch to using
character positions, including &quot;chop()&quot;,
&quot;chomp()&quot;, &quot;substr()&quot;,
&quot;pos()&quot;, &quot;index()&quot;,
&quot;rindex()&quot;, &quot;sprintf()&quot;,
&quot;write()&quot;, and &quot;length()&quot;. Operators
that specifi- cally do not switch include &quot;vec()&quot;,
&quot;pack()&quot;, and &quot;unpack()&quot;. Operators that
really dont care include operators that treats strings as a
bucket of bits such as &quot;sort()&quot;, and operators
dealing with filenames.</p>

<p>&middot; The &quot;pack()&quot;/&quot;unpack()&quot;
letters &quot;c&quot; and &quot;C&quot; do not change, since
they are often used for byte-oriented formats. Again, think
&quot;char&quot; in the C language.</p>

<p>There is a new &quot;U&quot; specifier that converts
between Unicode charac- ters and code points.</p>

<p>&middot; The &quot;chr()&quot; and &quot;ord()&quot;
functions work on characters, similar to
&quot;pack(&quot;U&quot;)&quot; and
&quot;unpack(&quot;U&quot;)&quot;, not
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot;.
&quot;pack(&quot;C&quot;)&quot; and
&quot;unpack(&quot;C&quot;)&quot; are methods for emulating
byte-ori- ented &quot;chr()&quot; and &quot;ord()&quot; on
Unicode strings. While these methods reveal the internal
encoding of Unicode strings, that is not some- thing one
normally needs to care about at all.</p>

<p>&middot; The bit string operators, &quot;&amp; ^
~&quot;, can operate on character data. However, for
backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal
value, one should not use &quot;~&quot; (the bit complement)
with characters of both values less than 256 and values
greater than 256. Most impor- tantly, DeMorgan s laws
(&quot;~($x $y) eq ~$x&amp;~$y&quot; and &quot;~($x&amp;$y)
eq ~$x ~$y&quot;) will not hold. The reason for this
mathematical faux pas is that the complement cannot return
both the 8-bit (byte-wide) bit complement and the full
character-wide bit complement.</p>

<p>&middot; lc(), uc(), lcfirst(), and ucfirst() work for
the following cases:</p>

<p>&middot; the case mapping is from a single Unicode
character to another single Unicode character, or</p>

<p>&middot; the case mapping is from a single Unicode
character to more than one Unicode character.</p>

<p>Things to do with locales (Lithuanian, Turkish, Azeri)
do not work since Perl does not understand the concept of
Unicode locales.</p>

<p>See the Unicode Technical Report #21, Case Mappings, for
more details.</p>

<p>&middot; And finally, &quot;scalar reverse()&quot;
reverses by character rather than by byte.</p>

<p>User-Defined Character Properties</p>

<p>You can define your own character properties by defining
subroutines whose names begin with &quot;In&quot; or
&quot;Is&quot;. The subroutines can be defined in any
package. The user-defined properties can be used in the
regular expression &quot;&quot; and &quot;P&quot;
constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its
package in the &quot;&quot; or &quot;P&quot; construct.</p>

<p># assuming property IsForeign defined in Lang:: package
main; # property package name required if ($txt =~
/{Lang::IsForeign}+/) { ... }</p>

<p>package Lang; # property package name not required if
($txt =~ /{IsForeign}+/) { ... }</p>

<p>Note that the effect is compile-time and immutable once
defined.</p>

<p>The subroutines must return a specially-formatted
string, with one or more newline-separated lines. Each line
must be one of the following:</p>

<p>&middot; Two hexadecimal numbers separated by horizontal
whitespace (space or tabular characters) denoting a range of
Unicode code points to include.</p>

<p>&middot; Something to include, prefixed by
&quot;+&quot;: a built-in character prop- erty (prefixed by
&quot;utf8::&quot;) or a user-defined character property, to
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p>&middot; Something to exclude, prefixed by
&quot;-&quot;: an existing character prop- erty (prefixed by
&quot;utf8::&quot;) or a user-defined character property, to
represent all the characters in that property; two
hexadecimal code points for a range; or a single hexadecimal
code point.</p>

<p>&middot; Something to negate, prefixed &quot;!&quot;: an
existing character property (prefixed by &quot;utf8::&quot;)
or a user-defined character property, to represent all the
characters in that property; two hexadecimal code points for
a range; or a single hexadecimal code point.</p>

<p>&middot; Something to intersect with, prefixed by
&quot;&amp;&quot;: an existing character property (prefixed
by &quot;utf8::&quot;) or a user-defined character prop-
erty, for all the characters except the characters in the
property; two hexadecimal code points for a range; or a
single hexadecimal code point.</p>

<p>For example, to define a property that covers both the
Japanese syl- labaries (hiragana and katakana), you can
define</p>

<p>sub InKana { return &lt;&lt;END; 3040309F 30A030FF END
}</p>

<p>Imagine that the here-doc end marker is at the beginning
of the line. Now you can use &quot;{InKana}&quot; and
&quot;P{InKana}&quot;.</p>

<p>You could also have used the existing block property
names:</p>

<p>sub InKana { return &lt;&lt;END; +utf8::InHiragana
+utf8::InKatakana END }</p>

<p>Suppose you wanted to match only the allocated
characters, not the raw block ranges: in other words, you
want to remove the non-characters:</p>

<p>sub InKana { return &lt;&lt;END; +utf8::InHiragana
+utf8::InKatakana -utf8::IsCn END }</p>

<p>The negation is useful for defining (surprise!) negated
classes.</p>

<p>sub InNotKana { return &lt;&lt;END; !utf8::InHiragana
-utf8::InKatakana +utf8::IsCn END }</p>

<p>Intersection is useful for getting the common characters
matched by two (or more) classes.</p>

<p>sub InFooAndBar { return &lt;&lt;END; +main::Foo
&amp;main::Bar END }</p>

<p>Its important to remember not to use &quot;&amp;&quot;
for the first set -- that would be intersecting with nothing
(resulting in an empty set).</p>

<p>You can also define your own mappings to be used in the
lc(), lcfirst(), uc(), and ucfirst() (or their
string-inlined versions). The principle is the same: define
subroutines in the &quot;main&quot; package with names like
&quot;ToLower&quot; (for lc() and lcfirst()),
&quot;ToTitle&quot; (for the first character in ucfirst()),
and &quot;ToUpper&quot; (for uc(), and the rest of the
characters in ucfirst()).</p>

<p>The string returned by the subroutines needs now to be
three hexadeci- mal numbers separated by tabulators: start
of the source range, end of the source range, and start of
the destination range. For example:</p>

<p>sub ToUpper { return &lt;&lt;END; 006100630041 END }</p>

<p>defines an uc() mapping that causes only the characters
&quot;a&quot;, &quot;b&quot;, and &quot;c&quot; to be mapped
to &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, all other
characters will remain unchanged.</p>

<p>If there is no source range to speak of, that is, the
mapping is from a single character to another single
character, leave the end of the source range empty, but the
two tabulator characters are still needed. For example:</p>

<p>sub ToLower { return &lt;&lt;END; 00410061 END }</p>

<p>defines a lc() mapping that causes only &quot;A&quot; to
be mapped to &quot;a&quot;, all other characters will remain
unchanged.</p>

<p>(For serious hackers only) If you want to introspect the
default mappings, you can find the data in the directory
$Config{privlib}/uni- core/To/. The mapping data is returned
as the here-document, and the &quot;utf8::ToSpecFoo&quot;
are special exception mappings derived from &lt;$Con-
fig{privlib}&gt;/unicore/SpecialCasing.txt. The
&quot;Digit&quot; and &quot;Fold&quot; map- pings that one
can see in the directory are not directly user-accessi- ble,
one can use either the &quot;Unicode::UCD&quot; module, or
just match case- insensitively (thats when the
&quot;Fold&quot; mapping is used).</p>

<p>A final note on the user-defined property tests and
mappings: they will be used only if the scalar has been
marked as having Unicode charac- ters. Old byte-style
strings will not be affected.</p>

<p>Character Encodings for Input and Output</p>

<p>See Encode.</p>

<p>Unicode Regular Expression Support Level</p>

<p>The following list of Unicode support for regular
expressions describes all the features currently supported.
The references to &quot;Level N&quot; and the section
numbers refer to the Unicode Technical Report 18,
&quot;Unicode Regular Expression Guidelines&quot;, version 6
(Unicode 3.2.0, Perl 5.8.0).</p>

<p>&middot; Level 1 - Basic Unicode Support</p>

<p>2.1 Hex Notation - done [1] Named Notation - done [2]
2.2 Categories - done [3][4] 2.3 Subtraction - MISSING
[5][6] 2.4 Simple Word Boundaries - done [7] 2.5 Simple
Loose Matches - done [8] 2.6 End of Line - MISSING
[9][10]</p>

<p>[ 1] .} [ 2] .} [ 3] . {...} P{...} [ 4] support for
scripts (see UTR#24 Script Names), blocks, binary
properties, enumerated non-binary properties, and numeric
properties (as listed in UTR#18 Other Properties) [ 5] have
negation [ 6] can use regular expression look-ahead [a] or
user-defined character properties [b] to emulate subtraction
[ 7] include Letters in word characters [ 8] note that Perl
does Full case-folding in matching, not Simple: for example
U+1F88 is equivalent with U+1F00 U+03B9, not with 1F80. This
difference matters for certain Greek capital letters with
certain modifiers: the Full case-folding decomposes the
letter, while the Simple case-folding would map it to a
single character. [ 9] see UTR #13 Unicode Newline
Guidelines [10] should do ^ and $ also on , and (should also
affect &lt;&gt;, $., and script line numbers) (the , and do
match</p>

<p>[a] You can mimic class subtraction using lookahead. For
example, what UTR #18 might write as</p>

<p>[{Greek}-[{UNASSIGNED}]]</p>

<p>in Perl can be written as:</p>

<p>(?!{Unassigned}){InGreekAndCoptic}
(?={Assigned}){InGreekAndCoptic}</p>

<p>But in this particular example, you probably really
want</p>

<p>{GreekAndCoptic}</p>

<p>which will match assigned characters known to be part of
the Greek script.</p>

<p>Also see the Unicode::Regex::Set module, it does
implement the full UTR #18 grouping, intersection, union,
and removal (subtraction) syntax.</p>

<p>[b] See &quot;User-Defined Character
Properties&quot;.</p>

<p>&middot; Level 2 - Extended Unicode Support</p>

<p>3.1 Surrogates - MISSING [11] 3.2 Canonical Equivalents
- MISSING [12][13] 3.3 Locale-Independent Graphemes -
MISSING [14] 3.4 Locale-Independent Words - MISSING [15] 3.5
Locale-Independent Loose Matches - MISSING [16]</p>

<p>[11] Surrogates are solely a UTF-16 concept and Perls
internal representation is UTF-8. The Encode module does
UTF-16, though. [12] see UTR#15 Unicode Normalization [13]
have Unicode::Normalize but not integrated to regexes [14]
have at this level . should equal that [15] need three
classes, not just 72W [16] see UTR#21 Case Mappings</p>

<p>&middot; Level 3 - Locale-Sensitive Support</p>

<p>4.1 Locale-Dependent Categories - MISSING 4.2
Locale-Dependent Graphemes - MISSING [16][17] 4.3
Locale-Dependent Words - MISSING 4.4 Locale-Dependent Loose
Matches - MISSING 4.5 Locale-Dependent Ranges - MISSING</p>

<p>[16] see UTR#10 Unicode Collation Algorithms [17] have
Unicode::Collate but not integrated to regexes</p>

<p>Unicode Encodings</p>

<p>Unicode characters are assigned to code points, which
are abstract num- bers. To use these numbers, various
encodings are needed.</p>

<p>&middot; UTF-8</p>

<p>UTF-8 is a variable-length (1 to 6 bytes, current
character alloca- tions require 4 bytes), byte-order
independent encoding. For ASCII (and we really do mean 7-bit
ASCII, not another 8-bit encoding), UTF-8 is
transparent.</p>

<p>The following table is from Unicode 3.2.</p>

<p>Code Points 1st Byte 2nd Byte 3rd Byte 4th Byte</p>

<p>U+0000..U+007F 00..7F U+0080..U+07FF C2..DF 80..BF
U+0800..U+0FFF E0 A0..BF 80..BF U+1000..U+CFFF E1..EC 80..BF
80..BF U+D000..U+D7FF ED 80..9F 80..BF U+D800..U+DFFF
******* ill-formed ******* U+E000..U+FFFF EE..EF 80..BF
80..BF U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
U+100000..U+10FFFF F4 80..8F 80..BF 80..BF</p>

<p>Note the &quot;A0..BF&quot; in
&quot;U+0800..U+0FFF&quot;, the &quot;80..9F&quot; in
&quot;U+D000...U+D7FF&quot;, the &quot;90..B&quot;F in
&quot;U+10000..U+3FFFF&quot;, and the &quot;80...8F&quot; in
&quot;U+100000..U+10FFFF&quot;. The &quot;gaps&quot; are
caused by legal UTF-8 avoiding non-shortest encodings: it is
technically possible to UTF-8-encode a single code point in
different ways, but that is explicitly forbidden, and the
shortest possible encoding should always be used. So thats
what Perl does.</p>

<p>Another way to look at it is via bits:</p>

<p>Code Points 1st Byte 2nd Byte 3rd Byte 4th Byte</p>

<p>0aaaaaaa 0aaaaaaa 00000bbbbbaaaaaa 110bbbbb 10aaaaaa
ccccbbbbbbaaaaaa 1110cccc 10bbbbbb 10aaaaaa
00000dddccccccbbbbbbaaaaaa 11110ddd 10cccccc 10bbbbbb
10aaaaaa</p>

<p>As you can see, the continuation bytes all begin with
10, and the leading bits of the start byte tell how many
bytes the are in the encoded character.</p>

<p>&middot; UTF-EBCDIC</p>

<p>Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is
ASCII-safe.</p>

<p>&middot; UTF-16, UTF-16BE, UTF-16LE, Surrogates, and
BOMs (Byte Order Marks)</p>

<p>The followings items are mostly for reference and
general Unicode knowledge, Perl doesn t use these constructs
internally.</p>

<p>UTF-16 is a 2 or 4 byte encoding. The Unicode code
points &quot;U+0000..U+FFFF&quot; are stored in a single
16-bit unit, and the code points
&quot;U+10000..U+10FFFF&quot; in two 16-bit units. The
latter case is using surrogates, the first 16-bit unit being
the high surrogate, and the second being the low
surrogate.</p>

<p>Surrogates are code points set aside to encode the
&quot;U+10000..U+10FFFF&quot; range of Unicode code points
in pairs of 16-bit units. The high surrogates are the range
&quot;U+D800..U+DBFF&quot;, and the low surrogates are the
range &quot;U+DC00..U+DFFF&quot;. The surrogate encoding
is</p>

<p>$hi = ($uni - 0x10000) / 0x400 + 0xD800; $lo = ($uni -
0x10000) % 0x400 + 0xDC00;</p>

<p>and the decoding is</p>

<p>$uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo -
0xDC00);</p>

<p>If you try to generate surrogates (for example by using
chr()), you will get a warning if warnings are turned on,
because those code points are not valid for a Unicode
character.</p>

<p>Because of the 16-bitness, UTF-16 is byte-order
dependent. UTF-16 itself can be used for in-memory
computations, but if storage or transfer is required either
UTF-16BE (big-endian) or UTF-16LE (lit- tle-endian)
encodings must be chosen.</p>

<p>This introduces another problem: what if you just know
that your data is UTF-16, but you dont know which
endianness? Byte Order Marks, or BOMs, are a solution to
this. A special character has been reserved in Unicode to
function as a byte order marker: the character with the code
point &quot;U+FEFF&quot; is the BOM.</p>

<p>The trick is that if you read a BOM, you will know the
byte order, since if it was written on a big-endian
platform, you will read the bytes &quot;0xFE 0xFF&quot;, but
if it was written on a little-endian platform, you will read
the bytes &quot;0xFF 0xFE&quot;. (And if the origi- nating
platform was writing in UTF-8, you will read the bytes
&quot;0xEF 0xBB 0xBF&quot;.)</p>

<p>The way this trick works is that the character with the
code point &quot;U+FFFE&quot; is guaranteed not to be a
valid Unicode character, so the sequence of bytes &quot;0xFF
0xFE&quot; is unambiguously &quot;BOM, represented in
little-endian format&quot; and cannot be &quot;U+FFFE&quot;,
represented in big- endian format&quot;.</p>

<p>&middot; UTF-32, UTF-32BE, UTF-32LE</p>

<p>The UTF-32 family is pretty much like the UTF-16 family,
expect that the units are 32-bit, and therefore the
surrogate scheme is not needed. The BOM signatures will be
&quot;0x00 0x00 0xFE 0xFF&quot; for BE and &quot;0xFF 0xFE
0x00 0x00&quot; for LE.</p>

<p>&middot; UCS-2, UCS-4</p>

<p>Encodings defined by the ISO 10646 standard. UCS-2 is a
16-bit encoding. Unlike UTF-16, UCS-2 is not extensible
beyond &quot;U+FFFF&quot;, because it does not use
surrogates. UCS-4 is a 32-bit encoding, functionally
identical to UTF-32.</p>

<p>&middot; UTF-7</p>

<p>A seven-bit safe (non-eight-bit) encoding, which is
useful if the transport or storage is not eight-bit safe.
Defined by RFC 2152.</p>

<p>Security Implications of Unicode</p>

<p>&middot; Malformed UTF-8</p>

<p>Unfortunately, the specification of UTF-8 leaves some
room for interpretation of how many bytes of encoded output
one should gen- erate from one input Unicode character.
Strictly speaking, the shortest possible sequence of UTF-8
bytes should be generated, because otherwise there is
potential for an input buffer overflow at the receiving end
of a UTF-8 connection. Perl always generates the shortest
length UTF-8, and with warnings on Perl will warn about
non-shortest length UTF-8 along with other malformations,
such as the surrogates, which are not real Unicode code
points.</p>

<p>&middot; Regular expressions behave slightly differently
between byte data and character (Unicode) data. For example,
the &quot;word character&quot; character class &quot;1104
eight-bit bytes or Unicode.</p>

<p>In the first case, the set of &quot;768 default set of
alphabetic characters, digits, and the &quot;_&quot;--or, if
you are using a locale (see perllocale), the &quot;384 few
more letters according to your language and country.</p>

<p>In the second case, the &quot;768 larger. Most
importantly, even in the set of the first 256 charac- ters,
it will probably match different characters: unlike most
locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters
somewhere as &quot;24 For example, your locale might not
think that LATIN SMALL LETTER ETH is a letter (unless you
happen to speak Icelandic), but Unicode does.</p>

<p>As discussed elsewhere, Perl has one foot (two hooves?)
planted in each of two worlds: the old world of bytes and
the new world of characters, upgrading from bytes to
characters when necessary. If your legacy code does not
explicitly use Unicode, no automatic switch-over to
characters should happen. Characters shouldnt get downgraded
to bytes, either. It is possible to accidentally mix bytes
and characters, however (see perluniintro), in which case
&quot;1368 Review your code. Use warnings and the
&quot;strict&quot; pragma.</p>

<p>Unicode in Perl on EBCDIC</p>

<p>The way Unicode is handled on EBCDIC platforms is still
experimental. On such platforms, references to UTF-8
encoding in this document and elsewhere should be read as
meaning the UTF-EBCDIC specified in Unicode Technical Report
16, unless ASCII vs. EBCDIC issues are specifically
discussed. There is no &quot;utfebcdic&quot; pragma or
&quot;:utfebcdic&quot; layer; rather, &quot;utf8&quot; and
&quot;:utf8&quot; are reused to mean the platform s
&quot;natural&quot; 8-bit encoding of Unicode. See
perlebcdic for more discussion of the issues.</p>

<p>Locales</p>

<p>Usually locale settings and Unicode do not affect each
other, but there are a couple of exceptions:</p>

<p>&middot; You can enable automatic UTF-8-ification of
your standard file han- dles, default &quot;open()&quot;
layer, and @ARGV by using either the &quot;-C&quot; command
line switch or the &quot;PERL_UNICODE&quot; environment
variable, see perlrun for the documentation of the
&quot;-C&quot; switch.</p>

<p>&middot; Perl tries really hard to work both with
Unicode and the old byte- oriented world. Most often this is
nice, but sometimes Perls straddling of the proverbial fence
causes problems.</p>

<p>When Unicode Does Not Happen</p>

<p>While Perl does have extensive ways to input and output
in Unicode, and few other entry points like the @ARGV which
can be interpreted as Unicode (UTF-8), there still are many
places where Unicode (in some encoding or another) could be
given as arguments or received as results, or both, but it
is not.</p>

<p>The following are such interfaces. For all of these
interfaces Perl currently (as of 5.8.3) simply assumes byte
strings both as arguments and results, or UTF-8 strings if
the &quot;encoding&quot; pragma has been used.</p>

<p>One reason why Perl does not attempt to resolve the role
of Unicode in this cases is that the answers are highly
dependent on the operating system and the file system(s).
For example, whether filenames can be in Unicode, and in
exactly what kind of encoding, is not exactly a portable
concept. Similarly for the qx and system: how well will the
command line interface (and which of them?) handle
Unicode?</p>

<p>&middot; chdir, chmod, chown, chroot, exec, link, lstat,
mkdir, rename, rmdir, stat, symlink, truncate, unlink,
utime, -X</p>

<p>&middot; %ENV</p>

<p>&middot; glob (aka the &lt;*&gt;)</p>

<p>&middot; open, opendir, sysopen</p>

<p>&middot; qx (aka the backtick operator), system</p>

<p>&middot; readdir, readlink</p>

<p>Forcing Unicode in Perl (Or Unforcing Unicode in
Perl)</p>

<p>Sometimes (see &quot;When Unicode Does Not Happen&quot;)
there are situations where you simply need to force Perl to
believe that a byte string is UTF-8, or vice versa. The
low-level calls utf8::upgrade($bytestring) and
utf8::downgrade($utf8string) are the answers.</p>

<p>Do not use them without careful thought, though: Perl
may easily get very confused, angry, or even crash, if you
suddenly change the nature of scalar like that. Especially
careful you have to be if you use the utf8::upgrade(): any
random byte string is not valid UTF-8.</p>

<p>Using Unicode in XS</p>

<p>If you want to handle Perl Unicode in XS extensions, you
may find the following C APIs useful. See also &quot;Unicode
Support&quot; in perlguts for an explanation about Unicode
at the XS level, and perlapi for the API details.</p>

<p>&middot; &quot;DO_UTF8(sv)&quot; returns true if the
&quot;UTF8&quot; flag is on and the bytes pragma is not in
effect. &quot;SvUTF8(sv)&quot; returns true is the
&quot;UTF8&quot; flag is on; the bytes pragma is ignored.
The &quot;UTF8&quot; flag being on does not mean that there
are any characters of code points greater than 255 (or 127)
in the scalar or that there are even any charac- ters in the
scalar. What the &quot;UTF8&quot; flag means is that the
sequence of octets in the representation of the scalar is
the sequence of UTF-8 encoded code points of the characters
of a string. The &quot;UTF8&quot; flag being off means that
each octet in this representation encodes a single character
with code point 0..255 within the string. Perls Unicode
model is not to use UTF-8 until it is absolutely
necessary.</p>

<p>&middot; &quot;uvuni_to_utf8(buf, chr)&quot; writes a
Unicode character code point into a buffer encoding the code
point as UTF-8, and returns a pointer pointing after the
UTF-8 bytes.</p>

<p>&middot; &quot;utf8_to_uvuni(buf, lenp)&quot; reads
UTF-8 encoded bytes from a buffer and returns the Unicode
character code point and, optionally, the length of the
UTF-8 byte sequence.</p>

<p>&middot; &quot;utf8_length(start, end)&quot; returns the
length of the UTF-8 encoded buffer in characters.
&quot;sv_len_utf8(sv)&quot; returns the length of the UTF-8
encoded scalar.</p>

<p>&middot; &quot;sv_utf8_upgrade(sv)&quot; converts the
string of the scalar to its UTF-8 encoded form.
&quot;sv_utf8_downgrade(sv)&quot; does the opposite, if
possible. &quot;sv_utf8_encode(sv)&quot; is like
sv_utf8_upgrade except that it does not set the
&quot;UTF8&quot; flag. &quot;sv_utf8_decode()&quot; does the
oppo- site of &quot;sv_utf8_encode()&quot;. Note that none
of these are to be used as general-purpose encoding or
decoding interfaces: &quot;use Encode&quot; for that.
&quot;sv_utf8_upgrade()&quot; is affected by the encoding
pragma but &quot;sv_utf8_downgrade()&quot; is not (since the
encoding pragma is designed to be a one-way street).</p>

<p>&middot; is_utf8_char(s) returns true if the pointer
points to a valid UTF-8 character.</p>

<p>&middot; &quot;is_utf8_string(buf, len)&quot; returns
true if &quot;len&quot; bytes of the buffer are valid
UTF-8.</p>

<p>&middot; &quot;UTF8SKIP(buf)&quot; will return the
number of bytes in the UTF-8 encoded character in the
buffer. &quot;UNISKIP(chr)&quot; will return the number of
bytes required to UTF-8-encode the Unicode character code
point. &quot;UTF8SKIP()&quot; is useful for example for
iterating over the characters of a UTF-8 encoded buffer;
&quot;UNISKIP()&quot; is useful, for example, in computing
the size required for a UTF-8 encoded buffer.</p>

<p>&middot; &quot;utf8_distance(a, b)&quot; will tell the
distance in characters between the two pointers pointing to
the same UTF-8 encoded buffer.</p>

<p>&middot; &quot;utf8_hop(s, off)&quot; will return a
pointer to an UTF-8 encoded buffer that is &quot;off&quot;
(positive or negative) Unicode characters displaced from the
UTF-8 buffer &quot;s&quot;. Be careful not to overstep the
buffer: &quot;utf8_hop()&quot; will merrily run off the end
or the beginning of the buffer if told to do so.</p>

<p>&middot; &quot;pv_uni_display(dsv, spv, len, pvlim,
flags)&quot; and &quot;sv_uni_dis- play(dsv, ssv, pvlim,
flags)&quot; are useful for debugging the output of Unicode
strings and scalars. By default they are useful only for
debugging--they display all characters as hexadecimal code
points--but with the flags &quot;UNI_DISPLAY_ISPRINT&quot;,
&quot;UNI_DIS- PLAY_BACKSLASH&quot;, and
&quot;UNI_DISPLAY_QQ&quot; you can make the output more
readable.</p>

<p>&middot; &quot;ibcmp_utf8(s1, pe1, u1, l1, u1, s2, pe2,
l2, u2)&quot; can be used to compare two strings
case-insensitively in Unicode. For case-sensi- tive
comparisons you can just use &quot;memEQ()&quot; and
&quot;memNE()&quot; as usual.</p>

<p>For more information, see perlapi, and utf8.c and utf8.h
in the Perl source code distribution.</p>

<p>BUGS Interaction with Locales</p>

<p>Use of locales with Unicode data may lead to odd
results. Currently, Perl attempts to attach 8-bit locale
info to characters in the range 0..255, but this technique
is demonstrably incorrect for locales that use characters
above that range when mapped into Unicode. Perls Uni- code
support will also tend to run slower. Use of locales with
Unicode is discouraged.</p>

<p>Interaction with Extensions</p>

<p>When Perl exchanges data with an extension, the
extension should be able to understand the UTF-8 flag and
act accordingly. If the extension doesn t know about the
flag, its likely that the extension will return
incorrectly-flagged data.</p>

<p>So if you re working with Unicode data, consult the
documentation of every module you re using if there are any
issues with Unicode data exchange. If the documentation does
not talk about Unicode at all, sus- pect the worst and
probably look at the source to learn how the module is
implemented. Modules written completely in Perl shouldn t
cause problems. Modules that directly or indirectly access
code written in other programming languages are at risk.</p>

<p>For affected functions, the simple strategy to avoid
data corruption is to always make the encoding of the
exchanged data explicit. Choose an encoding that you know
the extension can handle. Convert arguments passed to the
extensions to that encoding and convert results back from
that encoding. Write wrapper functions that do the
conversions for you, so you can later change the functions
when the extension catches up.</p>

<p>To provide an example, let s say the popular
Foo::Bar::escape_html function doesn t deal with Unicode
data yet. The wrapper function would convert the argument to
raw UTF-8 and convert the result back to Perls internal
representation like so:</p>

<p>sub my_escape_html ($) { my($what) = shift; return
unless defined $what;
Encode::decode_utf8(Foo::Bar::escape_html(Encode::encode_utf8($what)));
}</p>

<p>Sometimes, when the extension does not convert data but
just stores and retrieves them, you will be in a position to
use the otherwise dangerous Encode::_utf8_on() function. Let
s say the popular &quot;Foo::Bar&quot; extension, written in
C, provides a &quot;param&quot; method that lets you store
and retrieve data according to these prototypes:</p>

<p>$self-&gt;param($name, $value); # set a scalar $value =
$self-&gt;param($name); # retrieve a scalar</p>

<p>If it does not yet provide support for any encoding, one
could write a derived class with such a &quot;param&quot;
method:</p>

<p>sub param { my($self,$name,$value) = @_;
utf8::upgrade($name); # make sure it is UTF-8 encoded if
(defined $value) utf8::upgrade($value); # make sure it is
UTF-8 encoded return $self-&gt;SUPER::param($name,$value); }
else { my $ret = $self-&gt;SUPER::param($name);
Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
return $ret; } }</p>

<p>Some extensions provide filters on data entry/exit
points, such as DB_File::filter_store_key and family. Look
out for such filters in the documentation of your
extensions, they can make the transition to Uni- code data
much easier.</p>

<p>Speed</p>

<p>Some functions are slower when working on UTF-8 encoded
strings than on byte encoded strings. All functions that
need to hop over characters such as length(), substr() or
index(), or matching regular expressions can work much
faster when the underlying data are byte-encoded.</p>

<p>In Perl 5.8.0 the slowness was often quite spectacular;
in Perl 5.8.1 a caching scheme was introduced which will
hopefully make the slowness somewhat less spectacular, at
least for some operations. In general, operations with UTF-8
encoded strings are still slower. As an example, the Unicode
properties (character classes) like &quot;{Nd}&quot; are
known to be quite a bit slower (5-20 times) than their
simpler counterparts like &quot;&quot; (then again, there
268 Unicode characters matching &quot;Nd&quot; compared with
the 10 ASCII characters matching &quot;d&quot;).</p>

<p>Porting code from perl-5.6.X</p>

<p>Perl 5.8 has a different Unicode model from 5.6. In 5.6
the programmer was required to use the &quot;utf8&quot;
pragma to declare that a given scope expected to deal with
Unicode data and had to make sure that only Uni- code data
were reaching that scope. If you have code that is working
with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will
continue to work under 5.6, so you should be safe to try
them out.</p>

<p>&middot; A filehandle that should read or write
UTF-8</p>

<p>if ($] &gt; 5.007) { binmode $fh, &quot;:utf8&quot;;
}</p>

<p>&middot; A scalar that is going to be passed to some
extension</p>

<p>Be it Compress::Zlib, Apache::Request or any extension
that has no mention of Unicode in the manpage, you need to
make sure that the UTF-8 flag is stripped off. Note that at
the time of this writing (October 2002) the mentioned
modules are not UTF-8-aware. Please check the documentation
to verify if this is still true.</p>

<p>if ($] &gt; 5.007) { require Encode; $val =
Encode::encode_utf8($val); # make octets }</p>

<p>&middot; A scalar we got back from an extension</p>

<p>If you believe the scalar comes back as UTF-8, you will
most likely want the UTF-8 flag restored:</p>

<p>if ($] &gt; 5.007) { require Encode; $val =
Encode::decode_utf8($val); }</p>

<p>&middot; Same thing, if you are really sure it is
UTF-8</p>

<p>if ($] &gt; 5.007) { require Encode;
Encode::_utf8_on($val); }</p>

<p>&middot; A wrapper for fetchrow_array and
fetchrow_hashref</p>

<p>When the database contains only UTF-8, a wrapper
function or method is a convenient way to replace all your
fetchrow_array and fetchrow_hashref calls. A wrapper
function will also make it easier to adapt to future
enhancements in your database driver. Note that at the time
of this writing (October 2002), the DBI has no stan-
dardized way to deal with UTF-8 data. Please check the
documenta- tion to verify if that is still true.</p>

<p>sub fetchrow { my($self, $sth, $what) = @_; # $what is
one of fetchrow_{array,hashref} if ($] &lt; 5.007) { return
$sth-&gt;$what; } else { require Encode; if (wantarray) { my
@arr = $sth-&gt;$what; for (@arr) { defined &amp;&amp; /[^
00-177]/ &amp;&amp; Encode::_utf8_on($_); } return @arr; }
else { my $ret = $sth-&gt;$what; if (ref $ret) { for my $k
(keys %$ret) { defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_) for $ret-&gt;{$k}; } return $ret; }
else { defined &amp;&amp; /[^ 00-177]/ &amp;&amp;
Encode::_utf8_on($_) for $ret; return $ret; } } } }</p>

<p>&middot; A large scalar that you know can only contain
ASCII</p>

<p>Scalars that contain only ASCII and are marked as UTF-8
are some- times a drag to your program. If you recognize
such a situation, just remove the UTF-8 flag:</p>

<p>utf8::downgrade($val) if $] &gt; 5.007;</p>

<p>SEE ALSO perluniintro, encoding, Encode, open, utf8,
bytes, perlretut, &quot;${^UNI- CODE}&quot; in perlvar</p>

<p>perl v5.8.8 2014-02-11 PERLUNICODE(1)</p>
<hr>
</body>
</html>
