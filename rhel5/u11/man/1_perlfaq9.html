<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:30 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLFAQ9(1) Perl Programmers Reference Guide
PERLFAQ9(1)</p>

<p>NAME perlfaq9 - Networking ($Revision: 1.28 $, $Date:
2005/12/31 00:54:37 $)</p>

<p>DESCRIPTION This section deals with questions related to
networking, the internet, and a few on the web.</p>

<p>What is the correct form of response from a CGI
script?</p>

<p>(Alan Flavell &lt;flavell+www@a5.ph.gla.ac.uk&gt;
answers...)</p>

<p>The Common Gateway Interface (CGI) specifies a software
interface between a program (&quot;CGI script&quot;) and a
web server (HTTPD). It is not specific to Perl, and has its
own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi</p>

<p>The CGI specification is outlined in an informational
RFC: http://www.ietf.org/rfc/rfc3875</p>

<p>Other relevant documentation listed in:
http://www.perl.org/CGI_MetaFAQ.html</p>

<p>These Perl FAQs very selectively cover some CGI issues.
However, Perl programmers are strongly advised to use the
CGI.pm module, to take care of the details for them.</p>

<p>The similarity between CGI response headers (defined in
the CGI speci- fication) and HTTP response headers (defined
in the HTTP specification, RFC2616) is intentional, but can
sometimes be confusing.</p>

<p>The CGI specification defines two kinds of script: the
&quot;Parsed Header&quot; script, and the &quot;Non Parsed
Header&quot; (NPH) script. Check your server documentation
to see what it supports. &quot;Parsed Header&quot; scripts
are sim- pler in various respects. The CGI specification
allows any of the usual newline representations in the CGI
response (it s the servers job to create an accurate HTTP
response based on it). So &quot;0 written in text mode is
technically correct, and recommended. NPH scripts are more
tricky: they must put out a complete and accurate set of
HTTP transac- tion response headers; the HTTP specification
calls for records to be terminated with carriage-return and
line-feed, i.e ASCII 15 12 writ- ten in binary mode.</p>

<p>Using CGI.pm gives excellent platform independence,
including EBCDIC systems. CGI.pm selects an appropriate
newline representation ($CGI::CRLF) and sets binmode as
appropriate.</p>

<p>My CGI script runs from the command line but not the
browser. (500 Server Error)</p>

<p>Several things could be wrong. You can go through the
&quot;Troubleshooting Perl CGI scripts&quot; guide at</p>

<p>http://www.perl.org/troubleshooting_CGI.html</p>

<p>If, after that, you can demonstrate that you ve read the
FAQs and that your problem isn t something simple that can
be easily answered, youll probably receive a courteous and
useful reply to your question if you post it on
comp.infosystems.www.authoring.cgi (if its something to do
with HTTP or the CGI protocols). Questions that appear to be
Perl questions but are really CGI ones that are posted to
comp.lang.perl.misc are not so well received.</p>

<p>The useful FAQs, related documents, and troubleshooting
guides are listed in the CGI Meta FAQ:</p>

<p>http://www.perl.org/CGI_MetaFAQ.html</p>

<p>How can I get better error messages from a CGI
program?</p>

<p>Use the CGI::Carp module. It replaces &quot;warn&quot;
and &quot;die&quot;, plus the nor- mal Carp modules
&quot;carp&quot;, &quot;croak&quot;, and &quot;confess&quot;
functions with more verbose and safer versions. It still
sends them to the normal server error log.</p>

<p>use CGI::Carp; warn &quot;This is a complaint&quot;; die
&quot;But this one is serious&quot;;</p>

<p>The following use of CGI::Carp also redirects errors to
a file of your choice, placed in a BEGIN block to catch
compile-time warnings as well:</p>

<p>BEGIN { use CGI::Carp qw(carpout); open(LOG,
&quot;&gt;&gt;/var/local/cgi-logs/mycgi-log&quot;) or die
&quot;Unable to append to mycgi-log: $!0; carpout(*LOG);
}</p>

<p>You can even arrange for fatal errors to go back to the
client browser, which is nice for your own debugging, but
might confuse the end user.</p>

<p>use CGI::Carp qw(fatalsToBrowser); die &quot;Bad error
here&quot;;</p>

<p>Even if the error happens before you get the HTTP header
out, the mod- ule will try to take care of this to avoid the
dreaded server 500 errors. Normal warnings still go out to
the server error log (or wher- ever youve sent them with
&quot;carpout&quot;) with the application name and date
stamp prepended.</p>

<p>How do I remove HTML from a string?</p>

<p>The most correct way (albeit not the fastest) is to use
HTML::Parser from CPAN. Another mostly correct way is to use
HTML::FormatText which not only removes HTML but also
attempts to do a little simple format- ting of the resulting
plain text.</p>

<p>Many folks attempt a simple-minded regular expression
approach, like &quot;s/&lt;.*?&gt;//g&quot;, but that fails
in many cases because the tags may con- tinue over line
breaks, they may contain quoted angle-brackets, or HTML
comment may be present. Plus, folks forget to convert
entities--like &quot;&amp;lt;&quot; for example.</p>

<p>Heres one &quot;simple-minded&quot; approach, that works
for most files:</p>

<p>#!/usr/bin/perl -p0777
s/&lt;(?:[^&gt;&quot;]*([&quot;]).*?1)*&gt;//gs</p>

<p>If you want a more complete solution, see the 3-stage
striphtml program in
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
.</p>

<p>Here are some tricky cases that you should think about
when picking a solution:</p>

<p>&lt;IMG SRC = &quot;foo.gif&quot; ALT = &quot;A &gt;
B&quot;&gt;</p>

<p>&lt;IMG SRC = &quot;foo.gif&quot; ALT = &quot;A &gt;
B&quot;&gt;</p>

<p>&lt;!-- &lt;A comment&gt; --&gt;</p>

<p>&lt;script&gt;if (a&lt;b &amp;&amp;
a&gt;c)&lt;/script&gt;</p>

<p>&lt;# Just data #&gt;</p>

<p>&lt;![INCLUDE CDATA [
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ]]&gt;</p>

<p>If HTML comments include other tags, those solutions
would also break on text like this:</p>

<p>&lt;!-- This section commented out. &lt;B&gt;You cant
see me!&lt;/B&gt; --&gt;</p>

<p>How do I extract URLs?</p>

<p>You can easily extract all sorts of URLs from HTML with
&quot;HTML::Sim- pleLinkExtor&quot; which handles anchors,
images, objects, frames, and many other tags that can
contain a URL. If you need anything more complex, you can
create your own subclass of &quot;HTML::LinkExtor&quot; or
&quot;HTML::Parser&quot;. You might even use
&quot;HTML::SimpleLinkExtor&quot; as an exam- ple for
something specifically suited to your needs.</p>

<p>You can use URI::Find to extract URLs from an arbitrary
text document.</p>

<p>Less complete solutions involving regular expressions
can save you a lot of processing time if you know that the
input is simple. One solu- tion from Tom Christiansen runs
100 times faster than most module based approaches but only
extracts URLs from anchors where the first attribute is HREF
and there are no other attributes.</p>

<p>#!/usr/bin/perl -n00 # qxurl - tchrist@perl.com print
&quot;$20 while m{ &lt; A HREF = ([&quot;]) (.*?) 1 &gt;
}gsix;</p>

<p>How do I download a file from the uses machine? How do I
open a file on another machine?</p>

<p>In this case, download means to use the file upload
feature of HTML forms. You allow the web surfer to specify a
file to send to your web server. To you it looks like a
download, and to the user it looks like an upload. No matter
what you call it, you do it with whats known as
multipart/form-data encoding. The CGI.pm module (which comes
with Perl as part of the Standard Library) supports this in
the start_multi- part_form() method, which isnt the same as
the startform() method.</p>

<p>See the section in the CGI.pm documentation on file
uploads for code examples and details.</p>

<p>How do I make a pop-up menu in HTML?</p>

<p>Use the &lt;SELECT&gt; and &lt;OPTION&gt; tags. The
CGI.pm module (available from CPAN) supports this widget, as
well as many others, including some that it cleverly
synthesizes on its own.</p>

<p>How do I fetch an HTML file?</p>

<p>One approach, if you have the lynx text-based HTML
browser installed on your system, is this:</p>

<p>$html_code = lynx -source $url; $text_data = lynx -dump
$url;</p>

<p>The libwww-perl (LWP) modules from CPAN provide a more
powerful way to do this. They dont require lynx, but like
lynx, can still work through proxies:</p>

<p># simplest version use LWP::Simple; $content =
get($URL);</p>

<p># or print HTML from a URL use LWP::Simple; getprint
&quot;http://www.linpro.no/lwp/&quot;;</p>

<p># or print ASCII from HTML from a URL # also need
HTML-Tree package from CPAN use LWP::Simple; use
HTML::Parser; use HTML::FormatText; my ($html, $ascii);
$html = get(&quot;http://www.perl.com/&quot;); defined $html
or die &quot;Can t fetch HTML from
http://www.perl.com/&quot;; $ascii =
HTML::FormatText-&gt;new-&gt;format(parse_html($html));
print $ascii;</p>

<p>How do I automate an HTML form submission?</p>

<p>If you are doing something complex, such as moving
through many pages and forms or a web site, you can use
&quot;WWW::Mechanize&quot;. See its docu- mentation for all
the details.</p>

<p>If youre submitting values using the GET method, create
a URL and encode the form using the &quot;query_form&quot;
method:</p>

<p>use LWP::Simple; use URI::URL;</p>

<p>my $url = url(http://www.perl.com/cgi-bin/cpan_mod);
$url-&gt;query_form(module =&gt; DB_File, readme =&gt; 1);
$content = get($url);</p>

<p>If youre using the POST method, create your own user
agent and encode the content appropriately.</p>

<p>use HTTP::Request::Common qw(POST); use
LWP::UserAgent;</p>

<p>$ua = LWP::UserAgent-&gt;new(); my $req = POST
http://www.perl.com/cgi-bin/cpan_mod, [ module =&gt;
DB_File, readme =&gt; 1 ]; $content =
$ua-&gt;request($req)-&gt;as_string;</p>

<p>How do I decode or create those %-encodings on the
web?</p>

<p>If you are writing a CGI script, you should be using the
CGI.pm module that comes with perl, or some other equivalent
module. The CGI module automatically decodes queries for
you, and provides an escape() func- tion to handle
encoding.</p>

<p>The best source of detailed information on URI encoding
is RFC 2396. Basically, the following substitutions do
it:</p>

<p>s/([^1104</p>

<p>s/%([A-Fa-f]{2})/chr hex $1/eg; # decode
s/%([[:xdigit:]]{2})/chr hex $1/eg; # same thing</p>

<p>However, you should only apply them to individual URI
components, not the entire URI, otherwise you ll lose
information and generally mess things up. If that didnt
explain it, dont worry. Just go read sec- tion 2 of the RFC,
its probably the best explanation there is.</p>

<p>RFC 2396 also contains a lot of other useful
information, including a regexp for breaking any arbitrary
URI into components (Appendix B).</p>

<p>How do I redirect to another page?</p>

<p>Specify the complete URL of the destination (even if it
is on the same server). This is one of the two different
kinds of CGI &quot;Location:&quot; responses which are
defined in the CGI specification for a Parsed Head- ers
script. The other kind (an absolute URLpath) is resolved
internally to the server without any HTTP redirection. The
CGI specifications do not allow relative URLs in either
case.</p>

<p>Use of CGI.pm is strongly recommended. This example
shows redirection with a complete URL. This redirection is
handled by the web browser.</p>

<p>use CGI qw/:standard/;</p>

<p>my $url = http://www.cpan.org/; print
redirect($url);</p>

<p>This example shows a redirection with an absolute
URLpath. This redi- rection is handled by the local web
server.</p>

<p>my $url = /CPAN/index.html; print redirect($url);</p>

<p>But if coded directly, it could be as follows (the final
&quot;0 is shown separately, for clarity), using either a
complete URL or an absolute URLpath.</p>

<p>print &quot;Location: $url0; # CGI response header print
&quot;0; # end of headers</p>

<p>How do I put a password on my web pages?</p>

<p>To enable authentication for your web server, you need
to configure your web server. The configuration is different
for different sorts of web servers---apache does it
differently from iPlanet which does it differently from IIS.
Check your web server documentation for the details for your
particular server.</p>

<p>How do I edit my .htpasswd and .htgroup files with
Perl?</p>

<p>The HTTPD::UserAdmin and HTTPD::GroupAdmin modules
provide a consistent OO interface to these files, regardless
of how they re stored. Databases may be text, dbm, Berkeley
DB or any database with a DBI com- patible driver.
HTTPD::UserAdmin supports files used by the
&quot;Basic&quot; and &quot;Digest&quot; authentication
schemes. Heres an example:</p>

<p>use HTTPD::UserAdmin (); HTTPD::UserAdmin -&gt;new(DB
=&gt; &quot;/foo/.htpasswd&quot;) -&gt;add($username =&gt;
$password);</p>

<p>How do I make sure users cat enter values into a form
that cause my CGI script to do bad things?</p>

<p>See the security references listed in the CGI Meta
FAQ</p>

<p>http://www.perl.org/CGI_MetaFAQ.html</p>

<p>How do I parse a mail header?</p>

<p>For a quick-and-dirty solution, try this solution
derived from &quot;split&quot; in perlfunc:</p>

<p>$/ = ; $header = &lt;MSG&gt;; $header =~ s/0s+/ /g; #
merge continuation lines %head = ( UNIX_FROM_LINE, split
/^([-408</p>

<p>That solution doesnt do well if, for example, youre
trying to main- tain all the Received lines. A more complete
approach is to use the Mail::Header module from CPAN (part
of the MailTools package).</p>

<p>How do I decode a CGI form?</p>

<p>(contributed by brian d foy)</p>

<p>Use the CGI.pm module that comes with Perl. Its quick,
it s easy, and it actually does quite a bit of work to
ensure things happen correctly. It handles GET, POST, and
HEAD requests, multipart forms, multivalued fields, query
string and message body combinations, and many other things
you probably dont want to think about.</p>

<p>It doesnt get much easier: the CGI module automatically
parses the input and makes each value available through the
&quot;param()&quot; function.</p>

<p>use CGI qw(:standard);</p>

<p>my $total = param( price ) + param( shipping );</p>

<p>my @items = param( item ); # multiple values, same field
name</p>

<p>If you want an object-oriented approach, CGI.pm can do
that too.</p>

<p>use CGI;</p>

<p>my $cgi = CGI-&gt;new();</p>

<p>my $total = $cgi-&gt;param( price ) + $cgi-&gt;param(
shipping );</p>

<p>my @items = $cgi-&gt;param( item );</p>

<p>You might also try CGI::Minimal which is a lightweight
version of the same thing. Other CGI::* modules on CPAN
might work better for you, too.</p>

<p>Many people try to write their own decoder (or copy one
from another program) and then run into one of the many
&quot;gotchas&quot; of the task. Its much easier and less
hassle to use CGI.pm.</p>

<p>How do I check a valid mail address?</p>

<p>You cant, at least, not in real time. Bummer, eh?</p>

<p>Without sending mail to the address and seeing whether
theres a human on the other end to answer you, you cannot
determine whether a mail address is valid. Even if you apply
the mail header standard, you can have problems, because
there are deliverable addresses that arent RFC-822 (the mail
header standard) compliant, and addresses that arent
deliverable which are compliant.</p>

<p>You can use the Email::Valid or RFC::RFC822::Address
which check the format of the address, although they cannot
actually tell you if it is a deliverable address (i.e. that
mail to the address will not bounce). Modules like
Mail::CheckUser and Mail::EXPN try to interact with the
domain name system or particular mail servers to learn even
more, but their methods do not work everywhere---especially
for security con- scious administrators.</p>

<p>Many are tempted to try to eliminate many
frequently-invalid mail addresses with a simple regex, such
as &quot;/^[264 It s a very bad idea. However, this also
throws out many valid ones, and says nothing about potential
deliverability, so it is not sug- gested. Instead, see
http://www.cpan.org/authors/Tom_Chris-
tiansen/scripts/ckaddr.gz , which actually checks against
the full RFC spec (except for nested comments), looks for
addresses you may not wish to accept mail to (say, Bill
Clinton or your postmaster), and then makes sure that the
hostname given can be looked up in the DNS MX records. Its
not fast, but it works for what it tries to do.</p>

<p>Our best advice for verifying a persons mail address is
to have them enter their address twice, just as you normally
do to change a pass- word. This usually weeds out typos. If
both versions match, send mail to that address with a
personal message that looks somewhat like:</p>

<p>Dear someuser@host.com,</p>

<p>Please confirm the mail address you gave us Wed May 6
09:38:41 MDT 1998 by replying to this message. Include the
string &quot;Rumpelstiltskin&quot; in that reply, but
spelled in reverse; that is, start with &quot;Nik...&quot;.
Once this is done, your confirmed address will be entered
into our records.</p>

<p>If you get the message back and theyve followed your
directions, you can be reasonably assured that its real.</p>

<p>A related strategy thats less open to forgery is to give
them a PIN (personal ID number). Record the address and PIN
(best that it be a random one) for later processing. In the
mail you send, ask them to include the PIN in their reply.
But if it bounces, or the message is included via a
&quot;vacation&quot; script, itll be there anyway. So its
best to ask them to mail back a slight alteration of the
PIN, such as with the characters reversed, one added or
subtracted to each digit, etc.</p>

<p>How do I decode a MIME/BASE64 string?</p>

<p>The MIME-Base64 package (available from CPAN) handles
this as well as the MIME/QP encoding. Decoding BASE64
becomes as simple as:</p>

<p>use MIME::Base64; $decoded =
decode_base64($encoded);</p>

<p>The MIME-Tools package (available from CPAN) supports
extraction with decoding of BASE64 encoded attachments and
content directly from email messages.</p>

<p>If the string to decode is short (less than 84 bytes
long) a more direct approach is to use the unpack() function
s &quot;u&quot; format after minor transliterations:</p>

<p>tr#A-Za-z0-9+/##cd; # remove non-base64 chars
tr#A-Za-z0-9+/# -_#; # convert to uuencoded format $len =
pack(&quot;c&quot;, 32 + 0.75*length); # compute length byte
print unpack(&quot;u&quot;, $len . $_); # uudecode and
print</p>

<p>How do I return the uses mail address?</p>

<p>On systems that support getpwuid, the $&lt; variable,
and the Sys::Hostname module (which is part of the standard
perl distribution), you can probably try using something
like this:</p>

<p>use Sys::Hostname; $address = sprintf( %s@%s , scalar
getpwuid($&lt;), hostname);</p>

<p>Company policies on mail address can mean that this
generates addresses that the company s mail system will not
accept, so you should ask for users mail addresses when this
matters. Furthermore, not all systems on which Perl runs are
so forthcoming with this information as is Unix.</p>

<p>The Mail::Util module from CPAN (part of the MailTools
package) pro- vides a mailaddress() function that tries to
guess the mail address of the user. It makes a more
intelligent guess than the code above, using information
given when the module was installed, but it could still be
incorrect. Again, the best way is often just to ask the
user.</p>

<p>How do I send mail?</p>

<p>Use the &quot;sendmail&quot; program directly:</p>

<p>open(SENDMAIL, &quot;/usr/lib/sendmail -oi -t
-odq&quot;) or die &quot;Can t fork for sendmail: $!0; print
SENDMAIL &lt;&lt;&quot;EOF&quot;; From: User Originating
Mail &lt;me@host&gt; To: Final Destination
&lt;you@otherhost&gt; Subject: A relevant subject line</p>

<p>Body of the message goes here after the blank line in as
many lines as you like. EOF close(SENDMAIL) or warn
&quot;sendmail didn t close nicely&quot;;</p>

<p>The -oi option prevents sendmail from interpreting a
line consisting of a single dot as &quot;end of
message&quot;. The -t option says to use the head- ers to
decide who to send the message to, and -odq says to put the
mes- sage into the queue. This last option means your
message wont be immediately delivered, so leave it out if
you want immediate delivery.</p>

<p>Alternate, less convenient approaches include calling
mail (sometimes called mailx) directly or simply opening up
port 25 have having an intimate conversation between just
you and the remote SMTP daemon, probably sendmail.</p>

<p>Or you might be able use the CPAN module
Mail::Mailer:</p>

<p>use Mail::Mailer;</p>

<p>$mailer = Mail::Mailer-&gt;new(); $mailer-&gt;open({
From =&gt; $from_address, To =&gt; $to_address, Subject
=&gt; $subject, }) or die &quot;Cant open: $!0; print
$mailer $body; $mailer-&gt;close();</p>

<p>The Mail::Internet module uses Net::SMTP which is less
Unix-centric than Mail::Mailer, but less reliable. Avoid raw
SMTP commands. There are many reasons to use a mail
transport agent like sendmail. These include queuing, MX
records, and security.</p>

<p>How do I use MIME to make an attachment to a mail
message?</p>

<p>This answer is extracted directly from the MIME::Lite
documentation. Create a multipart message (i.e., one with
attachments).</p>

<p>use MIME::Lite;</p>

<p>### Create a new multipart message: $msg =
MIME::Lite-&gt;new( From =&gt;me@myhost.com, To
=&gt;you@yourhost.com, Cc =&gt;some@other.com,
some@more.com, Subject =&gt;A message with 2 parts..., Type
=&gt;multipart/mixed );</p>

<p>### Add parts (each &quot;attach&quot; has same
arguments as &quot;new&quot;): $msg-&gt;attach(Type
=&gt;TEXT, Data =&gt;&quot;Here s the GIF file you
wanted&quot; ); $msg-&gt;attach(Type =&gt;image/gif, Path
=&gt;aaa000123.gif, Filename =&gt;logo.gif );</p>

<p>$text = $msg-&gt;as_string;</p>

<p>MIME::Lite also includes a method for sending these
things.</p>

<p>$msg-&gt;send;</p>

<p>This defaults to using sendmail but can be customized to
use SMTP via Net::SMTP.</p>

<p>How do I read mail?</p>

<p>While you could use the Mail::Folder module from CPAN
(part of the MailFolder package) or the Mail::Internet
module from CPAN (part of the MailTools package), often a
module is overkill. Here s a mail sorter.</p>

<p>#!/usr/bin/perl</p>

<p>my(@msgs, @sub); my $msgno = -1; $/ = ; # paragraph
reads while (&lt;&gt;) { if (/^From /m) {
/^Subject:(?:Re:)*(.*)/mi; $sub[++$msgno] = lc($1) ; }
$msgs[$msgno] .= $_; } for my $i (sort { $sub[$a] cmp
$sub[$b] $a &lt;=&gt; $b } (0 .. $#msgs)) { print $msgs[$i];
}</p>

<p>Or more succinctly,</p>

<p>#!/usr/bin/perl -n00 # bysub2 - awkish sort-by-subject
BEGIN { $msgno = -1 } $sub[++$msgno] =
(/^Subject:(?:Re:)*(.*)/mi)[0] if /^From/m; $msg[$msgno] .=
$_; END { print @msg[ sort { $sub[$a] cmp $sub[$b] $a
&lt;=&gt; $b } (0 .. $#msg) ] }</p>

<p>How do I find out my hostname, domainname, or IP
address?</p>

<p>gethostbyname, Socket, Net::Domain, Sys::Hostname&quot;
(contributed by brian d foy)</p>

<p>The Net::Domain module, which is part of the standard
distribution starting in perl5.7.3, can get you the fully
qualified domain name (FQDN), the host name, or the domain
name.</p>

<p>use Net::Domain qw(hostname hostfqdn hostdomain);</p>

<p>my $host = hostfqdn();</p>

<p>The &quot;Sys::Hostname&quot; module, included in the
standard distribution since perl5.6, can also get the
hostname.</p>

<p>use Sys::Hostname;</p>

<p>$host = hostname();</p>

<p>To get the IP address, you can use the
&quot;gethostbyname&quot; built-in func- tion to turn the
name into a number. To turn that number into the dot- ted
octet form (a.b.c.d) that most people expect, use the
&quot;inet_ntoa&quot; function from the &lt;Socket&gt;
module, which also comes with perl.</p>

<p>use Socket;</p>

<p>my $address = inet_ntoa( scalar gethostbyname( $host
localhost ) );</p>

<p>How do I fetch a news article or the active
newsgroups?</p>

<p>Use the Net::NNTP or News::NNTPClient modules, both
available from CPAN. This can make tasks like fetching the
newsgroup list as simple as</p>

<p>perl -MNews::NNTPClient -e print
News::NNTPClient-&gt;new-&gt;list(&quot;newsgroups&quot;)</p>

<p>How do I fetch/put an FTP file?</p>

<p>LWP::Simple (available from CPAN) can fetch but not put.
Net::FTP (also available from CPAN) is more complex but can
put as well as fetch.</p>

<p>How can I do RPC in Perl?</p>

<p>(Contributed by brian d foy)</p>

<p>Use one of the RPC modules you can find on CPAN (
http://search.cpan.org/search?query=RPC&amp;mode=all ).</p>

<p>AUTHOR AND COPYRIGHT Copyright (c) 1997-2006 Tom
Christiansen, Nathan Torkington, and other authors as noted.
All rights reserved.</p>

<p>This documentation is free; you can redistribute it
and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in
this file are hereby placed into the public domain. You are
permitted and encouraged to use this code in your own
programs for fun or for profit as you see fit. A simple
comment in the code giving credit would be courteous but is
not required.</p>

<p>perl v5.8.8 2014-02-11 PERLFAQ9(1)</p>
<hr>
</body>
</html>
