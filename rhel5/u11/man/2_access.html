<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:05:58 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>ACCESS(2) Linux Programmer s Manual ACCESS(2)</p>

<p>NAME access - check users permissions for a file</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int access(const char *pathname, int mode);</p>

<p>DESCRIPTION access() checks whether the process would be
allowed to read, write or test for existence of the file (or
other file system object) whose name is pathname. If
pathname is a symbolic link permissions of the file referred
to by this symbolic link are tested.</p>

<p>mode is a mask consisting of one or more of R_OK, W_OK,
X_OK and F_OK.</p>

<p>R_OK, W_OK and X_OK request checking whether the file
exists and has read, write and execute permissions,
respectively. F_OK just requests checking for the existence
of the file.</p>

<p>The tests depend on the permissions of the directories
occurring in the path to the file, as given in pathname, and
on the permissions of directories and files referred to by
symbolic links encountered on the way.</p>

<p>The check is done with the processs real UID and GID,
rather than with the effective IDs as is done when actually
attempting an operation. This is to allow set-user-ID
programs to easily determine the invoking users
authority.</p>

<p>Only access bits are checked, not the file type or
contents. There- fore, if a directory is found to be
&quot;writable,&quot; it probably means that files can be
created in the directory, and not that the directory can be
written as a file. Similarly, a DOS file may be found to be
&quot;exe- cutable,&quot; but the execve(2) call will still
fail.</p>

<p>If the process has appropriate privileges, an
implementation may indi- cate success for X_OK even if none
of the execute file permission bits are set.</p>

<p>RETURN VALUE On success (all requested permissions
granted), zero is returned. On error (at least one bit in
mode asked for a permission that is denied, or some other
error occurred), -1 is returned, and errno is set appro-
priately.</p>

<p>ERRORS access() shall fail if:</p>

<p>EACCES The requested access would be denied to the file
or search per- mission is denied for one of the directories
in the path prefix of pathname. (See also
path_resolution(2).)</p>

<p>ELOOP Too many symbolic links were encountered in
resolving pathname.</p>

<p>ENAMETOOLONG pathname is too long.</p>

<p>ENOENT A directory component in pathname would have been
accessible but does not exist or was a dangling symbolic
link.</p>

<p>ENOTDIR A component used as a directory in pathname is
not, in fact, a directory.</p>

<p>EROFS Write permission was requested for a file on a
read-only filesystem.</p>

<p>access() may fail if:</p>

<p>EFAULT pathname points outside your accessible address
space.</p>

<p>EINVAL mode was incorrectly specified.</p>

<p>EIO An I/O error occurred.</p>

<p>ENOMEM Insufficient kernel memory was available.</p>

<p>ETXTBSY Write access was requested to an executable
which is being exe- cuted.</p>

<p>RESTRICTIONS access() returns an error if any of the
access types in the requested call fails, even if other
types might be successful.</p>

<p>access() may not work correctly on NFS file systems with
UID mapping enabled, because UID mapping is done on the
server and hidden from the client, which checks
permissions.</p>

<p>Using access() to check if a user is authorized to e.g.
open a file before actually doing so using open(2) creates a
security hole, because the user might exploit the short time
interval between checking and opening the file to manipulate
it.</p>

<p>CONFORMING TO SVr4, POSIX.1-2001, 4.3BSD</p>

<p>SEE ALSO chmod(2), chown(2), faccessat(2), open(2),
path_resolution(2), set- gid(2), setuid(2), stat(2)</p>

<p>Linux 2004-06-23 ACCESS(2)</p>
<hr>
</body>
</html>
