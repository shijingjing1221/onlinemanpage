<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:13:04 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>HSEARCH(3) Linux Programmer s Manual HSEARCH(3)</p>

<p>NAME hcreate, hdestroy, hsearch - hash table
management</p>

<p>SYNOPSIS #include &lt;search.h&gt;</p>

<p>int hcreate(size_t nel);</p>

<p>ENTRY *hsearch(ENTRY item, ACTION action);</p>

<p>void hdestroy(void);</p>

<p>#define _GNU_SOURCE #include &lt;search.h&gt;</p>

<p>int hcreate_r(size_t nel, struct hsearch_data *tab);</p>

<p>int hsearch_r(ENTRY item, ACTION action, ENTRY **ret,
struct hsearch_data *tab);</p>

<p>void hdestroy_r(struct hsearch_data *tab);</p>

<p>DESCRIPTION The three functions hcreate(), hsearch(),
and hdestroy() allow the user to create a hash table (only
one at a time) which associates a key with any data.</p>

<p>First the table must be created with the function
hcreate(). The argu- ment nel is an estimate of the maximum
number of entries in the table. The function hcreate() may
adjust this value upward to improve the per- formance of the
resulting hash table.</p>

<p>The corresponding function hdestroy() frees the memory
occupied by the hash table so that a new table can be
constructed.</p>

<p>The argument item is of type ENTRY, which is a typedef
defined in &lt;search.h&gt; and includes these elements:</p>

<p>typedef struct entry { char *key; void *data; }
ENTRY;</p>

<p>The field key points to the null-terminated string which
is the search key. The field data points to the data
associated with that key. The function hsearch() searches
the hash table for an item with the same key as item (where
&quot;the same&quot; is determined using strcmp(3)), and if
successful returns a pointer to it. The argument action
determines what hsearch() does after an unsuccessful search.
A value of ENTER instructs it to insert a copy of item,
while a value of FIND means to return NULL.</p>

<p>The three functions hcreate_r(), hsearch_r(),
hdestroy_r() are reen- trant versions that allow the use of
more than one table. The last argument used identifies the
table. The struct it points to must be zeroed before the
first call to hcreate_r().</p>

<p>RETURN VALUE hcreate() and hcreate_r() return 0 when
allocation of the memory for the hash table fails, non-zero
otherwise.</p>

<p>hsearch() returns NULL if action is ENTER and the hash
table is full, or action is FIND and item cannot be found in
the hash table.</p>

<p>hsearch_r() returns 0 if action is ENTER and the hash
table is full, and non-zero otherwise.</p>

<p>ERRORS POSIX documents</p>

<p>ENOMEM Out of memory.</p>

<p>The glibc implementation will return the following two
errors.</p>

<p>ENOMEM Table full with action set to ENTER.</p>

<p>ESRCH The action parameter is FIND and no corresponding
element is found in the table.</p>

<p>CONFORMING TO The functions hcreate(), hsearch(), and
hdestroy() are from SVr4, and are described in POSIX.1-2001.
The functions hcreate_r(), hsearch_r(), hdestroy_r() are GNU
extensions.</p>

<p>BUGS SVr4 and POSIX.1-2001 specify that action is
significant only for unsuccessful searches, so that an ENTER
should not do anything for a successful search. The libc and
glibc implementations update the data for the given key in
this case.</p>

<p>Individual hash table entries can be added, but not
deleted.</p>

<p>EXAMPLE The following program inserts 24 items in to a
hash table, then prints some of them.</p>

<p>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;
#include &lt;search.h&gt;</p>

<p>char *data[] = { &quot;alpha&quot;, &quot;bravo&quot;,
&quot;charlie&quot;, &quot;delta&quot;, &quot;echo&quot;,
&quot;foxtrot&quot;, &quot;golf&quot;, &quot;hotel&quot;,
&quot;india&quot;, &quot;juliet&quot;, &quot;kilo&quot;,
&quot;lima&quot;, &quot;mike&quot;, &quot;november&quot;,
&quot;oscar&quot;, &quot;papa&quot;, &quot;quebec&quot;,
&quot;romeo&quot;, &quot;sierra&quot;, &quot;tango&quot;,
&quot;uniform&quot;, &quot;victor&quot;, &quot;whisky&quot;,
&quot;x-ray&quot;, &quot;yankee&quot;, &quot;zulu&quot;
};</p>

<p>int main() { ENTRY e, *ep; int i;</p>

<p>/* starting with small table, and letting it grow does
not work */ hcreate(30); for (i = 0; i &lt; 24; i++) { e.key
= data[i]; /* data is just an integer, instead of a pointer
to something */ e.data = (void *)i; ep = hsearch(e, ENTER);
/* there should be no failures */ if (ep == NULL) {
fprintf(stderr, &quot;entry failed0); exit(1); } } for (i =
22; i &lt; 26; i++) { /* print two entries from the table,
and show that two are not in the table */ e.key = data[i];
ep = hsearch(e, FIND); printf(&quot;%9.9s -&gt; %9.9s:%d0,
e.key, ep ? ep-&gt;key : &quot;NULL&quot;, ep ?
(int)(ep-&gt;data) : 0); } return 0; }</p>

<p>SEE ALSO bsearch(3), lsearch(3), malloc(3),
tsearch(3)</p>

<p>GNU 2004-05-20 HSEARCH(3)</p>
<hr>
</body>
</html>
