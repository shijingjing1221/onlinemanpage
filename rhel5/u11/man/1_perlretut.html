<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:18:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>PERLRETUT(1) Perl Programmers Reference Guide
PERLRETUT(1)</p>

<p>NAME perlretut - Perl regular expressions tutorial</p>

<p>DESCRIPTION This page provides a basic tutorial on
understanding, creating and using regular expressions in
Perl. It serves as a complement to the reference page on
regular expressions perlre. Regular expressions are an
integral part of the &quot;m//&quot;, &quot;s///&quot;,
&quot;qr//&quot; and &quot;split&quot; operators and so this
tutorial also overlaps with &quot;Regexp Quote-Like
Operators&quot; in perlop and &quot;split&quot; in
perlfunc.</p>

<p>Perl is widely renowned for excellence in text
processing, and regular expressions are one of the big
factors behind this fame. Perl regular expressions display
an efficiency and flexibility unknown in most other computer
languages. Mastering even the basics of regular expressions
will allow you to manipulate text with surprising ease.</p>

<p>What is a regular expression? A regular expression is
simply a string that describes a pattern. Patterns are in
common use these days; exam- ples are the patterns typed
into a search engine to find web pages and the patterns used
to list files in a directory, e.g., &quot;ls *.txt&quot; or
&quot;dir *.*&quot;. In Perl, the patterns described by
regular expressions are used to search strings, extract
desired parts of strings, and to do search and replace
operations.</p>

<p>Regular expressions have the undeserved reputation of
being abstract and difficult to understand. Regular
expressions are constructed using simple concepts like
conditionals and loops and are no more difficult to
understand than the corresponding &quot;if&quot;
conditionals and &quot;while&quot; loops in the Perl
language itself. In fact, the main challenge in learning
regular expressions is just getting used to the terse
notation used to express these concepts.</p>

<p>This tutorial flattens the learning curve by discussing
regular expres- sion concepts, along with their notation,
one at a time and with many examples. The first part of the
tutorial will progress from the sim- plest word searches to
the basic regular expression concepts. If you master the
first part, you will have all the tools needed to solve
about 98% of your needs. The second part of the tutorial is
for those comfortable with the basics and hungry for more
power tools. It dis- cusses the more advanced regular
expression operators and introduces the latest cutting edge
innovations in 5.6.0.</p>

<p>A note: to save time, regular expression is often
abbreviated as reg- exp or regex. Regexp is a more natural
abbreviation than regex, but is harder to pronounce. The
Perl pod documentation is evenly split on regexp vs regex;
in Perl, there is more than one way to abbreviate it. Well
use regexp in this tutorial.</p>

<p>Part 1: The basics Simple word matching</p>

<p>The simplest regexp is simply a word, or more generally,
a string of characters. A regexp consisting of a word
matches any string that con- tains that word:</p>

<p>&quot;Hello World&quot; =~ /World/; # matches</p>

<p>What is this perl statement all about? &quot;Hello
World&quot; is a simple double quoted string.
&quot;World&quot; is the regular expression and the
&quot;//&quot; enclos- ing &quot;/World/&quot; tells perl to
search a string for a match. The operator &quot;=~&quot;
associates the string with the regexp match and produces a
true value if the regexp matched, or false if the regexp did
not match. In our case, &quot;World&quot; matches the second
word in &quot;Hello World&quot;, so the expression is true.
Expressions like this are useful in conditionals:</p>

<p>if (&quot;Hello World&quot; =~ /World/) { print &quot;It
matches0; } else { print &quot;It doesnt match0; }</p>

<p>There are useful variations on this theme. The sense of
the match can be reversed by using &quot;!~&quot;
operator:</p>

<p>if (&quot;Hello World&quot; !~ /World/) { print &quot;It
doesnt match0; } else { print &quot;It matches0; }</p>

<p>The literal string in the regexp can be replaced by a
variable:</p>

<p>$greeting = &quot;World&quot;; if (&quot;Hello
World&quot; =~ /$greeting/) { print &quot;It matches0; }
else { print &quot;It doesnt match0; }</p>

<p>If youre matching against the special default variable
$_, the &quot;$_ =~&quot; part can be omitted:</p>

<p>$_ = &quot;Hello World&quot;; if (/World/) { print
&quot;It matches0; } else { print &quot;It doesnt match0;
}</p>

<p>And finally, the &quot;//&quot; default delimiters for a
match can be changed to arbitrary delimiters by putting an
&rsquo;m&rsquo; out front:</p>

<p>&quot;Hello World&quot; =~ m!World!; # matches,
delimited by ! &quot;Hello World&quot; =~ m{World}; #
matches, note the matching {} &quot;/usr/bin/perl&quot; =~
m&quot;/perl&quot;; # matches after /usr/bin, # / becomes an
ordinary char</p>

<p>&quot;/World/&quot;, &quot;m!World!&quot;, and
&quot;m{World}&quot; all represent the same thing. When,
e.g., &quot;&quot; is used as a delimiter, the forward slash
&rsquo;/&rsquo; becomes an ordinary character and can be
used in a regexp without trouble.</p>

<p>Let s consider how different regexps would match
&quot;Hello World&quot;:</p>

<p>&quot;Hello World&quot; =~ /world/; # doesnt match
&quot;Hello World&quot; =~ /o W/; # matches &quot;Hello
World&quot; =~ /oW/; # doesnt match &quot;Hello World&quot;
=~ /World /; # doesnt match</p>

<p>The first regexp &quot;world&quot; doesnt match because
regexps are case-sensi- tive. The second regexp matches
because the substring &rsquo;o W&rsquo; occurs in the string
&quot;Hello World&quot; . The space character is treated
like any other character in a regexp and is needed to match
in this case. The lack of a space character is the reason
the third regexp &rsquo;oW&rsquo; doesnt match. The fourth
regexp &rsquo;World &rsquo; doesnt match because there is a
space at the end of the regexp, but not at the end of the
string. The lesson here is that regexps must match a part of
the string exactly in order for the statement to be
true.</p>

<p>If a regexp matches in more than one place in the
string, perl will always match at the earliest possible
point in the string:</p>

<p>&quot;Hello World&quot; =~ /o/; # matches o in Hello
&quot;That hat is red&quot; =~ /hat/; # matches hat in
That</p>

<p>With respect to character matching, there are a few more
points you need to know about. First of all, not all
characters can be used as is in a match. Some characters,
called metacharacters, are reserved for use in regexp
notation. The metacharacters are</p>

<p>{}[]()^$.*+? The significance of each of these will be
explained in the rest of the tutorial, but for now, it is
important only to know that a metacharac- ter can be matched
by putting a backslash before it:</p>

<p>&quot;2+2=4&quot; =~ /2+2/; # doesn t match, + is a
metacharacter &quot;2+2=4&quot; =~ /2+2/; # matches, + is
treated like an ordinary + &quot;The interval is
[0,1).&quot; =~ /[0,1)./ # is a syntax error! &quot;The
interval is [0,1).&quot; =~ / # matches
&quot;/usr/bin/perl&quot; =~ /usrbinperl/; # matches</p>

<p>In the last regexp, the forward slash &rsquo;/&rsquo; is
also backslashed, because it is used to delimit the regexp.
This can lead to LTS (leaning tooth- pick syndrome),
however, and it is often more readable to change delim-
iters.</p>

<p>&quot;/usr/bin/perl&quot; =~ m!/usr/bin/perl!; # easier
to read</p>

<p>The backslash character &rsquo;&acute; is a
metacharacter itself and needs to be backslashed:</p>

<p>C:WIN32 =~ /C:\WIN/; # matches</p>

<p>In addition to the metacharacters, there are some ASCII
characters which dont have printable character equivalents
and are instead repre- sented by escape sequences. Common
examples are &quot;&quot; for a tab, &quot;0 &quot; for a
carriage return and &quot;&quot; for a bell. for a newline,
&quot; If your string is better thought of as a sequence of
arbitrary bytes, the octal escape sequence, e.g., &quot;
33&quot;, or hexadecimal escape sequence, e.g.,
&quot;B&quot; may be a more natural representation for your
bytes. Here are some examples of escapes:</p>

<p>&quot;10002000&quot; =~ m(02) # matches
&quot;10000000&quot; =~ /000/ # matches &quot;10002000&quot;
=~ / 002/ # doesnt match, &quot;0&quot; ne &quot; 00&quot;
&quot;cat&quot; =~ /14314/ # matches, but a weird way to
spell cat</p>

<p>If youve been around Perl a while, all this talk of
escape sequences may seem familiar. Similar escape sequences
are used in double-quoted strings and in fact the regexps in
Perl are mostly treated as double- quoted strings. This
means that variables can be used in regexps as well. Just
like double-quoted strings, the values of the variables in
the regexp will be substituted in before the regexp is
evaluated for matching purposes. So we have:</p>

<p>$foo = house; housecat =~ /$foo/; # matches cathouse =~
/cat$foo/; # matches housecat =~ /${foo}cat/; # matches</p>

<p>So far, so good. With the knowledge above you can
already perform searches with just about any literal string
regexp you can dream up. Here is a very simple emulation of
the Unix grep program:</p>

<p>% cat &gt; simple_grep #!/usr/bin/perl $regexp = shift;
while (&lt;&gt;) { print if /$regexp/; } ^D</p>

<p>% chmod +x simple_grep</p>

<p>% simple_grep abba /usr/dict/words Babbage cabbage
cabbages sabbath Sabbathize Sabbathizes sabbatical scabbard
scabbards</p>

<p>This program is easy to understand.
&quot;#!/usr/bin/perl&quot; is the standard way to invoke a
perl program from the shell. &quot;$regexp = shift;&quot;
saves the first command line argument as the regexp to be
used, leaving the rest of the command line arguments to be
treated as files. &quot;while (&lt;&gt;)&quot; loops over
all the lines in all the files. For each line, &quot;print
if /$regexp/;&quot; prints the line if the regexp matches
the line. In this line, both &quot;print&quot; and
&quot;/$regexp/&quot; use the default vari- able $_
implicitly.</p>

<p>With all of the regexps above, if the regexp matched
anywhere in the string, it was considered a match.
Sometimes, however, we d like to specify where in the string
the regexp should try to match. To do this, we would use the
anchor metacharacters &quot;^&quot; and &quot;$&quot;. The
anchor &quot;^&quot; means match at the beginning of the
string and the anchor &quot;$&quot; means match at the end
of the string, or before a newline at the end of the string.
Here is how they are used:</p>

<p>&quot;housekeeper&quot; =~ /keeper/; # matches
&quot;housekeeper&quot; =~ /^keeper/; # doesnt match
&quot;housekeeper&quot; =~ /keeper$/; # matches
&quot;housekeeper0 =~ /keeper$/; # matches</p>

<p>The second regexp doesn t match because &quot;^&quot;
constrains &quot;keeper&quot; to match only at the beginning
of the string, but &quot;housekeeper&quot; has keeper
starting in the middle. The third regexp does match, since
the &quot;$&quot; constrains &quot;keeper&quot; to match
only at the end of the string.</p>

<p>When both &quot;^&quot; and &quot;$&quot; are used at
the same time, the regexp has to match both the beginning
and the end of the string, i.e., the regexp matches the
whole string. Consider</p>

<p>&quot;keeper&quot; =~ /^keep$/; # doesnt match
&quot;keeper&quot; =~ /^keeper$/; # matches &quot;&quot; =~
/^$/; # ^$ matches an empty string</p>

<p>The first regexp doesnt match because the string has
more to it than &quot;keep&quot;. Since the second regexp is
exactly the string, it matches. Using both &quot;^&quot; and
&quot;$&quot; in a regexp forces the complete string to
match, so it gives you complete control over which strings
match and which don t. Suppose you are looking for a fellow
named bert, off in a string by himself:</p>

<p>&quot;dogbert&quot; =~ /bert/; # matches, but not what
you want</p>

<p>&quot;dilbert&quot; =~ /^bert/; # doesnt match, but ..
&quot;bertram&quot; =~ /^bert/; # matches, so still not good
enough</p>

<p>&quot;bertram&quot; =~ /^bert$/; # doesnt match, good
&quot;dilbert&quot; =~ /^bert$/; # doesnt match, good
&quot;bert&quot; =~ /^bert$/; # matches, perfect</p>

<p>Of course, in the case of a literal string, one could
just as easily use the string equivalence &quot;$string eq
&rsquo;bert&rsquo;&quot; and it would be more efficient. The
&quot;^...$&quot; regexp really becomes useful when we add
in the more powerful regexp tools below.</p>

<p>Using character classes</p>

<p>Although one can already do quite a lot with the literal
string regexps above, we ve only scratched the surface of
regular expression technol- ogy. In this and subsequent
sections we will introduce regexp concepts (and associated
metacharacter notations) that will allow a regexp to not
just represent a single character sequence, but a whole
class of them.</p>

<p>One such concept is that of a character class. A
character class allows a set of possible characters, rather
than just a single charac- ter, to match at a particular
point in a regexp. Character classes are denoted by brackets
&quot;[...]&quot;, with the set of characters to be possibly
matched inside. Here are some examples:</p>

<p>/cat/; # matches cat /[bcr]at/; # matches bat, cat, or
rat /item[0123456789]/; # matches item0 or ... or item9
&quot;abc&quot; =~ /[cab]/; # matches a</p>

<p>In the last statement, even though &rsquo;c&rsquo; is
the first character in the class, &rsquo;a&rsquo; matches
because the first character position in the string is the
earliest point at which the regexp can match.</p>

<p>/[yY][eE][sS]/; # match yes in a case-insensitive way #
yes, Yes, YES, etc.</p>

<p>This regexp displays a common task: perform a
case-insensitive match. Perl provides away of avoiding all
those brackets by simply appending an &rsquo;i&rsquo; to the
end of the match. Then &quot;/[yY][eE][sS]/;&quot; can be
rewrit- ten as &quot;/yes/i;&quot;. The &rsquo;i&rsquo;
stands for case-insensitive and is an exam- ple of a
modifier of the matching operation. We will meet other modi-
fiers later in the tutorial.</p>

<p>We saw in the section above that there were ordinary
characters, which represented themselves, and special
characters, which needed a back- slash &quot; class, but the
sets of ordinary and special characters inside a charac- ter
class are different than those outside a character class.
The spe- cial characters for a character class are
&quot;-]$&quot;. &quot;]&quot; is special because it denotes
the end of a character class. &quot;$&quot; is special
because it denotes a scalar variable. &quot; used in escape
sequences, just like above. Here is how the special
characters &quot;]$</p>

<p>/[]c]def/; # matches ]def or cdef $x = bcr; /[$x]at/; #
matches bat, cat, or rat /[]at/; # matches $at or xat
/[\$x]at/; # matches t, bat, cat, or rat</p>

<p>The last two are a little tricky. in &quot;[]&quot;, the
backslash protects the dollar sign, so the character class
has two members &quot;$&quot; and &quot;x&quot;. In
&quot;[\$x]&quot;, the backslash is protected, so $x is
treated as a variable and substituted in double quote
fashion.</p>

<p>The special character &rsquo;-&rsquo; acts as a range
operator within character classes, so that a contiguous set
of characters can be written as a range. With ranges, the
unwieldy &quot;[0123456789]&quot; and
&quot;[abc...xyz]&quot; become the svelte &quot;[0-9]&quot;
and &quot;[a-z]&quot;. Some examples are</p>

<p>/item[0-9]/; # matches item0 or ... or item9
/[0-9bx-z]aa/; # matches 0aa, ..., 9aa, # baa, xaa, yaa, or
zaa /[0-9a-fA-F]/; # matches a hexadecimal digit
/[0-9a-zA-Z_]/; # matches a &quot;word&quot; character, #
like those in a perl variable name</p>

<p>If &rsquo;-&rsquo; is the first or last character in a
character class, it is treated as an ordinary character;
&quot;[-ab]&quot;, &quot;[ab-]&quot; and
&quot;[a&minus;b]&quot; are all equivalent.</p>

<p>The special character &quot;^&quot; in the first
position of a character class denotes a negated character
class, which matches any character but those in the
brackets. Both &quot;[...]&quot; and &quot;[^...]&quot; must
match a charac- ter, or the match fails. Then</p>

<p>/[^a]at/; # doesnt match aat or at, but matches # all
other bat, cat, 0at, %at, etc. /[^0-9]/; # matches a
non-numeric character /[a^]at/; # matches aat or ^at; here ^
is ordinary</p>

<p>Now, even &quot;[0-9]&quot; can be a bother the write
multiple times, so in the interest of saving keystrokes and
making regexps more readable, Perl has several abbreviations
for common character classes:</p>

<p>&middot; is a digit and represents [0-9]</p>

<p>0f] &middot; is a whitespace character and represents
[</p>

<p>&middot; 48a word character (alphanumeric or _) and
represents [0-9a-zA-Z_]</p>

<p>&middot; a negated ; it represents any character but a
digit [^0-9]</p>

<p>&middot; is a negated t represents any non-whitespace
character [^ &middot; W is a negated 984</p>

<p>&middot; The period . matches any character but
&quot;0</p>

<p>The &quot; <small>88 character classes. Here are some in
use:</small></p>

<p><small>/::/; # matches a hh:mm:ss time format /[ #
matches any digit or whitespace character /96 # non-word
char, followed by a word char /..rt/; # matches any two
chars, followed by rt /end./; # matches end. /end[.]/; #
same thing, matches end.</small></p>

<p><small>Because a period is a metacharacter, it needs to
be escaped to match as an ordinary period. Because, for
example, &quot;&quot; and &quot;288 characters, it is
incorrect to think of &quot;[^480 DeMorgans
laws.</small></p>

<p><small>. T An anchor useful in basic regexps is the w
word anchor &quot;h i s matches a boundary between a word
character and a non-word character &quot;14424</small></p>

<p><small>$x = &quot;Housecat catenates house and
cat&quot;; $x =~ /cat/; # matches cat in housecat a t / ; $x
=~ /# hes cat in catenates m a t ; # m a t c h e s c a $x =~
/catt i n h o u s e c a t a $x =~ /t</small></p>

<p><small>Note in the last example, the end of the string
is considered a word boundary.</small></p>

<p><small>You might wonder why &rsquo;.&rsquo; matches
everything but &quot;0 - why not every character? The reason
is that often one is matching against lines and would like
to ignore the newline characters. For instance, while the
string &quot;0 represents one line, we would like to think
of as empty. Then</small></p>

<p><small>&quot;&quot; =~ /^$/; # matches &quot;0 =~ /^$/;
# matches, &quot;0 is ignored</small></p>

<p><small>&quot;&quot; =~ /./; # doesnt match; it needs a
char &quot;&quot; =~ /^.$/; # doesnt match; it needs a char
&quot;0 =~ /^.$/; # doesnt match; it needs a char other than
&quot;0 &quot;a&quot; =~ /^.$/; # matches &quot;a0 =~ /^.$/;
# matches, ignores the &quot;0</small></p>

<p><small>This behavior is convenient, because we usually
want to ignore newlines when we count and match characters
in a line. Sometimes, however, we want to keep track of
newlines. We might even want &quot;^&quot; and &quot;$&quot;
to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the
string. Perl allows us to choose between ignoring and paying
attention to newlines by using the &quot;//s&quot; and
&quot;//m&quot; modifiers. &quot;//s&quot; and
&quot;//m&quot; stand for single line and multi- line and
they determine whether a string is to be treated as one con-
tinuous string, or as a set of lines. The two modifiers
affect two aspects of how the regexp is interpreted: 1) how
the &rsquo;.&rsquo; character class is defined, and 2) where
the anchors &quot;^&quot; and &quot;$&quot; are able to
match. Here are the four possible combinations:</small></p>

<p><small>&middot; no modifiers (//): Default behavior.
&rsquo;.&rsquo; matches any character except &quot;0.
&quot;^&quot; matches only at the beginning of the string
and &quot;$&quot; matches only at the end or before a
newline at the end.</small></p>

<p><small>&middot; s modifier (//s): Treat string as a
single long line. &rsquo;.&rsquo; matches any character,
even &quot;0. &quot;^&quot; matches only at the beginning of
the string and &quot;$&quot; matches only at the end or
before a newline at the end.</small></p>

<p><small>&middot; m modifier (//m): Treat string as a set
of multiple lines. &rsquo;.&rsquo; matches any character
except &quot;0. &quot;^&quot; and &quot;$&quot; are able to
match at the start or end of _ any line within the
string.</small></p>

<p><small>&middot; both s and m modifiers (//sm): Treat
string as a single long line, but detect multiple lines.
&rsquo;.&rsquo; matches any character, even &quot;0.
&quot;^&quot; and &quot;$&quot;, however, are able to match
at the start or end of _any line within the
string.</small></p>

<p><small>Here are examples of &quot;//s&quot; and
&quot;//m&quot; in action:</small></p>

<p><small>$x = &quot;There once was a girl0ho programmed in
Perl0;</small></p>

<p><small>$x =~ /^Who/; # doesnt match, &quot;Who&quot; not
at start of string $x =~ /^Who/s; # doesnt match,
&quot;Who&quot; not at start of string $x =~ /^Who/m; #
matches, &quot;Who&quot; at start of second line $x =~
/^Who/sm; # matches, &quot;Who&quot; at start of second
line</small></p>

<p><small>$x =~ /girl.Who/; # doesnt match, &quot;.&quot;
doesnt match &quot;0 $x =~ /girl.Who/s; # matches,
&quot;.&quot; matches &quot;0 $x =~ /girl.Who/m; # doesnt
match, &quot;.&quot; doesn t match &quot;0 $x =~
/girl.Who/sm; # matches, &quot;.&quot; matches
&quot;0</small></p>

<p><small>Most of the time, the default behavior is what is
want, but &quot;//s&quot; and &quot;//m&quot; are
occasionally very useful. If &quot;//m&quot; is being used,
the start of the string can still be matched with &quot;0
still be matched with the anchors &quot; (matches both the
endbefore,and thnewline like &quot;$&quot;), and
&quot;&quot; (matches only the end):</small></p>

<p><small>$x =~ /^Who/m; # matches, &quot;Who&quot; at
start of second line $x =~ /0ho&quot; is not at start of
string</small></p>

<p><small>$x =~ /girl$/m; # matches, &quot;girl&quot; at
end of first line $x =~ /girlm; # doesnt match,
&quot;girl&quot; is not at end of string $x =~ /Perlm; #
matches, &quot;Perl&quot;=~is/Perlm;at newline#
doesntbeforematch,en$x &quot;Perl&quot; is not at end of
string</small></p>

<p><small>We now know how to create choices among classes
of characters in a reg- exp. What about choices among words
or character strings? Such choices are described in the next
section.</small></p>

<p><small>Matching this or that</small></p>

<p><small>Sometimes we would like to our regexp to be able
to match different possible words or character strings. This
is accomplished by using the alternation metacharacter
&quot;&quot;. To match &quot;dog&quot; or &quot;cat&quot;,
we form the regexp &quot;dog cat&quot;. As before, perl will
try to match the regexp at the earliest possible point in
the string. At each character position, perl will first try
to match the first alternative, &quot;dog&quot;. If
&quot;dog&quot; doesnt match, perl will then try the next
alternative, &quot;cat&quot;. If &quot;cat&quot; doesn t
match either, then the match fails and perl moves to the
next position in the string. Some examples:</small></p>

<p><small>&quot;cats and dogs&quot; =~ /catdogbird/; #
matches &quot;cat&quot; &quot;cats and dogs&quot; =~
/dogcatbird/; # matches &quot;cat&quot;</small></p>

<p><small>Even though &quot;dog&quot; is the first
alternative in the second regexp, &quot;cat&quot; is able to
match earlier in the string.</small></p>

<p><small>&quot;cats&quot; =~ /ccacatcats/; # matches
&quot;c&quot; &quot;cats&quot; =~ /catscatcac/; # matches
&quot;cats&quot;</small></p>

<p><small>Here, all the alternatives match at the first
string position, so the first alternative is the one that
matches. If some of the alternatives are truncations of the
others, put the longest ones first to give them a chance to
match.</small></p>

<p><small>&quot;cab&quot; =~ /abc/ # matches &quot;c&quot;
# /abc/ == /[abc]/</small></p>

<p><small>The last example points out that character
classes are like alterna- tions of characters. At a given
character position, the first alterna- tive that allows the
regexp match to succeed will be the one that
matches.</small></p>

<p><small>Grouping things and hierarchical
matching</small></p>

<p><small>Alternation allows a regexp to choose among
alternatives, but by itself it unsatisfying. The reason is
that each alternative is a whole reg- exp, but sometime we
want alternatives for just part of a regexp. For instance,
suppose we want to search for housecats or housekeepers. The
regexp &quot;housecat housekeeper&quot; fits the bill, but
is inefficient because we had to type &quot;house&quot;
twice. It would be nice to have parts of the regexp be
constant, like &quot;house&quot;, and some parts have
alternatives, like &quot;catkeeper&quot;.</small></p>

<p><small>The ggrouping metacharacters &quot;()&quot; solve
this problem. Grouping allows parts of a regexp to be
treated as a single unit. Parts of a regexp are grouped by
enclosing them in parentheses. Thus we could solve the
&quot;housecat housekeeper&quot; by forming the regexp as
&quot;house(cat keeper)&quot;. The regexp
&quot;house(catkeeper)&quot; means match &quot;house&quot;
followed by either &quot;cat&quot; or &quot;keeper&quot;.
Some more examples are</small></p>

<p><small>/(ab)b/; # matches ab or bb /(acb)b/; # matches
acb or bb /(^a b)c/; # matches ac at start of string or bc
anywhere /(a[bc])d/; # matches ad, bd, or cd</small></p>

<p><small>/house(cat)/; # matches either housecat or house
/house(cat(s) )/; # matches either housecats or housecat or
# house . Note groups can be nested.</small></p>

<p><small>/(1920)/; # match years 19xx, 20xx, or the Y2K
problem, xx &quot;20&quot; =~ /(1920)/; # matches the null
alternative (), # because 20 cant match</small></p>

<p><small>Alternations behave the same way in groups as out
of them: at a given string position, the leftmost
alternative that allows the regexp to match is taken. So in
the last example at the first string position,
&quot;20&quot; matches the second alternative, but there is
nothing left over to match the next two digits &quot;&quot;.
So perl moves on to the next alter- native, which is the
null alternative and that works, since &quot;20&quot; is two
digits.</small></p>

<p><small>The process of trying one alternative, seeing if
it matches, and moving on to the next alternative if it
doesn t, is called backtracking. The term backtracking comes
from the idea that matching a regexp is like a walk in the
woods. Successfully matching a regexp is like arriving at a
destination. There are many possible trailheads, one for
each string position, and each one is tried in order, left
to right. From each trailhead there may be many paths, some
of which get you there, and some which are dead ends. When
you walk along a trail and hit a dead end, you have to
backtrack along the trail to an earlier point to try another
trail. If you hit your destination, you stop immediately and
forget about trying all the other trails. You are
persistent, and only if you have tried all the trails from
all the trailheads and not arrived at your destination, do
you declare failure. To be concrete, here is a step-by-step
analysis of what perl does when it tries to match the
regexp</small></p>

<p><small>&quot;abcde&quot; =~
/(abdabc)(dfdde)/;</small></p>

<p><small>0 Start with the first letter in the string
a.</small></p>

<p><small>1 Try the first alternative in the first group
abd.</small></p>

<p><small>2 Match a followed by b. So far so
good.</small></p>

<p><small>3 d in the regexp doesnt match c in the string -
a dead end. So backtrack two characters and pick the second
alternative in the first group abc.</small></p>

<p><small>4 Match a followed by b followed by c. We are on
a roll and have satisfied the first group. Set $1 to
abc.</small></p>

<p><small>5 Move on to the second group and pick the first
alternative df.</small></p>

<p><small>6 Match the d.</small></p>

<p><small>7 f in the regexp doesnt match e in the string,
so a dead end. Backtrack one character and pick the second
alternative in the sec- ond group d.</small></p>

<p><small>8 d matches. The second grouping is satisfied, so
set $2 to d.</small></p>

<p><small>9 We are at the end of the regexp, so we are
done! We have matched abcd out of the string
&quot;abcde&quot;.</small></p>

<p><small>There are a couple of things to note about this
analysis. First, the third alternative in the second group
de also allows a match, but we stopped before we got to it -
at a given character position, leftmost wins. Second, we
were able to get a match at the first character posi- tion
of the string a. If there were no matches at the first posi-
tion, perl would move to the second character position b and
attempt the match all over again. Only when all possible
paths at all possible character positions have been
exhausted does perl give up and declare &quot;$string =~
/(abdabc)(dfdde)/;&quot; to be false.</small></p>

<p><small>Even with all this work, regexp matching happens
remarkably fast. To speed things up, during compilation
stage, perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a proces- sor cache. When
the code is executed, these opcodes can then run at full
throttle and search very quickly.</small></p>

<p><small>Extracting matches</small></p>

<p><small>The grouping metacharacters &quot;()&quot; also
serve another completely differ- ent function: they allow
the extraction of the parts of a string that matched. This
is very useful to find out what matched and for text
processing in general. For each grouping, the part that
matched inside goes into the special variables $1, $2, etc.
They can be used just as ordinary variables:</small></p>

<p><small># extract hours, minutes, seconds if ($time =~
/():():()/) { # match hh:mm:ss format $hours = $1; $minutes
= $2; $seconds = $3; }</small></p>

<p><small>Now, we know that in scalar context, &quot;$time
=~ /():():()/&quot; returns a true or false value. In list
context, however, it returns the list of matched values
&quot;($1,$2,$3)&quot;. So we could write the code more
compactly as</small></p>

<p><small># extract hours, minutes, seconds ($hours,
$minutes, $second) = ($time =~ /():():()/);</small></p>

<p><small>If the groupings in a regexp are nested, $1 gets
the group with the leftmost opening parenthesis, $2 the next
opening parenthesis, etc. For example, here is a complex
regexp and the matching variables indi- cated below
it:</small></p>

<p><small>/(ab(cdef)((gi)j))/; 1 2 34</small></p>

<p><small>so that if the regexp matched, e.g., $2 would
contain cd or ef. For convenience, perl sets $+ to the
string held by the highest numbered $1, $2, ... that got
assigned (and, somewhat related, $^N to the value of the $1,
$2, ... most-recently assigned; i.e. the $1, $2, ...
associated with the rightmost closing parenthesis used in
the match).</small></p>

<p><small>Closely associated with the matching variables
$1, $2, ... are the backreferences &quot;1&quot;,
&quot;2&quot;, ... . Backreferences are simply matching
variables that can be used _ inside a regexp. This is a
really nice fea- ture - what matches later in a regexp can
depend on what matched ear- lier in the regexp. Suppose we
wanted to look for doubled words in text, like the the . The
following regexp finds all 3-letter doubles with a space in
between:</small></p>

<p><small>/(24</small></p>

<p><small>The grouping assigns a value to 1, so that the
same 3 letter sequence is used for both parts. Here are some
words with repeated parts:</small></p>

<p><small>% simple_grep ^(24 beriberi booboo coco mama
murmur papa</small></p>

<p><small>The regexp has a single grouping which considers
4-letter combinations, then 3-letter combinations, etc. and
uses &quot;1&quot; to look for a repeat. Although $1 and
&quot;1&quot; represent the same thing, care should be taken
to use matched variables $1, $2, ... only outside a regexp
and backrefer- ences &quot;1&quot;, &quot;2&quot;, ... only
inside a regexp; not doing so may lead to surprising and/or
undefined results.</small></p>

<p><small>In addition to what was matched, Perl 5.6.0 also
provides the positions of what was matched with the
&quot;@-&quot; and &quot;@+&quot; arrays. &quot;$-[0]&quot;
is the posi- tion of the start of the entire match and $+[0]
is the position of the end. Similarly, &quot;$-[n]&quot; is
the position of the start of the $n match and $+[n] is the
position of the end. If $n is undefined, so are
&quot;$-[n]&quot; and $+[n]. Then this code</small></p>

<p><small>$x = &quot;Mmm...donut, thought Homer&quot;; $x
=~ /^(MmmYech)...(donutpeas)/; # matches foreach $expr
(1..$#-) { print &quot;Match $expr: ${$expr} at position
($-[$expr],$+[$expr])0; }</small></p>

<p><small>prints</small></p>

<p><small>Match 1: Mmm at position (0,3) Match 2: donut at
position (6,11)</small></p>

<p><small>Even if there are no groupings in a regexp, it is
still possible to find out what exactly matched in a string.
If you use them, perl will set $&lsquo; to the part of the
string before the match, will set $&amp; to the part of the
string that matched, and will set $&rsquo; to the part of
the string after the match. An example:</small></p>

<p><small>$x = &quot;the cat caught the mouse&quot;; $x =~
/cat/; # $ = the , $&amp; = cat, $ = caught the mouse $x =~
/the/; # $ = , $&amp; = the, $ = cat caught the
mouse</small></p>

<p><small>In the second match, &quot;$&lsquo; =
&rsquo;&rsquo;&quot; because the regexp matched at the first
character position in the string and stopped, it never saw
the second the. It is important to note that using $&lsquo;
and $&rsquo; slows down regexp matching quite a bit, and
$&amp; slows it down to a lesser extent, because if they are
used in one regexp in a program, they are generated for
&lt;all&gt; regexps in the program. So if raw performance is
a goal of your application, they should be avoided. If you
need them, use &quot;@-&quot; and &quot;@+&quot;
instead:</small></p>

<p><small>$ is the same as substr( $x, 0, $-[0] ) $&amp; is
the same as substr( $x, $-[0], $+[0]-$-[0] ) $ is the same
as substr( $x, $+[0] )</small></p>

<p><small>Matching repetitions</small></p>

<p><small>The examples in the previous section display an
annoying weakness. We were only matching 3-letter words, or
syllables of 4 letters or less. We d like to be able to
match words or syllables of any length, without writing out
tedious alternatives like &quot;24</small></p>

<p><small>This is exactly the problem the q quantifier
metacharacters &quot;?&quot;, &quot;*&quot;, &quot;+&quot;,
and &quot;{}&quot; were created for. They allow us to
determine the number of repeats of a portion of a regexp we
consider to be a match. Quanti- fiers are put immediately
after the character, character class, or grouping that we
want to specify. They have the following
meanings:</small></p>

<p><small>&middot; &quot;a?&quot; = match a 1 or 0
times</small></p>

<p><small>&middot; &quot;a*&quot; = match a 0 or more
times, i.e., any number of times</small></p>

<p><small>&middot; &quot;a+&quot; = match a 1 or more
times, i.e., at least once</small></p>

<p><small>&middot; &quot;a{n,m}&quot; = match at least
&quot;n&quot; times, but not more than &quot;m&quot;
times.</small></p>

<p><small>&middot; &quot;a{n,}&quot; = match at least
&quot;n&quot; or more times</small></p>

<p><small>&middot; &quot;a{n}&quot; = match exactly
&quot;n&quot; times</small></p>

<p><small>Here are some examples:</small></p>

<p><small>/[a-z]+*/; # match a lowercase word, at least
some space, and # any number of digits /(1152 /y(es)?/i; #
matches y, Y, or a case-insensitive yes $year =~ /{2,4}/; #
make sure year is at least 2 but not more # than 4 digits
$year =~ /{4}{2}/; # better match; throw out 3 digit dates
$year =~ /{2}({2})?/; # same thing written differently.
However, # this produces $1 and the other does
not.</small></p>

<p><small>% simple_grep ^(984 beriberi booboo coco mama
murmur papa</small></p>

<p><small>For all of these quantifiers, perl will try to
match as much of the string as possible, while still
allowing the regexp to succeed. Thus with
&quot;/a?.../&quot;, perl will first try to match the regexp
with the &quot;a&quot; present; if that fails, perl will try
to match the regexp without the &quot;a&quot; present. For
the quantifier &quot;*&quot;, we get the
following:</small></p>

<p><small>$x = &quot;the cat in the hat&quot;; $x =~
/^(.*)(cat)(.*)$/; # matches, # $1 = the # $2 = cat # $3 =
in the hat</small></p>

<p><small>Which is what we might expect, the match finds
the only &quot;cat&quot; in the string and locks onto it.
Consider, however, this regexp:</small></p>

<p><small>$x =~ /^(.*)(at)(.*)$/; # matches, # $1 = the cat
in the h # $2 = at # $3 = (0 matches)</small></p>

<p><small>One might initially guess that perl would find
the &quot;at&quot; in &quot;cat&quot; and stop there, but
that wouldnt give the longest possible string to the first
quantifier &quot;.*&quot;. Instead, the first quantifier
&quot;.*&quot; grabs as much of the string as possible while
still having the regexp match. In this example, that means
having the &quot;at&quot; sequence with the final
&quot;at&quot; in the string. The other important principle
illustrated here is that when there are two or more elements
in a regexp, the leftmost quanti- fier, if there is one,
gets to grab as much the string as possible, leaving the
rest of the regexp to fight over scraps. Thus in our exam-
ple, the first quantifier &quot;.*&quot; grabs most of the
string, while the sec- ond quantifier &quot;.*&quot; gets
the empty string. Quantifiers that grab as much of the
string as possible are called m maximal match or greedy
quan- tifiers.</small></p>

<p><small>When a regexp can match a string in several
different ways, we can use the principles above to predict
which way the regexp will match:</small></p>

<p><small>&middot; Principle 0: Taken as a whole, any
regexp will be matched at the earliest possible position in
the string.</small></p>

<p><small>&middot; Principle 1: In an alternation
&quot;abc...&quot;, the leftmost alternative that allows a
match for the whole regexp will be the one used.</small></p>

<p><small>&middot; Principle 2: The maximal matching
quantifiers &quot;?&quot;, &quot;*&quot;, &quot;+&quot; and
&quot;{n,m}&quot; will in general match as much of the
string as possible while still allowing the whole regexp to
match.</small></p>

<p><small>&middot; Principle 3: If there are two or more
elements in a regexp, the leftmost greedy quantifier, if
any, will match as much of the string as possible while
still allowing the whole regexp to match. The next leftmost
greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still
allowing the whole regexp to match. And so on, until all the
regexp elements are satisfied.</small></p>

<p><small>As we have seen above, Principle 0 overrides the
others - the regexp will be matched as early as possible,
with the other principles deter- mining how the regexp
matches at that earliest character position.</small></p>

<p><small>Here is an example of these principles in
action:</small></p>

<p><small>$x = &quot;The programming republic of
Perl&quot;; $x =~ /^(.+)(er)(.*)$/; # matches, # $1 = The
programming republic of Pe # $2 = r # $3 = l</small></p>

<p><small>This regexp matches at the earliest string
position, &rsquo;T&rsquo;. One might think that
&quot;e&quot;, being leftmost in the alternation, would be
matched, but &quot;r&quot; produces the longest string in
the first quantifier.</small></p>

<p><small>$x =~ /(m{1,2})(.*)$/; # matches, # $1 = mm # $2
= ing republic of Perl</small></p>

<p><small>Here, The earliest possible match is at the first
&rsquo;m&rsquo; in &quot;programming&quot;.
&quot;m{1,2}&quot; is the first quantifier, so it gets to
match a maximal &quot;mm&quot;.</small></p>

<p><small>$x =~ /.*(m{1,2})(.*)$/; # matches, # $1 = m # $2
= ing republic of Perl</small></p>

<p><small>Here, the regexp matches at the start of the
string. The first quanti- fier &quot;.*&quot; grabs as much
as possible, leaving just a single &rsquo;m&rsquo; for the
second quantifier &quot;m{1,2}&quot;.</small></p>

<p><small>$x =~ /(.?)(m{1,2})(.*)$/; # matches, # $1 = a #
$2 = mm # $3 = ing republic of Perl</small></p>

<p><small>Here, &quot;.?&quot; eats its maximal one
character at the earliest possible position in the string,
&rsquo;a&rsquo; in &quot;programming&quot;, leaving
&quot;m{1,2}&quot; the opportunity to match both
&quot;m&quot;s. Finally,</small></p>

<p><small>&quot;aXXXb&quot; =~ /(X*)/; # matches with $1
=</small></p>

<p><small>because it can match zero copies of
&rsquo;X&rsquo; at the beginning of the string. If you
definitely want to match at least one &rsquo;X&rsquo;, use
&quot;X+&quot;, not &quot;X*&quot;.</small></p>

<p><small>Sometimes greed is not good. At times, we would
like quantifiers to match a _minimal piece of string, rather
than a maximal piece. For this purpose, Larry Wall created
the m minimal match or non-greedy quanti- fiers
&quot;??&quot;,&quot;*?&quot;, &quot;+?&quot;, and
&quot;{}?&quot;. These are the usual quantifiers with a
&quot;?&quot; appended to them. They have the following
meanings:</small></p>

<p><small>&middot; &quot;a??&quot; = match a 0 or 1 times.
Try 0 first, then 1.</small></p>

<p><small>&middot; &quot;a*?&quot; = match a 0 or more
times, i.e., any number of times, but as few times as
possible</small></p>

<p><small>&middot; &quot;a+?&quot; = match a 1 or more
times, i.e., at least once, but as few times as
possible</small></p>

<p><small>&middot; &quot;a{n,m}?&quot; = match at least
&quot;n&quot; times, not more than &quot;m&quot; times, as
few times as possible</small></p>

<p><small>&middot; &quot;a{n,}?&quot; = match at least
&quot;n&quot; times, but as few times as
possible</small></p>

<p><small>&middot; &quot;a{n}?&quot; = match exactly
&quot;n&quot; times. Because we match exactly &quot;n&quot;
times, &quot;a{n}?&quot; is equivalent to &quot;a{n}&quot;
and is just there for nota- tional consistency.</small></p>

<p><small>Let s look at the example above, but with minimal
quantifiers:</small></p>

<p><small>$x = &quot;The programming republic of
Perl&quot;; $x =~ /^(.+?)(er)(.*)$/; # matches, # $1 = Th #
$2 = e # $3 = programming republic of Perl</small></p>

<p><small>The minimal string that will allow both the start
of the string &quot;^&quot; and the alternation to match is
&quot;Th&quot;, with the alternation &quot;e r&quot;
matching &quot;e&quot;. The second quantifier &quot;.*&quot;
is free to gobble up the rest of the string.</small></p>

<p><small>$x =~ /(m{1,2}?)(.*?)$/; # matches, # $1 = m # $2
= ming republic of Perl</small></p>

<p><small>The first string position that this regexp can
match is at the first &rsquo;m&rsquo; in
&quot;programming&quot;. At this position, the minimal
&quot;m{1,2}?&quot; matches just one &rsquo;m&rsquo;.
Although the second quantifier &quot;.*?&quot; would prefer
to match no characters, it is constrained by the
end-of-string anchor &quot;$&quot; to match the rest of the
string.</small></p>

<p><small>$x =~ /(.*?)(m{1,2}?)(.*)$/; # matches, # $1 =
The progra # $2 = m # $3 = ming republic of Perl</small></p>

<p><small>In this regexp, you might expect the first
minimal quantifier &quot;.*?&quot; to match the empty
string, because it is not constrained by a &quot;^&quot;
anchor to match the beginning of the word. Principle 0
applies here, however. Because it is possible for the whole
regexp to match at the start of the string, it _ will match
at the start of the string. Thus the first quantifier has to
match everything up to the first &quot;m&quot;. The second
minimal quantifier matches just one &quot;m&quot; and the
third quantifier matches the rest of the string.</small></p>

<p><small>$x =~ /(.??)(m{1,2})(.*)$/; # matches, # $1 = a #
$2 = mm # $3 = ing republic of Perl</small></p>

<p><small>Just as in the previous regexp, the first
quantifier &quot;.??&quot; can match earliest at position
&rsquo;a&rsquo;, so it does. The second quantifier is
greedy, so it matches &quot;mm&quot;, and the third matches
the rest of the string.</small></p>

<p><small>We can modify principle 3 above to take into
account non-greedy quanti- fiers:</small></p>

<p><small>&middot; Principle 3: If there are two or more
elements in a regexp, the leftmost greedy (non-greedy)
quantifier, if any, will match as much (little) of the
string as possible while still allowing the whole regexp to
match. The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string
remaining available to it as possible, while still allowing
the whole regexp to match. And so on, until all the regexp
elements are satisfied.</small></p>

<p><small>Just like alternation, quantifiers are also
susceptible to backtrack- ing. Here is a step-by-step
analysis of the example</small></p>

<p><small>$x = &quot;the cat in the hat&quot;; $x =~
/^(.*)(at)(.*)$/; # matches, # $1 = the cat in the h # $2 =
at # $3 = (0 matches)</small></p>

<p><small>0 Start with the first letter in the string
t.</small></p>

<p><small>1 The first quantifier .* starts out by matching
the whole string the cat in the hat.</small></p>

<p><small>2 a in the regexp element at doesnt match the end
of the string. Backtrack one character.</small></p>

<p><small>3 a in the regexp element at still doesnt match
the last letter of the string t, so backtrack one more
character.</small></p>

<p><small>4 Now we can match the a and the t.</small></p>

<p><small>5 Move on to the third element .*. Since we are
at the end of the string and .* can match 0 times, assign it
the empty string.</small></p>

<p><small>6 We are done!</small></p>

<p><small>Most of the time, all this moving forward and
backtracking happens quickly and searching is fast. There
are some pathological regexps, however, whose execution time
exponentially grows with the size of the string. A typical
structure that blows up in your face is of the
form</small></p>

<p><small>/(ab+)*/;</small></p>

<p><small>The problem is the nested indeterminate
quantifiers. There are many different ways of partitioning a
string of length n between the &quot;+&quot; and
&quot;*&quot;: one repetition with &quot;b+&quot; of length
n, two repetitions with the first &quot;b+&quot; length k
and the second with length n-k, m repetitions whose bits add
up to length n, etc. In fact there are an exponential number
of ways to partition a string as a function of length. A
regexp may get lucky and match early in the process, but if
there is no match, perl will try _ every possibility before
giving up. So be careful with nested &quot;*&quot;s,
&quot;{n,m}&quot;s, and &quot;+&quot; s. The book _
Mastering regular expres- sions by Jeffrey Friedl gives a
wonderful discussion of this and other efficiency
issues.</small></p>

<p><small>Building a regexp</small></p>

<p><small>At this point, we have all the basic regexp
concepts covered, so lets give a more involved example of a
regular expression. We will build a regexp that matches
numbers.</small></p>

<p><small>The first task in building a regexp is to decide
what we want to match and what we want to exclude. In our
case, we want to match both inte- gers and floating point
numbers and we want to reject any string that isnt a
number.</small></p>

<p><small>The next task is to break the problem down into
smaller problems that are easily converted into a
regexp.</small></p>

<p><small>The simplest case is integers. These consist of a
sequence of digits, with an optional sign in front. The
digits we can represent with &quot;+&quot; and the sign can
be matched with &quot;[+-]&quot;. Thus the integer regexp
is</small></p>

<p><small>/[+-]?+/; # matches integers</small></p>

<p><small>A floating point number potentially has a sign,
an integral part, a decimal point, a fractional part, and an
exponent. One or more of these parts is optional, so we need
to check out the different possi- bilities. Floating point
numbers which are in proper form include 123., 0.345, .34,
-1e6, and 25.4E-72. As with integers, the sign out front is
completely optional and can be matched by &quot;[+-]?&quot;.
We can see that if there is no exponent, floating point
numbers must have a deci- mal point, otherwise they are
integers. We might be tempted to model these with
&quot;*.*&quot;, but this would also match just a single
decimal point, which is not a number. So the three cases of
floating point number sans exponent are</small></p>

<p><small>/[+-]?+./; # 1., 321., etc. /[+-]?.+/; # .1,
.234, etc. /[+-]?+.+/; # 1.0, 30.56, etc.</small></p>

<p><small>These can be combined into a single regexp with a
three-way alterna- tion:</small></p>

<p><small>/[+-]?(+.++..+)/; # floating point, no
exponent</small></p>

<p><small>In this alternation, it is important to put
&rsquo;+.+&rsquo; before &rsquo;+.&rsquo;. If
&rsquo;+.&rsquo; were first, the regexp would happily match
that and ignore the fractional part of the
number.</small></p>

<p><small>Now consider floating point numbers with
exponents. The key observa- tion here is that _ both
integers and numbers with decimal points are allowed in
front of an exponent. Then exponents, like the overall sign,
are independent of whether we are matching numbers with or
with- out decimal points, and can be decoupled from the
mantissa. The overall form of the regexp now becomes
clear:</small></p>

<p><small>/^(optional sign)(integer f.p. mantissa)(optional
exponent)$/;</small></p>

<p><small>The exponent is an &quot;e&quot; or
&quot;E&quot;, followed by an integer. So the exponent
regexp is</small></p>

<p><small>/[eE][+-]?+/; # exponent</small></p>

<p><small>Putting all the parts together, we get a regexp
that matches numbers:</small></p>

<p><small>/^[+-]?(+.++..++)([eE][+-]?+)?$/; # Ta
da!</small></p>

<p><small>Long regexps like this may impress your friends,
but can be hard to decipher. In complex situations like
this, the &quot;//x&quot; modifier for a match is
invaluable. It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.
Using it, we can rewrite our extended regexp in the more
pleasing form</small></p>

<p><small>/^ [+-]? # first, match an optional sign ( # then
match integers or f.p. mantissas: +.+ # mantissa of the form
a.b +. # mantissa of the form a. .+ # mantissa of the form
.b + # integer of the form a ) ([eE][+-]?+)? # finally,
optionally match an exponent $/x;</small></p>

<p><small>If whitespace is mostly irrelevant, how does one
include space charac- ters in an extended regexp? The answer
is to backslash it &rsquo; &rsquo; or put it in a character
class &quot;[ ]&quot; . The same thing goes for pound signs,
use &quot; and the mantissa/integer, and we could add this
to our regexp as fol- lows:</small></p>

<p><small>/^ [+-]? * # first, match an optional sign *and
space* ( # then match integers or f.p. mantissas: +.+ #
mantissa of the form a.b +. # mantissa of the form a. .+ #
mantissa of the form .b + # integer of the form a )
([eE][+-]?+)? # finally, optionally match an exponent
$/x;</small></p>

<p><small>In this form, it is easier to see a way to
simplify the alternation. Alternatives 1, 2, and 4 all start
with &quot;+&quot;, so it could be factored out:</small></p>

<p><small>/^ [+-]? * # first, match an optional sign ( #
then match integers or f.p. mantissas: + # start out with a
... ( .* # mantissa of the form a.b or a. )? # ? takes care
of integers of the form a .+ # mantissa of the form .b )
([eE][+-]?+)? # finally, optionally match an exponent
$/x;</small></p>

<p><small>or written in the compact form,</small></p>

<p><small>/^[+-]? *(+(.*)?.+)([eE][+-]?+)?$/;</small></p>

<p><small>This is our final regexp. To recap, we built a
regexp by</small></p>

<p><small>&middot; specifying the task in
detail,</small></p>

<p><small>&middot; breaking down the problem into smaller
parts,</small></p>

<p><small>&middot; translating the small parts into
regexps,</small></p>

<p><small>&middot; combining the regexps,</small></p>

<p><small>&middot; and optimizing the final combined
regexp.</small></p>

<p><small>These are also the typical steps involved in
writing a computer pro- gram. This makes perfect sense,
because regular expressions are essen- tially programs
written a little computer language that specifies pat-
terns.</small></p>

<p><small>Using regular expressions in Perl</small></p>

<p><small>The last topic of Part 1 briefly covers how
regexps are used in Perl programs. Where do they fit into
Perl syntax?</small></p>

<p><small>We have already introduced the matching operator
in its default &quot;/reg- exp/&quot; and arbitrary
delimiter &quot;m!regexp!&quot; forms. We have used the
binding operator &quot;=~&quot; and its negation
&quot;!~&quot; to test for string matches. Associated with
the matching operator, we have discussed the single line
&quot;//s&quot;, multi-line &quot;//m&quot;,
case-insensitive &quot;//i&quot; and extended
&quot;//x&quot; modifiers.</small></p>

<p><small>There are a few more things you might want to
know about matching oper- ators. First, we pointed out
earlier that variables in regexps are substituted before the
regexp is evaluated:</small></p>

<p><small>$pattern = Seuss; while (&lt;&gt;) { print if
/$pattern/; }</small></p>

<p><small>This will print any lines containing the word
&quot;Seuss&quot;. It is not as efficient as it could be,
however, because perl has to re-evaluate $pattern each time
through the loop. If $pattern wont be changing over the
lifetime of the script, we can add the &quot;//o&quot;
modifier, which directs perl to only perform variable
substitutions once:</small></p>

<p><small>#!/usr/bin/perl # Improved simple_grep $regexp =
shift; while (&lt;&gt;) { print if /$regexp/o; # a good deal
faster }</small></p>

<p><small>If you change $pattern after the first
substitution happens, perl will ignore it. If you dont want
any substitutions at all, use the special delimiter
&quot;m&rsquo;&rsquo;&quot;:</small></p>

<p><small>@pattern = (Seuss); while (&lt;&gt;) { print if
m@pattern; # matches literal @pattern , not Seuss
}</small></p>

<p><small>&quot;m&rsquo;&rsquo;&quot; acts like single
quotes on a regexp; all other &quot;m&quot; delimiters act
like double quotes. If the regexp evaluates to the empty
string, the regexp in the _ last successful match is used
instead. So we have</small></p>

<p><small>&quot;dog&quot; =~ /d/; # d matches &quot;dogbert
=~ //; # this matches the d regexp used before</small></p>

<p><small>The final two modifiers &quot;//g&quot; and
&quot;//c&quot; concern multiple matches. The modifier
&quot;//g&quot; stands for global matching and allows the
matching oper- ator to match within a string as many times
as possible. In scalar context, successive invocations
against a string will have &quot;//g&quot; jump from match
to match, keeping track of position in the string as it goes
along. You can get or set the position with the
&quot;pos()&quot; function.</small></p>

<p><small>The use of &quot;//g&quot; is shown in the
following example. Suppose we have a string that consists of
words separated by spaces. If we know how many words there
are in advance, we could extract the words using
groupings:</small></p>

<p><small>$x = &quot;cat dog house&quot;; # 3 words $x =~
/^(24 # $1 = cat # $2 = dog # $3 = house</small></p>

<p><small>But what if we had an indeterminate number of
words? This is the sort of task &quot;//g&quot; was made
for. To extract all words, form the simple reg- exp
&quot;(960</small></p>

<p><small>while ($x =~ /(144 print &quot;Word is $1, ends
at position &quot;, pos $x, &quot;0; }</small></p>

<p><small>prints</small></p>

<p><small>Word is cat, ends at position 3 Word is dog, ends
at position 7 Word is house, ends at position 13</small></p>

<p><small>A failed match or changing the target string
resets the position. If you dont want the position reset
after failure to match, add the &quot;//c&quot;, as in
&quot;/regexp/gc&quot;. The current position in the string
is asso- ciated with the string, not the regexp. This means
that different strings have different positions and their
respective positions can be set or read
independently.</small></p>

<p><small>In list context, &quot;//g&quot; returns a list
of matched groupings, or if there are no groupings, a list
of matches to the whole regexp. So if we wanted just the
words, we could use</small></p>

<p><small>@words = ($x =~ /(408 # $word[0] = cat # $word[1]
= dog # $word[2] = house</small></p>

<p><small>Closely associated with the &quot;//g&quot;
modifier is the &quot;G&quot; anchor. The &quot;G&quot;
anchor matches at the point where the previous
&quot;//g&quot; match left off. &quot;G&quot; allows us to
easily do context-sensitive matching:</small></p>

<p><small>$metric = 1; # use metric units ... $x =
&lt;FILE&gt;; # read in measurement $x =~ /^([+-]?+)/g; #
get magnitude $weight = $1; if ($metric) { # error checking
print &quot;Units error!&quot; unless $x =~ /Gkg./g; } else
{ print &quot;Units error!&quot; unless $x =~ /Glbs./g; } $x
=~ /Gidgetsprocket)/g; # continue processing</small></p>

<p><small>The combination of &quot;//g&quot; and
&quot;G&quot; allows us to process the string a bit at a
time and use arbitrary Perl logic to decide what to do next.
Cur- rently, the &quot;G&quot; anchor is only fully
supported when used to anchor to the start of the
pattern.</small></p>

<p><small>&quot;G&quot; is also invaluable in processing
fixed length records with reg- exps. Suppose we have a
snippet of coding region DNA, encoded as base pair letters
&quot;ATCGTTGAAT...&quot; and we want to find all the stop
codons &quot;TGA&quot;. In a coding region, codons are
3-letter sequences, so we can think of the DNA snippet as a
sequence of 3-letter records. The naive regexp</small></p>

<p><small># expanded, this is &quot;ATC GTT GAA TGC AAA TGA
CAT GAC&quot; $dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;;
$dna =~ /TGA/;</small></p>

<p><small>doesn t work; it may match a &quot;TGA&quot;, but
there is no guarantee that the match is aligned with codon
boundaries, e.g., the substring &quot;GTT GAA&quot; gives a
match. A better solution is</small></p>

<p><small>while ($dna =~ /(48 print &quot;Got a TGA stop
codon at position &quot;, pos $dna, &quot;0; }</small></p>

<p><small>which prints</small></p>

<p><small>Got a TGA stop codon at position 18 Got a TGA
stop codon at position 23</small></p>

<p><small>Position 18 is good, but position 23 is bogus.
What happened?</small></p>

<p><small>The answer is that our regexp works well until we
get past the last real match. Then the regexp will fail to
match a synchronized &quot;TGA&quot; and start stepping
ahead one character position at a time, not what we want.
The solution is to use &quot;G&quot; to anchor the match to
the codon alignment:</small></p>

<p><small>while ($dna =~ /G(24 print &quot;Got a TGA stop
codon at position &quot;, pos $dna, &quot;0; }</small></p>

<p><small>This prints</small></p>

<p><small>Got a TGA stop codon at position 18</small></p>

<p><small>which is the correct answer. This example
illustrates that it is important not only to match what is
desired, but to reject what is not desired.</small></p>

<p><small>search and replace</small></p>

<p><small>Regular expressions also play a big role in s
search and replace opera- tions in Perl. Search and replace
is accomplished with the &quot;s///&quot; operator. The
general form is &quot;s/regexp/replacement/modifiers&quot;,
with everything we know about regexps and modifiers applying
in this case as well. The &quot;replacement&quot; is a Perl
double quoted string that replaces in the string whatever is
matched with the &quot;regexp&quot;. The operator
&quot;=~&quot; is also used here to associate a string with
&quot;s///&quot;. If matching against $_, the &quot;$_
=~&quot; can be dropped. If there is a match,
&quot;s///&quot; returns the number of substitutions made,
otherwise it returns false. Here are a few
examples:</small></p>

<p><small>$x = &quot;Time to feed the cat!&quot;; $x =~
s/cat/hacker/; # $x contains &quot;Time to feed the
hacker!&quot; if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
$more_insistent = 1; } $y = &quot;quoted words&quot;; $y =~
s/^(.*)$/$1/; # strip single quotes, # $y contains
&quot;quoted words&quot;</small></p>

<p><small>In the last example, the whole string was
matched, but only the part inside the single quotes was
grouped. With the &quot;s///&quot; operator, the matched
variables $1, $2, etc. are immediately available for use in
the replacement expression, so we use $1 to replace the
quoted string with just what was quoted. With the global
modifier, &quot;s///g&quot; will search and replace all
occurrences of the regexp in the string:</small></p>

<p><small>$x = &quot;I batted 4 for 4&quot;; $x =~
s/4/four/; # doesnt do it all: # $x contains &quot;I batted
four for 4&quot; $x = &quot;I batted 4 for 4&quot;; $x =~
s/4/four/g; # does it all: # $x contains &quot;I batted four
for four&quot;</small></p>

<p><small>If you prefer regex over regexp in this tutorial,
you could use the following program to replace
it:</small></p>

<p><small>% cat &gt; simple_replace #!/usr/bin/perl $regexp
= shift; $replacement = shift; while (&lt;&gt;) {
s/$regexp/$replacement/go; print; } ^D</small></p>

<p><small>% simple_replace regexp regex
perlretut.pod</small></p>

<p><small>In &quot;simple_replace&quot; we used the
&quot;s///g&quot; modifier to replace all occur- rences of
the regexp on each line and the &quot;s///o&quot; modifier
to compile the regexp only once. As with
&quot;simple_grep&quot;, both the &quot;print&quot; and the
&quot;s/$regexp/$replacement/go&quot; use $_
implicitly.</small></p>

<p><small>A modifier available specifically to search and
replace is the &quot;s///e&quot; evaluation modifier.
&quot;s///e&quot; wraps an &quot;eval{...}&quot; around the
replace- ment string and the evaluated result is substituted
for the matched substring. &quot;s///e&quot; is useful if
you need to do a bit of computation in the process of
replacing text. This example counts character frequen- cies
in a line:</small></p>

<p><small>$x = &quot;Bill the cat&quot;; $x =~
s/(.)/$chars{$1}++;$1/eg; # final $1 replaces char with
itself print &quot;frequency of $_ is $chars{$_}0 foreach
(sort {$chars{$b} &lt;=&gt; $chars{$a}} keys
%chars);</small></p>

<p><small>This prints</small></p>

<p><small>frequency of is 2 frequency of t is 2 frequency
of l is 2 frequency of B is 1 frequency of c is 1 frequency
of e is 1 frequency of h is 1 frequency of i is 1 frequency
of a is 1</small></p>

<p><small>As with the match &quot;m//&quot; operator,
&quot;s///&quot; can use other delimiters, such as
&quot;s!!!&quot; and &quot;s{}{}&quot;, and even
&quot;s{}//&quot;. If single quotes are used
&quot;s&rsquo;&rsquo;&rsquo;&quot;, then the regexp and
replacement are treated as single quoted strings and there
are no substitutions. &quot;s///&quot; in list context
returns the same thing as in scalar context, i.e., the
number of matches.</small></p>

<p><small>The split operator</small></p>

<p><small>The &quot;&quot;split&quot; function can also
optionally use a matching operator &quot;m//&quot; to split
a string. &quot;split /regexp/, string, limit&quot; splits
&quot;string&quot; into a list of substrings and returns
that list. The regexp is used to match the character
sequence that the &quot;string&quot; is split with respect
to. The &quot;limit&quot;, if present, constrains splitting
into no more than &quot;limit&quot; number of strings. For
example, to split a string into words, use</small></p>

<p><small>$x = &quot;Calvin and Hobbes&quot;; @words =
split /, $x; # $word[0] = Calvin # $word[1] = and # $word[2]
= Hobbes</small></p>

<p><small>If the empty regexp &quot;//&quot; is used, the
regexp always matches and the string is split into
individual characters. If the regexp has group- ings, then
list produced contains the matched substrings from the
groupings as well. For instance,</small></p>

<p><small>$x = &quot;/usr/bin/perl&quot;; @dirs = split
m!/!, $x; # $dirs[0] = # $dirs[1] = usr # $dirs[2] = bin #
$dirs[3] = perl @parts = split m!(/)!, $x; # $parts[0] = #
$parts[1] = / # $parts[2] = usr # $parts[3] = / # $parts[4]
= bin # $parts[5] = / # $parts[6] = perl</small></p>

<p><small>Since the first character of $x matched the
regexp, &quot;split&quot; prepended an empty initial element
to the list.</small></p>

<p><small>If you have read this far, congratulations! You
now have all the basic tools needed to use regular
expressions to solve a wide range of text processing
problems. If this is your first time through the tutorial,
why not stop here and play around with regexps a while...
Part 2 con- cerns the more esoteric aspects of regular
expressions and those con- cepts certainly arent needed
right at the start.</small></p>

<p><small>Part 2: Power tools OK, you know the basics of
regexps and you want to know more. If matching regular
expressions is analogous to a walk in the woods, then the
tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time. Most of the tools
in part 2 are anal- ogous to flare guns and satellite
phones. They arent used too often on a hike, but when we are
stuck, they can be invaluable.</small></p>

<p><small>What follows are the more advanced, less used, or
sometimes esoteric capabilities of perl regexps. In Part 2,
we will assume you are com- fortable with the basics and
concentrate on the new features.</small></p>

<p><small>More on characters, strings, and character
classes</small></p>

<p><small>There are a number of escape sequences and
character classes that we havent covered yet.</small></p>

<p><small>There are several escape sequences that convert
characters or strings between upper and lower case. &quot;nd
&quot;&quot; convert the next character to lower or upper
case, respectively:</small></p>

<p><small>$x = &quot;perl&quot;; $string =~ /$x/; # matches
Perl in $string $x = &quot;M(rs?s)\.&quot;; # note the
double backslash $string =~ //; # matches mr., mrs., and
ms.,</small></p>

<p><small>&quot;nd &quot;U&quot; converts a whole
substring, delimited by &quot;r &quot;U&quot; and
&quot;</small></p>

<p><small>$x = &quot;This word is in lower case:SHOUT $x =~
/shout/; # matches $x = &quot;I STILL KEYPUNCH CARDS FOR MY
360&quot; $x =~ /Ukeypunch/; # matches punch card
string</small></p>

<p><small>If there is no &quot; regexps &quot;$word&quot;
or &quot;ord&quot; convert the first character of $word to
uppercase and the rest of the characters to
lowercase.</small></p>

<p><small>Control characters can be escaped with &quot;
acter would be matched with &quot; quotes, or protects most
non-alphabetic characters. For instance,</small></p>

<p><small>$x = &quot;QThat !^*&amp;%~&amp; cat!&quot;; $x
=~ /Q!^*&amp;%~&amp;; # check for rough language</small></p>

<p><small>It does not protect &quot;$&quot; or
&quot;@&quot;, so that variables can still be substi-
tuted.</small></p>

<p><small>With the advent of 5.6.0, perl regexps can handle
more than just the standard ASCII character set. Perl now
supports U Unicode, a standard for encoding the character
sets from many of the worlds written lan- guages. Unicode
does this by allowing characters to be more than one byte
wide. Perl uses the UTF-8 encoding, in which ASCII
characters are still encoded as one byte, but characters
greater than &quot;chr(127)&quot; may be stored as two or
more bytes.</small></p>

<p><small>What does this mean for regexps? Well, regexp
users dont need to know much about perls internal
representation of strings. But they do need to know 1) how
to represent Unicode characters in a regexp and 2) when a
matching operation will treat the string to be searched as a
sequence of bytes (the old way) or as a sequence of Unicode
characters (the new way). The answer to 1) is that Unicode
characters greater than &quot;chr(127)&quot; may be
represented using the &quot;ex}&quot; notation, with
&quot;hex&quot; a hexadecimal integer:</small></p>

<p><small>/}/; # match a Unicode smiley face :)</small></p>

<p><small>Unicode characters in the range of 128-255 use
two hexadecimal digits with braces: &quot;b}&quot;. Note
that this is different than &quot;&quot;, which is just a
hexadecimal byte with no Unicode significance.</small></p>

<p><small>NOTE: in Perl 5.6.0 it used to be that one needed
to say &quot;use utf8&quot; to use any Unicode features.
This is no more the case: for almost all Unicode processing,
the explicit &quot;utf8&quot; pragma is not needed. (The
only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit &quot;use
utf8&quot; is needed.)</small></p>

<p><small>Figuring out the hexadecimal sequence of a
Unicode character you want or deciphering someone elses
hexadecimal Unicode regexp is about as much fun as
programming in machine code. So another way to specify
Unicode characters is to use the n named character escape
sequence &quot;ame}&quot;. &quot;name&quot; is a name for
the Unicode character, as specified in the Unicode standard.
For instance, if we wanted to represent or match the
astrological sign for the planet Mercury, we could
use</small></p>

<p><small>use charnames &quot;:full&quot;; # use named
chars with Unicode full names $x =
&quot;abcERCURY}def&quot;; $x =~ /ERCURY}/; #
matches</small></p>

<p><small>One can also use short names or restrict names to
a certain alphabet:</small></p>

<p><small>use charnames :full; print &quot;REEK SMALL
LETTER SIGMA} is called sigma.0;</small></p>

<p><small>use charnames &quot;:short&quot;; print
&quot;reek:Sigma} is an upper-case sigma.0;</small></p>

<p><small>use charnames qw(greek); print &quot;igma} is
Greek sigma0;</small></p>

<p><small>A list of full names is found in the file
Names.txt in the lib/perl5/5.X.X/unicore
directory.</small></p>

<p><small>The answer to requirement 2), as of 5.6.0, is
that if a regexp contains Unicode characters, the string is
searched as a sequence of Unicode characters. Otherwise, the
string is searched as a sequence of bytes. If the string is
being searched as a sequence of Unicode characters, but
matching a single byte is required, we can use the
&quot;escape sequence. &quot;is a character class akin to
&quot;.&quot; except that it matches any byte 0-255.
So</small></p>

<p><small>use charnames &quot;:full&quot;; # use named
chars with Unicode full names $x = &quot;a&quot;; $x =~ / #
matches a, eats one byte $x = &quot;&quot;; $x =~ / # doesnt
match, no bytes to match $x = &quot;ERCURY}&quot;; #
two-byte Unicode character $x =~ / # matches, but
dangerous!</small></p>

<p><small>The last regexp matches, but is dangerous because
the string _character position is no longer synchronized to
the string _ byte position. This generates the warning
Malformed UTF-8 character. The &quot;is best used for
matching the binary data in strings with binary data inter-
mixed with Unicode characters.</small></p>

<p><small>Let us now discuss the rest of the character
classes. Just as with Unicode characters, there are named
Unicode character classes repre- sented by the
&quot;{name}&quot; escape sequence. Closely associated is
the &quot;P{name}&quot; character class, which is the
negation of the &quot;{name}&quot; class. For example, to
match lower and uppercase characters,</small></p>

<p><small>use charnames &quot;:full&quot;; # use named
chars with Unicode full names $x = &quot;BOB&quot;; $x =~
/^{IsUpper}/; # matches, uppercase char class $x =~
/^P{IsUpper}/; # doesnt match, char class sans uppercase $x
=~ /^{IsLower}/; # doesnt match, lowercase char class $x =~
/^P{IsLower}/; # matches, char class sans
lowercase</small></p>

<p><small>Here is the association between some Perl named
classes and the tradi- tional Unicode classes:</small></p>

<p><small>Perl class name Unicode class name or regular
expression</small></p>

<p><small>IsAlpha /^[LM]/ IsAlnum /^[LMN]/ IsASCII $code
&lt;= 127 IsCntrl /^C/ IsBlank $code =~ /^(00200009)$/
/^Z[^lp]/ IsDigit Nd IsGraph /^([LMNPS]Co)/ IsLower Ll
IsPrint /^([LMNPS]CoZs)/ IsPunct /^P/ IsSpace /^Z/ ($code =~
/^(0009000A000B000C 000D)$/ IsSpacePerl /^Z/ ($code =~
/^(0009000A 000C 000D 008520282029)$/ IsUpper /^L[ut]/
IsWord /^[LMN]/ $code eq &quot;005F&quot; IsXDigit $code =~
/^00(3[0-9][46][1-6])$/</small></p>

<p><small>You can also use the official Unicode class names
with the &quot;&quot; and &quot;P&quot;, like
&quot;{L}&quot; for Unicode letters , or &quot;{Lu}&quot;
for uppercase letters, or &quot;P{Nd}&quot; for non-digits.
If a &quot;name&quot; is just one letter, the braces can be
dropped. For instance, &quot;M&quot; is the character class
of Unicode marks, for example accent marks. For the full
list see perlunicode.</small></p>

<p><small>The Unicode has also been separated into various
sets of characters which you can test with
&quot;{In...}&quot; (in) and &quot;P{In...}&quot; (not in),
for example &quot;{Latin}&quot;, &quot;{Greek}&quot;, or
&quot;P{Katakana}&quot;. For the full list see
perlunicode.</small></p>

<p><small>&quot; the Unicode combining character sequences.
A combining character sequence is a base character followed
by any number of combining char- acters. An example of a
combining character is an accent. Using the Unicode full
names, e.g., &quot;A + COMBINING RING&quot; is a combining
charac- ter sequence with base character &quot;A&quot; and
combining character &quot;COMBIN- ING RING&quot; , which
translates in Danish to A with the circle atop it, as in the
word Angstrom. &quot;PMM*}&quot;, i.e., a non- mark followed
by one or more marks.</small></p>

<p><small>For the full and latest information about Unicode
see the latest Uni- code standard, or the Unicode Consortium
s website http://www.uni- code.org/</small></p>

<p><small>As if all those classes werent enough, Perl also
defines POSIX style character classes. These have the form
&quot;[:name:]&quot;, with &quot;name&quot; the name of the
POSIX class. The POSIX classes are &quot;alpha&quot;,
&quot;alnum&quot;, &quot;ascii&quot;, &quot;cntrl&quot;,
&quot;digit&quot;, &quot;graph&quot;, &quot;lower&quot;,
&quot;print&quot;, &quot;punct&quot;, &quot;space&quot;,
&quot;upper&quot;, and &quot;xdigit&quot;, and two
extensions, &quot;word&quot; (a Perl extension to match
&quot;168blank&quot; (a GNU extension). If &quot;utf8&quot;
is being used, then these classes are defined the same as
their corresponding perl Unicode classes:
&quot;[:upper:]&quot; is the same as &quot;{IsUpper}&quot;,
etc. The POSIX character classes, however, don t require
using &quot;utf8&quot;. The &quot;[:digit:]&quot;,
&quot;[:word:]&quot;, and &quot;[:space:]&quot; correspond
to the familiar &quot;&quot;, &quot;144haracter classes. To
negate a POSIX class, put a &quot;^&quot; in front of the
name, so that, e.g., &quot;[:^digit:]&quot; corresponds to
&quot;utf8&quot;, &quot;P{IsDigit}&quot;. The Unicode and
POSIX character classes can be used just like &quot;&quot;,
with the exception that POSIX char- acter classes can only
be used inside of a character class:</small></p>

<p><small>/bc[:digit:]xyz]/; # match a,b,c,x,y,z, or a
digit /^=item:digit:]]/; # match =item, # followed by a
space and a digit use charnames &quot;:full&quot;;
/bc{IsDigit}xyz]; # match a,b,c,x,y,z, or a digit
/^=itemIsDigit}/; # match =item, # followed by a space and a
digit</small></p>

<p><small>Whew! That is all the rest of the characters and
character classes.</small></p>

<p><small>Compiling and saving regular
expressions</small></p>

<p><small>In Part 1 we discussed the &quot;//o&quot;
modifier, which compiles a regexp just once. This suggests
that a compiled regexp is some data structure that can be
stored once and used again and again. The regexp quote
&quot;qr//&quot; does exactly that: &quot;qr/string/&quot;
compiles the &quot;string&quot; as a regexp and transforms
the result into a form that can be assigned to a
variable:</small></p>

<p><small>$reg = qr/foo+bar?/; # reg contains a compiled
regexp</small></p>

<p><small>Then $reg can be used as a regexp:</small></p>

<p><small>$x = &quot;fooooba&quot;; $x =~ $reg; # matches,
just like /foo+bar?/ $x =~ /$reg/; # same thing, alternate
form</small></p>

<p><small>$reg can also be interpolated into a larger
regexp:</small></p>

<p><small>$x =~ /(abc)?$reg/; # still matches</small></p>

<p><small>As with the matching operator, the regexp quote
can use different delimiters, e.g., &quot;qr!!&quot;,
&quot;qr{}&quot; and &quot;qr~~&quot;. The single quote
delim- iters &quot;qr&rsquo;&rsquo;&quot; prevent any
interpolation from taking place.</small></p>

<p><small>Pre-compiled regexps are useful for creating
dynamic matches that dont need to be recompiled each time
they are encountered. Using pre-com- piled regexps,
&quot;simple_grep&quot; program can be expanded into a
program that matches multiple patterns:</small></p>

<p><small>% cat &gt; multi_grep #!/usr/bin/perl #
multi_grep - match any of &lt;number&gt; regexps # usage:
multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2
...</small></p>

<p><small>$number = shift; $regexp[$_] = shift foreach
(0..$number-1); @compiled = map qr/$_/, @regexp; while
($line = &lt;&gt;) { foreach $pattern (@compiled) { if
($line =~ /$pattern/) { print $line; last; # we matched, so
move onto the next line } } } ^D</small></p>

<p><small>% multi_grep 2 last for multi_grep $regexp[$_] =
shift foreach (0..$number-1); foreach $pattern (@compiled) {
last;</small></p>

<p><small>Storing pre-compiled regexps in an array
@compiled allows us to simply loop through the regexps
without any recompilation, thus gaining flexi- bility
without sacrificing speed.</small></p>

<p><small>Embedding comments and modifiers in a regular
expression</small></p>

<p><small>Starting with this section, we will be discussing
Perl s set of extended patterns. These are extensions to the
traditional regular expression syntax that provide powerful
new tools for pattern matching. We have already seen
extensions in the form of the minimal matching constructs
&quot;??&quot;, &quot;*?&quot;, &quot;+?&quot;,
&quot;{n,m}?&quot;, and &quot;{n,}?&quot;. The rest of the
extensions below have the form &quot;(?char...)&quot;, where
the &quot;char&quot; is a character that determines the type
of extension.</small></p>

<p><small>The first extension is an embedded comment
&quot;(?#text)&quot;. This embeds a comment into the regular
expression without affecting its meaning. The comment should
not have any closing parentheses in the text. An exam- ple
is</small></p>

<p><small>/(?# Match an integer:)[+-]?+/;</small></p>

<p><small>This style of commenting has been largely
superseded by the raw, freeform commenting that is allowed
with the &quot;//x&quot; modifier.</small></p>

<p><small>The modifiers &quot;//i&quot;, &quot;//m&quot;,
&quot;//s&quot;, and &quot;//x&quot; can also embedded in a
regexp using &quot;(?i)&quot;, &quot;(?m)&quot;,
&quot;(?s)&quot;, and &quot;(?x)&quot;. For
instance,</small></p>

<p><small>/(?i)yes/; # match yes case insensitively /yes/i;
# same thing /(?x)( # freeform version of an integer regexp
[+-]? # match an optional sign + # match a sequence of
digits ) /x;</small></p>

<p><small>Embedded modifiers can have two important
advantages over the usual modifiers. Embedded modifiers
allow a custom set of modifiers to _ each regexp pattern.
This is great for matching an array of regexps that must
have different modifiers:</small></p>

<p><small>$pattern[0] = (?i)doctor; $pattern[1] = Johnson;
... while (&lt;&gt;) { foreach $patt (@pattern) { print if
/$patt/; } }</small></p>

<p><small>The second advantage is that embedded modifiers
only affect the regexp inside the group the embedded
modifier is contained in. So grouping can be used to
localize the modifiers effects:</small></p>

<p><small>/Answer: ((?i)yes)/; # matches Answer: yes,
Answer: YES, etc.</small></p>

<p><small>Embedded modifiers can also turn off any
modifiers already present by using, e.g., &quot;(?-i)&quot;.
Modifiers can also be combined into a single expression,
e.g., &quot;(?s-i)&quot; turns on single line mode and turns
off case insensitivity.</small></p>

<p><small>Non-capturing groupings</small></p>

<p><small>We noted in Part 1 that groupings &quot;()&quot;
had two distinct functions: 1) group regexp elements
together as a single unit, and 2) extract, or capture,
substrings that matched the regexp in the grouping. Non-cap-
turing groupings, denoted by &quot;(?:regexp)&quot;, allow
the regexp to be treated as a single unit, but dont extract
substrings or set matching variables $1, etc. Both capturing
and non-capturing groupings are allowed to co-exist in the
same regexp. Because there is no extrac- tion, non-capturing
groupings are faster than capturing groupings. Non-capturing
groupings are also handy for choosing exactly which parts of
a regexp are to be extracted to matching
variables:</small></p>

<p><small># match a number, $1-$4 are set, but we only want
$1 /([+-]? *(+(.*)?.+)([eE][+-]?+)?)/;</small></p>

<p><small># match a number faster , only $1 is set /([+-]?
*(?:+(?:.*)?.+)(?:[eE][+-]?+)?)/;</small></p>

<p><small># match a number, get $1 = whole number, $2 =
exponent /([+-]?
*(?:+(?:.*)?.+)(?:[eE]([+-]?+))?)/;</small></p>

<p><small>Non-capturing groupings are also useful for
removing nuisance elements gathered from a split
operation:</small></p>

<p><small>$x = 12a34b5; @num = split /(ab)/, $x; # @num =
(12,a,34,b,5) @num = split /(?:ab)/, $x; # @num =
(12,34,5)</small></p>

<p><small>Non-capturing groupings may also have embedded
modifiers: &quot;(?i-m:regexp)&quot; is a non-capturing
grouping that matches &quot;regexp&quot; case insensitively
and turns off multi-line mode.</small></p>

<p><small>Looking ahead and looking behind</small></p>

<p><small>This section concerns the lookahead and
lookbehind assertions. First, a little
background.</small></p>

<p><small>In Perl regular expressions, most regexp elements
eat up a certain amount of string when they match. For
instance, the regexp element &quot;[abc}]&quot; eats up one
character of the string when it matches, in the sense that
perl moves to the next character position in the string
after the match. There are some elements, however, that dont
eat up characters (advance the character position) if they
match. The exam- ples we have seen so far are the anchors.
The anchor &quot;^&quot; matches the beginning of the line,
but doesnt eat any characters. Similarly, the m a t c h e s
, e . g . , i f t h e word boundary anchor &quot;c h a r a c
t e r t o t h e l e f t is a word character and the
character to the right is a non-word char- acter, but it
doesn t eat up any characters itself. Anchors are exam- ples
of zero-width assertions. Zero-width, because they consume
no characters, and assertions, because they test some
property of the string. In the context of our walk in the
woods analogy to regexp matching, most regexp elements move
us along a trail, but anchors have us stop a moment and
check our surroundings. If the local environment checks out,
we can proceed forward. But if the local environment doesnt
satisfy us, we must backtrack.</small></p>

<p><small>Checking the environment entails either looking
ahead on the trail, looking behind, or both. &quot;^&quot;
looks behind, to see that there are no characters before.
&quot;$&quot; looks ahead, to see that there are no charac-
l o o k s b o t h a h e a d a n d b e h i n ters after.
&quot;d , t o s e e i f t h e c h a r a c t e r s on either
side differ in their word-ness.</small></p>

<p><small>The lookahead and lookbehind assertions are
generalizations of the anchor concept. Lookahead and
lookbehind are zero-width assertions that let us specify
which characters we want to test for. The looka- head
assertion is denoted by &quot;(?=regexp)&quot; and the
lookbehind assertion is denoted by
&quot;(?&lt;=fixed-regexp)&quot;. Some examples
are</small></p>

<p><small>$x = &quot;I catch the housecat Tom-cat with
catnip&quot;; $x =~ /cat(?=/; # matches cat in housecat
@catwords = ($x =~ /(?&lt;=cat384 # $catwords[0] = catch #
$catwords[1] = catnip a $x =~ /t $x =~ /(?&lt;=cat(?=/; #
doesnt match; no isolated cat in # middle of $x</small></p>

<p><small>Note that the parentheses in
&quot;(?=regexp)&quot; and &quot;(?&lt;=regexp)&quot; are
non-capturing, since these are zero-width assertions. Thus
in the sec- ond regexp, the substrings captured are those of
the whole regexp itself. Lookahead &quot;(?=regexp)&quot;
can match arbitrary regexps, but look- behind
&quot;(?&lt;=fixed-regexp)&quot; only works for regexps of
fixed width, i.e., a fixed number of characters long. Thus
&quot;(?&lt;=(abbc))&quot; is fine, but
&quot;(?&lt;=(ab)*)&quot; is not. The negated versions of
the lookahead and lookbe- hind assertions are denoted by
&quot;(?!regexp)&quot; and &quot;(?&lt;!fixed-regexp)&quot;
respectively. They evaluate true if the regexps do _ not
match:</small></p>

<p><small>$x = &quot;foobar&quot;; $x =~ /foo(?!bar)/; #
doesnt match, bar follows foo $x =~ /foo(?!baz)/; # matches,
baz doesnt follow foo $x =~ /(?&lt;!foo/; # matches, there
is no before foo</small></p>

<p><small>The &quot;is unsupported in lookbehind, because
the already treacherous definition of &quot;would become
even more so when going backwards.</small></p>

<p><small>Using independent subexpressions to prevent
backtracking</small></p>

<p><small>The last few extended patterns in this tutorial
are experimental as of 5.6.0. Play with them, use them in
some code, but don t rely on them just yet for production
code.</small></p>

<p><small>Independent subexpressions are regular
expressions, in the context of a larger regular expression,
that function independently of the larger regular
expression. That is, they consume as much or as little of
the string as they wish without regard for the ability of
the larger regexp to match. Independent subexpressions are
represented by &quot;(?&gt;regexp)&quot;. We can illustrate
their behavior by first considering an ordinary reg-
exp:</small></p>

<p><small>$x = &quot;ab&quot;; $x =~ /a*ab/; #
matches</small></p>

<p><small>This obviously matches, but in the process of
matching, the subexpres- sion &quot;a*&quot; first grabbed
the &quot;a&quot;. Doing so, however, wouldnt allow the
whole regexp to match, so after backtracking, &quot;a*&quot;
eventually gave back the &quot;a&quot; and matched the empty
string. Here, what &quot;a*&quot; matched was dependent on
what the rest of the regexp matched.</small></p>

<p><small>Contrast that with an independent
subexpression:</small></p>

<p><small>$x =~ /(?&gt;a*)ab/; # doesnt match!</small></p>

<p><small>The independent subexpression
&quot;(?&gt;a*)&quot; doesnt care about the rest of the
regexp, so it sees an &quot;a&quot; and grabs it. Then the
rest of the reg- exp &quot;ab&quot; cannot match. Because
&quot;(?&gt;a*)&quot; is independent, there is no
backtracking and the independent subexpression does not give
up its &quot;a&quot;. Thus the match of the regexp as a
whole fails. A similar behav- ior occurs with completely
independent regexps:</small></p>

<p><small>$x = &quot;ab&quot;; $x =~ /a*/g; # matches, eats
an a $x =~ /Gab/g; # doesnt match, no a
available</small></p>

<p><small>Here &quot;//g&quot; and &quot;G&quot; create a
tag team handoff of the string from one regexp to the other.
Regexps with an independent subexpression are much like
this, with a handoff of the string to the independent subex-
pression, and a handoff of the string back to the enclosing
regexp.</small></p>

<p><small>The ability of an independent subexpression to
prevent backtracking can be quite useful. Suppose we want to
match a non-empty string enclosed in parentheses up to two
levels deep. Then the following regexp matches:</small></p>

<p><small>$x = &quot;abc(de(fg)h&quot;; # unbalanced
parentheses $x =~ /( [^()]+ ()]* )+ /x;</small></p>

<p><small>The regexp matches an open parenthesis, one or
more copies of an alter- nation, and a close parenthesis.
The alternation is two-way, with the first alternative
&quot;[^()]+&quot; matching a substring with no parentheses
and the second alternative &quot;()]*&quot; matching a
substring delimited by parentheses. The problem with this
regexp is that it is pathological: it has nested
indeterminate quantifiers of the form &quot;(a+ b)+&quot;.
We dis- cussed in Part 1 how nested quantifiers like this
could take an expo- nentially long time to execute if there
was no match possible. To pre- vent the exponential blowup,
we need to prevent useless backtracking at some point. This
can be done by enclosing the inner quantifier as an
independent subexpression:</small></p>

<p><small>$x =~ /( (?&gt;[^()]+) ()]* )+ /x;</small></p>

<p><small>Here, &quot;(?&gt;[^()]+)&quot; breaks the
degeneracy of string partitioning by gobbling up as much of
the string as possible and keeping it. Then match failures
fail much more quickly.</small></p>

<p><small>Conditional expressions</small></p>

<p><small>A conditional expression is a form of
if-then-else statement that allows one to choose which
patterns are to be matched, based on some condition. There
are two types of conditional expression: &quot;(?(condi-
tion)yes-regexp)&quot; and
&quot;(?(condition)yes-regexpno-regexp)&quot;.
&quot;(?(condi- tion)yes-regexp)&quot; is like an &rsquo;if
() {}&rsquo; statement in Perl. If the &quot;condition&quot;
is true, the &quot;yes-regexp&quot; will be matched. If the
&quot;condi- tion&quot; is false, the &quot;yes-regexp&quot;
will be skipped and perl will move onto the next regexp
element. The second form is like an &rsquo;if () {} else
{}&rsquo; statement in Perl. If the &quot;condition&quot; is
true, the &quot;yes-regexp&quot; will be matched, otherwise
the &quot;no-regexp&quot; will be matched.</small></p>

<p><small>The &quot;condition&quot; can have two forms. The
first form is simply an inte- ger in parentheses
&quot;(integer)&quot;. It is true if the corresponding back-
reference &quot;integer&quot; matched earlier in the regexp.
The second form is a bare zero width assertion
&quot;(?...)&quot;, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).</small></p>

<p><small>The integer form of the &quot;condition&quot;
allows us to choose, with more flexibility, what to match
based on what matched earlier in the regexp. This searches
for words of the form &quot;$x$x&quot; or
&quot;$x$y$y$x&quot;:</small></p>

<p><small>% simple_grep ^(120 beriberi coco couscous deed
... toot toto tutu</small></p>

<p><small>The lookbehind &quot;condition&quot; allows,
along with backreferences, an ear- lier part of the match to
influence a later part of the match. For
instance,</small></p>

<p><small>/[ATGC]+(?(?&lt;=AA)GC)$/;</small></p>

<p><small>matches a DNA sequence such that it either ends
in &quot;AAG&quot;, or some other base pair combination and
&quot;C&quot;. Note that the form is
&quot;(?(?&lt;=AA)GC)&quot; and not
&quot;(?((?&lt;=AA))GC)&quot;; for the lookahead, lookbehind
or code asser- tions, the parentheses around the conditional
are not needed.</small></p>

<p><small>A bit of magic: executing Perl code in a regular
expression</small></p>

<p><small>Normally, regexps are a part of Perl expressions.
C Code evaluation expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp. A code
evaluation expression is denoted &quot;(?{code})&quot;, with
&quot;code&quot; a string of Perl statements.</small></p>

<p><small>Code expressions are zero-width assertions, and
the value they return depends on their environment. There
are two possibilities: either the code expression is used as
a conditional in a conditional expression
&quot;(?(condition)...)&quot;, or it is not. If the code
expression is a condi- tional, the code is evaluated and the
result (i.e., the result of the last statement) is used to
determine truth or falsehood. If the code expression is not
used as a conditional, the assertion always evaluates true
and the result is put into the special variable $^R. The
variable $^R can then be used in code expressions later in
the regexp. Here are some silly examples:</small></p>

<p><small>$x = &quot;abcdef&quot;; $x =~ /abc(?{print
&quot;Hi Mom!&quot;;})def/; # matches, # prints Hi Mom! $x
=~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; # doesnt match,
# no Hi Mom!</small></p>

<p><small>Pay careful attention to the next
example:</small></p>

<p><small>$x =~ /abc(?{print &quot;Hi Mom!&quot;;})ddd/; #
doesnt match, # no Hi Mom! # but why not?</small></p>

<p><small>At first glance, you d think that it shouldn t
print, because obviously the &quot;ddd&quot; isnt going to
match the target string. But look at this
example:</small></p>

<p><small>$x =~ /abc(?{print &quot;Hi Mom!&quot;;})[d]dd/;
# doesnt match, # but _does_ print</small></p>

<p><small>Hmm. What happened here? If youve been following
along, you know that the above pattern should be effectively
the same as the last one -- enclosing the d in a character
class isnt going to change what it matches. So why does the
first not print while the second one does?</small></p>

<p><small>The answer lies in the optimizations the REx
engine makes. In the first case, all the engine sees are
plain old characters (aside from the &quot;?{}&quot;
construct). Its smart enough to realize that the string ddd
doesn t occur in our target string before actually running
the pattern through. But in the second case, we ve tricked
it into thinking that our pattern is more complicated than
it is. It takes a look, sees our character class, and
decides that it will have to actually run the pat- tern to
determine whether or not it matches, and in the process of
run- ning it hits the print statement before it discovers
that we dont have a match.</small></p>

<p><small>To take a closer look at how the engine does
optimizations, see the section &quot;Pragmas and
debugging&quot; below.</small></p>

<p><small>More fun with &quot;?{}&quot;:</small></p>

<p><small>$x =~ /(?{print &quot;Hi Mom!&quot;;})/; #
matches, # prints Hi Mom! $x =~ /(?{$c = 1;})(?{print
&quot;$c&quot;;})/; # matches, # prints 1 $x =~ /(?{$c =
1;})(?{print &quot;$^R&quot;;})/; # matches, # prints
1</small></p>

<p><small>The bit of magic mentioned in the section title
occurs when the regexp backtracks in the process of
searching for a match. If the regexp backtracks over a code
expression and if the variables used within are localized
using &quot;local&quot;, the changes in the variables
produced by the code expression are undone! Thus, if we
wanted to count how many times a character got matched
inside a group, we could use, e.g.,</small></p>

<p><small>$x = &quot;aaaa&quot;; $count = 0; # initialize a
count $c = &quot;bob&quot;; # test if $c gets clobbered $x
=~ /(?{local $c = 0;}) # initialize count ( a # match a
(?{local $c = $c + 1;}) # increment count )* # do this any
number of times, aa # but match aa at the end (?{$count =
$c;}) # copy local $c var into $count /x; print &quot;a
count is $count, variable is $c0;</small></p>

<p><small>This prints</small></p>

<p><small>a count is 2, $c variable is bob</small></p>

<p><small>If we replace the &quot; (?{local $c = $c +
1;})&quot; with &quot; (?{$c = $c + 1;})&quot; , the
variable changes are _ not undone during back- tracking, and
we get</small></p>

<p><small>a count is 4, $c variable is bob</small></p>

<p><small>Note that only localized variable changes are
undone. Other side effects of code expression execution are
permanent. Thus</small></p>

<p><small>$x = &quot;aaaa&quot;; $x =~ /(a(?{print
&quot;Yow0;}))*aa/;</small></p>

<p><small>produces</small></p>

<p><small>Yow Yow Yow Yow</small></p>

<p><small>The result $^R is automatically localized, so
that it will behave prop- erly in the presence of
backtracking.</small></p>

<p><small>This example uses a code expression in a
conditional to match the arti- cle the in either English or
German:</small></p>

<p><small>$lang = DE; # use German ... $text =
&quot;das&quot;; print &quot;matched0 if $text =~ /(?(?{
$lang eq EN; # is the language English? }) the # if so, then
match the (diedasder) # else, match die dasder )
/xi;</small></p>

<p><small>Note that the syntax here is
&quot;(?(?{...})yes-regexp no-regexp)&quot;, not
&quot;(?((?{...}))yes-regexpno-regexp)&quot;. In other
words, in the case of a code expression, we dont need the
extra parentheses around the condi- tional.</small></p>

<p><small>If you try to use code expressions with
interpolating variables, perl may surprise you:</small></p>

<p><small>$bar = 5; $pat = (?{ 1 }); /foo(?{ $bar })bar/; #
compiles ok, $bar not interpolated /foo(?{ 1 })$bar/; #
compile error! /foo${pat}bar/; # compile error!</small></p>

<p><small>$pat = qr/(?{ $foo = 1 })/; # precompile code
regexp /foo${pat}bar/; # compiles ok</small></p>

<p><small>If a regexp has (1) code expressions and
interpolating variables, or (2) a variable that interpolates
a code expression, perl treats the regexp as an error. If
the code expression is precompiled into a vari- able,
however, interpolating is ok. The question is, why is this
an error?</small></p>

<p><small>The reason is that variable interpolation and
code expressions together pose a security risk. The
combination is dangerous because many programmers who write
search engines often take user input and plug it directly
into a regexp:</small></p>

<p><small>$regexp = &lt;&gt;; # read user-supplied regexp
$chomp $regexp; # get rid of possible newline $text =~
/$regexp/; # search $text for the $regexp</small></p>

<p><small>If the $regexp variable contains a code
expression, the user could then execute arbitrary Perl code.
For instance, some joker could search for
&quot;system(&rsquo;rm -rf *&rsquo;);&quot; to erase your
files. In this sense, the combi- nation of interpolation and
code expressions t taints your regexp. So by default, using
both interpolation and code expressions in the same reg- exp
is not allowed. If you re not concerned about malicious
users, it is possible to bypass this security check by
invoking &quot;use re &rsquo;eval&rsquo;&quot; :</small></p>

<p><small>use re eval; # throw caution out the door $bar =
5; $pat = (?{ 1 }); /foo(?{ 1 })$bar/; # compiles ok
/foo${pat}bar/; # compiles ok</small></p>

<p><small>Another form of code expression is the p pattern
code expression . The pattern code expression is like a
regular code expression, except that the result of the code
evaluation is treated as a regular expression and matched
immediately. A simple example is</small></p>

<p><small>$length = 5; $char = a; $x = aaaaabb; $x =~
/(??{$char x $length})/x; # matches, there are 5 of
a</small></p>

<p><small>This final example contains both ordinary and
pattern code expressions. It detects if a binary string
1101010010001... has a Fibonacci spacing 0,1,1,2,3,5,... of
the 1s:</small></p>

<p><small>$s0 = 0; $s1 = 1; # initial conditions $x =
&quot;1101010010001000001&quot;; print &quot;It is a
Fibonacci sequence0 if $x =~ /^1 # match an initial 1 (
(??{0 x $s0}) # match $s0 of 0 1 # and then a 1 (?{ $largest
= $s0; # largest seq so far $s2 = $s1 + $s0; # compute next
term $s0 = $s1; # in Fibonacci sequence $s1 = $s2; }) )+ #
repeat as needed $ # that is all there is /x; print
&quot;Largest sequence matched was $largest0;</small></p>

<p><small>This prints</small></p>

<p><small>It is a Fibonacci sequence Largest sequence
matched was 5</small></p>

<p><small>Ha! Try that with your garden variety regexp
package...</small></p>

<p><small>Note that the variables $s0 and $s1 are not
substituted when the regexp is compiled, as happens for
ordinary variables outside a code expres- sion. Rather, the
code expressions are evaluated when perl encounters them
during the search for a match.</small></p>

<p><small>The regexp without the &quot;//x&quot; modifier
is</small></p>

<p><small>/^1((??{ 0
x$s0})1(?{$largest=$s0;$s2=$s1+$s0$s0=$s1;$s1=$s2;}))+$/;</small></p>

<p><small>and is a great start on an Obfuscated Perl entry
:-) When working with code and conditional expressions, the
extended form of regexps is almost necessary in creating and
debugging regexps.</small></p>

<p><small>Pragmas and debugging</small></p>

<p><small>Speaking of debugging, there are several pragmas
available to control and debug regexps in Perl. We have
already encountered one pragma in the previous section,
&quot;use re &rsquo;eval&rsquo;;&quot; , that allows
variable interpo- lation and code expressions to coexist in
a regexp. The other pragmas are</small></p>

<p><small>use re taint; $tainted = &lt;&gt;; @parts =
($tainted =~ /(72</small></p>

<p><small>The &quot;taint&quot; pragma causes any
substrings from a match with a tainted variable to be
tainted as well. This is not normally the case, as reg- exps
are often used to extract the safe bits from a tainted
variable. Use &quot;taint&quot; when you are not extracting
safe bits, but are performing some other processing. Both
&quot;taint&quot; and &quot;eval&quot; pragmas are lexically
scoped, which means they are in effect only until the end of
the block enclosing the pragmas.</small></p>

<p><small>use re debug; /^(.*)$/s; # output debugging
info</small></p>

<p><small>use re debugcolor; /^(.*)$/s; # output debugging
info in living color</small></p>

<p><small>The global &quot;debug&quot; and
&quot;debugcolor&quot; pragmas allow one to get detailed
debugging info about regexp compilation and execution.
&quot;debugcolor&quot; is the same as debug, except the
debugging information is displayed in color on terminals
that can display termcap color sequences. Here is example
output:</small></p>

<p><small>% perl -e use re &quot;debug&quot;;
&quot;abc&quot; =~ /a*b+c/; Compiling REx a*b+c size 9 first
at 1 1: STAR(4) 2: EXACT &lt;a&gt;(0) 4: PLUS(7) 5: EXACT
&lt;b&gt;(0) 7: EXACT &lt;c&gt;(9) 9: END(0) floating bc at
0..2147483647 (checking floating) minlen 2 Guessing start of
match, REx a*b+c against abc... Found floating substr bc at
offset 1... Guessed: match at offset 0 Matching REx a*b+c
against abc Setting an EVAL scope, savestack=3 0 &lt;&gt;
&lt;abc&gt; 1: STAR EXACT &lt;a&gt; can match 1 times out of
32767... Setting an EVAL scope, savestack=3 1 &lt;a&gt;
&lt;bc&gt; 4: PLUS EXACT &lt;b&gt; can match 1 times out of
32767... Setting an EVAL scope, savestack=3 2 &lt;ab&gt;
&lt;c&gt; 7: EXACT &lt;c&gt; 3 &lt;abc&gt; &lt;&gt; 9: END
Match successful! Freeing REx: a*b+c</small></p>

<p><small>If you have gotten this far into the tutorial,
you can probably guess what the different parts of the
debugging output tell you. The first part</small></p>

<p><small>Compiling REx a*b+c size 9 first at 1 1: STAR(4)
2: EXACT &lt;a&gt;(0) 4: PLUS(7) 5: EXACT &lt;b&gt;(0) 7:
EXACT &lt;c&gt;(9) 9: END(0)</small></p>

<p><small>describes the compilation stage. STAR(4) means
that there is a starred object, in this case
&rsquo;a&rsquo;, and if it matches, goto line 4, i.e.,
PLUS(7). The middle lines describe some heuristics and
optimizations performed before a match:</small></p>

<p><small>floating bc at 0..2147483647 (checking floating)
minlen 2 Guessing start of match, REx a*b+c against abc...
Found floating substr bc at offset 1... Guessed: match at
offset 0</small></p>

<p><small>Then the match is executed and the remaining
lines describe the pro- cess:</small></p>

<p><small>Matching REx a*b+c against abc Setting an EVAL
scope, savestack=3 0 &lt;&gt; &lt;abc&gt; 1: STAR EXACT
&lt;a&gt; can match 1 times out of 32767... Setting an EVAL
scope, savestack=3 1 &lt;a&gt; &lt;bc&gt; 4: PLUS EXACT
&lt;b&gt; can match 1 times out of 32767... Setting an EVAL
scope, savestack=3 2 &lt;ab&gt; &lt;c&gt; 7: EXACT &lt;c&gt;
3 &lt;abc&gt; &lt;&gt; 9: END Match successful! Freeing REx:
a*b+c</small></p>

<p><small>Each step is of the form &quot;n &lt;x&gt;
&lt;y&gt;&quot; , with &quot;&lt;x&gt;&quot; the part of the
string matched and &quot;&lt;y&gt;&quot; the part not yet
matched. The &quot; 1: STAR&quot; says that perl is at line
number 1 n the compilation list above. See &quot;Debugging
regular expressions&quot; in perldebguts for much more
detail.</small></p>

<p><small>An alternative method of debugging regexps is to
embed &quot;print&quot; state- ments within the regexp. This
provides a blow-by-blow account of the backtracking in an
alternation:</small></p>

<p><small>&quot;that this&quot; =~ m@(?{print &quot;Start
at position &quot;, pos, &quot;0;}) t(?{print &quot;t10;})
h(?{print &quot;h10;}) i(?{print &quot;i10;}) s(?{print
&quot;s10;}) t(?{print &quot;t20;}) h(?{print &quot;h20;})
a(?{print &quot;a20;}) t(?{print &quot;t20;}) (?{print
&quot;Done at position &quot;, pos, &quot;0;})
@x;</small></p>

<p><small>prints</small></p>

<p><small>Start at position 0 t1 h1 t2 h2 a2 t2 Done at
position 4</small></p>

<p><small>BUGS Code expressions, conditional expressions,
and independent expressions are eexperimental. Dont use them
in production code. Yet.</small></p>

<p><small>SEE ALSO This is just a tutorial. For the full
story on perl regular expres- sions, see the perlre regular
expressions reference page.</small></p>

<p><small>For more information on the matching
&quot;m//&quot; and substitution &quot;s///&quot; operators,
see &quot;Regexp Quote-Like Operators&quot; in perlop. For
informa- tion on the &quot;split&quot; operation, see
&quot;split&quot; in perlfunc.</small></p>

<p><small>For an excellent all-around resource on the care
and feeding of regular expressions, see the book _ Mastering
Regular Expressions by Jeffrey Friedl (published by OReilly,
ISBN 1556592-257-3).</small></p>

<p><small>AUTHOR AND COPYRIGHT Copyright (c) 2000 Mark
Kvale All rights reserved.</small></p>

<p><small>This document may be distributed under the same
terms as Perl itself.</small></p>

<p><small>Acknowledgments</small></p>

<p><small>The inspiration for the stop codon DNA example
came from the ZIP code example in chapter 7 of _ Mastering
Regular Expressions.</small></p>

<p><small>The author would like to thank Jeff Pinyan,
Andrew Johnson, Peter Haworth, Ronald J Kimball, and Joe
Smith for all their helpful com- ments.</small></p>

<p><small>perl v5.8.8 2014-02-11 PERLRETUT(1)</small></p>
<hr>
</body>
</html>
