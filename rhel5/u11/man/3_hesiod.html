<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:13:06 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>HESIOD(3) HESIOD(3)</p>

<p>NAME hesiod, hesiod_init, hesiod_resolve,
hesiod_free_list, hesiod_to_bind, hesiod_free_string,
hesiod_end - Hesiod name server interface library</p>

<p>SYNOPSIS #include &lt;hesiod.h&gt;</p>

<p>int hesiod_init(void **context) char
**hesiod_resolve(void *context, const char *name, const char
*type) void hesiod_free_list(void *context, char **list);
char *hesiod_to_bind(void *context, const char *name, const
char *type) void hesiod_free_string(void *context, char
*str); char **hesiod_parse_result(void *context, unsigned
const char *result, int rlen) void hesiod_end(void
*context)</p>

<p>cc file.c -lhesiod</p>

<p>DESCRIPTION This family of functions allows you to
perform lookups of Hesiod infor- mation, which is stored as
text records in the Domain Name Service. To perform lookups,
you must first initialize a context, an opaque object which
stores information used internally by the library between
calls. hesiod_init initializes a context, storing a pointer
to the context in the location pointed to by the context
argument. hesiod_end frees the resources used by a
context.</p>

<p>hesiod_resolve is the primary interface to the library.
If successful, it returns a list of one or more strings
giving the records matching name and type. The last element
of the list is followed by a NULL pointer. It is the caller
s responsibility to call hesiod_free_list to free the
resources used by the returned list.</p>

<p>hesiod_to_bind converts name and type into the DNS name
used by hes- iod_resolve. It is the callers responsibility
to free the returned string using hesiod_free_string.</p>

<p>hesiod_parse_result parses the result of a name server
query into text records. It is the caller s responsibility
to call hesiod_free_list to free the resources used by the
returned list.</p>

<p>RETURN VALUES If successful, hesiod_init returns 0;
otherwise it returns -1 and sets errno to indicate the
error. On failure, hesiod_resolve and hes- iod_to_bind
return NULL and set the global variable errno to indicate
the error.</p>

<p>ENVIRONMENT If the environment variable HES_DOMAIN is
set, it will override the domain in the Hesiod configuration
file. If the environment variable HESIOD_CONFIG is set, it
specifies the location of the Hesiod configu- ration
file.</p>

<p>SEE ALSO Hesiod - Project Athena Technical Plan -- Name
Service, named(8), hesiod.conf(5)</p>

<p>ERRORS Hesiod calls may fail because of:</p>

<p>ENOMEM Insufficient memory was available to carry out
the requested operation.</p>

<p>ENOEXEC hesiod_init failed because the Hesiod
configuration file was invalid.</p>

<p>ECONNREFUSED hesiod_resolve failed because no name
server could be contacted to answer the query.</p>

<p>EMSGSIZE hesiod_resolve or hesiod_to_bind failed because
the query or response was too big to fit into the packet
buffers.</p>

<p>ENOENT hesiod_resolve failed because the name server had
no text records matching name and type, or hesiod_to_bind
failed because the name argument had a domain extension
which could not be resolved with type rhs-extension in the
local Hesiod domain.</p>

<p>AUTHOR Steve Dyer, IBM/Project Athena Greg Hudson, MIT
Team Athena Copyright 1987, 1988, 1995, 1996, 2000 by the
Massachusetts Institute of Technology.</p>

<p>BUGS The strings corresponding to the errno values set
by the Hesiod func- tions are not particularly indicative of
what went wrong, especially for ENOEXEC and ENOENT.</p>

<p>30 November 1996 HESIOD(3)</p>
<hr>
</body>
</html>
