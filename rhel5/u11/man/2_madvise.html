<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:15:46 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>MADVISE(2) Linux Programmer s Manual MADVISE(2)</p>

<p>NAME madvise - give advice about use of memory</p>

<p>SYNOPSIS #include &lt;sys/mman.h&gt;</p>

<p>int madvise(void *start, size_t length, int advice);</p>

<p>DESCRIPTION The madvise() system call advises the kernel
about how to handle paging input/output in the address range
beginning at address start and with size length bytes. It
allows an application to tell the kernel how it expects to
use some mapped or shared memory areas, so that the kernel
can choose appropriate read-ahead and caching techniques.
This call does not influence the semantics of the
application (except in the case of MADV_DONTNEED), but may
influence its performance. The kernel is free to ignore the
advice.</p>

<p>The advice is indicated in the advice parameter which
can be</p>

<p>MADV_NORMAL No special treatment. This is the
default.</p>

<p>MADV_RANDOM Expect page references in random order.
(Hence, read ahead may be less useful than normally.)</p>

<p>MADV_SEQUENTIAL Expect page references in sequential
order. (Hence, pages in the given range can be aggressively
read ahead, and may be freed soon after they are
accessed.)</p>

<p>MADV_WILLNEED Expect access in the near future. (Hence,
it might be a good idea to read some pages ahead.)</p>

<p>MADV_DONTNEED Do not expect access in the near future.
(For the time being, the application is finished with the
given range, so the kernel can free resources associated
with it.) Subsequent accesses of pages in this range will
succeed, but will result either in re- loading of the memory
contents from the underlying mapped file (see mmap()) or
zero-fill-on-demand pages for mappings without an underlying
file.</p>

<p>RETURN VALUE On success madvise() returns zero. On
error, it returns -1 and errno is set appropriately.</p>

<p>ERRORS EAGAIN A kernel resource was temporarily
unavailable.</p>

<p>EBADF The map exists, but the area maps something that
isnt a file.</p>

<p>EINVAL The value len is negative, start is not
page-aligned, advice is not a valid value, or the
application is attempting to release locked or shared pages
(with MADV_DONTNEED).</p>

<p>EIO (for MADV_WILLNEED) Paging in this area would exceed
the pro- cesss maximum resident set size.</p>

<p>ENOMEM (for MADV_WILLNEED) Not enough memory: paging in
failed.</p>

<p>ENOMEM Addresses in the specified range are not
currently mapped, or are outside the address space of the
process.</p>

<p>LINUX NOTES The current Linux implementation (2.4.0)
views this system call more as a command than as advice and
hence may return an error when it cannot do what it usually
would do in response to this advice. (See the ERRORS
description above.) This is nonstandard behaviour.</p>

<p>The Linux implementation requires that the address start
be page- aligned, and allows length to be zero. If there are
some parts of the specified address range that are not
mapped, the Linux version of mad- vise() ignores them and
applies the call to the rest (but returns ENOMEM from the
system call, as it should).</p>

<p>HISTORY The madvise() function first appeared in
4.4BSD.</p>

<p>CONFORMING TO POSIX.1b. POSIX.1-2001 describes
posix_madvise() with constants POSIX_MADV_NORMAL, etc., with
a behaviour close to that described here. There is a similar
posix_fadvise() for file access.</p>

<p>SEE ALSO getrlimit(2), mincore(2), mmap(2), mprotect(2),
msync(2), munmap(2)</p>

<p>Linux 2.4.5 2001-06-10 MADVISE(2)</p>
<hr>
</body>
</html>
