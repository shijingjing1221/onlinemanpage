<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Sat Nov 12 05:11:44 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p>GETOPT(3) Linux Programmer s Manual GETOPT(3)</p>

<p>NAME getopt - Parse command-line options</p>

<p>SYNOPSIS #include &lt;unistd.h&gt;</p>

<p>int getopt(int argc, char * const argv[], const char
*optstring);</p>

<p>extern char *optarg; extern int optind, opterr,
optopt;</p>

<p>#define _GNU_SOURCE #include &lt;getopt.h&gt;</p>

<p>int getopt_long(int argc, char * const argv[], const
char *optstring, const struct option *longopts, int
*longindex);</p>

<p>int getopt_long_only(int argc, char * const argv[],
const char *optstring, const struct option *longopts, int
*longindex);</p>

<p>DESCRIPTION The getopt() function parses the
command-line arguments. Its arguments argc and argv are the
argument count and array as passed to the main() function on
program invocation. An element of argv that starts with -
(and is not exactly &quot;-&quot; or &quot;--&quot;) is an
option element. The charac- ters of this element (aside from
the initial - ) are option charac- ters. If getopt() is
called repeatedly, it returns successively each of the
option characters from each of the option elements.</p>

<p>If getopt() finds another option character, it returns
that character, updating the external variable optind and a
static variable nextchar so that the next call to getopt()
can resume the scan with the following option character or
argv-element.</p>

<p>If there are no more option characters, getopt() returns
-1. Then optind is the index in argv of the first
argv-element that is not an option.</p>

<p>optstring is a string containing the legitimate option
characters. If such a character is followed by a colon, the
option requires an argu- ment, so getopt() places a pointer
to the following text in the same argv-element, or the text
of the following argv-element, in optarg. Two colons mean an
option takes an optional arg; if there is text in the
current argv-element, it is returned in optarg, otherwise
optarg is set to zero. This is a GNU extension. If optstring
contains W fol- lowed by a semicolon, then -W foo is treated
as the long option --foo. (The -W option is reserved by
POSIX.2 for implementation extensions.) This behaviour is a
GNU extension, not available with libraries before GNU libc
2.</p>

<p>By default, getopt() permutes the contents of argv as it
scans, so that eventually all the non-options are at the
end. Two other modes are also implemented. If the first
character of optstring is + or the environment variable
POSIXLY_CORRECT is set, then option processing stops as soon
as a non-option argument is encountered. If the first
character of optstring is -, then each non-option
argv-element is handled as if it were the argument of an
option with character code 1. (This is used by programs that
were written to expect options and other argv-elements in
any order and that care about the ordering of the two.) The
special argument &quot;--&quot; forces an end of
option-scanning regardless of the scanning mode.</p>

<p>If getopt() does not recognize an option character, it
prints an error message to stderr, stores the character in
optopt, and returns ?. The calling program may prevent the
error message by setting opterr to 0.</p>

<p>If getopt() finds an option character in argv that was
not included in optstring, or if it detects a missing option
argument, it returns ? and sets the external variable optopt
to the actual option character. If the first character
(following any optional +or - described above) of optstring
is a colon (:), then getopt() returns : instead of ? to
indicate a missing option argument. If an error was
detected, and the first character of optstring is not a
colon, and the external variable opterr is non-zero (which
is the default), getopt() prints an error message.</p>

<p>The getopt_long() function works like getopt() except
that it also accepts long options, started out by two
dashes. (If the program accepts only long options, then
optstring should be specified as an empty string
(&quot;&quot;), not NULL.) Long option names may be
abbreviated if the abbreviation is unique or is an exact
match for some defined option. A long option may take a
parameter, of the form --arg=param or --arg param.</p>

<p>longopts is a pointer to the first element of an array
of struct option declared in &lt;getopt.h&gt; as</p>

<p>struct option { const char *name; int has_arg; int
*flag; int val; };</p>

<p>The meanings of the different fields are:</p>

<p>name is the name of the long option.</p>

<p>has_arg is: no_argument (or 0) if the option does not
take an argument; required_argument (or 1) if the option
requires an argument; or optional_argument (or 2) if the
option takes an optional argu- ment.</p>

<p>flag specifies how results are returned for a long
option. If flag is NULL, then getopt_long() returns val.
(For example, the calling program may set val to the
equivalent short option char- acter.) Otherwise,
getopt_long() returns 0, and flag points to a variable which
is set to val if the option is found, but left unchanged if
the option is not found.</p>

<p>val is the value to return, or to load into the variable
pointed to by flag.</p>

<p>The last element of the array has to be filled with
zeroes.</p>

<p>If longindex is not NULL, it points to a variable which
is set to the index of the long option relative to
longopts.</p>

<p>getopt_long_only() is like getopt_long(), but - as well
as -- can indicate a long option. If an option that starts
with - (not --) doesn t match a long option, but does match
a short option, it is parsed as a short option instead.</p>

<p>RETURN VALUE If an option was successfully found, then
getopt() returns the option character. If all command-line
options have been parsed, then getopt() returns -1. If
getopt() encounters an option character that was not in
optstring, then ? is returned. If getopt() encounters an
option with a missing argument, then the return value
depends on the first charac- ter in optstring: if it is : ,
then : is returned; otherwise ? is returned.</p>

<p>getopt_long() and getopt_long_only() also return the
option character when a short option is recognized. For a
long option, they return val if flag is NULL, and 0
otherwise. Error and -1 returns are the same as for
getopt(), plus ? for an ambiguous match or an extraneous
parame- ter.</p>

<p>ENVIRONMENT VARIABLES POSIXLY_CORRECT If this is set,
then option processing stops as soon as a non- option
argument is encountered.</p>

<p>_&lt;PID&gt;_GNU_nonoption_argv_flags_ This variable was
used by bash 2.0 to communicate to GNU libc which arguments
are the results of wildcard expansion and so should not be
considered as options. This behaviour was removed in bash
version 2.01, but the support remains in GNU libc.</p>

<p>EXAMPLE The following example program illustrates the
use of getopt_long() with most of its features.</p>

<p>#include &lt;stdio.h&gt; /* for printf */ #include
&lt;stdlib.h&gt; /* for exit */ #include
&lt;getopt.h&gt;</p>

<p>int main (int argc, char **argv) { int c; int
digit_optind = 0;</p>

<p>while (1) { int this_option_optind = optind ? optind :
1; int option_index = 0; static struct option long_options[]
= { {&quot;add&quot;, 1, 0, 0}, {&quot;append&quot;, 0, 0,
0}, {&quot;delete&quot;, 1, 0, 0}, {&quot;verbose&quot;, 0,
0, 0}, {&quot;create&quot;, 1, 0, c}, {&quot;file&quot;, 1,
0, 0}, {0, 0, 0, 0} };</p>

<p>c = getopt_long (argc, argv, &quot;abc:d:012&quot;,
long_options, &amp;option_index); if (c == -1) break;</p>

<p>switch (c) { case 0: printf (&quot;option %s&quot;,
long_options[option_index].name); if (optarg) printf (&quot;
with arg %s&quot;, optarg); printf (&quot;0); break;</p>

<p>case 0: case 1: case 2: if (digit_optind != 0 &amp;&amp;
digit_optind != this_option_optind) printf (&quot;digits
occur in two different argv-elements.0); digit_optind =
this_option_optind; printf (&quot;option %c0, c); break;</p>

<p>case a: printf (&quot;option a0); break;</p>

<p>case b: printf (&quot;option b0); break;</p>

<p>case c: printf (&quot;option c with value %s0, optarg);
break;</p>

<p>case d: printf (&quot;option d with value %s0, optarg);
break;</p>

<p>case ?: break;</p>

<p>default: printf (&quot;?? getopt returned character code
0%o ??0, c); } }</p>

<p>if (optind &lt; argc) { printf (&quot;non-option
ARGV-elements: &quot;); while (optind &lt; argc) printf
(&quot;%s &quot;, argv[optind++]); printf (&quot;0); }</p>

<p>exit (0); }</p>

<p>BUGS The POSIX.2 specification of getopt() has a
technical error described in POSIX.2 Interpretation 150. The
GNU implementation (and probably all other implementations)
implements the correct behaviour rather than that
specified.</p>

<p>CONFORMING TO getopt(): POSIX.2 and POSIX.1-2001,
provided the environment variable POSIXLY_CORRECT is set.
Otherwise, the elements of argv arent really const, because
we permute them. We pretend theyre const in the prototype to
be compatible with other systems.</p>

<p>On some older implementations, getopt() was declared in
&lt;stdio.h&gt;. SUSv1 permitted the declaration to appear
in either &lt;unistd.h&gt; or &lt;stdio.h&gt;. POSIX.1-2001
marked the use of &lt;stdio.h&gt; for this purpose as
LEGACY. POSIX.1-2001 does not allow the declaration to
appear in &lt;stdio.h&gt;.</p>

<p>GNU 2004-07-28 GETOPT(3)</p>
<hr>
</body>
</html>
