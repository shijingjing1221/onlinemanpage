<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:33:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STRUCT I2C_BOARD_INF</title>

</head>
<body>

<h1 align="center">STRUCT I2C_BOARD_INF</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#MEMBERS">MEMBERS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">struct_i2c_board_info
&minus; template for device creation</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">struct
i2c_board_info { <br>
char type[I2C_NAME_SIZE]; <br>
unsigned short flags; <br>
unsigned short addr; <br>
void * platform_data; <br>
struct dev_archdata * archdata; <br>
struct device_node * of_node; <br>
struct acpi_dev_node acpi_node; <br>
int irq; <br>
};</p>

<h2>MEMBERS
<a name="MEMBERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">type[I2C_NAME_SIZE]</p>

<p style="margin-left:17%;">chip type, to initialize
i2c_client.name</p>

<p style="margin-left:11%; margin-top: 1em">flags</p>

<p style="margin-left:17%;">to initialize
i2c_client.flags</p>

<p style="margin-left:11%; margin-top: 1em">addr</p>

<p style="margin-left:17%;">stored in i2c_client.addr</p>


<p style="margin-left:11%; margin-top: 1em">platform_data</p>

<p style="margin-left:17%;">stored in
i2c_client.dev.platform_data</p>

<p style="margin-left:11%; margin-top: 1em">archdata</p>

<p style="margin-left:17%;">copied into
i2c_client.dev.archdata</p>

<p style="margin-left:11%; margin-top: 1em">of_node</p>

<p style="margin-left:17%;">pointer to OpenFirmware device
node</p>

<p style="margin-left:11%; margin-top: 1em">acpi_node</p>

<p style="margin-left:17%;">ACPI device node</p>

<p style="margin-left:11%; margin-top: 1em">irq</p>

<p style="margin-left:17%;">stored in i2c_client.irq</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">I2C doesn't
actually support hardware probing, although controllers and
devices may be able to use I2C_SMBUS_QUICK to tell whether
or not there's a device at a given address. Drivers commonly
need more information than that, such as chip type,
configuration, associated IRQ, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">i2c_board_info
is used to build tables of information listing I2C devices
that are present. This information is used to grow the
driver model tree. For mainboards this is done statically
using <b>i2c_register_board_info</b>; bus numbers identify
adapters that aren't yet available. For add&minus;on boards,
<b>i2c_new_device</b> does this dynamically with the adapter
already known.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<hr>
</body>
</html>
