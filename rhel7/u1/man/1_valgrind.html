<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:40:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>VALGRIND</title>

</head>
<body>

<h1 align="center">VALGRIND</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#TOOL SELECTION OPTIONS">TOOL SELECTION OPTIONS</a><br>
<a href="#BASIC OPTIONS">BASIC OPTIONS</a><br>
<a href="#ERROR-RELATED OPTIONS">ERROR-RELATED OPTIONS</a><br>
<a href="#MALLOC()-RELATED OPTIONS">MALLOC()-RELATED OPTIONS</a><br>
<a href="#UNCOMMON OPTIONS">UNCOMMON OPTIONS</a><br>
<a href="#DEBUGGING VALGRIND OPTIONS">DEBUGGING VALGRIND OPTIONS</a><br>
<a href="#MEMCHECK OPTIONS">MEMCHECK OPTIONS</a><br>
<a href="#CACHEGRIND OPTIONS">CACHEGRIND OPTIONS</a><br>
<a href="#CALLGRIND OPTIONS">CALLGRIND OPTIONS</a><br>
<a href="#HELGRIND OPTIONS">HELGRIND OPTIONS</a><br>
<a href="#DRD OPTIONS">DRD OPTIONS</a><br>
<a href="#MASSIF OPTIONS">MASSIF OPTIONS</a><br>
<a href="#SGCHECK OPTIONS">SGCHECK OPTIONS</a><br>
<a href="#BBV OPTIONS">BBV OPTIONS</a><br>
<a href="#LACKEY OPTIONS">LACKEY OPTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">valgrind
&minus; a suite of tools for debugging and profiling
programs</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>valgrind</b>
[<i>valgrind&minus;options</i>] [<b>your&minus;program</b>]
[<i>your&minus;program&minus;options</i>]</p> </td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Valgrind</b>
is a flexible program for debugging and profiling Linux
executables. It consists of a core, which provides a
synthetic CPU in software, and a series of debugging and
profiling tools. The architecture is modular, so that new
tools can be created easily and without disturbing the
existing structure.</p>

<p style="margin-left:11%; margin-top: 1em">Some of the
options described below work with all Valgrind tools, and
some only work with a few or one. The section MEMCHECK
OPTIONS and those below it describe tool&minus;specific
options.</p>

<p style="margin-left:11%; margin-top: 1em">This manual
page covers only basic usage and options. For more
comprehensive information, please see the HTML documentation
on your system: $INSTALL/share/doc/valgrind/html/index.html,
or online:
http://www.valgrind.org/docs/manual/index.html.</p>

<h2>TOOL SELECTION OPTIONS
<a name="TOOL SELECTION OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The single most
important option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;tool=&lt;toolname&gt;
[default: memcheck]</b></p>

<p style="margin-left:17%;">Run the Valgrind tool called
<i>toolname</i>, e.g. memcheck, cachegrind, callgrind,
helgrind, drd, massif, lackey, none, exp&minus;sgcheck,
exp&minus;bbv, exp&minus;dhat, etc.</p>

<h2>BASIC OPTIONS
<a name="BASIC OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These options
work with all tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b>&minus;h
&minus;&minus;help</b></p>

<p style="margin-left:17%;">Show help for all options, both
for the core and for the selected tool. If the option is
repeated it is equivalent to giving
<b>&minus;&minus;help&minus;debug</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help&minus;debug</b></p>

<p style="margin-left:17%;">Same as
<b>&minus;&minus;help</b>, but also lists debugging options
which usually are only of use to Valgrind's developers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;version</b></p>

<p style="margin-left:17%;">Show the version number of the
Valgrind core. Tools can have their own version numbers.
There is a scheme in place to ensure that tools only execute
when the core version is one they are known to work with.
This was done to minimise the chances of strange problems
arising from tool&minus;vs&minus;core version
incompatibilities.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;q</b>,
<b>&minus;&minus;quiet</b></p>

<p style="margin-left:17%;">Run silently, and only print
error messages. Useful if you are running regression tests
or have some other automated test machinery.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Be more verbose. Gives extra
information on various aspects of your program, such as: the
shared objects loaded, the suppressions used, the progress
of the instrumentation and execution engines, and warnings
about unusual behaviour. Repeating the option increases the
verbosity level.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;children=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
trace into sub&minus;processes initiated via the <i>exec</i>
system call. This is necessary for multi&minus;process
programs.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
Valgrind does trace into the child of a <i>fork</i> (it
would be difficult not to, since <i>fork</i> makes an
identical copy of a process), so this option is arguably
badly named. However, most children of <i>fork</i> calls
immediately call <i>exec</i> anyway.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;children&minus;skip=patt1,patt2,...</b></p>

<p style="margin-left:17%;">This option only has an effect
when <b>&minus;&minus;trace&minus;children=yes</b> is
specified. It allows for some children to be skipped. The
option takes a comma separated list of patterns for the
names of child executables that Valgrind should not trace
into. Patterns may include the metacharacters ? and *, which
have the usual meaning.</p>

<p style="margin-left:17%; margin-top: 1em">This can be
useful for pruning uninteresting branches from a tree of
processes being run on Valgrind. But you should be careful
when using it. When Valgrind skips tracing into an
executable, it doesn't just skip tracing that executable, it
also skips tracing any of that executable's child processes.
In other words, the flag doesn't merely cause tracing to
stop at the specified executables &minus;&minus; it skips
tracing of entire process subtrees rooted at any of the
specified executables.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;children&minus;skip&minus;by&minus;arg=patt1,patt2,...</b></p>

<p style="margin-left:17%;">This is the same as
<b>&minus;&minus;trace&minus;children&minus;skip</b>, with
one difference: the decision as to whether to trace into a
child process is made by examining the arguments to the
child process, rather than the name of its executable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;child&minus;silent&minus;after&minus;fork=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will not
show any debugging or logging output for the child process
resulting from a <i>fork</i> call. This can make the output
less confusing (although more misleading) when dealing with
processes that create children. It is particularly useful in
conjunction with <i>&minus;&minus;trace&minus;children=</i>.
Use of this option is also strongly recommended if you are
requesting XML output (<i>&minus;&minus;xml=yes</i>), since
otherwise the XML from child and parent may become mixed up,
which usually makes it useless.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb=&lt;no|yes|full&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Valgrind will provide
&quot;gdbserver&quot; functionality when
<b>&minus;&minus;vgdb=yes</b> or
<b>&minus;&minus;vgdb=full</b> is specified. This allows an
external GNU GDB debugger to control and debug your program
when it runs on Valgrind. <b>&minus;&minus;vgdb=full</b>
incurs significant performance overheads, but provides more
precise breakpoints and watchpoints. See Debugging your
program using Valgrind&rsquo;s gdbserver and GDB for a
detailed description.</p>

<p style="margin-left:17%; margin-top: 1em">If the embedded
gdbserver is enabled but no gdb is currently being used, the
vgdb command line utility can send &quot;monitor
commands&quot; to Valgrind from a shell. The Valgrind core
provides a set of Valgrind monitor commands. A tool can
optionally provide tool specific monitor commands, which are
documented in the tool specific chapter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb&minus;error=&lt;number&gt;
[default: 999999999]</b></p>

<p style="margin-left:17%;">Use this option when the
Valgrind gdbserver is enabled with
<b>&minus;&minus;vgdb=yes</b> or
<b>&minus;&minus;vgdb=full</b>. Tools that report errors
will wait for &quot;number&quot; errors to be reported
before freezing the program and waiting for you to connect
with GDB. It follows that a value of zero will cause the
gdbserver to be started before your program is executed.
This is typically used to insert GDB breakpoints before
execution, and also works with tools that do not report
errors, such as Massif.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb&minus;stop&minus;at=&lt;set&gt;
[default: none]</b></p>

<p style="margin-left:17%;">Use this option when the
Valgrind gdbserver is enabled with
<b>&minus;&minus;vgdb=yes</b> or
<b>&minus;&minus;vgdb=full</b>. The Valgrind gdbserver will
be invoked for each error after
<b>&minus;&minus;vgdb&minus;error</b> have been reported.
You can additionally ask the Valgrind gdbserver to be
invoked for other events, specified in one of the following
ways:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a comma
separated list of one or more of <b>startup exit
valgrindabexit</b>.</p>

<p style="margin-left:23%; margin-top: 1em">The values
<b>startupexitvalgrindabexit</b> respectively indicate to
invoke gdbserver before your program is executed, after the
last instruction of your program, on Valgrind abnormal exit
(e.g. internal error, out of memory, ...).</p>

<p style="margin-left:23%; margin-top: 1em">Note:
<b>startup</b> and <b>&minus;&minus;vgdb&minus;error=0</b>
will both cause Valgrind gdbserver to be invoked before your
program is executed. The
<b>&minus;&minus;vgdb&minus;error=0</b> will in addition
cause your program to stop on all subsequent errors.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>all</b> to specify the complete set. It is equivalent to
<b>&minus;&minus;vgdb&minus;stop&minus;at=startup,exit,valgrindabexit</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>none</b> for the empty set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;track&minus;fds=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
print out a list of open file descriptors on exit or on
request, via the gdbserver monitor command <i>v.info
open_fds</i>. Along with each file descriptor is printed a
stack backtrace of where the file was opened and any details
relating to the file descriptor such as the file name or
socket details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;time&minus;stamp=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, each message is
preceded with an indication of the elapsed wallclock time
since startup, expressed as days, hours, minutes, seconds
and milliseconds.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;log&minus;fd=&lt;number&gt;
[default: 2, stderr]</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send all of its messages to the specified file descriptor.
The default, 2, is the standard error channel (stderr). Note
that this may interfere with the client's own use of stderr,
as Valgrind's output will be interleaved with any output
that the client sends to stderr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;log&minus;file=&lt;filename&gt;</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send all of its messages to the specified file. If the file
name is empty, it causes an abort. There are three special
format specifiers that can be used in the file name.</p>

<p style="margin-left:17%; margin-top: 1em"><b>%p</b> is
replaced with the current process ID. This is very useful
for program that invoke multiple processes. WARNING: If you
use <b>&minus;&minus;trace&minus;children=yes</b> and your
program invokes multiple processes OR your program forks
without calling exec afterwards, and you don't use this
specifier (or the <b>%q</b> specifier below), the Valgrind
output from all those processes will go into one file,
possibly jumbled up, and possibly incomplete.</p>

<p style="margin-left:17%; margin-top: 1em"><b>%q{FOO}</b>
is replaced with the contents of the environment variable
<i>FOO</i>. If the <b>{FOO}</b> part is malformed, it causes
an abort. This specifier is rarely needed, but very useful
in certain circumstances (eg. when running MPI programs).
The idea is that you specify a variable which will be set
differently for each process in the job, for example
BPROC_RANK or whatever is applicable in your MPI setup. If
the named environment variable is not set, it causes an
abort. Note that in some shells, the <b>{</b> and <b>}</b>
characters may need to be escaped with a backslash.</p>

<p style="margin-left:17%; margin-top: 1em"><b>%%</b> is
replaced with <b>%</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If an <b>%</b>
is followed by any other character, it causes an abort.</p>

<p style="margin-left:17%; margin-top: 1em">If the file
name specifies a relative file name, it is put in the
program's initial working directory : this is the current
directory when the program started its execution after the
fork or after the exec. If it specifies an absolute file
name (ie. starts with '/') then it is put there.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;log&minus;socket=&lt;ip&minus;address:port&minus;number&gt;</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send all of its messages to the specified port at the
specified IP address. The port may be omitted, in which case
port 1500 is used. If a connection cannot be made to the
specified socket, Valgrind falls back to writing output to
the standard error (stderr). This option is intended to be
used in conjunction with the valgrind&minus;listener
program. For further details, see the commentary in the
manual.</p>

<h2>ERROR-RELATED OPTIONS
<a name="ERROR-RELATED OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These options
are used by all tools that can report errors, e.g. Memcheck,
but not Cachegrind.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;xml=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, the important
parts of the output (e.g. tool error messages) will be in
XML format rather than plain text. Furthermore, the XML
output will be sent to a different output channel than the
plain text output. Therefore, you also must use one of
<b>&minus;&minus;xml&minus;fd</b>,
<b>&minus;&minus;xml&minus;file</b> or
<b>&minus;&minus;xml&minus;socket</b> to specify where the
XML is to be sent.</p>

<p style="margin-left:17%; margin-top: 1em">Less important
messages will still be printed in plain text, but because
the XML output and plain text output are sent to different
output channels (the destination of the plain text output is
still controlled by <b>&minus;&minus;log&minus;fd</b>,
<b>&minus;&minus;log&minus;file</b> and
<b>&minus;&minus;log&minus;socket</b>) this should not cause
problems.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
aimed at making life easier for tools that consume
Valgrind's output as input, such as GUI front ends.
Currently this option works with Memcheck, Helgrind, DRD and
SGcheck. The output format is specified in the file
docs/internals/xml&minus;output&minus;protocol4.txt in the
source tree for Valgrind 3.5.0 or later.</p>

<p style="margin-left:17%; margin-top: 1em">The recommended
options for a GUI to pass, when requesting XML output, are:
<b>&minus;&minus;xml=yes</b> to enable XML output,
<b>&minus;&minus;xml&minus;file</b> to send the XML output
to a (presumably GUI&minus;selected) file,
<b>&minus;&minus;log&minus;file</b> to send the plain text
output to a second GUI&minus;selected file,
<b>&minus;&minus;child&minus;silent&minus;after&minus;fork=yes</b>,
and <b>&minus;q</b> to restrict the plain text output to
critical error messages created by Valgrind itself. For
example, failure to read a specified suppressions file
counts as a critical error message. In this way, for a
successful run the text output file will be empty. But if it
isn't empty, then it will contain important information
which the GUI user should be made aware of.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;xml&minus;fd=&lt;number&gt;
[default: &minus;1, disabled]</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send its XML output to the specified file descriptor. It
must be used in conjunction with
<b>&minus;&minus;xml=yes</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;xml&minus;file=&lt;filename&gt;</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send its XML output to the specified file. It must be used
in conjunction with <b>&minus;&minus;xml=yes</b>. Any
<b>%p</b> or <b>%q</b> sequences appearing in the filename
are expanded in exactly the same way as they are for
<b>&minus;&minus;log&minus;file</b>. See the description of
<b>&minus;&minus;log&minus;file</b> for details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;xml&minus;socket=&lt;ip&minus;address:port&minus;number&gt;</b></p>

<p style="margin-left:17%;">Specifies that Valgrind should
send its XML output the specified port at the specified IP
address. It must be used in conjunction with
<b>&minus;&minus;xml=yes</b>. The form of the argument is
the same as that used by
<b>&minus;&minus;log&minus;socket</b>. See the description
of <b>&minus;&minus;log&minus;socket</b> for further
details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;xml&minus;user&minus;comment=&lt;string&gt;</b></p>

<p style="margin-left:17%;">Embeds an extra user comment
string at the start of the XML output. Only works when
<b>&minus;&minus;xml=yes</b> is specified; ignored
otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;demangle=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Enable/disable automatic
demangling (decoding) of C++ names. Enabled by default. When
enabled, Valgrind will attempt to translate encoded C++
names back to something approaching the original. The
demangler handles symbols mangled by g++ versions 2.X, 3.X
and 4.X.</p>

<p style="margin-left:17%; margin-top: 1em">An important
fact about demangling is that function names mentioned in
suppressions files should be in their mangled form. Valgrind
does not demangle function names when searching for
applicable suppressions, because to do otherwise would make
suppression file contents dependent on the state of
Valgrind's demangling machinery, and also slow down
suppression matching.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;num&minus;callers=&lt;number&gt;
[default: 12]</b></p>

<p style="margin-left:17%;">Specifies the maximum number of
entries shown in stack traces that identify program
locations. Note that errors are commoned up using only the
top four function locations (the place in the current
function, and that of its three immediate callers). So this
doesn't affect the total number of errors reported.</p>

<p style="margin-left:17%; margin-top: 1em">The maximum
value for this is 500. Note that higher settings will make
Valgrind run a bit more slowly and take a bit more memory,
but can be useful when working with programs with
deeply&minus;nested call chains.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;unw&minus;stack&minus;scan&minus;thresh=&lt;number&gt;
[default: 0]</b> ,
<b>&minus;&minus;unw&minus;stack&minus;scan&minus;frames=&lt;number&gt;
[default: 5]</b></p>

<p style="margin-left:17%;">Stack&minus;scanning support is
available only on ARM targets.</p>

<p style="margin-left:17%; margin-top: 1em">These flags
enable and control stack unwinding by stack scanning. When
the normal stack unwinding mechanisms &minus;&minus; usage
of Dwarf CFI records, and frame&minus;pointer following
&minus;&minus; fail, stack scanning may be able to recover a
stack trace.</p>

<p style="margin-left:17%; margin-top: 1em">Note that stack
scanning is an imprecise, heuristic mechanism that may give
very misleading results, or none at all. It should be used
only in emergencies, when normal unwinding fails, and it is
important to nevertheless have stack traces.</p>

<p style="margin-left:17%; margin-top: 1em">Stack scanning
is a simple technique: the unwinder reads words from the
stack, and tries to guess which of them might be return
addresses, by checking to see if they point just after ARM
or Thumb call instructions. If so, the word is added to the
backtrace.</p>

<p style="margin-left:17%; margin-top: 1em">The main danger
occurs when a function call returns, leaving its return
address exposed, and a new function is called, but the new
function does not overwrite the old address. The result of
this is that the backtrace may contain entries for functions
which have already returned, and so be very confusing.</p>

<p style="margin-left:17%; margin-top: 1em">A second
limitation of this implementation is that it will scan only
the page (4KB, normally) containing the starting stack
pointer. If the stack frames are large, this may result in
only a few (or not even any) being present in the trace.
Also, if you are unlucky and have an initial stack pointer
near the end of its containing page, the scan may miss all
interesting frames.</p>

<p style="margin-left:17%; margin-top: 1em">By default
stack scanning is disabled. The normal use case is to ask
for it when a stack trace would otherwise be very short. So,
to enable it, use
&minus;&minus;unw&minus;stack&minus;scan&minus;thresh=number.
This requests Valgrind to try using stack scanning to
&quot;extend&quot; stack traces which contain fewer than
number frames.</p>

<p style="margin-left:17%; margin-top: 1em">If stack
scanning does take place, it will only generate at most the
number of frames specified by
&minus;&minus;unw&minus;stack&minus;scan&minus;frames.
Typically, stack scanning generates so many garbage entries
that this value is set to a low value (5) by default. In no
case will a stack trace larger than the value specified by
&minus;&minus;num&minus;callers be created.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;error&minus;limit=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind stops
reporting errors after 10,000,000 in total, or 1,000
different ones, have been seen. This is to stop the error
tracking machinery from becoming a huge performance overhead
in programs with many errors.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;error&minus;exitcode=&lt;number&gt;
[default: 0]</b></p>

<p style="margin-left:17%;">Specifies an alternative exit
code to return if Valgrind reported any errors in the run.
When set to the default value (zero), the return value from
Valgrind will always be the return value of the process
being simulated. When set to a nonzero value, that value is
returned instead, if Valgrind detects any errors. This is
useful for using Valgrind as part of an automated test
suite, since it makes it easy to detect test cases for which
Valgrind has reported errors, just by inspecting return
codes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;sigill&minus;diagnostics=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Enable/disable printing of
illegal instruction diagnostics. Enabled by default, but
defaults to disabled when <b>&minus;&minus;quiet</b> is
given. The default can always be explicitly overridden by
giving this option.</p>

<p style="margin-left:17%; margin-top: 1em">When enabled, a
warning message will be printed, along with some
diagnostics, whenever an instruction is encountered that
Valgrind cannot decode or translate, before the program is
given a SIGILL signal. Often an illegal instruction
indicates a bug in the program or missing support for the
particular instruction in Valgrind. But some programs do
deliberately try to execute an instruction that might be
missing and trap the SIGILL signal to detect processor
features. Using this flag makes it possible to avoid the
diagnostic output that you would otherwise get in such
cases.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;below&minus;main=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">By default, stack traces for
errors do not show any functions that appear beneath
<b>main</b> because most of the time it's uninteresting C
library stuff and/or gobbledygook. Alternatively, if
<b>main</b> is not present in the stack trace, stack traces
will not show any functions below <b>main</b>&minus;like
functions such as glibc's <b>__libc_start_main</b>.
Furthermore, if <b>main</b>&minus;like functions are present
in the trace, they are normalised as <b>(below main)</b>, in
order to make the output more deterministic.</p>

<p style="margin-left:17%; margin-top: 1em">If this option
is enabled, all stack trace entries will be shown and
<b>main</b>&minus;like functions will not be normalised.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;fullpath&minus;after=&lt;string&gt;
[default: don't show source paths]</b></p>

<p style="margin-left:17%;">By default Valgrind only shows
the filenames in stack traces, but not full paths to source
files. When using Valgrind in large projects where the
sources reside in multiple different directories, this can
be inconvenient. <b>&minus;&minus;fullpath&minus;after</b>
provides a flexible solution to this problem. When this
option is present, the path to each source file is shown,
with the following all&minus;important caveat: if
<b>string</b> is found in the path, then the path up to and
including <b>string</b> is omitted, else the path is shown
unmodified. Note that <b>string</b> is not required to be a
prefix of the path.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
consider a file named
/home/janedoe/blah/src/foo/bar/xyzzy.c. Specifying
<b>&minus;&minus;fullpath&minus;after=/home/janedoe/blah/src/</b>
will cause Valgrind to show the name as foo/bar/xyzzy.c.</p>

<p style="margin-left:17%; margin-top: 1em">Because the
string is not required to be a prefix,
<b>&minus;&minus;fullpath&minus;after=src/</b> will produce
the same output. This is useful when the path contains
arbitrary machine&minus;generated characters. For example,
the path /my/build/dir/C32A1B47/blah/src/foo/xyzzy can be
pruned to foo/xyzzy using
<b>&minus;&minus;fullpath&minus;after=/blah/src/</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If you simply
want to see the full path, just specify an empty string:
<b>&minus;&minus;fullpath&minus;after=</b>. This isn't a
special case, merely a logical consequence of the above
rules.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, you
can use <b>&minus;&minus;fullpath&minus;after</b> multiple
times. Any appearance of it causes Valgrind to switch to
producing full paths and applying the above filtering rule.
Each produced path is compared against all the
<b>&minus;&minus;fullpath&minus;after</b>&minus;specified
strings, in the order specified. The first string to match
causes the path to be truncated as described above. If none
match, the full path is shown. This facilitates chopping off
prefixes when the sources are drawn from a number of
unrelated directories.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;extra&minus;debuginfo&minus;path=&lt;path&gt;
[default: undefined and unused]</b></p>

<p style="margin-left:17%;">By default Valgrind searches in
several well&minus;known paths for debug objects, such as
/usr/lib/debug/.</p>

<p style="margin-left:17%; margin-top: 1em">However, there
may be scenarios where you may wish to put debug objects at
an arbitrary location, such as external storage when running
Valgrind on a mobile device with limited local storage.
Another example might be a situation where you do not have
permission to install debug object packages on the system
where you are running Valgrind.</p>

<p style="margin-left:17%; margin-top: 1em">In these
scenarios, you may provide an absolute path as an extra,
final place for Valgrind to search for debug objects by
specifying
<b>&minus;&minus;extra&minus;debuginfo&minus;path=/path/to/debug/objects</b>.
The given path will be prepended to the absolute path name
of the searched&minus;for object. For example, if Valgrind
is looking for the debuginfo for /w/x/y/zz.so and
<b>&minus;&minus;extra&minus;debuginfo&minus;path=/a/b/c</b>
is specified, it will look for a debug object at
/a/b/c/w/x/y/zz.so.</p>

<p style="margin-left:17%; margin-top: 1em">This flag
should only be specified once. If it is specified multiple
times, only the last instance is honoured.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;debuginfo&minus;server=ipaddr:port
[default: undefined and unused]</b></p>

<p style="margin-left:17%;">This is a new, experimental,
feature introduced in version 3.9.0.</p>

<p style="margin-left:17%; margin-top: 1em">In some
scenarios it may be convenient to read debuginfo from
objects stored on a different machine. With this flag,
Valgrind will query a debuginfo server running on ipaddr and
listening on port port, if it cannot find the debuginfo
object in the local filesystem.</p>

<p style="margin-left:17%; margin-top: 1em">The debuginfo
server must accept TCP connections on port port. The
debuginfo server is contained in the source file
auxprogs/valgrind&minus;di&minus;server.c. It will only
serve from the directory it is started in. port defaults to
1500 in both client and server if not specified.</p>

<p style="margin-left:17%; margin-top: 1em">If Valgrind
looks for the debuginfo for /w/x/y/zz.so by using the
debuginfo server, it will strip the pathname components and
merely request zz.so on the server. That in turn will look
only in its current working directory for a matching
debuginfo object.</p>

<p style="margin-left:17%; margin-top: 1em">The debuginfo
data is transmitted in small fragments (8 KB) as requested
by Valgrind. Each block is compressed using LZO to reduce
transmission time. The implementation has been tuned for
best performance over a single&minus;stage 802.11g (WiFi)
network link.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
checks for matching primary vs debug objects, using GNU
debuglink CRC scheme, are performed even when using the
debuginfo server. To disable such checking, you need to also
specify
&minus;&minus;allow&minus;mismatched&minus;debuginfo=yes.</p>

<p style="margin-left:17%; margin-top: 1em">By default the
Valgrind build system will build
valgrind&minus;di&minus;server for the target platform,
which is almost certainly not what you want. So far we have
been unable to find out how to get automake/autoconf to
build it for the build platform. If you want to use it, you
will have to recompile it by hand using the command shown at
the top of auxprogs/valgrind&minus;di&minus;server.c.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;allow&minus;mismatched&minus;debuginfo=no|yes
[no]</b></p>

<p style="margin-left:17%;">When reading debuginfo from
separate debuginfo objects, Valgrind will by default check
that the main and debuginfo objects match, using the GNU
debuglink mechanism. This guarantees that it does not read
debuginfo from out of date debuginfo objects, and also
ensures that Valgrind can't crash as a result of
mismatches.</p>

<p style="margin-left:17%; margin-top: 1em">This check can
be overridden using
&minus;&minus;allow&minus;mismatched&minus;debuginfo=yes.
This may be useful when the debuginfo and main objects have
not been split in the proper way. Be careful when using
this, though: it disables all consistency checking, and
Valgrind has been observed to crash when the main and
debuginfo objects don't match.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;suppressions=&lt;filename&gt;
[default: $PREFIX/lib/valgrind/default.supp]</b></p>

<p style="margin-left:17%;">Specifies an extra file from
which to read descriptions of errors to suppress. You may
use up to 100 extra suppression files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;gen&minus;suppressions=&lt;yes|no|all&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When set to <i>yes</i>,
Valgrind will pause after every error shown and print the
line:</p>


<p style="margin-left:23%; margin-top: 1em">&minus;&minus;&minus;&minus;
Print suppression ? &minus;&minus;&minus;
[Return/N/n/Y/y/C/c] &minus;&minus;&minus;&minus;</p>

<p style="margin-left:17%; margin-top: 1em">The prompt's
behaviour is the same as for the
<b>&minus;&minus;db&minus;attach</b> option (see below).</p>

<p style="margin-left:17%; margin-top: 1em">If you choose
to, Valgrind will print out a suppression for this error.
You can then cut and paste it into a suppression file if you
don't want to hear about the error in the future.</p>

<p style="margin-left:17%; margin-top: 1em">When set to
<i>all</i>, Valgrind will print a suppression for every
reported error, without querying the user.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
particularly useful with C++ programs, as it prints out the
suppressions with mangled names, as required.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
suppressions printed are as specific as possible. You may
want to common up similar ones, by adding wildcards to
function names, and by using frame&minus;level wildcards.
The wildcarding facilities are powerful yet flexible, and
with a bit of careful editing, you may be able to suppress a
whole family of related errors with only a few
suppressions.</p>

<p style="margin-left:17%; margin-top: 1em">Sometimes two
different errors are suppressed by the same suppression, in
which case Valgrind will output the suppression more than
once, but you only need to have one copy in your suppression
file (but having more than one won't cause problems). Also,
the suppression name is given as &lt;insert a suppression
name here&gt;; the name doesn't really matter, it's only
used with the <b>&minus;v</b> option which prints out all
used suppression records.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;db&minus;attach=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
pause after every error shown and print the line:</p>


<p style="margin-left:23%; margin-top: 1em">&minus;&minus;&minus;&minus;
Attach to debugger ? &minus;&minus;&minus;
[Return/N/n/Y/y/C/c] &minus;&minus;&minus;&minus;</p>

<p style="margin-left:17%; margin-top: 1em">Pressing
<i>Ret</i>, or <i>N Ret</i> or <i>n Ret</i>, causes Valgrind
not to start a debugger for this error.</p>

<p style="margin-left:17%; margin-top: 1em">Pressing <i>Y
Ret</i> or <i>y Ret</i> causes Valgrind to start a debugger
for the program at this point. When you have finished with
the debugger, quit from it, and the program will continue.
Trying to continue from inside the debugger doesn't
work.</p>

<p style="margin-left:17%; margin-top: 1em">Note: if you
use GDB, more powerful debugging support is provided by the
<b>&minus;&minus;vgdb=</b><i>yes</i> or <i>full</i> value.
This activates Valgrind's internal gdbserver, which provides
more&minus;or&minus;less full GDB&minus;style control of the
application: insertion of breakpoints, continuing from
inside GDB, inferior function calls, and much more.</p>

<p style="margin-left:17%; margin-top: 1em"><i>C Ret</i> or
<i>c Ret</i> causes Valgrind not to start a debugger, and
not to ask again.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;db&minus;command=&lt;command&gt;
[default: gdb &minus;nw %f %p]</b></p>

<p style="margin-left:17%;">Specify the debugger to use
with the <b>&minus;&minus;db&minus;attach</b> command. The
default debugger is GDB. This option is a template that is
expanded by Valgrind at runtime. %f is replaced with the
executable's file name and %p is replaced by the process ID
of the executable.</p>

<p style="margin-left:17%; margin-top: 1em">This specifies
how Valgrind will invoke the debugger. By default it will
use whatever GDB is detected at build time, which is usually
/usr/bin/gdb. Using this command, you can specify some
alternative command to invoke the debugger you want to
use.</p>

<p style="margin-left:17%; margin-top: 1em">The command
string given can include one or instances of the %p and %f
expansions. Each instance of %p expands to the PID of the
process to be debugged and each instance of %f expands to
the path to the executable for the process to be
debugged.</p>

<p style="margin-left:17%; margin-top: 1em">Since
&lt;command&gt; is likely to contain spaces, you will need
to put this entire option in quotes to ensure it is
correctly handled by the shell.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;input&minus;fd=&lt;number&gt;
[default: 0, stdin]</b></p>

<p style="margin-left:17%;">When using
<b>&minus;&minus;db&minus;attach=yes</b> or
<b>&minus;&minus;gen&minus;suppressions=yes</b>, Valgrind
will stop so as to read keyboard input from you when each
error occurs. By default it reads from the standard input
(stdin), which is problematic for programs which close
stdin. This option allows you to specify an alternative file
descriptor from which to read input.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dsymutil=no|yes
[no]</b></p>

<p style="margin-left:17%;">This option is only relevant
when running Valgrind on Mac OS X.</p>

<p style="margin-left:17%; margin-top: 1em">Mac OS X uses a
deferred debug information (debuginfo) linking scheme. When
object files containing debuginfo are linked into a .dylib
or an executable, the debuginfo is not copied into the final
file. Instead, the debuginfo must be linked manually by
running dsymutil, a system&minus;provided utility, on the
executable or .dylib. The resulting combined debuginfo is
placed in a directory alongside the executable or .dylib,
but with the extension .dSYM.</p>

<p style="margin-left:17%; margin-top: 1em">With
<b>&minus;&minus;dsymutil=no</b>, Valgrind will detect cases
where the .dSYM directory is either missing, or is present
but does not appear to match the associated executable or
.dylib, most likely because it is out of date. In these
cases, Valgrind will print a warning message but take no
further action.</p>

<p style="margin-left:17%; margin-top: 1em">With
<b>&minus;&minus;dsymutil=yes</b>, Valgrind will, in such
cases, automatically run dsymutil as necessary to bring the
debuginfo up to date. For all practical purposes, if you
always use <b>&minus;&minus;dsymutil=yes</b>, then there is
never any need to run dsymutil manually or as part of your
applications's build system, since Valgrind will run it as
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">Valgrind will
not attempt to run dsymutil on any executable or library in
/usr/, /bin/, /sbin/, /opt/, /sw/, /System/, /Library/ or
/Applications/ since dsymutil will always fail in such
situations. It fails both because the debuginfo for such
pre&minus;installed system components is not available
anywhere, and also because it would require write privileges
in those directories.</p>

<p style="margin-left:17%; margin-top: 1em">Be careful when
using <b>&minus;&minus;dsymutil=yes</b>, since it will cause
pre&minus;existing .dSYM directories to be silently deleted
and re&minus;created. Also note that dsymutil is quite slow,
sometimes excessively so.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;max&minus;stackframe=&lt;number&gt;
[default: 2000000]</b></p>

<p style="margin-left:17%;">The maximum size of a stack
frame. If the stack pointer moves by more than this amount
then Valgrind will assume that the program is switching to a
different stack.</p>

<p style="margin-left:17%; margin-top: 1em">You may need to
use this option if your program has large
stack&minus;allocated arrays. Valgrind keeps track of your
program's stack pointer. If it changes by more than the
threshold amount, Valgrind assumes your program is switching
to a different stack, and Memcheck behaves differently than
it would for a stack pointer change smaller than the
threshold. Usually this heuristic works well. However, if
your program allocates large structures on the stack, this
heuristic will be fooled, and Memcheck will subsequently
report large numbers of invalid stack accesses. This option
allows you to change the threshold to a different value.</p>

<p style="margin-left:17%; margin-top: 1em">You should only
consider use of this option if Valgrind's debug output
directs you to do so. In that case it will tell you the new
threshold you should specify.</p>

<p style="margin-left:17%; margin-top: 1em">In general,
allocating large structures on the stack is a bad idea,
because you can easily run out of stack space, especially on
systems with limited memory or which expect to support large
numbers of threads each with a small stack, and also because
the error checking performed by Memcheck is more effective
for heap&minus;allocated data than for stack&minus;allocated
data. If you have to use this option, you may wish to
consider rewriting your code to allocate on the heap rather
than on the stack.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;main&minus;stacksize=&lt;number&gt;
[default: use current 'ulimit' value]</b></p>

<p style="margin-left:17%;">Specifies the size of the main
thread's stack.</p>

<p style="margin-left:17%; margin-top: 1em">To simplify its
memory management, Valgrind reserves all required space for
the main thread's stack at startup. That means it needs to
know the required stack size at startup.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
Valgrind uses the current &quot;ulimit&quot; value for the
stack size, or 16 MB, whichever is lower. In many cases this
gives a stack size in the range 8 to 16 MB, which almost
never overflows for most applications.</p>

<p style="margin-left:17%; margin-top: 1em">If you need a
larger total stack size, use
<b>&minus;&minus;main&minus;stacksize</b> to specify it.
Only set it as high as you need, since reserving far more
space than you need (that is, hundreds of megabytes more
than you need) constrains Valgrind's memory allocators and
may reduce the total amount of memory that Valgrind can use.
This is only really of significance on 32&minus;bit
machines.</p>

<p style="margin-left:17%; margin-top: 1em">On Linux, you
may request a stack of size up to 2GB. Valgrind will stop
with a diagnostic message if the stack cannot be
allocated.</p>


<p style="margin-left:17%; margin-top: 1em"><b>&minus;&minus;main&minus;stacksize</b>
only affects the stack size for the program's initial
thread. It has no bearing on the size of thread stacks, as
Valgrind does not allocate those.</p>

<p style="margin-left:17%; margin-top: 1em">You may need to
use both <b>&minus;&minus;main&minus;stacksize</b> and
<b>&minus;&minus;max&minus;stackframe</b> together. It is
important to understand that
<b>&minus;&minus;main&minus;stacksize</b> sets the maximum
total stack size, whilst
<b>&minus;&minus;max&minus;stackframe</b> specifies the
largest size of any one stack frame. You will have to work
out the <b>&minus;&minus;main&minus;stacksize</b> value for
yourself (usually, if your applications segfaults). But
Valgrind will tell you the needed
<b>&minus;&minus;max&minus;stackframe</b> size, if
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">As discussed
further in the description of
<b>&minus;&minus;max&minus;stackframe</b>, a requirement for
a large stack is a sign of potential portability problems.
You are best advised to place all large data in
heap&minus;allocated memory.</p>

<h2>MALLOC()-RELATED OPTIONS
<a name="MALLOC()-RELATED OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For tools that
use their own version of malloc (e.g. Memcheck, Massif,
Helgrind, DRD), the following options apply.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;alignment=&lt;number&gt;
[default: 8 or 16, depending on the platform]</b></p>

<p style="margin-left:17%;">By default Valgrind's
<b>malloc</b>, <b>realloc</b>, etc, return a block whose
starting address is 8&minus;byte aligned or 16&minus;byte
aligned (the value depends on the platform and matches the
platform default). This option allows you to specify a
different alignment. The supplied value must be greater than
or equal to the default, less than or equal to 4096, and
must be a power of two.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;redzone&minus;size=&lt;number&gt;
[default: depends on the tool]</b></p>

<p style="margin-left:17%;">Valgrind's <b>malloc,
realloc,</b> etc, add padding blocks before and after each
heap block allocated by the program being run. Such padding
blocks are called redzones. The default value for the
redzone size depends on the tool. For example, Memcheck adds
and protects a minimum of 16 bytes before and after each
block allocated by the client. This allows it to detect
block underruns or overruns of up to 16 bytes.</p>

<p style="margin-left:17%; margin-top: 1em">Increasing the
redzone size makes it possible to detect overruns of larger
distances, but increases the amount of memory used by
Valgrind. Decreasing the redzone size will reduce the memory
needed by Valgrind but also reduces the chances of detecting
over/underruns, so is not recommended.</p>

<h2>UNCOMMON OPTIONS
<a name="UNCOMMON OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These options
apply to all tools, as they affect certain obscure workings
of the Valgrind core. Most people won't need to use
them.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;smc&minus;check=&lt;none|stack|all|all&minus;non&minus;file&gt;
[default: stack]</b></p>

<p style="margin-left:17%;">This option controls Valgrind's
detection of self&minus;modifying code. If no checking is
done, if a program executes some code, then overwrites it
with new code, and executes the new code, Valgrind will
continue to execute the translations it made for the old
code. This will likely lead to incorrect behaviour and/or
crashes.</p>

<p style="margin-left:17%; margin-top: 1em">Valgrind has
four levels of self&minus;modifying code detection: no
detection, detect self&minus;modifying code on the stack
(which is used by GCC to implement nested functions), detect
self&minus;modifying code everywhere, and detect
self&minus;modifying code everywhere except in
file&minus;backed mappings. Note that the default option
will catch the vast majority of cases. The main case it will
not catch is programs such as JIT compilers that dynamically
generate code <i>and</i> subsequently overwrite part or all
of it. Running with <i>all</i> will slow Valgrind down
noticeably. Running with <i>none</i> will rarely speed
things up, since very little code gets put on the stack for
most programs. The <b>VALGRIND_DISCARD_TRANSLATIONS</b>
client request is an alternative to
<b>&minus;&minus;smc&minus;check=all</b> that requires more
programmer effort but allows Valgrind to run your program
faster, by telling it precisely when translations need to be
re&minus;made.</p>


<p style="margin-left:17%; margin-top: 1em"><b>&minus;&minus;smc&minus;check=all&minus;non&minus;file</b>
provides a cheaper but more limited version of
<b>&minus;&minus;smc&minus;check=all</b>. It adds checks to
any translations that do not originate from
file&minus;backed memory mappings. Typical applications that
generate code, for example JITs in web browsers, generate
code into anonymous mmaped areas, whereas the
&quot;fixed&quot; code of the browser always lives in
file&minus;backed mappings.
<b>&minus;&minus;smc&minus;check=all&minus;non&minus;file</b>
takes advantage of this observation, limiting the overhead
of checking to code which is likely to be JIT generated.</p>

<p style="margin-left:17%; margin-top: 1em">Some
architectures (including ppc32, ppc64, ARM and MIPS) require
programs which create code at runtime to flush the
instruction cache in between code generation and first use.
Valgrind observes and honours such instructions. Hence, on
ppc32/Linux, ppc64/Linux and ARM/Linux, Valgrind always
provides complete, transparent support for
self&minus;modifying code. It is only on platforms such as
x86/Linux, AMD64/Linux, x86/Darwin and AMD64/Darwin that you
need to use this option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;read&minus;inline&minus;info=&lt;yes|no&gt;
[default: see below]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
read information about inlined function calls from DWARF3
debug info. This slows Valgrind startup and makes it use
more memory (typically for each inlined piece of code, 6
words and space for the function name), but it results in
more descriptive stacktraces. For the 3.10.0 release, this
functionality is enabled by default only for Linux and
Android targets and only for the tools Memcheck, Helgrind
and DRD. Here is an example of some stacktraces with
<b>&minus;&minus;read&minus;inline&minus;info=no</b>:</p>

<p style="margin-left:23%; margin-top: 1em">==15380==
Conditional jump or move depends on uninitialised value(s)
<br>
==15380== at 0x80484EA: main (inlinfo.c:6) <br>
==15380== <br>
==15380== Conditional jump or move depends on uninitialised
value(s) <br>
==15380== at 0x8048550: fun_noninline (inlinfo.c:6) <br>
==15380== by 0x804850E: main (inlinfo.c:34) <br>
==15380== <br>
==15380== Conditional jump or move depends on uninitialised
value(s) <br>
==15380== at 0x8048520: main (inlinfo.c:6)</p>

<p style="margin-left:17%; margin-top: 1em">And here are
the same errors with
<b>&minus;&minus;read&minus;inline&minus;info=yes</b>:</p>

<p style="margin-left:23%; margin-top: 1em">==15377==
Conditional jump or move depends on uninitialised value(s)
<br>
==15377== at 0x80484EA: fun_d (inlinfo.c:6) <br>
==15377== by 0x80484EA: fun_c (inlinfo.c:14) <br>
==15377== by 0x80484EA: fun_b (inlinfo.c:20) <br>
==15377== by 0x80484EA: fun_a (inlinfo.c:26) <br>
==15377== by 0x80484EA: main (inlinfo.c:33) <br>
==15377== <br>
==15377== Conditional jump or move depends on uninitialised
value(s) <br>
==15377== at 0x8048550: fun_d (inlinfo.c:6) <br>
==15377== by 0x8048550: fun_noninline (inlinfo.c:41) <br>
==15377== by 0x804850E: main (inlinfo.c:34) <br>
==15377== <br>
==15377== Conditional jump or move depends on uninitialised
value(s) <br>
==15377== at 0x8048520: fun_d (inlinfo.c:6) <br>
==15377== by 0x8048520: main (inlinfo.c:35)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;read&minus;var&minus;info=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
read information about variable types and locations from
DWARF3 debug info. This slows Valgrind startup significantly
and makes it use significantly more memory, but for the
tools that can take advantage of it (Memcheck, Helgrind,
DRD) it can result in more precise error messages. For
example, here are some standard errors issued by
Memcheck:</p>

<p style="margin-left:23%; margin-top: 1em">==15363==
Uninitialised byte(s) found during client check request <br>
==15363== at 0x80484A9: croak (varinfo1.c:28) <br>
==15363== by 0x8048544: main (varinfo1.c:55) <br>
==15363== Address 0x80497f7 is 7 bytes inside data symbol
&quot;global_i2&quot; <br>
==15363== <br>
==15363== Uninitialised byte(s) found during client check
request <br>
==15363== at 0x80484A9: croak (varinfo1.c:28) <br>
==15363== by 0x8048550: main (varinfo1.c:56) <br>
==15363== Address 0xbea0d0cc is on thread 1's stack <br>
==15363== in frame #1, created by main (varinfo1.c:45) <br>
&gt;&lt;/programlisting&gt;</p>


<p style="margin-left:23%; margin-top: 1em">&lt;para&gt;And
here are the same errors with <br>

&lt;option&gt;&minus;&minus;read&minus;var&minus;info=yes&lt;/option&gt;:&lt;/para&gt;</p>


<p style="margin-left:23%; margin-top: 1em">&lt;programlisting&gt;&lt;![CDATA[
<br>
==15370== Uninitialised byte(s) found during client check
request <br>
==15370== at 0x80484A9: croak (varinfo1.c:28) <br>
==15370== by 0x8048544: main (varinfo1.c:55) <br>
==15370== Location 0x80497f7 is 0 bytes inside global_i2[7],
<br>
==15370== a global variable declared at varinfo1.c:41 <br>
==15370== <br>
==15370== Uninitialised byte(s) found during client check
request <br>
==15370== at 0x80484A9: croak (varinfo1.c:28) <br>
==15370== by 0x8048550: main (varinfo1.c:56) <br>
==15370== Location 0xbeb4a0cc is 0 bytes inside local var
&quot;local&quot; <br>
==15370== declared at varinfo1.c:46, in frame #1 of thread
1</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb&minus;poll=&lt;number&gt;
[default: 5000]</b></p>

<p style="margin-left:17%;">As part of its main loop, the
Valgrind scheduler will poll to check if some activity (such
as an external command or some input from a gdb) has to be
handled by gdbserver. This activity poll will be done after
having run the given number of basic blocks (or slightly
more than the given number of basic blocks). This poll is
quite cheap so the default value is set relatively low. You
might further decrease this value if vgdb cannot use ptrace
system call to interrupt Valgrind if all threads are (most
of the time) blocked in a system call.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb&minus;shadow&minus;registers=no|yes
[default: no]</b></p>

<p style="margin-left:17%;">When activated, gdbserver will
expose the Valgrind shadow registers to GDB. With this, the
value of the Valgrind shadow registers can be examined or
changed using GDB. Exposing shadow registers only works with
GDB version 7.1 or later.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;vgdb&minus;prefix=&lt;prefix&gt;
[default: /tmp/vgdb&minus;pipe]</b></p>

<p style="margin-left:17%;">To communicate with gdb/vgdb,
the Valgrind gdbserver creates 3 files (2 named FIFOs and a
mmap shared memory file). The prefix option controls the
directory and prefix for the creation of these files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;run&minus;libc&minus;freeres=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">This option is only relevant
when running Valgrind on Linux.</p>

<p style="margin-left:17%; margin-top: 1em">The GNU C
library (<b>libc.so</b>), which is used by all programs, may
allocate memory for its own uses. Usually it doesn't bother
to free that memory when the program ends&mdash;there would
be no point, since the Linux kernel reclaims all process
resources when a process exits anyway, so it would just slow
things down.</p>

<p style="margin-left:17%; margin-top: 1em">The glibc
authors realised that this behaviour causes leak checkers,
such as Valgrind, to falsely report leaks in glibc, when a
leak check is done at exit. In order to avoid this, they
provided a routine called <b>__libc_freeres</b> specifically
to make glibc release all memory it has allocated. Memcheck
therefore tries to run <b>__libc_freeres</b> at exit.</p>

<p style="margin-left:17%; margin-top: 1em">Unfortunately,
in some very old versions of glibc, <b>__libc_freeres</b> is
sufficiently buggy to cause segmentation faults. This was
particularly noticeable on Red Hat 7.1. So this option is
provided in order to inhibit the run of
<b>__libc_freeres</b>. If your program seems to run fine on
Valgrind, but segfaults at exit, you may find that
<b>&minus;&minus;run&minus;libc&minus;freeres=no</b> fixes
that, although at the cost of possibly falsely reporting
space leaks in libc.so.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;sim&minus;hints=hint1,hint2,...</b></p>

<p style="margin-left:17%;">Pass miscellaneous hints to
Valgrind which slightly modify the simulated behaviour in
nonstandard or dangerous ways, possibly to help the
simulation of strange features. By default no hints are
enabled. Use with caution! Currently known hints are:</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>lax&minus;ioctls:</b> Be very lax about ioctl handling;
the only assumption is that the size is correct. Doesn't
require the full buffer to be initialized when writing.
Without this, using some device drivers with a large number
of strange ioctl commands becomes very tiresome.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>fuse&minus;compatible:</b> Enable special handling for
certain system calls that may block in a FUSE
file&minus;system. This may be necessary when running
Valgrind on a multi&minus;threaded program that uses one
thread to manage a FUSE file&minus;system and another thread
to access that file&minus;system.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>enable&minus;outer:</b> Enable some special magic needed
when the program being run is itself Valgrind.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>no&minus;inner&minus;prefix:</b> Disable printing a
prefix <b>&gt;</b> in front of each stdout or stderr output
line in an inner Valgrind being run by an outer Valgrind.
This is useful when running Valgrind regression tests in an
outer/inner setup. Note that the prefix <b>&gt;</b> will
always be printed in front of the inner debug logging
lines.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>no&minus;nptl&minus;pthread&minus;stackcache:</b> This
hint is only relevant when running Valgrind on Linux.</p>

<p style="margin-left:23%; margin-top: 1em">The GNU glibc
pthread library (<b>libpthread.so</b>), which is used by
pthread programs, maintains a cache of pthread stacks. When
a pthread terminates, the memory used for the pthread stack
and some thread local storage related data structure are not
always directly released. This memory is kept in a cache (up
to a certain size), and is re&minus;used if a new thread is
started.</p>

<p style="margin-left:23%; margin-top: 1em">This cache
causes the helgrind tool to report some false positive race
condition errors on this cached memory, as helgrind does not
understand the internal glibc cache synchronisation
primitives. So, when using helgrind, disabling the cache
helps to avoid false positive race conditions, in particular
when using thread local storage variables (e.g. variables
using the <b>__thread</b> qualifier).</p>

<p style="margin-left:23%; margin-top: 1em">When using the
memcheck tool, disabling the cache ensures the memory used
by glibc to handle __thread variables is directly released
when a thread terminates.</p>

<p style="margin-left:23%; margin-top: 1em">Note: Valgrind
disables the cache using some internal knowledge of the
glibc stack cache implementation and by examining the debug
information of the pthread library. This technique is thus
somewhat fragile and might not work for all glibc versions.
This has been succesfully tested with various glibc versions
(e.g. 2.11, 2.16, 2.18) on various platforms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;fair&minus;sched=&lt;no|yes|try&gt;
[default: no]</b></p>

<p style="margin-left:17%;">The
<b>&minus;&minus;fair&minus;sched</b> option controls the
locking mechanism used by Valgrind to serialise thread
execution. The locking mechanism controls the way the
threads are scheduled, and different settings give different
trade&minus;offs between fairness and performance. For more
details about the Valgrind thread serialisation scheme and
its impact on performance and thread scheduling, see
Scheduling and Multi-Thread Performance.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The
value <b>&minus;&minus;fair&minus;sched=yes</b> activates a
fair scheduler. In short, if multiple threads are ready to
run, the threads will be scheduled in a round robin fashion.
This mechanism is not available on all platforms or Linux
versions. If not available, using
<b>&minus;&minus;fair&minus;sched=yes</b> will cause
Valgrind to terminate with an error.</p>

<p style="margin-left:23%; margin-top: 1em">You may find
this setting improves overall responsiveness if you are
running an interactive multithreaded program, for example a
web browser, on Valgrind.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The
value <b>&minus;&minus;fair&minus;sched=try</b> activates
fair scheduling if available on the platform. Otherwise, it
will automatically fall back to
<b>&minus;&minus;fair&minus;sched=no</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The
value <b>&minus;&minus;fair&minus;sched=no</b> activates a
scheduler which does not guarantee fairness between threads
ready to run, but which in general gives the highest
performance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;kernel&minus;variant=variant1,variant2,...</b></p>

<p style="margin-left:17%;">Handle system calls and ioctls
arising from minor variants of the default kernel for this
platform. This is useful for running on hacked kernels or
with kernel modules which support nonstandard ioctls, for
example. Use with caution. If you don't understand what this
option does then you almost certainly don't need it.
Currently known variants are:</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>bproc</b>: support the <b>sys_broc</b> system call on
x86. This is for running on BProc, which is a minor variant
of standard Linux which is sometimes used for building
clusters.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>android&minus;no&minus;hw&minus;tls</b>: some versions of
the Android emulator for ARM do not provide a hardware TLS
(thread&minus;local state) register, and Valgrind crashes at
startup. Use this variant to select software support for
TLS.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>android&minus;gpu&minus;sgx5xx</b>: use this to support
handling of proprietary ioctls for the PowerVR SGX 5XX
series of GPUs on Android devices. Failure to select this
does not cause stability problems, but may cause Memcheck to
report false errors after the program performs
GPU&minus;specific ioctls.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>android&minus;gpu&minus;adreno3xx</b>: similarly, use
this to support handling of proprietary ioctls for the
Qualcomm Adreno 3XX series of GPUs on Android devices.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;merge&minus;recursive&minus;frames=&lt;number&gt;
[default: 0]</b></p>

<p style="margin-left:17%;">Some recursive algorithms, for
example balanced binary tree implementations, create many
different stack traces, each containing cycles of calls. A
cycle is defined as two identical program counter values
separated by zero or more other program counter values.
Valgrind may then use a lot of memory to store all these
stack traces. This is a poor use of memory considering that
such stack traces contain repeated uninteresting recursive
calls instead of more interesting information such as the
function that has initiated the recursive call.</p>

<p style="margin-left:17%; margin-top: 1em">The option
<b>&minus;&minus;merge&minus;recursive&minus;frames=&lt;number&gt;</b>
instructs Valgrind to detect and merge recursive call cycles
having a size of up to <b>&lt;number&gt;</b> frames. When
such a cycle is detected, Valgrind records the cycle in the
stack trace as a unique program counter.</p>

<p style="margin-left:17%; margin-top: 1em">The value 0
(the default) causes no recursive call merging. A value of 1
will cause stack traces of simple recursive algorithms (for
example, a factorial implementation) to be collapsed. A
value of 2 will usually be needed to collapse stack traces
produced by recursive algorithms such as binary trees, quick
sort, etc. Higher values might be needed for more complex
recursive algorithms.</p>

<p style="margin-left:17%; margin-top: 1em">Note: recursive
calls are detected by analysis of program counter values.
They are not detected by looking at function names.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;num&minus;transtab&minus;sectors=&lt;number&gt;
[default: 6 for Android platforms, 16 for all
others]</b></p>

<p style="margin-left:17%;">Valgrind translates and
instruments your program's machine code in small fragments.
The translations are stored in a translation cache that is
divided into a number of sections (sectors). If the cache is
full, the sector containing the oldest translations is
emptied and reused. If these old translations are needed
again, Valgrind must re&minus;translate and
re&minus;instrument the corresponding machine code, which is
expensive. If the &quot;executed instructions&quot; working
set of a program is big, increasing the number of sectors
may improve performance by reducing the number of
re&minus;translations needed. Sectors are allocated on
demand. Once allocated, a sector can never be freed, and
occupies considerable space, depending on the tool (about 40
MB per sector for Memcheck). Use the option
<b>&minus;&minus;stats=yes</b> to obtain precise information
about the memory used by a sector and the allocation and
recycling of sectors.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;aspace&minus;minaddr=&lt;address&gt;
[default: depends on the platform]</b></p>

<p style="margin-left:17%;">To avoid potential conflicts
with some system libraries, Valgrind does not use the
address space below
<b>&minus;&minus;aspace&minus;minaddr</b> value, keeping it
reserved in case a library specifically requests memory in
this region. So, some &quot;pessimistic&quot; value is
guessed by Valgrind depending on the platform. On linux, by
default, Valgrind avoids using the first 64MB even if
typically there is no conflict in this complete zone. You
can use the option <b>&minus;&minus;aspace&minus;minaddr</b>
to have your memory hungry application benefitting from more
of this lower memory. On the other hand, if you encounter a
conflict, increasing aspace&minus;minaddr value might solve
it. Conflicts will typically manifest themselves with mmap
failures in the low range of the address space. The provided
address must be page aligned and must be equal or bigger to
0x1000 (4KB). To find the default value on your platform, do
something such as valgrind &minus;d &minus;d date
2&gt;&amp;1 | grep &minus;i minaddr. Values lower than
0x10000 (64KB) are known to create problems on some
distributions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;emwarns=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Valgrind will
emit warnings about its CPU emulation in certain cases.
These are usually not interesting.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;require&minus;text&minus;symbol=:sonamepatt:fnnamepatt</b></p>

<p style="margin-left:17%;">When a shared object whose
soname matches <i>sonamepatt</i> is loaded into the process,
examine all the text symbols it exports. If none of those
match <i>fnnamepatt</i>, print an error message and abandon
the run. This makes it possible to ensure that the run does
not continue unless a given shared object contains a
particular function name.</p>

<p style="margin-left:17%; margin-top: 1em">Both
<i>sonamepatt</i> and <i>fnnamepatt</i> can be written using
the usual <i>?</i> and <i>*</i> wildcards. For example:
<i>&quot;:*libc.so*:foo?bar&quot;</i>. You may use
characters other than a colon to separate the two patterns.
It is only important that the first character and the
separator character are the same. For example, the above
example could also be written
<i>&quot;Q*libc.so*Qfoo?bar&quot;</i>. Multiple <i><br>
&minus;&minus;require&minus;text&minus;symbol</i> flags are
allowed, in which case shared objects that are loaded into
the process will be checked against all of them.</p>

<p style="margin-left:17%; margin-top: 1em">The purpose of
this is to support reliable usage of marked&minus;up
libraries. For example, suppose we have a version of GCC's
<i>libgomp.so</i> which has been marked up with annotations
to support Helgrind. It is only too easy and confusing to
load the wrong, un&minus;annotated <i>libgomp.so</i> into
the application. So the idea is: add a text symbol in the
marked&minus;up library, for example
<i>annotated_for_helgrind_3_6</i>, and then give the flag
<i>&minus;&minus;require&minus;text&minus;symbol=:*libgomp*so*:annotated_for_helgrind_3_6</i>
so that when <i>libgomp.so</i> is loaded, Valgrind scans its
symbol table, and if the symbol isn't present the run is
aborted, rather than continuing silently with the
un&minus;marked&minus;up library. Note that you should put
the entire flag in quotes to stop shells expanding up the
<i>*</i> and <i>?</i> wildcards.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;soname&minus;synonyms=syn1=pattern1,syn2=pattern2,...</b></p>

<p style="margin-left:17%;">When a shared library is
loaded, Valgrind checks for functions in the library that
must be replaced or wrapped. For example, Memcheck replaces
all malloc related functions (malloc, free, calloc, ...)
with its own versions. Such replacements are done by default
only in shared libraries whose soname matches a predefined
soname pattern (e.g. <i>libc.so*</i> on linux). By default,
no replacement is done for a statically linked library or
for alternative libraries such as tcmalloc. In some cases,
the replacements allow
<b>&minus;&minus;soname&minus;synonyms</b> to specify one
additional synonym pattern, giving flexibility in the
replacement.</p>

<p style="margin-left:17%; margin-top: 1em">Currently, this
flexibility is only allowed for the malloc related
functions, using the synonym <i>somalloc</i>. This synonym
is usable for all tools doing standard replacement of malloc
related functions (e.g. memcheck, massif, drd, helgrind,
exp&minus;dhat, exp&minus;sgcheck).</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
Alternate malloc library: to replace the malloc related
functions in an alternate library with soname
<i>mymalloclib.so</i>, give the option
<b>&minus;&minus;soname&minus;synonyms=somalloc=mymalloclib.so</b>.
A pattern can be used to match multiple libraries sonames.
For example,
<b>&minus;&minus;soname&minus;synonyms=somalloc=*tcmalloc*</b>
will match the soname of all variants of the tcmalloc
library (native, debug, profiled, ... tcmalloc
variants).</p>

<p style="margin-left:23%; margin-top: 1em">Note: the
soname of a elf shared library can be retrieved using the
readelf utility.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
Replacements in a statically linked library are done by
using the <i>NONE</i> pattern. For example, if you link with
<i>libtcmalloc.a</i>, memcheck will properly work when you
give the option
<b>&minus;&minus;soname&minus;synonyms=somalloc=NONE</b>.
Note that a NONE pattern will match the main executable and
any shared library having no soname.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; To run a
&quot;default&quot; Firefox build for Linux, in which
JEMalloc is linked in to the main executable, use
<b>&minus;&minus;soname&minus;synonyms=somalloc=NONE</b>.</p>

<h2>DEBUGGING VALGRIND OPTIONS
<a name="DEBUGGING VALGRIND OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are also
some options for debugging Valgrind itself. You shouldn't
need to use them in the normal run of things. If you wish to
see the list, use the <b>&minus;&minus;help&minus;debug</b>
option.</p>

<h2>MEMCHECK OPTIONS
<a name="MEMCHECK OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;leak&minus;check=&lt;no|summary|yes|full&gt;
[default: summary]</b></p>

<p style="margin-left:17%;">When enabled, search for memory
leaks when the client program finishes. If set to
<i>summary</i>, it says how many leaks occurred. If set to
<i>full</i> or <i>yes</i>, it also gives details of each
individual leak.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;leak&minus;resolution=&lt;low|med|high&gt;
[default: high]</b></p>

<p style="margin-left:17%;">When doing leak checking,
determines how willing Memcheck is to consider different
backtraces to be the same for the purposes of merging
multiple leaks into a single leak report. When set to
<i>low</i>, only the first two entries need match. When
<i>med</i>, four entries have to match. When <i>high</i>,
all entries need to match.</p>

<p style="margin-left:17%; margin-top: 1em">For hardcore
leak debugging, you probably want to use
<b>&minus;&minus;leak&minus;resolution=high</b> together
with <b>&minus;&minus;num&minus;callers=40</b> or some such
large number.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
<b>&minus;&minus;leak&minus;resolution</b> setting does not
affect Memcheck's ability to find leaks. It only changes how
the results are presented.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;leak&minus;kinds=&lt;set&gt;
[default: definite,possible]</b></p>

<p style="margin-left:17%;">Specifies the leak kinds to
show in a full leak search, in one of the following
ways:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a comma
separated list of one or more of <b>definite indirect
possible reachable</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>all</b> to specify the complete set (all leak kinds). It
is equivalent to
<b>&minus;&minus;show&minus;leak&minus;kinds=definite,indirect,possible,reachable</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>none</b> for the empty set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;errors&minus;for&minus;leak&minus;kinds=&lt;set&gt;
[default: definite,possible]</b></p>

<p style="margin-left:17%;">Specifies the leak kinds to
count as errors in a full leak search. The
<b>&lt;set&gt;</b> is specified similarly to
<b>&minus;&minus;show&minus;leak&minus;kinds</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;leak&minus;check&minus;heuristics=&lt;set&gt;
[default: none]</b></p>

<p style="margin-left:17%;">Specifies the set of leak check
heuristics to be used during leak searches. The heuristics
control which interior pointers to a block cause it to be
considered as reachable. The heuristic set is specified in
one of the following ways:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a comma
separated list of one or more of <b>stdstring length64
newarray multipleinheritance</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>all</b> to activate the complete set of heuristics. It is
equivalent to
<b>&minus;&minus;leak&minus;check&minus;heuristics=stdstring,length64,newarray,multipleinheritance</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>none</b> for the empty set.</p>

<p style="margin-left:17%; margin-top: 1em">Note that these
heuristics are dependent on the layout of the objects
produced by the C++ compiler. They have been tested with
some gcc versions (e.g. 4.4 and 4.7). They might not work
properly with other C++ compilers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;reachable=&lt;yes|no&gt;</b>
,
<b>&minus;&minus;show&minus;possibly&minus;lost=&lt;yes|no&gt;</b></p>

<p style="margin-left:17%;">These options provide an
alternative way to specify the leak kinds to show:</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>&minus;&minus;show&minus;reachable=no
&minus;&minus;show&minus;possibly&minus;lost=yes</b> is
equivalent to
<b>&minus;&minus;show&minus;leak&minus;kinds=definite,possible</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>&minus;&minus;show&minus;reachable=no
&minus;&minus;show&minus;possibly&minus;lost=no</b> is
equivalent to
<b>&minus;&minus;show&minus;leak&minus;kinds=definite</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
<b>&minus;&minus;show&minus;reachable=yes</b> is equivalent
to <b>&minus;&minus;show&minus;leak&minus;kinds=all</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<b>&minus;&minus;show&minus;possibly&minus;lost=no</b> has
no effect if <b>&minus;&minus;show&minus;reachable=yes</b>
is specified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;undef&minus;value&minus;errors=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Controls whether Memcheck
reports uses of undefined value errors. Set this to
<i>no</i> if you don't want to see undefined value errors.
It also has the side effect of speeding up Memcheck
somewhat.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;track&minus;origins=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Controls whether Memcheck
tracks the origin of uninitialised values. By default, it
does not, which means that although it can tell you that an
uninitialised value is being used in a dangerous way, it
cannot tell you where the uninitialised value came from.
This often makes it difficult to track down the root
problem.</p>

<p style="margin-left:17%; margin-top: 1em">When set to
<i>yes</i>, Memcheck keeps track of the origins of all
uninitialised values. Then, when an uninitialised value
error is reported, Memcheck will try to show the origin of
the value. An origin can be one of the following four
places: a heap block, a stack allocation, a client request,
or miscellaneous other sources (eg, a call to
<i>brk</i>).</p>

<p style="margin-left:17%; margin-top: 1em">For
uninitialised values originating from a heap block, Memcheck
shows where the block was allocated. For uninitialised
values originating from a stack allocation, Memcheck can
tell you which function allocated the value, but no more
than that &minus;&minus; typically it shows you the source
location of the opening brace of the function. So you should
carefully check that all of the function's local variables
are initialised properly.</p>

<p style="margin-left:17%; margin-top: 1em">Performance
overhead: origin tracking is expensive. It halves Memcheck's
speed and increases memory use by a minimum of 100MB, and
possibly more. Nevertheless it can drastically reduce the
effort required to identify the root cause of uninitialised
value errors, and so is often a programmer productivity win,
despite running more slowly.</p>

<p style="margin-left:17%; margin-top: 1em">Accuracy:
Memcheck tracks origins quite accurately. To avoid very
large space and time overheads, some approximations are
made. It is possible, although unlikely, that Memcheck will
report an incorrect origin, or not be able to identify any
origin.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
combination <b>&minus;&minus;track&minus;origins=yes</b> and
<b>&minus;&minus;undef&minus;value&minus;errors=no</b> is
nonsensical. Memcheck checks for and rejects this
combination at startup.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;partial&minus;loads&minus;ok=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Controls how Memcheck handles
32&minus;, 64&minus;, 128&minus; and 256&minus;bit naturally
aligned loads from addresses for which some bytes are
addressable and others are not. When <i>yes</i>, such loads
do not produce an address error. Instead, loaded bytes
originating from illegal addresses are marked as
uninitialised, and those corresponding to legal addresses
are handled in the normal way.</p>

<p style="margin-left:17%; margin-top: 1em">When <i>no</i>,
loads from partially invalid addresses are treated the same
as loads from completely invalid addresses: an
illegal&minus;address error is issued, and the resulting
bytes are marked as initialised.</p>

<p style="margin-left:17%; margin-top: 1em">Note that code
that behaves in this way is in violation of the ISO C/C++
standards, and should be considered broken. If at all
possible, such code should be fixed. This option should be
used only as a last resort.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;keep&minus;stacktraces=alloc|free|alloc&minus;and&minus;free|alloc&minus;then&minus;free|none
[default: alloc&minus;then&minus;free]</b></p>

<p style="margin-left:17%;">Controls which stack trace(s)
to keep for malloc'd and/or free'd blocks.</p>

<p style="margin-left:17%; margin-top: 1em">With
<i>alloc&minus;then&minus;free</i>, a stack trace is
recorded at allocation time, and is associated with the
block. When the block is freed, a second stack trace is
recorded, and this replaces the allocation stack trace. As a
result, any &quot;use after free&quot; errors relating to
this block can only show a stack trace for where the block
was freed.</p>

<p style="margin-left:17%; margin-top: 1em">With
<i>alloc&minus;and&minus;free</i>, both allocation and the
deallocation stack traces for the block are stored. Hence a
&quot;use after free&quot; error will show both, which may
make the error easier to diagnose. Compared to
<i>alloc&minus;then&minus;free</i>, this setting slightly
increases Valgrind's memory use as the block contains two
references instead of one.</p>

<p style="margin-left:17%; margin-top: 1em">With
<i>alloc</i>, only the allocation stack trace is recorded
(and reported). With <i>free</i>, only the deallocation
stack trace is recorded (and reported). These values
somewhat decrease Valgrind's memory and cpu usage. They can
be useful depending on the error types you are searching for
and the level of detail you need to analyse them. For
example, if you are only interested in memory leak errors,
it is sufficient to record the allocation stack traces.</p>

<p style="margin-left:17%; margin-top: 1em">With
<i>none</i>, no stack traces are recorded for malloc and
free operations. If your program allocates a lot of blocks
and/or allocates/frees from many different stack traces,
this can significantly decrease cpu and/or memory required.
Of course, few details will be reported for errors related
to heap blocks.</p>

<p style="margin-left:17%; margin-top: 1em">Note that once
a stack trace is recorded, Valgrind keeps the stack trace in
memory even if it is not referenced by any block. Some
programs (for example, recursive algorithms) can generate a
huge number of stack traces. If Valgrind uses too much
memory in such circumstances, you can reduce the memory
required with the options
<i>&minus;&minus;keep&minus;stacktraces</i> and/or by using
a smaller value for the option
<i>&minus;&minus;num&minus;callers</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;freelist&minus;vol=&lt;number&gt;
[default: 20000000]</b></p>

<p style="margin-left:17%;">When the client program
releases memory using <b>free</b> (in C) or delete (C++),
that memory is not immediately made available for
re&minus;allocation. Instead, it is marked inaccessible and
placed in a queue of freed blocks. The purpose is to defer
as long as possible the point at which freed&minus;up memory
comes back into circulation. This increases the chance that
Memcheck will be able to detect invalid accesses to blocks
for some significant period of time after they have been
freed.</p>

<p style="margin-left:17%; margin-top: 1em">This option
specifies the maximum total size, in bytes, of the blocks in
the queue. The default value is twenty million bytes.
Increasing this increases the total amount of memory used by
Memcheck but may detect invalid uses of freed blocks which
would otherwise go undetected.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;freelist&minus;big&minus;blocks=&lt;number&gt;
[default: 1000000]</b></p>

<p style="margin-left:17%;">When making blocks from the
queue of freed blocks available for re&minus;allocation,
Memcheck will in priority re&minus;circulate the blocks with
a size greater or equal to
<b>&minus;&minus;freelist&minus;big&minus;blocks</b>. This
ensures that freeing big blocks (in particular freeing
blocks bigger than <b>&minus;&minus;freelist&minus;vol</b>)
does not immediately lead to a re&minus;circulation of all
(or a lot of) the small blocks in the free list. In other
words, this option increases the likelihood to discover
dangling pointers for the &quot;small&quot; blocks, even
when big blocks are freed.</p>

<p style="margin-left:17%; margin-top: 1em">Setting a value
of 0 means that all the blocks are re&minus;circulated in a
FIFO order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;workaround&minus;gcc296&minus;bugs=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, assume that reads
and writes some small distance below the stack pointer are
due to bugs in GCC 2.96, and does not report them. The
&quot;small distance&quot; is 256 bytes by default. Note
that GCC 2.96 is the default compiler on some ancient Linux
distributions (RedHat 7.X) and so you may need to use this
option. Do not use it if you do not have to, as it can cause
real errors to be overlooked. A better alternative is to use
a more recent GCC in which this bug is fixed.</p>

<p style="margin-left:17%; margin-top: 1em">You may also
need to use this option when working with GCC 3.X or 4.X on
32&minus;bit PowerPC Linux. This is because GCC generates
code which occasionally accesses below the stack pointer,
particularly for floating&minus;point to/from integer
conversions. This is in violation of the 32&minus;bit
PowerPC ELF specification, which makes no provision for
locations below the stack pointer to be accessible.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;mismatched&minus;frees=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">When enabled, Memcheck checks
that heap blocks are deallocated using a function that
matches the allocating function. That is, it expects
<i>free</i> to be used to deallocate blocks allocated by
<i>malloc</i>, <i>delete</i> for blocks allocated by
<i>new</i>, and <i>delete[]</i> for blocks allocated by
<i>new[]</i>. If a mismatch is detected, an error is
reported. This is in general important because in some
environments, freeing with a non&minus;matching function can
cause crashes.</p>

<p style="margin-left:17%; margin-top: 1em">There is
however a scenario where such mismatches cannot be avoided.
That is when the user provides implementations of
<i>new</i>/<i>new[]</i> that call <i>malloc</i> and of
<i>delete</i>/<i>delete[]</i> that call <i>free</i>, and
these functions are asymmetrically inlined. For example,
imagine that <i>delete[]</i> is inlined but <i>new[]</i> is
not. The result is that Memcheck &quot;sees&quot; all
<i>delete[]</i> calls as direct calls to <i>free</i>, even
when the program source contains no mismatched calls.</p>

<p style="margin-left:17%; margin-top: 1em">This causes a
lot of confusing and irrelevant error reports.
<i>&minus;&minus;show&minus;mismatched&minus;frees=no</i>
disables these checks. It is not generally advisable to
disable them, though, because you may miss real errors as a
result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ignore&minus;ranges=0xPP&minus;0xQQ[,0xRR&minus;0xSS]</b></p>

<p style="margin-left:17%;">Any ranges listed in this
option (and multiple ranges can be specified, separated by
commas) will be ignored by Memcheck's addressability
checking.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;malloc&minus;fill=&lt;hexnumber&gt;</b></p>

<p style="margin-left:17%;">Fills blocks allocated by
malloc, new, etc, but not by calloc, with the specified
byte. This can be useful when trying to shake out obscure
memory corruption problems. The allocated area is still
regarded by Memcheck as undefined &minus;&minus; this option
only affects its contents. Note that
<b>&minus;&minus;malloc&minus;fill</b> does not affect a
block of memory when it is used as argument to client
requests VALGRIND_MEMPOOL_ALLOC or
VALGRIND_MALLOCLIKE_BLOCK.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;free&minus;fill=&lt;hexnumber&gt;</b></p>

<p style="margin-left:17%;">Fills blocks freed by free,
delete, etc, with the specified byte value. This can be
useful when trying to shake out obscure memory corruption
problems. The freed area is still regarded by Memcheck as
not valid for access &minus;&minus; this option only affects
its contents. Note that <b>&minus;&minus;free&minus;fill</b>
does not affect a block of memory when it is used as
argument to client requests VALGRIND_MEMPOOL_FREE or
VALGRIND_FREELIKE_BLOCK.</p>

<h2>CACHEGRIND OPTIONS
<a name="CACHEGRIND OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line
size&gt;</b></p>

<p style="margin-left:17%;">Specify the size, associativity
and line size of the level 1 instruction cache.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line
size&gt;</b></p>

<p style="margin-left:17%;">Specify the size, associativity
and line size of the level 1 data cache.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line
size&gt;</b></p>

<p style="margin-left:17%;">Specify the size, associativity
and line size of the last&minus;level cache.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cache&minus;sim=no|yes
[yes]</b></p>

<p style="margin-left:17%;">Enables or disables collection
of cache access and miss counts.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;branch&minus;sim=no|yes
[no]</b></p>

<p style="margin-left:17%;">Enables or disables collection
of branch instruction and misprediction counts. By default
this is disabled as it slows Cachegrind down by
approximately 25%. Note that you cannot specify
<b>&minus;&minus;cache&minus;sim=no</b> and
<b>&minus;&minus;branch&minus;sim=no</b> together, as that
would leave Cachegrind with no information to collect.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cachegrind&minus;out&minus;file=&lt;file&gt;</b></p>

<p style="margin-left:17%;">Write the profile data to file
rather than to the default output file,
cachegrind.out.&lt;pid&gt;. The <b>%p</b> and <b>%q</b>
format specifiers can be used to embed the process ID and/or
the contents of an environment variable in the name, as is
the case for the core option <b>--log-file</b>.</p>

<h2>CALLGRIND OPTIONS
<a name="CALLGRIND OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;callgrind&minus;out&minus;file=&lt;file&gt;</b></p>

<p style="margin-left:17%;">Write the profile data to file
rather than to the default output file,
callgrind.out.&lt;pid&gt;. The <b>%p</b> and <b>%q</b>
format specifiers can be used to embed the process ID and/or
the contents of an environment variable in the name, as is
the case for the core option <b>--log-file</b>. When
multiple dumps are made, the file name is modified further;
see below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dump&minus;line=&lt;no|yes&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">This specifies that event
counting should be performed at source line granularity.
This allows source annotation for sources which are compiled
with debug information (<b>&minus;g</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dump&minus;instr=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">This specifies that event
counting should be performed at per&minus;instruction
granularity. This allows for assembly code annotation.
Currently the results can only be displayed by
KCachegrind.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;compress&minus;strings=&lt;no|yes&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">This option influences the
output format of the profile data. It specifies whether
strings (file and function names) should be identified by
numbers. This shrinks the file, but makes it more difficult
for humans to read (which is not recommended in any
case).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;compress&minus;pos=&lt;no|yes&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">This option influences the
output format of the profile data. It specifies whether
numerical positions are always specified as absolute values
or are allowed to be relative to previous numbers. This
shrinks the file size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;combine&minus;dumps=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, when multiple
profile data parts are to be generated these parts are
appended to the same output file. Not recommended.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dump&minus;every&minus;bb=&lt;count&gt;
[default: 0, never]</b></p>

<p style="margin-left:17%;">Dump profile data every
<b>count</b> basic blocks. Whether a dump is needed is only
checked when Valgrind's internal scheduler is run.
Therefore, the minimum setting useful is about 100000. The
count is a 64&minus;bit value to make long dump periods
possible.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dump&minus;before=&lt;function&gt;</b></p>

<p style="margin-left:17%;">Dump when entering
<b>function</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;zero&minus;before=&lt;function&gt;</b></p>

<p style="margin-left:17%;">Zero all costs when entering
<b>function</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dump&minus;after=&lt;function&gt;</b></p>

<p style="margin-left:17%;">Dump when leaving
<b>function</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;instr&minus;atstart=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Specify if you want Callgrind
to start simulation and profiling from the beginning of the
program. When set to no, Callgrind will not be able to
collect any information, including calls, but it will have
at most a slowdown of around 4, which is the minimum
Valgrind overhead. Instrumentation can be interactively
enabled via callgrind_control &minus;i on.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
resulting call graph will most probably not contain
<b>main</b>, but will contain all the functions executed
after instrumentation was enabled. Instrumentation can also
programatically enabled/disabled. See the Callgrind include
file callgrind.h for the macro you have to use in your
source code.</p>

<p style="margin-left:17%; margin-top: 1em">For cache
simulation, results will be less accurate when switching on
instrumentation later in the program run, as the simulator
starts with an empty cache at that moment. Switch on event
collection later to cope with this error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;collect&minus;atstart=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Specify whether event
collection is enabled at beginning of the profile run.</p>

<p style="margin-left:17%; margin-top: 1em">To only look at
parts of your program, you have two possibilities:</p>

<p style="margin-left:23%; margin-top: 1em">1. Zero event
counters before entering the program part you want to
profile, and dump the event counters to a file after leaving
that program part.</p>

<p style="margin-left:23%; margin-top: 1em">2. Switch
on/off collection state as needed to only see event counters
happening while inside of the program part you want to
profile.</p>

<p style="margin-left:17%; margin-top: 1em">The second
option can be used if the program part you want to profile
is called many times. Option 1, i.e. creating a lot of dumps
is not practical here.</p>

<p style="margin-left:17%; margin-top: 1em">Collection
state can be toggled at entry and exit of a given function
with the option <b>--toggle-collect</b>. If you use this
option, collection state should be disabled at the
beginning. Note that the specification of
<b>&minus;&minus;toggle&minus;collect</b> implicitly sets
<b>&minus;&minus;collect&minus;state=no</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Collection
state can be toggled also by inserting the client request
CALLGRIND_TOGGLE_COLLECT ; at the needed code positions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;toggle&minus;collect=&lt;function&gt;</b></p>

<p style="margin-left:17%;">Toggle collection on entry/exit
of <b>function</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;collect&minus;jumps=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">This specifies whether
information for (conditional) jumps should be collected. As
above, callgrind_annotate currently is not able to show you
the data. You have to use KCachegrind to get jump arrows in
the annotated code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;collect&minus;systime=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">This specifies whether
information for system call times should be collected.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;collect&minus;bus=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">This specifies whether the
number of global bus events executed should be collected.
The event type &quot;Ge&quot; is used for these events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cache&minus;sim=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Specify if you want to do full
cache simulation. By default, only instruction read accesses
will be counted (&quot;Ir&quot;). With cache simulation,
further event counters are enabled: Cache misses on
instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), data
read accesses (&quot;Dr&quot;) and related cache misses
(&quot;D1mr&quot;/&quot;DLmr&quot;), data write accesses
(&quot;Dw&quot;) and related cache misses
(&quot;D1mw&quot;/&quot;DLmw&quot;). For more information,
see Cachegrind: a cache and branch-prediction profiler.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;branch&minus;sim=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Specify if you want to do
branch prediction simulation. Further event counters are
enabled: Number of executed conditional branches and related
predictor misses (&quot;Bc&quot;/&quot;Bcm&quot;), executed
indirect jumps and related misses of the jump address
predictor (&quot;Bi&quot;/&quot;Bim&quot;).</p>

<h2>HELGRIND OPTIONS
<a name="HELGRIND OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;free&minus;is&minus;write=no|yes
[default: no]</b></p>

<p style="margin-left:17%;">When enabled (not the default),
Helgrind treats freeing of heap memory as if the memory was
written immediately before the free. This exposes races
where memory is referenced by one thread, and freed by
another, but there is no observable synchronisation event to
ensure that the reference happens before the free.</p>

<p style="margin-left:17%; margin-top: 1em">This
functionality is new in Valgrind 3.7.0, and is regarded as
experimental. It is not enabled by default because its
interaction with custom memory allocators is not well
understood at present. User feedback is welcomed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;track&minus;lockorders=no|yes
[default: yes]</b></p>

<p style="margin-left:17%;">When enabled (the default),
Helgrind performs lock order consistency checking. For some
buggy programs, the large number of lock order errors
reported can become annoying, particularly if you're only
interested in race errors. You may therefore find it helpful
to disable lock order checking.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;history&minus;level=none|approx|full
[default: full]</b></p>


<p style="margin-left:17%;"><b>&minus;&minus;history&minus;level=full</b>
(the default) causes Helgrind collects enough information
about &quot;old&quot; accesses that it can produce two stack
traces in a race report &minus;&minus; both the stack trace
for the current access, and the trace for the older,
conflicting access. To limit memory usage, &quot;old&quot;
accesses stack traces are limited to a maximum of 8 entries,
even if <b>&minus;&minus;num&minus;callers</b> value is
bigger.</p>

<p style="margin-left:17%; margin-top: 1em">Collecting such
information is expensive in both speed and memory,
particularly for programs that do many inter&minus;thread
synchronisation events (locks, unlocks, etc). Without such
information, it is more difficult to track down the root
causes of races. Nonetheless, you may not need it in
situations where you just want to check for the presence or
absence of races, for example, when doing regression testing
of a previously race&minus;free program.</p>


<p style="margin-left:17%; margin-top: 1em"><b>&minus;&minus;history&minus;level=none</b>
is the opposite extreme. It causes Helgrind not to collect
any information about previous accesses. This can be
dramatically faster than
<b>&minus;&minus;history&minus;level=full</b>.</p>


<p style="margin-left:17%; margin-top: 1em"><b>&minus;&minus;history&minus;level=approx</b>
provides a compromise between these two extremes. It causes
Helgrind to show a full trace for the later access, and
approximate information regarding the earlier access. This
approximate information consists of two stacks, and the
earlier access is guaranteed to have occurred somewhere
between program points denoted by the two stacks. This is
not as useful as showing the exact stack for the previous
access (as <b>&minus;&minus;history&minus;level=full</b>
does), but it is better than nothing, and it is almost as
fast as <b>&minus;&minus;history&minus;level=none</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;conflict&minus;cache&minus;size=N
[default: 1000000]</b></p>

<p style="margin-left:17%;">This flag only has any effect
at <b>&minus;&minus;history&minus;level=full</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Information
about &quot;old&quot; conflicting accesses is stored in a
cache of limited size, with LRU&minus;style management. This
is necessary because it isn't practical to store a stack
trace for every single memory access made by the program.
Historical information on not recently accessed locations is
periodically discarded, to free up space in the cache.</p>

<p style="margin-left:17%; margin-top: 1em">This option
controls the size of the cache, in terms of the number of
different memory addresses for which conflicting access
information is stored. If you find that Helgrind is showing
race errors with only one stack instead of the expected two
stacks, try increasing this value.</p>

<p style="margin-left:17%; margin-top: 1em">The minimum
value is 10,000 and the maximum is 30,000,000 (thirty times
the default value). Increasing the value by 1 increases
Helgrind's memory requirement by very roughly 100 bytes, so
the maximum value will easily eat up three extra gigabytes
or so of memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;check&minus;stack&minus;refs=no|yes
[default: yes]</b></p>

<p style="margin-left:17%;">By default Helgrind checks all
data memory accesses made by your program. This flag enables
you to skip checking for accesses to thread stacks (local
variables). This can improve performance, but comes at the
cost of missing races on stack&minus;allocated data.</p>

<h2>DRD OPTIONS
<a name="DRD OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;check&minus;stack&minus;var=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Controls whether DRD detects
data races on stack variables. Verifying stack variables is
disabled by default because most programs do not share stack
variables over threads.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;exclusive&minus;threshold=&lt;n&gt;
[default: off]</b></p>

<p style="margin-left:17%;">Print an error message if any
mutex or writer lock has been held longer than the time
specified in milliseconds. This option enables the detection
of lock contention.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;join&minus;list&minus;vol=&lt;n&gt;
[default: 10]</b></p>

<p style="margin-left:17%;">Data races that occur between a
statement at the end of one thread and another thread can be
missed if memory access information is discarded immediately
after a thread has been joined. This option allows to
specify for how many joined threads memory access
information should be retained.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;first&minus;race&minus;only=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Whether to report only the
first data race that has been detected on a memory location
or all data races that have been detected on a memory
location.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;free&minus;is&minus;write=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Whether to report races between
accessing memory and freeing memory. Enabling this option
may cause DRD to run slightly slower. Notes:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Don't
enable this option when using custom memory allocators that
use the VG_USERREQ__MALLOCLIKE_BLOCK and
VG_USERREQ__FREELIKE_BLOCK because that would result in
false positives.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Don't
enable this option when using reference&minus;counted
objects because that will result in false positives, even
when that code has been annotated properly with
ANNOTATE_HAPPENS_BEFORE and ANNOTATE_HAPPENS_AFTER. See e.g.
the output of the following command for an example: valgrind
&minus;&minus;tool=drd
&minus;&minus;free&minus;is&minus;write=yes
drd/tests/annotate_smart_pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;report&minus;signal&minus;unlocked=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Whether to report calls to
<b>pthread_cond_signal</b> and <b>pthread_cond_broadcast</b>
where the mutex associated with the signal through
<b>pthread_cond_wait</b> or <b>pthread_cond_timed_wait</b>is
not locked at the time the signal is sent. Sending a signal
without holding a lock on the associated mutex is a common
programming error which can cause subtle race conditions and
unpredictable behavior. There exist some uncommon
synchronization patterns however where it is safe to send a
signal without holding a lock on the associated mutex.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;segment&minus;merging=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Controls segment merging.
Segment merging is an algorithm to limit memory usage of the
data race detection algorithm. Disabling segment merging may
improve the accuracy of the so&minus;called 'other segments'
displayed in race reports but can also trigger an out of
memory error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;segment&minus;merging&minus;interval=&lt;n&gt;
[default: 10]</b></p>

<p style="margin-left:17%;">Perform segment merging only
after the specified number of new segments have been
created. This is an advanced configuration option that
allows to choose whether to minimize DRD's memory usage by
choosing a low value or to let DRD run faster by choosing a
slightly higher value. The optimal value for this parameter
depends on the program being analyzed. The default value
works well for most programs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;shared&minus;threshold=&lt;n&gt;
[default: off]</b></p>

<p style="margin-left:17%;">Print an error message if a
reader lock has been held longer than the specified time (in
milliseconds). This option enables the detection of lock
contention.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;confl&minus;seg=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Show conflicting segments in
race reports. Since this information can help to find the
cause of a data race, this option is enabled by default.
Disabling this option makes the output of DRD more
compact.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;show&minus;stack&minus;usage=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Print stack usage at thread
exit time. When a program creates a large number of threads
it becomes important to limit the amount of virtual memory
allocated for thread stacks. This option makes it possible
to observe how much stack memory has been used by each
thread of the client program. Note: the DRD tool itself
allocates some temporary data on the client thread stack.
The space necessary for this temporary data must be
allocated by the client program when it allocates stack
memory, but is not included in stack usage reported by
DRD.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;addr=&lt;address&gt;
[default: none]</b></p>

<p style="margin-left:17%;">Trace all load and store
activity for the specified address. This option may be
specified more than once.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ptrace&minus;addr=&lt;address&gt;
[default: none]</b></p>

<p style="margin-left:17%;">Trace all load and store
activity for the specified address and keep doing that even
after the memory at that address has been freed and
reallocated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;alloc=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all memory allocations
and deallocations. May produce a huge amount of output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;barrier=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all barrier activity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;cond=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all condition variable
activity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;fork&minus;join=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all thread creation and
all thread termination events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;hb=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace execution of the
ANNOTATE_HAPPENS_BEFORE(), ANNOTATE_HAPPENS_AFTER() and
ANNOTATE_HAPPENS_DONE() client requests.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;mutex=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all mutex activity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;rwlock=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all reader&minus;writer
lock activity.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;semaphore=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Trace all semaphore
activity.</p>

<h2>MASSIF OPTIONS
<a name="MASSIF OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;heap=&lt;yes|no&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">Specifies whether heap
profiling should be done.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;heap&minus;admin=&lt;size&gt;
[default: 8]</b></p>

<p style="margin-left:17%;">If heap profiling is enabled,
gives the number of administrative bytes per block to use.
This should be an estimate of the average, since it may
vary. For example, the allocator used by glibc on Linux
requires somewhere between 4 to 15 bytes per block,
depending on various factors. That allocator also requires
admin space for freed blocks, but Massif cannot account for
this.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;stacks=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Specifies whether stack
profiling should be done. This option slows Massif down
greatly, and so is off by default. Note that Massif assumes
that the main stack has size zero at start&minus;up. This is
not true, but doing otherwise accurately is difficult.
Furthermore, starting at zero better indicates the size of
the part of the main stack that a user program actually has
control over.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;pages&minus;as&minus;heap=&lt;yes|no&gt;
[default: no]</b></p>

<p style="margin-left:17%;">Tells Massif to profile memory
at the page level rather than at the malloc'd block level.
See above for details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;depth=&lt;number&gt;
[default: 30]</b></p>

<p style="margin-left:17%;">Maximum depth of the allocation
trees recorded for detailed snapshots. Increasing it will
make Massif run somewhat more slowly, use more memory, and
produce bigger output files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;alloc&minus;fn=&lt;name&gt;</b></p>

<p style="margin-left:17%;">Functions specified with this
option will be treated as though they were a heap allocation
function such as <b>malloc</b>. This is useful for functions
that are wrappers to <b>malloc</b> or <b>new</b>, which can
fill up the allocation trees with uninteresting information.
This option can be specified multiple times on the command
line, to name multiple functions.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
named function will only be treated this way if it is the
top entry in a stack trace, or just below another function
treated this way. For example, if you have a function
<b>malloc1</b> that wraps <b>malloc</b>, and <b>malloc2</b>
that wraps <b>malloc1</b>, just specifying
<b>&minus;&minus;alloc&minus;fn=malloc2</b> will have no
effect. You need to specify
<b>&minus;&minus;alloc&minus;fn=malloc1</b> as well. This is
a little inconvenient, but the reason is that checking for
allocation functions is slow, and it saves a lot of time if
Massif can stop looking through the stack trace entries as
soon as it finds one that doesn't match rather than having
to continue through all the entries.</p>

<p style="margin-left:17%; margin-top: 1em">Note that C++
names are demangled. Note also that overloaded C++ names
must be written in full. Single quotes may be necessary to
prevent the shell from breaking them up. For example:</p>


<p style="margin-left:23%; margin-top: 1em">&minus;&minus;alloc&minus;fn='operator
new(unsigned, std::nothrow_t const&amp;)'</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ignore&minus;fn=&lt;name&gt;</b></p>

<p style="margin-left:17%;">Any direct heap allocation
(i.e. a call to <b>malloc</b>, <b>new</b>, etc, or a call to
a function named by an <b>&minus;&minus;alloc&minus;fn</b>
option) that occurs in a function specified by this option
will be ignored. This is mostly useful for testing purposes.
This option can be specified multiple times on the command
line, to name multiple functions.</p>

<p style="margin-left:17%; margin-top: 1em">Any
<b>realloc</b> of an ignored block will also be ignored,
even if the <b>realloc</b> call does not occur in an ignored
function. This avoids the possibility of negative heap sizes
if ignored blocks are shrunk with <b>realloc</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The rules for
writing C++ function names are the same as for
<b>&minus;&minus;alloc&minus;fn</b> above.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;threshold=&lt;m.n&gt;
[default: 1.0]</b></p>

<p style="margin-left:17%;">The significance threshold for
heap allocations, as a percentage of total memory size.
Allocation tree entries that account for less than this will
be aggregated. Note that this should be specified in tandem
with ms_print's option of the same name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;peak&minus;inaccuracy=&lt;m.n&gt;
[default: 1.0]</b></p>

<p style="margin-left:17%;">Massif does not necessarily
record the actual global memory allocation peak; by default
it records a peak only when the global memory allocation
size exceeds the previous peak by at least 1.0%. This is
because there can be many local allocation peaks along the
way, and doing a detailed snapshot for every one would be
expensive and wasteful, as all but one of them will be later
discarded. This inaccuracy can be changed (even to 0.0%) via
this option, but Massif will run drastically slower as the
number approaches zero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;time&minus;unit=&lt;i|ms|B&gt;
[default: i]</b></p>

<p style="margin-left:17%;">The time unit used for the
profiling. There are three possibilities: instructions
executed (i), which is good for most cases; real (wallclock)
time (ms, i.e. milliseconds), which is sometimes useful; and
bytes allocated/deallocated on the heap and/or stack (B),
which is useful for very short&minus;run programs, and for
testing purposes, because it is the most reproducible across
different machines.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;detailed&minus;freq=&lt;n&gt;
[default: 10]</b></p>

<p style="margin-left:17%;">Frequency of detailed
snapshots. With <b>&minus;&minus;detailed&minus;freq=1</b>,
every snapshot is detailed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;max&minus;snapshots=&lt;n&gt;
[default: 100]</b></p>

<p style="margin-left:17%;">The maximum number of snapshots
recorded. If set to N, for all programs except very
short&minus;running ones, the final number of snapshots will
be between N/2 and N.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;massif&minus;out&minus;file=&lt;file&gt;
[default: massif.out.%p]</b></p>

<p style="margin-left:17%;">Write the profile data to file
rather than to the default output file,
massif.out.&lt;pid&gt;. The <b>%p</b> and <b>%q</b> format
specifiers can be used to embed the process ID and/or the
contents of an environment variable in the name, as is the
case for the core option <b>--log-file</b>.</p>

<h2>SGCHECK OPTIONS
<a name="SGCHECK OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are no
SGCheck&minus;specific command&minus;line options at
present.</p>

<h2>BBV OPTIONS
<a name="BBV OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;bb&minus;out&minus;file=&lt;name&gt;
[default: bb.out.%p]</b></p>

<p style="margin-left:17%;">This option selects the name of
the basic block vector file. The <b>%p</b> and <b>%q</b>
format specifiers can be used to embed the process ID and/or
the contents of an environment variable in the name, as is
the case for the core option <b>--log-file</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;pc&minus;out&minus;file=&lt;name&gt;
[default: pc.out.%p]</b></p>

<p style="margin-left:17%;">This option selects the name of
the PC file. This file holds program counter addresses and
function name info for the various basic blocks. This can be
used in conjunction with the basic block vector file to
fast&minus;forward via function names instead of just
instruction counts. The <b>%p</b> and <b>%q</b> format
specifiers can be used to embed the process ID and/or the
contents of an environment variable in the name, as is the
case for the core option <b>--log-file</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;interval&minus;size=&lt;number&gt;
[default: 100000000]</b></p>

<p style="margin-left:17%;">This option selects the size of
the interval to use. The default is 100 million
instructions, which is a commonly used value. Other sizes
can be used; smaller intervals can help programs with
finer&minus;grained phases. However smaller interval size
can lead to accuracy issues due to warm&minus;up effects
(When fast&minus;forwarding the various architectural
features will be un&minus;initialized, and it will take some
number of instructions before they &quot;warm up&quot; to
the state a full simulation would be at without the
fast&minus;forwarding. Large interval sizes tend to mitigate
this.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;instr&minus;count&minus;only
[default: no]</b></p>

<p style="margin-left:17%;">This option tells the tool to
only display instruction count totals, and to not generate
the actual basic block vector file. This is useful for
debugging, and for gathering instruction count info without
generating the large basic block vector files.</p>

<h2>LACKEY OPTIONS
<a name="LACKEY OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;basic&minus;counts=&lt;no|yes&gt;
[default: yes]</b></p>

<p style="margin-left:17%;">When enabled, Lackey prints the
following statistics and information about the execution of
the client program:</p>

<p style="margin-left:23%; margin-top: 1em">1. The number
of calls to the function specified by the
<b>&minus;&minus;fnname</b> option (the default is main). If
the program has had its symbols stripped, the count will
always be zero.</p>

<p style="margin-left:23%; margin-top: 1em">2. The number
of conditional branches encountered and the number and
proportion of those taken.</p>

<p style="margin-left:23%; margin-top: 1em">3. The number
of superblocks entered and completed by the program. Note
that due to optimisations done by the JIT, this is not at
all an accurate value.</p>

<p style="margin-left:23%; margin-top: 1em">4. The number
of guest (x86, amd64, ppc, etc.) instructions and IR
statements executed. IR is Valgrind's RISC&minus;like
intermediate representation via which all instrumentation is
done.</p>

<p style="margin-left:23%; margin-top: 1em">5. Ratios
between some of these counts.</p>

<p style="margin-left:23%; margin-top: 1em">6. The exit
code of the client program.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;detailed&minus;counts=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Lackey prints a
table containing counts of loads, stores and ALU operations,
differentiated by their IR types. The IR types are
identified by their IR name (&quot;I1&quot;, &quot;I8&quot;,
... &quot;I128&quot;, &quot;F32&quot;, &quot;F64&quot;, and
&quot;V128&quot;).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;mem=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Lackey prints the
size and address of almost every memory access made by the
program. See the comments at the top of the file
lackey/lk_main.c for details about the output format, how it
works, and inaccuracies in the address trace. Note that this
option produces immense amounts of output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;trace&minus;superblocks=&lt;no|yes&gt;
[default: no]</b></p>

<p style="margin-left:17%;">When enabled, Lackey prints out
the address of every superblock (a single entry, multiple
exit, linear chunk of code) executed by the program. This is
primarily of interest to Valgrind developers. See the
comments at the top of the file lackey/lk_main.c for details
about the output format. Note that this option produces
large amounts of output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;fnname=&lt;name&gt;
[default: main]</b></p>

<p style="margin-left:17%;">Changes the function for which
calls are counted when
<b>&minus;&minus;basic&minus;counts=yes</b> is
specified.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">cg_annotate(1),
callgrind_annotate(1), callgrind_control(1), ms_print(1),
$INSTALL/share/doc/valgrind/html/index.html or
http://www.valgrind.org/docs/manual/index.html,
<b><font color="#0000FF">Debugging your program using
Valgrind's gdbserver and GDB</font></b>
<small><font color="#000000">[1]</font></small>
<b><font color="#0000FF">vgdb</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">,</font>
<b><font color="#0000FF">Valgrind monitor
commands</font></b>
<small><font color="#000000">[3]</font></small>
<font color="#000000">,</font> <b><font color="#0000FF">The
Commentary</font></b>
<small><font color="#000000">[4]</font></small>
<font color="#000000">,</font>
<b><font color="#0000FF">Scheduling and Multi&minus;Thread
Performance</font></b>
<small><font color="#000000">[5]</font></small>
<font color="#000000">,</font>
<b><font color="#0000FF">Cachegrind: a cache and
branch&minus;prediction profiler</font></b>
<small><font color="#000000">[6]</font></small>
<font color="#000000">.</font></p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
Valgrind developers.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
manpage was written by Andres Roldan
&lt;aroldan@debian.org&gt; and the Valgrind
developers.</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><font color="#000000">Debugging
your program using Valgrind&rsquo;s gdbserver and
GDB</font></p> </td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.gdbserver</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="6%">



<p style="margin-top: 1em"><font color="#000000">vgdb</font></p> </td>
<td width="77%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.vgdb</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">3.</font></p> </td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em"><font color="#000000">Valgrind
monitor commands</font></p></td>
<td width="45%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.valgrind-monitor-commands</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">4.</font></p> </td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em"><font color="#000000">The
Commentary</font></p> </td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/manual-core.html#manual-core.comment</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">5.</font></p> </td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><font color="#000000">Scheduling
and Multi-Thread Performance</font></p></td>
<td width="23%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/manual-core.html#manual-core.pthreads_perf_sched</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">6.</font></p> </td>
<td width="2%"></td>
<td width="77%">



<p style="margin-top: 1em"><font color="#000000">Cachegrind:
a cache and branch-prediction profiler</font></p></td>
<td width="6%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">http://www.valgrind.org/docs/manual/cg-manual.html</font></p>
<hr>
</body>
</html>
