<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:31:48 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::pair&lt; _T1, _T2 &gt;</title>

</head>
<body>

<h1 align="center">std::pair&lt; _T1, _T2 &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Member Typedef Documentation">Member Typedef Documentation</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Data Documentation">Member Data Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::pair&lt;
_T1, _T2 &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherited by
<b>std::sub_match&lt; _Bi_iter &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _T1 <b>first_type</b>
<br>
typedef _T2 <b>second_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">constexpr <b>pair</b> () <br>
constexpr <b>pair</b> (const _T1 &amp;__a, const _T2
&amp;__b)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>template&lt;class _U1 , class _U2 , class = typename
enable_if&lt;__and_&lt;is_convertible&lt;const _U1&amp;,
_T1&gt;,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>is_convertible&lt;const _U2&amp;,
_T2&gt;&gt;::value&gt;::type&gt; constexpr <b>pair</b>
(const <b>pair</b>&lt; _U1, _U2 &gt; &amp;__p)</p></td></tr>
</table>

<p style="margin-left:17%;">constexpr <b>pair</b> (const
<b>pair</b> &amp;)=default <br>
constexpr <b>pair</b> (<b>pair</b> &amp;&amp;)=default <br>
template&lt;class _U1 , class = typename
enable_if&lt;is_convertible&lt;_U1,
_T1&gt;::value&gt;::type&gt; constexpr <b>pair</b> (_U1
&amp;&amp;__x, const _T2 &amp;__y) <br>
template&lt;class _U2 , class = typename
enable_if&lt;is_convertible&lt;_U2,
_T2&gt;::value&gt;::type&gt; constexpr <b>pair</b> (const
_T1 &amp;__x, _U2 &amp;&amp;__y)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>template&lt;class _U1 , class _U2 , class = typename
enable_if&lt;__and_&lt;is_convertible&lt;_U1, _T1&gt;,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>is_convertible&lt;_U2, _T2&gt;&gt;::value&gt;::type&gt;
constexpr <b>pair</b> (_U1 &amp;&amp;__x, _U2
&amp;&amp;__y)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>template&lt;class _U1 , class _U2 , class = typename
enable_if&lt;__and_&lt;is_convertible&lt;_U1, _T1&gt;,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>is_convertible&lt;_U2, _T2&gt;&gt;::value&gt;::type&gt;
constexpr <b>pair</b> (<b>pair</b>&lt; _U1, _U2 &gt;
&amp;&amp;__p)</p> </td></tr>
</table>

<p style="margin-left:17%;">template&lt;typename... _Args1,
typename... _Args2&gt; <b>pair</b>
(<b>piecewise_construct_t</b>, <b>tuple</b>&lt;
_Args1...&gt;, <b>tuple</b>&lt; _Args2...&gt;) <br>
void &amp;&amp; <b>noexcept</b> (<b>swap</b>(<b>second</b>,
__p.second))) <b><br>
pair</b> &amp; <b>operator=</b> (const <b>pair</b> &amp;__p)
<b><br>
pair</b> &amp; <b>operator=</b> (<b>pair</b> &amp;&amp;__p)
noexcept(__and_&lt; <b>is_nothrow_move_assignable</b>&lt;
_T1 &gt;, <b>is_nothrow_move_assignable</b>&lt; _T2
&gt;&gt;::value) <br>
template&lt;class _U1 , class _U2 &gt; <b>pair</b> &amp;
<b>operator=</b> (const <b>pair</b>&lt; _U1, _U2 &gt;
&amp;__p) <br>
template&lt;class _U1 , class _U2 &gt; <b>pair</b> &amp;
<b>operator=</b> (<b>pair</b>&lt; _U1, _U2 &gt;
&amp;&amp;__p)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;">_T1 <b>first</b> <br>
_T2 <b>second</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt;struct std::pair&lt; _T1, _T2 &gt;</b>
<br>
Struct holding two objects of arbitrary type.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters:</b></p>

<p style="margin-left:17%;"><i>_T1</i> Type of first
object. <i><br>
_T2</i> Type of second object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 96 of file stl_pair.h.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt; typedef _T2 std::pair&lt; _T1, _T2
&gt;::second_type</b> <tt><br>
first_type</tt> is the first bound type</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 99 of file stl_pair.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt; constexpr std::pair&lt; _T1, _T2
&gt;::pair ()</b> <tt>[inline] <br>
second</tt> is a copy of the second object The default
constructor creates <tt>first</tt> and <tt>second</tt> using
their respective default constructors.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 108 of file stl_pair.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt; constexpr std::pair&lt; _T1, _T2
&gt;::pair (const _T1 &amp;__a, const _T2 &amp;__b)</b>
<tt>[inline]</tt> <br>
Two objects may be passed to a <tt>pair</tt> constructor to
be copied.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 112 of file stl_pair.h.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>template&lt;class _T1, class _T2&gt;
template&lt;class _U1 , class _U2 , class = typename
enable_if&lt;__and_&lt;is_convertible&lt;const _U1&amp;,
_T1&gt;,</b></p> </td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>is_convertible&lt;const _U2&amp;,
_T2&gt;&gt;::value&gt;::type&gt; constexpr std::pair&lt;
_T1, _T2 &gt;::pair (const pair&lt; _U1, _U2 &gt;
&amp;__p)</b> <tt>[inline]</tt></p></td></tr>
</table>

<p style="margin-left:11%;">There is also a templated copy
ctor for the <tt>pair</tt> class itself.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 124 of file stl_pair.h.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt; _T1 std::pair&lt; _T1, _T2
&gt;::first</b> <tt><br>
second_type</tt> is the second bound type</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 101 of file stl_pair.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::_Temporary_buffer&lt; _ForwardIterator, _Tp
&gt;::_Temporary_buffer(), std::set&lt; _StateIdT
&gt;::insert(), and std::operator==().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_T1, class _T2&gt; _T2 std::pair&lt; _T1, _T2
&gt;::second</b> <tt><br>
first</tt> is a copy of the first object</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 102 of file stl_pair.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::_Temporary_buffer&lt; _ForwardIterator, _Tp
&gt;::_Temporary_buffer(), std::set&lt; _StateIdT
&gt;::insert(), and std::operator==().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
