<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:31:39 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::match_results&lt; _Bi_iter, _Alloc &gt;</title>

</head>
<body>

<h1 align="center">std::match_results&lt; _Bi_iter, _Alloc &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Member Data Documentation">Member Data Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::match_results&lt;
_Bi_iter, _Alloc &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::vector&lt; sub_match&lt; _Bi_iter &gt;, _Alloc
&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">bool <b>ready</b> () const</p>

<p style="margin-left:11%; margin-top: 1em"><b>Private
Types</b></p>

<p style="margin-left:17%;">typedef <br>
_Alloc_traits::const_pointer <b>const_pointer</b>&quot; <br>
typedef <b>std::reverse_iterator</b> <br>
&lt; const_iterator &gt; <b>const_reverse_iterator</b>&quot;
<br>
typedef _Base::pointer <b>pointer</b> <br>
typedef <b>std::reverse_iterator</b> <br>
&lt; iterator &gt; <b>reverse_iterator</b>&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Private
Member Functions</b></p>


<p style="margin-left:17%;"><b>_Alloc_traits::_S_on_swap</b>
(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()) <br>
pointer <b>_M_allocate</b> (size_t __n) <br>
pointer <b>_M_allocate_and_copy</b> (size_type __n,
_ForwardIterator __first, _ForwardIterator __last) <b><br>
void _M_assign_aux</b> (_InputIterator __first,
_InputIterator __last, <b>std::input_iterator_tag</b>)
<b><br>
void _M_assign_aux</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<b><br>
void _M_assign_dispatch</b> (_Integer __n, _Integer __val,
__true_type) <b><br>
void _M_assign_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <br>
size_type <b>_M_check_len</b> (size_type __n, const char
*__s) const <b><br>
void _M_deallocate</b> (pointer __p, size_t __n) <b><br>
void _M_default_append</b> (size_type __n) <b><br>
void _M_default_initialize</b> (size_type __n) <b><br>
void _M_emplace_back_aux</b> (_Args &amp;&amp;...__args)
<b><br>
void _M_erase_at_end</b> (pointer __pos) <b><br>
void _M_fill_assign</b> (size_type __n, const
<b>value_type</b> &amp;__val) <b><br>
void _M_fill_initialize</b> (size_type __n, const
<b>value_type</b> &amp;__value) <b><br>
void _M_fill_insert</b> (iterator __pos, size_type __n,
const <b>value_type</b> &amp;__x) <br>
_Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> () noexcept
<br>
const _Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> ()
const noexcept <b><br>
void _M_initialize_dispatch</b> (_Integer __n, _Integer
__value, __true_type) <b><br>
void _M_initialize_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <b><br>
void _M_insert_aux</b> (iterator __position, _Args
&amp;&amp;...__args) <b><br>
void _M_insert_dispatch</b> (iterator __pos, _Integer __n,
_Integer __val, __true_type) <b><br>
void _M_insert_dispatch</b> (iterator __pos, _InputIterator
__first, _InputIterator __last, __false_type) <b><br>
void _M_range_check</b> (size_type __n) const <b><br>
void _M_range_initialize</b> (_InputIterator __first,
_InputIterator __last, <b>std::input_iterator_tag</b>)
<b><br>
void _M_range_initialize</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<b><br>
void _M_range_insert</b> (iterator __pos, _InputIterator
__first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <b><br>
void _M_range_insert</b> (iterator __pos, _ForwardIterator
__first, _ForwardIterator __last,
<b>std::forward_iterator_tag</b>) <br>
bool <b>_M_shrink_to_fit</b> () <b><br>
void assign</b> (size_type __n, const <b>value_type</b>
&amp;__val) <b><br>
void assign</b> (_InputIterator __first, _InputIterator
__last) <b><br>
void assign</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l) <b><br>
reference at</b> (size_type __n) <b><br>
const_reference at</b> (size_type __n) const <b><br>
reference back</b> () <b><br>
const_reference back</b> () const <br>
iterator <b>begin</b> () noexcept <br>
size_type <b>capacity</b> () const noexcept <b><br>
void clear</b> () noexcept <b><br>
const_reverse_iterator crbegin</b> () const noexcept <b><br>
const_reverse_iterator crend</b> () const noexcept <b><br>
sub_match</b>&lt; _Bi_iter &gt; * <b>data</b> () noexcept
<br>
const <b>sub_match</b>&lt; _Bi_iter &gt; * <b>data</b> ()
const noexcept <br>
iterator <b>emplace</b> (iterator __position, _Args
&amp;&amp;...__args) <b><br>
void emplace_back</b> (_Args &amp;&amp;...__args) <br>
iterator <b>end</b> () noexcept <br>
iterator <b>erase</b> (iterator __position) <br>
iterator <b>erase</b> (iterator __first, iterator __last)
<b><br>
reference front</b> () <b><br>
const_reference front</b> () const <br>
iterator <b>insert</b> (iterator __position, const
<b>value_type</b> &amp;__x) <br>
iterator <b>insert</b> (iterator __position,
<b>value_type</b> &amp;&amp;__x) <b><br>
void insert</b> (iterator __position,
<b>initializer_list</b>&lt; <b>value_type</b> &gt; __l)
<b><br>
void insert</b> (iterator __position, size_type __n, const
<b>value_type</b> &amp;__x) <b><br>
void insert</b> (iterator __position, _InputIterator
__first, _InputIterator __last) <b><br>
reference operator[]</b> (size_type __n) <b><br>
const_reference operator[]</b> (size_type __n) const <b><br>
void pop_back</b> () <b><br>
void push_back</b> (const <b>value_type</b> &amp;__x)
<b><br>
void push_back</b> (<b>value_type</b> &amp;&amp;__x) <b><br>
reverse_iterator rbegin</b> () noexcept <b><br>
const_reverse_iterator rbegin</b> () const noexcept <b><br>
reverse_iterator rend</b> () noexcept <b><br>
const_reverse_iterator rend</b> () const noexcept <b><br>
void reserve</b> (size_type __n) <b><br>
void resize</b> (size_type __new_size) <b><br>
void resize</b> (size_type __new_size, const
<b>value_type</b> &amp;__x) <b><br>
void shrink_to_fit</b> ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Private
Attributes</b></p>

<p style="margin-left:17%;"><b>__a</b> <br>
_Vector_impl <b>_M_impl <br>
void</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">class
<b>__detail::_SpecializedResults&lt; _Bi_iter, _Alloc
&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>10.? Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef <b>sub_match</b>&lt; _Bi_iter &gt; <b>value_type</b>
<br>
typedef const <b>value_type</b> &amp; <b>const_reference</b>
<br>
typedef <b>const_reference reference</b> <br>
typedef _Base_type::const_iterator <b>const_iterator</b>
<br>
typedef const_iterator <b>iterator</b> <br>
typedef <br>
__iter_traits::difference_type <b>difference_type</b>&quot;
<br>
typedef __iter_traits::value_type <b>char_type</b> <br>
typedef <b>allocator_traits</b> <br>
&lt; _Alloc &gt;::size_type <b>size_type</b>&quot; <br>
typedef <b>std::basic_string</b> <br>
&lt; char_type &gt; <b>string_type</b>&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.1
Construction, Copying, and Destruction</b></p>

<p style="margin-left:17%;"><b>__pad0__</b>:
<b>_Base_type</b>(__a) { } <b>match_results</b>(const
<b>match_results</b>&amp; __rhs) : <b>_Base_type</b>(__rhs)
{ } <b>match_results</b>(<b>match_results</b>&amp;&amp;
__rhs) noexcept : <b>_Base_type</b>(std::move(__rhs)) { }
<b>match_results</b>&amp; operator=(const
<b>match_results</b>&amp; __rhs) {
<b>match_results</b>(__rhs).<b>swap</b>(*<b>this</b>) <br>
return * <b>this <br>
match_results</b> &amp; <b>operator=</b>
(<b>match_results</b> &amp;&amp;__rhs) <b><br>
~match_results</b> ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.2
Size</b></p>

<p style="margin-left:17%;">size_type <b>size</b> () const
<br>
size_type <b>max_size</b> () const <br>
bool <b>empty</b> () const</p>

<p style="margin-left:11%; margin-top: 1em"><b>10.3 Element
Access</b></p>

<p style="margin-left:17%;">difference_type <b>length</b>
(size_type __sub=0) const <br>
difference_type <b>position</b> (size_type __sub=0) const
<b><br>
string_type str</b> (size_type __sub=0) const <b><br>
const_reference operator[]</b> (size_type __sub) const
<b><br>
const_reference prefix</b> () const <b><br>
const_reference suffix</b> () const <br>
const_iterator <b>begin</b> () const <br>
const_iterator <b>cbegin</b> () const <br>
const_iterator <b>end</b> () const <br>
const_iterator <b>cend</b> () const</p>

<p style="margin-left:11%; margin-top: 1em"><b>10.4
Formatting</b> <br>
These functions perform formatted substitution of the
matched character sequences into their target. The format
specifiers and escape sequences accepted by these functions
are determined by their <tt>flags</tt> parameter as
documented above.</p>

<p style="margin-left:17%;">template&lt;typename _Out_iter
&gt; _Out_iter <b>format</b> (_Out_iter __out, const
char_type *__fmt_first, const char_type *__fmt_last,
match_flag_type
__flags=<b>regex_constants::format_default</b>) const <br>
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; _Out_iter <b>format</b> (_Out_iter __out, const
<b>basic_string</b>&lt; char_type, _St, _Sa &gt; &amp;__fmt,
match_flag_type
__flags=<b>regex_constants::format_default</b>) const <br>
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; <b>basic_string</b>&lt; char_type, _St, _Sa &gt;
<b>format</b> (const <b>basic_string</b>&lt; char_type, _St,
_Sa &gt; &amp;__fmt, match_flag_type
__flags=<b>regex_constants::format_default</b>) const
<b><br>
string_type format</b> (const char_type *__fmt,
match_flag_type
__flags=<b>regex_constants::format_default</b>) const</p>

<p style="margin-left:11%; margin-top: 1em"><b>10.5
Allocator</b></p>

<p style="margin-left:17%;">allocator_type
<b>get_allocator</b> () const</p>

<p style="margin-left:11%; margin-top: 1em"><b>10.6
Swap</b></p>

<p style="margin-left:17%;"><b>void swap</b>
(<b>match_results</b> &amp;__that)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;class
std::match_results&lt; _Bi_iter, _Alloc &gt;</b> <br>
The results of a match or search operation.</p>

<p style="margin-left:11%; margin-top: 1em">A collection of
character sequences representing the result of a regular
expression match. Storage for the collection is allocated
and freed as necessary by the member functions of class
template match_results.</p>

<p style="margin-left:11%; margin-top: 1em">This class
satisfies the Sequence requirements, with the exception that
only the operations defined for a const-qualified Sequence
are supported.</p>

<p style="margin-left:11%; margin-top: 1em">The sub_match
object stored at index 0 represents sub-expression 0, i.e.
the whole match. In this case the sub_match member matched
is always true. The sub_match object stored at index n
denotes what matched the marked sub-expression n within the
matched expression. If the sub-expression n participated in
a regular expression match then the sub_match member matched
evaluates to true, and members first and second denote the
range of characters [first, second) which formed that match.
Otherwise matched is false, and members first and second
point to the end of the sequence that was searched.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1429 of file regex.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::~match_results
()</b> <tt>[inline]</tt> <br>
Destroys a match_results object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1519 of file regex.h.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::begin () const</b> <tt>[inline]</tt> <br>
Gets an iterator to the start of the sub_match
collection.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1676 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::operator==().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::cbegin () const</b> <tt>[inline]</tt> <br>
Gets an iterator to the start of the sub_match
collection.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1683 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::cend () const</b> <tt>[inline]</tt> <br>
Gets an iterator to one-past-the-end of the collection.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1697 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool
std::match_results&lt; _Bi_iter, _Alloc &gt;::empty ()
const</b> <tt>[inline]</tt> <br>
Indicates if the match_results contains no results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
values:</b></p>

<p style="margin-left:17%;"><i>true</i> The match_results
object is empty. <i><br>
false</i> The match_results object is not empty.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1563 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::match_results&lt; _FwdIterT, _Alloc &gt;::end(),
std::operator==(), std::match_results&lt; _FwdIterT, _Alloc
&gt;::prefix(), and std::match_results&lt; _FwdIterT, _Alloc
&gt;::suffix().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::end () const</b> <tt>[inline]</tt> <br>
Gets an iterator to one-past-the-end of the collection.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1690 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::match_results&lt; _FwdIterT, _Alloc &gt;::cend(), and
std::operator==().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _Out_iter &gt; _Out_iter
std::match_results&lt; _Bi_iter, _Alloc &gt;::format
(_Out_iter__out, const char_type *__fmt_first, const
char_type *__fmt_last, match_flag_type__flags =
regex_constants::format_default) const</b> <tt>[inline]</tt>
<b><br>
Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Implement this function.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1718 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::match_results&lt; _FwdIterT, _Alloc &gt;::format().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; _Out_iter std::match_results&lt; _Bi_iter, _Alloc
&gt;::format (_Out_iter__out, const basic_string&lt;
char_type, _St, _Sa &gt; &amp;__fmt, match_flag_type__flags
= regex_constants::format_default) const</b>
<tt>[inline]</tt> <b><br>
Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1728 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; basic_string&lt;char_type, _St, _Sa&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::format (const
basic_string&lt; char_type, _St, _Sa &gt; &amp;__fmt,
match_flag_type__flags = regex_constants::format_default)
const</b> <tt>[inline]</tt> <b><br>
Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1740 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; string_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::format (const
char_type *__fmt, match_flag_type__flags =
regex_constants::format_default) const</b> <tt>[inline]</tt>
<b><br>
Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1752 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
allocator_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt> <br>
Gets a copy of the allocator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1773 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
difference_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::length (size_type__sub =</b> <tt>0</tt><b>) const</b>
<tt>[inline]</tt> <br>
Gets the length of the indicated submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the length of the indicated submatch, or the length
of the entire match if <tt>__sub</tt> is zero (the
default).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1582 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::max_size ()
const</b> <tt>[inline]</tt> <br>
Gets the number of matches and submatches. The number of
matches for a given regular expression will be either 0 if
there was no match or mark_count() + 1 if a match was
successful. Some matches may be empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">the number of matches
found.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1554 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
match_results&amp; std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator= (match_results&lt; _Bi_iter, _Alloc &gt;
&amp;&amp;__rhs)</b> <tt>[inline]</tt> <br>
Move-assigns rhs to *this.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1510 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator[] (size_type__sub) const</b>
<tt>[inline]</tt> <br>
Gets a sub_match reference for the match or submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to the indicated submatch, or the entire
match if <tt>__sub</tt> is zero.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>__sub</tt> &gt;= size() then this function returns a
sub_match with a special value indicating no submatch.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1630 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
difference_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::position (size_type__sub =</b> <tt>0</tt><b>)
const</b> <tt>[inline]</tt> <br>
Gets the offset of the beginning of the indicated
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the offset from the beginning of the target sequence
to the beginning of the submatch, unless the value of
<tt>__sub</tt> is zero (the default), in which case this
function returns the offset from the beginning of the target
sequence to the beginning of the match.</p>

<p style="margin-left:11%; margin-top: 1em">Returns -1 if
<tt>__sub</tt> is out of range.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1599 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::prefix () const</b> <tt>[inline]</tt> <br>
Gets a sub_match representing the match prefix.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to a sub_match object representing the part
of the target range between the start of the target range
and the start of the match.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1647 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::operator==(), and std::match_results&lt; _FwdIterT,
_Alloc &gt;::position().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool
std::match_results&lt; _Bi_iter, _Alloc &gt;::ready ()
const</b> <tt>[inline]</tt> <br>
Indicates if the match_results is ready.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
values:</b></p>

<p style="margin-left:17%;"><i>true</i> The object has a
fully-established result state. <i><br>
false</i> The object is not ready.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1530 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::operator==(), std::match_results&lt; _FwdIterT, _Alloc
&gt;::operator[](), std::match_results&lt; _FwdIterT, _Alloc
&gt;::prefix(), and std::match_results&lt; _FwdIterT, _Alloc
&gt;::suffix().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::size ()
const</b> <tt>[inline]</tt> <br>
Gets the number of matches and submatches. The number of
matches for a given regular expression will be either 0 if
there was no match or mark_count() + 1 if a match was
successful. Some matches may be empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">the number of matches
found.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1547 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::match_results&lt; _FwdIterT, _Alloc &gt;::empty(),
std::operator==(), std::match_results&lt; _FwdIterT, _Alloc
&gt;::operator[](), and std::match_results&lt; _FwdIterT,
_Alloc &gt;::position().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; string_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::str
(size_type__sub =</b> <tt>0</tt><b>) const</b>
<tt>[inline]</tt> <br>
Gets the match or submatch converted to a string type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets the submatch (or match, if <tt>__sub</tt> is zero)
extracted from the target range and converted to the
associated string type.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1615 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::suffix () const</b> <tt>[inline]</tt> <br>
Gets a sub_match representing the match suffix.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to a sub_match object representing the part
of the target range between the end of the match and the end
of the target range.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1664 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::operator==().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; void
std::match_results&lt; _Bi_iter, _Alloc &gt;::swap
(match_results&lt; _Bi_iter, _Alloc &gt; &amp;__that)</b>
<tt>[inline]</tt> <br>
Swaps the contents of two match_results.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1787 of file regex.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::match_results&lt; _FwdIterT, _Alloc &gt;::operator=(),
and std::swap().</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::__pad0__</b>
<tt>[explicit]</tt> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1502 of file regex.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; return*
std::match_results&lt; _Bi_iter, _Alloc &gt;::this</b> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1503 of file regex.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
