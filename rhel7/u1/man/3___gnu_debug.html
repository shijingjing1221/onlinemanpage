<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:19:20 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug</title>

</head>
<body>

<h1 align="center">__gnu_debug</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Enumeration Type Documentation">Enumeration Type Documentation</a><br>
<a href="#Function Documentation">Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">__gnu_debug
&minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>_After_nth_from</b>
<br>
struct <b>_BeforeBeginHelper</b> <br>
class <b>_Equal_to</b> <br>
class <b>_Not_equal_to</b> <br>
class <b>_Safe_iterator</b> <br>
class <b>_Safe_iterator_base</b> <br>
class <b>_Safe_local_iterator</b> <br>
class <b>_Safe_local_iterator_base</b> <br>
class <b>_Safe_sequence</b> <br>
class <b>_Safe_sequence_base</b> <br>
class <b>_Safe_unordered_container</b> <br>
class <b>_Safe_unordered_container_base</b> <br>
class <b>basic_string</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">typedef <b>basic_string</b>&lt;
char &gt; <b>string</b> <br>
typedef <b>basic_string</b>&lt; wchar_t &gt;
<b>wstring</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Enumerations</b></p>

<p style="margin-left:17%;">enum <b>_Debug_msg_id</b> {
<b>__msg_valid_range</b>, <b>__msg_insert_singular</b>,
<b>__msg_insert_different</b>, <b>__msg_erase_bad</b>,
<b>__msg_erase_different</b>, <b>__msg_subscript_oob</b>,
<b>__msg_empty</b>, <b>__msg_unpartitioned</b>,
<b>__msg_unpartitioned_pred</b>, <b>__msg_unsorted</b>,
<b>__msg_unsorted_pred</b>, <b>__msg_not_heap</b>,
<b>__msg_not_heap_pred</b>, <b>__msg_bad_bitset_write</b>,
<b>__msg_bad_bitset_read</b>, <b>__msg_bad_bitset_flip</b>,
<b>__msg_self_splice</b>, <b>__msg_splice_alloc</b>,
<b>__msg_splice_bad</b>, <b>__msg_splice_other</b>,
<b>__msg_splice_overlap</b>, <b>__msg_init_singular</b>,
<b>__msg_init_copy_singular</b>,
<b>__msg_init_const_singular</b>,
<b>__msg_copy_singular</b>, <b>__msg_bad_deref</b>,
<b>__msg_bad_inc</b>, <b>__msg_bad_dec</b>,
<b>__msg_iter_subscript_oob</b>, <b>__msg_advance_oob</b>,
<b>__msg_retreat_oob</b>, <b>__msg_iter_compare_bad</b>,
<b>__msg_compare_different</b>, <b>__msg_iter_order_bad</b>,
<b>__msg_order_different</b>, <b>__msg_distance_bad</b>,
<b>__msg_distance_different</b>, <b>__msg_deref_istream</b>,
<b>__msg_inc_istream</b>, <b>__msg_output_ostream</b>,
<b>__msg_deref_istreambuf</b>, <b>__msg_inc_istreambuf</b>,
<b>__msg_insert_after_end</b>, <b>__msg_erase_after_bad</b>,
<b>__msg_valid_range2</b>,
<b>__msg_local_iter_compare_bad</b>,
<b>__msg_non_empty_range</b>, <b>__msg_self_move_assign</b>,
<b>__msg_bucket_index_oob</b>,
<b>__msg_valid_load_factor</b>, <b>__msg_equal_allocs</b> }
<br>
enum <b>_Distance_precision</b> { <b>__dp_equality</b>,
<b>__dp_sign</b>, <b>__dp_exact</b> }</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Iterator
&gt; _Siter_base&lt; _Iterator &gt; <br>
::iterator_type <b>__base</b> (_Iterator __it)&quot; <br>
template&lt;typename _Iterator &gt; bool
<b>__check_dereferenceable</b> (_Iterator &amp;) <br>
template&lt;typename _Tp &gt; bool
<b>__check_dereferenceable</b> (const _Tp *__ptr) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__check_dereferenceable</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__x) <br>
template&lt;typename _ForwardIterator , typename _Tp &gt;
bool <b>__check_partitioned_lower</b> (_ForwardIterator
__first, _ForwardIterator __last, const _Tp &amp;__value)
<br>
template&lt;typename _ForwardIterator , typename _Tp ,
typename _Pred &gt; bool <b>__check_partitioned_lower</b>
(_ForwardIterator __first, _ForwardIterator __last, const
_Tp &amp;__value, _Pred __pred) <br>
template&lt;typename _ForwardIterator , typename _Tp &gt;
bool <b>__check_partitioned_upper</b> (_ForwardIterator
__first, _ForwardIterator __last, const _Tp &amp;__value)
<br>
template&lt;typename _ForwardIterator , typename _Tp ,
typename _Pred &gt; bool <b>__check_partitioned_upper</b>
(_ForwardIterator __first, _ForwardIterator __last, const
_Tp &amp;__value, _Pred __pred) <br>
template&lt;typename _Iterator &gt; bool
<b>__check_singular</b> (_Iterator &amp;) <br>
template&lt;typename _Tp &gt; bool <b>__check_singular</b>
(const _Tp *__ptr) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__check_singular</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__x) <br>
bool <b>__check_singular_aux</b> (const void *) <br>
bool <b>__check_singular_aux</b> (const
<b>_Safe_iterator_base</b> *__x) <br>
template&lt;typename _InputIterator &gt; bool
<b>__check_sorted</b> (const _InputIterator &amp;__first,
const _InputIterator &amp;__last) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; bool <b>__check_sorted</b> (const _InputIterator
&amp;__first, const _InputIterator &amp;__last, _Predicate
__pred) <br>
template&lt;typename _InputIterator &gt; bool
<b>__check_sorted_aux</b> (const _InputIterator &amp;, const
_InputIterator &amp;, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; bool
<b>__check_sorted_aux</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__check_sorted_aux</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__first, const <b>_Safe_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;__last,
<b>std::random_access_iterator_tag</b> __tag) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; bool <b>__check_sorted_aux</b> (const _InputIterator
&amp;, const _InputIterator &amp;, _Predicate,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator , typename _Predicate
&gt; bool <b>__check_sorted_aux</b> (_ForwardIterator
__first, _ForwardIterator __last, _Predicate __pred,
<b>std::forward_iterator_tag</b>) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Predicate &gt; bool <b>__check_sorted_aux</b>
(const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__first, const <b>_Safe_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;__last, _Predicate __pred,
<b>std::random_access_iterator_tag</b> __tag) <br>
template&lt;typename _InputIterator1 , typename
_InputIterator2 &gt; bool <b>__check_sorted_set</b> (const
_InputIterator1 &amp;__first, const _InputIterator1
&amp;__last, const _InputIterator2 &amp;) <br>
template&lt;typename _InputIterator1 , typename
_InputIterator2 , typename _Predicate &gt; bool
<b>__check_sorted_set</b> (const _InputIterator1
&amp;__first, const _InputIterator1 &amp;__last, const
_InputIterator2 &amp;, _Predicate __pred) <br>
template&lt;typename _InputIterator &gt; bool
<b>__check_sorted_set_aux</b> (const _InputIterator
&amp;__first, const _InputIterator &amp;__last,
std::__true_type) <br>
template&lt;typename _InputIterator &gt; bool
<b>__check_sorted_set_aux</b> (const _InputIterator &amp;,
const _InputIterator &amp;, std::__false_type) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; bool <b>__check_sorted_set_aux</b> (const
_InputIterator &amp;__first, const _InputIterator
&amp;__last, _Predicate __pred, std::__true_type) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; bool <b>__check_sorted_set_aux</b> (const
_InputIterator &amp;, const _InputIterator &amp;,
_Predicate, std::__false_type) <br>
template&lt;typename _CharT , typename _Integer &gt; const
_CharT * <b>__check_string</b> (const _CharT *__s, const
_Integer &amp;__n __attribute__((__unused__))) <br>
template&lt;typename _CharT &gt; const _CharT *
<b>__check_string</b> (const _CharT *__s) <br>
template&lt;typename _InputIterator &gt; _InputIterator
<b>__check_valid_range</b> (const _InputIterator
&amp;__first, const _InputIterator &amp;__last
__attribute__((__unused__))) <br>
template&lt;typename _Iterator1 , typename _Iterator2 &gt;
<b>std::pair</b>&lt; typename <br>
std::iterator_traits <br>
&lt; _Iterator1 &gt; <br>
::difference_type, <b><br>
_Distance_precision</b> &gt; <b>__get_distance</b> (const
_Iterator1 &amp;__lhs, const _Iterator2 &amp;__rhs,
<b>std::random_access_iterator_tag</b>)&quot; <br>
template&lt;typename _Iterator1 , typename _Iterator2 &gt;
<b>std::pair</b>&lt; typename <br>
std::iterator_traits <br>
&lt; _Iterator1 &gt; <br>
::difference_type, <b><br>
_Distance_precision</b> &gt; <b>__get_distance</b> (const
_Iterator1 &amp;__lhs, const _Iterator2 &amp;__rhs,
<b>std::forward_iterator_tag</b>)&quot; <br>
template&lt;typename _Iterator1 , typename _Iterator2 &gt;
<b>std::pair</b>&lt; typename <br>
std::iterator_traits <br>
&lt; _Iterator1 &gt; <br>
::difference_type, <b><br>
_Distance_precision</b> &gt; <b>__get_distance</b> (const
_Iterator1 &amp;__lhs, const _Iterator2 &amp;__rhs)&quot;
<br>
template&lt;typename _InputIterator &gt; bool
<b>__valid_range</b> (const _InputIterator &amp;__first,
const _InputIterator &amp;__last) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__valid_range</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__first, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__last) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__valid_range</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__first, const <b>_Safe_local_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__last) <br>
template&lt;typename _Integral &gt; bool
<b>__valid_range_aux</b> (const _Integral &amp;, const
_Integral &amp;, std::__true_type) <br>
template&lt;typename _InputIterator &gt; bool
<b>__valid_range_aux</b> (const _InputIterator &amp;__first,
const _InputIterator &amp;__last, std::__false_type) <br>
template&lt;typename _RandomAccessIterator &gt; bool
<b>__valid_range_aux2</b> (const _RandomAccessIterator
&amp;__first, const _RandomAccessIterator &amp;__last,
<b>std::random_access_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; bool
<b>__valid_range_aux2</b> (const _InputIterator &amp;, const
_InputIterator &amp;, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>getline</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str, _CharT __delim)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>getline</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str)&quot; <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator!=</b> (const
<b>_Safe_local_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_local_iterator</b>&lt;
_IteratorR, _Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator!=</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__lhs, const <b>_Safe_local_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator!=</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator!=</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const _CharT *__lhs,
const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator
&gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
<b>_Safe_iterator</b>&lt; _Iterator, <br>
_Sequence &gt; <b>operator+</b> (typename
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence
&gt;::difference_type __n, const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__i)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
<br>
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
<br>
_Allocator &gt; <b>operator+</b> (const _CharT *__lhs, const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
<br>
_Allocator &gt; <b>operator+</b> (_CharT __lhs, const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
<br>
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
<br>
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, _CharT __rhs)&quot; <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; <b>_Safe_iterator</b>&lt;
_IteratorL, <br>
_Sequence &gt;::difference_type <b>operator-</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs)&quot; <br>
template&lt;typename _Iterator , typename _Sequence &gt;
<b>_Safe_iterator</b>&lt; _Iterator, <br>
_Sequence &gt;::difference_type <b>operator-</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;__rhs)&quot; <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator&lt;</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator&lt;</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_ostream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>operator&lt;&lt;</b>
(<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
&amp;__os, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str)&quot; <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator&lt;=</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator&lt;=</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator==</b> (const
<b>_Safe_local_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_local_iterator</b>&lt;
_IteratorR, _Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator==</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__lhs, const <b>_Safe_local_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator==</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator==</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const _CharT *__lhs,
const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator
&gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator&gt;</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator&gt;</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _IteratorL , typename _IteratorR ,
typename _Sequence &gt; bool <b>operator&gt;=</b> (const
<b>_Safe_iterator</b>&lt; _IteratorL, _Sequence &gt;
&amp;__lhs, const <b>_Safe_iterator</b>&lt; _IteratorR,
_Sequence &gt; &amp;__rhs) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>operator&gt;=</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>operator&gt;&gt;</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str)&quot; <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; void <b>swap</b> (<b>basic_string</b>&lt;
_CharT, _Traits, _Allocator &gt; &amp;__lhs,
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GNU debug
classes for public use.</p>

<h2>Enumeration Type Documentation
<a name="Enumeration Type Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>enum
__gnu_debug::_Distance_precision</b> <br>
The precision to which we can calculate the distance between
two iterators.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 70 of file safe_iterator.h.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; _Siter_base&lt;_Iterator&gt;::iterator_type
__gnu_debug::__base (_Iterator__it)</b> <tt>[inline]</tt>
<br>
Helper function to extract base iterator of random access
safe iterator in order to reduce performance impact of debug
mode. Limited to random access iterator because it is the
only category for which it is possible to check for correct
iterators order in the __valid_range function thanks to the
&lt; operator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 446 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_parallel::__for_each_template_random_access_workstealing(),
__gnu_debug::_Safe_iterator&lt; _Base_iterator, map
&gt;::_M_before_dereferenceable(), std::boolalpha(),
std::dec(), std::fixed(), std::hex(), std::internal(),
std::left(), std::noboolalpha(), std::noshowbase(),
std::noshowpoint(), std::noshowpos(), std::noskipws(),
std::nounitbuf(), std::nouppercase(), std::oct(),
std::right(), std::scientific(), std::showbase(),
std::showpoint(), std::showpos(), std::skipws(),
std::unitbuf(), and std::uppercase().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; bool __gnu_debug::__check_dereferenceable
(_Iterator &amp;)</b> <tt>[inline]</tt> <br>
Assume that some arbitrary iterator is dereferenceable,
because we can&rsquo;t prove that it isn&rsquo;t.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 70 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; bool __gnu_debug::__check_dereferenceable (const
_Tp *__ptr)</b> <tt>[inline]</tt> <br>
Non-NULL pointers are dereferenceable.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 76 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::__check_dereferenceable (const
_Safe_iterator&lt; _Iterator, _Sequence &gt; &amp;__x)</b>
<tt>[inline]</tt> <br>
Safe iterators know if they are singular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 82 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence
&gt;::_M_dereferenceable().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; bool __gnu_debug::__check_singular (const _Tp
*__ptr)</b> <tt>[inline]</tt> <br>
Non-NULL pointers are nonsingular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 57 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::__check_singular (const _Safe_iterator&lt;
_Iterator, _Sequence &gt; &amp;__x)</b> <tt>[inline]</tt>
<br>
Safe iterators know if they are singular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 63 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
__gnu_debug::_Safe_iterator_base::_M_singular().</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::__check_singular_aux (const _Safe_iterator_base
*__x)</b> <tt>[inline]</tt> <br>
Iterators that derive from _Safe_iterator_base but that
aren&rsquo;t _Safe_iterators can be determined singular or
non-singular via _Safe_iterator_base.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 64 of file safe_iterator.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
__gnu_debug::_Safe_iterator_base::_M_singular().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Integer &gt; const _CharT*
__gnu_debug::__check_string (const _CharT *__s, const
_Integer &amp;__n __attribute__(__unused__))</b>
<tt>[inline]</tt> <br>
Checks that __s is non-NULL or __n == 0, and then returns
__s.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 168 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT &gt; const _CharT* __gnu_debug::__check_string (const
_CharT *__s)</b> <tt>[inline]</tt> <br>
Checks that __s is non-NULL and then returns __s.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 180 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator1 , typename _Iterator2 &gt; std::pair&lt;typename
std::iterator_traits&lt;_Iterator1&gt;::difference_type,
_Distance_precision&gt; __gnu_debug::__get_distance (const
_Iterator1 &amp;__lhs, const _Iterator2 &amp;__rhs,
std::random_access_iterator_tag)</b> <tt>[inline]</tt> <br>
Determine the distance between two iterators with some known
precision.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 83 of file safe_iterator.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::make_pair().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator &gt; bool __gnu_debug::__valid_range (const
_InputIterator &amp;__first, const _InputIterator
&amp;__last)</b> <tt>[inline]</tt> <br>
Don&rsquo;t know what these iterators are, or if they are
even iterators (we may get an integral type for
InputIterator), so see if they are integral and pass them on
to the next phase otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 131 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
__valid_range_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::__valid_range (const _Safe_iterator&lt;
_Iterator, _Sequence &gt; &amp;__first, const
_Safe_iterator&lt; _Iterator, _Sequence &gt;
&amp;__last)</b> <tt>[inline]</tt> <br>
Safe iterators know how to check if they form a valid
range.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 140 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::__valid_range (const _Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp;__first, const
_Safe_local_iterator&lt; _Iterator, _Sequence &gt;
&amp;__last)</b> <tt>[inline]</tt> <br>
Safe local iterators know how to check if they form a valid
range.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 147 of file functions.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Integral &gt; bool __gnu_debug::__valid_range_aux (const
_Integral &amp;, const _Integral &amp;,
std::__true_type)</b> <tt>[inline]</tt> <br>
We say that integral types for a valid range, and defer to
other routines to realize what to do with integral types
instead of iterators.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 111 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__valid_range().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator &gt; bool __gnu_debug::__valid_range_aux
(const _InputIterator &amp;__first, const _InputIterator
&amp;__last, std::__false_type)</b> <tt>[inline]</tt> <br>
We have iterators, so figure out what kind of iterators that
are to see if we can check the range ahead of time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 119 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::__iterator_category(), and __valid_range_aux2().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_RandomAccessIterator &gt; bool
__gnu_debug::__valid_range_aux2 (const _RandomAccessIterator
&amp;__first, const _RandomAccessIterator &amp;__last,
std::random_access_iterator_tag)</b> <tt>[inline]</tt> <br>
If the distance between two random access iterators is
nonnegative, assume the range is valid.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 90 of file functions.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__valid_range_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator &gt; bool __gnu_debug::__valid_range_aux2
(const _InputIterator &amp;, const _InputIterator &amp;,
std::input_iterator_tag)</b> <tt>[inline]</tt> <br>
Can&rsquo;t test for a valid range with input iterators,
because iteration may be destructive. So we just assume that
the range is valid.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 101 of file functions.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
