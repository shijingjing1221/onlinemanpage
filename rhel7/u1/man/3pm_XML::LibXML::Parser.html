<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:51:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XML::LibXML::Parser</title>

</head>
<body>

<h1 align="center">XML::LibXML::Parser</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#PARSING">PARSING</a><br>
<a href="#SERIALIZATION">SERIALIZATION</a><br>
<a href="#PARSER OPTIONS">PARSER OPTIONS</a><br>
<a href="#XML CATALOGS">XML CATALOGS</a><br>
<a href="#ERROR REPORTING">ERROR REPORTING</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::LibXML::Parser
&minus; Parsing XML Data with XML::LibXML</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use XML::LibXML 1.70;
  # Parser constructor
  $parser = XML::LibXML&minus;&gt;new();
  $parser = XML::LibXML&minus;&gt;new(option=&gt;value, ...);
  $parser = XML::LibXML&minus;&gt;new({option=&gt;value, ...});
  # Parsing XML
  $dom = XML::LibXML&minus;&gt;load_xml(
      location =&gt; $file_or_url
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml(
      string =&gt; $xml_string
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml(
      string =&gt; (\$xml_string)
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml({
      IO =&gt; $perl_file_handle
      # parser options ...
    );
  $dom = $parser&minus;&gt;load_xml(...);
  # Parsing HTML
  $dom = XML::LibXML&minus;&gt;load_html(...);
  $dom = $parser&minus;&gt;load_html(...);
  # Parsing well&minus;balanced XML chunks
  $fragment = $parser&minus;&gt;parse_balanced_chunk( $wbxmlstring, $encoding );
  # Processing XInclude
  $parser&minus;&gt;process_xincludes( $doc );
  $parser&minus;&gt;processXIncludes( $doc );
  # Old&minus;style parser interfaces
  $doc = $parser&minus;&gt;parse_file( $xmlfilename );
  $doc = $parser&minus;&gt;parse_fh( $io_fh );
  $doc = $parser&minus;&gt;parse_string( $xmlstring);
  $doc = $parser&minus;&gt;parse_html_file( $htmlfile, \%opts );
  $doc = $parser&minus;&gt;parse_html_fh( $io_fh, \%opts );
  $doc = $parser&minus;&gt;parse_html_string( $htmlstring, \%opts );
  # Push parser
  $parser&minus;&gt;parse_chunk($string, $terminate);
  $parser&minus;&gt;init_push();
  $parser&minus;&gt;push(@data);
  $doc = $parser&minus;&gt;finish_push( $recover );
  # Set/query parser options
  $parser&minus;&gt;option_exists($name);
  $parser&minus;&gt;get_option($name);
  $parser&minus;&gt;set_option($name,$value);
  $parser&minus;&gt;set_options({$name=&gt;$value,...});
  # XML catalogs
  $parser&minus;&gt;load_catalog( $catalog_file );</pre>


<h2>PARSING
<a name="PARSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An
<small>XML</small> document is read into a data structure
such as a <small>DOM</small> tree by a piece of software,
called a parser. XML::LibXML currently provides four
different parser interfaces:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p>A <small>DOM</small> Pull-Parser</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p>A <small>DOM</small> Push-Parser</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p>A <small>SAX</small> Parser</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p>A <small>DOM</small> based <small>SAX</small>
Parser.</p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Creating a
Parser Instance</b> <br>
XML::LibXML provides an <small>OO</small> interface to the
libxml2 parser functions. Thus you have to create a parser
instance before you can parse any <small>XML</small>
data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">new</p></td>
<td width="5%"></td>
<td width="45%">

<pre style="margin-top: 1em">  $parser = XML::LibXML&minus;&gt;new();</td>
<td width="35%">
</td></tr>
</table></pre>

<p style="margin-left:17%;">$parser =
XML::LibXML&minus;&gt;new(option=&gt;value, ...); <br>
$parser = XML::LibXML&minus;&gt;new({option=&gt;value,
...});</p>

<p style="margin-left:17%; margin-top: 1em">Create a new
<small>XML</small> and <small>HTML</small> parser instance.
Each parser instance holds default values for various parser
options. Optionally, one can pass a hash reference or a list
of option =&gt; value pairs to set a different default set
of options. Unless specified otherwise, the options
<tt>&quot;load_ext_dtd&quot;</tt>, and
<tt>&quot;expand_entities&quot;</tt> are set to 1. See
&quot;Parser Options&quot; for a list of libxml2
parser&rsquo;s options.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOM</small>
Parser</b> <br>
One of the common parser interfaces of XML::LibXML is the
<small>DOM</small> parser. This parser reads
<small>XML</small> data into a <small>DOM</small> like data
structure, so each tag can get accessed and transformed.</p>


<p style="margin-left:11%; margin-top: 1em">XML::LibXML&rsquo;s
<small>DOM</small> parser is not only capable to parse
<small>XML</small> data, but also (strict)
<small>HTML</small> files. There are three ways to parse
documents &minus; as a string, as a Perl filehandle, or as a
filename/URL. The return value from each is a
XML::LibXML::Document object, which is a <small>DOM</small>
object.</p>

<p style="margin-left:11%; margin-top: 1em">All of the
functions listed below will throw an exception if the
document is invalid. To prevent this causing your program
exiting, wrap the call in an eval{} block <br>
load_xml</p>

<pre style="margin-left:17%;">  $dom = XML::LibXML&minus;&gt;load_xml(
      location =&gt; $file_or_url
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml(
      string =&gt; $xml_string
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml(
      string =&gt; (\$xml_string)
      # parser options ...
    );
  $dom = XML::LibXML&minus;&gt;load_xml({
      IO =&gt; $perl_file_handle
      # parser options ...
    );
  $dom = $parser&minus;&gt;load_xml(...);</pre>


<p style="margin-left:17%; margin-top: 1em">This function
is available since XML::LibXML 1.70. It provides easy to use
interface to the <small>XML</small> parser that parses given
file (or <small>URL</small> ), string, or input stream to a
<small>DOM</small> tree. The arguments can be passed in a
<small>HASH</small> reference or as name =&gt; value pairs.
The function can be called as a class method or an object
method. In both cases it internally creates a new parser
instance passing the specified parser options; if called as
an object method, it clones the original parser (preserving
its settings) and additionally applies the specified options
to the new parser. See the constructor
<tt>&quot;new&quot;</tt> and &quot;Parser Options&quot; for
more information.</p>

<p style="margin-left:11%;">load_html</p>

<pre style="margin-left:17%;">  $dom = XML::LibXML&minus;&gt;load_html(...);
  $dom = $parser&minus;&gt;load_html(...);</pre>


<p style="margin-left:17%; margin-top: 1em">This function
is available since XML::LibXML 1.70. It has the same usage
as <tt>&quot;load_xml&quot;</tt>, providing interface to the
<small>HTML</small> parser. See
<tt>&quot;load_xml&quot;</tt> for more information.</p>

<p style="margin-left:11%; margin-top: 1em">Parsing
<small>HTML</small> may cause problems, especially if the
ampersand (&rsquo;&amp;&rsquo;) is used. This is a common
problem if <small>HTML</small> code is parsed that contains
links to CGI-scripts. Such links cause the parser to throw
errors. In such cases libxml2 still parses the entire
document as there was no error, but the error causes
XML::LibXML to stop the parsing process. However, the
document is not lost. Such <small>HTML</small> documents
should be parsed using the <i>recover</i> flag. By default
recovering is deactivated.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
described above are implemented to parse well formed
documents. In some cases a program gets well balanced
<small>XML</small> instead of well formed documents (e.g. an
<small>XML</small> fragment from a database). With
XML::LibXML it is not required to wrap such fragments in the
code, because XML::LibXML is capable even to parse well
balanced <small>XML</small> fragments. <br>
parse_balanced_chunk</p>

<pre style="margin-left:17%;">  $fragment = $parser&minus;&gt;parse_balanced_chunk( $wbxmlstring, $encoding );</pre>


<p style="margin-left:17%; margin-top: 1em">This function
parses a well balanced <small>XML</small> string into a
XML::LibXML::DocumentFragment. The first arguments contains
the input string, the optional second argument can be used
to specify character encoding of the input (
<small>UTF&minus;8</small> is assumed by default).</p>

<p style="margin-left:11%;">parse_xml_chunk</p>

<p style="margin-left:17%;">This is the old name of
<i>parse_balanced_chunk()</i>. Because it may causes
confusion with the push parser interface, this function
should not be used anymore.</p>

<p style="margin-left:11%; margin-top: 1em">By default
XML::LibXML does not process XInclude tags within an
<small>XML</small> Document (see options section below).
XML::LibXML allows to post process a document to expand
XInclude tags. <br>
process_xincludes</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;process_xincludes( $doc );</pre>


<p style="margin-left:17%; margin-top: 1em">After a
document is parsed into a <small>DOM</small> structure, you
may want to expand the documents XInclude tags. This
function processes the given document structure and expands
all XInclude tags (or throws an error) by using the flags
and callbacks of the given parser instance.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
resulting Tree contains some extra nodes (of type
<small>XML_XINCLUDE_START</small> and
<small>XML_XINCLUDE_END</small> ) after successfully
processing the document. These nodes indicate where data was
included into the original tree. if the document is
serialized, these extra nodes will not show up.</p>

<p style="margin-left:17%; margin-top: 1em">Remember: A
Document with processed XIncludes differs from the original
document after serialization, because the original XInclude
tags will not get restored!</p>

<p style="margin-left:17%; margin-top: 1em">If the parser
flag &quot;expand_xincludes&quot; is set to 1, you need not
to post process the parsed document.</p>

<p style="margin-left:11%;">processXIncludes</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;processXIncludes( $doc );</pre>


<p style="margin-left:17%; margin-top: 1em">This is an
alias to process_xincludes, but through a
<small>JAVA</small> like function name.</p>

<p style="margin-left:11%;">parse_file</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_file( $xmlfilename );</pre>


<p style="margin-left:17%; margin-top: 1em">This function
parses an <small>XML</small> document from a file or
network; <tt>$xmlfilename</tt> can be either a filename or
an <small>URL.</small> Note that for parsing files, this
function is the fastest choice, about 6&minus;8 times faster
then <i>parse_fh()</i>.</p>

<p style="margin-left:11%;">parse_fh</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_fh( $io_fh );</pre>



<p style="margin-left:17%; margin-top: 1em"><i>parse_fh()</i>
parses a <small>IOREF</small> or a subclass of
IO::Handle.</p>

<p style="margin-left:17%; margin-top: 1em">Because the
data comes from an open handle, libxml2&rsquo;s parser does
not know about the base <small>URI</small> of the document.
To set the base <small>URI</small> one should use
<i>parse_fh()</i> as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $doc = $parser&minus;&gt;parse_fh( $io_fh, $baseuri );</pre>


<p style="margin-left:11%;">parse_string</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_string( $xmlstring);</pre>


<p style="margin-left:17%; margin-top: 1em">This function
is similar to <i>parse_fh()</i>, but it parses an
<small>XML</small> document that is available as a single
string in memory, or alternatively as a reference to a
scalar containing a string. Again, you can pass an optional
base <small>URI</small> to the function.</p>

<pre style="margin-left:17%; margin-top: 1em">  my $doc = $parser&minus;&gt;parse_string( $xmlstring, $baseuri );
  my $doc = $parser&minus;&gt;parse_string(\$xmlstring, $baseuri);</pre>


<p style="margin-left:11%;">parse_html_file</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_html_file( $htmlfile, \%opts );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>parse_file()</i> but parses <small>HTML</small> (strict)
documents; <tt>$htmlfile</tt> can be filename or
<small>URL.</small></p>

<p style="margin-left:17%; margin-top: 1em">An optional
second argument can be used to pass some options to the
<small>HTML</small> parser as a <small>HASH</small>
reference. See options labeled with <small>HTML</small> in
&quot;Parser Options&quot;.</p>

<p style="margin-left:11%;">parse_html_fh</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_html_fh( $io_fh, \%opts );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>parse_fh()</i> but parses <small>HTML</small> (strict)
streams.</p>

<p style="margin-left:17%; margin-top: 1em">An optional
second argument can be used to pass some options to the
<small>HTML</small> parser as a <small>HASH</small>
reference. See options labeled with <small>HTML</small> in
&quot;Parser Options&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note: encoding
option may not work correctly with this function in libxml2
&lt; 2.6.27 if the <small>HTML</small> file declares charset
using a <small>META</small> tag.</p>

<p style="margin-left:11%;">parse_html_string</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;parse_html_string( $htmlstring, \%opts );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>parse_string()</i> but parses <small>HTML</small>
(strict) strings.</p>

<p style="margin-left:17%; margin-top: 1em">An optional
second argument can be used to pass some options to the
<small>HTML</small> parser as a <small>HASH</small>
reference. See options labeled with <small>HTML</small> in
&quot;Parser Options&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Push
Parser</b> <br>
XML::LibXML provides a push parser interface. Rather than
pulling the data from a given source the push parser waits
for the data to be pushed into it.</p>

<p style="margin-left:11%; margin-top: 1em">This allows one
to parse large documents without waiting for the parser to
finish. The interface is especially useful if a program
needs to pre-process the incoming pieces of
<small>XML</small> (e.g. to detect document boundaries).</p>

<p style="margin-left:11%; margin-top: 1em">While
XML::LibXML parse_*() functions force the data to be a
well-formed <small>XML,</small> the push parser will take
any arbitrary string that contains some <small>XML</small>
data. The only requirement is that all the pushed strings
are together a well formed document. With the push parser
interface a program can interrupt the parsing process as
required, where the parse_*() functions give not enough
flexibility.</p>

<p style="margin-left:11%; margin-top: 1em">Different to
the pull parser implemented in <i>parse_fh()</i> or
<i>parse_file()</i>, the push parser is not able to find out
about the documents end itself. Thus the calling program
needs to indicate explicitly when the parsing is done.</p>

<p style="margin-left:11%; margin-top: 1em">In XML::LibXML
this is done by a single function: <br>
parse_chunk</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;parse_chunk($string, $terminate);</pre>



<p style="margin-left:17%; margin-top: 1em"><i>parse_chunk()</i>
tries to parse a given chunk of data, which isn&rsquo;t
necessarily well balanced data. The function takes two
parameters: The chunk of data as a string and optional a
termination flag. If the termination flag is set to a true
value (e.g. 1), the parsing will be stopped and the
resulting document will be returned as the following example
describes:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $parser = XML::LibXML&minus;&gt;new;
  for my $string ( &quot;&lt;&quot;, &quot;foo&quot;, ' bar=&quot;hello world&quot;', &quot;/&gt;&quot;) {
       $parser&minus;&gt;parse_chunk( $string );
  }
  my $doc = $parser&minus;&gt;parse_chunk(&quot;&quot;, 1); # terminate the parsing</pre>


<p style="margin-left:11%; margin-top: 1em">Internally
XML::LibXML provides three functions that control the push
parser process: <br>
init_push</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;init_push();</pre>


<p style="margin-left:17%; margin-top: 1em">Initializes the
push parser.</p>

<p style="margin-left:11%;">push</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;push(@data);</pre>


<p style="margin-left:17%; margin-top: 1em">This function
pushes the data stored inside the array to libxml2&rsquo;s
parser. Each entry in <tt>@data</tt> must be a normal
scalar! This method can be called repeatedly.</p>

<p style="margin-left:11%;">finish_push</p>

<pre style="margin-left:17%;">  $doc = $parser&minus;&gt;finish_push( $recover );</pre>


<p style="margin-left:17%; margin-top: 1em">This function
returns the result of the parsing process. If this function
is called without a parameter it will complain about non
well-formed documents. If <tt>$restore</tt> is 1, the push
parser can be used to restore broken or non well formed (
<small>XML</small> ) documents as the following example
shows:</p>

<pre style="margin-left:17%; margin-top: 1em">  eval {
      $parser&minus;&gt;push( &quot;&lt;foo&gt;&quot;, &quot;bar&quot; );
      $doc = $parser&minus;&gt;finish_push();    # will report broken XML
  };
  if ( $@ ) {
     # ...
  }</pre>


<p style="margin-left:17%; margin-top: 1em">This can be
annoying if the closing tag is missed by accident. The
following code will restore the document:</p>

<pre style="margin-left:17%; margin-top: 1em">  eval {
      $parser&minus;&gt;push( &quot;&lt;foo&gt;&quot;, &quot;bar&quot; );
      $doc = $parser&minus;&gt;finish_push(1);   # will return the data parsed
                                        # unless an error happened
  };
  print $doc&minus;&gt;toString(); # returns &quot;&lt;foo&gt;bar&lt;/foo&gt;&quot;</pre>


<p style="margin-left:17%; margin-top: 1em">Of course
<i>finish_push()</i> will return nothing if there was no
data pushed to the parser before.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pull Parser
(Reader)</b> <br>
XML::LibXML also provides a pull-parser interface similar to
the XmlReader interface in .NET. This interface is almost
streaming, and is usually faster and simpler to use than
<small>SAX.</small> See XML::LibXML::Reader.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Direct
<small>SAX</small> Parser</b> <br>
XML::LibXML provides a direct <small>SAX</small> parser in
the XML::LibXML::SAX module.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOM</small>
based <small>SAX</small> Parser</b> <br>
XML::LibXML also provides a <small>DOM</small> based
<small>SAX</small> parser. The <small>SAX</small> parser is
defined in the module XML::LibXML::SAX::Parser. As it is not
a stream based parser, it parses documents into a
<small>DOM</small> and traverses the <small>DOM</small> tree
instead.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>API</small> of this parser is exactly the same as any
other Perl <small>SAX2</small> parser. See XML::SAX::Intro
for details.</p>

<p style="margin-left:11%; margin-top: 1em">Aside from the
regular parsing methods, you can access the
<small>DOM</small> tree traverser directly, using the
<i>generate()</i> method:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $doc = build_yourself_a_document();
  my $saxparser = $XML::LibXML::SAX::Parser&minus;&gt;new( ... );
  $parser&minus;&gt;generate( $doc );</pre>


<p style="margin-left:11%; margin-top: 1em">This is useful
for serializing <small>DOM</small> trees, for example that
you might have done prior processing on, or that you have as
a result of <small>XSLT</small> processing.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>WARNING</small></i></p>

<p style="margin-left:11%; margin-top: 1em">This is
<small>NOT</small> a streaming <small>SAX</small> parser. As
I said above, this parser reads the entire document into a
<small>DOM</small> and serialises it. Some people
couldn&rsquo;t read that in the paragraph above so
I&rsquo;ve added this warning. If you want a streaming
<small>SAX</small> parser look at the XML::LibXML::SAX man
page</p>

<h2>SERIALIZATION
<a name="SERIALIZATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::LibXML
provides some functions to serialize nodes and documents.
The serialization functions are described on the
XML::LibXML::Node manpage or the XML::LibXML::Document
manpage. XML::LibXML checks three global flags that alter
the serialization process:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>skipXMLDeclaration</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>skipDTD</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>setTagCompression</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">of that three
functions only setTagCompression is available for all
serialization functions.</p>

<p style="margin-left:11%; margin-top: 1em">Because
XML::LibXML does these flags not itself, one has to define
them locally as the following example shows:</p>

<pre style="margin-left:11%; margin-top: 1em">  local $XML::LibXML::skipXMLDeclaration = 1;
  local $XML::LibXML::skipDTD = 1;
  local $XML::LibXML::setTagCompression = 1;</pre>


<p style="margin-left:11%; margin-top: 1em">If
skipXMLDeclaration is defined and not &rsquo;0&rsquo;, the
<small>XML</small> declaration is omitted during
serialization.</p>

<p style="margin-left:11%; margin-top: 1em">If skipDTD is
defined and not &rsquo;0&rsquo;, an existing
<small>DTD</small> would not be serialized with the
document.</p>

<p style="margin-left:11%; margin-top: 1em">If
setTagCompression is defined and not &rsquo;0&rsquo; empty
tags are displayed as open and closing tags rather than the
shortcut. For example the empty tag <i>foo</i> will be
rendered as <i>&lt;foo&gt;&lt;/foo&gt;</i> rather than
<i>&lt;foo/&gt;</i>.</p>

<h2>PARSER OPTIONS
<a name="PARSER OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Handling of
libxml2 parser options has been unified and improved in
XML::LibXML 1.70. You can now set default options for a
particular parser instance by passing them to the
constructor as
<tt>&quot;XML::LibXML&minus;&gt;new({name=&gt;value,
...})&quot;</tt> or
<tt>&quot;XML::LibXML&minus;&gt;new(name=&gt;value,...)&quot;</tt>.
The options can be queried and changed using the following
methods (pre&minus;1.70 interfaces such as
<tt>&quot;$parser&minus;&gt;load_ext_dtd(0)&quot;</tt> also
exist, see below): <br>
option_exists</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;option_exists($name);</pre>


<p style="margin-left:17%; margin-top: 1em">Returns 1 if
the current XML::LibXML version supports the option
<tt>$name</tt>, otherwise returns 0 (note that this does not
necessarily mean that the option is supported by the
underlying libxml2 library).</p>

<p style="margin-left:11%;">get_option</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;get_option($name);</pre>


<p style="margin-left:17%; margin-top: 1em">Returns the
current value of the parser option <tt>$name</tt>.</p>

<p style="margin-left:11%;">set_option</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;set_option($name,$value);</pre>


<p style="margin-left:17%; margin-top: 1em">Sets option
<tt>$name</tt> to value <tt>$value</tt>.</p>

<p style="margin-left:11%;">set_options</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;set_options({$name=&gt;$value,...});</pre>


<p style="margin-left:17%; margin-top: 1em">Sets multiple
parsing options at once.</p>


<p style="margin-left:11%; margin-top: 1em"><small>IMPORTANT
NOTE:</small> This documentation reflects the parser flags
available in libxml2 2.7.3. Some options have no effect if
an older version of libxml2 is used.</p>

<p style="margin-left:11%; margin-top: 1em">Each of the
flags listed below is labeled <br>
/parser/</p>

<p style="margin-left:17%;">if it can be used with a
<tt>&quot;XML::LibXML&quot;</tt> parser object (i.e. passed
to <tt>&quot;XML::LibXML&minus;&gt;new&quot;</tt>,
<tt>&quot;XML::LibXML&minus;&gt;set_option&quot;</tt>,
etc.)</p>

<p style="margin-left:11%;">/html/</p>

<p style="margin-left:17%;">if it can be used passed to the
<tt>&quot;parse_html_*&quot;</tt> methods</p>

<p style="margin-left:11%;">/reader/</p>

<p style="margin-left:17%;">if it can be used with the
<tt>&quot;XML::LibXML::Reader&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Unless
specified otherwise, the default for boolean valued options
is 0 (false).</p>

<p style="margin-left:11%; margin-top: 1em">The available
options are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>URI</small></p></td>
<td width="2%"></td>
<td width="34%">


<p>/parser, html, reader/</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In case of
parsing strings or file handles, XML::LibXML doesn&rsquo;t
know about the base uri of the document. To make relative
references such as XIncludes work, one has to set a base
<small>URI,</small> that is then used for the parsed
document.</p>

<p style="margin-left:11%;">line_numbers</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">If this option
is activated, libxml2 will store the line number of each
element node in the parsed document. The line number can be
obtained using the <tt>&quot;line_number()&quot;</tt> method
of the <tt>&quot;XML::LibXML::Node&quot;</tt> class (for
non-element nodes this may report the line number of the
containing element). The line numbers are also used for
reporting positions of validation errors.</p>


<p style="margin-left:17%; margin-top: 1em"><small>IMPORTANT:</small>
Due to limitations in the libxml2 library line numbers
greater than 65535 will be returned as 65535. Unfortunately,
this is a long and sad story, please see
&lt;http://bugzilla.gnome.org/show_bug.cgi?id=325533&gt; for
more details.</p>

<p style="margin-left:11%;">encoding</p>

<p style="margin-left:17%;">/html/</p>

<p style="margin-left:17%; margin-top: 1em">character
encoding of the input</p>

<p style="margin-left:11%;">recover</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">recover from
errors; possible values are 0, 1, and 2</p>

<p style="margin-left:17%; margin-top: 1em">A true value
turns on recovery mode which allows one to parse broken
<small>XML</small> or <small>HTML</small> data. The recovery
mode allows the parser to return the successfully parsed
portion of the input document. This is useful for almost
well-formed documents, where for example a closing tag is
missing somewhere. Still, XML::LibXML will only parse until
the first fatal (non-recoverable) error occurs, reporting
recoverable parsing errors as warnings. To suppress even
these warnings, use recover=&gt;2.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
validation is switched off automatically in recovery
mode.</p>

<p style="margin-left:11%;">expand_entities</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">substitute
entities; possible values are 0 and 1; default is 1</p>

<p style="margin-left:17%; margin-top: 1em">Note that
although this flag disables entity substitution, it does not
prevent the parser from loading external entities; when
substitution of an external entity is disabled, the entity
will be represented in the document tree by an
<small>XML_ENTITY_REF_NODE</small> node whose subtree will
be the content obtained by parsing the external resource;
Although this nesting is visible from the <small>DOM</small>
it is transparent to XPath data model, so it is possible to
match nodes in an unexpanded entity by the same XPath
expression as if the entity were expanded. See also
ext_ent_handler.</p>

<p style="margin-left:11%;">ext_ent_handler</p>

<p style="margin-left:17%;">/parser/</p>

<p style="margin-left:17%; margin-top: 1em">Provide a
custom external entity handler to be used when
expand_entities is set to 1. Possible value is a subroutine
reference.</p>

<p style="margin-left:17%; margin-top: 1em">This feature
does not work properly in libxml2 &lt; 2.6.27!</p>

<p style="margin-left:17%; margin-top: 1em">The subroutine
provided is called whenever the parser needs to retrieve the
content of an external entity. It is called with two
arguments: the system <small>ID</small> ( <small>URI</small>
) and the public <small>ID.</small> The value returned by
the subroutine is parsed as the content of the entity.</p>

<p style="margin-left:17%; margin-top: 1em">This method can
be used to completely disable entity loading, e.g. to
prevent exploits of the type described at
(&lt;http://searchsecuritychannel.techtarget.com/generic/0,295582,sid97_gci1304703,00.html&gt;),
where a service is tricked to expose its private data by
letting it parse a remote file ( <small>RSS</small> feed)
that contains an entity reference to a local file (e.g.
<tt>&quot;/etc/fstab&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">A more granular
solution to this problem, however, is provided by custom
<small>URL</small> resolvers, as in</p>

<pre style="margin-left:17%; margin-top: 1em">  my $c = XML::LibXML::InputCallback&minus;&gt;new();
  sub match {   # accept file:/ URIs except for XML catalogs in /etc/xml/
    my ($uri) = @_;
    return ($uri=~m{^file:/}
            and $uri !~ m{^file:///etc/xml/})
           ? 1 : 0;
  }
  $c&minus;&gt;register_callbacks([ \&amp;match, sub{}, sub{}, sub{} ]);
  $parser&minus;&gt;input_callbacks($c);</pre>


<p style="margin-left:11%;">load_ext_dtd</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">load the
external <small>DTD</small> subset while parsing; possible
values are 0 and 1. Unless specified, XML::LibXML sets this
option to 1.</p>

<p style="margin-left:17%; margin-top: 1em">This flag is
also required for <small>DTD</small> Validation, to provide
complete attribute, and to expand entities, regardless if
the document has an internal subset. Thus switching off
external <small>DTD</small> loading, will disable entity
expansion, validation, and complete attributes on internal
subsets as well.</p>

<p style="margin-left:11%;">complete_attributes</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">create default
<small>DTD</small> attributes; possible values are 0 and
1</p>

<p style="margin-left:11%;">validation</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">validate with
the <small>DTD</small> ; possible values are 0 and 1</p>

<p style="margin-left:11%;">suppress_errors</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">suppress error
reports; possible values are 0 and 1</p>

<p style="margin-left:11%;">suppress_warnings</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">suppress
warning reports; possible values are 0 and 1</p>

<p style="margin-left:11%;">pedantic_parser</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">pedantic error
reporting; possible values are 0 and 1</p>

<p style="margin-left:11%;">no_blanks</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">remove blank
nodes; possible values are 0 and 1</p>

<p style="margin-left:11%;">no_defdtd</p>

<p style="margin-left:17%;">/html/</p>

<p style="margin-left:17%; margin-top: 1em">do not add a
default <small>DOCTYPE</small> ; possible values are 0 and
1</p>

<p style="margin-left:17%; margin-top: 1em">the default is
(0) to add a <small>DTD</small> when the input html lacks
one</p>

<p style="margin-left:11%;">expand_xinclude or xinclude</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">Implement
XInclude substitution; possible values are 0 and 1</p>

<p style="margin-left:17%; margin-top: 1em">Expands
XInclude tags immediately while parsing the document. Note
that the parser will use the <small>URI</small> resolvers
installed via
<tt>&quot;XML::LibXML::InputCallback&quot;</tt> to parse the
included document (if any).</p>

<p style="margin-left:11%;">no_xinclude_nodes</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">do not generate
<small>XINCLUDE START/END</small> nodes; possible values are
0 and 1</p>

<p style="margin-left:11%;">no_network</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">Forbid network
access; possible values are 0 and 1</p>

<p style="margin-left:17%; margin-top: 1em">If set to true,
all attempts to fetch non-local resources (such as
<small>DTD</small> or external entities) will fail (unless
custom callbacks are defined).</p>

<p style="margin-left:17%; margin-top: 1em">It may be
necessary to use the flag <tt>&quot;recover&quot;</tt> for
processing documents requiring such resources while
networking is off.</p>

<p style="margin-left:11%;">clean_namespaces</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">remove
redundant namespaces declarations during parsing; possible
values are 0 and 1.</p>

<p style="margin-left:11%;">no_cdata</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">merge
<small>CDATA</small> as text nodes; possible values are 0
and 1</p>

<p style="margin-left:11%;">no_basefix</p>

<p style="margin-left:17%;">/parser, reader/</p>

<p style="margin-left:17%; margin-top: 1em">not fixup
<small>XINCLUDE</small> xml#base <small>URIS</small> ;
possible values are 0 and 1</p>

<p style="margin-left:11%;">huge</p>

<p style="margin-left:17%;">/parser, html, reader/</p>

<p style="margin-left:17%; margin-top: 1em">relax any
hardcoded limit from the parser; possible values are 0 and
1. Unless specified, XML::LibXML sets this option to 0.</p>

<p style="margin-left:17%; margin-top: 1em">Note: the
default value for this option was changed to protect against
denial of service through entity expansion attacks. Before
enabling the option ensure you have taken alternative
measures to protect your application against this type of
attack.</p>

<p style="margin-left:11%;">gdome</p>

<p style="margin-left:17%;">/parser/</p>

<p style="margin-left:17%; margin-top: 1em"><small>THIS
OPTION IS EXPERIMENTAL</small> !</p>

<p style="margin-left:17%; margin-top: 1em">Although quite
powerful, XML::LibXML&rsquo;s <small>DOM</small>
implementation is incomplete with respect to the
<small>DOM</small> level 2 or level 3 specifications.
<small>XML::GDOME</small> is based on libxml2 as well and
and provides a rather complete <small>DOM</small>
implementation by wrapping libgdome. This flag allows you to
make use of XML::LibXML&rsquo;s full parser options and
<small>XML::GDOME</small> &rsquo;s <small>DOM</small>
implementation at the same time.</p>

<p style="margin-left:17%; margin-top: 1em">To make use of
this function, one has to install libgdome and configure
XML::LibXML to use this library. For this you need to
rebuild XML::LibXML!</p>

<p style="margin-left:17%; margin-top: 1em">Note: this
feature was not seriously tested in recent XML::LibXML
releases.</p>

<p style="margin-left:11%; margin-top: 1em">For
compatibility with XML::LibXML versions prior to 1.70, the
following methods are also supported for querying and
setting the corresponding parser options (if called without
arguments, the methods return the current value of the
corresponding parser options; with an argument sets the
option to a given value):</p>

<pre style="margin-left:11%; margin-top: 1em">  $parser&minus;&gt;validation();
  $parser&minus;&gt;recover();
  $parser&minus;&gt;pedantic_parser();
  $parser&minus;&gt;line_numbers();
  $parser&minus;&gt;load_ext_dtd();
  $parser&minus;&gt;complete_attributes();
  $parser&minus;&gt;expand_xinclude();
  $parser&minus;&gt;gdome_dom();
  $parser&minus;&gt;clean_namespaces();
  $parser&minus;&gt;no_network();</pre>


<p style="margin-left:11%; margin-top: 1em">The following
obsolete methods trigger parser options in some special way:
<br>
recover_silently</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;recover_silently(1);</pre>


<p style="margin-left:17%; margin-top: 1em">If called
without an argument, returns true if the current value of
the <tt>&quot;recover&quot;</tt> parser option is 2 and
returns false otherwise. With a true argument sets the
<tt>&quot;recover&quot;</tt> parser option to 2; with a
false argument sets the <tt>&quot;recover&quot;</tt> parser
option to 0.</p>

<p style="margin-left:11%;">expand_entities</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;expand_entities(0);</pre>


<p style="margin-left:17%; margin-top: 1em">Get/set the
<tt>&quot;expand_entities&quot;</tt> option. If called with
a true argument, also turns the
<tt>&quot;load_ext_dtd&quot;</tt> option to 1.</p>

<p style="margin-left:11%;">keep_blanks</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;keep_blanks(0);</pre>


<p style="margin-left:17%; margin-top: 1em">This is
actually the opposite of the <tt>&quot;no_blanks&quot;</tt>
parser option. If used without an argument retrieves negated
value of <tt>&quot;no_blanks&quot;</tt>. If used with an
argument sets <tt>&quot;no_blanks&quot;</tt> to the opposite
value.</p>

<p style="margin-left:11%;">base_uri</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;base_uri( $your_base_uri );</pre>


<p style="margin-left:17%; margin-top: 1em">Get/set the
<tt>&quot;URI&quot;</tt> option.</p>

<h2>XML CATALOGS
<a name="XML CATALOGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><tt>&quot;libxml2&quot;</tt>
supports <small>XML</small> catalogs. Catalogs are used to
map remote resources to their local copies. Using catalogs
can speed up parsing processes if many external resources
from remote addresses are loaded into the parsed documents
(such as DTDs or XIncludes).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
libxml2 has a global pool of loaded catalogs, so if you
apply the method <tt>&quot;load_catalog&quot;</tt> to one
parser instance, all parser instances will start using the
catalog (in addition to other previously loaded
catalogs).</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
catalogs are not used when a custom external entity handler
is specified. At the current state it is not possible to
make use of both types of resolving systems at the same
time. <br>
load_catalog</p>

<pre style="margin-left:17%;">  $parser&minus;&gt;load_catalog( $catalog_file );</pre>


<p style="margin-left:17%; margin-top: 1em">Loads the
<small>XML</small> catalog file <tt>$catalog_file</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">  # Global external entity loader (similar to ext_ent_handler option
  # but this works really globally, also in XML::LibXSLT include etc..)
  XML::LibXML::externalEntityLoader(\&amp;my_loader);</pre>


<h2>ERROR REPORTING
<a name="ERROR REPORTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::LibXML
throws exceptions during parsing, validation or XPath
processing (and some other occasions). These errors can be
caught by using <i>eval</i> blocks. The error is stored in
<i>$@</i>. There are two implementations: the old one throws
$@ which is just a message string, in the new one $@ is an
object from the class XML::LibXML::Error; this class
overrides the operator &quot;&quot; so that when printed,
the object flattens to the usual error message.</p>

<p style="margin-left:11%; margin-top: 1em">XML::LibXML
throws errors as they occur. This is a very common
misunderstanding in the use of XML::LibXML. If the eval is
omitted, XML::LibXML will always halt your script by
&quot;croaking&quot; (see Carp man page for details).</p>

<p style="margin-left:11%; margin-top: 1em">Also note that
an increasing number of functions throw errors if bad data
is passed as arguments. If you cannot assure valid data
passed to XML::LibXML you should eval these functions.</p>

<p style="margin-left:11%; margin-top: 1em">Note: since
version 1.59, <i>get_last_error()</i> is no longer available
in XML::LibXML for thread-safety reasons.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Matt Sergeant,
Christian Glahn, Petr Pajas</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">2.0018</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">2001&minus;2007,
AxKit.com Ltd.</p>


<p style="margin-left:11%; margin-top: 1em">2002&minus;2006,
Christian Glahn.</p>


<p style="margin-left:11%; margin-top: 1em">2006&minus;2009,
Petr Pajas.</p>
<hr>
</body>
</html>
