<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:49:03 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GLMAP2</title>

</head>
<body>

<h1 align="center">GLMAP2</h1>

<a href="#NAME">NAME</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#PARAMETERS">PARAMETERS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#ASSOCIATED GETS">ASSOCIATED GETS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">glMap2 &minus;
define a two&minus;dimensional evaluator</p>

<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>void
glMap2f(GLenum&nbsp;</b><i>target</i><b>,
GLfloat&nbsp;</b><i>u1</i><b>,
GLfloat&nbsp;</b><i>u2</i><b>,
GLint&nbsp;</b><i>ustride</i><b>,
GLint&nbsp;</b><i>uorder</i><b>,
GLfloat&nbsp;</b><i>v1</i><b>,
GLfloat&nbsp;</b><i>v2</i><b>,
GLint&nbsp;</b><i>vstride</i><b>,
GLint&nbsp;</b><i>vorder</i><b>,
const&nbsp;GLfloat&nbsp;*&nbsp;</b><i>points</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>void
glMap2d(GLenum&nbsp;</b><i>target</i><b>,
GLdouble&nbsp;</b><i>u1</i><b>,
GLdouble&nbsp;</b><i>u2</i><b>,
GLint&nbsp;</b><i>ustride</i><b>,
GLint&nbsp;</b><i>uorder</i><b>,
GLdouble&nbsp;</b><i>v1</i><b>,
GLdouble&nbsp;</b><i>v2</i><b>,
GLint&nbsp;</b><i>vstride</i><b>,
GLint&nbsp;</b><i>vorder</i><b>,
const&nbsp;GLdouble&nbsp;*&nbsp;</b><i>points</i><b>);</b></p> </td></tr>
</table>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><i>target</i></b></p>

<p style="margin-left:17%;">Specifies the kind of values
that are generated by the evaluator. Symbolic constants
<b>GL_MAP2_VERTEX_3</b>, <b>GL_MAP2_VERTEX_4</b>,
<b>GL_MAP2_INDEX</b>, <b>GL_MAP2_COLOR_4</b>,
<b>GL_MAP2_NORMAL</b>, <b>GL_MAP2_TEXTURE_COORD_1</b>,
<b>GL_MAP2_TEXTURE_COORD_2</b>,
<b>GL_MAP2_TEXTURE_COORD_3</b>, and
<b>GL_MAP2_TEXTURE_COORD_4</b> are accepted.</p>

<p style="margin-left:11%; margin-top: 1em"><i>u1</i>,
<i>u2</i></p>

<p style="margin-left:17%;">Specify a linear mapping of u,
as presented to <b>glEvalCoord2</b>(), to u^, one of the two
variables that are evaluated by the equations specified by
this command. Initially, <i>u1</i> is 0 and <i>u2</i> is
1.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ustride</i></p>

<p style="margin-left:17%;">Specifies the number of floats
or doubles between the beginning of control point R ij and
the beginning of control point R i + 1 &#8290; j, where i
and j are the u and v control point indices, respectively.
This allows control points to be embedded in arbitrary data
structures. The only constraint is that the values for a
particular control point must occupy contiguous memory
locations. The initial value of <i>ustride</i> is 0.</p>


<p style="margin-left:11%; margin-top: 1em"><i>uorder</i></p>

<p style="margin-left:17%;">Specifies the dimension of the
control point array in the u axis. Must be positive. The
initial value is 1.</p>

<p style="margin-left:11%; margin-top: 1em"><i>v1</i>,
<i>v2</i></p>

<p style="margin-left:17%;">Specify a linear mapping of v,
as presented to <b>glEvalCoord2</b>(), to v^, one of the two
variables that are evaluated by the equations specified by
this command. Initially, <i>v1</i> is 0 and <i>v2</i> is
1.</p>


<p style="margin-left:11%; margin-top: 1em"><i>vstride</i></p>

<p style="margin-left:17%;">Specifies the number of floats
or doubles between the beginning of control point R ij and
the beginning of control point R i &#8289; j + 1, where i
and j are the u and v control point indices, respectively.
This allows control points to be embedded in arbitrary data
structures. The only constraint is that the values for a
particular control point must occupy contiguous memory
locations. The initial value of <i>vstride</i> is 0.</p>


<p style="margin-left:11%; margin-top: 1em"><i>vorder</i></p>

<p style="margin-left:17%;">Specifies the dimension of the
control point array in the v axis. Must be positive. The
initial value is 1.</p>


<p style="margin-left:11%; margin-top: 1em"><i>points</i></p>

<p style="margin-left:17%;">Specifies a pointer to the
array of control points.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Evaluators
provide a way to use polynomial or rational polynomial
mapping to produce vertices, normals, texture coordinates,
and colors. The values produced by an evaluator are sent on
to further stages of GL processing just as if they had been
presented using <b>glVertex</b>(), <b>glNormal</b>(),
<b>glTexCoord</b>(), and <b>glColor</b>() commands, except
that the generated values do not update the current normal,
texture coordinates, or color.</p>

<p style="margin-left:11%; margin-top: 1em">All polynomial
or rational polynomial splines of any degree (up to the
maximum degree supported by the GL implementation) can be
described using evaluators. These include almost all
surfaces used in computer graphics, including B&minus;spline
surfaces, NURBS surfaces, Bezier surfaces, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">Evaluators
define surfaces based on bivariate Bernstein polynomials.
Define p &#8289; u^ v^ as</p>

<p style="margin-left:11%; margin-top: 1em">p &#8289; u^ v^
= &Sigma; i = 0 n &Sigma; j = 0 m B i n &#8289; u^ &#8290; B
j m &#8289; v^ &#8290; R ij</p>

<p style="margin-left:11%; margin-top: 1em">where R ij is a
control point, B i n &#8289; u^ is the ith Bernstein
polynomial of degree n (<i>uorder</i> = n + 1)</p>

<p style="margin-left:11%; margin-top: 1em">B i n &#8289;
u^ = n i &#8290; u^ i &#8290; 1 &minus; u^ n &minus; i</p>

<p style="margin-left:11%; margin-top: 1em">and B j m
&#8289; v^ is the jth Bernstein polynomial of degree m
(<i>vorder</i> = m + 1)</p>

<p style="margin-left:11%; margin-top: 1em">B j m &#8289;
v^ = m j &#8290; v^ j &#8290; 1 &minus; v^ m &minus; j</p>

<p style="margin-left:11%; margin-top: 1em">Recall that 0 0
== 1 and n 0 == 1</p>

<p style="margin-left:11%; margin-top: 1em"><b>glMap2</b>
is used to define the basis and to specify what kind of
values are produced. Once defined, a map can be enabled and
disabled by calling <b>glEnable</b>() and <b>glDisable</b>()
with the map name, one of the nine predefined values for
<i>target</i>, described below. When <b>glEvalCoord2</b>()
presents values u and v, the bivariate Bernstein polynomials
are evaluated using u^ and v^, where</p>

<p style="margin-left:11%; margin-top: 1em">u^ = u &minus;
u1 u2 &minus; u1</p>

<p style="margin-left:11%; margin-top: 1em">v^ = v &minus;
v1 v2 &minus; v1</p>

<p style="margin-left:11%; margin-top: 1em"><i>target</i>
is a symbolic constant that indicates what kind of control
points are provided in <i>points</i>, and what output is
generated when the map is evaluated. It can assume one of
nine predefined values:</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_VERTEX_3</b></p>

<p style="margin-left:17%;">Each control point is three
floating&minus;point values representing x, y, and z.
Internal <b>glVertex3</b>() commands are generated when the
map is evaluated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_VERTEX_4</b></p>

<p style="margin-left:17%;">Each control point is four
floating&minus;point values representing x, y, z, and w.
Internal <b>glVertex4</b>() commands are generated when the
map is evaluated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_INDEX</b></p>

<p style="margin-left:17%;">Each control point is a single
floating&minus;point value representing a color index.
Internal <b>glIndex</b>() commands are generated when the
map is evaluated but the current index is not updated with
the value of these <b>glIndex</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_COLOR_4</b></p>

<p style="margin-left:17%;">Each control point is four
floating&minus;point values representing red, green, blue,
and alpha. Internal <b>glColor4</b>() commands are generated
when the map is evaluated but the current color is not
updated with the value of these <b>glColor4</b>()
commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_NORMAL</b></p>

<p style="margin-left:17%;">Each control point is three
floating&minus;point values representing the x, y, and z
components of a normal vector. Internal <b>glNormal</b>()
commands are generated when the map is evaluated but the
current normal is not updated with the value of these
<b>glNormal</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_TEXTURE_COORD_1</b></p>

<p style="margin-left:17%;">Each control point is a single
floating&minus;point value representing the s texture
coordinate. Internal <b>glTexCoord1</b>() commands are
generated when the map is evaluated but the current texture
coordinates are not updated with the value of these
<b>glTexCoord</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_TEXTURE_COORD_2</b></p>

<p style="margin-left:17%;">Each control point is two
floating&minus;point values representing the s and t texture
coordinates. Internal <b>glTexCoord2</b>() commands are
generated when the map is evaluated but the current texture
coordinates are not updated with the value of these
<b>glTexCoord</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_TEXTURE_COORD_3</b></p>

<p style="margin-left:17%;">Each control point is three
floating&minus;point values representing the s, t, and r
texture coordinates. Internal <b>glTexCoord3</b>() commands
are generated when the map is evaluated but the current
texture coordinates are not updated with the value of these
<b>glTexCoord</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAP2_TEXTURE_COORD_4</b></p>

<p style="margin-left:17%;">Each control point is four
floating&minus;point values representing the s, t, r, and q
texture coordinates. Internal <b>glTexCoord4</b>() commands
are generated when the map is evaluated but the current
texture coordinates are not updated with the value of these
<b>glTexCoord</b>() commands.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ustride</i>,
<i>uorder</i>, <i>vstride</i>, <i>vorder</i>, and
<i>points</i> define the array addressing for accessing the
control points. <i>points</i> is the location of the first
control point, which occupies one, two, three, or four
contiguous memory locations, depending on which map is being
defined. There are uorder &times; vorder control points in
the array. <i>ustride</i> specifies how many float or double
locations are skipped to advance the internal memory pointer
from control point R i &#8290; j to control point R i + 1
&#8290; j. <i>vstride</i> specifies how many float or double
locations are skipped to advance the internal memory pointer
from control point R i &#8290; j to control point R i
&#8289; j + 1.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As is the case
with all GL commands that accept pointers to data, it is as
if the contents of <i>points</i> were copied by
<b>glMap2</b> before <b>glMap2</b> returns. Changes to the
contents of <i>points</i> have no effect after <b>glMap2</b>
is called.</p>

<p style="margin-left:11%; margin-top: 1em">Initially,
<b>GL_AUTO_NORMAL</b> is enabled. If <b>GL_AUTO_NORMAL</b>
is enabled, normal vectors are generated when either
<b>GL_MAP2_VERTEX_3</b> or <b>GL_MAP2_VERTEX_4</b> is used
to generate vertices.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>target</i> is not an accepted value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if <i>u1</i> is equal to <i>u2</i>, or if
<i>v1</i> is equal to <i>v2</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if either <i>ustride</i> or <i>vstride</i> is
less than the number of values in a control point.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if either <i>uorder</i> or <i>vorder</i> is
less than 1 or greater than the return value of
<b>GL_MAX_EVAL_ORDER</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>glMap2</b> is executed between the
execution of <b>glBegin</b>() and the corresponding
execution of <b>glEnd</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>glMap2</b> is called and the value of
<b>GL_ACTIVE_TEXTURE</b> is not <b>GL_TEXTURE0</b>.</p>

<h2>ASSOCIATED GETS
<a name="ASSOCIATED GETS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>glGetMap</b>()</p>

<p style="margin-left:11%; margin-top: 1em"><b>glGet</b>()
with argument <b>GL_MAX_EVAL_ORDER</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_VERTEX_3</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_VERTEX_4</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_INDEX</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_COLOR_4</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_NORMAL</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_TEXTURE_COORD_1</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_TEXTURE_COORD_2</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_TEXTURE_COORD_3</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>glIsEnabled</b>()
with argument <b>GL_MAP2_TEXTURE_COORD_4</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>glBegin</b>(),
<b>glColor</b>(), <b>glEnable</b>(), <b>glEvalCoord</b>(),
<b>glEvalMesh</b>(), <b>glEvalPoint</b>(), <b>glMap1</b>(),
<b>glMapGrid</b>(), <b>glNormal</b>(), <b>glTexCoord</b>(),
<b>glVertex</b>()</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
&copy; 1991&minus;2006 Silicon Graphics, Inc. This document
is licensed under the SGI Free Software B License. For
details, see
<b><font color="#0000FF">http://oss.sgi.com/projects/FreeB/</font></b><font color="#000000">.</font></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>opengl.org</b></font></p>
<hr>
</body>
</html>
