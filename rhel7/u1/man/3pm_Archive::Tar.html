<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:22:14 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Archive::Tar</title>

</head>
<body>

<h1 align="center">Archive::Tar</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Object Methods">Object Methods</a><br>
<a href="#Class Methods">Class Methods</a><br>
<a href="#GLOBAL VARIABLES">GLOBAL VARIABLES</a><br>
<a href="#FAQ">FAQ</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#TODO">TODO</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Archive::Tar
&minus; module for manipulations of tar archives</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Archive::Tar;
    my $tar = Archive::Tar&minus;&gt;new;
    $tar&minus;&gt;read('origin.tgz');
    $tar&minus;&gt;extract();
    $tar&minus;&gt;add_files('file/foo.pl', 'docs/README');
    $tar&minus;&gt;add_data('file/baz.txt', 'This is the contents now');
    $tar&minus;&gt;rename('oldname', 'new/file/name');
    $tar&minus;&gt;chown('/', 'root');
    $tar&minus;&gt;chown('/', 'root:root');
    $tar&minus;&gt;chmod('/tmp', '1777');
    $tar&minus;&gt;write('files.tar');                   # plain tar
    $tar&minus;&gt;write('files.tgz', COMPRESS_GZIP);    # gzip compressed
    $tar&minus;&gt;write('files.tbz', COMPRESS_BZIP);    # bzip2 compressed</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Archive::Tar
provides an object oriented mechanism for handling tar
files. It provides class methods for quick and easy files
handling while also allowing for the creation of tar file
objects for custom manipulation. If you have the IO::Zlib
module installed, Archive::Tar will also support compressed
or gzipped tar files.</p>

<p style="margin-left:11%; margin-top: 1em">An object of
class Archive::Tar represents a .tar(.gz) archive full of
files and things.</p>

<h2>Object Methods
<a name="Object Methods"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;new(
[$file, $compressed] )</b> <br>
Returns a new Tar object. If given any arguments,
<tt>&quot;new()&quot;</tt> calls the
<tt>&quot;read()&quot;</tt> method automatically, passing on
the arguments provided to the <tt>&quot;read()&quot;</tt>
method.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;new()&quot;</tt> is invoked with arguments and the
<tt>&quot;read()&quot;</tt> method fails for any reason,
<tt>&quot;new()&quot;</tt> returns undef.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;read
( $filename|$handle, [$compressed, {opt =&gt;
&rsquo;val&rsquo;}] )</b> <br>
Read the given tar file into memory. The first argument can
either be the name of a file or a reference to an already
open filehandle (or an IO::Zlib object if it&rsquo;s
compressed)</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;read&quot;</tt> will <i>replace</i> any previous
content in <tt>$tar</tt>!</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument may be considered optional, but remains for
backwards compatibility. Archive::Tar now looks at the file
magic to determine what class should be used to open the
file and will transparently Do The Right Thing.</p>

<p style="margin-left:11%; margin-top: 1em">Archive::Tar
will warn if you try to pass a bzip2 compressed file and the
IO::Zlib / IO::Uncompress::Bunzip2 modules are not available
and simply return.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
can currently <b>not</b> pass a <tt>&quot;gzip&quot;</tt>
compressed filehandle, which is not opened with
<tt>&quot;IO::Zlib&quot;</tt>, a <tt>&quot;bzip2&quot;</tt>
compressed filehandle, which is not opened with
<tt>&quot;IO::Uncompress::Bunzip2&quot;</tt>, nor a string
containing the full archive information (either compressed
or uncompressed). These are worth while features, but not
currently implemented. See the <tt>&quot;TODO&quot;</tt>
section.</p>

<p style="margin-left:11%; margin-top: 1em">The third
argument can be a hash reference with options. Note that all
options are case-sensitive. <br>
limit</p>

<p style="margin-left:17%;">Do not read more than
<tt>&quot;limit&quot;</tt> files. This is useful if you have
very big archives, and are only interested in the first few
files.</p>

<p style="margin-left:11%;">filter</p>

<p style="margin-left:17%;">Can be set to a regular
expression. Only files with names that match the expression
will be read.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>md5</p></td>
<td width="2%"></td>
<td width="83%">


<p>Set to 1 and the md5sum of files will be returned
(instead of file data)</p></td></tr>
</table>

<p style="margin-left:17%;">my <tt>$iter</tt> =
Archive::Tar&minus;&gt;iter( <tt>$file</tt>, 1, {md5 =&gt;
1} ); <br>
while( my <tt>$f</tt> = <tt>$iter</tt>&minus;&gt;() ) { <br>
print <tt>$f</tt>&minus;&gt;data . &quot;\t&quot; .
<tt>$f</tt>&minus;&gt;full_path . $/; <br>
}</p>

<p style="margin-left:11%;">extract</p>

<p style="margin-left:17%;">If set to true, immediately
extract entries when reading them. This gives you the same
memory break as the <tt>&quot;extract_archive&quot;</tt>
function. Note however that entries will not be read into
memory, but written straight to disk. This means no
<tt>&quot;Archive::Tar::File&quot;</tt> objects are created
for you to inspect.</p>

<p style="margin-left:11%; margin-top: 1em">All files are
stored internally as <tt>&quot;Archive::Tar::File&quot;</tt>
objects. Please consult the Archive::Tar::File documentation
for details.</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
number of files read in scalar context, and a list of
<tt>&quot;Archive::Tar::File&quot;</tt> objects in list
context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;contains_file(
$filename )</b> <br>
Check if the archive contains a certain file. It will return
true if the file is in the archive, false otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Note however,
that this function does an exact match using
<tt>&quot;eq&quot;</tt> on the full path. So it cannot
compensate for case-insensitive file&minus; systems or
compare 2 paths to see if they would point to the same
underlying file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;extract(
[@filenames] )</b> <br>
Write files whose names are equivalent to any of the names
in <tt>@filenames</tt> to disk, creating subdirectories as
necessary. This might not work too well under
<small>VMS.</small> Under MacPerl, the file&rsquo;s
modification time will be converted to the MacOS zero of
time, and appropriate conversions will be done to the path.
However, the length of each element of the path is not
inspected to see whether it&rsquo;s longer than MacOS
currently allows (32 characters).</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;extract&quot;</tt> is called without a list of
file names, the entire contents of the archive are
extracted.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a list
of filenames extracted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;extract_file(
$file, [$extract_path] )</b> <br>
Write an entry, whose name is equivalent to the file name
provided to disk. Optionally takes a second parameter, which
is the full native path (including filename) the entry will
be written to.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    $tar&minus;&gt;extract_file( 'name/in/archive', 'name/i/want/to/give/it' );
    $tar&minus;&gt;extract_file( $at_file_object,   'name/i/want/to/give/it' );</pre>


<p style="margin-left:11%; margin-top: 1em">Returns true on
success, false on failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;list_files(
[\@properties] )</b> <br>
Returns a list of the names of all the files in the
archive.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;list_files()&quot;</tt> is passed an array
reference as its first argument it returns a list of hash
references containing the requested properties of each file.
The following list of properties is supported: name, size,
mtime (last modified date), mode, uid, gid, linkname, uname,
gname, devmajor, devminor, prefix.</p>

<p style="margin-left:11%; margin-top: 1em">Passing an
array reference containing only one element,
&rsquo;name&rsquo;, is special cased to return a list of
names rather than a list of hash references, making it
equivalent to calling <tt>&quot;list_files&quot;</tt>
without arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;get_files(
[@filenames] )</b> <br>
Returns the <tt>&quot;Archive::Tar::File&quot;</tt> objects
matching the filenames provided. If no filename list was
passed, all <tt>&quot;Archive::Tar::File&quot;</tt> objects
in the current Tar object are returned.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the <tt>&quot;Archive::Tar::File&quot;</tt> documentation on
how to handle these objects.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;get_content(
$file )</b> <br>
Return the content of the named file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;replace_content(
$file, $content )</b> <br>
Make the string <tt>$content</tt> be the content for the
file named <tt>$file</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;rename(
$file, $new_name )</b> <br>
Rename the file of the in-memory archive to
<tt>$new_name</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
must specify a Unix path for <tt>$new_name</tt>, since per
tar standard, all files in the archive must be Unix
paths.</p>

<p style="margin-left:11%; margin-top: 1em">Returns true on
success and false on failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;chmod(
$file, $mode )</b> <br>
Change mode of <tt>$file</tt> to <tt>$mode</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Returns true on
success and false on failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;chown(
$file, $uname [, $gname] )</b> <br>
Change owner <tt>$file</tt> to <tt>$uname</tt> and
<tt>$gname</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Returns true on
success and false on failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;remove
(@filenamelist)</b> <br>
Removes any entries with names matching any of the given
filenames from the in-memory archive. Returns a list of
<tt>&quot;Archive::Tar::File&quot;</tt> objects that
remain.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;clear</b>
<tt><br>
&quot;clear&quot;</tt> clears the current in-memory archive.
This effectively gives you a &rsquo;blank&rsquo; object,
ready to be filled again. Note that
<tt>&quot;clear&quot;</tt> only has effect on the object,
not the underlying tarfile.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;write
( [$file, $compressed, $prefix] )</b> <br>
Write the in-memory archive to disk. The first argument can
either be the name of a file or a reference to an already
open filehandle (a <small>GLOB</small> reference).</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument is used to indicate compression. You can either
compress using <tt>&quot;gzip&quot;</tt> or
<tt>&quot;bzip2&quot;</tt>. If you pass a digit, it&rsquo;s
assumed to be the <tt>&quot;gzip&quot;</tt> compression
level (between 1 and 9), but the use of constants is
preferred:</p>

<pre style="margin-left:11%; margin-top: 1em">  # write a gzip compressed file
  $tar&minus;&gt;write( 'out.tgz', COMPRESS_GZIP );
  # write a bzip compressed file
  $tar&minus;&gt;write( 'out.tbz', COMPRESS_BZIP );</pre>


<p style="margin-left:11%; margin-top: 1em">Note that when
you pass in a filehandle, the compression argument is
ignored, as all files are printed verbatim to your
filehandle. If you wish to enable compression with
filehandles, use an <tt>&quot;IO::Zlib&quot;</tt> or
<tt>&quot;IO::Compress::Bzip2&quot;</tt> filehandle
instead.</p>

<p style="margin-left:11%; margin-top: 1em">The third
argument is an optional prefix. All files will be tucked
away in the directory you specify as prefix. So if you have
files &rsquo;a&rsquo; and &rsquo;b&rsquo; in your archive,
and you specify &rsquo;foo&rsquo; as prefix, they will be
written to the archive as &rsquo;foo/a&rsquo; and
&rsquo;foo/b&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">If no arguments
are given, <tt>&quot;write&quot;</tt> returns the entire
formatted archive as a string, which could be useful if
you&rsquo;d like to stuff the archive into a socket or a
pipe to gzip or something.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;add_files(
@filenamelist )</b> <br>
Takes a list of filenames and adds them to the in-memory
archive.</p>

<p style="margin-left:11%; margin-top: 1em">The path to the
file is automatically converted to a Unix like equivalent
for use in the archive, and, if on MacOS, the file&rsquo;s
modification time is converted from the MacOS epoch to the
Unix epoch. So tar archives created on MacOS with
<b>Archive::Tar</b> can be read both with <i>tar</i> on Unix
and applications like <i>suntar</i> or <i>Stuffit
Expander</i> on MacOS.</p>

<p style="margin-left:11%; margin-top: 1em">Be aware that
the file&rsquo;s type/creator and resource fork will be
lost, which is usually what you want in cross-platform
archives.</p>

<p style="margin-left:11%; margin-top: 1em">Instead of a
filename, you can also pass it an existing
<tt>&quot;Archive::Tar::File&quot;</tt> object from, for
example, another archive. The object will be clone, and
effectively be a copy of the original, not an alias.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a list
of <tt>&quot;Archive::Tar::File&quot;</tt> objects that were
just added.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;add_data
( $filename, $data, [$opthashref] )</b> <br>
Takes a filename, a scalar full of data and optionally a
reference to a hash with specific options.</p>

<p style="margin-left:11%; margin-top: 1em">Will add a file
to the in-memory archive, with name <tt>$filename</tt> and
content <tt>$data</tt>. Specific properties can be set using
<tt>$opthashref</tt>. The following list of properties is
supported: name, size, mtime (last modified date), mode,
uid, gid, linkname, uname, gname, devmajor, devminor,
prefix, type. (On MacOS, the file&rsquo;s path and
modification times are converted to Unix equivalents.)</p>

<p style="margin-left:11%; margin-top: 1em">Valid values
for the file type are the following constants defined by
Archive::Tar::Constant: <small><br>
FILE</small></p>

<p style="margin-left:17%;">Regular file.</p>

<p style="margin-left:11%;"><small>HARDLINK <br>
SYMLINK</small></p>

<p style="margin-left:17%;">Hard and symbolic
(&quot;soft&quot;) links; linkname should specify
target.</p>

<p style="margin-left:11%;"><small>CHARDEV <br>
BLOCKDEV</small></p>

<p style="margin-left:17%;">Character and block devices.
devmajor and devminor should specify the major and minor
device numbers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><small>DIR</small></p></td>
<td width="2%"></td>
<td width="15%">


<p>Directory.</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>FIFO</small></p>

<p style="margin-left:17%;"><small>FIFO</small> (named
pipe).</p>

<p style="margin-left:11%;"><small>SOCKET</small></p>

<p style="margin-left:17%;">Socket.</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
<tt>&quot;Archive::Tar::File&quot;</tt> object that was just
added, or <tt>&quot;undef&quot;</tt> on failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;error(
[$BOOL] )</b> <br>
Returns the current error string (usually, the last error
reported). If a true value was specified, it will give the
<tt>&quot;Carp::longmess&quot;</tt> equivalent of the error,
in effect giving you a stacktrace.</p>

<p style="margin-left:11%; margin-top: 1em">For backwards
compatibility, this error is also available as
<tt>$Archive::Tar::error</tt> although it is much
recommended you use the method call instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$tar&minus;&gt;setcwd(
$cwd );</b> <tt><br>
&quot;Archive::Tar&quot;</tt> needs to know the current
directory, and it will run <tt>&quot;Cwd::cwd()&quot;</tt>
<i>every</i> time it extracts a <i>relative</i> entry from
the tarfile and saves it in the file system. (As of version
1.30, however, <tt>&quot;Archive::Tar&quot;</tt> will use
the speed optimization described below automatically, so
it&rsquo;s only relevant if you&rsquo;re using
<tt>&quot;extract_file()&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Since
<tt>&quot;Archive::Tar&quot;</tt> doesn&rsquo;t change the
current directory internally while it is extracting the
items in a tarball, all calls to
<tt>&quot;Cwd::cwd()&quot;</tt> can be avoided if we can
guarantee that the current directory doesn&rsquo;t get
changed externally.</p>

<p style="margin-left:11%; margin-top: 1em">To use this
performance boost, set the current directory via</p>

<pre style="margin-left:11%; margin-top: 1em">    use Cwd;
    $tar&minus;&gt;setcwd( cwd() );</pre>


<p style="margin-left:11%; margin-top: 1em">once before
calling a function like <tt>&quot;extract_file&quot;</tt>
and <tt>&quot;Archive::Tar&quot;</tt> will use the current
directory setting from then on and won&rsquo;t call
<tt>&quot;Cwd::cwd()&quot;</tt> internally.</p>

<p style="margin-left:11%; margin-top: 1em">To switch back
to the default behaviour, use</p>

<pre style="margin-left:11%; margin-top: 1em">    $tar&minus;&gt;setcwd( undef );</pre>


<p style="margin-left:11%; margin-top: 1em">and
<tt>&quot;Archive::Tar&quot;</tt> will call
<tt>&quot;Cwd::cwd()&quot;</tt> internally again.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
using <tt>&quot;Archive::Tar&quot;</tt>&rsquo;s
<tt>&quot;extract()&quot;</tt> method,
<tt>&quot;setcwd()&quot;</tt> will be called for you.</p>

<h2>Class Methods
<a name="Class Methods"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;create_archive($file,
$compressed, @filelist)</b> <br>
Creates a tar file from the list of files provided. The
first argument can either be the name of the tar file to
create or a reference to an open file handle (e.g. a
<small>GLOB</small> reference).</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument is used to indicate compression. You can either
compress using <tt>&quot;gzip&quot;</tt> or
<tt>&quot;bzip2&quot;</tt>. If you pass a digit, it&rsquo;s
assumed to be the <tt>&quot;gzip&quot;</tt> compression
level (between 1 and 9), but the use of constants is
preferred:</p>

<pre style="margin-left:11%; margin-top: 1em">  # write a gzip compressed file
  Archive::Tar&minus;&gt;create_archive( 'out.tgz', COMPRESS_GZIP, @filelist );
  # write a bzip compressed file
  Archive::Tar&minus;&gt;create_archive( 'out.tbz', COMPRESS_BZIP, @filelist );</pre>


<p style="margin-left:11%; margin-top: 1em">Note that when
you pass in a filehandle, the compression argument is
ignored, as all files are printed verbatim to your
filehandle. If you wish to enable compression with
filehandles, use an <tt>&quot;IO::Zlib&quot;</tt> or
<tt>&quot;IO::Compress::Bzip2&quot;</tt> filehandle
instead.</p>

<p style="margin-left:11%; margin-top: 1em">The remaining
arguments list the files to be included in the tar file.
These files must all exist. Any files which don&rsquo;t
exist or can&rsquo;t be read are silently ignored.</p>

<p style="margin-left:11%; margin-top: 1em">If the archive
creation fails for any reason,
<tt>&quot;create_archive&quot;</tt> will return false.
Please use the <tt>&quot;error&quot;</tt> method to find the
cause of the failure.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
method does not write <tt>&quot;on the fly&quot;</tt> as it
were; it still reads all the files into memory before
writing out the archive. Consult the <small>FAQ</small>
below if this is a problem.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;iter(
$filename, [ $compressed, {opt =&gt; $val} ] )</b> <br>
Returns an iterator function that reads the tar file without
loading it all in memory. Each time the function is called
it will return the next file in the tarball. The files are
returned as <tt>&quot;Archive::Tar::File&quot;</tt> objects.
The iterator function returns the empty list once it has
exhausted the files contained.</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument can be a hash reference with options, which are
identical to the arguments passed to
<tt>&quot;read()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Example
usage:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $next = Archive::Tar&minus;&gt;iter( &quot;example.tar.gz&quot;, 1, {filter =&gt; qr/\.pm$/} );
    while( my $f = $next&minus;&gt;() ) {
        print $f&minus;&gt;name, &quot;\n&quot;;
        $f&minus;&gt;extract or warn &quot;Extraction failed&quot;;
        # ....
    }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;list_archive($file,
$compressed, [\@properties])</b> <br>
Returns a list of the names of all the files in the archive.
The first argument can either be the name of the tar file to
list or a reference to an open file handle (e.g. a
<small>GLOB</small> reference).</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;list_archive()&quot;</tt> is passed an array
reference as its third argument it returns a list of hash
references containing the requested properties of each file.
The following list of properties is supported: full_path,
name, size, mtime (last modified date), mode, uid, gid,
linkname, uname, gname, devmajor, devminor, prefix,
type.</p>

<p style="margin-left:11%; margin-top: 1em">See
<tt>&quot;Archive::Tar::File&quot;</tt> for details about
supported properties.</p>

<p style="margin-left:11%; margin-top: 1em">Passing an
array reference containing only one element,
&rsquo;name&rsquo;, is special cased to return a list of
names rather than a list of hash references.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;extract_archive($file,
$compressed)</b> <br>
Extracts the contents of the tar file. The first argument
can either be the name of the tar file to create or a
reference to an open file handle (e.g. a <small>GLOB</small>
reference). All relative paths in the tar file will be
created underneath the current working directory.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;extract_archive&quot;</tt>
will return a list of files it extracted. If the archive
extraction fails for any reason,
<tt>&quot;extract_archive&quot;</tt> will return false.
Please use the <tt>&quot;error&quot;</tt> method to find the
cause of the failure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$bool =
Archive::Tar&minus;&gt;has_io_string</b> <br>
Returns true if we currently have
<tt>&quot;IO::String&quot;</tt> support loaded.</p>

<p style="margin-left:11%; margin-top: 1em">Either
<tt>&quot;IO::String&quot;</tt> or
<tt>&quot;perlio&quot;</tt> support is needed to support
writing stringified archives. Currently,
<tt>&quot;perlio&quot;</tt> is the preferred method, if
available.</p>

<p style="margin-left:11%; margin-top: 1em">See the
<tt>&quot;GLOBAL VARIABLES&quot;</tt> section to see how to
change this preference.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$bool =
Archive::Tar&minus;&gt;has_perlio</b> <br>
Returns true if we currently have
<tt>&quot;perlio&quot;</tt> support loaded.</p>

<p style="margin-left:11%; margin-top: 1em">This requires
<tt>&quot;perl&minus;5.8&quot;</tt> or higher, compiled with
<tt>&quot;perlio&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Either
<tt>&quot;IO::String&quot;</tt> or
<tt>&quot;perlio&quot;</tt> support is needed to support
writing stringified archives. Currently,
<tt>&quot;perlio&quot;</tt> is the preferred method, if
available.</p>

<p style="margin-left:11%; margin-top: 1em">See the
<tt>&quot;GLOBAL VARIABLES&quot;</tt> section to see how to
change this preference.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$bool =
Archive::Tar&minus;&gt;has_zlib_support</b> <br>
Returns true if <tt>&quot;Archive::Tar&quot;</tt> can
extract <tt>&quot;zlib&quot;</tt> compressed archives</p>

<p style="margin-left:11%; margin-top: 1em"><b>$bool =
Archive::Tar&minus;&gt;has_bzip2_support</b> <br>
Returns true if <tt>&quot;Archive::Tar&quot;</tt> can
extract <tt>&quot;bzip2&quot;</tt> compressed archives</p>


<p style="margin-left:11%; margin-top: 1em"><b>Archive::Tar&minus;&gt;can_handle_compressed_files</b>
<br>
A simple checking routine, which will return true if
<tt>&quot;Archive::Tar&quot;</tt> is able to uncompress
compressed archives on the fly with
<tt>&quot;IO::Zlib&quot;</tt> and
<tt>&quot;IO::Compress::Bzip2&quot;</tt> or false if not
both are installed.</p>

<p style="margin-left:11%; margin-top: 1em">You can use
this as a shortcut to determine whether
<tt>&quot;Archive::Tar&quot;</tt> will do what you think
before passing compressed archives to its
<tt>&quot;read&quot;</tt> method.</p>

<h2>GLOBAL VARIABLES
<a name="GLOBAL VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::FOLLOW_SYMLINK</b>
<br>
Set this variable to <tt>1</tt> to make
<tt>&quot;Archive::Tar&quot;</tt> effectively make a copy of
the file when extracting. Default is <tt>0</tt>, which means
the symlink stays intact. Of course, you will have to pack
the file linked to as well.</p>

<p style="margin-left:11%; margin-top: 1em">This option is
checked when you write out the tarfile using
<tt>&quot;write&quot;</tt> or
<tt>&quot;create_archive&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">This works just
like <tt>&quot;/bin/tar&quot;</tt>&rsquo;s
<tt>&quot;&minus;h&quot;</tt> option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::CHOWN</b>
<br>
By default, <tt>&quot;Archive::Tar&quot;</tt> will try to
<tt>&quot;chown&quot;</tt> your files if it is able to. In
some cases, this may not be desired. In that case, set this
variable to <tt>0</tt> to disable
<tt>&quot;chown&quot;</tt>&minus;ing, even if it were
possible.</p>

<p style="margin-left:11%; margin-top: 1em">The default is
<tt>1</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::CHMOD</b>
<br>
By default, <tt>&quot;Archive::Tar&quot;</tt> will try to
<tt>&quot;chmod&quot;</tt> your files to whatever mode was
specified for the particular file in the archive. In some
cases, this may not be desired. In that case, set this
variable to <tt>0</tt> to disable
<tt>&quot;chmod&quot;</tt>&minus;ing.</p>

<p style="margin-left:11%; margin-top: 1em">The default is
<tt>1</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::SAME_PERMISSIONS</b>
<br>
When, <tt>$Archive::Tar::CHMOD</tt> is enabled, this setting
controls whether the permissions on files from the archive
are used without modification of if they are filtered by
removing any setid bits and applying the current umask.</p>

<p style="margin-left:11%; margin-top: 1em">The default is
<tt>1</tt> for the root user and <tt>0</tt> for normal
users.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::DO_NOT_USE_PREFIX</b>
<br>
By default, <tt>&quot;Archive::Tar&quot;</tt> will try to
put paths that are over 100 characters in the
<tt>&quot;prefix&quot;</tt> field of your tar header, as
defined per POSIX-standard. However, some (older) tar
programs do not implement this spec. To retain compatibility
with these older or non-POSIX compliant versions, you can
set the <tt>$DO_NOT_USE_PREFIX</tt> variable to a true
value, and <tt>&quot;Archive::Tar&quot;</tt> will use an
alternate way of dealing with paths over 100 characters by
using the <tt>&quot;GNU Extended Header&quot;</tt>
feature.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
clients who do not support the <tt>&quot;GNU Extended
Header&quot;</tt> feature will not be able to read these
archives. Such clients include tars on
<tt>&quot;Solaris&quot;</tt>, <tt>&quot;Irix&quot;</tt> and
<tt>&quot;AIX&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The default is
<tt>0</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::DEBUG</b>
<br>
Set this variable to <tt>1</tt> to always get the
<tt>&quot;Carp::longmess&quot;</tt> output of the warnings,
instead of the regular <tt>&quot;carp&quot;</tt>. This is
the same message you would get by doing:</p>

<pre style="margin-left:11%; margin-top: 1em">    $tar&minus;&gt;error(1);</pre>


<p style="margin-left:11%; margin-top: 1em">Defaults to
<tt>0</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::WARN</b>
<br>
Set this variable to <tt>0</tt> if you do not want any
warnings printed. Personally I recommend against doing this,
but people asked for the option. Also, be advised that this
is of course not threadsafe.</p>

<p style="margin-left:11%; margin-top: 1em">Defaults to
<tt>1</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::error</b>
<br>
Holds the last reported error. Kept for historical reasons,
but its use is very much discouraged. Use the
<tt>&quot;error()&quot;</tt> method instead:</p>

<pre style="margin-left:11%; margin-top: 1em">    warn $tar&minus;&gt;error unless $tar&minus;&gt;extract;</pre>


<p style="margin-left:11%; margin-top: 1em">Note that in
older versions of this module, the
<tt>&quot;error()&quot;</tt> method would return an
effectively global value even when called an instance method
as above. This has since been fixed, and multiple instances
of <tt>&quot;Archive::Tar&quot;</tt> now have separate error
strings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::INSECURE_EXTRACT_MODE</b>
<br>
This variable indicates whether
<tt>&quot;Archive::Tar&quot;</tt> should allow files to be
extracted outside their current working directory.</p>

<p style="margin-left:11%; margin-top: 1em">Allowing this
could have security implications, as a malicious tar archive
could alter or replace any file the extracting user has
permissions to. Therefor, the default is to not allow
insecure extractions.</p>

<p style="margin-left:11%; margin-top: 1em">If you trust
the archive, or have other reasons to allow the archive to
write files outside your current working directory, set this
variable to <tt>&quot;true&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
is a backwards incompatible change from version
<tt>1.36</tt> and before.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::HAS_PERLIO</b>
<br>
This variable holds a boolean indicating if we currently
have <tt>&quot;perlio&quot;</tt> support loaded. This will
be enabled for any perl greater than <tt>5.8</tt> compiled
with <tt>&quot;perlio&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you feel
strongly about disabling it, set this variable to
<tt>&quot;false&quot;</tt>. Note that you will then need
<tt>&quot;IO::String&quot;</tt> installed to support writing
stringified archives.</p>

<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t
change this variable unless you <b>really</b> know what
you&rsquo;re doing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::HAS_IO_STRING</b>
<br>
This variable holds a boolean indicating if we currently
have <tt>&quot;IO::String&quot;</tt> support loaded. This
will be enabled for any perl that has a loadable
<tt>&quot;IO::String&quot;</tt> module.</p>

<p style="margin-left:11%; margin-top: 1em">If you feel
strongly about disabling it, set this variable to
<tt>&quot;false&quot;</tt>. Note that you will then need
<tt>&quot;perlio&quot;</tt> support from your perl to be
able to write stringified archives.</p>

<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t
change this variable unless you <b>really</b> know what
you&rsquo;re doing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$Archive::Tar::ZERO_PAD_NUMBERS</b>
<br>
This variable holds a boolean indicating if we will create
zero padded numbers for <tt>&quot;size&quot;</tt>,
<tt>&quot;mtime&quot;</tt> and
<tt>&quot;checksum&quot;</tt>. The default is <tt>0</tt>,
indicating that we will create space padded numbers. Added
for compatibility with <tt>&quot;busybox&quot;</tt>
implementations.</p>

<h2>FAQ
<a name="FAQ"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">What&rsquo;s
the minimum perl version required to run Archive::Tar?</p>

<p style="margin-left:17%;">You will need perl version
5.005_03 or newer.</p>

<p style="margin-left:11%;">Isn&rsquo;t Archive::Tar
slow?</p>

<p style="margin-left:17%;">Yes it is. It&rsquo;s pure
perl, so it&rsquo;s a lot slower then your
<tt>&quot;/bin/tar&quot;</tt> However, it&rsquo;s very
portable. If speed is an issue, consider using
<tt>&quot;/bin/tar&quot;</tt> instead.</p>

<p style="margin-left:11%;">Isn&rsquo;t Archive::Tar
heavier on memory than /bin/tar?</p>

<p style="margin-left:17%;">Yes it is, see previous answer.
Since <tt>&quot;Compress::Zlib&quot;</tt> and therefore
<tt>&quot;IO::Zlib&quot;</tt> doesn&rsquo;t support
<tt>&quot;seek&quot;</tt> on their filehandles, there is
little choice but to read the archive into memory. This is
ok if you want to do in-memory manipulation of the
archive.</p>

<p style="margin-left:17%; margin-top: 1em">If you just
want to extract, use the
<tt>&quot;extract_archive&quot;</tt> class method instead.
It will optimize and write to disk immediately.</p>

<p style="margin-left:17%; margin-top: 1em">Another option
is to use the <tt>&quot;iter&quot;</tt> class method to
iterate over the files in the tarball without reading them
all in memory at once.</p>

<p style="margin-left:11%;">Can you lazy-load data
instead?</p>

<p style="margin-left:17%;">In some cases, yes. You can use
the <tt>&quot;iter&quot;</tt> class method to iterate over
the files in the tarball without reading them all in memory
at once.</p>

<p style="margin-left:11%;">How much memory will an X kb
tar file need?</p>

<p style="margin-left:17%;">Probably more than X kb, since
it will all be read into memory. If this is a problem, and
you don&rsquo;t need to do in memory manipulation of the
archive, consider using the <tt>&quot;iter&quot;</tt> class
method, or <tt>&quot;/bin/tar&quot;</tt> instead.</p>

<p style="margin-left:11%;">What do you do with unsupported
filetypes in an archive?</p>

<p style="margin-left:17%;"><tt>&quot;Unix&quot;</tt> has a
few filetypes that aren&rsquo;t supported on other
platforms, like <tt>&quot;Win32&quot;</tt>. If we encounter
a <tt>&quot;hardlink&quot;</tt> or
<tt>&quot;symlink&quot;</tt> we&rsquo;ll just try to make a
copy of the original file, rather than throwing an
error.</p>

<p style="margin-left:17%; margin-top: 1em">This does
require you to read the entire archive in to memory first,
since otherwise we wouldn&rsquo;t know what data to fill the
copy with. (This means that you cannot use the class
methods, including <tt>&quot;iter&quot;</tt> on archives
that have incompatible filetypes and still expect things to
work).</p>

<p style="margin-left:17%; margin-top: 1em">For other
filetypes, like <tt>&quot;chardevs&quot;</tt> and
<tt>&quot;blockdevs&quot;</tt> we&rsquo;ll warn that the
extraction of this particular item didn&rsquo;t work.</p>

<p style="margin-left:11%;">I&rsquo;m using WinZip, or some
other non-POSIX client, and files are not <br>
being extracted properly!</p>

<p style="margin-left:17%;">By default,
<tt>&quot;Archive::Tar&quot;</tt> is in a completely
POSIX-compatible mode, which uses the POSIX-specification of
<tt>&quot;tar&quot;</tt> to store files. For paths greater
than 100 characters, this is done using the <tt>&quot;POSIX
header prefix&quot;</tt>. Non-POSIX-compatible clients may
not support this part of the specification, and may only
support the <tt>&quot;GNU Extended Header&quot;</tt>
functionality. To facilitate those clients, you can set the
<tt>$Archive::Tar::DO_NOT_USE_PREFIX</tt> variable to
<tt>&quot;true&quot;</tt>. See the <tt>&quot;GLOBAL
VARIABLES&quot;</tt> section for details on this
variable.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<small>GNU</small> tar earlier than version 1.14 does not
cope well with the <tt>&quot;POSIX header prefix&quot;</tt>.
If you use such a version, consider setting the
<tt>$Archive::Tar::DO_NOT_USE_PREFIX</tt> variable to
<tt>&quot;true&quot;</tt>.</p>

<p style="margin-left:11%;">How do I extract only files
that have property X from an archive?</p>

<p style="margin-left:17%;">Sometimes, you might not wish
to extract a complete archive, just the files that are
relevant to you, based on some criteria.</p>

<p style="margin-left:17%; margin-top: 1em">You can do this
by filtering a list of
<tt>&quot;Archive::Tar::File&quot;</tt> objects based on
your criteria. For example, to extract only files that have
the string <tt>&quot;foo&quot;</tt> in their title, you
would use:</p>

<pre style="margin-left:17%; margin-top: 1em">    $tar&minus;&gt;extract(
        grep { $_&minus;&gt;full_path =~ /foo/ } $tar&minus;&gt;get_files
    );</pre>


<p style="margin-left:17%; margin-top: 1em">This way, you
can filter on any attribute of the files in the archive.
Consult the <tt>&quot;Archive::Tar::File&quot;</tt>
documentation on how to use these objects.</p>

<p style="margin-left:11%;">How do I access .tar.Z
files?</p>

<p style="margin-left:17%;">The
<tt>&quot;Archive::Tar&quot;</tt> module can optionally use
<tt>&quot;Compress::Zlib&quot;</tt> (via the
<tt>&quot;IO::Zlib&quot;</tt> module) to access tar files
that have been compressed with <tt>&quot;gzip&quot;</tt>.
Unfortunately tar files compressed with the Unix
<tt>&quot;compress&quot;</tt> utility cannot be read by
<tt>&quot;Compress::Zlib&quot;</tt> and so cannot be
directly accesses by <tt>&quot;Archive::Tar&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>&quot;uncompress&quot;</tt> or
<tt>&quot;gunzip&quot;</tt> programs are available, you can
use one of these workarounds to read
<tt>&quot;.tar.Z&quot;</tt> files from
<tt>&quot;Archive::Tar&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">Firstly with
<tt>&quot;uncompress&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em"><tt>use
Archive::Tar; <br>
open F, &quot;uncompress &minus;c $filename |&quot;; <br>
my $tar = Archive::Tar&minus;&gt;new(*F); <br>
...</tt></p>

<p style="margin-left:17%; margin-top: 1em">and this with
<tt>&quot;gunzip&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em"><tt>use
Archive::Tar; <br>
open F, &quot;gunzip &minus;c $filename |&quot;; <br>
my $tar = Archive::Tar&minus;&gt;new(*F); <br>
...</tt></p>

<p style="margin-left:17%; margin-top: 1em">Similarly, if
the <tt>&quot;compress&quot;</tt> program is available, you
can use this to write a <tt>&quot;.tar.Z&quot;</tt> file</p>

<pre style="margin-left:17%; margin-top: 1em">    use Archive::Tar;
    use IO::File;
    my $fh = new IO::File &quot;| compress &minus;c &gt;$filename&quot;;
    my $tar = Archive::Tar&minus;&gt;new();
    ...
    $tar&minus;&gt;write($fh);
    $fh&minus;&gt;close ;</pre>


<p style="margin-left:11%;">How do I handle Unicode
strings?</p>


<p style="margin-left:17%;"><tt>&quot;Archive::Tar&quot;</tt>
uses byte semantics for any files it reads from or writes to
disk. This is not a problem if you only deal with files and
never look at their content or work solely with byte
strings. But if you use Unicode strings with character
semantics, some additional steps need to be taken.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
you add a Unicode string like</p>

<pre style="margin-left:17%; margin-top: 1em">    # Problem
    $tar&minus;&gt;add_data('file.txt', &quot;Euro: \x{20AC}&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">then there will
be a problem later when the tarfile gets written out to disk
via <tt>&quot;$tar&minus;&quot;</tt><i>write()</i>&gt;:</p>

<pre style="margin-left:17%; margin-top: 1em">    Wide character in print at .../Archive/Tar.pm line 1014.</pre>


<p style="margin-left:17%; margin-top: 1em">The data was
added as a Unicode string and when writing it out to disk,
the <tt>&quot;:utf8&quot;</tt> line discipline wasn&rsquo;t
set by <tt>&quot;Archive::Tar&quot;</tt>, so Perl tried to
convert the string to <small>ISO&minus;8859</small> and
failed. The written file now contains garbage.</p>

<p style="margin-left:17%; margin-top: 1em">For this
reason, Unicode strings need to be converted to
UTF&minus;8&minus;encoded bytestrings before they are handed
off to <tt>&quot;add_data()&quot;</tt>:</p>

<pre style="margin-left:17%; margin-top: 1em">    use Encode;
    my $data = &quot;Accented character: \x{20AC}&quot;;
    $data = encode('utf8', $data);
    $tar&minus;&gt;add_data('file.txt', $data);</pre>


<p style="margin-left:17%; margin-top: 1em">A opposite
problem occurs if you extract a UTF8&minus;encoded file from
a tarball. Using <tt>&quot;get_content()&quot;</tt> on the
<tt>&quot;Archive::Tar::File&quot;</tt> object will return
its content as a bytestring, not as a Unicode string.</p>

<p style="margin-left:17%; margin-top: 1em">If you want it
to be a Unicode string (because you want character semantics
with operations like regular expression matching), you need
to decode the UTF8&minus;encoded content and have Perl
convert it into a Unicode string:</p>

<pre style="margin-left:17%; margin-top: 1em">    use Encode;
    my $data = $tar&minus;&gt;get_content();
    # Make it a Unicode string
    $data = decode('utf8', $data);</pre>


<p style="margin-left:17%; margin-top: 1em">There is no
easy way to provide this functionality in
<tt>&quot;Archive::Tar&quot;</tt>, because a tarball can
contain many files, and each of which could be encoded in a
different way.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>AIX</small> tar does not fill all unused space in the
tar archive with 0x00. This sometimes leads to warning
messages from <tt>&quot;Archive::Tar&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">  Invalid header block at offset nnn</pre>


<p style="margin-left:11%; margin-top: 1em">A fix for that
problem is scheduled to be released in the following levels
of <small>AIX,</small> all of which should be coming out in
the 4th quarter of 2009:</p>

<pre style="margin-left:11%; margin-top: 1em"> AIX 5.3 TL7 SP10
 AIX 5.3 TL8 SP8
 AIX 5.3 TL9 SP5
 AIX 5.3 TL10 SP2
 AIX 6.1 TL0 SP11
 AIX 6.1 TL1 SP7
 AIX 6.1 TL2 SP6
 AIX 6.1 TL3 SP3</pre>


<p style="margin-left:11%; margin-top: 1em">The <small>IBM
APAR</small> number for this problem is
<small>IZ50240</small> (Reported component <small>ID:
5765G0300 / AIX 5.3</small> ). It is possible to get an ifix
for that problem. If you need an ifix please contact your
local <small>IBM AIX</small> support.</p>

<h2>TODO
<a name="TODO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Check if passed
in handles are open for read/write</p>

<p style="margin-left:17%;">Currently I don&rsquo;t know of
any portable pure perl way to do this. Suggestions
welcome.</p>

<p style="margin-left:11%;">Allow archives to be passed in
as string</p>

<p style="margin-left:17%;">Currently, we only allow opened
filehandles or filenames, but not strings. The internals
would need some reworking to facilitate stringified
archives.</p>

<p style="margin-left:11%;">Facilitate processing an opened
filehandle of a compressed archive</p>

<p style="margin-left:17%;">Currently, we only support this
if the filehandle is an IO::Zlib object. Environments, like
apache, will present you with an opened filehandle to an
uploaded file, which might be a compressed archive.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>GNU</small> tar specification</p>


<p style="margin-left:17%;"><tt>&quot;http://www.gnu.org/software/tar/manual/tar.html&quot;</tt></p>

<p style="margin-left:11%;">The <small>PAX</small> format
specification</p>

<p style="margin-left:17%;">The specification which tar
derives from; <tt>&quot;
http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;</tt></p>

<p style="margin-left:11%;">A comparison of
<small>GNU</small> and <small>POSIX</small> tar standards;
<br>

&quot;http://www.delorie.com/gnu/docs/tar/tar_114.html&quot;
<small><br>
GNU</small> tar intends to switch to <small>POSIX</small>
compatibility</p>

<p style="margin-left:17%;"><small>GNU</small> Tar authors
have expressed their intention to become completely
POSIX-compatible;
<tt>&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;</tt></p>

<p style="margin-left:11%;">A Comparison between various
tar implementations</p>

<p style="margin-left:17%;">Lists known issues and
incompatibilities;
<tt>&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;</tt></p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module by
Jos Boumans &lt;kane@cpan.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Please reports
bugs to &lt;bug&minus;archive&minus;tar@rt.cpan.org&gt;.</p>

<h2>ACKNOWLEDGEMENTS
<a name="ACKNOWLEDGEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thanks to Sean
Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas,
Rainer Tammer and especially Andrew Savige for their help
and suggestions.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module is
copyright (c) 2002 &minus; 2009 Jos Boumans
&lt;kane@cpan.org&gt;. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you may redistribute and/or modify it under
the same terms as Perl itself.</p>
<hr>
</body>
</html>
