<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:17:59 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>RAWSHARK</title>

</head>
<body>

<h1 align="center">RAWSHARK</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INPUT">INPUT</a><br>
<a href="#OUTPUT">OUTPUT</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#READ FILTER SYNTAX">READ FILTER SYNTAX</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">rawshark
&minus; Dump and analyze raw pcap data</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>rawshark</b>
[&nbsp;<b>&minus;d&nbsp;</b>&lt;encap:dlt&gt;|&lt;proto:protoname&gt;&nbsp;]
[&nbsp;<b>&minus;F&nbsp;</b>&lt;field&nbsp;to&nbsp;display&gt;&nbsp;]
[&nbsp;<b>&minus;h&nbsp;</b>] [&nbsp;<b>&minus;l&nbsp;</b>]
[&nbsp;<b>&minus;n&nbsp;</b>]
[&nbsp;<b>&minus;N&nbsp;</b>&lt;name&nbsp;resolving&nbsp;flags&gt;&nbsp;]
[&nbsp;<b>&minus;o&nbsp;</b>&lt;preference&nbsp;setting&gt;&nbsp;]&nbsp;...
[&nbsp;<b>&minus;p&nbsp;</b>]
[&nbsp;<b>&minus;r&nbsp;</b>&lt;pipe&gt;|&minus;&nbsp;]
[&nbsp;<b>&minus;R&nbsp;</b>&lt;read&nbsp;(display)&nbsp;filter&gt;&nbsp;]
[&nbsp;<b>&minus;s&nbsp;</b>]
[&nbsp;<b>&minus;S&nbsp;</b>&lt;field&nbsp;format&gt;&nbsp;]
[&nbsp;<b>&minus;t&nbsp;</b>ad|a|r|d|e&nbsp;]
[&nbsp;<b>&minus;v&nbsp;</b>]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Rawshark</b>
reads a stream of packets from a file or pipe, and prints a
line describing its output, followed by a set of matching
fields for each packet on stdout.</p>

<h2>INPUT
<a name="INPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Unlike
<b>TShark</b>, <b>Rawshark</b> makes no assumptions about
encapsulation or input. The <b>&minus;d</b> and
<b>&minus;r</b> flags must be specified in order for it to
run. One or more <b>&minus;F</b> flags should be specified
in order for the output to be useful. The other flags listed
above follow the same conventions as <b>Wireshark</b> and
<b>TShark</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Rawshark</b>
expects input records with the following format by default.
This matches the format of the packet header and packet data
in a pcap-formatted file on disk.</p>

<pre style="margin-left:11%; margin-top: 1em">    struct rawshark_rec_s {
        uint32_t ts_sec;      /* Time stamp (seconds) */
        uint32_t ts_usec;     /* Time stamp (microseconds) */
        uint32_t caplen;      /* Length of the packet buffer */
        uint32_t len;         /* &quot;On the wire&quot; length of the packet */
        uint8_t data[caplen]; /* Packet data */
    };</pre>


<p style="margin-left:11%; margin-top: 1em">If
<b>&minus;p</b> is supplied <b>rawshark</b> expects the
following format. This matches the <i>struct pcap_pkthdr</i>
structure and packet data used in libpcap/WinPcap. This
structure&rsquo;s format is platform-dependent; the size of
the <i>tv_sec</i> field in the <i>struct timeval</i>
structure could be 32 bits or 64 bits. For <b>rawshark</b>
to work, the layout of the structure in the input must match
the layout of the structure in <b>rawshark</b>. Note that
this format will probably be the same as the previous format
if <b>rawshark</b> is a 32&minus;bit program, but will not
necessarily be the same if <b>rawshark</b> is a 64&minus;bit
program.</p>

<pre style="margin-left:11%; margin-top: 1em">    struct rawshark_rec_s {
        struct timeval ts;    /* Time stamp */
        uint32_t caplen;      /* Length of the packet buffer */
        uint32_t len;         /* &quot;On the wire&quot; length of the packet */
        uint8_t data[caplen]; /* Packet data */
    };</pre>


<p style="margin-left:11%; margin-top: 1em">In either case,
the endianness (byte ordering) of each integer must match
the system on which <b>rawshark</b> is running.</p>

<h2>OUTPUT
<a name="OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If one or more
fields are specified via the <b>&minus;F</b> flag,
<b>Rawshark</b> prints the number, field type, and display
format for each field on the first line as &quot;packet
number&quot; 0. For each record, the packet number, matching
fields, and a &quot;1&quot; or &quot;0&quot; are printed to
indicate if the field matched any supplied display filter. A
&quot;&minus;&quot; is used to signal the end of a field
description and at the end of each packet line. For example,
the flags <b>&minus;F ip.src &minus;F dns.qry.type</b> might
generate the following output:</p>

<pre style="margin-left:11%; margin-top: 1em">    0 FT_IPv4 BASE_NONE &minus; 1 FT_UINT16 BASE_HEX &minus;
    1 1=&quot;1&quot; 0=&quot;192.168.77.10&quot; 1 &minus;
    2 1=&quot;1&quot; 0=&quot;192.168.77.250&quot; 1 &minus;
    3 0=&quot;192.168.77.10&quot; 1 &minus;
    4 0=&quot;74.125.19.104&quot; 1 &minus;</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
packets 1 and 2 are <small>DNS</small> queries, and 3 and 4
are not. Adding <b>&minus;R &quot;not dns&quot;</b> still
prints each line, but there&rsquo;s an indication that
packets 1 and 2 didn&rsquo;t pass the filter:</p>

<pre style="margin-left:11%; margin-top: 1em">    0 FT_IPv4 BASE_NONE &minus; 1 FT_UINT16 BASE_HEX &minus;
    1 1=&quot;1&quot; 0=&quot;192.168.77.10&quot; 0 &minus;
    2 1=&quot;1&quot; 0=&quot;192.168.77.250&quot; 0 &minus;
    3 0=&quot;192.168.77.10&quot; 1 &minus;
    4 0=&quot;74.125.19.104&quot; 1 &minus;</pre>


<p style="margin-left:11%; margin-top: 1em">Also note that
the output may be in any order, and that multiple matching
fields might be displayed.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&minus;d
&lt;encapsulation&gt;</p>

<p style="margin-left:17%;">Specify how the packet data
should be dissected. The encapsulation is of the form
<i>type</i><b>:</b><i>value</i>, where <i>type</i> is one
of:</p>


<p style="margin-left:17%; margin-top: 1em"><b>encap</b>:<i>name</i>
Packet data should be dissected using the libpcap/WinPcap
data link type ( <small>DLT</small> ) <i>name</i>, e.g.
<b>encap:EN10MB</b> for Ethernet. Names are converted using
<i>pcap_datalink_name_to_val()</i>. A complete list of DLTs
can be found at
&lt;http://www.tcpdump.org/linktypes.html&gt;.</p>


<p style="margin-left:17%; margin-top: 1em"><b>encap</b>:<i>number</i>
Packet data should be dissected using the libpcap/WinPcap
<small>DLT</small> <i>number</i>, e.g. <b>encap:105</b> for
raw <small>IEEE 802.11.</small></p>


<p style="margin-left:17%; margin-top: 1em"><b>proto</b>:<i>protocol</i>
Packet data should be passed to the specified Wireshark
protocol dissector, e.g. <b>proto:http</b> for
<small>HTTP</small> data.</p>

<p style="margin-left:11%;">&minus;F &lt;field to
display&gt;</p>

<p style="margin-left:17%;">Add the matching field to the
output. Fields are any valid display filter field. More than
one <b>&minus;F</b> flag may be specified, and each field
can match multiple times in a given packet. A single field
may be specified per <b>&minus;F</b> flag. If you want to
apply a display filter, use the <b>&minus;R</b> flag.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;h</p></td>
<td width="3%"></td>
<td width="83%">


<p>Print the version and options and exits.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;l</p></td>
<td width="3%"></td>
<td width="83%">


<p>Flush the standard output after the information for each
packet is printed. (This is not, strictly speaking,
line-buffered if <b>&minus;V</b> was specified; however, it
is the same as line-buffered if <b>&minus;V</b> wasn&rsquo;t
specified, as only one line is printed for each packet, and,
as <b>&minus;l</b> is normally used when piping a live
capture to a program or script, so that output for a packet
shows up as soon as the packet is seen and dissected, it
should work just as well as true line-buffering. We do this
as a workaround for a deficiency in the Microsoft Visual C
<small>++</small> C library.)</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This may be
useful when piping the output of <b>TShark</b> to another
program, as it means that the program to which the output is
piped will see the dissected data for a packet as soon as
<b>TShark</b> sees the packet and generates that output,
rather than seeing it only when the standard output buffer
containing that data fills up.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">&minus;n</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Disable network object name
resolution (such as hostname, <small>TCP</small> and
<small>UDP</small> port names), the <b>&minus;N</b> flag
might override this one.</p></td></tr>
</table>

<p style="margin-left:11%;">&minus;N &lt;name resolving
flags&gt;</p>

<p style="margin-left:17%;">Turn on name resolving only for
particular types of addresses and port numbers, with name
resolving for other types of addresses and port numbers
turned off. This flag overrides <b>&minus;n</b> if both
<b>&minus;N</b> and <b>&minus;n</b> are present. If both
<b>&minus;N</b> and <b>&minus;n</b> flags are not present,
all name resolutions are turned on.</p>

<p style="margin-left:17%; margin-top: 1em">The argument is
a string that may contain the letters:</p>

<p style="margin-left:17%; margin-top: 1em"><b>m</b> to
enable <small>MAC</small> address resolution</p>

<p style="margin-left:17%; margin-top: 1em"><b>n</b> to
enable network address resolution</p>

<p style="margin-left:17%; margin-top: 1em"><b>N</b> to
enable using external resolvers (e.g., <small>DNS</small> )
for network address resolution</p>

<p style="margin-left:17%; margin-top: 1em"><b>t</b> to
enable transport-layer port number resolution</p>

<p style="margin-left:17%; margin-top: 1em"><b>C</b> to
enable concurrent (asynchronous) <small>DNS</small>
lookups</p>

<p style="margin-left:11%;">&minus;o
&lt;preference&gt;:&lt;value&gt;</p>

<p style="margin-left:17%;">Set a preference value,
overriding the default value and any value read from a
preference file. The argument to the option is a string of
the form <i>prefname</i><b>:</b><i>value</i>, where
<i>prefname</i> is the name of the preference (which is the
same name that would appear in the preference file), and
<i>value</i> is the value to which it should be set.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;p</p></td>
<td width="3%"></td>
<td width="83%">


<p>Assume that packet data is preceded by a pcap_pkthdr
struct as defined in pcap.h. On some systems the size of the
timestamp data will be different from the data written to
disk. On other systems they are identical and this flag has
no effect.</p></td></tr>
</table>

<p style="margin-left:11%;">&minus;r
&lt;pipe&gt;|&minus;</p>

<p style="margin-left:17%;">Read packet data from <i>input
source</i>. It can be either the name of a
<small>FIFO</small> (named pipe) or
&lsquo;&lsquo;&minus;&rsquo;&rsquo; to read data from the
standard input, and must have the record format specified
above.</p>

<p style="margin-left:11%;">&minus;R &lt;read (display)
filter&gt;</p>

<p style="margin-left:17%;">Cause the specified filter
(which uses the syntax of read/display filters, rather than
that of capture filters) to be applied before printing the
output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;s</p></td>
<td width="3%"></td>
<td width="83%">


<p>Allows standard pcap files to be used as input, by
skipping over the 24 byte pcap file header.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;S</p></td>
<td width="3%"></td>
<td width="83%">


<p>Use the specified format string to print each field. The
following formats are supported:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><b>%D</b> Field
name or description, e.g. &quot;Type&quot; for
dns.qry.type</p>

<p style="margin-left:17%; margin-top: 1em"><b>%N</b> Base
10 numeric value of the field.</p>

<p style="margin-left:17%; margin-top: 1em"><b>%S</b>
String value of the field.</p>

<p style="margin-left:17%; margin-top: 1em">For something
similar to Wireshark&rsquo;s standard display (&quot;Type: A
(1)&quot;) you could use <b>%D: %S (%N)</b>.</p>

<p style="margin-left:11%;">&minus;t ad|a|r|d|e</p>

<p style="margin-left:17%;">Set the format of the packet
timestamp printed in summary lines, the default is relative.
The format can be one of:</p>

<p style="margin-left:17%; margin-top: 1em"><b>ad</b>
absolute with date: The absolute date and time is the actual
time and date the packet was captured</p>

<p style="margin-left:17%; margin-top: 1em"><b>a</b>
absolute: The absolute time is the actual time the packet
was captured, with no date displayed</p>

<p style="margin-left:17%; margin-top: 1em"><b>r</b>
relative: The relative time is the time elapsed between the
first packet and the current packet</p>

<p style="margin-left:17%; margin-top: 1em"><b>d</b> delta:
The delta time is the time since the previous packet was
captured</p>

<p style="margin-left:17%; margin-top: 1em"><b>e</b> epoch:
The time in seconds since epoch (Jan 1, 1970 00:00:00)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;v</p></td>
<td width="3%"></td>
<td width="41%">


<p>Print the version and exit.</p></td>
<td width="42%">
</td></tr>
</table>

<h2>READ FILTER SYNTAX
<a name="READ FILTER SYNTAX"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For a complete
table of protocol and protocol fields that are filterable in
<b>TShark</b> see the <i>wireshark&minus;filter</i>(4)
manual page.</p>

<h2>FILES
<a name="FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These files
contains various <b>Wireshark</b> configuration values. <br>
Preferences</p>

<p style="margin-left:17%;">The <i>preferences</i> files
contain global (system-wide) and personal preference
settings. If the system-wide preference file exists, it is
read first, overriding the default settings. If the personal
preferences file exists, it is read next, overriding any
previous values. Note: If the command line option
<b>&minus;o</b> is used (possibly more than once), it will
in turn override values from the preferences files.</p>

<p style="margin-left:17%; margin-top: 1em">The preferences
settings are in the form
<i>prefname</i><b>:</b><i>value</i>, one per line, where
<i>prefname</i> is the name of the preference and
<i>value</i> is the value to which it should be set; white
space is allowed between <b>:</b> and <i>value</i>. A
preference setting can be continued on subsequent lines by
indenting the continuation lines with white space. A
<b>#</b> character starts a comment that runs to the end of
the line:</p>

<pre style="margin-left:17%; margin-top: 1em">  # Capture in promiscuous mode?
  # TRUE or FALSE (case&minus;insensitive).
  capture.prom_mode: TRUE</pre>


<p style="margin-left:17%; margin-top: 1em">The global
preferences file is looked for in the <i>wireshark</i>
directory under the <i>share</i> subdirectory of the main
installation directory (for example,
<i>/usr/local/share/wireshark/preferences</i>) on
UNIX-compatible systems, and in the main installation
directory (for example, <i>C:\Program
Files\Wireshark\preferences</i>) on Windows systems.</p>

<p style="margin-left:17%; margin-top: 1em">The personal
preferences file is looked for in
<i>$HOME/.wireshark/preferences</i> on UNIX-compatible
systems and <i>%APPDATA%\Wireshark\preferences</i> (or, if
<tt>%APPDATA</tt>% isn&rsquo;t defined,
<i>%USERPROFILE%\Application Data\Wireshark\preferences</i>)
on Windows systems.</p>

<p style="margin-left:11%;">Disabled (Enabled)
Protocols</p>

<p style="margin-left:17%;">The <i>disabled_protos</i>
files contain system-wide and personal lists of protocols
that have been disabled, so that their dissectors are never
called. The files contain protocol names, one per line,
where the protocol name is the same name that would be used
in a display filter for the protocol:</p>

<pre style="margin-left:17%; margin-top: 1em">  http
  tcp     # a comment</pre>


<p style="margin-left:17%; margin-top: 1em">The global
<i>disabled_protos</i> file uses the same directory as the
global preferences file.</p>

<p style="margin-left:17%; margin-top: 1em">The personal
<i>disabled_protos</i> file uses the same directory as the
personal preferences file.</p>

<p style="margin-left:11%;">Name Resolution (hosts)</p>

<p style="margin-left:17%;">If the personal <i>hosts</i>
file exists, it is used to resolve IPv4 and IPv6 addresses
before any other attempts are made to resolve them. The file
has the standard <i>hosts</i> file syntax; each line
contains one <small>IP</small> address and name, separated
by whitespace. The same directory as for the personal
preferences file is used.</p>

<p style="margin-left:17%; margin-top: 1em">Capture filter
name resolution is handled by libpcap on UNIX-compatible
systems and WinPcap on Windows. As such the Wireshark
personal <i>hosts</i> file will not be consulted for capture
filter name resolution.</p>

<p style="margin-left:11%;">Name Resolution (ethers)</p>

<p style="margin-left:17%;">The <i>ethers</i> files are
consulted to correlate 6&minus;byte hardware addresses to
names. First the personal <i>ethers</i> file is tried and if
an address is not found there the global <i>ethers</i> file
is tried next.</p>

<p style="margin-left:17%; margin-top: 1em">Each line
contains one hardware address and name, separated by
whitespace. The digits of the hardware address are separated
by colons (:), dashes (&minus;) or periods (.). The same
separator character must be used consistently in an address.
The following three lines are valid lines of an
<i>ethers</i> file:</p>

<pre style="margin-left:17%; margin-top: 1em">  ff:ff:ff:ff:ff:ff          Broadcast
  c0&minus;00&minus;ff&minus;ff&minus;ff&minus;ff          TR_broadcast
  00.00.00.00.00.00          Zero_broadcast</pre>


<p style="margin-left:17%; margin-top: 1em">The global
<i>ethers</i> file is looked for in the <i>/etc</i>
directory on UNIX-compatible systems, and in the main
installation directory (for example, <i>C:\Program
Files\Wireshark</i>) on Windows systems.</p>

<p style="margin-left:17%; margin-top: 1em">The personal
<i>ethers</i> file is looked for in the same directory as
the personal preferences file.</p>

<p style="margin-left:17%; margin-top: 1em">Capture filter
name resolution is handled by libpcap on UNIX-compatible
systems and WinPcap on Windows. As such the Wireshark
personal <i>ethers</i> file will not be consulted for
capture filter name resolution.</p>

<p style="margin-left:11%;">Name Resolution (manuf)</p>

<p style="margin-left:17%;">The <i>manuf</i> file is used
to match the 3&minus;byte vendor portion of a 6&minus;byte
hardware address with the manufacturer&rsquo;s name; it can
also contain well-known <small>MAC</small> addresses and
address ranges specified with a netmask. The format of the
file is the same as the <i>ethers</i> files, except that
entries of the form:</p>

<pre style="margin-left:17%; margin-top: 1em">  00:00:0C      Cisco</pre>


<p style="margin-left:17%; margin-top: 1em">can be
provided, with the 3&minus;byte <small>OUI</small> and the
name for a vendor, and entries such as:</p>

<pre style="margin-left:17%; margin-top: 1em">  00&minus;00&minus;0C&minus;07&minus;AC/40     All&minus;HSRP&minus;routers</pre>


<p style="margin-left:17%; margin-top: 1em">can be
specified, with a <small>MAC</small> address and a mask
indicating how many bits of the address must match. The
above entry, for example, has 40 significant bits, or 5
bytes, and would match addresses from
00&minus;00&minus;0C&minus;07&minus;AC&minus;00 through
00&minus;00&minus;0C&minus;07&minus;AC&minus;FF. The mask
need not be a multiple of 8.</p>

<p style="margin-left:17%; margin-top: 1em">The
<i>manuf</i> file is looked for in the same directory as the
global preferences file.</p>

<p style="margin-left:11%;">Name Resolution (ipxnets)</p>

<p style="margin-left:17%;">The <i>ipxnets</i> files are
used to correlate 4&minus;byte <small>IPX</small> network
numbers to names. First the global <i>ipxnets</i> file is
tried and if that address is not found there the personal
one is tried next.</p>

<p style="margin-left:17%; margin-top: 1em">The format is
the same as the <i>ethers</i> file, except that each address
is four bytes instead of six. Additionally, the address can
be represented as a single hexadecimal number, as is more
common in the <small>IPX</small> world, rather than four hex
octets. For example, these four lines are valid lines of an
<i>ipxnets</i> file:</p>

<pre style="margin-left:17%; margin-top: 1em">  C0.A8.2C.00              HR
  c0&minus;a8&minus;1c&minus;00              CEO
  00:00:BE:EF              IT_Server1
  110f                     FileServer3</pre>


<p style="margin-left:17%; margin-top: 1em">The global
<i>ipxnets</i> file is looked for in the <i>/etc</i>
directory on UNIX-compatible systems, and in the main
installation directory (for example, <i>C:\Program
Files\Wireshark</i>) on Windows systems.</p>

<p style="margin-left:17%; margin-top: 1em">The personal
<i>ipxnets</i> file is looked for in the same directory as
the personal preferences file.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>WIRESHARK_DEBUG_EP_NO_CHUNKS</small></p>

<p style="margin-left:17%;">Normally per-packet memory is
allocated in large &quot;chunks.&quot; This behavior
doesn&rsquo;t work well with debugging tools such as
Valgrind or ElectricFence. Export this environment variable
to force individual allocations. Note: disabling chunks also
disables canaries (see below).</p>


<p style="margin-left:11%;"><small>WIRESHARK_DEBUG_SE_NO_CHUNKS</small></p>

<p style="margin-left:17%;">Normally per-file memory is
allocated in large &quot;chunks.&quot; This behavior
doesn&rsquo;t work well with debugging tools such as
Valgrind or ElectricFence. Export this environment variable
to force individual allocations. Note: disabling chunks also
disables canaries (see below).</p>


<p style="margin-left:11%;"><small>WIRESHARK_DEBUG_EP_NO_CANARY</small></p>

<p style="margin-left:17%;">Normally per-packet memory
allocations are separated by &quot;canaries&quot; which
allow detection of memory overruns. This comes at the
expense of some extra memory usage. Exporting this
environment variable disables these canaries.</p>


<p style="margin-left:11%;"><small>WIRESHARK_DEBUG_SE_USE_CANARY</small></p>

<p style="margin-left:17%;">Exporting this environment
variable causes per-file memory allocations to be protected
with &quot;canaries&quot; which allow for detection of
memory overruns. This comes at the expense of significant
extra memory usage.</p>


<p style="margin-left:11%;"><small>WIRESHARK_DEBUG_SCRUB_MEMORY</small></p>

<p style="margin-left:17%;">If this environment variable is
set, the contents of per-packet and per-file memory is
initialized to 0xBADDCAFE when the memory is allocated and
is reset to 0xDEADBEEF when the memory is freed. This
functionality is useful mainly to developers looking for
bugs in the way memory is handled.</p>


<p style="margin-left:11%;"><small>WIRESHARK_DEBUG_WMEM_OVERRIDE</small></p>

<p style="margin-left:17%;">Setting this environment
variable forces the wmem framework to use the specified
allocator backend for *all* allocations, regardless of which
backend is normally specified by the code. This is mainly
useful to developers when testing or debugging. See
<i><small>README</small> .wmem</i> in the source
distribution for details.</p>


<p style="margin-left:11%;"><small>WIRESHARK_RUN_FROM_BUILD_DIRECTORY</small></p>

<p style="margin-left:17%;">This environment variable
causes the plugins and other data files to be loaded from
the build directory (where the program was compiled) rather
than from the standard locations. It has no effect when the
program in question is running with root (or setuid)
permissions on *NIX.</p>


<p style="margin-left:11%;"><small>WIRESHARK_DATA_DIR</small></p>

<p style="margin-left:17%;">This environment variable
causes the various data files to be loaded from a directory
other than the standard locations. It has no effect when the
program in question is running with root (or setuid)
permissions on *NIX.</p>


<p style="margin-left:11%;"><small>WIRESHARK_PYTHON_DIR</small></p>

<p style="margin-left:17%;">This environment variable
points to an alternate location for Python. It has no effect
when the program in question is running with root (or
setuid) permissions on *NIX.</p>


<p style="margin-left:11%;"><small>ERF_RECORDS_TO_CHECK</small></p>

<p style="margin-left:17%;">This environment variable
controls the number of <small>ERF</small> records checked
when deciding if a file really is in the <small>ERF</small>
format. Setting this environment variable a number higher
than the default (20) would make false positives less
likely.</p>


<p style="margin-left:11%;"><small>IPFIX_RECORDS_TO_CHECK</small></p>

<p style="margin-left:17%;">This environment variable
controls the number of <small>IPFIX</small> records checked
when deciding if a file really is in the
<small>IPFIX</small> format. Setting this environment
variable a number higher than the default (20) would make
false positives less likely.</p>


<p style="margin-left:11%;"><small>WIRESHARK_ABORT_ON_DISSECTOR_BUG</small></p>

<p style="margin-left:17%;">If this environment variable is
set, <b>Rawshark</b> will call <i>abort</i>(3) when a
dissector bug is encountered. <i>abort</i>(3) will cause the
program to exit abnormally; if you are running
<b>Rawshark</b> in a debugger, it should halt in the
debugger and allow inspection of the process, and, if you
are not running it in a debugger, it will, on some OSes,
assuming your environment is configured correctly, generate
a core dump file. This can be useful to developers
attempting to troubleshoot a problem with a protocol
dissector.</p>


<p style="margin-left:11%;"><small>WIRESHARK_EP_VERIFY_POINTERS</small></p>

<p style="margin-left:17%;">This environment variable, if
set, causes certain uses of pointers to be audited to ensure
they do not point to memory that is deallocated after each
packet has been fully dissected. This can be useful to
developers writing or auditing code.</p>


<p style="margin-left:11%;"><small>WIRESHARK_SE_VERIFY_POINTERS</small></p>

<p style="margin-left:17%;">This environment variable, if
set, causes certain uses of pointers to be audited to ensure
they do not point to memory that is deallocated after when a
capture file is closed. This can be useful to developers
writing or auditing code.</p>


<p style="margin-left:11%;"><small>WIRESHARK_ABORT_ON_OUT_OF_MEMORY</small></p>

<p style="margin-left:17%;">This environment variable, if
present, causes <i>abort</i>(3) to be called if certain
out-of-memory conditions (which normally result in an
exception and an explanatory error message) are experienced.
This can be useful to developers debugging out-of-memory
conditions.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>wireshark&minus;filter</i>(4),
<i>wireshark</i>(1), <i>tshark</i>(1), <i>editcap</i>(1),
<i>pcap</i>(3), <i>dumpcap</i>(1), <i>text2pcap</i>(1),
<i>pcap&minus;filter</i>(7) or <i>tcpdump</i>(8)</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Rawshark</b>
is part of the <b>Wireshark</b> distribution. The latest
version of <b>Wireshark</b> can be found at
&lt;http://www.wireshark.org&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><small>HTML</small>
versions of the Wireshark project man pages are available
at:
&lt;http://www.wireshark.org/docs/man&minus;pages&gt;.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Rawshark</b>
uses the same packet dissection code that <b>Wireshark</b>
does, as well as using many other modules from
<b>Wireshark</b>; see the list of authors in the
<b>Wireshark</b> man page for a list of authors of that
code.</p>
<hr>
</body>
</html>
