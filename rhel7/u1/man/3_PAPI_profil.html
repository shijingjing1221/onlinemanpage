<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:10:27 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PAPI_profil</title>

</head>
<body>

<h1 align="center">PAPI_profil</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">PAPI_profil
&minus;</p>

<p style="margin-left:11%; margin-top: 1em">Generate a
histogram of hardware counter overflows vs. PC
addresses.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>C
Interface:</b></p>

<p style="margin-left:17%;">#include &lt;<b>papi.h</b>&gt;
<br>
int <b>PAPI_profil</b>(void *buf, unsigned bufsiz, unsigned
long offset, unsigned scale, int EventSet, int EventCode,
int threshold, int flags );</p>

<p style="margin-left:11%; margin-top: 1em"><b>Fortran
Interface</b></p>

<p style="margin-left:17%;">The profiling routines have no
Fortran interface.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>*buf</i> -- pointer to a
buffer of bufsiz bytes in which the histogram counts are
stored in an array of unsigned short, unsigned int, or
unsigned long long values, or &rsquo;buckets&rsquo;. The
size of the buckets is determined by values in the flags
argument. <i><br>
bufsiz</i> -- the size of the histogram buffer in bytes. It
is computed from the length of the code region to be
profiled, the size of the buckets, and the scale factor as
discussed above. <i><br>
offset</i> -- the start address of the region to be
profiled. <i><br>
scale</i> -- broadly and historically speaking, a
contraction factor that indicates how much smaller the
histogram buffer is than the region to be profiled. More
precisely, scale is interpreted as an unsigned 16-bit
fixed-point fraction with the decimal point implied on the
left. Its value is the reciprocal of the number of addresses
in a subdivision, per counter of histogram buffer. Below is
a table of representative values for scale. <i><br>
EventSet</i> -- The PAPI EventSet to profile. This EventSet
is marked as profiling-ready, but profiling doesn&rsquo;t
actually start until a <b>PAPI_start()</b> call is issued.
<i><br>
EventCode</i> -- Code of the Event in the EventSet to
profile. This event must already be a member of the
EventSet. <i><br>
threshold</i> -- minimum number of events that must occur
before the PC is sampled. If hardware overflow is supported
for your component, this threshold will trigger an interrupt
when reached. Otherwise, the counters will be sampled
periodically and the PC will be recorded for the first
sample that exceeds the threshold. If the value of threshold
is 0, profiling will be disabled for this event. <i><br>
flags</i> -- bit pattern to control profiling behavior.
Defined values are shown in the table above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
values:</b></p>

<p style="margin-left:17%;"><i>PAPI_OK <br>
PAPI_EINVAL</i> One or more of the arguments is invalid.
<i><br>
PAPI_ENOMEM</i> Insufficient memory to complete the
operation. <i><br>
PAPI_ENOEVST</i> The EventSet specified does not exist.
<i><br>
PAPI_EISRUN</i> The EventSet is currently counting events.
<i><br>
PAPI_ECNFLCT</i> The underlying counter hardware can not
count this event and other events in the EventSet
simultaneously. <i><br>
PAPI_ENOEVNT</i> The PAPI preset is not available on the
underlying hardware.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PAPI_profil()</b>
provides hardware event statistics by profiling the
occurence of specified hardware counter events. It is
designed to mimic the UNIX SVR4 profil call.</p>

<p style="margin-left:11%; margin-top: 1em">The statistics
are generated by creating a histogram of hardware counter
event overflows vs. program counter addresses for the
current process. The histogram is defined for a specific
region of program code to be profiled, and the identified
region is logically broken up into a set of equal size
subdivisions, each of which corresponds to a count in the
histogram.</p>

<p style="margin-left:11%; margin-top: 1em">With each
hardware event overflow, the current subdivision is
identified and its corresponding histogram count is
incremented. These counts establish a relative measure of
how many hardware counter events are occuring in each code
subdivision.</p>

<p style="margin-left:11%; margin-top: 1em">The resulting
histogram counts for a profiled region can be used to
identify those program addresses that generate a
disproportionately high percentage of the event of
interest.</p>

<p style="margin-left:11%; margin-top: 1em">Events to be
profiled are specified with the EventSet and EventCode
parameters. More than one event can be simultaneously
profiled by calling <b>PAPI_profil()</b> several times with
different EventCode values. Profiling can be turned off for
a given event by calling <b>PAPI_profil()</b> with a
threshold value of 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Representative
values for the scale variable</b></p>

<p style="margin-left:17%; margin-top: 1em">HEX DECIMAL
DEFININTION <br>
0x20000 131072 Maps precisely one instruction address to a
unique bucket in buf. <br>
0x10000 65536 Maps precisely two instruction addresses to a
unique bucket in buf. <br>
0x0FFFF 65535 Maps approximately two instruction addresses
to a unique bucket in buf. <br>
0x08000 32768 Maps every four instruction addresses to a
bucket in buf. <br>
0x04000 16384 Maps every eight instruction addresses to a
bucket in buf. <br>
0x00002 2 Maps all instruction addresses to the same bucket
in buf. <br>
0x00001 1 Undefined. <br>
0x00000 0 Undefined.</p>

<p style="margin-left:11%; margin-top: 1em">Historically,
the scale factor was introduced to allow the allocation of
buffers smaller than the code size to be profiled. Data and
instruction sizes were assumed to be multiples of 16-bits.
These assumptions are no longer necessarily true.
<b>PAPI_profil()</b> has preserved the traditional
definition of scale where appropriate, but deprecated the
definitions for 0 and 1 (disable scaling) and extended the
range of scale to include 65536 and 131072 to allow for
exactly two addresses and exactly one address per profiling
bucket.</p>

<p style="margin-left:11%; margin-top: 1em">The value of
bufsiz is computed as follows:</p>

<p style="margin-left:11%; margin-top: 1em">bufsiz = (end -
start)*(bucket_size/2)*(scale/65536) where</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>bufsiz - the size of the buffer in bytes</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>end, start - the ending and starting addresses of the
profiled region</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>bucket_size - the size of each bucket in bytes; 2, 4, or
8 as defined in flags</p></td></tr>
</table>

<p style="margin-left:11%;"><b>Defined bits for the flags
variable:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em">PAPI_PROFIL_POSIX Default type
of profiling, similar to profil (3).</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_RANDOM Drop a random 25% of the samples.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_WEIGHTED Weight the samples by their
value.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_COMPRESS Ignore samples as values in the
hash buckets get big.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_BUCKET_16 Use unsigned short (16 bit)
buckets, This is the default bucket.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_BUCKET_32 Use unsigned int (32 bit)
buckets.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_BUCKET_64 Use unsigned long long (64 bit)
buckets.</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>PAPI_PROFIL_FORCE_SW Force software overflow in
profiling.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<p style="margin-left:17%; margin-top: 1em">* int retval;
<br>
* unsigned long length; <br>
* PAPI_exe_info_t *prginfo; <br>
* unsigned short *profbuf; <br>
* <br>
* if ((prginfo = PAPI_get_executable_info()) == NULL) <br>
* handle_error(1); <br>
* <br>
* length = (unsigned long)(prginfo-&gt;text_end -
prginfo-&gt;text_start); <br>
* <br>
* profbuf = (unsigned short *)malloc(length); <br>
* if (profbuf == NULL) <br>
* handle_error(1); <br>
* memset(profbuf,0x00,length); <br>
* <br>
* if ((retval = PAPI_profil(profbuf, length, start, 65536,
EventSet, <br>
* PAPI_FP_INS, 1000000, PAPI_PROFIL_POSIX |
PAPI_PROFIL_BUCKET_16)) <br>
* != PAPI_OK) <br>
* handle_error(retval); <br>
*</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
Also:</b></p>

<p style="margin-left:17%;"><b>PAPI_overflow <br>
PAPI_sprofil</b></p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%;">Generated automatically by
Doxygen for PAPI from the source code.</p>
<hr>
</body>
</html>
