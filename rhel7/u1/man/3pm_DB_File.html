<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:34:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DB_File</title>

</head>
<body>

<h1 align="center">DB_File</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#DB_HASH">DB_HASH</a><br>
<a href="#DB_BTREE">DB_BTREE</a><br>
<a href="#DB_RECNO">DB_RECNO</a><br>
<a href="#THE API INTERFACE">THE API INTERFACE</a><br>
<a href="#DBM FILTERS">DBM FILTERS</a><br>
<a href="#HINTS AND TIPS">HINTS AND TIPS</a><br>
<a href="#COMMON QUESTIONS">COMMON QUESTIONS</a><br>
<a href="#REFERENCES">REFERENCES</a><br>
<a href="#HISTORY">HISTORY</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AVAILABILITY">AVAILABILITY</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DB_File &minus;
Perl5 access to Berkeley DB version 1.x</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> use DB_File;
 [$X =] tie %hash,  'DB_File', [$filename, $flags, $mode, $DB_HASH] ;
 [$X =] tie %hash,  'DB_File', $filename, $flags, $mode, $DB_BTREE ;
 [$X =] tie @array, 'DB_File', $filename, $flags, $mode, $DB_RECNO ;
 $status = $X&minus;&gt;del($key [, $flags]) ;
 $status = $X&minus;&gt;put($key, $value [, $flags]) ;
 $status = $X&minus;&gt;get($key, $value [, $flags]) ;
 $status = $X&minus;&gt;seq($key, $value, $flags) ;
 $status = $X&minus;&gt;sync([$flags]) ;
 $status = $X&minus;&gt;fd ;
 # BTREE only
 $count = $X&minus;&gt;get_dup($key) ;
 @list  = $X&minus;&gt;get_dup($key) ;
 %list  = $X&minus;&gt;get_dup($key, 1) ;
 $status = $X&minus;&gt;find_dup($key, $value) ;
 $status = $X&minus;&gt;del_dup($key, $value) ;
 # RECNO only
 $a = $X&minus;&gt;length;
 $a = $X&minus;&gt;pop ;
 $X&minus;&gt;push(list);
 $a = $X&minus;&gt;shift;
 $X&minus;&gt;unshift(list);
 @r = $X&minus;&gt;splice(offset, length, elements);
 # DBM Filters
 $old_filter = $db&minus;&gt;filter_store_key  ( sub { ... } ) ;
 $old_filter = $db&minus;&gt;filter_store_value( sub { ... } ) ;
 $old_filter = $db&minus;&gt;filter_fetch_key  ( sub { ... } ) ;
 $old_filter = $db&minus;&gt;filter_fetch_value( sub { ... } ) ;
 untie %hash ;
 untie @array ;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>DB_File</b>
is a module which allows Perl programs to make use of the
facilities provided by Berkeley <small>DB</small> version
1.x (if you have a newer version of <small>DB,</small> see
&quot;Using DB_File with Berkeley <small>DB</small> version
2 or greater&quot;). It is assumed that you have a copy of
the Berkeley <small>DB</small> manual pages at hand when
reading this documentation. The interface defined here
mirrors the Berkeley <small>DB</small> interface
closely.</p>

<p style="margin-left:11%; margin-top: 1em">Berkeley
<small>DB</small> is a C library which provides a consistent
interface to a number of database formats. <b>DB_File</b>
provides an interface to all three of the database types
currently supported by Berkeley <small>DB.</small></p>

<p style="margin-left:11%; margin-top: 1em">The file types
are: <b><small><br>
DB_HASH</small></b></p>

<p style="margin-left:18%;">This database type allows
arbitrary key/value pairs to be stored in data files. This
is equivalent to the functionality provided by other hashing
packages like <small>DBM, NDBM, ODBM, GDBM,</small> and
<small>SDBM.</small> Remember though, the files created
using <small>DB_HASH</small> are not compatible with any of
the other packages mentioned.</p>

<p style="margin-left:18%; margin-top: 1em">A default
hashing algorithm, which will be adequate for most
applications, is built into Berkeley <small>DB.</small> If
you do need to use your own hashing algorithm it is possible
to write your own in Perl and have <b>DB_File</b> use it
instead.</p>


<p style="margin-left:11%;"><b><small>DB_BTREE</small></b></p>

<p style="margin-left:18%;">The btree format allows
arbitrary key/value pairs to be stored in a sorted, balanced
binary tree.</p>

<p style="margin-left:18%; margin-top: 1em">As with the
<small>DB_HASH</small> format, it is possible to provide a
user defined Perl routine to perform the comparison of keys.
By default, though, the keys are stored in lexical
order.</p>


<p style="margin-left:11%;"><b><small>DB_RECNO</small></b></p>

<p style="margin-left:18%;"><small>DB_RECNO</small> allows
both fixed-length and variable-length flat text files to be
manipulated using the same key/value pair interface as in
<small>DB_HASH</small> and <small>DB_BTREE.</small> In this
case the key will consist of a record (line) number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
DB_File with Berkeley <small>DB</small> version 2 or
greater</b> <br>
Although <b>DB_File</b> is intended to be used with Berkeley
<small>DB</small> version 1, it can also be used with
version 2, 3 or 4. In this case the interface is limited to
the functionality provided by Berkeley <small>DB 1</small>
.x. Anywhere the version 2 or greater interface differs,
<b>DB_File</b> arranges for it to work like version 1. This
feature allows <b>DB_File</b> scripts that were built with
version 1 to be migrated to version 2 or greater without any
changes.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
make use of the new features available in Berkeley <small>DB
2</small> .x or greater, use the Perl module
<b>BerkeleyDB</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
The database file format has changed multiple times in
Berkeley <small>DB</small> version 2, 3 and 4. If you cannot
recreate your databases, you must dump any existing
databases with either the <tt>&quot;db_dump&quot;</tt> or
the <tt>&quot;db_dump185&quot;</tt> utility that comes with
Berkeley <small>DB.</small> Once you have rebuilt DB_File to
use Berkeley <small>DB</small> version 2 or greater, your
databases can be recreated using
<tt>&quot;db_load&quot;</tt>. Refer to the Berkeley
<small>DB</small> documentation for further details.</p>

<p style="margin-left:11%; margin-top: 1em">Please read
&quot; <small>COPYRIGHT&quot;</small> before using version
2.x or greater of Berkeley <small>DB</small> with
DB_File.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interface to
Berkeley <small>DB</small> <br>
DB_File</b> allows access to Berkeley <small>DB</small>
files using the <i>tie()</i> mechanism in Perl 5 (for full
details, see &quot;<i>tie()</i>&quot; in perlfunc). This
facility allows <b>DB_File</b> to access Berkeley
<small>DB</small> files using either an associative array
(for <small>DB_HASH &amp; DB_BTREE</small> file types) or an
ordinary array (for the <small>DB_RECNO</small> file
type).</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the <i>tie()</i> interface, it is also possible to access
most of the functions provided in the Berkeley <small>DB
API</small> directly. See &quot; <small>THE API
INTERFACE&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>Opening a
Berkeley <small>DB</small> Database File</b> <br>
Berkeley <small>DB</small> uses the function <i>dbopen()</i>
to open or create a database. Here is the C prototype for
<i>dbopen()</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">      DB*
      dbopen (const char * file, int flags, int mode,
              DBTYPE type, const void * openinfo)</pre>


<p style="margin-left:11%; margin-top: 1em">The parameter
<tt>&quot;type&quot;</tt> is an enumeration which specifies
which of the 3 interface methods ( <small>DB_HASH,
DB_BTREE</small> or <small>DB_RECNO</small> ) is to be used.
Depending on which of these is actually chosen, the final
parameter, <i>openinfo</i> points to a data structure which
allows tailoring of the specific interface method.</p>

<p style="margin-left:11%; margin-top: 1em">This interface
is handled slightly differently in <b>DB_File</b>. Here is
an equivalent call using <b>DB_File</b>:</p>

<pre style="margin-left:11%; margin-top: 1em">        tie %array, 'DB_File', $filename, $flags, $mode, $DB_HASH ;</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;filename&quot;</tt>, <tt>&quot;flags&quot;</tt>
and <tt>&quot;mode&quot;</tt> parameters are the direct
equivalent of their <i>dbopen()</i> counterparts. The final
parameter <tt>$DB_HASH</tt> performs the function of both
the <tt>&quot;type&quot;</tt> and
<tt>&quot;openinfo&quot;</tt> parameters in
<i>dbopen()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In the example
above <tt>$DB_HASH</tt> is actually a pre-defined reference
to a hash object. <b>DB_File</b> has three of these
pre-defined references. Apart from <tt>$DB_HASH</tt>, there
is also <tt>$DB_BTREE</tt> and <tt>$DB_RECNO</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The keys
allowed in each of these pre-defined references is limited
to the names used in the equivalent C structure. So, for
example, the <tt>$DB_HASH</tt> reference will only allow
keys called <tt>&quot;bsize&quot;</tt>,
<tt>&quot;cachesize&quot;</tt>,
<tt>&quot;ffactor&quot;</tt>, <tt>&quot;hash&quot;</tt>,
<tt>&quot;lorder&quot;</tt> and
<tt>&quot;nelem&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To change one
of these elements, just assign to it like this:</p>

<pre style="margin-left:11%; margin-top: 1em">        $DB_HASH&minus;&gt;{'cachesize'} = 10000 ;</pre>


<p style="margin-left:11%; margin-top: 1em">The three
predefined variables <tt>$DB_HASH</tt>, <tt>$DB_BTREE</tt>
and <tt>$DB_RECNO</tt> are usually adequate for most
applications. If you do need to create extra instances of
these objects, constructors are available for each file
type.</p>

<p style="margin-left:11%; margin-top: 1em">Here are
examples of the constructors and the valid options available
for <small>DB_HASH, DB_BTREE</small> and
<small>DB_RECNO</small> respectively.</p>

<pre style="margin-left:11%; margin-top: 1em">     $a = new DB_File::HASHINFO ;
     $a&minus;&gt;{'bsize'} ;
     $a&minus;&gt;{'cachesize'} ;
     $a&minus;&gt;{'ffactor'};
     $a&minus;&gt;{'hash'} ;
     $a&minus;&gt;{'lorder'} ;
     $a&minus;&gt;{'nelem'} ;
     $b = new DB_File::BTREEINFO ;
     $b&minus;&gt;{'flags'} ;
     $b&minus;&gt;{'cachesize'} ;
     $b&minus;&gt;{'maxkeypage'} ;
     $b&minus;&gt;{'minkeypage'} ;
     $b&minus;&gt;{'psize'} ;
     $b&minus;&gt;{'compare'} ;
     $b&minus;&gt;{'prefix'} ;
     $b&minus;&gt;{'lorder'} ;
     $c = new DB_File::RECNOINFO ;
     $c&minus;&gt;{'bval'} ;
     $c&minus;&gt;{'cachesize'} ;
     $c&minus;&gt;{'psize'} ;
     $c&minus;&gt;{'flags'} ;
     $c&minus;&gt;{'lorder'} ;
     $c&minus;&gt;{'reclen'} ;
     $c&minus;&gt;{'bfname'} ;</pre>


<p style="margin-left:11%; margin-top: 1em">The values
stored in the hashes above are mostly the direct equivalent
of their C counterpart. Like their C counterparts, all are
set to a default values &minus; that means you don&rsquo;t
have to set <i>all</i> of the values when you only want to
change one. Here is an example:</p>

<pre style="margin-left:11%; margin-top: 1em">     $a = new DB_File::HASHINFO ;
     $a&minus;&gt;{'cachesize'} =  12345 ;
     tie %y, 'DB_File', &quot;filename&quot;, $flags, 0777, $a ;</pre>


<p style="margin-left:11%; margin-top: 1em">A few of the
options need extra discussion here. When used, the C
equivalent of the keys <tt>&quot;hash&quot;</tt>,
<tt>&quot;compare&quot;</tt> and <tt>&quot;prefix&quot;</tt>
store pointers to C functions. In <b>DB_File</b> these keys
are used to store references to Perl subs. Below are
templates for each of the subs:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub hash
    {
        my ($data) = @_ ;
        ...
        # return the hash value for $data
        return $hash ;
    }
    sub compare
    {
        my ($key, $key2) = @_ ;
        ...
        # return  0 if $key1 eq $key2
        #        &minus;1 if $key1 lt $key2
        #         1 if $key1 gt $key2
        return (&minus;1 , 0 or 1) ;
    }
    sub prefix
    {
        my ($key, $key2) = @_ ;
        ...
        # return number of bytes of $key2 which are
        # necessary to determine that it is greater than $key1
        return $bytes ;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">See
&quot;Changing the <small>BTREE</small> sort order&quot; for
an example of using the <tt>&quot;compare&quot;</tt>
template.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using the <small>DB_RECNO</small> interface and you intend
making use of <tt>&quot;bval&quot;</tt>, you should check
out &quot;The &rsquo;bval&rsquo; Option&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Default
Parameters</b> <br>
It is possible to omit some or all of the final 4 parameters
in the call to <tt>&quot;tie&quot;</tt> and let them take
default values. As <small>DB_HASH</small> is the most common
file format used, the call:</p>

<pre style="margin-left:11%; margin-top: 1em">    tie %A, &quot;DB_File&quot;, &quot;filename&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">is equivalent
to:</p>

<pre style="margin-left:11%; margin-top: 1em">    tie %A, &quot;DB_File&quot;, &quot;filename&quot;, O_CREAT|O_RDWR, 0666, $DB_HASH ;</pre>


<p style="margin-left:11%; margin-top: 1em">It is also
possible to omit the filename parameter as well, so the
call:</p>

<pre style="margin-left:11%; margin-top: 1em">    tie %A, &quot;DB_File&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">is equivalent
to:</p>

<pre style="margin-left:11%; margin-top: 1em">    tie %A, &quot;DB_File&quot;, undef, O_CREAT|O_RDWR, 0666, $DB_HASH ;</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;In
Memory Databases&quot; for a discussion on the use of
<tt>&quot;undef&quot;</tt> in place of a filename.</p>

<p style="margin-left:11%; margin-top: 1em"><b>In Memory
Databases</b> <br>
Berkeley <small>DB</small> allows the creation of in-memory
databases by using <small>NULL</small> (that is, a
<tt>&quot;(char *)0&quot;</tt> in C) in place of the
filename. <b>DB_File</b> uses <tt>&quot;undef&quot;</tt>
instead of <small>NULL</small> to provide this
functionality.</p>

<h2>DB_HASH
<a name="DB_HASH"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>DB_HASH</small> file format is probably the most
commonly used of the three file formats that <b>DB_File</b>
supports. It is also very straightforward to use.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Simple
Example</b> <br>
This example shows how to create a database, add key/value
pairs to the database, delete keys/value pairs and finally
how to enumerate the contents of the database.</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    our (%h, $k, $v) ;
    unlink &quot;fruit&quot; ;
    tie %h, &quot;DB_File&quot;, &quot;fruit&quot;, O_RDWR|O_CREAT, 0666, $DB_HASH
        or die &quot;Cannot open file 'fruit': $!\n&quot;;
    # Add a few key/value pairs to the file
    $h{&quot;apple&quot;} = &quot;red&quot; ;
    $h{&quot;orange&quot;} = &quot;orange&quot; ;
    $h{&quot;banana&quot;} = &quot;yellow&quot; ;
    $h{&quot;tomato&quot;} = &quot;red&quot; ;
    # Check for existence of a key
    print &quot;Banana Exists\n\n&quot; if $h{&quot;banana&quot;} ;
    # Delete a key/value pair.
    delete $h{&quot;apple&quot;} ;
    # print the contents of the file
    while (($k, $v) = each %h)
      { print &quot;$k &minus;&gt; $v\n&quot; }
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">here is the
output:</p>

<pre style="margin-left:11%; margin-top: 1em">    Banana Exists
    orange &minus;&gt; orange
    tomato &minus;&gt; red
    banana &minus;&gt; yellow</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
like ordinary associative arrays, the order of the keys
retrieved is in an apparently random order.</p>

<h2>DB_BTREE
<a name="DB_BTREE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>DB_BTREE</small> format is useful when you want to
store data in a given order. By default the keys will be
stored in lexical order, but as you will see from the
example shown in the next section, it is very easy to define
your own sorting function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Changing the
<small>BTREE</small> sort order</b> <br>
This script shows how to override the default sorting
algorithm that <small>BTREE</small> uses. Instead of using
the normal lexical ordering, a case insensitive compare
function will be used.</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my %h ;
    sub Compare
    {
        my ($key1, $key2) = @_ ;
        &quot;\L$key1&quot; cmp &quot;\L$key2&quot; ;
    }
    # specify the Perl sub that will do the comparison
    $DB_BTREE&minus;&gt;{'compare'} = \&amp;Compare ;
    unlink &quot;tree&quot; ;
    tie %h, &quot;DB_File&quot;, &quot;tree&quot;, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open file 'tree': $!\n&quot; ;
    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;
    # Delete
    delete $h{&quot;duck&quot;} ;
    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print &quot;$_\n&quot; }
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">Here is the
output from the code above.</p>

<pre style="margin-left:11%; margin-top: 1em">    mouse
    Smith
    Wall</pre>


<p style="margin-left:11%; margin-top: 1em">There are a few
point to bear in mind if you want to change the ordering in
a <small>BTREE</small> database:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>The new compare function must be specified when you
create the database.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>You cannot change the ordering once the database has
been created. Thus you must use the same compare function
every time you access the database.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Duplicate keys are entirely defined by the comparison
function. In the case-insensitive example above, the keys:
&rsquo; <small>KEY</small> &rsquo; and &rsquo;key&rsquo;
would be considered duplicates, and assigning to the second
one would overwrite the first. If duplicates are allowed for
(with the R_DUP flag discussed below), only a single copy of
duplicate keys is stored in the database
&minus;&minus;&minus; so (again with example above)
assigning three values to the keys: &rsquo;
<small>KEY</small> &rsquo;, &rsquo;Key&rsquo;, and
&rsquo;key&rsquo; would leave just the first key: &rsquo;
<small>KEY</small> &rsquo; in the database with three
values. For some situations this results in information
loss, so care should be taken to provide fully qualified
comparison functions when necessary. For example, the above
comparison routine could be modified to additionally compare
case-sensitively if two keys are equal in the case
insensitive comparison:</p></td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    sub compare {
        my($key1, $key2) = @_;
        lc $key1 cmp lc $key2 ||
        $key1 cmp $key2;
    }</pre>


<p style="margin-left:18%; margin-top: 1em">And now you
will only have duplicates when the keys themselves are truly
the same. (note: in versions of the db library prior to
about November 1996, such duplicate keys were retained so it
was possible to recover the original keys in sets of keys
that compared as equal).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Handling
Duplicate Keys</b> <br>
The <small>BTREE</small> file type optionally allows a
single key to be associated with an arbitrary number of
values. This option is enabled by setting the flags element
of <tt>$DB_BTREE</tt> to R_DUP when creating the
database.</p>

<p style="margin-left:11%; margin-top: 1em">There are some
difficulties in using the tied hash interface if you want to
manipulate a <small>BTREE</small> database with duplicate
keys. Consider this code:</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, %h) ;
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    # Enable duplicate records
    $DB_BTREE&minus;&gt;{'flags'} = R_DUP ;
    tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    # iterate through the associative array
    # and print each key/value pair.
    foreach (sort keys %h)
      { print &quot;$_  &minus;&gt; $h{$_}\n&quot; }
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">Here is the
output:</p>

<pre style="margin-left:11%; margin-top: 1em">    Smith   &minus;&gt; John
    Wall    &minus;&gt; Larry
    Wall    &minus;&gt; Larry
    Wall    &minus;&gt; Larry
    mouse   &minus;&gt; mickey</pre>


<p style="margin-left:11%; margin-top: 1em">As you can see
3 records have been successfully created with key
<tt>&quot;Wall&quot;</tt> &minus; the only thing is, when
they are retrieved from the database they <i>seem</i> to
have the same value, namely <tt>&quot;Larry&quot;</tt>. The
problem is caused by the way that the associative array
interface works. Basically, when the associative array
interface is used to fetch the value associated with a given
key, it will only ever retrieve the first value.</p>

<p style="margin-left:11%; margin-top: 1em">Although it may
not be immediately obvious from the code above, the
associative array interface can be used to write values with
duplicate keys, but it cannot be used to read them back from
the database.</p>

<p style="margin-left:11%; margin-top: 1em">The way to get
around this problem is to use the Berkeley <small>DB
API</small> method called <tt>&quot;seq&quot;</tt>. This
method allows sequential access to key/value pairs. See
&quot; <small>THE API INTERFACE&quot;</small> for details of
both the <tt>&quot;seq&quot;</tt> method and the
<small>API</small> in general.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
script above rewritten using the <tt>&quot;seq&quot;</tt>
<small>API</small> method.</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $status, $key, $value) ;
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    # Enable duplicate records
    $DB_BTREE&minus;&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    # iterate through the btree using seq
    # and print each key/value pair.
    $key = $value = 0 ;
    for ($status = $x&minus;&gt;seq($key, $value, R_FIRST) ;
         $status == 0 ;
         $status = $x&minus;&gt;seq($key, $value, R_NEXT) )
      {  print &quot;$key &minus;&gt; $value\n&quot; }
    undef $x ;
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">that
prints:</p>

<pre style="margin-left:11%; margin-top: 1em">    Smith   &minus;&gt; John
    Wall    &minus;&gt; Brick
    Wall    &minus;&gt; Brick
    Wall    &minus;&gt; Larry
    mouse   &minus;&gt; mickey</pre>


<p style="margin-left:11%; margin-top: 1em">This time we
have got all the key/value pairs, including the multiple
values associated with the key
<tt>&quot;Wall&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To make life
easier when dealing with duplicate keys, <b>DB_File</b>
comes with a few utility methods.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The</b>
<i>get_dup()</i> <b>Method</b> <br>
The <tt>&quot;get_dup&quot;</tt> method assists in reading
duplicate values from <small>BTREE</small> databases. The
method can take the following forms:</p>

<pre style="margin-left:11%; margin-top: 1em">    $count = $x&minus;&gt;get_dup($key) ;
    @list  = $x&minus;&gt;get_dup($key) ;
    %list  = $x&minus;&gt;get_dup($key, 1) ;</pre>


<p style="margin-left:11%; margin-top: 1em">In a scalar
context the method returns the number of values associated
with the key, <tt>$key</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In list
context, it returns all the values which match
<tt>$key</tt>. Note that the values will be returned in an
apparently random order.</p>

<p style="margin-left:11%; margin-top: 1em">In list
context, if the second parameter is present and evaluates
<small>TRUE,</small> the method returns an associative
array. The keys of the associative array correspond to the
values that matched in the <small>BTREE</small> and the
values of the array are a count of the number of times that
particular value occurred in the <small>BTREE.</small></p>

<p style="margin-left:11%; margin-top: 1em">So assuming the
database created above, we can use
<tt>&quot;get_dup&quot;</tt> like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE&minus;&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    my $cnt  = $x&minus;&gt;get_dup(&quot;Wall&quot;) ;
    print &quot;Wall occurred $cnt times\n&quot; ;
    my %hash = $x&minus;&gt;get_dup(&quot;Wall&quot;, 1) ;
    print &quot;Larry is there\n&quot; if $hash{'Larry'} ;
    print &quot;There are $hash{'Brick'} Brick Walls\n&quot; ;
    my @list = sort $x&minus;&gt;get_dup(&quot;Wall&quot;) ;
    print &quot;Wall =&gt;      [@list]\n&quot; ;
    @list = $x&minus;&gt;get_dup(&quot;Smith&quot;) ;
    print &quot;Smith =&gt;     [@list]\n&quot; ;
    @list = $x&minus;&gt;get_dup(&quot;Dog&quot;) ;
    print &quot;Dog =&gt;       [@list]\n&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">and it will
print:</p>

<pre style="margin-left:11%; margin-top: 1em">    Wall occurred 3 times
    Larry is there
    There are 2 Brick Walls
    Wall =&gt;     [Brick Brick Larry]
    Smith =&gt;    [John]
    Dog =&gt;      []</pre>


<p style="margin-left:11%; margin-top: 1em"><b>The</b>
<i>find_dup()</i> <b>Method</b></p>

<pre style="margin-left:11%;">    $status = $X&minus;&gt;find_dup($key, $value) ;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
checks for the existence of a specific key/value pair. If
the pair exists, the cursor is left pointing to the pair and
the method returns 0. Otherwise the method returns a
non-zero value.</p>

<p style="margin-left:11%; margin-top: 1em">Assuming the
database from the previous example:</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $found) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE&minus;&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    $found = ( $x&minus;&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Larry Wall is $found there\n&quot; ;
    $found = ( $x&minus;&gt;find_dup(&quot;Wall&quot;, &quot;Harry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Harry Wall is $found there\n&quot; ;
    undef $x ;
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">prints this</p>

<pre style="margin-left:11%; margin-top: 1em">    Larry Wall is  there
    Harry Wall is not there</pre>


<p style="margin-left:11%; margin-top: 1em"><b>The</b>
<i>del_dup()</i> <b>Method</b></p>

<pre style="margin-left:11%;">    $status = $X&minus;&gt;del_dup($key, $value) ;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
deletes a specific key/value pair. It returns 0 if they
exist and have been deleted successfully. Otherwise the
method returns a non-zero value.</p>

<p style="margin-left:11%; margin-top: 1em">Again assuming
the existence of the <tt>&quot;tree&quot;</tt> database</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $found) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE&minus;&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    $x&minus;&gt;del_dup(&quot;Wall&quot;, &quot;Larry&quot;) ;
    $found = ( $x&minus;&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Larry Wall is $found there\n&quot; ;
    undef $x ;
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">prints this</p>

<pre style="margin-left:11%; margin-top: 1em">    Larry Wall is not there</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Matching
Partial Keys</b> <br>
The <small>BTREE</small> interface has a feature which
allows partial keys to be matched. This functionality is
<i>only</i> available when the <tt>&quot;seq&quot;</tt>
method is used along with the R_CURSOR flag.</p>

<pre style="margin-left:11%; margin-top: 1em">    $x&minus;&gt;seq($key, $value, R_CURSOR) ;</pre>


<p style="margin-left:11%; margin-top: 1em">Here is the
relevant quote from the dbopen man page where it defines the
use of the R_CURSOR flag with seq:</p>

<pre style="margin-left:11%; margin-top: 1em">    Note, for the DB_BTREE access method, the returned key is not
    necessarily an exact match for the specified key. The returned key
    is the smallest key greater than or equal to the specified key,
    permitting partial key matches and range searches.</pre>


<p style="margin-left:11%; margin-top: 1em">In the example
script below, the <tt>&quot;match&quot;</tt> sub uses this
feature to find and print the first matching key/value pair
given a partial key.</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    use Fcntl ;
    my ($filename, $x, %h, $st, $key, $value) ;
    sub match
    {
        my $key = shift ;
        my $value = 0;
        my $orig_key = $key ;
        $x&minus;&gt;seq($key, $value, R_CURSOR) ;
        print &quot;$orig_key\t&minus;&gt; $key\t&minus;&gt; $value\n&quot; ;
    }
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'mouse'} = 'mickey' ;
    $h{'Wall'} = 'Larry' ;
    $h{'Walls'} = 'Brick' ;
    $h{'Smith'} = 'John' ;
    $key = $value = 0 ;
    print &quot;IN ORDER\n&quot; ;
    for ($st = $x&minus;&gt;seq($key, $value, R_FIRST) ;
         $st == 0 ;
         $st = $x&minus;&gt;seq($key, $value, R_NEXT) )
      {  print &quot;$key    &minus;&gt; $value\n&quot; }
    print &quot;\nPARTIAL MATCH\n&quot; ;
    match &quot;Wa&quot; ;
    match &quot;A&quot; ;
    match &quot;a&quot; ;
    undef $x ;
    untie %h ;</pre>


<p style="margin-left:11%; margin-top: 1em">Here is the
output:</p>

<pre style="margin-left:11%; margin-top: 1em">    IN ORDER
    Smith &minus;&gt; John
    Wall  &minus;&gt; Larry
    Walls &minus;&gt; Brick
    mouse &minus;&gt; mickey
    PARTIAL MATCH
    Wa &minus;&gt; Wall  &minus;&gt; Larry
    A  &minus;&gt; Smith &minus;&gt; John
    a  &minus;&gt; mouse &minus;&gt; mickey</pre>


<h2>DB_RECNO
<a name="DB_RECNO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>DB_RECNO</small>
provides an interface to flat text files. Both variable and
fixed length records are supported.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
make <small>RECNO</small> more compatible with Perl, the
array offset for all <small>RECNO</small> arrays begins at 0
rather than 1 as in Berkeley <small>DB.</small></p>

<p style="margin-left:11%; margin-top: 1em">As with normal
Perl arrays, a <small>RECNO</small> array can be accessed
using negative indexes. The index &minus;1 refers to the
last element of the array, &minus;2 the second last, and so
on. Attempting to access an element before the start of the
array will raise a fatal run-time error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
&rsquo;bval&rsquo; Option</b> <br>
The operation of the bval option warrants some discussion.
Here is the definition of bval from the Berkeley <small>DB
1.85</small> recno manual page:</p>

<pre style="margin-left:11%; margin-top: 1em">    The delimiting byte to be used to mark  the  end  of  a
    record for variable&minus;length records, and the pad charac&minus;
    ter for fixed&minus;length records.  If no  value  is  speci&minus;
    fied,  newlines  (``\n'')  are  used to mark the end of
    variable&minus;length records and  fixed&minus;length  records  are
    padded with spaces.</pre>


<p style="margin-left:11%; margin-top: 1em">The second
sentence is wrong. In actual fact bval will only default to
<tt>&quot;\n&quot;</tt> when the openinfo parameter in
dbopen is <small>NULL.</small> If a non-NULL openinfo
parameter is used at all, the value that happens to be in
bval will be used. That means you always have to specify
bval when making use of any of the options in the openinfo
parameter. This documentation error will be fixed in the
next release of Berkeley <small>DB.</small></p>

<p style="margin-left:11%; margin-top: 1em">That clarifies
the situation with regards Berkeley <small>DB</small>
itself. What about <b>DB_File</b>? Well, the behavior
defined in the quote above is quite useful, so
<b>DB_File</b> conforms to it.</p>

<p style="margin-left:11%; margin-top: 1em">That means that
you can specify other options (e.g. cachesize) and still
have bval default to <tt>&quot;\n&quot;</tt> for variable
length records, and space for fixed length records.</p>

<p style="margin-left:11%; margin-top: 1em">Also note that
the bval option only allows you to specify a single byte as
a delimiter.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Simple
Example</b> <br>
Here is a simple example that uses <small>RECNO</small> (if
you are using a version of Perl earlier than 5.004_57 this
example won&rsquo;t work -- see &quot;Extra
<small>RECNO</small> Methods&quot; for a workaround).</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my $filename = &quot;text&quot; ;
    unlink $filename ;
    my @h ;
    tie @h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_RECNO
        or die &quot;Cannot open file 'text': $!\n&quot; ;
    # Add a few key/value pairs to the file
    $h[0] = &quot;orange&quot; ;
    $h[1] = &quot;blue&quot; ;
    $h[2] = &quot;yellow&quot; ;
    push @h, &quot;green&quot;, &quot;black&quot; ;
    my $elements = scalar @h ;
    print &quot;The array contains $elements entries\n&quot; ;
    my $last = pop @h ;
    print &quot;popped $last\n&quot; ;
    unshift @h, &quot;white&quot; ;
    my $first = shift @h ;
    print &quot;shifted $first\n&quot; ;
    # Check for existence of a key
    print &quot;Element 1 Exists with value $h[1]\n&quot; if $h[1] ;
    # use a negative index
    print &quot;The last element is $h[&minus;1]\n&quot; ;
    print &quot;The 2nd last element is $h[&minus;2]\n&quot; ;
    untie @h ;</pre>


<p style="margin-left:11%; margin-top: 1em">Here is the
output from the script:</p>

<pre style="margin-left:11%; margin-top: 1em">    The array contains 5 entries
    popped black
    shifted white
    Element 1 Exists with value blue
    The last element is green
    The 2nd last element is yellow</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Extra
<small>RECNO</small> Methods</b> <br>
If you are using a version of Perl earlier than 5.004_57,
the tied array interface is quite limited. In the example
script above <tt>&quot;push&quot;</tt>,
<tt>&quot;pop&quot;</tt>, <tt>&quot;shift&quot;</tt>,
<tt>&quot;unshift&quot;</tt> or determining the array length
will not work with a tied array.</p>

<p style="margin-left:11%; margin-top: 1em">To make the
interface more useful for older versions of Perl, a number
of methods are supplied with <b>DB_File</b> to simulate the
missing array operations. All these methods are accessed via
the object returned from the tie call.</p>

<p style="margin-left:11%; margin-top: 1em">Here are the
methods: <b><br>
$X&minus;&gt;push(list) ;</b></p>

<p style="margin-left:18%;">Pushes the elements of
<tt>&quot;list&quot;</tt> to the end of the array.</p>

<p style="margin-left:11%;"><b>$value =</b>
<b><i>$X</i></b><b>&minus;&gt;pop ;</b></p>

<p style="margin-left:18%;">Removes and returns the last
element of the array.</p>

<p style="margin-left:11%;"><b>$X&minus;&gt;shift</b></p>

<p style="margin-left:18%;">Removes and returns the first
element of the array.</p>

<p style="margin-left:11%;"><b>$X&minus;&gt;unshift(list)
;</b></p>

<p style="margin-left:18%;">Pushes the elements of
<tt>&quot;list&quot;</tt> to the start of the array.</p>

<p style="margin-left:11%;"><b>$X&minus;&gt;length</b></p>

<p style="margin-left:18%;">Returns the number of elements
in the array.</p>

<p style="margin-left:11%;"><b>$X&minus;&gt;splice(offset,
length, elements);</b></p>

<p style="margin-left:18%;">Returns a splice of the
array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Another
Example</b> <br>
Here is a more complete example that makes use of some of
the methods described above. It also makes use of the
<small>API</small> interface directly (see &quot; <small>THE
API INTERFACE&quot;</small> ).</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    my (@h, $H, $file, $i) ;
    use DB_File ;
    use Fcntl ;
    $file = &quot;text&quot; ;
    unlink $file ;
    $H = tie @h, &quot;DB_File&quot;, $file, O_RDWR|O_CREAT, 0666, $DB_RECNO
        or die &quot;Cannot open file $file: $!\n&quot; ;
    # first create a text file to play with
    $h[0] = &quot;zero&quot; ;
    $h[1] = &quot;one&quot; ;
    $h[2] = &quot;two&quot; ;
    $h[3] = &quot;three&quot; ;
    $h[4] = &quot;four&quot; ;
    # Print the records in order.
    #
    # The length method is needed here because evaluating a tied
    # array in a scalar context does not return the number of
    # elements in the array.
    print &quot;\nORIGINAL\n&quot; ;
    foreach $i (0 .. $H&minus;&gt;length &minus; 1) {
        print &quot;$i: $h[$i]\n&quot; ;
    }
    # use the push &amp; pop methods
    $a = $H&minus;&gt;pop ;
    $H&minus;&gt;push(&quot;last&quot;) ;
    print &quot;\nThe last record was [$a]\n&quot; ;
    # and the shift &amp; unshift methods
    $a = $H&minus;&gt;shift ;
    $H&minus;&gt;unshift(&quot;first&quot;) ;
    print &quot;The first record was [$a]\n&quot; ;
    # Use the API to add a new record after record 2.
    $i = 2 ;
    $H&minus;&gt;put($i, &quot;Newbie&quot;, R_IAFTER) ;
    # and a new record before record 1.
    $i = 1 ;
    $H&minus;&gt;put($i, &quot;New One&quot;, R_IBEFORE) ;
    # delete record 3
    $H&minus;&gt;del(3) ;
    # now print the records in reverse order
    print &quot;\nREVERSE\n&quot; ;
    for ($i = $H&minus;&gt;length &minus; 1 ; $i &gt;= 0 ; &minus;&minus; $i)
      { print &quot;$i: $h[$i]\n&quot; }
    # same again, but use the API functions instead
    print &quot;\nREVERSE again\n&quot; ;
    my ($s, $k, $v)  = (0, 0, 0) ;
    for ($s = $H&minus;&gt;seq($k, $v, R_LAST) ;
             $s == 0 ;
             $s = $H&minus;&gt;seq($k, $v, R_PREV))
      { print &quot;$k: $v\n&quot; }
    undef $H ;
    untie @h ;</pre>


<p style="margin-left:11%; margin-top: 1em">and this is
what it outputs:</p>

<pre style="margin-left:11%; margin-top: 1em">    ORIGINAL
    0: zero
    1: one
    2: two
    3: three
    4: four
    The last record was [four]
    The first record was [zero]
    REVERSE
    5: last
    4: three
    3: Newbie
    2: one
    1: New One
    0: first
    REVERSE again
    5: last
    4: three
    3: Newbie
    2: one
    1: New One
    0: first</pre>


<p style="margin-left:11%; margin-top: 1em">Notes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Rather than iterating through the array, <tt>@h</tt>
like this:</p></td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    foreach $i (@h)</pre>


<p style="margin-left:18%; margin-top: 1em">it is necessary
to use either this:</p>

<pre style="margin-left:18%; margin-top: 1em">    foreach $i (0 .. $H&minus;&gt;length &minus; 1)</pre>


<p style="margin-left:18%; margin-top: 1em">or this:</p>

<pre style="margin-left:18%; margin-top: 1em">    for ($a = $H&minus;&gt;get($k, $v, R_FIRST) ;
         $a == 0 ;
         $a = $H&minus;&gt;get($k, $v, R_NEXT) )</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Notice that both times the
<tt>&quot;put&quot;</tt> method was used the record index
was specified using a variable, <tt>$i</tt>, rather than the
literal value itself. This is because
<tt>&quot;put&quot;</tt> will return the record number of
the inserted line via that parameter.</p></td></tr>
</table>

<h2>THE API INTERFACE
<a name="THE API INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As well as
accessing Berkeley <small>DB</small> using a tied hash or
array, it is also possible to make direct use of most of the
<small>API</small> functions defined in the Berkeley
<small>DB</small> documentation.</p>

<p style="margin-left:11%; margin-top: 1em">To do this you
need to store a copy of the object returned from the
tie.</p>

<pre style="margin-left:11%; margin-top: 1em">        $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">Once you have
done that, you can access the Berkeley <small>DB API</small>
functions as <b>DB_File</b> methods directly like this:</p>

<pre style="margin-left:11%; margin-top: 1em">        $db&minus;&gt;put($key, $value, R_NOOVERWRITE) ;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Important:</b>
If you have saved a copy of the object returned from
<tt>&quot;tie&quot;</tt>, the underlying database file will
<i>not</i> be closed until both the tied variable is untied
and all copies of the saved object are destroyed.</p>

<pre style="margin-left:11%; margin-top: 1em">    use DB_File ;
    $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot;
        or die &quot;Cannot tie filename: $!&quot; ;
    ...
    undef $db ;
    untie %hash ;</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;The
<i>untie()</i> Gotcha&quot; for more details.</p>

<p style="margin-left:11%; margin-top: 1em">All the
functions defined in dbopen are available except for
<i>close()</i> and <i>dbopen()</i> itself. The
<b>DB_File</b> method interface to the supported functions
have been implemented to mirror the way Berkeley
<small>DB</small> works whenever possible. In particular
note that:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">The methods return a status
value. All return 0 on success. All return &minus;1 to
signify an error and set <tt>$!</tt> to the exact error
code. The return code 1 generally (but not always) means
that the key specified did not exist in the database.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Other return
codes are defined. See below and in the Berkeley
<small>DB</small> documentation for details. The Berkeley
<small>DB</small> documentation should be used as the
definitive source.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Whenever a Berkeley
<small>DB</small> function returns data via one of its
parameters, the equivalent <b>DB_File</b> method does
exactly the same.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>If you are careful, it is possible to mix
<small>API</small> calls with the tied hash/array interface
in the same piece of code. Although only a few of the
methods used to implement the tied interface currently make
use of the cursor, you should always assume that the cursor
has been changed any time the tied hash/array interface is
used. As an example, this code will probably not do what you
expect:</p> </td></tr>
</table>

<pre style="margin-left:18%; margin-top: 1em">    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
        or die &quot;Cannot tie $filename: $!&quot; ;
    # Get the first key/value pair and set  the cursor
    $X&minus;&gt;seq($key, $value, R_FIRST) ;
    # this line will modify the cursor
    $count = scalar keys %x ;
    # Get the second key/value pair.
    # oops, it didn't, it got the last key/value pair!
    $X&minus;&gt;seq($key, $value, R_NEXT) ;</pre>


<p style="margin-left:18%; margin-top: 1em">The code above
can be rearranged to get around the problem, like this:</p>

<pre style="margin-left:18%; margin-top: 1em">    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
        or die &quot;Cannot tie $filename: $!&quot; ;
    # this line will modify the cursor
    $count = scalar keys %x ;
    # Get the first key/value pair and set  the cursor
    $X&minus;&gt;seq($key, $value, R_FIRST) ;
    # Get the second key/value pair.
    # worked this time.
    $X&minus;&gt;seq($key, $value, R_NEXT) ;</pre>


<p style="margin-left:11%; margin-top: 1em">All the
constants defined in dbopen for use in the flags parameters
in the methods defined below are also available. Refer to
the Berkeley <small>DB</small> documentation for the precise
meaning of the flags values.</p>

<p style="margin-left:11%; margin-top: 1em">Below is a list
of the methods available. <b><br>
$status =</b> <b><i>$X</i></b><b>&minus;&gt;get($key, $value
[, $flags]) ;</b></p>

<p style="margin-left:18%;">Given a key (<tt>$key</tt>)
this method reads the value associated with it from the
database. The value read from the database is returned in
the <tt>$value</tt> parameter.</p>

<p style="margin-left:18%; margin-top: 1em">If the key does
not exist the method returns 1.</p>

<p style="margin-left:18%; margin-top: 1em">No flags are
currently defined for this method.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$X</i></b><b>&minus;&gt;put($key, $value [, $flags])
;</b></p>

<p style="margin-left:18%;">Stores the key/value pair in
the database.</p>

<p style="margin-left:18%; margin-top: 1em">If you use
either the R_IAFTER or R_IBEFORE flags, the <tt>$key</tt>
parameter will have the record number of the inserted
key/value pair set.</p>

<p style="margin-left:18%; margin-top: 1em">Valid flags are
R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and
R_SETCURSOR.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$X</i></b><b>&minus;&gt;del($key [, $flags]) ;</b></p>

<p style="margin-left:18%;">Removes all key/value pairs
with key <tt>$key</tt> from the database.</p>

<p style="margin-left:18%; margin-top: 1em">A return code
of 1 means that the requested key was not in the
database.</p>

<p style="margin-left:18%; margin-top: 1em">R_CURSOR is the
only valid flag at present.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$X</i></b><b>&minus;&gt;fd ;</b></p>

<p style="margin-left:18%;">Returns the file descriptor for
the underlying database.</p>

<p style="margin-left:18%; margin-top: 1em">See
&quot;Locking: The Trouble with fd&quot; for an explanation
for why you should not use <tt>&quot;fd&quot;</tt> to lock
your database.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$X</i></b><b>&minus;&gt;seq($key, $value, $flags)
;</b></p>

<p style="margin-left:18%;">This interface allows
sequential retrieval from the database. See dbopen for full
details.</p>

<p style="margin-left:18%; margin-top: 1em">Both the
<tt>$key</tt> and <tt>$value</tt> parameters will be set to
the key/value pair read from the database.</p>

<p style="margin-left:18%; margin-top: 1em">The flags
parameter is mandatory. The valid flag values are R_CURSOR,
R_FIRST, R_LAST, R_NEXT and R_PREV.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$X</i></b><b>&minus;&gt;sync([$flags]) ;</b></p>

<p style="margin-left:18%;">Flushes any cached buffers to
disk.</p>

<p style="margin-left:18%; margin-top: 1em">R_RECNOSYNC is
the only valid flag at present.</p>

<h2>DBM FILTERS
<a name="DBM FILTERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<small>DBM</small> Filter is a piece of code that is be used
when you <i>always</i> want to make the same transformation
to all keys and/or values in a <small>DBM</small>
database.</p>

<p style="margin-left:11%; margin-top: 1em">There are four
methods associated with <small>DBM</small> Filters. All work
identically, and each is used to install (or uninstall) a
single <small>DBM</small> Filter. Each expects a single
parameter, namely a reference to a sub. The only difference
between them is the place that the filter is installed.</p>

<p style="margin-left:11%; margin-top: 1em">To summarise:
<b><br>
filter_store_key</b></p>

<p style="margin-left:18%;">If a filter has been installed
with this method, it will be invoked every time you write a
key to a <small>DBM</small> database.</p>

<p style="margin-left:11%;"><b>filter_store_value</b></p>

<p style="margin-left:18%;">If a filter has been installed
with this method, it will be invoked every time you write a
value to a <small>DBM</small> database.</p>

<p style="margin-left:11%;"><b>filter_fetch_key</b></p>

<p style="margin-left:18%;">If a filter has been installed
with this method, it will be invoked every time you read a
key from a <small>DBM</small> database.</p>

<p style="margin-left:11%;"><b>filter_fetch_value</b></p>

<p style="margin-left:18%;">If a filter has been installed
with this method, it will be invoked every time you read a
value from a <small>DBM</small> database.</p>

<p style="margin-left:11%; margin-top: 1em">You can use any
combination of the methods, from none, to all four.</p>

<p style="margin-left:11%; margin-top: 1em">All filter
methods return the existing filter, if present, or
<tt>&quot;undef&quot;</tt> in not.</p>

<p style="margin-left:11%; margin-top: 1em">To delete a
filter pass <tt>&quot;undef&quot;</tt> to it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
Filter</b> <br>
When each filter is called by Perl, a local copy of
<tt>$_</tt> will contain the key or value to be filtered.
Filtering is achieved by modifying the contents of
<tt>$_</tt>. The return code from the filter is ignored.</p>

<p style="margin-left:11%; margin-top: 1em"><b>An Example
-- the <small>NULL</small> termination problem.</b> <br>
Consider the following scenario. You have a
<small>DBM</small> database that you need to share with a
third-party C application. The C application assumes that
<i>all</i> keys and values are <small>NULL</small>
terminated. Unfortunately when Perl writes to
<small>DBM</small> databases it doesn&rsquo;t use
<small>NULL</small> termination, so your Perl application
will have to manage <small>NULL</small> termination itself.
When you write to the database you will have to use
something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $hash{&quot;$key\0&quot;} = &quot;$value\0&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">Similarly the
<small>NULL</small> needs to be taken into account when you
are considering the length of existing keys/values.</p>

<p style="margin-left:11%; margin-top: 1em">It would be
much better if you could ignore the <small>NULL</small>
terminations issue in the main application code and have a
mechanism that automatically added the terminating
<small>NULL</small> to all keys and values whenever you
write to the database and have them removed when you read
from the database. As I&rsquo;m sure you have already
guessed, this is a problem that <small>DBM</small> Filters
can fix very easily.</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my %hash ;
    my $filename = &quot;filt&quot; ;
    unlink $filename ;
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH
      or die &quot;Cannot open $filename: $!\n&quot; ;
    # Install DBM Filters
    $db&minus;&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;
    $db&minus;&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } ) ;
    $db&minus;&gt;filter_fetch_value( sub { s/\0$//    } ) ;
    $db&minus;&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } ) ;
    $hash{&quot;abc&quot;} = &quot;def&quot; ;
    my $a = $hash{&quot;ABC&quot;} ;
    # ...
    undef $db ;
    untie %hash ;</pre>


<p style="margin-left:11%; margin-top: 1em">Hopefully the
contents of each of the filters should be self-explanatory.
Both &quot;fetch&quot; filters remove the terminating
<small>NULL,</small> and both &quot;store&quot; filters add
a terminating <small>NULL.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Another
Example -- Key is a C int.</b> <br>
Here is another real-life example. By default, whenever Perl
writes to a <small>DBM</small> database it always writes the
key and value as strings. So when you use this:</p>

<pre style="margin-left:11%; margin-top: 1em">    $hash{12345} = &quot;something&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">the key 12345
will get stored in the <small>DBM</small> database as the 5
byte string &quot;12345&quot;. If you actually want the key
to be stored in the <small>DBM</small> database as a C int,
you will have to use <tt>&quot;pack&quot;</tt> when writing,
and <tt>&quot;unpack&quot;</tt> when reading.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
<small>DBM</small> Filter that does it:</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my %hash ;
    my $filename = &quot;filt&quot; ;
    unlink $filename ;
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH
      or die &quot;Cannot open $filename: $!\n&quot; ;
    $db&minus;&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } ) ;
    $db&minus;&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } ) ;
    $hash{123} = &quot;def&quot; ;
    # ...
    undef $db ;
    untie %hash ;</pre>


<p style="margin-left:11%; margin-top: 1em">This time only
two filters have been used -- we only need to manipulate the
contents of the key, so it wasn&rsquo;t necessary to install
any value filters.</p>

<h2>HINTS AND TIPS
<a name="HINTS AND TIPS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Locking: The
Trouble with fd</b> <br>
Until version 1.72 of this module, the recommended technique
for locking <b>DB_File</b> databases was to flock the
filehandle returned from the &quot;fd&quot; function.
Unfortunately this technique has been shown to be
fundamentally flawed (Kudos to David Harris for tracking
this down). Use it at your own peril!</p>

<p style="margin-left:11%; margin-top: 1em">The locking
technique went like this.</p>

<pre style="margin-left:11%; margin-top: 1em">    $db = tie(%db, 'DB_File', 'foo.db', O_CREAT|O_RDWR, 0644)
        || die &quot;dbcreat foo.db $!&quot;;
    $fd = $db&minus;&gt;fd;
    open(DB_FH, &quot;+&lt;&amp;=$fd&quot;) || die &quot;dup $!&quot;;
    flock (DB_FH, LOCK_EX) || die &quot;flock: $!&quot;;
    ...
    $db{&quot;Tom&quot;} = &quot;Jerry&quot; ;
    ...
    flock(DB_FH, LOCK_UN);
    undef $db;
    untie %db;
    close(DB_FH);</pre>


<p style="margin-left:11%; margin-top: 1em">In simple
terms, this is what happens:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="53%">


<p>Use &quot;tie&quot; to open the database.</p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="53%">


<p>Lock the database with fd &amp; flock.</p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="4%"></td>
<td width="53%">


<p>Read &amp; Write to the database.</p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="4%"></td>
<td width="53%">


<p>Unlock and close the database.</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here is the
crux of the problem. A side-effect of opening the
<b>DB_File</b> database in step 2 is that an initial block
from the database will get read from disk and cached in
memory.</p>

<p style="margin-left:11%; margin-top: 1em">To see why this
is a problem, consider what can happen when two processes,
say &quot;A&quot; and &quot;B&quot;, both want to update the
same <b>DB_File</b> database using the locking steps
outlined above. Assume process &quot;A&quot; has already
opened the database and has a write lock, but it
hasn&rsquo;t actually updated the database yet (it has
finished step 2, but not started step 3 yet). Now process
&quot;B&quot; tries to open the same database &minus; step 1
will succeed, but it will block on step 2 until process
&quot;A&quot; releases the lock. The important thing to
notice here is that at this point in time both processes
will have cached identical initial blocks from the
database.</p>

<p style="margin-left:11%; margin-top: 1em">Now process
&quot;A&quot; updates the database and happens to change
some of the data held in the initial buffer. Process
&quot;A&quot; terminates, flushing all cached data to disk
and releasing the database lock. At this point the database
on disk will correctly reflect the changes made by process
&quot;A&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">With the lock
released, process &quot;B&quot; can now continue. It also
updates the database and unfortunately it too modifies the
data that was in its initial buffer. Once that data gets
flushed to disk it will overwrite some/all of the changes
process &quot;A&quot; made to the database.</p>

<p style="margin-left:11%; margin-top: 1em">The result of
this scenario is at best a database that doesn&rsquo;t
contain what you expect. At worst the database will
corrupt.</p>

<p style="margin-left:11%; margin-top: 1em">The above
won&rsquo;t happen every time competing process update the
same <b>DB_File</b> database, but it does illustrate why the
technique should not be used.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Safe ways to
lock a database</b> <br>
Starting with version 2.x, Berkeley <small>DB</small> has
internal support for locking. The companion module to this
one, <b>BerkeleyDB</b>, provides an interface to this
locking functionality. If you are serious about locking
Berkeley <small>DB</small> databases, I strongly recommend
using <b>BerkeleyDB</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If using
<b>BerkeleyDB</b> isn&rsquo;t an option, there are a number
of modules available on <small>CPAN</small> that can be used
to implement locking. Each one implements locking
differently and has different goals in mind. It is therefore
worth knowing the difference, so that you can pick the right
one for your application. Here are the three locking
wrappers: <b><br>
Tie::DB_Lock</b></p>

<p style="margin-left:18%;">A <b>DB_File</b> wrapper which
creates copies of the database file for read access, so that
you have a kind of a multiversioning concurrent read system.
However, updates are still serial. Use for databases where
reads may be lengthy and consistency problems may occur.</p>

<p style="margin-left:11%;"><b>Tie::DB_LockFile</b></p>

<p style="margin-left:18%;">A <b>DB_File</b> wrapper that
has the ability to lock and unlock the database while it is
being used. Avoids the tie-before-flock problem by simply
re-tie-ing the database when you get or drop a lock. Because
of the flexibility in dropping and re-acquiring the lock in
the middle of a session, this can be massaged into a system
that will work with long updates and/or reads if the
application follows the hints in the <small>POD</small>
documentation.</p>

<p style="margin-left:11%;"><b>DB_File::Lock</b></p>

<p style="margin-left:18%;">An extremely lightweight
<b>DB_File</b> wrapper that simply flocks a lockfile before
tie-ing the database and drops the lock after the untie.
Allows one to use the same lockfile for multiple databases
to avoid deadlock problems, if desired. Use for databases
where updates are reads are quick and simple flock locking
semantics are enough.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Sharing
Databases With C Applications</b> <br>
There is no technical reason why a Berkeley
<small>DB</small> database cannot be shared by both a Perl
and a C application.</p>

<p style="margin-left:11%; margin-top: 1em">The vast
majority of problems that are reported in this area boil
down to the fact that C strings are <small>NULL</small>
terminated, whilst Perl strings are not. See &quot;
<small>DBM FILTERS&quot;</small> for a generic way to work
around this problem.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a real
example. Netscape 2.0 keeps a record of the locations you
visit along with the time you last visited them in a
<small>DB_HASH</small> database. This is usually stored in
the file <i>~/.netscape/history.db</i>. The key field in the
database is the location string and the value field is the
time the location was last visited stored as a 4 byte binary
value.</p>

<p style="margin-left:11%; margin-top: 1em">If you
haven&rsquo;t already guessed, the location string is stored
with a terminating <small>NULL.</small> This means you need
to be careful when accessing the database.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
snippet of code that is loosely based on Tom
Christiansen&rsquo;s <i>ggh</i> script (available from your
nearest <small>CPAN</small> archive in
<i>authors/id/TOMC/scripts/nshist.gz</i>).</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    use Fcntl ;
    my ($dotdir, $HISTORY, %hist_db, $href, $binary_time, $date) ;
    $dotdir = $ENV{HOME} || $ENV{LOGNAME};
    $HISTORY = &quot;$dotdir/.netscape/history.db&quot;;
    tie %hist_db, 'DB_File', $HISTORY
        or die &quot;Cannot open $HISTORY: $!\n&quot; ;;
    # Dump the complete database
    while ( ($href, $binary_time) = each %hist_db ) {
        # remove the terminating NULL
        $href =~ s/\x00$// ;
        # convert the binary time into a user friendly string
        $date = localtime unpack(&quot;V&quot;, $binary_time);
        print &quot;$date $href\n&quot; ;
    }
    # check for the existence of a specific key
    # remember to add the NULL
    if ( $binary_time = $hist_db{&quot;http://mox.perl.com/\x00&quot;} ) {
        $date = localtime unpack(&quot;V&quot;, $binary_time) ;
        print &quot;Last visited mox.perl.com on $date\n&quot; ;
    }
    else {
        print &quot;Never visited mox.perl.com\n&quot;
    }
    untie %hist_db ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>The</b>
<i>untie()</i> <b>Gotcha</b> <br>
If you make use of the Berkeley <small>DB API,</small> it is
<i>very</i> strongly recommended that you read &quot;The
untie Gotcha&quot; in perltie.</p>

<p style="margin-left:11%; margin-top: 1em">Even if you
don&rsquo;t currently make use of the <small>API</small>
interface, it is still worth reading it.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example which illustrates the problem from a <b>DB_File</b>
perspective:</p>

<pre style="margin-left:11%; margin-top: 1em">    use DB_File ;
    use Fcntl ;
    my %x ;
    my $X ;
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_TRUNC
        or die &quot;Cannot tie first time: $!&quot; ;
    $x{123} = 456 ;
    untie %x ;
    tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
        or die &quot;Cannot tie second time: $!&quot; ;
    untie %x ;</pre>


<p style="margin-left:11%; margin-top: 1em">When run, the
script will produce this error message:</p>

<pre style="margin-left:11%; margin-top: 1em">    Cannot tie second time: Invalid argument at bad.file line 14.</pre>


<p style="margin-left:11%; margin-top: 1em">Although the
error message above refers to the second <i>tie()</i>
statement in the script, the source of the problem is really
with the <i>untie()</i> statement that precedes it.</p>

<p style="margin-left:11%; margin-top: 1em">Having read
perltie you will probably have already guessed that the
error is caused by the extra copy of the tied object stored
in <tt>$X</tt>. If you haven&rsquo;t, then the problem boils
down to the fact that the <b>DB_File</b> destructor,
<small>DESTROY,</small> will not be called until <i>all</i>
references to the tied object are destroyed. Both the tied
variable, <tt>%x</tt>, and <tt>$X</tt> above hold a
reference to the object. The call to <i>untie()</i> will
destroy the first, but <tt>$X</tt> still holds a valid
reference, so the destructor will not get called and the
database file <i>tst.fil</i> will remain open. The fact that
Berkeley <small>DB</small> then reports the attempt to open
a database that is already open via the catch-all
&quot;Invalid argument&quot; doesn&rsquo;t help.</p>

<p style="margin-left:11%; margin-top: 1em">If you run the
script with the <tt>&quot;&minus;w&quot;</tt> flag the error
message becomes:</p>

<pre style="margin-left:11%; margin-top: 1em">    untie attempted while 1 inner references still exist at bad.file line 12.
    Cannot tie second time: Invalid argument at bad.file line 14.</pre>


<p style="margin-left:11%; margin-top: 1em">which pinpoints
the real problem. Finally the script can now be modified to
fix the original problem by destroying the
<small>API</small> object before the untie:</p>

<pre style="margin-left:11%; margin-top: 1em">    ...
    $x{123} = 456 ;
    undef $X ;
    untie %x ;
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
    ...</pre>


<h2>COMMON QUESTIONS
<a name="COMMON QUESTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Why is there
Perl source in my database?</b> <br>
If you look at the contents of a database file created by
DB_File, there can sometimes be part of a Perl script
included in it.</p>

<p style="margin-left:11%; margin-top: 1em">This happens
because Berkeley <small>DB</small> uses dynamic memory to
allocate buffers which will subsequently be written to the
database file. Being dynamic, the memory could have been
used for anything before <small>DB</small> malloced it. As
Berkeley <small>DB</small> doesn&rsquo;t clear the memory
once it has been allocated, the unused portions will contain
random junk. In the case where a Perl script gets written to
the database, the random junk will correspond to an area of
dynamic memory that happened to be used during the
compilation of the script.</p>

<p style="margin-left:11%; margin-top: 1em">Unless you
don&rsquo;t like the possibility of there being part of your
Perl scripts embedded in a database file, this is nothing to
worry about.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
store complex data structures with DB_File?</b> <br>
Although <b>DB_File</b> cannot do this directly, there is a
module which can layer transparently over <b>DB_File</b> to
accomplish this feat.</p>

<p style="margin-left:11%; margin-top: 1em">Check out the
<small>MLDBM</small> module, available on
<small>CPAN</small> in the directory
<i>modules/by&minus;module/MLDBM</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What does
&quot;Invalid Argument&quot; mean?</b> <br>
You will get this error message when one of the parameters
in the <tt>&quot;tie&quot;</tt> call is wrong. Unfortunately
there are quite a few parameters to get wrong, so it can be
difficult to figure out which one it is.</p>

<p style="margin-left:11%; margin-top: 1em">Here are a
couple of possibilities:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="79%">


<p>Attempting to reopen a database without closing it.</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="79%">


<p>Using the O_WRONLY flag.</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>What does
&quot;Bareword &rsquo;DB_File&rsquo; not allowed&quot;
mean?</b> <br>
You will encounter this particular error message when you
have the <tt>&quot;strict 'subs'&quot;</tt> pragma (or the
full strict pragma) in your script. Consider this
script:</p>

<pre style="margin-left:11%; margin-top: 1em">    use warnings ;
    use strict ;
    use DB_File ;
    my %x ;
    tie %x, DB_File, &quot;filename&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">Running it
produces the error in question:</p>

<pre style="margin-left:11%; margin-top: 1em">    Bareword &quot;DB_File&quot; not allowed while &quot;strict subs&quot; in use</pre>


<p style="margin-left:11%; margin-top: 1em">To get around
the error, place the word <tt>&quot;DB_File&quot;</tt> in
either single or double quotes, like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    tie %x, &quot;DB_File&quot;, &quot;filename&quot; ;</pre>


<p style="margin-left:11%; margin-top: 1em">Although it
might seem like a real pain, it is really worth the effort
of having a <tt>&quot;use strict&quot;</tt> in all your
scripts.</p>

<h2>REFERENCES
<a name="REFERENCES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Articles that
are either about <b>DB_File</b> or make use of it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em"><i>Full-Text Searching in
Perl</i>, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb&rsquo;s
Journal, Issue 295, January 1999, pp 34&minus;41</p></td></tr>
</table>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Moved to the
Changes file.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some older
versions of Berkeley <small>DB</small> had problems with
fixed length records using the <small>RECNO</small> file
format. This problem has been fixed since version 1.85 of
Berkeley <small>DB.</small></p>

<p style="margin-left:11%; margin-top: 1em">I am sure there
are bugs in the code. If you do find any, or can suggest any
enhancements, I would welcome your comments.</p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>DB_File</b>
comes with the standard Perl source distribution. Look in
the directory <i>ext/DB_File</i>. Given the amount of time
between releases of Perl the version that ships with Perl is
quite likely to be out of date, so the most recent version
can always be found on <small>CPAN</small> (see &quot;
<small>CPAN&quot;</small> in perlmodlib for details), in the
directory <i>modules/by&minus;module/DB_File</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This version of
<b>DB_File</b> will work with either version 1.x, 2.x or 3.x
of Berkeley <small>DB,</small> but is limited to the
functionality provided by version 1.</p>

<p style="margin-left:11%; margin-top: 1em">The official
web site for Berkeley <small>DB</small> is
<i>http://www.oracle.com/technology/products/berkeley&minus;db/db/index.html</i>.
All versions of Berkeley <small>DB</small> are available
there.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
Berkeley <small>DB</small> version 1 is available at your
nearest <small>CPAN</small> archive in
<i>src/misc/db.1.85.tar.gz</i>.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1995&minus;2012 Paul Marquess. All rights reserved. This
program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">Although
<b>DB_File</b> is covered by the Perl license, the library
it makes use of, namely Berkeley <small>DB,</small> is not.
Berkeley <small>DB</small> has its own copyright and its own
license. Please take the time to read it.</p>

<p style="margin-left:11%; margin-top: 1em">Here are a few
words taken from the Berkeley <small>DB FAQ</small> (at
<i>http://www.oracle.com/technology/products/berkeley&minus;db/db/index.html</i>)
regarding the license:</p>

<pre style="margin-left:11%; margin-top: 1em">    Do I have to license DB to use it in Perl scripts?
    No. The Berkeley DB license requires that software that uses
    Berkeley DB be freely redistributable. In the case of Perl, that
    software is Perl, and not your scripts. Any Perl scripts that you
    write are your property, including scripts that make use of
    Berkeley DB. Neither the Perl license nor the Berkeley DB license
    place any restriction on what you may do with them.</pre>


<p style="margin-left:11%; margin-top: 1em">If you are in
any doubt about the license situation, contact either the
Berkeley <small>DB</small> authors or the author of DB_File.
See &quot; <small>AUTHOR&quot;</small> for details.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perl,
<i>dbopen</i>(3), <i>hash</i>(3), <i>recno</i>(3),
<i>btree</i>(3), perldbmfilter</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The DB_File
interface was written by Paul Marquess
&lt;pmqs@cpan.org&gt;.</p>
<hr>
</body>
</html>
