<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:25:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>BLKPARSE</title>

</head>
<body>

<h1 align="center">BLKPARSE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#TRACE ACTIONS">TRACE ACTIONS</a><br>
<a href="#OUTPUT DESCRIPTION AND FORMATTING">OUTPUT DESCRIPTION AND FORMATTING</a><br>
<a href="#ACTION IDENTIFIERS">ACTION IDENTIFIERS</a><br>
<a href="#RWBS DESCRIPTION">RWBS DESCRIPTION</a><br>
<a href="#DEFAULT OUTPUT">DEFAULT OUTPUT</a><br>
<a href="#DEFAULT OUTPUT PER ACTION">DEFAULT OUTPUT PER ACTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#REPORTING BUGS">REPORTING BUGS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">blkparse
&minus; produce formatted output of event streams of block
devices</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>blkparse
[</b> <i>options</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>blkparse</i> utility will attempt to combine streams of
events for various devices on various CPUs, and produce a
formatted output of the event information. Specifically, it
will take the (machine-readable) output of the
<i>blktrace</i> utility and convert it to a nicely formatted
and human-readable form.</p>

<p style="margin-left:11%; margin-top: 1em">As with
<i>blktrace</i>, some details concerning <i>blkparse</i>
will help in understanding the command line options
presented below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="2%"></td>
<td width="86%">


<p>By default, <i>blkparse</i> expects to run in a
post-processing mode; one where the trace events have been
saved by a previous run of blktrace, and blkparse is
combining event streams and dumping formatted data.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">blkparse may be
run in a live manner concurrently with blktrace by
specifying <b>&minus;i &minus;</b> to blkparse, and
combining it with the live option for blktrace. An example
would be:</p>

<p style="margin-left:14%; margin-top: 1em">% blktrace
&minus;d /dev/sda &minus;o &minus; | blkparse &minus;i
&minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&minus;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">You can set how many blkparse
batches event reads via the <b>&minus;b</b> option, the
default is to handle events in batches of 512.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If you have saved event traces in blktrace with
different output names (via the <b>&minus;o</b> option to
blktrace), you must specify the same input name via the
<b>&minus;i</b> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The format of the output data can be controlled via the
<b>&minus;f</b> or <b>&minus;F</b> options &minus;&minus;
see OUTPUT DESCRIPTION AND FORMATTING for details.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">By default,
blkparse sends formatted data to standard output. This may
be changed via the <b>&minus;o</b> option, or text output
can be disabled via the <b>&minus;O</b> option. A merged
binary stream can be produced using the <b>&minus;d</b>
option.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&minus;A
<i>hex-mask</i> <br>
&minus;&minus;set-mask=<i>hex-mask</i></p>

<p style="margin-left:22%;">Set filter mask to
<i>hex-mask</i>, see blktrace (8) for masks</p>

<p style="margin-left:11%; margin-top: 1em">&minus;a
<i>mask</i> <br>
&minus;&minus;act-mask=<i>mask</i></p>

<p style="margin-left:22%;">Add <i>mask</i> to current
filter, see blktrace (8) for masks</p>

<p style="margin-left:11%; margin-top: 1em">&minus;D
<i>dir</i> <br>
&minus;&minus;input-directory=<i>dir</i></p>

<p style="margin-left:22%;">Prepend <i>dir</i> to input
file names</p>

<p style="margin-left:11%; margin-top: 1em">&minus;b
<i>batch</i> <br>
&minus;&minus;batch={batch}</p>

<p style="margin-left:22%;">Standard input read
batching</p>

<p style="margin-left:11%; margin-top: 1em">&minus;i
<i>file</i> <br>
&minus;&minus;input=<i>file</i></p>

<p style="margin-left:22%;">Specifies base name for input
files &minus;&minus; default is
<i>device</i>.blktrace.<i>cpu</i>.</p>

<p style="margin-left:22%; margin-top: 1em">As noted above,
specifying <b>&minus;i &minus;</b> runs in live mode with
blktrace (reading data from standard in).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;F
<i>typ,fmt</i> <br>
&minus;&minus;format=<i>typ,fmt</i> <br>
&minus;f <i>fmt</i> <br>
&minus;&minus;format&minus;spec=<i>fmt</i></p>

<p style="margin-left:22%;">Sets output format (See OUTPUT
DESCRIPTION AND FORMATTING for details.)</p>

<p style="margin-left:22%; margin-top: 1em">The &minus;f
form specifies a format for all events</p>

<p style="margin-left:22%; margin-top: 1em">The &minus;F
form allows one to specify a format for a specific event
type. The single&minus;character <i>typ</i> field is one of
the action specifiers described in ACTION IDENTIFIERS.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;M <br>
&minus;&minus;no-msgs</p>

<p style="margin-left:22%;">When &minus;d is specified,
this will stop messages from being output to the file. (Can
seriously reduce the size of the resultant file when using
the CFQ I/O scheduler.)</p>

<p style="margin-left:11%; margin-top: 1em">&minus;h <br>
&minus;&minus;hash&minus;by&minus;name</p>

<p style="margin-left:22%;">Hash processes by name, not by
PID</p>

<p style="margin-left:11%; margin-top: 1em">&minus;o
<i>file</i> <br>
&minus;&minus;output=<i>file</i></p>

<p style="margin-left:22%;">Output file</p>

<p style="margin-left:11%; margin-top: 1em">&minus;O <br>
&minus;&minus;no&minus;text&minus;output</p>

<p style="margin-left:22%;">Do <i>not</i> produce text
output, used for binary (<b>&minus;d</b>) only</p>

<p style="margin-left:11%; margin-top: 1em">&minus;d
<i>file</i> <br>
&minus;&minus;dump&minus;binary=<i>file</i></p>

<p style="margin-left:22%;">Binary output file</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q <br>
&minus;&minus;quiet</p>

<p style="margin-left:22%;">Quiet mode</p>

<p style="margin-left:11%; margin-top: 1em">&minus;s <br>
&minus;&minus;per&minus;program&minus;stats</p>

<p style="margin-left:22%;">Displays data sorted by
program</p>

<p style="margin-left:11%; margin-top: 1em">&minus;t <br>
&minus;&minus;track&minus;ios</p>

<p style="margin-left:22%;">Display time deltas per IO</p>

<p style="margin-left:11%; margin-top: 1em">&minus;w
<i>span</i> <br>
&minus;&minus;stopwatch=<i>span</i></p>

<p style="margin-left:22%;">Display traces for the
<i>span</i> specified &minus;&minus; where span can be:
<i><br>
end&minus;time</i> &minus;&minus; Display traces from time 0
through <i>end&minus;time</i> (in ns) <br>
or <i><br>
start:end&minus;time</i> &minus;&minus; Display traces from
time <i>start</i> through end&minus;time (in ns).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v <br>
&minus;&minus;verbose</p>

<p style="margin-left:22%;">More verbose marginal on
marginal errors</p>

<p style="margin-left:11%; margin-top: 1em">&minus;V <br>
&minus;&minus;version</p>

<p style="margin-left:22%;">Display version</p>

<h2>TRACE ACTIONS
<a name="TRACE ACTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
trace actions are recognised:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>C -- complete</b> A
previously issued request has been completed. The output
will detail the sector and size of that request, as well as
the success or failure of it.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>D -- issued</b> A request
that previously resided on the block layer queue or in the
i/o scheduler has been sent to the driver.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>I -- inserted</b> A request
is being sent to the i/o scheduler for addition to the
internal queue and later service by the driver. The request
is fully formed at this time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>Q -- queued</b> This notes
intent to queue i/o at the given location. No real requests
exists yet.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>B -- bounced</b> The data
pages attached to this <i>bio</i> are not reachable by the
hardware and must be bounced to a lower memory location.
This causes a big slowdown in i/o performance, since the
data must be copied to/from kernel buffers. Usually this can
be fixed with using better hardware -- either a better i/o
controller, or a platform with an IOMMU.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>M -- back merge</b> A
previously inserted request exists that ends on the boundary
of where this i/o begins, so the i/o scheduler can merge
them together.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>F -- front merge</b> Same as
the back merge, except this i/o ends where a previously
inserted requests starts.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>M --front or back merge</b>
One of the above</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>M -- front or back merge</b>
One of the above.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>G -- get request</b> To send
any type of request to a block device, a <i>struct
request</i> container must be allocated first.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>S -- sleep</b> No available
request structures were available, so the issuer has to wait
for one to be freed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>P -- plug</b> When i/o is
queued to a previously empty block device queue, Linux will
plug the queue in anticipation of future ios being added
before this data is needed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>U -- unplug</b> Some request
data already queued in the device, start sending requests to
the driver. This may happen automatically if a timeout
period has passed (see next entry) or if a number of
requests have been added to the queue.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>T -- unplug due to timer</b>
If nobody requests the i/o that was queued after plugging
the queue, Linux will automatically unplug it after a
defined period has passed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>X -- split</b> On raid or
device mapper setups, an incoming i/o may straddle a device
or internal zone and needs to be chopped up into smaller
pieces for service. This may indicate a performance problem
due to a bad setup of that raid/dm device, but may also just
be part of normal boundary conditions. dm is notably bad at
this and will clone lots of i/o.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>A -- remap</b> For stacked
devices, incoming i/o is remapped to device below it in the
i/o stack. The remap action details what exactly is being
remapped to what.</p></td></tr>
</table>

<h2>OUTPUT DESCRIPTION AND FORMATTING
<a name="OUTPUT DESCRIPTION AND FORMATTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The output from
blkparse can be tailored for specific use -- in particular,
to ease parsing of output, and/or limit output fields to
those the user wants to see. The data for fields which can
be output include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>a</b></p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Action, a (small) string (1 or 2
characters) -- see table below for more details</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>c</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>CPU id</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>C</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Command</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>d</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>RWBS field, a (small) string (1-3 characters) -- see
section below for more details</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>D</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>7-character string containing the major and minor
numbers of the event&rsquo;s device (separated by a
comma).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>e</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Error value</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>m</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Minor number of event&rsquo;s device.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>M</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Major number of event&rsquo;s device.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>n</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Number of blocks</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>N</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Number of bytes</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>p</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Process ID</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>P</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Display packet data &minus;&minus; series of hexadecimal
values</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>s</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Sequence numbers</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>S</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Sector number</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>t</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Time stamp (nanoseconds)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>T</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Time stamp (seconds)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>u</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Elapsed value in microseconds (<i>&minus;t</i> command
line option)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>U</b></p></td>
<td width="5%"></td>
<td width="83%">


<p>Payload unsigned integer</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
user can optionally specify field display width, and
optionally a left-aligned specifier. These precede field
specifiers, with a &rsquo;%&rsquo; character, followed by
the optional left-alignment specifier (&minus;) followed by
the width (a decimal number) and then the field.</p>

<p style="margin-left:11%; margin-top: 1em">Thus, to
specify the command in a 12-character field that is left
aligned:</p>

<p style="margin-left:11%; margin-top: 1em">&minus;f
&quot;%&minus;12C&quot;</p>

<h2>ACTION IDENTIFIERS
<a name="ACTION IDENTIFIERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
table shows the various actions which may be output:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">A</p></td>
<td width="10%"></td>
<td width="56%">


<p style="margin-top: 1em">IO was remapped to a different
device</p> </td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>B</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO bounced</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>C</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO completion</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>D</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO issued to driver</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>F</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO front merged with request on queue</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>G</p></td>
<td width="10%"></td>
<td width="56%">


<p>Get request</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>I</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO inserted onto request queue</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>M</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO back merged with request on queue</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>P</p></td>
<td width="10%"></td>
<td width="56%">


<p>Plug request</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>Q</p></td>
<td width="10%"></td>
<td width="56%">


<p>IO handled by request queue code</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>S</p></td>
<td width="10%"></td>
<td width="56%">


<p>Sleep request</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>T</p></td>
<td width="10%"></td>
<td width="56%">


<p>Unplug due to timeout</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>U</p></td>
<td width="10%"></td>
<td width="56%">


<p>Unplug request</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>X</p></td>
<td width="10%"></td>
<td width="56%">


<p>Split</p></td>
<td width="22%">
</td></tr>
</table>

<h2>RWBS DESCRIPTION
<a name="RWBS DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is a small
string containing at least one character (&rsquo;R&rsquo;
for read, &rsquo;W&rsquo; for write, or &rsquo;D&rsquo; for
block discard operation), and optionally either a
&rsquo;B&rsquo; (for barrier operations) or &rsquo;S&rsquo;
(for synchronous operations).</p>

<h2>DEFAULT OUTPUT
<a name="DEFAULT OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The standard
header (or initial fields displayed) include:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;%D %2c
%8s %5T.%9t %5p %2a %3d&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Breaking this
down:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>%D</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">Displays the event&rsquo;s
device major/minor as: %3d,%&minus;3d.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>%2c</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>CPU ID (2-character field).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>%8s</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Sequence number</p></td></tr>
</table>

<p style="margin-left:11%;"><b>%5T.%9t</b></p>

<p style="margin-left:22%;">5-character field for the
seconds portion of the time stamp and a 9-character field
for the nanoseconds in the time stamp.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>%5p</b></p></td>
<td width="7%"></td>
<td width="63%">


<p>5-character field for the process ID.</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>%2a</b></p></td>
<td width="7%"></td>
<td width="63%">


<p>2-character field for one of the actions.</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>%3d</b></p></td>
<td width="7%"></td>
<td width="63%">


<p>3-character field for the RWBS data.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Seeing this in
action:</p>

<p style="margin-left:22%; margin-top: 1em">8,0 3 1
0.000000000 697 G W 223490 + 8 [kjournald]</p>

<p style="margin-left:22%; margin-top: 1em">The header is
the data in this line up to the 223490 (starting block). The
default output for all event types includes this header.</p>

<h2>DEFAULT OUTPUT PER ACTION
<a name="DEFAULT OUTPUT PER ACTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>C
&minus;&minus; complete</b></p>

<p style="margin-left:17%;">If a payload is present, this
is presented between parenthesis following the header,
followed by the error value.</p>

<p style="margin-left:17%; margin-top: 1em">If no payload
is present, the sector and number of blocks are presented
(with an intervening plus (+) character). If the
<b>&minus;t</b> option was specified, then the elapsed time
is presented. In either case, it is followed by the error
value for the completion.</p>

<p style="margin-left:11%; margin-top: 1em"><b>B
&minus;&minus; bounced <br>
D &minus;&minus; issued <br>
I &minus;&minus; inserted <br>
Q &minus;&minus; queued</b></p>

<p style="margin-left:17%;">If a payload is present, the
number of payload bytes is output, followed by the payload
in hexadecimal between parenthesis.</p>

<p style="margin-left:17%; margin-top: 1em">If no payload
is present, the sector and number of blocks are presented
(with an intervening plus (+) character). If the
<b>&minus;t</b> option was specified, then the elapsed time
is presented (in parenthesis). In either case, it is
followed by the command associated with the event
(surrounded by square brackets).</p>

<p style="margin-left:11%; margin-top: 1em"><b>F
&minus;&minus; front merge <br>
G &minus;&minus; get request <br>
M &minus;&minus; back merge <br>
S &minus;&minus; sleep</b></p>

<p style="margin-left:17%;">The starting sector and number
of blocks is output (with an intervening plus (+)
character), followed by the command associated with the
event (surrounded by square brackets).</p>

<p style="margin-left:11%; margin-top: 1em"><b>P
&minus;&minus; plug</b></p>

<p style="margin-left:17%;">The command associated with the
event (surrounded by square brackets) is output.</p>

<p style="margin-left:11%; margin-top: 1em"><b>U
&minus;&minus; unplug <br>
T &minus;&minus; unplug due to timer</b></p>

<p style="margin-left:17%;">The command associated with the
event (surrounded by square brackets) is output, followed by
the number of requests outstanding.</p>

<p style="margin-left:11%; margin-top: 1em"><b>X
&minus;&minus; split</b></p>

<p style="margin-left:17%;">The original starting sector
followed by the new sector (separated by a slash (/) is
output, followed by the command associated with the event
(surrounded by square brackets).</p>

<p style="margin-left:11%; margin-top: 1em"><b>A
&minus;&minus; remap</b></p>

<p style="margin-left:17%;">Sector and length is output,
along with the original device and sector offset.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To trace the
i/o on the device <i>/dev/hda</i> <b>and parse the output to
human readable form, use the following command:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>% blktrace
&minus;d /dev/sda &minus;o &minus; | blkparse &minus;i
&minus;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>(see</b>
<i>blktrace</i> (8) for more information). This same
behaviour can be achieve with the convenience script
<i>btrace</i>. The command</p>

<p style="margin-left:11%; margin-top: 1em">% btrace
/dev/sda</p>

<p style="margin-left:11%; margin-top: 1em">has exactly the
same effect as the previous command. See <i>btrace</i> (8)
for more information.</p>

<p style="margin-left:11%; margin-top: 1em">To trace the
i/o on a device and save the output for later processing
with <i>blkparse</i>, use <i>blktrace</i> like this:</p>

<p style="margin-left:11%; margin-top: 1em">% blktrace
/dev/sda /dev/sdb</p>

<p style="margin-left:11%; margin-top: 1em">This will trace
i/o on the devices <i>/dev/sda</i> and <i>/dev/sdb</i> and
save the recorded information in the files <i>sda</i> and
<i>sdb</i> in the current directory, for the two different
devices, respectively. This trace information can later be
parsed by the <i>blkparse</i> utility:</p>

<p style="margin-left:11%; margin-top: 1em">% blkparse sda
sdb</p>

<p style="margin-left:11%; margin-top: 1em">which will
output the previously recorded tracing information in human
readable form to stdout.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>blkparse</i>
was written by Jens Axboe, Alan D. Brunelle and Nathan
Scott. This man page was created from the <i>blktrace</i>
documentation by Bas Zoetekouw.</p>

<h2>REPORTING BUGS
<a name="REPORTING BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Report bugs to
&lt;linux&minus;btrace@vger.kernel.org&gt;</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
&copy; 2006 Jens Axboe, Alan D. Brunelle and Nathan Scott.
<br>
This is free software. You may redistribute copies of it
under the terms of the GNU General Public License
&lt;http://www.gnu.org/licenses/gpl.html&gt;. There is NO
WARRANTY, to the extent permitted by law. <br>
This manual page was created for Debian by Bas Zoetekouw. It
was derived from the documentation provided by the authors
and it may be used, distributed and modified under the terms
of the GNU General Public License, version 2. <br>
On Debian systems, the text of the GNU General Public
License can be found in
/usr/share/common&minus;licenses/GPL&minus;2.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">btrace (8),
blktrace (8), verify_blkparse (1), blkrawverify (1), btt
(1)</p>
<hr>
</body>
</html>
