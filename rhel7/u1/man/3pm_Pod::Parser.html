<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:14:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Pod::Parser</title>

</head>
<body>

<h1 align="center">Pod::Parser</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#REQUIRES">REQUIRES</a><br>
<a href="#EXPORTS">EXPORTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#QUICK OVERVIEW">QUICK OVERVIEW</a><br>
<a href="#PARSING OPTIONS">PARSING OPTIONS</a><br>
<a href="#RECOMMENDED SUBROUTINE/METHOD OVERRIDES">RECOMMENDED SUBROUTINE/METHOD OVERRIDES</a><br>
<a href="#command()">command()</a><br>
<a href="#verbatim()">verbatim()</a><br>
<a href="#textblock()">textblock()</a><br>
<a href="#interior_sequence()">interior_sequence()</a><br>
<a href="#OPTIONAL SUBROUTINE/METHOD OVERRIDES">OPTIONAL SUBROUTINE/METHOD OVERRIDES</a><br>
<a href="#new()">new()</a><br>
<a href="#initialize()">initialize()</a><br>
<a href="#begin_pod()">begin_pod()</a><br>
<a href="#begin_input()">begin_input()</a><br>
<a href="#end_input()">end_input()</a><br>
<a href="#end_pod()">end_pod()</a><br>
<a href="#preprocess_line()">preprocess_line()</a><br>
<a href="#preprocess_paragraph()">preprocess_paragraph()</a><br>
<a href="#METHODS FOR PARSING AND PROCESSING">METHODS FOR PARSING AND PROCESSING</a><br>
<a href="#parse_text()">parse_text()</a><br>
<a href="#interpolate()">interpolate()</a><br>
<a href="#parse_from_filehandle()">parse_from_filehandle()</a><br>
<a href="#parse_from_file()">parse_from_file()</a><br>
<a href="#ACCESSOR METHODS">ACCESSOR METHODS</a><br>
<a href="#errorsub()">errorsub()</a><br>
<a href="#cutting()">cutting()</a><br>
<a href="#parseopts()">parseopts()</a><br>
<a href="#output_file()">output_file()</a><br>
<a href="#output_handle()">output_handle()</a><br>
<a href="#input_file()">input_file()</a><br>
<a href="#input_handle()">input_handle()</a><br>
<a href="#PRIVATE METHODS AND DATA">PRIVATE METHODS AND DATA</a><br>
<a href="#TREE-BASED PARSING">TREE-BASED PARSING</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#LICENSE">LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Pod::Parser
&minus; base class for creating POD filters and
translators</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Pod::Parser;
    package MyParser;
    @ISA = qw(Pod::Parser);
    sub command {
        my ($parser, $command, $paragraph, $line_num) = @_;
        ## Interpret the command and its text; sample actions might be:
        if ($command eq 'head1') { ... }
        elsif ($command eq 'head2') { ... }
        ## ... other commands and their actions
        my $out_fh = $parser&minus;&gt;output_handle();
        my $expansion = $parser&minus;&gt;interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }
    sub verbatim {
        my ($parser, $paragraph, $line_num) = @_;
        ## Format verbatim paragraph; sample actions might be:
        my $out_fh = $parser&minus;&gt;output_handle();
        print $out_fh $paragraph;
    }
    sub textblock {
        my ($parser, $paragraph, $line_num) = @_;
        ## Translate/Format this block of text; sample actions might be:
        my $out_fh = $parser&minus;&gt;output_handle();
        my $expansion = $parser&minus;&gt;interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }
    sub interior_sequence {
        my ($parser, $seq_command, $seq_argument) = @_;
        ## Expand an interior sequence; sample actions might be:
        return &quot;*$seq_argument*&quot;     if ($seq_command eq 'B');
        return &quot;`$seq_argument'&quot;     if ($seq_command eq 'C');
        return &quot;_${seq_argument}_'&quot;  if ($seq_command eq 'I');
        ## ... other sequence commands and their resulting text
    }
    package main;
    ## Create a parser object and have it parse file whose name was
    ## given on the command&minus;line (use STDIN if no files were given).
    $parser = new MyParser();
    $parser&minus;&gt;parse_from_filehandle(\*STDIN)  if (@ARGV == 0);
    for (@ARGV) { $parser&minus;&gt;parse_from_file($_); }</pre>


<h2>REQUIRES
<a name="REQUIRES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perl5.005,
Pod::InputObjects, Exporter, Symbol, Carp</p>

<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Nothing.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
is a base class for creating <small>POD</small> filters and
translators. It handles most of the effort involved with
parsing the <small>POD</small> sections from an input
stream, leaving subclasses free to be concerned only with
performing the actual translation of text.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
parses PODs, and makes method calls to handle the various
components of the <small>POD.</small> Subclasses of
<b>Pod::Parser</b> override these methods to translate the
<small>POD</small> into whatever output format they
desire.</p>

<p style="margin-left:11%; margin-top: 1em">Note: This
module is considered as legacy; modern Perl releases (5.18
and higher) are going to remove Pod::Parser from core and
use Pod::Simple for all things <small>POD.</small></p>

<h2>QUICK OVERVIEW
<a name="QUICK OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To create a
<small>POD</small> filter for translating <small>POD</small>
documentation into some other format, you create a subclass
of <b>Pod::Parser</b> which typically overrides just the
base class implementation for the following methods:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b><i>command()</i></b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b><i>verbatim()</i></b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b><i>textblock()</i></b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b><i>interior_sequence()</i></b></p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">You may also
want to override the <b><i>begin_input()</i></b> and
<b><i>end_input()</i></b> methods for your subclass (to
perform any needed per-file and/or per-document
initialization or cleanup).</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
perform any preprocessing of input before it is parsed you
may want to override one or more of
<b><i>preprocess_line()</i></b> and/or
<b><i>preprocess_paragraph()</i></b>.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes it
may be necessary to make more than one pass over the input
files. If this is the case you have several options. You can
make the first pass using <b>Pod::Parser</b> and override
your methods to store the intermediate results in memory
somewhere for the <b><i>end_pod()</i></b> method to process.
You could use <b>Pod::Parser</b> for several passes with an
appropriate state variable to control the operation for each
pass. If your input source can&rsquo;t be reset to start at
the beginning, you can store it in some other structure as a
string or an array and have that structure implement a
<b><i>getline()</i></b> method (which is all that
<b><i>parse_from_filehandle()</i></b> uses to read
input).</p>

<p style="margin-left:11%; margin-top: 1em">Feel free to
add any member data fields you need to keep track of things
like current font, indentation, horizontal or vertical
position, or whatever else you like. Be sure to read &quot;
<small>PRIVATE METHODS AND DATA&quot;</small> to avoid name
collisions.</p>

<p style="margin-left:11%; margin-top: 1em">For the most
part, the <b>Pod::Parser</b> base class should be able to do
most of the input parsing for you and leave you free to
worry about how to interpret the commands and translate the
result.</p>

<p style="margin-left:11%; margin-top: 1em">Note that all
we have described here in this quick overview is the
simplest most straightforward use of <b>Pod::Parser</b> to
do stream-based parsing. It is also possible to use the
<b>Pod::Parser::parse_text</b> function to do more
sophisticated tree-based parsing. See &quot;TREE-BASED
<small>PARSING&quot;</small> .</p>

<h2>PARSING OPTIONS
<a name="PARSING OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<i>parse-option</i> is simply a named option of
<b>Pod::Parser</b> with a value that corresponds to a
certain specified behavior. These various behaviors of
<b>Pod::Parser</b> may be enabled/disabled by setting or
unsetting one or more <i>parse-options</i> using the
<b><i>parseopts()</i></b> method. The set of currently
accepted parse-options is as follows: <b><br>
&minus;want_nonPODs</b> (default: unset)</p>

<p style="margin-left:15%;">Normally (by default)
<b>Pod::Parser</b> will only provide access to the
<small>POD</small> sections of the input. Input paragraphs
that are not part of the POD-format documentation are not
made available to the caller (not even using
<b><i>preprocess_paragraph()</i></b>). Setting this option
to a non-empty, non-zero value will allow
<b><i>preprocess_paragraph()</i></b> to see non-POD sections
of the input as well as <small>POD</small> sections. The
<b><i>cutting()</i></b> method can be used to determine if
the corresponding paragraph is a <small>POD</small>
paragraph, or some other input paragraph.</p>

<p style="margin-left:11%;"><b>&minus;process_cut_cmd</b>
(default: unset)</p>

<p style="margin-left:15%;">Normally (by default)
<b>Pod::Parser</b> handles the <tt>&quot;=cut&quot;</tt>
<small>POD</small> directive by itself and does not pass it
on to the caller for processing. Setting this option to a
non-empty, non-zero value will cause <b>Pod::Parser</b> to
pass the <tt>&quot;=cut&quot;</tt> directive to the caller
just like any other <small>POD</small> command (and hence it
may be processed by the <b><i>command()</i></b> method).</p>


<p style="margin-left:15%; margin-top: 1em"><b>Pod::Parser</b>
will still interpret the <tt>&quot;=cut&quot;</tt> directive
to mean that &quot;cutting mode&quot; has been (re)entered,
but the caller will get a chance to capture the actual
<tt>&quot;=cut&quot;</tt> paragraph itself for whatever
purpose it desires.</p>

<p style="margin-left:11%;"><b>&minus;warnings</b>
(default: unset)</p>

<p style="margin-left:15%;">Normally (by default)
<b>Pod::Parser</b> recognizes a bare minimum of pod syntax
errors and warnings and issues diagnostic messages for
errors, but not for warnings. (Use <b>Pod::Checker</b> to do
more thorough checking of <small>POD</small> syntax.)
Setting this option to a non-empty, non-zero value will
cause <b>Pod::Parser</b> to issue diagnostics for the few
warnings it recognizes as well as the errors.</p>

<p style="margin-left:11%; margin-top: 1em">Please see
&quot;<i>parseopts()</i>&quot; for a complete description of
the interface for the setting and unsetting of
parse-options.</p>

<h2>RECOMMENDED SUBROUTINE/METHOD OVERRIDES
<a name="RECOMMENDED SUBROUTINE/METHOD OVERRIDES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
provides several methods which most subclasses will probably
want to override. These methods are as follows:</p>

<h2>command()
<a name="command()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;command($cmd,$text,$line_num,$pod_para);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
should be overridden by subclasses to take the appropriate
action when a <small>POD</small> command paragraph (denoted
by a line beginning with &quot;=&quot;) is encountered. When
such a <small>POD</small> directive is seen in the input,
this method is called and is passed: <br>
$cmd</p>

<p style="margin-left:15%;">the name of the command for
this <small>POD</small> paragraph</p>

<p style="margin-left:11%;">$text</p>

<p style="margin-left:15%;">the paragraph text for the
given <small>POD</small> paragraph command.</p>

<p style="margin-left:11%;">$line_num</p>

<p style="margin-left:15%;">the line-number of the
beginning of the paragraph</p>

<p style="margin-left:11%;">$pod_para</p>

<p style="margin-left:15%;">a reference to a
<tt>&quot;Pod::Paragraph&quot;</tt> object which contains
further information about the paragraph command (see
Pod::InputObjects for details).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note</b>
that this method <i>is</i> called for
<tt>&quot;=pod&quot;</tt> paragraphs.</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of this method simply treats the raw
<small>POD</small> command as normal block of paragraph text
(invoking the <b><i>textblock()</i></b> method with the
command paragraph).</p>

<h2>verbatim()
<a name="verbatim()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;verbatim($text,$line_num,$pod_para);</pre>


<p style="margin-left:11%; margin-top: 1em">This method may
be overridden by subclasses to take the appropriate action
when a block of verbatim text is encountered. It is passed
the following parameters: <br>
$text</p>

<p style="margin-left:15%;">the block of text for the
verbatim paragraph</p>

<p style="margin-left:11%;">$line_num</p>

<p style="margin-left:15%;">the line-number of the
beginning of the paragraph</p>

<p style="margin-left:11%;">$pod_para</p>

<p style="margin-left:15%;">a reference to a
<tt>&quot;Pod::Paragraph&quot;</tt> object which contains
further information about the paragraph (see
Pod::InputObjects for details).</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of this method simply prints the textblock
(unmodified) to the output filehandle.</p>

<h2>textblock()
<a name="textblock()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;textblock($text,$line_num,$pod_para);</pre>


<p style="margin-left:11%; margin-top: 1em">This method may
be overridden by subclasses to take the appropriate action
when a normal block of <small>POD</small> text is
encountered (although the base class method will usually do
what you want). It is passed the following parameters: <br>
$text</p>

<p style="margin-left:15%;">the block of text for the a
<small>POD</small> paragraph</p>

<p style="margin-left:11%;">$line_num</p>

<p style="margin-left:15%;">the line-number of the
beginning of the paragraph</p>

<p style="margin-left:11%;">$pod_para</p>

<p style="margin-left:15%;">a reference to a
<tt>&quot;Pod::Paragraph&quot;</tt> object which contains
further information about the paragraph (see
Pod::InputObjects for details).</p>

<p style="margin-left:11%; margin-top: 1em">In order to
process interior sequences, subclasses implementations of
this method will probably want to invoke either
<b><i>interpolate()</i></b> or <b><i>parse_text()</i></b>,
passing it the text block <tt>$text</tt>, and the
corresponding line number in <tt>$line_num</tt>, and then
perform any desired processing upon the returned result.</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of this method simply prints the text block
as it occurred in the input stream).</p>

<h2>interior_sequence()
<a name="interior_sequence()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;interior_sequence($seq_cmd,$seq_arg,$pod_seq);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
should be overridden by subclasses to take the appropriate
action when an interior sequence is encountered. An interior
sequence is an embedded command within a block of text which
appears as a command name (usually a single uppercase
character) followed immediately by a string of text which is
enclosed in angle brackets. This method is passed the
sequence command <tt>$seq_cmd</tt> and the corresponding
text <tt>$seq_arg</tt>. It is invoked by the
<b><i>interpolate()</i></b> method for each interior
sequence that occurs in the string that it is passed. It
should return the desired text string to be used in place of
the interior sequence. The <tt>$pod_seq</tt> argument is a
reference to a <tt>&quot;Pod::InteriorSequence&quot;</tt>
object which contains further information about the interior
sequence. Please see Pod::InputObjects for details if you
need to access this additional information.</p>

<p style="margin-left:11%; margin-top: 1em">Subclass
implementations of this method may wish to invoke the
<b><i>nested()</i></b> method of <tt>$pod_seq</tt> to see if
it is nested inside some other interior-sequence (and if so,
which kind).</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of the <b><i>interior_sequence()</i></b>
method simply returns the raw text of the interior sequence
(as it occurred in the input) to the caller.</p>

<h2>OPTIONAL SUBROUTINE/METHOD OVERRIDES
<a name="OPTIONAL SUBROUTINE/METHOD OVERRIDES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
provides several methods which subclasses may want to
override to perform any special pre/post&minus;processing.
These methods do <i>not</i> have to be overridden, but it
may be useful for subclasses to take advantage of them.</p>

<h2>new()
<a name="new()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            my $parser = Pod::Parser&minus;&gt;new();</pre>


<p style="margin-left:11%; margin-top: 1em">This is the
constructor for <b>Pod::Parser</b> and its subclasses. You
<i>do not</i> need to override this method! It is capable of
constructing subclass objects as well as base class objects,
provided you use any of the following constructor invocation
styles:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $parser1 = MyParser&minus;&gt;new();
    my $parser2 = new MyParser();
    my $parser3 = $parser2&minus;&gt;new();</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;MyParser&quot;</tt> is some subclass of
<b>Pod::Parser</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Using the
syntax <tt>&quot;MyParser::new()&quot;</tt> to invoke the
constructor is <i>not</i> recommended, but if you insist on
being able to do this, then the subclass <i>will</i> need to
override the <b><i>new()</i></b> constructor method. If you
do override the constructor, you <i>must</i> be sure to
invoke the <b><i>initialize()</i></b> method of the newly
blessed object.</p>

<p style="margin-left:11%; margin-top: 1em">Using any of
the above invocations, the first argument to the constructor
is always the corresponding package name (or object
reference). No other arguments are required, but if desired,
an associative array (or hash-table) my be passed to the
<b><i>new()</i></b> constructor, as in:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $parser1 = MyParser&minus;&gt;new( MYDATA =&gt; $value1, MOREDATA =&gt; $value2 );
    my $parser2 = new MyParser( &minus;myflag =&gt; 1 );</pre>


<p style="margin-left:11%; margin-top: 1em">All arguments
passed to the <b><i>new()</i></b> constructor will be
treated as key/value pairs in a hash-table. The newly
constructed object will be initialized by copying the
contents of the given hash-table (which may have been
empty). The <b><i>new()</i></b> constructor for this class
and all of its subclasses returns a blessed reference to the
initialized object (hash-table).</p>

<h2>initialize()
<a name="initialize()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;initialize();</pre>


<p style="margin-left:11%; margin-top: 1em">This method
performs any necessary object initialization. It takes no
arguments (other than the object instance of course, which
is typically copied to a local variable named
<tt>$self</tt>). If subclasses override this method then
they <i>must</i> be sure to invoke
<tt>&quot;$self&minus;&gt;SUPER::initialize()&quot;</tt>.</p>

<h2>begin_pod()
<a name="begin_pod()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;begin_pod();</pre>


<p style="margin-left:11%; margin-top: 1em">This method is
invoked at the beginning of processing for each
<small>POD</small> document that is encountered in the
input. Subclasses should override this method to perform any
per-document initialization.</p>

<h2>begin_input()
<a name="begin_input()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;begin_input();</pre>


<p style="margin-left:11%; margin-top: 1em">This method is
invoked by <b><i>parse_from_filehandle()</i></b> immediately
<i>before</i> processing input from a filehandle. The base
class implementation does nothing, however, subclasses may
override it to perform any per-file initializations.</p>

<p style="margin-left:11%; margin-top: 1em">Note that if
multiple files are parsed for a single <small>POD</small>
document (perhaps the result of some future
<tt>&quot;=include&quot;</tt> directive) this method is
invoked for every file that is parsed. If you wish to
perform certain initializations once per document, then you
should use <b><i>begin_pod()</i></b>.</p>

<h2>end_input()
<a name="end_input()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;end_input();</pre>


<p style="margin-left:11%; margin-top: 1em">This method is
invoked by <b><i>parse_from_filehandle()</i></b> immediately
<i>after</i> processing input from a filehandle. The base
class implementation does nothing, however, subclasses may
override it to perform any per-file cleanup actions.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that if multiple files are parsed for a single
<small>POD</small> document (perhaps the result of some kind
of <tt>&quot;=include&quot;</tt> directive) this method is
invoked for every file that is parsed. If you wish to
perform certain cleanup actions once per document, then you
should use <b><i>end_pod()</i></b>.</p>

<h2>end_pod()
<a name="end_pod()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;end_pod();</pre>


<p style="margin-left:11%; margin-top: 1em">This method is
invoked at the end of processing for each <small>POD</small>
document that is encountered in the input. Subclasses should
override this method to perform any per-document
finalization.</p>

<h2>preprocess_line()
<a name="preprocess_line()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">          $textline = $parser&minus;&gt;preprocess_line($text, $line_num);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
should be overridden by subclasses that wish to perform any
kind of preprocessing for each <i>line</i> of input
(<i>before</i> it has been determined whether or not it is
part of a <small>POD</small> paragraph). The parameter
<tt>$text</tt> is the input line; and the parameter
<tt>$line_num</tt> is the line number of the corresponding
text line.</p>

<p style="margin-left:11%; margin-top: 1em">The value
returned should correspond to the new text to use in its
place. If the empty string or an undefined value is returned
then no further processing will be performed for this
line.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that the <b><i>preprocess_line()</i></b> method is invoked
<i>before</i> the <b><i>preprocess_paragraph()</i></b>
method. After all (possibly preprocessed) lines in a
paragraph have been assembled together and it has been
determined that the paragraph is part of the
<small>POD</small> documentation from one of the selected
sections, then <b><i>preprocess_paragraph()</i></b> is
invoked.</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of this method returns the given text.</p>

<h2>preprocess_paragraph()
<a name="preprocess_paragraph()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $textblock = $parser&minus;&gt;preprocess_paragraph($text, $line_num);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
should be overridden by subclasses that wish to perform any
kind of preprocessing for each block (paragraph) of
<small>POD</small> documentation that appears in the input
stream. The parameter <tt>$text</tt> is the
<small>POD</small> paragraph from the input file; and the
parameter <tt>$line_num</tt> is the line number for the
beginning of the corresponding paragraph.</p>

<p style="margin-left:11%; margin-top: 1em">The value
returned should correspond to the new text to use in its
place If the empty string is returned or an undefined value
is returned, then the given <tt>$text</tt> is ignored (not
processed).</p>

<p style="margin-left:11%; margin-top: 1em">This method is
invoked after gathering up all the lines in a paragraph and
after determining the cutting state of the paragraph, but
before trying to further parse or interpret them. After
<b><i>preprocess_paragraph()</i></b> returns, the current
cutting state (which is returned by
<tt>&quot;$self&minus;&gt;cutting()&quot;</tt>) is examined.
If it evaluates to true then input text (including the given
<tt>$text</tt>) is cut (not processed) until the next
<small>POD</small> directive is encountered.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that the <b><i>preprocess_line()</i></b> method is invoked
<i>before</i> the <b><i>preprocess_paragraph()</i></b>
method. After all (possibly preprocessed) lines in a
paragraph have been assembled together and either it has
been determined that the paragraph is part of the
<small>POD</small> documentation from one of the selected
sections or the <tt>&quot;&minus;want_nonPODs&quot;</tt>
option is true, then <b><i>preprocess_paragraph()</i></b> is
invoked.</p>

<p style="margin-left:11%; margin-top: 1em">The base class
implementation of this method returns the given text.</p>

<h2>METHODS FOR PARSING AND PROCESSING
<a name="METHODS FOR PARSING AND PROCESSING"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
provides several methods to process input text. These
methods typically won&rsquo;t need to be overridden (and in
some cases they can&rsquo;t be overridden), but subclasses
may want to invoke them to exploit their functionality.</p>

<h2>parse_text()
<a name="parse_text()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $ptree1 = $parser&minus;&gt;parse_text($text, $line_num);
            $ptree2 = $parser&minus;&gt;parse_text({%opts}, $text, $line_num);
            $ptree3 = $parser&minus;&gt;parse_text(\%opts, $text, $line_num);</pre>


<p style="margin-left:11%; margin-top: 1em">This method is
useful if you need to perform your own interpolation of
interior sequences and can&rsquo;t rely upon
<b>interpolate</b> to expand them in simple bottom-up
order.</p>

<p style="margin-left:11%; margin-top: 1em">The parameter
<tt>$text</tt> is a string or block of text to be parsed for
interior sequences; and the parameter <tt>$line_num</tt> is
the line number corresponding to the beginning of
<tt>$text</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>parse_text()</i></b>
will parse the given text into a parse-tree of
&quot;nodes.&quot; and interior-sequences. Each
&quot;node&quot; in the parse tree is either a text-string,
or a <b>Pod::InteriorSequence</b>. The result returned is a
parse-tree of type <b>Pod::ParseTree</b>. Please see
Pod::InputObjects for more information about
<b>Pod::InteriorSequence</b> and <b>Pod::ParseTree</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If desired, an
optional hash-ref may be specified as the first argument to
customize certain aspects of the parse-tree that is created
and returned. The set of recognized option keywords are:
<b><br>
&minus;expand_seq</b> =&gt;
<i>code-ref</i>|<i>method-name</i></p>

<p style="margin-left:15%;">Normally, the parse-tree
returned by <b><i>parse_text()</i></b> will contain an
unexpanded <tt>&quot;Pod::InteriorSequence&quot;</tt> object
for each interior-sequence encountered. Specifying
<b>&minus;expand_seq</b> tells <b><i>parse_text()</i></b> to
&quot;expand&quot; every interior-sequence it sees by
invoking the referenced function (or named method of the
parser object) and using the return value as the expanded
result.</p>

<p style="margin-left:15%; margin-top: 1em">If a subroutine
reference was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  &amp;$code_ref( $parser, $sequence )</pre>


<p style="margin-left:15%; margin-top: 1em">and if a
method-name was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  $parser&minus;&gt;method_name( $sequence )</pre>


<p style="margin-left:15%; margin-top: 1em">where
<tt>$parser</tt> is a reference to the parser object, and
<tt>$sequence</tt> is a reference to the interior-sequence
object. [ <i><small>NOTE</small></i> : If the
<b><i>interior_sequence()</i></b> method is specified, then
it is invoked according to the interface specified in
&quot;<i>interior_sequence()</i>&quot;].</p>

<p style="margin-left:11%;"><b>&minus;expand_text</b> =&gt;
<i>code-ref</i>|<i>method-name</i></p>

<p style="margin-left:15%;">Normally, the parse-tree
returned by <b><i>parse_text()</i></b> will contain a
text-string for each contiguous sequence of characters
outside of an interior-sequence. Specifying
<b>&minus;expand_text</b> tells <b><i>parse_text()</i></b>
to &quot;preprocess&quot; every such text-string it sees by
invoking the referenced function (or named method of the
parser object) and using the return value as the
preprocessed (or &quot;expanded&quot;) result. [Note that if
the result is an interior-sequence, then it will <i>not</i>
be expanded as specified by the <b>&minus;expand_seq</b>
option; Any such recursive expansion needs to be handled by
the specified callback routine.]</p>

<p style="margin-left:15%; margin-top: 1em">If a subroutine
reference was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  &amp;$code_ref( $parser, $text, $ptree_node )</pre>


<p style="margin-left:15%; margin-top: 1em">and if a
method-name was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  $parser&minus;&gt;method_name( $text, $ptree_node )</pre>


<p style="margin-left:15%; margin-top: 1em">where
<tt>$parser</tt> is a reference to the parser object,
<tt>$text</tt> is the text-string encountered, and
<tt>$ptree_node</tt> is a reference to the current node in
the parse-tree (usually an interior-sequence object or else
the top-level node of the parse-tree).</p>

<p style="margin-left:11%;"><b>&minus;expand_ptree</b>
=&gt; <i>code-ref</i>|<i>method-name</i></p>

<p style="margin-left:15%;">Rather than returning a
<tt>&quot;Pod::ParseTree&quot;</tt>, pass the parse-tree as
an argument to the referenced subroutine (or named method of
the parser object) and return the result instead of the
parse-tree object.</p>

<p style="margin-left:15%; margin-top: 1em">If a subroutine
reference was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  &amp;$code_ref( $parser, $ptree )</pre>


<p style="margin-left:15%; margin-top: 1em">and if a
method-name was given, it is invoked as:</p>

<pre style="margin-left:15%; margin-top: 1em">  $parser&minus;&gt;method_name( $ptree )</pre>


<p style="margin-left:15%; margin-top: 1em">where
<tt>$parser</tt> is a reference to the parser object, and
<tt>$ptree</tt> is a reference to the parse-tree object.</p>

<h2>interpolate()
<a name="interpolate()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $textblock = $parser&minus;&gt;interpolate($text, $line_num);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
translates all text (including any embedded interior
sequences) in the given text string <tt>$text</tt> and
returns the interpolated result. The parameter
<tt>$line_num</tt> is the line number corresponding to the
beginning of <tt>$text</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><i>interpolate()</i></b>
merely invokes a private method to recursively expand nested
interior sequences in bottom-up order (innermost sequences
are expanded first). If there is a need to expand nested
sequences in some alternate order, use <b>parse_text</b>
instead.</p>

<h2>parse_from_filehandle()
<a name="parse_from_filehandle()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;parse_from_filehandle($in_fh,$out_fh);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
takes an input filehandle (which is assumed to already be
opened for reading) and reads the entire input stream
looking for blocks (paragraphs) of <small>POD</small>
documentation to be processed. If no first argument is given
the default input filehandle <tt>&quot;STDIN&quot;</tt> is
used.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$in_fh</tt> parameter may be any object that provides a
<b><i>getline()</i></b> method to retrieve a single line of
input text (hence, an appropriate wrapper object could be
used to parse PODs from a single string or an array of
strings).</p>

<p style="margin-left:11%; margin-top: 1em">Using
<tt>&quot;$in_fh&minus;&gt;getline()&quot;</tt>, input is
read line-by-line and assembled into paragraphs or
&quot;blocks&quot; (which are separated by lines containing
nothing but whitespace). For each block of
<small>POD</small> documentation encountered it will invoke
a method to parse the given paragraph.</p>

<p style="margin-left:11%; margin-top: 1em">If a second
argument is given then it should correspond to a filehandle
where output should be sent (otherwise the default output
filehandle is <tt>&quot;STDOUT&quot;</tt> if no output
filehandle is currently in use).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
For performance reasons, this method caches the input stream
at the top of the stack in a local variable. Any attempts by
clients to change the stack contents during processing when
in the midst executing of this method <i>will not affect</i>
the input stream used by the current invocation of this
method.</p>

<p style="margin-left:11%; margin-top: 1em">This method
does <i>not</i> usually need to be overridden by
subclasses.</p>

<h2>parse_from_file()
<a name="parse_from_file()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;parse_from_file($filename,$outfile);</pre>


<p style="margin-left:11%; margin-top: 1em">This method
takes a filename and does the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>opens the input and output files for reading (creating
the appropriate filehandles)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>invokes the <b><i>parse_from_filehandle()</i></b> method
passing it the corresponding input and output
filehandles.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>closes the input and output files.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the special
input filename &quot;&minus;&quot; or
&quot;&lt;&amp;STDIN&quot; is given then the
<small>STDIN</small> filehandle is used for input (and no
open or close is performed). If no input filename is
specified then &quot;&minus;&quot; is implied. Filehandle
references, or objects that support the regular
<small>IO</small> operations (like
<tt>&quot;&lt;$fh&gt;&quot;</tt> or
<tt>&quot;$fh&minus;&lt;Egt&quot;</tt>getline&gt;) are also
accepted; the handles must already be opened.</p>

<p style="margin-left:11%; margin-top: 1em">If a second
argument is given then it should be the name of the desired
output file. If the special output filename
&quot;&minus;&quot; or &quot;&gt;&amp;STDOUT&quot; is given
then the <small>STDOUT</small> filehandle is used for output
(and no open or close is performed). If the special output
filename &quot;&gt;&amp;STDERR&quot; is given then the
<small>STDERR</small> filehandle is used for output (and no
open or close is performed). If no output filehandle is
currently in use and no output filename is specified, then
&quot;&minus;&quot; is implied. Alternatively, filehandle
references or objects that support the regular
<small>IO</small> operations (like
<tt>&quot;print&quot;</tt>, e.g. IO::String) are also
accepted; the object must already be opened.</p>

<p style="margin-left:11%; margin-top: 1em">This method
does <i>not</i> usually need to be overridden by
subclasses.</p>

<h2>ACCESSOR METHODS
<a name="ACCESSOR METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Clients of
<b>Pod::Parser</b> should use the following methods to
access instance data fields:</p>

<h2>errorsub()
<a name="errorsub()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;errorsub(&quot;method_name&quot;);
            $parser&minus;&gt;errorsub(\&amp;warn_user);
            $parser&minus;&gt;errorsub(sub { print STDERR, @_ });</pre>


<p style="margin-left:11%; margin-top: 1em">Specifies the
method or subroutine to use when printing error messages
about <small>POD</small> syntax. The supplied
method/subroutine <i>must</i> return <small>TRUE</small>
upon successful printing of the message. If
<tt>&quot;undef&quot;</tt> is given, then the <b>carp</b>
builtin is used to issue error messages (this is the default
behavior).</p>

<pre style="margin-left:11%; margin-top: 1em">            my $errorsub = $parser&minus;&gt;errorsub()
            my $errmsg = &quot;This is an error message!\n&quot;
            (ref $errorsub) and &amp;{$errorsub}($errmsg)
                or (defined $errorsub) and $parser&minus;&gt;$errorsub($errmsg)
                    or  carp($errmsg);</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
method name, or else a reference to the user-supplied
subroutine used to print error messages. Returns
<tt>&quot;undef&quot;</tt> if the <b>carp</b> builtin is
used to issue error messages (this is the default
behavior).</p>

<h2>cutting()
<a name="cutting()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $boolean = $parser&minus;&gt;cutting();</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
current <tt>&quot;cutting&quot;</tt> state: a boolean-valued
scalar which evaluates to true if text from the input file
is currently being &quot;cut&quot; (meaning it is <i>not</i>
considered part of the <small>POD</small> document).</p>

<pre style="margin-left:11%; margin-top: 1em">            $parser&minus;&gt;cutting($boolean);</pre>


<p style="margin-left:11%; margin-top: 1em">Sets the
current <tt>&quot;cutting&quot;</tt> state to the given
value and returns the result.</p>

<h2>parseopts()
<a name="parseopts()"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When invoked
with no additional arguments, <b>parseopts</b> returns a
hashtable of all the current parsing options.</p>

<pre style="margin-left:11%; margin-top: 1em">            ## See if we are parsing non&minus;POD sections as well as POD ones
            my %opts = $parser&minus;&gt;parseopts();
            $opts{'&minus;want_nonPODs}' and print &quot;&minus;want_nonPODs\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">When invoked
using a single string, <b>parseopts</b> treats the string as
the name of a parse-option and returns its corresponding
value if it exists (returns <tt>&quot;undef&quot;</tt> if it
doesn&rsquo;t).</p>

<pre style="margin-left:11%; margin-top: 1em">            ## Did we ask to see '=cut' paragraphs?
            my $want_cut = $parser&minus;&gt;parseopts('&minus;process_cut_cmd');
            $want_cut and print &quot;&minus;process_cut_cmd\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">When invoked
with multiple arguments, <b>parseopts</b> treats them as
key/value pairs and the specified parse-option names are set
to the given values. Any unspecified parse-options are
unaffected.</p>

<pre style="margin-left:11%; margin-top: 1em">            ## Set them back to the default
            $parser&minus;&gt;parseopts(&minus;warnings =&gt; 0);</pre>


<p style="margin-left:11%; margin-top: 1em">When passed a
single hash-ref, <b>parseopts</b> uses that hash to
completely reset the existing parse-options, all previous
parse-option values are lost.</p>

<pre style="margin-left:11%; margin-top: 1em">            ## Reset all options to default
            $parser&minus;&gt;parseopts( { } );</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>PARSING OPTIONS&quot;</small> for more information on
the name and meaning of each parse-option currently
recognized.</p>

<h2>output_file()
<a name="output_file()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $fname = $parser&minus;&gt;output_file();</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
name of the output file being written.</p>

<h2>output_handle()
<a name="output_handle()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $fhandle = $parser&minus;&gt;output_handle();</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
output filehandle object.</p>

<h2>input_file()
<a name="input_file()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $fname = $parser&minus;&gt;input_file();</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
name of the input file being read.</p>

<h2>input_handle()
<a name="input_handle()"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">            $fhandle = $parser&minus;&gt;input_handle();</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
current input filehandle object.</p>

<h2>PRIVATE METHODS AND DATA
<a name="PRIVATE METHODS AND DATA"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Pod::Parser</b>
makes use of several internal methods and data fields which
clients should not need to see or use. For the sake of
avoiding name collisions for client data and methods, these
methods and fields are briefly discussed here. Determined
hackers may obtain further information about them by reading
the <b>Pod::Parser</b> source code.</p>

<p style="margin-left:11%; margin-top: 1em">Private data
fields are stored in the hash-object whose reference is
returned by the <b><i>new()</i></b> constructor for this
class. The names of all private methods and data-fields used
by <b>Pod::Parser</b> begin with a prefix of &quot;_&quot;
and match the regular expression
<tt>&quot;/^_\w+$/&quot;</tt>.</p>

<h2>TREE-BASED PARSING
<a name="TREE-BASED PARSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If
straightforward stream-based parsing wont meet your needs
(as is likely the case for tasks such as translating PODs
into structured markup languages like <small>HTML</small>
and <small>XML</small> ) then you may need to take the
tree-based approach. Rather than doing everything in one
pass and calling the <b><i>interpolate()</i></b> method to
expand sequences into text, it may be desirable to instead
create a parse-tree using the <b><i>parse_text()</i></b>
method to return a tree-like structure which may contain an
ordered list of children (each of which may be a
text-string, or a similar tree-like structure).</p>

<p style="margin-left:11%; margin-top: 1em">Pay special
attention to &quot; <small>METHODS FOR PARSING AND
PROCESSING&quot;</small> and to the objects described in
Pod::InputObjects. The former describes the gory details and
parameters for how to customize and extend the parsing
behavior of <b>Pod::Parser</b>. <b>Pod::InputObjects</b>
provides several objects that may all be used
interchangeably as parse-trees. The most obvious one is the
<b>Pod::ParseTree</b> object. It defines the basic interface
and functionality that all things trying to be a
<small>POD</small> parse-tree should do. A
<b>Pod::ParseTree</b> is defined such that each
&quot;node&quot; may be a text-string, or a reference to
another parse-tree. Each <b>Pod::Paragraph</b> object and
each <b>Pod::InteriorSequence</b> object also supports the
basic parse-tree interface.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><i>parse_text()</i></b> method takes a given paragraph of
text, and returns a parse-tree that contains one or more
children, each of which may be a text-string, or an
InteriorSequence object. There are also callback-options
that may be passed to <b><i>parse_text()</i></b> to
customize the way it expands or transforms
interior-sequences, as well as the returned result. These
callbacks can be used to create a parse-tree with
custom-made objects (which may or may not support the
parse-tree interface, depending on how you choose to do
it).</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
turn an entire <small>POD</small> document into a
parse-tree, that process is fairly straightforward. The
<b><i>parse_text()</i></b> method is the key to doing this
successfully. Every paragraph-callback (i.e. the polymorphic
methods for <b><i>command()</i></b>,
<b><i>verbatim()</i></b>, and <b><i>textblock()</i></b>
paragraphs) takes a <b>Pod::Paragraph</b> object as an
argument. Each paragraph object has a
<b><i>parse_tree()</i></b> method that can be used to get or
set a corresponding parse-tree. So for each of those
paragraph-callback methods, simply call
<b><i>parse_text()</i></b> with the options you desire, and
then use the returned parse-tree to assign to the given
paragraph object.</p>

<p style="margin-left:11%; margin-top: 1em">That gives you
a parse-tree for each paragraph &minus; so now all you need
is an ordered list of paragraphs. You can maintain that
yourself as a data element in the object/hash. The most
straightforward way would be simply to use an array-ref,
with the desired set of custom &quot;options&quot; for each
invocation of <b>parse_text</b>. Let&rsquo;s assume the
desired option-set is given by the hash <tt>%options</tt>.
Then we might do something like the following:</p>

<pre style="margin-left:11%; margin-top: 1em">    package MyPodParserTree;
    @ISA = qw( Pod::Parser );
    ...
    sub begin_pod {
        my $self = shift;
        $self&minus;&gt;{'&minus;paragraphs'} = [];  ## initialize paragraph list
    }
    sub command {
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser&minus;&gt;parse_text({%options}, $paragraph, ...);
        $pod_para&minus;&gt;parse_tree( $ptree );
        push @{ $self&minus;&gt;{'&minus;paragraphs'} }, $pod_para;
    }
    sub verbatim {
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        push @{ $self&minus;&gt;{'&minus;paragraphs'} }, $pod_para;
    }
    sub textblock {
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser&minus;&gt;parse_text({%options}, $paragraph, ...);
        $pod_para&minus;&gt;parse_tree( $ptree );
        push @{ $self&minus;&gt;{'&minus;paragraphs'} }, $pod_para;
    }
    ...
    package main;
    ...
    my $parser = new MyPodParserTree(...);
    $parser&minus;&gt;parse_from_file(...);
    my $paragraphs_ref = $parser&minus;&gt;{'&minus;paragraphs'};</pre>


<p style="margin-left:11%; margin-top: 1em">Of course, in
this module-author&rsquo;s humble opinion, I&rsquo;d be more
inclined to use the existing <b>Pod::ParseTree</b> object
than a simple array. That way everything in it, paragraphs
and sequences, all respond to the same core interface for
all parse-tree nodes. The result would look something
like:</p>

<pre style="margin-left:11%; margin-top: 1em">    package MyPodParserTree2;
    ...
    sub begin_pod {
        my $self = shift;
        $self&minus;&gt;{'&minus;ptree'} = new Pod::ParseTree;  ## initialize parse&minus;tree
    }
    sub parse_tree {
        ## convenience method to get/set the parse&minus;tree for the entire POD
        (@_ &gt; 1)  and  $_[0]&minus;&gt;{'&minus;ptree'} = $_[1];
        return $_[0]&minus;&gt;{'&minus;ptree'};
    }
    sub command {
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser&minus;&gt;parse_text({&lt;&lt;options&gt;&gt;}, $paragraph, ...);
        $pod_para&minus;&gt;parse_tree( $ptree );
        $parser&minus;&gt;parse_tree()&minus;&gt;append( $pod_para );
    }
    sub verbatim {
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        $parser&minus;&gt;parse_tree()&minus;&gt;append( $pod_para );
    }
    sub textblock {
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser&minus;&gt;parse_text({&lt;&lt;options&gt;&gt;}, $paragraph, ...);
        $pod_para&minus;&gt;parse_tree( $ptree );
        $parser&minus;&gt;parse_tree()&minus;&gt;append( $pod_para );
    }
    ...
    package main;
    ...
    my $parser = new MyPodParserTree2(...);
    $parser&minus;&gt;parse_from_file(...);
    my $ptree = $parser&minus;&gt;parse_tree;
    ...</pre>


<p style="margin-left:11%; margin-top: 1em">Now you have
the entire <small>POD</small> document as one great big
parse-tree. You can even use the <b>&minus;expand_seq</b>
option to <b>parse_text</b> to insert whole different kinds
of objects. Just don&rsquo;t expect <b>Pod::Parser</b> to
know what to do with them after that. That will need to be
in your code. Or, alternatively, you can insert any object
you like so long as it conforms to the <b>Pod::ParseTree</b>
interface.</p>

<p style="margin-left:11%; margin-top: 1em">One could use
this to create subclasses of <b>Pod::Paragraphs</b> and
<b>Pod::InteriorSequences</b> for specific commands (or to
create your own custom node-types in the parse-tree) and add
some kind of <b><i>emit()</i></b> method to each custom
node/subclass object in the tree. Then all you&rsquo;d need
to do is recursively walk the tree in the desired order,
processing the children (most likely from left to right) by
formatting them if they are text-strings, or by calling
their <b><i>emit()</i></b> method if they are
objects/references.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please note
that <small>POD</small> has the notion of
&quot;paragraphs&quot;: this is something starting
<i>after</i> a blank (read: empty) line, with the single
exception of the file start, which is also starting a
paragraph. That means that especially a command (e.g.
<tt>&quot;=head1&quot;</tt>) <i>must</i> be preceded with a
blank line; <tt>&quot;__END__&quot;</tt> is <i>not</i> a
blank line.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Pod::InputObjects,
Pod::Select</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pod::InputObjects</b>
defines <small>POD</small> input objects corresponding to
command paragraphs, parse-trees, and interior-sequences.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pod::Select</b>
is a subclass of <b>Pod::Parser</b> which provides the
ability to selectively include and/or exclude sections of a
<small>POD</small> document from being translated based upon
the current heading, subheading, subsubheading, etc.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
bugs using &lt;http://rt.cpan.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Brad Appleton
&lt;bradapp@enteract.com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Based on code
for <b>Pod::Text</b> written by Tom Christiansen
&lt;tchrist@mox.perl.com&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Pod-Parser is
free software; you can redistribute it and/or modify it
under the terms of the Artistic License distributed with
Perl version 5.000 or (at your option) any later version.
Please refer to the Artistic License that came with your
Perl distribution for more details. If your version of Perl
was not distributed under the terms of the Artistic License,
than you may distribute PodParser under the same terms as
Perl itself.</p>
<hr>
</body>
</html>
