<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:54:21 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>hunspell</title>

</head>
<body>

<h1 align="center">hunspell</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>hunspell</b>
- spell checking, stemming, morphological generation and
analysis</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;hunspell/hunspell.hxx&gt; /* or */ <br>
#include &lt;hunspell/hunspell.h&gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Hunspell(const
char *</b><i>affpath</i><b>, const char
*</b><i>dpath</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Hunspell(const
char *</b><i>affpath</i><b>, const char
*</b><i>dpath</i><b>, const char *</b>
<i>key</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>~Hunspell(</b><i>);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
add_dic(const char *</b><i>dpath</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
add_dic(const char *</b><i>dpath</i><b>, const char
*</b><i>key</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
spell(const char *</b><i>word</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
spell(const char *</b><i>word</i><b>, int
*</b><i>info</i><b>, char **</b><i>root</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
suggest(char***</b><i>slst</i><b>, const char
*</b><i>word);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
analyze(char***</b><i>slst</i><b>, const char
*</b><i>word);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
stem(char***</b><i>slst</i><b>, const char
*</b><i>word);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
stem(char***</b><i>slst</i><b>, char **</b><i>morph</i><b>,
int</b> <i>n);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
generate(char***</b><i>slst</i><b>, const char
*</b><i>word</i><b>, const char *</b><i>word2);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
generate(char***</b><i>slst</i><b>, const char
*</b><i>word</i><b>, char **</b><i>desc</i><b>, int</b>
<i>n);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
free_list(char ***</b><i>slst</i><b>, int</b> <i>n);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
add(const char *</b><i>word);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
add_with_affix(const char *</b><i>word</i><b>, const char
*</b><i>example);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
remove(const char *</b><i>word);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>char *
get_dic_encoding(</b><i>);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
get_wordchars(</b><i>);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned
short * get_wordchars_utf16(int *</b><i>len);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>struct
cs_info * get_csconv(</b><i>);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
get_version(</b><i>);</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>Hunspell</b> library routines give the user word-level
linguistic functions: spell checking and correction,
stemming, morphological generation and analysis in
item-and-arrangement style.</p>

<p style="margin-left:11%; margin-top: 1em">The optional C
header contains the C interface of the C++ library with
Hunspell_create and Hunspell_destroy constructor and
destructor, and an extra HunHandle parameter (the allocated
object) in the wrapper functions (see in the C header file
<b>hunspell.h</b>).</p>

<p style="margin-left:11%; margin-top: 1em">The basic
spelling functions, <b>spell()</b> and <b>suggest()</b> can
be used for stemming, morphological generation and analysis
by XML input texts (see XML API).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constructor
and destructor</b> <br>
Hunspell&rsquo;s constructor needs paths of the affix and
dictionary files. See the <b>hunspell</b>(4) manual page for
the dictionary format. Optional <b>key</b> parameter is for
dictionaries encrypted by the <b>hzip</b> tool of the
Hunspell distribution.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extra
dictionaries</b> <br>
The add_dic() function load an extra dictionary file. The
extra dictionaries use the affix file of the allocated
Hunspell object. Maximal number of the extra dictionaries is
limited in the source code (20).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Spelling and
correction</b> <br>
The spell() function returns non-zero, if the input word is
recognised by the spell checker, and a zero value if not.
Optional reference variables return a bit array (info) and
the root word of the input word. Info bits checked with the
SPELL_COMPOUND, SPELL_FORBIDDEN or SPELL_WARN macros sign
compound words, explicit forbidden and probably bad words.
From version 1.3, the non-zero return value is 2 for the
dictionary words with the flag &quot;WARN&quot; (probably
bad words).</p>

<p style="margin-left:11%; margin-top: 1em">The suggest()
function has two input parameters, a reference variable of
the output suggestion list, and an input word. The function
returns the number of the suggestions. The reference
variable will contain the address of the newly allocated
suggestion list or NULL, if the return value of suggest() is
zero. Maximal number of the suggestions is limited in the
source code.</p>

<p style="margin-left:11%; margin-top: 1em">The spell() and
suggest() can recognize XML input, see the XML API
section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Morphological
functions</b> <br>
The plain stem() and analyze() functions are similar to the
suggest(), but instead of suggestions, return stems and
results of the morphological analysis. The plain generate()
waits a second word, too. This extra word and its affixation
will be the model of the morphological generation of the
requested forms of the first word.</p>

<p style="margin-left:11%; margin-top: 1em">The extended
stem() and generate() use the results of a morphological
analysis:</p>

<p style="margin-left:22%; margin-top: 1em">char ** result,
result2; <br>
int n1 = analyze(&amp;result, &quot;words&quot;); <br>
int n2 = stem(&amp;result2, result, n1);</p>

<p style="margin-left:11%; margin-top: 1em">The
morphological annotation of the Hunspell library has fixed
(two letter and a colon) field identifiers, see the
<b>hunspell</b>(4) manual page.</p>

<p style="margin-left:22%; margin-top: 1em">char ** result;
<br>
char * affix = &quot;is:plural&quot;; // description depends
from dictionaries, too <br>
int n = generate(&amp;result, &quot;word&quot;, &amp;affix,
1); <br>
for (int i = 0; i &lt; n; i++) printf(&quot;%s0,
result[i]);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Memory
deallocation</b> <br>
The free_list() function frees the memory allocated by
suggest(), analyze, generate and stem() functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
functions</b> <br>
The add(), add_with_affix() and remove() are helper
functions of a personal dictionary implementation to add and
remove words from the base dictionary in run-time. The
add_with_affix() uses a second word as a model of the
enabled affixation of the new word.</p>

<p style="margin-left:11%; margin-top: 1em">The
get_dic_encoding() function returns &quot;ISO8859-1&quot; or
the character encoding defined in the affix file with the
&quot;SET&quot; keyword.</p>

<p style="margin-left:11%; margin-top: 1em">The
get_csconv() function returns the 8-bit character case table
of the encoding of the dictionary.</p>

<p style="margin-left:11%; margin-top: 1em">The
get_wordchars() and get_wordchars_utf16() return the extra
word characters definied in affix file for tokenization by
the &quot;WORDCHARS&quot; keyword.</p>

<p style="margin-left:11%; margin-top: 1em">The
get_version() returns the version string of the library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>XML API</b>
<br>
The spell() function returns non-zero for the
&quot;&lt;?xml?&gt;&quot; input indicating the XML API
support.</p>

<p style="margin-left:11%; margin-top: 1em">The suggest()
function stems, analyzes and generates the forms of the
input word, if it was added by one of the following
&quot;SPELLML&quot; syntaxes:</p>

<p style="margin-left:22%; margin-top: 1em">&lt;?xml?&gt;
<br>
&lt;query type=&quot;analyze&quot;&gt; <br>
&lt;word&gt;dogs&lt;/word&gt; <br>
&lt;/query&gt;</p>

<p style="margin-left:22%; margin-top: 1em">&lt;?xml?&gt;
<br>
&lt;query type=&quot;stem&quot;&gt; <br>
&lt;word&gt;dogs&lt;/word&gt; <br>
&lt;/query&gt;</p>

<p style="margin-left:22%; margin-top: 1em">&lt;?xml?&gt;
<br>
&lt;query type=&quot;generate&quot;&gt; <br>
&lt;word&gt;dog&lt;/word&gt; <br>
&lt;word&gt;cats&lt;/word&gt; <br>
&lt;/query&gt;</p>

<p style="margin-left:22%; margin-top: 1em">&lt;?xml?&gt;
<br>
&lt;query type=&quot;generate&quot;&gt; <br>
&lt;word&gt;dog&lt;/word&gt; <br>

&lt;code&gt;&lt;a&gt;is:pl&lt;/a&gt;&lt;a&gt;is:poss&lt;/a&gt;&lt;/code&gt;
<br>
&lt;/query&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The outputs of
the type=&quot;stem&quot; query and the stem() library
function are the same. The output of the
type=&quot;analyze&quot; query is a string contained a
&lt;code&gt;&lt;a&gt;result1&lt;/a&gt;&lt;a&gt;result2&lt;/a&gt;...&lt;/code&gt;
element. This element can be used in the second syntax of
the type=&quot;generate&quot; query.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See analyze.cxx
in the Hunspell distribution.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hunspell based
on Ispell&rsquo;s spell checking algorithms and
OpenOffice.org&rsquo;s Myspell source code.</p>

<p style="margin-left:11%; margin-top: 1em">Author of
International Ispell is Geoff Kuenning.</p>

<p style="margin-left:11%; margin-top: 1em">Author of
MySpell is Kevin Hendricks.</p>

<p style="margin-left:11%; margin-top: 1em">Author of
Hunspell is L&aacute;szl&oacute; N&eacute;meth.</p>

<p style="margin-left:11%; margin-top: 1em">Author of the
original C API is Caolan McNamara.</p>

<p style="margin-left:11%; margin-top: 1em">Author of the
Aspell table-driven phonetic transcription algorithm and
code is Bj&ouml;rn Jacke.</p>

<p style="margin-left:11%; margin-top: 1em">See also THANKS
and Changelog files of Hunspell distribution.</p>
<hr>
</body>
</html>
