<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:51:42 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XML::SAX::Writer</title>

</head>
<body>

<h1 align="center">XML::SAX::Writer</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#THE CONSUMER INTERFACE">THE CONSUMER INTERFACE</a><br>
<a href="#THE ENCODER INTERFACE">THE ENCODER INTERFACE</a><br>
<a href="#CUSTOM OUTPUT">CUSTOM OUTPUT</a><br>
<a href="#TODO">TODO</a><br>
<a href="#CREDITS">CREDITS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#POD ERRORS">POD ERRORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::SAX::Writer
&minus; SAX2 Writer</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use XML::SAX::Writer;
  use XML::SAX::SomeDriver;
  my $w = XML::SAX::Writer&minus;&gt;new;
  my $d = XML::SAX::SomeDriver&minus;&gt;new(Handler =&gt; $w);
  $d&minus;&gt;parse('some options...');</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Why yet
another <small>XML</small> Writer ?</b> <br>
A new <small>XML</small> Writer was needed to match the
<small>SAX2</small> effort because quite naturally no
existing writer understood <small>SAX2.</small> My first
intention had been to start patching XML::Handler::YAWriter
as it had previously been my favourite writer in the
<small>SAX1</small> world.</p>

<p style="margin-left:11%; margin-top: 1em">However the
more I patched it the more I realised that what I thought
was going to be a simple patch (mostly adding a few event
handlers and changing the attribute syntax) was turning out
to be a rewrite due to various ideas I&rsquo;d been
collecting along the way. Besides, I couldn&rsquo;t find a
way to elegantly make it work with <small>SAX2</small>
without breaking the <small>SAX1</small> compatibility which
people are probably still using. There are of course ways to
do that, but most require user interaction which is
something I wanted to avoid.</p>

<p style="margin-left:11%; margin-top: 1em">So in the end
there was a new writer. I think it&rsquo;s in fact better
this way as it helps keep <small>SAX1</small> and
<small>SAX2</small> separated.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">new(%hash)</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is the
constructor for this object. &nbsp;It takes a number of
parameters, all of which are optional.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&minus;&minus; Output</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This parameter
can be one of several things. &nbsp;If it is a simple
scalar, it is interpreted as a filename which will be opened
for writing. &nbsp;If it is a scalar reference, output will
be appended to this scalar. &nbsp;If it is an array
reference, output will be pushed onto this array as it is
generated. &nbsp;If it is a filehandle, then output will be
sent to this filehandle.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, it is
possible to pass an object for this parameter, in which case
it is assumed to be an object that implements the consumer
interface described later in the documentation.</p>

<p style="margin-left:17%; margin-top: 1em">If this
parameter is not provided, then output is sent to
<small>STDOUT.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&minus;&minus; Escape</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This should be
a hash reference where the keys are characters sequences
that should be escaped and the values are the escaped form
of the sequence. &nbsp;By default, this module will escape
the ampersand (&amp;), less than (&lt;), greater than
(&gt;), double quote (&quot;), and apostrophe (&rsquo;).
Note that some browsers don&rsquo;t support the &amp;apos;
escape used for apostrophes so that you should be careful
when outputting <small>XHTML.</small></p>

<p style="margin-left:17%; margin-top: 1em">If you only
want to add entries to the Escape hash, you can first copy
the contents of
<tt>%XML::SAX::Writer::DEFAULT_ESCAPE</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">


<p style="margin-top: 1em">&minus;&minus; CommentEscape</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Comment content
often needs to be escaped differently from other content.
This option works exactly as the previous one except that by
default it only escapes the double dash (&minus;&minus;) and
that the contents can be copied from
<tt>%XML::SAX::Writer::COMMENT_ESCAPE</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="20%">


<p style="margin-top: 1em">&minus;&minus; EncodeFrom</p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The character
set encoding in which incoming data will be provided. This
defaults to <small>UTF&minus;8,</small> which works for
US-ASCII as well.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p style="margin-top: 1em">&minus;&minus; EncodeTo</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The character
set encoding in which output should be encoded. &nbsp;Again,
this defaults to <small>UTF&minus;8.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em">&minus;&minus;
QuoteCharacter</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Set the
character used to quote attributes. This defaults to single
quotes (&rsquo;) for backwards compatiblity.</p>

<h2>THE CONSUMER INTERFACE
<a name="THE CONSUMER INTERFACE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::SAX::Writer
can receive pluggable consumer objects that will be in
charge of writing out what is formatted by this module.
Setting a Consumer is done by setting the Output option to
the object of your choice instead of to an array, scalar, or
file handle as is more commonly done (internally those in
fact map to Consumer classes and and simply available as
options for your convienience).</p>

<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t understand this, don&rsquo;t worry. You
don&rsquo;t need it most of the time.</p>

<p style="margin-left:11%; margin-top: 1em">That object can
be from any class, but must have two methods in its
<small>API.</small> It is also strongly recommended that it
inherits from XML::SAX::Writer::ConsumerInterface so that it
will not break if that interface evolves over time. There
are examples at the end of XML::SAX::Writer&rsquo;s
code.</p>

<p style="margin-left:11%; margin-top: 1em">The two methods
that it needs to implement are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="20%">


<p style="margin-top: 1em">output <small>STRING</small></p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">(Required)</p>

<p style="margin-left:17%; margin-top: 1em">This is called
whenever the Writer wants to output a string formatted in
<small>XML.</small> Encoding conversion, character escaping,
and formatting have already taken place. It&rsquo;s up to
the consumer to do whatever it wants with the string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em"><i>finalize()</i></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">(Optional)</p>

<p style="margin-left:17%; margin-top: 1em">This is called
once the document has been output in its entirety, during
the end_document event. end_document will in fact return
whatever <i>finalize()</i> returns, and that in turn should
be returned by <i>parse()</i> for whatever parser was
invoked. It might be useful if you need to provide feedback
of some sort.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example of a custom consumer. Note the extra
<tt>&quot;$&quot;</tt> signs in front of <tt>$self</tt>; the
base class is optimized for the overwhelmingly common case
where only one data member is required and <tt>$self</tt> is
a reference to that data member.</p>

<pre style="margin-left:11%; margin-top: 1em">    package MyConsumer;
    @ISA = qw( XML::SAX::Writer::ConsumerInterface );
    use strict;
    sub new {
        my $self = shift&minus;&gt;SUPER::new( my $output );
        $$self = '';      # Note the extra '$'
        return $self;
    }
    sub output {
        my $self = shift;
        $$self .= uc shift;
    }
    sub get_output {
        my $self = shift;
        return $$self;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">And
here&rsquo;s one way to use it:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $c = MyConsumer&minus;&gt;new;
    my $w = XML::SAX::Writer&minus;&gt;new( Output =&gt; $c );
    ## ... send events to $w ...
    print $c&minus;&gt;get_output;</pre>


<p style="margin-left:11%; margin-top: 1em">If you need to
store more that one data member, pass in an array or hash
reference:</p>

<pre style="margin-left:11%; margin-top: 1em">        my $self = shift&minus;&gt;SUPER::new( {} );</pre>


<p style="margin-left:11%; margin-top: 1em">and access it
like:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub output {
        my $self = shift;
        $$self&minus;&gt;{Output} .= uc shift;
    }</pre>


<h2>THE ENCODER INTERFACE
<a name="THE ENCODER INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Encoders can be
plugged in to allow one to use one&rsquo;s favourite encoder
object. Presently there are two encoders: Iconv and
NullEncoder, and one based on <tt>&quot;Encode&quot;</tt>
ought to be out soon. They need to implement two methods,
and may inherit from XML::SAX::Writer::NullConverter if they
wish to <br>
new <small>FROM_ENCODING, TO_ENCODING</small></p>

<p style="margin-left:17%;">Creates a new Encoder. The
arguments are the chosen encodings.</p>

<p style="margin-left:11%;">convert
<small>STRING</small></p>

<p style="margin-left:17%;">Converts that string and
returns it.</p>

<h2>CUSTOM OUTPUT
<a name="CUSTOM OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module is
generally used to write <small>XML</small> -- which it does
most of the time -- but just like the rest of
<small>SAX</small> it can be used as a generic framework to
output data, the opposite of a non-XML <small>SAX</small>
parser.</p>

<p style="margin-left:11%; margin-top: 1em">Of course
there&rsquo;s only so much that one can abstract, so
depending on your format this may or may not be useful. If
it is, you&rsquo;ll need to know the followin
<small>API</small> (and probably to have a look inside
<tt>&quot;XML::SAX::Writer::XML&quot;</tt>, the default
Writer). <br>
init</p>

<p style="margin-left:17%;">Called before the writing
starts, it&rsquo;s a chance for the subclass to do some
initialisation if it needs it.</p>

<p style="margin-left:11%;">setConverter</p>

<p style="margin-left:17%;">This is used to set the proper
converter for character encodings. The default
implementation should suffice but you can override it. It
must set <tt>&quot;$self&minus;&quot;</tt>{Encoder}&gt; to
an Encoder object. Subclasses *should* call it.</p>

<p style="margin-left:11%;">setConsumer</p>

<p style="margin-left:17%;">Same as above, except that it
is for the Consumer object, and that it must set
<tt>&quot;$self&minus;&quot;</tt>{Consumer}&gt;.</p>

<p style="margin-left:11%;">setEscaperRegex</p>

<p style="margin-left:17%;">Will initialise the escaping
regex <tt>&quot;$self&minus;&quot;</tt>{EscaperRegex}&gt;
based on what is needed.</p>

<p style="margin-left:11%;">escape
<small>STRING</small></p>

<p style="margin-left:17%;">Takes a string and escapes it
properly.</p>

<p style="margin-left:11%;">setCommentEscaperRegex and
escapeComment <small>STRING</small></p>

<p style="margin-left:17%;">These work exactly the same as
the two above, except that they are meant to operate on
comment contents, which often have different escaping rules
than those that apply to regular content.</p>

<h2>TODO
<a name="TODO"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    &minus; proper UTF&minus;16 handling
    &minus; the formatting options need to be developed.
    &minus; test, test, test (and then some tests)
    &minus; doc, doc, doc (actually this part is in better shape)
    &minus; remove the xml_decl and replace it with intelligent logic, as
    discussed on perl&minus;xml
    &minus; make a the Consumer selecting code available in the API, to avoid
    duplicating
    &minus; add an Apache output Consumer, triggered by passing $r as Output</pre>


<h2>CREDITS
<a name="CREDITS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Michael Koehne
(XML::Handler::YAWriter) for much inspiration and Barrie
Slaymaker for the Consumer pattern idea, the coderef output
option and miscellaneous bugfixes and performance tweaks. Of
course the usual suspects (Kip Hampton and Matt Sergeant)
helped in the usual ways.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Robin Berjon,
robin@knowscape.com</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2001&minus;2006 Robin Berjon and Perl <small>XML</small>
project. Some rights reserved. This program is free
software; you can redistribute it and/or modify it under the
same terms as Perl itself.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::SAX::*</p>

<h2>POD ERRORS
<a name="POD ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hey! <b>The
above document had some coding errors, which are explained
below:</b> <br>
Around line 440:</p>

<p style="margin-left:17%;">Non-ASCII character seen before
=encoding in &rsquo;&nbsp;It&rsquo;. Assuming
<small>UTF&minus;8</small></p>

<p style="margin-left:11%;">Around line 443:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>

<p style="margin-left:11%;">Around line 459:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>

<p style="margin-left:11%;">Around line 471:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>

<p style="margin-left:11%;">Around line 478:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>

<p style="margin-left:11%;">Around line 483:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>

<p style="margin-left:11%;">Around line 488:</p>

<p style="margin-left:17%;">Expected &rsquo;=item
*&rsquo;</p>
<hr>
</body>
</html>
