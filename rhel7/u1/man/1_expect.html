<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 00:41:47 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EXPECT</title>

</head>
<body>

<h1 align="center">EXPECT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#INTRODUCTION">INTRODUCTION</a><br>
<a href="#USAGE">USAGE</a><br>
<a href="#COMMANDS">COMMANDS</a><br>
<a href="#LIBRARIES">LIBRARIES</a><br>
<a href="#PRETTY-PRINTING">PRETTY-PRINTING</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXPECT HINTS">EXPECT HINTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">expect &minus;
programmed dialogue with interactive programs, Version 5</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>expect</b> [
<b>&minus;dDinN</b> ] [ <b>&minus;c</b> <i>cmds</i> ] [ [
<b>&minus;</b>[<b>f</b>|<b>b</b>] ] <i>cmdfile</i> ] [
<i>args</i> ]</p>

<h2>INTRODUCTION
<a name="INTRODUCTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Expect</b>
is a program that &quot;talks&quot; to other interactive
programs according to a script. Following the script,
<b>Expect</b> knows what can be expected from a program and
what the correct response should be. An interpreted language
provides branching and high-level control structures to
direct the dialogue. In addition, the user can take control
and interact directly when desired, afterward returning
control to the script.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Expectk</b>
is a mixture of <b>Expect</b> and <b>Tk</b>. It behaves just
like <b>Expect</b> and <b>Tk</b>&rsquo;s <b>wish</b>.
<b>Expect</b> can also be used directly in C or C++ (that
is, without Tcl). See libexpect(3).</p>

<p style="margin-left:11%; margin-top: 1em">The name
&quot;Expect&quot; comes from the idea of <i>send/expect</i>
sequences popularized by uucp, kermit and other modem
control programs. However unlike uucp, <b>Expect</b> is
generalized so that it can be run as a user-level command
with any program and task in mind. <b>Expect</b> can
actually talk to several programs at the same time.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
here are some things <b>Expect</b> can do:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p>Cause your computer to dial you back, so that you can
login without paying for the call.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p>Start a game (e.g., rogue) and if the optimal
configuration doesn&rsquo;t appear, restart it (again and
again) until it does, then hand over control to you.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p>Run fsck, and in response to its questions, answer
&quot;yes&quot;, &quot;no&quot; or give control back to you,
based on predetermined criteria.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p>Connect to another network or BBS (e.g., MCI Mail,
CompuServe) and automatically retrieve your mail so that it
appears as if it was originally sent to your local
system.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p>Carry environment variables, current directory, or any
kind of information across rlogin, telnet, tip, su, chgrp,
etc.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There are a
variety of reasons why the shell cannot perform these tasks.
(Try, you&rsquo;ll see.) All are possible with
<b>Expect</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In general,
<b>Expect</b> is useful for running any program which
requires interaction between the program and the user. All
that is necessary is that the interaction can be
characterized programmatically. <b>Expect</b> can also give
the user back control (without halting the program being
controlled) if desired. Similarly, the user can return
control to the script at any time.</p>

<h2>USAGE
<a name="USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Expect</b>
reads <i>cmdfile</i> for a list of commands to execute.
<b>Expect</b> may also be invoked implicitly on systems
which support the #! notation by marking the script
executable, and making the first line in your script:</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/local/bin/expect
&minus;f</p>

<p style="margin-left:11%; margin-top: 1em">Of course, the
path must accurately describe where <b>Expect</b> lives.
/usr/local/bin is just an example.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;c</b> flag prefaces a command to be executed
before any in the script. The command should be quoted to
prevent being broken up by the shell. This option may be
used multiple times. Multiple commands may be executed with
a single <b>&minus;c</b> by separating them with semicolons.
Commands are executed in the order they appear. (When using
Expectk, this option is specified as
<b>&minus;command</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;d</b> flag enables some diagnostic output, which
primarily reports internal activity of commands such as
<b>expect</b> and <b>interact</b>. This flag has the same
effect as &quot;exp_internal 1&quot; at the beginning of an
Expect script, plus the version of <b>Expect</b> is printed.
(The <b>strace</b> command is useful for tracing statements,
and the <b>trace</b> command is useful for tracing variable
assignments.) (When using Expectk, this option is specified
as <b>&minus;diag</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;D</b> flag enables an interactive debugger. An
integer value should follow. The debugger will take control
before the next Tcl procedure if the value is non-zero or if
a ^C is pressed (or a breakpoint is hit, or other
appropriate debugger command appears in the script). See the
README file or SEE ALSO (below) for more information on the
debugger. (When using Expectk, this option is specified as
<b>&minus;Debug</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;f</b> flag prefaces a file from which to read
commands from. The flag itself is optional as it is only
useful when using the #! notation (see above), so that other
arguments may be supplied on the command line. (When using
Expectk, this option is specified as
<b>&minus;file</b>.)</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
command file is read into memory and executed in its
entirety. It is occasionally desirable to read files one
line at a time. For example, stdin is read this way. In
order to force arbitrary files to be handled this way, use
the <b>&minus;b</b> flag. (When using Expectk, this option
is specified as <b>&minus;buffer</b>.) Note that
stdio-buffering may still take place however this
shouldn&rsquo;t cause problems when reading from a fifo or
stdin.</p>

<p style="margin-left:11%; margin-top: 1em">If the string
&quot;&minus;&quot; is supplied as a filename, standard
input is read instead. (Use &quot;./&minus;&quot; to read
from a file actually named &quot;&minus;&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;i</b> flag causes <b>Expect</b> to interactively
prompt for commands instead of reading them from a file.
Prompting is terminated via the <b>exit</b> command or upon
EOF. See <b>interpreter</b> (below) for more information.
<b>&minus;i</b> is assumed if neither a command file nor
<b>&minus;c</b> is used. (When using Expectk, this option is
specified as <b>&minus;interactive</b>.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;</b>
may be used to delimit the end of the options. This is
useful if you want to pass an option-like argument to your
script without it being interpreted by <b>Expect</b>. This
can usefully be placed in the #! line to prevent any
flag-like interpretation by Expect. For example, the
following will leave the original arguments (including the
script name) in the variable <i>argv</i>.</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/local/bin/expect
&minus;&minus;</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
usual getopt(3) and execve(2) conventions must be observed
when adding arguments to the #! line.</p>

<p style="margin-left:11%; margin-top: 1em">The file
$exp_library/expect.rc is sourced automatically if present,
unless the <b>&minus;N</b> flag is used. (When using
Expectk, this option is specified as <b>&minus;NORC</b>.)
Immediately after this, the file ~/.expect.rc is sourced
automatically, unless the <b>&minus;n</b> flag is used. If
the environment variable DOTDIR is defined, it is treated as
a directory and .expect.rc is read from there. (When using
Expectk, this option is specified as <b>&minus;norc</b>.)
This sourcing occurs only after executing any
<b>&minus;c</b> flags.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;v</b>
causes Expect to print its version number and exit. (The
corresponding flag in Expectk, which uses long flag names,
is &minus;version.)</p>

<p style="margin-left:11%; margin-top: 1em">Optional
<i>args</i> are constructed into a list and stored in the
variable named <i>argv</i>. <i>argc</i> is initialized to
the length of argv.</p>

<p style="margin-left:11%; margin-top: 1em"><i>argv0</i> is
defined to be the name of the script (or binary if no script
is used). For example, the following prints out the name of
the script and the first three arguments:</p>

<p style="margin-left:11%; margin-top: 1em">send_user
&quot;$argv0 [lrange $argv 0 2]\n&quot;</p>

<h2>COMMANDS
<a name="COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Expect</b>
uses <i>Tcl</i> (Tool Command Language). Tcl provides
control flow (e.g., if, for, break), expression evaluation
and several other features such as recursion, procedure
definition, etc. Commands used here but not defined (e.g.,
<b>set</b>, <b>if</b>, <b>exec</b>) are Tcl commands (see
tcl(3)). <b>Expect</b> supports additional commands,
described below. Unless otherwise specified, commands return
the empty string.</p>

<p style="margin-left:11%; margin-top: 1em">Commands are
listed alphabetically so that they can be quickly located.
However, new users may find it easier to start by reading
the descriptions of <b>spawn</b>, <b>send</b>,
<b>expect</b>, and <b>interact</b>, in that order.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
best introduction to the language (both Expect and Tcl) is
provided in the book &quot;Exploring Expect&quot; (see SEE
ALSO below). Examples are included in this man page but they
are very limited since this man page is meant primarily as
reference material.</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
the text of this man page, &quot;Expect&quot; with an
uppercase &quot;E&quot; refers to the <b>Expect</b> program
while &quot;expect&quot; with a lower-case &quot;e&quot;
refers to the <b>expect</b> command within the <b>Expect</b>
program.) <b><br>
close</b> <i>[-slave] [&minus;onexec 0|1] [&minus;i
spawn_id]</i></p>

<p style="margin-left:20%;">closes the connection to the
current process. Most interactive programs will detect EOF
on their stdin and exit; thus <b>close</b> usually suffices
to kill the process as well. The <b>&minus;i</b> flag
declares the process to close corresponding to the named
spawn_id.</p>

<p style="margin-left:20%; margin-top: 1em">Both
<b>expect</b> and <b>interact</b> will detect when the
current process exits and implicitly do a <b>close</b>. But
if you kill the process by, say, &quot;exec kill $pid&quot;,
you will need to explicitly call <b>close</b>.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;onexec</b> flag determines whether the spawn id
will be closed in any new spawned processes or if the
process is overlayed. To leave a spawn id open, use the
value 0. A non-zero integer value will force the spawn
closed (the default) in any new processes.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;slave</b> flag closes the slave associated with
the spawn id. (See &quot;spawn -pty&quot;.) When the
connection is closed, the slave is automatically closed as
well if still open.</p>

<p style="margin-left:20%; margin-top: 1em">No matter
whether the connection is closed implicitly or explicitly,
you should call <b>wait</b> to clear up the corresponding
kernel process slot. <b>close</b> does not call <b>wait</b>
since there is no guarantee that closing a process
connection will cause it to exit. See <b>wait</b> below for
more info.</p>

<p style="margin-left:11%;"><b>debug</b> <i>[[-now]
0|1]</i></p>

<p style="margin-left:20%;">controls a Tcl debugger
allowing you to step through statements, set breakpoints,
etc.</p>

<p style="margin-left:20%; margin-top: 1em">With no
arguments, a 1 is returned if the debugger is not running,
otherwise a 0 is returned.</p>

<p style="margin-left:20%; margin-top: 1em">With a 1
argument, the debugger is started. With a 0 argument, the
debugger is stopped. If a 1 argument is preceded by the
<b>&minus;now</b> flag, the debugger is started immediately
(i.e., in the middle of the <b>debug</b> command itself).
Otherwise, the debugger is started with the next Tcl
statement.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>debug</b> command does not change any traps. Compare this
to starting Expect with the <b>-D</b> flag (see above).</p>

<p style="margin-left:20%; margin-top: 1em">See the README
file or SEE ALSO (below) for more information on the
debugger.</p>

<p style="margin-left:11%;"><b>disconnect</b></p>

<p style="margin-left:20%;">disconnects a forked process
from the terminal. It continues running in the background.
The process is given its own process group (if possible).
Standard I/O is redirected to /dev/null.</p>

<p style="margin-left:20%; margin-top: 1em">The following
fragment uses <b>disconnect</b> to continue running the
script in the background.</p>

<p style="margin-left:20%; margin-top: 1em">if {[fork]!=0}
exit <br>
disconnect <br>
. . .</p>

<p style="margin-left:20%; margin-top: 1em">The following
script reads a password, and then runs a program every hour
that demands a password each time it is run. The script
supplies the password so that you only have to type it once.
(See the <b>stty</b> command which demonstrates how to turn
off password echoing.)</p>

<p style="margin-left:20%; margin-top: 1em">send_user
&quot;password?\ &quot; <br>
expect_user -re &quot;(.*)\n&quot; <br>
for {} 1 {} { <br>
if {[fork]!=0} {sleep 3600;continue} <br>
disconnect <br>
spawn priv_prog <br>
expect Password: <br>
send &quot;$expect_out(1,string)\r&quot; <br>
. . . <br>
exit <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">An advantage to
using <b>disconnect</b> over the shell asynchronous process
feature (&amp;) is that <b>Expect</b> can save the terminal
parameters prior to disconnection, and then later apply them
to new ptys. With &amp;, <b>Expect</b> does not have a
chance to read the terminal&rsquo;s parameters since the
terminal is already disconnected by the time <b>Expect</b>
receives control.</p>

<p style="margin-left:11%;"><b>exit</b> <i>[&minus;opts]
[status]</i></p>

<p style="margin-left:20%;">causes <b>Expect</b> to exit or
otherwise prepare to do so.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;onexit</b> flag causes the next argument to be
used as an exit handler. Without an argument, the current
exit handler is returned.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;noexit</b> flag causes <b>Expect</b> to prepare to
exit but stop short of actually returning control to the
operating system. The user-defined exit handler is run as
well as Expect&rsquo;s own internal handlers. No further
Expect commands should be executed. This is useful if you
are running Expect with other Tcl extensions. The current
interpreter (and main window if in the Tk environment)
remain so that other Tcl extensions can clean up. If
Expect&rsquo;s <b>exit</b> is called again (however this
might occur), the handlers are not rerun.</p>

<p style="margin-left:20%; margin-top: 1em">Upon exiting,
all connections to spawned processes are closed. Closure
will be detected as an EOF by spawned processes. <b>exit</b>
takes no other actions beyond what the normal _exit(2)
procedure does. Thus, spawned processes that do not check
for EOF may continue to run. (A variety of conditions are
important to determining, for example, what signals a
spawned process will be sent, but these are
system-dependent, typically documented under exit(3).)
Spawned processes that continue to run will be inherited by
init.</p>

<p style="margin-left:20%; margin-top: 1em"><i>status</i>
(or 0 if not specified) is returned as the exit status of
<b>Expect</b>. <b>exit</b> is implicitly executed if the end
of the script is reached.</p>

<p style="margin-left:11%;"><b>exp_continue</b>
[-continue_timer]</p>

<p style="margin-left:20%;">The command <b>exp_continue</b>
allows <b>expect</b> itself to continue executing rather
than returning as it normally would. By default
<b>exp_continue</b> resets the timeout timer. The
<i>-continue_timer</i> flag prevents timer from being
restarted. (See <b>expect</b> for more information.)</p>

<p style="margin-left:11%;"><b>exp_internal</b>
<i>[&minus;f file] value</i></p>

<p style="margin-left:20%;">causes further commands to send
diagnostic information internal to <b>Expect</b> to stderr
if <i>value</i> is non-zero. This output is disabled if
<i>value</i> is 0. The diagnostic information includes every
character received, and every attempt made to match the
current output against the patterns.</p>

<p style="margin-left:20%; margin-top: 1em">If the optional
<i>file</i> is supplied, all normal and debugging output is
written to that file (regardless of the value of
<i>value</i>). Any previous diagnostic output file is
closed.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;info</b> flag causes exp_internal to return a
description of the most recent non-info arguments given.</p>

<p style="margin-left:11%;"><b>exp_open</b> <i>[args]
[&minus;i spawn_id]</i></p>

<p style="margin-left:20%;">returns a Tcl file identifier
that corresponds to the original spawn id. The file
identifier can then be used as if it were opened by
Tcl&rsquo;s <b>open</b> command. (The spawn id should no
longer be used. A <b>wait</b> should not be executed.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;leaveopen</b> flag leaves the spawn id open for
access through Expect commands. A <b>wait</b> must be
executed on the spawn id.</p>

<p style="margin-left:11%;"><b>exp_pid</b> <i>[&minus;i
spawn_id]</i></p>

<p style="margin-left:20%;">returns the process id
corresponding to the currently spawned process. If the
<b>&minus;i</b> flag is used, the pid returned corresponds
to that of the given spawn id.</p>

<p style="margin-left:11%;"><b>exp_send</b></p>

<p style="margin-left:20%;">is an alias for
<b>send</b>.</p>

<p style="margin-left:11%;"><b>exp_send_error</b></p>

<p style="margin-left:20%;">is an alias for
<b>send_error</b>.</p>

<p style="margin-left:11%;"><b>exp_send_log</b></p>

<p style="margin-left:20%;">is an alias for
<b>send_log</b>.</p>

<p style="margin-left:11%;"><b>exp_send_tty</b></p>

<p style="margin-left:20%;">is an alias for
<b>send_tty</b>.</p>

<p style="margin-left:11%;"><b>exp_send_user</b></p>

<p style="margin-left:20%;">is an alias for
<b>send_user</b>.</p>

<p style="margin-left:11%;"><b>exp_version</b>
<i>[[&minus;exit] version]</i></p>

<p style="margin-left:20%;">is useful for assuring that the
script is compatible with the current version of Expect.</p>

<p style="margin-left:20%; margin-top: 1em">With no
arguments, the current version of <b>Expect</b> is returned.
This version may then be encoded in your script. If you
actually know that you are not using features of recent
versions, you can specify an earlier version.</p>

<p style="margin-left:20%; margin-top: 1em">Versions
consist of three numbers separated by dots. First is the
major number. Scripts written for versions of <b>Expect</b>
with a different major number will almost certainly not
work. <b>exp_version</b> returns an error if the major
numbers do not match.</p>

<p style="margin-left:20%; margin-top: 1em">Second is the
minor number. Scripts written for a version with a greater
minor number than the current version may depend upon some
new feature and might not run. <b>exp_version</b> returns an
error if the major numbers match, but the script minor
number is greater than that of the running
<b>Expect</b>.</p>

<p style="margin-left:20%; margin-top: 1em">Third is a
number that plays no part in the version comparison.
However, it is incremented when the <b>Expect</b> software
distribution is changed in any way, such as by additional
documentation or optimization. It is reset to 0 upon each
new minor version.</p>

<p style="margin-left:20%; margin-top: 1em">With the
<b>&minus;exit</b> flag, <b>Expect</b> prints an error and
exits if the version is out of date.</p>

<p style="margin-left:11%;"><b>expect</b> <i>[[&minus;opts]
pat1 body1] ... [&minus;opts] patn [bodyn]</i></p>

<p style="margin-left:20%;">waits until one of the patterns
matches the output of a spawned process, a specified time
period has passed, or an end-of-file is seen. If the final
body is empty, it may be omitted.</p>

<p style="margin-left:20%; margin-top: 1em">Patterns from
the most recent <b>expect_before</b> command are implicitly
used before any other patterns. Patterns from the most
recent <b>expect_after</b> command are implicitly used after
any other patterns.</p>

<p style="margin-left:20%; margin-top: 1em">If the
arguments to the entire <b>expect</b> statement require more
than one line, all the arguments may be &quot;braced&quot;
into one so as to avoid terminating each line with a
backslash. In this one case, the usual Tcl substitutions
will occur despite the braces.</p>

<p style="margin-left:20%; margin-top: 1em">If a pattern is
the keyword <b>eof</b>, the corresponding body is executed
upon end-of-file. If a pattern is the keyword
<b>timeout</b>, the corresponding body is executed upon
timeout. If no timeout keyword is used, an implicit null
action is executed upon timeout. The default timeout period
is 10 seconds but may be set, for example to 30, by the
command &quot;set timeout 30&quot;. An infinite timeout may
be designated by the value &minus;1. If a pattern is the
keyword <b>default</b>, the corresponding body is executed
upon either timeout or end-of-file.</p>

<p style="margin-left:20%; margin-top: 1em">If a pattern
matches, then the corresponding body is executed.
<b>expect</b> returns the result of the body (or the empty
string if no pattern matched). In the event that multiple
patterns match, the one appearing first is used to select a
body.</p>

<p style="margin-left:20%; margin-top: 1em">Each time new
output arrives, it is compared to each pattern in the order
they are listed. Thus, you may test for absence of a match
by making the last pattern something guaranteed to appear,
such as a prompt. In situations where there is no prompt,
you must use <b>timeout</b> (just like you would if you were
interacting manually).</p>

<p style="margin-left:20%; margin-top: 1em">Patterns are
specified in three ways. By default, patterns are specified
as with Tcl&rsquo;s <b>string match</b> command. (Such
patterns are also similar to C-shell regular expressions
usually referred to as &quot;glob&quot; patterns). The
<b>&minus;gl</b> flag may may be used to protect patterns
that might otherwise match <b>expect</b> flags from doing
so. Any pattern beginning with a &quot;-&quot; should be
protected this way. (All strings starting with &quot;-&quot;
are reserved for future options.)</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following fragment looks for a successful login. (Note
that <b>abort</b> is presumed to be a procedure defined
elsewhere in the script.)</p>

<p style="margin-left:20%; margin-top: 1em">expect { <br>
busy {puts busy\n ; exp_continue} <br>
failed abort <br>
&quot;invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">Quotes are
necessary on the fourth pattern since it contains a space,
which would otherwise separate the pattern from the action.
Patterns with the same action (such as the 3rd and 4th)
require listing the actions again. This can be avoid by
using regexp-style patterns (see below). More information on
forming glob-style patterns can be found in the Tcl
manual.</p>

<p style="margin-left:20%; margin-top: 1em">Regexp-style
patterns follow the syntax defined by Tcl&rsquo;s
<b>regexp</b> (short for &quot;regular expression&quot;)
command. regexp patterns are introduced with the flag
<b>&minus;re</b>. The previous example can be rewritten
using a regexp as:</p>

<p style="margin-left:20%; margin-top: 1em">expect { <br>
busy {puts busy\n ; exp_continue} <br>
&minus;re &quot;failed|invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">Both types of
patterns are &quot;unanchored&quot;. This means that
patterns do not have to match the entire string, but can
begin and end the match anywhere in the string (as long as
everything else matches). Use ^ to match the beginning of a
string, and $ to match the end. Note that if you do not wait
for the end of a string, your responses can easily end up in
the middle of the string as they are echoed from the spawned
process. While still producing correct results, the output
can look unnatural. Thus, use of $ is encouraged if you can
exactly describe the characters at the end of a string.</p>

<p style="margin-left:20%; margin-top: 1em">Note that in
many editors, the ^ and $ match the beginning and end of
lines respectively. However, because expect is not line
oriented, these characters match the beginning and end of
the data (as opposed to lines) currently in the expect
matching buffer. (Also, see the note below on &quot;system
indigestion.&quot;)</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;ex</b> flag causes the pattern to be matched as an
&quot;exact&quot; string. No interpretation of *, ^, etc is
made (although the usual Tcl conventions must still be
observed). Exact patterns are always unanchored.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;nocase</b> flag causes uppercase characters of the
output to compare as if they were lowercase characters. The
pattern is not affected.</p>

<p style="margin-left:20%; margin-top: 1em">While reading
output, more than 2000 bytes can force earlier bytes to be
&quot;forgotten&quot;. This may be changed with the function
<b>match_max</b>. (Note that excessively large values can
slow down the pattern matcher.) If <i>patlist</i> is
<b>full_buffer</b>, the corresponding body is executed if
<i>match_max</i> bytes have been received and no other
patterns have matched. Whether or not the <b>full_buffer</b>
keyword is used, the forgotten characters are written to
expect_out(buffer).</p>

<p style="margin-left:20%; margin-top: 1em">If
<i>patlist</i> is the keyword <b>null</b>, and nulls are
allowed (via the <b>remove_nulls</b> command), the
corresponding body is executed if a single ASCII 0 is
matched. It is not possible to match 0 bytes via glob or
regexp patterns.</p>

<p style="margin-left:20%; margin-top: 1em">Upon matching a
pattern (or eof or full_buffer), any matching and previously
unmatched output is saved in the variable
<i>expect_out(buffer)</i>. Up to 9 regexp substring matches
are saved in the variables <i>expect_out(1,string)</i>
through <i>expect_out(9,string)</i>. If the <b>-indices</b>
flag is used before a pattern, the starting and ending
indices (in a form suitable for <b>lrange</b>) of the 10
strings are stored in the variables
<i>expect_out(X,start)</i> and <i>expect_out(X,end)</i>
where X is a digit, corresponds to the substring position in
the buffer. 0 refers to strings which matched the entire
pattern and is generated for glob patterns as well as regexp
patterns. For example, if a process has produced output of
&quot;abcdefgh\n&quot;, the result of:</p>

<p style="margin-left:20%; margin-top: 1em">expect
&quot;cd&quot;</p>

<p style="margin-left:20%; margin-top: 1em">is as if the
following statements had executed:</p>

<p style="margin-left:20%; margin-top: 1em">set
expect_out(0,string) cd <br>
set expect_out(buffer) abcd</p>

<p style="margin-left:20%; margin-top: 1em">and
&quot;efgh\n&quot; is left in the output buffer. If a
process produced the output &quot;abbbcabkkkka\n&quot;, the
result of:</p>

<p style="margin-left:20%; margin-top: 1em">expect
&minus;indices &minus;re &quot;b(b*).*(k+)&quot;</p>

<p style="margin-left:20%; margin-top: 1em">is as if the
following statements had executed:</p>

<p style="margin-left:20%; margin-top: 1em">set
expect_out(0,start) 1 <br>
set expect_out(0,end) 10 <br>
set expect_out(0,string) bbbcabkkkk <br>
set expect_out(1,start) 2 <br>
set expect_out(1,end) 3 <br>
set expect_out(1,string) bb <br>
set expect_out(2,start) 10 <br>
set expect_out(2,end) 10 <br>
set expect_out(2,string) k <br>
set expect_out(buffer) abbbcabkkkk</p>

<p style="margin-left:20%; margin-top: 1em">and
&quot;a\n&quot; is left in the output buffer. The pattern
&quot;*&quot; (and -re &quot;.*&quot;) will flush the output
buffer without reading any more output from the process.</p>

<p style="margin-left:20%; margin-top: 1em">Normally, the
matched output is discarded from Expect&rsquo;s internal
buffers. This may be prevented by prefixing a pattern with
the <b>&minus;notransfer</b> flag. This flag is especially
useful in experimenting (and can be abbreviated to
&quot;-not&quot; for convenience while experimenting).</p>

<p style="margin-left:20%; margin-top: 1em">The spawn id
associated with the matching output (or eof or full_buffer)
is stored in <i>expect_out(spawn_id)</i>.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;timeout</b> flag causes the current expect command
to use the following value as a timeout instead of using the
value of the timeout variable.</p>

<p style="margin-left:20%; margin-top: 1em">By default,
patterns are matched against output from the current
process, however the <b>&minus;i</b> flag declares the
output from the named spawn_id list be matched against any
following patterns (up to the next <b>&minus;i</b>). The
spawn_id list should either be a whitespace separated list
of spawn_ids or a variable referring to such a list of
spawn_ids.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following example waits for &quot;connected&quot; from
the current process, or &quot;busy&quot;, &quot;failed&quot;
or &quot;invalid password&quot; from the spawn_id named by
$proc2.</p>

<p style="margin-left:20%; margin-top: 1em">expect { <br>
&minus;i $proc2 busy {puts busy\n ; exp_continue} <br>
&minus;re &quot;failed|invalid password&quot; abort <br>
timeout abort <br>
connected <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">The value of
the global variable <i>any_spawn_id</i> may be used to match
patterns to any spawn_ids that are named with all other
<b>&minus;i</b> flags in the current <b>expect</b> command.
The spawn_id from a <b>&minus;i</b> flag with no associated
pattern (i.e., followed immediately by another
<b>&minus;i</b>) is made available to any other patterns in
the same <b>expect</b> command associated with
<i>any_spawn_id.</i></p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;i</b> flag may also name a global variable in
which case the variable is read for a list of spawn ids. The
variable is reread whenever it changes. This provides a way
of changing the I/O source while the command is in
execution. Spawn ids provided this way are called
&quot;indirect&quot; spawn ids.</p>

<p style="margin-left:20%; margin-top: 1em">Actions such as
<b>break</b> and <b>continue</b> cause control structures
(i.e., <b>for</b>, <b>proc</b>) to behave in the usual way.
The command <b>exp_continue</b> allows <b>expect</b> itself
to continue executing rather than returning as it normally
would.</p>

<p style="margin-left:20%; margin-top: 1em">This is useful
for avoiding explicit loops or repeated expect statements.
The following example is part of a fragment to automate
rlogin. The <b>exp_continue</b> avoids having to write a
second <b>expect</b> statement (to look for the prompt
again) if the rlogin prompts for a password.</p>

<p style="margin-left:20%; margin-top: 1em">expect { <br>
Password: { <br>
stty -echo <br>
send_user &quot;password (for $user) on $host: &quot; <br>
expect_user -re &quot;(.*)\n&quot; <br>
send_user &quot;\n&quot; <br>
send &quot;$expect_out(1,string)\r&quot; <br>
stty echo <br>
exp_continue <br>
} incorrect { <br>
send_user &quot;invalid password or account\n&quot; <br>
exit <br>
} timeout { <br>
send_user &quot;connection to $host timed out\n&quot; <br>
exit <br>
} eof { <br>
send_user \ <br>
&quot;connection to host failed: $expect_out(buffer)&quot;
<br>
exit <br>
} -re $prompt <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following fragment might help a user guide an
interaction that is already totally automated. In this case,
the terminal is put into raw mode. If the user presses
&quot;+&quot;, a variable is incremented. If &quot;p&quot;
is pressed, several returns are sent to the process, perhaps
to poke it in some way, and &quot;i&quot; lets the user
interact with the process, effectively stealing away control
from the script. In each case, the <b>exp_continue</b>
allows the current <b>expect</b> to continue pattern
matching after executing the current action.</p>

<p style="margin-left:20%; margin-top: 1em">stty raw
&minus;echo <br>
expect_after { <br>
&minus;i $user_spawn_id <br>
&quot;p&quot; {send &quot;\r\r\r&quot;; exp_continue} <br>
&quot;+&quot; {incr foo; exp_continue} <br>
&quot;i&quot; {interact; exp_continue} <br>
&quot;quit&quot; exit <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">By default,
<b>exp_continue</b> resets the timeout timer. The timer is
not restarted, if <b>exp_continue</b> is called with the
<b>&minus;continue_timer</b> flag.</p>

<p style="margin-left:11%;"><b>expect_after</b>
<i>[expect_args]</i></p>

<p style="margin-left:20%;">works identically to the
<b>expect_before</b> except that if patterns from both
<b>expect</b> and <b>expect_after</b> can match, the
<b>expect</b> pattern is used. See the <b>expect_before</b>
command for more information.</p>

<p style="margin-left:11%;"><b>expect_background</b>
<i>[expect_args]</i></p>

<p style="margin-left:20%;">takes the same arguments as
<b>expect</b>, however it returns immediately. Patterns are
tested whenever new input arrives. The pattern
<b>timeout</b> and <b>default</b> are meaningless to
<b>expect_background</b> and are silently discarded.
Otherwise, the <b>expect_background</b> command uses
<b>expect_before</b> and <b>expect_after</b> patterns just
like <b>expect</b> does.</p>

<p style="margin-left:20%; margin-top: 1em">When
<b>expect_background</b> actions are being evaluated,
background processing for the same spawn id is blocked.
Background processing is unblocked when the action
completes. While background processing is blocked, it is
possible to do a (foreground) <b>expect</b> on the same
spawn id.</p>

<p style="margin-left:20%; margin-top: 1em">It is not
possible to execute an <b>expect</b> while an
<b>expect_background</b> is unblocked.
<b>expect_background</b> for a particular spawn id is
deleted by declaring a new expect_background with the same
spawn id. Declaring <b>expect_background</b> with no pattern
removes the given spawn id from the ability to match
patterns in the background.</p>

<p style="margin-left:11%;"><b>expect_before</b>
<i>[expect_args]</i></p>

<p style="margin-left:20%;">takes the same arguments as
<b>expect</b>, however it returns immediately.
Pattern-action pairs from the most recent
<b>expect_before</b> with the same spawn id are implicitly
added to any following <b>expect</b> commands. If a pattern
matches, it is treated as if it had been specified in the
<b>expect</b> command itself, and the associated body is
executed in the context of the <b>expect</b> command. If
patterns from both <b>expect_before</b> and <b>expect</b>
can match, the <b>expect_before</b> pattern is used.</p>

<p style="margin-left:20%; margin-top: 1em">If no pattern
is specified, the spawn id is not checked for any
patterns.</p>

<p style="margin-left:20%; margin-top: 1em">Unless
overridden by a <b>&minus;i</b> flag, <b>expect_before</b>
patterns match against the spawn id defined at the time that
the <b>expect_before</b> command was executed (not when its
pattern is matched).</p>

<p style="margin-left:20%; margin-top: 1em">The &minus;info
flag causes <b>expect_before</b> to return the current
specifications of what patterns it will match. By default,
it reports on the current spawn id. An optional spawn id
specification may be given for information on that spawn id.
For example</p>

<p style="margin-left:20%; margin-top: 1em">expect_before
-info -i $proc</p>

<p style="margin-left:20%; margin-top: 1em">At most one
spawn id specification may be given. The flag
&minus;indirect suppresses direct spawn ids that come only
from indirect specifications.</p>

<p style="margin-left:20%; margin-top: 1em">Instead of a
spawn id specification, the flag &quot;-all&quot; will cause
&quot;-info&quot; to report on all spawn ids.</p>

<p style="margin-left:20%; margin-top: 1em">The output of
the &minus;info flag can be reused as the argument to
expect_before.</p>

<p style="margin-left:11%;"><b>expect_tty</b>
<i>[expect_args]</i></p>

<p style="margin-left:20%;">is like <b>expect</b> but it
reads characters from /dev/tty (i.e. keystrokes from the
user). By default, reading is performed in cooked mode.
Thus, lines must end with a return in order for
<b>expect</b> to see them. This may be changed via
<b>stty</b> (see the <b>stty</b> command below).</p>

<p style="margin-left:11%;"><b>expect_user</b>
<i>[expect_args]</i></p>

<p style="margin-left:20%;">is like <b>expect</b> but it
reads characters from stdin (i.e. keystrokes from the user).
By default, reading is performed in cooked mode. Thus, lines
must end with a return in order for <b>expect</b> to see
them. This may be changed via <b>stty</b> (see the
<b>stty</b> command below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>fork</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>creates a new process. The new process is an exact copy
of the current <b>Expect</b> process. On success,
<b>fork</b> returns 0 to the new (child) process and returns
the process ID of the child process to the parent process.
On failure (invariably due to lack of resources, e.g., swap
space, memory), <b>fork</b> returns &minus;1 to the parent
process, and no child process is created.</p></td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">Forked
processes exit via the <b>exit</b> command, just like the
original process. Forked processes are allowed to write to
the log files. If you do not disable debugging or logging in
most of the processes, the result can be confusing.</p>

<p style="margin-left:20%; margin-top: 1em">Some pty
implementations may be confused by multiple readers and
writers, even momentarily. Thus, it is safest to <b>fork</b>
before spawning processes.</p>

<p style="margin-left:11%;"><b>interact</b> <i>[string1
body1] ... [stringn [bodyn]]</i></p>

<p style="margin-left:20%;">gives control of the current
process to the user, so that keystrokes are sent to the
current process, and the stdout and stderr of the current
process are returned.</p>

<p style="margin-left:20%; margin-top: 1em">String-body
pairs may be specified as arguments, in which case the body
is executed when the corresponding string is entered. (By
default, the string is not sent to the current process.) The
<b>interpreter</b> command is assumed, if the final body is
missing.</p>

<p style="margin-left:20%; margin-top: 1em">If the
arguments to the entire <b>interact</b> statement require
more than one line, all the arguments may be
&quot;braced&quot; into one so as to avoid terminating each
line with a backslash. In this one case, the usual Tcl
substitutions will occur despite the braces.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following command runs interact with the following
string-body pairs defined: When ^Z is pressed, <b>Expect</b>
is suspended. (The <b>&minus;reset</b> flag restores the
terminal modes.) When ^A is pressed, the user sees &quot;you
typed a control-A&quot; and the process is sent a ^A. When $
is pressed, the user sees the date. When ^C is pressed,
<b>Expect</b> exits. If &quot;foo&quot; is entered, the user
sees &quot;bar&quot;. When ~~ is pressed, the <b>Expect</b>
interpreter runs interactively.</p>

<p style="margin-left:20%; margin-top: 1em">set CTRLZ \032
<br>
interact { <br>
-reset $CTRLZ {exec kill &minus;STOP [pid]} <br>
\001 {send_user &quot;you typed a control&minus;A\n&quot;;
<br>
send &quot;\001&quot; <br>
} <br>
$ {send_user &quot;The date is [clock format [clock
seconds]].&quot;} <br>
\003 exit <br>
foo {send_user &quot;bar&quot;} <br>
~~ <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">In string-body
pairs, strings are matched in the order they are listed as
arguments. Strings that partially match are not sent to the
current process in anticipation of the remainder coming. If
characters are then entered such that there can no longer
possibly be a match, only the part of the string will be
sent to the process that cannot possibly begin another
match. Thus, strings that are substrings of partial matches
can match later, if the original strings that was attempting
to be match ultimately fails.</p>

<p style="margin-left:20%; margin-top: 1em">By default,
string matching is exact with no wild cards. (In contrast,
the <b>expect</b> command uses glob-style patterns by
default.) The <b>&minus;ex</b> flag may be used to protect
patterns that might otherwise match <b>interact</b> flags
from doing so. Any pattern beginning with a &quot;-&quot;
should be protected this way. (All strings starting with
&quot;-&quot; are reserved for future options.)</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;re</b> flag forces the string to be interpreted as
a regexp-style pattern. In this case, matching substrings
are stored in the variable <i>interact_out</i> similarly to
the way <b>expect</b> stores its output in the variable
<b>expect_out</b>. The <b>&minus;indices</b> flag is
similarly supported.</p>

<p style="margin-left:20%; margin-top: 1em">The pattern
<b>eof</b> introduces an action that is executed upon
end-of-file. A separate <b>eof</b> pattern may also follow
the <b>&minus;output</b> flag in which case it is matched if
an eof is detected while writing output. The default
<b>eof</b> action is &quot;return&quot;, so that
<b>interact</b> simply returns upon any EOF.</p>

<p style="margin-left:20%; margin-top: 1em">The pattern
<b>timeout</b> introduces a timeout (in seconds) and action
that is executed after no characters have been read for a
given time. The <b>timeout</b> pattern applies to the most
recently specified process. There is no default timeout. The
special variable &quot;timeout&quot; (used by the
<b>expect</b> command) has no affect on this timeout.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following statement could be used to autologout users
who have not typed anything for an hour but who still get
frequent system messages:</p>

<p style="margin-left:20%; margin-top: 1em">interact -input
$user_spawn_id timeout 3600 return -output \ <br>
$spawn_id</p>

<p style="margin-left:20%; margin-top: 1em">If the pattern
is the keyword <b>null</b>, and nulls are allowed (via the
<b>remove_nulls</b> command), the corresponding body is
executed if a single ASCII 0 is matched. It is not possible
to match 0 bytes via glob or regexp patterns.</p>

<p style="margin-left:20%; margin-top: 1em">Prefacing a
pattern with the flag <b>&minus;iwrite</b> causes the
variable <i>interact_out(spawn_id)</i> to be set to the
spawn_id which matched the pattern (or eof).</p>

<p style="margin-left:20%; margin-top: 1em">Actions such as
<b>break</b> and <b>continue</b> cause control structures
(i.e., <b>for</b>, <b>proc</b>) to behave in the usual way.
However <b>return</b> causes interact to return to its
caller, while <b>inter_return</b> causes <b>interact</b> to
cause a return in its caller. For example, if &quot;proc
foo&quot; called <b>interact</b> which then executed the
action <b>inter_return</b>, <b>proc foo</b> would return.
(This means that if <b>interact</b> calls <b>interpreter</b>
interactively typing <b>return</b> will cause the interact
to continue, while <b>inter_return</b> will cause the
interact to return to its caller.)</p>

<p style="margin-left:20%; margin-top: 1em">During
<b>interact</b>, raw mode is used so that all characters may
be passed to the current process. If the current process
does not catch job control signals, it will stop if sent a
stop signal (by default ^Z). To restart it, send a continue
signal (such as by &quot;kill &minus;CONT
&lt;pid&gt;&quot;). If you really want to send a SIGSTOP to
such a process (by ^Z), consider spawning csh first and then
running your program. On the other hand, if you want to send
a SIGSTOP to <b>Expect</b> itself, first call interpreter
(perhaps by using an escape character), and then press
^Z.</p>

<p style="margin-left:20%; margin-top: 1em">String-body
pairs can be used as a shorthand for avoiding having to
enter the interpreter and execute commands interactively.
The previous terminal mode is used while the body of a
string-body pair is being executed.</p>

<p style="margin-left:20%; margin-top: 1em">For speed,
actions execute in raw mode by default. The
<b>&minus;reset</b> flag resets the terminal to the mode it
had before <b>interact</b> was executed (invariably, cooked
mode). Note that characters entered when the mode is being
switched may be lost (an unfortunate feature of the terminal
driver on some systems). The only reason to use
<b>&minus;reset</b> is if your action depends on running in
cooked mode.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;echo</b> flag sends characters that match the
following pattern back to the process that generated them as
each character is read. This may be useful when the user
needs to see feedback from partially typed patterns.</p>

<p style="margin-left:20%; margin-top: 1em">If a pattern is
being echoed but eventually fails to match, the characters
are sent to the spawned process. If the spawned process then
echoes them, the user will see the characters twice.
<b>&minus;echo</b> is probably only appropriate in
situations where the user is unlikely to not complete the
pattern. For example, the following excerpt is from rftp,
the recursive-ftp script, where the user is prompted to
enter ~g, ~p, or ~l, to get, put, or list the current
directory recursively. These are so far away from the normal
ftp commands, that the user is unlikely to type ~ followed
by anything else, except mistakenly, in which case,
they&rsquo;ll probably just ignore the result anyway.</p>

<p style="margin-left:20%; margin-top: 1em">interact { <br>
-echo ~g {getcurdirectory 1} <br>
-echo ~l {getcurdirectory 0} <br>
-echo ~p {putcurdirectory} <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;nobuffer</b> flag sends characters that match the
following pattern on to the output process as characters are
read.</p>

<p style="margin-left:20%; margin-top: 1em">This is useful
when you wish to let a program echo back the pattern. For
example, the following might be used to monitor where a
person is dialing (a Hayes-style modem). Each time
&quot;atd&quot; is seen the script logs the rest of the
line.</p>

<p style="margin-left:20%; margin-top: 1em">proc lognumber
{} { <br>
interact -nobuffer -re &quot;(.*)\r&quot; return <br>
puts $log &quot;[clock format [clock seconds]]: dialed
$interact_out(1,string)&quot; <br>
}</p>

<p style="margin-left:20%; margin-top: 1em">interact
-nobuffer &quot;atd&quot; lognumber</p>

<p style="margin-left:20%; margin-top: 1em">During
<b>interact</b>, previous use of <b>log_user</b> is ignored.
In particular, <b>interact</b> will force its output to be
logged (sent to the standard output) since it is presumed
the user doesn&rsquo;t wish to interact blindly.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;o</b> flag causes any following key-body pairs to
be applied to the output of the current process. This can be
useful, for example, when dealing with hosts that send
unwanted characters during a telnet session.</p>

<p style="margin-left:20%; margin-top: 1em">By default,
<b>interact</b> expects the user to be writing stdin and
reading stdout of the <b>Expect</b> process itself. The
<b>&minus;u</b> flag (for &quot;user&quot;) makes
<b>interact</b> look for the user as the process named by
its argument (which must be a spawned id).</p>

<p style="margin-left:20%; margin-top: 1em">This allows two
unrelated processes to be joined together without using an
explicit loop. To aid in debugging, Expect diagnostics
always go to stderr (or stdout for certain logging and
debugging information). For the same reason, the
<b>interpreter</b> command will read interactively from
stdin.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the following fragment creates a login process. Then it
dials the user (not shown), and finally connects the two
together. Of course, any process may be substituted for
login. A shell, for example, would allow the user to work
without supplying an account and password.</p>

<p style="margin-left:20%; margin-top: 1em">spawn login
<br>
set login $spawn_id <br>
spawn tip modem <br>
# dial back out to user <br>
# connect user to login <br>
interact &minus;u $login</p>

<p style="margin-left:20%; margin-top: 1em">To send output
to multiple processes, list each spawn id list prefaced by a
<b>&minus;output</b> flag. Input for a group of output spawn
ids may be determined by a spawn id list prefaced by a
<b>&minus;input</b> flag. (Both <b>&minus;input</b> and
<b>&minus;output</b> may take lists in the same form as the
<b>&minus;i</b> flag in the <b>expect</b> command, except
that any_spawn_id is not meaningful in <b>interact</b>.) All
following flags and strings (or patterns) apply to this
input until another -input flag appears. If no
<b>&minus;input</b> appears, <b>&minus;output</b> implies
&quot;&minus;input $user_spawn_id &minus;output&quot;.
(Similarly, with patterns that do not have
<b>&minus;input</b>.) If one <b>&minus;input</b> is
specified, it overrides $user_spawn_id. If a second
<b>&minus;input</b> is specified, it overrides $spawn_id.
Additional <b>&minus;input</b> flags may be specified.</p>

<p style="margin-left:20%; margin-top: 1em">The two implied
input processes default to having their outputs specified as
$spawn_id and $user_spawn_id (in reverse). If a
<b>&minus;input</b> flag appears with no
<b>&minus;output</b> flag, characters from that process are
discarded.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;i</b> flag introduces a replacement for the
current spawn_id when no other <b>&minus;input</b> or
<b>&minus;output</b> flags are used. A &minus;i flag implies
a &minus;o flag.</p>

<p style="margin-left:20%; margin-top: 1em">It is possible
to change the processes that are being interacted with by
using indirect spawn ids. (Indirect spawn ids are described
in the section on the expect command.) Indirect spawn ids
may be specified with the -i, -u, -input, or -output
flags.</p>

<p style="margin-left:11%;"><b>interpreter [args]</b></p>

<p style="margin-left:20%;">causes the user to be
interactively prompted for <b>Expect</b> and Tcl commands.
The result of each command is printed.</p>

<p style="margin-left:20%; margin-top: 1em">Actions such as
<b>break</b> and <b>continue</b> cause control structures
(i.e., <b>for</b>, <b>proc</b>) to behave in the usual way.
However <b>return</b> causes interpreter to return to its
caller, while <b>inter_return</b> causes <b>interpreter</b>
to cause a return in its caller. For example, if &quot;proc
foo&quot; called <b>interpreter</b> which then executed the
action <b>inter_return</b>, <b>proc foo</b> would return.
Any other command causes <b>interpreter</b> to continue
prompting for new commands.</p>

<p style="margin-left:20%; margin-top: 1em">By default, the
prompt contains two integers. The first integer describes
the depth of the evaluation stack (i.e., how many times
Tcl_Eval has been called). The second integer is the Tcl
history identifier. The prompt can be set by defining a
procedure called &quot;prompt1&quot; whose return value
becomes the next prompt. If a statement has open quotes,
parens, braces, or brackets, a secondary prompt (by default
&quot;+&gt; &quot;) is issued upon newline. The secondary
prompt may be set by defining a procedure called
&quot;prompt2&quot;.</p>

<p style="margin-left:20%; margin-top: 1em">During
<b>interpreter</b>, cooked mode is used, even if the its
caller was using raw mode.</p>

<p style="margin-left:20%; margin-top: 1em">If stdin is
closed, <b>interpreter</b> will return unless the
<b>&minus;eof</b> flag is used, in which case the subsequent
argument is invoked.</p>

<p style="margin-left:11%;"><b>log_file</b> <i>[args]
[[&minus;a] file]</i></p>

<p style="margin-left:20%;">If a filename is provided,
<b>log_file</b> will record a transcript of the session
(beginning at that point) in the file. <b>log_file</b> will
stop recording if no argument is given. Any previous log
file is closed.</p>

<p style="margin-left:20%; margin-top: 1em">Instead of a
filename, a Tcl file identifier may be provided by using the
<b>&minus;open</b> or <b>&minus;leaveopen</b> flags. This is
similar to the <b>spawn</b> command. (See <b>spawn</b> for
more info.)</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;a</b> flag forces output to be logged that was
suppressed by the <b>log_user</b> command.</p>

<p style="margin-left:20%; margin-top: 1em">By default, the
<b>log_file</b> command <i>appends</i> to old files rather
than truncating them, for the convenience of being able to
turn logging off and on multiple times in one session. To
truncate files, use the <b>&minus;noappend</b> flag.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>-info</b> flag causes log_file to return a description of
the most recent non-info arguments given.</p>

<p style="margin-left:11%;"><b>log_user</b>
<i>-info|0|1</i></p>

<p style="margin-left:20%;">By default, the send/expect
dialogue is logged to stdout (and a logfile if open). The
logging to stdout is disabled by the command &quot;log_user
0&quot; and reenabled by &quot;log_user 1&quot;. Logging to
the logfile is unchanged.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>-info</b> flag causes log_user to return a description of
the most recent non-info arguments given.</p>

<p style="margin-left:11%;"><b>match_max</b> <i>[&minus;d]
[&minus;i spawn_id] [size]</i></p>

<p style="margin-left:20%;">defines the size of the buffer
(in bytes) used internally by <b>expect</b>. With no
<i>size</i> argument, the current size is returned.</p>

<p style="margin-left:20%; margin-top: 1em">With the
<b>&minus;d</b> flag, the default size is set. (The initial
default is 2000.) With the <b>&minus;i</b> flag, the size is
set for the named spawn id, otherwise it is set for the
current process.</p>

<p style="margin-left:11%;"><b>overlay</b> <i>[&minus;#
spawn_id] [&minus;# spawn_id] [...] program [args]</i></p>

<p style="margin-left:20%;">executes <i>program args</i> in
place of the current <b>Expect</b> program, which
terminates. A bare hyphen argument forces a hyphen in front
of the command name as if it was a login shell. All
spawn_ids are closed except for those named as arguments.
These are mapped onto the named file identifiers.</p>

<p style="margin-left:20%; margin-top: 1em">Spawn_ids are
mapped to file identifiers for the new program to inherit.
For example, the following line runs chess and allows it to
be controlled by the current process &minus; say, a chess
master.</p>

<p style="margin-left:20%; margin-top: 1em">overlay
&minus;0 $spawn_id &minus;1 $spawn_id &minus;2 $spawn_id
chess</p>

<p style="margin-left:20%; margin-top: 1em">This is more
efficient than &quot;interact &minus;u&quot;, however, it
sacrifices the ability to do programmed interaction since
the <b>Expect</b> process is no longer in control.</p>

<p style="margin-left:20%; margin-top: 1em">Note that no
controlling terminal is provided. Thus, if you disconnect or
remap standard input, programs that do job control (shells,
login, etc) will not function properly.</p>

<p style="margin-left:11%;"><b>parity</b> <i>[&minus;d]
[&minus;i spawn_id] [value]</i></p>

<p style="margin-left:20%;">defines whether parity should
be retained or stripped from the output of spawned
processes. If <i>value</i> is zero, parity is stripped,
otherwise it is not stripped. With no <i>value</i> argument,
the current value is returned.</p>

<p style="margin-left:20%; margin-top: 1em">With the
<b>&minus;d</b> flag, the default parity value is set. (The
initial default is 1, i.e., parity is not stripped.) With
the <b>&minus;i</b> flag, the parity value is set for the
named spawn id, otherwise it is set for the current
process.</p>

<p style="margin-left:11%;"><b>remove_nulls</b>
<i>[&minus;d] [&minus;i spawn_id] [value]</i></p>

<p style="margin-left:20%;">defines whether nulls are
retained or removed from the output of spawned processes
before pattern matching or storing in the variable
<i>expect_out</i> or <i>interact_out</i>. If <i>value</i> is
1, nulls are removed. If <i>value</i> is 0, nulls are not
removed. With no <i>value</i> argument, the current value is
returned.</p>

<p style="margin-left:20%; margin-top: 1em">With the
<b>&minus;d</b> flag, the default value is set. (The initial
default is 1, i.e., nulls are removed.) With the
<b>&minus;i</b> flag, the value is set for the named spawn
id, otherwise it is set for the current process.</p>

<p style="margin-left:20%; margin-top: 1em">Whether or not
nulls are removed, <b>Expect</b> will record null bytes to
the log and stdout.</p>

<p style="margin-left:11%;"><b>send</b> <i>[&minus;flags]
string</i></p>

<p style="margin-left:20%;">Sends <i>string</i> to the
current process. For example, the command</p>

<p style="margin-left:20%; margin-top: 1em">send
&quot;hello world\r&quot;</p>

<p style="margin-left:20%; margin-top: 1em">sends the
characters, h e l l o &lt;blank&gt; w o r l d &lt;return&gt;
to the current process. (Tcl includes a printf-like command
(called <b>format</b>) which can build arbitrarily complex
strings.)</p>

<p style="margin-left:20%; margin-top: 1em">Characters are
sent immediately although programs with line-buffered input
will not read the characters until a return character is
sent. A return character is denoted &quot;\r&quot;.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;&minus;</b> flag forces the next argument to be
interpreted as a string rather than a flag. Any string can
be preceded by &quot;&minus;&minus;&quot; whether or not it
actually looks like a flag. This provides a reliable
mechanism to specify variable strings without being tripped
up by those that accidentally look like flags. (All strings
starting with &quot;-&quot; are reserved for future
options.)</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;i</b> flag declares that the string be sent to the
named spawn_id. If the spawn_id is <i>user_spawn_id</i>, and
the terminal is in raw mode, newlines in the string are
translated to return-newline sequences so that they appear
as if the terminal was in cooked mode. The <b>&minus;raw</b>
flag disables this translation.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;null</b> flag sends null characters (0 bytes). By
default, one null is sent. An integer may follow the
<b>&minus;null</b> to indicate how many nulls to send.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;break</b> flag generates a break condition. This
only makes sense if the spawn id refers to a tty device
opened via &quot;spawn -open&quot;. If you have spawned a
process such as tip, you should use tip&rsquo;s convention
for generating a break.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;s</b> flag forces output to be sent
&quot;slowly&quot;, thus avoid the common situation where a
computer outtypes an input buffer that was designed for a
human who would never outtype the same buffer. This output
is controlled by the value of the variable
&quot;send_slow&quot; which takes a two element list. The
first element is an integer that describes the number of
bytes to send atomically. The second element is a real
number that describes the number of seconds by which the
atomic sends must be separated. For example, &quot;set
send_slow {10 .001}&quot; would force &quot;send
&minus;s&quot; to send strings with 1 millisecond in between
each 10 characters sent.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;h</b> flag forces output to be sent (somewhat)
like a human actually typing. Human-like delays appear
between the characters. (The algorithm is based upon a
Weibull distribution, with modifications to suit this
particular application.) This output is controlled by the
value of the variable &quot;send_human&quot; which takes a
five element list. The first two elements are average
interarrival time of characters in seconds. The first is
used by default. The second is used at word endings, to
simulate the subtle pauses that occasionally occur at such
transitions. The third parameter is a measure of variability
where .1 is quite variable, 1 is reasonably variable, and 10
is quite invariable. The extremes are 0 to infinity. The
last two parameters are, respectively, a minimum and maximum
interarrival time. The minimum and maximum are used last and
&quot;clip&quot; the final time. The ultimate average can be
quite different from the given average if the minimum and
maximum clip enough values.</p>

<p style="margin-left:20%; margin-top: 1em">As an example,
the following command emulates a fast and consistent
typist:</p>

<p style="margin-left:20%; margin-top: 1em">set send_human
{.1 .3 1 .05 2} <br>
send &minus;h &quot;I&rsquo;m hungry. Let&rsquo;s do
lunch.&quot;</p>

<p style="margin-left:20%; margin-top: 1em">while the
following might be more suitable after a hangover:</p>

<p style="margin-left:20%; margin-top: 1em">set send_human
{.4 .4 .2 .5 100} <br>
send &minus;h &quot;Goodd party lash night!&quot;</p>

<p style="margin-left:20%; margin-top: 1em">Note that
errors are not simulated, although you can set up error
correction situations yourself by embedding mistakes and
corrections in a send argument.</p>

<p style="margin-left:20%; margin-top: 1em">The flags for
sending null characters, for sending breaks, for forcing
slow output and for human-style output are mutually
exclusive. Only the one specified last will be used.
Furthermore, no <i>string</i> argument can be specified with
the flags for sending null characters or breaks.</p>

<p style="margin-left:20%; margin-top: 1em">It is a good
idea to precede the first <b>send</b> to a process by an
<b>expect</b>. <b>expect</b> will wait for the process to
start, while <b>send</b> cannot. In particular, if the first
<b>send</b> completes before the process starts running, you
run the risk of having your data ignored. In situations
where interactive programs offer no initial prompt, you can
precede <b>send</b> by a delay as in:</p>

<p style="margin-left:20%; margin-top: 1em"># To avoid
giving hackers hints on how to break in, <br>
# this system does not prompt for an external password. <br>
# Wait for 5 seconds for exec to complete <br>
spawn telnet very.secure.gov <br>
sleep 5 <br>
send password\r</p>


<p style="margin-left:20%; margin-top: 1em"><b>exp_send</b>
is an alias for <b>send</b><i>.</i> If you are using Expectk
or some other variant of Expect in the Tk environment,
<b>send</b> is defined by Tk for an entirely different
purpose. <b>exp_send</b> is provided for compatibility
between environments. Similar aliases are provided for other
Expect&rsquo;s other send commands.</p>

<p style="margin-left:11%;"><b>send_error</b>
<i>[&minus;flags] string</i></p>

<p style="margin-left:20%;">is like <b>send</b>, except
that the output is sent to stderr rather than the current
process.</p>

<p style="margin-left:11%;"><b>send_log</b> <i>[&minus;-]
string</i></p>

<p style="margin-left:20%;">is like <b>send</b>, except
that the string is only sent to the log file (see
<b>log_file</b>.) The arguments are ignored if no log file
is open.</p>

<p style="margin-left:11%;"><b>send_tty</b>
<i>[&minus;flags] string</i></p>

<p style="margin-left:20%;">is like <b>send</b>, except
that the output is sent to /dev/tty rather than the current
process.</p>

<p style="margin-left:11%;"><b>send_user</b>
<i>[&minus;flags] string</i></p>

<p style="margin-left:20%;">is like <b>send</b>, except
that the output is sent to stdout rather than the current
process.</p>

<p style="margin-left:11%;"><b>sleep</b> <i>seconds</i></p>

<p style="margin-left:20%;">causes the script to sleep for
the given number of seconds. Seconds may be a decimal
number. Interrupts (and Tk events if you are using Expectk)
are processed while Expect sleeps.</p>

<p style="margin-left:11%;"><b>spawn</b> <i>[args] program
[args]</i></p>

<p style="margin-left:20%;">creates a new process running
<i>program args</i>. Its stdin, stdout and stderr are
connected to Expect, so that they may be read and written by
other <b>Expect</b> commands. The connection is broken by
<b>close</b> or if the process itself closes any of the file
identifiers.</p>

<p style="margin-left:20%; margin-top: 1em">When a process
is started by <b>spawn</b>, the variable <i>spawn_id</i> is
set to a descriptor referring to that process. The process
described by <i>spawn_id</i> is considered the <i>current
process</i>. <i>spawn_id</i> may be read or written, in
effect providing job control.</p>


<p style="margin-left:20%; margin-top: 1em"><i>user_spawn_id</i>
is a global variable containing a descriptor which refers to
the user. For example, when <i>spawn_id</i> is set to this
value, <b>expect</b> behaves like <b>expect_user</b>.</p>


<p style="margin-left:20%; margin-top: 1em"><i>error_spawn_id</i>
is a global variable containing a descriptor which refers to
the standard error. For example, when <i>spawn_id</i> is set
to this value, <b>send</b> behaves like
<b>send_error</b>.</p>


<p style="margin-left:20%; margin-top: 1em"><i>tty_spawn_id</i>
is a global variable containing a descriptor which refers to
/dev/tty. If /dev/tty does not exist (such as in a cron, at,
or batch script), then <i>tty_spawn_id</i> is not defined.
This may be tested as:</p>

<p style="margin-left:20%; margin-top: 1em">if {[info vars
tty_spawn_id]} { <br>
# /dev/tty exists <br>
} else { <br>
# /dev/tty doesn&rsquo;t exist <br>
# probably in cron, batch, or at script <br>
}</p>

<p style="margin-left:20%; margin-top: 1em"><b>spawn</b>
returns the UNIX process id. If no process is spawned, 0 is
returned. The variable <i>spawn_out(slave,name)</i> is set
to the name of the pty slave device.</p>

<p style="margin-left:20%; margin-top: 1em">By default,
<b>spawn</b> echoes the command name and arguments. The
<b>&minus;noecho</b> flag stops <b>spawn</b> from doing
this.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;console</b> flag causes console output to be
redirected to the spawned process. This is not supported on
all systems.</p>

<p style="margin-left:20%; margin-top: 1em">Internally,
<b>spawn</b> uses a pty, initialized the same way as the
user&rsquo;s tty. This is further initialized so that all
settings are &quot;sane&quot; (according to stty(1)). If the
variable <i>stty_init</i> is defined, it is interpreted in
the style of stty arguments as further configuration. For
example, &quot;set stty_init raw&quot; will cause further
spawned processes&rsquo;s terminals to start in raw mode.
<b>&minus;nottycopy</b> skips the initialization based on
the user&rsquo;s tty. <b>&minus;nottyinit</b> skips the
&quot;sane&quot; initialization.</p>

<p style="margin-left:20%; margin-top: 1em">Normally,
<b>spawn</b> takes little time to execute. If you notice
spawn taking a significant amount of time, it is probably
encountering ptys that are wedged. A number of tests are run
on ptys to avoid entanglements with errant processes. (These
take 10 seconds per wedged pty.) Running Expect with the
<b>&minus;d</b> option will show if <b>Expect</b> is
encountering many ptys in odd states. If you cannot kill the
processes to which these ptys are attached, your only
recourse may be to reboot.</p>

<p style="margin-left:20%; margin-top: 1em">If
<i>program</i> cannot be spawned successfully because
exec(2) fails (e.g. when <i>program</i> doesn&rsquo;t
exist), an error message will be returned by the next
<b>interact</b> or <b>expect</b> command as if
<i>program</i> had run and produced the error message as
output. This behavior is a natural consequence of the
implementation of <b>spawn</b>. Internally, spawn forks,
after which the spawned process has no way to communicate
with the original <b>Expect</b> process except by
communication via the spawn_id.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;open</b> flag causes the next argument to be
interpreted as a Tcl file identifier (i.e., returned by
<b>open</b>.) The spawn id can then be used as if it were a
spawned process. (The file identifier should no longer be
used.) This lets you treat raw devices, files, and pipelines
as spawned processes without using a pty. 0 is returned to
indicate there is no associated process. When the connection
to the spawned process is closed, so is the Tcl file
identifier. The <b>&minus;leaveopen</b> flag is similar to
<b>&minus;open</b> except that <b>&minus;leaveopen</b>
causes the file identifier to be left open even after the
spawn id is closed.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;pty</b> flag causes a pty to be opened but no
process spawned. 0 is returned to indicate there is no
associated process. Spawn_id is set as usual.</p>

<p style="margin-left:20%; margin-top: 1em">The variable
<i>spawn_out(slave,fd)</i> is set to a file identifier
corresponding to the pty slave. It can be closed using
&quot;close -slave&quot;.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;ignore</b> flag names a signal to be ignored in
the spawned process. Otherwise, signals get the default
behavior. Signals are named as in the <b>trap</b> command,
except that each signal requires a separate flag.</p>

<p style="margin-left:11%;"><b>strace</b> <i>level</i></p>

<p style="margin-left:20%;">causes following statements to
be printed before being executed. (Tcl&rsquo;s trace command
traces variables.) <i>level</i> indicates how far down in
the call stack to trace. For example, the following command
runs <b>Expect</b> while tracing the first 4 levels of
calls, but none below that.</p>

<p style="margin-left:20%; margin-top: 1em">expect &minus;c
&quot;strace 4&quot; script.exp</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>-info</b> flag causes strace to return a description of
the most recent non-info arguments given.</p>

<p style="margin-left:11%;"><b>stty</b> <i>args</i></p>

<p style="margin-left:20%;">changes terminal modes
similarly to the external stty command.</p>

<p style="margin-left:20%; margin-top: 1em">By default, the
controlling terminal is accessed. Other terminals can be
accessed by appending &quot;&lt; /dev/tty...&quot; to the
command. (Note that the arguments should not be grouped into
a single argument.)</p>

<p style="margin-left:20%; margin-top: 1em">Requests for
status return it as the result of the command. If no status
is requested and the controlling terminal is accessed, the
previous status of the raw and echo attributes are returned
in a form which can later be used by the command.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the arguments <b>raw</b> or <b>&minus;cooked</b> put the
terminal into raw mode. The arguments <b>&minus;raw</b> or
<b>cooked</b> put the terminal into cooked mode. The
arguments <b>echo</b> and <b>&minus;echo</b> put the
terminal into echo and noecho mode respectively.</p>

<p style="margin-left:20%; margin-top: 1em">The following
example illustrates how to temporarily disable echoing. This
could be used in otherwise-automatic scripts to avoid
embedding passwords in them. (See more discussion on this
under EXPECT HINTS below.)</p>

<p style="margin-left:20%; margin-top: 1em">stty
&minus;echo <br>
send_user &quot;Password: &quot; <br>
expect_user -re &quot;(.*)\n&quot; <br>
set password $expect_out(1,string) <br>
stty echo</p>

<p style="margin-left:11%;"><b>system</b> <i>args</i></p>

<p style="margin-left:20%;">gives <i>args</i> to sh(1) as
input, just as if it had been typed as a command from a
terminal. <b>Expect</b> waits until the shell terminates.
The return status from sh is handled the same way that
<b>exec</b> handles its return status.</p>

<p style="margin-left:20%; margin-top: 1em">In contrast to
<b>exec</b> which redirects stdin and stdout to the script,
<b>system</b> performs no redirection (other than that
indicated by the string itself). Thus, it is possible to use
programs which must talk directly to /dev/tty. For the same
reason, the results of <b>system</b> are not recorded in the
log.</p>

<p style="margin-left:11%;"><b>timestamp</b>
<i>[args]</i></p>

<p style="margin-left:20%;">returns a timestamp. With no
arguments, the number of seconds since the epoch is
returned.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;format</b> flag introduces a string which is
returned but with substitutions made according to the POSIX
rules for strftime. For example %a is replaced by an
abbreviated weekday name (i.e., Sat). Others are: <br>
%a abbreviated weekday name <br>
%A full weekday name <br>
%b abbreviated month name <br>
%B full month name <br>
%c date-time as in: Wed Oct 6 11:45:56 1993 <br>
%d day of the month (01-31) <br>
%H hour (00-23) <br>
%I hour (01-12) <br>
%j day (001-366) <br>
%m month (01-12) <br>
%M minute (00-59) <br>
%p am or pm <br>
%S second (00-61) <br>
%u day (1-7, Monday is first day of week) <br>
%U week (00-53, first Sunday is first day of week one) <br>
%V week (01-53, ISO 8601 style) <br>
%w day (0-6) <br>
%W week (00-53, first Monday is first day of week one) <br>
%x date-time as in: Wed Oct 6 1993 <br>
%X time as in: 23:59:59 <br>
%y year (00-99) <br>
%Y year as in: 1993 <br>
%Z timezone (or nothing if not determinable) <br>
%% a bare percent sign</p>

<p style="margin-left:20%; margin-top: 1em">Other %
specifications are undefined. Other characters will be
passed through untouched. Only the C locale is
supported.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;seconds</b> flag introduces a number of seconds
since the epoch to be used as a source from which to format.
Otherwise, the current time is used.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;gmt</b> flag forces timestamp output to use the
GMT timezone. With no flag, the local timezone is used.</p>

<p style="margin-left:11%;"><b>trap</b> <i>[[command]
signals]</i></p>

<p style="margin-left:20%;">causes the given <i>command</i>
to be executed upon future receipt of any of the given
signals. The command is executed in the global scope. If
<i>command</i> is absent, the signal action is returned. If
<i>command</i> is the string SIG_IGN, the signals are
ignored. If <i>command</i> is the string SIG_DFL, the
signals are result to the system default. <i>signals</i> is
either a single signal or a list of signals. Signals may be
specified numerically or symbolically as per signal(3). The
&quot;SIG&quot; prefix may be omitted.</p>

<p style="margin-left:20%; margin-top: 1em">With no
arguments (or the argument &minus;number), <b>trap</b>
returns the signal number of the trap command currently
being executed.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;code</b> flag uses the return code of the command
in place of whatever code Tcl was about to return when the
command originally started running.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;interp</b> flag causes the command to be evaluated
using the interpreter active at the time the command started
running rather than when the trap was declared.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;name</b> flag causes the <b>trap</b> command to
return the signal name of the trap command currently being
executed.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;max</b> flag causes the <b>trap</b> command to
return the largest signal number that can be set.</p>

<p style="margin-left:20%; margin-top: 1em">For example,
the command &quot;trap {send_user &quot;Ouch!&quot;}
SIGINT&quot; will print &quot;Ouch!&quot; each time the user
presses ^C.</p>

<p style="margin-left:20%; margin-top: 1em">By default,
SIGINT (which can usually be generated by pressing ^C) and
SIGTERM cause Expect to exit. This is due to the following
trap, created by default when Expect starts.</p>

<p style="margin-left:20%; margin-top: 1em">trap exit
{SIGINT SIGTERM}</p>

<p style="margin-left:20%; margin-top: 1em">If you use the
-D flag to start the debugger, SIGINT is redefined to start
the interactive debugger. This is due to the following
trap:</p>

<p style="margin-left:20%; margin-top: 1em">trap {exp_debug
1} SIGINT</p>

<p style="margin-left:20%; margin-top: 1em">The debugger
trap can be changed by setting the environment variable
EXPECT_DEBUG_INIT to a new trap command.</p>

<p style="margin-left:20%; margin-top: 1em">You can, of
course, override both of these just by adding trap commands
to your script. In particular, if you have your own
&quot;trap exit SIGINT&quot;, this will override the
debugger trap. This is useful if you want to prevent users
from getting to the debugger at all.</p>

<p style="margin-left:20%; margin-top: 1em">If you want to
define your own trap on SIGINT but still trap to the
debugger when it is running, use:</p>

<p style="margin-left:20%; margin-top: 1em">if
{![exp_debug]} {trap mystuff SIGINT}</p>

<p style="margin-left:20%; margin-top: 1em">Alternatively,
you can trap to the debugger using some other signal.</p>

<p style="margin-left:20%; margin-top: 1em"><b>trap</b>
will not let you override the action for SIGALRM as this is
used internally to <b>Expect</b>. The disconnect command
sets SIGALRM to SIG_IGN (ignore). You can reenable this as
long as you disable it during subsequent spawn commands.</p>

<p style="margin-left:20%; margin-top: 1em">See signal(3)
for more info.</p>

<p style="margin-left:11%;"><b>wait</b> <i>[args]</i></p>

<p style="margin-left:20%;">delays until a spawned process
(or the current process if none is named) terminates.</p>

<p style="margin-left:20%; margin-top: 1em"><b>wait</b>
normally returns a list of four integers. The first integer
is the pid of the process that was waited upon. The second
integer is the corresponding spawn id. The third integer is
-1 if an operating system error occurred, or 0 otherwise. If
the third integer was 0, the fourth integer is the status
returned by the spawned process. If the third integer was
-1, the fourth integer is the value of errno set by the
operating system. The global variable errorCode is also
set.</p>

<p style="margin-left:20%; margin-top: 1em">Additional
elements may appear at the end of the return value from
<b>wait</b>. An optional fifth element identifies a class of
information. Currently, the only possible value for this
element is CHILDKILLED in which case the next two values are
the C-style signal name and a short textual description.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;i</b> flag declares the process to wait
corresponding to the named spawn_id (NOT the process id).
Inside a SIGCHLD handler, it is possible to wait for any
spawned process by using the spawn id -1.</p>

<p style="margin-left:20%; margin-top: 1em">The
<b>&minus;nowait</b> flag causes the wait to return
immediately with the indication of a successful wait. When
the process exits (later), it will automatically disappear
without the need for an explicit wait.</p>

<p style="margin-left:20%; margin-top: 1em">The <b>wait</b>
command may also be used wait for a forked process using the
arguments &quot;-i -1&quot;. Unlike its use with spawned
processes, this command can be executed at any time. There
is no control over which process is reaped. However, the
return value can be checked for the process id.</p>

<h2>LIBRARIES
<a name="LIBRARIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Expect
automatically knows about two built-in libraries for Expect
scripts. These are defined by the directories named in the
variables exp_library and exp_exec_library. Both are meant
to contain utility files that can be used by other
scripts.</p>

<p style="margin-left:11%; margin-top: 1em">exp_library
contains architecture-independent files. exp_exec_library
contains architecture-dependent files. Depending on your
system, both directories may be totally empty. The existence
of the file $exp_exec_library/cat-buffers describes whether
your /bin/cat buffers by default.</p>

<h2>PRETTY-PRINTING
<a name="PRETTY-PRINTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A vgrind
definition is available for pretty-printing <b>Expect</b>
scripts. Assuming the vgrind definition supplied with the
<b>Expect</b> distribution is correctly installed, you can
use it as:</p>

<p style="margin-left:11%; margin-top: 1em">vgrind
&minus;lexpect file</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It many not be
apparent how to put everything together that the man page
describes. I encourage you to read and try out the examples
in the example directory of the <b>Expect</b> distribution.
Some of them are real programs. Others are simply
illustrative of certain techniques, and of course, a couple
are just quick hacks. The INSTALL file has a quick overview
of these programs.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Expect</b> papers (see SEE ALSO) are also useful. While
some papers use syntax corresponding to earlier versions of
Expect, the accompanying rationales are still valid and go
into a lot more detail than this man page.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Extensions may
collide with Expect&rsquo;s command names. For example,
<b>send</b> is defined by Tk for an entirely different
purpose. For this reason, most of the <b>Expect</b> commands
are also available as &quot;exp_XXXX&quot;. Commands and
variables beginning with &quot;exp&quot;, &quot;inter&quot;,
&quot;spawn&quot;, and &quot;timeout&quot; do not have
aliases. Use the extended command names if you need this
compatibility between environments.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Expect</b>
takes a rather liberal view of scoping. In particular,
variables read by commands specific to the <b>Expect</b>
program will be sought first from the local scope, and if
not found, in the global scope. For example, this obviates
the need to place &quot;global timeout&quot; in every
procedure you write that uses <b>expect</b>. On the other
hand, variables written are always in the local scope
(unless a &quot;global&quot; command has been issued). The
most common problem this causes is when spawn is executed in
a procedure. Outside the procedure, <i>spawn_id</i> no
longer exists, so the spawned process is no longer
accessible simply because of scoping. Add a &quot;global
spawn_id&quot; to such a procedure.</p>

<p style="margin-left:11%; margin-top: 1em">If you cannot
enable the multispawning capability (i.e., your system
supports neither select (BSD *.*), poll (SVR&gt;2), nor
something equivalent), <b>Expect</b> will only be able to
control a single process at a time. In this case, do not
attempt to set <i>spawn_id</i>, nor should you execute
processes via exec while a spawned process is running.
Furthermore, you will not be able to <b>expect</b> from
multiple processes (including the user as one) at the same
time.</p>

<p style="margin-left:11%; margin-top: 1em">Terminal
parameters can have a big effect on scripts. For example, if
a script is written to look for echoing, it will misbehave
if echoing is turned off. For this reason, Expect forces
sane terminal parameters by default. Unfortunately, this can
make things unpleasant for other programs. As an example,
the emacs shell wants to change the &quot;usual&quot;
mappings: newlines get mapped to newlines instead of
carriage-return newlines, and echoing is disabled. This
allows one to use emacs to edit the input line.
Unfortunately, Expect cannot possibly guess this.</p>

<p style="margin-left:11%; margin-top: 1em">You can request
that Expect not override its default setting of terminal
parameters, but you must then be very careful when writing
scripts for such environments. In the case of emacs, avoid
depending upon things like echoing and end-of-line
mappings.</p>

<p style="margin-left:11%; margin-top: 1em">The commands
that accepted arguments braced into a single list (the
<b>expect</b> variants and <b>interact</b>) use a heuristic
to decide if the list is actually one argument or many. The
heuristic can fail only in the case when the list actually
does represent a single argument which has multiple embedded
\n&rsquo;s with non-whitespace characters between them. This
seems sufficiently improbable, however the argument
&quot;&minus;nobrace&quot; can be used to force a single
argument to be handled as a single argument. This could
conceivably be used with machine-generated Expect code.
Similarly, -brace forces a single argument to be handle as
multiple patterns/actions.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It was really
tempting to name the program &quot;sex&quot; (for either
&quot;Smart EXec&quot; or &quot;Send-EXpect&quot;), but good
sense (or perhaps just Puritanism) prevailed.</p>

<p style="margin-left:11%; margin-top: 1em">On some
systems, when a shell is spawned, it complains about not
being able to access the tty but runs anyway. This means
your system has a mechanism for gaining the controlling tty
that <b>Expect</b> doesn&rsquo;t know about. Please find out
what it is, and send this information back to me.</p>

<p style="margin-left:11%; margin-top: 1em">Ultrix 4.1 (at
least the latest versions around here) considers timeouts of
above 1000000 to be equivalent to 0.</p>

<p style="margin-left:11%; margin-top: 1em">Digital UNIX
4.0A (and probably other versions) refuses to allocate ptys
if you define a SIGCHLD handler. See grantpt page for more
info.</p>

<p style="margin-left:11%; margin-top: 1em">IRIX 6.0 does
not handle pty permissions correctly so that if Expect
attempts to allocate a pty previously used by someone else,
it fails. Upgrade to IRIX 6.1.</p>

<p style="margin-left:11%; margin-top: 1em">Telnet
(verified only under SunOS 4.1.2) hangs if TERM is not set.
This is a problem under cron, at and in cgi scripts, which
do not define TERM. Thus, you must set it explicitly - to
what type is usually irrelevant. It just has to be set to
something! The following probably suffices for most
cases.</p>

<p style="margin-left:11%; margin-top: 1em">set env(TERM)
vt100</p>

<p style="margin-left:11%; margin-top: 1em">Tip (verified
only under BSDI BSD/OS 3.1 i386) hangs if SHELL and HOME are
not set. This is a problem under cron, at and in cgi
scripts, which do not define these environment variables.
Thus, you must set them explicitly - to what type is usually
irrelevant. It just has to be set to something! The
following probably suffices for most cases.</p>

<p style="margin-left:11%; margin-top: 1em">set env(SHELL)
/bin/sh <br>
set env(HOME) /usr/local/bin</p>

<p style="margin-left:11%; margin-top: 1em">Some
implementations of ptys are designed so that the kernel
throws away any unread output after 10 to 15 seconds (actual
number is implementation-dependent) after the process has
closed the file descriptor. Thus <b>Expect</b> programs such
as</p>

<p style="margin-left:11%; margin-top: 1em">spawn date <br>
sleep 20 <br>
expect</p>

<p style="margin-left:11%; margin-top: 1em">will fail. To
avoid this, invoke non-interactive programs with <b>exec</b>
rather than <b>spawn</b>. While such situations are
conceivable, in practice I have never encountered a
situation in which the final output of a truly interactive
program would be lost due to this behavior.</p>

<p style="margin-left:11%; margin-top: 1em">On the other
hand, Cray UNICOS ptys throw away any unread output
immediately after the process has closed the file
descriptor. I have reported this to Cray and they are
working on a fix.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes a
delay is required between a prompt and a response, such as
when a tty interface is changing UART settings or matching
baud rates by looking for start/stop bits. Usually, all this
is require is to sleep for a second or two. A more robust
technique is to retry until the hardware is ready to receive
input. The following example uses both strategies:</p>

<p style="margin-left:11%; margin-top: 1em">send
&quot;speed 9600\r&quot;; <br>
sleep 1 <br>
expect { <br>
timeout {send &quot;\r&quot;; exp_continue} <br>
$prompt <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">trap
&minus;code will not work with any command that sits in
Tcl&rsquo;s event loop, such as sleep. The problem is that
in the event loop, Tcl discards the return codes from async
event handlers. A workaround is to set a flag in the trap
code. Then check the flag immediately after the command
(i.e., sleep).</p>

<p style="margin-left:11%; margin-top: 1em">The
expect_background command ignores -timeout arguments and has
no concept of timeouts in general.</p>

<h2>EXPECT HINTS
<a name="EXPECT HINTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a
couple of things about <b>Expect</b> that may be
non-intuitive. This section attempts to address some of
these things with a couple of suggestions.</p>

<p style="margin-left:11%; margin-top: 1em">A common expect
problem is how to recognize shell prompts. Since these are
customized differently by differently people and different
shells, portably automating rlogin can be difficult without
knowing the prompt. A reasonable convention is to have users
store a regular expression describing their prompt (in
particular, the end of it) in the environment variable
EXPECT_PROMPT. Code like the following can be used. If
EXPECT_PROMPT doesn&rsquo;t exist, the code still has a good
chance of functioning correctly.</p>

<p style="margin-left:11%; margin-top: 1em">set prompt
&quot;(%|#|\\$) $&quot; ;# default prompt <br>
catch {set prompt $env(EXPECT_PROMPT)}</p>

<p style="margin-left:11%; margin-top: 1em">expect -re
$prompt</p>

<p style="margin-left:11%; margin-top: 1em">I encourage you
to write <b>expect</b> patterns that include the end of
whatever you expect to see. This avoids the possibility of
answering a question before seeing the entire thing. In
addition, while you may well be able to answer questions
before seeing them entirely, if you answer early, your
answer may appear echoed back in the middle of the question.
In other words, the resulting dialogue will be correct but
look scrambled.</p>

<p style="margin-left:11%; margin-top: 1em">Most prompts
include a space character at the end. For example, the
prompt from ftp is &rsquo;f&rsquo;, &rsquo;t&rsquo;,
&rsquo;p&rsquo;, &rsquo;&gt;&rsquo; and &lt;blank&gt;. To
match this prompt, you must account for each of these
characters. It is a common mistake not to include the blank.
Put the blank in explicitly.</p>

<p style="margin-left:11%; margin-top: 1em">If you use a
pattern of the form X*, the * will match all the output
received from the end of X to the last thing received. This
sounds intuitive but can be somewhat confusing because the
phrase &quot;last thing received&quot; can vary depending
upon the speed of the computer and the processing of I/O
both by the kernel and the device driver.</p>

<p style="margin-left:11%; margin-top: 1em">In particular,
humans tend to see program output arriving in huge chunks
(atomically) when in reality most programs produce output
one line at a time. Assuming this is the case, the * in the
pattern of the previous paragraph may only match the end of
the current line even though there seems to be more, because
at the time of the match that was all the output that had
been received.</p>

<p style="margin-left:11%; margin-top: 1em"><b>expect</b>
has no way of knowing that further output is coming unless
your pattern specifically accounts for it.</p>

<p style="margin-left:11%; margin-top: 1em">Even depending
on line-oriented buffering is unwise. Not only do programs
rarely make promises about the type of buffering they do,
but system indigestion can break output lines up so that
lines break at seemingly random places. Thus, if you can
express the last few characters of a prompt when writing
patterns, it is wise to do so.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
waiting for a pattern in the last output of a program and
the program emits something else instead, you will not be
able to detect that with the <b>timeout</b> keyword. The
reason is that <b>expect</b> will not timeout &minus;
instead it will get an <b>eof</b> indication. Use that
instead. Even better, use both. That way if that line is
ever moved around, you won&rsquo;t have to edit the line
itself.</p>

<p style="margin-left:11%; margin-top: 1em">Newlines are
usually converted to carriage return, linefeed sequences
when output by the terminal driver. Thus, if you want a
pattern that explicitly matches the two lines, from, say,
printf(&quot;foo\nbar&quot;), you should use the pattern
&quot;foo\r\nbar&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">A similar
translation occurs when reading from the user, via
<b>expect_user</b>. In this case, when you press return, it
will be translated to a newline. If <b>Expect</b> then
passes that to a program which sets its terminal to raw mode
(like telnet), there is going to be a problem, as the
program expects a true return. (Some programs are actually
forgiving in that they will automatically translate newlines
to returns, but most don&rsquo;t.) Unfortunately, there is
no way to find out that a program put its terminal into raw
mode.</p>

<p style="margin-left:11%; margin-top: 1em">Rather than
manually replacing newlines with returns, the solution is to
use the command &quot;stty raw&quot;, which will stop the
translation. Note, however, that this means that you will no
longer get the cooked line-editing features.</p>


<p style="margin-left:11%; margin-top: 1em"><b>interact</b>
implicitly sets your terminal to raw mode so this problem
will not arise then.</p>

<p style="margin-left:11%; margin-top: 1em">It is often
useful to store passwords (or other private information) in
<b>Expect</b> scripts. This is not recommended since
anything that is stored on a computer is susceptible to
being accessed by anyone. Thus, interactively prompting for
passwords from a script is a smarter idea than embedding
them literally. Nonetheless, sometimes such embedding is the
only possibility.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
the UNIX file system has no direct way of creating scripts
which are executable but unreadable. Systems which support
setgid shell scripts may indirectly simulate this as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Create the
<b>Expect</b> script (that contains the secret data) as
usual. Make its permissions be 750
(&minus;rwxr&minus;x&minus;&minus;&minus;) and owned by a
trusted group, i.e., a group which is allowed to read it. If
necessary, create a new group for this purpose. Next, create
a /bin/sh script with permissions 2751
(&minus;rwxr&minus;s&minus;&minus;x) owned by the same group
as before.</p>

<p style="margin-left:11%; margin-top: 1em">The result is a
script which may be executed (and read) by anyone. When
invoked, it runs the <b>Expect</b> script.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Tcl</b>(3),
<b>libexpect</b>(3) <i><br>
&quot;Exploring Expect: A Tcl-Based Toolkit for Automating
Interactive Programs&quot;</i> by Don Libes, pp. 602, ISBN
1-56592-090-2, O&rsquo;Reilly and Associates, 1995. <i><br>
&quot;expect: Curing Those Uncontrollable Fits of
Interactivity&quot;</i> by Don Libes, Proceedings of the
Summer 1990 USENIX Conference, Anaheim, California, June
11-15, 1990. <i><br>
&quot;Using</i> <b>expect</b> to Automate System
Administration Tasks&quot; by Don Libes, Proceedings of the
1990 USENIX Large Installation Systems Administration
Conference, Colorado Springs, Colorado, October 17-19, 1990.
<i><br>
&quot;Tcl: An Embeddable Command Language&quot;</i> by John
Ousterhout, Proceedings of the Winter 1990 USENIX
Conference, Washington, D.C., January 22-26, 1990. <i><br>
&quot;expect: Scripts for Controlling Interactive
Programs&quot;</i> by Don Libes, Computing Systems, Vol. 4,
No. 2, University of California Press Journals, November
1991. <i><br>
&quot;Regression Testing and Conformance Testing Interactive
Programs&quot;,</i> by Don Libes, Proceedings of the Summer
1992 USENIX Conference, pp. 135-144, San Antonio, TX, June
12-15, 1992. <i><br>
&quot;Kibitz &minus; Connecting Multiple Interactive
Programs Together&quot;,</i> by Don Libes, Software &minus;
Practice &amp; Experience, John Wiley &amp; Sons, West
Sussex, England, Vol. 23, No. 5, May, 1993. <i><br>
&quot;A Debugger for Tcl Applications&quot;,</i> by Don
Libes, Proceedings of the 1993 Tcl/Tk Workshop, Berkeley,
CA, June 10-11, 1993.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Don Libes,
National Institute of Standards and Technology</p>

<h2>ACKNOWLEDGMENTS
<a name="ACKNOWLEDGMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thanks to John
Ousterhout for Tcl, and Scott Paisley for inspiration.
Thanks to Rob Savoye for Expect&rsquo;s autoconfiguration
code.</p>

<p style="margin-left:11%; margin-top: 1em">The HISTORY
file documents much of the evolution of <b>expect</b>. It
makes interesting reading and might give you further insight
to this software. Thanks to the people mentioned in it who
sent me bug fixes and gave other assistance.</p>

<p style="margin-left:11%; margin-top: 1em">Design and
implementation of <b>Expect</b> was paid for in part by the
U.S. government and is therefore in the public domain.
However the author and NIST would like credit if this
program and documentation or portions of them are used.</p>
<hr>
</body>
</html>
