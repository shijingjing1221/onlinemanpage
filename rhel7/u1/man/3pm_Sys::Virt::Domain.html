<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:33:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Sys::Virt::Domain</title>

</head>
<body>

<h1 align="center">Sys::Virt::Domain</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#CONSTANTS">CONSTANTS</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Sys::Virt::Domain
&minus; Represent &amp; manage a libvirt guest domain</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;Sys::Virt::Domain&quot;</tt> module represents a
guest domain managed by the virtual machine monitor.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">my $id =
$dom&minus;&gt;<i>get_id()</i></p>

<p style="margin-left:17%;">Returns an integer with a
locally unique identifier for the domain.</p>

<p style="margin-left:11%;">my $uuid =
$dom&minus;&gt;<i>get_uuid()</i></p>

<p style="margin-left:17%;">Returns a 16 byte long string
containing the raw globally unique identifier (
<small>UUID</small> ) for the domain.</p>

<p style="margin-left:11%;">my $uuid =
$dom&minus;&gt;<i>get_uuid_string()</i></p>

<p style="margin-left:17%;">Returns a printable string
representation of the raw <small>UUID,</small> in the format
&rsquo;
<small>XXXXXXXX&minus;XXXX&minus;XXXX&minus;XXXX&minus;XXXXXXXXXXXX</small>
&rsquo;.</p>

<p style="margin-left:11%;">my $name =
$dom&minus;&gt;<i>get_name()</i></p>

<p style="margin-left:17%;">Returns a string with a locally
unique name of the domain</p>

<p style="margin-left:11%;">my $hostname =
$dom&minus;&gt;<i>get_hostname()</i></p>

<p style="margin-left:17%;">Returns a string representing
the hostname of the guest</p>

<p style="margin-left:11%;">my $str =
$dom&minus;&gt;get_metadata($type, $uri, $flags =0)</p>

<p style="margin-left:17%;">Returns the metadata element of
type <tt>$type</tt> associated with the domain. If
<tt>$type</tt> is
<tt>&quot;Sys::Virt::Domain::METADATA_ELEMENT&quot;</tt>
then the <tt>$uri</tt> parameter specifies the
<small>XML</small> namespace to retrieve, otherwise
<tt>$uri</tt> should be <tt>&quot;undef&quot;</tt>. The
optional <tt>$flags</tt> parameter defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_metadata($type,
$val, $key, $uri, $flags=0)</p>

<p style="margin-left:17%;">Sets the metadata element of
type <tt>$type</tt> to hold the value <tt>$val</tt>. If
<tt>$type</tt> is
<tt>&quot;Sys::Virt::Domain::METADATA_ELEMENT&quot;</tt>
then the <tt>$key</tt> and <tt>$uri</tt> elements specify an
<small>XML</small> namespace to use, otherwise they should
both be <tt>&quot;undef&quot;</tt>. The optional
<tt>$flags</tt> parameter defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>is_active()</i></p>

<p style="margin-left:17%;">Returns a true value if the
domain is currently running</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>is_persistent()</i></p>

<p style="margin-left:17%;">Returns a true value if the
domain has a persistent configuration file defined</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>is_updated()</i></p>

<p style="margin-left:17%;">Returns a true value if the
domain is running and has a persistent configuration file
defined that is out of date compared to the current live
config.</p>

<p style="margin-left:11%;">my $xml =
$dom&minus;&gt;get_xml_description($flags=0)</p>

<p style="margin-left:17%;">Returns an <small>XML</small>
document containing a complete description of the
domain&rsquo;s configuration. The optional <tt>$flags</tt>
parameter controls generation of the <small>XML</small>
document, defaulting to 0 if omitted. It can be one or more
of the <small>XML DUMP</small> constants listed later in
this document.</p>

<p style="margin-left:11%;">my $type =
$dom&minus;&gt;<i>get_os_type()</i></p>

<p style="margin-left:17%;">Returns a string containing the
name of the <small>OS</small> type running within the
domain.</p>


<p style="margin-left:11%;">$dom&minus;&gt;create($flags)</p>

<p style="margin-left:17%;">Start a domain whose
configuration was previously defined using the
<tt>&quot;define_domain&quot;</tt> method in Sys::Virt. The
<tt>$flags</tt> parameter accepts one of the <small>DOMAIN
CREATION</small> constants documented later, and defaults to
0 if omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;create_with_files($fds,
$flags)</p>

<p style="margin-left:17%;">Start a domain whose
configuration was previously defined using the
<tt>&quot;define_domain&quot;</tt> method in Sys::Virt. The
<tt>$fds</tt> parameter is an array of <small>UNIX</small>
file descriptors which will be passed to the init process of
the container. This is only supported with container based
virtualization.The <tt>$flags</tt> parameter accepts one of
the <small>DOMAIN CREATION</small> constants documented
later, and defaults to 0 if omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>undefine()</i></p>

<p style="margin-left:17%;">Remove the configuration
associated with a domain previously defined with the
<tt>&quot;define_domain&quot;</tt> method in Sys::Virt. If
the domain is running, you probably want to use the
<tt>&quot;shutdown&quot;</tt> or
<tt>&quot;destroy&quot;</tt> methods instead.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>suspend()</i></p>

<p style="margin-left:17%;">Temporarily stop execution of
the domain, allowing later continuation by calling the
<tt>&quot;resume&quot;</tt> method.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>resume()</i></p>

<p style="margin-left:17%;">Resume execution of a domain
previously halted with the <tt>&quot;suspend&quot;</tt>
method.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>pm_wakeup()</i></p>

<p style="margin-left:17%;">Wakeup the guest from power
management suspend state</p>


<p style="margin-left:11%;">$dom&minus;&gt;pm_suspend_for_duration($target,
$duration, $flags=0)</p>

<p style="margin-left:17%;">Tells the guest
<small>OS</small> to enter the power management suspend
state identified by <tt>$target</tt>. The <tt>$target</tt>
parameter should be one of the <small>NODE SUSPEND
CONTANTS</small> listed in <tt>&quot;Sys::Virt&quot;</tt>.
The <tt>$duration</tt> specifies when the guest should
automatically wakeup. The <tt>$flags</tt> parameter is
optional and defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;save($filename)</p>

<p style="margin-left:17%;">Take a snapshot of the
domain&rsquo;s state and save the information to the file
named in the <tt>$filename</tt> parameter. The domain can
later be restored from this file with the
<tt>&quot;restore_domain&quot;</tt> method on the Sys::Virt
object.</p>


<p style="margin-left:11%;">$dom&minus;&gt;managed_save($flags=0)</p>

<p style="margin-left:17%;">Take a snapshot of the
domain&rsquo;s state and save the information to a managed
save location. The domain will be automatically restored
with this state when it is next started. The <tt>$flags</tt>
parameter is unused and defaults to zero.</p>

<p style="margin-left:11%;">$bool =
$dom&minus;&gt;has_managed_save_image($flags=0)</p>

<p style="margin-left:17%;">Return a non-zero value if the
domain has a managed save image that will be used at next
start. The <tt>$flags</tt> parameter is unused and defaults
to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;managed_save_remove($flags=0)</p>

<p style="margin-left:17%;">Remove the current managed save
image, causing the guest to perform a full boot next time it
is started. The <tt>$flags</tt> parameter is unused and
defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;core_dump($filename[,
$flags])</p>

<p style="margin-left:17%;">Trigger a core dump of the
guest virtual machine, saving its memory image to
<tt>$filename</tt> so it can be analysed by tools such as
<tt>&quot;crash&quot;</tt>. The optional <tt>$flags</tt>
flags parameter is currently unused and if omitted will
default to 0.</p>


<p style="margin-left:11%;">$dom&minus;&gt;core_dump_format($filename,
$format, [, $flags])</p>

<p style="margin-left:17%;">Trigger a core dump of the
guest virtual machine, saving its memory image to
<tt>$filename</tt> so it can be analysed by tools such as
<tt>&quot;crash&quot;</tt>. The <tt>$format</tt> parameter
is one of the core dump format constants. The optional
<tt>$flags</tt> flags parameter is currently unused and if
omitted will default to 0. <br>
Sys::Virt::Domain::CORE_DUMP_FORMAT_RAW</p>

<p style="margin-left:23%;">The raw <small>ELF</small>
format</p>


<p style="margin-left:17%;">Sys::Virt::Domain::CORE_DUMP_FORMAT_KDUMP_ZLIB</p>

<p style="margin-left:23%;">The zlib compressed
<small>ELF</small> format</p>


<p style="margin-left:17%;">Sys::Virt::Domain::CORE_DUMP_FORMAT_KDUMP_SNAPPY</p>

<p style="margin-left:23%;">The snappy compressed
<small>ELF</small> format</p>


<p style="margin-left:17%;">Sys::Virt::Domain::CORE_DUMP_FORMAT_KDUMP_LZO</p>

<p style="margin-left:23%;">The lzo compressed
<small>ELF</small> format</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>destroy()</i></p>

<p style="margin-left:17%;">Immediately poweroff the
machine. This is equivalent to removing the power plug. The
guest <small>OS</small> is given no time to cleanup / save
state. For a clean poweroff sequence, use the
<tt>&quot;shutdown&quot;</tt> method instead.</p>

<p style="margin-left:11%;">my $info =
$dom&minus;&gt;<i>get_info()</i></p>

<p style="margin-left:17%;">Returns a hash reference
summarising the execution state of the domain. The elements
of the hash are as follows: <br>
maxMem</p>

<p style="margin-left:23%;">The maximum memory allowed for
this domain, in kilobytes</p>

<p style="margin-left:17%;">memory</p>

<p style="margin-left:23%;">The current memory allocated to
the domain in kilobytes</p>

<p style="margin-left:17%;">cpuTime</p>

<p style="margin-left:23%;">The amount of
<small>CPU</small> time used by the domain</p>

<p style="margin-left:17%;">nrVirtCpu</p>

<p style="margin-left:23%;">The current number of virtual
CPUs enabled in the domain</p>

<p style="margin-left:17%;">state</p>

<p style="margin-left:23%;">The execution state of the
machine, which will be one of the constants
&amp;Sys::Virt::Domain::STATE_*.</p>

<p style="margin-left:11%;">my ($state, $reason) =
$dom&minus;&gt;<i>get_state()</i></p>

<p style="margin-left:17%;">Returns an array whose values
specify the current state of the guest, and the reason for
it being in that state. The <tt>$state</tt> values are the
same as for the <tt>&quot;get_info&quot;</tt>
<small>API,</small> and the <tt>$reason</tt> values come
from: <br>
Sys::Virt::Domain::STATE_CRASHED_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has crashed</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_CRASHED_PANICKED</p>

<p style="margin-left:23%;">The domain has crashed due to a
kernel panic</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_NOSTATE_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has no state</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_DUMP</p>

<p style="margin-left:23%;">The guest is paused due to a
core dump operation</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The guest is paused due to a
snapshot</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_IOERROR</p>

<p style="margin-left:23%;">The guest is paused due to an
I/O error</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_MIGRATION</p>

<p style="margin-left:23%;">The guest is paused due to
migration</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_SAVE</p>

<p style="margin-left:23%;">The guest is paused due to a
save operation</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has paused</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_USER</p>

<p style="margin-left:23%;">The guest is paused at admin
request</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_WATCHDOG</p>

<p style="margin-left:23%;">The guest is paused due to the
watchdog</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_SHUTTING_DOWN</p>

<p style="margin-left:23%;">The guest is paused while
domain shutdown takes place</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_SNAPSHOT</p>

<p style="margin-left:23%;">The guest is paused while a
snapshot takes place</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PAUSED_CRASHED</p>

<p style="margin-left:23%;">The guest is paused due to a
kernel panic</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_BOOTED</p>

<p style="margin-left:23%;">The guest is running after
being booted</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The guest is running after
restore from snapshot</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_MIGRATED</p>

<p style="margin-left:23%;">The guest is running after
migration</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_MIGRATION_CANCELED</p>

<p style="margin-left:23%;">The guest is running after
migration abort</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_RESTORED</p>

<p style="margin-left:23%;">The guest is running after
restore from file</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_SAVE_CANCELED</p>

<p style="margin-left:23%;">The guest is running after save
cancel</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has started</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_UNPAUSED</p>

<p style="margin-left:23%;">The guest is running after a
resume</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_WAKEUP</p>

<p style="margin-left:23%;">The guest is running after
wakeup from power management suspend</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_RUNNING_CRASHED</p>

<p style="margin-left:23%;">The guest was restarted after
crashing</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_BLOCKED_UNKNOWN</p>

<p style="margin-left:23%;">The guest is blocked for an
unknown reason</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTDOWN_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has shutdown</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTDOWN_USER</p>

<p style="margin-left:23%;">The guest is shutdown due to
admin request</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_CRASHED</p>

<p style="margin-left:23%;">The guest is shutoff after a
crash</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_DESTROYED</p>

<p style="margin-left:23%;">The guest is shutoff after
being destroyed</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_FAILED</p>

<p style="margin-left:23%;">The guest is shutoff due to a
virtualization failure</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The guest is shutoff after a
snapshot</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_MIGRATED</p>

<p style="margin-left:23%;">The guest is shutoff after
migration</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_SAVED</p>

<p style="margin-left:23%;">The guest is shutoff after a
save</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_SHUTDOWN</p>

<p style="margin-left:23%;">The guest is shutoff due to
controlled shutdown</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_SHUTOFF_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
has shutoff</p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PMSUSPENDED_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
was suspended to <small>RAM</small></p>


<p style="margin-left:17%;">Sys::Virt::Domain::STATE_PMSUSPENDED_DISK_UNKNOWN</p>

<p style="margin-left:23%;">It is not known why the domain
was suspended to disk</p>

<p style="margin-left:11%;">my $info =
$dom&minus;&gt;get_control_info($flags=0)</p>

<p style="margin-left:17%;">Returns a hash reference
providing information about the control channel. The
returned keys in the hash are <br>
&quot;state&quot;</p>

<p style="margin-left:23%;">One of the <small>CONTROL
INFO</small> constants listed later</p>

<p style="margin-left:17%;">&quot;details&quot;</p>

<p style="margin-left:23%;">Currently unsed, always 0.</p>

<p style="margin-left:17%;">&quot;stateTime&quot;</p>

<p style="margin-left:23%;">The elapsed time since the
control channel entered the current state.</p>

<p style="margin-left:11%;">my $time =
$dom&minus;&gt;get_time($flags=0);</p>

<p style="margin-left:17%;">Get the current time of the
guest, in seconds and nanoseconds. The <tt>$flags</tt>
parameter is currently unused and defaults to zero. The
return value is an array ref with two elements, the first
contains the time in seconds, the second contains the
remaining nanoseconds.</p>

<p style="margin-left:11%;">$dom&minus;&gt;set_time($secs,
$nsecs, $flags=0);</p>

<p style="margin-left:17%;">Set the current time of the
guest, in seconds and nanoseconds. The <tt>$flags</tt>
parameter accepts one of <br>
&quot;Sys::Virt::Domain::TIME_SYNC&quot;</p>

<p style="margin-left:23%;">Re-sync domain time from
domain&rsquo;s <small>RTC.</small></p>

<p style="margin-left:11%;">my @errs =
$dom&minus;&gt;get_disk_errors($flags=0)</p>

<p style="margin-left:17%;">Returns a list of all disk
errors that have occurred on the backing store for the
guest&rsquo;s virtual disks. The returned array elements are
hash references, containing two keys <br>
&quot;path&quot;</p>

<p style="margin-left:23%;">The path of the disk with an
error</p>

<p style="margin-left:17%;">&quot;error&quot;</p>

<p style="margin-left:23%;">The error type</p>


<p style="margin-left:11%;">$dom&minus;&gt;send_key($keycodeset,
$holdtime, \@keycodes, $flags=0)</p>

<p style="margin-left:17%;">Sends a sequence of keycodes to
the guest domain. The <tt>$keycodeset</tt> should be one of
the constants listed later in the <small>KEYCODE SET</small>
section. <tt>$holdtiem</tt> is the duration, in
milliseconds, to keep the key pressed before releasing it
and sending the next keycode. <tt>@keycodes</tt> is an array
reference containing the list of keycodes to send to the
guest. The elements in the array should be keycode values
from the specified keycode set. <tt>$flags</tt> is currently
unused.</p>

<p style="margin-left:11%;">my $info =
$dom&minus;&gt;get_block_info($dev, $flags=0)</p>

<p style="margin-left:17%;">Returns a hash reference
summarising the disk usage of the host backing store for a
guest block device. The <tt>$dev</tt> parameter should be
the path to the backing store on the host. <tt>$flags</tt>
is currently unused and defaults to 0 if omitted. The
returned hash contains the following elements <br>
capacity</p>

<p style="margin-left:23%;">Logical size in bytes of the
block device backing image *</p>

<p style="margin-left:17%;">allocation</p>

<p style="margin-left:23%;">Highest allocated extent in
bytes of the block device backing image</p>

<p style="margin-left:17%;">physical</p>

<p style="margin-left:23%;">Physical size in bytes of the
container of the backing image</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_max_memory($mem)</p>

<p style="margin-left:17%;">Set the maximum memory for the
domain to the value <tt>$mem</tt>. The value of the
<tt>$mem</tt> parameter is specified in kilobytes.</p>

<p style="margin-left:11%;">$mem =
$dom&minus;&gt;<i>get_max_memory()</i></p>

<p style="margin-left:17%;">Returns the current maximum
memory allowed for this domain in kilobytes.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_memory($mem,
$flags)</p>

<p style="margin-left:17%;">Set the current memory for the
domain to the value <tt>$mem</tt>. The value of the
<tt>$mem</tt> parameter is specified in kilobytes. This must
be less than, or equal to the domain&rsquo;s max memory
limit. The <tt>$flags</tt> parameter can control whether the
update affects the live guest, or inactive config,
defaulting to modifying the current state.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_memory_stats_period($period,
$flags)</p>

<p style="margin-left:17%;">Set the period on which guests
memory stats are refreshed, with <tt>$period</tt> being a
value in seconds. The <tt>$flags</tt> parameter is currently
unused.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>shutdown()</i></p>

<p style="margin-left:17%;">Request that the guest
<small>OS</small> perform a graceful shutdown and poweroff.
This usually requires some form of cooperation from the
guest operating system, such as responding to an
<small>ACPI</small> signal, or a guest agent process. For an
immediate, forceful poweroff, use the
<tt>&quot;destroy&quot;</tt> method instead.</p>


<p style="margin-left:11%;">$dom&minus;&gt;reboot([$flags])</p>

<p style="margin-left:17%;">Request that the guest
<small>OS</small> perform a graceful shutdown and optionally
restart. The optional <tt>$flags</tt> parameter is currently
unused and if omitted defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;reset([$flags])</p>

<p style="margin-left:17%;">Perform a hardware reset of the
virtual machine. The guest <small>OS</small> is given no
opportunity to shutdown gracefully. The optional
<tt>$flags</tt> parameter is currently unused and if omitted
defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>get_max_vcpus()</i></p>

<p style="margin-left:17%;">Return the maximum number of
vcpus that are configured for the domain</p>


<p style="margin-left:11%;">$dom&minus;&gt;attach_device($xml[,
$flags])</p>

<p style="margin-left:17%;">Hotplug a new device whose
configuration is given by <tt>$xml</tt>, to the running
guest. The optional &lt;$flags&gt; parameter defaults to 0,
but can accept one of the device hotplug flags described
later.</p>


<p style="margin-left:11%;">$dom&minus;&gt;detach_device($xml[,
$flags])</p>

<p style="margin-left:17%;">Hotunplug a existing device
whose configuration is given by <tt>$xml</tt>, from the
running guest. The optional &lt;$flags&gt; parameter
defaults to 0, but can accept one of the device hotplug
flags described later.</p>


<p style="margin-left:11%;">$dom&minus;&gt;update_device($xml[,
$flags])</p>

<p style="margin-left:17%;">Update the configuration of an
existing device. The new configuration is given by
<tt>$xml</tt>. The optional &lt;$flags&gt; parameter
defaults to 0 but can accept one of the device hotplug flags
described later.</p>

<p style="margin-left:11%;">$data =
$dom&minus;&gt;block_peek($path, $offset, $size[,
$flags])</p>

<p style="margin-left:17%;">Peek into the guest disk
<tt>$path</tt>, at byte <tt>$offset</tt> capturing
<tt>$size</tt> bytes of data. The returned scalar may
contain embedded NULLs. The optional <tt>$flags</tt>
parameter is currently unused and if omitted defaults to
zero.</p>

<p style="margin-left:11%;">$data =
$dom&minus;&gt;memory_peek($offset, $size[, $flags])</p>

<p style="margin-left:17%;">Peek into the guest memory at
byte <tt>$offset</tt> virtual address, capturing
<tt>$size</tt> bytes of memory. The return scalar may
contain embedded NULLs. The optional <tt>$flags</tt>
parameter is currently unused and if omitted defaults to
zero.</p>

<p style="margin-left:11%;">$flag =
$dom&minus;&gt;<i>get_autostart()</i>;</p>

<p style="margin-left:17%;">Return a true value if the
guest domain is configured to automatically start upon boot.
Return false, otherwise</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_autostart($flag)</p>

<p style="margin-left:17%;">Set the state of the autostart
flag, which determines whether the guest will automatically
start upon boot of the host <small>OS</small></p>


<p style="margin-left:11%;">$dom&minus;&gt;set_vcpus($count,
[$flags])</p>

<p style="margin-left:17%;">Set the number of virtual CPUs
in the guest <small>VM</small> to <tt>$count</tt>. The
optional <tt>$flags</tt> parameter can be used to control
whether the setting changes the live config or inactive
config.</p>

<p style="margin-left:11%;">$count =
$dom&minus;&gt;get_vcpus([$flags])</p>

<p style="margin-left:17%;">Get the number of virtual CPUs
in the guest <small>VM.</small> The optional <tt>$flags</tt>
parameter can be used to control whether to query the
setting of the live config or inactive config.</p>

<p style="margin-left:11%;">$type =
$dom&minus;&gt;<i>get_scheduler_type()</i></p>

<p style="margin-left:17%;">Return the scheduler type for
the guest domain</p>

<p style="margin-left:11%;">$stats =
$dom&minus;&gt;block_stats($path)</p>

<p style="margin-left:17%;">Fetch the current I/O
statistics for the block device given by <tt>$path</tt>. The
returned hash reference contains keys for <br>
&quot;rd_req&quot;</p>

<p style="margin-left:23%;">Number of read requests</p>

<p style="margin-left:17%;">&quot;rd_bytes&quot;</p>

<p style="margin-left:23%;">Number of bytes read</p>

<p style="margin-left:17%;">&quot;wr_req&quot;</p>

<p style="margin-left:23%;">Number of write requests</p>

<p style="margin-left:17%;">&quot;wr_bytes&quot;</p>

<p style="margin-left:23%;">Number of bytes written</p>

<p style="margin-left:17%;">&quot;errs&quot;</p>

<p style="margin-left:23%;">Some kind of error count</p>

<p style="margin-left:11%;">my $params =
$dom&minus;&gt;get_scheduler_parameters($flags=0)</p>

<p style="margin-left:17%;">Return the set of scheduler
tunable parameters for the guest, as a hash reference. The
precise set of keys in the hash are specific to the
hypervisor.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_scheduler_parameters($params,
$flags=0)</p>

<p style="margin-left:17%;">Update the set of scheduler
tunable parameters. The value names for tunables vary, and
can be discovered using the
<tt>&quot;get_scheduler_params&quot;</tt> call</p>

<p style="margin-left:11%;">my $params =
$dom&minus;&gt;get_memory_parameters($flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of memory tunable parameters for the
guest. The keys in the hash are one of the constants
<small>MEMORY PARAMETERS</small> described later. The
<tt>$flags</tt> parameter accepts one or more the
<small>CONFIG OPTION</small> constants documented later, and
defaults to 0 if omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_memory_parameters($params,
$flags=0)</p>

<p style="margin-left:17%;">Update the memory tunable
parameters for the guest. The <tt>$params</tt> should be a
hash reference whose keys are one of the <small>MEMORY
PARAMETERS</small> constants. The <tt>$flags</tt> parameter
accepts one or more the <small>CONFIG OPTION</small>
constants documented later, and defaults to 0 if
omitted.</p>

<p style="margin-left:11%;">my $params =
$dom&minus;&gt;get_blkio_parameters($flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of blkio tunable parameters for the
guest. The keys in the hash are one of the constants
<small>BLKIO PARAMETERS</small> described later. The
<tt>$flags</tt> parameter accepts one or more the
<small>CONFIG OPTION</small> constants documented later, and
defaults to 0 if omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_blkio_parameters($params,
$flags=0)</p>

<p style="margin-left:17%;">Update the blkio tunable
parameters for the guest. The <tt>$params</tt> should be a
hash reference whose keys are one of the <small>BLKIO
PARAMETERS</small> constants. The <tt>$flags</tt> parameter
accepts one or more the <small>CONFIG OPTION</small>
constants documented later, and defaults to 0 if
omitted.</p>

<p style="margin-left:11%;">$stats =
$dom&minus;&gt;get_block_iotune($disk, $flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of blkio tunable parameters for the guest
disk <tt>$disk</tt>. The keys in the hash are one of the
constants <small>BLOCK IOTUNE PARAMETERS</small> described
later.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_block_iotune($disk,
$params, $flags=0);</p>

<p style="margin-left:17%;">Update the blkio tunable
parameters for the guest disk <tt>$disk</tt>. The
<tt>$params</tt> should be a hash reference whose keys are
one of the <small>BLOCK IOTUNE PARAMETERS</small>
constants.</p>

<p style="margin-left:11%;">my $params =
$dom&minus;&gt;get_interface_parameters($intf, $flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of interface tunable parameters for the
guest. The keys in the hash are one of the constants
<small>INTERFACE PARAMETERS</small> described later.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_interface_parameters($intf,
$params, $flags=0)</p>

<p style="margin-left:17%;">Update the interface tunable
parameters for the guest. The <tt>$params</tt> should be a
hash reference whose keys are one of the <small>INTERFACE
PARAMETERS</small> constants.</p>

<p style="margin-left:11%;">my $params =
$dom&minus;&gt;get_numa_parameters($flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of numa tunable parameters for the guest.
The keys in the hash are one of the constants <small>NUMA
PARAMETERS</small> described later. The <tt>$flags</tt>
parameter accepts one or more the <small>CONFIG
OPTION</small> constants documented later, and defaults to 0
if omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_numa_parameters($params,
$flags=0)</p>

<p style="margin-left:17%;">Update the numa tunable
parameters for the guest. The <tt>$params</tt> should be a
hash reference whose keys are one of the <small>NUMA
PARAMETERS</small> constants. The <tt>$flags</tt> parameter
accepts one or more the <small>CONFIG OPTION</small>
constants documented later, and defaults to 0 if
omitted.</p>


<p style="margin-left:11%;">$dom&minus;&gt;block_resize($disk,
$newsize, $flags=0)</p>

<p style="margin-left:17%;">Resize the disk <tt>$disk</tt>
to have new size <tt>$newsize</tt> <small>KB.</small> If the
disk is backed by a special image format, the actual resize
is done by the hypervisor. If the disk is backed by a raw
file, or block device, the resize must be done prior to
invoking this <small>API</small> call, and it merely updates
the hypervisor&rsquo;s view of the disk size. The following
flags may be used <br>
Sys::Virt::Domain::BLOCK_RESIZE_BYTES</p>

<p style="margin-left:23%;">Treat <tt>$newsize</tt> as if
it were in bytes, rather than <small>KB.</small></p>


<p style="margin-left:11%;">$dom&minus;&gt;interface_stats($path)</p>

<p style="margin-left:17%;">Fetch the current I/O
statistics for the block device given by <tt>$path</tt>. The
returned hash containins keys for <br>
&quot;rx_bytes&quot;</p>

<p style="margin-left:23%;">Total bytes received</p>

<p style="margin-left:17%;">&quot;rx_packets&quot;</p>

<p style="margin-left:23%;">Total packets received</p>

<p style="margin-left:17%;">&quot;rx_errs&quot;</p>

<p style="margin-left:23%;">Total packets received with
errors</p>

<p style="margin-left:17%;">&quot;rx_drop&quot;</p>

<p style="margin-left:23%;">Total packets drop at
reception</p>

<p style="margin-left:17%;">&quot;tx_bytes&quot;</p>

<p style="margin-left:23%;">Total bytes transmitted</p>

<p style="margin-left:17%;">&quot;tx_packets&quot;</p>

<p style="margin-left:23%;">Total packets transmitted</p>

<p style="margin-left:17%;">&quot;tx_errs&quot;</p>

<p style="margin-left:23%;">Total packets transmitted with
errors</p>

<p style="margin-left:17%;">&quot;tx_drop&quot;</p>

<p style="margin-left:23%;">Total packets dropped at
transmission.</p>


<p style="margin-left:11%;">$dom&minus;&gt;memory_stats($flags=0)</p>

<p style="margin-left:17%;">Fetch the current memory
statistics for the guest domain. The <tt>$flags</tt>
parameter is currently unused and can be omitted. The
returned hash containins keys for <br>
&quot;swap_in&quot;</p>

<p style="margin-left:23%;">Data read from swap space</p>

<p style="margin-left:17%;">&quot;swap_out&quot;</p>

<p style="margin-left:23%;">Data written to swap space</p>

<p style="margin-left:17%;">&quot;major_fault&quot;</p>

<p style="margin-left:23%;">Page fault involving disk
I/O</p>

<p style="margin-left:17%;">&quot;minor_fault&quot;</p>

<p style="margin-left:23%;">Page fault not involving disk
I/O</p>

<p style="margin-left:17%;">&quot;unused&quot;</p>

<p style="margin-left:23%;">Memory not used by the
system</p>

<p style="margin-left:17%;">&quot;available&quot;</p>

<p style="margin-left:23%;">Total memory seen by guest</p>

<p style="margin-left:11%;">$info =
$dom&minus;&gt;<i>get_security_label()</i></p>

<p style="margin-left:17%;">Fetch information about the
security label assigned to the guest domain. The returned
hash reference has two keys, <tt>&quot;model&quot;</tt>
gives the name of the security model in effect (eg
<tt>&quot;selinux&quot;</tt>), while
<tt>&quot;label&quot;</tt> provides the name of the security
label applied to the domain. This method only returns
information about the first security label. To retrieve all
labels, use
<tt>&quot;get_security_label_list&quot;</tt>.</p>

<p style="margin-left:11%;">@info =
$dom&minus;&gt;<i>get_security_label_list()</i></p>

<p style="margin-left:17%;">Fetches information about all
security labels assigned to the guest domain. The elements
in the returned array are all hash references, whose keys
are as described for
<tt>&quot;get_security_label&quot;</tt>.</p>

<p style="margin-left:11%;">$ddom =
$dom&minus;&gt;migrate(destcon, \%params, flags=0)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. The <tt>&quot;destcon&quot;</tt> parameter
should be a <tt>&quot;Sys::Virt&quot;</tt> connection to the
remote target host. The <tt>&quot;flags&quot;</tt> parameter
takes one or more of the
<tt>&quot;Sys::Virt::Domain::MIGRATE_XXX&quot;</tt>
constants described later in this document. The
<tt>%params</tt> parameter is a hash reference used to set
various parameters for the migration operation, with the
following valid keys. <br>
&quot;Sys::Virt::Domain::MIGRATE_PARAM_URI&quot;</p>

<p style="margin-left:23%;">The <small>URI</small> to use
for initializing the domain migration. It takes a hypervisor
specific format. The uri_transports element of the
hypervisor capabilities <small>XML</small> includes details
of the supported <small>URI</small> schemes. When omitted
libvirt will auto-generate suitable default
<small>URI.</small> It is typically only necessary to
specify this <small>URI</small> if the destination host has
multiple interfaces and a specific interface is required to
transmit migration data.</p>


<p style="margin-left:17%;">&quot;Sys::Virt::Domain::MIGRATE_PARAM_DEST_NAME&quot;</p>

<p style="margin-left:23%;">The name to be used for the
domain on the destination host. Omitting this parameter
keeps the domain name the same. This field is only allowed
to be used with hypervisors that support domain renaming
during migration.</p>


<p style="margin-left:17%;">&quot;Sys::Virt::Domain::MIGRATE_PARAM_DEST_XML&quot;</p>

<p style="margin-left:23%;">The new configuration to be
used for the domain on the destination host. The
configuration must include an identical set of virtual
devices, to ensure a stable guest <small>ABI</small> across
migration. Only parameters related to host side
configuration can be changed in the <small>XML.</small>
Hypervisors which support this field will forbid migration
if the provided <small>XML</small> would cause a change in
the guest <small>ABI.</small> This field cannot be used to
rename the domain during migration (use
<small>VIR_MIGRATE_PARAM_DEST_NAME</small> field for that
purpose). Domain name in the destination <small>XML</small>
must match the original domain name.</p>

<p style="margin-left:23%; margin-top: 1em">Omitting this
parameter keeps the original domain configuration. Using
this field with hypervisors that do not support changing
domain configuration during migration will result in a
failure.</p>


<p style="margin-left:17%;">&quot;Sys::Virt::Domain::MIGRATE_PARAM_GRAPHICS_URI&quot;</p>

<p style="margin-left:23%;"><small>URI</small> to use for
migrating client&rsquo;s connection to domain&rsquo;s
graphical console as <small>VIR_TYPED_PARAM_STRING.</small>
If specified, the client will be asked to automatically
reconnect using these parameters instead of the
automatically computed ones. This can be useful if, e.g.,
the client does not have a direct access to the network
virtualization hosts are connected to and needs to connect
through a proxy. The <small>URI</small> is formed as
follows:</p>

<pre style="margin-left:23%; margin-top: 1em">      protocol://hostname[:port]/[?parameters]</pre>


<p style="margin-left:23%; margin-top: 1em">where protocol
is either &quot;spice&quot; or &quot;vnc&quot; and
parameters is a list of protocol specific parameters
separated by &rsquo;&amp;&rsquo;. Currently recognized
parameters are &quot;tlsPort&quot; and
&quot;tlsSubject&quot;. For example,</p>

<pre style="margin-left:23%; margin-top: 1em">      spice://target.host.com:1234/?tlsPort=4567</pre>



<p style="margin-left:17%;">&quot;Sys::Virt::Domain::MIGRATE_PARAM_BANDWIDTH&quot;</p>

<p style="margin-left:23%;">The maximum bandwidth (in
MiB/s) that will be used for migration. If set to 0 or
omitted, libvirt will choose a suitable default. Some
hypervisors do not support this feature and will return an
error if this field is used and is not 0.</p>


<p style="margin-left:17%;">&quot;Sys::Virt::Domain::MIGRATE_PARAM_LISTEN_ADDRESS&quot;</p>

<p style="margin-left:23%;">The address on which to listen
for incoming migration connections. If omitted, libvirt will
listen on the wildcard address (0.0.0.0 or ::). This default
may be a security risk if guests, or other untrusted users
have the ability to connect to the virtualization host, thus
use of an explicit restricted listen address is
recommended.</p>

<p style="margin-left:11%;">$ddom =
$dom&minus;&gt;migrate(destcon, flags=0, dname=undef,
uri=undef, <br>
bandwidth=0)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. Use of positional parameters with
<tt>&quot;migrate&quot;</tt> is deprecated in favour of
passing a hash reference as described above.</p>

<p style="margin-left:11%;">$ddom =
$dom&minus;&gt;migrate2(destcon, dxml, flags, dname, uri,
bandwidth)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. This method is deprecated in favour of
passing a hash ref to <tt>&quot;migrate&quot;</tt>.</p>

<p style="margin-left:11%;">$ddom =
$dom&minus;&gt;migrate_to_uri(destcon, \%params,
flags=0)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. The <tt>&quot;destri&quot;</tt> parameter
should be a valid libvirt connection <small>URI</small> for
the remote target host. The <tt>&quot;flags&quot;</tt>
parameter takes one or more of the
<tt>&quot;Sys::Virt::Domain::MIGRATE_XXX&quot;</tt>
constants described later in this document. The
<tt>%params</tt> parameter is a hash reference used to set
various parameters for the migration operation, with the
same keys described for the <tt>&quot;migrate&quot;</tt>
<small>API.</small></p>


<p style="margin-left:11%;">$dom&minus;&gt;migrate_to_uri(desturi,
flags, dname, bandwidth)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. Use of positional parameters with
<tt>&quot;migrate_to_uri&quot;</tt> is deprecated in favour
of passing a hash reference as described above.</p>


<p style="margin-left:11%;">$dom&minus;&gt;migrate_to_uri2(dconnuri,
miguri, dxml, flags, dname, bandwidth)</p>

<p style="margin-left:17%;">Migrate a domain to an
alternative host. This method is deprecated in favour of
passing a hash ref to
<tt>&quot;migrate_to_uri&quot;</tt>.</p>


<p style="margin-left:11%;">$dom&minus;&gt;migrate_set_max_downtime($downtime,
$flags)</p>

<p style="margin-left:17%;">Set the maximum allowed
downtime during migration of the guest. A longer downtime
makes it more likely that migration will complete, at the
cost of longer time blackout for the guest <small>OS</small>
at the switch over point. The <tt>&quot;downtime&quot;</tt>
parameter is measured in milliseconds. The <tt>$flags</tt>
parameter is currently unused and defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;migrate_set_max_speed($bandwidth,
$flags)</p>

<p style="margin-left:17%;">Set the maximum allowed
bandwidth during migration of the guest. The
<tt>&quot;bandwidth&quot;</tt> parameter is measured in
MB/second. The <tt>$flags</tt> parameter is currently unused
and defaults to zero.</p>

<p style="margin-left:11%;">$bandwidth =
$dom&minus;&gt;migrate_get_max_speed($flag)</p>

<p style="margin-left:17%;">Get the maximum allowed
bandwidth during migration fo the guest. The returned
&lt;bandwidth&gt; value is measured in MB/second. The
<tt>$flags</tt> parameter is currently unused and defaults
to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;migrate_set_compression_cache($cacheSize,
$flags)</p>

<p style="margin-left:17%;">Set the maximum allowed
compression cache size during migration of the guest. The
<tt>&quot;cacheSize&quot;</tt> parameter is measured in
bytes. The <tt>$flags</tt> parameter is currently unused and
defaults to zero.</p>

<p style="margin-left:11%;">$cacheSize =
$dom&minus;&gt;migrate_get_compression_cache($flag)</p>

<p style="margin-left:17%;">Get the maximum allowed
compression cache size during migration of the guest. The
returned &lt;bandwidth&gt; value is measured in bytes. The
<tt>$flags</tt> parameter is currently unused and defaults
to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;inject_nmi($flags)</p>

<p style="margin-left:17%;">Trigger an <small>NMI</small>
in the guest virtual machine. The <tt>$flags</tt> parameter
is currently unused and defaults to 0.</p>


<p style="margin-left:11%;">$dom&minus;&gt;open_console($st,
$devname, $flags)</p>

<p style="margin-left:17%;">Open the text console for a
serial, parallel or paravirt console device identified by
<tt>$devname</tt>, connecting it to the stream <tt>$st</tt>.
If <tt>$devname</tt> is undefined, the default console will
be opened. <tt>$st</tt> must be a
<tt>&quot;Sys::Virt::Stream&quot;</tt> object used for
bi-directional communication with the console.
<tt>$flags</tt> is currently unused, defaulting to 0.</p>


<p style="margin-left:11%;">$dom&minus;&gt;open_channel($st,
$devname, $flags)</p>

<p style="margin-left:17%;">Open the text console for a
data channel device identified by <tt>$devname</tt>,
connecting it to the stream <tt>$st</tt>. <tt>$st</tt> must
be a <tt>&quot;Sys::Virt::Stream&quot;</tt> object used for
bi-directional communication with the channel.
<tt>$flags</tt> is currently unused, defaulting to 0.</p>


<p style="margin-left:11%;">$dom&minus;&gt;open_graphics($idx,
$fd, $flags)</p>

<p style="margin-left:17%;">Open the graphics console for a
guest, identified by <tt>$idx</tt>, counting from 0. The
<tt>$fd</tt> should be a file descriptor for an anoymous
socket pair. The <tt>$flags</tt> argument should be one of
the constants listed at the end of this document, and
defaults to 0.</p>

<p style="margin-left:11%;">$fd =
$dom&minus;&gt;open_graphics_fd($idx, $flags)</p>

<p style="margin-left:17%;">Open the graphics console for a
guest, identified by <tt>$idx</tt>, counting from 0. The
<tt>$flags</tt> argument should be one of the constants
listed at the end of this document, and defaults to 0. The
return value will be a file descriptor connected to the
console which must be closed when no longer needed. This
method is preferred over <tt>&quot;open_graphics&quot;</tt>
since it will work correctly under sVirt mandatory access
control policies.</p>

<p style="margin-left:11%;">my $mimetype =
$dom&minus;&gt;screenshot($st, $screen, $flags)</p>

<p style="margin-left:17%;">Capture a screenshot of the
virtual machine&rsquo;s monitor. The <tt>$screen</tt>
parameter controls which monitor is captured when using a
multi-head or multi-card configuration. <tt>$st</tt> must be
a <tt>&quot;Sys::Virt::Stream&quot;</tt> object from which
the data can be read. <tt>$flags</tt> is currently unused
and defaults to 0. The mimetype of the screenshot is
returned</p>

<p style="margin-left:11%;">@vcpuinfo =
$dom&minus;&gt;get_vcpu_info($flags=0)</p>

<p style="margin-left:17%;">Obtain information about the
state of all virtual CPUs in a running guest domain. The
returned list will have one element for each vCPU, where
each elements contains a hash reference. The keys in the
hash are, <tt>&quot;number&quot;</tt> the vCPU number,
<tt>&quot;cpu&quot;</tt> the physical <small>CPU</small> on
which the vCPU is currently scheduled,
<tt>&quot;cpuTime&quot;</tt> the cummulative execution time
of the vCPU, <tt>&quot;state&quot;</tt> the running state
and <tt>&quot;affinity&quot;</tt> giving the allowed
shedular placement. The value for
<tt>&quot;affinity&quot;</tt> is a string representing a
bitmask against physical CPUs, 8 cpus per character. To
extract the bits use the <tt>&quot;unpack&quot;</tt>
function with the <tt>&quot;b*&quot;</tt> template.
<small>NB</small> The <tt>&quot;state&quot;</tt>,
<tt>&quot;cpuTime&quot;</tt>, <tt>&quot;cpu&quot;</tt>
values are only available if using <tt>$flags</tt> value of
0, and the domain is currently running; otherwise they will
all be set to zero.</p>

<p style="margin-left:11%;">$dom&minus;&gt;pin_vcpu($vcpu,
$mask)</p>

<p style="margin-left:17%;">Pin the virtual
<small>CPU</small> given by index <tt>$vcpu</tt> to physical
CPUs given by <tt>$mask</tt>. The <tt>$mask</tt> is a string
representing a bitmask against physical CPUs, 8 cpus per
character.</p>

<p style="margin-left:11%;">$mask =
$dom&minus;&gt;<i>get_emulator_pin_info()</i></p>

<p style="margin-left:17%;">Obtain information about the
<small>CPU</small> affinity of the emulator process. The
returned <tt>$mask</tt> is a bitstring against physical
CPUs, 8 cpus per character. To extract the bits use the
<tt>&quot;unpack&quot;</tt> function with the
<tt>&quot;b*&quot;</tt> template.</p>


<p style="margin-left:11%;">$dom&minus;&gt;pin_emulator($newmask,
$flags=0)</p>

<p style="margin-left:17%;">Pin the emulator threads to the
physical CPUs identified by the affinity in
<tt>$newmask</tt>. The <tt>$newmask</tt> is a bitstring
against the physical CPUa, 8 cpus per character. To create a
suitable bitstring, use the <tt>&quot;vec&quot;</tt>
function with a value of <tt>1</tt> for the
<tt>&quot;BITS&quot;</tt> parameter.</p>

<p style="margin-left:11%;">my @stats =
$dom&minus;&gt;get_cpu_stats($startCpu, $numCpus,
$flags=0)</p>

<p style="margin-left:17%;">Requests the guests host
physical <small>CPU</small> usage statistics, starting from
host <small>CPU</small> &lt;$startCpu&gt; counting upto
<tt>$numCpus</tt>. If <tt>$startCpu</tt> is &minus;1 and
<tt>$numCpus</tt> is 1, then the utilization across all CPUs
is returned. Returns an array of hash references, each
element containing stats for one <small>CPU.</small></p>

<p style="margin-left:11%;">my $info =
$dom&minus;&gt;<i>get_job_info()</i></p>

<p style="margin-left:17%;">Returns a hash reference
summarising the execution state of the background job. The
elements of the hash are as follows: <br>
type</p>

<p style="margin-left:23%;">The type of job, one of the
<small>JOB TYPE</small> constants listed later in this
document.</p>

<p style="margin-left:17%;">timeElapsed</p>

<p style="margin-left:23%;">The elapsed time in
milliseconds</p>

<p style="margin-left:17%;">timeRemaining</p>

<p style="margin-left:23%;">The expected remaining time in
milliseconds. Only set if the <tt>&quot;type&quot;</tt> is
<small>JOB_UNBOUNDED.</small></p>

<p style="margin-left:17%;">dataTotal</p>

<p style="margin-left:23%;">The total amount of data
expected to be processed by the job, in bytes.</p>

<p style="margin-left:17%;">dataProcessed</p>

<p style="margin-left:23%;">The current amount of data
processed by the job, in bytes.</p>

<p style="margin-left:17%;">dataRemaining</p>

<p style="margin-left:23%;">The expected amount of data
remaining to be processed by the job, in bytes.</p>

<p style="margin-left:17%;">memTotal</p>

<p style="margin-left:23%;">The total amount of mem
expected to be processed by the job, in bytes.</p>

<p style="margin-left:17%;">memProcessed</p>

<p style="margin-left:23%;">The current amount of mem
processed by the job, in bytes.</p>

<p style="margin-left:17%;">memRemaining</p>

<p style="margin-left:23%;">The expected amount of mem
remaining to be processed by the job, in bytes.</p>

<p style="margin-left:17%;">fileTotal</p>

<p style="margin-left:23%;">The total amount of file
expected to be processed by the job, in bytes.</p>

<p style="margin-left:17%;">fileProcessed</p>

<p style="margin-left:23%;">The current amount of file
processed by the job, in bytes.</p>

<p style="margin-left:17%;">fileRemaining</p>

<p style="margin-left:23%;">The expected amount of file
remaining to be processed by the job, in bytes.</p>

<p style="margin-left:11%;">my ($type, $stats) =
$dom&minus;&gt;get_job_stats($flags=0)</p>

<p style="margin-left:17%;">Returns an array summarising
the execution state of the background job. The
<tt>$type</tt> value is one of the <small>JOB TYPE</small>
constants listed later in this document. The <tt>$stats</tt>
value is a hash reference, whose elements are one of the
following constants. <br>
type</p>

<p style="margin-left:23%;">The type of job, one of the
<small>JOB TYPE</small> constants listed later in this
document.</p>

<p style="margin-left:23%; margin-top: 1em">The
<tt>$flags</tt> parameter defaults to zero and can take one
of the following constants. <br>
Sys::Virt::Domain::JOB_STATS_COMPLETED</p>

<p style="margin-left:29%;">Return the stats of the most
recently completed job.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_TIME_ELAPSED</p>

<p style="margin-left:23%;">The elapsed time in
milliseconds</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_TIME_REMAINING</p>

<p style="margin-left:23%;">The expected remaining time in
milliseconds. Only set if the <tt>&quot;type&quot;</tt> is
<small>JOB_UNBOUNDED.</small></p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DATA_TOTAL</p>

<p style="margin-left:23%;">The total amount of data
expected to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DATA_PROCESSED</p>

<p style="margin-left:23%;">The current amount of data
processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DATA_REMAINING</p>

<p style="margin-left:23%;">The expected amount of data
remaining to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_TOTAL</p>

<p style="margin-left:23%;">The total amount of mem
expected to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_PROCESSED</p>

<p style="margin-left:23%;">The current amount of mem
processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_REMAINING</p>

<p style="margin-left:23%;">The expected amount of mem
remaining to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_CONSTANT</p>

<p style="margin-left:23%;">The number of pages filled with
a constant byte which have been transferred</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_NORMAL</p>

<p style="margin-left:23%;">The number of pages transferred
without any compression</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_MEMORY_NORMAL_BYTES</p>

<p style="margin-left:23%;">The number of bytes transferred
without any compression</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DISK_TOTAL</p>

<p style="margin-left:23%;">The total amount of file
expected to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DISK_PROCESSED</p>

<p style="margin-left:23%;">The current amount of file
processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DISK_REMAINING</p>

<p style="margin-left:23%;">The expected amount of file
remaining to be processed by the job, in bytes.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_COMPRESSION_CACHE</p>

<p style="margin-left:23%;">The size of the compression
cache in bytes</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_COMPRESSION_BYTES</p>

<p style="margin-left:23%;">The number of compressed bytes
transferred</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_COMPRESSION_PAGES</p>

<p style="margin-left:23%;">The number of compressed pages
transferred</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_COMPRESSION_CACHE_MISSES</p>

<p style="margin-left:23%;">The number of changing pages
not in compression cache</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_COMPRESSION_OVERFLOW</p>

<p style="margin-left:23%;">The number of changing pages in
the compression cache but sent uncompressed since the
compressed page was larger than the non-compressed page.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::JOB_DOWNTIME</p>

<p style="margin-left:23%;">The number of milliseconds of
downtime expected during migration switchover.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>abort_job()</i></p>

<p style="margin-left:17%;">Aborts the currently executing
job</p>

<p style="margin-left:11%;">my $info =
$dom&minus;&gt;get_block_job_info($path, $flags=0)</p>

<p style="margin-left:17%;">Returns a hash reference
summarising the execution state of the block job. The
<tt>$path</tt> parameter should be the fully qualified path
of the block device being changed.</p>


<p style="margin-left:11%;">$dom&minus;&gt;set_block_job_speed($path,
$bandwidth, $flags=0)</p>

<p style="margin-left:17%;">Change the maximum I/O
bandwidth used by the block job that is currently executing
for <tt>$path</tt>. The <tt>$bandwidth</tt> argument is
specified in MB/s</p>


<p style="margin-left:11%;">$dom&minus;&gt;abort_block_job($path,
$flags=0)</p>

<p style="margin-left:17%;">Abort the current job that is
executing for the block device associated with
<tt>$path</tt></p>


<p style="margin-left:11%;">$dom&minus;&gt;block_pull($path,
$bandwith, $flags=0)</p>

<p style="margin-left:17%;">Merge the backing files
associated with <tt>$path</tt> into the top level file. The
<tt>$bandwidth</tt> parameter specifies the maximum I/O rate
to allow in MB/s.</p>


<p style="margin-left:11%;">$dom&minus;&gt;block_rebase($path,
$base, $bandwith, $flags=0)</p>

<p style="margin-left:17%;">Switch the backing path
associated with <tt>$path</tt> to instead use
<tt>$base</tt>. The <tt>$bandwidth</tt> parameter specifies
the maximum I/O rate to allow in MB/s.</p>


<p style="margin-left:11%;">$dom&minus;&gt;block_copy($path,
$destxml, $params, $flags=0)</p>

<p style="margin-left:17%;">Copy contents of a disk image
&lt;$path&gt; into the target volume described by
<tt>$destxml</tt> which follows the schema of the
&lt;disk&gt; element in the domain <small>XML.</small> The
<tt>$params</tt> parameter is a hash of optional parameters
to control the process <br>
Sys::Virt::Domain::BLOCK_COPY_BANDWIDTH</p>

<p style="margin-left:23%;">The maximum bandwidth in bytes
per second.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::BLOCK_COPY_GRANULARITY</p>

<p style="margin-left:23%;">The granularity in bytes of the
copy process</p>


<p style="margin-left:17%;">Sys::Virt::Domain::BLOCK_COPY_BUF_SIZE</p>

<p style="margin-left:23%;">The maximum amount of data in
flight in bytes.</p>


<p style="margin-left:11%;">$dom&minus;&gt;block_commit($path,
$base, $top, $bandwith, $flags=0)</p>

<p style="margin-left:17%;">Commit changes there were made
to the temporary top level file <tt>$top</tt>. Takes all the
differences between <tt>$top</tt> and <tt>$base</tt> and
merge them into <tt>$base</tt>. The <tt>$bandwidth</tt>
parameter specifies the maximum I/O rate to allow in
MB/s.</p>

<p style="margin-left:11%;">$count =
$dom&minus;&gt;<i>num_of_snapshots()</i></p>

<p style="margin-left:17%;">Return the number of saved
snapshots of the domain</p>

<p style="margin-left:11%;">@names =
$dom&minus;&gt;<i>list_snapshot_names()</i></p>

<p style="margin-left:17%;">List the names of all saved
snapshots. The names can be used with the
<tt>&quot;lookup_snapshot_by_name&quot;</tt></p>

<p style="margin-left:11%;">@snapshots =
$dom&minus;&gt;<i>list_snapshots()</i></p>

<p style="margin-left:17%;">Return a list of all snapshots
currently known to the domain. The elements in the returned
list are instances of the Sys::Virt::DomainSnapshot class.
This method requires O(n) <small>RPC</small> calls, so the
<tt>&quot;list_all_snapshots&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my @snapshots =
$dom&minus;&gt;list_all_snapshots($flags)</p>

<p style="margin-left:17%;">Return a list of all domain
snapshots associated with this domain. The elements in the
returned list are instances of the Sys::Virt::DomainSnapshot
class. The <tt>$flags</tt> parameter can be used to filter
the list of return domain snapshots.</p>

<p style="margin-left:11%;">my $snapshot =
$dom&minus;&gt;get_snapshot_by_name($name)</p>

<p style="margin-left:17%;">Return the domain snapshot with
a name of <tt>$name</tt>. The returned object is an instance
of the Sys::Virt::DomainSnapshot class.</p>


<p style="margin-left:11%;">$dom&minus;&gt;<i>has_current_snapshot()</i></p>

<p style="margin-left:17%;">Returns a true value if the
domain has a currently active snapshot</p>

<p style="margin-left:11%;">$snapshot =
$dom&minus;&gt;<i>current_snapshot()</i></p>

<p style="margin-left:17%;">Returns the currently active
snapshot for the domain.</p>

<p style="margin-left:11%;">$snapshot =
$dom&minus;&gt;create_snapshot($xml[, $flags])</p>

<p style="margin-left:17%;">Create a new snapshot from the
<tt>$xml</tt>. The <tt>$flags</tt> parameter accepts the
<b><small>SNAPSHOT CREATION</small></b> constants listed in
<tt>&quot;Sys::Virt::DomainSnapshots&quot;</tt>.</p>


<p style="margin-left:11%;">$dom&minus;&gt;fs_trim($mountPoint,
$minimum, $flags=0);</p>

<p style="margin-left:17%;">Issue an <small>FS_TRIM</small>
command to the device at <tt>$mountPoint</tt> to remove
chunks of unused space that are at least <tt>$minimum</tt>
bytes in length. <tt>$flags</tt> is currently unused and
defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;fs_freeze(\@mountPoints,
$flags=0);</p>

<p style="margin-left:17%;">Freeze all the filesystems
associated with the <tt>@mountPoints</tt> array reference.
If &lt;@mountPoints&gt; is an empty list, then all
filesystems will be frozen. <tt>$flags</tt> is currently
unused and defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;fs_thaw(\@mountPoints,
$flags=0);</p>

<p style="margin-left:17%;">Thaw all the filesystems
associated with the <tt>@mountPoints</tt> array reference.
If &lt;@mountPoints&gt; is an empty list, then all
filesystems will be thawed. <tt>$flags</tt> is currently
unused and defaults to zero.</p>


<p style="margin-left:11%;">$dom&minus;&gt;send_process_signal($pid,
$signum, $flags=0);</p>

<p style="margin-left:17%;">Send the process <tt>$pid</tt>
the signal <tt>$signum</tt>. The <tt>$signum</tt> value must
be one of the constants listed later, not a
<small>POSIX</small> or Linux signal value. <tt>$flags</tt>
is currently unused and defaults to zero.</p>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A number of the
APIs take a <tt>&quot;flags&quot;</tt> parameter. In most
cases passing a value of zero will be satisfactory. Some
APIs, however, accept named constants to alter their
behaviour. This section documents the current known
constants.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
STATE</small></b> <br>
The domain state constants are useful in interpreting the
<tt>&quot;state&quot;</tt> key in the hash returned by the
<tt>&quot;get_info&quot;</tt> method. <br>
Sys::Virt::Domain::STATE_NOSTATE</p>

<p style="margin-left:17%;">The domain is active, but is
not running / blocked (eg idle)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_RUNNING</p>

<p style="margin-left:17%;">The domain is active and
running</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_BLOCKED</p>

<p style="margin-left:17%;">The domain is active, but
execution is blocked</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_PAUSED</p>

<p style="margin-left:17%;">The domain is active, but
execution has been paused</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_SHUTDOWN</p>

<p style="margin-left:17%;">The domain is active, but in
the shutdown phase</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_SHUTOFF</p>

<p style="margin-left:17%;">The domain is inactive, and
shut down.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_CRASHED</p>

<p style="margin-left:17%;">The domain is inactive, and
crashed.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATE_PMSUSPENDED</p>

<p style="margin-left:17%;">The domain is active, but in
power management suspend state</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CONTROL
INFO</small></b> <br>
The following constants can be used to determine what the
guest domain control channel status is <br>
Sys::Virt::Domain::CONTROL_ERROR</p>

<p style="margin-left:17%;">The control channel has a fatal
error</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CONTROL_OK</p>

<p style="margin-left:17%;">The control channel is ready
for jobs</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CONTROL_OCCUPIED</p>

<p style="margin-left:17%;">The control channel is busy</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CONTROL_JOB</p>

<p style="margin-left:17%;">The control channel is busy
with a job</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
CREATION</small></b> <br>
The following constants can be used to control the behaviour
of domain creation <br>
Sys::Virt::Domain::START_PAUSED</p>

<p style="margin-left:17%;">Keep the guest vCPUs paused
after starting the guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::START_AUTODESTROY</p>

<p style="margin-left:17%;">Automatically destroy the guest
when the connection is closed (or fails)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::START_BYPASS_CACHE</p>

<p style="margin-left:17%;">Do not use <small>OS
I/O</small> cache if starting a domain with a saved state
image</p>


<p style="margin-left:11%;">Sys::Virt::Domain::START_FORCE_BOOT</p>

<p style="margin-left:17%;">Boot the guest, even if there
was a saved snapshot</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>KEYCODE
SETS</small></b> <br>
The following constants define the set of supported keycode
sets <br>
Sys::Virt::Domain::KEYCODE_SET_LINUX</p>

<p style="margin-left:17%;">The Linux event subsystem
keycodes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_XT</p>

<p style="margin-left:17%;">The original <small>XT</small>
keycodes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_ATSET1</p>

<p style="margin-left:17%;">The <small>AT</small> Set1
keycodes (aka <small>XT</small> )</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_ATSET2</p>

<p style="margin-left:17%;">The <small>AT</small> Set2
keycodes (aka <small>AT</small> )</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_ATSET3</p>

<p style="margin-left:17%;">The <small>AT</small> Set3
keycodes (aka <small>PS2</small> )</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_OSX</p>

<p style="margin-left:17%;">The OS-X keycodes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_XT_KBD</p>

<p style="margin-left:17%;">The <small>XT</small> keycodes
from the Linux Keyboard driver</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_USB</p>

<p style="margin-left:17%;">The <small>USB HID</small>
keycode set</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_WIN32</p>

<p style="margin-left:17%;">The Windows keycode set</p>


<p style="margin-left:11%;">Sys::Virt::Domain::KEYCODE_SET_RFB</p>

<p style="margin-left:17%;">The <small>XT</small> keycode
set, with the extended scancodes using the high bit of the
first byte, instead of the low bit of the second byte.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MEMORY
PEEK</small></b> <br>
The following constants can be used with the
<tt>&quot;memory_peek&quot;</tt> method&rsquo;s flags
parameter <br>
Sys::Virt::Domain::MEMORY_VIRTUAL</p>

<p style="margin-left:17%;">Indicates that the offset is
using virtual memory addressing.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_PHYSICAL</p>

<p style="margin-left:17%;">Indicates that the offset is
using physical memory addressing.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>VCPU
STATE</small></b> <br>
The following constants are useful when interpreting the
virtual <small>CPU</small> run state <br>
Sys::Virt::Domain::VCPU_OFFLINE</p>

<p style="margin-left:17%;">The virtual <small>CPU</small>
is not online</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_RUNNING</p>

<p style="margin-left:17%;">The virtual <small>CPU</small>
is executing code</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_BLOCKED</p>

<p style="margin-left:17%;">The virtual <small>CPU</small>
is waiting to be scheduled</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OPEN
GRAPHICS CONSTANTS</small></b> <br>
The following constants are used when opening a connection
to the guest graphics server <br>
Sys::Virt::Domain::OPEN_GRAPHICS_SKIPAUTH</p>

<p style="margin-left:17%;">Skip authentication of the
client</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OPEN
CONSOLE CONSTANTS</small></b> <br>
The following constants are used when opening a connection
to the guest console <br>
Sys::Virt::Domain::OPEN_CONSOLE_FORCE</p>

<p style="margin-left:17%;">Force opening of the console,
disconnecting any other open session</p>


<p style="margin-left:11%;">Sys::Virt::Domain::OPEN_CONSOLE_SAFE</p>

<p style="margin-left:17%;">Check if the console driver
supports safe operations</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OPEN
CHANNEL CONSTANTS</small></b> <br>
The following constants are used when opening a connection
to the guest channel <br>
Sys::Virt::Domain::OPEN_CHANNEL_FORCE</p>

<p style="margin-left:17%;">Force opening of the channel,
disconnecting any other open session</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XML
DUMP OPTIONS</small></b> <br>
The following constants are used to control the information
included in the <small>XML</small> configuration dump <br>
Sys::Virt::Domain::XML_INACTIVE</p>

<p style="margin-left:17%;">Report the persistent inactive
configuration for the guest, even if it is currently
running.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::XML_SECURE</p>

<p style="margin-left:17%;">Include security sensitive
information in the <small>XML</small> dump, such as
passwords.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::XML_UPDATE_CPU</p>

<p style="margin-left:17%;">Update the <small>CPU</small>
model definition to match the current executing state.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::XML_MIGRATABLE</p>

<p style="margin-left:17%;">Update the <small>XML</small>
to allow migration to older versions of libvirt</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DEVICE
HOTPLUG OPTIONS</small></b> <br>
The following constants are used to control device hotplug
operations <br>
Sys::Virt::Domain::DEVICE_MODIFY_CURRENT</p>

<p style="margin-left:17%;">Modify the domain in its
current state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DEVICE_MODIFY_LIVE</p>

<p style="margin-left:17%;">Modify only the live state of
the domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DEVICE_MODIFY_CONFIG</p>

<p style="margin-left:17%;">Modify only the persistent
config of the domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DEVICE_MODIFY_FORCE</p>

<p style="margin-left:17%;">Force the device to be
modified</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MEMORY
OPTIONS</small></b> <br>
The following constants are used to control memory change
operations <br>
Sys::Virt::Domain::MEM_CURRENT</p>

<p style="margin-left:17%;">Modify the current state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEM_LIVE</p>

<p style="margin-left:17%;">Modify only the live state of
the domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEM_CONFIG</p>

<p style="margin-left:17%;">Modify only the persistent
config of the domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEM_MAXIMUM</p>

<p style="margin-left:17%;">Modify the maximum memory
value</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CONFIG
OPTIONS</small></b> <br>
The following constants are used to control what
configuration a domain update changes <br>
Sys::Virt::Domain::AFFECT_CURRENT</p>

<p style="margin-left:17%;">Modify the current state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::AFFECT_LIVE</p>

<p style="margin-left:17%;">Modify only the live state of
the domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::AFFECT_CONFIG</p>

<p style="margin-left:17%;">Modify only the persistent
config of the domain</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MIGRATE
OPTIONS</small></b> <br>
The following constants are used to control how migration is
performed <br>
Sys::Virt::Domain::MIGRATE_LIVE</p>

<p style="margin-left:17%;">Migrate the guest without
interrupting its execution on the source host.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_PEER2PEER</p>

<p style="margin-left:17%;">Manage the migration process
over a direct peer&minus;2&minus;peer connection between the
source and destination host libvirtd daemons.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_TUNNELLED</p>

<p style="margin-left:17%;">Tunnel the migration data over
the libvirt daemon connection, rather than the native
hypervisor data transport. Requires <small>PEER2PEER</small>
flag to be set.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_PERSIST_DEST</p>

<p style="margin-left:17%;">Make the domain persistent on
the destination host, defining its configuration file upon
completion of migration.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_UNDEFINE_SOURCE</p>

<p style="margin-left:17%;">Remove the domain&rsquo;s
persistent configuration after migration completes
successfully.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_PAUSED</p>

<p style="margin-left:17%;">Do not re-start execution of
the guest CPUs on the destination host after migration
completes.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_NON_SHARED_DISK</p>

<p style="margin-left:17%;">Copy the complete contents of
the disk images during migration</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_NON_SHARED_INC</p>

<p style="margin-left:17%;">Copy the incrementally changed
contents of the disk images during migration</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_CHANGE_PROTECTION</p>

<p style="margin-left:17%;">Do not allow changes to the
virtual domain configuration while migration is taking
place. This option is automatically implied if doing a
peer&minus;2&minus;peer migration.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_UNSAFE</p>

<p style="margin-left:17%;">Migrate even if the
compatibility check indicates the migration will be unsafe
to the guest.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_OFFLINE</p>

<p style="margin-left:17%;">Migrate the guest config if the
guest is not currently running</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_COMPRESSED</p>

<p style="margin-left:17%;">Enable compression of the
migration data stream</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_ABORT_ON_ERROR</p>

<p style="margin-left:17%;">Abort if an I/O error occurrs
on the disk</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_AUTO_CONVERGE</p>

<p style="margin-left:17%;">Force convergance of the
migration operation by throttling guest runtime</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MIGRATE_RDMA_PIN_ALL</p>

<p style="margin-left:17%;">Pin memory for
<small>RDMA</small> transfer</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>UNDEFINE
CONSTANTS</small></b> <br>
The following constants can be used when undefining virtual
domain configurations <br>
Sys::Virt::Domain::UNDEFINE_MANAGED_SAVE</p>

<p style="margin-left:17%;">Also remove any managed save
image when undefining the virtual domain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::UNDEFINE_SNAPSHOTS_METADATA</p>

<p style="margin-left:17%;">Also remove any snapshot
metadata when undefining the virtual domain.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::UNDEFINE_NVRAM</p>

<p style="margin-left:17%;">Also remove any
<small>NVRAM</small> state file when undefining the virtual
domain.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>JOB
TYPES</small></b> <br>
The following constants describe the different background
job types. <br>
Sys::Virt::Domain::JOB_NONE</p>

<p style="margin-left:17%;">No job is active</p>


<p style="margin-left:11%;">Sys::Virt::Domain::JOB_BOUNDED</p>

<p style="margin-left:17%;">A job with a finite completion
time is active</p>


<p style="margin-left:11%;">Sys::Virt::Domain::JOB_UNBOUNDED</p>

<p style="margin-left:17%;">A job with an unbounded
completion time is active</p>


<p style="margin-left:11%;">Sys::Virt::Domain::JOB_COMPLETED</p>

<p style="margin-left:17%;">The job has finished, but
isn&rsquo;t cleaned up</p>


<p style="margin-left:11%;">Sys::Virt::Domain::JOB_FAILED</p>

<p style="margin-left:17%;">The job has hit an error, but
isn&rsquo;t cleaned up</p>


<p style="margin-left:11%;">Sys::Virt::Domain::JOB_CANCELLED</p>

<p style="margin-left:17%;">The job was aborted at user
request, but isn&rsquo;t cleaned up</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MEMORY
PARAMETERS</small></b> <br>
The following constants are useful when getting/setting
memory parameters for guests <br>
Sys::Virt::Domain::MEMORY_HARD_LIMIT</p>

<p style="margin-left:17%;">The maximum memory the guest
can use.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_SOFT_LIMIT</p>

<p style="margin-left:17%;">The memory upper limit enforced
during memory contention.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_MIN_GUARANTEE</p>

<p style="margin-left:17%;">The minimum memory guaranteed
to be reserved for the guest.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_SWAP_HARD_LIMIT</p>

<p style="margin-left:17%;">The maximum swap the guest can
use.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_PARAM_UNLIMITED</p>

<p style="margin-left:17%;">The value of an unlimited
memory parameter</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>BLKIO
PARAMETERS</small></b> <br>
The following parameters control I/O tuning for the domain
as a whole <br>
Sys::Virt::Domain::BLKIO_WEIGHT</p>

<p style="margin-left:17%;">The I/O weight parameter</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLKIO_DEVICE_WEIGHT</p>

<p style="margin-left:17%;">The per-device I/O weight
parameter</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLKIO_DEVICE_READ_BPS</p>

<p style="margin-left:17%;">The per-device I/O bytes read
per second</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLKIO_DEVICE_READ_IOPS</p>

<p style="margin-left:17%;">The per-device I/O operations
read per second</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLKIO_DEVICE_WRITE_BPS</p>

<p style="margin-left:17%;">The per-device I/O bytes write
per second</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLKIO_DEVICE_WRITE_IOPS</p>

<p style="margin-left:17%;">The per-device I/O operations
write per second</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>BLKIO
TUNING PARAMETERS</small></b> <br>
The following parameters control I/O tuning for an
individual guest disk. <br>
Sys::Virt::Domain::BLOCK_IOTUNE_TOTAL_BYTES_SEC</p>

<p style="margin-left:17%;">The total bytes processed per
second.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_IOTUNE_READ_BYTES_SEC</p>

<p style="margin-left:17%;">The bytes read per second.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_IOTUNE_WRITE_BYTES_SEC</p>

<p style="margin-left:17%;">The bytes written per
second.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_IOTUNE_TOTAL_IOPS_SEC</p>

<p style="margin-left:17%;">The total I/O operations
processed per second.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_IOTUNE_READ_IOPS_SEC</p>

<p style="margin-left:17%;">The I/O operations read per
second.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_IOTUNE_WRITE_IOPS_SEC</p>

<p style="margin-left:17%;">The I/O operations written per
second.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SCHEDULER
CONSTANTS</small></b> <br>
Sys::Virt::Domain::SCHEDULER_CAP</p>

<p style="margin-left:17%;">The <small>VM</small> cap
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_CPU_SHARES</p>

<p style="margin-left:17%;">The <small>CPU</small> shares
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_LIMIT</p>

<p style="margin-left:17%;">The <small>VM</small> limit
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_RESERVATION</p>

<p style="margin-left:17%;">The <small>VM</small>
reservation tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_SHARES</p>

<p style="margin-left:17%;">The <small>VM</small> shares
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_VCPU_PERIOD</p>

<p style="margin-left:17%;">The <small>VCPU</small> period
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_VCPU_QUOTA</p>

<p style="margin-left:17%;">The <small>VCPU</small> quota
tunable</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SCHEDULER_WEIGHT</p>

<p style="margin-left:17%;">The <small>VM</small> weight
tunable</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>NUMA
PARAMETERS</small></b> <br>
The following constants are useful when getting/setting the
guest <small>NUMA</small> memory policy <br>
Sys::Virt::Domain::NUMA_MODE</p>

<p style="margin-left:17%;">The <small>NUMA</small> policy
mode</p>


<p style="margin-left:11%;">Sys::Virt::Domain::NUMA_NODESET</p>

<p style="margin-left:17%;">The <small>NUMA</small> nodeset
mask</p>

<p style="margin-left:11%; margin-top: 1em">The following
constants are useful when interpreting the
<tt>&quot;Sys::Virt::Domain::NUMA_MODE&quot;</tt> parameter
value <br>
Sys::Virt::Domain::NUMATUNE_MEM_STRICT</p>

<p style="margin-left:17%;">Allocation is mandatory from
the mask nodes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::NUMATUNE_MEM_PREFERRED</p>

<p style="margin-left:17%;">Allocation is preferred from
the masked nodes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::NUMATUNE_MEM_INTERLEAVE</p>

<p style="margin-left:17%;">Allocation is interleaved
across all masked nods</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>INTERFACE
PARAMETERS</small></b> <br>
The following constants are useful when getting/setting the
per network interface tunable parameters <br>
Sys::Virt::Domain::BANDWIDTH_IN_AVERAGE</p>

<p style="margin-left:17%;">The average inbound
bandwidth</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BANDWIDTH_IN_PEAK</p>

<p style="margin-left:17%;">The peak inbound bandwidth</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BANDWIDTH_IN_BURST</p>

<p style="margin-left:17%;">The burstable inbound
bandwidth</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BANDWIDTH_OUT_AVERAGE</p>

<p style="margin-left:17%;">The average outbound
bandwidth</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BANDWIDTH_OUT_PEAK</p>

<p style="margin-left:17%;">The peak outbound bandwidth</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BANDWIDTH_OUT_BURST</p>

<p style="margin-left:17%;">The burstable outbound
bandwidth</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>VCPU
FLAGS</small></b> <br>
The following constants are useful when getting/setting the
<small>VCPU</small> count for a guest <br>
Sys::Virt::Domain::VCPU_LIVE</p>

<p style="margin-left:17%;">Flag to request the live
value</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_CONFIG</p>

<p style="margin-left:17%;">Flag to request the persistent
config value</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_CURRENT</p>

<p style="margin-left:17%;">Flag to request the current
config value</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_MAXIMUM</p>

<p style="margin-left:17%;">Flag to request adjustment of
the maximum vCPU value</p>


<p style="margin-left:11%;">Sys::Virt::Domain::VCPU_GUEST</p>

<p style="margin-left:17%;">Flag to request the guest
<small>VCPU</small> mask</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>STATE
CHANGE EVENTS</small></b> <br>
The following constants allow domain state change events to
be interpreted. The events contain both a state change, and
a reason. <br>
Sys::Virt::Domain::EVENT_DEFINED</p>

<p style="margin-left:17%;">Indicates that a persistent
configuration has been defined for the domain. <br>
Sys::Virt::Domain::EVENT_DEFINED_ADDED</p>

<p style="margin-left:23%;">The defined configuration is
newly added</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_DEFINED_UPDATED</p>

<p style="margin-left:23%;">The defined configuration is an
update to an existing configuration</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_RESUMED</p>

<p style="margin-left:17%;">The domain has resumed
execution <br>
Sys::Virt::Domain::EVENT_RESUMED_MIGRATED</p>

<p style="margin-left:23%;">The domain resumed because
migration has completed. This is emitted on the destination
host.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_RESUMED_UNPAUSED</p>

<p style="margin-left:23%;">The domain resumed because the
admin unpaused it.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_RESUMED_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The domain resumed because it
was restored from a snapshot</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_STARTED</p>

<p style="margin-left:17%;">The domain has started running
<br>
Sys::Virt::Domain::EVENT_STARTED_BOOTED</p>

<p style="margin-left:23%;">The domain was booted from
shutoff state</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STARTED_MIGRATED</p>

<p style="margin-left:23%;">The domain started due to an
incoming migration</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STARTED_RESTORED</p>

<p style="margin-left:23%;">The domain was restored from
saved state file</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STARTED_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The domain was restored from a
snapshot</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STARTED_WAKEUP</p>

<p style="margin-left:23%;">The domain was woken up from
suspend</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_STOPPED</p>

<p style="margin-left:17%;">The domain has stopped running
<br>
Sys::Virt::Domain::EVENT_STOPPED_CRASHED</p>

<p style="margin-left:23%;">The domain stopped because
guest operating system has crashed</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_DESTROYED</p>

<p style="margin-left:23%;">The domain stopped because
administrator issued a destroy command.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_FAILED</p>

<p style="margin-left:23%;">The domain stopped because of a
fault in the host virtualization environment.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_MIGRATED</p>

<p style="margin-left:23%;">The domain stopped because it
was migrated to another machine.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_SAVED</p>

<p style="margin-left:23%;">The domain was saved to a state
file</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_SHUTDOWN</p>

<p style="margin-left:23%;">The domain stopped due to
graceful shutdown of the guest.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_STOPPED_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The domain was stopped due to a
snapshot</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_SHUTDOWN</p>

<p style="margin-left:17%;">The domain has shutdown but is
not yet stopped <br>
Sys::Virt::Domain::EVENT_SHUTDOWN_FINISHED</p>

<p style="margin-left:23%;">The domain finished shutting
down</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_SUSPENDED</p>

<p style="margin-left:17%;">The domain has stopped
executing, but still exists <br>
Sys::Virt::Domain::EVENT_SUSPENDED_MIGRATED</p>

<p style="margin-left:23%;">The domain has been suspended
due to offline migration</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_PAUSED</p>

<p style="margin-left:23%;">The domain has been suspended
due to administrator pause request.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_IOERROR</p>

<p style="margin-left:23%;">The domain has been suspended
due to a block device I/O error.</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_FROM_SNAPSHOT</p>

<p style="margin-left:23%;">The domain has been suspended
due to resume from snapshot</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_WATCHDOG</p>

<p style="margin-left:23%;">The domain has been suspended
due to the watchdog triggering</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_RESTORED</p>

<p style="margin-left:23%;">The domain has been suspended
due to restore from saved state</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_SUSPENDED_API_ERROR</p>

<p style="margin-left:23%;">The domain has been suspended
due to an <small>API</small> error</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_UNDEFINED</p>

<p style="margin-left:17%;">The persistent configuration
has gone away <br>
Sys::Virt::Domain::EVENT_UNDEFINED_REMOVED</p>

<p style="margin-left:23%;">The domain configuration has
gone away due to it being removed by administrator.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_PMSUSPENDED</p>

<p style="margin-left:17%;">The domain has stopped running
<br>
Sys::Virt::Domain::EVENT_PMSUSPENDED_MEMORY</p>

<p style="margin-left:23%;">The domain has suspend to
<small>RAM.</small></p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_PMSUSPENDED_DISK</p>

<p style="margin-left:23%;">The domain has suspend to
Disk.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_CRASHED</p>

<p style="margin-left:17%;">The domain has crashed <br>
Sys::Virt::Domain::EVENT_CRASHED_PANICKED</p>

<p style="margin-left:23%;">The domain has crashed due to a
kernel panic</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EVENT
ID CONSTANTS</small></b> <br>
Sys::Virt::Domain::EVENT_ID_LIFECYCLE</p>

<p style="margin-left:17%;">Domain lifecycle events</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_REBOOT</p>

<p style="margin-left:17%;">Soft / warm reboot events</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_RTC_CHANGE</p>

<p style="margin-left:17%;"><small>RTC</small> clock
adjustments</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_IO_ERROR</p>

<p style="margin-left:17%;">File <small>IO</small> errors,
typically from disks</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_WATCHDOG</p>

<p style="margin-left:17%;">Watchdog device triggering</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_GRAPHICS</p>

<p style="margin-left:17%;">Graphics client
connections.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_IO_ERROR_REASON</p>

<p style="margin-left:17%;">File <small>IO</small> errors,
typically from disks, with a root cause</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_CONTROL_ERROR</p>

<p style="margin-left:17%;">Errors from the virtualization
control channel</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_BLOCK_JOB</p>

<p style="margin-left:17%;">Completion status of
asynchronous block jobs, identified by source file name.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_BLOCK_JOB_2</p>

<p style="margin-left:17%;">Completion status of
asynchronous block jobs, identified by target device
name.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_DISK_CHANGE</p>

<p style="margin-left:17%;">Changes in disk media</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_TRAY_CHANGE</p>

<p style="margin-left:17%;"><small>CDROM</small> media tray
state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_PMSUSPEND</p>

<p style="margin-left:17%;">Power management initiated
suspend to <small>RAM</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_PMSUSPEND_DISK</p>

<p style="margin-left:17%;">Power management initiated
suspend to Disk</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_PMWAKEUP</p>

<p style="margin-left:17%;">Power management initiated
wakeup</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_BALLOON_CHANGE</p>

<p style="margin-left:17%;">Balloon target changes</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_DEVICE_REMOVED</p>

<p style="margin-left:17%;">Asynchronous guest device
removal</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_TUNABLE</p>

<p style="margin-left:17%;">Changes of any domain tuning
parameters. The callback will be provided with a hash
listing all changed parameters. The later <small>DOMAIN
TUNABLE</small> constants can be useful when accessing the
hash keys</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_ID_AGENT_LIFECYCLE</p>

<p style="margin-left:17%;">Domain guest agent lifecycle
events. The <tt>&quot;state&quot;</tt> parameter to the
callback will match one of the constants <br>

Sys::Virt::Domain::EVENT_AGENT_LIFECYCLE_STATE_CONNECTED</p>

<p style="margin-left:23%;">The agent is now connected</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED</p>

<p style="margin-left:23%;">The agent is now
disconnected</p>

<p style="margin-left:17%; margin-top: 1em">The second
parameter, <tt>&quot;reason&quot;</tt>, matches one of the
following constants <br>
Sys::Virt::Domain::EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN</p>

<p style="margin-left:23%;">The reason is unknown</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED</p>

<p style="margin-left:23%;">The domain was initially
booted</p>


<p style="margin-left:17%;">Sys::Virt::Domain::EVENT_AGENT_LIFECYCLE_REASON_CHANNEL</p>

<p style="margin-left:23%;">The channel on a running guest
changed state</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>IO
ERROR EVENT CONSTANTS</small></b> <br>
These constants describe what action was taken due to the
<small>IO</small> error. <br>
Sys::Virt::Domain::EVENT_IO_ERROR_NONE</p>

<p style="margin-left:17%;">No action was taken, the error
was ignored &amp; reported as success to guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_IO_ERROR_PAUSE</p>

<p style="margin-left:17%;">The guest is paused since the
error occurred</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_IO_ERROR_REPORT</p>

<p style="margin-left:17%;">The error has been reported to
the guest <small>OS</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>WATCHDOG
EVENT CONSTANTS</b></small> <br>
These constants describe what action was taken due to the
watchdog firing <br>
Sys::Virt::Domain::EVENT_WATCHDOG_NONE</p>

<p style="margin-left:17%;">No action was taken, the
watchdog was ignored</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_WATCHDOG_PAUSE</p>

<p style="margin-left:17%;">The guest is paused since the
watchdog fired</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_WATCHDOG_POWEROFF</p>

<p style="margin-left:17%;">The guest is powered off after
the watchdog fired</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_WATCHDOG_RESET</p>

<p style="margin-left:17%;">The guest is reset after the
watchdog fired</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_WATCHDOG_SHUTDOWN</p>

<p style="margin-left:17%;">The guest attempted to
gracefully shutdown after the watchdog fired</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_WATCHDOG_DEBUG</p>

<p style="margin-left:17%;">No action was taken, the
watchdog was logged</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GRAPHICS
EVENT PHASE CONSTANTS</small></b> <br>
These constants describe the phase of the graphics
connection <br>
Sys::Virt::Domain::EVENT_GRAPHICS_CONNECT</p>

<p style="margin-left:17%;">The initial client
connection</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_GRAPHICS_INITIALIZE</p>

<p style="margin-left:17%;">The client has been
authenticated &amp; the connection is running</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_GRAPHICS_DISCONNECT</p>

<p style="margin-left:17%;">The client has disconnected</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GRAPHICS
EVENT ADDRESS CONSTANTS</small></b> <br>
These constants describe the format of the address <br>
Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_IPV4</p>

<p style="margin-left:17%;">An IPv4 address</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_IPV6</p>

<p style="margin-left:17%;">An IPv6 address</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_GRAPHICS_ADDRESS_UNIX</p>

<p style="margin-left:17%;">An <small>UNIX</small> socket
path address</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>DISK
CHANGE EVENT CONSTANTS</small></b> <br>
These constants describe the reason for a disk change event
<br>
Sys::Virt::Domain::EVENT_DISK_CHANGE_MISSING_ON_START</p>

<p style="margin-left:17%;">The disk media was cleared, as
its source was missing when attempting to start the
guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_DISK_DROP_MISSING_ON_START</p>

<p style="margin-left:17%;">The disk device was dropped, as
its source was missing whe attempting to start the guest</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>TRAY
CHANGE CONSTANTS</small></b> <br>
These constants describe the reason for a tray change event
<br>
Sys::Virt::Domain::EVENT_TRAY_CHANGE_CLOSE</p>

<p style="margin-left:17%;">The tray was closed</p>


<p style="margin-left:11%;">Sys::Virt::Domain::EVENT_TRAY_CHANGE_OPEN</p>

<p style="margin-left:17%;">The tray was opened</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK JOB TYPE CONSTANTS</small></b> <br>
The following constants identify the different types of
domain block jobs <br>
Sys::Virt::Domain::BLOCK_JOB_TYPE_UNKNOWN</p>

<p style="margin-left:17%;">An unknown block job type</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_TYPE_PULL</p>

<p style="margin-left:17%;">The block pull job type</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_TYPE_COPY</p>

<p style="margin-left:17%;">The block copy job type</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_TYPE_COMMIT</p>

<p style="margin-left:17%;">The block commit job type</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_TYPE_ACTIVE_COMMIT</p>

<p style="margin-left:17%;">The block active commit job
type</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK JOB COMPLETION CONSTANTS</small></b> <br>
The following constants can be used to determine the
completion status of a block job <br>
Sys::Virt::Domain::BLOCK_JOB_COMPLETED</p>

<p style="margin-left:17%;">A successfully completed block
job</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_FAILED</p>

<p style="margin-left:17%;">An unsuccessful block job</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_CANCELED</p>

<p style="margin-left:17%;">A block job canceled byy the
user</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_READY</p>

<p style="margin-left:17%;">A block job is running</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK REBASE CONSTANTS</small></b> <br>
The following constants are useful when rebasing block
devices <br>
Sys::Virt::Domain::BLOCK_REBASE_SHALLOW</p>

<p style="margin-left:17%;">Limit copy to top of source
backing chain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_REBASE_REUSE_EXT</p>

<p style="margin-left:17%;">Reuse existing external file
for copy</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_REBASE_COPY_RAW</p>

<p style="margin-left:17%;">Make destination file raw</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_REBASE_COPY</p>

<p style="margin-left:17%;">Start a copy job</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_REBASE_RELATIVE</p>

<p style="margin-left:17%;">Keep backing chain referenced
using relative names</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK COPY CONSTANTS</small></b> <br>
The following constants are useful when copying block
devices <br>
Sys::Virt::Domain::BLOCK_COPY_SHALLOW</p>

<p style="margin-left:17%;">Limit copy to top of source
backing chain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_COPY_REUSE_EXT</p>

<p style="margin-left:17%;">Reuse existing external file
for copy</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK JOB ABORT CONSTANTS</small></b> <br>
The following constants are useful when aborting job copy
jobs <br>
Sys::Virt::Domain::BLOCK_JOB_ABORT_ASYNC</p>

<p style="margin-left:17%;">Request only, do not wait for
completion</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_JOB_ABORT_PIVOT</p>

<p style="margin-left:17%;">Pivot to mirror when ending a
copy job</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
BLOCK COMMIT JOB CONSTANTS</small></b> <br>
The following constants are useful with block commit job
types <br>
Sys::Virt::Domain::BLOCK_COMMIT_DELETE</p>

<p style="margin-left:17%;">Delete any files that are
invalid after commit</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_COMMIT_SHALLOW</p>

<p style="margin-left:17%;"><small>NULL</small> base means
next backing file, not whole chain</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_COMMIT_ACTIVE</p>

<p style="margin-left:17%;">Allow two phase commit when top
is active layer</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_COMMIT_RELATIVE</p>

<p style="margin-left:17%;">Keep backing chain referenced
using relative names</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
SAVE / RESTORE CONSTANTS</small></b> <br>
The following constants can be used when saving or restoring
virtual machines <br>
Sys::Virt::Domain::SAVE_BYPASS_CACHE</p>

<p style="margin-left:17%;">Do not use <small>OS
I/O</small> cache when saving state.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SAVE_PAUSED</p>

<p style="margin-left:17%;">Mark the saved state as paused
to prevent the guest CPUs starting upon restore.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SAVE_RUNNING</p>

<p style="margin-left:17%;">Mark the saved state as running
to allow the guest CPUs to start upon restore.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
CORE DUMP CONSTANTS</small></b> <br>
The following constants can be used when triggering domain
core dumps <br>
Sys::Virt::Domain::DUMP_LIVE</p>

<p style="margin-left:17%;">Do not pause execution while
dumping the guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DUMP_CRASH</p>

<p style="margin-left:17%;">Crash the guest after
completing the core dump</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DUMP_BYPASS_CACHE</p>

<p style="margin-left:17%;">Do not use <small>OS
I/O</small> cache when writing core dump</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DUMP_RESET</p>

<p style="margin-left:17%;">Reset the virtual machine after
finishing the dump</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DUMP_MEMORY_ONLY</p>

<p style="margin-left:17%;">Only include guest
<small>RAM</small> in the dump, not the device state</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DESTROY
CONSTANTS</small></b> <br>
The following constants are useful when terminating guests
using the <tt>&quot;destroy&quot;</tt> <small>API.</small>
<br>
Sys::Virt::Domain::DESTROY_DEFAULT</p>

<p style="margin-left:17%;">Destroy the guest using the
default approach</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DESTROY_GRACEFUL</p>

<p style="margin-left:17%;">Destroy the guest in a graceful
manner</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SHUTDOWN
CONSTANTS</small></b> <br>
The following constants are useful when requesting that a
guest terminate using the <tt>&quot;shutdown&quot;</tt>
<small>API</small> <br>
Sys::Virt::Domain::SHUTDOWN_DEFAULT</p>

<p style="margin-left:17%;">Shutdown using the
hypervisor&rsquo;s default mechanism</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SHUTDOWN_GUEST_AGENT</p>

<p style="margin-left:17%;">Shutdown by issuing a command
to a guest agent</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SHUTDOWN_ACPI_POWER_BTN</p>

<p style="margin-left:17%;">Shutdown by injecting an
<small>ACPI</small> power button press</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SHUTDOWN_INITCTL</p>

<p style="margin-left:17%;">Shutdown by talking to initctl
(containers only)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SHUTDOWN_SIGNAL</p>

<p style="margin-left:17%;">Shutdown by sending
<small>SIGTERM</small> to the init process</p>


<p style="margin-left:11%;">Sys::Virt::Domain::SHUTDOWN_PARAVIRT</p>

<p style="margin-left:17%;">Shutdown by issuing a paravirt
power control command</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>REBOOT
CONSTANTS</small></b> <br>
The following constants are useful when requesting that a
guest terminate using the <tt>&quot;reboot&quot;</tt>
<small>API</small> <br>
Sys::Virt::Domain::REBOOT_DEFAULT</p>

<p style="margin-left:17%;">Reboot using the
hypervisor&rsquo;s default mechanism</p>


<p style="margin-left:11%;">Sys::Virt::Domain::REBOOT_GUEST_AGENT</p>

<p style="margin-left:17%;">Reboot by issuing a command to
a guest agent</p>


<p style="margin-left:11%;">Sys::Virt::Domain::REBOOT_ACPI_POWER_BTN</p>

<p style="margin-left:17%;">Reboot by injecting an
<small>ACPI</small> power button press</p>


<p style="margin-left:11%;">Sys::Virt::Domain::REBOOT_INITCTL</p>

<p style="margin-left:17%;">Reboot by talking to initctl
(containers only)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::REBOOT_SIGNAL</p>

<p style="margin-left:17%;">Reboot by sending
<small>SIGHUP</small> to the init process</p>


<p style="margin-left:11%;">Sys::Virt::Domain::REBOOT_PARAVIRT</p>

<p style="margin-left:17%;">Reboot by issuing a paravirt
power control command</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>METADATA
CONSTANTS</small></b> <br>
The following constants are useful when reading/writing
metadata about a guest <br>
Sys::Virt::Domain::METADATA_TITLE</p>

<p style="margin-left:17%;">The short human friendly title
of the guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::METADATA_DESCRIPTION</p>

<p style="margin-left:17%;">The long free text description
of the guest</p>


<p style="margin-left:11%;">Sys::Virt::Domain::METADATA_ELEMENT</p>

<p style="margin-left:17%;">The structured metadata
elements for the guest</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>DISK
ERROR CONSTANTS</small></b> <br>
The following constants are useful when interpreting disk
error codes <br>
Sys::Virt::Domain::DISK_ERROR_NONE</p>

<p style="margin-left:17%;">No error</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DISK_ERROR_NO_SPACE</p>

<p style="margin-left:17%;">The host storage has run out of
free space</p>


<p style="margin-left:11%;">Sys::Virt::Domain::DISK_ERROR_UNSPEC</p>

<p style="margin-left:17%;">An unspecified error has
ocurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MEMORY
STATISTIC CONSTANTS</small></b> <br>
Sys::Virt::Domain::MEMORY_STAT_SWAP_IN</p>

<p style="margin-left:17%;">Swap in</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_SWAP_OUT</p>

<p style="margin-left:17%;">Swap out</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_MINOR_FAULT</p>

<p style="margin-left:17%;">Minor faults</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_MAJOR_FAULT</p>

<p style="margin-left:17%;">Major faults</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_RSS</p>

<p style="margin-left:17%;">Resident memory</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_UNUSED</p>

<p style="margin-left:17%;">Unused memory</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_AVAILABLE</p>

<p style="margin-left:17%;">Available memory</p>


<p style="margin-left:11%;">Sys::Virt::Domain::MEMORY_STAT_ACTUAL_BALLOON</p>

<p style="margin-left:17%;">Actual balloon limit</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
LIST CONSTANTS</small></b> <br>
The following constants can be used when listing domains
<br>
Sys::Virt::Domain::LIST_ACTIVE</p>

<p style="margin-left:17%;">Only list domains that are
currently active (running, or paused)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_AUTOSTART</p>

<p style="margin-left:17%;">Only list domains that are set
to automatically start on boot</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_HAS_SNAPSHOT</p>

<p style="margin-left:17%;">Only list domains that have a
stored snapshot</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_INACTIVE</p>

<p style="margin-left:17%;">Only list domains that are
currently inactive (shutoff, saved)</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_MANAGEDSAVE</p>

<p style="margin-left:17%;">Only list domains that have
current managed save state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_NO_AUTOSTART</p>

<p style="margin-left:17%;">Only list domains that are not
set to automatically start on boto</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_NO_MANAGEDSAVE</p>

<p style="margin-left:17%;">Only list domains that do not
have any managed save state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_NO_SNAPSHOT</p>

<p style="margin-left:17%;">Only list domains that do not
have a stored snapshot</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_OTHER</p>

<p style="margin-left:17%;">Only list domains that are not
running, paused or shutoff</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_PAUSED</p>

<p style="margin-left:17%;">Only list domains that are
paused</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_PERSISTENT</p>

<p style="margin-left:17%;">Only list domains which have a
persistent config</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_RUNNING</p>

<p style="margin-left:17%;">Only list domains that are
currently running</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_SHUTOFF</p>

<p style="margin-left:17%;">Only list domains that are
currently shutoff</p>


<p style="margin-left:11%;">Sys::Virt::Domain::LIST_TRANSIENT</p>

<p style="margin-left:17%;">Only list domains that do not
have a persistent config</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>SEND
KEY CONSTANTS</small></b> <br>
The following constants are to be used with the
<tt>&quot;send_key&quot;</tt> <small>API</small> <br>
Sys::Virt::Domain::SEND_KEY_MAX_KEYS</p>

<p style="margin-left:17%;">The maximum number of keys that
can be sent in a single call to
<tt>&quot;send_key&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b><small>BLOCK
STATS CONSTANTS</small></b> <br>
The following constants provide the names of well known
block stats fields <br>
Sys::Virt::Domain::BLOCK_STATS_ERRS</p>

<p style="margin-left:17%;">The number of I/O errors</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_FLUSH_REQ</p>

<p style="margin-left:17%;">The number of flush
requests</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_FLUSH_TOTAL_TIMES</p>

<p style="margin-left:17%;">The time spent processing flush
requests</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_READ_BYTES</p>

<p style="margin-left:17%;">The amount of data read</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_READ_REQ</p>

<p style="margin-left:17%;">The number of read requests</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_READ_TOTAL_TIMES</p>

<p style="margin-left:17%;">The time spent processing read
requests</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_WRITE_BYTES</p>

<p style="margin-left:17%;">The amount of data written</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_WRITE_REQ</p>

<p style="margin-left:17%;">The number of write
requests</p>


<p style="margin-left:11%;">Sys::Virt::Domain::BLOCK_STATS_WRITE_TOTAL_TIMES</p>

<p style="margin-left:17%;">The time spent processing write
requests</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>CPU
STATS CONSTANTS</small></b> <br>
The following constants provide the names of well known cpu
stats fields <br>
Sys::Virt::Domain::CPU_STATS_CPUTIME</p>

<p style="margin-left:17%;">The total <small>CPU</small>
time, including both hypervisor and vCPU time.</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CPU_STATS_USERTIME</p>

<p style="margin-left:17%;">THe total time in kernel</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CPU_STATS_SYSTEMTIME</p>

<p style="margin-left:17%;">The total time in userspace</p>


<p style="margin-left:11%;">Sys::Virt::Domain::CPU_STATS_VCPUTIME</p>

<p style="margin-left:17%;">The total vCPU time.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>CPU
STATS CONSTANTS</small></b> <br>
The following constants provide the names of well known
schedular parameters <br>
Sys::Virt::SCHEDULER_EMULATOR_PERIOD</p>

<p style="margin-left:17%;">The duration of the time period
for scheduling the emulator</p>


<p style="margin-left:11%;">Sys::Virt::SCHEDULER_EMULATOR_QUOTA</p>

<p style="margin-left:17%;">The quota for the emulator in
one schedular time period</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
STATS FLAG CONSTANTS</small></b> <br>
The following constants are used as flags when requesting
bulk domain stats from
<tt>&quot;Sys::Virt::get_all_domain_stats&quot;</tt>. <br>
Sys::Virt::Domain::GET_ALL_STATS_ACTIVE</p>

<p style="margin-left:17%;">Include stats for active
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_INACTIVE</p>

<p style="margin-left:17%;">Include stats for inactive
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_OTHER</p>

<p style="margin-left:17%;">Include stats for other
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_PAUSED</p>

<p style="margin-left:17%;">Include stats for paused
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_PERSISTENT</p>

<p style="margin-left:17%;">Include stats for persistent
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_RUNNING</p>

<p style="margin-left:17%;">Include stats for running
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_SHUTOFF</p>

<p style="margin-left:17%;">Include stats for shutoff
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_TRANSIENT</p>

<p style="margin-left:17%;">Include stats for transient
domains</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_ENFORCE_STATS</p>

<p style="margin-left:17%;">Require that all requested
stats fields are returned</p>


<p style="margin-left:11%;">Sys::Virt::Domain::GET_ALL_STATS_BACKING</p>

<p style="margin-left:17%;">Get stats for image backing
files too</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DOMAIN
STATS FIELD CONSTANTS</small></b> <br>
The following constants are used to control which fields are
returned for stats queries. <br>
Sys::Virt::Domain::STATS_BALLOON</p>

<p style="margin-left:17%;">Balloon statistics</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATS_BLOCK</p>

<p style="margin-left:17%;">Block device info</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATS_CPU_TOTAL</p>

<p style="margin-left:17%;"><small>CPU</small> usage
info</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATS_INTERFACE</p>

<p style="margin-left:17%;">Network interface info</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATS_STATE</p>

<p style="margin-left:17%;">General lifecycle state</p>


<p style="margin-left:11%;">Sys::Virt::Domain::STATS_VCPU</p>

<p style="margin-left:17%;">Virtual <small>CPU</small>
info</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>PROCESS
SIGNALS</small></b> <br>
The following constants provide the names of signals which
can be sent to guest processes. They mostly correspond to
<small>POSIX</small> signal names. <br>
Sys::Virt::Domain::PROCESS_SIGNAL_NOP</p>

<p style="margin-left:17%;"><small>SIGNOP</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_HUP</p>

<p style="margin-left:17%;"><small>SIGHUP</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_INT</p>

<p style="margin-left:17%;"><small>SIGINT</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_QUIT</p>

<p style="margin-left:17%;"><small>SIGQUIT</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_ILL</p>

<p style="margin-left:17%;"><small>SIGILL</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_TRAP</p>

<p style="margin-left:17%;"><small>SIGTRAP</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_ABRT</p>

<p style="margin-left:17%;"><small>SIGABRT</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_BUS</p>

<p style="margin-left:17%;"><small>SIGBUS</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_FPE</p>

<p style="margin-left:17%;"><small>SIGFPE</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_KILL</p>

<p style="margin-left:17%;"><small>SIGKILL</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_USR1</p>

<p style="margin-left:17%;"><small>SIGUSR1</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_SEGV</p>

<p style="margin-left:17%;"><small>SIGSEGV</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_USR2</p>

<p style="margin-left:17%;"><small>SIGUSR2</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_PIPE</p>

<p style="margin-left:17%;"><small>SIGPIPE</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_ALRM</p>

<p style="margin-left:17%;"><small>SIGALRM</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_TERM</p>

<p style="margin-left:17%;"><small>SIGTERM</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_STKFLT</p>

<p style="margin-left:17%;"><small>SIGSTKFLT</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_CHLD</p>

<p style="margin-left:17%;"><small>SIGCHLD</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_CONT</p>

<p style="margin-left:17%;"><small>SIGCONT</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_STOP</p>

<p style="margin-left:17%;"><small>SIGSTOP</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_TSTP</p>

<p style="margin-left:17%;"><small>SIGTSTP</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_TTIN</p>

<p style="margin-left:17%;"><small>SIGTTIN</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_TTOU</p>

<p style="margin-left:17%;"><small>SIGTTOU</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_URG</p>

<p style="margin-left:17%;"><small>SIGURG</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_XCPU</p>

<p style="margin-left:17%;"><small>SIGXCPU</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_XFSZ</p>

<p style="margin-left:17%;"><small>SIGXFSZ</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_VTALRM</p>

<p style="margin-left:17%;"><small>SIGVTALRM</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_PROF</p>

<p style="margin-left:17%;"><small>SIGPROF</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_WINCH</p>

<p style="margin-left:17%;"><small>SIGWINCH</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_POLL</p>

<p style="margin-left:17%;"><small>SIGPOLL</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_PWR</p>

<p style="margin-left:17%;"><small>SIGPWR</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_SYS</p>

<p style="margin-left:17%;"><small>SIGSYS</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT0</p>

<p style="margin-left:17%;"><small>SIGRT0</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT1</p>

<p style="margin-left:17%;"><small>SIGRT1</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT2</p>

<p style="margin-left:17%;"><small>SIGRT2</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT3</p>

<p style="margin-left:17%;"><small>SIGRT3</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT4</p>

<p style="margin-left:17%;"><small>SIGRT4</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT5</p>

<p style="margin-left:17%;"><small>SIGRT5</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT6</p>

<p style="margin-left:17%;"><small>SIGRT6</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT7</p>

<p style="margin-left:17%;"><small>SIGRT7</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT8</p>

<p style="margin-left:17%;"><small>SIGRT8</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT9</p>

<p style="margin-left:17%;"><small>SIGRT9</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT10</p>

<p style="margin-left:17%;"><small>SIGRT10</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT11</p>

<p style="margin-left:17%;"><small>SIGRT11</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT12</p>

<p style="margin-left:17%;"><small>SIGRT12</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT13</p>

<p style="margin-left:17%;"><small>SIGRT13</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT14</p>

<p style="margin-left:17%;"><small>SIGRT14</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT15</p>

<p style="margin-left:17%;"><small>SIGRT15</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT16</p>

<p style="margin-left:17%;"><small>SIGRT16</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT17</p>

<p style="margin-left:17%;"><small>SIGRT17</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT18</p>

<p style="margin-left:17%;"><small>SIGRT18</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT19</p>

<p style="margin-left:17%;"><small>SIGRT19</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT20</p>

<p style="margin-left:17%;"><small>SIGRT20</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT21</p>

<p style="margin-left:17%;"><small>SIGRT21</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT22</p>

<p style="margin-left:17%;"><small>SIGRT22</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT23</p>

<p style="margin-left:17%;"><small>SIGRT23</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT24</p>

<p style="margin-left:17%;"><small>SIGRT24</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT25</p>

<p style="margin-left:17%;"><small>SIGRT25</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT26</p>

<p style="margin-left:17%;"><small>SIGRT26</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT27</p>

<p style="margin-left:17%;"><small>SIGRT27</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT28</p>

<p style="margin-left:17%;"><small>SIGRT28</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT29</p>

<p style="margin-left:17%;"><small>SIGRT29</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT30</p>

<p style="margin-left:17%;"><small>SIGRT30</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT31</p>

<p style="margin-left:17%;"><small>SIGRT31</small></p>


<p style="margin-left:11%;">Sys::Virt::Domain::PROCESS_SIGNAL_RT32</p>

<p style="margin-left:17%;"><small>SIGRT32</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>DOMAIN
TUNABLE CONSTANTS</b></small> <br>
The following constants are useful when accessing domain
tuning parameters in APIs and events <br>
Sys::Virt::Domain::TUNABLE_CPU_CPU_SHARES</p>

<p style="margin-left:17%;">Proportional <small>CPU</small>
weight</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_EMULATORPIN</p>

<p style="margin-left:17%;">Emulator thread
<small>CPU</small> pinning mask</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_EMULATOR_PERIOD</p>

<p style="margin-left:17%;">Emulator thread
<small>CPU</small> period</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_EMULATOR_QUOTA</p>

<p style="margin-left:17%;">Emulator thread
<small>CPU</small> quota</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_VCPUPIN</p>

<p style="margin-left:17%;"><small>VCPU</small> thread
pinning mask</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_VCPU_PERIOD</p>

<p style="margin-left:17%;"><small>VCPU</small> thread
period</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_CPU_VCPU_QUOTA</p>

<p style="margin-left:17%;"><small>VCPU</small> thread
quota</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_DISK</p>

<p style="margin-left:17%;">The name of guest disks</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_READ_BYTES_SEC</p>

<p style="margin-left:17%;">Read throughput in bytes per
sec</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_READ_IOPS_SEC</p>

<p style="margin-left:17%;">Read throughput in I/O
operations per sec</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_TOTAL_BYTES_SEC</p>

<p style="margin-left:17%;">Total throughput in bytes per
sec</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_TOTAL_IOPS_SEC</p>

<p style="margin-left:17%;">Total throughput in I/O
operations per sec</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_WRITE_BYTES_SEC</p>

<p style="margin-left:17%;">Write throughput in bytes per
sec</p>


<p style="margin-left:11%;">Sys::Virt::Domain::TUNABLE_BLKDEV_WRITE_IOPS_SEC</p>

<p style="margin-left:17%;">Write throughput in I/O
operations per sec</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Daniel P.
Berrange &lt;berrange@redhat.com&gt;</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2006 Red Hat Copyright (C) 2006&minus;2007 Daniel P.
Berrange</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of either the <small>GNU</small> General
Public License as published by the Free Software Foundation
(either version 2 of the License, or at your option any
later version), or, the Artistic License, as specified in
the Perl <small>README</small> file.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sys::Virt,
Sys::Virt::Error,
<tt>&quot;http://libvirt.org&quot;</tt></p>
<hr>
</body>
</html>
