<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:33:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Sys::Virt</title>

</head>
<body>

<h1 align="center">Sys::Virt</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ERROR HANDLING">ERROR HANDLING</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#CONSTANTS">CONSTANTS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sys::Virt
&minus; Represent and manage a libvirt hypervisor
connection</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  my $vmm = Sys::Virt&minus;&gt;new(uri =&gt; $uri);
  my @domains = $vmm&minus;&gt;list_domains();
  foreach my $dom (@domains) {
    print &quot;Domain &quot;, $dom&minus;&gt;get_id, &quot; &quot;, $dom&minus;&gt;get_name, &quot;\n&quot;;
  }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Sys::Virt
module provides a Perl <small>XS</small> binding to the
libvirt virtual machine management APIs. This allows
machines running within arbitrary virtualization containers
to be managed with a consistent <small>API.</small></p>

<h2>ERROR HANDLING
<a name="ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Any operations
in the Sys::Virt <small>API</small> which have failure
scenarios will result in an instance of the Sys::Virt::Error
module being thrown. To catch these errors, simply wrap the
method in an eval block:</p>

<pre style="margin-left:11%; margin-top: 1em">  eval { my $vmm = Sys::Virt&minus;&gt;new(uri =&gt; $uri); };
  if ($@) {
    print STDERR &quot;Unable to open connection to $addr&quot; . $@&minus;&gt;message . &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">For details of
the information contained in the error objects, consult the
Sys::Virt::Error manual page.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">my $vmm =
Sys::Virt&minus;&gt;new(uri =&gt; $uri, readonly =&gt; $ro,
flags =&gt; <br>
$flags);</p>

<p style="margin-left:17%;">Attach to the virtualization
host identified by <tt>&quot;uri&quot;</tt>. The
<tt>&quot;uri&quot;</tt> parameter may be omitted, in which
case the default connection made will be to the local Xen
hypervisor. Some example URIs include: <br>
xen:///</p>

<p style="margin-left:23%;">Xen on the local machine</p>

<p style="margin-left:17%;">test:///default</p>

<p style="margin-left:23%;">Dummy &quot;in memory&quot;
driver for test suites</p>

<p style="margin-left:17%;">qemu:///system</p>

<p style="margin-left:23%;">System-wide driver for
<small>QEMU / KVM</small> virtualization</p>

<p style="margin-left:17%;">qemu:///session</p>

<p style="margin-left:23%;">Per-user driver for
<small>QEMU</small> virtualization</p>

<p style="margin-left:17%;">qemu+tls://somehost/system</p>

<p style="margin-left:23%;">System-wide <small>QEMU</small>
driver on <tt>&quot;somehost&quot;</tt> using
<small>TLS</small> security</p>

<p style="margin-left:17%;">xen+tcp://somehost/</p>

<p style="margin-left:23%;">Xen driver on
<tt>&quot;somehost&quot;</tt> using <small>TCP /
SASL</small> security</p>

<p style="margin-left:17%; margin-top: 1em">For further
details consult
<tt>&quot;http://libvirt.org/uri.html&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">If the optional
<tt>&quot;readonly&quot;</tt> parameter is supplied, then an
unprivileged connection to the <small>VMM</small> will be
attempted. If it is not supplied, then it defaults to making
a fully privileged connection to the <small>VMM.</small> If
the calling application is not running as root, it may be
necessary to provide authentication callbacks.</p>

<p style="margin-left:17%; margin-top: 1em">If the optional
<tt>&quot;auth&quot;</tt> parameter is set to a non-zero
value, authentication will be enabled during connection,
using the default set of credential gathering callbacks. The
default callbacks prompt for credentials on the console, so
are not suitable for graphical applications. For such apps a
custom implementation should be supplied. The
<tt>&quot;credlist&quot;</tt> parameter should be an array
reference listing the set of credential types that will be
supported. The credential constants in this module can be
used as values in this list. The
<tt>&quot;callback&quot;</tt> parameter should be a
subroutine reference containing the code necessary to gather
the credentials. When invoked it will be supplied with a
single parameter, a array reference of requested
credentials. The elements of the array are hash references,
with keys <tt>&quot;type&quot;</tt> giving the type of
credential, <tt>&quot;prompt&quot;</tt> giving a user
descriptive user prompt, <tt>&quot;challenge&quot;</tt>
giving name of the credential required. The answer should be
collected from the user, and returned by setting the
<tt>&quot;result&quot;</tt> key. This key may already be set
with a default result if applicable</p>

<p style="margin-left:17%; margin-top: 1em">As a simple
example returning hardcoded credentials</p>

<pre style="margin-left:17%; margin-top: 1em">    my $uri  = &quot;qemu+tcp://192.168.122.1/system&quot;;
    my $username = &quot;test&quot;;
    my $password = &quot;123456&quot;;
    my $con = Sys::Virt&minus;&gt;new(uri =&gt; $uri,
                             auth =&gt; 1,
                             credlist =&gt; [
                               Sys::Virt::CRED_AUTHNAME,
                               Sys::Virt::CRED_PASSPHRASE,
                             ],
                             callback =&gt;
         sub {
               my $creds = shift;
               foreach my $cred (@{$creds}) {
                  if ($cred&minus;&gt;{type} == Sys::Virt::CRED_AUTHNAME) {
                      $cred&minus;&gt;{result} = $username;
                  }
                  if ($cred&minus;&gt;{type} == Sys::Virt::CRED_PASSPHRASE) {
                      $cred&minus;&gt;{result} = $password;
                  }
               }
               return 0;
         });</pre>


<p style="margin-left:17%; margin-top: 1em">For backwards
compatibility with earlier releases, the
<tt>&quot;address&quot;</tt> parameter is accepted as a
synonym for the <tt>&quot;uri&quot;</tt> parameter. The use
of <tt>&quot;uri&quot;</tt> is recommended for all newly
written code.</p>

<p style="margin-left:11%;">my $st =
$vmm&minus;&gt;new_stream($flags)</p>

<p style="margin-left:17%;">Create a new stream, with the
given flags</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_domain($xml, $flags);</p>

<p style="margin-left:17%;">Create a new domain based on
the <small>XML</small> description passed into the
<tt>$xml</tt> parameter. The returned object is an instance
of the Sys::Virt::Domain class. This method is not available
with unprivileged connections to the <small>VMM.</small> The
<tt>$flags</tt> parameter accepts one of the <small>DOMAIN
CREATION</small> constants documented in Sys::Virt::Domain,
and defaults to 0 if omitted.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_domain_with_files($xml, $fds,
$flags);</p>

<p style="margin-left:17%;">Create a new domain based on
the <small>XML</small> description passed into the
<tt>$xml</tt> parameter. The returned object is an instance
of the Sys::Virt::Domain class. This method is not available
with unprivileged connections to the <small>VMM.</small> The
<tt>$fds</tt> parameter is an array of <small>UNIX</small>
file descriptors which will be passed to the init process of
the container. This is only supported with container based
virtualization. The <tt>$flags</tt> parameter accepts one of
the <small>DOMAIN CREATION</small> constants documented in
Sys::Virt::Domain, and defaults to 0 if omitted.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;define_domain($xml);</p>

<p style="margin-left:17%;">Defines, but does not start, a
new domain based on the <small>XML</small> description
passed into the <tt>$xml</tt> parameter. The returned object
is an instance of the Sys::Virt::Domain class. This method
is not available with unprivileged connections to the
<small>VMM.</small> The defined domain can be later started
by calling the <tt>&quot;create&quot;</tt> method on the
returned <tt>&quot;Sys::Virt::Domain&quot;</tt> object.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_network($xml);</p>

<p style="margin-left:17%;">Create a new network based on
the <small>XML</small> description passed into the
<tt>$xml</tt> parameter. The returned object is an instance
of the Sys::Virt::Network class. This method is not
available with unprivileged connections to the
<small>VMM.</small></p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;define_network($xml);</p>

<p style="margin-left:17%;">Defines, but does not start, a
new network based on the <small>XML</small> description
passed into the <tt>$xml</tt> parameter. The returned object
is an instance of the Sys::Virt::Network class. This method
is not available with unprivileged connections to the
<small>VMM.</small> The defined network can be later started
by calling the <tt>&quot;create&quot;</tt> method on the
returned <tt>&quot;Sys::Virt::Network&quot;</tt> object.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_storage_pool($xml);</p>

<p style="margin-left:17%;">Create a new storage pool based
on the <small>XML</small> description passed into the
<tt>$xml</tt> parameter. The returned object is an instance
of the Sys::Virt::StoragePool class. This method is not
available with unprivileged connections to the
<small>VMM.</small></p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;define_storage_pool($xml);</p>

<p style="margin-left:17%;">Defines, but does not start, a
new storage pol based on the <small>XML</small> description
passed into the <tt>$xml</tt> parameter. The returned object
is an instance of the Sys::Virt::StoragePool class. This
method is not available with unprivileged connections to the
<small>VMM.</small> The defined pool can be later started by
calling the <tt>&quot;create&quot;</tt> method on the
returned <tt>&quot;Sys::Virt::StoragePool&quot;</tt>
object.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_interface($xml);</p>

<p style="margin-left:17%;">Create a new interface based on
the <small>XML</small> description passed into the
<tt>$xml</tt> parameter. The returned object is an instance
of the Sys::Virt::Interface class. This method is not
available with unprivileged connections to the
<small>VMM.</small></p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;define_interface($xml);</p>

<p style="margin-left:17%;">Defines, but does not start, a
new interface based on the <small>XML</small> description
passed into the <tt>$xml</tt> parameter. The returned object
is an instance of the Sys::Virt::Interface class. This
method is not available with unprivileged connections to the
<small>VMM.</small> The defined interface can be later
started by calling the <tt>&quot;create&quot;</tt> method on
the returned <tt>&quot;Sys::Virt::Interface&quot;</tt>
object.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;create_node_device($xml);</p>

<p style="margin-left:17%;">Create a new virtual node
device based on the <small>XML</small> description passed
into the <tt>$xml</tt> parameter. The returned object is an
instance of the Sys::Virt::NodeDevice class. This method is
not available with unprivileged connections to the
<small>VMM.</small></p>

<p style="margin-left:11%;">my @doms =
$vmm&minus;&gt;<i>list_domains()</i></p>

<p style="margin-left:17%;">Return a list of all running
domains currently known to the <small>VMM.</small> The
elements in the returned list are instances of the
Sys::Virt::Domain class. This method requires O(n)
<small>RPC</small> calls, so the
<tt>&quot;list_all_domains&quot;</tt> method is recommended
as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nids =
$vmm&minus;&gt;<i>num_of_domains()</i></p>

<p style="margin-left:17%;">Return the number of running
domains known to the <small>VMM.</small> This can be used as
the <tt>&quot;maxids&quot;</tt> parameter to
<tt>&quot;list_domain_ids&quot;</tt>.</p>

<p style="margin-left:11%;">my @domIDs =
$vmm&minus;&gt;list_domain_ids($maxids)</p>

<p style="margin-left:17%;">Return a list of all domain IDs
currently known to the <small>VMM.</small> The IDs can be
used with the <tt>&quot;get_domain_by_id&quot;</tt>
method.</p>

<p style="margin-left:11%;">my @doms =
$vmm&minus;&gt;<i>list_defined_domains()</i></p>

<p style="margin-left:17%;">Return a list of all domains
defined, but not currently running, on the
<small>VMM.</small> The elements in the returned list are
instances of the Sys::Virt::Domain class. This method
requires O(n) <small>RPC</small> calls, so the
<tt>&quot;list_all_domains&quot;</tt> method is recommended
as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_defined_domains()</i></p>

<p style="margin-left:17%;">Return the number of running
domains known to the <small>VMM.</small> This can be used as
the <tt>&quot;maxnames&quot;</tt> parameter to
<tt>&quot;list_defined_domain_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @names =
$vmm&minus;&gt;list_defined_domain_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of names of all
domains defined, but not currently running, on the
<small>VMM.</small> The names can be used with the
<tt>&quot;get_domain_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @doms =
$vmm&minus;&gt;list_all_domains($flags)</p>

<p style="margin-left:17%;">Return a list of all domains
currently known to the <small>VMM,</small> whether running
or shutoff. The elements in the returned list are instances
of the Sys::Virt::Domain class. The <tt>$flags</tt>
parameter can be used to filter the list of returned
domains.</p>

<p style="margin-left:11%;">my @nets =
$vmm&minus;&gt;<i>list_networks()</i></p>

<p style="margin-left:17%;">Return a list of all networks
currently known to the <small>VMM.</small> The elements in
the returned list are instances of the Sys::Virt::Network
class. This method requires O(n) <small>RPC</small> calls,
so the <tt>&quot;list_all_networks&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_networks()</i></p>

<p style="margin-left:17%;">Return the number of running
networks known to the <small>VMM.</small> This can be used
as the <tt>&quot;maxids&quot;</tt> parameter to
<tt>&quot;list_network_ids&quot;</tt>.</p>

<p style="margin-left:11%;">my @netNames =
$vmm&minus;&gt;list_network_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of all network
names currently known to the <small>VMM.</small> The names
can be used with the
<tt>&quot;get_network_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @nets =
$vmm&minus;&gt;<i>list_defined_networks()</i></p>

<p style="margin-left:17%;">Return a list of all networks
defined, but not currently running, on the
<small>VMM.</small> The elements in the returned list are
instances of the Sys::Virt::Network class. This method
requires O(n) <small>RPC</small> calls, so the
<tt>&quot;list_all_networks&quot;</tt> method is recommended
as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnamess =
$vmm&minus;&gt;<i>num_of_defined_networks()</i></p>

<p style="margin-left:17%;">Return the number of running
networks known to the host. This can be used as the
<tt>&quot;maxnames&quot;</tt> parameter to
<tt>&quot;list_defined_network_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @names =
$vmm&minus;&gt;list_defined_network_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of names of all
networks defined, but not currently running, on the host.
The names can be used with the
<tt>&quot;get_network_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @nets =
$vmm&minus;&gt;list_all_networks($flags)</p>

<p style="margin-left:17%;">Return a list of all networks
currently known to the <small>VMM,</small> whether running
or shutoff. The elements in the returned list are instances
of the Sys::Virt::Network class. The <tt>$flags</tt>
parameter can be used to filter the list of returned
networks.</p>

<p style="margin-left:11%;">my @pools =
$vmm&minus;&gt;<i>list_storage_pools()</i></p>

<p style="margin-left:17%;">Return a list of all storage
pools currently known to the host. The elements in the
returned list are instances of the Sys::Virt::StoragePool
class. This method requires O(n) <small>RPC</small> calls,
so the <tt>&quot;list_all_storage_pools&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_storage_pools()</i></p>

<p style="margin-left:17%;">Return the number of running
storage pools known to the <small>VMM.</small> This can be
used as the <tt>&quot;maxids&quot;</tt> parameter to
<tt>&quot;list_storage_pool_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @poolNames =
$vmm&minus;&gt;list_storage_pool_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of all storage
pool names currently known to the <small>VMM.</small> The
IDs can be used with the
<tt>&quot;get_network_by_id&quot;</tt> method.</p>

<p style="margin-left:11%;">my @pools =
$vmm&minus;&gt;<i>list_defined_storage_pools()</i></p>

<p style="margin-left:17%;">Return a list of all storage
pools defined, but not currently running, on the host. The
elements in the returned list are instances of the
Sys::Virt::StoragePool class. This method requires O(n)
<small>RPC</small> calls, so the
<tt>&quot;list_all_storage_pools&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_defined_storage_pools()</i></p>

<p style="margin-left:17%;">Return the number of running
networks known to the host. This can be used as the
<tt>&quot;maxnames&quot;</tt> parameter to
<tt>&quot;list_defined_storage_pool_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @names =
$vmm&minus;&gt;list_defined_storage_pool_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of names of all
storage pools defined, but not currently running, on the
host. The names can be used with the
<tt>&quot;get_storage_pool_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @pools =
$vmm&minus;&gt;list_all_storage_pools($flags)</p>

<p style="margin-left:17%;">Return a list of all storage
pools currently known to the <small>VMM,</small> whether
running or shutoff. The elements in the returned list are
instances of the Sys::Virt::StoragePool class. The
<tt>$flags</tt> parameter can be used to filter the list of
returned pools.</p>

<p style="margin-left:11%;">my @devs =
$vmm&minus;&gt;list_node_devices($capability)</p>

<p style="margin-left:17%;">Return a list of all devices
currently known to the host <small>OS.</small> The elements
in the returned list are instances of the
Sys::Virt::NodeDevice class. The optional
<tt>&quot;capability&quot;</tt> parameter allows the list to
be restricted to only devices with a particular capability
type. This method requires O(n) <small>RPC</small> calls, so
the <tt>&quot;list_all_node_devices&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;num_of_node_devices($capability[,
$flags])</p>

<p style="margin-left:17%;">Return the number of host
devices known to the <small>VMM.</small> This can be used as
the <tt>&quot;maxids&quot;</tt> parameter to
<tt>&quot;list_node_device_names&quot;</tt>. The
<tt>&quot;capability&quot;</tt> parameter allows the list to
be restricted to only devices with a particular capability
type, and should be left as <tt>&quot;undef&quot;</tt> if
the full list is required. The optional &lt;flags&gt;
parameter is currently unused and defaults to 0 if
omitted.</p>

<p style="margin-left:11%;">my @netNames =
$vmm&minus;&gt;list_node_device_names($capability,
$maxnames[, <br>
$flags])</p>

<p style="margin-left:17%;">Return a list of all host
device names currently known to the <small>VMM.</small> The
names can be used with the
<tt>&quot;get_node_device_by_name&quot;</tt> method. The
<tt>&quot;capability&quot;</tt> parameter allows the list to
be restricted to only devices with a particular capability
type, and should be left as <tt>&quot;undef&quot;</tt> if
the full list is required. The optional &lt;flags&gt;
parameter is currently unused and defaults to 0 if
omitted.</p>

<p style="margin-left:11%;">my @devs =
$vmm&minus;&gt;list_all_node_devices($flags)</p>

<p style="margin-left:17%;">Return a list of all node
devices currently known to the <small>VMM.</small> The
elements in the returned list are instances of the
Sys::Virt::NodeDevice class. The <tt>$flags</tt> parameter
can be used to filter the list of returned devices.</p>

<p style="margin-left:11%;">my @ifaces =
$vmm&minus;&gt;<i>list_interfaces()</i></p>

<p style="margin-left:17%;">Return a list of all network
interfaces currently known to the <small>VMM.</small> The
elements in the returned list are instances of the
Sys::Virt::Interface class. This method requires O(n)
<small>RPC</small> calls, so the
<tt>&quot;list_all_interfaces&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_interfaces()</i></p>

<p style="margin-left:17%;">Return the number of running
interfaces known to the <small>VMM.</small> This can be used
as the <tt>&quot;maxnames&quot;</tt> parameter to
<tt>&quot;list_interface_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @names =
$vmm&minus;&gt;list_interface_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of all interface
names currently known to the <small>VMM.</small> The names
can be used with the
<tt>&quot;get_interface_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @ifaces =
$vmm&minus;&gt;<i>list_defined_interfaces()</i></p>

<p style="margin-left:17%;">Return a list of all network
interfaces currently known to the <small>VMM.</small> The
elements in the returned list are instances of the
Sys::Virt::Interface class. This method requires O(n)
<small>RPC</small> calls, so the
<tt>&quot;list_all_interfaces&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_defined_interfaces()</i></p>

<p style="margin-left:17%;">Return the number of inactive
interfaces known to the <small>VMM.</small> This can be used
as the <tt>&quot;maxnames&quot;</tt> parameter to
<tt>&quot;list_defined_interface_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @names =
$vmm&minus;&gt;list_defined_interface_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of inactive
interface names currently known to the <small>VMM.</small>
The names can be used with the
<tt>&quot;get_interface_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @ifaces =
$vmm&minus;&gt;list_all_interfaces($flags)</p>

<p style="margin-left:17%;">Return a list of all interfaces
currently known to the <small>VMM,</small> whether running
or shutoff. The elements in the returned list are instances
of the Sys::Virt::Interface class. The <tt>$flags</tt>
parameter can be used to filter the list of returned
interfaces.</p>

<p style="margin-left:11%;">my @ifaces =
$vmm&minus;&gt;<i>list_secrets()</i></p>

<p style="margin-left:17%;">Return a list of all secrets
currently known to the <small>VMM.</small> The elements in
the returned list are instances of the Sys::Virt::Secret
class. This method requires O(n) <small>RPC</small> calls,
so the <tt>&quot;list_all_secrets&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nuuids =
$vmm&minus;&gt;<i>num_of_secrets()</i></p>

<p style="margin-left:17%;">Return the number of secrets
known to the <small>VMM.</small> This can be used as the
<tt>&quot;maxuuids&quot;</tt> parameter to
<tt>&quot;list_secrets&quot;</tt>.</p>

<p style="margin-left:11%;">my @uuids =
$vmm&minus;&gt;list_secret_uuids($maxuuids)</p>

<p style="margin-left:17%;">Return a list of all secret
uuids currently known to the <small>VMM.</small> The uuids
can be used with the <tt>&quot;get_secret_by_uuid&quot;</tt>
method.</p>

<p style="margin-left:11%;">my @secrets =
$vmm&minus;&gt;list_all_secrets($flags)</p>

<p style="margin-left:17%;">Return a list of all secrets
currently known to the <small>VMM.</small> The elements in
the returned list are instances of the Sys::Virt::Network
class. The <tt>$flags</tt> parameter can be used to filter
the list of returned secrets.</p>

<p style="margin-left:11%;">my @nets =
$vmm&minus;&gt;<i>list_nwfilters()</i></p>

<p style="margin-left:17%;">Return a list of all nwfilters
currently known to the <small>VMM.</small> The elements in
the returned list are instances of the Sys::Virt::NWFilter
class. This method requires O(n) <small>RPC</small> calls,
so the <tt>&quot;list_all_nwfilters&quot;</tt> method is
recommended as a more efficient alternative.</p>

<p style="margin-left:11%;">my $nnames =
$vmm&minus;&gt;<i>num_of_nwfilters()</i></p>

<p style="margin-left:17%;">Return the number of running
nwfilters known to the <small>VMM.</small> This can be used
as the <tt>&quot;maxids&quot;</tt> parameter to
<tt>&quot;list_nwfilter_names&quot;</tt>.</p>

<p style="margin-left:11%;">my @filterNames =
$vmm&minus;&gt;list_nwfilter_names($maxnames)</p>

<p style="margin-left:17%;">Return a list of all nwfilter
names currently known to the <small>VMM.</small> The names
can be used with the
<tt>&quot;get_nwfilter_by_name&quot;</tt> method.</p>

<p style="margin-left:11%;">my @nwfilters =
$vmm&minus;&gt;list_all_nwfilters($flags)</p>

<p style="margin-left:17%;">Return a list of all nwfilters
currently known to the <small>VMM.</small> The elements in
the returned list are instances of the Sys::Virt::NWFilter
class. The <tt>$flags</tt> parameter is currently unused and
defaults to zero.</p>


<p style="margin-left:11%;">$vmm&minus;&gt;define_save_image_xml($file,
$dxml, $flags=0)</p>

<p style="margin-left:17%;">Update the <small>XML</small>
associated with a virtual machine&rsquo;s save image. The
<tt>$file</tt> parameter is the fully qualified path to the
save image <small>XML,</small> while <tt>$dxml</tt> is the
new <small>XML</small> document to write. The
<tt>$flags</tt> parameter is currently unused and defaults
to zero.</p>

<p style="margin-left:11%;">$xml =
$vmm&minus;&gt;get_save_image_xml_description($file,
$flags=1)</p>

<p style="margin-left:17%;">Retrieve the current
<small>XML</small> configuration associated with the virtual
machine&rsquo;s save image identified by <tt>$file</tt>. The
<tt>$flags</tt> parameter is currently unused and defaults
to zero.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;get_domain_by_name($name)</p>

<p style="margin-left:17%;">Return the domain with a name
of <tt>$name</tt>. The returned object is an instance of the
Sys::Virt::Domain class.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;get_domain_by_id($id)</p>

<p style="margin-left:17%;">Return the domain with a local
id of <tt>$id</tt>. The returned object is an instance of
the Sys::Virt::Domain class.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;get_domain_by_uuid($uuid)</p>

<p style="margin-left:17%;">Return the domain with a
globally unique id of <tt>$uuid</tt>. The returned object is
an instance of the Sys::Virt::Domain class.</p>

<p style="margin-left:11%;">my $net =
$vmm&minus;&gt;get_network_by_name($name)</p>

<p style="margin-left:17%;">Return the network with a name
of <tt>$name</tt>. The returned object is an instance of the
Sys::Virt::Network class.</p>

<p style="margin-left:11%;">my $net =
$vmm&minus;&gt;get_network_by_uuid($uuid)</p>

<p style="margin-left:17%;">Return the network with a
globally unique id of <tt>$uuid</tt>. The returned object is
an instance of the Sys::Virt::Network class.</p>

<p style="margin-left:11%;">my $pool =
$vmm&minus;&gt;get_storage_pool_by_name($name)</p>

<p style="margin-left:17%;">Return the storage pool with a
name of <tt>$name</tt>. The returned object is an instance
of the Sys::Virt::StoragePool class.</p>

<p style="margin-left:11%;">my $pool =
$vmm&minus;&gt;get_storage_pool_by_uuid($uuid)</p>

<p style="margin-left:17%;">Return the storage pool with a
globally unique id of <tt>$uuid</tt>. The returned object is
an instance of the Sys::Virt::StoragePool class.</p>

<p style="margin-left:11%;">my $pool =
$vmm&minus;&gt;get_storage_pool_by_volume($vol)</p>

<p style="margin-left:17%;">Return the storage pool with a
storage volume <tt>$vol</tt>. The <tt>$vol</tt> parameter
must be an instance of the Sys::Virt::StorageVol class. The
returned object is an instance of the Sys::Virt::StoragePool
class.</p>

<p style="margin-left:11%;">my $vol =
$vmm&minus;&gt;get_storage_volume_by_path($path)</p>

<p style="margin-left:17%;">Return the storage volume with
a location of <tt>$path</tt>. The returned object is an
instance of the Sys::Virt::StorageVol class.</p>

<p style="margin-left:11%;">my $vol =
$vmm&minus;&gt;get_storage_volume_by_key($key)</p>

<p style="margin-left:17%;">Return the storage volume with
a globally unique id of <tt>$key</tt>. The returned object
is an instance of the Sys::Virt::StorageVol class.</p>

<p style="margin-left:11%;">my $dev =
$vmm&minus;&gt;get_node_device_by_name($name)</p>

<p style="margin-left:17%;">Return the node device with a
name of <tt>$name</tt>. The returned object is an instance
of the Sys::Virt::NodeDevice class.</p>

<p style="margin-left:11%;">my $dev =
$vmm&minus;&gt;get_node_device_scsihost_by_wwn($wwnn, $wwpn,
$flags=0)</p>

<p style="margin-left:17%;">Return the node device which is
a <small>SCSI</small> host identified by <tt>$wwnn</tt> and
<tt>$wwpn</tt>. The <tt>$flags</tt> parameter is unused and
defaults to zero. The returned object is an instance of the
Sys::Virt::NodeDevice class.</p>

<p style="margin-left:11%;">my $iface =
$vmm&minus;&gt;get_interface_by_name($name)</p>

<p style="margin-left:17%;">Return the interface with a
name of <tt>$name</tt>. The returned object is an instance
of the Sys::Virt::Interface class.</p>

<p style="margin-left:11%;">my $iface =
$vmm&minus;&gt;get_interface_by_mac($mac)</p>

<p style="margin-left:17%;">Return the interface with a
<small>MAC</small> address of <tt>$mac</tt>. The returned
object is an instance of the Sys::Virt::Interface class.</p>

<p style="margin-left:11%;">my $sec =
$vmm&minus;&gt;get_secret_by_uuid($uuid)</p>

<p style="margin-left:17%;">Return the secret with a
globally unique id of <tt>$uuid</tt>. The returned object is
an instance of the Sys::Virt::Secret class.</p>

<p style="margin-left:11%;">my $sec =
$vmm&minus;&gt;get_secret_by_usage($usageType, $usageID)</p>

<p style="margin-left:17%;">Return the secret with a usage
type of <tt>$usageType</tt>, identified by
<tt>$usageID</tt>. The returned object is an instance of the
Sys::Virt::Secret class.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;get_nwfilter_by_name($name)</p>

<p style="margin-left:17%;">Return the domain with a name
of <tt>$name</tt>. The returned object is an instance of the
Sys::Virt::NWFilter class.</p>

<p style="margin-left:11%;">my $dom =
$vmm&minus;&gt;get_nwfilter_by_uuid($uuid)</p>

<p style="margin-left:17%;">Return the nwfilter with a
globally unique id of <tt>$uuid</tt>. The returned object is
an instance of the Sys::Virt::NWFilter class.</p>

<p style="margin-left:11%;">my $xml =
$vmm&minus;&gt;find_storage_pool_sources($type, $srcspec[,
$flags])</p>

<p style="margin-left:17%;">Probe for available storage
pool sources for the pool of type <tt>$type</tt>. The
<tt>$srcspec</tt> parameter can be
<tt>&quot;undef&quot;</tt>, or a parameter to refine the
discovery process, for example a server hostname for
<small>NFS</small> discovery. The <tt>$flags</tt> parameter
is optional, and if omitted defaults to zero. The returned
scalar is an <small>XML</small> document describing the
discovered storage pool sources.</p>

<p style="margin-left:11%;">my @stats =
$vmm&minus;&gt;get_all_domain_stats($stats, \@doms=undef,
$flags=0);</p>

<p style="margin-left:17%;">Get an list of all statistics
for domains known to the hypervisor. The <tt>$stats</tt>
parameter controls which data fields to return and should be
a combination of the <small>DOMAIN STATS FIELD
CONSTANTS.</small></p>

<p style="margin-left:17%; margin-top: 1em">The optional
<tt>@doms</tt> parameter is a list of Sys::Virt::Domain
objects to return stats for. If this is undefined, then all
domains will be returned. The <tt>$flags</tt> method can be
used to filter the list of returned domains.</p>

<p style="margin-left:17%; margin-top: 1em">The return data
for the method is a list, one element for each domain. The
element will be a hash with two keys,
<tt>&quot;dom&quot;</tt> pointing to an instance of
<tt>&quot;Sys::Virt::Domain&quot;</tt> and
<tt>&quot;data&quot;</tt> pointing to another hash reference
containing the actual statistics.</p>


<p style="margin-left:11%;">$vmm&minus;&gt;interface_change_begin($flags)</p>

<p style="margin-left:17%;">Begin a transaction for
changing the configuration of one or more network
interfaces</p>


<p style="margin-left:11%;">$vmm&minus;&gt;interface_change_commit($flags)</p>

<p style="margin-left:17%;">Complete a transaction for
changing the configuration of one or more network
interfaces</p>


<p style="margin-left:11%;">$vmm&minus;&gt;interface_change_rollback($flags)</p>

<p style="margin-left:17%;">Abort a transaction for
changing the configuration of one or more network
interfaces</p>


<p style="margin-left:11%;">$vmm&minus;&gt;restore_domain($savefile)</p>

<p style="margin-left:17%;">Recreate a domain from the
saved state file given in the <tt>$savefile</tt>
parameter.</p>


<p style="margin-left:11%;">$vmm&minus;&gt;get_max_vcpus($domtype)</p>

<p style="margin-left:17%;">Return the maximum number of
vcpus that can be configured for a domain of type
<tt>$domtype</tt></p>

<p style="margin-left:11%;">my $hostname =
$vmm&minus;&gt;<i>get_hostname()</i></p>

<p style="margin-left:17%;">Return the name of the host
with which this connection is associated.</p>

<p style="margin-left:11%;">my $uri =
$vmm&minus;&gt;<i>get_uri()</i></p>

<p style="margin-left:17%;">Return the <small>URI</small>
associated with the open connection. This may be different
from the <small>URI</small> used when initially connecting
to libvirt, when &rsquo;auto&minus;probing&rsquo; or drivers
occurrs.</p>

<p style="margin-left:11%;">my $xml =
$vmm&minus;&gt;<i>get_sysinfo()</i></p>

<p style="margin-left:17%;">Return an <small>XML</small>
documenting representing the host system information,
typically obtained from <small>SMBIOS</small> tables.</p>

<p style="margin-left:11%;">my $type =
$vmm&minus;&gt;<i>get_type()</i></p>

<p style="margin-left:17%;">Return the type of
virtualization backend accessed by this <small>VMM</small>
object. Currently the only supported type is
<tt>&quot;Xen&quot;</tt>.</p>

<p style="margin-left:11%;">my $xml =
$vmm&minus;&gt;domain_xml_from_native($format, $config);</p>

<p style="margin-left:17%;">Convert the native hypervisor
configuration <tt>$config</tt> which is in format
&lt;$format&gt; into libvirrt domain <small>XML.</small>
Valid values of <tt>$format</tt> vary between hypervisor
drivers.</p>

<p style="margin-left:11%;">my $config =
$vmm&minus;&gt;domain_xml_to_native($format, $xml)</p>

<p style="margin-left:17%;">Convert the libvirt domain
<small>XML</small> configuration <tt>$xml</tt> to a native
hypervisor configuration in format <tt>$format</tt></p>

<p style="margin-left:11%;">my $ver =
$vmm&minus;&gt;<i>get_version()</i></p>

<p style="margin-left:17%;">Return the complete version
number as a string encoded in the formula <tt>&quot;(major *
1000000) + (minor * 1000) + micro&quot;</tt>.</p>

<p style="margin-left:11%;">my $ver =
$vmm&minus;&gt;get_major_version</p>

<p style="margin-left:17%;">Return the major version number
of the libvirt library.</p>

<p style="margin-left:11%;">my $ver =
$vmm&minus;&gt;get_minor_version</p>

<p style="margin-left:17%;">Return the minor version number
of the libvirt library.</p>

<p style="margin-left:11%;">my $ver =
$vmm&minus;&gt;get_micro_version</p>

<p style="margin-left:17%;">Return the micro version number
of the libvirt library.</p>

<p style="margin-left:11%;">my $ver =
$vmm&minus;&gt;get_library_version</p>

<p style="margin-left:17%;">Return the version number of
the <small>API</small> associated with the active
connection. This differs from
<tt>&quot;get_version&quot;</tt> in that if the connection
is to a remote libvirtd daemon, it will return the
<small>API</small> version of the remote libvirt, rather
than the local client.</p>


<p style="margin-left:11%;">$conn&minus;&gt;<i>is_secure()</i></p>

<p style="margin-left:17%;">Returns a true value if the
current connection is secure against network interception.
This implies either use of <small>UNIX</small> sockets, or
encryption with a <small>TCP</small> stream.</p>


<p style="margin-left:11%;">$conn&minus;&gt;<i>is_encrypted()</i></p>

<p style="margin-left:17%;">Returns a true value if the
current connection data stream is encrypted.</p>


<p style="margin-left:11%;">$conn&minus;&gt;<i>is_alive()</i></p>

<p style="margin-left:17%;">Returns a true value if the
connection is alive, as determined by keep-alive packets or
other recent <small>RPC</small> traffic.</p>


<p style="margin-left:11%;">$conn&minus;&gt;set_keep_alive($interval,
$count)</p>

<p style="margin-left:17%;">Change the operation of the
keep alive protocol to send <tt>$count</tt> packets spaced
<tt>$interval</tt> seconds apart before considering the
connection dead.</p>

<p style="margin-left:11%;">my $info =
$con&minus;&gt;<i>get_node_info()</i></p>

<p style="margin-left:17%;">Returns a hash reference
summarising the capabilities of the host node. The elements
of the hash are as follows: <br>
memory</p>

<p style="margin-left:23%;">The amount of physical memory
in the host</p>

<p style="margin-left:17%;">model</p>

<p style="margin-left:23%;">The model of the
<small>CPU,</small> eg x86_64</p>

<p style="margin-left:17%;">cpus</p>

<p style="margin-left:23%;">The total number of logical
CPUs.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>mhz</p></td>
<td width="1%"></td>
<td width="35%">


<p>The peak <small>MHZ</small> of the
<small>CPU</small></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%;">nodes</p>

<p style="margin-left:23%;">The number of
<small>NUMA</small> cells</p>

<p style="margin-left:17%;">sockets</p>

<p style="margin-left:23%;">The number of
<small>CPU</small> sockets</p>

<p style="margin-left:17%;">cores</p>

<p style="margin-left:23%;">The number of cores per
socket</p>

<p style="margin-left:17%;">threads</p>

<p style="margin-left:23%;">The number of threads per
core</p>


<p style="margin-left:17%; margin-top: 1em"><small>NB,</small>
more accurate information about the total number of CPUs and
those online can be obtained using the
<tt>&quot;get_node_cpu_map&quot;</tt> method.</p>

<p style="margin-left:11%;">my ($totcpus, $onlinemap,
$totonline) = $con&minus;&gt;<i>get_node_cpu_map()</i>;</p>

<p style="margin-left:17%;">Returns an array containing
information about the CPUs available on the host. The first
element, <tt>&quot;totcpus&quot;</tt>, specifies the total
number of CPUs available to the host regardles of their
online stat. The second element,
<tt>&quot;onlinemap&quot;</tt>, provides a bitmap detailing
which CPUs are currently online. The third element,
<tt>&quot;totonline&quot;</tt>, specifies the total number
of online CPUs. The values in the bitmap can be extracted
using the <tt>&quot;unpack&quot;</tt> method as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">  my @onlinemap = split(//, unpack(&quot;b*&quot;, $onlinemap));</pre>


<p style="margin-left:11%;">my $info =
$con&minus;&gt;get_node_cpu_stats($cpuNum=&minus;1,
$flags=0)</p>

<p style="margin-left:17%;">Returns a hash reference
providing information about the host <small>CPU</small>
statistics. If &lt;$cpuNum&gt; is omitted, it defaults to
<tt>&quot;Sys::Virt::NODE_CPU_STATS_ALL_CPUS&quot;</tt>
which causes it to return cummulative information for all
CPUs in the host. If <tt>$cpuNum</tt> is zero or larger, it
returns information just for the specified number. The
<tt>$flags</tt> parameter is currently unused and defaults
to zero. The fields in the returned hash reference are <br>
kernel</p>

<p style="margin-left:23%;">The time spent in
kernelspace</p>

<p style="margin-left:17%;">user</p>

<p style="margin-left:23%;">The time spent in userspace</p>

<p style="margin-left:17%;">idle</p>

<p style="margin-left:23%;">The idle time</p>

<p style="margin-left:17%;">iowait</p>

<p style="margin-left:23%;">The I/O wait time</p>

<p style="margin-left:17%;">utilization</p>

<p style="margin-left:23%;">The overall percentage
utilization.</p>

<p style="margin-left:11%;">my $info =
$con&minus;&gt;get_node_memory_stats($cellNum=&minus;1,
$flags=0)</p>

<p style="margin-left:17%;">Returns a hash reference
providing information about the host memory statistics. If
&lt;$cellNum&gt; is omitted, it defaults to
<tt>&quot;Sys::Virt::NODE_MEMORY_STATS_ALL_CELLS&quot;</tt>
which causes it to return cummulative information for all
<small>NUMA</small> cells in the host. If <tt>$cellNum</tt>
is zero or larger, it returns information just for the
specified number. The <tt>$flags</tt> parameter is currently
unused and defaults to zero. The fields in the returned hash
reference are <br>
total</p>

<p style="margin-left:23%;">The total memory</p>

<p style="margin-left:17%;">free</p>

<p style="margin-left:23%;">The free memory</p>

<p style="margin-left:17%;">buffers</p>

<p style="margin-left:23%;">The memory consumed by
buffers</p>

<p style="margin-left:17%;">cached</p>

<p style="margin-left:23%;">The memory consumed for
cache</p>

<p style="margin-left:11%;">my $params =
$conn&minus;&gt;get_node_memory_parameters($flags=0)</p>

<p style="margin-left:17%;">Return a hash reference
containing the set of memory tunable parameters for the
node. The keys in the hash are one of the constants
<small>MEMORY PARAMETERS</small> described later. The
<tt>$flags</tt> parameter is currently unused, and defaults
to 0 if omitted.</p>


<p style="margin-left:11%;">$conn&minus;&gt;set_node_memory_parameters($params,
$flags=0)</p>

<p style="margin-left:17%;">Update the memory tunable
parameters for the node. The <tt>$params</tt> should be a
hash reference whose keys are one of the <small>MEMORY
PARAMETERS</small> constants. The <tt>$flags</tt> parameter
is currently unused, and defaults to 0 if omitted.</p>


<p style="margin-left:11%;">$conn&minus;&gt;node_suspend_for_duration($target,
$duration, $flags=0)</p>

<p style="margin-left:17%;">Suspend the the host, using
mode <tt>$target</tt> which is one of the <small>NODE
SUSPEND</small> constants listed later. The
<tt>$duration</tt> parameter controls how long the node is
suspended for before waking up.</p>


<p style="margin-left:11%;">$conn&minus;&gt;domain_event_register($callback)</p>

<p style="margin-left:17%;">Register a callback to received
notificaitons of domain state change events. Only a single
callback can be registered with each connection instance.
The callback will be invoked with four parameters, an
instance of <tt>&quot;Sys::Virt&quot;</tt> for the
connection, an instance of
<tt>&quot;Sys::Virt::Domain&quot;</tt> for the domain
changing state, and a <tt>&quot;event&quot;</tt> and
<tt>&quot;detail&quot;</tt> arguments, corresponding to the
event constants defined in the
<tt>&quot;Sys::Virt::Domain&quot;</tt> module. Before
discarding the connection object, the callback must be
deregistered, otherwise the connection object memory will
never be released in garbage collection.</p>


<p style="margin-left:11%;">$conn&minus;&gt;<i>domain_event_deregister()</i></p>

<p style="margin-left:17%;">Unregister a callback, allowing
the connection object to be garbage collected.</p>

<p style="margin-left:11%;">$callback =
$conn&minus;&gt;domain_event_register_any($dom, $eventID,
$callback)</p>

<p style="margin-left:17%;">Register a callback to received
notifications of domain events. The <tt>$dom</tt> parameter
can be <tt>&quot;undef&quot;</tt> to request events on all
known domains, or a specific
<tt>&quot;Sys::Virt::Domain&quot;</tt> object to filter
events. The <tt>$eventID</tt> parameter is one of the
<small>EVENT ID</small> constants described later in this
document. The <tt>$callback</tt> is a subroutine reference
that will receive the events.</p>

<p style="margin-left:17%; margin-top: 1em">All callbacks
receive a <tt>&quot;Sys::Virt&quot;</tt> connection as the
first parameter and a <tt>&quot;Sys::Virt::Domain&quot;</tt>
object indiciating the domain on which the event occurred as
the second parameter. Subsequent parameters vary according
to the event type <small><br>
EVENT_ID_LIFECYCLE</small></p>

<p style="margin-left:23%;">Extra
<tt>&quot;event&quot;</tt> and <tt>&quot;detail&quot;</tt>
parameters defining the lifecycle transition that
occurred.</p>


<p style="margin-left:17%;"><small>EVENT_ID_REBOOT</small></p>

<p style="margin-left:23%;">No extra parameters</p>


<p style="margin-left:17%;"><small>EVENT_ID_RTC_CHANGE</small></p>

<p style="margin-left:23%;">The
<tt>&quot;utcoffset&quot;</tt> gives the offset from
<small>UTC</small> in seconds</p>


<p style="margin-left:17%;"><small>EVENT_ID_WATCHDOG</small></p>

<p style="margin-left:23%;">The <tt>&quot;action&quot;</tt>
defines the action that is taken as a result of the watchdog
triggering. One of the <small>WATCHDOG</small> constants
described later</p>


<p style="margin-left:17%;"><small>EVENT_ID_IO_ERROR</small></p>

<p style="margin-left:23%;">The
<tt>&quot;srcPath&quot;</tt> is the file on the host which
had the error. The <tt>&quot;devAlias&quot;</tt> is the
unique device alias from the guest configuration associated
with <tt>&quot;srcPath&quot;</tt>. The
<tt>&quot;action&quot;</tt> is the action taken as a result
of the error, one of the <small>IO ERROR</small> constants
described later</p>


<p style="margin-left:17%;"><small>EVENT_ID_GRAPHICS</small></p>

<p style="margin-left:23%;">The <tt>&quot;phase&quot;</tt>
is the stage of the connection, one of the <small>GRAPHICS
PHASE</small> constants described later. The
<tt>&quot;local&quot;</tt> and <tt>&quot;remote&quot;</tt>
parameters follow with the details of the local and remote
network addresses. The <tt>&quot;authScheme&quot;</tt>
describes how the user was authenticated (if at all).
Finally <tt>&quot;identities&quot;</tt> is an array ref
containing authenticated identities for the user, if
any.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is a unique callback <small>ID</small> that must be
used when unregistering the event.</p>


<p style="margin-left:11%;">$conn&minus;&gt;domain_event_deregister_any($callbackID)</p>

<p style="margin-left:17%;">Unregister a callback,
associated with the <tt>$callbackID</tt> previously obtained
from <tt>&quot;domain_event_register_any&quot;</tt>.</p>

<p style="margin-left:11%;">$callback =
$conn&minus;&gt;network_event_register_any($dom, $eventID,
<br>
$callback)</p>

<p style="margin-left:17%;">Register a callback to received
notifications of network events. The <tt>$dom</tt> parameter
can be <tt>&quot;undef&quot;</tt> to request events on all
known networks, or a specific
<tt>&quot;Sys::Virt::Network&quot;</tt> object to filter
events. The <tt>$eventID</tt> parameter is one of the
<small>EVENT ID</small> constants described later in this
document. The <tt>$callback</tt> is a subroutine reference
that will receive the events.</p>

<p style="margin-left:17%; margin-top: 1em">All callbacks
receive a <tt>&quot;Sys::Virt&quot;</tt> connection as the
first parameter and a
<tt>&quot;Sys::Virt::Network&quot;</tt> object indiciating
the network on which the event occurred as the second
parameter. Subsequent parameters vary according to the event
type <small><br>
EVENT_ID_LIFECYCLE</small></p>

<p style="margin-left:23%;">Extra
<tt>&quot;event&quot;</tt> and <tt>&quot;detail&quot;</tt>
parameters defining the lifecycle transition that
occurred.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is a unique callback <small>ID</small> that must be
used when unregistering the event.</p>


<p style="margin-left:11%;">$conn&minus;&gt;network_event_deregister_any($callbackID)</p>

<p style="margin-left:17%;">Unregister a callback,
associated with the <tt>$callbackID</tt> previously obtained
from <tt>&quot;network_event_register_any&quot;</tt>.</p>


<p style="margin-left:11%;">$conn&minus;&gt;register_close_callback($coderef);</p>

<p style="margin-left:17%;">Register a callback to be
invoked when the connection is closed. The callback will be
invoked with two parameters, the <tt>$conn</tt> it was
registered against, and the reason for the close event. The
reason value will be one of the <tt>&quot;CLOSE REASON
CONSTANTS&quot;</tt> listed later in this document.</p>


<p style="margin-left:11%;">$conn&minus;&gt;<i>unregister_close_callback()</i>;</p>

<p style="margin-left:17%;">Remove the previously
registered close callback.</p>

<p style="margin-left:11%;">my $xml =
$con&minus;&gt;baseline_cpu(\@xml, $flags=0)</p>

<p style="margin-left:17%;">Given an array ref whose
elements are <small>XML</small> documents describing host
CPUs, compute the baseline <small>CPU</small> model that is
operable across all hosts. The <small>XML</small> for the
baseline <small>CPU</small> model is returned. The optional
<tt>$flags</tt> parameter can take one of <br>
Sys::Virt::BASELINE_CPU_EXPAND_FEATURES</p>

<p style="margin-left:23%;">Expand the <small>CPU</small>
definition to list all feature flags, even those implied by
the model name.</p>

<p style="margin-left:11%;">@names =
$con&minus;&gt;get_cpu_model_names($arch, $flags=0)</p>

<p style="margin-left:17%;">Get a list of valid
<small>CPU</small> models names for the architecture given
by <tt>$arch</tt>. The <tt>$arch</tt> value should be one of
the architectures listed in the capabilities
<small>XML</small> document. The <tt>$flags</tt> parameter
is currently unused and defaults to 0.</p>

<p style="margin-left:11%;">my $info =
$con&minus;&gt;<i>get_node_security_model()</i></p>

<p style="margin-left:17%;">Returns a hash reference
summarising the security model of the host node. There are
two keys in the hash, <tt>&quot;model&quot;</tt> specifying
the name of the security model (eg &rsquo;selinux&rsquo;)
and <tt>&quot;doi&quot;</tt> specifying the &rsquo;domain of
interpretation&rsquo; for security labels.</p>

<p style="margin-left:11%;">my $xml =
$con&minus;&gt;<i>get_capabilities()</i>;</p>

<p style="margin-left:17%;">Returns an <small>XML</small>
document describing the hypervisor capabilities</p>

<p style="margin-left:11%;">my $xml =
$con&minus;&gt;get_domain_capabilities($emulator, $arch,
$machine, <br>
$virttype, flags=0);</p>

<p style="margin-left:17%;">Returns an <small>XML</small>
document describing the capabilities of the requested guest
configuration. Either <tt>$emulator</tt> or <tt>$arch</tt>
must be a valid string referring to an emulator binary or an
architecture name respectively. The <tt>$machine</tt>
parameter is an optional name of a guest machine, and
<tt>$virttype</tt> is an optional name of the virtualization
type. <tt>$flags</tt> is unused and defaults to zero.</p>

<p style="margin-left:11%;">my $result =
$con&minus;&gt;compare_cpu($xml, $flags=0);</p>

<p style="margin-left:17%;">Checks whether the
<small>CPU</small> definition in <tt>$xml</tt> is compatible
with the current hypervisor connection. This can be used to
determine whether it is safe to migrate a guest to this
host. The returned result is one of the constants listed
later The optional <tt>$flags</tt> parameter can take one of
the following constants <br>
Sys::Virt::COMPARE_CPU_FAIL_INCOMPATIBLE</p>

<p style="margin-left:23%;">Raise a fatal error if the CPUs
are not compatible, instead of just returning a special
error code.</p>

<p style="margin-left:11%;">$mem =
$con&minus;&gt;<i>get_node_free_memory()</i>;</p>

<p style="margin-left:17%;">Returns the current free memory
on the host</p>

<p style="margin-left:11%;">@mem =
$con&minus;&gt;get_node_cells_free_memory($start, $end);</p>

<p style="margin-left:17%;">Returns the free memory on each
<small>NUMA</small> cell between <tt>$start</tt> and
<tt>$end</tt>.</p>

<p style="margin-left:11%;">@pages =
$con&minus;&gt;get_node_free_pages(\@pagesizes, $start,
$end);</p>

<p style="margin-left:17%;">Returns information about the
number of pages free on each <small>NUMA</small> cell
between <tt>$start</tt> and <tt>$end</tt> inclusive. The
<tt>@pagesizes</tt> parameter should be an arrayref
specifying which pages sizes information should be returned
for. Information about supported page sizes is available in
the capabilities <small>XML.</small> The returned array has
an element for each <small>NUMA</small> cell requested. The
elements are hash references with two keys,
&rsquo;cell&rsquo; specifies the <small>NUMA</small> cell
number and &rsquo;pages&rsquo; specifies the free page
information for that cell. The &rsquo;pages&rsquo; value is
another hash reference where the keys are the page sizes and
the values are the free count for that size.</p>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
sets of constants are useful when dealing with APIs in this
package</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CONNECTION</small></b>
<br>
When opening a connection the following constants can be
used: <br>
Sys::Virt::CONNECT_RO</p>

<p style="margin-left:17%;">Request a read-only
connection</p>


<p style="margin-left:11%;">Sys::Virt::CONNECT_NO_ALIASES</p>

<p style="margin-left:17%;">Prevent the resolution of
<small>URI</small> aliases</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CREDENTIAL
TYPES</small></b> <br>
When providing authentication callbacks, the following
constants indicate the type of credential being requested
<br>
Sys::Virt::CRED_AUTHNAME</p>

<p style="margin-left:17%;">Identity to act as</p>

<p style="margin-left:11%;">Sys::Virt::CRED_USERNAME</p>

<p style="margin-left:17%;">Identity to authorize as</p>

<p style="margin-left:11%;">Sys::Virt::CRED_CNONCE</p>

<p style="margin-left:17%;">Client supplies a nonce</p>

<p style="margin-left:11%;">Sys::Virt::CRED_REALM</p>

<p style="margin-left:17%;">Authentication realm</p>

<p style="margin-left:11%;">Sys::Virt::CRED_ECHOPROMPT</p>

<p style="margin-left:17%;">Challenge response
non-secret</p>


<p style="margin-left:11%;">Sys::Virt::CRED_NOECHOPROMPT</p>

<p style="margin-left:17%;">Challenge response secret</p>

<p style="margin-left:11%;">Sys::Virt::CRED_PASSPHRASE</p>

<p style="margin-left:17%;">Passphrase secret</p>

<p style="margin-left:11%;">Sys::Virt::CRED_LANGUAGE</p>

<p style="margin-left:17%;"><small>RFC 1766</small>
language code</p>

<p style="margin-left:11%;">Sys::Virt::CRED_EXTERNAL</p>

<p style="margin-left:17%;">Externally provided
credential</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>CPU
COMPARISON CONSTANTS</small></b> <br>
Sys::Virt::CPU_COMPARE_INCOMPATIBLE</p>

<p style="margin-left:17%;">This host is missing one or
more <small>CPU</small> features in the <small>CPU</small>
description</p>


<p style="margin-left:11%;">Sys::Virt::CPU_COMPARE_IDENTICAL</p>

<p style="margin-left:17%;">The host has an identical
<small>CPU</small> description</p>


<p style="margin-left:11%;">Sys::Virt::CPU_COMPARE_SUPERSET</p>

<p style="margin-left:17%;">The host offers a superset of
the <small>CPU</small> descriptoon</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>NODE
SUSPEND CONSTANTS</small></b> <br>
Sys::Virt::NODE_SUSPEND_TARGET_MEM</p>

<p style="margin-left:17%;">Suspends to memory (equivalent
of S3 on x86 architectures)</p>


<p style="margin-left:11%;">Sys::Virt::NODE_SUSPEND_TARGET_DISK</p>

<p style="margin-left:17%;">Suspends to disk (equivalent of
S5 on x86 architectures)</p>


<p style="margin-left:11%;">Sys::Virt::NODE_SUSPEND_TARGET_HYBRID</p>

<p style="margin-left:17%;">Suspends to memory and disk
(equivalent of S3+S5 on x86 architectures)</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>NODE
VCPU CONSTANTS</small></b> <br>
Sys::Virt::NODE_CPU_STATS_ALL_CPUS</p>

<p style="margin-left:17%;">Request statistics for all
CPUs</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>NODE
MEMORY CONSTANTS</small></b> <br>
Sys::Virt::NODE_MEMORY_STATS_ALL_CELLS</p>

<p style="margin-left:17%;">Request statistics for all
memory cells</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MEMORY
PARAMETERS</small></b> <br>
The following constants are used to name memory parameters
of the node <br>
Sys::Virt::NODE_MEMORY_SHARED_FULL_SCANS</p>

<p style="margin-left:17%;">How many times all mergeable
areas have been scanned.</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_PAGES_SHARED</p>

<p style="margin-left:17%;">How many the shared memory
pages are being used.</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_PAGES_SHARING</p>

<p style="margin-left:17%;">How many sites are sharing the
pages</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_PAGES_TO_SCAN</p>

<p style="margin-left:17%;">How many present pages to scan
before the shared memory service goes to sleep</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_PAGES_UNSHARED</p>

<p style="margin-left:17%;">How many pages unique but
repeatedly checked for merging.</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_PAGES_VOLATILE</p>

<p style="margin-left:17%;">How many pages changing too
fast to be placed in a tree.</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_SLEEP_MILLISECS</p>

<p style="margin-left:17%;">How many milliseconds the
shared memory service should sleep before next scan.</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_SHARED_MERGE_ACROSS_NODES</p>

<p style="margin-left:17%;">Whether pages can be merged
across <small>NUMA</small> nodes</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CLOSE
REASON CONSTANTS</small></b> <br>
The following constants related to the connection close
callback, describe the reason for the closing of the
connection. <br>
Sys::Virt::CLOSE_REASON_CLIENT</p>

<p style="margin-left:17%;">The client application
requested the connection be closed</p>


<p style="margin-left:11%;">Sys::Virt::CLOSE_REASON_EOF</p>

<p style="margin-left:17%;">End-of-file was encountered
reading data from the connection</p>


<p style="margin-left:11%;">Sys::Virt::CLOSE_REASON_ERROR</p>

<p style="margin-left:17%;">An I/O error was encountered
reading/writing data from/to the connection</p>


<p style="margin-left:11%;">Sys::Virt::CLOSE_REASON_KEEPALIVE</p>

<p style="margin-left:17%;">The connection keepalive timer
triggered due to lack of response from the server</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>CPU
STATS CONSTANTS</small></b> <br>
The following constants provide the names of known
<small>CPU</small> stats fields <br>
Sys::Virt::NODE_CPU_STATS_IDLE</p>

<p style="margin-left:17%;">Time spent idle</p>


<p style="margin-left:11%;">Sys::Virt::NODE_CPU_STATS_IOWAIT</p>

<p style="margin-left:17%;">Time spent waiting for I/O to
complete</p>


<p style="margin-left:11%;">Sys::Virt::NODE_CPU_STATS_KERNEL</p>

<p style="margin-left:17%;">Time spent executing kernel
code</p>


<p style="margin-left:11%;">Sys::Virt::NODE_CPU_STATS_USER</p>

<p style="margin-left:17%;">Time spent executing user
code</p>


<p style="margin-left:11%;">Sys::Virt::NODE_CPU_STATS_INTR</p>

<p style="margin-left:17%;">Time spent processing
interrupts</p>


<p style="margin-left:11%;">Sys::Virt::NODE_CPU_STATS_UTILIZATION</p>

<p style="margin-left:17%;">Percentage utilization of the
<small>CPU.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>MEMORY
STAS CONSTANTS</b></small> <br>
The following constants provide the names of known memory
stats fields <br>
Sys::Virt::NODE_MEMORY_STATS_BUFFERS</p>

<p style="margin-left:17%;">The amount of memory consumed
by I/O buffers</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_STATS_CACHED</p>

<p style="margin-left:17%;">The amount of memory consumed
by disk cache</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_STATS_FREE</p>

<p style="margin-left:17%;">The amount of free memory</p>


<p style="margin-left:11%;">Sys::Virt::NODE_MEMORY_STATS_TOTAL</p>

<p style="margin-left:17%;">The total amount of memory</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>IP</small>
address constants</b> <br>
The following constants are used to interpret
<small>IP</small> address types <br>
Sys::Virt::IP_ADDR_TYPE_IPV4</p>

<p style="margin-left:17%;">An IPv4 address type</p>


<p style="margin-left:11%;">Sys::Virt::IP_ADDR_TYPE_IPV6</p>

<p style="margin-left:17%;">An IPv6 address type</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hopefully none,
but the <small>XS</small> code needs to be audited to ensure
it is not leaking memory.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Daniel P.
Berrange &lt;berrange@redhat.com&gt;</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2006&minus;2009 Red Hat Copyright (C) 2006&minus;2009 Daniel
P. Berrange</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of either the <small>GNU</small> General
Public License as published by the Free Software Foundation
(either version 2 of the License, or at your option any
later version), or, the Artistic License, as specified in
the Perl <small>README</small> file.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Sys::Virt::Domain,
Sys::Virt::Network, Sys::Virt::StoragePool,
Sys::Virt::StorageVol, Sys::Virt::Error,
<tt>&quot;http://libvirt.org&quot;</tt></p>
<hr>
</body>
</html>
