<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:30:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STAPPROBES</title>

</head>
<body>

<h1 align="center">STAPPROBES</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SYNTAX">SYNTAX</a><br>
<a href="#DWARF DEBUGINFO">DWARF DEBUGINFO</a><br>
<a href="#ON-THE-FLY ARMING">ON-THE-FLY ARMING</a><br>
<a href="#PROBE POINT FAMILIES">PROBE POINT FAMILIES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stapprobes
&minus; systemtap probe points</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
sections enumerate the variety of probe points supported by
the systemtap translator, and some of the additional aliases
defined by standard tapset scripts. Many are individually
documented in the <i>3stap</i> manual section, with the
<i>probe::</i> prefix.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<p style="margin-left:22%; margin-top: 1em"><b>probe</b>
PROBEPOINT [<b>,</b> PROBEPOINT] <b>{</b> [STMT ...]
<b>}</b></p>

<p style="margin-left:11%; margin-top: 1em">A probe
declaration may list multiple comma-separated probe points
in order to attach a handler to all of the named events.
Normally, the handler statements are run whenever any of
events occur.</p>

<p style="margin-left:11%; margin-top: 1em">The syntax of a
single probe point is a general dotted-symbol sequence. This
allows a breakdown of the event namespace into parts,
somewhat like the Domain Name System does on the Internet.
Each component identifier may be parametrized by a string or
number literal, with a syntax like a function call. A
component may include a &quot;*&quot; character, to expand
to a set of matching probe points. It may also include
&quot;**&quot; to match multiple sequential components at
once. Probe aliases likewise expand to other probe
points.</p>

<p style="margin-left:11%; margin-top: 1em">Probe aliases
can be given on their own, or with a suffix. The suffix
attaches to the underlying probe point that the alias is
expanded to. For example,</p>


<p style="margin-left:22%; margin-top: 1em">syscall.read.return.maxactive(10)</p>

<p style="margin-left:11%; margin-top: 1em">expands to</p>


<p style="margin-left:22%; margin-top: 1em">kernel.function(&quot;sys_read&quot;).return.maxactive(10)</p>

<p style="margin-left:11%; margin-top: 1em">with the
component <i>maxactive(10)</i> being recognized as a
suffix.</p>

<p style="margin-left:11%; margin-top: 1em">Normally, each
and every probe point resulting from wildcard- and
alias-expansion must be resolved to some low-level system
instrumentation facility (e.g., a kprobe address, marker, or
a timer configuration), otherwise the elaboration phase will
fail.</p>

<p style="margin-left:11%; margin-top: 1em">However, a
probe point may be followed by a &quot;?&quot; character, to
indicate that it is optional, and that no error should
result if it fails to resolve. Optionalness passes down
through all levels of alias/wildcard expansion. Alternately,
a probe point may be followed by a &quot;!&quot; character,
to indicate that it is both optional and sufficient. (Think
vaguely of the Prolog cut operator.) If it does resolve,
then no further probe points in the same comma-separated
list will be resolved. Therefore, the &quot;!&quot;
sufficiency mark only makes sense in a list of probe point
alternatives.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally, a
probe point may be followed by a &quot;if (expr)&quot;
statement, in order to enable/disable the probe point
on-the-fly. With the &quot;if&quot; statement, if the
&quot;expr&quot; is false when the probe point is hit, the
whole probe body including alias&rsquo;s body is skipped.
The condition is stacked up through all levels of
alias/wildcard expansion. So the final condition becomes the
logical-and of conditions of all expanded alias/wildcard.
The expressions are necessarily restricted to global
variables.</p>

<p style="margin-left:11%; margin-top: 1em">These are all
<b>syntactically</b> valid probe points. (They are generally
<b>semantically</b> invalid, depending on the contents of
the tapsets, and the versions of kernel/user software
installed.)</p>


<p style="margin-left:22%; margin-top: 1em">kernel.function(&quot;foo&quot;).return
<br>
process(&quot;/bin/vi&quot;).statement(0x2222) <br>
end <br>
syscall.* <br>
syscall.*.return.maxactive(10) <br>
sys**open <br>
kernel.function(&quot;no_such_function&quot;) ? <br>

module(&quot;awol&quot;).function(&quot;no_such_function&quot;)
! <br>
signal.*? if (switch) <br>
kprobe.function(&quot;foo&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">Probes may be
broadly classified into &quot;synchronous&quot; and
&quot;asynchronous&quot;. A &quot;synchronous&quot; event is
deemed to occur when any processor executes an instruction
matched by the specification. This gives these probes a
reference point (instruction address) from which more
contextual data may be available. Other families of probe
points refer to &quot;asynchronous&quot; events such as
timers/counters rolling over, where there is no fixed
reference point that is related. Each probe point
specification may match multiple locations (for example,
using wildcards or aliases), and all them are then probed. A
probe declaration may also contain several comma-separated
specifications, all of which are probed.</p>

<h2>DWARF DEBUGINFO
<a name="DWARF DEBUGINFO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Resolving some
probe points requires DWARF debuginfo or &quot;debug
symbols&quot; for the specific part being instrumented. For
some others, DWARF is automatically synthesized on the fly
from source code header files. For others, it is not needed
at all. Since a systemtap script may use any mixture of
probe points together, the union of their DWARF requirements
has to be met on the computer where script compilation
occurs. (See the <i>&minus;&minus;use&minus;server</i>
option and the <b>stap-server(8)</b> man page for
information about the remote compilation facility, which
allows these requirements to be met on a different
machine.)</p>

<p style="margin-left:11%; margin-top: 1em">The following
point lists many of the available probe point families, to
classify them with respect to their need for DWARF
debuginfo.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-202401.png" alt="Image grohtml-202401.png"></p>

<h2>ON-THE-FLY ARMING
<a name="ON-THE-FLY ARMING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
types of probe points may be armed/disarmed on-the-fly to
save overheads during uninteresting times. Arming conditions
may also be added to other types of probes, but will be
treated as a wrapping conditional and won&rsquo;t benefit
from overhead savings.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-202402.png" alt="Image grohtml-202402.png"></p>

<h2>PROBE POINT FAMILIES
<a name="PROBE POINT FAMILIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>BEGIN/END/ERROR</b>
<br>
The probe points <i>begin</i> and <i>end</i> are defined by
the translator to refer to the time of session startup and
shutdown. All &quot;begin&quot; probe handlers are run, in
some sequence, during the startup of the session. All global
variables will have been initialized prior to this point.
All &quot;end&quot; probes are run, in some sequence, during
the <i>normal</i> shutdown of a session, such as in the
aftermath of an <i>exit ()</i> function call, or an
interruption from the user. In the case of an
error-triggered shutdown, &quot;end&quot; probes are not
run. There are no target variables available in either
context.</p>

<p style="margin-left:11%; margin-top: 1em">If the order of
execution among &quot;begin&quot; or &quot;end&quot; probes
is significant, then an optional sequence number may be
provided:</p>

<p style="margin-left:22%; margin-top: 1em">begin(N) <br>
end(N)</p>

<p style="margin-left:11%; margin-top: 1em">The number N
may be positive or negative. The probe handlers are run in
increasing order, and the order between handlers with the
same sequence number is unspecified. When &quot;begin&quot;
or &quot;end&quot; are given without a sequence, they are
effectively sequence zero.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>error</i> probe point is similar to the <i>end</i> probe,
except that each such probe handler run when the session
ends after errors have occurred. In such cases,
&quot;end&quot; probes are skipped, but each
&quot;error&quot; probe is still attempted. This kind of
probe can be used to clean up or emit a &quot;final
gasp&quot;. It may also be numerically parametrized to set a
sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NEVER</b>
<br>
The probe point <i>never</i> is specially defined by the
translator to mean &quot;never&quot;. Its probe handler is
never run, though its statements are analyzed for symbol /
type correctness as usual. This probe point may be useful in
conjunction with optional probes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SYSCALL and
ND_SYSCALL</b> <br>
The <i>syscall.*</i> and <i>nd_syscall.*</i> aliases define
several hundred probes, too many to detail here. They are of
the general form:</p>

<p style="margin-left:22%; margin-top: 1em">syscall.NAME
<br>
nd_syscall.NAME <br>
syscall.NAME.return <br>
nd_syscall.NAME.return</p>

<p style="margin-left:11%; margin-top: 1em">Generally, a
pair of probes are defined for each normal system call as
listed in the <i>syscalls(2)</i> manual page, one for entry
and one for return. Those system calls that never return do
not have a corresponding <i>.return</i> probe. The nd_*
family of probes are about the same, except it uses
<b>non-DWARF</b> based searching mechanisms, which may
result in a lower quality of symbolic context data
(parameters), and may miss some system calls. You may want
to try them first, in case kernel debugging information is
not immediately available.</p>

<p style="margin-left:11%; margin-top: 1em">Each probe
alias provides a variety of variables. Looking at the tapset
source code is the most reliable way. Generally, each
variable listed in the standard manual page is made
available as a script-level variable, so <i>syscall.open</i>
exposes <i>filename</i>, <i>flags</i>, and <i>mode</i>. In
addition, a standard suite of variables is available at most
aliases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>argstr</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>A pretty-printed form of the entire argument list,
without parentheses.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>name</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>The name of the system call.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>retstr</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>For return probes, a pretty-printed form of the
system-call result.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As usual for
probe aliases, these variables are all simply initialized
once from the underlying $context variables, so that later
changes to $context variables are not automatically
reflected. Not all probe aliases obey all of these general
guidelines. Please report any bothersome ones you encounter
as a bug.</p>

<p style="margin-left:11%; margin-top: 1em">If debuginfo
availability is a problem, you may try using the non-DWARF
syscall probe aliases instead. Use the <i>nd_syscall.</i>
prefix instead of <i>syscall.</i> The same context variables
are available, as far as possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TIMERS</b>
<br>
Intervals defined by the standard kernel &quot;jiffies&quot;
timer may be used to trigger probe handlers asynchronously.
Two probe point variants are supported by the
translator:</p>


<p style="margin-left:22%; margin-top: 1em">timer.jiffies(N)
<br>
timer.jiffies(N).randomize(M)</p>

<p style="margin-left:11%; margin-top: 1em">The probe
handler is run every N jiffies (a kernel-defined unit of
time, typically between 1 and 60 ms). If the
&quot;randomize&quot; component is given, a linearly
distributed random value in the range [&minus;M..+M] is
added to N every time the handler is run. N is restricted to
a reasonable range (1 to around a million), and M is
restricted to be smaller than N. There are no target
variables provided in either context. It is possible for
such probes to be run concurrently on a multi-processor
computer.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
intervals may be specified in units of time. There are two
probe point variants similar to the jiffies timer:</p>

<p style="margin-left:22%; margin-top: 1em">timer.ms(N)
<br>
timer.ms(N).randomize(M)</p>

<p style="margin-left:11%; margin-top: 1em">Here, N and M
are specified in milliseconds, but the full options for
units are seconds (s/sec), milliseconds (ms/msec),
microseconds (us/usec), nanoseconds (ns/nsec), and hertz
(hz). Randomization is not supported for hertz timers.</p>

<p style="margin-left:11%; margin-top: 1em">The actual
resolution of the timers depends on the target kernel. For
kernels prior to 2.6.17, timers are limited to jiffies
resolution, so intervals are rounded up to the nearest
jiffies interval. After 2.6.17, the implementation uses
hrtimers for tighter precision, though the actual resolution
will be arch-dependent. In either case, if the
&quot;randomize&quot; component is given, then the random
value will be added to the interval before any rounding
occurs.</p>

<p style="margin-left:11%; margin-top: 1em">Profiling
timers are also available to provide probes that execute on
all CPUs at the rate of the system tick (CONFIG_HZ). This
probe takes no parameters. On some kernels, this is a
one-concurrent-user-only or disabled facility, resulting in
error &minus;16 (EBUSY) during probe registration.</p>


<p style="margin-left:22%; margin-top: 1em">timer.profile.tick</p>

<p style="margin-left:11%; margin-top: 1em">Full context
information of the interrupted process is available, making
this probe suitable for a time-based sampling profiler.</p>

<p style="margin-left:11%; margin-top: 1em">It is
recommended to use the tapset probe <i>timer.profile</i>
rather than timer.profile.tick. This probe point behaves
identically to timer.profile.tick when the underlying
functionality is available, and falls back to using
perf.sw.cpu_clock on some recent kernels which lack the
corresponding profile timer facility.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DWARF</b>
<br>
This family of probe points uses symbolic debugging
information for the target kernel/module/program, as may be
found in unstripped executables, or the separate
<i>debuginfo</i> packages. They allow placement of probes
logically into the execution path of the target program, by
specifying a set of points in the source or object code.
When a matching statement executes on any processor, the
probe handler is run in that context.</p>

<p style="margin-left:11%; margin-top: 1em">Probe points in
the DWARF family can be identified by the target kernel
module (or user process), source file, line number, function
name, or some combination of these.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of DWARF probe points currently supported:</p>


<p style="margin-left:22%; margin-top: 1em">kernel.function(PATTERN)
<br>
kernel.function(PATTERN).call <br>
kernel.function(PATTERN).callee(PATTERN) <br>
kernel.function(PATTERN).callees(DEPTH) <br>
kernel.function(PATTERN).return <br>
kernel.function(PATTERN).inline <br>
kernel.function(PATTERN).label(LPATTERN) <br>
module(MPATTERN).function(PATTERN) <br>
module(MPATTERN).function(PATTERN).call <br>
module(MPATTERN).function(PATTERN).callee(PATTERN) <br>
module(MPATTERN).function(PATTERN).callees(DEPTH) <br>
module(MPATTERN).function(PATTERN).return <br>
module(MPATTERN).function(PATTERN).inline <br>
module(MPATTERN).function(PATTERN).label(LPATTERN) <br>
kernel.statement(PATTERN) <br>
kernel.statement(PATTERN).nearest <br>
kernel.statement(ADDRESS).absolute <br>
module(MPATTERN).statement(PATTERN) <br>
process(&quot;PATH&quot;).function(&quot;NAME&quot;) <br>

process(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
<br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).function(&quot;NAME&quot;)
<br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
<br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;).nearest
<br>
process(&quot;PATH&quot;).function(&quot;*&quot;).return
<br>

process(&quot;PATH&quot;).function(&quot;myfun&quot;).label(&quot;foo&quot;)
<br>

process(&quot;PATH&quot;).function(&quot;foo&quot;).callee(&quot;bar&quot;)
<br>

process(&quot;PATH&quot;).function(&quot;foo&quot;).callees(DEPTH)
<br>
process(PID).function(&quot;NAME&quot;) <br>

process(PID).function(&quot;myfun&quot;).label(&quot;foo&quot;)
<br>
process(PID).plt(&quot;NAME&quot;) <br>
process(PID).plt(&quot;NAME&quot;).return <br>
process(PID).statement(&quot;*@FILE.c:123&quot;) <br>
process(PID).statement(&quot;*@FILE.c:123&quot;).nearest
<br>
process(PID).statement(ADDRESS).absolute</p>

<p style="margin-left:11%; margin-top: 1em">(See the
USER-SPACE section below for more information on the process
probes.)</p>

<p style="margin-left:11%; margin-top: 1em">The list above
includes multiple variants and modifiers which provide
additional functionality or filters. They are:</p>

<p style="margin-left:22%;"><b>.function</b></p>

<p style="margin-left:32%;">Places a probe near the
beginning of the named function, so that parameters are
available as context variables.</p>

<p style="margin-left:22%;"><b>.return</b></p>

<p style="margin-left:32%;">Places a probe at the moment
<b>after</b> the return from the named function, so the
return value is available as the &quot;$return&quot; context
variable.</p>

<p style="margin-left:22%;"><b>.inline</b></p>

<p style="margin-left:32%;">Filters the results to include
only instances of inlined functions. Note that inlined
functions do not have an identifiable return point, so
<b>.return</b> is not supported on <b>.inline</b>
probes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>.call</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Filters the results to include only non-inlined
functions (the opposite set of <b>.inline</b>)</p></td></tr>
</table>

<p style="margin-left:22%;"><b>.exported</b></p>

<p style="margin-left:32%;">Filters the results to include
only exported functions.</p>

<p style="margin-left:22%;"><b>.statement</b></p>

<p style="margin-left:32%;">Places a probe at the exact
spot, exposing those local variables that are visible
there.</p>

<p style="margin-left:22%;"><b>.statement.nearest</b></p>

<p style="margin-left:32%;">Places a probe at the nearest
available spot to the given statement.</p>

<p style="margin-left:22%;"><b>.callee</b></p>

<p style="margin-left:32%;">Places a probe on the callee
function given in the <b>.callee</b> modifier, where the
callee must be a function called by the target function
given in <b>.function</b>. The advantage of doing this over
directly probing the callee function is that this probe
point is run only when the callee is called from the target
function (add the -DSTAP_CALLEE_MATCHALL directive to
override this when calling <b>stap</b>(1)).</p>

<p style="margin-left:32%; margin-top: 1em">Note that only
callees that can be statically determined are available. For
example, calls through function pointers are not available.
Additionally, calls to functions located in other objects
(e.g. libraries) are not available (instead use another
probe point). This feature will only work for code compiled
with GCC 4.7+.</p>

<p style="margin-left:22%;"><b>.callees</b></p>

<p style="margin-left:32%;">Shortcut for
<b>.callee(&quot;*&quot;)</b>, which places a probe on all
callees of the function.</p>

<p style="margin-left:22%;"><b>.callees</b>(DEPTH)</p>

<p style="margin-left:32%;">Recursively places probes on
callees. For example, <b>.callees(2)</b> will probe both
callees of the target function, as well as callees of those
callees. And <b>.callees(3)</b> goes one level deeper,
etc... A callee probe at depth N is only triggered when the
N callers in the callstack match those that were statically
determined during analysis (this also may be overriden using
-DSTAP_CALLEE_MATCHALL).</p>

<p style="margin-left:11%; margin-top: 1em">In the above
list of probe points, MPATTERN stands for a string literal
that aims to identify the loaded kernel module of interest.
For in-tree kernel modules, the name suffices (e.g.
&quot;btrfs&quot;). The name may also include the
&quot;*&quot;, &quot;[]&quot;, and &quot;?&quot; wildcards
to match multiple in-tree modules. Out-of-tree modules are
also supported by specifying the full path to the ko file.
Wildcards are not supported. The file must follow the
convention of being named &lt;module_name&gt;.ko (characters
&rsquo;,&rsquo; and &rsquo;-&rsquo; are replaced by
&rsquo;_&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">LPATTERN stands
for a source program label. It may also contain
&quot;*&quot;, &quot;[]&quot;, and &quot;?&quot; wildcards.
PATTERN stands for a string literal that aims to identify a
point in the program. It is made up of three parts:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The first part is the name of a function, as would
appear in the <i>nm</i> program&rsquo;s output. This part
may use the &quot;*&quot; and &quot;?&quot; wildcarding
operators to match multiple names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The second part is optional and begins with the
&quot;@&quot; character. It is followed by the path to the
source file containing the function, which may include a
wildcard pattern, such as mm/slab*. If it does not match as
is, an implicit &quot;*/&quot; is optionally added
<i>before</i> the pattern, so that a script need only name
the last few components of a possibly long source directory
path.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Finally, the third part is optional if the file name
part was given, and identifies the line number in the source
file preceded by a &quot;:&quot; or a &quot;+&quot;. The
line number is assumed to be an absolute line number if
preceded by a &quot;:&quot;, or relative to the declaration
line of the function if preceded by a &quot;+&quot;. All the
lines in the function can be matched with &quot;:*&quot;. A
range of lines x through y can be matched with
&quot;:x&minus;y&quot;. Ranges and specific lines can be
mixed using commas, e.g. &quot;:x,y&minus;z&quot;.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, PATTERN may be a numeric constant, indicating
an address. Such an address may be found from symbol tables
of the appropriate kernel / module object file. It is
verified against known statement code boundaries, and will
be relocated for use at run time.</p>

<p style="margin-left:11%; margin-top: 1em">In guru mode
only, absolute kernel-space addresses may be specified with
the &quot;.absolute&quot; suffix. Such an address is
considered already relocated, as if it came from
<b>/proc/kallsyms</b>, so it cannot be checked against
statement/instruction boundaries.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CONTEXT
VARIABLES</b> <br>
Many of the source-level context variables, such as function
parameters, locals, globals visible in the compilation unit,
may be visible to probe handlers. They may refer to these
variables by prefixing their name with &quot;$&quot; within
the scripts. In addition, a special syntax allows limited
traversal of structures, pointers, and arrays. More syntax
allows pretty-printing of individual variables or their
groups. See also <b>@cast</b>. Note that variables may be
inaccessible due to them being paged out, or for a few other
reasons. See also man <i>error::fault</i>(7stap).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em">$var</p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">refers to an in-scope variable
&quot;var&quot;. If it&rsquo;s an integer-like type, it will
be cast to a 64-bit int for systemtap script use.
String-like pointers (char *) may be copied to systemtap
string values using the <i>kernel_string</i> or
<i>user_string</i> functions.</p></td></tr>
</table>

<p style="margin-left:11%;">@var(&quot;varname&quot;)</p>

<p style="margin-left:22%;">an alternative syntax for
<i>$varname</i></p>


<p style="margin-left:11%;">@var(&quot;varname@src/file.c&quot;)</p>

<p style="margin-left:22%;">refers to the global (either
file local or external) variable <i>varname</i> defined when
the file <i>src/file.c</i> was compiled. The CU in which the
variable is resolved is the first CU in the module of the
probe point which matches the given file name at the end and
has the shortest file name path (e.g. given
<i>@var(&quot;foo@bar/baz.c&quot;)</i> and CUs with file
name paths <i>src/sub/module/bar/baz.c</i> and
<i>src/bar/baz.c</i> the second CU will be chosen to resolve
the (file) global variable <i>foo</i></p>

<p style="margin-left:11%;">$var&minus;&gt;field traversal
via a structure&rsquo;s or a pointer&rsquo;s field. This</p>

<p style="margin-left:22%;">generalized indirection
operator may be repeated to follow more levels. Note that
the <i>.</i> operator is not used for plain structure
members, only <i>&minus;&gt;</i> for both purposes. (This is
because &quot;.&quot; is reserved for string
concatenation.)</p>

<p style="margin-left:11%;">$return</p>

<p style="margin-left:22%;">is available in return probes
only for functions that are declared with a return value,
which can be determined using @defined($return).</p>

<p style="margin-left:11%;">$var[N]</p>

<p style="margin-left:22%;">indexes into an array. The
index given with a literal number or even an arbitrary
numeric expression.</p>

<p style="margin-left:11%; margin-top: 1em">A number of
operators exist for such basic context variable
expressions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>$$vars</p></td>
<td width="2%"></td>
<td width="78%">


<p>expands to a character string that is equivalent to</p></td></tr>
</table>


<p style="margin-left:22%; margin-top: 1em">sprintf(&quot;parm1=%x
... parmN=%x var1=%x ... varN=%x&quot;, <br>
parm1, ..., parmN, var1, ..., varN)</p>

<p style="margin-left:22%; margin-top: 1em">for each
variable in scope at the probe point. Some values may be
printed as <i>=?</i> if their run-time location cannot be
found.</p>

<p style="margin-left:11%;">$$locals</p>

<p style="margin-left:22%;">expands to a subset of $$vars
for only local variables.</p>

<p style="margin-left:11%;">$$parms</p>

<p style="margin-left:22%;">expands to a subset of $$vars
for only function parameters.</p>

<p style="margin-left:11%;">$$return</p>

<p style="margin-left:22%;">is available in return probes
only. It expands to a string that is equivalent to
sprintf(&quot;return=%x&quot;, $return) if the probed
function has a return value, or else an empty string.</p>

<p style="margin-left:11%;">&amp; $EXPR</p>

<p style="margin-left:22%;">expands to the address of the
given context variable expression, if it is addressable.</p>

<p style="margin-left:11%;">@defined($EXPR)</p>

<p style="margin-left:22%;">expands to 1 or 0 iff the given
context variable expression is resolvable, for use in
conditionals such as</p>


<p style="margin-left:22%; margin-top: 1em">@defined($foo&minus;&gt;bar)
? $foo&minus;&gt;bar : 0</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>$EXPR$</p></td>
<td width="2%"></td>
<td width="78%">


<p>expands to a string with all of $EXPR&rsquo;s members,
equivalent to</p></td></tr>
</table>


<p style="margin-left:22%; margin-top: 1em">sprintf(&quot;{.a=%i,
.b=%u, .c={...}, .d=[...]}&quot;, <br>
$EXPR&minus;&gt;a, $EXPR&minus;&gt;b)</p>

<p style="margin-left:11%;">$EXPR$$</p>

<p style="margin-left:22%;">expands to a string with all of
$var&rsquo;s members and submembers, equivalent to</p>


<p style="margin-left:22%; margin-top: 1em">sprintf(&quot;{.a=%i,
.b=%u, .c={.x=%p, .y=%c}, .d=[%i, ...]}&quot;, <br>
$EXPR&minus;&gt;a, $EXPR&minus;&gt;b,
$EXPR&minus;&gt;c&minus;&gt;x,
$EXPR&minus;&gt;c&minus;&gt;y, $EXPR&minus;&gt;d[0])</p>

<p style="margin-left:11%; margin-top: 1em"><b>MORE ON
RETURN PROBES</b> <br>
For the kernel &quot;.return&quot; probes, only a certain
fixed number of returns may be outstanding. The default is a
relatively small number, on the order of a few times the
number of physical CPUs. If many different threads
concurrently call the same blocking function, such as
futex(2) or read(2), this limit could be exceeded, and
skipped &quot;kretprobes&quot; would be reported by
&quot;stap &minus;t&quot;. To work around this, specify
a</p>

<p style="margin-left:22%; margin-top: 1em">probe
FOO.return.maxactive(NNN)</p>

<p style="margin-left:11%; margin-top: 1em">suffix, with a
large enough NNN to cover all expected concurrently blocked
threads. Alternately, use the</p>

<p style="margin-left:22%; margin-top: 1em">stap
&minus;DKRETACTIVE=NNNN</p>

<p style="margin-left:11%; margin-top: 1em">stap command
line macro setting to override the default for all
&quot;.return&quot; probes.</p>

<p style="margin-left:11%; margin-top: 1em">For
&quot;.return&quot; probes, context variables other than the
&quot;$return&quot; may be accessible, as a convenience for
a script programmer wishing to access function parameters.
These values are <b>snapshots</b> taken at the time of
function entry. Local variables within the function are
<b>not</b> generally accessible, since those variables did
not exist in allocated/initialized form at the snapshot
moment.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
arbitrary entry-time expressions can also be saved for
&quot;.return&quot; probes using the <i>@entry(expr)</i>
operator. For example, one can compute the elapsed time of a
function:</p>

<p style="margin-left:22%; margin-top: 1em">probe
kernel.function(&quot;do_filp_open&quot;).return { <br>
println( get_timeofday_us() &minus;
@entry(get_timeofday_us()) ) <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The following
table summarizes how values related to a function parameter
context variable, a pointer named <b>addr</b>, may be
accessed from a <i>.return</i> probe.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-202403.png" alt="Image grohtml-202403.png"></p>


<p style="margin-left:11%; margin-top: 1em"><b>DWARFLESS</b>
<br>
In absence of debugging information, entry &amp; exit points
of kernel &amp; module functions can be probed using the
&quot;kprobe&quot; family of probes. However, these do not
permit looking up the arguments / local variables of the
function. Following constructs are supported :</p>


<p style="margin-left:22%; margin-top: 1em">kprobe.function(FUNCTION)
<br>
kprobe.function(FUNCTION).call <br>
kprobe.function(FUNCTION).return <br>
kprobe.module(NAME).function(FUNCTION) <br>
kprobe.module(NAME).function(FUNCTION).call <br>
kprobe.module(NAME).function(FUNCTION).return <br>
kprobe.statement.(ADDRESS).absolute</p>

<p style="margin-left:11%; margin-top: 1em">Probes of type
<b>function</b> are recommended for kernel functions,
whereas probes of type <b>module</b> are recommended for
probing functions of the specified module. In case the
absolute address of a kernel or module function is known,
<b>statement</b> probes can be utilized.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<i>FUNCTION</i> and <i>MODULE</i> names <b>must not</b>
contain wildcards, or the probe will not be registered.
Also, statement probes must be run under guru-mode only.</p>


<p style="margin-left:11%; margin-top: 1em"><b>USER-SPACE</b>
<br>
Support for user-space probing is available for kernels that
are configured with the utrace extensions, or have the
uprobes facility in linux 3.5. (Various kernel build
configuration options need to be enabled; systemtap will
advise if these are missing.)</p>

<p style="margin-left:11%; margin-top: 1em">There are
several forms. First, a non-symbolic probe point:</p>


<p style="margin-left:22%; margin-top: 1em">process(PID).statement(ADDRESS).absolute</p>

<p style="margin-left:11%; margin-top: 1em">is analogous to
kernel.statement(ADDRESS).absolute in that both use raw
(unverified) virtual addresses and provide no $variables.
The target PID parameter must identify a running process,
and ADDRESS should identify a valid instruction address. All
threads of that process will be probed.</p>

<p style="margin-left:11%; margin-top: 1em">Second,
non-symbolic user-kernel interface events handled by utrace
may be probed:</p>


<p style="margin-left:22%; margin-top: 1em">process(PID).begin
<br>
process(&quot;FULLPATH&quot;).begin <br>
process.begin <br>
process(PID).thread.begin <br>
process(&quot;FULLPATH&quot;).thread.begin <br>
process.thread.begin <br>
process(PID).end <br>
process(&quot;FULLPATH&quot;).end <br>
process.end <br>
process(PID).thread.end <br>
process(&quot;FULLPATH&quot;).thread.end <br>
process.thread.end <br>
process(PID).syscall <br>
process(&quot;FULLPATH&quot;).syscall <br>
process.syscall <br>
process(PID).syscall.return <br>
process(&quot;FULLPATH&quot;).syscall.return <br>
process.syscall.return <br>
process(PID).insn <br>
process(&quot;FULLPATH&quot;).insn <br>
process(PID).insn.block <br>
process(&quot;FULLPATH&quot;).insn.block</p>

<p style="margin-left:11%; margin-top: 1em">A <b>.begin</b>
probe gets called when new process described by PID or
FULLPATH gets created. A <b>.thread.begin</b> probe gets
called when a new thread described by PID or FULLPATH gets
created. A <b>.end</b> probe gets called when process
described by PID or FULLPATH dies. A <b>.thread.end</b>
probe gets called when a thread described by PID or FULLPATH
dies. A <b>.syscall</b> probe gets called when a thread
described by PID or FULLPATH makes a system call. The system
call number is available in the <b>$syscall</b> context
variable, and the first 6 arguments of the system call are
available in the <b>$argN</b> (ex. $arg1, $arg2, ...)
context variable. A <b>.syscall.return</b> probe gets called
when a thread described by PID or FULLPATH returns from a
system call. The system call number is available in the
<b>$syscall</b> context variable, and the return value of
the system call is available in the <b>$return</b> context
variable. A <b>.insn</b> probe gets called for every
single-stepped instruction of the process described by PID
or FULLPATH. A <b>.insn.block</b> probe gets called for
every block-stepped instruction of the process described by
PID or FULLPATH.</p>

<p style="margin-left:11%; margin-top: 1em">If a process
probe is specified without a PID or FULLPATH, all user
threads will be probed. However, if systemtap was invoked
with the <i>&minus;c</i> or <i>&minus;x</i> options, then
process probes are restricted to the process hierarchy
associated with the target process. If a process probe is
unspecified (i.e. without a PID or FULLPATH), but with the
<i>&minus;c</i> option, the PATH of the <i>&minus;c</i> cmd
will be heuristically filled into the process PATH. In that
case, only command parameters are allowed in the <i>-c</i>
command (i.e. no command substitution allowed and no
occurrences of any of these characters:
&rsquo;|&amp;;&lt;&gt;(){}&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">Third, symbolic
static instrumentation compiled into programs and shared
libraries may be probed:</p>


<p style="margin-left:22%; margin-top: 1em">process(&quot;PATH&quot;).mark(&quot;LABEL&quot;)
<br>

process(&quot;PATH&quot;).provider(&quot;PROVIDER&quot;).mark(&quot;LABEL&quot;)
<br>
process(PID).mark(&quot;LABEL&quot;) <br>

process(PID).provider(&quot;PROVIDER&quot;).mark(&quot;LABEL&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">A <b>.mark</b>
probe gets called via a static probe which is defined in the
application by STAP_PROBE1(PROVIDER,LABEL,arg1), which are
macros defined in <b>sys/sdt.h</b>. The PROVIDER is an
arbitrary application identifier, LABEL is the marker site
identifier, and arg1 is the integer-typed argument.
STAP_PROBE1 is used for probes with 1 argument, STAP_PROBE2
is used for probes with 2 arguments, and so on. The
arguments of the probe are available in the context
variables $arg1, $arg2, ... An alternative to using the
STAP_PROBE macros is to use the dtrace script to create
custom macros. Additionally, the variables $$name and
$$provider are available as parts of the probe point name.
The <b>sys/sdt.h</b> macro names DTRACE_PROBE* are available
as aliases for STAP_PROBE*.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, full
symbolic source-level probes in user-space programs and
shared libraries are supported. These are exactly analogous
to the symbolic DWARF-based kernel/module probes described
above. They expose the same sorts of context $variables for
function parameters, local variables, and so on.</p>


<p style="margin-left:22%; margin-top: 1em">process(&quot;PATH&quot;).function(&quot;NAME&quot;)
<br>

process(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
<br>
process(&quot;PATH&quot;).plt(&quot;NAME&quot;) <br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).plt(&quot;NAME&quot;)
<br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).function(&quot;NAME&quot;)
<br>

process(&quot;PATH&quot;).library(&quot;PATH&quot;).statement(&quot;*@FILE.c:123&quot;)
<br>
process(&quot;PATH&quot;).function(&quot;*&quot;).return
<br>

process(&quot;PATH&quot;).function(&quot;myfun&quot;).label(&quot;foo&quot;)
<br>

process(&quot;PATH&quot;).function(&quot;foo&quot;).callee(&quot;bar&quot;)
<br>
process(&quot;PATH&quot;).plt(&quot;NAME&quot;).return <br>
process(PID).function(&quot;NAME&quot;) <br>
process(PID).statement(&quot;*@FILE.c:123&quot;) <br>
process(PID).plt(&quot;NAME&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">Note that for
all process probes, <i>PATH</i> names refer to executables
that are searched the same way shells do: relative to the
working directory if they contain a &quot;/&quot; character,
otherwise in <b>$PATH</b>. If PATH names refer to scripts,
the actual interpreters (specified in the script in the
first line after the #! characters) are probed.</p>

<p style="margin-left:11%; margin-top: 1em">If PATH is a
process component parameter referring to shared libraries
then all processes that map it at runtime would be selected
for probing. If PATH is a library component parameter
referring to shared libraries then the process specified by
the process component would be selected. Note that the PATH
pattern in a library component will always apply to
libraries statically determined to be in use by the process.
However, you may also specify the full path to any library
file even if not statically needed by the process.</p>

<p style="margin-left:11%; margin-top: 1em">A .plt probe
will probe functions in the program linkage table
corresponding to the rest of the probe point. .plt can be
specified as a shorthand for .plt(&quot;*&quot;). The symbol
name is available as a $$name context variable; function
arguments are not available, since PLTs are processed
without debuginfo. A .plt.return probe places a probe at the
moment <b>after</b> the return from the named function.</p>

<p style="margin-left:11%; margin-top: 1em">If the PATH
string contains wildcards as in the MPATTERN case, then
standard globbing is performed to find all matching paths.
In this case, the <b>$PATH</b> environment variable is not
used.</p>

<p style="margin-left:11%; margin-top: 1em">If systemtap
was invoked with the <i>&minus;c</i> or <i>&minus;x</i>
options, then process probes are restricted to the process
hierarchy associated with the target process.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JAVA</b>
<br>
Support for probing Java methods is available using Byteman
as a backend. Byteman is an instrumentation tool from the
JBoss project which systemtap can use to monitor invocations
for a specific method or line in a Java program.</p>

<p style="margin-left:11%; margin-top: 1em">Systemtap does
so by generating a Byteman script listing the probes to
instrument and then invoking the Byteman <i>bminstall</i>
utility.</p>

<p style="margin-left:11%; margin-top: 1em">This Java
instrumentation support is currently a prototype feature
with major limitations. Moreover, Java probing currently
does not work across users; the stap script must run (with
appropriate permissions) under the same user that the Java
process being probed. (Thus a stap script under root
currently cannot probe Java methods in a non-root-user Java
process.)</p>

<p style="margin-left:11%; margin-top: 1em">The first probe
type refers to Java processes by the name of the Java
process:</p>


<p style="margin-left:22%; margin-top: 1em">java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
<br>

java(&quot;PNAME&quot;).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return</p>

<p style="margin-left:11%; margin-top: 1em">The PNAME
argument must be a pre-existing jvm pid, and be identifiable
via a jps listing.</p>

<p style="margin-left:11%; margin-top: 1em">The PATTERN
parameter specifies the signature of the Java method to
probe. The signature must consist of the exact name of the
method, followed by a bracketed list of the types of the
arguments, for instance
&quot;myMethod(int,double,Foo)&quot;. Wildcards are not
supported.</p>

<p style="margin-left:11%; margin-top: 1em">The probe can
be set to trigger at a specific line within the method by
appending a line number with colon, just as in other types
of probes: &quot;myMethod(int,double,Foo):245&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The CLASSNAME
parameter identifies the Java class the method belongs to,
either with or without the package qualification. By
default, the probe only triggers on descendants of the class
that do not override the method definition of the original
class. However, CLASSNAME can take an optional caret prefix,
as in <i>^org.my.MyClass,</i> which specifies that the probe
should also trigger on all descendants of MyClass that
override the original method. For instance, every method
with signature foo(int) in program org.my.MyApp can be
probed at once using</p>


<p style="margin-left:22%; margin-top: 1em">java(&quot;org.my.MyApp&quot;).class(&quot;^java.lang.Object&quot;).method(&quot;foo(int)&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">The second
probe type works analogously, but refers to Java processes
by PID:</p>


<p style="margin-left:22%; margin-top: 1em">java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;)
<br>

java(PID).class(&quot;CLASSNAME&quot;).method(&quot;PATTERN&quot;).return</p>

<p style="margin-left:11%; margin-top: 1em">(PIDs for an
already running process can be obtained using the
<i>jps</i>(1) utility.)</p>

<p style="margin-left:11%; margin-top: 1em">Context
variables defined within java probes include <i>$arg1</i>
through <i>$arg10</i> (for up to the first 10 arguments of a
method), represented as integers or strings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PROCFS</b>
<br>
These probe points allow procfs &quot;files&quot; in
/proc/systemtap/MODNAME to be created, read and written
using a permission that may be modified using the proper
umask value. Default permissions are 0400 for read probes,
and 0200 for write probes. If both a read and write probe
are being used on the same file, a default permission of
0600 will be used. Using procfs.umask(0040).read would
result in a 0404 permission set for the file.
(<i>MODNAME</i> is the name of the systemtap module). The
<i>proc</i> filesystem is a pseudo-filesystem which is used
as an interface to kernel data structures. There are several
probe point variants supported by the translator:</p>


<p style="margin-left:22%; margin-top: 1em">procfs(&quot;PATH&quot;).read
<br>
procfs(&quot;PATH&quot;).umask(UMASK).read <br>
procfs(&quot;PATH&quot;).read.maxsize(MAXSIZE) <br>
procfs(&quot;PATH&quot;).umask(UMASK).maxsize(MAXSIZE) <br>
procfs(&quot;PATH&quot;).write <br>
procfs(&quot;PATH&quot;).umask(UMASK).write <br>
procfs.read <br>
procfs.umask(UMASK).read <br>
procfs.read.maxsize(MAXSIZE) <br>
procfs.umask(UMASK).read.maxsize(MAXSIZE) <br>
procfs.write <br>
procfs.umask(UMASK).write</p>

<p style="margin-left:11%; margin-top: 1em"><i>PATH</i> is
the file name (relative to /proc/systemtap/MODNAME) to be
created. If no <i>PATH</i> is specified (as in the last two
variants above), <i>PATH</i> defaults to
&quot;command&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">When a user
reads /proc/systemtap/MODNAME/PATH, the corresponding procfs
<i>read</i> probe is triggered. The string data to be read
should be assigned to a variable named <i>$value</i>, like
this:</p>


<p style="margin-left:22%; margin-top: 1em">procfs(&quot;PATH&quot;).read
{ $value = &quot;100\n&quot; }</p>

<p style="margin-left:11%; margin-top: 1em">When a user
writes into /proc/systemtap/MODNAME/PATH, the corresponding
procfs <i>write</i> probe is triggered. The data the user
wrote is available in the string variable named
<i>$value</i>, like this:</p>


<p style="margin-left:22%; margin-top: 1em">procfs(&quot;PATH&quot;).write
{ printf(&quot;user wrote: %s&quot;, $value) }</p>

<p style="margin-left:11%; margin-top: 1em"><i>MAXSIZE</i>
is the size of the procfs read buffer. Specifying
<i>MAXSIZE</i> allows larger procfs output. If no
<i>MAXSIZE</i> is specified, the procfs read buffer defaults
to <i>STP_PROCFS_BUFSIZE</i> (which defaults to
<i>MAXSTRINGLEN</i>, the maximum length of a string). If
setting the procfs read buffers for more than one file is
needed, it may be easiest to override the
<i>STP_PROCFS_BUFSIZE</i> definition. Here&rsquo;s an
example of using <i>MAXSIZE</i>:</p>


<p style="margin-left:22%; margin-top: 1em">procfs.read.maxsize(1024)
{ <br>
$value = &quot;long string...&quot; <br>
$value .= &quot;another long string...&quot; <br>
$value .= &quot;another long string...&quot; <br>
$value .= &quot;another long string...&quot; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>NETFILTER
HOOKS</b> <br>
These probe points allow observation of network packets
using the netfilter mechanism. A netfilter probe in
systemtap corresponds to a netfilter hook function in the
original netfilter probes API. It is probably more
convenient to use <i>tapset::netfilter</i>(3stap), which
wraps the primitive netfilter hooks and does the work of
extracting useful information from the context
variables.</p>

<p style="margin-left:11%; margin-top: 1em">There are
several probe point variants supported by the
translator:</p>


<p style="margin-left:22%; margin-top: 1em">netfilter.hook(&quot;HOOKNAME&quot;).pf(&quot;PROTOCOL_F&quot;)
<br>

netfilter.pf(&quot;PROTOCOL_F&quot;).hook(&quot;HOOKNAME&quot;)
<br>

netfilter.hook(&quot;HOOKNAME&quot;).pf(&quot;PROTOCOL_F&quot;).priority(&quot;PRIORITY&quot;)
<br>

netfilter.pf(&quot;PROTOCOL_F&quot;).hook(&quot;HOOKNAME&quot;).priority(&quot;PRIORITY&quot;)</p>


<p style="margin-left:11%; margin-top: 1em"><i>PROTOCOL_F</i>
is the protocol family to listen for, currently one of
<i>NFPROTO_IPV4, NFPROTO_IPV6, NFPROTO_ARP,</i> or
<i>NFPROTO_BRIDGE.</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>HOOKNAME</i>
is the point, or &rsquo;hook&rsquo;, in the protocol stack
at which to intercept the packet. The available hook names
for each protocol family are taken from the kernel header
files &lt;linux/netfilter_ipv4.h&gt;,
&lt;linux/netfilter_ipv6.h&gt;,
&lt;linux/netfilter_arp.h&gt; and
&lt;linux/netfilter_bridge.h&gt;. For instance, allowable
hook names for <i>NFPROTO_IPV4</i> are
<i>NF_INET_PRE_ROUTING, NF_INET_LOCAL_IN, NF_INET_FORWARD,
NF_INET_LOCAL_OUT,</i> and <i>NF_INET_POST_ROUTING.</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>PRIORITY</i>
is an integer priority giving the order in which the probe
point should be triggered relative to any other netfilter
hook functions which trigger on the same packet. Hook
functions execute on each packet in order from smallest
priority number to largest priority number. If no
<i>PRIORITY</i> is specified (as in the first two probe
point variants above), <i>PRIORITY</i> defaults to
&quot;0&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of predefined priority names of the form
<i>NF_IP_PRI_*</i> and <i>NF_IP6_PRI_*</i> which are defined
in the kernel header files &lt;linux/netfilter_ipv4.h&gt;
and &lt;linux/netfilter_ipv6.h&gt; respectively. The script
is permitted to use these instead of specifying an integer
priority. (The probe points for <i>NFPROTO_ARP</i> and
<i>NFPROTO_BRIDGE</i> currently do not expose any named hook
priorities to the script writer.) Thus, allowable ways to
specify the priority include:</p>


<p style="margin-left:22%; margin-top: 1em">priority(&quot;255&quot;)
<br>
priority(&quot;NF_IP_PRI_SELINUX_LAST&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">A script using
guru mode is permitted to specify any identifier or number
as the parameter for hook, pf, and priority. This feature
should be used with caution, as the parameter is inserted
verbatim into the C code generated by systemtap.</p>

<p style="margin-left:11%; margin-top: 1em">The netfilter
probe points define the following context variables: <i><br>
$hooknum</i></p>

<p style="margin-left:22%;">The hook number.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>$skb</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The address of the sk_buff struct representing the
packet. See &lt;linux/skbuff.h&gt; for details on how to use
this struct, or alternatively use the tapset
<i>tapset::netfilter</i>(3stap) for easy access to key
information.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>$in</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The address of the net_device struct representing the
network device on which the packet was received (if any).
May be 0 if the device is unknown or undefined at that stage
in the protocol stack.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>$out</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>The address of the net_device struct representing the
network device on which the packet will be sent (if any).
May be 0 if the device is unknown or undefined at that stage
in the protocol stack.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>$verdict</i></p>

<p style="margin-left:22%;">(Guru mode only.) Assigning one
of the verdict values defined in &lt;linux/netfilter.h&gt;
to this variable alters the further progress of the packet
through the protocol stack. For instance, the following guru
mode script forces all ipv6 network packets to be
dropped:</p>

<p style="margin-left:22%; margin-top: 1em">probe
netfilter.pf(&quot;NFPROTO_IPV6&quot;).hook(&quot;NF_IP6_PRE_ROUTING&quot;)
{ <br>
$verdict = 0 /* nf_drop */ <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">For
convenience, unlike the primitive probe points discussed
here, the probes defined in <i>tapset::netfilter</i>(3stap)
export the lowercase names of the verdict constants (e.g.
NF_DROP becomes nf_drop) as local variables.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KERNEL
TRACEPOINTS</b> <br>
This family of probe points hooks up to static probing
tracepoints inserted into the kernel or modules. As with
markers, these tracepoints are special macro calls inserted
by kernel developers to make probing faster and more
reliable than with DWARF-based probes, and DWARF debugging
information is not required to probe tracepoints.
Tracepoints have an extra advantage of more strongly-typed
parameters than markers.</p>

<p style="margin-left:11%; margin-top: 1em">Tracepoint
probes look like: <b>kernel.trace(&quot;name&quot;)</b>. The
tracepoint name string, which may contain the usual wildcard
characters, is matched against the names defined by the
kernel developers in the tracepoint header files.</p>

<p style="margin-left:11%; margin-top: 1em">The handler
associated with a tracepoint-based probe may read the
optional parameters specified at the macro call site. These
are named according to the declaration by the tracepoint
author. For example, the tracepoint probe
<b>kernel.trace(&quot;sched_switch&quot;)</b> provides the
parameters <b>$rq</b>, <b>$prev</b>, and <b>$next</b>. If
the parameter is a complex type, as in a struct pointer,
then a script can access fields with the same syntax as
DWARF $target variables. Also, tracepoint parameters cannot
be modified, but in guru-mode a script may modify fields of
parameters.</p>

<p style="margin-left:11%; margin-top: 1em">The name of the
tracepoint is available in <b>$$name</b>, and a string of
name=value pairs for all parameters of the tracepoint is
available in <b>$$vars</b> or <b>$$parms</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KERNEL
MARKERS (OBSOLETE)</b> <br>
This family of probe points hooks up to an older style of
static probing markers inserted into older kernels or
modules. These markers are special STAP_MARK macro calls
inserted by kernel developers to make probing faster and
more reliable than with DWARF-based probes. Further, DWARF
debugging information is <i>not</i> required to probe
markers.</p>

<p style="margin-left:11%; margin-top: 1em">Marker probe
points begin with <b>kernel</b>. The next part names the
marker itself: <b>mark(&quot;name&quot;)</b>. The marker
name string, which may contain the usual wildcard
characters, is matched against the names given to the marker
macros when the kernel and/or module was compiled.
Optionally, you can specify
<b>format(&quot;format&quot;)</b>. Specifying the marker
format string allows differentiation between two markers
with the same name but different marker format strings.</p>

<p style="margin-left:11%; margin-top: 1em">The handler
associated with a marker-based probe may read the optional
parameters specified at the macro call site. These are named
<b>$arg1</b> through <b>$argNN</b>, where NN is the number
of parameters supplied by the macro. Number and string
parameters are passed in a type-safe manner.</p>

<p style="margin-left:11%; margin-top: 1em">The marker
format string associated with a marker is available in
<b>$format</b>. And also the marker name string is available
in <b>$name</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HARDWARE
BREAKPOINTS</b> <br>
This family of probes is used to set hardware watchpoints
for a given <br>
(global) kernel symbol. The probes take three components as
inputs :</p>

<p style="margin-left:11%; margin-top: 1em">1. The
<b>virtual</b>address<b>/</b>name of the kernel symbol to be
traced is supplied as argument to this class of probes. (
Probes for only data segment variables are supported.
Probing local variables of a function cannot be done.)</p>

<p style="margin-left:11%; margin-top: 1em">2. Nature of
access to be probed : a. <i>.write</i> probe gets triggered
when a write happens at the specified address/symbol name.
b. <i>rw</i> probe is triggered when either a read or write
happens.</p>

<p style="margin-left:11%; margin-top: 1em">3.
<b>.length</b> (optional) Users have the option of
specifying the address interval to be probed using
&quot;length&quot; constructs. The user-specified length
gets approximated to the closest possible address length
that the architecture can support. If the specified length
exceeds the limits imposed by architecture, an error message
is flagged and probe registration fails. Wherever
&rsquo;length&rsquo; is not specified, the translator
requests a hardware breakpoint probe of length 1. It should
be noted that the &quot;length&quot; construct is not valid
with symbol names.</p>

<p style="margin-left:11%; margin-top: 1em">Following
constructs are supported :</p>

<p style="margin-left:22%; margin-top: 1em">probe
kernel.data(ADDRESS).write <br>
probe kernel.data(ADDRESS).rw <br>
probe kernel.data(ADDRESS).length(LEN).write <br>
probe kernel.data(ADDRESS).length(LEN).rw <br>
probe kernel.data(&quot;SYMBOL_NAME&quot;).write <br>
probe kernel.data(&quot;SYMBOL_NAME&quot;).rw</p>

<p style="margin-left:11%; margin-top: 1em">This set of
probes make use of the debug registers of the processor,
which is a scarce resource. (4 on x86 , 1 on powerpc ) The
script translation flags a warning if a user requests more
hardware breakpoint probes than the limits set by
architecture. For example,a pass-2 warning is flashed when
an input script requests 5 hardware breakpoint probes on an
x86 system while x86 architecture supports a maximum of 4
breakpoints. Users are cautioned to set probes
judiciously.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PERF</b>
<br>
This family of probe points interfaces to the kernel
&quot;perf event&quot; infrastructure for controlling
hardware performance counters. The events being attached to
are described by the &quot;type&quot;, &quot;config&quot;
fields of the <i>perf_event_attr</i> structure, and are
sampled at an interval governed by the
&quot;sample_period&quot; field.</p>

<p style="margin-left:11%; margin-top: 1em">These fields
are made available to systemtap scripts using the following
syntax:</p>

<p style="margin-left:22%; margin-top: 1em">probe
perf.type(NN).config(MM).sample(XX) <br>
probe perf.type(NN).config(MM) <br>
probe perf.type(NN).config(MM).process(&quot;PROC&quot;)
<br>
probe perf.type(NN).config(MM).counter(&quot;COUNTER&quot;)
<br>
probe
perf.type(NN).config(MM).process(&quot;PROC&quot;).counter(&quot;COUNTER&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">The systemtap
probe handler is called once per XX increments of the
underlying performance counter. The default sampling count
is 1000000. The range of valid type/config is described by
the <i>perf_event_open</i>(2) system call, and/or the
<i>linux/perf_event.h</i> file. Invalid combinations or
exhausted hardware counter resources result in errors during
systemtap script startup. Systemtap does not sanity-check
the values: it merely passes them through to the kernel for
error- and safety-checking. By default the perf event probe
is systemwide unless .process is specified, which will bind
the probe to a specific task. If the name is omitted then it
is inferred from the stap &minus;c argument. A perf event
can be read on demand using .counter. The body of the perf
probe handler will not be invoked for a .counter probe;
instead, the counter is read in a user space probe via: <br>

process(&quot;PROCESS&quot;).statement(&quot;func@file&quot;)
{stat &lt;&lt;&lt; @perf(&quot;NAME&quot;)}</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Here are some
example probe points, defining the associated events. <br>
begin, end, end</p>

<p style="margin-left:22%;">refers to the startup and
normal shutdown of the session. In this case, the handler
would run once during startup and twice during shutdown.</p>


<p style="margin-left:11%;">timer.jiffies(1000).randomize(200)</p>

<p style="margin-left:22%;">refers to a periodic interrupt,
every 1000 +/&minus; 200 jiffies.</p>


<p style="margin-left:11%;">kernel.function(&quot;*init*&quot;),
kernel.function(&quot;*exit*&quot;)</p>

<p style="margin-left:22%;">refers to all kernel functions
with &quot;init&quot; or &quot;exit&quot; in the name.</p>


<p style="margin-left:11%;">kernel.function(&quot;*@kernel/time.c:240&quot;)</p>

<p style="margin-left:22%;">refers to any functions within
the &quot;kernel/time.c&quot; file that span line 240. Note
that this is <b>not</b> a probe at the statement at that
line number. Use the kernel.statement probe instead.</p>


<p style="margin-left:11%;">kernel.trace(&quot;sched_*&quot;)</p>

<p style="margin-left:22%;">refers to all scheduler-related
(really, prefixed) tracepoints in the kernel.</p>


<p style="margin-left:11%;">kernel.mark(&quot;getuid&quot;)</p>

<p style="margin-left:22%;">refers to an obsolete
STAP_MARK(getuid, ...) macro call in the kernel.</p>


<p style="margin-left:11%;">module(&quot;usb*&quot;).function(&quot;*sync*&quot;).return</p>

<p style="margin-left:22%;">refers to the moment of return
from all functions with &quot;sync&quot; in the name in any
of the USB drivers.</p>


<p style="margin-left:11%;">kernel.statement(0xc0044852)</p>

<p style="margin-left:22%;">refers to the first byte of the
statement whose compiled instructions include the given
address in the kernel.</p>


<p style="margin-left:11%;">kernel.statement(&quot;*@kernel/time.c:296&quot;)</p>

<p style="margin-left:22%;">refers to the statement of line
296 within &quot;kernel/time.c&quot;.</p>


<p style="margin-left:11%;">kernel.statement(&quot;bio_init@fs/bio.c+3&quot;)</p>

<p style="margin-left:22%;">refers to the statement at line
bio_init+3 within &quot;fs/bio.c&quot;.</p>


<p style="margin-left:11%;">kernel.data(&quot;pid_max&quot;).write</p>

<p style="margin-left:22%;">refers to a hardware breakpoint
of type &quot;write&quot; set on pid_max</p>

<p style="margin-left:11%;">syscall.*.return</p>

<p style="margin-left:22%;">refers to the group of probe
aliases with any name in the third position</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>stap</i>(1),
<i><br>
probe::*</i>(3stap), <i><br>
 tapset::*</i>(3stap)</p>
<hr>
</body>
</html>
