<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:32:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STRUCT CFG80211_OPS</title>

</head>
<body>

<h1 align="center">STRUCT CFG80211_OPS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#MEMBERS">MEMBERS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">struct_cfg80211_ops
&minus; backend description for wireless configuration</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">struct
cfg80211_ops { <br>
int (* suspend) (struct wiphy *wiphy, struct cfg80211_wowlan
*wow); <br>
int (* resume) (struct wiphy *wiphy); <br>
void (* set_wakeup) (struct wiphy *wiphy, bool enabled);
<br>
struct wireless_dev * (* add_virtual_intf) (struct wiphy
*wiphy,const char *name,enum nl80211_iftype type,u32
*flags,struct vif_params *params); <br>
int (* del_virtual_intf) (struct wiphy *wiphy,struct
wireless_dev *wdev); <br>
int (* change_virtual_intf) (struct wiphy *wiphy,struct
net_device *dev,enum nl80211_iftype type, u32 *flags,struct
vif_params *params); <br>
int (* add_key) (struct wiphy *wiphy, struct net_device
*netdev,u8 key_index, bool pairwise, const u8
*mac_addr,struct key_params *params); <br>
int (* get_key) (struct wiphy *wiphy, struct net_device
*netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void
*cookie,void (*callback); <br>
int (* del_key) (struct wiphy *wiphy, struct net_device
*netdev,u8 key_index, bool pairwise, const u8 *mac_addr);
<br>
int (* set_default_key) (struct wiphy *wiphy,struct
net_device *netdev,u8 key_index, bool unicast, bool
multicast); <br>
int (* set_default_mgmt_key) (struct wiphy *wiphy,struct
net_device *netdev,u8 key_index); <br>
int (* start_ap) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_ap_settings *settings); <br>
int (* change_beacon) (struct wiphy *wiphy, struct
net_device *dev,struct cfg80211_beacon_data *info); <br>
int (* stop_ap) (struct wiphy *wiphy, struct net_device
*dev); <br>
int (* add_station) (struct wiphy *wiphy, struct net_device
*dev,const u8 *mac,struct station_parameters *params); <br>
int (* del_station) (struct wiphy *wiphy, struct net_device
*dev,const u8 *mac); <br>
int (* change_station) (struct wiphy *wiphy, struct
net_device *dev,const u8 *mac,struct station_parameters
*params); <br>
int (* get_station) (struct wiphy *wiphy, struct net_device
*dev,const u8 *mac, struct station_info *sinfo); <br>
int (* dump_station) (struct wiphy *wiphy, struct net_device
*dev,int idx, u8 *mac, struct station_info *sinfo); <br>
int (* add_mpath) (struct wiphy *wiphy, struct net_device
*dev,const u8 *dst, const u8 *next_hop); <br>
int (* del_mpath) (struct wiphy *wiphy, struct net_device
*dev,const u8 *dst); <br>
int (* change_mpath) (struct wiphy *wiphy, struct net_device
*dev,const u8 *dst, const u8 *next_hop); <br>
int (* get_mpath) (struct wiphy *wiphy, struct net_device
*dev,u8 *dst, u8 *next_hop, struct mpath_info *pinfo); <br>
int (* dump_mpath) (struct wiphy *wiphy, struct net_device
*dev,int idx, u8 *dst, u8 *next_hop,struct mpath_info
*pinfo); <br>
int (* get_mesh_config) (struct wiphy *wiphy,struct
net_device *dev,struct mesh_config *conf); <br>
int (* update_mesh_config) (struct wiphy *wiphy,struct
net_device *dev, u32 mask,const struct mesh_config *nconf);
<br>
int (* join_mesh) (struct wiphy *wiphy, struct net_device
*dev,const struct mesh_config *conf,const struct mesh_setup
*setup); <br>
int (* leave_mesh) (struct wiphy *wiphy, struct net_device
*dev); <br>
int (* change_bss) (struct wiphy *wiphy, struct net_device
*dev,struct bss_parameters *params); <br>
int (* set_txq_params) (struct wiphy *wiphy, struct
net_device *dev,struct ieee80211_txq_params *params); <br>
int (* libertas_set_mesh_channel) (struct wiphy
*wiphy,struct net_device *dev,struct ieee80211_channel
*chan); <br>
int (* set_monitor_channel) (struct wiphy *wiphy,struct
cfg80211_chan_def *chandef); <br>
int (* scan) (struct wiphy *wiphy,struct
cfg80211_scan_request *request); <br>
int (* auth) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_auth_request *req); <br>
int (* assoc) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_assoc_request *req); <br>
int (* deauth) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_deauth_request *req); <br>
int (* disassoc) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_disassoc_request *req); <br>
int (* connect) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_connect_params *sme); <br>
int (* disconnect) (struct wiphy *wiphy, struct net_device
*dev,u16 reason_code); <br>
int (* join_ibss) (struct wiphy *wiphy, struct net_device
*dev,struct cfg80211_ibss_params *params); <br>
int (* leave_ibss) (struct wiphy *wiphy, struct net_device
*dev); <br>
int (* set_mcast_rate) (struct wiphy *wiphy, struct
net_device *dev,int rate[IEEE80211_NUM_BANDS]); <br>
int (* set_wiphy_params) (struct wiphy *wiphy, u32 changed);
<br>
int (* set_tx_power) (struct wiphy *wiphy, struct
wireless_dev *wdev,enum nl80211_tx_power_setting type, int
mbm); <br>
int (* get_tx_power) (struct wiphy *wiphy, struct
wireless_dev *wdev,int *dbm); <br>
int (* set_wds_peer) (struct wiphy *wiphy, struct net_device
*dev,const u8 *addr); <br>
void (* rfkill_poll) (struct wiphy *wiphy); <br>
#ifdef CONFIG_NL80211_TESTMODE <br>
int (* testmode_cmd) (struct wiphy *wiphy, struct
wireless_dev *wdev,void *data, int len); <br>
int (* testmode_dump) (struct wiphy *wiphy, struct sk_buff
*skb,struct netlink_callback *cb,void *data, int len); <br>
#endif <br>
int (* set_bitrate_mask) (struct wiphy *wiphy,struct
net_device *dev,const u8 *peer,const struct
cfg80211_bitrate_mask *mask); <br>
int (* dump_survey) (struct wiphy *wiphy, struct net_device
*netdev,int idx, struct survey_info *info); <br>
int (* set_pmksa) (struct wiphy *wiphy, struct net_device
*netdev,struct cfg80211_pmksa *pmksa); <br>
int (* del_pmksa) (struct wiphy *wiphy, struct net_device
*netdev,struct cfg80211_pmksa *pmksa); <br>
int (* flush_pmksa) (struct wiphy *wiphy, struct net_device
*netdev); <br>
int (* remain_on_channel) (struct wiphy *wiphy,struct
wireless_dev *wdev,struct ieee80211_channel *chan,unsigned
int duration,u64 *cookie); <br>
int (* cancel_remain_on_channel) (struct wiphy *wiphy,struct
wireless_dev *wdev,u64 cookie); <br>
int (* mgmt_tx) (struct wiphy *wiphy, struct wireless_dev
*wdev,struct cfg80211_mgmt_tx_params *params,u64 *cookie);
<br>
int (* mgmt_tx_cancel_wait) (struct wiphy *wiphy,struct
wireless_dev *wdev,u64 cookie); <br>
int (* set_power_mgmt) (struct wiphy *wiphy, struct
net_device *dev,bool enabled, int timeout); <br>
int (* set_cqm_rssi_config) (struct wiphy *wiphy,struct
net_device *dev,s32 rssi_thold, u32 rssi_hyst); <br>
int (* set_cqm_txe_config) (struct wiphy *wiphy,struct
net_device *dev,u32 rate, u32 pkts, u32 intvl); <br>
void (* mgmt_frame_register) (struct wiphy *wiphy,struct
wireless_dev *wdev,u16 frame_type, bool reg); <br>
int (* set_antenna) (struct wiphy *wiphy, u32 tx_ant, u32
rx_ant); <br>
int (* get_antenna) (struct wiphy *wiphy, u32 *tx_ant, u32
*rx_ant); <br>
int (* set_ringparam) (struct wiphy *wiphy, u32 tx, u32 rx);
<br>
void (* get_ringparam) (struct wiphy *wiphy,u32 *tx, u32
*tx_max, u32 *rx, u32 *rx_max); <br>
int (* sched_scan_start) (struct wiphy *wiphy,struct
net_device *dev,struct cfg80211_sched_scan_request
*request); <br>
int (* sched_scan_stop) (struct wiphy *wiphy, struct
net_device *dev); <br>
int (* set_rekey_data) (struct wiphy *wiphy, struct
net_device *dev,struct cfg80211_gtk_rekey_data *data); <br>
int (* tdls_mgmt) (struct wiphy *wiphy, struct net_device
*dev,const u8 *peer, u8 action_code, u8 dialog_token,u16
status_code, u32 peer_capability,const u8 *buf, size_t len);
<br>
int (* tdls_oper) (struct wiphy *wiphy, struct net_device
*dev,const u8 *peer, enum nl80211_tdls_operation oper); <br>
int (* probe_client) (struct wiphy *wiphy, struct net_device
*dev,const u8 *peer, u64 *cookie); <br>
int (* set_noack_map) (struct wiphy *wiphy,struct net_device
*dev,u16 noack_map); <br>
int (* get_et_sset_count) (struct wiphy *wiphy,struct
net_device *dev, int sset); <br>
void (* get_et_stats) (struct wiphy *wiphy, struct
net_device *dev,struct ethtool_stats *stats, u64 *data);
<br>
void (* get_et_strings) (struct wiphy *wiphy, struct
net_device *dev,u32 sset, u8 *data); <br>
int (* get_channel) (struct wiphy *wiphy,struct wireless_dev
*wdev,struct cfg80211_chan_def *chandef); <br>
int (* start_p2p_device) (struct wiphy *wiphy,struct
wireless_dev *wdev); <br>
void (* stop_p2p_device) (struct wiphy *wiphy,struct
wireless_dev *wdev); <br>
int (* set_mac_acl) (struct wiphy *wiphy, struct net_device
*dev,const struct cfg80211_acl_data *params); <br>
int (* start_radar_detection) (struct wiphy *wiphy,struct
net_device *dev,struct cfg80211_chan_def *chandef,u32
cac_time_ms); <br>
int (* update_ft_ies) (struct wiphy *wiphy, struct
net_device *dev,struct cfg80211_update_ft_ies_params *ftie);
<br>
int (* crit_proto_start) (struct wiphy *wiphy,struct
wireless_dev *wdev,enum nl80211_crit_proto_id protocol,u16
duration); <br>
void (* crit_proto_stop) (struct wiphy *wiphy,struct
wireless_dev *wdev); <br>
int (* set_coalesce) (struct wiphy *wiphy,struct
cfg80211_coalesce *coalesce); <br>
int (* channel_switch) (struct wiphy *wiphy,struct
net_device *dev,struct cfg80211_csa_settings *params); <br>
int (* set_qos_map) (struct wiphy *wiphy,struct net_device
*dev,struct cfg80211_qos_map *qos_map); <br>
int (* set_ap_chanwidth) (struct wiphy *wiphy, struct
net_device *dev,struct cfg80211_chan_def *chandef); <br>
};</p>

<h2>MEMBERS
<a name="MEMBERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">suspend</p>

<p style="margin-left:17%;">wiphy device needs to be
suspended. The variable <i>wow</i> will be <b>NULL</b> or
contain the enabled Wake&minus;on&minus;Wireless triggers
that are configured for the device.</p>

<p style="margin-left:11%; margin-top: 1em">resume</p>

<p style="margin-left:17%;">wiphy device needs to be
resumed</p>

<p style="margin-left:11%; margin-top: 1em">set_wakeup</p>

<p style="margin-left:17%;">Called when WoWLAN is
enabled/disabled, use this callback to call
<b>device_set_wakeup_enable</b> to enable/disable wakeup
from the device.</p>


<p style="margin-left:11%; margin-top: 1em">add_virtual_intf</p>

<p style="margin-left:17%;">create a new virtual interface
with the given name, must set the struct wireless_dev's
iftype. Beware: You must create the new netdev in the
wiphy's network namespace! Returns the struct wireless_dev,
or an ERR_PTR. For P2P device wdevs, the driver must also
set the address member in the wdev.</p>


<p style="margin-left:11%; margin-top: 1em">del_virtual_intf</p>

<p style="margin-left:17%;">remove the virtual
interface</p>


<p style="margin-left:11%; margin-top: 1em">change_virtual_intf</p>

<p style="margin-left:17%;">change type/configuration of
virtual interface, keep the struct wireless_dev's iftype
updated.</p>

<p style="margin-left:11%; margin-top: 1em">add_key</p>

<p style="margin-left:17%;">add a key with the given
parameters. <i>mac_addr</i> will be <b>NULL</b> when adding
a group key.</p>

<p style="margin-left:11%; margin-top: 1em">get_key</p>

<p style="margin-left:17%;">get information about the key
with the given parameters. <i>mac_addr</i> will be
<b>NULL</b> when requesting information for a group key. All
pointers given to the <i>callback</i> function need not be
valid after it returns. This function should return an error
if it is not possible to retrieve the key, &minus;ENOENT if
it doesn't exist.</p>

<p style="margin-left:11%; margin-top: 1em">del_key</p>

<p style="margin-left:17%;">remove a key given the
<i>mac_addr</i> (<b>NULL</b> for a group key) and
<i>key_index</i>, return &minus;ENOENT if the key doesn't
exist.</p>


<p style="margin-left:11%; margin-top: 1em">set_default_key</p>

<p style="margin-left:17%;">set the default key on an
interface</p>


<p style="margin-left:11%; margin-top: 1em">set_default_mgmt_key</p>

<p style="margin-left:17%;">set the default management
frame key on an interface</p>

<p style="margin-left:11%; margin-top: 1em">start_ap</p>

<p style="margin-left:17%;">Start acting in AP mode defined
by the parameters.</p>


<p style="margin-left:11%; margin-top: 1em">change_beacon</p>

<p style="margin-left:17%;">Change the beacon parameters
for an access point mode interface. This should reject the
call when AP mode wasn't started.</p>

<p style="margin-left:11%; margin-top: 1em">stop_ap</p>

<p style="margin-left:17%;">Stop being an AP, including
stopping beaconing.</p>


<p style="margin-left:11%; margin-top: 1em">add_station</p>

<p style="margin-left:17%;">Add a new station.</p>


<p style="margin-left:11%; margin-top: 1em">del_station</p>

<p style="margin-left:17%;">Remove a station; <i>mac</i>
may be NULL to remove all stations.</p>


<p style="margin-left:11%; margin-top: 1em">change_station</p>

<p style="margin-left:17%;">Modify a given station. Note
that flags changes are not much validated in cfg80211, in
particular the auth/assoc/authorized flags might come to the
driver in invalid combinations &minus;&minus; make sure to
check them, also against the existing state! Drivers must
call <b>cfg80211_check_station_change</b> to validate the
information.</p>


<p style="margin-left:11%; margin-top: 1em">get_station</p>

<p style="margin-left:17%;">get station information for the
station identified by <i>mac</i></p>


<p style="margin-left:11%; margin-top: 1em">dump_station</p>

<p style="margin-left:17%;">dump station callback
&minus;&minus; resume dump at index <i>idx</i></p>

<p style="margin-left:11%; margin-top: 1em">add_mpath</p>

<p style="margin-left:17%;">add a fixed mesh path</p>

<p style="margin-left:11%; margin-top: 1em">del_mpath</p>

<p style="margin-left:17%;">delete a given mesh path</p>


<p style="margin-left:11%; margin-top: 1em">change_mpath</p>

<p style="margin-left:17%;">change a given mesh path</p>

<p style="margin-left:11%; margin-top: 1em">get_mpath</p>

<p style="margin-left:17%;">get a mesh path for the given
parameters</p>

<p style="margin-left:11%; margin-top: 1em">dump_mpath</p>

<p style="margin-left:17%;">dump mesh path callback
&minus;&minus; resume dump at index <i>idx</i></p>


<p style="margin-left:11%; margin-top: 1em">get_mesh_config</p>

<p style="margin-left:17%;">Get the current mesh
configuration</p>


<p style="margin-left:11%; margin-top: 1em">update_mesh_config</p>

<p style="margin-left:17%;">Update mesh parameters on a
running mesh. The mask is a bitfield which tells us which
parameters to set, and which to leave alone.</p>

<p style="margin-left:11%; margin-top: 1em">join_mesh</p>

<p style="margin-left:17%;">join the mesh network with the
specified parameters (invoked with the wireless_dev mutex
held)</p>

<p style="margin-left:11%; margin-top: 1em">leave_mesh</p>

<p style="margin-left:17%;">leave the current mesh network
(invoked with the wireless_dev mutex held)</p>

<p style="margin-left:11%; margin-top: 1em">change_bss</p>

<p style="margin-left:17%;">Modify parameters for a given
BSS.</p>


<p style="margin-left:11%; margin-top: 1em">set_txq_params</p>

<p style="margin-left:17%;">Set TX queue parameters</p>


<p style="margin-left:11%; margin-top: 1em">libertas_set_mesh_channel</p>

<p style="margin-left:17%;">Only for backward compatibility
for libertas, as it doesn't implement join_mesh and needs to
set the channel to join the mesh instead.</p>


<p style="margin-left:11%; margin-top: 1em">set_monitor_channel</p>

<p style="margin-left:17%;">Set the monitor mode channel
for the device. If other interfaces are active this callback
should reject the configuration. If no interfaces are active
or the device is down, the channel should be stored for when
a monitor interface becomes active.</p>

<p style="margin-left:11%; margin-top: 1em">scan</p>

<p style="margin-left:17%;">Request to do a scan. If
returning zero, the scan request is given the driver, and
will be valid until passed to <b>cfg80211_scan_done</b>. For
scan results, call <b>cfg80211_inform_bss</b>; you can call
this outside the scan/scan_done bracket too.</p>

<p style="margin-left:11%; margin-top: 1em">auth</p>

<p style="margin-left:17%;">Request to authenticate with
the specified peer (invoked with the wireless_dev mutex
held)</p>

<p style="margin-left:11%; margin-top: 1em">assoc</p>

<p style="margin-left:17%;">Request to (re)associate with
the specified peer (invoked with the wireless_dev mutex
held)</p>

<p style="margin-left:11%; margin-top: 1em">deauth</p>

<p style="margin-left:17%;">Request to deauthenticate from
the specified peer (invoked with the wireless_dev mutex
held)</p>

<p style="margin-left:11%; margin-top: 1em">disassoc</p>

<p style="margin-left:17%;">Request to disassociate from
the specified peer (invoked with the wireless_dev mutex
held)</p>

<p style="margin-left:11%; margin-top: 1em">connect</p>

<p style="margin-left:17%;">Connect to the ESS with the
specified parameters. When connected, call
<b>cfg80211_connect_result</b> with status code
<b>WLAN_STATUS_SUCCESS</b>. If the connection fails for some
reason, call <b>cfg80211_connect_result</b> with the status
from the AP. (invoked with the wireless_dev mutex held)</p>

<p style="margin-left:11%; margin-top: 1em">disconnect</p>

<p style="margin-left:17%;">Disconnect from the BSS/ESS.
(invoked with the wireless_dev mutex held)</p>

<p style="margin-left:11%; margin-top: 1em">join_ibss</p>

<p style="margin-left:17%;">Join the specified IBSS (or
create if necessary). Once done, call
<b>cfg80211_ibss_joined</b>, also call that function when
changing BSSID due to a merge. (invoked with the
wireless_dev mutex held)</p>

<p style="margin-left:11%; margin-top: 1em">leave_ibss</p>

<p style="margin-left:17%;">Leave the IBSS. (invoked with
the wireless_dev mutex held)</p>


<p style="margin-left:11%; margin-top: 1em">set_mcast_rate</p>

<p style="margin-left:17%;">Set the specified multicast
rate (only if vif is in ADHOC or MESH mode)</p>


<p style="margin-left:11%; margin-top: 1em">set_wiphy_params</p>

<p style="margin-left:17%;">Notify that wiphy parameters
have changed; <i>changed</i> bitfield (see enum
wiphy_params_flags) describes which values have changed. The
actual parameter values are available in struct wiphy. If
returning an error, no value should be changed.</p>


<p style="margin-left:11%; margin-top: 1em">set_tx_power</p>

<p style="margin-left:17%;">set the transmit power
according to the parameters, the power passed is in mBm, to
get dBm use <b>MBM_TO_DBM</b>. The wdev may be <b>NULL</b>
if power was set for the wiphy, and will always be
<b>NULL</b> unless the driver supports per&minus;vif TX
power (as advertised by the nl80211 feature flag.)</p>


<p style="margin-left:11%; margin-top: 1em">get_tx_power</p>

<p style="margin-left:17%;">store the current TX power into
the dbm variable; return 0 if successful</p>


<p style="margin-left:11%; margin-top: 1em">set_wds_peer</p>

<p style="margin-left:17%;">set the WDS peer for a WDS
interface</p>


<p style="margin-left:11%; margin-top: 1em">rfkill_poll</p>

<p style="margin-left:17%;">polls the hw rfkill line, use
cfg80211 reporting functions to adjust rfkill hw state</p>


<p style="margin-left:11%; margin-top: 1em">testmode_cmd</p>

<p style="margin-left:17%;">run a test mode command;
<i>wdev</i> may be <b>NULL</b></p>


<p style="margin-left:11%; margin-top: 1em">testmode_dump</p>

<p style="margin-left:17%;">Implement a test mode dump. The
cb&minus;&gt;args[2] and up may be used by the function, but
0 and 1 must not be touched. Additionally, return error
codes other than &minus;ENOBUFS and &minus;ENOENT will
terminate the dump and return to userspace with an error, so
be careful. If any data was passed in from userspace then
the data/len arguments will be present and point to the data
contained in <b>NL80211_ATTR_TESTDATA</b>.</p>


<p style="margin-left:11%; margin-top: 1em">set_bitrate_mask</p>

<p style="margin-left:17%;">set the bitrate mask
configuration</p>


<p style="margin-left:11%; margin-top: 1em">dump_survey</p>

<p style="margin-left:17%;">get site survey
information.</p>

<p style="margin-left:11%; margin-top: 1em">set_pmksa</p>

<p style="margin-left:17%;">Cache a PMKID for a BSSID. This
is mostly useful for fullmac devices running firmwares
capable of generating the (re) association RSN IE. It allows
for faster roaming between WPA2 BSSIDs.</p>

<p style="margin-left:11%; margin-top: 1em">del_pmksa</p>

<p style="margin-left:17%;">Delete a cached PMKID.</p>


<p style="margin-left:11%; margin-top: 1em">flush_pmksa</p>

<p style="margin-left:17%;">Flush all cached PMKIDs.</p>


<p style="margin-left:11%; margin-top: 1em">remain_on_channel</p>

<p style="margin-left:17%;">Request the driver to remain
awake on the specified channel for the specified duration to
complete an off&minus;channel operation (e.g., public action
frame exchange). When the driver is ready on the requested
channel, it must indicate this with an event notification by
calling <b>cfg80211_ready_on_channel</b>.</p>


<p style="margin-left:11%; margin-top: 1em">cancel_remain_on_channel</p>

<p style="margin-left:17%;">Cancel an on&minus;going
remain&minus;on&minus;channel operation. This allows the
operation to be terminated prior to timeout based on the
duration value.</p>

<p style="margin-left:11%; margin-top: 1em">mgmt_tx</p>

<p style="margin-left:17%;">Transmit a management
frame.</p>


<p style="margin-left:11%; margin-top: 1em">mgmt_tx_cancel_wait</p>

<p style="margin-left:17%;">Cancel the wait time from
transmitting a management frame on another channel</p>


<p style="margin-left:11%; margin-top: 1em">set_power_mgmt</p>

<p style="margin-left:17%;">Configure WLAN power
management. A timeout value of &minus;1 allows the driver to
adjust the dynamic ps timeout value.</p>


<p style="margin-left:11%; margin-top: 1em">set_cqm_rssi_config</p>

<p style="margin-left:17%;">Configure connection quality
monitor RSSI threshold.</p>


<p style="margin-left:11%; margin-top: 1em">set_cqm_txe_config</p>

<p style="margin-left:17%;">Configure connection quality
monitor TX error thresholds.</p>


<p style="margin-left:11%; margin-top: 1em">mgmt_frame_register</p>

<p style="margin-left:17%;">Notify driver that a management
frame type was registered. Note that this callback may not
sleep, and cannot run concurrently with itself.</p>


<p style="margin-left:11%; margin-top: 1em">set_antenna</p>

<p style="margin-left:17%;">Set antenna configuration
(tx_ant, rx_ant) on the device. Parameters are bitmaps of
allowed antennas to use for TX/RX. Drivers may reject TX/RX
mask combinations they cannot support by returning
&minus;EINVAL (also see nl80211.h
<i>NL80211_ATTR_WIPHY_ANTENNA_TX</i>).</p>


<p style="margin-left:11%; margin-top: 1em">get_antenna</p>

<p style="margin-left:17%;">Get current antenna
configuration from device (tx_ant, rx_ant).</p>


<p style="margin-left:11%; margin-top: 1em">set_ringparam</p>

<p style="margin-left:17%;">Set tx and rx ring sizes.</p>


<p style="margin-left:11%; margin-top: 1em">get_ringparam</p>

<p style="margin-left:17%;">Get tx and rx ring current and
maximum sizes.</p>


<p style="margin-left:11%; margin-top: 1em">sched_scan_start</p>

<p style="margin-left:17%;">Tell the driver to start a
scheduled scan.</p>


<p style="margin-left:11%; margin-top: 1em">sched_scan_stop</p>

<p style="margin-left:17%;">Tell the driver to stop an
ongoing scheduled scan. This call must stop the scheduled
scan and be ready for starting a new one before it returns,
i.e. <i>sched_scan_start</i> may be called immediately after
that again and should not fail in that case. The driver
should not call <b>cfg80211_sched_scan_stopped</b> for a
requested stop (when this method returns 0.)</p>


<p style="margin-left:11%; margin-top: 1em">set_rekey_data</p>

<p style="margin-left:17%;">give the data necessary for GTK
rekeying to the driver</p>

<p style="margin-left:11%; margin-top: 1em">tdls_mgmt</p>

<p style="margin-left:17%;">Transmit a TDLS management
frame.</p>

<p style="margin-left:11%; margin-top: 1em">tdls_oper</p>

<p style="margin-left:17%;">Perform a high&minus;level TDLS
operation (e.g. TDLS link setup).</p>


<p style="margin-left:11%; margin-top: 1em">probe_client</p>

<p style="margin-left:17%;">probe an associated client,
must return a cookie that it later passes to
<b>cfg80211_probe_status</b>.</p>


<p style="margin-left:11%; margin-top: 1em">set_noack_map</p>

<p style="margin-left:17%;">Set the NoAck Map for the
TIDs.</p>


<p style="margin-left:11%; margin-top: 1em">get_et_sset_count</p>

<p style="margin-left:17%;">Ethtool API to get
string&minus;set count. See
<i>ethtool_ops</i>.get_sset_count</p>


<p style="margin-left:11%; margin-top: 1em">get_et_stats</p>

<p style="margin-left:17%;">Ethtool API to get a set of u64
stats. See <i>ethtool_ops</i>.get_ethtool_stats</p>


<p style="margin-left:11%; margin-top: 1em">get_et_strings</p>

<p style="margin-left:17%;">Ethtool API to get a set of
strings to describe stats and perhaps other supported types
of ethtool data&minus;sets. See
<i>ethtool_ops</i>.get_strings</p>


<p style="margin-left:11%; margin-top: 1em">get_channel</p>

<p style="margin-left:17%;">Get the current operating
channel for the virtual interface. For monitor interfaces,
it should return <b>NULL</b> unless there's a single current
monitoring channel.</p>


<p style="margin-left:11%; margin-top: 1em">start_p2p_device</p>

<p style="margin-left:17%;">Start the given P2P device.</p>


<p style="margin-left:11%; margin-top: 1em">stop_p2p_device</p>

<p style="margin-left:17%;">Stop the given P2P device.</p>


<p style="margin-left:11%; margin-top: 1em">set_mac_acl</p>

<p style="margin-left:17%;">Sets MAC address control list
in AP and P2P GO mode. Parameters include ACL policy, an
array of MAC address of stations and the number of MAC
addresses. If there is already a list in driver this new
list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers
which advertise the support for MAC based ACL have to
implement this callback.</p>


<p style="margin-left:11%; margin-top: 1em">start_radar_detection</p>

<p style="margin-left:17%;">Start radar detection in the
driver.</p>


<p style="margin-left:11%; margin-top: 1em">update_ft_ies</p>

<p style="margin-left:17%;">Provide updated Fast BSS
Transition information to the driver. If the SME is in the
driver/firmware, this information can be used in building
Authentication and Reassociation Request frames.</p>


<p style="margin-left:11%; margin-top: 1em">crit_proto_start</p>

<p style="margin-left:17%;">Indicates a critical protocol
needs more link reliability for a given duration
(milliseconds). The protocol is provided so the driver can
take the most appropriate actions.</p>


<p style="margin-left:11%; margin-top: 1em">crit_proto_stop</p>

<p style="margin-left:17%;">Indicates critical protocol no
longer needs increased link reliability. This operation can
not fail.</p>


<p style="margin-left:11%; margin-top: 1em">set_coalesce</p>

<p style="margin-left:17%;">Set coalesce parameters.</p>


<p style="margin-left:11%; margin-top: 1em">channel_switch</p>

<p style="margin-left:17%;">initiate channel&minus;switch
procedure (with CSA)</p>


<p style="margin-left:11%; margin-top: 1em">set_qos_map</p>

<p style="margin-left:17%;">Set QoS mapping information to
the driver</p>


<p style="margin-left:11%; margin-top: 1em">set_ap_chanwidth</p>

<p style="margin-left:17%;">Set the AP (including P2P GO)
mode channel width for the given interface This is used e.g.
for dynamic HT 20/40 MHz channel width changes during the
lifetime of the BSS.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This struct is
registered by fullmac card drivers and/or wireless stacks in
order to handle configuration requests on their
interfaces.</p>

<p style="margin-left:11%; margin-top: 1em">All callbacks
except where otherwise noted should return 0 on success or a
negative error code.</p>

<p style="margin-left:11%; margin-top: 1em">All operations
are currently invoked under rtnl for consistency with the
wireless extensions but this is subject to reevaluation as
soon as this code is used more widely and we have a first
user without wext.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Johannes
Berg</b> &lt;johannes@sipsolutions.net&gt;</p>

<p style="margin-left:17%;">Author.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<hr>
</body>
</html>
