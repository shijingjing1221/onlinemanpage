<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:14:50 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>POPT</title>

</head>
<body>

<h1 align="center">POPT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BASIC POPT USAGE">BASIC POPT USAGE</a><br>
<a href="#ERROR HANDLING">ERROR HANDLING</a><br>
<a href="#OPTION ALIASING">OPTION ALIASING</a><br>
<a href="#PARSING ARGUMENT STRINGS">PARSING ARGUMENT STRINGS</a><br>
<a href="#HANDLING EXTRA ARGUMENTS">HANDLING EXTRA ARGUMENTS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">popt &minus;
Parse command line options</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>poptContext
poptGetContext(const char *</b> <i>name</i><b>, int</b>
<i>argc</i><b>, <br>
const char **</b> <i>argv</i><b>, <br>
const struct poptOption *</b> <i>options</i><b>, <br>
int</b> <i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
poptFreeContext(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
poptResetContext(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptGetNextOpt(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
poptGetOptArg(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
poptGetArg(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
poptPeekArg(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
** poptGetArgs(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char
*const poptStrerror(const int</b> <i>error</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const char *
poptBadOption(poptContext</b> <i>con</i><b>, int</b>
<i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptReadDefaultConfig(poptContext</b> <i>con</i><b>, int</b>
<i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptReadConfigFile(poptContext</b> <i>con</i><b>, char *</b>
<i>fn</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptAddAlias(poptContext</b> <i>con</i><b>, struct
poptAlias</b> <i>alias</i><b>, <br>
int</b> <i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptParseArgvString(char *</b> <i>s</i><b>, int *</b>
<i>argcPtr</i><b>, <br>
const char ***</b> <i>argvPtr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptDupArgv(int</b> <i>argc</i><b>, const char **</b>
<i>argv</i><b>, int *</b> <i>argcPtr</i><b>, <br>
const char ***</b> <i>argvPtr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
poptStuffArgs(poptContext</b> <i>con</i><b>, const char
**</b> <i>argv</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The popt
library exists essentially for parsing command-line options.
It is found superior in many ways when compared to parsing
the argv array by hand or using the getopt functions
<b>getopt()</b> and <b>getopt_long()</b> [see
<b>getopt</b>(3)]. Some specific advantages of popt are: it
does not utilize global variables, thus enabling multiple
passes in parsing <i>argv</i> ; it can parse an arbitrary
array of <i>argv</i>-style elements, allowing parsing of
command-line-strings from any source; it provides a standard
method of option aliasing (to be discussed at length
below.); it can exec external option filters; and, finally,
it can automatically generate help and usage messages for
the application.</p>

<p style="margin-left:11%; margin-top: 1em">Like
<b>getopt_long()</b>, the popt library supports short and
long style options. Recall that a <b>short option</b>
consists of a - character followed by a single alphanumeric
character. A <b>long option</b>, common in GNU utilities,
consists of two - characters followed by a string made up of
letters, numbers and hyphens. Long options are optionally
allowed to begin with a single -, primarily to allow
command-line compatibility between popt applications and X
toolkit applications. Either type of option may be followed
by an argument. A space separates a short option from its
arguments; either a space or an = separates a long option
from an argument.</p>

<p style="margin-left:11%; margin-top: 1em">The popt
library is highly portable and should work on any POSIX
platform. The latest version is distributed with rpm and is
always available from: ftp://ftp.rpm.org/pub/rpm/dist.</p>

<p style="margin-left:11%; margin-top: 1em">It may be
redistributed under the X consortium license, see the file
COPYING in the popt source distribution for details.</p>

<h2>BASIC POPT USAGE
<a name="BASIC POPT USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>1. THE
OPTION TABLE</b> <br>
Applications provide popt with information on their
command-line options by means of an &quot;option
table,&quot; i.e., an array of <b>struct poptOption</b>
structures:</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;popt.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">struct
poptOption { <br>
const char * longName; /* may be NULL */ <br>
char shortName; /* may be &rsquo;\0&rsquo; */ <br>
int argInfo; <br>
void * arg; /* depends on argInfo */ <br>
int val; /* 0 means don&rsquo;t return, just update flag */
<br>
char * descrip; /* description for autohelp -- may be NULL
*/ <br>
char * argDescrip; /* argument description for autohelp */
<br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Each member of
the table defines a single option that may be passed to the
program. Long and short options are considered a single
option that may occur in two different forms. The first two
members, <i>longName</i> and <i>shortName</i>, define the
names of the option; the first is a long name, while the
latter is a single character.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>argInfo</i> member tells popt what type of argument is
expected after the argument. If no option is expected,
<b>POPT_ARG_NONE</b> should be used. The rest of the valid
values are shown in the following table:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-266801.png" alt="Image grohtml-266801.png"></p>

<p style="margin-left:11%; margin-top: 1em">For numeric
values, if the <i>argInfo</i> value is bitwise or&rsquo;d
with one of <b>POPT_ARGFLAG_OR</b>, <b>POPT_ARGFLAG_AND</b>,
or <b>POPT_ARGFLAG_XOR</b>, the value is saved by performing
an OR, AND, or XOR. If the <i>argInfo</i> value is bitwise
or&rsquo;d with <b>POPT_ARGFLAG_NOT</b>, the value will be
negated before saving. For the common operations of setting
and/or clearing bits, <b>POPT_BIT_SET</b> and
<b>POPT_BIT_CLR</b> have the appropriate flags set to
perform bit operations.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>argInfo</i> value is bitwise or&rsquo;d with
<b>POPT_ARGFLAG_ONEDASH</b>, the long argument may be given
with a single - instead of two. For example, if
<b>--longopt</b> is an option with
<b>POPT_ARGFLAG_ONEDASH</b>, is specified, <b>-longopt</b>
is accepted as well.</p>

<p style="margin-left:11%; margin-top: 1em">The next
element, <i>arg</i>, allows popt to automatically update
program variables when the option is used. If <i>arg</i> is
<b>NULL</b>, it is ignored and popt takes no special action.
Otherwise it should point to a variable of the type
indicated in the right-most column of the table above.</p>

<p style="margin-left:11%; margin-top: 1em">If the option
takes no argument (<i>argInfo</i> is <b>POPT_ARG_NONE</b>),
the variable pointed to by <i>arg</i> is set to 1 when the
option is used. (Incidentally, it will perhaps not escape
the attention of hunt-and-peck typists that the value of
<b>POPT_ARG_NONE</b> is 0.) If the option does take an
argument, the variable that <i>arg</i> points to is updated
to reflect the value of the argument. Any string is
acceptable for <b>POPT_ARG_STRING</b> arguments, but
<b>POPT_ARG_INT</b>, <b>POPT_ARG_LONG</b>,
<b>POPT_ARG_FLOAT</b>, and <b>POPT_ARG_DOUBLE</b> are
converted to the appropriate type, and an error returned if
the conversion fails.</p>


<p style="margin-left:11%; margin-top: 1em"><b>POPT_ARG_VAL</b>
causes <i>arg</i> to be set to the (integer) value of
<i>val</i> when the argument is found. This is most often
useful for mutually-exclusive arguments in cases where it is
not an error for multiple arguments to occur and where you
want the last argument specified to win; for example,
&quot;rm -i -f&quot;. <b>POPT_ARG_VAL</b> causes the parsing
function not to return a value, since the value of
<i>val</i> has already been used.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>argInfo</i> value is bitwise or&rsquo;d with
<b>POPT_ARGFLAG_OPTIONAL</b>, the argument to the long
option may be omitted. If the long option is used without an
argument, a default value of zero or NULL will be saved (if
the arg pointer is present), otherwise behavior will be
identical to a long option with argument.</p>

<p style="margin-left:11%; margin-top: 1em">The next
option, <i>val</i>, is the value popt&rsquo;s parsing
function should return when the option is encountered. If it
is 0, the parsing function does not return a value, instead
parsing the next command-line argument.</p>

<p style="margin-left:11%; margin-top: 1em">The last two
options, <i>descrip</i> and <i>argDescrip</i> are only
required if automatic help messages are desired (automatic
usage messages can be generated without them).
<i>descrip</i> is a text description of the argument and
<i>argdescrip</i> is a short summary of the type of
arguments the option expects, or NULL if the option
doesn&rsquo;t require any arguments.</p>

<p style="margin-left:11%; margin-top: 1em">If popt should
automatically provide <b>--usage</b> and <b>--help</b>
(<b>-?</b>) options, one line in the table should be the
macro <b>POPT_AUTOHELP</b>. This macro includes another
option table (via <b>POPT_ARG_INCLUDE_TABLE;</b> see below)
in the main one which provides the table entries for these
arguments. When <b>--usage</b> or <b>--help</b> are passed
to programs which use popt&rsquo;s automatical help, popt
displays the appropriate message on stderr as soon as it
finds the option, and exits the program with a return code
of 0. If you want to use popt&rsquo;s automatic help
generation in a different way, you need to explicitly add
the option entries to your programs option table instead of
using <b>POPT_AUTOHELP</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>argInfo</i> value is bitwise or&rsquo;d with
<b>POPT_ARGFLAG_DOC_HIDDEN</b>, the argument will not be
shown in help output.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>argInfo</i> value is bitwise or&rsquo;d with
<b>POPT_ARGFLAG_SHOW_DEFAULT</b>, the inital value of the
arg will be shown in help output.</p>

<p style="margin-left:11%; margin-top: 1em">The final
structure in the table should have all the pointer values
set to <b>NULL</b> and all the arithmetic values set to 0,
marking the end of the table. The macro <b>POPT_TABLEEND</b>
is provided to do that.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
types of option table entries which do not specify command
line options. When either of these types of entries are
used, the <i>longName</i> element must be <b>NULL</b> and
the <b>shortName</b> element must be
<b>&rsquo;\0&rsquo;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The first of
these special entry types allows the application to nest
another option table in the current one; such nesting may
extend quite deeply (the actual depth is limited by the
program&rsquo;s stack). Including other option tables allows
a library to provide a standard set of command-line options
to every program which uses it (this is often done in
graphical programming toolkits, for example). To do this,
set the <i>argInfo</i> field to
<b>POPT_ARG_INCLUDE_TABLE</b> and the arg field to point to
the table which is being included. If automatic help
generation is being used, the <i>descrip</i> field should
contain a overall description of the option table being
included.</p>

<p style="margin-left:11%; margin-top: 1em">The other
special option table entry type tells popt to call a
function (a callback) when any option in that table is
found. This is especially usefull when included option
tables are being used, as the program which provides the
top-level option table doesn&rsquo;t need to be aware of the
other options which are provided by the included table. When
a callback is set for a table, the parsing function never
returns information on an option in the table. Instead,
options information must be retained via the callback or by
having popt set a variable through the option&rsquo;s
<i>arg</i> field. Option callbacks should match the
following prototype:</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
poptCallbackType(poptContext con, <br>
const struct poptOption * opt, <br>
const char * arg, void * data);</b></p>

<p style="margin-left:11%; margin-top: 1em">The first
parameter is the context which is being parsed (see the next
section for information on contexts), <i>opt</i> points to
the option which triggered this callback, and <i>arg</i> is
the option&rsquo;s argument. If the option does not take an
argument, <i>arg</i> is <b>NULL</b>. The final parameter,
<i>data</i> is taken from the <i>descrip</i> field of the
option table entry which defined the callback. As
<i>descrip</i> is a pointer, this allows callback functions
to be passed an arbitrary set of data (though a typecast
will have to be used).</p>

<p style="margin-left:11%; margin-top: 1em">The option
table entry which defines a callback has an <i>argInfo</i>
of <b>POPT_ARG_CALLBACK</b>, an <i>arg</i> which points to
the callback function, and a <i>descrip</i> field which
specifies an arbitrary pointer to be passed to the
callback.</p>

<p style="margin-left:11%; margin-top: 1em"><b>2. CREATING
A CONTEXT</b> <br>
popt can interleave the parsing of multiple command-line
sets. It allows this by keeping all the state information
for a particular set of command-line arguments in a
<b>poptContext</b> data structure, an opaque type that
should not be modified outside the popt library.</p>

<p style="margin-left:11%; margin-top: 1em">New popt
contexts are created by <b>poptGetContext()</b>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>poptContext
poptGetContext(const char *</b> <i>name</i><b>, int</b>
<i>argc</i><b>, <br>
const char **</b> <i>argv</i><b>, <br>
const struct poptOption *</b> <i>options</i><b>, <br>
int</b> <i>flags</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The first
parameter, <i>name</i>, is used only for alias handling
(discussed later). It should be the name of the application
whose options are being parsed, or should be <b>NULL</b> if
no option aliasing is desired. The next two arguments
specify the command-line arguments to parse. These are
generally passed to <b>poptGetContext()</b> exactly as they
were passed to the program&rsquo;s <b>main()</b> function.
The <i>options</i> parameter points to the table of
command-line options, which was described in the previous
section. The final parameter, <i>flags</i>, can take one of
three values:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-266802.png" alt="Image grohtml-266802.png"></p>

<p style="margin-left:11%; margin-top: 1em">A
<b>poptContext</b> keeps track of which options have already
been parsed and which remain, among other things. If a
program wishes to restart option processing of a set of
arguments, it can reset the <b>poptContext</b> by passing
the context as the sole argument to
<b>poptResetContext()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When argument
processing is complete, the process should free the
<b>poptContext</b> as it contains dynamically allocated
components. The <b>poptFreeContext()</b> function takes a
<b>poptContext</b> as its sole argument and frees the
resources the context is using.</p>

<p style="margin-left:11%; margin-top: 1em">Here are the
prototypes of both <b>poptResetContext()</b> and
<b>poptFreeContext()</b>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
void poptFreeContext(poptContext</b> <i>con</i><b>); <br>
void poptResetContext(poptContext</b>
<i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>3. PARSING
THE COMMAND LINE</b> <br>
After an application has created a <b>poptContext</b>, it
may begin parsing arguments. <b>poptGetNextOpt()</b>
performs the actual argument parsing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
int poptGetNextOpt(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">Taking the
context as its sole argument, this function parses the next
command-line argument found. After finding the next argument
in the option table, the function fills in the object
pointed to by the option table entry&rsquo;s <i>arg</i>
pointer if it is not <b>NULL</b>. If the val entry for the
option is non-0, the function then returns that value.
Otherwise, <b>poptGetNextOpt()</b> continues on to the next
argument.</p>


<p style="margin-left:11%; margin-top: 1em"><b>poptGetNextOpt()</b>
returns -1 when the final argument has been parsed, and
other negative values when errors occur. This makes it a
good idea to keep the <i>val</i> elements in the options
table greater than 0.</p>

<p style="margin-left:11%; margin-top: 1em">If all of the
command-line options are handled through <i>arg</i>
pointers, command-line parsing is reduced to the following
line of code:</p>

<p style="margin-left:11%; margin-top: 1em">rc =
poptGetNextOpt(poptcon);</p>

<p style="margin-left:11%; margin-top: 1em">Many
applications require more complex command-line parsing than
this, however, and use the following structure:</p>

<p style="margin-left:11%; margin-top: 1em">while ((rc =
poptGetNextOpt(poptcon)) &gt; 0) { <br>
switch (rc) { <br>
/* specific arguments are handled here */ <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">When returned
options are handled, the application needs to know the value
of any arguments that were specified after the option. There
are two ways to discover them. One is to ask popt to fill in
a variable with the value of the option through the option
table&rsquo;s <i>arg</i> elements. The other is to use
<b>poptGetOptArg()</b>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
char * poptGetOptArg(poptContext</b> <i>con</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the argument given for the final option returned by
<b>poptGetNextOpt()</b>, or it returns <b>NULL</b> if no
argument was specified. The calling function is responsible
for deallocating this string.</p>

<p style="margin-left:11%; margin-top: 1em"><b>4. LEFTOVER
ARGUMENTS</b> <br>
Many applications take an arbitrary number of command-line
arguments, such as a list of file names. When popt
encounters an argument that does not begin with a -, it
assumes it is such an argument and adds it to a list of
leftover arguments. Three functions allow applications to
access such arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="63%">


<p style="margin-top: 1em"><b>const char *
poptGetArg(poptContext</b> <i>con</i><b>);</b></p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:22%;">This function returns the next
leftover argument and marks it as processed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="64%">


<p style="margin-top: 1em"><b>const char *
poptPeekArg(poptContext</b> <i>con</i><b>);</b></p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:22%;">The next leftover argument is
returned but not marked as processed. This allows an
application to look ahead into the argument list, without
modifying the list.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p style="margin-top: 1em"><b>const char **
poptGetArgs(poptContext</b> <i>con</i><b>);</b></p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:22%;">All the leftover arguments are
returned in a manner identical to <i>argv</i>. The final
element in the returned array points to <b>NULL</b>,
indicating the end of the arguments.</p>

<p><b>5. AUTOMATIC HELP MESSAGES</b></p></table>

<p style="margin-left:11%;">The <b>popt</b> library can
automatically generate help messages which describe the
options a program accepts. There are two types of help
messages which can be generated. Usage messages are a short
messages which lists valid options, but does not describe
them. Help messages describe each option on one (or more)
lines, resulting in a longer, but more useful, message.
Whenever automatic help messages are used, the
<b>descrip</b> and <b>argDescrip</b> fields <b>struct
poptOption</b> members should be filled in for each
option.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>POPT_AUTOHELP</b> macro makes it easy to add
<b>--usage</b> and <b>--help</b> messages to your program,
and is described in part 1 of this man page. If more control
is needed over your help messages, the following two
functions are available:</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
void poptPrintHelp(poptContext</b> <i>con</i><b>, FILE *</b>
<i>f</i><b>, int</b> <i>flags</i><b>); <br>
void poptPrintUsage(poptContext</b> <i>con</i><b>, FILE
*</b> <i>f</i><b>, int</b> <i>flags</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>poptPrintHelp()</b>
displays the standard help message to the stdio file
descriptor f, while <b>poptPrintUsage()</b> displays the
shorter usage message. Both functions currently ignore the
<b>flags</b> argument; it is there to allow future
changes.</p>

<h2>ERROR HANDLING
<a name="ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of the popt
functions that can return errors return integers. When an
error occurs, a negative error code is returned. The
following table summarizes the error codes that occur:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Error
Description <br>
POPT_ERROR_NOARG</b> Argument missing for an option. <b><br>
POPT_ERROR_BADOPT</b> Option&rsquo;s argument couldn&rsquo;t
be parsed. <b><br>
POPT_ERROR_OPTSTOODEEP</b> Option aliasing nested too
deeply. <b><br>
POPT_ERROR_BADQUOTE</b> Quotations do not match. <b><br>
POPT_ERROR_BADNUMBER</b> Option couldn&rsquo;t be converted
to number. <b><br>
POPT_ERROR_OVERFLOW</b> A given number was too big or
small.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a more
detailed discussion of each error: <b><br>
POPT_ERROR_NOARG</b></p>

<p style="margin-left:22%;">An option that requires an
argument was specified on the command line, but no argument
was given. This can be returned only by
<b>poptGetNextOpt()</b>.</p>

<p style="margin-left:11%;"><b>POPT_ERROR_BADOPT</b></p>

<p style="margin-left:22%;">An option was specified in
<i>argv</i> but is not in the option table. This error can
be returned only from <b>poptGetNextOpt()</b>.</p>


<p style="margin-left:11%;"><b>POPT_ERROR_OPTSTOODEEP</b></p>

<p style="margin-left:22%;">A set of option aliases is
nested too deeply. Currently, popt follows options only 10
levels to prevent infinite recursion. Only
<b>poptGetNextOpt()</b> can return this error.</p>

<p style="margin-left:11%;"><b>POPT_ERROR_BADQUOTE</b></p>

<p style="margin-left:22%;">A parsed string has a quotation
mismatch (such as a single quotation mark).
<b>poptParseArgvString()</b>, <b>poptReadConfigFile()</b>,
or <b>poptReadDefaultConfig()</b> can return this error.</p>


<p style="margin-left:11%;"><b>POPT_ERROR_BADNUMBER</b></p>

<p style="margin-left:22%;">A conversion from a string to a
number (int or long) failed due to the string containing
nonnumeric characters. This occurs when
<b>poptGetNextOpt()</b> is processing an argument of type
<b>POPT_ARG_INT</b>, <b>POPT_ARG_LONG</b>,
POPT_ARG_FLOAT<b>, or</b> POPT_ARG_DOUBLE<b>.</b></p>

<p style="margin-left:11%;"><b>POPT_ERROR_OVERFLOW</b></p>

<p style="margin-left:22%;">A string-to-number conversion
failed because the number was too large or too small. Like
<b>POPT_ERROR_BADNUMBER</b>, this error can occur only when
<b>poptGetNextOpt()</b> is processing an argument of type
<b>POPT_ARG_INT</b>, <b>POPT_ARG_LONG</b>,
POPT_ARG_FLOAT<b>, or</b> POPT_ARG_DOUBLE<b>.</b></p>

<p style="margin-left:11%;"><b>POPT_ERROR_ERRNO</b></p>

<p style="margin-left:22%;">A system call returned with an
error, and <i>errno</i> still contains the error from the
system call. Both <b>poptReadConfigFile()</b> and
<b>poptReadDefaultConfig()</b> can return this error.</p>

<p style="margin-left:11%; margin-top: 1em">Two functions
are available to make it easy for applications to provide
good error messages.</p>

<p style="margin-left:22%; margin-top: 1em"><b>const char
*const poptStrerror(const int</b> <i>error</i><b>);</b> <br>
This function takes a popt error code and returns a string
describing the error, just as with the standard
<b>strerror()</b> function.</p></table>

<p style="margin-left:22%; margin-top: 1em"><b>const char *
poptBadOption(poptContext</b> <i>con</i><b>, int</b>
<i>flags</i><b>);</b> <br>
If an error occurred during <b>poptGetNextOpt()</b>, this
function returns the option that caused the error. If the
<i>flags</i> argument is set to
<b>POPT_BADOPTION_NOALIAS</b>, the outermost option is
returned. Otherwise, <i>flags</i> should be 0, and the
option that is returned may have been specified through an
alias.</p>

<p style="margin-left:11%; margin-top: 1em">These two
functions make popt error handling trivial for most
applications. When an error is detected from most of the
functions, an error message is printed along with the error
string from <b>poptStrerror()</b>. When an error occurs
during argument parsing, code similiar to the following
displays a useful error message:</p>


<p style="margin-left:11%; margin-top: 1em">fprintf(stderr,
&quot;%s: %s\n&quot;, <br>
poptBadOption(optCon, POPT_BADOPTION_NOALIAS), <br>
poptStrerror(rc));</p>

<h2>OPTION ALIASING
<a name="OPTION ALIASING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One of the
primary benefits of using popt over <b>getopt()</b> is the
ability to use option aliasing. This lets the user specify
options that popt expands into other options when they are
specified. If the standard grep program made use of popt,
users could add a <b>--text</b> option that expanded to
<b>-i -n -E -2</b> to let them more easily find information
in text files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>1.
SPECIFYING ALIASES</b> <br>
Aliases are normally specified in two places:
<i>/etc/popt</i> and the <b>.popt</b> file in the
user&rsquo;s home directory (found through the <b>HOME</b>
environment variable). Both files have the same format, an
arbitrary number of lines formatted like this:</p>

<p style="margin-left:11%; margin-top: 1em"><i>appname</i>
<b>alias</b> <i>newoption expansion</i></p>

<p style="margin-left:11%; margin-top: 1em">The
<i>appname</i> is the name of the application, which must be
the same as the <i>name</i> parameter passed to
<b>poptGetContext()</b>. This allows each file to specify
aliases for multiple programs. The <b>alias</b> keyword
specifies that an alias is being defined; currently popt
configuration files support only aliases, but other
abilities may be added in the future. The next option is the
option that should be aliased, and it may be either a short
or a long option. The rest of the line specifies the
expansion for the alias. It is parsed similarly to a shell
command, which allows \, &quot;, and &rsquo; to be used for
quoting. If a backslash is the final character on a line,
the next line in the file is assumed to be a logical
continuation of the line containing the backslash, just as
in shell.</p>

<p style="margin-left:11%; margin-top: 1em">The following
entry would add a <b>--text</b> option to the grep command,
as suggested at the beginning of this section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>grep alias
--text -i -n -E -2</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>2. ENABLING
ALIASES</b> <br>
An application must enable alias expansion for a
<b>poptContext</b> before calling <b>poptGetNextArg()</b>
for the first time. There are three functions that define
aliases for a context:</p></table>

<p style="margin-left:22%; margin-top: 1em"><b>int
poptReadDefaultConfig(poptContext</b> <i>con</i><b>, int</b>
<i>flags</i><b>);</b> <br>
This function reads aliases from <i>/etc/popt</i> and the
<b>.popt</b> file in the user&rsquo;s home directory.
Currently, <i>flags</i> should be <b>NULL</b>, as it is
provided only for future expansion.</p></table>

<p style="margin-left:22%; margin-top: 1em"><b>int
poptReadConfigFile(poptContext</b> <i>con</i><b>, char *</b>
<i>fn</i><b>);</b> <br>
The file specified by <i>fn</i> is opened and parsed as a
popt configuration file. This allows programs to use
program-specific configuration files.</p></table>

<p style="margin-left:22%; margin-top: 1em"><b>int
poptAddAlias(poptContext</b> <i>con</i><b>, struct
poptAlias</b> <i>alias</i><b>, <br>
int</b> <i>flags</i><b>);</b> <br>
Occasionally, processes want to specify aliases without
having to read them from a configuration file. This function
adds a new alias to a context. The <i>flags</i> argument
should be 0, as it is currently reserved for future
expansion. The new alias is specified as a <b>struct
poptAlias</b>, which is defined as:</p>

<p style="margin-left:22%; margin-top: 1em">struct
poptAlias { <br>
const char * longName; /* may be NULL */ <br>
char shortName; /* may be &rsquo;\0&rsquo; */ <br>
int argc; <br>
const char ** argv; /* must be free()able */ <br>
};</p>

<p style="margin-left:22%; margin-top: 1em">The first two
elements, <i>longName</i> and <i>shortName</i>, specify the
option that is aliased. The final two, <i>argc</i> and
<i>argv</i>, define the expansion to use when the aliases
option is encountered.</p>

<h2>PARSING ARGUMENT STRINGS
<a name="PARSING ARGUMENT STRINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although popt
is usually used for parsing arguments already divided into
an <i>argv</i>-style array, some programs need to parse
strings that are formatted identically to command lines. To
facilitate this, popt provides a function that parses a
string into an array of strings, using rules similiar to
normal shell parsing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
int poptParseArgvString(char *</b> <i>s</i><b>, int *</b>
<i>argcPtr</i><b>, <br>
char ***</b> <i>argvPtr</i><b>); <br>
int poptDupArgv(int</b> <i>argc</i><b>, const char **</b>
<i>argv</i><b>, int *</b> <i>argcPtr</i><b>, <br>
const char ***</b> <i>argvPtr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The string s is
parsed into an <i>argv</i>-style array. The integer pointed
to by the <i>argcPtr</i> parameter contains the number of
elements parsed, and the final <i>argvPtr</i> parameter
contains the address of the newly created array. The routine
<b>poptDupArgv()</b> can be used to make a copy of an
existing argument array.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>argvPtr</i> created by <b>poptParseArgvString()</b> or
<b>poptDupArgv()</b> is suitable to pass directly to
<b>poptGetContext()</b>. Both routines return a single
dynamically allocated contiguous block of storage and should
be <b>free()</b>ed when the application is finished with the
storage.</p>

<h2>HANDLING EXTRA ARGUMENTS
<a name="HANDLING EXTRA ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some
applications implement the equivalent of option aliasing but
need to do so through special logic. The
<b>poptStuffArgs()</b> function allows an application to
insert new arguments into the current
<b>poptContext</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;popt.h&gt; <br>
int poptStuffArgs(poptContext</b> <i>con</i><b>, const char
**</b> <i>argv</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">The passed
<i>argv</i> must have a <b>NULL</b> pointer as its final
element. When <b>poptGetNextOpt()</b> is next called, the
&quot;stuffed&quot; arguments are the first to be parsed.
popt returns to the normal arguments once all the stuffed
arguments have been exhausted.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
example is a simplified version of the program
&quot;robin&quot; which appears in Chapter 15 of the text
cited below. Robin has been stripped of everything but its
argument-parsing logic, slightly reworked, and renamed
&quot;parse.&quot; It may prove useful in illustrating at
least some of the features of the extremely rich popt
library.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;popt.h&gt; <br>
#include &lt;stdio.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">void
usage(poptContext optCon, int exitcode, char *error, char
*addl) { <br>
poptPrintUsage(optCon, stderr, 0); <br>
if (error) fprintf(stderr, &quot;%s: %s0, error, addl); <br>
exit(exitcode); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int main(int
argc, char *argv[]) { <br>
char c; /* used for argument parsing */ <br>
int i = 0; /* used for tracking options */ <br>
char *portname; <br>
int speed = 0; /* used in argument parsing to set speed */
<br>
int raw = 0; /* raw mode? */ <br>
int j; <br>
char buf[BUFSIZ+1]; <br>
poptContext optCon; /* context for parsing command-line
options */</p>

<p style="margin-left:11%; margin-top: 1em">struct
poptOption optionsTable[] = {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;bps&quot;, &rsquo;b&rsquo;, POPT_ARG_INT,
&amp;speed, 0,</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;signaling rate in bits-per-second&quot;,
&quot;BPS&quot; },</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;crnl&quot;, &rsquo;c&rsquo;, 0, 0,
&rsquo;c&rsquo;,</p> </td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;expand cr characters to cr/lf sequences&quot;
},</p> </td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;hwflow&quot;, &rsquo;h&rsquo;, 0, 0,
&rsquo;h&rsquo;,</p> </td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;use hardware (RTS/CTS) flow control&quot; },</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;noflow&quot;, &rsquo;n&rsquo;, 0, 0,
&rsquo;n&rsquo;,</p> </td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;use no flow control&quot; },</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;raw&quot;, &rsquo;r&rsquo;, 0, &amp;raw, 0,</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;don&rsquo;t perform any character
conversions&quot; },</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ &quot;swflow&quot;, &rsquo;s&rsquo;, 0, 0,
&rsquo;s&rsquo;,</p> </td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">
</td>
<td width="8%">


<p>&quot;use software (XON/XOF) flow control&quot; } ,</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>POPT_AUTOHELP</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="52%">


<p>{ NULL, 0, 0, NULL, 0 }</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:11%;">};</p>

<p style="margin-left:11%; margin-top: 1em">optCon =
poptGetContext(NULL, argc, argv, optionsTable, 0); <br>
poptSetOtherOptionHelp(optCon, &quot;[OPTIONS]*
&lt;port&gt;&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">if (argc &lt;
2) {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%"></td>
<td width="60%">


<p>poptPrintUsage(optCon, stderr, 0);</p></td></tr>
<tr valign="top" align="left">
<td width="40%"></td>
<td width="60%">


<p>exit(1);</p></td></tr>
</table>

<p style="margin-left:11%;">}</p>

<p style="margin-left:11%; margin-top: 1em">/* Now do
options processing, get portname */ <br>
while ((c = poptGetNextOpt(optCon)) &gt;= 0) { <br>
switch (c) { <br>
case &rsquo;c&rsquo;: <br>
buf[i++] = &rsquo;c&rsquo;; <br>
break; <br>
case &rsquo;h&rsquo;: <br>
buf[i++] = &rsquo;h&rsquo;; <br>
break; <br>
case &rsquo;s&rsquo;: <br>
buf[i++] = &rsquo;s&rsquo;; <br>
break; <br>
case &rsquo;n&rsquo;: <br>
buf[i++] = &rsquo;n&rsquo;; <br>
break; <br>
} <br>
} <br>
portname = poptGetArg(optCon); <br>
if((portname == NULL) || !(poptPeekArg(optCon) == NULL))
<br>
usage(optCon, 1, &quot;Specify a single port&quot;,
&quot;.e.g., /dev/cua0&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">if (c &lt; -1)
{ <br>
/* an error occurred during option processing */ <br>
fprintf(stderr, &quot;%s: %s\n&quot;, <br>
poptBadOption(optCon, POPT_BADOPTION_NOALIAS), <br>
poptStrerror(c)); <br>
return 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Print out
options, portname chosen */ <br>
printf(&quot;Options chosen: &quot;); <br>
for(j = 0; j &lt; i ; j++) <br>
printf(&quot;-%c &quot;, buf[j]); <br>
if(raw) printf(&quot;-r &quot;); <br>
if(speed) printf(&quot;-b %d &quot;, speed); <br>
printf(&quot;\nPortname chosen: %s\n&quot;, portname);</p>


<p style="margin-left:11%; margin-top: 1em">poptFreeContext(optCon);
<br>
exit(0); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">RPM, a popular
Linux package management program, makes heavy use of
popt&rsquo;s features. Many of its command-line arguments
are implemented through popt aliases, which makes RPM an
excellent example of how to take advantage of the popt
library. For more information on RPM, see
http://www.rpm.org. The popt source code distribution
includes test program(s) which use all of the features of
the popt libraries in various ways. If a feature isn&rsquo;t
working for you, the popt test code is the first place to
look.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None presently
known.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Erik W. Troan
&lt;ewt@redhat.com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">This man page
is derived in part from <i>Linux Application Development</i>
by Michael K. Johnson and Erik W. Troan, Copyright (c) 1998
by Addison Wesley Longman, Inc., and included in the popt
documentation with the permission of the Publisher and the
appreciation of the Authors.</p>

<p style="margin-left:11%; margin-top: 1em">Thanks to
Robert Lynch for his extensive work on this man page.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>getopt</b>(3)</p>

<p style="margin-left:11%; margin-top: 1em"><i>Linux
Application Development</i>, by Michael K. Johnson and Erik
W. Troan (Addison-Wesley, 1998; ISBN 0-201-30821-5), Chapter
24.</p>

<p style="margin-left:11%; margin-top: 1em"><b>popt.ps</b>
is a Postscript version of the above cited book chapter. It
can be found in the source archive for popt available at:
ftp://ftp.rpm.org/pub/rpm.</p>
<hr>
</body>
</html>
