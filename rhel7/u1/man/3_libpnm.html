<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:01:48 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>User manual for old pnm functions</title>

</head>
<body>

<h1 align="center">User manual for old pnm functions</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libpnm -
libnetpbm functions to read and write PNM image files</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;netpbm/pnm.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_init( int *</b><i>argcP</i><b>, char
*</b><i>argv</i><b>[] );</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel **
pnm_allocarray( int</b> <i>cols</i><b>, int</b>
<i>rows</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel *
pnm_allocrow( int</b> <i>cols</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_freearray( xel **</b><i>xels</i><b>, int</b>
<i>rows</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_freerow( xel *</b><i>xelrow</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_readpnminit( FILE *</b><i>fp</i><b>, int
*</b><i>colsP</i><b>, int *</b><i>rowsP</i><b>, xelval
*</b><i>maxvalP</i><b>, int *</b><i>formatP</i>
<b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_readpnmrow( FILE *</b><i>fp</i><b>, xel
*</b><i>xelrow</i><b>, int</b> <i>cols</i><b>, xelval</b>
<i>maxval</i><b>, int</b> <i>format</i> <b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel **
pnm_readpnm( FILE *</b><i>fp</i><b>, int
*</b><i>colsP</i><b>, int *</b><i>rowsP</i><b>, xelval
*</b><i>maxvalP</i><b>, int</b><i>*</i> <b>formatP</b>
<i>);</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_writepnminit( FILE * fp , int</b> <i>cols</i><b>,
int</b> <i>rows</i><b>, xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>, int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_writepnmrow( FILE *</b><i>fp</i><b>, xel
*</b><i>xelrow</i><b>, int cols</b><i>,</i> <b>xelval</b>
<i>maxval</i><b>, int</b> <i>format</i><b>, int</b>
<i>forceplain</i> <b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_writepnm( FILE *</b><i>fp</i><b>, xel **</b>
<i>xels</i><b>, int</b> <i>cols</i><b>, int</b>
<i>rows</i><b>, xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>, int</b> <i>forceplain</i> <b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_nextimage(FILE *</b> <i>file</i><b>, <br>
int * const</b> <i>eofP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_check( FILE *</b> <i>file</i><b>, const enum
pm_check_type</b> <i>check_type</i><b>, const int</b>
<i>format</i><b>, const int</b> <i>cols</i><b>, const
int</b> <i>rows</i><b>, const xelval</b> <i>maxval</i><b>,
enum pm_check_code *</b><i>retvalP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_promoteformatrow( xel *</b><i>xelrow</i><b>, int</b>
<i>cols</i><b>, xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>, xelval</b> <i>newmaxval</i><b>, int</b>
<i>newformat</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_promoteformat( xel **</b><i>xels</i><b>, int</b>
<i>cols</i><b>, xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>, xelval</b> <i>newmaxval</i><b>, int</b>
<i>newformat</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel
pnm_whitexel( xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel
pnm_blackxel( xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pnm_invertxel( xel *</b><i>x</i><b>, xelval</b>
<i>maxval</i><b>, int</b> <i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel
pnm_backgroundxelrow( xel *</b><i>xelrow</i><b>, int</b>
<i>cols</i><b>, xelval</b> <i>maxval</i><b>, int</b>
<i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>xel
pnm_backgroundxel( xel **</b><i>xels</i><b>, int</b>
<i>cols</i><b>, int</b> <i>rows</i><b>, xelval</b>
<i>maxval</i><b>, int</b> <i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef ...
xelval;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef ...
xel;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PNM_ASSIGN1(</b><i>x</i><b>,</b><i>v</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PNM_GET1(</b><i>x</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PNM_EQUAL(</b><i>x</i><b>,</b><i>y</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PNM_FORMAT_TYPE(</b><i>format</i><b>) ...</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These library
functions are part of <b>Netpbm</b>(1)</p>

<p style="margin-left:11%; margin-top: 1em"><b>TYPES AND
CONSTANTS</b> <br>
Each <b>xel</b> contains three <b>xelval</b>s, each of which
should contain only the values between <b>0</b> and
<b>PNM_MAXMAXVAL</b>, inclusive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>XEL
MANIPULATIONS</b> <br>
The <b>PNM_GET1</b> macro extracts a single value from an
xel, when ou know it&rsquo;s from a PBM or PGM file. When
it&rsquo;s from a PPM file, use <b>PPM_GETR()</b>,
<b>PPM_GETG()</b>, and <b>PPM_GETB()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PNM_ASSIGN1</b> macro assigns a single value to an xel,
when you know it&rsquo;s from a PBM or PGM file. When
it&rsquo;s from a PPM file, use <b>PPM_ASSIGN</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PNM_EQUAL</b> macro checks two xels for equality. The
<b>PNM_FORMAT_TYPE</b> macro computes a format type code
from a format code. The format types are PBM, PGM, PPM, and
PAM. But note that PBM, PGM, and PPM each are two different
formats: a plain one and a raw one. So there are four format
types, but seven formats. <b>PNM_FORMAT_TYPE</b> does not
work on the PAM format code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_whitexel()</b>
and <b>pnm_blackxel()</b> return a white or black xel,
respectively, for the given <i>maxval</i> and
<i>format</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_invertxel()</b>
inverts an xel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INITIALIZATION
<br>
pnm_init()</b> is obsolete (at least since Netpbm 9.25
(March 2002)). Use
<a href="libpm.html#initialization"><b>pm_proginit()</b></a>
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_init()</b>
is identical to <b>pm_proginit</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MEMORY
MANAGEMENT <br>
pnm_allocarray()</b> allocates space for an array of xels.
<b>pnm_freearray()</b> frees an array space allocated by
<b>pnm_allocarray()</b> or <b>pnm_readpnm()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_allocrow()</b>
allocates space for a row of a PNM image.
<b>pnm_freerow()</b> frees it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>READING PNM
FILES <br>
pnm_readpnminit()</b> is similar to
<b>pnm_readpaminit()</b>, but reads only PNM images and has
a different parameter list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_readpnmrow()</b>
is similar to <b>pnm_readpamrow()</b> but only works on PNM
images and has a different parameter list and returns the
row as an array of xels instead of tuples.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_readpnm()</b>
is similar to <b>pnm_readpam()</b> except that it reads only
PNM images and uses a different parameter list and returns
an array of rows such that <b>pnm_readpnmrow()</b> would
return rather than such that <b>pnm_readpamrow()</b> would
return.</p>

<p style="margin-left:11%; margin-top: 1em"><b>WRITING
FILES <br>
pnm_writepnminit()</b> is similar to
<b>pnm_writepaminit()</b> except that it can write only a
PNM header and has a different parameter list.</p>


<p style="margin-left:11%; margin-top: 1em"><i>forceplain</i>
is a binary value. True (nonzero) means to write the image
in the plain (ASCII) version of the selected format. False
(zero) means to write it in the raw (binary) version of the
selected format. See
<b>PNM</b>format<b>specification</b>(1)</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_writepnmrow()</b>
is similar to <b>pnm_writepamrow()</b> except that it works
only on PNM images and has a different parameter list and
takes an array of xels instead of an array of tuples. See
the description of <i>forceplain</i> above.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_writepnm()</b>
is similar to <b>pnm_writepam()</b> except that it works
only on PNM image, has a different parameter list, and takes
an array of rows of xels instead of an array of rows of
tuples. See the description of <i>forceplain</i> above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FORMAT
PROMOTION <br>
pnm_promoteformatrow()</b> promotes a row of xels from one
maxval and format to a new set. Use this when you are
combining multiple anymaps of different types - just take
the maximum of the maxvals and the maximum of the formats,
and promote them all to that.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_promoteformat()</b>
promotes an entire anymap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MISCELLANEOUS
<br>
pnm_nextimage()</b> positions a PNM input file to the next
image in it (so that a subsequent <b>pnm_readpnminit()</b>
reads its header).</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_nextimage()</b>
is analogous to <b>pbm_nextimage()</b>, but works on PPM,
PGM, and PBM files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_check()</b>
is similar to <b>pnm_checkpam()</b> except it works only on
PNM images.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_check()</b>
is identical to <b>ppm_check()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_backgroundxelrow()</b>
figures out an appropriate background xel based on the row
of xels <i>xelrow</i>, which is <i>cols</i> xels wide, has
maxval <i>maxval</i>, and represents an image with format
<i>format</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This estimate
works best when the row is the top or bottom row of the
image.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pnm_backgroundxel()</b>
does the same thing as <b>pnm_backgroundxelrow()</b>, except
based on an entire image instead of just one row. This tends
to do a slightly better job than
<b>pnmbackgroundxelrow()</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Libnetpbm</b>(1)
, <b>Libnetpbm</b>User&rsquo;s<b>Guide</b>(1) ,
<b>Libnetpbm</b>Directory<b>(1)</b> , <b>pbm</b>(1) ,
<b>pgm</b>(1) , <b>ppm</b>(1) , <b>pam</b>(1) ,
<b>libpbm</b>(1) , <b>libpgm</b>(1) , <b>libppm</b>(1)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
1989, 1991 by Tony Hansen and Jef Poskanzer.</p>
<hr>
</body>
</html>
