<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:30:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STATES</title>

</head>
<body>

<h1 align="center">STATES</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#STATES PROGRAM FILES">STATES PROGRAM FILES</a><br>
<a href="#PRIMITIVE FUNCTIONS">PRIMITIVE FUNCTIONS</a><br>
<a href="#BUILTIN VARIABLES">BUILTIN VARIABLES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">states &minus;
awk alike text processing tool</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>states</b>
[<b>&minus;hvV</b>] [<b>&minus;D</b>
<i>var</i><b>=</b><i>val</i>] [<b>&minus;f</b> <i>file</i>]
[<b>&minus;o</b> <i>outputfile</i>] [<b>&minus;p</b>
<i>path</i>] [<b>&minus;s</b> <i>startstate</i>]
[<b>&minus;W</b> <i>level</i>] [<i>filename</i> ...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>States</b>
is an awk-alike text processing tool with some state machine
extensions. It is designed for program source code
highlighting and to similar tasks where state information
helps input processing.</p>

<p style="margin-left:11%; margin-top: 1em">At a single
point of time, <b>States</b> is in one state, each quite
similar to awk&rsquo;s work environment, they have regular
expressions which are matched from the input and actions
which are executed when a match is found. From the action
blocks, <b>states</b> can perform state transitions; it can
move to another state from which the processing is
continued. State transitions are recorded so <b>states</b>
can return to the calling state once the current state has
finished.</p>

<p style="margin-left:11%; margin-top: 1em">The biggest
difference between <b>states</b> and awk, besides state
machine extensions, is that <b>states</b> is not
line-oriented. It matches regular expression tokens from the
input and once a match is processed, it continues processing
from the current position, not from the beginning of the
next input line.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;D</b>
<i>var</i><b>=</b><i>val</i><b>,
&minus;&minus;define=</b><i>var</i><b>=</b><i>val</i></p>

<p style="margin-left:23%;">Define variable <i>var</i> to
have string value <i>val</i>. Command line definitions
overwrite variable definitions found from the config
file.</p>

<p style="margin-left:11%;"><b>&minus;f</b> <i>file</i><b>,
&minus;&minus;file=</b><i>file</i></p>

<p style="margin-left:23%;">Read state definitions from
file <i>file</i>. As a default, <b>states</b> tries to read
state definitions from file <b>states.st</b> in the current
working directory.</p>

<p style="margin-left:11%;"><b>&minus;h,
&minus;&minus;help</b></p>

<p style="margin-left:23%;">Print short help message and
exit.</p>

<p style="margin-left:11%;"><b>&minus;o</b> <i>file</i><b>,
&minus;&minus;output=</b><i>file</i></p>

<p style="margin-left:23%;">Save output to file <i>file</i>
instead of printing it to <b>stdout</b>.</p>

<p style="margin-left:11%;"><b>&minus;p</b> <i>path</i><b>,
&minus;&minus;path=</b><i>path</i></p>

<p style="margin-left:23%;">Set the load path to
<i>path</i>. The load path defaults to the directory, from
which the state definitions file is loaded.</p>

<p style="margin-left:11%;"><b>&minus;s</b>
<i>state</i><b>, &minus;&minus;state=</b><i>state</i></p>

<p style="margin-left:23%;">Start execution from state
<b>state</b>. This definition overwrites start state
resolved from the <b>start</b> block.</p>

<p style="margin-left:11%;"><b>&minus;v,
&minus;&minus;verbose</b></p>

<p style="margin-left:23%;">Increase the program
verbosity.</p>

<p style="margin-left:11%;"><b>&minus;V,
&minus;&minus;version</b></p>

<p style="margin-left:23%;">Print <b>states</b> version and
exit.</p>

<p style="margin-left:11%;"><b>&minus;W</b>
<i>level</i><b>, &minus;&minus;warning=</b><i>level</i></p>

<p style="margin-left:23%;">Set the warning level to
<i>level</i>. Possible values for <i>level</i> are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="8%">


<p><b>light</b></p></td>
<td width="4%"></td>
<td width="37%">


<p>light warnings (default)</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="8%">


<p><b>all</b></p></td>
<td width="4%"></td>
<td width="37%">


<p>all warnings</p></td>
<td width="28%">
</td></tr>
</table>

<h2>STATES PROGRAM FILES
<a name="STATES PROGRAM FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>States</b>
program files can contain on <i>start</i> block,
<i>startrules</i> and <i>namerules</i> blocks to specify the
initial state, <i>state</i> definitions and
<i>expressions</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>start</i> block is the main() of the <b>states</b>
program, it is executed on script startup for each input
file and it can perform any initialization the script needs.
It normally also calls the <b>check_startrules()</b> and
<b>check_namerules()</b> primitives which resolve the
initial state from the input file name or the data found
from the beginning of the input file. Here is a sample start
block which initializes two variables and does the standard
start state resolving:</p>

<p style="margin-left:22%; margin-top: 1em">start <br>
{ <br>
a = 1; <br>
msg = &quot;Hello, world!&quot;; <br>
check_startrules (); <br>
check_namerules (); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Once the start
block is processed, the input processing is continued from
the initial state.</p>

<p style="margin-left:11%; margin-top: 1em">The initial
state is resolved by the information found from the
<i>startrules</i> and <i>namerules</i> blocks. Both blocks
contain regular expression - symbol pairs, when the regular
expression is matched from the name of from the beginning of
the input file, the initial state is named by the
corresponding symbol. For example, the following start and
name rules can distinguish C and Fortran files:</p>

<p style="margin-left:22%; margin-top: 1em">namerules <br>
{ <br>
/\.(c|h)$/ c; <br>
/\.[fF]$/ fortran; <br>
}</p>

<p style="margin-left:22%; margin-top: 1em">startrules <br>
{ <br>
/-\*- [cC] -\*-/ c; <br>
/-\*- fortran -\*-/ fortran; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If these rules
are used with the previously shown start block,
<b>states</b> first check the beginning of input file. If it
has string <b>-*- c -*-</b>, the file is assumed to contain
C code and the processing is started from state called
<b>c</b>. If the beginning of the input file has string
<b>-*- fortran -*-</b>, the initial state is <b>fortran</b>.
If none of the start rules matched, the name of the input
file is matched with the namerules. If the name ends to
suffix <b>c</b> or <b>C</b>, we go to state <b>c</b>. If the
suffix is <b>f</b> or <b>F</b>, the initial state is
fortran.</p>

<p style="margin-left:11%; margin-top: 1em">If both start
and name rules failed to resolve the start state,
<b>states</b> just copies its input to output
unmodified.</p>

<p style="margin-left:11%; margin-top: 1em">The start state
can also be specified from the command line with option
<b>&minus;s</b>, <b>&minus;&minus;state</b>.</p>

<p style="margin-left:11%; margin-top: 1em">State
definitions have the following syntax:</p>

<p style="margin-left:11%; margin-top: 1em"><b>state {</b>
<i>expr</i> {<i>statements</i>} ... }</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>expr</i> is: a regular expression, special expression or
symbol and <i>statements</i> is a list of statements. When
the expression <i>expr</i> is matched from the input, the
statement block is executed. The statement block can call
<b>states</b>&rsquo; primitives, user-defined subroutines,
call other states, etc. Once the block is executed, the
input processing is continued from the current intput
position (which might have been changed if the statement
block called other states).</p>

<p style="margin-left:11%; margin-top: 1em">Special
expressions <b>BEGIN</b> and <b>END</b> can be used in the
place of <i>expr</i>. Expression <b>BEGIN</b> matches the
beginning of the state, its block is called when the state
is entered. Expression <b>END</b> matches the end of the
state, its block is executed when <b>states</b> leaves the
state.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>expr</i>
is a symbol, its value is looked up from the global
environment and if it is a regular expression, it is matched
to the input, otherwise that rule is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>states</b> program file can also have top-level
expressions, they are evaluated after the program file is
parsed but before any input files are processed or the
<i>start</i> block is evaluated.</p>

<h2>PRIMITIVE FUNCTIONS
<a name="PRIMITIVE FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>call
(</b><i>symbol</i><b>)</b></p>

<p style="margin-left:23%;">Move to state <i>symbol</i> and
continue input file processing from that state. Function
returns whatever the <b>symbol</b> state&rsquo;s terminating
<b>return</b> statement returned.</p>

<p style="margin-left:11%;"><b>calln
(</b><i>name</i><b>)</b></p>

<p style="margin-left:23%;">Like <b>call</b> but the
argument <i>name</i> is evaluated and its value must be
string. For example, this function can be used to call a
state which name is stored to a variable.</p>

<p style="margin-left:11%;"><b>check_namerules ()</b></p>

<p style="margin-left:23%;">Try to resolve start state from
<b>namerules</b> rules. Function returns <b>1</b> if start
state was resolved or <b>0</b> otherwise.</p>

<p style="margin-left:11%;"><b>check_startrules ()</b></p>

<p style="margin-left:23%;">Try to resolve start state from
<b>startrules</b> rules. Function returns <b>1</b> if start
state was resolved or <b>0</b> otherwise.</p>

<p style="margin-left:11%;"><b>concat (</b><i>str</i><b>,
...)</b></p>

<p style="margin-left:23%;">Concanate argument strings and
return result as a new string.</p>

<p style="margin-left:11%;"><b>float
(</b><i>any</i><b>)</b></p>

<p style="margin-left:23%;">Convert argument to a floating
point number.</p>

<p style="margin-left:11%;"><b>getenv
(</b><i>str</i><b>)</b></p>

<p style="margin-left:23%;">Get value of environment
variable <i>str</i>. Returns an empty string if variable
<i>var</i> is undefined.</p>

<p style="margin-left:11%;"><b>int
(</b><i>any</i><b>)</b></p>

<p style="margin-left:23%;">Convert argument to an integer
number.</p>

<p style="margin-left:11%;"><b>length (</b><i>item</i><b>,
...)</b></p>

<p style="margin-left:23%;">Count the length of argument
strings or lists.</p>

<p style="margin-left:11%;"><b>list (</b><i>any</i><b>,
...)</b></p>

<p style="margin-left:23%;">Create a new list which
contains items <i>any</i>, ...</p>

<p style="margin-left:11%;"><b>panic (</b><i>any</i><b>,
...)</b></p>

<p style="margin-left:23%;">Report a non-recoverable error
and exit with status <b>1</b>. Function never returns.</p>

<p style="margin-left:11%;"><b>print (</b><i>any</i><b>,
...)</b></p>

<p style="margin-left:23%;">Convert arguments to strings
and print them to the output.</p>

<p style="margin-left:11%;"><b>range
(</b><i>source</i><b>,</b> <i>start</i><b>,</b>
<i>end</i><b>)</b></p>

<p style="margin-left:23%;">Return a sub&minus;range of
<i>source</i> starting from position <i>start</i>
(inclusively) to <i>end</i> (exclusively). Argument
<i>source</i> can be string or list.</p>

<p style="margin-left:11%;"><b>regexp
(</b><i>string</i><b>)</b></p>

<p style="margin-left:23%;">Convert string <i>string</i> to
a new regular expression.</p>

<p style="margin-left:11%;"><b>regexp_syntax
(</b><i>char</i><b>,</b> <i>syntax</i><b>)</b></p>

<p style="margin-left:23%;">Modify regular expression
character syntaxes by assigning new syntax <i>syntax</i> for
character <i>char</i>. Possible values for <i>syntax</i>
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="5%">


<p><b>&rsquo;w&rsquo;</b></p></td>
<td width="7%"></td>
<td width="53%">


<p>character is a word constituent</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="5%">


<p><b>&rsquo; &rsquo;</b></p></td>
<td width="7%"></td>
<td width="53%">


<p>character isn&rsquo;t a word constituent</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>regmatch
(</b><i>string</i><b>,</b> <i>regexp</i><b>)</b></p>

<p style="margin-left:23%;">Check if string <i>string</i>
matches regular expression <i>regexp</i>. Functions returns
a boolean success status and sets sub-expression registers
<b>$</b><i>n</i>.</p>

<p style="margin-left:11%;"><b>regsub (</b><i>string</i>,
<i>regexp</i><b>,</b> <i>subst</i><b>)</b></p>

<p style="margin-left:23%;">Search regular expression
<i>regexp</i> from string <i>string</i> and replace the
matching substring with string <i>subst</i>. Returns the
resulting string. The substitution string <i>subst</i> can
contain <b>$</b><i>n</i> references to the <i>n</i>:th
parenthesized sup-expression.</p>

<p style="margin-left:11%;"><b>regsuball
(</b><i>string</i>, <i>regexp</i><b>,</b>
<i>subst</i><b>)</b></p>

<p style="margin-left:23%;">Like <b>regsub</b> but replace
all matches of regular expression <i>regexp</i> from string
<i>string</i> with string <i>subst</i>.</p>

<p style="margin-left:11%;"><b>require_state
(</b><i>symbol</i><b>)</b></p>

<p style="margin-left:23%;">Check that the state
<i>symbol</i> is defined. If the required state is
undefined, the function tries to autoload it. If the loading
fails, the program will terminate with an error message.</p>

<p style="margin-left:11%;"><b>split
(</b><i>regexp</i><b>,</b> <i>string</i><b>)</b></p>

<p style="margin-left:23%;">Split string <i>string</i> to
list considering matches of regular rexpression
<i>regexp</i> as item separator.</p>

<p style="margin-left:11%;"><b>sprintf (</b><i>fmt</i>,
...)</p>

<p style="margin-left:23%;">Format arguments according to
<i>fmt</i> and return result as a string.</p>

<p style="margin-left:11%;"><b>strcmp
(</b><i>str1</i><b>,</b> <i>str2</i><b>)</b></p>

<p style="margin-left:23%;">Perform a case&minus;sensitive
comparision for strings <i>str1</i> and <i>str2</i>.
Function returns a value that is:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p><b>-1</b></p></td>
<td width="9%"></td>
<td width="50%">


<p>string <i>str1</i> is less than <i>str2</i></p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p><b>0</b></p></td>
<td width="9%"></td>
<td width="50%">


<p>strings are equal</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p><b>1</b></p></td>
<td width="9%"></td>
<td width="50%">


<p>string <i>str1</i> is greater than <i>str2</i></p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>string
(</b><i>any</i><b>)</b></p>

<p style="margin-left:23%;">Convert argument to string.</p>

<p style="margin-left:11%;"><b>strncmp
(</b><i>str1</i><b>,</b> <i>str2</i><b>,</b>
<i>num</i><b>)</b></p>

<p style="margin-left:23%;">Perform a case&minus;sensitive
comparision for strings <i>str1</i> and <i>str2</i>
comparing at maximum <i>num</i> <b>characters.</b></p>

<p style="margin-left:11%;"><b>substring
(</b><i>str</i><b>,</b> <i>start</i><b>,</b>
<i>end</i><b>)</b></p>

<p style="margin-left:23%;">Return a substring of string
<i>str</i> starting from position <i>start</i> (inclusively)
to <i>end</i> (exclusively).</p>

<h2>BUILTIN VARIABLES
<a name="BUILTIN VARIABLES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>$.</b></p></td>
<td width="6%"></td>
<td width="77%">


<p style="margin-top: 1em">current input line number</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>$</b><i>n</i></p></td>
<td width="6%"></td>
<td width="77%">


<p>the <i>n</i>:th parenthesized regular expression
sub-expression from the latest state regular expression or
from the <b>regmatch</b> primitive</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>$&lsquo;</b></p></td>
<td width="6%"></td>
<td width="77%">


<p>everything before the matched regular rexpression. This
is usable when used with the <b>regmatch</b> primitive; the
contents of this variable is undefined when used in action
blocks to refer the data before the block&rsquo;s regular
expression.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>$B</b></p></td>
<td width="6%"></td>
<td width="77%">


<p>an alias for <b>$&lsquo;</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>argv</b></p></td>
<td width="6%"></td>
<td width="77%">


<p>list of input file names</p></td></tr>
</table>

<p style="margin-left:11%;"><b>filename</b></p>

<p style="margin-left:23%;">name of the current input
file</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>program</b></p></td>
<td width="1%"></td>
<td width="55%">


<p>name of the program (usually <b>states</b>)</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>version</b></p></td>
<td width="1%"></td>
<td width="55%">


<p>program version string</p></td>
<td width="22%">
</td></tr>
</table>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">/usr/share/enscript/hl/*.st
enscript&rsquo;s states definitions</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">awk(1),
enscript(1)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Markku Rossi
&lt;mtr@iki.fi&gt; &lt;http://www.iki.fi/~mtr/&gt;</p>

<p style="margin-left:11%; margin-top: 1em">GNU Enscript
WWW home page: &lt;http://www.iki.fi/~mtr/genscript/&gt;</p>
<hr>
</body>
</html>
