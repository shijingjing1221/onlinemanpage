<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:03:56 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Mail::SpamAssassin::Plugin</title>

</head>
<body>

<h1 align="center">Mail::SpamAssassin::Plugin</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INTERFACE">INTERFACE</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#HELPER APIS">HELPER APIS</a><br>
<a href="#LOGGING">LOGGING</a><br>
<a href="#REGISTERING EVAL RULES">REGISTERING EVAL RULES</a><br>
<a href="#STANDARD ARGUMENTS FOR RULE TYPES">STANDARD ARGUMENTS FOR RULE TYPES</a><br>
<a href="#BACKWARD COMPATIBILITY">BACKWARD COMPATIBILITY</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Mail::SpamAssassin::Plugin
&minus; SpamAssassin plugin base class</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SpamAssassin
configuration:</b></p>

<pre style="margin-left:11%;">  loadplugin MyPlugin /path/to/myplugin.pm</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Perl
code:</b></p>

<pre style="margin-left:11%;">  package MyPlugin;
  use Mail::SpamAssassin::Plugin;
  our @ISA = qw(Mail::SpamAssassin::Plugin);
  sub new {
    my ($class, $mailsa) = @_;
    # the usual perlobj boilerplate to create a subclass object
    $class = ref($class) || $class;
    my $self = $class&minus;&gt;SUPER::new($mailsa);
    bless ($self, $class);
    # then register an eval rule, if desired...
    $self&minus;&gt;register_eval_rule (&quot;check_for_foo&quot;);
    # and return the new plugin object
    return $self;
  }
  ...methods...
  1;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is the
base class for SpamAssassin plugins; all plugins must be
objects that implement this class.</p>

<p style="margin-left:11%; margin-top: 1em">This class
provides no-op stub methods for all the callbacks that a
plugin can receive. It is expected that your plugin will
override one or more of these stubs to perform its
actions.</p>

<p style="margin-left:11%; margin-top: 1em">SpamAssassin
implements a plugin chain; each callback event is passed to
each of the registered plugin objects in turn. Any plugin
can call
<tt>&quot;$self&minus;&gt;inhibit_further_callbacks()&quot;</tt>
to block delivery of that event to later plugins in the
chain. This is useful if the plugin has handled the event,
and there will be no need for later plugins to handle it as
well.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
looking to write a simple eval rule, skip straight to
<tt>&quot;register_eval_rule()&quot;</tt>, below.</p>

<h2>INTERFACE
<a name="INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In all the
plugin APIs below, <tt>&quot;options&quot;</tt> refers to a
reference to a hash containing name-value pairs. This is
used to ensure future-compatibility, in that we can add new
options in future without affecting objects built to an
earlier version of the <small>API.</small></p>

<p style="margin-left:11%; margin-top: 1em">For example,
here would be how to print out the <tt>&quot;line&quot;</tt>
item in a <tt>&quot;parse_config()&quot;</tt> method:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub parse_config {
    my ($self, $opts) = @_;
    print &quot;MyPlugin: parse_config got &quot;.$opts&minus;&gt;{line}.&quot;\n&quot;;
  }</pre>


<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
methods can be overridden by subclasses to handle events.
<br>
$plugin = MyPluginClass&minus;&gt;new ($mailsaobject)</p>

<p style="margin-left:17%;">Constructor. Plugins that need
to register themselves will need to define their own; the
default super-class constructor will work fine for plugins
that just override a method.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
subclasses must provide the <tt>$mailsaobject</tt> to the
superclass constructor, like so:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $self = $class&minus;&gt;SUPER::new($mailsaobject);</pre>


<p style="margin-left:17%; margin-top: 1em">Lifecycle note:
plugins that will need to store per-scan state should not
store that on the Plugin object; instead this should be
stored on the PerMsgStatus object, see
<tt>&quot;check_start()&quot;</tt> below. It is also
likewise recommended that configuration settings be stored
on the Conf object; see
<tt>&quot;parse_config()&quot;</tt>.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;parse_config
( { options ... } )</p>

<p style="margin-left:17%;">Parse a configuration line that
hasn&rsquo;t already been handled.
<tt>&quot;options&quot;</tt> is a reference to a hash
containing these options: <br>
line</p>

<p style="margin-left:23%;">The line of configuration text
to parse. This has leading and trailing whitespace, and
comments, removed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>key</p></td>
<td width="1%"></td>
<td width="77%">


<p>The configuration key; ie. the first &quot;word&quot; on
the line.</p></td></tr>
</table>

<p style="margin-left:17%;">value</p>

<p style="margin-left:23%;">The configuration value;
everything after the first &quot;word&quot; and any
whitespace after that.</p>

<p style="margin-left:17%;">conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%;">user_config</p>

<p style="margin-left:23%;">A boolean: <tt>1</tt> if
reading a user&rsquo;s configuration, <tt>0</tt> if reading
the system-wide configuration files.</p>

<p style="margin-left:17%; margin-top: 1em">If the
configuration line was a setting that is handled by this
plugin, the method implementation should call
<tt>&quot;$self&minus;&gt;inhibit_further_callbacks()&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If the setting
is not handled by this plugin, the method should return
<tt>0</tt> so that a later plugin may handle it, or so that
SpamAssassin can output a warning message to the user if no
plugin understands it.</p>

<p style="margin-left:17%; margin-top: 1em">Lifecycle note:
it is suggested that configuration be stored on the
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object in use,
instead of the plugin object itself. That can be found as
<tt>&quot;$plugin&minus;&gt;{main}&minus;&gt;{conf}&quot;</tt>,
or as &quot;conf&quot; in the <tt>$options</tt> hash
reference above. By storing it on <tt>&quot;conf&quot;</tt>,
this allows per-user and system-wide configuration
precedence to be dealt with correctly.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;finish_parsing_start
( { options ... } )</p>

<p style="margin-left:17%;">Signals that the system-wide
configuration has been completely read, but internal data
structures are not yet created. It is possible to use this
hook to dynamically change the configuration already read in
or add new config options.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;options&quot;</tt>
is a reference to a hash containing these options: <br>
conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%; margin-top: 1em">Note: there are
no guarantees that the internal data structures of
SpamAssassin will not change from release to release. In
particular to this plugin hook, if you modify the rules data
structures in a third-party plugin, all bets are off until
such time that an <small>API</small> is present for
modifying that configuration data.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;finish_parsing_end
( { options ... } )</p>

<p style="margin-left:17%;">Signals that the system-wide
configuration parsing has just finished, and SpamAssassin is
nearly ready to check messages.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;options&quot;</tt>
is a reference to a hash containing these options: <br>
conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%; margin-top: 1em">Note: there are
no guarantees that the internal data structures of
SpamAssassin will not change from release to release. In
particular to this plugin hook, if you modify the rules data
structures in a third-party plugin, all bets are off until
such time that an <small>API</small> is present for
modifying that configuration data.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;user_conf_parsing_start
( { options ... } )</p>

<p style="margin-left:17%;">Signals that the per-user
configuration has been completely read, but not converted to
internal data structures. It is possible to use this hook to
dynamically change the configuration already read in or add
new config options.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;allow_user_rules&quot;</tt> is enabled in the
configuration, it is possible that additional rules have
been added since the
<tt>&quot;finish_parsing_start&quot;</tt> plugin hook
invocation was called. <br>
conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%; margin-top: 1em">Note: there are
no guarantees that the internal data structures of
SpamAssassin will not change from release to release. In
particular to this plugin hook, if you modify the rules data
structures in a third-party plugin, all bets are off until
such time that an <small>API</small> is present for
modifying that configuration data.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;user_conf_parsing_end
( { options ... } )</p>

<p style="margin-left:17%;">Signals that the per-user
configuration parsing has just finished, and SpamAssassin is
nearly ready to check messages. If
<tt>&quot;allow_user_rules&quot;</tt> is enabled in the
configuration, it is possible that additional rules have
been added since the <tt>&quot;finish_parsing_end&quot;</tt>
plugin hook invocation was called.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;options&quot;</tt>
is a reference to a hash containing these options: <br>
conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%; margin-top: 1em">Note: there are
no guarantees that the internal data structures of
SpamAssassin will not change from release to release. In
particular to this plugin hook, if you modify the rules data
structures in a third-party plugin, all bets are off until
such time that an <small>API</small> is present for
modifying that configuration data.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;signal_user_changed
( { options ... } )</p>

<p style="margin-left:17%;">Signals that the current user
has changed for a new one. <br>
username</p>

<p style="margin-left:23%;">The new user&rsquo;s
username.</p>

<p style="margin-left:17%;">user_dir</p>

<p style="margin-left:23%;">The new user&rsquo;s home
directory. (equivalent to <tt>&quot;~&quot;</tt>.)</p>

<p style="margin-left:17%;">userstate_dir</p>

<p style="margin-left:23%;">The new user&rsquo;s storage
directory. (equivalent to
<tt>&quot;~/.spamassassin&quot;</tt>.)</p>


<p style="margin-left:11%;">$plugin&minus;&gt;services_authorized_for_username
( { options ... } )</p>

<p style="margin-left:17%;">Validates that a given username
is authorized to use certain services.</p>

<p style="margin-left:17%; margin-top: 1em">In order to
authorize a user, the plugin should first check that it can
handle any of the services passed into the method and then
set the value for each allowed service to true (or any
non-negative value).</p>

<p style="margin-left:17%; margin-top: 1em">The current
supported services are: bayessql <br>
username</p>

<p style="margin-left:23%;">A username</p>

<p style="margin-left:17%;">services</p>

<p style="margin-left:23%;">Reference to a hash containing
the services you want to check.</p>

<p style="margin-left:23%; margin-top: 1em">{</p>

<pre style="margin-left:23%; margin-top: 1em">  'bayessql' =&gt; 0</pre>


<p style="margin-left:23%; margin-top: 1em">}</p>

<p style="margin-left:17%;">conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;compile_now_start
( { options ... } )</p>

<p style="margin-left:17%;">This is called at the beginning
of <i>Mail::SpamAssassin::compile_now()</i> so plugins can
do any necessary initialization for multi-process
SpamAssassin (such as spamd or mass-check &minus;j). <br>
use_user_prefs</p>

<p style="margin-left:23%;">The value of
<tt>$use_user_prefs</tt> option in <i>compile_now()</i>.</p>

<p style="margin-left:17%;">keep_userstate</p>

<p style="margin-left:23%;">The value of
<tt>$keep_userstate</tt> option in <i>compile_now()</i>.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;compile_now_finish
( { options ... } )</p>

<p style="margin-left:17%;">This is called at the end of
<i>Mail::SpamAssassin::compile_now()</i> so plugins can do
any necessary initialization for multi-process SpamAssassin
(such as spamd or mass-check &minus;j). <br>
use_user_prefs</p>

<p style="margin-left:23%;">The value of
<tt>$use_user_prefs</tt> option in <i>compile_now()</i>.</p>

<p style="margin-left:17%;">keep_userstate</p>

<p style="margin-left:23%;">The value of
<tt>$keep_userstate</tt> option in <i>compile_now()</i>.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;check_start (
{ options ... } )</p>

<p style="margin-left:17%;">Signals that a message check
operation is starting. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:23%; margin-top: 1em">Lifecycle note:
it is recommended that rules that need to track test state
on a per-scan basis should store that state on this object,
not on the plugin object itself, since the plugin object
will be shared between all active scanners.</p>

<p style="margin-left:23%; margin-top: 1em">The message
being scanned is accessible through the
<tt>&quot;$permsgstatus&minus;&gt;get_message()&quot;</tt>
<small>API</small> ; there are a number of other public APIs
on that object, too. See
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
perldoc.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;check_main (
{ options ... } )</p>

<p style="margin-left:17%;">Signals that a message should
be checked. Note that implementations of this hook should
return <tt>1</tt>. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;check_tick (
{ options ... } )</p>

<p style="margin-left:17%;">Called periodically during a
message check operation. A callback set for this method is a
good place to run through an event loop dealing with network
events triggered in a <tt>&quot;parse_metadata&quot;</tt>
method, for example. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;check_post_dnsbl
( { options ... } )</p>

<p style="margin-left:17%;">Called after the
<small>DNSBL</small> results have been harvested. This is a
good place to harvest your own asynchronously-started
network lookups. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;check_post_learn
( { options ... } )</p>

<p style="margin-left:17%;">Called after auto-learning may
(or may not) have taken place. If you wish to perform
additional learning, whether or not auto-learning happens,
this is the place to do it. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;check_end ( {
options ... } )</p>

<p style="margin-left:17%;">Signals that a message check
operation has just finished, and the results are about to be
returned to the caller. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan. The current score, names of
rules that hit, etc. can be retrieved using the public APIs
on this object.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;finish_tests
( { options ... } )</p>

<p style="margin-left:17%;">Called via
<tt>&quot;Mail::SpamAssassin::finish&quot;</tt>. This should
clear up any tests that a plugin has added to the
namespace.</p>

<p style="margin-left:17%; margin-top: 1em">In certain
circumstances, plugins may find it useful to compile perl
functions from the ruleset, on the fly. It is important to
remove these once the
<tt>&quot;Mail::SpamAssassin&quot;</tt> object is deleted,
however, and this <small>API</small> allows this.</p>

<p style="margin-left:17%; margin-top: 1em">Each plugin is
responsible for its own generated perl functions. <br>
conf</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object on
which the configuration data should be stored.</p>

<p style="margin-left:17%; margin-top: 1em">See also the
<tt>&quot;register_generated_rule_method&quot;</tt> helper
<small>API,</small> below.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;extract_metadata
( { options ... } )</p>

<p style="margin-left:17%;">Signals that a message is being
mined for metadata. Some plugins may wish to add their own
metadata as well.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>msg</p></td>
<td width="1%"></td>
<td width="77%">


<p>The <tt>&quot;Mail::SpamAssassin::Message&quot;</tt>
object for this message.</p></td></tr>
</table>

<p style="margin-left:17%;">permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;parsed_metadata
( { options ... } )</p>

<p style="margin-left:17%;">Signals that a message&rsquo;s
metadata has been parsed, and can now be accessed by the
plugin. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;start_rules (
{ options ... } )</p>

<p style="margin-left:17%;">Called before testing a set of
rules of a given type and priority. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:17%;">ruletype</p>

<p style="margin-left:23%;">The type of the rules about to
be performed.</p>

<p style="margin-left:17%;">priority</p>

<p style="margin-left:23%;">The priority level of the rules
about to be performed.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;hit_rule ( {
options ... } )</p>

<p style="margin-left:17%;">Called when a rule fires. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:17%;">ruletype</p>

<p style="margin-left:23%;">The type of the rule that
fired.</p>

<p style="margin-left:17%;">rulename</p>

<p style="margin-left:23%;">The name of the rule that
fired.</p>

<p style="margin-left:17%;">score</p>

<p style="margin-left:23%;">The rule&rsquo;s score in the
active scoreset.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;ran_rule ( {
options ... } )</p>

<p style="margin-left:17%;">Called after a rule has been
tested, whether or not it fired. When the rule fires, the
hit_rule callback is always called before this. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:17%;">ruletype</p>

<p style="margin-left:23%;">The type of the rule that was
tested.</p>

<p style="margin-left:17%;">rulename</p>

<p style="margin-left:23%;">The name of the rule that was
tested.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;autolearn_discriminator
( { options ... } )</p>

<p style="margin-left:17%;">Control whether a just-scanned
message should be learned as either spam or ham. This method
should return one of <tt>1</tt> to learn the message as
spam, <tt>0</tt> to learn as ham, or
<tt>&quot;undef&quot;</tt> to not learn from the message at
all. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;autolearn ( {
options ... } )</p>

<p style="margin-left:17%;">Signals that a message is about
to be auto-learned as either ham or spam. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:17%;">isspam</p>

<p style="margin-left:23%;"><tt>1</tt> if the message is
spam, <tt>0</tt> if ham.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;per_msg_finish
( { options ... } )</p>

<p style="margin-left:17%;">Signals that a
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt> object
is being destroyed, and any per-scan context held on that
object by this plugin should be destroyed as well.</p>

<p style="margin-left:17%; margin-top: 1em">Normally, any
member variables on the <tt>&quot;PerMsgStatus&quot;</tt>
object will be cleaned up automatically -- but if your
plugin has made a circular reference on that object, this is
the place to break them so that garbage collection can
operate correctly. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;have_shortcircuited
( { options ... } )</p>

<p style="margin-left:17%;">Has the current scan operation
&rsquo;short&minus;circuited&rsquo;? In other words, can
further scanning be skipped, since the message is already
definitively classified as either spam or ham?</p>

<p style="margin-left:17%; margin-top: 1em">Plugins should
return <tt>0</tt> to indicate that scanning should continue,
or <tt>1</tt> to indicate that short-circuiting has taken
effect. <br>
permsgstatus</p>

<p style="margin-left:23%;">The
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
context object for this scan.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;bayes_learn (
{ options ... } )</p>

<p style="margin-left:17%;">Called at the end of a bayes
learn operation.</p>

<p style="margin-left:17%; margin-top: 1em">This phase is
the best place to map the raw (original) token value to the
<small>SHA1</small> hashed value. <br>
toksref</p>

<p style="margin-left:23%;">Reference to hash returned by
call to tokenize. The hash takes the format of:</p>

<pre style="margin-left:23%; margin-top: 1em">  {
    'SHA1 Hash Value' =&gt; 'raw (original) value',
    ...
  }</pre>



<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
This data structure has changed since it was originally
introduced in version 3.0.0. The values are no longer perl
anonymous hashes, they are a single string containing the
raw token value. You can test for backward compatibility by
checking to see if the value for a key is a reference to a
perl <small>HASH,</small> for instance:</p>

<p style="margin-left:23%; margin-top: 1em">if
(ref($toksref&minus;&gt;{$sometokenkey}) eq &rsquo;
<small>HASH</small> &rsquo;) {...</p>

<p style="margin-left:23%; margin-top: 1em">If it is, then
you are using the old interface, otherwise you are using the
current interface.</p>

<p style="margin-left:17%;">isspam</p>

<p style="margin-left:23%;">Boolean value stating what
flavor of message the tokens represent, if true then message
was specified as spam, false is nonspam. Note, when function
is scan then isspam value is not valid.</p>

<p style="margin-left:17%;">msgid</p>

<p style="margin-left:23%;">Generated message id of the
message just learned.</p>

<p style="margin-left:17%;">msgatime</p>

<p style="margin-left:23%;">Received date of the current
message or current time if received date could not be
determined. In addition, if the receive date is more than 24
hrs into the future it will be reset to current
datetime.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;bayes_forget
( { options ... } )</p>

<p style="margin-left:17%;">Called at the end of a bayes
forget operation. <br>
toksref</p>

<p style="margin-left:23%;">Reference to hash returned by
call to tokenize. See bayes_learn documentation for
additional information on the format.</p>

<p style="margin-left:17%;">isspam</p>

<p style="margin-left:23%;">Boolean value stating what
flavor of message the tokens represent, if true then message
was specified as spam, false is nonspam. Note, when function
is scan then isspam value is not valid.</p>

<p style="margin-left:17%;">msgid</p>

<p style="margin-left:23%;">Generated message id of the
message just forgotten.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;bayes_scan (
{ options ... } )</p>

<p style="margin-left:17%;">Called at the end of a bayes
scan operation. <small>NOTE:</small> Will not be called in
case of error or if the message is otherwise skipped. <br>
toksref</p>

<p style="margin-left:23%;">Reference to hash returned by
call to tokenize. See bayes_learn documentation for
additional information on the format.</p>

<p style="margin-left:17%;">probsref</p>

<p style="margin-left:23%;">Reference to hash of calculated
probabilities for tokens found in the database.</p>

<pre style="margin-left:23%; margin-top: 1em">  {
    'SHA1 Hash Value' =&gt; {
            'prob' =&gt; 'calculated probability',
            'spam_count' =&gt; 'Total number of spam msgs w/ token',
            'ham_count' =&gt; 'Total number of ham msgs w/ token',
            'atime' =&gt; 'Atime value for token in database'
          }
  }</pre>


<p style="margin-left:17%;">score</p>

<p style="margin-left:23%;">Score calculated for this
particular message.</p>

<p style="margin-left:17%;">msgatime</p>

<p style="margin-left:23%;">Calculated atime of the message
just learned, note it may have been adjusted if it was
determined to be too far into the future.</p>

<p style="margin-left:17%;">significant_tokens</p>

<p style="margin-left:23%;">Array ref of the tokens found
to be significant in determining the score for this
message.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;plugin_report
( { options ... } )</p>

<p style="margin-left:17%;">Called if the message is to be
reported as spam. If the reporting system is available, the
variable
<tt>&quot;$options&minus;&gt;{report}&minus;&gt;report_available}&quot;</tt>
should be set to <tt>1</tt>; if the reporting system
successfully reported the message, the variable
<tt>&quot;$options&minus;&gt;{report}&minus;&gt;report_return}&quot;</tt>
should be set to <tt>1</tt>. <br>
report</p>

<p style="margin-left:23%;">Reference to the Reporter
object (<tt>&quot;$options&minus;&gt;{report}&quot;</tt> in
the paragraph above.)</p>

<p style="margin-left:17%;">text</p>

<p style="margin-left:23%;">Reference to a markup removed
copy of the message in scalar string format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>msg</p></td>
<td width="1%"></td>
<td width="63%">


<p>Reference to the original message object.</p></td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:11%;">$plugin&minus;&gt;plugin_revoke
( { options ... } )</p>

<p style="margin-left:17%;">Called if the message is to be
reported as ham (revokes a spam report). If the reporting
system is available, the variable
<tt>&quot;$options&minus;&gt;{revoke}&minus;&gt;revoke_available}&quot;</tt>
should be set to <tt>1</tt>; if the reporting system
successfully revoked the message, the variable
<tt>&quot;$options&minus;&gt;{revoke}&minus;&gt;revoke_return}&quot;</tt>
should be set to <tt>1</tt>. <br>
revoke</p>

<p style="margin-left:23%;">Reference to the Reporter
object (<tt>&quot;$options&minus;&gt;{revoke}&quot;</tt> in
the paragraph above.)</p>

<p style="margin-left:17%;">text</p>

<p style="margin-left:23%;">Reference to a markup removed
copy of the message in scalar string format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>msg</p></td>
<td width="1%"></td>
<td width="63%">


<p>Reference to the original message object.</p></td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:11%;">$plugin&minus;&gt;whitelist_address(
{ options ... } )</p>

<p style="margin-left:17%;">Called when a request is made
to add an address to a persistent address list. <br>
address</p>

<p style="margin-left:23%;">Address you wish to add.</p>

<p style="margin-left:17%;">cli_p</p>

<p style="margin-left:23%;">Indicate if the call is being
made from a command line interface.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;blacklist_address(
{ options ... } )</p>

<p style="margin-left:17%;">Called when a request is made
to add an address to a persistent address list. <br>
address</p>

<p style="margin-left:23%;">Address you wish to add.</p>

<p style="margin-left:17%;">cli_p</p>

<p style="margin-left:23%;">Indicate if the call is being
made from a command line interface.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;remove_address(
{ options ... } )</p>

<p style="margin-left:17%;">Called when a request is made
to remove an address to a persistent address list. <br>
address</p>

<p style="margin-left:23%;">Address you wish to remove.</p>

<p style="margin-left:17%;">cli_p</p>

<p style="margin-left:23%;">Indicate if the call is being
made from a command line interface.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;spamd_child_init
()</p>

<p style="margin-left:17%;">Called in each new child
process when it starts up under spamd.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;log_scan_result
( { options ... } )</p>

<p style="margin-left:17%;">Called when spamd has completed
scanning a message. Currently, only spamd calls this
<small>API.</small> <br>
result</p>

<p style="margin-left:23%;">The <tt>'result: ...'</tt> line
for this scan. Format is as described at
<b>http://wiki.apache.org/spamassassin/SpamdSyslogFormat</b>.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;spamd_child_post_connection_close
()</p>

<p style="margin-left:17%;">Called when child returns from
handling a connection.</p>

<p style="margin-left:17%; margin-top: 1em">If there was an
accept failure, the child will die and this code will not be
called.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;finish ()</p>

<p style="margin-left:17%;">Called when the
<tt>&quot;Mail::SpamAssassin&quot;</tt> object is
destroyed.</p>

<p style="margin-left:11%;">$plugin&minus;&gt;learner_new
()</p>

<p style="margin-left:17%;">Used to support human-trained
probabilistic classifiers like the BAYES_* ruleset. Called
when a new <tt>&quot;Mail::SpamAssassin::Bayes&quot;</tt>
object has been created; typically when a new user&rsquo;s
scan is about to start.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;learn_message
()</p>

<p style="margin-left:17%;">Train the classifier with a
training message. <br>
isspam</p>

<p style="margin-left:23%;">1 if the message is spam, 0 if
it&rsquo;s non-spam.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>msg</p></td>
<td width="1%"></td>
<td width="77%">


<p>The message&rsquo;s
<tt>&quot;Mail::SpamAssassin::Message&quot;</tt> object.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>id</p></td>
<td width="1%"></td>
<td width="77%">


<p>An optional message-identification string, used
internally to tag the message. If it is
<tt>&quot;undef&quot;</tt>, one will be generated. It should
be unique to that message.</p></td></tr>
</table>


<p style="margin-left:11%;">$plugin&minus;&gt;forget_message
()</p>

<p style="margin-left:17%;">Tell the classifier to
&rsquo;forget&rsquo; its training about a specific
message.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>msg</p></td>
<td width="1%"></td>
<td width="77%">


<p>The message&rsquo;s
<tt>&quot;Mail::SpamAssassin::Message&quot;</tt> object.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>id</p></td>
<td width="1%"></td>
<td width="77%">


<p>An optional message-identification string, used
internally to tag the message. If it is
<tt>&quot;undef&quot;</tt>, one will be generated. It should
be unique to that message.</p></td></tr>
</table>

<p style="margin-left:11%;">$plugin&minus;&gt;learner_sync
()</p>

<p style="margin-left:17%;">Tell the classifier to
&rsquo;sync&rsquo; any pending changes against the current
user&rsquo;s training database. This is called by
<tt>&quot;sa&minus;learn &minus;&minus;sync&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If you do not
need to implement these for your classifier, create an
implementation that just contains <tt>&quot;return
1&quot;</tt>.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;learner_expire_old_training
()</p>

<p style="margin-left:17%;">Tell the classifier to perform
infrequent, time-consuming cleanup of the current
user&rsquo;s training database. This is called by
<tt>&quot;sa&minus;learn
&minus;&minus;force&minus;expire&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If you do not
need to implement these for your classifier, create an
implementation that just contains <tt>&quot;return
1&quot;</tt>.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;learner_is_scan_available
()</p>

<p style="margin-left:17%;">Should return 1 if it is
possible to use the current user&rsquo;s training data for a
message-scan operation, or 0 otherwise.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;learner_dump_database
()</p>

<p style="margin-left:17%;">Dump information about the
current user&rsquo;s training data to
<tt>&quot;stdout&quot;</tt>. This is called by
<tt>&quot;sa&minus;learn &minus;&minus;dump&quot;</tt>. <br>
magic</p>

<p style="margin-left:23%;">Set to 1 if &quot;magic&quot;
name-value metadata should be dumped.</p>

<p style="margin-left:17%;">toks</p>

<p style="margin-left:23%;">Set to 1 if the database of
tokens should be dumped.</p>

<p style="margin-left:17%;">regex</p>

<p style="margin-left:23%;">Either
<tt>&quot;undef&quot;</tt> to dump all tokens, or a value
which specifies a regular expression subset of the tokens to
dump.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;learner_close
()</p>

<p style="margin-left:17%;">Close any open databases. <br>
quiet</p>

<p style="margin-left:23%;">Set to 1 if warning messages
should be suppressed.</p>

<h2>HELPER APIS
<a name="HELPER APIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These methods
provide an <small>API</small> for plugins to register
themselves to receive specific events, or control the
callback chain behaviour. <br>
$plugin&minus;&gt;register_eval_rule ($nameofevalsub)</p>

<p style="margin-left:17%;">Plugins that implement an eval
test will need to call this, so that SpamAssassin calls into
the object when that eval test is encountered. See the
<b><small>REGISTERING EVAL RULES</small></b> section for
full details.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;register_generated_rule_method
($nameofsub)</p>

<p style="margin-left:17%;">In certain circumstances,
plugins may find it useful to compile perl functions from
the ruleset, on the fly. It is important to remove these
once the <tt>&quot;Mail::SpamAssassin&quot;</tt> object is
deleted, however, and this <small>API</small> allows
this.</p>

<p style="margin-left:17%; margin-top: 1em">Once the method
<tt>$nameofsub</tt> has been generated, call this
<small>API</small> with the name of the method (including
full package scope). This indicates that it&rsquo;s a
temporary piece of generated code, built from the
SpamAssassin ruleset, and when
<tt>&quot;Mail::SpamAssassin::finish()&quot;</tt> is called,
the method will be destroyed.</p>

<p style="margin-left:17%; margin-top: 1em">This
<small>API</small> was added in SpamAssassin 3.2.0.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;register_method_priority($methodname,
$priority)</p>

<p style="margin-left:17%;">Indicate that the method named
<tt>$methodname</tt> on the current object has a callback
priority of <tt>$priority</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">This is used by
the plugin handler to determine the relative order of
callbacks; plugins with lower-numbered priorities are called
before plugins with higher-numbered priorities. Each method
can have a different priority value. The default value is
<tt>0</tt>. The ordering of callbacks to methods with equal
priority is undefined.</p>

<p style="margin-left:17%; margin-top: 1em">Typically, you
only need to worry about this if you need to ensure your
plugin&rsquo;s method is called before another
plugin&rsquo;s implementation of that method. It should be
called from your plugin&rsquo;s constructor.</p>

<p style="margin-left:17%; margin-top: 1em">This
<small>API</small> was added in SpamAssassin 3.2.0.</p>


<p style="margin-left:11%;">$plugin&minus;&gt;<i>inhibit_further_callbacks()</i></p>

<p style="margin-left:17%;">Tells the plugin handler to
inhibit calling into other plugins in the plugin chain for
the current callback. Frequently used when parsing
configuration settings using
<tt>&quot;parse_config()&quot;</tt>.</p>

<h2>LOGGING
<a name="LOGGING"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Mail::SpamAssassin::Plugin::dbg($message)</p>

<p style="margin-left:17%;">Output a debugging message
<tt>$message</tt>, if the SpamAssassin object is running
with debugging turned on.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE:</small></i>
This function is not available in the package namespace of
general plugins and can&rsquo;t be called via
<tt>$self</tt>&minus;&gt;<i>dbg()</i>. If a plugin wishes to
output debug information, it should call
<tt>&quot;Mail::SpamAssassin::Plugin::dbg($msg)&quot;</tt>.</p>


<p style="margin-left:11%;">Mail::SpamAssassin::Plugin::info($message)</p>

<p style="margin-left:17%;">Output an informational message
<tt>$message</tt>, if the SpamAssassin object is running
with informational messages turned on.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE:</small></i>
This function is not available in the package namespace of
general plugins and can&rsquo;t be called via
<tt>$self</tt>&minus;&gt;<i>info()</i>. If a plugin wishes
to output debug information, it should call
<tt>&quot;Mail::SpamAssassin::Plugin::info($msg)&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">In general, it
is better for plugins to use the
<tt>&quot;Mail::SpamAssassin::Logger&quot;</tt> module to
import <tt>&quot;dbg&quot;</tt> and
<tt>&quot;info&quot;</tt> directly, like so:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Mail::SpamAssassin::Logger;
  dbg(&quot;some message&quot;);
  info(&quot;some other message&quot;);</pre>


<h2>REGISTERING EVAL RULES
<a name="REGISTERING EVAL RULES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Plugins that
implement an eval test must register the methods that can be
called from rules in the configuration files, in the plugin
class&rsquo; constructor.</p>

<p style="margin-left:11%; margin-top: 1em">For
example,</p>

<pre style="margin-left:11%; margin-top: 1em">  $plugin&minus;&gt;register_eval_rule ('check_for_foo')</pre>


<p style="margin-left:11%; margin-top: 1em">will cause
<tt>&quot;$plugin&minus;&gt;check_for_foo()&quot;</tt> to be
called for this SpamAssassin rule:</p>

<pre style="margin-left:11%; margin-top: 1em">  header   FOO_RULE     eval:check_for_foo()</pre>


<p style="margin-left:11%; margin-top: 1em">Note that eval
rules are passed the following arguments: <br>
&minus; The plugin object itself <br>
&minus; The &quot;Mail::SpamAssassin::PerMsgStatus&quot;
object calling the rule <br>
&minus; standard arguments for the rule type in use <br>
&minus; any and all arguments as specified in the
configuration file</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
the eval test method should look something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  sub check_for_foo {
    my ($self, $permsgstatus, ...arguments...) = @_;
    ...code returning 0 or 1
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Note that the
headers can be accessed using the <tt>&quot;get()&quot;</tt>
method on the
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>
object, and the body by
<tt>&quot;get_decoded_stripped_body_text_array()&quot;</tt>
and other similar methods. Similarly, the
<tt>&quot;Mail::SpamAssassin::Conf&quot;</tt> object holding
the current configuration may be accessed through
<tt>&quot;$permsgstatus&minus;&gt;{main}&minus;&gt;{conf}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The eval rule
should return <tt>1</tt> for a hit, or <tt>0</tt> if the
rule is not hit.</p>

<p style="margin-left:11%; margin-top: 1em">State for a
single message being scanned should be stored on the
<tt>$permsgstatus</tt> object, not on the <tt>$self</tt>
object, since <tt>$self</tt> persists between scan
operations. See the &rsquo;lifecycle note&rsquo; on the
<tt>&quot;check_start()&quot;</tt> method above.</p>

<h2>STANDARD ARGUMENTS FOR RULE TYPES
<a name="STANDARD ARGUMENTS FOR RULE TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Plugins will be
called with the same arguments as a standard EvalTest.
Different rule types receive different information by
default: <br>
&minus; header tests: no extra arguments <br>
&minus; body tests: fully rendered message as array
reference <br>
&minus; rawbody tests: fully decoded message as array
reference <br>
&minus; full tests: pristine message as scalar reference</p>

<p style="margin-left:11%; margin-top: 1em">The
configuration file arguments will be passed in after the
standard arguments.</p>

<h2>BACKWARD COMPATIBILITY
<a name="BACKWARD COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that if
you write a plugin and need to determine if a particular
helper method is supported on
<tt>&quot;Mail::SpamAssassin::Plugin&quot;</tt>, you can do
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($self&minus;&gt;can(&quot;name_of_method&quot;)) {
      eval {
        $self&minus;&gt;name_of_method();        # etc.
      }
    } else {
      # take fallback action
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The same
applies for the public APIs on objects of other types, such
as
<tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Mail::SpamAssassin&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Mail::SpamAssassin::PerMsgStatus&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em">http://wiki.apache.org/spamassassin/PluginWritingTips</p>


<p style="margin-left:11%; margin-top: 1em">http://issues.apache.org/SpamAssassin/show_bug.cgi?id=2163</p>
<hr>
</body>
</html>
