<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:24:46 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SGI</title>

</head>
<body>

<h1 align="center">SGI</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Function Documentation">Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SGI &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class
<b>__gnu_cxx::binary_compose&lt; _Operation1, _Operation2,
_Operation3 &gt;</b> <br>
struct <b>__gnu_cxx::constant_binary_fun&lt; _Result, _Arg1,
_Arg2 &gt;</b> <br>
struct <b>__gnu_cxx::constant_unary_fun&lt; _Result,
_Argument &gt;</b> <br>
struct <b>__gnu_cxx::constant_void_fun&lt; _Result &gt;</b>
<br>
class <b>__gnu_cxx::hash_map&lt; _Key, _Tp, _HashFn,
_EqualKey, _Alloc &gt;</b> <br>
class <b>__gnu_cxx::hash_multimap&lt; _Key, _Tp, _HashFn,
_EqualKey, _Alloc &gt;</b> <br>
class <b>__gnu_cxx::hash_multiset&lt; _Value, _HashFcn,
_EqualKey, _Alloc &gt;</b> <br>
class <b>__gnu_cxx::hash_set&lt; _Value, _HashFcn,
_EqualKey, _Alloc &gt;</b> <br>
struct <b>__gnu_cxx::project1st&lt; _Arg1, _Arg2 &gt;</b>
<br>
struct <b>__gnu_cxx::project2nd&lt; _Arg1, _Arg2 &gt;</b>
<br>
struct <b>__gnu_cxx::rb_tree&lt; _Key, _Value, _KeyOfValue,
_Compare, _Alloc &gt;</b> <br>
class <b>__gnu_cxx::rope&lt; _CharT, _Alloc &gt;</b> <br>
struct <b>__gnu_cxx::select1st&lt; _Pair &gt;</b> <br>
struct <b>__gnu_cxx::select2nd&lt; _Pair &gt;</b> <br>
class <b>__gnu_cxx::slist&lt; _Tp, _Alloc &gt;</b> <br>
class <b>__gnu_cxx::subtractive_rng</b> <br>
struct <b>__gnu_cxx::temporary_buffer&lt; _ForwardIterator,
_Tp &gt;</b> <br>
class <b>__gnu_cxx::unary_compose&lt; _Operation1,
_Operation2 &gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Tp &gt;
const _Tp &amp; <b>__gnu_cxx::__median</b> (const _Tp
&amp;__a, const _Tp &amp;__b, const _Tp &amp;__c) <br>
template&lt;typename _Tp , typename _Compare &gt; const _Tp
&amp; <b>__gnu_cxx::__median</b> (const _Tp &amp;__a, const
_Tp &amp;__b, const _Tp &amp;__c, _Compare __comp) <br>
size_t <b>std::_Find_first</b> () const noexcept <br>
size_t <b>std::_Find_next</b> (size_t __prev) const noexcept
<br>
template&lt;class _Operation1 , class _Operation2 &gt;
unary_compose&lt; _Operation1, <br>
_Operation2 &gt; <b>__gnu_cxx::compose1</b> (const
_Operation1 &amp;__fn1, const _Operation2 &amp;__fn2)&quot;
<br>
template&lt;class _Operation1 , class _Operation2 , class
_Operation3 &gt; binary_compose&lt; _Operation1, <br>
_Operation2, _Operation3 &gt; <b>__gnu_cxx::compose2</b>
(const _Operation1 &amp;__fn1, const _Operation2 &amp;__fn2,
const _Operation3 &amp;__fn3)&quot; <br>
template&lt;class _Result &gt; constant_void_fun&lt; _Result
&gt; <b>__gnu_cxx::constant0</b> (const _Result &amp;__val)
<br>
template&lt;class _Result &gt; constant_unary_fun&lt;
_Result, <br>
_Result &gt; <b>__gnu_cxx::constant1</b> (const _Result
&amp;__val)&quot; <br>
template&lt;class _Result &gt; constant_binary_fun&lt;
_Result, <br>
_Result, _Result &gt; <b>__gnu_cxx::constant2</b> (const
_Result &amp;__val)&quot; <br>
template&lt;typename _InputIterator , typename _Size ,
typename _OutputIterator &gt; pair&lt; _InputIterator, <br>
_OutputIterator &gt; <b>__gnu_cxx::copy_n</b>
(_InputIterator __first, _Size __count, _OutputIterator
__result)&quot; <br>
template&lt;typename _InputIterator , typename _Distance
&gt; void <b>__gnu_cxx::distance</b> (_InputIterator
__first, _InputIterator __last, _Distance &amp;__n) <br>
template&lt;class _Tp &gt; _Tp
<b>__gnu_cxx::identity_element</b> (<b>std::plus</b>&lt; _Tp
&gt;) <br>
template&lt;class _Tp &gt; _Tp
<b>__gnu_cxx::identity_element</b>
(<b>std::multiplies</b>&lt; _Tp &gt;) <br>
template&lt;typename _InputIterator1 , typename
_InputIterator2 &gt; int
<b>__gnu_cxx::lexicographical_compare_3way</b>
(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2) <br>
template&lt;typename _Tp , typename _Integer , typename
_MonoidOperation &gt; _Tp <b>__gnu_cxx::power</b> (_Tp __x,
_Integer __n, _MonoidOperation __monoid_op) <br>
template&lt;typename _Tp , typename _Integer &gt; _Tp
<b>__gnu_cxx::power</b> (_Tp __x, _Integer __n) <br>
template&lt;typename _InputIterator , typename
_RandomAccessIterator &gt; _RandomAccessIterator
<b>__gnu_cxx::random_sample</b> (_InputIterator __first,
_InputIterator __last, _RandomAccessIterator __out_first,
_RandomAccessIterator __out_last) <br>
template&lt;typename _InputIterator , typename
_RandomAccessIterator , typename _RandomNumberGenerator &gt;
_RandomAccessIterator <b>__gnu_cxx::random_sample</b>
(_InputIterator __first, _InputIterator __last,
_RandomAccessIterator __out_first, _RandomAccessIterator
__out_last, _RandomNumberGenerator &amp;__rand) <br>
template&lt;typename _ForwardIterator , typename
_OutputIterator , typename _Distance &gt; _OutputIterator
<b>__gnu_cxx::random_sample_n</b> (_ForwardIterator __first,
_ForwardIterator __last, _OutputIterator __out, const
_Distance __n) <br>
template&lt;typename _ForwardIterator , typename
_OutputIterator , typename _Distance , typename
_RandomNumberGenerator &gt; _OutputIterator
<b>__gnu_cxx::random_sample_n</b> (_ForwardIterator __first,
_ForwardIterator __last, _OutputIterator __out, const
_Distance __n, _RandomNumberGenerator &amp;__rand) <br>
template&lt;typename _InputIter , typename _Size , typename
_ForwardIter &gt; pair&lt; _InputIter, _ForwardIter &gt;
<b>__gnu_cxx::uninitialized_copy_n</b> (_InputIter __first,
_Size __count, _ForwardIter __result) <br>
bitset&lt; _Nb &gt; &amp; <b>std::_Unchecked_set</b> (size_t
__pos) noexcept <br>
bitset&lt; _Nb &gt; &amp; <b>std::_Unchecked_set</b> (size_t
__pos, int __val) noexcept <br>
bitset&lt; _Nb &gt; &amp; <b>std::_Unchecked_reset</b>
(size_t __pos) noexcept <br>
bitset&lt; _Nb &gt; &amp; <b>std::_Unchecked_flip</b>
(size_t __pos) noexcept <br>
constexpr bool <b>std::_Unchecked_test</b> (size_t __pos)
const noexcept</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Because
libstdc++ based its implementation of the STL subsections of
the library on the SGI 3.3 implementation, we inherited
their extensions as well.</p>

<p style="margin-left:11%; margin-top: 1em">They are
additionally documented in the <tt>online
documentation</tt>, a copy of which is also shipped with the
library source code (in .../docs/html/documentation.html).
You can also read the documentation <tt>on SGI&rsquo;s
site</tt>, which is still running even though the code is
not maintained.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NB</b> that
the following notes are pulled from various comments all
over the place, so they may seem stilted.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>identity_element</tt> functions are not part of the C++
standard; SGI provided them as an extension. Its argument is
an operation, and its return value is the identity element
for that operation. It is overloaded for addition and
multiplication, and you can overload it for your own
nefarious operations.</p>

<p style="margin-left:11%; margin-top: 1em">As an extension
to the binders, SGI provided composition functors and
wrapper functions to aid in their creation. The
<tt>unary_compose</tt> functor is constructed from two
functions/functors, <tt>f</tt> and <tt>g</tt>. Calling
<tt>operator()</tt> with a single argument <tt>x</tt>
returns <tt>f</tt>(g(x)). The function <tt>compose1</tt>
takes the two functions and constructs a
<tt>unary_compose</tt> variable for you.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>binary_compose</tt>
is constructed from three functors, <tt>f</tt>, <tt>g1</tt>,
and <tt>g2</tt>. Its <tt>operator()</tt> returns
<tt>f</tt>(g1(x),g2(x)). The function compose2 takes f, g1,
and g2, and constructs the <tt>binary_compose</tt> instance
for you. For example, if <tt>f</tt> returns an int, then</p>

<p style="margin-left:11%; margin-top: 1em">* int answer =
(compose2(f,g1,g2))(x); <br>
*</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<p style="margin-left:11%; margin-top: 1em">* int temp1 =
g1(x); <br>
* int temp2 = g2(x); <br>
* int answer = f(temp1,temp2); <br>
*</p>

<p style="margin-left:11%; margin-top: 1em">But the first
form is more compact, and can be passed around as a functor
to other algorithms.</p>

<p style="margin-left:11%; margin-top: 1em">As an
extension, SGI provided a functor called <tt>identity</tt>.
When a functor is required but no operations are desired,
this can be used as a pass-through. Its <tt>operator()</tt>
returns its argument unchanged.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>select1st</tt>
and <tt>select2nd</tt> are extensions provided by SGI. Their
<tt>operator()s</tt> take a <tt>std::pair</tt> as an
argument, and return either the first member or the second
member, respectively. They can be used (especially with the
composition functors) to <i>strip</i> data from a sequence
before performing the remainder of an algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>operator()</tt> of the <tt>project1st</tt> functor takes
two arbitrary arguments and returns the first one, while
<tt>project2nd</tt> returns the second one. They are
extensions provided by SGI.</p>

<p style="margin-left:11%; margin-top: 1em">These three
functors are each constructed from a single arbitrary
variable/value. Later, their <tt>operator()s</tt> completely
ignore any arguments passed, and return the stored
value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><tt>constant_void_fun&rsquo;s operator()</tt> takes no
arguments</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><tt>constant_unary_fun&rsquo;s operator()</tt> takes one
argument (ignored)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><tt>constant_binary_fun&rsquo;s operator()</tt> takes
two arguments (ignored)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The helper
creator functions <tt>constant0</tt>, <tt>constant1</tt>,
and <tt>constant2</tt> each take a <i>result</i> argument
and construct variables of the appropriate functor type.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; const _Tp&amp; __gnu_cxx::__median (const _Tp
&amp;__a, const _Tp &amp;__b, const _Tp &amp;__c)</b> <br>
Find the median of three values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> A value. <i><br>
__b</i> A value. <i><br>
__c</i> A value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">One of <tt>a</tt>, <tt>b</tt>
or <tt>c</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>{l</tt>,m,n} is some convolution of <tt>{a</tt>,b,c}
such that <tt>l&lt;=m&lt;=n</tt> then the value returned
will be <tt>m</tt>. This is an SGI extension.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 546 of file ext/algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Compare &gt; const _Tp&amp;
__gnu_cxx::__median (const _Tp &amp;__a, const _Tp &amp;__b,
const _Tp &amp;__c, _Compare__comp)</b> <br>
Find the median of three values using a predicate for
comparison.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> A value. <i><br>
__b</i> A value. <i><br>
__c</i> A value. <i><br>
__comp</i> A binary predicate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">One of <tt>a</tt>, <tt>b</tt>
or <tt>c</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>{l</tt>,m,n} is some convolution of <tt>{a</tt>,b,c}
such that <tt>comp(l,m)</tt> and <tt>comp(m,n)</tt> are both
true then the value returned will be <tt>m</tt>. This is an
SGI extension.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 580 of file ext/algorithm.</p>

<p style="margin-left:11%; margin-top: 1em"><b>size_t
std::_Find_first () const</b> <tt>[noexcept]</tt> <br>
Finds the index of the first &rsquo;on&rsquo; bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The index of the first bit set,
or size() if not found.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
Also:</b></p>

<p style="margin-left:17%;">_Find_next</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1354 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em"><b>size_t
std::_Find_next (size_t__prev) const</b> <tt>[noexcept]</tt>
<br>
Finds the index of the next &rsquo;on&rsquo; bit after
prev.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The index of the next bit set,
or size() if not found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__prev</i> Where to start
searching.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
Also:</b></p>

<p style="margin-left:17%;">_Find_first</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1365 of file bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bitset&lt;_Nb&gt;&amp;
std::_Unchecked_flip (size_t__pos)</b> <tt>[noexcept]</tt>
<br>
These versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range
checking.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1037 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::flip().</p>


<p style="margin-left:11%; margin-top: 1em"><b>bitset&lt;_Nb&gt;&amp;
std::_Unchecked_reset (size_t__pos)</b> <tt>[noexcept]</tt>
<br>
These versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range
checking.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1030 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::reset().</p>


<p style="margin-left:11%; margin-top: 1em"><b>bitset&lt;_Nb&gt;&amp;
std::_Unchecked_set (size_t__pos)</b> <tt>[noexcept]</tt>
<br>
These versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range
checking.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1013 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::set().</p>


<p style="margin-left:11%; margin-top: 1em"><b>bitset&lt;_Nb&gt;&amp;
std::_Unchecked_set (size_t__pos, int__val)</b>
<tt>[noexcept]</tt> <br>
These versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range
checking.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1020 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::_Unchecked_test (size_t__pos) const</b>
<tt>[noexcept]</tt> <br>
These versions of single-bit set, reset, flip, and test are
extensions from the SGI version. They do no range
checking.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1044 of file bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::test().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Operation1 , class _Operation2 &gt;
unary_compose&lt;_Operation1, _Operation2&gt;
__gnu_cxx::compose1 (const _Operation1 &amp;__fn1, const
_Operation2 &amp;__fn2)</b> <tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 145 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Operation1 , class _Operation2 , class _Operation3 &gt;
binary_compose&lt;_Operation1, _Operation2, _Operation3&gt;
__gnu_cxx::compose2 (const _Operation1 &amp;__fn1, const
_Operation2 &amp;__fn2, const _Operation3 &amp;__fn3)</b>
<tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 172 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Result &gt; constant_void_fun&lt;_Result&gt;
__gnu_cxx::constant0 (const _Result &amp;__val)</b>
<tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 330 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Result &gt; constant_unary_fun&lt;_Result, _Result&gt;
__gnu_cxx::constant1 (const _Result &amp;__val)</b>
<tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 336 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Result &gt;
constant_binary_fun&lt;_Result,_Result,_Result&gt;
__gnu_cxx::constant2 (const _Result &amp;__val)</b>
<tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 342 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator , typename _Size , typename _OutputIterator
&gt; pair&lt;_InputIterator, _OutputIterator&gt;
__gnu_cxx::copy_n (_InputIterator__first, _Size__count,
_OutputIterator__result)</b> <tt>[inline]</tt> <br>
Copies the range [first,first+count) into
[result,result+count).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__count</i> The number of elements to copy. <i><br>
__result</i> An output iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A std::pair composed of
first+count and result+count.</p>

<p style="margin-left:11%; margin-top: 1em">This is an SGI
extension. This inline function will boil down to a call to
<tt>memmove</tt> whenever possible. Failing that, if random
access iterators are passed, then the loop count will be
known (and therefore a candidate for compiler optimizations
such as unrolling).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 120 of file ext/algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::__iterator_category().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator , typename _Distance &gt; void
__gnu_cxx::distance (_InputIterator__first,
_InputIterator__last, _Distance &amp;__n)</b>
<tt>[inline]</tt> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 105 of file ext/iterator.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::__iterator_category().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Tp &gt; _Tp __gnu_cxx::identity_element (std::plus&lt; _Tp
&gt;)</b> <tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 87 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Tp &gt; _Tp __gnu_cxx::identity_element
(std::multiplies&lt; _Tp &gt;)</b> <tt>[inline]</tt> <br>
An <b>SGI extension</b> .</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 93 of file ext/functional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator1 , typename _InputIterator2 &gt; int
__gnu_cxx::lexicographical_compare_3way
(_InputIterator1__first1, _InputIterator1__last1,
_InputIterator2__first2, _InputIterator2__last2)</b>
<tt><br>
memcmp</tt> on steroids.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first1</i> An input
iterator. <i><br>
__last1</i> An input iterator. <i><br>
__first2</i> An input iterator. <i><br>
__last2</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An int, as with
<tt>memcmp</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value will be less than zero if the first range is
<i>lexigraphically less than</i> the second, greater than
zero if the second range is <i>lexigraphically less than</i>
the first, and zero otherwise. This is an SGI extension.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 201 of file ext/algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Integer , typename _MonoidOperation &gt; _Tp
__gnu_cxx::power (_Tp__x, _Integer__n,
_MonoidOperation__monoid_op)</b> <tt>[inline]</tt> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 113 of file ext/numeric.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Integer &gt; _Tp __gnu_cxx::power (_Tp__x,
_Integer__n)</b> <tt>[inline]</tt> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 123 of file ext/numeric.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator , typename _RandomAccessIterator &gt;
_RandomAccessIterator __gnu_cxx::random_sample
(_InputIterator__first, _InputIterator__last,
_RandomAccessIterator__out_first,
_RandomAccessIterator__out_last)</b> <tt>[inline]</tt> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 388 of file ext/algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator , typename _RandomAccessIterator , typename
_RandomNumberGenerator &gt; _RandomAccessIterator
__gnu_cxx::random_sample (_InputIterator__first,
_InputIterator__last, _RandomAccessIterator__out_first,
_RandomAccessIterator__out_last, _RandomNumberGenerator
&amp;__rand)</b> <tt>[inline]</tt> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 411 of file ext/algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_ForwardIterator , typename _OutputIterator , typename
_Distance &gt; _OutputIterator __gnu_cxx::random_sample_n
(_ForwardIterator__first, _ForwardIterator__last,
_OutputIterator__out, const _Distance__n)</b> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 267 of file ext/algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::distance(), and std::min().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_ForwardIterator , typename _OutputIterator , typename
_Distance , typename _RandomNumberGenerator &gt;
_OutputIterator __gnu_cxx::random_sample_n
(_ForwardIterator__first, _ForwardIterator__last,
_OutputIterator__out, const _Distance__n,
_RandomNumberGenerator &amp;__rand)</b> <br>
This is an SGI extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Needs documentation! See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 301 of file ext/algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::distance(), and std::min().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIter , typename _Size , typename _ForwardIter &gt;
pair&lt;_InputIter, _ForwardIter&gt;
__gnu_cxx::uninitialized_copy_n (_InputIter__first,
_Size__count, _ForwardIter__result)</b> <tt>[inline]</tt>
<br>
Copies the range [first,last) into result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__count</i> Length <i><br>
__result</i> An output iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">__result + (__first +
__count)</p>

<p style="margin-left:11%; margin-top: 1em">Like copy(),
but does not require an initialized output range.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 122 of file ext/memory.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::__iterator_category().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
