<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 01:47:32 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HTML::Tree::AboutObjects</title>

</head>
<body>

<h1 align="center">HTML::Tree::AboutObjects</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#A User&rsquo;s View of Object-Oriented Modules">A User&rsquo;s View of Object-Oriented Modules</a><br>
<a href="#BACK">BACK</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">HTML::Tree::AboutObjects
&minus;&minus; article: &quot;User&rsquo;s View of
Object&minus;Oriented Modules&quot;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  # This an article, not a module.</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
article by Sean M. Burke first appeared in <i>The Perl
Journal</i> #17 and is copyright 2000 The Perl Journal. It
appears courtesy of Jon Orwant and The Perl Journal. This
document may be distributed under the same terms as Perl
itself.</p>

<h2>A User&rsquo;s View of Object-Oriented Modules
<a name="A User&rsquo;s View of Object-Oriented Modules"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;
Sean M. Burke</p>

<p style="margin-left:11%; margin-top: 1em">The first time
that most Perl programmers run into object-oriented
programming when they need to use a module whose interface
is object-oriented. This is often a mystifying experience,
since talk of &quot;methods&quot; and
&quot;constructors&quot; is unintelligible to programmers
who thought that functions and variables was all there was
to worry about.</p>

<p style="margin-left:11%; margin-top: 1em">Articles and
books that explain object-oriented programming (
<small>OOP</small> ), do so in terms of how to program that
way. That&rsquo;s understandable, and if you learn to write
object-oriented code of your own, you&rsquo;d find it easy
to use object-oriented code that others write. But this
approach is the <i>long</i> way around for people whose
immediate goal is just to use existing object-oriented
modules, but who don&rsquo;t yet want to know all the gory
details of having to write such modules for themselves.</p>

<p style="margin-left:11%; margin-top: 1em">This article is
for those programmers -- programmers who want to know about
objects from the perspective of using object-oriented
modules.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modules and
Their Functional Interfaces</b> <br>
Modules are the main way that Perl provides for bundling up
code for later use by yourself or others. As I&rsquo;m sure
you can&rsquo;t help noticing from reading <i>The Perl
Journal</i>, <small>CPAN</small> (the Comprehensive Perl
Archive Network) is the repository for modules (or groups of
modules) that others have written, to do anything from
composing music to accessing Web pages. A good deal of those
modules even come with every installation of Perl.</p>

<p style="margin-left:11%; margin-top: 1em">One module that
you may have used before, and which is fairly typical in its
interface, is Text::Wrap. It comes with Perl, so you
don&rsquo;t even need to install it from
<small>CPAN.</small> You use it in a program of yours, by
having your program code say early on:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Text::Wrap;</pre>


<p style="margin-left:11%; margin-top: 1em">and after that,
you can access a function called <tt>&quot;wrap&quot;</tt>,
which inserts line-breaks in text that you feed it, so that
the text will be wrapped to seventy-two (or however many)
columns.</p>

<p style="margin-left:11%; margin-top: 1em">The way this
<tt>&quot;use Text::Wrap&quot;</tt> business works is that
the module Text::Wrap exists as a file
&quot;Text/Wrap.pm&quot; somewhere in one of your library
directories. That file contains Perl code...</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: And
mixed in with the Perl code, there&rsquo;s documentation,
which is what you read with &quot;perldoc Text::Wrap&quot;.
The perldoc program simply ignores the code and formats the
documentation text, whereas &quot;use Text::Wrap&quot; loads
and runs the code while ignoring the documentation.</p>

<p style="margin-left:11%; margin-top: 1em">...which, among
other things, defines a function called
<tt>&quot;Text::Wrap::wrap&quot;</tt>, and then
<tt>&quot;exports&quot;</tt> that function, which means that
when you say <tt>&quot;wrap&quot;</tt> after having said
&quot;use Text::Wrap&quot;, you&rsquo;ll be actually calling
the <tt>&quot;Text::Wrap::wrap&quot;</tt> function. Some
modules don&rsquo;t export their functions, so you have to
call them by their full name, like
<tt>&quot;Text::Wrap::wrap(...parameters...)&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Regardless of
whether the typical module exports the functions it
provides, a module is basically just a container for chunks
of code that do useful things. The way the module allows for
you to interact with it, is its <i>interface</i>. And when,
like with Text::Wrap, its interface consists of functions,
the module is said to have a <b>functional
interface</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: the
term &quot;function&quot; (and therefore
&quot;function<i>al</i>&quot;) has various senses. I&rsquo;m
using the term here in its broadest sense, to refer to
routines -- bits of code that are called by some name and
which take parameters and return some value.</p>

<p style="margin-left:11%; margin-top: 1em">Using modules
with functional interfaces is straightforward -- instead of
defining your own &quot;wrap&quot; function with
<tt>&quot;sub wrap { ... }&quot;</tt>, you entrust &quot;use
Text::Wrap&quot; to do that for you, along with whatever
other functions its defines and exports, according to the
module&rsquo;s documentation. Without too much bother, you
can even write your own modules to contain your frequently
used functions; I suggest having a look at the
<tt>&quot;perlmod&quot;</tt> man page for more leads on
doing this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modules with
Object-Oriented Interfaces</b> <br>
So suppose that one day you want to write a program that
will automate the process of <tt>&quot;ftp&quot;</tt>ing a
bunch of files from one server down to your local machine,
and then off to another server.</p>

<p style="margin-left:11%; margin-top: 1em">A quick browse
through search.cpan.org turns up the module
&quot;Net::FTP&quot;, which you can download and install it
using normal installation instructions (unless your sysadmin
has already installed it, as many have).</p>

<p style="margin-left:11%; margin-top: 1em">Like Text::Wrap
or any other module with a familiarly functional interface,
you start off using Net::FTP in your program by saying:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Net::FTP;</pre>


<p style="margin-left:11%; margin-top: 1em">However,
that&rsquo;s where the similarity ends. The first hint of
difference is that the documentation for Net::FTP refers to
it as a <b>class</b>. A class is a kind of module, but one
that has an object-oriented interface.</p>

<p style="margin-left:11%; margin-top: 1em">Whereas modules
like Text::Wrap provide bits of useful code as
<i>functions</i>, to be called like
<tt>&quot;function(...parameters...)&quot;</tt> or like
<tt>&quot;PackageName::function(...parameters...)&quot;</tt>,
Net::FTP and other modules with object-oriented interfaces
provide <b>methods</b>. Methods are sort of like functions
in that they have a name and parameters; but methods look
different, and are different, because you have to call them
with a syntax that has a class name or an object as a
special argument. I&rsquo;ll explain the syntax for method
calls, and then later explain what they all mean.</p>

<p style="margin-left:11%; margin-top: 1em">Some methods
are meant to be called as <b>class methods</b>, with the
class name (same as the module name) as a special argument.
Class methods look like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  ClassName&minus;&gt;methodname(parameter1, parameter2, ...)
  ClassName&minus;&gt;methodname()   # if no parameters
  ClassName&minus;&gt;methodname     # same as above</pre>


<p style="margin-left:11%; margin-top: 1em">which you will
sometimes see written:</p>

<pre style="margin-left:11%; margin-top: 1em">  methodname ClassName (parameter1, parameter2, ...)
  methodname ClassName      # if no parameters</pre>


<p style="margin-left:11%; margin-top: 1em">Basically all
class methods are for making new objects, and methods that
make objects are called &quot;<b>constructors</b>&quot; (and
the process of making them is called
&quot;constructing&quot; or &quot;instantiating&quot;).
Constructor methods typically have the name &quot;new&quot;,
or something including &quot;new&quot;
(&quot;new_from_file&quot;, etc.); but they can conceivably
be named anything -- <small>DBI</small> &rsquo;s constructor
method is named &quot;connect&quot;, for example.</p>

<p style="margin-left:11%; margin-top: 1em">The object that
a constructor method returns is typically captured in a
scalar variable:</p>

<pre style="margin-left:11%; margin-top: 1em">  $object = ClassName&minus;&gt;new(param1, param2...);</pre>


<p style="margin-left:11%; margin-top: 1em">Once you have
an object (more later on exactly what that is), you can use
the other kind of method call syntax, the syntax for
<b>object method</b> calls. Calling object methods is just
like class methods, except that instead of the ClassName as
the special argument, you use an expression that yeilds an
&quot;object&quot;. Usually this is just a scalar variable
that you earlier captured the output of the constructor in.
Object method calls look like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $object&minus;&gt;methodname(parameter1, parameter2, ...);
  $object&minus;&gt;methodname()   # if no parameters
  $object&minus;&gt;methodname     # same as above</pre>


<p style="margin-left:11%; margin-top: 1em">which is
occasionally written as:</p>

<pre style="margin-left:11%; margin-top: 1em">  methodname $object (parameter1, parameter2, ...)
  methodname $object      # if no parameters</pre>


<p style="margin-left:11%; margin-top: 1em">Examples of
method calls are:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $session1 = Net::FTP&minus;&gt;new(&quot;ftp.myhost.com&quot;);
    # Calls a class method &quot;new&quot;, from class Net::FTP,
    #  with the single parameter &quot;ftp.myhost.com&quot;,
    #  and saves the return value (which is, as usual,
    #  an object), in $session1.
    # Could also be written:
    #  new Net::FTP('ftp.myhost.com')
  $session1&minus;&gt;login(&quot;sburke&quot;,&quot;aoeuaoeu&quot;)
    || die &quot;failed to login!\n&quot;;
     # calling the object method &quot;login&quot;
  print &quot;Dir:\n&quot;, $session1&minus;&gt;dir(), &quot;\n&quot;;
  $session1&minus;&gt;quit;
    # same as $session1&minus;&gt;quit()
  print &quot;Done\n&quot;;
  exit;</pre>


<p style="margin-left:11%; margin-top: 1em">Incidentally, I
suggest always using the syntaxes with parentheses and
&quot;&minus;&gt;&quot; in them,</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: the
character-pair &quot;&minus;&gt;&quot; is supposed to look
like an arrow, not &quot;negative greater-than&quot;!</p>

<p style="margin-left:11%; margin-top: 1em">and avoiding
the syntaxes that start out &quot;methodname
<tt>$object</tt>&quot; or &quot;methodname ModuleName&quot;.
When everything&rsquo;s going right, they all mean the same
thing as the &quot;&minus;&gt;&quot; variants, but the
syntax with &quot;&minus;&gt;&quot; is more visually
distinct from function calls, as well as being immune to
some kinds of rare but puzzling ambiguities that can arise
when you&rsquo;re trying to call methods that have the same
name as subroutines you&rsquo;ve defined.</p>

<p style="margin-left:11%; margin-top: 1em">But, syntactic
alternatives aside, all this talk of constructing objects
and object methods begs the question -- what <i>is</i> an
object? There are several angles to this question that the
rest of this article will answer in turn: what can you do
with objects? what&rsquo;s in an object? what&rsquo;s an
object value? and why do some modules use objects at
all?</p>

<p style="margin-left:11%; margin-top: 1em"><b>What Can You
Do with Objects?</b> <br>
You&rsquo;ve seen that you can make objects, and call object
methods with them. But what are object methods for? The
answer depends on the class:</p>

<p style="margin-left:11%; margin-top: 1em">A Net::FTP
object represents a session between your computer and an
<small>FTP</small> server. So the methods you call on a
Net::FTP object are for doing whatever you&rsquo;d need to
do across an <small>FTP</small> connection. You make the
session and log in:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $session = Net::FTP&minus;&gt;new('ftp.aol.com');
  die &quot;Couldn't connect!&quot; unless defined $session;
    # The class method call to &quot;new&quot; will return
    # the new object if it goes OK, otherwise it
    # will return undef.
  $session&minus;&gt;login('sburke', 'p@ssw3rD')
   || die &quot;Did I change my password again?&quot;;
    # The object method &quot;login&quot; will give a true
    # return value if actually logs in, otherwise
    # it'll return false.</pre>


<p style="margin-left:11%; margin-top: 1em">You can use the
session object to change directory on that session:</p>

<pre style="margin-left:11%; margin-top: 1em">  $session&minus;&gt;cwd(&quot;/home/sburke/public_html&quot;)
     || die &quot;Hey, that was REALLY supposed to work!&quot;;
   # if the cwd fails, it'll return false</pre>


<p style="margin-left:11%; margin-top: 1em">...get files
from the machine at the other end of the session...</p>

<pre style="margin-left:11%; margin-top: 1em">  foreach my $f ('log_report_ua.txt', 'log_report_dom.txt',
                 'log_report_browsers.txt')
  {
    $session&minus;&gt;get($f) || warn &quot;Getting $f failed!&quot;
  };</pre>


<p style="margin-left:11%; margin-top: 1em">...and plenty
else, ending finally with closing the connection:</p>

<pre style="margin-left:11%; margin-top: 1em">  $session&minus;&gt;quit();</pre>


<p style="margin-left:11%; margin-top: 1em">In short,
object methods are for doing things related to (or with)
whatever the object represents. For <small>FTP</small>
sessions, it&rsquo;s about sending commands to the server at
the other end of the connection, and that&rsquo;s about it
-- there, methods are for doing something to the world
outside the object, and the objects is just something that
specifies what bit of the world (well, what
<small>FTP</small> session) to act upon.</p>

<p style="margin-left:11%; margin-top: 1em">With most other
classes, however, the object itself stores some kind of
information, and it typically makes no sense to do things
with such an object without considering the data
that&rsquo;s in the object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>What&rsquo;s</b>
<i>in</i> <b>an Object?</b> <br>
An object is (with rare exceptions) a data structure
containing a bunch of attributes, each of which has a value,
as well as a name that you use when you read or set the
attribute&rsquo;s value. Some of the object&rsquo;s
attributes are private, meaning you&rsquo;ll never see them
documented because they&rsquo;re not for you to read or
write; but most of the object&rsquo;s documented attributes
are at least readable, and usually writeable, by you.
Net::FTP objects are a bit thin on attributes, so
we&rsquo;ll use objects from the class Business::US_Amort
for this example. Business::US_Amort is a very simple class
(available from <small>CPAN</small> ) that I wrote for
making calculations to do with loans (specifically,
amortization, using US-style algorithms).</p>

<p style="margin-left:11%; margin-top: 1em">An object of
the class Business::US_Amort represents a loan with
particular parameters, i.e., attributes. The most basic
attributes of a &quot;loan object&quot; are its interest
rate, its principal (how much money it&rsquo;s for), and
it&rsquo;s term (how long it&rsquo;ll take to repay). You
need to set these attributes before anything else can be
done with the object. The way to get at those attributes for
loan objects is just like the way to get at attributes for
any class&rsquo;s objects: through accessors. An
<b>accessor</b> is simply any method that accesses (whether
reading or writing, <small>AKA</small> getting or putting)
some attribute in the given object. Moreover, accessors are
the <b>only</b> way that you can change an object&rsquo;s
attributes. (If a module&rsquo;s documentation wants you to
know about any other way, it&rsquo;ll tell you.)</p>

<p style="margin-left:11%; margin-top: 1em">Usually, for
simplicity&rsquo;s sake, an accessor is named after the
attribute it reads or writes. With Business::US_Amort
objects, the accessors you need to use first are
<tt>&quot;principal&quot;</tt>,
<tt>&quot;interest_rate&quot;</tt>, and
<tt>&quot;term&quot;</tt>. Then, with at least those
attributes set, you can call the <tt>&quot;run&quot;</tt>
method to figure out several things about the loan. Then you
can call various accessors, like
<tt>&quot;total_paid_toward_interest&quot;</tt>, to read the
results:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Business::US_Amort;
  my $loan = Business::US_Amort&minus;&gt;new;
  # Set the necessary attributes:
  $loan&minus;&gt;principal(123654);
  $loan&minus;&gt;interest_rate(9.25);
  $loan&minus;&gt;term(20); # twenty years
  # NOW we know enough to calculate:
  $loan&minus;&gt;run;
  # And see what came of that:
  print
    &quot;Total paid toward interest: A WHOPPING &quot;,
    $loan&minus;&gt;total_paid_interest, &quot;!!\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">This
illustrates a convention that&rsquo;s common with accessors:
calling the accessor with no arguments (as with
<tt>$loan</tt>&minus;&gt;total_paid_interest) usually means
to read the value of that attribute, but providing a value
(as with <tt>$loan</tt>&minus;&gt;term(20)) means you want
that attribute to be set to that value. This stands to
reason: why would you be providing a value, if not to set
the attribute to that value?</p>

<p style="margin-left:11%; margin-top: 1em">Although a
loan&rsquo;s term, principal, and interest rates are all
single numeric values, an objects values can any kind of
scalar, or an array, or even a hash. Moreover, an
attribute&rsquo;s value(s) can be objects themselves. For
example, consider <small>MIDI</small> files (as I wrote
about in TPJ#13): a <small>MIDI</small> file usually
consists of several tracks. A <small>MIDI</small> file is
complex enough to merit being an object with attributes like
its overall tempo, the file-format variant it&rsquo;s in,
and the list of instrument tracks in the file. But tracks
themselves are complex enough to be objects too, with
attributes like their track-type, a list of
<small>MIDI</small> commands if they&rsquo;re a
<small>MIDI</small> track, or raw data if they&rsquo;re not.
So I ended up writing the <small>MIDI</small> modules so
that the &quot;tracks&quot; attribute of a MIDI::Opus object
is an array of objects from the class MIDI::Track. This may
seem like a runaround -- you ask what&rsquo;s in one object,
and get <i>another</i> object, or several! But in this case,
it exactly reflects what the module is for --
<small>MIDI</small> files contain <small>MIDI</small>
tracks, which then contain data.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What is an
Object Value?</b> <br>
When you call a constructor like
Net::FTP&minus;&gt;new(<i>hostname</i>), you get back an
object value, a value you can later use, in combination with
a method name, to call object methods.</p>

<p style="margin-left:11%; margin-top: 1em">Now, so far
we&rsquo;ve been pretending, in the above examples, that the
variables <tt>$session</tt> or <tt>$loan</tt> <i>are</i> the
objects you&rsquo;re dealing with. This idea is innocuous up
to a point, but it&rsquo;s really a misconception that will,
at best, limit you in what you know how to do. The reality
is not that the variables <tt>$session</tt> or
<tt>$query</tt> are objects; it&rsquo;s a little more
indirect -- they <i>hold</i> values that symbolize objects.
The kind of value that <tt>$session</tt> or <tt>$query</tt>
hold is what I&rsquo;m calling an object value.</p>

<p style="margin-left:11%; margin-top: 1em">To understand
what kind of value this is, first think about the other
kinds of scalar values you know about: The first two scalar
values you probably ever ran into in Perl are <b>numbers</b>
and <b>strings</b>, which you learned (or just assumed) will
usually turn into each other on demand; that is, the
three-character string &quot;2.5&quot; can become the
quantity two and a half, and vice versa. Then, especially if
you started using <tt>&quot;perl &minus;w&quot;</tt> early
on, you learned about the <b>undefined value</b>, which can
turn into 0 if you treat it as a number, or the empty-string
if you treat it as a string.</p>

<p style="margin-left:17%; margin-top: 1em">Footnote: You
may <i>also</i> have been learning about references, in
which case you&rsquo;re ready to hear that object values are
just a kind of reference, except that they reflect the class
that created thing they point to, instead of merely being a
plain old array reference, hash reference, etc. <i>If</i>
this makes makes sense to you, and you want to know more
about how objects are implemented in Perl, have a look at
the <tt>&quot;perltoot&quot;</tt> man page.</p>

<p style="margin-left:11%; margin-top: 1em">And now
you&rsquo;re learning about <b>object values</b>. An object
value is a value that points to a data structure somewhere
in memory, which is where all the attributes for this object
are stored. That data structure as a whole belongs to a
class (probably the one you named in the constructor method,
like ClassName&minus;&gt;new), so that the object value can
be used as part of object method calls.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
actually <i>see</i> what an object value is, you might try
just saying &quot;print <tt>$object</tt>&quot;.
That&rsquo;ll get you something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  Net::FTP=GLOB(0x20154240)</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:11%; margin-top: 1em">  Business::US_Amort=HASH(0x15424020)</pre>


<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
not very helpful if you wanted to really get at the
object&rsquo;s insides, but that&rsquo;s because the object
value is only a symbol for the object. This may all sound
very abstruse and metaphysical, so a real-world allegory
might be very helpful:</p>

<p style="margin-left:17%; margin-top: 1em">You get an
advertisement in the mail saying that you have been
(im)personally selected to have the rare privilege of
applying for a credit card. For whatever reason, <i>this</i>
offer sounds good to you, so you fill out the form and mail
it back to the credit card company. They gleefully approve
the application and create your account, and send you a card
with a number on it.</p>

<p style="margin-left:17%; margin-top: 1em">Now, you can do
things with the number on that card -- clerks at stores can
ring up things you want to buy, and charge your account by
keying in the number on the card. You can pay for things you
order online by punching in the card number as part of your
online order. You can pay off part of the account by sending
the credit card people some of your money (well, a check)
with some note (usually the pre-printed slip) that has the
card number for the account you want to pay toward. And you
should be able to call the credit card company&rsquo;s
computer and ask it things about the card, like its balance,
its credit limit, its <small>APR,</small> and maybe an
itemization of recent purchases ad payments.</p>

<p style="margin-left:17%; margin-top: 1em">Now, what
you&rsquo;re <i>really</i> doing is manipulating a credit
card <i>account</i>, a completely abstract entity with some
data attached to it (balance, <small>APR,</small> etc). But
for ease of access, you have a credit card <i>number</i>
that is a symbol for that account. Now, that symbol is just
a bunch of digits, and the number is effectively meaningless
and useless in and of itself -- but in the appropriate
context, it&rsquo;s understood to <i>mean</i> the credit
card account you&rsquo;re accessing.</p>

<p style="margin-left:11%; margin-top: 1em">This is exactly
the relationship between objects and object values, and from
this analogy, several facts about object values are a bit
more explicable:</p>

<p style="margin-left:11%; margin-top: 1em">* An object
value does nothing in and of itself, but it&rsquo;s useful
when you use it in the context of an
<tt>$object</tt>&minus;&gt;method call, the same way that a
card number is useful in the context of some operation
dealing with a card account.</p>

<p style="margin-left:11%; margin-top: 1em">Moreover,
several copies of the same object value all refer to the
same object, the same way that making several copies of your
card number won&rsquo;t change the fact that they all still
refer to the same single account (this is true whether
you&rsquo;re &quot;copying&quot; the number by just writing
it down on different slips of paper, or whether you go to
the trouble of forging exact replicas of your own plastic
credit card). That&rsquo;s why this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $x = Net::FTP&minus;&gt;new(&quot;ftp.aol.com&quot;);
  $x&minus;&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">does the same
thing as this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $x = Net::FTP&minus;&gt;new(&quot;ftp.aol.com&quot;);
  $y = $x;
  $z = $y;
  $z&minus;&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">That is,
<tt>$z</tt> and <tt>$y</tt> and <tt>$x</tt> are three
different <i>slots</i> for values, but what&rsquo;s in those
slots are all object values pointing to the same object --
you don&rsquo;t have three different <small>FTP</small>
connections, just three variables with values pointing to
the some single <small>FTP</small> connection.</p>

<p style="margin-left:11%; margin-top: 1em">* You
can&rsquo;t tell much of anything about the object just by
looking at the object value, any more than you can see your
credit account balance by holding the plastic card up to the
light, or by adding up the digits in your credit card
number.</p>

<p style="margin-left:11%; margin-top: 1em">* You
can&rsquo;t just make up your own object values and have
them work -- they can come only from constructor methods of
the appropriate class. Similarly, you get a credit card
number <i>only</i> by having a bank approve your application
for a credit card account -- at which point <i>they</i> let
<i>you</i> know what the number of your new card is.</p>

<p style="margin-left:11%; margin-top: 1em">Now,
there&rsquo;s even more to the fact that you can&rsquo;t
just make up your own object value: even though you can
print an object value and get a string like
&quot;Net::FTP=GLOB(0x20154240)&quot;, that string is just a
<i>representation</i> of an object value.</p>

<p style="margin-left:11%; margin-top: 1em">Internally, an
object value has a basically different type from a string,
or a number, or the undefined value -- if <tt>$x</tt> holds
a real string, then that value&rsquo;s slot in memory says
&quot;this is a value of type <i>string</i>, and its
characters are...&quot;, whereas if it&rsquo;s an object
value, the value&rsquo;s slot in memory says, &quot;this is
a value of type <i>reference</i>, and the location in memory
that it points to is...&quot; (and by looking at
what&rsquo;s at that location, Perl can tell the class of
what&rsquo;s there).</p>

<p style="margin-left:11%; margin-top: 1em">Perl
programmers typically don&rsquo;t have to think about all
these details of Perl&rsquo;s internals. Many other
languages force you to be more conscious of the differences
between all of these (and also between types of numbers,
which are stored differently depending on their size and
whether they have fractional parts). But Perl does its best
to hide the different types of scalars from you -- it turns
numbers into strings and back as needed, and takes the
string or number representation of undef or of object values
as needed. However, you can&rsquo;t go from a string
representation of an object value, back to an object value.
And that&rsquo;s why this doesn&rsquo;t work:</p>

<pre style="margin-left:11%; margin-top: 1em">   $x = Net::FTP&minus;&gt;new('ftp.aol.com');
   $y = Net::FTP&minus;&gt;new('ftp.netcom.com');
   $z = Net::FTP&minus;&gt;new('ftp.qualcomm.com');
   $all = join(' ', $x,$y,$z);           # !!!
  ...later...
   ($aol, $netcom, $qualcomm) = split(' ', $all);  # !!!
   $aol&minus;&gt;login(&quot;sburke&quot;, &quot;aoeuaoeu&quot;);
   $netcom&minus;&gt;login(&quot;sburke&quot;, &quot;qjkxqjkx&quot;);
   $qualcomm&minus;&gt;login(&quot;smb&quot;, &quot;dhtndhtn&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">This fails
because <tt>$aol</tt> ends up holding merely the <b>string
representation</b> of the object value from <tt>$x</tt>, not
the object value itself -- when <tt>&quot;join&quot;</tt>
tried to join the characters of the &quot;strings&quot;
<tt>$x</tt>, <tt>$y</tt>, and <tt>$z</tt>, Perl saw that
they weren&rsquo;t strings at all, so it gave
<tt>&quot;join&quot;</tt> their string representations.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
this distinction between object values and their string
representations doesn&rsquo;t really fit into the analogy of
credit card numbers, because credit card numbers really
<i>are</i> numbers -- even thought they don&rsquo;t express
any meaningful quantity, if you stored them in a database as
a quantity (as opposed to just an <small>ASCII</small>
string), that wouldn&rsquo;t stop them from being valid as
credit card numbers.</p>

<p style="margin-left:11%; margin-top: 1em">This may seem
rather academic, but there&rsquo;s there&rsquo;s two common
mistakes programmers new to objects often make, which make
sense only in terms of the distinction between object values
and their string representations:</p>

<p style="margin-left:11%; margin-top: 1em">The first
common error involves forgetting (or never having known in
the first place) that when you go to use a value as a hash
key, Perl uses the string representation of that value. When
you want to use the numeric value two and a half as a key,
Perl turns it into the three-character string
&quot;2.5&quot;. But if you then want to use that string as
a number, Perl will treat it as meaning two and a half, so
you&rsquo;re usually none the wiser that Perl converted the
number to a string and back. But recall that Perl
can&rsquo;t turn strings back into objects -- so if you
tried to use a Net::FTP object value as a hash key, Perl
actually used its string representation, like
&quot;Net::FTP=GLOB(0x20154240)&quot;, but that string is
unusable as an object value. (Incidentally, there&rsquo;s a
module Tie::RefHash that implements hashes that <i>do</i>
let you use real object-values as keys.)</p>

<p style="margin-left:11%; margin-top: 1em">The second
common error with object values is in trying to save an
object value to disk (whether printing it to a file, or
storing it in a conventional database file). All
you&rsquo;ll get is the string, which will be useless.</p>

<p style="margin-left:11%; margin-top: 1em">When you want
to save an object and restore it later, you may find that
the object&rsquo;s class already provides a method
specifically for this. For example, MIDI::Opus provides
methods for writing an object to disk as a standard
<small>MIDI</small> file. The file can later be read back
into memory by a MIDI::Opus constructor method, which will
return a new MIDI::Opus object representing whatever file
you tell it to read into memory. Similar methods are
available with, for example, classes that manipulate graphic
images and can save them to files, which can be read back
later.</p>

<p style="margin-left:11%; margin-top: 1em">But some
classes, like Business::US_Amort, provide no such methods
for storing an object in a file. When this is the case, you
can try using any of the Data::Dumper, Storable, or
FreezeThaw modules. Using these will be unproblematic for
objects of most classes, but it may run into limitations
with others. For example, a Business::US_Amort object can be
turned into a string with Data::Dumper, and that string
written to a file. When it&rsquo;s restored later, its
attributes will be accessible as normal. But in the unlikely
case that the loan object was saved in mid-calculation, the
calculation may not be resumable. This is because of the way
that that <i>particular</i> class does its calculations, but
similar limitations may occur with objects from other
classses.</p>

<p style="margin-left:11%; margin-top: 1em">But often, even
<i>wanting</i> to save an object is basically wrong -- what
would saving an ftp <i>session</i> even mean? Saving the
hostname, username, and password? current directory on both
machines? the local <small>TCP/IP</small> port number? In
the case of &quot;saving&quot; a Net::FTP object,
you&rsquo;re better off just saving whatever details you
actually need for your own purposes, so that you can make a
new object later and just set those values for it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>So Why Do
Some Modules Use Objects?</b> <br>
All these details of using objects are definitely enough to
make you wonder -- is it worth the bother? If you&rsquo;re a
module author, writing your module with an object-oriented
interface restricts the audience of potential users to those
who understand the basic concepts of objects and object
values, as well as Perl&rsquo;s syntax for calling methods.
Why complicate things by having an object-oriented
interface?</p>

<p style="margin-left:11%; margin-top: 1em">A somewhat
esoteric answer is that a module has an object-oriented
interface because the module&rsquo;s insides are written in
an object-oriented style. This article is about the basics
of object-oriented <i>interfaces</i>, and it&rsquo;d be
going far afield to explain what object-oriented
<i>design</i> is. But the short story is that
object-oriented design is just one way of attacking messy
problems. It&rsquo;s a way that many programmers find very
helpful (and which others happen to find to be far more of a
hassle than it&rsquo;s worth, incidentally), and it just
happens to show up for you, the module user, as merely the
style of interface.</p>

<p style="margin-left:11%; margin-top: 1em">But a simpler
answer is that a functional interface is sometimes a
hindrance, because it limits the number of things you can do
at once -- limiting it, in fact, to one. For many problems
that some modules are meant to solve, doing without an
object-oriented interface would be like wishing that Perl
didn&rsquo;t use filehandles. The ideas are rather simpler
-- just imagine that Perl let you access files, but
<i>only</i> one at a time, with code like:</p>

<pre style="margin-left:11%; margin-top: 1em">  open(&quot;foo.txt&quot;) || die &quot;Can't open foo.txt: $!&quot;;
  while(readline) {
    print $_ if /bar/;
  }
  close;</pre>


<p style="margin-left:11%; margin-top: 1em">That
hypothetical kind of Perl would be simpler, by doing without
filehandles. But you&rsquo;d be out of luck if you wanted to
read from one file while reading from another, or read from
two and print to a third.</p>

<p style="margin-left:11%; margin-top: 1em">In the same
way, a functional <small>FTP</small> module would be fine
for just uploading files to one server at a time, but it
wouldn&rsquo;t allow you to easily write programs that make
need to use <i>several</i> simultaneous sessions (like
&quot;look at server A and server B, and if A has a file
called X.dat, then download it locally and then upload it to
server B -- except if B has a file called Y.dat, in which
case do it the other way around&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Some kinds of
problems that modules solve just lend themselves to an
object-oriented interface. For those kinds of tasks, a
functional interface would be more familiar, but less
powerful. Learning to use object-oriented modules&rsquo;
interfaces does require becoming comfortable with the
concepts from this article. But in the end it will allow you
to use a broader range of modules and, with them, to write
programs that can do more.</p>

<p style="margin-left:11%; margin-top: 1em"><b>[end body of
article]</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>[Author
Credit]</b> <br>
Sean M. Burke has contributed several modules to
<small>CPAN,</small> about half of them object-oriented.</p>

<p style="margin-left:11%; margin-top: 1em">[The next
section should be in a greybox:]</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Gory
Details</b> <br>
For sake of clarity of explanation, I had to oversimplify
some of the facts about objects. Here&rsquo;s a few of the
gorier details:</p>

<p style="margin-left:11%; margin-top: 1em">* Every example
I gave of a constructor was a class method. But object
methods can be constructors, too, if the class was written
to work that way: <tt>$new</tt> =
<tt>$old</tt>&minus;&gt;copy, <tt>$node_y</tt> =
<tt>$node_x</tt>&minus;&gt;new_subnode, or the like.</p>

<p style="margin-left:11%; margin-top: 1em">* I&rsquo;ve
given the impression that there&rsquo;s two kinds of
methods: object methods and class methods. In fact, the same
method can be both, because it&rsquo;s not the kind of
method it is, but the kind of calls it&rsquo;s written to
accept -- calls that pass an object, or calls that pass a
class-name.</p>

<p style="margin-left:11%; margin-top: 1em">* The term
&quot;object value&quot; isn&rsquo;t something you&rsquo;ll
find used much anywhere else. It&rsquo;s just my shorthand
for what would properly be called an &quot;object
reference&quot; or &quot;reference to a blessed item&quot;.
In fact, people usually say &quot;object&quot; when they
properly mean a reference to that object.</p>

<p style="margin-left:11%; margin-top: 1em">* I mentioned
creating objects with <i>con</i>structors, but I
didn&rsquo;t mention destroying them with <i>de</i>structor
-- a destructor is a kind of method that you call to tidy up
the object once you&rsquo;re done with it, and want it to
neatly go away (close connections, delete temporary files,
free up memory, etc). But because of the way Perl handles
memory, most modules won&rsquo;t require the user to know
about destructors.</p>

<p style="margin-left:11%; margin-top: 1em">* I said that
class method syntax has to have the class name, as in
<tt>$session</tt> = <b>Net::FTP</b>&minus;&gt;new($host).
Actually, you can instead use any expression that returns a
class name: <tt>$ftp_class</tt> = &rsquo;Net::FTP&rsquo;;
<tt>$session</tt> = <b>$ftp_class</b>&minus;&gt;new($host).
Moreover, instead of the method name for object&minus; or
class-method calls, you can use a scalar holding the method
name: <tt>$foo</tt>&minus;&gt;<b>$method</b>($host). But, in
practice, these syntaxes are rarely useful.</p>

<p style="margin-left:11%; margin-top: 1em">And finally, to
learn about objects from the perspective of writing your own
classes, see the <tt>&quot;perltoot&quot;</tt>
documentation, or Damian Conway&rsquo;s exhaustive and clear
book <i>Object Oriented Perl</i> (Manning Publications 1999,
<small>ISBN 1&minus;884777&minus;79&minus;1</small> ).</p>

<h2>BACK
<a name="BACK"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Return to the
HTML::Tree docs.</p>
<hr>
</body>
</html>
