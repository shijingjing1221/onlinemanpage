<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov  5 22:01:07 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DKMS</title>

</head>
<body>

<h1 align="center">DKMS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ACTIONS">ACTIONS</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ORIGINAL MODULES">ORIGINAL MODULES</a><br>
<a href="#DKMS.CONF">DKMS.CONF</a><br>
<a href="#DKMS.CONF VARIABLES">DKMS.CONF VARIABLES</a><br>
<a href="#DKMS.CONF OVERRIDES">DKMS.CONF OVERRIDES</a><br>
<a href="#/etc/dkms/framework.conf">/etc/dkms/framework.conf</a><br>
<a href="#dkms_autoinstaller">dkms_autoinstaller</a><br>
<a href="#MODULES.CONF / MODPROBE.CONF CHANGES">MODULES.CONF / MODPROBE.CONF CHANGES</a><br>
<a href="#CREATING RPMS WHICH UTILIZE DKMS">CREATING RPMS WHICH UTILIZE DKMS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#WEBPAGE">WEBPAGE</a><br>
<a href="#WHITE&minus;PAPERS">WHITE&minus;PAPERS</a><br>
<a href="#MAILING&minus;LIST">MAILING&minus;LIST</a><br>
<a href="#REFERENCES">REFERENCES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">dkms &minus;
Dynamic Kernel Module Support</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>dkms</b></p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">[<b>action</b>] [<b>options</b>]
[<b>module/module-version</b>] [<b>/path/to/source-tree</b>]
[<b>/path/to/tarball.tar</b>]
[<b>/path/to/driver.rpm</b>]</p> </td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>dkms</b> is
a framework which allows kernel modules to be dynamically
built for each kernel on your system in a simplified and
organized fashion.</p>

<h2>ACTIONS
<a name="ACTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>add</b></p></td>
<td width="2%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>/path/to/source&minus;tree</b>]
[<b>/path/to/tarball.tar</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">
</td>
<td width="2%"></td>
<td width="83%">


<p>Adds a module/module&minus;version combination to the
tree for builds and installs. If
module/module&minus;version, &minus;m
module/module&minus;version, or &minus;m
module&nbsp;&minus;v version are passed as options, this
command requires source in
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/</i>
as well as a properly formatted <i>dkms.conf</i> file. If
<i>/path/to/source&minus;tree</i> is passed as an option,
and source-tree contains a <i>dkms.conf</i> file, it will
copy <i>/path/to/source&minus;tree</i> to
<i>/usr/src/module&minus;module&minus;version.</i> If
<i>/path/to/tarball.tar</i> is passed, this command behaves
like the <b>ldtarball</b> command.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>remove</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>&minus;&minus;all</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Removes a module/version or module/version/kernel/arch
combination from the tree. If the module is currently
installed, it first uninstalls it and if applicable, will
replace it with its original_module. Use the
<b>&minus;&minus;all</b> option in order to remove all
instances for every kernel at once.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>build</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Builds the specified module/version combo for the
specified kernel/arch. If the <i>&minus;k</i> option is not
specified it builds for the currently running kernel and
arch.. All builds occur in the directory
<i>/var/lib/dkms/&lt;module&gt;/&lt;module&minus;version&gt;/build/.</i>
If the module/module&minus;version combo has not been added,
dkms will try to add it, and in that case <b>build</b> can
take the same arguments that <b>add</b> can.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>install</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>/path/to/driver.rpm</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Installs a built module/version combo onto the kernel it
was built for. If the kernel option is not specified it
assumes the currently running kernel. If the module has not
been built, dkms will try to build it. If the module has not
been added, dkms will try to add it. In both cases, the
<b>install</b> command can then take the same arguments as
the <b>build</b> or <b>add</b> commands. If you pass a .rpm
file, dkms will try to install that file with <b>rpm
-Uvh</b> , and it will perform an <b>autoinstall</b> action
to mesure that everything is built for your kernel if the
RPM installed sucessfully.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>uninstall</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Uninstalls an installed module/module&minus;version
combo from the kernel/arch passed in the -k option, or the
current kernel if the -k option was not passed. upon. After
uninstall completion, the driver will be left in the built
state. To completely remove a driver, the remove action
should be utilized.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>match</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>--templatekernel&nbsp;</b><i>kernel/arch</i>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Match installs modules onto the specified kernel by
looking at the configuration of the specified
<b>templatekernel.</b> Every module that is installed on the
<b>templatekernel</b> within <b>dkms</b> is then installed
on that specified kernel.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>mkdriverdisk</b></p><td width="17%"></td>
<td width="83%">


<p style="margin-top: 1em">[<b>-d&nbsp;</b><i>distro</i>]
[<b>-r&nbsp;</b><i>release</i>]
[<b>--media&nbsp;</b><i>mediatype</i>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>module/version</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Creates a floppy driver disk image for use when updated
drivers are needed to install an OS. Currently, the
supported distributions are redhat, suse and UnitedLinux.
For Red Hat driver disks, necessary driver disk files are
looked for in the redhat_driver_disk subdirectory of your
module source directory. You must specify the distro while
using this action. Driver disks can be made for single
kernels or can be made to support multiple kernels. To
create a driver disk image with modules for multiple
kernels, just specify multiple &minus;k parameters on the
command line (&minus;k kernel1/arch1 &minus;k
kernel2/arch2).</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Red Hat began
supporting multi-arched driver disks in RHEL3. To force
creation of a driver disk with arch information, specify
<b>&minus;d redhat2</b> or if you specify multiple
architectures on the command-line and use <b>&minus;d
redhat</b> , DKMS will create a version 2 driver disk. By
specifying <b>&minus;d redhat1</b> , you can force a version
1 driver disk image.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
redhat1 driver disks actually supported multiple
architectures when the second arch was i386 and the kernel
module was for the BOOT kernel. DKMS allows for this, and as
such you can create a redhat1 style driver disk if the only
other arch is i386 and the kernel name ends in BOOT.</p>

<p style="margin-left:17%; margin-top: 1em">Red Hat
introduced DDv3 starting with RHEL6. To create Red Hat DDv3,
specify <b>&minus;d redhat3</b> and specify the specfile to
use with <i>&minus;&minus;spec=specfile.</i> If no specfile
is specified, DKMS will use
<i>/etc/dkms/template&minus;dkms&minus;redhat&minus;kmod.spec</i></p>

<p style="margin-left:17%; margin-top: 1em">See
<i>http://people.redhat.com/dledford</i> for more
information on the Red Hat driver disk standards and which
files are necessary to make a driver disk.</p>

<p style="margin-left:17%; margin-top: 1em">Fedora Core 5
and higher, RHEL5 and higher require DKMS version 2.0.14 or
higher to generate a proper driver disk image.</p>

<p style="margin-left:17%; margin-top: 1em">For
suse/UnitedLinux driver disks,
/usr/share/YaST2/modules/Vendor.ycp will also be copied to
the driver disk; no other files are needed. However, for
these distros, you must specify a &minus;r release. For SuSE
9.1, it would be &minus;d suse &minus;r 9.1. For SLES9, it
would be &minus;d suse &minus;r sles9.</p>

<p style="margin-left:17%; margin-top: 1em">By default the
disk image it creates is 1440 (k) in size. This can be
overridden by specifying a different <b>&minus;&minus;size
####</b> which should should be given as a number in
kilobytes divisible by 20.</p>

<p style="margin-left:17%; margin-top: 1em">You may have
more content than will fit on a floppy. Therefore, DKMS can
now generate image files of different types.
<b>&minus;&minus;media floppy (default)</b> to generate a
floppy disk image, or <b>&minus;&minus;media iso</b> to
generate a CD-ROM ISO file, or <b>&minus;&minus;media
tar</b> to generate a tar file.</p>

<p style="margin-left:17%; margin-top: 1em">You may copy
the floppy or ISO image file to a USB key to be used with OS
installer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>mktarball</b></p></td>
<td width="1%"></td>
<td width="74%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>--archive&nbsp;</b><i>/path/to/tarball.tar</i>]
[<b>--source-only</b>] [<b>--binaries-only</b>]</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Creates a
tarball archive for the specified module/version of all
files in the DKMS tree for that module/version combination.
This includes the source and any built modules for kernels
in the tree (as specified). Otherwise, you can specify a
singular kernel to archive only, or multiple kernels to
archive (&minus;k kernel1/arch1 &minus;k kernel2/arch2).
Optionally, you can use <b>&minus;&minus;archive</b> to
specify the file that you would like to save this tarball
to. You can also specify
<b>&minus;&minus;binaries&minus;only</b> if you want the
resultant tarball not to include the module source.
Likewise, <b>&minus;&minus;source-only</b> can be used to
specify that no prebuilt binaries should be included in the
tarball. In general, <b>mktarball</b> is great for systems
management purposes as you can build your driver on just one
system and then use <b>ldtarball</b> on all of your other
systems to get the same built modules loaded without having
to wait for anything to compile.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>ldtarball</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This takes a
tarball made from the <b>mktarball</b> command and loads it
into your DKMS tree. This will leave any newly added modules
in the built state and <b>dkms install</b> should then be
called to install any of them. If files already exist where
<b>ldtarball</b> is attempting to place them, it will warn
and not copy over them. The <b>&minus;&minus;force</b>
option should be used to override this.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>mkrpm</b></p></td>
<td width="2%"></td>
<td width="80%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>] [<b>--source-only</b>]
[<b>--binaries-only</b>]</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This action
allows you to create an RPM package for a specified module /
version. It uses a template .spec file found in
<i>/etc/dkms/template&minus;dkms&minus;mkrpm.spec</i> as the
basis for the RPM. Alternatively, if DKMS finds a file
called
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/&lt;module&gt;&minus;dkms&minus;mkrpm.spec</i>
it will use that .spec file instead. In general, a DKMS
tarball is placed inside the contents of this RPM, and the
RPM itself calls various DKMS commands to load this tarball,
build and install modules on the end user&rsquo;s system. If
you do not want your RPM to contain any prebuilt binaries,
be sure to specify <b>&minus;&minus;source&minus;only</b> in
the mkrpm command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p style="margin-top: 1em"><b>mkdeb</b></p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:20%;">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>] [<b>--binaries-only</b>]
[<b>--source-only</b>]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>This action allows you to create a debian binary package
for a specified module / version. It uses a template debian
directory found in
<i>/etc/dkms/template&minus;dkms&minus;mkdeb</i> as the
basis for the package. Alternatively, if DKMS finds a file
called
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/&lt;module&gt;&minus;dkms&minus;mkdeb</i>
it will use that folder instead. In general, a DKMS tarball
is placed inside the contents of this package, and the
package itself calls various DKMS commands to load this
tarball, build and install modules on the end user&rsquo;s
system. If you do not want your debian package to contain
any prebuilt binaries, be sure to specify
<b>&minus;&minus;source&minus;only</b> in the mkdeb
command.</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>mkdsc</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>] [<b>--binaries-only</b>]
[<b>--source-only</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>This action allows you to create a debian source package
for a specified module / version. It will create a .tar.gz,
and a .dsc. All options supported by <b>mkdeb</b> are
supported by it. The main difference in it&rsquo;s usage is
that it will look in
<i>/etc/dkms/template&minus;dkms&minus;mkdsc</i> as the
basis for the package. Alternatively, if DKMS finds a file
called
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/&lt;module&gt;&minus;dkms&minus;mkdsc</i>
it will use that folder instead. If you do not want your
debian source package to contain any prebuilt binaries, be
sure to specify <b>&minus;&minus;source&minus;only</b> in
the mkdsc command.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>mkkmp</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>--spec&nbsp;</b><i>specfile</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>This action allows you to create an Kernel Module
Package source RPM for a specified module / version. It uses
the .spec file specified by
<i>&minus;&minus;spec=specfile</i> else
<i>$module&minus;kmp.spec</i> as the basis for the RPM. The
generated source RPM may then be built using SuSE&rsquo;s
build.rpm or Fedora/RHEL&rsquo;s mock chroot environments.
See http://kerneldrivers.org/ for more details on KMPs.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>status</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Returns the current status of modules, versions and
kernels within the tree as well as whether they have been
added, built or installed. Status can be shown for just a
certain module, a certain kernel, a module/version
combination or a module/version/kernel combination.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>autoinstall</b></p><td width="17%"></td>
<td width="83%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Attempt to install the latest revision of all modules
that have been installed for other kernel revisions.
dkms_autoinstaller is a stub that uses this action to
perform its work.</p></td></tr>
</table>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;m
&lt;module&gt;/&lt;module&minus;version&gt;</b></p>

<p style="margin-left:22%;">The name of the module and
module version you wnat to operate on. The <b>&minus;m</b>
part of this option is optional, and can be omitted in
virtually all circumstances.</p>

<p style="margin-left:11%;"><b>&minus;v
&lt;module&minus;version&gt;</b></p>

<p style="margin-left:22%;">The version of the module to
execute the specified action upon. This option only has to
be specified if you pass a <b>&minus;m</b> option without a
&lt;module&minus;version&gt; component of its own.</p>

<p style="margin-left:11%;"><b>&minus;k
&lt;kernel&minus;version&gt;/&lt;arch&gt;</b></p>

<p style="margin-left:22%;">The kernel and arch to perform
the action upon. You can specify multiple kernel
version/arch pairs on the command line by repeating the
&minus;k argument with a different kernel version and arch.
However, not all actions support multiple kernel versions
(it will error out in this case). The arch part can be
omitted, and DKMS will assume you want it to be the arch of
the currently running system.</p>

<p style="margin-left:11%;"><b>&minus;a,
&minus;&minus;arch</b></p>

<p style="margin-left:22%;">The system architecture to
perform the action upon. It is optional if you pass it as
part of the <b>&minus;k</b> option. If not specified, it
assumes the arch of the currently running system
(&lsquo;uname &minus;m&lsquo;). You can specify multiple
arch parameters on the same command line by repeating the
&minus;a argument with a different arch name. When multiple
architectures are specified, there must be a 1:1
relationship between &minus;k arguments to &minus;a
arguments. DKMS will then assume the first &minus;a argument
aligns with the first &minus;k kernel and so on for the
second, third, etc.</p>

<p style="margin-left:22%; margin-top: 1em">For example, if
you were to specify: &minus;k kernel1 &minus;k kernel2
&minus;a i386 &minus;k kernel3 &minus;a i686 &minus;a
x86_64, DKMS would process this as: kernel1-i386,
kernel2-i686, kernel3-x86_64.</p>

<p style="margin-left:11%;"><b>&minus;q,
&minus;&minus;quiet</b></p>

<p style="margin-left:22%;">Quiet.</p>

<p style="margin-left:11%;"><b>&minus;V,
&minus;&minus;version</b></p>

<p style="margin-left:22%;">Prints the currently installed
version of dkms and exits.</p>

<p style="margin-left:11%;"><b>&minus;c
&lt;dkms.conf&minus;location&gt;</b></p>

<p style="margin-left:22%;">The location of the
<i>dkms.conf</i> file. This is needed for the add action and
if not specified, it is assumed to be located in
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/.</i>
See below for more information on the format of
<i>dkms.conf.</i></p>

<p style="margin-left:11%;"><b>&minus;d,
&minus;&minus;distro</b></p>

<p style="margin-left:22%;">The distribution being used.
This is only currently needed for <b>mkdriverdisk.</b> The
supported distros are <b>redhat, suse</b> and
<b>UnitedLinux.</b> See the sections on <b>mkdriverdisk</b>
and <b>mkkmp</b> for more information.</p>

<p style="margin-left:11%;"><b>&minus;r,
&minus;&minus;release</b></p>

<p style="margin-left:22%;">The release being used. This is
only currently used for <b>mkdriverdisk</b> and is only used
for suse or UnitedLinux distros (eg. &minus;r 9.1). It is
used in the internal makeup of the driverdisk.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;size</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The size of the driver disk image to be created. By
default, this value is set at 1440. Any different size
should be given as an integer value only, should be
divisible by 20 and should represent the number of kilobytes
of the image size you desire.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;config
&lt;kernel&minus;.config&minus;location&gt;</b></p>

<p style="margin-left:22%;">During a <b>build</b> this
option is used to specify an alternate location for the
kernel .config file which was used to compile that kernel.
Normally, <b>dkms</b> uses the Red Hat standard location and
config filenames located in
<i>/usr/src/linux&minus;&lt;kernel&gt;/configs/.</i> If the
config for the kernel that you are building a module for is
not located here or does not have the expected name in this
location, you will need to tell <b>dkms</b> where the
necessary .config can be found so that your kernel can be
properly prepared for the module build.</p>

<p style="margin-left:11%;"><b>&minus;&minus;archive
&lt;tarball&minus;location&gt;</b></p>

<p style="margin-left:22%;">This option is used during a
<b>ldtarball</b> action to specify the location of the
tarball you wish to load into your DKMS tree. You only have
to specify the <b>--archive</b> part of this option if
&lt;tarball&minus;location&gt; does not already exist as a
file.</p>


<p style="margin-left:11%;"><b>&minus;&minus;templatekernel
&lt;kernel&minus;version&gt;</b></p>

<p style="margin-left:22%;">This option is required for the
action: <b>match.</b> Match will look at the templatekernel
specified and install all of the same module/version
combinations on the other kernel.</p>

<p style="margin-left:11%;"><b>&minus;&minus;force</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>ldtarball</b> to force copying over of
extant files.</p>


<p style="margin-left:11%;"><b>&minus;&minus;binaries&minus;only</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>mktarball</b> in order to create a DKMS
tarball which does not contain the source for the module
within it. This can be helpful in reducing the size of the
tarball if you know that the system which this tarball will
be loaded upon already has the source installed. In order to
load a tarball made as binaries-only <b>you must</b> have
the module source in that systems DKMS tree. If you do not,
DKMS <b>will refuse</b> to load a binaries-only tarball.</p>


<p style="margin-left:11%;"><b>&minus;&minus;source&minus;only</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>mktarball</b> or <b>mkrpm</b> or
<b>mkdeb</b> in order to create a DKMS tarball which does
not contain any prebuilt kernel module binaries within it.
This is helpful if you simply want to easily tar up your
source but don&rsquo;t want anything prebuilt within it.
Likewise, if you are using <b>mkrpm</b> but do not want the
RPM you create to have any prebuilt modules within it,
passing this option will keep its internal DKMS tarball from
containing any prebuilt modules.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;all</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>This option can be used to automatically specify all
relevant kernels/arches for a module/module-version. This is
useful for things like <b>remove</b> , <b>mktarball</b> ,
etc. This saves the trouble of having to actually specify
&minus;k kernel1 &minus;a arch1 &minus;k kernel2 &minus;a
arch2 for every kernel you have built your module for.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;prepare&minus;kernel</b></p>

<p style="margin-left:22%;">This option keeps DKMS from
first preparing your kernel before building a module for it.
Generally, this option should not be used so as to ensure
that modules are compiled correctly.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;clean&minus;kernel</b></p>

<p style="margin-left:22%;">This option keeps DKMS from
cleaning your kernel source tree after a build.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;depmod</b></p>

<p style="margin-left:22%;">This option prevents DKMS from
running the depmod command during <b>install</b> and
<b>uninstall</b> which will avoid (re)calculating module
dependencies and thereby save time.</p>


<p style="margin-left:11%;"><b>&minus;&minus;kernelsourcedir
&lt;kernel&minus;source&minus;directory&minus;location&gt;</b></p>

<p style="margin-left:22%;">Using this option you can
specify the location of your kernel source directory. Most
likely you will not need to set this if your kernel source
is accessible via
<i>/lib/modules/$kernel_version/build.</i></p>

<p style="margin-left:11%;"><b>&minus;&minus;directive
&lt;&quot;cli&minus;directive=cli&minus;value&quot;&gt;</b></p>

<p style="margin-left:22%;">Using this option, you can
specify additional directives from the command line. The
<b>&minus;&minus;directive</b> option can be used multiple
times on the same command-line to specify multiple
additional command line directives.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rpm_safe_upgrade</b></p>

<p style="margin-left:22%;">This flag should be used when
packaging DKMS enabled modules in RPMs. It should be
specified during both the <b>add</b> and <b>remove</b>
actions in the RPM spec to ensure that DKMS and RPM behave
correctly in all scenarios when upgrading between various
versions of a dkms enabled module RPM package. See the
sample.spec file for an example or read more in the section
below on Creating RPMs Which Utilize DKMS.</p>

<p style="margin-left:11%;"><b>&minus;&minus;spec
specfile</b></p>

<p style="margin-left:22%;">This option is used by the
<b>mkkmp</b> action to specify which RPM spec file to use
when generating the KMP. <i>specfile</i> will be sought in
the module source directory.</p>

<p style="margin-left:11%;"><b>&minus;&minus;dkmstree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a destination tree for
building and installing modules to. Useful in cases that you
don&rsquo;t want to contaminate a system when using solely
for building.</p>

<p style="margin-left:11%;"><b>&minus;&minus;sourcetree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a location to build a
DKMS package from. Useful for systems that you may not have
root access, but would still like to be able to build DKMS
packages.</p>

<p style="margin-left:11%;"><b>&minus;&minus;installtree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a location to place
modules when a <i>dkms install</i> command is issued.</p>


<p style="margin-left:11%;"><b>&minus;&minus;legacy&minus;postinst=[0|1]</b></p>

<p style="margin-left:22%;">Includes a legacy postinstall
script so that a DEB or RPM built by DKMS can be used on
versions prior than DKMS 2.1. This option currently defaults
to 1.</p>

<p style="margin-left:11%;"><b>&minus;&minus;dkmsframework
path/to/file</b></p>

<p style="margin-left:22%;">A supplemental configuration
file to the system-wide dkms framework, typically located in
/etc/dkms/framework.conf. All option that are normally
provided on a command line can be provided in this file.</p>

<h2>ORIGINAL MODULES
<a name="ORIGINAL MODULES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">During the
first install of a module for a &lt;kernelversion&gt;,
<b>dkms</b> will search
<i>/lib/modules/&lt;kernelversion&gt;</i> for a pre-existing
module of the same name. If one is found, it will
automatically be saved as an &quot;original_module&quot; so
that if the newer module is later removed, <b>dkms</b> will
put the original module back in its place. Currently, DKMS
searches for these original modules with first preference
going to modules located in
<i>/lib/modules/&lt;kernelversion&gt;/updates/</i> followed
by <b>$DEST_MODULE_LOCATION</b> (as specified in
<i>dkms.conf</i> ). If one cannot be found in either
location, a find will be used to locate one for that kernel.
If none are found, then during a later uninstall, your
kernel will not have that module replaced.</p>

<p style="margin-left:11%; margin-top: 1em">If more than
one is found, then the first one located (by preference
indicated above) will be considered the
&quot;original_module&quot;. As well, all copies of the
same-named module will be removed from your kernel tree and
placed into
<i>/var/lib/dkms/&lt;module&gt;/original_module/$kernelver/collisions</i>
so that they can be *manually* accessible later. DKMS will
never actually do anything with the modules found underneath
the /collisions directory, and they will be stored there
until you manually delete them.</p>

<h2>DKMS.CONF
<a name="DKMS.CONF"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When performing
an <b>add</b> , a proper <i>dkms.conf</i> file must be
found. A properly formatted conf file is essential for
communicating to <b>dkms</b> how and where the module should
be installed. While not all the directives are required,
providing as many as possible helps to limit any ambiguity.
Note that the <i>dkms.conf</i> is really only a
shell&minus;script of variable definitions which are then
sourced in by the <b>dkms</b> executable (of the format,
DIRECTIVE=&quot;directive text goes here&quot;). As well,
the directives are case&minus;sensitive and should be given
in <b>ALL CAPS.</b></p>

<p style="margin-left:11%; margin-top: 1em">It is important
to understand that many of the DKMS directives are arrays
whose index values are tied together. These array
associations can be considered families, and there are
currently four such families of directive arrays. MAKE[#]
and MAKE_MATCH[#] make up one family. PATCH[#] and
PATCH_MATCH[#] make up the second family. The third and
largest family consists of BUILT_MODULE_NAME[#],
BUILT_MODULE_LOCATION[#], DEST_MODULE_NAME[#],
DEST_MODULE_LOCATION[#], MODULES_CONF_ALIAS_TYPE[#],
MODULES_CONF_OBSOLETES[#], MODULES_CONF_OBSOLETE_ONLY[#] and
STRIP[#]. The fourth family is made up of only
MODULES_CONF[#]. When indexing these arrays when creating
your dkms.conf, each family should start at index value 0.
<b><br>
MAKE[#]=</b></p>

<p style="margin-left:22%;">The MAKE directive array tells
DKMS which make command should be used for building your
module. The default make command should be put into
<b>MAKE[0].</b> Other entries in the MAKE array will only be
used if their corresponding entry in <b>MAKE_MATCH[#]</b>
matches, as a regular expression (using egrep), the kernel
that the module is being built for. Note that if no value is
placed in <b>MAKE_MATCH[#]</b> for any <b>MAKE[#]</b> where
# &gt; 0, then that <b>MAKE</b> directive is ignored.
<b>MAKE_MATCH[0]</b> is optional and if it is populated, it
will be used to determine if MAKE[0] should be used to build
the module for that kernel. If multiple <b>MAKE_MATCH</b>
directives match against the kernel being built for, the
last matching <b>MAKE[#]</b> will be used to build your
module. If no MAKE directive is specified or if no
MAKE_MATCH matches the kernel being built for, DKMS will
attempt to use a generic MAKE command to build your
module.</p>

<p style="margin-left:22%; margin-top: 1em">KERNELRELEASE
will be automatically appended to MAKE[#]. If you want to
suppress this behavior, you can quote the make command:
&rsquo;make&rsquo;.</p>

<p style="margin-left:11%;"><b>MAKE_MATCH[#]=</b></p>

<p style="margin-left:22%;">See the above entry on
<b>MAKE[#]</b> directives. This array should be populated
with regular expressions which, when matched against the
kernel being built for, will tell <b>DKMS</b> to use the
corresponding make command in the <b>MAKE[#]</b> directive
array to build your module.</p>


<p style="margin-left:11%;"><b>BUILT_MODULE_NAME[#]=</b></p>

<p style="margin-left:22%;">This directive gives the name
of the module just after it is built. If your DKMS module
package contains more than one module to install, this is a
<b>required</b> directive for all of the modules. This
directive should explicitly not contain any trailing
&quot;.o&quot; or &quot;.ko&quot;. Note that for each module
within a dkms package, the numeric value of <b>#</b> must be
the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg. BUILT_MODULE_NAME[0]=&quot;qla2200&quot;
BUILT_MODULE_NAME[1]=&quot;qla2300&quot;).</p>


<p style="margin-left:11%;"><b>BUILT_MODULE_LOCATION[#]=</b></p>

<p style="margin-left:22%;">This directive tells DKMS where
to find your built module after it has been built. This
pathname should be given relative to the root directory of
your source files (where your dkms.conf file can be found).
If unset, DKMS expects to find your
<b>BUILT_MODULE_NAME[#]</b> in the root directory of your
source files. Note that for each module within a dkms
package, the numeric value of <b>#</b> must be the same for
each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the
numbering should start at 0 (eg.
BUILT_MODULE_LOCATION[0]=&quot;some/dir/&quot;
BUILT_MODULE_LOCATION[1]=&quot;other/dir/&quot;).</p>


<p style="margin-left:11%;"><b>DEST_MODULE_NAME[#]=</b></p>

<p style="margin-left:22%;">This directive can be used to
specify the name of the module as it should be installed.
This will rename the module from <b>BUILT_MODULE_NAME[#]</b>
to <b>DEST_MODULE_NAME[#].</b> This directive should
explicitly not contain any trailing &quot;.o&quot; or
&quot;.ko&quot;. If unset, it is assumed to be the same
value as <b>BUILT_MODULE_NAME[#].</b> Note that for each
module within a dkms package, the numeric value of <b>#</b>
must be the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg. DEST_MODULE_NAME[0]=&quot;qla2200_6x&quot;
DEST_MODULE_NAME[1]=&quot;qla2300_6x&quot;).</p>


<p style="margin-left:11%;"><b>DEST_MODULE_LOCATION[#]=</b></p>

<p style="margin-left:22%;">This directive specifies the
destination where a module should be installed to, once
compiled. It also is used for finding original_modules. This
is a <b>required</b> directive, except as noted below. This
directive must start with the text &quot;/kernel&quot; which
is in reference to
/lib/modules/&lt;kernelversion&gt;/kernel. Note that for
each module within a dkms package, the numeric value of
<b>#</b> must be the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg.
DEST_MODULE_LOCATION[0]=&quot;/kernel/drivers/something/&quot;
DEST_MODULE_LOCATION[1]=&quot;/kernel/drivers/other/&quot;).</p>


<p style="margin-left:22%; margin-top: 1em">DEST_MODULE_LOCATION
is ignored on Fedora Core 6 and higher, Red Hat Enterprise
Linux 5 and higher, Novell SuSE Linux Enterprise Server 10
and higher, Novell SuSE Linux 10.0 and higher, and Ubuntu.
Instead, the proper distribution-specific directory is
used.</p>


<p style="margin-left:11%;"><b>MODULES_CONF_ALIAS_TYPE[#]=</b></p>

<p style="margin-left:22%;">This directive array specifies
how your modules should be aliased in
<i>/etc/modules.conf</i> when your module is installed. This
is done in an intelligent fashion so if DKMS detects an
already existing reference in modules.conf, it won&rsquo;t
add a new line. If it is not detected, it will add it to the
modules.conf as the last alias number for that alias type
(eg. if
MODULES_CONF_ALIAS_TYPE=&quot;scsi_hostadapter&quot;, no
alias currently exists for that module and the last
scsi_hostadapter reference is 6, then your module will be
added as &quot;scsi_hostadapter7&quot;). Common values for
this directive include: <b>scsi_hostadapter</b> ,
<b>sound&minus;slot&minus;</b> and <b>eth.</b> Note that the
numeric value of <b>#</b> is tied to the index of
BUILD_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME
and DEST_MODULE_LOCATION. The index is also tied to
MODULES_CONF_OBSOLETES.</p>


<p style="margin-left:11%;"><b>MODULES_CONF_OBSOLETES[#]=</b></p>

<p style="margin-left:22%;">This directive array tells DKMS
what modules.conf alias references are obsoleted by the
module you are installing. If your module obsoletes more
than one module, this directive should be a
comma&minus;delimited list of those modules that are
obsoleted (eg. for megaraid2,
MODULES_CONF_OBSOLETES[0]=&quot;megaraid,megaraid_2002&quot;).
When you are installing your module, DKMS ensures that any
entries in <i>/etc/modules.conf</i> with the same
<b>MODULES_CONF_ALIAS_TYPE</b> are changed over to the new
module name. When you are uninstalling your module,
depending on the modules in your <i>/lib/modules</i> tree,
DKMS will take different actions. If you kernel has an
original_module, then modules.conf will not be touched and
the non&minus;obsolete reference will remain. If the kernel
does not have an original_module but does have one of the
obsolete modules, it will replace those references with the
first obsolete module name in the comma&minus;delimited list
that is also in that kernel (thus, your obsolete list should
be prioritized from left to right). If no original_module or
obsolete modules are found within the kernel, the alias
entry is removed all&minus;together. Note that the numeric
value of <b>#</b> is tied to the index of BUILD_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION. The index is also tied to
MODULES_CONF_ALIAS_TYPE.</p>


<p style="margin-left:11%;"><b>MODULES_CONF_OBSOLETE_ONLY[#]=</b></p>

<p style="margin-left:22%;">If set to <b>yes</b> , this
directive will tell DKMS to only modify
<i>/etc/modules.conf</i> if it finds within it an obsolete
reference as specified in the corresponding value of
<b>MODULES_CONF_OBSOLETES[#]</b> array directive.</p>

<p style="margin-left:11%;"><b>STRIP[#]=</b></p>

<p style="margin-left:22%;">By default strip is considered
to be &quot;yes&quot;. If set to &quot;no&quot;, DKMS will
not run strip &minus;g against your built module to remove
debug symbols from it. STRIP[0] is used as the default for
any unset entries in the STRIP array.</p>

<p style="margin-left:11%;"><b>PACKAGE_NAME=</b></p>

<p style="margin-left:22%;">This directive is used to give
the name associated with the entire package of modules. This
is the same name that is used with the <b>&minus;m</b>
option when building, adding, etc. and may not necessarily
be the same as the MODULE_NAME. This directive must be
present in every dkms.conf.</p>

<p style="margin-left:11%;"><b>PACKAGE_VERSION=</b></p>

<p style="margin-left:22%;">This directive is used to give
the version associated with the entire package of modules
being installed within that dkms package. This directive
must be present in every dkms.conf.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CLEAN=</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>CLEAN specifies the make clean command to be used to
clean up both before and after building the module. If
unset, it is assumed to be &quot;make clean&quot;.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>REMAKE_INITRD=</b></p>

<p style="margin-left:22%;">This directive specifies
whether your initrd should be remade after the module is
installed onto the kernel. Any text after the first
character is ignored and if the first character is not a
&quot;y&quot; or a &quot;Y&quot;, it is assumed that
REMAKE_INITRD=&quot;no&quot;.</p>

<p style="margin-left:11%;"><b>UDEV_TRIGGER=</b></p>

<p style="margin-left:22%;">This optional directive
specifies, if the udev daemon will be get a trigger event
after the module is installed for your currently running
kernel. Because this udev trigger might have some unfriendly
side effects on some Linux Systems, you can now disable this
trigger, if your driver does not need it anyway.
UDEV_TRIGGER=yes is assumed as the default, although this
directive may not be given. This ensures backward
compatibility to older DKMS releases. Any text after the
first character is ignored and if the first character is not
a &quot;n&quot; or a &quot;N&quot;, it is assumed that
UDEV_TRIGGER=&quot;yes&quot;.</p>

<p style="margin-left:11%;"><b>MODULES_CONF[#]=</b></p>

<p style="margin-left:22%;">This directive array specifies
what static configuration text lines need to be added into
<i>/etc/modules.conf</i> for your module. See the section on
MODULES.CONF CHANGES for more information regarding the
implications of modifying <i>/etc/modules.conf</i></p>

<p style="margin-left:11%;"><b>OBSOLETE_BY=</b></p>

<p style="margin-left:22%;">This directive allows you to
specify a kernel version that obsoletes the necessity for
this particular DKMS module. This can be specified as a
particular upstream kernel or an ABI bump of a kernel. For
example, &quot;2.6.24&quot; would be an upstream kernel and
&quot;2.6.24&minus;16&quot; would represent an ABI bump for
a kernel. Both are valid in this area.</p>

<p style="margin-left:22%; margin-top: 1em">Please avoid
the use of <b>OBSOLETE_BY</b> wherever possible. It&rsquo;s
use indicates a lack of proper module versioning using
<b>MODULE_VERSION()</b> tags in the module source itself. It
is better to fix the <b>MODULE_VERSION()</b> tags than use
<b>OBSOLETE_BY.</b> This also introduces a implicit
distribution/version dependency on the package, as the value
of <b>OBSOLETE_BY</b> is meaningful only in the context of a
single distribution/version.</p>

<p style="margin-left:22%; margin-top: 1em">If you feel you
must use it, please use as such in dkms.conf:</p>


<p style="margin-left:22%; margin-top: 1em">ubuntu_804=&quot;Ubuntu
<br>
8.04&quot; <br>
if [ &minus;x /usr/bin/lsb_release ]; then <br>
if [ &quot;$(/usr/bin/lsb_release &minus;sir)&quot; ==
&quot;${ubuntu_804}&quot; ]; then <br>
OBSOLETE_BY=&quot;2.6.25&quot; <br>
fi <br>
fi</p>

<p style="margin-left:11%;"><b>PATCH[#]=</b></p>

<p style="margin-left:22%;">Use the PATCH directive array
to specify patches which should be applied to your source
before a build occurs. All patches are expected to be in
&minus;p1 format and are applied with the patch &minus;p1
command. Each directive should specify the filename of the
patch to apply, and all patches must be located in the
patches subdirectory of your source directory (
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/patches/</i>
). If any patch fails to apply, the build will be halted and
the rejections can be inspected in
<i>/var/lib/dkms/&lt;module&gt;/&lt;module&minus;version&gt;/build/.</i>
If a PATCH should only be applied conditionally, the
<b>PATCH_MATCH[#]</b> array should be used, and a
corresponding regular expression should be placed in
<b>PATCH_MATCH[#]</b> which will alert dkms to only use that
<b>PATCH[#]</b> if the regular expression matches the kernel
which the module is currently being built for.</p>

<p style="margin-left:11%;"><b>PATCH_MATCH[#]=</b></p>

<p style="margin-left:22%;">See the above description for
<b>PATCH[#]</b> directives. If you only want a patch applied
in certain scenarios, the <b>PATCH_MATCH</b> array should be
utilized by giving a regular expression which matches the
kernels you intend the corresponding <b>PATCH[#]</b> to be
applied to before building that module.</p>

<p style="margin-left:11%;"><b>AUTOINSTALL=</b></p>

<p style="margin-left:22%;">If this directive is set to
<b>yes</b> then the service
<i>/etc/rc.d/init.d/dkms_autoinstaller</i> will
automatically try to install this module on any kernel you
boot into. See the section on <b>dkms_autoinstaller</b> for
more information.</p>

<p style="margin-left:11%;"><b>BUILD_DEPENDS[#]=</b></p>

<p style="margin-left:22%;">This optional directive is an
array that allows you to specify other modules as
dependencies for your module. Each array element should be
the <b>PACKAGE_NAME</b> of another module that is managed by
dkms. Do not specify a version or architecture in the
dependency. Note that this directive is only advisory;
missing or broken dependencies cause non-fatal warnings.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_KERNEL=</b></p>

<p style="margin-left:22%;">This optional directive allows
you to specify a regular expression which defines the subset
of kernels which DKMS is allowed to build your module for.
If the kernel being built for does not match against this
regular expression, the dkms build will error out. For
example, if you set it as =&quot;^2.4.*&quot;, your module
would not be built for 2.6 kernels.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_ARCH=</b></p>

<p style="margin-left:22%;">This optional directive
functions very similarly to <b>BUILD_EXCLUSIVE_KERNEL</b>
except that it matches against the kernel architecture. For
example, if you set it to =&quot;i.86&quot;, your module
would not be built for ia32e, x86_64, amd64, s390, etc.</p>

<p style="margin-left:11%;"><b>POST_ADD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after an <b>add</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_BUILD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after a <b>build</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_INSTALL=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after an <b>install</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_REMOVE=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after a <b>remove</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>PRE_BUILD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run before a <b>build</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>PRE_INSTALL=</b></p>

<p style="margin-left:22%;">The name of the script to be
run before an <b>install</b> is performed. The path should
be given relative to the root directory of your source. If
the script exits with a non&minus;zero value, the install
will be aborted. This is typically used to perform a custom
version comparison.</p>

<h2>DKMS.CONF VARIABLES
<a name="DKMS.CONF VARIABLES"></a>
</h2>


<p style="margin-left:22%; margin-top: 1em">Within your
<i>dkms.conf</i> file, you can use certain variables which
will be replaced at run&minus;time with their values.</p>

<p style="margin-left:11%;"><b>$kernelver</b></p>

<p style="margin-left:22%;">This variable can be used
within a directive definition and during use, the actual
kernel version in question will be substituted in its place.
This is especially useful in MAKE commands when specifying
which INCLUDE statements should be used when compiling your
module (eg. MAKE=&quot;make all
INCLUDEDIR=/lib/modules/${kernelver}/build/include&quot;).</p>

<p style="margin-left:11%;"><b>$dkms_tree</b></p>

<p style="margin-left:22%;">See the section on
/etc/dkms/framework.conf for more information. This variable
represents the location of the DKMS tree on the local
system. By default this is <i>/var/lib/dkms</i> , but this
value should not be hard&minus;coded into a dkms.conf in the
event that the local user has changed it on their
system.</p>

<p style="margin-left:11%;"><b>$source_tree</b></p>

<p style="margin-left:22%;">See the section on
/etc/dkms/framework.conf for more information. This variable
represents the location where DKMS keeps source on the local
system. By default this is <i>/usr/src</i> , but this value
should not be hard&minus;coded into a dkms.conf in the event
that the local user has changed it on their system.</p>

<p style="margin-left:11%;"><b>$kernel_source_dir</b></p>

<p style="margin-left:22%;">This variable holds the value
of the location of your kernel source directory. Usually,
this will be <i>/lib/modules/$kernelver/build</i> , unless
otherwise specified with the
<b>&minus;&minus;kernelsourcedir</b> option.</p>

<h2>DKMS.CONF OVERRIDES
<a name="DKMS.CONF OVERRIDES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can
override the module-provided <i>dkms.conf</i> files. Every
time after a dkms.conf file is read, dkms will look for and
read the following files in order:</p>


<p style="margin-left:11%; margin-top: 1em"><i>/etc/dkms/&lt;module&gt;.conf
/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;.conf
/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;&minus;&lt;kernel&gt;.conf
/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;&minus;&lt;kernel&gt;&minus;&lt;arch&gt;.conf</i></p>

<p style="margin-left:11%; margin-top: 1em">You can use
these files to override settings in the module-provided
dkms.conf files.</p>

<h2>/etc/dkms/framework.conf
<a name="/etc/dkms/framework.conf"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
configuration file controls how the overall DKMS framework
handles. It is sourced in every time the dkms command is
run. Mainly it can currently be used to set different
default values for the variables. <b>$dkms_tree</b> ,
<b>$source_tree</b> and <b>$install_tree</b> which control
where DKMS looks for its framework. The
<b>$symlink_modules</b> variable controls wheter binary
modules are copied to /lib/modules or if only symlinks are
created there. Note that these variables can also be
manipulated on the command line with &minus;&minus;dkmstree,
&minus;&minus;sourcetree, &minus;&minus;installtree and
&minus;&minus;symlink-modules options.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>$autoinstall_all_kernels</b> variable is used by the
common postinst for DKMS modules. It controls if the build
should be done for all installed kernels or only for the
current and latest installed kernel. It has no command line
equivalent.</p>

<h2>dkms_autoinstaller
<a name="dkms_autoinstaller"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
boot&minus;time service automatically installs any module
which has <b>AUTOINSTALL=&quot;yes&quot;</b> set in its
<b>dkms.conf</b> file. The service works quite simply and if
multiple versions of a module are in your system&rsquo;s
DKMS tree, it will not do anything and instead explain that
manual intervention is required.</p>

<h2>MODULES.CONF / MODPROBE.CONF CHANGES
<a name="MODULES.CONF / MODPROBE.CONF CHANGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Changes that
your module will make to <i>/etc/modules.conf</i> or
<i>/etc/modprobe.conf</i> should be specified with the
<b>MODULES_CONF_ALIAS_TYPE[#]</b> , the
<b>MODULES_CONF_OBSOLETES[#]</b> and the
<b>MODULES_CONF[#]</b> directive arrays. These arrays should
also be used even if your distro uses
<i>/etc/sysconfig/kernel</i> to track kernel modules.</p>

<p style="margin-left:11%; margin-top: 1em">When the first
module is installed upon the first kernel within the
user&rsquo;s system, these entries in <b>MODULES_CONF[#]</b>
are automatically added to <i>/etc/modules.conf</i> and if
<b>REMAKE_INITRD</b> is specified, then the user&rsquo;s
initrd is then remade. Subsequently, as your modules are
then later removed from the user&rsquo;s system, until the
final module/version combination is removed from the final
kernel version, those references in <i>modules.conf</i> will
remain. Once the last module/version combination is removed,
those references are then removed.</p>

<p style="margin-left:11%; margin-top: 1em">As
modules/versions are removed and initrds are remade, one of
three things will happen if you have specified a
<b>MODULES_CONF_ALIAS_TYPE.</b> If no original_module exists
for that kernel, and no <b>MODULES_CONF_OBSOLETES</b>
modules are found in that kernel too, the
<i>modules.conf</i> alias references will temporarily be
removed so that the initrd will successfully remake. Once
the initrd is remade, however; those references are then
automatically put back into <i>modules.conf</i> (unless you
are removing the last instance of the module on the last
kernel). However, if no original_module exists, but there is
an OBSOLETE module found within that kernel, the alias
reference is temporarily shifted to point to the OBSOLETE
module so that the initrd can be remade. After it is remade,
it then automatically puts back the alias reference (unless
you are removing the last instance of the module on the last
kernel). Lastly, if an original_module does exist for the
kernel version, then <i>modules.conf</i> is not touched and
all references persist (even if you are removing the last
instance of the module on the last kernel).</p>

<p style="margin-left:11%; margin-top: 1em">Certain module
installations might not only require adding references to
<i>modules.conf</i> but also require removing conflicting
references that might exist in the user&rsquo;s system. If
this is the case, the <b>MODULES_CONF_OBSOLETES[#]</b>
directive should be utilized to remove these references.
More information about this directive can be found in the
<b>DKMS.CONF</b> section of this man page.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
end state of your modules.conf file very much depends on
what kernel modules exist in the final kernel you remove
your DKMS module from. This is an imperfect system caused by
the fact that there is only one modules.conf file for every
kernel on your system even though various kernels use
different modules. In a perfect world, there would be one
modules.conf file for every kernel (just like
System.map).</p>

<h2>CREATING RPMS WHICH UTILIZE DKMS
<a name="CREATING RPMS WHICH UTILIZE DKMS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See the
<i>sample.spec</i> file packaged with <b>DKMS</b> as an
example for what your RPM spec file might look like.
Creating RPMs which utilize <b>dkms</b> is a fairly
straight&minus;forward process. The RPM need only to install
the source into
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/</i>
and then employ <b>dkms</b> itself to do all the work of
installation. As such, the RPM should first untar the source
into this directory. From here, within the RPM <i>.spec</i>
file, a <b>dkms add</b> should be called (remember to use
the &minus;&minus;rpm_safe_upgrade flag during the add)
followed by a <b>dkms build</b> followed by a <b>dkms
install.</b> Your <i>dkms.conf</i> file should be placed
within the
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/</i>
directory.</p>

<p style="margin-left:11%; margin-top: 1em">Under the
removal parts of the <i>.spec</i> file, all that needs to be
called is a: dkms remove &minus;m &lt;module&gt; &minus;v
&lt;module&minus;version&gt; &minus;&minus;all
&minus;&minus;rpm_safe_upgrade. Use of the
<b>&minus;&minus;rpm_safe_upgrade</b> flag is imperative for
making sure DKMS and RPM play nicely together in all
scenarios of using the &minus;Uvh flag with RPM to upgrade
dkms enabled packages. It will only function if used during
both the add <b>and</b> remove actions within the same RPM
spec file. Its use makes sure that when upgrading between
different releases of an RPM for the same
&lt;module&minus;version&gt;, DKMS does not do anything dumb
(eg. it ensures a smooth upgrade from
megaraid&minus;2.09-5.noarch.rpm to
megaraid&minus;2.09&minus;6.noarch.rpm).</p>

<p style="margin-left:11%; margin-top: 1em">It should be
noted that a binary RPM which contains source is not a
traditional practice. However, given the benefits of
<b>dkms</b> it hopefully will become so. As the RPM created
which utilizes <b>dkms</b> is not architecture specific,
<b>BuildArch: noarch</b> should be specified in the
<i>.spec</i> file to indicate that the package can work
regardless of the system architecture. Also note that DKMS
RPM upgrades (&minus;U option) will automatically work
because of the structure of the <b>dkms</b> tree.</p>

<p style="margin-left:11%; margin-top: 1em">Lastly, as a
matter of convention, you should name your RPM:
&lt;package&gt;&minus;&lt;version&gt;&minus;&lt;rpm&minus;version&gt;dkms.noarch.rpm.
The word <b>dkms</b> as part of the rpm&minus;version
signifies that the RPM works within the DKMS framework.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Gary
Lerhaupt</p>

<h2>WEBPAGE
<a name="WEBPAGE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>http://linux.dell.com/dkms</i></p>

<h2>WHITE&minus;PAPERS
<a name="WHITE&minus;PAPERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>http://linux.dell.com/dkms/dkms&minus;ols2004.pdf</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>http://www.dell.com/downloads/global/power/1q04&minus;ler.pdf</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>http://www.linuxjournal.com/article.php?sid=6896</i></p>

<h2>MAILING&minus;LIST
<a name="MAILING&minus;LIST"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">dkms&minus;devel@dell.com
<i>http://lists.us.dell.com/mailman/listinfo/dkms&minus;devel</i></p>

<h2>REFERENCES
<a name="REFERENCES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Kernel Module
Packages <i>http://kerneldrivers.org</i></p>

<p style="margin-left:11%; margin-top: 1em">Novell Kernel
Module Packages <i>http://www.suse.de/~agruen/KMPM</i></p>

<p style="margin-left:11%; margin-top: 1em">Fedora Kernel
Module Packages
<i>http://fedoraproject.org/wiki/Extras/KernelModuleProposal</i></p>
<hr>
</body>
</html>
