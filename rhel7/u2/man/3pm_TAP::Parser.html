<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:30:07 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TAP::Parser</title>

</head>
<body>

<h1 align="center">TAP::Parser</h1>

<a href="#NAME">NAME</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#INDIVIDUAL RESULTS">INDIVIDUAL RESULTS</a><br>
<a href="#TOTAL RESULTS">TOTAL RESULTS</a><br>
<a href="#CALLBACKS">CALLBACKS</a><br>
<a href="#TAP GRAMMAR">TAP GRAMMAR</a><br>
<a href="#BACKWARDS COMPATIBILITY">BACKWARDS COMPATIBILITY</a><br>
<a href="#SUBCLASSING">SUBCLASSING</a><br>
<a href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#COPYRIGHT &amp; LICENSE">COPYRIGHT &amp; LICENSE</a><br>
<a href="#POD ERRORS">POD ERRORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">TAP::Parser
&minus; Parse TAP output</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Version
3.28</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use TAP::Parser;
    my $parser = TAP::Parser&minus;&gt;new( { source =&gt; $source } );
    while ( my $result = $parser&minus;&gt;next ) {
        print $result&minus;&gt;as_string;
    }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><tt>&quot;TAP::Parser&quot;</tt>
is designed to produce a proper parse of <small>TAP</small>
output. For an example of how to run tests through this
module, see the simple harnesses
<tt>&quot;examples/&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s a
wiki dedicated to the Test Anything Protocol:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://testanything.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">It includes the
TAP::Parser Cookbook:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://testanything.org/wiki/index.php/TAP::Parser_Cookbook&gt;</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Class
Methods</b> <i><br>
&quot;new&quot;</i></p>

<pre style="margin-left:11%; margin-top: 1em"> my $parser = TAP::Parser&minus;&gt;new(\%args);</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a new
<tt>&quot;TAP::Parser&quot;</tt> object.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
should be a hashref with <i>one</i> of the following
keys:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p><tt>&quot;source&quot;</tt></p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">This is the
preferred method of passing input to the constructor.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;source&quot;</tt> is used to create a
TAP::Parser::Source that is passed to the
&quot;iterator_factory_class&quot; which in turn figures out
how to handle the source and creates a
&lt;TAP::Parser::Iterator&gt; for it. The iterator is used
by the parser to read in the <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the
<tt>&quot;sources&quot;</tt> parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>&quot;source&quot;</tt>, <tt>&quot;tap&quot;</tt> and
<tt>&quot;exec&quot;</tt> are <i>mutually exclusive</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;tap&quot;</tt></p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">The value
should be the complete <small>TAP</small> output.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>tap</i>
is used to create a TAP::Parser::Source that is passed to
the &quot;iterator_factory_class&quot; which in turn figures
out how to handle the source and creates a
&lt;TAP::Parser::Iterator&gt; for it. The iterator is used
by the parser to read in the <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the
<tt>&quot;sources&quot;</tt> parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>&quot;source&quot;</tt>, <tt>&quot;tap&quot;</tt> and
<tt>&quot;exec&quot;</tt> are <i>mutually exclusive</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;exec&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Must be passed
an array reference.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>exec</i>
array ref is used to create a TAP::Parser::Source that is
passed to the &quot;iterator_factory_class&quot; which in
turn figures out how to handle the source and creates a
&lt;TAP::Parser::Iterator&gt; for it. The iterator is used
by the parser to read in the <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">By default the
TAP::Parser::SourceHandler::Executable class will create a
TAP::Parser::Iterator::Process object to handle the source.
This passes the array reference strings as command arguments
to IPC::Open3::open3:</p>

<pre style="margin-left:17%; margin-top: 1em"> exec =&gt; [ '/usr/bin/ruby', 't/my_test.rb' ]</pre>


<p style="margin-left:17%; margin-top: 1em">If any
<tt>&quot;test_args&quot;</tt> are given they will be
appended to the end of the command argument list.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the
<tt>&quot;sources&quot;</tt> parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>&quot;source&quot;</tt>, <tt>&quot;tap&quot;</tt> and
<tt>&quot;exec&quot;</tt> are <i>mutually exclusive</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
keys are optional.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;sources&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>NEW</small>
to 3.18</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If set,
<tt>&quot;sources&quot;</tt> must be a hashref containing
the names of the TAP::Parser::SourceHandlers to load and/or
configure. The values are a hash of configuration that will
be accessible to to the source handlers via
&quot;config_for&quot; in TAP::Parser::Source.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">  sources =&gt; {
    Perl =&gt; { exec =&gt; '/path/to/custom/perl' },
    File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },
    MyCustom =&gt; { some =&gt; 'config' },
  }</pre>


<p style="margin-left:17%; margin-top: 1em">This will cause
<tt>&quot;TAP::Parser&quot;</tt> to pass custom
configuration to two of the built&minus; in source handlers
&minus; TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File &minus; and attempt to load
the <tt>&quot;MyCustom&quot;</tt> class. See
&quot;load_handlers&quot; in TAP::Parser::IteratorFactory
for more detail.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;sources&quot;</tt> parameter affects how
<tt>&quot;source&quot;</tt>, <tt>&quot;tap&quot;</tt> and
<tt>&quot;exec&quot;</tt> parameters are handled.</p>

<p style="margin-left:17%; margin-top: 1em">See
TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and
subclasses for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;callback&quot;</tt></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If present,
each callback corresponding to a given result type will be
called with the result as the argument if the
<tt>&quot;run&quot;</tt> method is used:</p>

<pre style="margin-left:17%; margin-top: 1em"> my %callbacks = (
     test    =&gt; \&amp;test_callback,
     plan    =&gt; \&amp;plan_callback,
     comment =&gt; \&amp;comment_callback,
     bailout =&gt; \&amp;bailout_callback,
     unknown =&gt; \&amp;unknown_callback,
 );
 my $aggregator = TAP::Parser::Aggregator&minus;&gt;new;
 for my $file ( @test_files ) {
     my $parser = TAP::Parser&minus;&gt;new(
         {
             source    =&gt; $file,
             callbacks =&gt; \%callbacks,
         }
     );
     $parser&minus;&gt;run;
     $aggregator&minus;&gt;add( $file, $parser );
 }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;switches&quot;</tt></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If using a Perl
file as a source, optional switches may be passed which will
be used when invoking the perl executable.</p>

<pre style="margin-left:17%; margin-top: 1em"> my $parser = TAP::Parser&minus;&gt;new( {
     source   =&gt; $test_file,
     switches =&gt; [ '&minus;Ilib' ],
 } );</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><tt>&quot;test_args&quot;</tt></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Used in
conjunction with the <tt>&quot;source&quot;</tt> and
<tt>&quot;exec&quot;</tt> option to supply a reference to an
<tt>@ARGV</tt> style array of arguments to pass to the test
program.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;spool&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If passed a
filehandle will write a copy of all parsed
<small>TAP</small> to that handle.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;merge&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If false,
<small>STDERR</small> is not captured (though it is
&rsquo;relayed&rsquo; to keep it somewhat synchronized with
<small>STDOUT.</small> )</p>

<p style="margin-left:17%; margin-top: 1em">If true,
<small>STDERR</small> and <small>STDOUT</small> are the same
filehandle. This may cause breakage if <small>STDERR</small>
contains anything resembling <small>TAP</small> format, but
does allow exact synchronization.</p>

<p style="margin-left:17%; margin-top: 1em">Subtleties of
this behavior may be platform-dependent and may change in
the future.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">



<p style="margin-top: 1em"><tt>&quot;grammar_class&quot;</tt></p> </td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>grammar</i>
class the parser should use. It defaults to
TAP::Parser::Grammar.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;make_grammar&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="34%">



<p style="margin-top: 1em"><tt>&quot;result_factory_class&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>result</i>
factory class the parser should use. It defaults to
TAP::Parser::ResultFactory.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;make_result&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">



<p style="margin-top: 1em"><tt>&quot;iterator_factory_class&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>iterator</i>
factory class the parser should use. It defaults to
TAP::Parser::IteratorFactory.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Instance
Methods</b> <i><br>
&quot;next&quot;</i></p>

<pre style="margin-left:11%; margin-top: 1em">  my $parser = TAP::Parser&minus;&gt;new( { source =&gt; $file } );
  while ( my $result = $parser&minus;&gt;next ) {
      print $result&minus;&gt;as_string, &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This method
returns the results of the parsing, one result at a time.
Note that it is destructive. You can&rsquo;t rewind and
examine previous results.</p>

<p style="margin-left:11%; margin-top: 1em">If callbacks
are used, they will be issued before this call returns.</p>

<p style="margin-left:11%; margin-top: 1em">Each result
returned is a subclass of TAP::Parser::Result. See that
module and related classes for more information on how to
use them.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;run&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $parser&minus;&gt;run;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
merely runs the parser and parses all of the
<small>TAP.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_grammar&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::Grammar object and return it. Passes through
any arguments given.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;grammar_class&quot;</tt> can be customized, as
described in &quot;new&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_result&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::Result object using the parser&rsquo;s
TAP::Parser::ResultFactory, and return it. Passes through
any arguments given.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;result_factory_class&quot;</tt> can be customized,
as described in &quot;new&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_iterator_factory&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em"><i><small>NEW</small>
to 3.18</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::IteratorFactory object and return it. Passes
through any arguments given.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;iterator_factory_class&quot;</tt>
can be customized, as described in &quot;new&quot;.</p>

<h2>INDIVIDUAL RESULTS
<a name="INDIVIDUAL RESULTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;ve
read this far in the docs, you&rsquo;ve seen this:</p>

<pre style="margin-left:11%; margin-top: 1em">    while ( my $result = $parser&minus;&gt;next ) {
        print $result&minus;&gt;as_string;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Each result
returned is a TAP::Parser::Result subclass, referred to as
<i>result types</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Result
types</b> <br>
Basically, you fetch individual results from the
<small>TAP.</small> The six types, with examples of each,
are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Version</p></td>
<td width="72%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> TAP version 12</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em">Plan</p></td>
<td width="77%">
</td></tr>
</table>
<pre style="margin-left:17%; margin-top: 1em"> 1..42</pre>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">Pragma</p></td>
<td width="74%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> pragma +strict</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em">Test</p></td>
<td width="77%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ok 3 &minus; We should start with some foobar!</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Comment</p></td>
<td width="72%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> # Hope we don't use up the foobar.</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Bailout</p></td>
<td width="72%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> Bail out!  We ran out of foobar!</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Unknown</p></td>
<td width="72%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ... yo, this ain't TAP! ...</pre>


<p style="margin-left:11%; margin-top: 1em">Each result
fetched is a result object of a different type. There are
common methods to each result object and different types may
have methods unique to their type. Sometimes a type method
may be overridden in a subclass, but its use is guaranteed
to be identical.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Common type
methods</b> <i><br>
&quot;type&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
type of result, such as <tt>&quot;comment&quot;</tt> or
<tt>&quot;test&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;as_string&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Prints a string
representation of the token. This might not be the exact
output, however. Tests will have test numbers added if not
present, <small>TODO</small> and <small>SKIP</small>
directives will be capitalized and, in general, things will
be cleaned up. If you need the original text for the token,
see the <tt>&quot;raw&quot;</tt> method.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;raw&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
original line of text which was parsed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is the test plan line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_test&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is a test line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_comment&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is a comment. Comments will generally
only appear in the <small>TAP</small> stream if
<small>STDERR</small> is merged to <small>STDOUT.</small>
See the <tt>&quot;merge&quot;</tt> option.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_bailout&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is bailout line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_yaml&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not the current item is a <small>YAML</small>
block.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_unknown&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not the current line could be parsed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_ok&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_ok ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Reports whether
or not a given result has passed. Anything which is
<b>not</b> a test result returns true. This is merely
provided as a convenient shortcut which allows you to do
this:</p>

<pre style="margin-left:11%; margin-top: 1em"> my $parser = TAP::Parser&minus;&gt;new( { source =&gt; $source } );
 while ( my $result = $parser&minus;&gt;next ) {
     # only print failing results
     print $result&minus;&gt;as_string unless $result&minus;&gt;is_ok;
 }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;plan&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_plan ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the <tt>$result</tt> object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;plan&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_plan ) {
     print $result&minus;&gt;plan;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is merely
a synonym for <tt>&quot;as_string&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;directive&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my $directive = $result&minus;&gt;directive;</pre>


<p style="margin-left:11%; margin-top: 1em">If a
<small>SKIP</small> directive is included with the plan,
this method will return it.</p>

<pre style="margin-left:11%; margin-top: 1em"> 1..0 # SKIP: why bother?</pre>



<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my $explanation = $result&minus;&gt;explanation;</pre>


<p style="margin-left:11%; margin-top: 1em">If a
<small>SKIP</small> directive was included with the plan,
this method will return the explanation, if any.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;pragma&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_pragma ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the <tt>$result</tt> object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;pragmas&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns a list
of pragmas each of which is a + or &minus; followed by the
pragma name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;comment&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_comment ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the <tt>$result</tt> object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;comment&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_comment ) {
      my $comment = $result&minus;&gt;comment;
      print &quot;I have something to say:  $comment&quot;;
  }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;bailout&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_bailout ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the <tt>$result</tt> object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_bailout ) {
      my $explanation = $result&minus;&gt;explanation;
      print &quot;We bailed out because ($explanation)&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">If, and only
if, a token is a bailout token, you can get an
&quot;explanation&quot; via this method. The explanation is
the text after the mystical &quot;Bail out!&quot; words
which appear in the tap output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;unknown&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_unknown ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">There are no
unique methods for unknown results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;test&quot;
methods</b></p>

<pre style="margin-left:11%;"> if ( $result&minus;&gt;is_test ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the <tt>$result</tt> object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;ok&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  my $ok = $result&minus;&gt;ok;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
literal text of the <tt>&quot;ok&quot;</tt> or <tt>&quot;not
ok&quot;</tt> status.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;number&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  my $test_number = $result&minus;&gt;number;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
number of the test, even if the original <small>TAP</small>
output did not supply that number.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;description&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  my $description = $result&minus;&gt;description;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
description of the test, if any. This is the portion after
the test number but before the directive.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;directive&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  my $directive = $result&minus;&gt;directive;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns either
<tt>&quot;TODO&quot;</tt> or <tt>&quot;SKIP&quot;</tt> if
either directive was present for a test line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  my $explanation = $result&minus;&gt;explanation;</pre>


<p style="margin-left:11%; margin-top: 1em">If a test had
either a <tt>&quot;TODO&quot;</tt> or
<tt>&quot;SKIP&quot;</tt> directive, this method will return
the accompanying explanation, if present.</p>

<pre style="margin-left:11%; margin-top: 1em">  not ok 17 &minus; 'Pigs can fly' # TODO not enough acid</pre>


<p style="margin-left:11%; margin-top: 1em">For the above
line, the explanation is <i>not enough acid</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_ok&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_ok ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the test passed.
Remember that for <small>TODO</small> tests, the test always
passes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly <tt>&quot;passed&quot;</tt>. The latter
method is deprecated and will issue a warning.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_actual_ok&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;is_actual_ok ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the test passed,
regardless of its <small>TODO</small> status.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly <tt>&quot;actual_passed&quot;</tt>. The
latter method is deprecated and will issue a warning.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_unplanned&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $test&minus;&gt;is_unplanned ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">If a test
number is greater than the number of planned tests, this
method will return true. Unplanned tests will <i>always</i>
return false for <tt>&quot;is_ok&quot;</tt>, regardless of
whether or not the test <tt>&quot;has_todo&quot;</tt> (see
TAP::Parser::Result::Test for more information about
this).</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_skip&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;has_skip ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not this test had a
<small>SKIP</small> directive.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_todo&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $result&minus;&gt;has_todo ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not this test had a
<small>TODO</small> directive.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<small>TODO</small> tests <i>always</i> pass. If you need to
know whether or not they really passed, check the
<tt>&quot;is_actual_ok&quot;</tt> method.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;in_todo&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $parser&minus;&gt;in_todo ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">True while the
most recent result was a <small>TODO.</small> Becomes true
before the <small>TODO</small> result is returned and stays
true until just before the next non&minus;
<small>TODO</small> test is returned.</p>

<h2>TOTAL RESULTS
<a name="TOTAL RESULTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">After parsing
the <small>TAP,</small> there are many methods available to
let you dig through the results and determine what is
meaningful to you.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Individual
Results</b> <br>
These results refer to individual tests which are run.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;passed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my @passed = $parser&minus;&gt;passed; # the test numbers which passed
 my $passed = $parser&minus;&gt;passed; # the number of tests which passed</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests passed. If a test
failed but had a <small>TODO</small> directive, it will be
counted as a passed test.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;failed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my @failed = $parser&minus;&gt;failed; # the test numbers which failed
 my $failed = $parser&minus;&gt;failed; # the number of tests which failed</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests failed. If a test
passed but had a <small>TODO</small> directive, it will
<b><small>NOT</small></b> be counted as a failed test.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_passed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> # the test numbers which actually passed
 my @actual_passed = $parser&minus;&gt;actual_passed;
 # the number of tests which actually passed
 my $actual_passed = $parser&minus;&gt;actual_passed;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually passed,
regardless of whether or not a <small>TODO</small> directive
was found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">This method is
a synonym for <tt>&quot;actual_passed&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_failed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> # the test numbers which actually failed
 my @actual_failed = $parser&minus;&gt;actual_failed;
 # the number of tests which actually failed
 my $actual_failed = $parser&minus;&gt;actual_failed;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually failed,
regardless of whether or not a <small>TODO</small> directive
was found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my @todo = $parser&minus;&gt;todo; # the test numbers with todo directives
 my $todo = $parser&minus;&gt;todo; # the number of tests with todo directives</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests had
<small>TODO</small> directives.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo_passed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> # the test numbers which unexpectedly succeeded
 my @todo_passed = $parser&minus;&gt;todo_passed;
 # the number of tests which unexpectedly succeeded
 my $todo_passed = $parser&minus;&gt;todo_passed;</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually passed but
were declared as &quot; <small>TODO&quot;</small> tests.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo_failed&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.</pre>


<p style="margin-left:11%; margin-top: 1em">This was a
badly misnamed method. It indicates which
<small>TODO</small> tests unexpectedly succeeded. Will now
issue a warning and call
<tt>&quot;todo_passed&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;skipped&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my @skipped = $parser&minus;&gt;skipped; # the test numbers with SKIP directives
 my $skipped = $parser&minus;&gt;skipped; # the number of tests with SKIP directives</pre>


<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests had
<small>SKIP</small> directives.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pragmas</b>
<i><br>
&quot;pragma&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get or set a
pragma. To get the state of a pragma:</p>

<pre style="margin-left:11%; margin-top: 1em">  if ( $p&minus;&gt;pragma('strict') ) {
      # be strict
  }</pre>


<p style="margin-left:11%; margin-top: 1em">To set the
state of a pragma:</p>

<pre style="margin-left:11%; margin-top: 1em">  $p&minus;&gt;pragma('strict', 1); # enable strict mode</pre>



<p style="margin-left:11%; margin-top: 1em"><i>&quot;pragmas&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get a list of
all the currently enabled pragmas:</p>

<pre style="margin-left:11%; margin-top: 1em">  my @pragmas_enabled = $p&minus;&gt;pragmas;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Summary
Results</b> <br>
These results are &quot;meta&quot; information about the
total results of an individual test program.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;plan&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my $plan = $parser&minus;&gt;plan;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
test plan, if found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;good_plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Deprecated. Use
<tt>&quot;is_good_plan&quot;</tt> instead.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_good_plan&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $parser&minus;&gt;is_good_plan ) { ... }</pre>


<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the number of tests
planned matches the number of tests run.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly <tt>&quot;good_plan&quot;</tt>. The latter
method is deprecated and will issue a warning.</p>

<p style="margin-left:11%; margin-top: 1em">And since
we&rsquo;re on that subject ...</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;tests_planned&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  print $parser&minus;&gt;tests_planned;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
number of tests planned, according to the plan. For example,
a plan of &rsquo;1..17&rsquo; will mean that 17 tests were
planned.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;tests_run&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  print $parser&minus;&gt;tests_run;</pre>


<p style="margin-left:11%; margin-top: 1em">Returns the
number of tests which actually were run. Hopefully this will
match the number of
<tt>&quot;$parser&minus;&gt;tests_planned&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;skip_all&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns a true
value (actually the reason for skipping) if all tests were
skipped.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;start_time&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
time when the Parser was created.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;end_time&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
time when the end of <small>TAP</small> input was seen.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_problems&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  if ( $parser&minus;&gt;has_problems ) {
      ...
  }</pre>


<p style="margin-left:11%; margin-top: 1em">This is a
&rsquo;catch&minus;all&rsquo; method which returns true if
any tests have currently failed, any <small>TODO</small>
tests unexpectedly succeeded, or any parse errors
occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;version&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $parser&minus;&gt;version;</pre>


<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the version number for the parsed
<small>TAP.</small> Version numbers were introduced with
<small>TAP</small> version 13 so if no version number is
found version 12 is assumed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;exit&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $parser&minus;&gt;exit;</pre>


<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the exit status. If the parser ran
an executable, it returns the exit status of the
executable.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;wait&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $parser&minus;&gt;wait;</pre>


<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the wait status. If the parser ran
an executable, it returns the wait status of the executable.
Otherwise, this merely returns the <tt>&quot;exit&quot;</tt>
status.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ignore_exit&quot;</b></p>


<pre style="margin-left:11%;">  $parser&minus;&gt;ignore_exit(1);</pre>


<p style="margin-left:11%; margin-top: 1em">Tell the parser
to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit
status are considered to have failed even if all individual
tests passed. In cases where it is not possible to control
the exit value of the test script use this option to ignore
it.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;parse_errors&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em"> my @errors = $parser&minus;&gt;parse_errors; # the parser errors
 my $errors = $parser&minus;&gt;parse_errors; # the number of parser_errors</pre>


<p style="margin-left:11%; margin-top: 1em">Fortunately,
all <small>TAP</small> output is perfect. In the event that
it is not, this method will return parser errors. Note that
a junk line which the parser does not recognize is
<tt>&quot;not&quot;</tt> an error. This allows this parser
to handle future versions of <small>TAP.</small> The
following are all <small>TAP</small> errors reported by the
parser:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Misplaced plan</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The plan (for
example, &rsquo;1..5&rsquo;), must only come at the
beginning or end of the <small>TAP</small> output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">No plan</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Gotta have a
plan!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">More than one plan</p></td>
<td width="55%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> 1..3
 ok 1 &minus; input file opened
 not ok 2 &minus; first line of the input valid # todo some data
 ok 3 read the rest of the file
 1..3</pre>


<p style="margin-left:17%; margin-top: 1em">Right. Very
funny. Don&rsquo;t do that.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">Test numbers out of sequence</p></td>
<td width="40%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> 1..3
 ok 1 &minus; input file opened
 not ok 2 &minus; first line of the input valid # todo some data
 ok 2 read the rest of the file</pre>


<p style="margin-left:17%; margin-top: 1em">That last test
line above should have the number &rsquo;3&rsquo; instead of
&rsquo;2&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
it&rsquo;s perfectly acceptable for some lines to have test
numbers and others to not have them. However, when a test
number is found, it must be in sequence. The following is
also an error:</p>

<pre style="margin-left:17%; margin-top: 1em"> 1..3
 ok 1 &minus; input file opened
 not ok &minus; first line of the input valid # todo some data
 ok 2 read the rest of the file</pre>


<p style="margin-left:17%; margin-top: 1em">But this is
not:</p>

<pre style="margin-left:17%; margin-top: 1em"> 1..3
 ok  &minus; input file opened
 not ok &minus; first line of the input valid # todo some data
 ok 3 read the rest of the file</pre>



<p style="margin-left:11%; margin-top: 1em"><i>&quot;get_select_handles&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get an a list
of file handles which can be passed to
<tt>&quot;select&quot;</tt> to determine the readiness of
this parser.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;delete_spool&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Delete and
return the spool.</p>

<pre style="margin-left:11%; margin-top: 1em">  my $fh = $parser&minus;&gt;delete_spool;</pre>


<h2>CALLBACKS
<a name="CALLBACKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As mentioned
earlier, a &quot;callback&quot; key may be added to the
<tt>&quot;TAP::Parser&quot;</tt> constructor. If present,
each callback corresponding to a given result type will be
called with the result as the argument if the
<tt>&quot;run&quot;</tt> method is used. The callback is
expected to be a subroutine reference (or anonymous
subroutine) which is invoked with the parser result as its
argument.</p>

<pre style="margin-left:11%; margin-top: 1em"> my %callbacks = (
     test    =&gt; \&amp;test_callback,
     plan    =&gt; \&amp;plan_callback,
     comment =&gt; \&amp;comment_callback,
     bailout =&gt; \&amp;bailout_callback,
     unknown =&gt; \&amp;unknown_callback,
 );
 my $aggregator = TAP::Parser::Aggregator&minus;&gt;new;
 for my $file ( @test_files ) {
     my $parser = TAP::Parser&minus;&gt;new(
         {
             source    =&gt; $file,
             callbacks =&gt; \%callbacks,
         }
     );
     $parser&minus;&gt;run;
     $aggregator&minus;&gt;add( $file, $parser );
 }</pre>


<p style="margin-left:11%; margin-top: 1em">Callbacks may
also be added like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $parser&minus;&gt;callback( test =&gt; \&amp;test_callback );
 $parser&minus;&gt;callback( plan =&gt; \&amp;plan_callback );</pre>


<p style="margin-left:11%; margin-top: 1em">The following
keys allowed for callbacks. These keys are
case-sensitive.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;test&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_test&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;version&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_version&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;plan&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_plan&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;comment&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_comment&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;bailout&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_unknown&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;yaml&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_yaml&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;unknown&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
<tt>&quot;$result&minus;&gt;is_unknown&quot;</tt> returns
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;ELSE&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If a result
does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are
specified as callbacks, this callback will <i>never</i> be
invoked.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;ALL&quot;</tt></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This callback
will always be invoked and this will happen for each result
after one of the above callbacks is invoked. For example, if
Term::ANSIColor is loaded, you could use the following to
color your test output:</p>

<pre style="margin-left:17%; margin-top: 1em"> my %callbacks = (
     test =&gt; sub {
         my $test = shift;
         if ( $test&minus;&gt;is_ok &amp;&amp; not $test&minus;&gt;directive ) {
             # normal passing test
             print color 'green';
         }
         elsif ( !$test&minus;&gt;is_ok ) {    # even if it's TODO
             print color 'white on_red';
         }
         elsif ( $test&minus;&gt;has_skip ) {
             print color 'white on_blue';
         }
         elsif ( $test&minus;&gt;has_todo ) {
             print color 'white';
         }
     },
     ELSE =&gt; sub {
         # plan, comment, and so on (anything which isn't a test line)
         print color 'black on_white';
     },
     ALL =&gt; sub {
         # now print them
         print shift&minus;&gt;as_string;
         print color 'reset';
         print &quot;\n&quot;;
     },
 );</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;EOF&quot;</tt></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked when
there are no more lines to be parsed. Since there is no
accompanying TAP::Parser::Result object the
<tt>&quot;TAP::Parser&quot;</tt> object is passed
instead.</p>

<h2>TAP GRAMMAR
<a name="TAP GRAMMAR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
looking for an <small>EBNF</small> grammar, see
TAP::Parser::Grammar.</p>

<h2>BACKWARDS COMPATIBILITY
<a name="BACKWARDS COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Perl-QA
list attempted to ensure backwards compatibility with
Test::Harness. However, there are some minor
differences.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Differences</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em"><small>TODO</small> plans</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A little-known
feature of Test::Harness is that it supported
<small>TODO</small> lists in the plan:</p>

<pre style="margin-left:17%; margin-top: 1em"> 1..2 todo 2
 ok 1 &minus; We have liftoff
 not ok 2 &minus; Anti&minus;gravity device activated</pre>


<p style="margin-left:17%; margin-top: 1em">Under
Test::Harness, test number 2 would <i>pass</i> because it
was listed as a <small>TODO</small> test on the plan line.
However, we are not aware of anyone actually using this
feature and hard-coding test numbers is discouraged because
it&rsquo;s very easy to add a test and break the test number
sequence. This makes test suites very fragile. Instead, the
following should be used:</p>

<pre style="margin-left:17%; margin-top: 1em"> 1..2
 ok 1 &minus; We have liftoff
 not ok 2 &minus; Anti&minus;gravity device activated # TODO</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">&rsquo;Missing&rsquo; tests</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">It rarely
happens, but sometimes a harness might encounter
&rsquo;missing tests:</p>

<pre style="margin-left:17%; margin-top: 1em"> ok 1
 ok 2
 ok 15
 ok 16
 ok 17</pre>


<p style="margin-left:17%; margin-top: 1em">Test::Harness
would report tests 3&minus;14 as having failed. For the
<tt>&quot;TAP::Parser&quot;</tt>, these tests are not
considered failed because they&rsquo;ve never run.
They&rsquo;re reported as parse failures (tests out of
sequence).</p>

<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you find you
need to provide custom functionality (as you would have
using Test::Harness::Straps), you&rsquo;re in luck:
<tt>&quot;TAP::Parser&quot;</tt> and friends are designed to
be easily plugged-into and/or subclassed.</p>

<p style="margin-left:11%; margin-top: 1em">Before you
start, it&rsquo;s important to know a few things: <br>
1.</p>

<p style="margin-left:14%;">All <tt>&quot;TAP::*&quot;</tt>
objects inherit from TAP::Object.</p>

<p style="margin-left:11%;">2.</p>

<p style="margin-left:14%;">Many
<tt>&quot;TAP::*&quot;</tt> classes have a
<i><small>SUBCLASSING</small></i> section to guide you.</p>

<p style="margin-left:11%;">3.</p>

<p style="margin-left:14%;">Note that
<tt>&quot;TAP::Parser&quot;</tt> is designed to be the
central &quot;maker&quot; &minus; ie: it is responsible for
creating most new objects in the
<tt>&quot;TAP::Parser::*&quot;</tt> namespace.</p>

<p style="margin-left:14%; margin-top: 1em">This makes it
possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases
you&rsquo;ll find you only need to sub-class one of the
parser&rsquo;s components.</p>

<p style="margin-left:14%; margin-top: 1em">The exception
to this rule are <i>SourceHandlers</i> &amp;
<i>Iterators</i>, but those are both created with
customizable <i>IteratorFactory</i>.</p>

<p style="margin-left:11%;">4.</p>

<p style="margin-left:14%;">By subclassing, you may end up
overriding undocumented methods. That&rsquo;s not a bad
thing per se, but be forewarned that undocumented methods
may change without warning from one release to the next
&minus; we cannot guarantee backwards compatibility. If any
<i>documented</i> method needs changing, it will be
deprecated first, and changed in a later release.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parser
Components</b> <i><br>
Sources</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser consumes input from a single
<i>raw source</i> of <small>TAP,</small> which could come
from anywhere (a file, an executable, a database, an
<small>IO</small> handle, a <small>URI,</small> etc..). The
source gets bundled up in a TAP::Parser::Source object which
gathers some meta data about it. The parser then uses a
TAP::Parser::IteratorFactory to determine which
TAP::Parser::SourceHandler to use to turn the raw source
into a stream of <small>TAP</small> by way of
&quot;Iterators&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If you simply
want <tt>&quot;TAP::Parser&quot;</tt> to handle a new source
of <small>TAP</small> you probably don&rsquo;t need to
subclass <tt>&quot;TAP::Parser&quot;</tt> itself. Rather,
you&rsquo;ll need to create a new TAP::Parser::SourceHandler
class, and just plug it into the parser using the
<i>sources</i> param to &quot;new&quot;. Before you start
writing one, read through TAP::Parser::IteratorFactory to
get a feel for how the system works first.</p>

<p style="margin-left:11%; margin-top: 1em">If you find you
really need to use your own iterator factory you can still
do so without sub-classing <tt>&quot;TAP::Parser&quot;</tt>
by setting &quot;iterator_factory_class&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If you just
need to customize the objects on creation, subclass
TAP::Parser and override
&quot;make_iterator_factory&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;make_source&quot; &amp; &quot;make_perl_source&quot;
have been <i><small>DEPRECATED</small></i> and are now
removed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Iterators</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser uses <i>iterators</i> to loop
through the <i>stream</i> of <small>TAP</small> read in from
the <i>source</i> it was given. There are a few types of
Iterators available by default, all sub-classes of
TAP::Parser::Iterator. Choosing which iterator to use is the
responsibility of the <i>iterator factory</i>, though it
simply delegates to the <i>Source Handler</i> it uses.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
writing your own TAP::Parser::SourceHandler, you may need to
create your own iterators too. If so you&rsquo;ll need to
subclass TAP::Parser::Iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;make_iterator&quot; has been
<i><small>DEPRECATED</small></i> and is now removed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Results</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser creates TAP::Parser::Results as it
iterates through the input <i>stream</i>. There are quite a
few result types available; choosing which class to use is
the responsibility of the <i>result factory</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To create your
own result types you have two options: <br>
option 1</p>

<p style="margin-left:14%;">Subclass TAP::Parser::Result
and register your new result type/class with the default
TAP::Parser::ResultFactory.</p>

<p style="margin-left:11%;">option 2</p>

<p style="margin-left:14%;">Subclass
TAP::Parser::ResultFactory itself and implement your own
TAP::Parser::Result creation logic. Then you&rsquo;ll need
to customize the class used by your parser by setting the
<tt>&quot;result_factory_class&quot;</tt> parameter. See
&quot;new&quot; for more details.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
customize the objects on creation, subclass TAP::Parser and
override &quot;make_result&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Grammar</i></p>


<p style="margin-left:11%; margin-top: 1em">TAP::Parser::Grammar
is the heart of the parser. It tokenizes the
<small>TAP</small> input <i>stream</i> and produces results.
If you need to customize its behaviour you should probably
familiarize yourself with the source first. Enough
lecturing.</p>

<p style="margin-left:11%; margin-top: 1em">Subclass
TAP::Parser::Grammar and customize your parser by setting
the <tt>&quot;grammar_class&quot;</tt> parameter. See
&quot;new&quot; for more details.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
customize the objects on creation, subclass TAP::Parser and
override &quot;make_grammar&quot;</p>

<h2>ACKNOWLEDGMENTS
<a name="ACKNOWLEDGMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of the
following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been
forthcoming.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Michael Schwern</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Andy Lester</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>chromatic</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p><small>GEOFFR</small></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Shlomi Fish</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Torsten Schoenfeld</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Jerry Gay</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Aristotle</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Adam Kennedy</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Yves Orton</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Adrian Howard</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Sean &amp; Lil</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Andreas J. Koenig</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Florian Ragwitz</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Corion</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Mark Stosberg</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Matt Kraai</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>David Wheeler</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Alex Vandiver</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Cosimo Streppone</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Ville Skyttae</p></td>
<td width="55%">
</td></tr>
</table>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Curtis
&quot;Ovid&quot; Poe &lt;ovid@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Andy Armstong
&lt;andy@hexten.net&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Eric Wilhelm @
&lt;ewilhelm at cpan dot org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Michael Peters
&lt;mpeters at plusthree dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Leif Eriksen
&lt;leif dot eriksen at bigpond dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Steve Purkis
&lt;spurkis@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Nicholas Clark
&lt;nick@ccl4.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Lee Johnson
&lt;notfadeaway at btinternet dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Philippe Bruhat
&lt;book@cpan.org&gt;</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
any bugs or feature requests to
<tt>&quot;bug&minus;test&minus;harness@rt.cpan.org&quot;</tt>,
or through the web interface at
&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test&minus;Harness&gt;.
We will be notified, and then you&rsquo;ll automatically be
notified of progress on your bug as we make changes.</p>

<p style="margin-left:11%; margin-top: 1em">Obviously, bugs
which include patches are best. If you prefer, you can patch
against bleed by via anonymous checkout of the latest
version:</p>

<pre style="margin-left:11%; margin-top: 1em"> git clone git://github.com/Perl&minus;Toolchain&minus;Gang/Test&minus;Harness.git</pre>


<h2>COPYRIGHT &amp; LICENSE
<a name="COPYRIGHT &amp; LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2006&minus;2008 Curtis &quot;Ovid&quot; Poe, all rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<h2>POD ERRORS
<a name="POD ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hey! <b>The
above document had some coding errors, which are explained
below:</b> <br>
Around line 1871:</p>

<p style="margin-left:17%;">Non-ASCII character seen before
=encoding in &rsquo;Skyttae&rsquo;. Assuming
<small>UTF&minus;8</small></p>
<hr>
</body>
</html>
