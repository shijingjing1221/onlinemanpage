<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 01:23:19 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curl_easy_setopt</title>

</head>
<body>

<h1 align="center">curl_easy_setopt</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BEHAVIOR OPTIONS">BEHAVIOR OPTIONS</a><br>
<a href="#CALLBACK OPTIONS">CALLBACK OPTIONS</a><br>
<a href="#ERROR OPTIONS">ERROR OPTIONS</a><br>
<a href="#NETWORK OPTIONS">NETWORK OPTIONS</a><br>
<a href="#NAMES and PASSWORDS OPTIONS (Authentication)">NAMES and PASSWORDS OPTIONS (Authentication)</a><br>
<a href="#HTTP OPTIONS">HTTP OPTIONS</a><br>
<a href="#SMTP OPTIONS">SMTP OPTIONS</a><br>
<a href="#TFTP OPTIONS">TFTP OPTIONS</a><br>
<a href="#FTP OPTIONS">FTP OPTIONS</a><br>
<a href="#RTSP OPTIONS">RTSP OPTIONS</a><br>
<a href="#PROTOCOL OPTIONS">PROTOCOL OPTIONS</a><br>
<a href="#CONNECTION OPTIONS">CONNECTION OPTIONS</a><br>
<a href="#SSL and SECURITY OPTIONS">SSL and SECURITY OPTIONS</a><br>
<a href="#SSH OPTIONS">SSH OPTIONS</a><br>
<a href="#OTHER OPTIONS">OTHER OPTIONS</a><br>
<a href="#TELNET OPTIONS">TELNET OPTIONS</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">curl_easy_setopt
&minus; set options for a curl easy handle</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;curl/curl.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">CURLcode
curl_easy_setopt(CURL *handle, CURLoption option,
parameter);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">curl_easy_setopt()
is used to tell libcurl how to behave. By using the
appropriate options to <i>curl_easy_setopt</i>, you can
change libcurl&rsquo;s behavior. All options are set with
the <i>option</i> followed by a <i>parameter</i>. That
parameter can be a <b>long</b>, a <b>function pointer</b>,
an <b>object pointer</b> or a <b>curl_off_t</b>, depending
on what the specific option expects. Read this manual
carefully as bad input values may cause libcurl to behave
badly! You can only set one option in each function call. A
typical application uses many curl_easy_setopt() calls in
the setup phase.</p>

<p style="margin-left:11%; margin-top: 1em">Options set
with this function call are valid for all forthcoming
transfers performed using this <i>handle</i>. The options
are not in any way reset between transfers, so if you want
subsequent transfers with different options, you must change
them between the transfers. You can optionally reset all
options back to internal default with
<i>curl_easy_reset(3)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Strings passed
to libcurl as &rsquo;char *&rsquo; arguments, are copied by
the library; thus the string storage associated to the
pointer argument may be overwritten after curl_easy_setopt()
returns. Exceptions to this rule are described in the option
details below.</p>

<p style="margin-left:11%; margin-top: 1em">Before version
7.17.0, strings were not copied. Instead the user was forced
keep them available until libcurl no longer needed them.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>handle</i> is the return code from a
<i>curl_easy_init(3)</i> or <i>curl_easy_duphandle(3)</i>
call.</p>

<h2>BEHAVIOR OPTIONS
<a name="BEHAVIOR OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_VERBOSE</p>

<p style="margin-left:22%;">Set the parameter to 1 to get
the library to display a lot of verbose information about
its operations. Very useful for libcurl and/or protocol
debugging and understanding. The verbose information will be
sent to stderr, or the stream set with
<i>CURLOPT_STDERR</i>.</p>

<p style="margin-left:22%; margin-top: 1em">You hardly ever
want this set in production use, you will almost always want
this when you debug/report problems. Another neat option for
debugging is the <i>CURLOPT_DEBUGFUNCTION</i>.</p>

<p style="margin-left:11%;">CURLOPT_HEADER</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to include the header in the body output. This is
only relevant for protocols that actually have headers
preceding the data (like HTTP).</p>

<p style="margin-left:11%;">CURLOPT_NOPROGRESS</p>

<p style="margin-left:22%;">Pass a long. If set to 1, it
tells the library to shut off the progress meter completely.
It will also prevent the <i>CURLOPT_PROGRESSFUNCTION</i>
from getting called.</p>

<p style="margin-left:22%; margin-top: 1em">Future versions
of libcurl are likely to not have any built-in progress
meter at all.</p>

<p style="margin-left:11%;">CURLOPT_NOSIGNAL</p>

<p style="margin-left:22%;">Pass a long. If it is 1,
libcurl will not use any functions that install signal
handlers or any functions that cause signals to be sent to
the process. This option is mainly here to allow
multi-threaded unix applications to still set/use all
timeout options etc, without risking getting signals. (Added
in 7.10)</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is set and libcurl has been built with the standard name
resolver, timeouts will not occur while the name resolve
takes place. Consider building libcurl with c-ares support
to enable asynchronous DNS lookups, which enables nice
timeouts for name resolves without signals.</p>

<p style="margin-left:22%; margin-top: 1em">Setting
<i>CURLOPT_NOSIGNAL</i> to 1 makes libcurl NOT ask the
system to ignore SIGPIPE signals, which otherwise are sent
by the system when trying to send data to a socket which is
closed in the other end. libcurl makes an effort to never
cause such SIGPIPEs to trigger, but some operating systems
have no way to avoid them and even on those that have there
are some corner cases when they may still happen, contrary
to our desire. In addition, using <i>CURLAUTH_NTLM_WB</i>
authentication could cause a SIGCHLD signal to be
raised.</p>

<p style="margin-left:11%;">CURLOPT_WILDCARDMATCH</p>

<p style="margin-left:22%;">Set this option to 1 if you
want to transfer multiple files according to a file name
pattern. The pattern can be specified as part of the
<i>CURLOPT_URL</i> option, using an fnmatch-like pattern
(Shell Pattern Matching) in the last part of URL (file
name).</p>

<p style="margin-left:22%; margin-top: 1em">By default,
libcurl uses its internal wildcard matching implementation.
You can provide your own matching function by the
<i>CURLOPT_FNMATCH_FUNCTION</i> option.</p>

<p style="margin-left:22%; margin-top: 1em">This feature is
only supported by the FTP download for now.</p>

<p style="margin-left:22%; margin-top: 1em">A brief
introduction of its syntax follows: <br>
* - ASTERISK</p>


<p style="margin-left:32%;">ftp://example.com/some/path/<b>*.txt</b>
(for all txt&rsquo;s from the root directory)</p>

<p style="margin-left:22%;">? - QUESTION MARK</p>

<p style="margin-left:32%;">Question mark matches any
(exactly one) character.</p>


<p style="margin-left:32%; margin-top: 1em">ftp://example.com/some/path/<b>photo?.jpeg</b></p>

<p style="margin-left:22%;">[ - BRACKET EXPRESSION</p>

<p style="margin-left:32%;">The left bracket opens a
bracket expression. The question mark and asterisk have no
special meaning in a bracket expression. Each bracket
expression ends by the right bracket and matches exactly one
character. Some examples follow:</p>


<p style="margin-left:32%; margin-top: 1em"><b>[a-zA-Z0&minus;9]</b>
or <b>[f&minus;gF&minus;G]</b> &minus; character
interval</p>

<p style="margin-left:32%; margin-top: 1em"><b>[abc]</b> -
character enumeration</p>

<p style="margin-left:32%; margin-top: 1em"><b>[^abc]</b>
or <b>[!abc]</b> - negation</p>


<p style="margin-left:32%; margin-top: 1em"><b>[[:</b><i>name</i><b>:]]</b>
class expression. Supported classes are
<b>alnum</b>,<b>lower</b>, <b>space</b>, <b>alpha</b>,
<b>digit</b>, <b>print</b>, <b>upper</b>, <b>blank</b>,
<b>graph</b>, <b>xdigit</b>.</p>

<p style="margin-left:32%; margin-top: 1em"><b>[][-!^]</b>
- special case &minus; matches only &rsquo;&minus;&rsquo;,
&rsquo;]&rsquo;, &rsquo;[&rsquo;, &rsquo;!&rsquo; or
&rsquo;^&rsquo;. These characters have no special
purpose.</p>


<p style="margin-left:32%; margin-top: 1em"><b>[\[\]\\]</b>
- escape syntax. Matches &rsquo;[&rsquo;, &rsquo;]&rsquo; or
&rsquo;\&rsquo;.</p>

<p style="margin-left:32%; margin-top: 1em">Using the rules
above, a file name pattern can be constructed:</p>


<p style="margin-left:32%; margin-top: 1em">ftp://example.com/some/path/<b>[a-z[:upper:]\\].jpeg</b></p>

<p style="margin-left:11%; margin-top: 1em">(This was added
in 7.21.0)</p>

<h2>CALLBACK OPTIONS
<a name="CALLBACK OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_WRITEFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>size_t function(
char *ptr, size_t size, size_t nmemb, void *userdata);</b>
This function gets called by libcurl as soon as there is
data received that needs to be saved. The size of the data
pointed to by <i>ptr</i> is <i>size</i> multiplied with
<i>nmemb</i>, it will not be zero terminated. Return the
number of bytes actually taken care of. If that amount
differs from the amount passed to your function, it&rsquo;ll
signal an error to the library. This will abort the transfer
and return <i>CURLE_WRITE_ERROR</i>.</p>

<p style="margin-left:22%; margin-top: 1em">From 7.18.0,
the function can return CURL_WRITEFUNC_PAUSE which then will
cause writing to this connection to become paused. See
<i>curl_easy_pause(3)</i> for further details.</p>

<p style="margin-left:22%; margin-top: 1em">This function
may be called with zero bytes data if the transferred file
is empty.</p>

<p style="margin-left:22%; margin-top: 1em">Set this option
to NULL to get the internal default function. The internal
default function will write the data to the FILE * given
with <i>CURLOPT_WRITEDATA</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Set the
<i>userdata</i> argument with the <i>CURLOPT_WRITEDATA</i>
option.</p>

<p style="margin-left:22%; margin-top: 1em">The callback
function will be passed as much data as possible in all
invokes, but you cannot possibly make any assumptions. It
may be one byte, it may be thousands. The maximum amount of
body data that can be passed to the write callback is
defined in the curl.h header file: CURL_MAX_WRITE_SIZE (the
usual default is 16K). If you however have
<i>CURLOPT_HEADER</i> set, which sends header data to the
write callback, you can get up to
<i>CURL_MAX_HTTP_HEADER</i> bytes of header data passed into
it. This usually means 100K.</p>

<p style="margin-left:11%;">CURLOPT_WRITEDATA</p>

<p style="margin-left:22%;">Data pointer to pass to the
file write function. If you use the
<i>CURLOPT_WRITEFUNCTION</i> option, this is the pointer
you&rsquo;ll get as input. If you don&rsquo;t use a
callback, you must pass a &rsquo;FILE *&rsquo; as libcurl
will pass this to fwrite() when writing data.</p>

<p style="margin-left:22%; margin-top: 1em">The internal
<i>CURLOPT_WRITEFUNCTION</i> will write the data to the FILE
* given with this option, or to stdout if this option
hasn&rsquo;t been set.</p>

<p style="margin-left:22%; margin-top: 1em">If you&rsquo;re
using libcurl as a win32 DLL, you <b>MUST</b> use the
<i>CURLOPT_WRITEFUNCTION</i> if you set this option or you
will experience crashes.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
also known with the older name <i>CURLOPT_FILE</i>, the name
<i>CURLOPT_WRITEDATA</i> was introduced in 7.9.7.</p>

<p style="margin-left:11%;">CURLOPT_READFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>size_t function(
void *ptr, size_t size, size_t nmemb, void *userdata);</b>
This function gets called by libcurl as soon as it needs to
read data in order to send it to the peer. The data area
pointed at by the pointer <i>ptr</i> may be filled with at
most <i>size</i> multiplied with <i>nmemb</i> number of
bytes. Your function must return the actual number of bytes
that you stored in that memory area. Returning 0 will signal
end-of-file to the library and cause it to stop the current
transfer.</p>

<p style="margin-left:22%; margin-top: 1em">If you stop the
current transfer by returning 0 &quot;pre-maturely&quot;
(i.e before the server expected it, like when you&rsquo;ve
said you will upload N bytes and you upload less than N
bytes), you may experience that the server &quot;hangs&quot;
waiting for the rest of the data that won&rsquo;t come.</p>

<p style="margin-left:22%; margin-top: 1em">The read
callback may return <i>CURL_READFUNC_ABORT</i> to stop the
current operation immediately, resulting in a
<i>CURLE_ABORTED_BY_CALLBACK</i> error code from the
transfer (Added in 7.12.1)</p>

<p style="margin-left:22%; margin-top: 1em">From 7.18.0,
the function can return CURL_READFUNC_PAUSE which then will
cause reading from this connection to become paused. See
<i>curl_easy_pause(3)</i> for further details.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Bugs</b>:
when doing TFTP uploads, you must return the exact amount of
data that the callback wants, or it will be considered the
final packet by the server end and the transfer will end
there.</p>

<p style="margin-left:22%; margin-top: 1em">If you set this
callback pointer to NULL, or don&rsquo;t set it at all, the
default internal read function will be used. It is doing an
fread() on the FILE * userdata set with
<i>CURLOPT_READDATA</i>.</p>

<p style="margin-left:11%;">CURLOPT_READDATA</p>

<p style="margin-left:22%;">Data pointer to pass to the
file read function. If you use the
<i>CURLOPT_READFUNCTION</i> option, this is the pointer
you&rsquo;ll get as input. If you don&rsquo;t specify a read
callback but instead rely on the default internal read
function, this data must be a valid readable FILE *.</p>

<p style="margin-left:22%; margin-top: 1em">If you&rsquo;re
using libcurl as a win32 DLL, you MUST use a
<i>CURLOPT_READFUNCTION</i> if you set this option.</p>

<p style="margin-left:22%; margin-top: 1em">This option was
also known by the older name <i>CURLOPT_INFILE</i>, the name
<i>CURLOPT_READDATA</i> was introduced in 7.9.7.</p>

<p style="margin-left:11%;">CURLOPT_IOCTLFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>curlioerr
function(CURL *handle, int cmd, void *clientp);</b>. This
function gets called by libcurl when something special
I/O-related needs to be done that the library can&rsquo;t do
by itself. For now, rewinding the read data stream is the
only action it can request. The rewinding of the read data
stream may be necessary when doing a HTTP PUT or POST with a
multi-pass authentication method. (Option added in
7.12.3).</p>

<p style="margin-left:22%; margin-top: 1em">Use
<i>CURLOPT_SEEKFUNCTION</i> instead to provide seeking!</p>

<p style="margin-left:11%;">CURLOPT_IOCTLDATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the 3rd argument in the
ioctl callback set with <i>CURLOPT_IOCTLFUNCTION</i>.
(Option added in 7.12.3)</p>

<p style="margin-left:11%;">CURLOPT_SEEKFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int function(void
*instream, curl_off_t offset, int origin);</b> This function
gets called by libcurl to seek to a certain position in the
input stream and can be used to fast forward a file in a
resumed upload (instead of reading all uploaded bytes with
the normal read function/callback). It is also called to
rewind a stream when doing a HTTP PUT or POST with a
multi-pass authentication method. The function shall work
like &quot;fseek&quot; or &quot;lseek&quot; and accepted
SEEK_SET, SEEK_CUR and SEEK_END as argument for origin,
although (in 7.18.0) libcurl only passes SEEK_SET. The
callback must return 0 (CURL_SEEKFUNC_OK) on success, 1
(CURL_SEEKFUNC_FAIL) to cause the upload operation to fail
or 2 (CURL_SEEKFUNC_CANTSEEK) to indicate that while the
seek failed, libcurl is free to work around the problem if
possible. The latter can sometimes be done by instead
reading from the input or similar.</p>

<p style="margin-left:22%; margin-top: 1em">If you forward
the input arguments directly to &quot;fseek&quot; or
&quot;lseek&quot;, note that the data type for <i>offset</i>
is not the same as defined for curl_off_t on many systems!
(Option added in 7.18.0)</p>

<p style="margin-left:11%;">CURLOPT_SEEKDATA</p>

<p style="margin-left:22%;">Data pointer to pass to the
file seek function. If you use the
<i>CURLOPT_SEEKFUNCTION</i> option, this is the pointer
you&rsquo;ll get as input. If you don&rsquo;t specify a seek
callback, NULL is passed. (Option added in 7.18.0)</p>

<p style="margin-left:11%;">CURLOPT_SOCKOPTFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int function(void
*clientp, curl_socket_t curlfd, curlsocktype purpose);</b>.
This function gets called by libcurl after the socket() call
but before the connect() call. The callback&rsquo;s
<i>purpose</i> argument identifies the exact purpose for
this particular socket:</p>


<p style="margin-left:22%; margin-top: 1em"><i>CURLSOCKTYPE_IPCXN</i>
for actively created connections or since 7.28.0
<i>CURLSOCKTYPE_ACCEPT</i> for FTP when the connection was
setup with PORT/EPSV (in earlier versions these sockets
weren&rsquo;t passed to this callback).</p>

<p style="margin-left:22%; margin-top: 1em">Future versions
of libcurl may support more purposes. It passes the newly
created socket descriptor so additional setsockopt() calls
can be done at the user&rsquo;s discretion. Return 0 (zero)
from the callback on success. Return 1 from the callback
function to signal an unrecoverable error to the library and
it will close the socket and return
<i>CURLE_COULDNT_CONNECT</i>. (Option added in 7.16.0)</p>

<p style="margin-left:22%; margin-top: 1em">Added in
7.21.5, the callback function may return
<i>CURL_SOCKOPT_ALREADY_CONNECTED</i>, which tells libcurl
that the socket is in fact already connected and then
libcurl will not attempt to connect it.</p>

<p style="margin-left:11%;">CURLOPT_SOCKOPTDATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the first argument in the
sockopt callback set with <i>CURLOPT_SOCKOPTFUNCTION</i>.
(Option added in 7.16.0)</p>

<p style="margin-left:11%;">CURLOPT_OPENSOCKETFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>curl_socket_t
function(void *clientp, curlsocktype purpose, struct
curl_sockaddr *address);</b>. This function gets called by
libcurl instead of the <i>socket(2)</i> call. The
callback&rsquo;s <i>purpose</i> argument identifies the
exact purpose for this particular socket:
<i>CURLSOCKTYPE_IPCXN</i> is for IP based connections.
Future versions of libcurl may support more purposes. It
passes the resolved peer address as a <i>address</i>
argument so the callback can modify the address or refuse to
connect at all. The callback function should return the
socket or <i>CURL_SOCKET_BAD</i> in case no connection could
be established or another error was detected. Any additional
<i>setsockopt(2)</i> calls can be done on the socket at the
user&rsquo;s discretion. <i>CURL_SOCKET_BAD</i> return value
from the callback function will signal an unrecoverable
error to the library and it will return
<i>CURLE_COULDNT_CONNECT</i>. This return code can be used
for IP address blacklisting. The default behavior is: <br>
return socket(addr-&gt;family, addr-&gt;socktype,
addr-&gt;protocol); <br>
(Option added in 7.17.1.)</p>

<p style="margin-left:11%;">CURLOPT_OPENSOCKETDATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the first argument in the
opensocket callback set with
<i>CURLOPT_OPENSOCKETFUNCTION</i>. (Option added in
7.17.1.)</p>


<p style="margin-left:11%;">CURLOPT_CLOSESOCKETFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int function(void
*clientp, curl_socket_t item);</b>. This function gets
called by libcurl instead of the <i>close(3)</i> or
<i>closesocket(3)</i> call when sockets are closed (not for
any other file descriptors). This is pretty much the reverse
to the <i>CURLOPT_OPENSOCKETFUNCTION</i> option. Return 0 to
signal success and 1 if there was an error. (Option added in
7.21.7)</p>

<p style="margin-left:11%;">CURLOPT_CLOSESOCKETDATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the first argument in the
closesocket callback set with
<i>CURLOPT_CLOSESOCKETFUNCTION</i>. (Option added in
7.21.7)</p>

<p style="margin-left:11%;">CURLOPT_PROGRESSFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int function(void
*clientp, double dltotal, double dlnow, double ultotal,
double ulnow);</b> . This function gets called by libcurl
instead of its internal equivalent with a frequent interval
during operation (roughly once per second or sooner) no
matter if data is being transferred or not. Unknown/unused
argument values passed to the callback will be set to zero
(like if you only download data, the upload size will remain
0). Returning a non-zero value from this callback will cause
libcurl to abort the transfer and return
<i>CURLE_ABORTED_BY_CALLBACK</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If you transfer
data with the multi interface, this function will not be
called during periods of idleness unless you call the
appropriate libcurl function that performs transfers.</p>


<p style="margin-left:22%; margin-top: 1em"><i>CURLOPT_NOPROGRESS</i>
must be set to 0 to make this function actually get
called.</p>

<p style="margin-left:11%;">CURLOPT_PROGRESSDATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the first argument in the
progress callback set with
<i>CURLOPT_PROGRESSFUNCTION</i>.</p>

<p style="margin-left:11%;">CURLOPT_HEADERFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>size_t function(
void *ptr, size_t size, size_t nmemb, void *userdata);</b>.
This function gets called by libcurl as soon as it has
received header data. The header callback will be called
once for each header and only complete header lines are
passed on to the callback. Parsing headers is very easy
using this. The size of the data pointed to by <i>ptr</i> is
<i>size</i> multiplied with <i>nmemb</i>. Do not assume that
the header line is zero terminated! The pointer named
<i>userdata</i> is the one you set with the
<i>CURLOPT_WRITEHEADER</i> option. The callback function
must return the number of bytes actually taken care of. If
that amount differs from the amount passed to your function,
it&rsquo;ll signal an error to the library. This will abort
the transfer and return <i>CURL_WRITE_ERROR</i>.</p>

<p style="margin-left:22%; margin-top: 1em">A complete HTTP
header that is passed to this function can be up to
<i>CURL_MAX_HTTP_HEADER</i> (100K) bytes.</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is not set, or if it is set to NULL, but
<i>CURLOPT_HEADERDATA</i> (<i>CURLOPT_WRITEHEADER</i>) is
set to anything but NULL, the function used to accept
response data will be used instead. That is, it will be the
function specified with <i>CURLOPT_WRITEFUNCTION</i>, or if
it is not specified or NULL - the default, stream-writing
function.</p>

<p style="margin-left:22%; margin-top: 1em">It&rsquo;s
important to note that the callback will be invoked for the
headers of all responses received after initiating a request
and not just the final response. This includes all responses
which occur during authentication negotiation. If you need
to operate on only the headers from the final response, you
will need to collect headers in the callback yourself and
use HTTP status lines, for example, to delimit response
boundaries.</p>

<p style="margin-left:22%; margin-top: 1em">When a server
sends a chunked encoded transfer, it may contain a trailer.
That trailer is identical to a HTTP header and if such a
trailer is received it is passed to the application using
this callback as well. There are several ways to detect it
being a trailer and not an ordinary header: 1) it comes
after the response-body. 2) it comes after the final header
line (CR LF) 3) a Trailer: header among the regular
response-headers mention what header(s) to expect in the
trailer.</p>

<p style="margin-left:22%; margin-top: 1em">For non-HTTP
protocols like FTP, POP3, IMAP and SMTP this function will
get called with the server responses to the commands that
libcurl sends.</p>

<p style="margin-left:11%;">CURLOPT_WRITEHEADER</p>

<p style="margin-left:22%;">(This option is also known as
<b>CURLOPT_HEADERDATA</b>) Pass a pointer to be used to
write the header part of the received data to. If you
don&rsquo;t use <i>CURLOPT_WRITEFUNCTION</i> or
<i>CURLOPT_HEADERFUNCTION</i> to take care of the writing,
this must be a valid FILE * as the internal default will
then be a plain fwrite(). See also the
<i>CURLOPT_HEADERFUNCTION</i> option above on how to set a
custom get-all-headers callback.</p>

<p style="margin-left:11%;">CURLOPT_DEBUGFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int
curl_debug_callback (CURL *, curl_infotype, char *, size_t,
void *);</b> <i>CURLOPT_DEBUGFUNCTION</i> replaces the
standard debug function used when <i>CURLOPT_VERBOSE</i> is
in effect. This callback receives debug information, as
specified with the <b>curl_infotype</b> argument. This
function must return 0. The data pointed to by the char *
passed to this function WILL NOT be zero terminated, but
will be exactly of the size as told by the size_t
argument.</p>

<p style="margin-left:22%; margin-top: 1em">Available
curl_infotype values: <br>
CURLINFO_TEXT</p>

<p style="margin-left:32%;">The data is informational
text.</p>

<p style="margin-left:22%;">CURLINFO_HEADER_IN</p>

<p style="margin-left:32%;">The data is header (or
header-like) data received from the peer.</p>

<p style="margin-left:22%;">CURLINFO_HEADER_OUT</p>

<p style="margin-left:32%;">The data is header (or
header-like) data sent to the peer.</p>

<p style="margin-left:22%;">CURLINFO_DATA_IN</p>

<p style="margin-left:32%;">The data is protocol data
received from the peer.</p>

<p style="margin-left:22%;">CURLINFO_DATA_OUT</p>

<p style="margin-left:32%;">The data is protocol data sent
to the peer.</p>

<p style="margin-left:11%;">CURLOPT_DEBUGDATA</p>

<p style="margin-left:22%;">Pass a pointer to whatever you
want passed in to your <i>CURLOPT_DEBUGFUNCTION</i> in the
last void * argument. This pointer is not used by libcurl,
it is only passed to the callback.</p>

<p style="margin-left:11%;">CURLOPT_SSL_CTX_FUNCTION</p>

<p style="margin-left:22%;">This option does only function
for libcurl powered by OpenSSL. If libcurl was built against
another SSL library, this functionality is absent.</p>

<p style="margin-left:22%; margin-top: 1em">Pass a pointer
to a function that matches the following prototype:
<b>CURLcode sslctxfun(CURL *curl, void *sslctx, void
*parm);</b> This function gets called by libcurl just before
the initialization of a SSL connection after having
processed all other SSL related options to give a last
chance to an application to modify the behaviour of
openssl&rsquo;s ssl initialization. The <i>sslctx</i>
parameter is actually a pointer to an openssl
<i>SSL_CTX</i>. If an error is returned no attempt to
establish a connection is made and the perform operation
will return the error code from this callback function. Set
the <i>parm</i> argument with the
<i>CURLOPT_SSL_CTX_DATA</i> option. This option was
introduced in 7.11.0.</p>

<p style="margin-left:22%; margin-top: 1em">This function
will get called on all new connections made to a server,
during the SSL negotiation. The SSL_CTX pointer will be a
new one every time.</p>

<p style="margin-left:22%; margin-top: 1em">To use this
properly, a non-trivial amount of knowledge of the openssl
libraries is necessary. For example, using this function
allows you to use openssl callbacks to add additional
validation code for certificates, and even to change the
actual URI of a HTTPS request (example used in the lib509
test case). See also the example section for a replacement
of the key, certificate and trust file settings.</p>

<p style="margin-left:11%;">CURLOPT_SSL_CTX_DATA</p>

<p style="margin-left:22%;">Data pointer to pass to the ssl
context callback set by the option
<i>CURLOPT_SSL_CTX_FUNCTION</i>, this is the pointer
you&rsquo;ll get as third parameter, otherwise <b>NULL</b>.
(Added in 7.11.0)</p>


<p style="margin-left:11%;">CURLOPT_CONV_TO_NETWORK_FUNCTION
<br>
CURLOPT_CONV_FROM_NETWORK_FUNCTION <br>
CURLOPT_CONV_FROM_UTF8_FUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>CURLcode
function(char *ptr, size_t length);</b></p>

<p style="margin-left:22%; margin-top: 1em">These three
options apply to non-ASCII platforms only. They are
available only if <b>CURL_DOES_CONVERSIONS</b> was defined
when libcurl was built. When this is the case,
<i>curl_version_info(3)</i> will return the
CURL_VERSION_CONV feature bit set.</p>

<p style="margin-left:22%; margin-top: 1em">The data to be
converted is in a buffer pointed to by the ptr parameter.
The amount of data to convert is indicated by the length
parameter. The converted data overlays the input data in the
buffer pointed to by the ptr parameter. CURLE_OK should be
returned upon successful conversion. A CURLcode return value
defined by curl.h, such as CURLE_CONV_FAILED, should be
returned if an error was encountered.</p>


<p style="margin-left:22%; margin-top: 1em"><b>CURLOPT_CONV_TO_NETWORK_FUNCTION</b>
and <b>CURLOPT_CONV_FROM_NETWORK_FUNCTION</b> convert
between the host encoding and the network encoding. They are
used when commands or ASCII data are sent/received over the
network.</p>


<p style="margin-left:22%; margin-top: 1em"><b>CURLOPT_CONV_FROM_UTF8_FUNCTION</b>
is called to convert from UTF8 into the host encoding. It is
required only for SSL processing.</p>

<p style="margin-left:22%; margin-top: 1em">If you set a
callback pointer to NULL, or don&rsquo;t set it at all, the
built-in libcurl iconv functions will be used. If HAVE_ICONV
was not defined when libcurl was built, and no callback has
been established, conversion will return the CURLE_CONV_REQD
error code.</p>

<p style="margin-left:22%; margin-top: 1em">If HAVE_ICONV
is defined, CURL_ICONV_CODESET_OF_HOST must also be defined.
For example:</p>

<p style="margin-left:22%; margin-top: 1em">#define
CURL_ICONV_CODESET_OF_HOST &quot;IBM-1047&quot;</p>

<p style="margin-left:22%; margin-top: 1em">The iconv code
in libcurl will default the network and UTF8 codeset names
as follows:</p>

<p style="margin-left:22%; margin-top: 1em">#define
CURL_ICONV_CODESET_OF_NETWORK &quot;ISO8859-1&quot;</p>

<p style="margin-left:22%; margin-top: 1em">#define
CURL_ICONV_CODESET_FOR_UTF8 &quot;UTF-8&quot;</p>

<p style="margin-left:22%; margin-top: 1em">You will need
to override these definitions if they are different on your
system.</p>

<p style="margin-left:11%;">CURLOPT_INTERLEAVEFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>size_t function(
void *ptr, size_t size, size_t nmemb, void *userdata)</b>.
This function gets called by libcurl as soon as it has
received interleaved RTP data. This function gets called for
each $ block and therefore contains exactly one upper-layer
protocol unit (e.g. one RTP packet). Curl writes the
interleaved header as well as the included data for each
call. The first byte is always an ASCII dollar sign. The
dollar sign is followed by a one byte channel identifier and
then a 2 byte integer length in network byte order. See
<i>RFC2326 Section 10.12</i> for more information on how RTP
interleaving behaves. If unset or set to NULL, curl will use
the default write function.</p>

<p style="margin-left:22%; margin-top: 1em">Interleaved RTP
poses some challenges for the client application. Since the
stream data is sharing the RTSP control connection, it is
critical to service the RTP in a timely fashion. If the RTP
data is not handled quickly, subsequent response processing
may become unreasonably delayed and the connection may
close. The application may use <i>CURL_RTSPREQ_RECEIVE</i>
to service RTP data when no requests are desired. If the
application makes a request, (e.g.
<i>CURL_RTSPREQ_PAUSE</i>) then the response handler will
process any pending RTP data before marking the request as
finished. (Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_INTERLEAVEDATA</p>

<p style="margin-left:22%;">This is the userdata pointer
that will be passed to <i>CURLOPT_INTERLEAVEFUNCTION</i>
when interleaved RTP data is received. (Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_CHUNK_BGN_FUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>long function
(const void *transfer_info, void *ptr, int remains)</b>.
This function gets called by libcurl before a part of the
stream is going to be transferred (if the transfer supports
chunks).</p>

<p style="margin-left:22%; margin-top: 1em">This callback
makes sense only when using the <i>CURLOPT_WILDCARDMATCH</i>
option for now.</p>

<p style="margin-left:22%; margin-top: 1em">The target of
transfer_info parameter is a &quot;feature depended&quot;
structure. For the FTP wildcard download, the target is
curl_fileinfo structure (see <i>curl/curl.h</i>). The
parameter ptr is a pointer given by
<i>CURLOPT_CHUNK_DATA</i>. The parameter remains contains
number of chunks remaining per the transfer. If the feature
is not available, the parameter has zero value.</p>

<p style="margin-left:22%; margin-top: 1em">Return
<i>CURL_CHUNK_BGN_FUNC_OK</i> if everything is fine,
<i>CURL_CHUNK_BGN_FUNC_SKIP</i> if you want to skip the
concrete chunk or <i>CURL_CHUNK_BGN_FUNC_FAIL</i> to tell
libcurl to stop if some error occurred. (This was added in
7.21.0)</p>

<p style="margin-left:11%;">CURLOPT_CHUNK_END_FUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>long function(void
*ptr)</b>. This function gets called by libcurl as soon as a
part of the stream has been transferred (or skipped).</p>

<p style="margin-left:22%; margin-top: 1em">Return
<i>CURL_CHUNK_END_FUNC_OK</i> if everything is fine or
<b>CURL_CHUNK_END_FUNC_FAIL</b> to tell the lib to stop if
some error occurred. (This was added in 7.21.0)</p>

<p style="margin-left:11%;">CURLOPT_CHUNK_DATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the ptr argument to the
<i>CURL_CHUNK_BGN_FUNTION</i> and
<i>CURL_CHUNK_END_FUNTION</i>. (This was added in
7.21.0)</p>

<p style="margin-left:11%;">CURLOPT_FNMATCH_FUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a function
that matches the following prototype: <b>int function(void
*ptr, const char *pattern, const char *string)</b> prototype
(see <i>curl/curl.h</i>). It is used internally for the
wildcard matching feature.</p>

<p style="margin-left:22%; margin-top: 1em">Return
<i>CURL_FNMATCHFUNC_MATCH</i> if pattern matches the string,
<i>CURL_FNMATCHFUNC_NOMATCH</i> if not or
<i>CURL_FNMATCHFUNC_FAIL</i> if an error occurred. (This was
added in 7.21.0)</p>

<p style="margin-left:11%;">CURLOPT_FNMATCH_DATA</p>

<p style="margin-left:22%;">Pass a pointer that will be
untouched by libcurl and passed as the ptr argument to the
<i>CURL_FNMATCH_FUNCTION</i>. (This was added in 7.21.0)</p>

<h2>ERROR OPTIONS
<a name="ERROR OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_ERRORBUFFER</p>

<p style="margin-left:22%;">Pass a char * to a buffer that
the libcurl may store human readable error messages in. This
may be more helpful than just the return code from
<i>curl_easy_perform</i>. The buffer must be at least
CURL_ERROR_SIZE big. Although this argument is a &rsquo;char
*&rsquo;, it does not describe an input string. Therefore
the (probably undefined) contents of the buffer is NOT
copied by the library. You must keep the associated storage
available until libcurl no longer needs it. Failing to do so
will cause very odd behavior or even crashes. libcurl will
need it until you call <i>curl_easy_cleanup(3)</i> or you
set the same option again to use a different pointer.</p>

<p style="margin-left:22%; margin-top: 1em">Use
<i>CURLOPT_VERBOSE</i> and <i>CURLOPT_DEBUGFUNCTION</i> to
better debug/trace why errors happen.</p>

<p style="margin-left:22%; margin-top: 1em">If the library
does not return an error, the buffer may not have been
touched. Do not rely on the contents in those cases.</p>

<p style="margin-left:11%;">CURLOPT_STDERR</p>

<p style="margin-left:22%;">Pass a FILE * as parameter.
Tell libcurl to use this stream instead of stderr when
showing the progress meter and displaying
<i>CURLOPT_VERBOSE</i> data.</p>

<p style="margin-left:11%;">CURLOPT_FAILONERROR</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to fail silently if the HTTP code returned is equal
to or larger than 400. The default action would be to return
the page normally, ignoring that code.</p>

<p style="margin-left:22%; margin-top: 1em">This method is
not fail-safe and there are occasions where non-successful
response codes will slip through, especially when
authentication is involved (response codes 401 and 407).</p>

<p style="margin-left:22%; margin-top: 1em">You might get
some amounts of headers transferred before this situation is
detected, like when a &quot;100-continue&quot; is received
as a response to a POST/PUT and a 401 or 407 is received
immediately afterwards.</p>

<h2>NETWORK OPTIONS
<a name="NETWORK OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_URL</p>

<p style="margin-left:22%;">Pass in a pointer to the actual
URL to deal with. The parameter should be a char * to a zero
terminated string which must be URL-encoded in the following
format:</p>


<p style="margin-left:22%; margin-top: 1em">scheme://host:port/path</p>

<p style="margin-left:22%; margin-top: 1em">For a greater
explanation of the format please see RFC3986.</p>

<p style="margin-left:22%; margin-top: 1em">If the given
URL lacks the scheme, or protocol, part (&quot;http://&quot;
or &quot;ftp://&quot; etc), libcurl will attempt to resolve
which protocol to use based on the given host mame. If the
protocol is not supported, libcurl will return
(<i>CURLE_UNSUPPORTED_PROTOCOL</i>) when you call
<i>curl_easy_perform(3)</i> or <i>curl_multi_perform(3)</i>.
Use <i>curl_version_info(3)</i> for detailed information on
which protocols are supported.</p>

<p style="margin-left:22%; margin-top: 1em">The host part
of the URL contains the address of the server that you want
to connect to. This can be the fully qualified domain name
of the server, the local network name of the machine on your
network or the IP address of the server or machine
represented by either an IPv4 or IPv6 address. For
example:</p>


<p style="margin-left:22%; margin-top: 1em">http://www.example.com/</p>


<p style="margin-left:22%; margin-top: 1em">http://hostname/</p>


<p style="margin-left:22%; margin-top: 1em">http://192.168.0.1/</p>


<p style="margin-left:22%; margin-top: 1em">http://[2001:1890:1112:1::20]/</p>

<p style="margin-left:22%; margin-top: 1em">It is also
possible to specify the user name and password as part of
the host, for some protocols, when connecting to servers
that require authentication.</p>

<p style="margin-left:22%; margin-top: 1em">For example the
following types of authentication support this:</p>


<p style="margin-left:22%; margin-top: 1em">http://user:password@www.example.com</p>


<p style="margin-left:22%; margin-top: 1em">ftp://user:password@ftp.example.com</p>


<p style="margin-left:22%; margin-top: 1em">pop3://user:password@mail.example.com</p>

<p style="margin-left:22%; margin-top: 1em">The port is
optional and when not specified libcurl will use the default
port based on the determined or specified protocol: 80 for
HTTP, 21 for FTP and 25 for SMTP, etc. The following
examples show how to specify the port:</p>


<p style="margin-left:22%; margin-top: 1em">http://www.example.com:8080/
- This will connect to a web server using port 8080 rather
than 80.</p>


<p style="margin-left:22%; margin-top: 1em">smtp://mail.example.com:587/
- This will connect to a SMTP server on the alternative mail
port.</p>

<p style="margin-left:22%; margin-top: 1em">The path part
of the URL is protocol specific and whilst some examples are
given below this list is not conclusive:</p>


<p style="margin-left:22%; margin-top: 1em"><b>HTTP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a HTTP request specifies the file to retrieve and from
what directory. If the directory is not specified then the
web server&rsquo;s root directory is used. If the file is
omitted then the default document will be retrieved for
either the directory specified or the root directory. The
exact resource returned for each URL is entirely dependent
on the server&rsquo;s configuration.</p>


<p style="margin-left:22%; margin-top: 1em">http://www.example.com
- This gets the main page from the web server.</p>


<p style="margin-left:22%; margin-top: 1em">http://www.example.com/index.html
- This returns the main page by explicitly requesting
it.</p>


<p style="margin-left:22%; margin-top: 1em">http://www.example.com/contactus/
- This returns the default document from the contactus
directory.</p>

<p style="margin-left:22%; margin-top: 1em"><b>FTP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of an FTP request specifies the file to retrieve and from
what directory. If the file part is omitted then libcurl
downloads the directory listing for the directory specified.
If the directory is omitted then the directory listing for
the root / home directory will be returned.</p>


<p style="margin-left:22%; margin-top: 1em">ftp://ftp.example.com
- This retrieves the directory listing for the root
directory.</p>


<p style="margin-left:22%; margin-top: 1em">ftp://ftp.example.com/readme.txt
- This downloads the file readme.txt from the root
directory.</p>


<p style="margin-left:22%; margin-top: 1em">ftp://ftp.example.com/libcurl/readme.txt
- This downloads readme.txt from the libcurl directory.</p>


<p style="margin-left:22%; margin-top: 1em">ftp://user:password@ftp.example.com/readme.txt
- This retrieves the readme.txt file from the user&rsquo;s
home directory. When a username and password is specified,
everything that is specified in the path part is relative to
the user&rsquo;s home directory. To retrieve files from the
root directory or a directory underneath the root directory
then the absolute path must be specified by prepending an
additional forward slash to the beginning of the path.</p>


<p style="margin-left:22%; margin-top: 1em">ftp://user:password@ftp.example.com//readme.txt
- This retrieves the readme.txt from the root directory when
logging in as a specified user.</p>


<p style="margin-left:22%; margin-top: 1em"><b>SMTP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a SMTP request specifies the host name to present during
communication with the mail server. If the path is omitted
then libcurl will attempt to resolve the local
computer&rsquo;s host name. However, this may not return the
fully qualified domain name that is required by some mail
servers and specifying this path allows you to set an
alternative name, such as your machine&rsquo;s fully
qualified domain name, which you might have obtained from an
external function such as gethostname or getaddrinfo.</p>


<p style="margin-left:22%; margin-top: 1em">smtp://mail.example.com
- This connects to the mail server at example.com and sends
your local computer&rsquo;s host name in the HELO / EHLO
command.</p>


<p style="margin-left:22%; margin-top: 1em">smtp://mail.example.com/client.example.com
- This will send client.example.com in the HELO / EHLO
command to the mail server at example.com.</p>


<p style="margin-left:22%; margin-top: 1em"><b>POP3</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a POP3 request specifies the mailbox (message) to
retrieve. If the mailbox is not specified then a list of
waiting messages is returned instead.</p>


<p style="margin-left:22%; margin-top: 1em">pop3://user:password@mail.example.com
- This lists the available messages
pop3://user:password@mail.example.com/1 - This retrieves the
first message</p>

<p style="margin-left:22%; margin-top: 1em"><b>SCP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a SCP request specifies the file to retrieve and from
what directory. The file part may not be omitted. The file
is taken as an absolute path from the root directory on the
server. To specify a path relative to the user&rsquo;s home
directory on the server, prepend ~/ to the path portion. If
the user name is not embedded in the URL, it can be set with
the <i>CURLOPT_USERPWD</i> or <b>CURLOPT_USERNAME</b>
option.</p>


<p style="margin-left:22%; margin-top: 1em">scp://user@example.com/etc/issue
- This specifies the file /etc/issue</p>


<p style="margin-left:22%; margin-top: 1em">scp://example.com/~/my-file
- This specifies the file my-file in the user&rsquo;s home
directory on the server</p>


<p style="margin-left:22%; margin-top: 1em"><b>SFTP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a SFTP request specifies the file to retrieve and from
what directory. If the file part is omitted then libcurl
downloads the directory listing for the directory specified.
If the path ends in a / then a directory listing is returned
instead of a file. If the path is omitted entirely then the
directory listing for the root / home directory will be
returned. If the user name is not embedded in the URL, it
can be set with the <i>CURLOPT_USERPWD</i> or
<b>CURLOPT_USERNAME</b> option.</p>


<p style="margin-left:22%; margin-top: 1em">sftp://user:password@example.com/etc/issue
- This specifies the file /etc/issue</p>


<p style="margin-left:22%; margin-top: 1em">sftp://user@example.com/~/my-file
- This specifies the file my-file in the user&rsquo;s home
directory</p>


<p style="margin-left:22%; margin-top: 1em">sftp://ssh.example.com/~/Documents/
- This requests a directory listing of the Documents
directory under the user&rsquo;s home directory</p>


<p style="margin-left:22%; margin-top: 1em"><b>LDAP</b></p>

<p style="margin-left:22%; margin-top: 1em">The path part
of a LDAP request can be used to specify the: Distinguished
Name, Attributes, Scope, Filter and Extension for a LDAP
search. Each field is separated by a question mark and when
that field is not required an empty string with the question
mark separator should be included.</p>


<p style="margin-left:22%; margin-top: 1em">ldap://ldap.example.com/o=My%20Organisation
- This will perform a LDAP search with the DN as My
Organisation.</p>


<p style="margin-left:22%; margin-top: 1em">ldap://ldap.example.com/o=My%20Organisation?postalAddress
- This will perform the same search but will only return
postalAddress attributes.</p>


<p style="margin-left:22%; margin-top: 1em">ldap://ldap.example.com/?rootDomainNamingContext
- This specifies an empty DN and requests information about
the rootDomainNamingContext attribute for an Active
Directory server.</p>

<p style="margin-left:22%; margin-top: 1em">For more
information about the individual components of a LDAP URL
please see RFC4516.</p>


<p style="margin-left:22%; margin-top: 1em"><b>NOTES</b></p>

<p style="margin-left:22%; margin-top: 1em">Starting with
version 7.20.0, the fragment part of the URI will not be
sent as part of the path, which was previously the case.</p>


<p style="margin-left:22%; margin-top: 1em"><i>CURLOPT_URL</i>
is the only option that <b>must</b> be set before
<i>curl_easy_perform(3)</i> is called.</p>


<p style="margin-left:22%; margin-top: 1em"><i>CURLOPT_PROTOCOLS</i>
can be used to limit what protocols libcurl will use for
this transfer, independent of what libcurl has been compiled
to support. That may be useful if you accept the URL from an
external source and want to limit the accessibility.</p>

<p style="margin-left:11%;">CURLOPT_PROTOCOLS</p>

<p style="margin-left:22%;">Pass a long that holds a
bitmask of CURLPROTO_* defines. If used, this bitmask limits
what protocols libcurl may use in the transfer. This allows
you to have a libcurl built to support a wide range of
protocols but still limit specific transfers to only be
allowed to use a subset of them. By default libcurl will
accept all protocols it supports. See also
<i>CURLOPT_REDIR_PROTOCOLS</i>. (Added in 7.19.4)</p>

<p style="margin-left:11%;">CURLOPT_REDIR_PROTOCOLS</p>

<p style="margin-left:22%;">Pass a long that holds a
bitmask of CURLPROTO_* defines. If used, this bitmask limits
what protocols libcurl may use in a transfer that it follows
to in a redirect when <i>CURLOPT_FOLLOWLOCATION</i> is
enabled. This allows you to limit specific transfers to only
be allowed to use a subset of protocols in redirections. By
default libcurl will allow all protocols except for FILE and
SCP. This is a difference compared to pre-7.19.4 versions
which unconditionally would follow to all protocols
supported. (Added in 7.19.4)</p>

<p style="margin-left:11%;">CURLOPT_PROXY</p>

<p style="margin-left:22%;">Set HTTP proxy to use. The
parameter should be a char * to a zero terminated string
holding the host name or dotted IP address. To specify port
number in this string, append :[port] to the end of the host
name. The proxy string may be prefixed with [protocol]://
since any such prefix will be ignored. The proxy&rsquo;s
port number may optionally be specified with the separate
option. If not specified, libcurl will default to using port
1080 for proxies. <i>CURLOPT_PROXYPORT</i>.</p>

<p style="margin-left:22%; margin-top: 1em">When you tell
the library to use a HTTP proxy, libcurl will transparently
convert operations to HTTP even if you specify an FTP URL
etc. This may have an impact on what other features of the
library you can use, such as <i>CURLOPT_QUOTE</i> and
similar FTP specifics that don&rsquo;t work unless you
tunnel through the HTTP proxy. Such tunneling is activated
with <i>CURLOPT_HTTPPROXYTUNNEL</i>.</p>

<p style="margin-left:22%; margin-top: 1em">libcurl
respects the environment variables <b>http_proxy</b>,
<b>ftp_proxy</b>, <b>all_proxy</b> etc, if any of those are
set. The <i>CURLOPT_PROXY</i> option does however override
any possibly set environment variables.</p>

<p style="margin-left:22%; margin-top: 1em">Setting the
proxy string to &quot;&quot; (an empty string) will
explicitly disable the use of a proxy, even if there is an
environment variable set for it.</p>

<p style="margin-left:22%; margin-top: 1em">Since 7.14.1,
the proxy host string given in environment variables can be
specified the exact same way as the proxy can be set with
<i>CURLOPT_PROXY</i>, include protocol prefix (http://) and
embedded user + password.</p>

<p style="margin-left:22%; margin-top: 1em">Since 7.21.7,
the proxy string may be specified with a protocol:// prefix
to specify alternative proxy protocols. Use socks4://,
socks4a://, socks5:// or socks5h:// (the last one to enable
socks5 and asking the proxy to do the resolving, also known
as CURLPROXY_SOCKS5_HOSTNAME type) to request the specific
SOCKS version to be used. No protocol specified, http:// and
all others will be treated as HTTP proxies.</p>

<p style="margin-left:11%;">CURLOPT_PROXYPORT</p>

<p style="margin-left:22%;">Pass a long with this option to
set the proxy port to connect to unless it is specified in
the proxy string <i>CURLOPT_PROXY</i>.</p>

<p style="margin-left:11%;">CURLOPT_PROXYTYPE</p>

<p style="margin-left:22%;">Pass a long with this option to
set type of the proxy. Available options for this are
<i>CURLPROXY_HTTP</i>, <i>CURLPROXY_HTTP_1_0</i> (added in
7.19.4), <i>CURLPROXY_SOCKS4</i> (added in 7.10),
<i>CURLPROXY_SOCKS5</i>, <i>CURLPROXY_SOCKS4A</i> (added in
7.18.0) and <i>CURLPROXY_SOCKS5_HOSTNAME</i> (added in
7.18.0). The HTTP type is default. (Added in 7.10)</p>

<p style="margin-left:22%; margin-top: 1em">If you set
<b>CURLOPT_PROXYTYPE</b> to <i>CURLPROXY_HTTP_1_0</i>, it
will only affect how libcurl speaks to a proxy when CONNECT
is used. The HTTP version used for &quot;regular&quot; HTTP
requests is instead controlled with
<i>CURLOPT_HTTP_VERSION</i>.</p>

<p style="margin-left:11%;">CURLOPT_NOPROXY</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string. The string consists of a comma separated
list of host names that do not require a proxy to get
reached, even if one is specified. The only wildcard
available is a single * character, which matches all hosts,
and effectively disables the proxy. Each name in this list
is matched as either a domain which contains the hostname,
or the hostname itself. For example, example.com would match
example.com, example.com:80, and www.example.com, but not
www.notanexample.com. (Added in 7.19.4)</p>

<p style="margin-left:11%;">CURLOPT_HTTPPROXYTUNNEL</p>

<p style="margin-left:22%;">Set the parameter to 1 to make
the library tunnel all operations through a given HTTP
proxy. There is a big difference between using a proxy and
to tunnel through it. If you don&rsquo;t know what this
means, you probably don&rsquo;t want this tunneling
option.</p>


<p style="margin-left:11%;">CURLOPT_SOCKS5_GSSAPI_SERVICE</p>

<p style="margin-left:22%;">Pass a char * as parameter to a
string holding the name of the service. The default service
name for a SOCKS5 server is rcmd/server-fqdn. This option
allows you to change it. (Added in 7.19.4)</p>

<p style="margin-left:11%;">CURLOPT_SOCKS5_GSSAPI_NEC</p>

<p style="margin-left:22%;">Pass a long set to 1 to enable
or 0 to disable. As part of the gssapi negotiation a
protection mode is negotiated. The RFC1961 says in section
4.3/4.4 it should be protected, but the NEC reference
implementation does not. If enabled, this option allows the
unprotected exchange of the protection mode negotiation.
(Added in 7.19.4).</p>

<p style="margin-left:11%;">CURLOPT_INTERFACE</p>

<p style="margin-left:22%;">Pass a char * as parameter.
This sets the interface name to use as outgoing network
interface. The name can be an interface name, an IP address,
or a host name.</p>

<p style="margin-left:22%; margin-top: 1em">Starting with
7.24.0: If the parameter starts with &quot;if!&quot; then it
is treated as only as interface name and no attempt will
ever be named to do treat it as an IP address or to do name
resolution on it. If the parameter starts with
&quot;host!&quot; it is treated as either an IP address or a
hostname. Hostnames are resolved synchronously. Using the
if! format is highly recommended when using the multi
interfaces to avoid allowing the code to block. If
&quot;if!&quot; is specified but the parameter does not
match an existing interface, CURLE_INTERFACE_FAILED is
returned.</p>

<p style="margin-left:11%;">CURLOPT_LOCALPORT</p>

<p style="margin-left:22%;">Pass a long. This sets the
local port number of the socket used for connection. This
can be used in combination with <i>CURLOPT_INTERFACE</i> and
you are recommended to use <i>CURLOPT_LOCALPORTRANGE</i> as
well when this is set. Valid port numbers are 1 - 65535.
(Added in 7.15.2)</p>

<p style="margin-left:11%;">CURLOPT_LOCALPORTRANGE</p>

<p style="margin-left:22%;">Pass a long. This is the number
of attempts libcurl will make to find a working local port
number. It starts with the given <i>CURLOPT_LOCALPORT</i>
and adds one to the number for each retry. Setting this to 1
or below will make libcurl do only one try for the exact
port number. Port numbers by nature are scarce resources
that will be busy at times so setting this value to
something too low might cause unnecessary connection setup
failures. (Added in 7.15.2)</p>

<p style="margin-left:11%;">CURLOPT_DNS_CACHE_TIMEOUT</p>

<p style="margin-left:22%;">Pass a long, this sets the
timeout in seconds. Name resolves will be kept in memory for
this number of seconds. Set to zero to completely disable
caching, or set to -1 to make the cached entries remain
forever. By default, libcurl caches this info for 60
seconds.</p>

<p style="margin-left:22%; margin-top: 1em">The name
resolve functions of various libc implementations
don&rsquo;t re-read name server information unless
explicitly told so (for example, by calling
<i>res_init(3)</i>). This may cause libcurl to keep using
the older server even if DHCP has updated the server info,
and this may look like a DNS cache issue to the casual
libcurl-app user.</p>


<p style="margin-left:11%;">CURLOPT_DNS_USE_GLOBAL_CACHE</p>

<p style="margin-left:22%;">Pass a long. If the value is 1,
it tells curl to use a global DNS cache that will survive
between easy handle creations and deletions. This is not
thread-safe and this will use a global variable.</p>


<p style="margin-left:22%; margin-top: 1em"><b>WARNING:</b>
this option is considered obsolete. Stop using it. Switch
over to using the share interface instead! See
<i>CURLOPT_SHARE</i> and <i>curl_share_init(3)</i>.</p>

<p style="margin-left:11%;">CURLOPT_BUFFERSIZE</p>

<p style="margin-left:22%;">Pass a long specifying your
preferred size (in bytes) for the receive buffer in libcurl.
The main point of this would be that the write callback gets
called more often and with smaller chunks. This is just
treated as a request, not an order. You cannot be guaranteed
to actually get the given size. (Added in 7.10)</p>

<p style="margin-left:22%; margin-top: 1em">This size is by
default set as big as possible (CURL_MAX_WRITE_SIZE), so it
only makes sense to use this option if you want it
smaller.</p>

<p style="margin-left:11%;">CURLOPT_PORT</p>

<p style="margin-left:22%;">Pass a long specifying what
remote port number to connect to, instead of the one
specified in the URL or the default port for the used
protocol.</p>

<p style="margin-left:11%;">CURLOPT_TCP_NODELAY</p>

<p style="margin-left:22%;">Pass a long specifying whether
the TCP_NODELAY option is to be set or cleared (1 = set, 0 =
clear). The option is cleared by default. This will have no
effect after the connection has been established.</p>

<p style="margin-left:22%; margin-top: 1em">Setting this
option will disable TCP&rsquo;s Nagle algorithm. The purpose
of this algorithm is to try to minimize the number of small
packets on the network (where &quot;small packets&quot;
means TCP segments less than the Maximum Segment Size (MSS)
for the network).</p>

<p style="margin-left:22%; margin-top: 1em">Maximizing the
amount of data sent per TCP segment is good because it
amortizes the overhead of the send. However, in some cases
(most notably telnet or rlogin) small segments may need to
be sent without delay. This is less efficient than sending
larger amounts of data at a time, and can contribute to
congestion on the network if overdone.</p>

<p style="margin-left:11%;">CURLOPT_ADDRESS_SCOPE</p>

<p style="margin-left:22%;">Pass a long specifying the
scope_id value to use when connecting to IPv6 link-local or
site-local addresses. (Added in 7.19.0)</p>

<p style="margin-left:11%;">CURLOPT_TCP_KEEPALIVE</p>

<p style="margin-left:22%;">Pass a long. If set to 1, TCP
keepalive probes will be sent. The delay and frequency of
these probes can be controlled by the
<i>CURLOPT_TCP_KEEPIDLE</i> and <i>CURLOPT_TCP_KEEPINTVL</i>
options, provided the operating system supports them. Set to
0 (default behavior) to disable keepalive probes (Added in
7.25.0).</p>

<p style="margin-left:11%;">CURLOPT_TCP_KEEPIDLE</p>

<p style="margin-left:22%;">Pass a long. Sets the delay, in
seconds, that the operating system will wait while the
connection is idle before sending keepalive probes. Not all
operating systems support this option. (Added in 7.25.0)</p>

<p style="margin-left:11%;">CURLOPT_TCP_KEEPINTVL</p>

<p style="margin-left:22%;">Pass a long. Sets the interval,
in seconds, that the operating system will wait between
sending keepalive probes. Not all operating systems support
this option. (Added in 7.25.0)</p>

<h2>NAMES and PASSWORDS OPTIONS (Authentication)
<a name="NAMES and PASSWORDS OPTIONS (Authentication)"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_NETRC</p>

<p style="margin-left:22%;">This parameter controls the
preference of libcurl between using user names and passwords
from your <i>~/.netrc</i> file, relative to user names and
passwords in the URL supplied with <i>CURLOPT_URL</i>.</p>

<p style="margin-left:22%; margin-top: 1em">libcurl uses a
user name (and supplied or prompted password) supplied with
<i>CURLOPT_USERPWD</i> in preference to any of the options
controlled by this parameter.</p>

<p style="margin-left:22%; margin-top: 1em">Pass a long,
set to one of the values described below. <br>
CURL_NETRC_OPTIONAL</p>

<p style="margin-left:32%;">The use of your <i>~/.netrc</i>
file is optional, and information in the URL is to be
preferred. The file will be scanned for the host and user
name (to find the password only) or for the host only, to
find the first user name and password after that
<i>machine</i>, which ever information is not specified in
the URL.</p>

<p style="margin-left:32%; margin-top: 1em">Undefined
values of the option will have this effect.</p>

<p style="margin-left:22%;">CURL_NETRC_IGNORED</p>

<p style="margin-left:32%;">The library will ignore the
file and use only the information in the URL.</p>

<p style="margin-left:32%; margin-top: 1em">This is the
default.</p>

<p style="margin-left:22%;">CURL_NETRC_REQUIRED</p>

<p style="margin-left:32%;">This value tells the library
that use of the file is required, to ignore the information
in the URL, and to search the file for the host only.</p>

<p style="margin-left:11%;">Only machine name, user name
and password are taken into account (init macros and similar
things aren&rsquo;t supported).</p>

<p style="margin-left:11%; margin-top: 1em">libcurl does
not verify that the file has the correct properties set (as
the standard Unix ftp client does). It should only be
readable by user. <br>
CURLOPT_NETRC_FILE</p>

<p style="margin-left:22%;">Pass a char * as parameter,
pointing to a zero terminated string containing the full
path name to the file you want libcurl to use as .netrc
file. If this option is omitted, and <i>CURLOPT_NETRC</i> is
set, libcurl will attempt to find a .netrc file in the
current user&rsquo;s home directory. (Added in 7.10.9)</p>

<p style="margin-left:11%;">CURLOPT_USERPWD</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be [user name]:[password] to use for the
connection. Use <i>CURLOPT_HTTPAUTH</i> to decide the
authentication method.</p>

<p style="margin-left:22%; margin-top: 1em">When using
NTLM, you can set the domain by prepending it to the user
name and separating the domain and name with a forward (/)
or backward slash (\). Like this:
&quot;domain/user:password&quot; or
&quot;domain\user:password&quot;. Some HTTP servers (on
Windows) support this style even for Basic
authentication.</p>

<p style="margin-left:22%; margin-top: 1em">When using HTTP
and <i>CURLOPT_FOLLOWLOCATION</i>, libcurl might perform
several requests to possibly different hosts. libcurl will
only send this user and password information to hosts using
the initial host name (unless
<i>CURLOPT_UNRESTRICTED_AUTH</i> is set), so if libcurl
follows locations to other hosts it will not send the user
and password to those. This is enforced to prevent
accidental information leakage.</p>

<p style="margin-left:11%;">CURLOPT_PROXYUSERPWD</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be [user name]:[password] to use for the
connection to the HTTP proxy. Use <i>CURLOPT_PROXYAUTH</i>
to decide the authentication method.</p>

<p style="margin-left:11%;">CURLOPT_USERNAME</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be pointing to the zero terminated user name to
use for the transfer.</p>


<p style="margin-left:22%; margin-top: 1em"><b>CURLOPT_USERNAME</b>
sets the user name to be used in protocol authentication.
You should not use this option together with the (older)
CURLOPT_USERPWD option.</p>

<p style="margin-left:22%; margin-top: 1em">In order to
specify the password to be used in conjunction with the user
name use the <i>CURLOPT_PASSWORD</i> option. (Added in
7.19.1)</p>

<p style="margin-left:11%;">CURLOPT_PASSWORD</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be pointing to the zero terminated password to
use for the transfer.</p>

<p style="margin-left:22%; margin-top: 1em">The
CURLOPT_PASSWORD option should be used in conjunction with
the <i>CURLOPT_USERNAME</i> option. (Added in 7.19.1)</p>

<p style="margin-left:11%;">CURLOPT_PROXYUSERNAME</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be pointing to the zero terminated user name to
use for the transfer while connecting to Proxy.</p>

<p style="margin-left:22%; margin-top: 1em">The
CURLOPT_PROXYUSERNAME option should be used in same way as
the <i>CURLOPT_PROXYUSERPWD</i> is used. In comparison to
<i>CURLOPT_PROXYUSERPWD</i> the CURLOPT_PROXYUSERNAME allows
the username to contain a colon, like in the following
example: &quot;sip:user@example.com&quot;. The
CURLOPT_PROXYUSERNAME option is an alternative way to set
the user name while connecting to Proxy. There is no meaning
to use it together with the <i>CURLOPT_PROXYUSERPWD</i>
option.</p>

<p style="margin-left:22%; margin-top: 1em">In order to
specify the password to be used in conjunction with the user
name use the <i>CURLOPT_PROXYPASSWORD</i> option. (Added in
7.19.1)</p>

<p style="margin-left:11%;">CURLOPT_PROXYPASSWORD</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be pointing to the zero terminated password to
use for the transfer while connecting to Proxy.</p>

<p style="margin-left:22%; margin-top: 1em">The
CURLOPT_PROXYPASSWORD option should be used in conjunction
with the <i>CURLOPT_PROXYUSERNAME</i> option. (Added in
7.19.1)</p>

<p style="margin-left:11%;">CURLOPT_HTTPAUTH</p>

<p style="margin-left:22%;">Pass a long as parameter, which
is set to a bitmask, to tell libcurl which authentication
method(s) you want it to use. The available bits are listed
below. If more than one bit is set, libcurl will first query
the site to see which authentication methods it supports and
then pick the best one you allow it to use. For some
methods, this will induce an extra network round-trip. Set
the actual name and password with the <i>CURLOPT_USERPWD</i>
option or with the <i>CURLOPT_USERNAME</i> and the
<i>CURLOPT_PASSWORD</i> options. (Added in 7.10.6) <br>
CURLAUTH_BASIC</p>

<p style="margin-left:32%;">HTTP Basic authentication. This
is the default choice, and the only method that is in
wide-spread use and supported virtually everywhere. This
sends the user name and password over the network in plain
text, easily captured by others.</p>

<p style="margin-left:22%;">CURLAUTH_DIGEST</p>

<p style="margin-left:32%;">HTTP Digest authentication.
Digest authentication is defined in RFC2617 and is a more
secure way to do authentication over public networks than
the regular old-fashioned Basic method.</p>

<p style="margin-left:22%;">CURLAUTH_DIGEST_IE</p>

<p style="margin-left:32%;">HTTP Digest authentication with
an IE flavor. Digest authentication is defined in RFC2617
and is a more secure way to do authentication over public
networks than the regular old-fashioned Basic method. The IE
flavor is simply that libcurl will use a special
&quot;quirk&quot; that IE is known to have used before
version 7 and that some servers require the client to use.
(This define was added in 7.19.3)</p>

<p style="margin-left:22%;">CURLAUTH_GSSNEGOTIATE</p>

<p style="margin-left:32%;">HTTP GSS-Negotiate
authentication. The GSS-Negotiate (also known as plain
&quot;Negotiate&quot;) method was designed by Microsoft and
is used in their web applications. It is primarily meant as
a support for Kerberos5 authentication but may also be used
along with other authentication methods. For more
information see IETF draft
draft-brezak-spnego-http-04.txt.</p>

<p style="margin-left:32%; margin-top: 1em">You need to
build libcurl with a suitable GSS-API library for this to
work.</p>

<p style="margin-left:22%;">CURLAUTH_NTLM</p>

<p style="margin-left:32%;">HTTP NTLM authentication. A
proprietary protocol invented and used by Microsoft. It uses
a challenge-response and hash concept similar to Digest, to
prevent the password from being eavesdropped.</p>

<p style="margin-left:32%; margin-top: 1em">You need to
build libcurl with either OpenSSL, GnuTLS or NSS support for
this option to work, or build libcurl on Windows.</p>

<p style="margin-left:22%;">CURLAUTH_NTLM_WB</p>

<p style="margin-left:32%;">NTLM delegating to winbind
helper. Authentication is performed by a separate binary
application that is executed when needed. The name of the
application is specified at compile time but is typically
/usr/bin/ntlm_auth (Added in 7.22.0)</p>

<p style="margin-left:32%; margin-top: 1em">Note that
libcurl will fork when necessary to run the winbind
application and kill it when complete, calling waitpid() to
await its exit when done. On POSIX operating systems,
killing the process will cause a SIGCHLD signal to be raised
(regardless of whether <i>CURLOPT_NOSIGNAL</i> is set),
which must be handled intelligently by the application. In
particular, the application must not unconditionally call
wait() in its SIGCHLD signal handler to avoid being subject
to a race condition. This behavior is subject to change in
future versions of libcurl.</p>

<p style="margin-left:22%;">CURLAUTH_ANY</p>

<p style="margin-left:32%;">This is a convenience macro
that sets all bits and thus makes libcurl pick any it finds
suitable. libcurl will automatically select the one it finds
most secure.</p>

<p style="margin-left:22%;">CURLAUTH_ANYSAFE</p>

<p style="margin-left:32%;">This is a convenience macro
that sets all bits except Basic and thus makes libcurl pick
any it finds suitable. libcurl will automatically select the
one it finds most secure.</p>

<p style="margin-left:22%;">CURLAUTH_ONLY</p>

<p style="margin-left:32%;">This is a meta symbol. Or this
value together with a single specific auth value to force
libcurl to probe for un-restricted auth and if not, only
that single auth algorithm is acceptable. (Added in
7.21.3)</p>

<p style="margin-left:11%;">CURLOPT_TLSAUTH_TYPE</p>

<p style="margin-left:22%;">Pass a long as parameter, which
is set to a bitmask, to tell libcurl which authentication
method(s) you want it to use for TLS authentication. <br>
CURLOPT_TLSAUTH_SRP</p>

<p style="margin-left:32%;">TLS-SRP authentication. Secure
Remote Password authentication for TLS is defined in RFC5054
and provides mutual authentication if both sides have a
shared secret. To use TLS-SRP, you must also set the
<i>CURLOPT_TLSAUTH_USERNAME</i> and
<i>CURLOPT_TLSAUTH_PASSWORD</i> options.</p>

<p style="margin-left:32%; margin-top: 1em">You need to
build libcurl with GnuTLS or OpenSSL with TLS-SRP support
for this to work. (Added in 7.21.4)</p>

<p style="margin-left:11%;">CURLOPT_TLSAUTH_USERNAME</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should point to the zero terminated username to use
for the TLS authentication method specified with the
<i>CURLOPT_TLSAUTH_TYPE</i> option. Requires that the
<i>CURLOPT_TLS_PASSWORD</i> option also be set. (Added in
7.21.4)</p>

<p style="margin-left:11%;">CURLOPT_TLSAUTH_PASSWORD</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should point to the zero terminated password to use
for the TLS authentication method specified with the
<i>CURLOPT_TLSAUTH_TYPE</i> option. Requires that the
<i>CURLOPT_TLS_USERNAME</i> option also be set. (Added in
7.21.4)</p>

<p style="margin-left:11%;">CURLOPT_PROXYAUTH</p>

<p style="margin-left:22%;">Pass a long as parameter, which
is set to a bitmask, to tell libcurl which authentication
method(s) you want it to use for your proxy authentication.
If more than one bit is set, libcurl will first query the
site to see what authentication methods it supports and then
pick the best one you allow it to use. For some methods,
this will induce an extra network round-trip. Set the actual
name and password with the <i>CURLOPT_PROXYUSERPWD</i>
option. The bitmask can be constructed by or&rsquo;ing
together the bits listed above for the
<i>CURLOPT_HTTPAUTH</i> option. As of this writing, only
Basic, Digest and NTLM work. (Added in 7.10.7)</p>

<h2>HTTP OPTIONS
<a name="HTTP OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_AUTOREFERER</p>

<p style="margin-left:22%;">Pass a parameter set to 1 to
enable this. When enabled, libcurl will automatically set
the Referer: field in requests where it follows a Location:
redirect.</p>

<p style="margin-left:11%;">CURLOPT_ACCEPT_ENCODING</p>

<p style="margin-left:22%;">Sets the contents of the
Accept-Encoding: header sent in a HTTP request, and enables
decoding of a response when a Content-Encoding: header is
received. Three encodings are supported: <i>identity</i>,
which does nothing, <i>deflate</i> which requests the server
to compress its response using the zlib algorithm, and
<i>gzip</i> which requests the gzip algorithm. If a
zero-length string is set, then an Accept-Encoding: header
containing all supported encodings is sent.</p>

<p style="margin-left:22%; margin-top: 1em">This is a
request, not an order; the server may or may not do it. This
option must be set (to any non-NULL value) or else any
unsolicited encoding done by the server is ignored. See the
special file lib/README.encoding for details.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was called CURLOPT_ENCODING before 7.21.6)</p>

<p style="margin-left:11%;">CURLOPT_TRANSFER_ENCODING</p>

<p style="margin-left:22%;">Adds a request for compressed
Transfer Encoding in the outgoing HTTP request. If the
server supports this and so desires, it can respond with the
HTTP response sent using a compressed Transfer-Encoding that
will be automatically uncompressed by libcurl on
reception.</p>


<p style="margin-left:22%; margin-top: 1em">Transfer-Encoding
differs slightly from the Content-Encoding you ask for with
<b>CURLOPT_ACCEPT_ENCODING</b> in that a Transfer-Encoding
is strictly meant to be for the transfer and thus MUST be
decoded before the data arrives in the client.
Traditionally, Transfer-Encoding has been much less used and
supported by both HTTP clients and HTTP servers.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.21.6)</p>

<p style="margin-left:11%;">CURLOPT_FOLLOWLOCATION</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to follow any Location: header that the server sends
as part of a HTTP header.</p>

<p style="margin-left:22%; margin-top: 1em">This means that
the library will re-send the same request on the new
location and follow new Location: headers all the way until
no more such headers are returned. <i>CURLOPT_MAXREDIRS</i>
can be used to limit the number of redirects libcurl will
follow.</p>

<p style="margin-left:22%; margin-top: 1em">Since 7.19.4,
libcurl can limit what protocols it will automatically
follow. The accepted protocols are set with
<i>CURLOPT_REDIR_PROTOCOLS</i> and it excludes the FILE
protocol by default.</p>

<p style="margin-left:11%;">CURLOPT_UNRESTRICTED_AUTH</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library it can continue to send authentication
(user+password) when following locations, even when hostname
changed. This option is meaningful only when setting
<i>CURLOPT_FOLLOWLOCATION</i>.</p>

<p style="margin-left:11%;">CURLOPT_MAXREDIRS</p>

<p style="margin-left:22%;">Pass a long. The set number
will be the redirection limit. If that many redirections
have been followed, the next redirect will cause an error
(<i>CURLE_TOO_MANY_REDIRECTS</i>). This option only makes
sense if the <i>CURLOPT_FOLLOWLOCATION</i> is used at the
same time. Added in 7.15.1: Setting the limit to 0 will make
libcurl refuse any redirect. Set it to -1 for an infinite
number of redirects (which is the default)</p>

<p style="margin-left:11%;">CURLOPT_POSTREDIR</p>

<p style="margin-left:22%;">Pass a bitmask to control how
libcurl acts on redirects after POSTs that get a 301, 302 or
303 response back. A parameter with bit 0 set (value
<b>CURL_REDIR_POST_301</b>) tells the library to respect
RFC2616/10.3.2 and not convert POST requests into GET
requests when following a 301 redirection. Setting bit 1
(value <b>CURL_REDIR_POST_302</b>) makes libcurl maintain
the request method after a 302 redirect whilst setting bit 2
(value <b>CURL_REDIR_POST_303</b>) makes libcurl maintain
the request method after a 303 redirect. The value
<b>CURL_REDIR_POST_ALL</b> is a convenience define that sets
all three bits.</p>

<p style="margin-left:22%; margin-top: 1em">The non-RFC
behaviour is ubiquitous in web browsers, so the library does
the conversion by default to maintain consistency. However,
a server may require a POST to remain a POST after such a
redirection. This option is meaningful only when setting
<i>CURLOPT_FOLLOWLOCATION</i>. (Added in 7.17.1) (This
option was known as CURLOPT_POST301 up to 7.19.0 as it only
supported the 301 then)</p>

<p style="margin-left:11%;">CURLOPT_PUT</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to use HTTP PUT to transfer data. The data should be
set with <i>CURLOPT_READDATA</i> and
<i>CURLOPT_INFILESIZE</i>.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
deprecated and starting with version 7.12.1 you should
instead use <i>CURLOPT_UPLOAD</i>.</p>

<p style="margin-left:11%;">CURLOPT_POST</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to do a regular HTTP post. This will also make the
library use a &quot;Content-Type:
application/x-www-form-urlencoded&quot; header. (This is by
far the most commonly used POST method).</p>

<p style="margin-left:22%; margin-top: 1em">Use one of
<i>CURLOPT_POSTFIELDS</i> or <i>CURLOPT_COPYPOSTFIELDS</i>
options to specify what data to post and
<i>CURLOPT_POSTFIELDSIZE</i> or
<i>CURLOPT_POSTFIELDSIZE_LARGE</i> to set the data size.</p>

<p style="margin-left:22%; margin-top: 1em">Optionally, you
can provide data to POST using the
<i>CURLOPT_READFUNCTION</i> and <i>CURLOPT_READDATA</i>
options but then you must make sure to not set
<i>CURLOPT_POSTFIELDS</i> to anything but NULL. When
providing data with a callback, you must transmit it using
chunked transfer-encoding or you must set the size of the
data with the <i>CURLOPT_POSTFIELDSIZE</i> or
<i>CURLOPT_POSTFIELDSIZE_LARGE</i> option. To enable chunked
encoding, you simply pass in the appropriate
Transfer-Encoding header, see the post-callback.c
example.</p>

<p style="margin-left:22%; margin-top: 1em">You can
override the default POST Content-Type: header by setting
your own with <i>CURLOPT_HTTPHEADER</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Using POST with
HTTP 1.1 implies the use of a &quot;Expect:
100-continue&quot; header. You can disable this header with
<i>CURLOPT_HTTPHEADER</i> as usual.</p>

<p style="margin-left:22%; margin-top: 1em">If you use POST
to a HTTP 1.1 server, you can send data without knowing the
size before starting the POST if you use chunked encoding.
You enable this by adding a header like
&quot;Transfer-Encoding: chunked&quot; with
<i>CURLOPT_HTTPHEADER</i>. With HTTP 1.0 or without chunked
transfer, you must specify the size in the request.</p>

<p style="margin-left:22%; margin-top: 1em">When setting
<i>CURLOPT_POST</i> to 1, it will automatically set
<i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).</p>

<p style="margin-left:22%; margin-top: 1em">If you issue a
POST request and then want to make a HEAD or GET using the
same re-used handle, you must explicitly set the new request
type using <i>CURLOPT_NOBODY</i> or <i>CURLOPT_HTTPGET</i>
or similar.</p>

<p style="margin-left:11%;">CURLOPT_POSTFIELDS</p>

<p style="margin-left:22%;">Pass a void * as parameter,
which should be the full data to post in a HTTP POST
operation. You must make sure that the data is formatted the
way you want the server to receive it. libcurl will not
convert or encode it for you. Most web servers will assume
this data to be url-encoded.</p>

<p style="margin-left:22%; margin-top: 1em">The pointed
data are NOT copied by the library: as a consequence, they
must be preserved by the calling application until the
transfer finishes.</p>

<p style="margin-left:22%; margin-top: 1em">This POST is a
normal application/x-www-form-urlencoded kind (and libcurl
will set that Content-Type by default when this option is
used), which is the most commonly used one by HTML forms.
See also the <i>CURLOPT_POST</i>. Using
<i>CURLOPT_POSTFIELDS</i> implies <i>CURLOPT_POST</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If you want to
do a zero-byte POST, you need to set
<i>CURLOPT_POSTFIELDSIZE</i> explicitly to zero, as simply
setting <i>CURLOPT_POSTFIELDS</i> to NULL or &quot;&quot;
just effectively disables the sending of the specified
string. libcurl will instead assume that you&rsquo;ll send
the POST data using the read callback!</p>

<p style="margin-left:22%; margin-top: 1em">Using POST with
HTTP 1.1 implies the use of a &quot;Expect:
100-continue&quot; header. You can disable this header with
<i>CURLOPT_HTTPHEADER</i> as usual.</p>

<p style="margin-left:22%; margin-top: 1em">To make
multipart/formdata posts (aka RFC2388-posts), check out the
<i>CURLOPT_HTTPPOST</i> option.</p>

<p style="margin-left:11%;">CURLOPT_POSTFIELDSIZE</p>

<p style="margin-left:22%;">If you want to post data to the
server without letting libcurl do a strlen() to measure the
data size, this option must be used. When this option is
used you can post fully binary data, which otherwise is
likely to fail. If this size is set to -1, the library will
use strlen() to get the size.</p>


<p style="margin-left:11%;">CURLOPT_POSTFIELDSIZE_LARGE</p>

<p style="margin-left:22%;">Pass a curl_off_t as parameter.
Use this to set the size of the <i>CURLOPT_POSTFIELDS</i>
data to prevent libcurl from doing strlen() on the data to
figure out the size. This is the large file version of the
<i>CURLOPT_POSTFIELDSIZE</i> option. (Added in 7.11.1)</p>

<p style="margin-left:11%;">CURLOPT_COPYPOSTFIELDS</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should be the full data to post in a HTTP POST
operation. It behaves as the <i>CURLOPT_POSTFIELDS</i>
option, but the original data are copied by the library,
allowing the application to overwrite the original data
after setting this option.</p>

<p style="margin-left:22%; margin-top: 1em">Because data
are copied, care must be taken when using this option in
conjunction with <i>CURLOPT_POSTFIELDSIZE</i> or
<i>CURLOPT_POSTFIELDSIZE_LARGE</i>: If the size has not been
set prior to <i>CURLOPT_COPYPOSTFIELDS</i>, the data are
assumed to be a NUL-terminated string; else the stored size
informs the library about the data byte count to copy. In
any case, the size must not be changed after
<i>CURLOPT_COPYPOSTFIELDS</i>, unless another
<i>CURLOPT_POSTFIELDS</i> or <i>CURLOPT_COPYPOSTFIELDS</i>
option is issued. (Added in 7.17.1)</p>

<p style="margin-left:11%;">CURLOPT_HTTPPOST</p>

<p style="margin-left:22%;">Tells libcurl you want a
multipart/formdata HTTP POST to be made and you instruct
what data to pass on to the server. Pass a pointer to a
linked list of curl_httppost structs as parameter. The
easiest way to create such a list, is to use
<i>curl_formadd(3)</i> as documented. The data in this list
must remain intact until you close this curl handle again
with <i>curl_easy_cleanup(3)</i>.</p>

<p style="margin-left:22%; margin-top: 1em">Using POST with
HTTP 1.1 implies the use of a &quot;Expect:
100-continue&quot; header. You can disable this header with
<i>CURLOPT_HTTPHEADER</i> as usual.</p>

<p style="margin-left:22%; margin-top: 1em">When setting
<i>CURLOPT_HTTPPOST</i>, it will automatically set
<i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).</p>

<p style="margin-left:11%;">CURLOPT_REFERER</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used to set the
Referer: header in the http request sent to the remote
server. This can be used to fool servers or scripts. You can
also set any custom header with
<i>CURLOPT_HTTPHEADER</i>.</p>

<p style="margin-left:11%;">CURLOPT_USERAGENT</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used to set the
User-Agent: header in the http request sent to the remote
server. This can be used to fool servers or scripts. You can
also set any custom header with
<i>CURLOPT_HTTPHEADER</i>.</p>

<p style="margin-left:11%;">CURLOPT_HTTPHEADER</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of HTTP headers to pass to the server in your HTTP request.
The linked list should be a fully valid list of <b>struct
curl_slist</b> structs properly filled in. Use
<i>curl_slist_append(3)</i> to create the list and
<i>curl_slist_free_all(3)</i> to clean up an entire list. If
you add a header that is otherwise generated and used by
libcurl internally, your added one will be used instead. If
you add a header with no content as in &rsquo;Accept:&rsquo;
(no data on the right side of the colon), the internally
used header will get disabled. Thus, using this option you
can add new headers, replace internal headers and remove
internal headers. To add a header with no content, make the
content be two quotes: &quot;&quot;. The headers included in
the linked list must not be CRLF-terminated, because curl
adds CRLF after each header item. Failure to comply with
this will result in strange bugs because the server will
most likely ignore part of the headers you specified.</p>

<p style="margin-left:22%; margin-top: 1em">The first line
in a request (containing the method, usually a GET or POST)
is not a header and cannot be replaced using this option.
Only the lines following the request-line are headers.
Adding this method line in this list of headers will only
cause your request to send an invalid header.</p>

<p style="margin-left:22%; margin-top: 1em">Pass a NULL to
this to reset back to no custom headers.</p>

<p style="margin-left:22%; margin-top: 1em">The most
commonly replaced headers have &quot;shortcuts&quot; in the
options <i>CURLOPT_COOKIE</i>, <i>CURLOPT_USERAGENT</i> and
<i>CURLOPT_REFERER</i>.</p>

<p style="margin-left:11%;">CURLOPT_HTTP200ALIASES</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of aliases to be treated as valid HTTP 200 responses. Some
servers respond with a custom header response line. For
example, IceCast servers respond with &quot;ICY 200
OK&quot;. By including this string in your list of aliases,
the response will be treated as a valid HTTP header line
such as &quot;HTTP/1.0 200 OK&quot;. (Added in 7.10.3)</p>

<p style="margin-left:22%; margin-top: 1em">The linked list
should be a fully valid list of struct curl_slist structs,
and be properly filled in. Use <i>curl_slist_append(3)</i>
to create the list and <i>curl_slist_free_all(3)</i> to
clean up an entire list.</p>

<p style="margin-left:22%; margin-top: 1em">The alias
itself is not parsed for any version strings. Before libcurl
7.16.3, Libcurl used the value set by option
<i>CURLOPT_HTTP_VERSION</i>, but starting with 7.16.3 the
protocol is assumed to match HTTP 1.0 when an alias
matched.</p>

<p style="margin-left:11%;">CURLOPT_COOKIE</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used to set a
cookie in the http request. The format of the string should
be NAME=CONTENTS, where NAME is the cookie name and CONTENTS
is what the cookie should contain.</p>

<p style="margin-left:22%; margin-top: 1em">If you need to
set multiple cookies, you need to set them all using a
single option and thus you need to concatenate them all in
one single string. Set multiple cookies in one string like
this: &quot;name1=content1; name2=content2;&quot; etc.</p>

<p style="margin-left:22%; margin-top: 1em">This option
sets the cookie header explicitly in the outgoing
request(s). If multiple requests are done due to
authentication, followed redirections or similar, they will
all get this cookie passed on.</p>

<p style="margin-left:22%; margin-top: 1em">Using this
option multiple times will only make the latest string
override the previous ones.</p>

<p style="margin-left:11%;">CURLOPT_COOKIEFILE</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It should contain the name
of your file holding cookie data to read. The cookie data
may be in Netscape / Mozilla cookie data format or just
regular HTTP-style headers dumped to a file.</p>

<p style="margin-left:22%; margin-top: 1em">Given an empty
or non-existing file or by passing the empty string
(&quot;&quot;), this option will enable cookies for this
curl handle, making it understand and parse received cookies
and then use matching cookies in future requests.</p>

<p style="margin-left:22%; margin-top: 1em">If you use this
option multiple times, you just add more files to read.
Subsequent files will add more cookies.</p>

<p style="margin-left:11%;">CURLOPT_COOKIEJAR</p>

<p style="margin-left:22%;">Pass a file name as char *,
zero terminated. This will make libcurl write all internally
known cookies to the specified file when
<i>curl_easy_cleanup(3)</i> is called. If no cookies are
known, no file will be created. Specify &quot;-&quot; to
instead have the cookies written to stdout. Using this
option also enables cookies for this session, so if you for
example follow a location it will make matching cookies get
sent accordingly.</p>

<p style="margin-left:22%; margin-top: 1em">If the cookie
jar file can&rsquo;t be created or written to (when the
<i>curl_easy_cleanup(3)</i> is called), libcurl will not and
cannot report an error for this. Using
<i>CURLOPT_VERBOSE</i> or <i>CURLOPT_DEBUGFUNCTION</i> will
get a warning to display, but that is the only visible
feedback you get about this possibly lethal situation.</p>

<p style="margin-left:11%;">CURLOPT_COOKIESESSION</p>

<p style="margin-left:22%;">Pass a long set to 1 to mark
this as a new cookie &quot;session&quot;. It will force
libcurl to ignore all cookies it is about to load that are
&quot;session cookies&quot; from the previous session. By
default, libcurl always stores and loads all cookies,
independent if they are session cookies or not. Session
cookies are cookies without expiry date and they are meant
to be alive and existing for this &quot;session&quot;
only.</p>

<p style="margin-left:11%;">CURLOPT_COOKIELIST</p>

<p style="margin-left:22%;">Pass a char * to a cookie
string. Cookie can be either in Netscape / Mozilla format or
just regular HTTP-style header (Set-Cookie: ...) format. If
cURL cookie engine was not enabled it will enable its cookie
engine. Passing a magic string &quot;ALL&quot; will erase
all cookies known by cURL. (Added in 7.14.1) Passing the
special string &quot;SESS&quot; will only erase all session
cookies known by cURL. (Added in 7.15.4) Passing the special
string &quot;FLUSH&quot; will write all cookies known by
cURL to the file specified by <i>CURLOPT_COOKIEJAR</i>.
(Added in 7.17.1)</p>

<p style="margin-left:11%;">CURLOPT_HTTPGET</p>

<p style="margin-left:22%;">Pass a long. If the long is 1,
this forces the HTTP request to get back to GET. Usable if a
POST, HEAD, PUT, or a custom request has been used
previously using the same curl handle.</p>

<p style="margin-left:22%; margin-top: 1em">When setting
<i>CURLOPT_HTTPGET</i> to 1, it will automatically set
<i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).</p>

<p style="margin-left:11%;">CURLOPT_HTTP_VERSION</p>

<p style="margin-left:22%;">Pass a long, set to one of the
values described below. They force libcurl to use the
specific HTTP versions. This is not sensible to do unless
you have a good reason. <br>
CURL_HTTP_VERSION_NONE</p>

<p style="margin-left:32%;">We don&rsquo;t care about what
version the library uses. libcurl will use whatever it
thinks fit.</p>

<p style="margin-left:22%;">CURL_HTTP_VERSION_1_0</p>

<p style="margin-left:32%;">Enforce HTTP 1.0 requests.</p>

<p style="margin-left:22%;">CURL_HTTP_VERSION_1_1</p>

<p style="margin-left:32%;">Enforce HTTP 1.1 requests.</p>


<p style="margin-left:11%;">CURLOPT_IGNORE_CONTENT_LENGTH</p>

<p style="margin-left:22%;">Ignore the Content-Length
header. This is useful for Apache 1.x (and similar servers)
which will report incorrect content length for files over 2
gigabytes. If this option is used, curl will not be able to
accurately report progress, and will simply stop the
download when the server ends the connection. (added in
7.14.1)</p>


<p style="margin-left:11%;">CURLOPT_HTTP_CONTENT_DECODING</p>

<p style="margin-left:22%;">Pass a long to tell libcurl how
to act on content decoding. If set to zero, content decoding
will be disabled. If set to 1 it is enabled. Libcurl has no
default content decoding but requires you to use
<i>CURLOPT_ENCODING</i> for that. (added in 7.16.2)</p>


<p style="margin-left:11%;">CURLOPT_HTTP_TRANSFER_DECODING</p>

<p style="margin-left:22%;">Pass a long to tell libcurl how
to act on transfer decoding. If set to zero, transfer
decoding will be disabled, if set to 1 it is enabled
(default). libcurl does chunked transfer decoding by default
unless this option is set to zero. (added in 7.16.2)</p>

<h2>SMTP OPTIONS
<a name="SMTP OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_MAIL_FROM</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. This should be used to
specify the sender&rsquo;s email address when sending SMTP
mail with libcurl.</p>

<p style="margin-left:22%; margin-top: 1em">An originator
email address should be specified with angled brackets
(&lt;&gt;) around it, which if not specified, will be added
by libcurl from version 7.21.4 onwards. Failing to provide
such brackets may cause the server to reject the email.</p>

<p style="margin-left:22%; margin-top: 1em">If this
parameter is not specified then an empty address will be
sent to the mail server which may or may not cause the email
to be rejected.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_MAIL_RCPT</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of recipients to pass to the server in your SMTP mail
request. The linked list should be a fully valid list of
<b>struct curl_slist</b> structs properly filled in. Use
<i>curl_slist_append(3)</i> to create the list and
<i>curl_slist_free_all(3)</i> to clean up an entire
list.</p>

<p style="margin-left:22%; margin-top: 1em">Each recipient
should be specified within a pair of angled brackets
(&lt;&gt;), however, should you not use an angled bracket as
the first character libcurl will assume you provided a
single email address and enclose that address within
brackets for you.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_MAIL_AUTH</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. This will be used to specify
the authentication address (identity) of a submitted message
that is being relayed to another server.</p>

<p style="margin-left:22%; margin-top: 1em">This optional
parameter allows co-operating agents in a trusted
environment to communicate the authentication of individual
messages and should only be used by the application program,
using libcurl, if the application is itself a mail server
acting in such an environment. If the application is
operating as such and the AUTH address is not known or is
invalid, then an empty string should be used for this
parameter.</p>

<p style="margin-left:22%; margin-top: 1em">Unlike
CURLOPT_MAIL_FROM and CURLOPT_MAIL_RCPT, the address should
not be specified within a pair of angled brackets
(&lt;&gt;). However, if an empty string is used then a pair
of brackets will be sent by libcurl as required by
RFC2554.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.25.0)</p>

<h2>TFTP OPTIONS
<a name="TFTP OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_TFTP_BLKSIZE</p>

<p style="margin-left:22%;">Specify block size to use for
TFTP data transmission. Valid range as per RFC2348 is
8-65464 bytes. The default of 512 bytes will be used if this
option is not specified. The specified block size will only
be used pending support by the remote server. If the server
does not return an option acknowledgement or returns an
option acknowledgement with no blksize, the default of 512
bytes will be used. (added in 7.19.4)</p>

<h2>FTP OPTIONS
<a name="FTP OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_FTPPORT</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used to get the
IP address to use for the FTP PORT instruction. The PORT
instruction tells the remote server to connect to our
specified IP address. The string may be a plain IP address,
a host name, a network interface name (under Unix) or just a
&rsquo;-&rsquo; symbol to let the library use your
system&rsquo;s default IP address. Default FTP operations
are passive, and thus won&rsquo;t use PORT.</p>

<p style="margin-left:22%; margin-top: 1em">The address can
be followed by a &rsquo;:&rsquo; to specify a port,
optionally followed by a &rsquo;-&rsquo; to specify a port
range. If the port specified is 0, the operating system will
pick a free port. If a range is provided and all ports in
the range are not available, libcurl will report
CURLE_FTP_PORT_FAILED for the handle. Invalid port/range
settings are ignored. IPv6 addresses followed by a port or
portrange have to be in brackets. IPv6 addresses without
port/range specifier can be in brackets. (added in
7.19.5)</p>

<p style="margin-left:22%; margin-top: 1em">Examples with
specified ports:</p>

<p style="margin-left:22%; margin-top: 1em">eth0:0 <br>
192.168.1.2:32000-33000 <br>
curl.se:32123 <br>
[::1]:1234-4567</p>

<p style="margin-left:22%; margin-top: 1em">You disable
PORT again and go back to using the passive version by
setting this option to NULL.</p>

<p style="margin-left:11%;">CURLOPT_QUOTE</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of FTP or SFTP commands to pass to the server prior to your
FTP request. This will be done before any other commands are
issued (even before the CWD command for FTP). The linked
list should be a fully valid list of &rsquo;struct
curl_slist&rsquo; structs properly filled in with text
strings. Use <i>curl_slist_append(3)</i> to append strings
(commands) to the list, and clear the entire list afterwards
with <i>curl_slist_free_all(3)</i>. Disable this operation
again by setting a NULL to this option. When speaking to a
FTP (or SFTP since 7.24.0) server, prefix the command with
an asterisk (*) to make libcurl continue even if the command
fails as by default libcurl will stop at first failure.</p>

<p style="margin-left:22%; margin-top: 1em">The set of
valid FTP commands depends on the server (see RFC959 for a
list of mandatory commands).</p>

<p style="margin-left:22%; margin-top: 1em">The valid SFTP
commands are: chgrp, chmod, chown, ln, mkdir, pwd, rename,
rm, rmdir, symlink (see <b>curl</b>(1)) (SFTP support added
in 7.16.3)</p>

<p style="margin-left:11%;">CURLOPT_POSTQUOTE</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of FTP or SFTP commands to pass to the server after your FTP
transfer request. The commands will only be run if no error
occurred. The linked list should be a fully valid list of
struct curl_slist structs properly filled in as described
for <i>CURLOPT_QUOTE</i>. Disable this operation again by
setting a NULL to this option.</p>

<p style="margin-left:11%;">CURLOPT_PREQUOTE</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of FTP commands to pass to the server after the transfer
type is set. The linked list should be a fully valid list of
struct curl_slist structs properly filled in as described
for <i>CURLOPT_QUOTE</i>. Disable this operation again by
setting a NULL to this option. Before version 7.16.0, if you
also set <i>CURLOPT_NOBODY</i> to 1, this option
didn&rsquo;t work.</p>

<p style="margin-left:11%;">CURLOPT_DIRLISTONLY</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to just list the names of files in a directory,
instead of doing a full directory listing that would include
file sizes, dates etc. This works for FTP and SFTP URLs.</p>

<p style="margin-left:22%; margin-top: 1em">This causes an
FTP NLST command to be sent on an FTP server. Beware that
some FTP servers list only files in their response to NLST;
they might not include subdirectories and symbolic
links.</p>

<p style="margin-left:22%; margin-top: 1em">Setting this
option to 1 also implies a directory listing even if the URL
doesn&rsquo;t end with a slash, which otherwise is
necessary.</p>

<p style="margin-left:22%; margin-top: 1em">Do NOT use this
option if you also use <i>CURLOPT_WILDCARDMATCH</i> as it
will effectively break that feature then.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was known as CURLOPT_FTPLISTONLY up to 7.16.4)</p>

<p style="margin-left:11%;">CURLOPT_APPEND</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to append to the remote file instead of overwrite
it. This is only useful when uploading to an FTP site.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was known as CURLOPT_FTPAPPEND up to 7.16.4)</p>

<p style="margin-left:11%;">CURLOPT_FTP_USE_EPRT</p>

<p style="margin-left:22%;">Pass a long. If the value is 1,
it tells curl to use the EPRT (and LPRT) command when doing
active FTP downloads (which is enabled by
<i>CURLOPT_FTPPORT</i>). Using EPRT means that it will first
attempt to use EPRT and then LPRT before using PORT, but if
you pass zero to this option, it will not try using EPRT or
LPRT, only plain PORT. (Added in 7.10.5)</p>

<p style="margin-left:22%; margin-top: 1em">If the server
is an IPv6 host, this option will have no effect as of
7.12.3.</p>

<p style="margin-left:11%;">CURLOPT_FTP_USE_EPSV</p>

<p style="margin-left:22%;">Pass a long. If the value is 1,
it tells curl to use the EPSV command when doing passive FTP
downloads (which it always does by default). Using EPSV
means that it will first attempt to use EPSV before using
PASV, but if you pass zero to this option, it will not try
using EPSV, only plain PASV.</p>

<p style="margin-left:22%; margin-top: 1em">If the server
is an IPv6 host, this option will have no effect as of
7.12.3.</p>

<p style="margin-left:11%;">CURLOPT_FTP_USE_PRET</p>

<p style="margin-left:22%;">Pass a long. If the value is 1,
it tells curl to send a PRET command before PASV (and EPSV).
Certain FTP servers, mainly drftpd, require this
non-standard command for directory listings as well as up
and downloads in PASV mode. Has no effect when using the
active FTP transfers mode. (Added in 7.20.0)</p>


<p style="margin-left:11%;">CURLOPT_FTP_CREATE_MISSING_DIRS</p>

<p style="margin-left:22%;">Pass a long. If the value is 1,
curl will attempt to create any remote directory that it
fails to CWD into. CWD is the command that changes working
directory. (Added in 7.10.7)</p>

<p style="margin-left:22%; margin-top: 1em">This setting
also applies to SFTP-connections. curl will attempt to
create the remote directory if it can&rsquo;t obtain a
handle to the target-location. The creation will fail if a
file of the same name as the directory to create already
exists or lack of permissions prevents creation. (Added in
7.16.3)</p>

<p style="margin-left:22%; margin-top: 1em">Starting with
7.19.4, you can also set this value to 2, which will make
libcurl retry the CWD command again if the subsequent MKD
command fails. This is especially useful if you&rsquo;re
doing many simultaneous connections against the same server
and they all have this option enabled, as then CWD may first
fail but then another connection does MKD before this
connection and thus MKD fails but trying CWD works! 7.19.4
also introduced the <i>CURLFTP_CREATE_DIR</i> and
<i>CURLFTP_CREATE_DIR_RETRY</i> enum names for these
arguments.</p>

<p style="margin-left:22%; margin-top: 1em">Before version
7.19.4, libcurl will simply ignore arguments set to 2 and
act as if 1 was selected.</p>


<p style="margin-left:11%;">CURLOPT_FTP_RESPONSE_TIMEOUT</p>

<p style="margin-left:22%;">Pass a long. Causes curl to set
a timeout period (in seconds) on the amount of time that the
server is allowed to take in order to generate a response
message for a command before the session is considered hung.
While curl is waiting for a response, this value overrides
<i>CURLOPT_TIMEOUT</i>. It is recommended that if used in
conjunction with <i>CURLOPT_TIMEOUT</i>, you set
<i>CURLOPT_FTP_RESPONSE_TIMEOUT</i> to a value smaller than
<i>CURLOPT_TIMEOUT</i>. (Added in 7.10.8)</p>


<p style="margin-left:11%;">CURLOPT_FTP_ALTERNATIVE_TO_USER</p>

<p style="margin-left:22%;">Pass a char * as parameter,
pointing to a string which will be used to authenticate if
the usual FTP &quot;USER user&quot; and &quot;PASS
password&quot; negotiation fails. This is currently only
known to be required when connecting to Tumbleweed&rsquo;s
Secure Transport FTPS server using client certificates for
authentication. (Added in 7.15.5)</p>

<p style="margin-left:11%;">CURLOPT_FTP_SKIP_PASV_IP</p>

<p style="margin-left:22%;">Pass a long. If set to 1, it
instructs libcurl to not use the IP address the server
suggests in its 227-response to libcurl&rsquo;s PASV command
when libcurl connects the data connection. Instead libcurl
will re-use the same IP address it already uses for the
control connection. But it will use the port number from the
227-response. (Added in 7.14.2)</p>

<p style="margin-left:22%; margin-top: 1em">This option has
no effect if PORT, EPRT or EPSV is used instead of PASV.</p>

<p style="margin-left:11%;">CURLOPT_FTPSSLAUTH</p>

<p style="margin-left:22%;">Pass a long using one of the
values from below, to alter how libcurl issues &quot;AUTH
TLS&quot; or &quot;AUTH SSL&quot; when FTP over SSL is
activated (see <i>CURLOPT_USE_SSL</i>). (Added in 7.12.2)
<br>
CURLFTPAUTH_DEFAULT</p>

<p style="margin-left:32%;">Allow libcurl to decide.</p>

<p style="margin-left:22%;">CURLFTPAUTH_SSL</p>

<p style="margin-left:32%;">Try &quot;AUTH SSL&quot; first,
and only if that fails try &quot;AUTH TLS&quot;.</p>

<p style="margin-left:22%;">CURLFTPAUTH_TLS</p>

<p style="margin-left:32%;">Try &quot;AUTH TLS&quot; first,
and only if that fails try &quot;AUTH SSL&quot;.</p>

<p style="margin-left:11%;">CURLOPT_FTP_SSL_CCC</p>

<p style="margin-left:22%;">If enabled, this option makes
libcurl use CCC (Clear Command Channel). It shuts down the
SSL/TLS layer after authenticating. The rest of the control
channel communication will be unencrypted. This allows NAT
routers to follow the FTP transaction. Pass a long using one
of the values below. (Added in 7.16.1) <br>
CURLFTPSSL_CCC_NONE</p>

<p style="margin-left:32%;">Don&rsquo;t attempt to use
CCC.</p>

<p style="margin-left:22%;">CURLFTPSSL_CCC_PASSIVE</p>

<p style="margin-left:32%;">Do not initiate the shutdown,
but wait for the server to do it. Do not send a reply.</p>

<p style="margin-left:22%;">CURLFTPSSL_CCC_ACTIVE</p>

<p style="margin-left:32%;">Initiate the shutdown and wait
for a reply.</p>

<p style="margin-left:11%;">CURLOPT_FTP_ACCOUNT</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string (or NULL to disable). When an FTP server
asks for &quot;account data&quot; after user name and
password has been provided, this data is sent off using the
ACCT command. (Added in 7.13.0)</p>

<p style="margin-left:11%;">CURLOPT_FTP_FILEMETHOD</p>

<p style="margin-left:22%;">Pass a long that should have
one of the following values. This option controls what
method libcurl should use to reach a file on a FTP(S)
server. The argument should be one of the following
alternatives: <br>
CURLFTPMETHOD_MULTICWD</p>

<p style="margin-left:32%;">libcurl does a single CWD
operation for each path part in the given URL. For deep
hierarchies this means many commands. This is how RFC1738
says it should be done. This is the default but the slowest
behavior.</p>

<p style="margin-left:22%;">CURLFTPMETHOD_NOCWD</p>

<p style="margin-left:32%;">libcurl does no CWD at all.
libcurl will do SIZE, RETR, STOR etc and give a full path to
the server for all these commands. This is the fastest
behavior.</p>

<p style="margin-left:22%;">CURLFTPMETHOD_SINGLECWD</p>

<p style="margin-left:32%;">libcurl does one CWD with the
full target directory and then operates on the file
&quot;normally&quot; (like in the multicwd case). This is
somewhat more standards compliant than &rsquo;nocwd&rsquo;
but without the full penalty of &rsquo;multicwd&rsquo;.</p>

<p style="margin-left:11%;">(Added in 7.15.1)</p>

<h2>RTSP OPTIONS
<a name="RTSP OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_RTSP_REQUEST</p>

<p style="margin-left:22%;">Tell libcurl what kind of RTSP
request to make. Pass one of the following RTSP enum values.
Unless noted otherwise, commands require the Session ID to
be initialized. (Added in 7.20.0) <br>
CURL_RTSPREQ_OPTIONS</p>

<p style="margin-left:32%;">Used to retrieve the available
methods of the server. The application is responsible for
parsing and obeying the response. <b>(The session ID is not
needed for this method.)</b> (Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_DESCRIBE</p>

<p style="margin-left:32%;">Used to get the low level
description of a stream. The application should note what
formats it understands in the <i>&rsquo;Accept:&rsquo;</i>
header. Unless set manually, libcurl will automatically fill
in <i>&rsquo;Accept: application/sdp&rsquo;</i>.
Time-condition headers will be added to Describe requests if
the <i>CURLOPT_TIMECONDITION</i> option is active. <b>(The
session ID is not needed for this method)</b> (Added in
7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_ANNOUNCE</p>

<p style="margin-left:32%;">When sent by a client, this
method changes the description of the session. For example,
if a client is using the server to record a meeting, the
client can use Announce to inform the server of all the
meta-information about the session. ANNOUNCE acts like a
HTTP PUT or POST just like <i>CURL_RTSPREQ_SET_PARAMETER</i>
(Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_SETUP</p>

<p style="margin-left:32%;">Setup is used to initialize the
transport layer for the session. The application must set
the desired Transport options for a session by using the
<i>CURLOPT_RTSP_TRANSPORT</i> option prior to calling setup.
If no session ID is currently set with
<i>CURLOPT_RTSP_SESSION_ID</i>, libcurl will extract and use
the session ID in the response to this request. <b>(The
session ID is not needed for this method).</b> (Added in
7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_PLAY</p>

<p style="margin-left:32%;">Send a Play command to the
server. Use the <i>CURLOPT_RANGE</i> option to modify the
playback time (e.g. &rsquo;npt=10-15&rsquo;). (Added in
7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_PAUSE</p>

<p style="margin-left:32%;">Send a Pause command to the
server. Use the <i>CURLOPT_RANGE</i> option with a single
value to indicate when the stream should be halted. (e.g.
npt=&rsquo;25&rsquo;) (Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_TEARDOWN</p>

<p style="margin-left:32%;">This command terminates an RTSP
session. Simply closing a connection does not terminate the
RTSP session since it is valid to control an RTSP session
over different connections. (Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_GET_PARAMETER</p>

<p style="margin-left:32%;">Retrieve a parameter from the
server. By default, libcurl will automatically include a
<i>Content-Type: text/parameters</i> header on all non-empty
requests unless a custom one is set. GET_PARAMETER acts just
like a HTTP PUT or POST (see
<i>CURL_RTSPREQ_SET_PARAMETER</i>). Applications wishing to
send a heartbeat message (e.g. in the presence of a
server-specified timeout) should send use an empty
GET_PARAMETER request. (Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_SET_PARAMETER</p>

<p style="margin-left:32%;">Set a parameter on the server.
By default, libcurl will automatically include a
<i>Content-Type: text/parameters</i> header unless a custom
one is set. The interaction with SET_PARAMTER is much like a
HTTP PUT or POST. An application may either use
<i>CURLOPT_UPLOAD</i> with <i>CURLOPT_READDATA</i> like a
HTTP PUT, or it may use <i>CURLOPT_POSTFIELDS</i> like a
HTTP POST. No chunked transfers are allowed, so the
application must set the <i>CURLOPT_INFILESIZE</i> in the
former and <i>CURLOPT_POSTFIELDSIZE</i> in the latter. Also,
there is no use of multi-part POSTs within RTSP. (Added in
7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_RECORD</p>

<p style="margin-left:32%;">Used to tell the server to
record a session. Use the <i>CURLOPT_RANGE</i> option to
modify the record time. (Added in 7.20.0)</p>

<p style="margin-left:22%;">CURL_RTSPREQ_RECEIVE</p>

<p style="margin-left:32%;">This is a special request
because it does not send any data to the server. The
application may call this function in order to receive
interleaved RTP data. It will return after processing one
read buffer of data in order to give the application a
chance to run. (Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_SESSION_ID</p>

<p style="margin-left:22%;">Pass a char * as a parameter to
set the value of the current RTSP Session ID for the handle.
Useful for resuming an in-progress session. Once this value
is set to any non-NULL value, libcurl will return
<i>CURLE_RTSP_SESSION_ERROR</i> if ID received from the
server does not match. If unset (or set to NULL), libcurl
will automatically set the ID the first time the server sets
it in a response. (Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_STREAM_URI</p>

<p style="margin-left:22%;">Set the stream URI to operate
on by passing a char * . For example, a single session may
be controlling <i>rtsp://foo/twister/audio</i> and
<i>rtsp://foo/twister/video</i> and the application can
switch to the appropriate stream using this option. If
unset, libcurl will default to operating on generic server
options by passing &rsquo;*&rsquo; in the place of the RTSP
Stream URI. This option is distinct from <i>CURLOPT_URL</i>.
When working with RTSP, the <i>CURLOPT_STREAM_URI</i>
indicates what URL to send to the server in the request
header while the <i>CURLOPT_URL</i> indicates where to make
the connection to. (e.g. the <i>CURLOPT_URL</i> for the
above examples might be set to <i>rtsp://foo/twister</i>
(Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_TRANSPORT</p>

<p style="margin-left:22%;">Pass a char * to tell libcurl
what to pass for the Transport: header for this RTSP
session. This is mainly a convenience method to avoid
needing to set a custom Transport: header for every SETUP
request. The application must set a Transport: header before
issuing a SETUP request. (Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_HEADER</p>

<p style="margin-left:22%;">This option is simply an alias
for <i>CURLOPT_HTTP_HEADER</i>. Use this to replace the
standard headers that RTSP and HTTP share. It is also valid
to use the shortcuts such as <i>CURLOPT_USERAGENT</i>.
(Added in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_CLIENT_CSEQ</p>

<p style="margin-left:22%;">Manually set the the CSEQ
number to issue for the next RTSP request. Useful if the
application is resuming a previously broken connection. The
CSEQ will increment from this new number henceforth. (Added
in 7.20.0)</p>

<p style="margin-left:11%;">CURLOPT_RTSP_SERVER_CSEQ</p>

<p style="margin-left:22%;">Manually set the CSEQ number to
expect for the next RTSP Server-&gt;Client request. At the
moment, this feature (listening for Server requests) is
unimplemented. (Added in 7.20.0)</p>

<h2>PROTOCOL OPTIONS
<a name="PROTOCOL OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_TRANSFERTEXT</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to use ASCII mode for FTP transfers, instead of the
default binary transfer. For win32 systems it does not set
the stdout to binary mode. This option can be usable when
transferring text data between systems with different views
on certain characters, such as newlines or similar.</p>

<p style="margin-left:22%; margin-top: 1em">libcurl does
not do a complete ASCII conversion when doing ASCII
transfers over FTP. This is a known limitation/flaw that
nobody has rectified. libcurl simply sets the mode to ASCII
and performs a standard transfer.</p>


<p style="margin-left:11%;">CURLOPT_PROXY_TRANSFER_MODE</p>

<p style="margin-left:22%;">Pass a long. If the value is
set to 1 (one), it tells libcurl to set the transfer mode
(binary or ASCII) for FTP transfers done via a HTTP proxy,
by appending ;type=a or ;type=i to the URL. Without this
setting, or it being set to 0 (zero, the default),
<i>CURLOPT_TRANSFERTEXT</i> has no effect when doing FTP via
a proxy. Beware that not all proxies support this feature.
(Added in 7.18.0)</p>

<p style="margin-left:11%;">CURLOPT_CRLF</p>

<p style="margin-left:22%;">Pass a long. If the value is
set to 1 (one), libcurl converts Unix newlines to CRLF
newlines on transfers. Disable this option again by setting
the value to 0 (zero).</p>

<p style="margin-left:11%;">CURLOPT_RANGE</p>

<p style="margin-left:22%;">Pass a char * as parameter,
which should contain the specified range you want. It should
be in the format &quot;X-Y&quot;, where X or Y may be left
out. HTTP transfers also support several intervals,
separated with commas as in <i>&quot;X-Y,N-M&quot;</i>.
Using this kind of multiple intervals will cause the HTTP
server to send the response document in pieces (using
standard MIME separation techniques). For RTSP, the
formatting of a range should follow RFC2326 Section 12.29.
For RTSP, byte ranges are <b>not</b> permitted. Instead,
ranges should be given in npt, utc, or smpte formats.</p>

<p style="margin-left:22%; margin-top: 1em">Pass a NULL to
this option to disable the use of ranges.</p>

<p style="margin-left:22%; margin-top: 1em">Ranges work on
HTTP, FTP, FILE (since 7.18.0), and RTSP (since 7.20.0)
transfers only.</p>

<p style="margin-left:11%;">CURLOPT_RESUME_FROM</p>

<p style="margin-left:22%;">Pass a long as parameter. It
contains the offset in number of bytes that you want the
transfer to start from. Set this option to 0 to make the
transfer start from the beginning (effectively disabling
resume). For FTP, set this option to -1 to make the transfer
start from the end of the target file (useful to continue an
interrupted upload).</p>

<p style="margin-left:22%; margin-top: 1em">When doing
uploads with FTP, the resume position is where in the
local/source file libcurl should try to resume the upload
from and it will then append the source file to the remote
target file.</p>

<p style="margin-left:11%;">CURLOPT_RESUME_FROM_LARGE</p>

<p style="margin-left:22%;">Pass a curl_off_t as parameter.
It contains the offset in number of bytes that you want the
transfer to start from. (Added in 7.11.0)</p>

<p style="margin-left:11%;">CURLOPT_CUSTOMREQUEST</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It can be used to specify
the request instead of GET or HEAD when performing HTTP
based requests, instead of LIST and NLST when performing FTP
directory listings and instead of LIST and RETR when issuing
POP3 based commands. This is particularly useful, for
example, for performing a HTTP DELETE request or a POP3 DELE
command.</p>

<p style="margin-left:22%; margin-top: 1em">Please
don&rsquo;t perform this at will, on HTTP based requests, by
making sure your server supports the command you are sending
first.</p>

<p style="margin-left:22%; margin-top: 1em">When you change
the request method by setting <b>CURLOPT_CUSTOMREQUEST</b>
to something, you don&rsquo;t actually change how libcurl
behaves or acts in regards to the particular request method,
it will only change the actual string sent in the
request.</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>

<p style="margin-left:22%; margin-top: 1em">With the HTTP
protocol when you tell libcurl to do a HEAD request, but
then specify a GET though a custom request libcurl will
still act as if it sent a HEAD. To switch to a proper HEAD
use <i>CURLOPT_NOBODY</i>, to switch to a proper POST use
<i>CURLOPT_POST</i> or <i>CURLOPT_POSTFIELDS</i> and to
switch to a proper GET use CURLOPT_HTTPGET.</p>

<p style="margin-left:22%; margin-top: 1em">With the POP3
protocol when you tell libcurl to use a custom request it
will behave like a LIST or RETR command was sent where it
expects data to be returned by the server. As such
<i>CURLOPT_NOBODY</i> should be used when specifying
commands such as DELE and NOOP for example.</p>

<p style="margin-left:22%; margin-top: 1em">Restore to the
internal default by setting this to NULL.</p>

<p style="margin-left:22%; margin-top: 1em">Many people
have wrongly used this option to replace the entire request
with their own, including multiple headers and POST
contents. While that might work in many cases, it will cause
libcurl to send invalid requests and it could possibly
confuse the remote server badly. Use <i>CURLOPT_POST</i> and
<i>CURLOPT_POSTFIELDS</i> to set POST data. Use
<i>CURLOPT_HTTPHEADER</i> to replace or extend the set of
headers sent by libcurl. Use <i>CURLOPT_HTTP_VERSION</i> to
change HTTP version.</p>

<p style="margin-left:22%; margin-top: 1em">(Support for
POP3 added in 7.26.0)</p>

<p style="margin-left:11%;">CURLOPT_FILETIME</p>

<p style="margin-left:22%;">Pass a long. If it is 1,
libcurl will attempt to get the modification date of the
remote document in this operation. This requires that the
remote server sends the time or replies to a time querying
command. The <i>curl_easy_getinfo(3)</i> function with the
<i>CURLINFO_FILETIME</i> argument can be used after a
transfer to extract the received time (if any).</p>

<p style="margin-left:11%;">CURLOPT_NOBODY</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to not include the body-part in the output. This is
only relevant for protocols that have separate header and
body parts. On HTTP(S) servers, this will make libcurl do a
HEAD request.</p>

<p style="margin-left:22%; margin-top: 1em">To change
request to GET, you should use <i>CURLOPT_HTTPGET</i>.
Change request to POST with <i>CURLOPT_POST</i> etc.</p>

<p style="margin-left:11%;">CURLOPT_INFILESIZE</p>

<p style="margin-left:22%;">When uploading a file to a
remote site, this option should be used to tell libcurl what
the expected size of the infile is. This value should be
passed as a long. See also
<i>CURLOPT_INFILESIZE_LARGE</i>.</p>

<p style="margin-left:22%; margin-top: 1em">For uploading
using SCP, this option or <i>CURLOPT_INFILESIZE_LARGE</i> is
mandatory.</p>

<p style="margin-left:22%; margin-top: 1em">When sending
emails using SMTP, this command can be used to specify the
optional SIZE parameter for the MAIL FROM command. (Added in
7.23.0)</p>

<p style="margin-left:22%; margin-top: 1em">This option
does not limit how much data libcurl will actually send, as
that is controlled entirely by what the read callback
returns.</p>

<p style="margin-left:11%;">CURLOPT_INFILESIZE_LARGE</p>

<p style="margin-left:22%;">When uploading a file to a
remote site, this option should be used to tell libcurl what
the expected size of the infile is. This value should be
passed as a curl_off_t. (Added in 7.11.0)</p>

<p style="margin-left:22%; margin-top: 1em">For uploading
using SCP, this option or <i>CURLOPT_INFILESIZE</i> is
mandatory.</p>

<p style="margin-left:22%; margin-top: 1em">This option
does not limit how much data libcurl will actually send, as
that is controlled entirely by what the read callback
returns.</p>

<p style="margin-left:11%;">CURLOPT_UPLOAD</p>

<p style="margin-left:22%;">A parameter set to 1 tells the
library to prepare for an upload. The
<i>CURLOPT_READDATA</i> and <i>CURLOPT_INFILESIZE</i> or
<i>CURLOPT_INFILESIZE_LARGE</i> options are also interesting
for uploads. If the protocol is HTTP, uploading means using
the PUT request unless you tell libcurl otherwise.</p>

<p style="margin-left:22%; margin-top: 1em">Using PUT with
HTTP 1.1 implies the use of a &quot;Expect:
100-continue&quot; header. You can disable this header with
<i>CURLOPT_HTTPHEADER</i> as usual.</p>

<p style="margin-left:22%; margin-top: 1em">If you use PUT
to a HTTP 1.1 server, you can upload data without knowing
the size before starting the transfer if you use chunked
encoding. You enable this by adding a header like
&quot;Transfer-Encoding: chunked&quot; with
<i>CURLOPT_HTTPHEADER</i>. With HTTP 1.0 or without chunked
transfer, you must specify the size.</p>

<p style="margin-left:11%;">CURLOPT_MAXFILESIZE</p>

<p style="margin-left:22%;">Pass a long as parameter. This
allows you to specify the maximum size (in bytes) of a file
to download. If the file requested is larger than this
value, the transfer will not start and
CURLE_FILESIZE_EXCEEDED will be returned.</p>

<p style="margin-left:22%; margin-top: 1em">The file size
is not always known prior to download, and for such files
this option has no effect even if the file transfer ends up
being larger than this given limit. This concerns both FTP
and HTTP transfers.</p>

<p style="margin-left:11%;">CURLOPT_MAXFILESIZE_LARGE</p>

<p style="margin-left:22%;">Pass a curl_off_t as parameter.
This allows you to specify the maximum size (in bytes) of a
file to download. If the file requested is larger than this
value, the transfer will not start and
<i>CURLE_FILESIZE_EXCEEDED</i> will be returned. (Added in
7.11.0)</p>

<p style="margin-left:22%; margin-top: 1em">The file size
is not always known prior to download, and for such files
this option has no effect even if the file transfer ends up
being larger than this given limit. This concerns both FTP
and HTTP transfers.</p>

<p style="margin-left:11%;">CURLOPT_TIMECONDITION</p>

<p style="margin-left:22%;">Pass a long as parameter. This
defines how the <i>CURLOPT_TIMEVALUE</i> time value is
treated. You can set this parameter to
<i>CURL_TIMECOND_IFMODSINCE</i> or
<i>CURL_TIMECOND_IFUNMODSINCE</i>. This feature applies to
HTTP, FTP, RTSP, and FILE.</p>

<p style="margin-left:22%; margin-top: 1em">The last
modification time of a file is not always known and in such
instances this feature will have no effect even if the given
time condition would not have been met.
<i>curl_easy_getinfo(3)</i> with the
<i>CURLINFO_CONDITION_UNMET</i> option can be used after a
transfer to learn if a zero-byte successful
&quot;transfer&quot; was due to this condition not
matching.</p>

<p style="margin-left:11%;">CURLOPT_TIMEVALUE</p>

<p style="margin-left:22%;">Pass a long as parameter. This
should be the time in seconds since 1 Jan 1970, and the time
will be used in a condition as specified with
<i>CURLOPT_TIMECONDITION</i>.</p>

<h2>CONNECTION OPTIONS
<a name="CONNECTION OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_TIMEOUT</p>

<p style="margin-left:22%;">Pass a long as parameter
containing the maximum time in seconds that you allow the
libcurl transfer operation to take. Normally, name lookups
can take a considerable time and limiting operations to less
than a few minutes risk aborting perfectly normal
operations. This option will cause curl to use the SIGALRM
to enable time-outing system calls.</p>

<p style="margin-left:22%; margin-top: 1em">In unix-like
systems, this might cause signals to be used unless
<i>CURLOPT_NOSIGNAL</i> is set.</p>

<p style="margin-left:22%; margin-top: 1em">Default timeout
is 0 (zero) which means it never times out.</p>

<p style="margin-left:11%;">CURLOPT_TIMEOUT_MS</p>

<p style="margin-left:22%;">Like <i>CURLOPT_TIMEOUT</i> but
takes number of milliseconds instead. If libcurl is built to
use the standard system name resolver, that portion of the
transfer will still use full-second resolution for timeouts
with a minimum timeout allowed of one second. (Added in
7.16.2)</p>

<p style="margin-left:11%;">CURLOPT_LOW_SPEED_LIMIT</p>

<p style="margin-left:22%;">Pass a long as parameter. It
contains the transfer speed in bytes per second that the
transfer should be below during
<i>CURLOPT_LOW_SPEED_TIME</i> seconds for the library to
consider it too slow and abort.</p>

<p style="margin-left:11%;">CURLOPT_LOW_SPEED_TIME</p>

<p style="margin-left:22%;">Pass a long as parameter. It
contains the time in seconds that the transfer should be
below the <i>CURLOPT_LOW_SPEED_LIMIT</i> for the library to
consider it too slow and abort.</p>


<p style="margin-left:11%;">CURLOPT_MAX_SEND_SPEED_LARGE</p>

<p style="margin-left:22%;">Pass a curl_off_t as parameter.
If an upload exceeds this speed (counted in bytes per
second) on cumulative average during the transfer, the
transfer will pause to keep the average rate less than or
equal to the parameter value. Defaults to unlimited speed.
(Added in 7.15.5)</p>


<p style="margin-left:11%;">CURLOPT_MAX_RECV_SPEED_LARGE</p>

<p style="margin-left:22%;">Pass a curl_off_t as parameter.
If a download exceeds this speed (counted in bytes per
second) on cumulative average during the transfer, the
transfer will pause to keep the average rate less than or
equal to the parameter value. Defaults to unlimited speed.
(Added in 7.15.5)</p>

<p style="margin-left:11%;">CURLOPT_MAXCONNECTS</p>

<p style="margin-left:22%;">Pass a long. The set number
will be the persistent connection cache size. The set amount
will be the maximum amount of simultaneously open
connections that libcurl may cache in this easy handle.
Default is 5, and there isn&rsquo;t much point in changing
this value unless you are perfectly aware of how this works
and changes libcurl&rsquo;s behaviour. This concerns
connections using any of the protocols that support
persistent connections.</p>

<p style="margin-left:22%; margin-top: 1em">When reaching
the maximum limit, curl closes the oldest one in the cache
to prevent increasing the number of open connections.</p>

<p style="margin-left:22%; margin-top: 1em">If you already
have performed transfers with this curl handle, setting a
smaller MAXCONNECTS than before may cause open connections
to get closed unnecessarily.</p>

<p style="margin-left:22%; margin-top: 1em">If you add this
easy handle to a multi handle, this setting is not
acknowledged, and you must instead use
<i>curl_multi_setopt(3)</i> and the
<i>CURLMOPT_MAXCONNECTS</i> option.</p>

<p style="margin-left:11%;">CURLOPT_CLOSEPOLICY</p>

<p style="margin-left:22%;">(Obsolete) This option does
nothing.</p>

<p style="margin-left:11%;">CURLOPT_FRESH_CONNECT</p>

<p style="margin-left:22%;">Pass a long. Set to 1 to make
the next transfer use a new (fresh) connection by force. If
the connection cache is full before this connection, one of
the existing connections will be closed as according to the
selected or default policy. This option should be used with
caution and only if you understand what it does. Set this to
0 to have libcurl attempt re-using an existing connection
(default behavior).</p>

<p style="margin-left:11%;">CURLOPT_FORBID_REUSE</p>

<p style="margin-left:22%;">Pass a long. Set to 1 to make
the next transfer explicitly close the connection when done.
Normally, libcurl keeps all connections alive when done with
one transfer in case a succeeding one follows that can
re-use them. This option should be used with caution and
only if you understand what it does. Set to 0 to have
libcurl keep the connection open for possible later re-use
(default behavior).</p>

<p style="margin-left:11%;">CURLOPT_CONNECTTIMEOUT</p>

<p style="margin-left:22%;">Pass a long. It should contain
the maximum time in seconds that you allow the connection to
the server to take. This only limits the connection phase,
once it has connected, this option is of no more use. Set to
zero to switch to the default built-in connection timeout -
300 seconds. See also the <i>CURLOPT_TIMEOUT</i> option.</p>

<p style="margin-left:22%; margin-top: 1em">In unix-like
systems, this might cause signals to be used unless
<i>CURLOPT_NOSIGNAL</i> is set.</p>

<p style="margin-left:11%;">CURLOPT_CONNECTTIMEOUT_MS</p>

<p style="margin-left:22%;">Like
<i>CURLOPT_CONNECTTIMEOUT</i> but takes the number of
milliseconds instead. If libcurl is built to use the
standard system name resolver, that portion of the connect
will still use full-second resolution for timeouts with a
minimum timeout allowed of one second. (Added in 7.16.2)</p>

<p style="margin-left:11%;">CURLOPT_IPRESOLVE</p>

<p style="margin-left:22%;">Allows an application to select
what kind of IP addresses to use when resolving host names.
This is only interesting when using host names that resolve
addresses using more than one version of IP. The allowed
values are: <br>
CURL_IPRESOLVE_WHATEVER</p>

<p style="margin-left:32%;">Default, resolves addresses to
all IP versions that your system allows.</p>

<p style="margin-left:22%;">CURL_IPRESOLVE_V4</p>

<p style="margin-left:32%;">Resolve to IPv4 addresses.</p>

<p style="margin-left:22%;">CURL_IPRESOLVE_V6</p>

<p style="margin-left:32%;">Resolve to IPv6 addresses.</p>

<p style="margin-left:11%;">CURLOPT_CONNECT_ONLY</p>

<p style="margin-left:22%;">Pass a long. If the parameter
equals 1, it tells the library to perform all the required
proxy authentication and connection setup, but no data
transfer. This option is implemented for HTTP, SMTP and
POP3.</p>

<p style="margin-left:22%; margin-top: 1em">The option can
be used to simply test a connection to a server, but is more
useful when used with the <i>CURLINFO_LASTSOCKET</i> option
to <i>curl_easy_getinfo(3)</i> as the library can set up the
connection and then the application can obtain the most
recently used socket for special data transfers. (Added in
7.15.2)</p>

<p style="margin-left:11%;">CURLOPT_USE_SSL</p>

<p style="margin-left:22%;">Pass a long using one of the
values from below, to make libcurl use your desired level of
SSL for the transfer. (Added in 7.11.0)</p>

<p style="margin-left:22%; margin-top: 1em">This is for
enabling SSL/TLS when you use FTP, SMTP, POP3, IMAP etc.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was known as CURLOPT_FTP_SSL up to 7.16.4, and the constants
were known as CURLFTPSSL_*) <br>
CURLUSESSL_NONE</p>

<p style="margin-left:32%;">Don&rsquo;t attempt to use
SSL.</p>

<p style="margin-left:22%;">CURLUSESSL_TRY</p>

<p style="margin-left:32%;">Try using SSL, proceed as
normal otherwise.</p>

<p style="margin-left:22%;">CURLUSESSL_CONTROL</p>

<p style="margin-left:32%;">Require SSL for the control
connection or fail with <i>CURLE_USE_SSL_FAILED</i>.</p>

<p style="margin-left:22%;">CURLUSESSL_ALL</p>

<p style="margin-left:32%;">Require SSL for all
communication or fail with <i>CURLE_USE_SSL_FAILED</i>.</p>

<p style="margin-left:11%;">CURLOPT_RESOLVE</p>

<p style="margin-left:22%;">Pass a pointer to a linked list
of strings with host name resolve information to use for
requests with this handle. The linked list should be a fully
valid list of <b>struct curl_slist</b> structs properly
filled in. Use <i>curl_slist_append(3)</i> to create the
list and <i>curl_slist_free_all(3)</i> to clean up an entire
list.</p>

<p style="margin-left:22%; margin-top: 1em">Each single
name resolve string should be written using the format
HOST:PORT:ADDRESS where HOST is the name libcurl will try to
resolve, PORT is the port number of the service where
libcurl wants to connect to the HOST and ADDRESS is the
numerical IP address. If libcurl is built to support IPv6,
ADDRESS can of course be either IPv4 or IPv6 style
addressing.</p>

<p style="margin-left:22%; margin-top: 1em">This option
effectively pre-populates the DNS cache with entries for the
host+port pair so redirects and everything that operations
against the HOST+PORT will instead use your provided
ADDRESS.</p>

<p style="margin-left:22%; margin-top: 1em">You can remove
names from the DNS cache again, to stop providing these fake
resolves, by including a string in the linked list that uses
the format &quot;-HOST:PORT&quot;. The host name must be
prefixed with a dash, and the host name and port number must
exactly match what was already added previously.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.21.3)</p>

<p style="margin-left:11%;">CURLOPT_DNS_SERVERS</p>

<p style="margin-left:22%;">Set the list of DNS servers to
be used instead of the system default. The format of the dns
servers option is:</p>


<p style="margin-left:22%; margin-top: 1em">host[:port][,host[:port]]...</p>

<p style="margin-left:22%; margin-top: 1em">For
example:</p>


<p style="margin-left:22%; margin-top: 1em">192.168.1.100,192.168.1.101,3.4.5.6</p>

<p style="margin-left:22%; margin-top: 1em">This option
requires that libcurl was built with a resolver backend that
supports this operation. The c-ares backend is the only such
one.</p>

<p style="margin-left:22%; margin-top: 1em">(Added in
7.24.0)</p>

<p style="margin-left:11%;">CURLOPT_ACCEPTTIMEOUT_MS</p>

<p style="margin-left:22%;">Pass a long telling libcurl the
maximum number of milliseconds to wait for a server to
connect back to libcurl when an active FTP connection is
used. If no timeout is set, the internal default of 60000
will be used. (Added in 7.24.0)</p>

<h2>SSL and SECURITY OPTIONS
<a name="SSL and SECURITY OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_SSLCERT</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. The string should be the
file name of your certificate. The default format is
&quot;PEM&quot; and can be changed with
<i>CURLOPT_SSLCERTTYPE</i>.</p>

<p style="margin-left:22%; margin-top: 1em">With NSS this
can also be the nickname of the certificate you wish to
authenticate with. If you want to use a file from the
current directory, please precede it with &quot;./&quot;
prefix, in order to avoid confusion with a nickname.</p>

<p style="margin-left:11%;">CURLOPT_SSLCERTTYPE</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. The string should be the
format of your certificate. Supported formats are
&quot;PEM&quot; and &quot;DER&quot;. (Added in 7.9.3)</p>

<p style="margin-left:11%;">CURLOPT_SSLKEY</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. The string should be the
file name of your private key. The default format is
&quot;PEM&quot; and can be changed with
<i>CURLOPT_SSLKEYTYPE</i>.</p>

<p style="margin-left:11%;">CURLOPT_SSLKEYTYPE</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. The string should be the
format of your private key. Supported formats are
&quot;PEM&quot;, &quot;DER&quot; and &quot;ENG&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">The format
&quot;ENG&quot; enables you to load the private key from a
crypto engine. In this case <i>CURLOPT_SSLKEY</i> is used as
an identifier passed to the engine. You have to set the
crypto engine with <i>CURLOPT_SSLENGINE</i>. &quot;DER&quot;
format key file currently does not work because of a bug in
OpenSSL.</p>

<p style="margin-left:11%;">CURLOPT_KEYPASSWD</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used as the
password required to use the <i>CURLOPT_SSLKEY</i> or
<i>CURLOPT_SSH_PRIVATE_KEYFILE</i> private key. You never
needed a pass phrase to load a certificate but you need one
to load your private key.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was known as CURLOPT_SSLKEYPASSWD up to 7.16.4 and
CURLOPT_SSLCERTPASSWD up to 7.9.2)</p>

<p style="margin-left:11%;">CURLOPT_SSLENGINE</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string as parameter. It will be used as the
identifier for the crypto engine you want to use for your
private key.</p>

<p style="margin-left:22%; margin-top: 1em">If the crypto
device cannot be loaded, <i>CURLE_SSL_ENGINE_NOTFOUND</i> is
returned.</p>

<p style="margin-left:11%;">CURLOPT_SSLENGINE_DEFAULT</p>

<p style="margin-left:22%;">Sets the actual crypto engine
as the default for (asymmetric) crypto operations.</p>

<p style="margin-left:22%; margin-top: 1em">If the crypto
device cannot be set, <i>CURLE_SSL_ENGINE_SETFAILED</i> is
returned.</p>

<p style="margin-left:22%; margin-top: 1em">Even though
this option doesn&rsquo;t need any parameter, in some
configurations <i>curl_easy_setopt</i> might be defined as a
macro taking exactly three arguments. Therefore, it&rsquo;s
recommended to pass 1 as parameter to this option.</p>

<p style="margin-left:11%;">CURLOPT_SSLVERSION</p>

<p style="margin-left:22%;">Pass a long as parameter to
control what version of SSL/TLS to attempt to use. (Added in
7.9.2)</p>

<p style="margin-left:22%; margin-top: 1em">The available
options are: <br>
CURL_SSLVERSION_DEFAULT</p>

<p style="margin-left:32%;">The default action. This will
attempt to figure out the remote SSL protocol version, i.e.
either SSLv3 or TLSv1 (but not SSLv2, which became disabled
by default with 7.18.1).</p>

<p style="margin-left:22%;">CURL_SSLVERSION_TLSv1</p>

<p style="margin-left:32%;">Force TLSv1.x</p>

<p style="margin-left:22%;">CURL_SSLVERSION_SSLv2</p>

<p style="margin-left:32%;">Force SSLv2</p>

<p style="margin-left:22%;">CURL_SSLVERSION_SSLv3</p>

<p style="margin-left:32%;">Force SSLv3</p>

<p style="margin-left:22%;">CURL_SSLVERSION_TLSv1_0</p>

<p style="margin-left:32%;">Force TLSv1.0 (Added in
7.34.0)</p>

<p style="margin-left:22%;">CURL_SSLVERSION_TLSv1_1</p>

<p style="margin-left:32%;">Force TLSv1.1 (Added in
7.34.0)</p>

<p style="margin-left:22%;">CURL_SSLVERSION_TLSv1_2</p>

<p style="margin-left:32%;">Force TLSv1.2 (Added in
7.34.0)</p>

<p style="margin-left:11%;">CURLOPT_SSL_VERIFYPEER</p>

<p style="margin-left:22%;">Pass a long as parameter. By
default, curl assumes a value of 1.</p>

<p style="margin-left:22%; margin-top: 1em">This option
determines whether curl verifies the authenticity of the
peer&rsquo;s certificate. A value of 1 means curl verifies;
0 (zero) means it doesn&rsquo;t.</p>

<p style="margin-left:22%; margin-top: 1em">When
negotiating a SSL connection, the server sends a certificate
indicating its identity. Curl verifies whether the
certificate is authentic, i.e. that you can trust that the
server is who the certificate says it is. This trust is
based on a chain of digital signatures, rooted in
certification authority (CA) certificates you supply. curl
uses a default bundle of CA certificates (the path for that
is determined at build time) and you can specify alternate
certificates with the <i>CURLOPT_CAINFO</i> option or the
<i>CURLOPT_CAPATH</i> option.</p>

<p style="margin-left:22%; margin-top: 1em">When
<i>CURLOPT_SSL_VERIFYPEER</i> is nonzero, and the
verification fails to prove that the certificate is
authentic, the connection fails. When the option is zero,
the peer certificate verification succeeds regardless.</p>

<p style="margin-left:22%; margin-top: 1em">Authenticating
the certificate is not by itself very useful. You typically
want to ensure that the server, as authentically identified
by its certificate, is the server you mean to be talking to.
Use <i>CURLOPT_SSL_VERIFYHOST</i> to control that. The check
that the host name in the certificate is valid for the host
name you&rsquo;re connecting to is done independently of the
<i>CURLOPT_SSL_VERIFYPEER</i> option.</p>

<p style="margin-left:11%;">CURLOPT_CAINFO</p>

<p style="margin-left:22%;">Pass a char * to a zero
terminated string naming a file holding one or more
certificates to verify the peer with. This makes sense only
when used in combination with the
<i>CURLOPT_SSL_VERIFYPEER</i> option. If
<i>CURLOPT_SSL_VERIFYPEER</i> is zero, <i>CURLOPT_CAINFO</i>
need not even indicate an accessible file.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
by default set to the system path where libcurl&rsquo;s
cacert bundle is assumed to be stored, as established at
build time.</p>

<p style="margin-left:22%; margin-top: 1em">If curl is
built against the NSS SSL library, the NSS PEM PKCS#11
module (libnsspem.so) needs to be available for this option
to work properly.</p>

<p style="margin-left:11%;">CURLOPT_ISSUERCERT</p>

<p style="margin-left:22%;">Pass a char * to a zero
terminated string naming a file holding a CA certificate in
PEM format. If the option is set, an additional check
against the peer certificate is performed to verify the
issuer is indeed the one associated with the certificate
provided by the option. This additional check is useful in
multi-level PKI where one needs to enforce that the peer
certificate is from a specific branch of the tree.</p>

<p style="margin-left:22%; margin-top: 1em">This option
makes sense only when used in combination with the
<i>CURLOPT_SSL_VERIFYPEER</i> option. Otherwise, the result
of the check is not considered as failure.</p>

<p style="margin-left:22%; margin-top: 1em">A specific
error code (CURLE_SSL_ISSUER_ERROR) is defined with the
option, which is returned if the setup of the SSL/TLS
session has failed due to a mismatch with the issuer of peer
certificate (<i>CURLOPT_SSL_VERIFYPEER</i> has to be set too
for the check to fail). (Added in 7.19.0)</p>

<p style="margin-left:11%;">CURLOPT_CAPATH</p>

<p style="margin-left:22%;">Pass a char * to a zero
terminated string naming a directory holding multiple CA
certificates to verify the peer with. If libcurl is built
against OpenSSL, the certificate directory must be prepared
using the openssl c_rehash utility. This makes sense only
when used in combination with the
<i>CURLOPT_SSL_VERIFYPEER</i> option. If
<i>CURLOPT_SSL_VERIFYPEER</i> is zero, <i>CURLOPT_CAPATH</i>
need not even indicate an accessible path. The
<i>CURLOPT_CAPATH</i> function apparently does not work in
Windows due to some limitation in openssl. This option is
OpenSSL-specific and does nothing if libcurl is built to use
GnuTLS. NSS-powered libcurl provides the option only for
backward compatibility.</p>

<p style="margin-left:11%;">CURLOPT_CRLFILE</p>

<p style="margin-left:22%;">Pass a char * to a zero
terminated string naming a file with the concatenation of
CRL (in PEM format) to use in the certificate validation
that occurs during the SSL exchange.</p>

<p style="margin-left:22%; margin-top: 1em">When curl is
built to use NSS or GnuTLS, there is no way to influence the
use of CRL passed to help in the verification process. When
libcurl is built with OpenSSL support, X509_V_FLAG_CRL_CHECK
and X509_V_FLAG_CRL_CHECK_ALL are both set, requiring CRL
check against all the elements of the certificate chain if a
CRL file is passed.</p>

<p style="margin-left:22%; margin-top: 1em">This option
makes sense only when used in combination with the
<i>CURLOPT_SSL_VERIFYPEER</i> option.</p>

<p style="margin-left:22%; margin-top: 1em">A specific
error code (CURLE_SSL_CRL_BADFILE) is defined with the
option. It is returned when the SSL exchange fails because
the CRL file cannot be loaded. A failure in certificate
verification due to a revocation information found in the
CRL does not trigger this specific error. (Added in
7.19.0)</p>

<p style="margin-left:11%;">CURLOPT_SSL_VERIFYHOST</p>

<p style="margin-left:22%;">Pass a long as parameter.</p>

<p style="margin-left:22%; margin-top: 1em">This option
determines whether libcurl verifies that the server cert is
for the server it is known as.</p>

<p style="margin-left:22%; margin-top: 1em">When
negotiating a SSL connection, the server sends a certificate
indicating its identity.</p>

<p style="margin-left:22%; margin-top: 1em">When
<i>CURLOPT_SSL_VERIFYHOST</i> is 2, that certificate must
indicate that the server is the server to which you meant to
connect, or the connection fails.</p>

<p style="margin-left:22%; margin-top: 1em">Curl considers
the server the intended one when the Common Name field or a
Subject Alternate Name field in the certificate matches the
host name in the URL to which you told Curl to connect.</p>

<p style="margin-left:22%; margin-top: 1em">When the value
is 1, libcurl will return a failure. It was previously (in
7.28.0 and earlier) a debug option of some sorts, but it is
no longer supported due to frequently leading to programmer
mistakes.</p>

<p style="margin-left:22%; margin-top: 1em">When the value
is 0, the connection succeeds regardless of the names in the
certificate.</p>

<p style="margin-left:22%; margin-top: 1em">The default
value for this option is 2.</p>

<p style="margin-left:22%; margin-top: 1em">This option
controls checking the server&rsquo;s certificate&rsquo;s
claimed identity. The server could be lying. To control
lying, see <i>CURLOPT_SSL_VERIFYPEER</i>. If libcurl is
built against NSS and <i>CURLOPT_SSL_VERIFYPEER</i> is zero,
<i>CURLOPT_SSL_VERIFYHOST</i> is ignored.</p>

<p style="margin-left:11%;">CURLOPT_CERTINFO</p>

<p style="margin-left:22%;">Pass a long set to 1 to enable
libcurl&rsquo;s certificate chain info gatherer. With this
enabled, libcurl (if built with OpenSSL) will extract lots
of information and data about the certificates in the
certificate chain used in the SSL connection. This data is
then possible to extract after a transfer using
<i>curl_easy_getinfo(3)</i> and its option
<i>CURLINFO_CERTINFO</i>. (Added in 7.19.1)</p>

<p style="margin-left:11%;">CURLOPT_RANDOM_FILE</p>

<p style="margin-left:22%;">Pass a char * to a zero
terminated file name. The file will be used to read from to
seed the random engine for SSL. The more random the
specified file is, the more secure the SSL connection will
become.</p>

<p style="margin-left:11%;">CURLOPT_EGDSOCKET</p>

<p style="margin-left:22%;">Pass a char * to the zero
terminated path name to the Entropy Gathering Daemon socket.
It will be used to seed the random engine for SSL.</p>

<p style="margin-left:11%;">CURLOPT_SSL_CIPHER_LIST</p>

<p style="margin-left:22%;">Pass a char *, pointing to a
zero terminated string holding the list of ciphers to use
for the SSL connection. The list must be syntactically
correct, it consists of one or more cipher strings separated
by colons. Commas or spaces are also acceptable separators
but colons are normally used, !, - and + can be used as
operators.</p>

<p style="margin-left:22%; margin-top: 1em">For OpenSSL and
GnuTLS valid examples of cipher lists include
&rsquo;RC4-SHA&rsquo;, &acute;SHA1+DES&acute;,
&rsquo;TLSv1&rsquo; and &rsquo;DEFAULT&rsquo;. The default
list is normally set when you compile OpenSSL.</p>

<p style="margin-left:22%; margin-top: 1em">You&rsquo;ll
find more details about cipher lists on this URL:
<i>http://www.openssl.org/docs/apps/ciphers.html</i></p>

<p style="margin-left:22%; margin-top: 1em">For NSS, valid
examples of cipher lists include
&rsquo;rsa_rc4_128_md5&rsquo;,
&acute;rsa_aes_128_sha&acute;, etc. With NSS you don&rsquo;t
add/remove ciphers. If one uses this option then all known
ciphers are disabled and only those passed in are
enabled.</p>

<p style="margin-left:22%; margin-top: 1em">You&rsquo;ll
find more details about the NSS cipher lists on this URL:
<i>http://git.fedorahosted.org/cgit/mod_nss.git/plain/docs/mod_nss.html#Directives</i></p>


<p style="margin-left:11%;">CURLOPT_SSL_SESSIONID_CACHE</p>

<p style="margin-left:22%;">Pass a long set to 0 to disable
libcurl&rsquo;s use of SSL session-ID caching. Set this to 1
to enable it. By default all transfers are done using the
cache. While nothing ever should get hurt by attempting to
reuse SSL session-IDs, there seem to be broken SSL
implementations in the wild that may require you to disable
this in order for you to succeed. (Added in 7.16.0)</p>

<p style="margin-left:11%;">CURLOPT_SSL_OPTIONS</p>

<p style="margin-left:22%;">Pass a long with a bitmask to
tell libcurl about specific SSL behaviors.</p>


<p style="margin-left:22%; margin-top: 1em">CURLSSLOPT_ALLOW_BEAST
is the only supported bit and by setting this the user will
tell libcurl to not attempt to use any workarounds for a
security flaw in the SSL3 and TLS1.0 protocols. If this
option isn&rsquo;t used or this bit is set to 0, the SSL
layer libcurl uses may use a work-around for this flaw
although it might cause interoperability problems with some
(older) SSL implementations. WARNING: avoiding this
work-around loosens the security, and by setting this option
to 1 you ask for exactly that. (Added in 7.25.0)</p>

<p style="margin-left:11%;">CURLOPT_KRBLEVEL</p>

<p style="margin-left:22%;">Pass a char * as parameter. Set
the kerberos security level for FTP; this also enables
kerberos awareness. This is a string, &rsquo;clear&rsquo;,
&rsquo;safe&rsquo;, &rsquo;confidential&rsquo; or
&rsquo;private&rsquo;. If the string is set but
doesn&rsquo;t match one of these, &rsquo;private&rsquo; will
be used. Set the string to NULL to disable kerberos support
for FTP.</p>

<p style="margin-left:22%; margin-top: 1em">(This option
was known as CURLOPT_KRB4LEVEL up to 7.16.3)</p>

<p style="margin-left:11%;">CURLOPT_GSSAPI_DELEGATION</p>

<p style="margin-left:22%;">Set the parameter to
CURLGSSAPI_DELEGATION_FLAG to allow unconditional GSSAPI
credential delegation. The delegation is disabled by default
since 7.21.7. Set the parameter to
CURLGSSAPI_DELEGATION_POLICY_FLAG to delegate only if the
OK-AS-DELEGATE flag is set in the service ticket in case
this feature is supported by the GSSAPI implementation and
the definition of GSS_C_DELEG_POLICY_FLAG was available at
compile-time. (Added in 7.22.0)</p>

<h2>SSH OPTIONS
<a name="SSH OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_SSH_AUTH_TYPES</p>

<p style="margin-left:22%;">Pass a long set to a bitmask
consisting of one or more of CURLSSH_AUTH_PUBLICKEY,
CURLSSH_AUTH_PASSWORD, CURLSSH_AUTH_HOST,
CURLSSH_AUTH_KEYBOARD and CURLSSH_AUTH_AGENT. Set
CURLSSH_AUTH_ANY to let libcurl pick a suitable one.
Currently CURLSSH_AUTH_HOST has no effect. (Added in 7.16.1)
If CURLSSH_AUTH_AGENT is used, libcurl attempts to connect
to ssh-agent or pageant and let the agent attempt the
authentication. (Added in 7.28.0)</p>


<p style="margin-left:11%;">CURLOPT_SSH_HOST_PUBLIC_KEY_MD5</p>

<p style="margin-left:22%;">Pass a char * pointing to a
string containing 32 hexadecimal digits. The string should
be the 128 bit MD5 checksum of the remote host&rsquo;s
public key, and libcurl will reject the connection to the
host unless the md5sums match. This option is only for SCP
and SFTP transfers. (Added in 7.17.1)</p>

<p style="margin-left:11%;">CURLOPT_SSH_PUBLIC_KEYFILE</p>

<p style="margin-left:22%;">Pass a char * pointing to a
file name for your public key. If not used, libcurl defaults
to <b>$HOME/.ssh/id_dsa.pub</b> if the HOME environment
variable is set, and just &quot;id_dsa.pub&quot; in the
current directory if HOME is not set. (Added in 7.16.1) If
an empty string is passed, libcurl will pass no public key
to libssh2 which then tries to compute it from the private
key, this is known to work when libssh2 1.4.0+ is linked
against OpenSSL. (Added in 7.26.0)</p>


<p style="margin-left:11%;">CURLOPT_SSH_PRIVATE_KEYFILE</p>

<p style="margin-left:22%;">Pass a char * pointing to a
file name for your private key. If not used, libcurl
defaults to <b>$HOME/.ssh/id_dsa</b> if the HOME environment
variable is set, and just &quot;id_dsa&quot; in the current
directory if HOME is not set. If the file is
password-protected, set the password with
<i>CURLOPT_KEYPASSWD</i>. (Added in 7.16.1)</p>

<p style="margin-left:11%;">CURLOPT_SSH_KNOWNHOSTS</p>

<p style="margin-left:22%;">Pass a pointer to a zero
terminated string holding the file name of the known_host
file to use. The known_hosts file should use the OpenSSH
file format as supported by libssh2. If this file is
specified, libcurl will only accept connections with hosts
that are known and present in that file, with a matching
public key. Use <i>CURLOPT_SSH_KEYFUNCTION</i> to alter the
default behavior on host and key (mis)matching. (Added in
7.19.6)</p>

<p style="margin-left:11%;">CURLOPT_SSH_KEYFUNCTION</p>

<p style="margin-left:22%;">Pass a pointer to a
curl_sshkeycallback function. It gets called when the
known_host matching has been done, to allow the application
to act and decide for libcurl how to proceed. The callback
will only be called if <i>CURLOPT_SSH_KNOWNHOSTS</i> is also
set.</p>

<p style="margin-left:22%; margin-top: 1em">The
curl_sshkeycallback function gets passed the CURL handle,
the key from the known_hosts file, the key from the remote
site, info from libcurl on the matching status and a custom
pointer (set with <i>CURLOPT_SSH_KEYDATA</i>). It MUST
return one of the following return codes to tell libcurl how
to act: <br>
CURLKHSTAT_FINE_ADD_TO_FILE</p>

<p style="margin-left:32%;">The host+key is accepted and
libcurl will append it to the known_hosts file before
continuing with the connection. This will also add the
host+key combo to the known_host pool kept in memory if it
wasn&rsquo;t already present there. The adding of data to
the file is done by completely replacing the file with a new
copy, so the permissions of the file must allow this.</p>

<p style="margin-left:22%;">CURLKHSTAT_FINE</p>

<p style="margin-left:32%;">The host+key is accepted
libcurl will continue with the connection. This will also
add the host+key combo to the known_host pool kept in memory
if it wasn&rsquo;t already present there.</p>

<p style="margin-left:22%;">CURLKHSTAT_REJECT</p>

<p style="margin-left:32%;">The host+key is rejected.
libcurl will deny the connection to continue and it will be
closed.</p>

<p style="margin-left:22%;">CURLKHSTAT_DEFER</p>

<p style="margin-left:32%;">The host+key is rejected, but
the SSH connection is asked to be kept alive. This feature
could be used when the app wants to somehow return back and
act on the host+key situation and then retry without needing
the overhead of setting it up from scratch again.</p>

<p style="margin-left:11%;">(Added in 7.19.6) <br>
CURLOPT_SSH_KEYDATA</p>

<p style="margin-left:22%;">Pass a void * as parameter.
This pointer will be passed along verbatim to the callback
set with <i>CURLOPT_SSH_KEYFUNCTION</i>. (Added in
7.19.6)</p>

<h2>OTHER OPTIONS
<a name="OTHER OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_PRIVATE</p>

<p style="margin-left:22%;">Pass a void * as parameter,
pointing to data that should be associated with this curl
handle. The pointer can subsequently be retrieved using
<i>curl_easy_getinfo(3)</i> with the CURLINFO_PRIVATE
option. libcurl itself does nothing with this data. (Added
in 7.10.3)</p>

<p style="margin-left:11%;">CURLOPT_SHARE</p>

<p style="margin-left:22%;">Pass a share handle as a
parameter. The share handle must have been created by a
previous call to <i>curl_share_init(3)</i>. Setting this
option, will make this curl handle use the data from the
shared handle instead of keeping the data to itself. This
enables several curl handles to share data. If the curl
handles are used simultaneously in multiple threads, you
<b>MUST</b> use the locking methods in the share handle. See
<i>curl_share_setopt(3)</i> for details.</p>

<p style="margin-left:22%; margin-top: 1em">If you add a
share that is set to share cookies, your easy handle will
use that cookie cache and get the cookie engine enabled. If
you unshare an object that was using cookies (or change to
another object that doesn&rsquo;t share cookies), the easy
handle will get its cookie engine disabled.</p>

<p style="margin-left:22%; margin-top: 1em">Data that the
share object is not set to share will be dealt with the
usual way, as if no share was used.</p>

<p style="margin-left:11%;">CURLOPT_NEW_FILE_PERMS</p>

<p style="margin-left:22%;">Pass a long as a parameter,
containing the value of the permissions that will be
assigned to newly created files on the remote server. The
default value is <i>0644</i>, but any valid value can be
used. The only protocols that can use this are
<i>sftp://</i>, <i>scp://</i>, and <i>file://</i>. (Added in
7.16.4)</p>


<p style="margin-left:11%;">CURLOPT_NEW_DIRECTORY_PERMS</p>

<p style="margin-left:22%;">Pass a long as a parameter,
containing the value of the permissions that will be
assigned to newly created directories on the remote server.
The default value is <i>0755</i>, but any valid value can be
used. The only protocols that can use this are
<i>sftp://</i>, <i>scp://</i>, and <i>file://</i>. (Added in
7.16.4)</p>

<h2>TELNET OPTIONS
<a name="TELNET OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">CURLOPT_TELNETOPTIONS</p>

<p style="margin-left:22%;">Provide a pointer to a
curl_slist with variables to pass to the telnet
negotiations. The variables should be in the format
&lt;option=value&gt;. libcurl supports the options
&rsquo;TTYPE&rsquo;, &rsquo;XDISPLOC&rsquo; and
&rsquo;NEW_ENV&rsquo;. See the TELNET standard for
details.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">CURLE_OK (zero)
means that the option was set properly, non-zero means an
error occurred as <i>&lt;curl/curl.h&gt;</i> defines. See
the <i>libcurl-errors(3)</i> man page for the full list with
descriptions.</p>

<p style="margin-left:11%; margin-top: 1em">If you try to
set an option that libcurl doesn&rsquo;t know about, perhaps
because the library is too old to support it or the option
was removed in a recent version, this function will return
<i>CURLE_FAILED_INIT</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>curl_easy_init</b>(3),
<b>curl_easy_cleanup</b>(3), <b>curl_easy_reset</b>(3)</p>
<hr>
</body>
</html>
