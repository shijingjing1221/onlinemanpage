<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:28:13 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STRUCT IEEE80211_OPS</title>

</head>
<body>

<h1 align="center">STRUCT IEEE80211_OPS</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#MEMBERS">MEMBERS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#POSSIBLE WITH A BUF_SIZE OF 8">POSSIBLE WITH A BUF_SIZE OF 8</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">struct_ieee80211_ops
&minus; callbacks from mac80211 to the driver</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">struct
ieee80211_ops { <br>
void (* tx) (struct ieee80211_hw *hw,struct
ieee80211_tx_control *control,struct sk_buff *skb); <br>
int (* start) (struct ieee80211_hw *hw); <br>
void (* stop) (struct ieee80211_hw *hw); <br>
#ifdef CONFIG_PM <br>
int (* suspend) (struct ieee80211_hw *hw, struct
cfg80211_wowlan *wowlan); <br>
int (* resume) (struct ieee80211_hw *hw); <br>
void (* set_wakeup) (struct ieee80211_hw *hw, bool enabled);
<br>
#endif <br>
int (* add_interface) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
int (* change_interface) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,enum nl80211_iftype new_type, bool p2p);
<br>
void (* remove_interface) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
int (* config) (struct ieee80211_hw *hw, u32 changed); <br>
void (* bss_info_changed) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_bss_conf *info,u32
changed); <br>
int (* start_ap) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
void (* stop_ap) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
u64 (* prepare_multicast) (struct ieee80211_hw *hw,struct
netdev_hw_addr_list *mc_list); <br>
void (* configure_filter) (struct ieee80211_hw *hw,unsigned
int changed_flags,unsigned int *total_flags,u64 multicast);
<br>
int (* set_tim) (struct ieee80211_hw *hw, struct
ieee80211_sta *sta,bool set); <br>
int (* set_key) (struct ieee80211_hw *hw, enum set_key_cmd
cmd,struct ieee80211_vif *vif, struct ieee80211_sta
*sta,struct ieee80211_key_conf *key); <br>
void (* update_tkip_key) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct
ieee80211_sta *sta,u32 iv32, u16 *phase1key); <br>
void (* set_rekey_data) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
<br>
void (* set_default_unicast_key) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif, int idx); <br>
int (* hw_scan) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,struct ieee80211_scan_request *req); <br>
void (* cancel_hw_scan) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
int (* sched_scan_start) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct cfg80211_sched_scan_request
*req,struct ieee80211_scan_ies *ies); <br>
int (* sched_scan_stop) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
void (* sw_scan_start) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,const u8 *mac_addr); <br>
void (* sw_scan_complete) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
int (* get_stats) (struct ieee80211_hw *hw,struct
ieee80211_low_level_stats *stats); <br>
void (* get_tkip_seq) (struct ieee80211_hw *hw, u8
hw_key_idx,u32 *iv32, u16 *iv16); <br>
int (* set_frag_threshold) (struct ieee80211_hw *hw, u32
value); <br>
int (* set_rts_threshold) (struct ieee80211_hw *hw, u32
value); <br>
int (* sta_add) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,struct ieee80211_sta *sta); <br>
int (* sta_remove) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,struct ieee80211_sta *sta); <br>
#ifdef CONFIG_MAC80211_DEBUGFS <br>
void (* sta_add_debugfs) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry
*dir); <br>
void (* sta_remove_debugfs) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry
*dir); <br>
#endif <br>
void (* sta_notify) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,enum sta_notify_cmd, struct ieee80211_sta
*sta); <br>
int (* sta_state) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,struct ieee80211_sta *sta,enum
ieee80211_sta_state old_state,enum ieee80211_sta_state
new_state); <br>
void (* sta_pre_rcu_remove) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta); <br>
void (* sta_rc_update) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta,u32 changed);
<br>
void (* sta_rate_tbl_update) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta); <br>
void (* sta_statistics) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta,struct
station_info *sinfo); <br>
int (* conf_tx) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif, u16 ac,const struct
ieee80211_tx_queue_params *params); <br>
u64 (* get_tsf) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
void (* set_tsf) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,u64 tsf); <br>
void (* reset_tsf) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
int (* tx_last_beacon) (struct ieee80211_hw *hw); <br>
int (* ampdu_action) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,enum ieee80211_ampdu_mlme_action
action,struct ieee80211_sta *sta, u16 tid, u16 *ssn,u8
buf_size); <br>
int (* get_survey) (struct ieee80211_hw *hw, int idx,struct
survey_info *survey); <br>
void (* rfkill_poll) (struct ieee80211_hw *hw); <br>
void (* set_coverage_class) (struct ieee80211_hw *hw, s16
coverage_class); <br>
#ifdef CONFIG_NL80211_TESTMODE <br>
int (* testmode_cmd) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,void *data, int len); <br>
int (* testmode_dump) (struct ieee80211_hw *hw, struct
sk_buff *skb,struct netlink_callback *cb,void *data, int
len); <br>
#endif <br>
void (* flush) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,u32 queues, bool drop); <br>
void (* channel_switch) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_channel_switch
*ch_switch); <br>
int (* set_antenna) (struct ieee80211_hw *hw, u32 tx_ant,
u32 rx_ant); <br>
int (* get_antenna) (struct ieee80211_hw *hw, u32 *tx_ant,
u32 *rx_ant); <br>
int (* remain_on_channel) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_channel *chan,int
duration,enum ieee80211_roc_type type); <br>
int (* cancel_remain_on_channel) (struct ieee80211_hw *hw);
<br>
int (* set_ringparam) (struct ieee80211_hw *hw, u32 tx, u32
rx); <br>
void (* get_ringparam) (struct ieee80211_hw *hw,u32 *tx, u32
*tx_max, u32 *rx, u32 *rx_max); <br>
bool (* tx_frames_pending) (struct ieee80211_hw *hw); <br>
int (* set_bitrate_mask) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,const struct cfg80211_bitrate_mask
*mask); <br>
void (* event_callback) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,const struct ieee80211_event *event);
<br>
void (* allow_buffered_frames) (struct ieee80211_hw
*hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum
ieee80211_frame_release_type reason,bool more_data); <br>
void (* release_buffered_frames) (struct ieee80211_hw
*hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum
ieee80211_frame_release_type reason,bool more_data); <br>
int (* get_et_sset_count) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif, int sset); <br>
void (* get_et_stats) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ethtool_stats *stats, u64 *data);
<br>
void (* get_et_strings) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,u32 sset, u8 *data); <br>
void (* mgd_prepare_tx) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
void (* mgd_protect_tdls_discover) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif); <br>
int (* add_chanctx) (struct ieee80211_hw *hw,struct
ieee80211_chanctx_conf *ctx); <br>
void (* remove_chanctx) (struct ieee80211_hw *hw,struct
ieee80211_chanctx_conf *ctx); <br>
void (* change_chanctx) (struct ieee80211_hw *hw,struct
ieee80211_chanctx_conf *ctx,u32 changed); <br>
int (* assign_vif_chanctx) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx); <br>
void (* unassign_vif_chanctx) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf
*ctx); <br>
int (* switch_vif_chanctx) (struct ieee80211_hw *hw,struct
ieee80211_vif_chanctx_switch *vifs,int n_vifs,enum
ieee80211_chanctx_switch_mode mode); <br>
void (* reconfig_complete) (struct ieee80211_hw *hw,enum
ieee80211_reconfig_type reconfig_type); <br>
#if IS_ENABLED(CONFIG_IPV6) <br>
void (* ipv6_addr_change) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct inet6_dev *idev); <br>
#endif <br>
void (* channel_switch_beacon) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif,struct cfg80211_chan_def
*chandef); <br>
int (* pre_channel_switch) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_channel_switch
*ch_switch); <br>
int (* post_channel_switch) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif); <br>
int (* join_ibss) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
void (* leave_ibss) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif); <br>
u32 (* get_expected_throughput) (struct ieee80211_sta *sta);
<br>
int (* get_txpower) (struct ieee80211_hw *hw, struct
ieee80211_vif *vif,int *dbm); <br>
int (* tdls_channel_switch) (struct ieee80211_hw *hw,struct
ieee80211_vif *vif,struct ieee80211_sta *sta, u8
oper_class,struct cfg80211_chan_def *chandef,struct sk_buff
*tmpl_skb, u32 ch_sw_tm_ie); <br>
void (* tdls_cancel_channel_switch) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta);
<br>
void (* tdls_recv_channel_switch) (struct ieee80211_hw
*hw,struct ieee80211_vif *vif,struct
ieee80211_tdls_ch_sw_params *params); <br>
void (* wake_tx_queue) (struct ieee80211_hw *hw,struct
ieee80211_txq *txq); <br>
};</p>

<h2>MEMBERS
<a name="MEMBERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">tx</p>

<p style="margin-left:17%;">Handler that 802.11 module
calls for each transmitted frame. skb contains the buffer
starting from the IEEE 802.11 header. The low&minus;level
driver should send the frame out based on configuration in
the TX control data. This handler should, preferably, never
fail and stop queues appropriately. Must be atomic.</p>

<p style="margin-left:11%; margin-top: 1em">start</p>

<p style="margin-left:17%;">Called before the first
netdevice attached to the hardware is enabled. This should
turn on the hardware and must turn on frame reception (for
possibly enabled monitor interfaces.) Returns negative error
codes, these may be seen in userspace, or zero. When the
device is started it should not have a MAC address to avoid
acknowledging frames before a non&minus;monitor device is
added. Must be implemented and can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">stop</p>

<p style="margin-left:17%;">Called after last netdevice
attached to the hardware is disabled. This should turn off
the hardware (at least it must turn off frame reception.)
May be called right after add_interface if that rejects an
interface. If you added any work onto the mac80211 workqueue
you should ensure to cancel it on this callback. Must be
implemented and can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">suspend</p>

<p style="margin-left:17%;">Suspend the device; mac80211
itself will quiesce before and stop transmitting and doing
any other configuration, and then ask the device to suspend.
This is only invoked when WoWLAN is configured, otherwise
the device is deconfigured completely and reconfigured at
resume time. The driver may also impose special conditions
under which it wants to use the &ldquo;normal&rdquo; suspend
(deconfigure), say if it only supports WoWLAN when the
device is associated. In this case, it must return 1 from
this function.</p>

<p style="margin-left:11%; margin-top: 1em">resume</p>

<p style="margin-left:17%;">If WoWLAN was configured, this
indicates that mac80211 is now resuming its operation, after
this the device must be fully functional again. If this
returns an error, the only way out is to also unregister the
device. If it returns 1, then mac80211 will also go through
the regular complete restart on resume.</p>

<p style="margin-left:11%; margin-top: 1em">set_wakeup</p>

<p style="margin-left:17%;">Enable or disable wakeup when
WoWLAN configuration is modified. The reason is that
<b>device_set_wakeup_enable</b> is supposed to be called
when the configuration changes, not only in
<b>suspend</b>.</p>


<p style="margin-left:11%; margin-top: 1em">add_interface</p>

<p style="margin-left:17%;">Called when a netdevice
attached to the hardware is enabled. Because it is not
called for monitor mode devices, <i>start</i> and
<i>stop</i> must be implemented. The driver should perform
any initialization it needs before the device can be
enabled. The initial configuration for the interface is
given in the conf parameter. The callback may refuse to add
an interface by returning a negative error code (which will
be seen in userspace.) Must be implemented and can
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">change_interface</p>

<p style="margin-left:17%;">Called when a netdevice changes
type. This callback is optional, but only if it is supported
can interface types be switched while the interface is UP.
The callback may sleep. Note that while an interface is
being switched, it will not be found by the interface
iteration callbacks.</p>


<p style="margin-left:11%; margin-top: 1em">remove_interface</p>

<p style="margin-left:17%;">Notifies a driver that an
interface is going down. The <i>stop</i> callback is called
after this if it is the last interface and no monitor
interfaces are present. When all interfaces are removed, the
MAC address in the hardware must be cleared so the device no
longer acknowledges packets, the mac_addr member of the conf
structure is, however, set to the MAC address of the device
going away. Hence, this callback must be implemented. It can
sleep.</p>

<p style="margin-left:11%; margin-top: 1em">config</p>

<p style="margin-left:17%;">Handler for configuration
requests. IEEE 802.11 code calls this function to change
hardware configuration, e.g., channel. This function should
never fail but returns a negative error code if it does. The
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">bss_info_changed</p>

<p style="margin-left:17%;">Handler for configuration
requests related to BSS parameters that may vary during
BSS's lifespan, and may affect low level driver (e.g.
assoc/disassoc status, erp parameters). This function should
not be used if no BSS has been set, unless for association
indication. The <i>changed</i> parameter indicates which of
the bss parameters has changed when a call is made. The
callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">start_ap</p>

<p style="margin-left:17%;">Start operation on the AP
interface, this is called after all the information in
bss_conf is set and beacon can be retrieved. A channel
context is bound before this is called. Note that if the
driver uses software scan or ROC, this (and <i>stop_ap</i>)
isn't called when the AP is just &ldquo;paused&rdquo; for
scanning/ROC, which is indicated by the beacon being
disabled/enabled via <i>bss_info_changed</i>.</p>

<p style="margin-left:11%; margin-top: 1em">stop_ap</p>

<p style="margin-left:17%;">Stop operation on the AP
interface.</p>


<p style="margin-left:11%; margin-top: 1em">prepare_multicast</p>

<p style="margin-left:17%;">Prepare for multicast filter
configuration. This callback is optional, and its return
value is passed to <b>configure_filter</b>. This callback
must be atomic.</p>


<p style="margin-left:11%; margin-top: 1em">configure_filter</p>

<p style="margin-left:17%;">Configure the device's RX
filter. See the section &ldquo;Frame filtering&rdquo; for
more information. This callback must be implemented and can
sleep.</p>

<p style="margin-left:11%; margin-top: 1em">set_tim</p>

<p style="margin-left:17%;">Set TIM bit. mac80211 calls
this function when a TIM bit must be set or cleared for a
given STA. Must be atomic.</p>

<p style="margin-left:11%; margin-top: 1em">set_key</p>

<p style="margin-left:17%;">See the section &ldquo;Hardware
crypto acceleration&rdquo; This callback is only called
between add_interface and remove_interface calls, i.e. while
the given virtual interface is enabled. Returns a negative
error code if the key can't be added. The callback can
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">update_tkip_key</p>

<p style="margin-left:17%;">See the section &ldquo;Hardware
crypto acceleration&rdquo; This callback will be called in
the context of Rx. Called for drivers which set
IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY. The callback must be
atomic.</p>


<p style="margin-left:11%; margin-top: 1em">set_rekey_data</p>

<p style="margin-left:17%;">If the device supports GTK
rekeying, for example while the host is suspended, it can
assign this callback to retrieve the data necessary to do
GTK rekeying, this is the KEK, KCK and replay counter. After
rekeying was done it should (for example during resume)
notify userspace of the new replay counter using
<b>ieee80211_gtk_rekey_notify</b>.</p>


<p style="margin-left:11%; margin-top: 1em">set_default_unicast_key</p>

<p style="margin-left:17%;">Set the default (unicast) key
index, useful for WEP when the device sends data packets
autonomously, e.g. for ARP offloading. The index can be
0&minus;3, or &minus;1 for unsetting it.</p>

<p style="margin-left:11%; margin-top: 1em">hw_scan</p>

<p style="margin-left:17%;">Ask the hardware to service the
scan request, no need to start the scan state machine in
stack. The scan must honour the channel configuration done
by the regulatory agent in the wiphy's registered bands. The
hardware (or the driver) needs to make sure that power save
is disabled. The <i>req</i> ie/ie_len members are rewritten
by mac80211 to contain the entire IEs after the SSID, so
that drivers need not look at these at all but just send
them after the SSID &minus;&minus; mac80211 includes the
(extended) supported rates and HT information (where
applicable). When the scan finishes,
<b>ieee80211_scan_completed</b> must be called; note that it
also must be called when the scan cannot finish due to any
error unless this callback returned a negative error code.
The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">cancel_hw_scan</p>

<p style="margin-left:17%;">Ask the low&minus;level tp
cancel the active hw scan. The driver should ask the
hardware to cancel the scan (if possible), but the scan will
be completed only after the driver will call
<b>ieee80211_scan_completed</b>. This callback is needed for
wowlan, to prevent enqueueing a new scan_work after the
low&minus;level driver was already suspended. The callback
can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sched_scan_start</p>

<p style="margin-left:17%;">Ask the hardware to start
scanning repeatedly at specific intervals. The driver must
call the <b>ieee80211_sched_scan_results</b> function
whenever it finds results. This process will continue until
sched_scan_stop is called.</p>


<p style="margin-left:11%; margin-top: 1em">sched_scan_stop</p>

<p style="margin-left:17%;">Tell the hardware to stop an
ongoing scheduled scan. In this case,
<b>ieee80211_sched_scan_stopped</b> must not be called.</p>


<p style="margin-left:11%; margin-top: 1em">sw_scan_start</p>

<p style="margin-left:17%;">Notifier function that is
called just before a software scan is started. Can be NULL,
if the driver doesn't need this notification. The mac_addr
parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,
the driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR
flag if it can use this parameter. The callback can
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sw_scan_complete</p>

<p style="margin-left:17%;">Notifier function that is
called just after a software scan finished. Can be NULL, if
the driver doesn't need this notification. The callback can
sleep.</p>

<p style="margin-left:11%; margin-top: 1em">get_stats</p>

<p style="margin-left:17%;">Return low&minus;level
statistics. Returns zero if statistics are available. The
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">get_tkip_seq</p>

<p style="margin-left:17%;">If your device implements TKIP
encryption in hardware this callback should be provided to
read the TKIP transmit IVs (both IV32 and IV16) for the
given key from hardware. The callback must be atomic.</p>


<p style="margin-left:11%; margin-top: 1em">set_frag_threshold</p>

<p style="margin-left:17%;">Configuration of fragmentation
threshold. Assign this if the device does fragmentation by
itself; if this callback is implemented then the stack will
not do fragmentation. The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">set_rts_threshold</p>

<p style="margin-left:17%;">Configuration of RTS threshold
(if device needs it) The callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">sta_add</p>

<p style="margin-left:17%;">Notifies low level driver about
addition of an associated station, AP, IBSS/WDS/mesh peer
etc. This callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">sta_remove</p>

<p style="margin-left:17%;">Notifies low level driver about
removal of an associated station, AP, IBSS/WDS/mesh peer
etc. Note that after the callback returns it isn't safe to
use the pointer, not even RCU protected; no RCU grace period
is guaranteed between returning here and freeing the
station. See <i>sta_pre_rcu_remove</i> if needed. This
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sta_add_debugfs</p>

<p style="margin-left:17%;">Drivers can use this callback
to add debugfs files when a station is added to mac80211's
station list. This callback and <i>sta_remove_debugfs</i>
should be within a CONFIG_MAC80211_DEBUGFS conditional. This
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sta_remove_debugfs</p>

<p style="margin-left:17%;">Remove the debugfs files which
were added using <i>sta_add_debugfs</i>. This callback can
sleep.</p>

<p style="margin-left:11%; margin-top: 1em">sta_notify</p>

<p style="margin-left:17%;">Notifies low level driver about
power state transition of an associated station, AP,
IBSS/WDS/mesh peer etc. For a VIF operating in AP mode, this
callback will not be called when the flag
<b>IEEE80211_HW_AP_LINK_PS</b> is set. Must be atomic.</p>

<p style="margin-left:11%; margin-top: 1em">sta_state</p>

<p style="margin-left:17%;">Notifies low level driver about
state transition of a station (which can be the AP, a
client, IBSS/WDS/mesh peer etc.) This callback is mutually
exclusive with <i>sta_add</i>/<i>sta_remove</i>. It must not
fail for down transitions but may fail for transitions up
the list of states. Also note that after the callback
returns it isn't safe to use the pointer, not even RCU
protected &minus; no RCU grace period is guaranteed between
returning here and freeing the station. See
<i>sta_pre_rcu_remove</i> if needed. The callback can
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sta_pre_rcu_remove</p>

<p style="margin-left:17%;">Notify driver about station
removal before RCU synchronisation. This is useful if a
driver needs to have station pointers protected using RCU,
it can then use this call to clear the pointers instead of
waiting for an RCU grace period to elapse in
<i>sta_state</i>. The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">sta_rc_update</p>

<p style="margin-left:17%;">Notifies the driver of changes
to the bitrates that can be used to transmit to the station.
The changes are advertised with bits from enum
ieee80211_rate_control_changed and the values are reflected
in the station data. This callback should only be used when
the driver uses hardware rate control
(<b>IEEE80211_HW_HAS_RATE_CONTROL</b>) since otherwise the
rate control algorithm is notified directly. Must be
atomic.</p>


<p style="margin-left:11%; margin-top: 1em">sta_rate_tbl_update</p>

<p style="margin-left:17%;">Notifies the driver that the
rate table changed. This is only used if the configured rate
control algorithm actually uses the new rate table API, and
is therefore optional. Must be atomic.</p>


<p style="margin-left:11%; margin-top: 1em">sta_statistics</p>

<p style="margin-left:17%;">Get statistics for this
station. For example with beacon filtering, the statistics
kept by mac80211 might not be accurate, so let the driver
pre&minus;fill the statistics. The driver can fill most of
the values (indicating which by setting the filled bitmap),
but not all of them make sense &minus; see the source for
which ones are possible. Statistics that the driver doesn't
fill will be filled by mac80211. The callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">conf_tx</p>

<p style="margin-left:17%;">Configure TX queue parameters
(EDCF (aifs, cw_min, cw_max), bursting) for a hardware TX
queue. Returns a negative error code on failure. The
callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">get_tsf</p>

<p style="margin-left:17%;">Get the current TSF timer value
from firmware/hardware. Currently, this is only used for
IBSS mode BSSID merging and debugging. Is not a required
function. The callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">set_tsf</p>

<p style="margin-left:17%;">Set the TSF timer to the
specified value in the firmware/hardware. Currently, this is
only used for IBSS mode debugging. Is not a required
function. The callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">reset_tsf</p>

<p style="margin-left:17%;">Reset the TSF timer and allow
firmware/hardware to synchronize with other STAs in the
IBSS. This is only used in IBSS mode. This function is
optional if the firmware/hardware takes full care of TSF
synchronization. The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">tx_last_beacon</p>

<p style="margin-left:17%;">Determine whether the last IBSS
beacon was sent by us. This is needed only for IBSS mode and
the result of this function is used to determine whether to
reply to Probe Requests. Returns non&minus;zero if this
device sent the last beacon. The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">ampdu_action</p>

<p style="margin-left:17%;">Perform a certain A&minus;MPDU
action The RA/TID combination determines the destination and
TID we want the ampdu action to be performed for. The action
is defined through ieee80211_ampdu_mlme_action. Starting
sequence number (<i>ssn</i>) is the first frame we expect to
perform the action on. Notice that TX/RX_STOP can pass NULL
for this parameter. The <i>buf_size</i> parameter is only
valid when the action is set to
<b>IEEE80211_AMPDU_TX_OPERATIONAL</b> and indicates the
peer's reorder buffer size (number of subframes) for this
session &minus;&minus; the driver may neither send
aggregates containing more subframes than this nor send
aggregates in a way that lost frames would exceed the buffer
size. If just limiting the aggregate size, this would be</p>

<p style="margin-left:11%; margin-top: 1em">get_survey</p>

<p style="margin-left:17%;">Return per&minus;channel survey
information</p>


<p style="margin-left:11%; margin-top: 1em">rfkill_poll</p>

<p style="margin-left:17%;">Poll rfkill hardware state. If
you need this, you also need to set
wiphy&minus;&gt;rfkill_poll to <b>true</b> before
registration, and need to call
<b>wiphy_rfkill_set_hw_state</b> in the callback. The
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">set_coverage_class</p>

<p style="margin-left:17%;">Set slot time for given
coverage class as specified in IEEE 802.11&minus;2007
section 17.3.8.6 and modify ACK timeout accordingly;
coverage class equals to &minus;1 to enable ACK timeout
estimation algorithm (dynack). To disable dynack set valid
value for coverage class. This callback is not required and
may sleep.</p>


<p style="margin-left:11%; margin-top: 1em">testmode_cmd</p>

<p style="margin-left:17%;">Implement a cfg80211 test mode
command. The passed <i>vif</i> may be <b>NULL</b>. The
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">testmode_dump</p>

<p style="margin-left:17%;">Implement a cfg80211 test mode
dump. The callback can sleep.</p>

<p style="margin-left:11%; margin-top: 1em">flush</p>

<p style="margin-left:17%;">Flush all pending frames from
the hardware queue, making sure that the hardware queues are
empty. The <i>queues</i> parameter is a bitmap of queues to
flush, which is useful if different virtual interfaces use
different hardware queues; it may also indicate all queues.
If the parameter <i>drop</i> is set to <b>true</b>, pending
frames may be dropped. Note that vif can be NULL. The
callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">channel_switch</p>

<p style="margin-left:17%;">Drivers that need (or want) to
offload the channel switch operation for CSAs received from
the AP may implement this callback. They must then call
<b>ieee80211_chswitch_done</b> to indicate completion of the
channel switch.</p>


<p style="margin-left:11%; margin-top: 1em">set_antenna</p>

<p style="margin-left:17%;">Set antenna configuration
(tx_ant, rx_ant) on the device. Parameters are bitmaps of
allowed antennas to use for TX/RX. Drivers may reject TX/RX
mask combinations they cannot support by returning
&minus;EINVAL (also see nl80211.h
<i>NL80211_ATTR_WIPHY_ANTENNA_TX</i>).</p>


<p style="margin-left:11%; margin-top: 1em">get_antenna</p>

<p style="margin-left:17%;">Get current antenna
configuration from device (tx_ant, rx_ant).</p>


<p style="margin-left:11%; margin-top: 1em">remain_on_channel</p>

<p style="margin-left:17%;">Starts an off&minus;channel
period on the given channel, must call back to
<b>ieee80211_ready_on_channel</b> when on that channel. Note
that normal channel traffic is not stopped as this is
intended for hw offload. Frames to transmit on the
off&minus;channel channel are transmitted normally except
for the <b>IEEE80211_TX_CTL_TX_OFFCHAN</b> flag. When the
duration (which will always be non&minus;zero) expires, the
driver must call <b>ieee80211_remain_on_channel_expired</b>.
Note that this callback may be called while the device is in
IDLE and must be accepted in this case. This callback may
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">cancel_remain_on_channel</p>

<p style="margin-left:17%;">Requests that an ongoing
off&minus;channel period is aborted before it expires. This
callback may sleep.</p>


<p style="margin-left:11%; margin-top: 1em">set_ringparam</p>

<p style="margin-left:17%;">Set tx and rx ring sizes.</p>


<p style="margin-left:11%; margin-top: 1em">get_ringparam</p>

<p style="margin-left:17%;">Get tx and rx ring current and
maximum sizes.</p>


<p style="margin-left:11%; margin-top: 1em">tx_frames_pending</p>

<p style="margin-left:17%;">Check if there is any pending
frame in the hardware queues before entering power save.</p>


<p style="margin-left:11%; margin-top: 1em">set_bitrate_mask</p>

<p style="margin-left:17%;">Set a mask of rates to be used
for rate control selection when transmitting a frame.
Currently only legacy rates are handled. The callback can
sleep.</p>


<p style="margin-left:11%; margin-top: 1em">event_callback</p>

<p style="margin-left:17%;">Notify driver about any event
in mac80211. See enum ieee80211_event_type for the different
types. The callback can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">allow_buffered_frames</p>

<p style="margin-left:17%;">Prepare device to allow the
given number of frames to go out to the given station. The
frames will be sent by mac80211 via the usual TX path after
this call. The TX information for frames released will also
have the <b>IEEE80211_TX_CTL_NO_PS_BUFFER</b> flag set and
the last one will also have <b>IEEE80211_TX_STATUS_EOSP</b>
set. In case frames from multiple TIDs are released and the
driver might reorder them between the TIDs, it must set the
<b>IEEE80211_TX_STATUS_EOSP</b> flag on the last frame and
clear it on all others and also handle the EOSP bit in the
QoS header correctly. Alternatively, it can also call the
<b>ieee80211_sta_eosp</b> function. The <i>tids</i>
parameter is a bitmap and tells the driver which TIDs the
frames will be on; it will at most have two bits set. This
callback must be atomic.</p>


<p style="margin-left:11%; margin-top: 1em">release_buffered_frames</p>

<p style="margin-left:17%;">Release buffered frames
according to the given parameters. In the case where the
driver buffers some frames for sleeping stations mac80211
will use this callback to tell the driver to release some
frames, either for PS&minus;poll or uAPSD. Note that if the
<i>more_data</i> parameter is <b>false</b> the driver must
check if there are more frames on the given TIDs, and if
there are more than the frames being released then it must
still set the more&minus;data bit in the frame. If the
<i>more_data</i> parameter is <b>true</b>, then of course
the more&minus;data bit must always be set. The <i>tids</i>
parameter tells the driver which TIDs to release frames
from, for PS&minus;poll it will always have only a single
bit set. In the case this is used for a PS&minus;poll
initiated release, the <i>num_frames</i> parameter will
always be 1 so code can be shared. In this case the driver
must also set <b>IEEE80211_TX_STATUS_EOSP</b> flag on the TX
status (and must report TX status) so that the PS&minus;poll
period is properly ended. This is used to avoid sending
multiple responses for a retried PS&minus;poll frame. In the
case this is used for uAPSD, the <i>num_frames</i> parameter
may be bigger than one, but the driver may send fewer frames
(it must send at least one, however). In this case it is
also responsible for setting the EOSP flag in the QoS header
of the frames. Also, when the service period ends, the
driver must set <b>IEEE80211_TX_STATUS_EOSP</b> on the last
frame in the SP. Alternatively, it may call the function
<b>ieee80211_sta_eosp</b> to inform mac80211 of the end of
the SP. This callback must be atomic.</p>


<p style="margin-left:11%; margin-top: 1em">get_et_sset_count</p>

<p style="margin-left:17%;">Ethtool API to get
string&minus;set count.</p>


<p style="margin-left:11%; margin-top: 1em">get_et_stats</p>

<p style="margin-left:17%;">Ethtool API to get a set of u64
stats.</p>


<p style="margin-left:11%; margin-top: 1em">get_et_strings</p>

<p style="margin-left:17%;">Ethtool API to get a set of
strings to describe stats and perhaps other supported types
of ethtool data&minus;sets.</p>


<p style="margin-left:11%; margin-top: 1em">mgd_prepare_tx</p>

<p style="margin-left:17%;">Prepare for transmitting a
management frame for association before associated. In
multi&minus;channel scenarios, a virtual interface is bound
to a channel before it is associated, but as it isn't
associated yet it need not necessarily be given airtime, in
particular since any transmission to a P2P GO needs to be
synchronized against the GO's powersave state. mac80211 will
call this function before transmitting a management frame
prior to having successfully associated to allow the driver
to give it channel time for the transmission, to get a
response and to be able to synchronize with the GO. The
callback will be called before each transmission and upon
return mac80211 will transmit the frame right away. The
callback is optional and can (should!) sleep.</p>


<p style="margin-left:11%; margin-top: 1em">mgd_protect_tdls_discover</p>

<p style="margin-left:17%;">Protect a TDLS discovery
session. After sending a TDLS discovery&minus;request, we
expect a reply to arrive on the AP's channel. We must stay
on the channel (no PSM, scan, etc.), since a TDLS
setup&minus;response is a direct packet not buffered by the
AP. mac80211 will call this function just before the
transmission of a TDLS discovery&minus;request. The
recommended period of protection is at least 2 * (DTIM
period). The callback is optional and can sleep.</p>


<p style="margin-left:11%; margin-top: 1em">add_chanctx</p>

<p style="margin-left:17%;">Notifies device driver about
new channel context creation.</p>


<p style="margin-left:11%; margin-top: 1em">remove_chanctx</p>

<p style="margin-left:17%;">Notifies device driver about
channel context destruction.</p>


<p style="margin-left:11%; margin-top: 1em">change_chanctx</p>

<p style="margin-left:17%;">Notifies device driver about
channel context changes that may happen when combining
different virtual interfaces on the same channel context
with different settings</p>


<p style="margin-left:11%; margin-top: 1em">assign_vif_chanctx</p>

<p style="margin-left:17%;">Notifies device driver about
channel context being bound to vif. Possible use is for hw
queue remapping.</p>


<p style="margin-left:11%; margin-top: 1em">unassign_vif_chanctx</p>

<p style="margin-left:17%;">Notifies device driver about
channel context being unbound from vif.</p>


<p style="margin-left:11%; margin-top: 1em">switch_vif_chanctx</p>

<p style="margin-left:17%;">switch a number of vifs from
one chanctx to another, as specified in the list of
<i>ieee80211_vif_chanctx_switch</i> passed to the driver,
according to the mode defined in
ieee80211_chanctx_switch_mode.</p>


<p style="margin-left:11%; margin-top: 1em">reconfig_complete</p>

<p style="margin-left:17%;">Called after a call to
<b>ieee80211_restart_hw</b> and during resume, when the
reconfiguration has completed. This can help the driver
implement the reconfiguration step (and indicate mac80211 is
ready to receive frames). This callback may sleep.</p>


<p style="margin-left:11%; margin-top: 1em">ipv6_addr_change</p>

<p style="margin-left:17%;">IPv6 address assignment on the
given interface changed. Currently, this is only called for
managed or P2P client interfaces. This callback is optional;
it must not sleep.</p>


<p style="margin-left:11%; margin-top: 1em">channel_switch_beacon</p>

<p style="margin-left:17%;">Starts a channel switch to a
new channel. Beacons are modified to include CSA or ECSA IEs
before calling this function. The corresponding count fields
in these IEs must be decremented, and when they reach 1 the
driver must call <b>ieee80211_csa_finish</b>. Drivers which
use <b>ieee80211_beacon_get</b> get the csa counter
decremented by mac80211, but must check if it is 1 using
<b>ieee80211_csa_is_complete</b> after the beacon has been
transmitted and then call <b>ieee80211_csa_finish</b>. If
the CSA count starts as zero or 1, this function will not be
called, since there won't be any time to beacon before the
switch anyway.</p>


<p style="margin-left:11%; margin-top: 1em">pre_channel_switch</p>

<p style="margin-left:17%;">This is an optional callback
that is called before a channel switch procedure is started
(ie. when a STA gets a CSA or an userspace initiated
channel&minus;switch), allowing the driver to prepare for
the channel switch.</p>


<p style="margin-left:11%; margin-top: 1em">post_channel_switch</p>

<p style="margin-left:17%;">This is an optional callback
that is called after a channel switch procedure is
completed, allowing the driver to go back to a normal
configuration.</p>

<p style="margin-left:11%; margin-top: 1em">join_ibss</p>

<p style="margin-left:17%;">Join an IBSS (on an IBSS
interface); this is called after all information in bss_conf
is set up and the beacon can be retrieved. A channel context
is bound before this is called.</p>

<p style="margin-left:11%; margin-top: 1em">leave_ibss</p>

<p style="margin-left:17%;">Leave the IBSS again.</p>


<p style="margin-left:11%; margin-top: 1em">get_expected_throughput</p>

<p style="margin-left:17%;">extract the expected throughput
towards the specified station. The returned value is
expressed in Kbps. It returns 0 if the RC algorithm does not
have proper data to provide.</p>


<p style="margin-left:11%; margin-top: 1em">get_txpower</p>

<p style="margin-left:17%;">get current maximum tx power
(in dBm) based on configuration and hardware limits.</p>


<p style="margin-left:11%; margin-top: 1em">tdls_channel_switch</p>

<p style="margin-left:17%;">Start channel&minus;switching
with a TDLS peer. The driver is responsible for continually
initiating channel&minus;switching operations and returning
to the base channel for communication with the AP. The
driver receives a channel&minus;switch request template and
the location of the switch&minus;timing IE within the
template as part of the invocation. The template is valid
only within the call, and the driver can optionally copy the
skb for further re&minus;use.</p>


<p style="margin-left:11%; margin-top: 1em">tdls_cancel_channel_switch</p>

<p style="margin-left:17%;">Stop channel&minus;switching
with a TDLS peer. Both peers must be on the base channel
when the call completes.</p>


<p style="margin-left:11%; margin-top: 1em">tdls_recv_channel_switch</p>

<p style="margin-left:17%;">a TDLS channel&minus;switch
related frame (request or response) has been received from a
remote peer. The driver gets parameters parsed from the
incoming frame and may use them to continue an ongoing
channel&minus;switch operation. In addition, a
channel&minus;switch response template is provided, together
with the location of the switch&minus;timing IE within the
template. The skb can only be used within the function
call.</p>


<p style="margin-left:11%; margin-top: 1em">wake_tx_queue</p>

<p style="margin-left:17%;">Called when new packets have
been added to the queue.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This structure
contains various callbacks that the driver may handle or, in
some cases, must handle, for example to configure the
hardware to a new channel or to transmit a frame.</p>

<h2>POSSIBLE WITH A BUF_SIZE OF 8
<a name="POSSIBLE WITH A BUF_SIZE OF 8"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&minus; TX:
1.....7 &minus; RX: 2....7 (lost frame #1) &minus; TX:
8..1... which is invalid since #1 was now
re&minus;transmitted well past the buffer size of 8. Correct
ways to retransmit #1 would be: &minus; TX: 1 or 18 or 81
Even &ldquo;189&rdquo; would be wrong since 1 could be lost
again.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
negative error code on failure. The callback can sleep.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Johannes
Berg</b> &lt;johannes@sipsolutions.net&gt;</p>

<p style="margin-left:17%;">Author.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<hr>
</body>
</html>
