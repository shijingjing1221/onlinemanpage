<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:37:22 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>virt-v2v</title>

</head>
<body>

<h1 align="center">virt-v2v</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INPUT AND OUTPUT MODES">INPUT AND OUTPUT MODES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#XEN PARAVIRTUALIZED GUESTS">XEN PARAVIRTUALIZED GUESTS</a><br>
<a href="#ENABLING VIRTIO">ENABLING VIRTIO</a><br>
<a href="#RHEL 4">RHEL 4</a><br>
<a href="#WINDOWS">WINDOWS</a><br>
<a href="#UEFI">UEFI</a><br>
<a href="#NETWORKS AND BRIDGES">NETWORKS AND BRIDGES</a><br>
<a href="#INPUT FROM VMWARE VCENTER SERVER">INPUT FROM VMWARE VCENTER SERVER</a><br>
<a href="#INPUT FROM VMWARE OVA">INPUT FROM VMWARE OVA</a><br>
<a href="#INPUT FROM RHEL 5 XEN">INPUT FROM RHEL 5 XEN</a><br>
<a href="#OUTPUT TO LIBVIRT">OUTPUT TO LIBVIRT</a><br>
<a href="#OUTPUT TO RHEV">OUTPUT TO RHEV</a><br>
<a href="#RESOURCE REQUIREMENTS">RESOURCE REQUIREMENTS</a><br>
<a href="#POST-CONVERSION TASKS">POST-CONVERSION TASKS</a><br>
<a href="#FREE SPACE FOR CONVERSION">FREE SPACE FOR CONVERSION</a><br>
<a href="#RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT">RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT</a><br>
<a href="#DEBUGGING RHEV-M IMPORT FAILURES">DEBUGGING RHEV-M IMPORT FAILURES</a><br>
<a href="#MINIMAL XML FOR &minus;i libvirtxml OPTION">MINIMAL XML FOR &minus;i libvirtxml OPTION</a><br>
<a href="#MACHINE READABLE OUTPUT">MACHINE READABLE OUTPUT</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">virt&minus;v2v
&minus; Convert a guest to use KVM</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi esx_guest
 virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi esx_guest \
   &minus;o rhev &minus;os rhev.nfs:/export_domain &minus;&minus;network rhevm
 virt&minus;v2v &minus;i libvirtxml guest&minus;domain.xml &minus;o local &minus;os /var/tmp
 virt&minus;v2v &minus;i disk disk.img &minus;o local &minus;os /var/tmp
 virt&minus;v2v &minus;i disk disk.img &minus;o glance</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
converts guests from a foreign hypervisor to run on
<small>KVM,</small> managed by libvirt, OpenStack, oVirt,
Red Hat Enterprise Virtualisation ( <small>RHEV</small> ) or
several other targets. It can currently convert Red Hat
Enterprise Linux and Windows guests running on Xen and
VMware <small>ESX.</small></p>

<p style="margin-left:11%; margin-top: 1em">There is also a
companion front-end called <i>virt&minus;p2v</i>(1) which
comes as an <small>ISO</small> or <small>CD</small> image
that can be booted on physical machines.</p>

<p style="margin-left:11%; margin-top: 1em">This manual
page documents the rewritten virt&minus;v2v included in
libguestfs &ge; 1.28.</p>

<h2>INPUT AND OUTPUT MODES
<a name="INPUT AND OUTPUT MODES"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">                         &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;  &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o null
 &minus;i disk &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;    &#9474;            &#9474; &#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o local
 &minus;i ova  &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9492;&#9472;&#9472;&#9654; &#9474; virt&minus;v2v   &#9474; &#9472;&#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o qemu
                  &#9492;&#9472;&#9472;&#9472;&#9472;&#9654; &#9474; conversion &#9474; &#9472;&#9472;&#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
 ESX &#9472;&#9472;&#9654;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;   &#9474; server     &#9474; &#9472;&#9472;&#9472;&#9472;&#9654; &minus;o libvirt &#9474;&#9472;&#9654; KVM
 Xen &#9472;&#9472;&#9654;&#9474; &minus;i libvirt &#9472;&#9472;&#9654; &#9474;            &#9474;     &#9474;  (default) &#9474;
 ... &#9472;&#9472;&#9654;&#9474;  (default) &#9474;   &#9474;            &#9474; &#9472;&#9472;&#9488; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;
        &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;   &#9474;            &#9474; &#9472;&#9488;&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o glance
 &minus;i libvirtxml &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &#9474;            &#9474; &#9488;&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o rhev
                         &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o vdsm</pre>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
has a number of possible input and output modes, selected
using the <i>&minus;i</i> and <i>&minus;o</i> options. Only
one input and output mode can be selected for each run of
virt&minus;v2v.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
libvirt</i> is used for reading from any libvirt source.
Since libvirt can connect to many different hypervisors, it
is used for reading guests from VMware <small>ESX, RHEL
5</small> Xen and more. The <i>&minus;ic</i> option selects
the precise libvirt source.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
disk</i> is used for reading from local disk images (mainly
for testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
ova</i> is used for reading from a VMware ova source
file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
libvirtxml</i> is used to read from libvirt
<small>XML</small> files. This is the method used by
<i>virt&minus;p2v</i>(1) behind the scenes.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
glance</i> is used for writing to OpenStack Glance.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
libvirt</i> is used for writing to any libvirt target.
Libvirt can connect to local or remote <small>KVM</small>
hypervisors. The <i>&minus;oc</i> option selects the precise
libvirt target.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
local</i> is used to write to a local disk image with a
local libvirt configuration file (mainly for testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
qemu</i> writes to a local disk image with a shell script
for booting the guest directly in qemu (mainly for
testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
rhev</i> is used to write to a RHEV-M / oVirt target.
<i>&minus;o vdsm</i> is only used when virt&minus;v2v runs
under <small>VDSM</small> control.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Convert from
VMware vCenter server to local libvirt</b> <br>
You have a VMware vCenter server called
<tt>&quot;vcenter.example.com&quot;</tt>, a datacenter
called <tt>&quot;Datacenter&quot;</tt>, and an ESXi
hypervisor called <tt>&quot;esxi&quot;</tt>. You want to
convert a guest called <tt>&quot;esx_guest&quot;</tt> to run
locally under libvirt.</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi esx_guest</pre>


<p style="margin-left:11%; margin-top: 1em">In this case
you will most likely have to run virt&minus;v2v as
<tt>&quot;root&quot;</tt>, since it needs to talk to the
system libvirt daemon and copy the guest disks to
<tt>&quot;/var/lib/libvirt/images&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information see &quot; <small>INPUT FROM VMWARE VCENTER
SERVER&quot;</small> below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert from
<small>ESX</small> to RHEV&minus;M/oVirt</b> <br>
This is the same as the previous example, except you want to
send the guest to a RHEV-M Export Storage Domain which is
located remotely (over <small>NFS</small> ) at
<tt>&quot;rhev.nfs:/export_domain&quot;</tt>. If you are
unclear about the location of the Export Storage Domain you
should check the settings on your RHEV-M management console.
Guest network interface(s) are connected to the target
network called <tt>&quot;rhevm&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi esx_guest \
   &minus;o rhev &minus;os rhev.nfs:/export_domain &minus;&minus;network rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">In this case
the host running virt&minus;v2v acts as a <b>conversion
server</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that after
conversion, the guest will appear in the RHEV-M Export
Storage Domain, from where you will need to import it using
the RHEV-M user interface. (See &quot; <small>OUTPUT TO
RHEV&quot;</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert disk
image to OpenStack glance</b> <br>
Given a disk image from another hypervisor that you want to
convert to run on OpenStack (only KVM-based OpenStack is
supported), you can do:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i disk disk.img &minus;o glance</pre>


<p style="margin-left:11%; margin-top: 1em">To control the
name of the image in Glance, use the <i>&minus;on</i>
option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert disk
image to disk image</b> <br>
Given a disk image from another hypervisor that you want to
convert to run on <small>KVM,</small> you have two options.
The simplest way is to try:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i disk disk.img &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
virt&minus;v2v guesses everything about the input
<tt>&quot;disk.img&quot;</tt> and (in this case) writes the
converted result to <tt>&quot;/var/tmp&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">A more complex
method is to write some libvirt <small>XML</small>
describing the input guest (if you can get the source
hypervisor to provide you with libvirt <small>XML,</small>
then so much the better). You can then do:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i libvirtxml guest&minus;domain.xml &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">Since
<tt>&quot;guest&minus;domain.xml&quot;</tt> contains the
path(s) to the guest disk image(s) you do not need to
specify the name of the disk image on the command line.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Display help.</p>

<p style="margin-left:11%;"><b>&minus;b</b> ... <b><br>
&minus;&minus;bridge</b> ...</p>

<p style="margin-left:17%;">See
<i>&minus;&minus;network</i> below.</p>

<p style="margin-left:11%;"><b>&minus;&minus;dcpath</b>
Folder/Datacenter</p>

<p style="margin-left:17%;">For VMware vCenter, override
the <tt>&quot;dcPath=...&quot;</tt> parameter used to select
the datacenter. Virt&minus;v2v can usually calculate this
from the <tt>&quot;vpx://&quot;</tt> <small>URI,</small> but
if it gets it wrong, then you can override it using this
setting. Go to your vCenter web folder interface, eg.
<tt>&quot;https://vcenter.example.com/folder&quot;</tt>
(<i>without</i> a trailing slash), and examine the
<tt>&quot;dcPath=&quot;</tt> parameter in the URLs that
appear on this page.</p>


<p style="margin-left:11%;"><b>&minus;&minus;debug&minus;gc</b></p>

<p style="margin-left:17%;">Debug garbage collection and
memory allocation. This is only useful when debugging memory
problems in virt&minus;v2v or the OCaml libguestfs
bindings.</p>


<p style="margin-left:11%;"><b>&minus;&minus;debug&minus;overlays</b></p>

<p style="margin-left:17%;">Save the overlay file(s)
created during conversion. This option is only used for
debugging virt&minus;v2v and may be removed in a future
version.</p>

<p style="margin-left:11%;"><b>&minus;i disk</b></p>

<p style="margin-left:17%;">Set the input method to
<i>disk</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you can read a virtual machine disk image with no metadata.
virt&minus;v2v tries to guess the best default metadata.
This is usually adequate but you can get finer control (eg.
of memory and vCPUs) by using <i>&minus;i libvirtxml</i>
instead. Only guests that use a single disk can be imported
this way.</p>

<p style="margin-left:11%;"><b>&minus;i libvirt</b></p>

<p style="margin-left:17%;">Set the input method to
<i>libvirt</i>. This is the default.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you have to specify a libvirt guest name or
<small>UUID</small> on the command line. You may also
specify a libvirt connection <small>URI</small> (see
<i>&minus;ic</i>).</p>

<p style="margin-left:11%;"><b>&minus;i libvirtxml</b></p>

<p style="margin-left:17%;">Set the input method to
<i>libvirtxml</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you have to pass a libvirt <small>XML</small> file on the
command line. This file is read in order to get metadata
about the source guest (such as its name, amount of memory),
and also to locate the input disks. See &quot;
<small>MINIMAL XML FOR</small> &minus;i libvirtxml
<small>OPTION&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;i local</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;i
disk</i>.</p>

<p style="margin-left:11%;"><b>&minus;i ova</b></p>

<p style="margin-left:17%;">Set the input method to
<i>ova</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you can read a VMware ova file. Virt&minus;v2v will read the
ova manifest file and check the vmdk volumes for validity
(checksums) as well as analyzing the ovf file, and then
convert the guest. See &quot; <small>INPUT FROM VMWARE
OVA&quot;</small> below</p>

<p style="margin-left:11%;"><b>&minus;ic</b> libvirtURI</p>

<p style="margin-left:17%;">Specify a libvirt connection
<small>URI</small> to use when reading the guest. This is
only used when <i>&minus;i&nbsp;libvirt</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Only local
libvirt connections, <small>ESX</small> connections, or
<small>RHEL 5</small> Xen remote connections can be used.
Other remote libvirt connections will not work in
general.</p>

<p style="margin-left:17%; margin-top: 1em">See also &quot;
<small>INPUT FROM VMWARE VCENTER SERVER&quot;</small> ,
&quot; <small>INPUT FROM RHEL 5 XEN&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;if</b> format</p>

<p style="margin-left:17%;">For <i>&minus;i disk</i> only,
this specifies the format of the input disk image. For other
input methods you should specify the input format in the
metadata.</p>


<p style="margin-left:11%;"><b>&minus;&minus;machine&minus;readable</b></p>

<p style="margin-left:17%;">This option is used to make the
output more machine friendly when being parsed by other
programs. See &quot; <small>MACHINE READABLE
OUTPUT&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;n</b> in:out <b><br>
&minus;n</b> out <b><br>
&minus;&minus;network</b> in:out <b><br>
&minus;&minus;network</b> out <b><br>
&minus;b</b> in:out <b><br>
&minus;b</b> out <b><br>
&minus;&minus;bridge</b> in:out <b><br>
&minus;&minus;bridge</b> out</p>

<p style="margin-left:17%;">Map network (or bridge) called
<tt>&quot;in&quot;</tt> to network (or bridge) called
<tt>&quot;out&quot;</tt>. If no <tt>&quot;in:&quot;</tt>
prefix is given, all other networks (or bridges) are mapped
to <tt>&quot;out&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>NETWORKS AND BRIDGES&quot;</small> below.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;copy</b></p>

<p style="margin-left:17%;">Don&rsquo;t copy the disks.
Instead, conversion is performed (and thrown away), and
metadata is written, but no disks are created. See also
discussion of <i>&minus;o&nbsp;null</i> below.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
in two cases: Either you want to test if conversion is
likely to succeed, without the long copying process. Or you
are only interested in looking at the metadata.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
not compatible with <i>&minus;o libvirt</i> since it would
create a faulty guest (one with no disks).</p>

<p style="margin-left:17%; margin-top: 1em">This option is
not compatible with <i>&minus;o glance</i> for technical
reasons.</p>

<p style="margin-left:11%;"><b>&minus;&minus;no&minus;trim
all <br>
&minus;&minus;no&minus;trim</b> mp[,mp...]</p>

<p style="margin-left:17%;">By default virt&minus;v2v runs
<i>fstrim</i>(8) to reduce the amount of data that needs to
be copied. This is known to break some buggy bootloaders
causing boot failures after conversion (see for example
https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27).</p>

<p style="margin-left:17%; margin-top: 1em">You can use
<i>&minus;&minus;no&minus;trim all</i> to disable all
trimming. Note this will greatly increase the amount of data
that has to be copied and can make virt&minus;v2v run much
more slowly.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
disable trimming on selected filesystems only (specified by
a comma-separated list of their mount point(s) in the
guest). Typically you would use
<i>&minus;&minus;no&minus;trim /boot</i> to work around the
grub bug mentioned above.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
disable trimming on partitions using the libguestfs naming
scheme for devices, eg: <i>&minus;&minus;no&minus;trim
/dev/sdb2</i> means do not trim the second partition on the
second block device. Use <i>virt&minus;filesystems</i>(1) to
list filesystem names in a guest.</p>

<p style="margin-left:11%;"><b>&minus;o disk</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;o
local</i>.</p>

<p style="margin-left:11%;"><b>&minus;o glance</b></p>

<p style="margin-left:17%;">Set the output method to
OpenStack Glance. In this mode the converted guest is
uploaded to Glance. You can control the image name by
setting the <i>&minus;on</i> option.</p>

<p style="margin-left:11%;"><b>&minus;o libvirt</b></p>

<p style="margin-left:17%;">Set the output method to
<i>libvirt</i>. This is the default.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode,
the converted guest is created as a libvirt guest. You may
also specify a libvirt connection <small>URI</small> (see
<i>&minus;oc</i>).</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>OUTPUT TO LIBVIRT&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;o local</b></p>

<p style="margin-left:17%;">Set the output method to
<i>local</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode,
the converted guest is written to a local directory
specified by <i>&minus;os /dir</i> (the directory must
exist). The converted guest&rsquo;s disks are written
as:</p>

<pre style="margin-left:17%; margin-top: 1em"> /dir/name&minus;sda
 /dir/name&minus;sdb
 [etc]</pre>


<p style="margin-left:17%; margin-top: 1em">and a libvirt
<small>XML</small> file is created containing guest
metadata:</p>

<pre style="margin-left:17%; margin-top: 1em"> /dir/name.xml</pre>


<p style="margin-left:17%; margin-top: 1em">where
<tt>&quot;name&quot;</tt> is the guest name.</p>

<p style="margin-left:11%;"><b>&minus;o null</b></p>

<p style="margin-left:17%;">Set the output method to
<i>null</i>.</p>

<p style="margin-left:17%; margin-top: 1em">The guest is
converted and copied (unless you also specify
<i>&minus;&minus;no&minus;copy</i>), but the results are
thrown away and no metadata is written.</p>

<p style="margin-left:11%;"><b>&minus;o ovirt</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;o
rhev</i>.</p>

<p style="margin-left:11%;"><b>&minus;o qemu</b></p>

<p style="margin-left:17%;">Set the output method to
<i>qemu</i>.</p>

<p style="margin-left:17%; margin-top: 1em">This is similar
to <i>&minus;o local</i>, except that a shell script is
written which you can use to boot the guest in qemu. The
converted disks and shell script are written to the
directory specified by <i>&minus;os</i>.</p>

<p style="margin-left:11%;"><b>&minus;o rhev</b></p>

<p style="margin-left:17%;">Set the output method to
<i>rhev</i>.</p>

<p style="margin-left:17%; margin-top: 1em">The converted
guest is written to a <small>RHEV</small> Export Storage
Domain. The <i>&minus;os</i> parameter must also be used to
specify the location of the Export Storage Domain. Note this
does not actually import the guest into <small>RHEV.</small>
You have to do that manually later using the
<small>UI.</small></p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>OUTPUT TO RHEV&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;o vdsm</b></p>

<p style="margin-left:17%;">Set the output method to
<i>vdsm</i>.</p>

<p style="margin-left:17%; margin-top: 1em">This mode is
similar to <i>&minus;o rhev</i>, but the full path to the
data domain must be given:
<tt>&quot;/rhev/data&minus;center/&lt;data&minus;center&minus;uuid&gt;/&lt;data&minus;domain&minus;uuid&gt;&quot;</tt>.
This mode is only used when virt&minus;v2v runs under
<small>VDSM</small> control.</p>

<p style="margin-left:11%;"><b>&minus;oa sparse <br>
&minus;oa preallocated</b></p>

<p style="margin-left:17%;">Set the output file allocation
mode. The default is <tt>&quot;sparse&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;oc</b> libvirtURI</p>

<p style="margin-left:17%;">Specify a libvirt connection to
use when writing the converted guest. This is only used when
<i>&minus;o&nbsp;libvirt</i>. See &quot; <small>OUTPUT TO
LIBVIRT&quot;</small> below.</p>

<p style="margin-left:17%; margin-top: 1em">Only local
libvirt connections can be used. Remote libvirt connections
will not work.</p>

<p style="margin-left:11%;"><b>&minus;of</b> format</p>

<p style="margin-left:17%;">When converting the guest,
convert the disks to the given format.</p>

<p style="margin-left:17%; margin-top: 1em">If not
specified, then the input format is used.</p>

<p style="margin-left:11%;"><b>&minus;on</b> name</p>

<p style="margin-left:17%;">Rename the guest when
converting it. If this option is not used then the output
name is the same as the input name.</p>

<p style="margin-left:11%;"><b>&minus;os</b> storage</p>

<p style="margin-left:17%;">The location of the storage for
the converted guest.</p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
libvirt</i>, this is a libvirt directory pool (see
<tt>&quot;virsh&nbsp;pool&minus;list&quot;</tt>) or pool
<small>UUID.</small></p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
local</i> and <i>&minus;o qemu</i>, this is a directory
name. The directory must exist.</p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
rhev</i>, this can be an <small>NFS</small> path of the
Export Storage Domain of the form
<tt>&quot;&lt;host&gt;:&lt;path&gt;&quot;</tt>, eg:</p>

<pre style="margin-left:17%; margin-top: 1em"> rhev&minus;storage.example.com:/rhev/export</pre>


<p style="margin-left:17%; margin-top: 1em">The
<small>NFS</small> export must be mountable and writable by
the user and host running virt&minus;v2v, since the
virt&minus;v2v program has to actually mount it when it
runs. So you probably have to run virt&minus;v2v as
<tt>&quot;root&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em"><b>Or:</b> You
can mount the Export Storage Domain yourself, and point
<i>&minus;os</i> to the mountpoint. Note that virt&minus;v2v
will still need to write to this remote directory, so
virt&minus;v2v will still need to run as
<tt>&quot;root&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">You will get an
error if virt&minus;v2v is unable to mount/write to the
Export Storage Domain.</p>


<p style="margin-left:11%;"><b>&minus;&minus;password&minus;file</b>
file</p>

<p style="margin-left:17%;">Instead of asking for
password(s) interactively, pass the password through a file.
Note the file should contain the whole password, <b>without
any trailing newline</b>, and for security the file should
have mode <tt>0600</tt> so that others cannot read it.</p>


<p style="margin-left:11%;"><b>&minus;&minus;print&minus;source</b></p>

<p style="margin-left:17%;">Print information about the
source guest and stop. This option is useful when you are
setting up network and bridge maps. See &quot;
<small>NETWORKS AND BRIDGES&quot;</small> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;q</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;quiet</b></p>

<p style="margin-left:17%;">This disables progress bars and
other unnecessary output.</p>

<p style="margin-left:11%;"><b>&minus;&minus;root ask <br>
&minus;&minus;root single <br>
&minus;&minus;root first <br>
&minus;&minus;root</b> /dev/sdX <b><br>
&minus;&minus;root</b> /dev/VG/LV</p>

<p style="margin-left:17%;">Choose the root filesystem to
be converted.</p>

<p style="margin-left:17%; margin-top: 1em">In the case
where the virtual machine is dual-boot or multi-boot, or
where the <small>VM</small> has other filesystems that look
like operating systems, this option can be used to select
the root filesystem (a.k.a. <tt>&quot;C:&quot;</tt> drive or
<tt>&quot;/&quot;</tt>) of the operating system that is to
be converted. The Windows Recovery Console, certain attached
<small>DVD</small> drives, and bugs in libguestfs inspection
heuristics, can make a guest look like a multi-boot
operating system.</p>

<p style="margin-left:17%; margin-top: 1em">The default in
virt&minus;v2v &le; 0.7.1 was
<i>&minus;&minus;root&nbsp;single</i>, which causes
virt&minus;v2v to die if a multi-boot operating system is
found.</p>

<p style="margin-left:17%; margin-top: 1em">Since
virt&minus;v2v &ge; 0.7.2 the default is now
<i>&minus;&minus;root&nbsp;ask</i>: If the <small>VM</small>
is found to be multi-boot, then virt&minus;v2v will stop and
list the possible root filesystems and ask the user which to
use. This requires that virt&minus;v2v is run
interactively.</p>


<p style="margin-left:17%; margin-top: 1em"><i>&minus;&minus;root&nbsp;first</i>
means to choose the first root device in the case of a
multi-boot operating system. Since this is a heuristic, it
may sometimes choose the wrong one.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
name a specific root device, eg.
<i>&minus;&minus;root&nbsp;/dev/sda2</i> would mean to use
the second partition on the first hard drive. If the named
root device does not exist or was not detected as a root
device, then virt&minus;v2v will fail.</p>

<p style="margin-left:17%; margin-top: 1em">Note that there
is a bug in grub which prevents it from successfully booting
a multiboot system if VirtIO is enabled. Grub is only able
to boot an operating system from the first VirtIO disk.
Specifically, <tt>&quot;/boot&quot;</tt> must be on the
first VirtIO disk, and it cannot chainload an
<small>OS</small> which is not in the first VirtIO disk.</p>


<p style="margin-left:11%;"><b>&minus;&minus;vdsm&minus;image&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;vol&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;vm&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;ovf&minus;output</b></p>

<p style="margin-left:17%;">Normally the
<small>RHEV</small> output mode chooses random UUIDs for the
target guest. However <small>VDSM</small> needs to control
the UUIDs and passes these parameters when virt&minus;v2v
runs under <small>VDSM</small> control. The parameters
control:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the image directory of each guest disk
(<i>&minus;&minus;vdsm&minus;image&minus;uuid</i>) (this
option is passed once for each guest disk)</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>UUIDs for each guest disk
(<i>&minus;&minus;vdsm&minus;vol&minus;uuid</i>) (this
option is passed once for each guest disk)</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the <small>OVF</small> file name
(<i>&minus;&minus;vdsm&minus;vm&minus;uuid</i>).</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the <small>OVF</small> output directory (default current
directory)
(<i>&minus;&minus;vdsm&minus;ovf&minus;output</i>).</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The format of
UUIDs is:
<tt>&quot;12345678&minus;1234&minus;1234&minus;1234&minus;123456789abc&quot;</tt>
(each hex digit can be <tt>&quot;0&minus;9&quot;</tt> or
<tt>&quot;a&minus;f&quot;</tt>), conforming to
<small>OSF&nbsp;DCE&nbsp;1.1.</small></p>

<p style="margin-left:17%; margin-top: 1em">These options
can only be used with <i>&minus;o vdsm</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;v</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Enable verbose messages for
debugging.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:17%;">Display version number and
exit.</p>

<p style="margin-left:11%;"><b>&minus;&minus;vmtype desktop
<br>
&minus;&minus;vmtype server</b></p>

<p style="margin-left:17%;">For the <i>&minus;o rhev</i> or
<i>&minus;o vdsm</i> targets only, specify the type of
guest. You can set this to <tt>&quot;desktop&quot;</tt> or
<tt>&quot;server&quot;</tt>. If the option is not given,
then a suitable default is chosen based on the detected
guest operating system.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;x</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Enable tracing of libguestfs <small>API</small>
calls.</p> </td>
<td width="23%">
</td></tr>
</table>

<h2>XEN PARAVIRTUALIZED GUESTS
<a name="XEN PARAVIRTUALIZED GUESTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Older versions
of virt&minus;v2v could turn a Xen paravirtualized (
<small>PV</small> ) guest into a <small>KVM</small> guest by
installing a new kernel. This version of virt&minus;v2v does
<i>not</i> attempt to install any new kernels. Instead it
will give you an error if there are <i>only</i> Xen
<small>PV</small> kernels available.</p>

<p style="margin-left:11%; margin-top: 1em">Therefore
before conversion you should check that a regular kernel is
installed. For some older Linux distributions, this means
installing a kernel from the table below:</p>

<pre style="margin-left:11%; margin-top: 1em"> RHEL 3         (Does not apply, as there was no Xen PV kernel)
 RHEL 4         i686 with &gt; 10GB of RAM: install 'kernel&minus;hugemem'
                i686 SMP: install 'kernel&minus;smp'
                other i686: install 'kernel'
                x86&minus;64 SMP with &gt; 8 CPUs: install 'kernel&minus;largesmp'
                x86&minus;64 SMP: install 'kernel&minus;smp'
                other x86&minus;64: install 'kernel'
 RHEL 5         i686: install 'kernel&minus;PAE'
                x86&minus;64: install 'kernel'
 SLES 10        i586 with &gt; 10GB of RAM: install 'kernel&minus;bigsmp'
                i586 SMP: install 'kernel&minus;smp'
                other i586: install 'kernel&minus;default'
                x86&minus;64 SMP: install 'kernel&minus;smp'
                other x86&minus;64: install 'kernel&minus;default'
 SLES 11+       i586: install 'kernel&minus;pae'
                x86&minus;64: install 'kernel&minus;default'
 Windows        (Does not apply, as there is no Xen PV Windows kernel)</pre>


<h2>ENABLING VIRTIO
<a name="ENABLING VIRTIO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;Virtio&quot;
is the name for a set of drivers which make disk (block
device), network and other guest operations work much faster
on <small>KVM.</small></p>

<p style="margin-left:11%; margin-top: 1em">Older versions
of virt&minus;v2v could install these drivers for certain
Linux guests. This version of virt&minus;v2v does <i>not</i>
attempt to install new Linux kernels or drivers, but will
warn you if they are not installed already.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
enable virtio, and hence improve performance of the guest
after conversion, you should ensure that the <b>minimum</b>
versions of packages are installed <i>before</i> conversion,
by consulting the table below.</p>

<pre style="margin-left:11%; margin-top: 1em"> RHEL 3         No virtio drivers are available
 RHEL 4         kernel &gt;= 2.5.9&minus;89.EL
                lvm2 &gt;= 2.02.42&minus;5.el4
                device&minus;mapper &gt;= 1.02.28&minus;2.el4
                selinux&minus;policy&minus;targeted &gt;= 1.17.30&minus;2.152.el4
                policycoreutils &gt;= 1.18.1&minus;4.13
 RHEL 5         kernel &gt;= 2.6.18&minus;128.el5
                lvm2 &gt;= 2.02.40&minus;6.el5
                selinux&minus;policy&minus;targeted &gt;= 2.4.6&minus;203.el5
 RHEL 6+        All versions support virtio
 Fedora         All versions support virtio
 SLES 11+       All versions support virtio
 SLES 10        kernel &gt;= 2.6.16.60&minus;0.85.1
 OpenSUSE 11+   All versions support virtio
 OpenSUSE 10    kernel &gt;= 2.6.25.5&minus;1.1
 Windows        Drivers are installed from the directory pointed to by
                &quot;VIRTIO_WIN&quot; environment variable
                (/usr/share/virtio&minus;win by default) if present</pre>


<h2>RHEL 4
<a name="RHEL 4"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>SELinux
relabel appears to hang forever</b> <br>
In <small>RHEL</small> &le; 4.7 there was a bug which causes
SELinux relabelling to appear to hang forever at:</p>

<pre style="margin-left:11%; margin-top: 1em"> *** Warning &minus;&minus; SELinux relabel is required. ***
 *** Disabling security enforcement.         ***
 *** Relabeling could take a very long time, ***
 *** depending on file system size.          ***</pre>


<p style="margin-left:11%; margin-top: 1em">In reality it
is waiting for you to press a key (but there is no visual
indication of this). You can either hit the
<tt>&quot;[Return]&quot;</tt> key, at which point the guest
will finish relabelling and reboot, or you can install
policycoreutils &ge; 1.18.1&minus;4.13 before starting the
v2v conversion. See also
https://bugzilla.redhat.com/show_bug.cgi?id=244636</p>

<h2>WINDOWS
<a name="WINDOWS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Boot
failure: 0x0000007B</b> <br>
This boot failure is caused by Windows being unable to find
or load the right disk driver (eg.
<tt>&quot;viostor.sys&quot;</tt>). If you experience this
error, here are some things to check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">First ensure that the guest
boots on the source hypervisor before conversion.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Check you have the Windows virtio drivers available in
<tt>&quot;/usr/share/virtio&minus;win&quot;</tt>, and that
virt&minus;v2v did not print any warning about not being
able to install virtio drivers.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">On
Red&nbsp;Hat&nbsp;Enterprise&nbsp;Linux&nbsp;7, you will
need to install the signed drivers available in the
<tt>&quot;virtio&minus;win&quot;</tt> package. If you do not
have access to the signed drivers, then you will probably
need to disable driver signing in the boot menus.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Check that you are presenting a
virtio-blk interface (<b>not</b> virtio-scsi and <b>not</b>
ide) to the guest. On the qemu/KVM command line you should
see something similar to this:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ... &minus;drive file=windows&minus;sda,if=virtio ...</pre>


<p style="margin-left:17%; margin-top: 1em">In libvirt
<small>XML,</small> you should see:</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;target dev='vda' bus='virtio'/&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Check that Windows Group Policy
does not prevent the driver from being installed or used.
Try deleting Windows Group Policy before conversion.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Check there is no anti-virus or other software which
implements Group Policy-like prohibitions on installing or
using new drivers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Enable boot debugging and check the
<tt>&quot;viostor.sys&quot;</tt> driver is being loaded.</p></td></tr>
</table>

<h2>UEFI
<a name="UEFI"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">VMware allows
you to present <small>UEFI</small> firmware to guests
(instead of the ordinary <small>PC BIOS</small> ).
Virt&minus;v2v can convert these guests, but requires that
<small>UEFI</small> is supported by the target
hypervisor.</p>

<p style="margin-left:11%; margin-top: 1em">Currently
<small>KVM</small> supports <small>OVMF,</small> a partially
open source <small>UEFI</small> firmware, and can run these
guests.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<small>OVMF</small> support was only recently added to
<small>KVM</small> (in 2014/2015), not all target
environments support <small>UEFI</small> guests yet:
<small><br>
UEFI</small> on libvirt, qemu</p>

<p style="margin-left:17%;">Supported. Virt&minus;v2v will
generate the correct libvirt <small>XML</small> (metadata)
automatically, but note that the same version of
<small>OVMF</small> must be installed on the conversion host
as is installed on the target hypervisor, else you will have
to adjust paths in the metadata.</p>

<p style="margin-left:11%;"><small>UEFI</small> on
OpenStack</p>

<p style="margin-left:17%;">Not supported.</p>

<p style="margin-left:11%;"><small>UEFI</small> on
<small>RHEV</small></p>

<p style="margin-left:17%;">Not supported.</p>

<h2>NETWORKS AND BRIDGES
<a name="NETWORKS AND BRIDGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Guests are
usually connected to one or more networks, and when
converted to the target hypervisor you usually want to
reconnect those networks at the destination. The options
<i>&minus;&minus;network</i> and <i>&minus;&minus;bridge</i>
allow you to do that.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
unsure of what networks and bridges are in use on the source
hypervisor, then you can examine the source metadata
(libvirt <small>XML,</small> vCenter information, etc.). Or
you can run virt&minus;v2v with the
<i>&minus;&minus;print&minus;source</i> option which causes
virt&minus;v2v to print out the information it has about the
guest on the source and then exit.</p>

<p style="margin-left:11%; margin-top: 1em">In the
<i>&minus;&minus;print&minus;source</i> output you will see
a section showing the guest&rsquo;s Network Interface Cards
(NICs):</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v [&minus;i ...] &minus;&minus;print&minus;source name
 [...]
 NICs:
     Network &quot;default&quot; mac: 52:54:00:d0:cf:0e</pre>


<p style="margin-left:11%; margin-top: 1em">This is typical
of a libvirt guest: It has a single network interface
connected to a network called
<tt>&quot;default&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To map a
specific network to a target network, for example
<tt>&quot;default&quot;</tt> on the source to
<tt>&quot;rhevm&quot;</tt> on the target, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v [...] &minus;&minus;network default:rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">To map every
network to a target network, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v [...] &minus;&minus;network rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">Bridges are
handled in the same way, but you have to use the
<i>&minus;&minus;bridge</i> option instead. For example:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v [&minus;i ...] &minus;&minus;print&minus;source name
 [...]
 NICs:
     Bridge &quot;br0&quot;
 $ virt&minus;v2v [...] &minus;&minus;bridge br0:targetbr</pre>


<h2>INPUT FROM VMWARE VCENTER SERVER
<a name="INPUT FROM VMWARE VCENTER SERVER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import guests from VMware vCenter Server.</p>

<p style="margin-left:11%; margin-top: 1em">vCenter &ge;
5.0 is required. Virt&minus;v2v <b>cannot</b> import guests
directly from an ESXi hypervisor. If you don&rsquo;t have
vCenter, using <small>OVA</small> is recommended instead
(see &quot; <small>INPUT FROM VMWARE OVA&quot;</small>
below).</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
uses libvirt for access to vCenter, and therefore the input
mode should be <i>&minus;i libvirt</i>. As this is the
default, you don&rsquo;t need to specify it on the command
line.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>ESX:
REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</small></b> <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then the converted guest will complain on every boot. The
tools cannot be removed after conversion because the
uninstaller checks if it is running on VMware and refuses to
start (which is also the reason that virt&minus;v2v cannot
remove them).</p>

<p style="margin-left:11%; margin-top: 1em">This is not
necessary for Linux guests, as virt&minus;v2v is able to
remove VMware tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>ESX:
VCENTER URI</small></b> <br>
The libvirt <small>URI</small> of a vCenter server looks
something like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> vpx://user@server/Datacenter/esxi</pre>


<p style="margin-left:11%; margin-top: 1em">where: <br>
&quot;user@&quot;</p>

<p style="margin-left:17%;">is the (optional, but
recommended) user to connect as.</p>

<p style="margin-left:17%; margin-top: 1em">If the username
contains a backslash (eg. <tt>&quot;DOMAIN\USER&quot;</tt>)
then you will need to URI-escape that character using
<tt>%5c</tt>: <tt>&quot;DOMAIN%5cUSER&quot;</tt> (5c is the
hexadecimal <small>ASCII</small> code for backslash.) Other
punctuation may also have to be escaped.</p>

<p style="margin-left:11%;">&quot;server&quot;</p>

<p style="margin-left:17%;">is the vCenter Server
(<i>not</i> hypervisor)</p>

<p style="margin-left:11%;">&quot;Datacenter&quot;</p>

<p style="margin-left:17%;">is the name of the
datacenter</p>

<p style="margin-left:11%;">&quot;esxi&quot;</p>

<p style="margin-left:17%;">is the name of the ESXi
hypervisor running the guest.</p>

<p style="margin-left:11%; margin-top: 1em">If the VMware
deployment is using folders, then these may need to be added
to the <small>URI,</small> eg:</p>

<pre style="margin-left:11%; margin-top: 1em"> vpx://user@server/Folder/Datacenter/esxi</pre>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
needs to calculate the <tt>&quot;dcPath&quot;</tt> parameter
from the <small>URI,</small> and it does this by removing
the final <tt>&quot;/esxi&quot;</tt> element, so in the
above example <tt>&quot;dcPath=Folder/Datacenter&quot;</tt>.
As it is not always possible to correctly calculate
<tt>&quot;dcPath&quot;</tt> from the <small>URI,</small> you
can override this using the <i>&minus;&minus;dcpath</i>
parameter.</p>

<p style="margin-left:11%; margin-top: 1em">For full
details of libvirt URIs, see:
http://libvirt.org/drvesx.html</p>

<p style="margin-left:11%; margin-top: 1em">Typical errors
from libvirt / virsh when the <small>URI</small> is wrong
include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find datacenter specified in [...]</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find compute resource specified in [...]</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Path [...] does not specify a compute resource</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Path [...] does not specify a host system</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find host system specified in [...]</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b><small>ESX:
TEST LIBVIRT CONNECTION TO VCENTER</small></b> <br>
Use the <i>virsh</i>(1) command to list the guests on the
vCenter Server like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi' list &minus;&minus;all
 Enter root's password for vcenter.example.com: ***
  Id    Name                           State
 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  &minus;     Fedora 20                      shut off
  &minus;     Windows 2003                   shut off</pre>


<p style="margin-left:11%; margin-top: 1em">If you get an
error &quot;Peer certificate cannot be authenticated with
given <small>CA</small> certificates&quot; or similar, then
you can either import the <small>ESX</small> host&rsquo;s
certificate, or bypass signature verification by adding the
<tt>&quot;?no_verify=1&quot;</tt> flag:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' list &minus;&minus;all</pre>


<p style="margin-left:11%; margin-top: 1em">You should also
try dumping the metadata from any guest on your server, like
this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi' dumpxml &quot;Windows 2003&quot;
 &lt;domain type='vmware'&gt;
   &lt;name&gt;Windows 2003&lt;/name&gt;
   [...]
 &lt;/domain&gt;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>If the above
commands do not work, then virt&minus;v2v is not going to
work either</b>. Fix your libvirt configuration and/or your
VMware vCenter Server before continuing.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>ESX:
IMPORTING A GUEST</small></b> <br>
To import a particular guest from vCenter Server, do:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;ic 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' \
   &quot;Windows 2003&quot; \
   &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;Windows 2003&quot;</tt> is the name of the guest
(which must be shut down).</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
may be asked for the vCenter password <i>twice</i>. This
happens once because libvirt needs it, and a second time
because virt&minus;v2v itself connects directly to the
server. Use <i>&minus;&minus;password&minus;file</i> to
supply a password via a file.</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the output flags are set to write the converted guest to a
temporary directory as this is just an example, but you can
also write to libvirt or any other supported target.</p>

<h2>INPUT FROM VMWARE OVA
<a name="INPUT FROM VMWARE OVA"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import guests from VMware&rsquo;s
<small>OVA</small> (Open Virtualization Appliance) files.
Only OVAs exported from VMware vSphere will work.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</small></b> <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then the converted guest will complain on every boot. The
tools cannot be removed after conversion because the
uninstaller checks if it is running on VMware and refuses to
start (which is also the reason that virt&minus;v2v cannot
remove them).</p>

<p style="margin-left:11%; margin-top: 1em">This is not
necessary for Linux guests, as virt&minus;v2v is able to
remove VMware tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
CREATE OVA</small></b> <br>
To create an <small>OVA</small> in vSphere, use the
&quot;Export <small>OVF</small> Template&quot; option (from
the <small>VM</small> context menu, or from the File menu).
Either &quot;Folder of files&quot; ( <small>OVF</small> ) or
&quot;Single file&quot; ( <small>OVA</small> ) will work,
but <small>OVA</small> is probably easier to deal with.
<small>OVA</small> files are really just uncompressed tar
files, so you can use commands like <tt>&quot;tar tf
VM.ova&quot;</tt> to view their contents.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
IMPORTING A GUEST</small></b> <br>
To import an <small>OVA</small> file called
<tt>&quot;VM.ova&quot;</tt>, do;</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;i ova VM.ova &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">If you exported
the guest as a &quot;Folder of files&quot;, <i>or</i> if you
unpacked the <small>OVA</small> tarball yourself, then you
can point virt&minus;v2v at the directory containing the
files:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;i ova /path/to/files &minus;o local &minus;os /var/tmp</pre>


<h2>INPUT FROM RHEL 5 XEN
<a name="INPUT FROM RHEL 5 XEN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import Xen guests from <small>RHEL 5</small> Xen
hosts.</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
uses libvirt for access to the remote Xen host, and
therefore the input mode should be <i>&minus;i libvirt</i>.
As this is the default, you don&rsquo;t need to specify it
on the command line.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
SET UP</small> SSH-AGENT <small>ACCESS TO XEN
HOST</small></b> <br>
Currently you must enable passwordless <small>SSH</small>
access to the remote Xen host from the virt&minus;v2v
conversion server.</p>

<p style="margin-left:11%; margin-top: 1em">You must also
use ssh-agent, and add your ssh public key to
<tt>&quot;/root/.ssh/authorized_keys&quot;</tt> (on the Xen
host).</p>

<p style="margin-left:11%; margin-top: 1em">After doing
this, you should check that passwordless access works from
the virt&minus;v2v server to the Xen host. For example:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ ssh root@xen.example.com
 [ logs straight into the shell, no password is requested ]</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
password-interactive and Kerberos access are <b>not</b>
supported. You <b>have</b> to set up ssh access using
ssh-agent and authorized_keys.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
TEST LIBVIRT CONNECTION TO REMOTE XEN HOST</small></b> <br>
Use the <i>virsh</i>(1) command to list the guests on the
remote Xen host:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c xen+ssh://root@xen.example.com list &minus;&minus;all
  Id    Name                           State
 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  0     Domain&minus;0                       running
  &minus;     rhel49&minus;x86_64&minus;pv               shut off</pre>


<p style="margin-left:11%; margin-top: 1em">You should also
try dumping the metadata from any guest on your server, like
this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c xen+ssh://root@xen.example.com dumpxml rhel49&minus;x86_64&minus;pv
 &lt;domain type='xen'&gt;
   &lt;name&gt;rhel49&minus;x86_64&minus;pv&lt;/name&gt;
   [...]
 &lt;/domain&gt;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>If the above
commands do not work, then virt&minus;v2v is not going to
work either</b>. Fix your libvirt configuration or the
remote server before continuing.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
IMPORTING A GUEST</small></b> <br>
To import a particular guest from a Xen server, do:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;ic 'xen+ssh://root@xen.example.com' \
   rhel49&minus;x86_64&minus;pv \
   &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;rhel49&minus;x86_64&minus;pv&quot;</tt> is the
name of the guest (which must be shut down).</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the output flags are set to write the converted guest to a
temporary directory as this is just an example, but you can
also write to libvirt or any other supported target.</p>

<h2>OUTPUT TO LIBVIRT
<a name="OUTPUT TO LIBVIRT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>&minus;o
libvirt</i> option lets you upload the converted guest to a
libvirt-managed host. There are several limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You can only use a local libvirt
connection [see below for how to workaround this].</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <i>&minus;os pool</i> option must specify a
directory pool, not anything more exotic such as iSCSI [but
see below].</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You can only upload to a <small>KVM</small>
hypervisor.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>To output to
a remote libvirt instance and/or a non-directory storage
pool</b> you have to use the following workaround:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Use virt&minus;v2v in
<i>&minus;o local</i> mode to convert the guest disks and
metadata into a local temporary directory:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;v2v [...] &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:17%; margin-top: 1em">This creates
two (or more) files in <tt>&quot;/var/tmp&quot;</tt>
called:</p>

<pre style="margin-left:17%; margin-top: 1em"> /var/tmp/NAME.xml     # the libvirt XML (metadata)
 /var/tmp/NAME&minus;sda     # the guest's first disk</pre>


<p style="margin-left:17%; margin-top: 1em">(for
<tt>&quot;NAME&quot;</tt> substitute the guest&rsquo;s
name).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Upload the converted disk(s)
into the storage pool called <tt>&quot;POOL&quot;</tt>:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> size=$(stat &minus;c%s /var/tmp/NAME&minus;sda)
 virsh vol&minus;create&minus;as POOL NAME&minus;sda $size &minus;&minus;format raw
 virsh vol&minus;upload &minus;&minus;pool POOL NAME&minus;sda /var/tmp/NAME&minus;sda</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Edit
<tt>&quot;/var/tmp/NAME.xml&quot;</tt> to change
<tt>&quot;/var/tmp/NAME&minus;sda&quot;</tt> to the pool
name. In other words, locate the following bit of
<small>XML:</small></p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> &lt;disk type='file' device='disk'&gt;
   &lt;driver name='qemu' type='raw' cache='none' /&gt;
   &lt;source file='/var/tmp/NAME&minus;sda' /&gt;
   &lt;target dev='hda' bus='ide' /&gt;
 &lt;/disk&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">and change two
things: The <tt>&quot;type='file'&quot;</tt> attribute must
be changed to <tt>&quot;type='volume'&quot;</tt>, and the
<tt>&quot;&lt;source&gt;&quot;</tt> element must be changed
to include <tt>&quot;pool&quot;</tt> and
<tt>&quot;volume&quot;</tt> attributes:</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;disk type='volume' device='disk'&gt;
   ...
   &lt;source pool='POOL' volume='NAME&minus;sda' /&gt;
   ...
 &lt;/disk&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="3%"></td>
<td width="52%">


<p style="margin-top: 1em">Define the final guest in
libvirt:</p> </td>
<td width="31%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virsh define /var/tmp/NAME.xml</pre>


<h2>OUTPUT TO RHEV
<a name="OUTPUT TO RHEV"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
only applies to the <i>&minus;o rhev</i> output mode. If you
use virt&minus;v2v from the RHEV-M user interface, then
behind the scenes the import is managed by
<small>VDSM</small> using the <i>&minus;o vdsm</i> output
mode (which end users should not try to use directly).</p>

<p style="margin-left:11%; margin-top: 1em">You have to
specify <i>&minus;o rhev</i> and an <i>&minus;os</i> option
that points to the RHEV-M Export Storage Domain. You can
either specify the <small>NFS</small> server and mountpoint,
eg.
<tt>&quot;&minus;os&nbsp;rhev&minus;storage:/rhev/export&quot;</tt>,
or you can mount that first and point to the directory where
it is mounted, eg.
<tt>&quot;&minus;os&nbsp;/tmp/mnt&quot;</tt>. Be careful not
to point to the Data Storage Domain by accident as that will
not work.</p>

<p style="margin-left:11%; margin-top: 1em">On successful
completion virt&minus;v2v will have written the new guest to
the Export Storage Domain, but it will not yet be ready to
run. It must be imported into <small>RHEV</small> using the
<small>UI</small> before it can be used.</p>

<p style="margin-left:11%; margin-top: 1em">In
<small>RHEV</small> &ge; 2.2 this is done from the Storage
tab. Select the export domain the guest was written to. A
pane will appear underneath the storage domain list
displaying several tabs, one of which is &quot;
<small>VM</small> Import&quot;. The converted guest will be
listed here. Select the appropriate guest an click
&quot;Import&quot;. See the <small>RHEV</small>
documentation for additional details.</p>

<p style="margin-left:11%; margin-top: 1em">If you export
several guests, then you can import them all at the same
time through the <small>UI.</small></p>

<h2>RESOURCE REQUIREMENTS
<a name="RESOURCE REQUIREMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Network</b>
<br>
The most important resource for virt&minus;v2v appears to be
network bandwidth. Virt&minus;v2v should be able to copy
guest data at gigabit ethernet speeds or greater.</p>

<p style="margin-left:11%; margin-top: 1em">Ensure that the
network connections between servers (conversion server,
<small>NFS</small> server, vCenter, Xen) are as fast and as
low latency as possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Disk
space</b> <br>
Virt&minus;v2v places potentially large temporary files in
<tt>$TMPDIR</tt> (which is <tt>&quot;/var/tmp&quot;</tt> if
you don&rsquo;t set it). Using tmpfs is a bad idea.</p>

<p style="margin-left:11%; margin-top: 1em">For each guest
disk, an overlay is stored temporarily. This stores the
changes made during conversion, and is used as a cache. The
overlays are not particularly large &minus; tens or low
hundreds of megabytes per disk is typical. In addition to
the overlay(s), input and output methods may use disk space,
as outlined in the table below. <i><br>
&minus;i ova</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the uncompressed source disks in
<tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%;"><i>&minus;o glance</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the output disks in <tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%;"><i>&minus;o local <br>
&minus;o qemu</i></p>

<p style="margin-left:17%;">You must ensure there is
sufficient space in the output directory for the converted
guest.</p>

<p style="margin-left:11%;"><i>&minus;o null</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the output disks in <tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>VMware
vCenter resources</b> <br>
Copying from VMware vCenter is currently quite slow, but we
believe this to be an issue with VMware. Ensuring the VMware
ESXi hypervisor and vCenter guest are running on fast
hardware with plenty of memory should alleviate this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compute
power and <small>RAM</small></b> <br>
Virt&minus;v2v is not especially compute or
<small>RAM</small> intensive. If you are running many
parallel conversions, then you may consider allocating one
<small>CPU</small> core and 512 <small>MB &minus; 1
GB</small> of <small>RAM</small> per running instance.</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
can be run in a virtual machine.</p>

<h2>POST-CONVERSION TASKS
<a name="POST-CONVERSION TASKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Guest
network configuration</b> <br>
Virt&minus;v2v cannot currently reconfigure a guest&rsquo;s
network configuration. If the converted guest is not
connected to the same subnet as the source, its network
configuration may have to be updated. See also
<i>virt&minus;customize</i>(1).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Converting a
Windows guest</b> <br>
When converting a Windows guests, the conversion process is
split into two stages:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="29%">


<p>Offline conversion.</p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="29%">


<p>First boot.</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The guest will
be bootable after the offline conversion stage, but will not
yet have all necessary drivers installed to work correctly.
These will be installed automatically the first time the
guest boots.</p>

<p style="margin-left:11%; margin-top: 1em"><b>N.B.</b>
Take care not to interrupt the automatic driver installation
process when logging in to the guest for the first time, as
this may prevent the guest from subsequently booting
correctly.</p>

<h2>FREE SPACE FOR CONVERSION
<a name="FREE SPACE FOR CONVERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
checks there is sufficient free space in the guest
filesystem to perform the conversion. Currently it checks:
<br>
Root filesystem or &quot;C:\&quot;</p>

<p style="margin-left:17%;">Minimum free space: 20
<small>MB</small></p>

<p style="margin-left:11%;">&quot;/boot&quot;</p>

<p style="margin-left:17%;">Minimum free space: 50
<small>MB</small></p>

<p style="margin-left:17%; margin-top: 1em">This is because
we need to build a new initramfs for some Enterprise Linux
conversions.</p>

<p style="margin-left:11%;">Any other mountable
filesystem</p>

<p style="margin-left:17%;">Minimum free space: 10
<small>MB</small></p>

<h2>RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT
<a name="RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Nothing in
virt&minus;v2v inherently needs root access, and it will run
just fine as a non-root user. However, certain external
features may require either root or a special user: <br>
Mounting the Export Storage Domain</p>

<p style="margin-left:17%;">When using <i>&minus;o rhev
&minus;os server:/esd</i> virt&minus;v2v has to have
sufficient privileges to <small>NFS</small> mount the Export
Storage Domain from <tt>&quot;server&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">You can avoid
needing root here by mounting it yourself before running
virt&minus;v2v, and passing <i>&minus;os /mountpoint</i>
instead, but first of all read the next section&nbsp;...</p>

<p style="margin-left:11%;">Writing to the Export Storage
Domain as 36:36</p>

<p style="margin-left:17%;">RHEV-M cannot read files and
directories from the Export Storage Domain unless they have
<small>UID:GID 36:36.</small> You will see <small>VM</small>
import problems if the <small>UID:GID</small> is not
correct.</p>

<p style="margin-left:17%; margin-top: 1em">When you run
virt&minus;v2v <i>&minus;o rhev</i> as root, virt&minus;v2v
attempts to create files and directories with the correct
ownership. If you run virt&minus;v2v as non-root, it will
probably still work, but you will need to manually change
ownership after virt&minus;v2v has finished.</p>

<p style="margin-left:11%;">Writing to libvirt</p>

<p style="margin-left:17%;">When using <i>&minus;o
libvirt</i>, you may need to run virt&minus;v2v as root so
that it can write to the libvirt system instance (ie.
<tt>&quot;qemu:///system&quot;</tt>) and to the default
location for disk images (usually
<tt>&quot;/var/lib/libvirt/images&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">You can avoid
this by setting up libvirt connection authentication, see
http://libvirt.org/auth.html. Alternatively, use
<i>&minus;oc qemu:///session</i>, which will write to your
per-user libvirt instance.</p>

<p style="margin-left:11%;">Writing to Glance</p>

<p style="margin-left:17%;">This does <i>not</i> need root
(in fact it probably won&rsquo;t work), but may require
either a special user and/or for you to source a script that
sets authentication environment variables. Consult the
Glance documentation.</p>

<h2>DEBUGGING RHEV-M IMPORT FAILURES
<a name="DEBUGGING RHEV-M IMPORT FAILURES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When you export
to the RHEV-M Export Storage Domain, and then import that
guest through the RHEV-M <small>UI,</small> you may
encounter an import failure. Diagnosing these failures is
infuriatingly difficult as the <small>UI</small> generally
hides the true reason for the failure.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
log files of interest. The first is stored on the RHEV-M
server itself, and is called
<tt>&quot;/var/log/ovirt&minus;engine/engine.log&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">The second
file, which is the most useful, is found on the
<small>SPM</small> host ( <small>SPM</small> stands for
&quot;Storage Pool Manager&quot;). This is a
<small>RHEV</small> node that is elected to do all metadata
modifications in the data center, such as image or snapshot
creation. You can find out which host is the current
<small>SPM</small> from the &quot;Hosts&quot; tab &quot;Spm
Status&quot; column. Once you have located the
<small>SPM,</small> log into it and grab the file
<tt>&quot;/var/log/vdsm/vdsm.log&quot;</tt> which will
contain detailed error messages from low-level commands.</p>

<h2>MINIMAL XML FOR &minus;i libvirtxml OPTION
<a name="MINIMAL XML FOR &minus;i libvirtxml OPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When using the
<i>&minus;i libvirtxml</i> option, you have to supply some
libvirt <small>XML.</small> Writing this from scratch is
hard, so the template below is helpful.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note this
should only be used for testing and/or where you know what
you&rsquo;re doing!</b> If you have libvirt metadata for the
guest, always use that instead.</p>

<pre style="margin-left:11%; margin-top: 1em"> &lt;domain type='kvm'&gt;
   &lt;name&gt;NAME&lt;/name&gt;
   &lt;memory&gt;1048576&lt;/memory&gt;
   &lt;vcpu&gt;2&lt;/vcpu&gt;
   &lt;os&gt;
     &lt;type&gt;hvm&lt;/type&gt;
     &lt;boot dev='hd'/&gt;
   &lt;/os&gt;
   &lt;features&gt;
     &lt;acpi/&gt;
     &lt;apic/&gt;
     &lt;pae/&gt;
   &lt;/features&gt;
   &lt;devices&gt;
     &lt;disk type='file' device='disk'&gt;
       &lt;driver name='qemu' type='raw'/&gt;
       &lt;source file='/path/to/disk/image'/&gt;
       &lt;target dev='hda' bus='ide'/&gt;
     &lt;/disk&gt;
     &lt;interface type='network'&gt;
       &lt;mac address='52:54:00:01:02:03'/&gt;
       &lt;source network='default'/&gt;
       &lt;model type='rtl8139'/&gt;
     &lt;/interface&gt;
   &lt;/devices&gt;
 &lt;/domain&gt;</pre>


<h2>MACHINE READABLE OUTPUT
<a name="MACHINE READABLE OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>&minus;&minus;machine&minus;readable</i> option can be
used to make the output more machine friendly, which is
useful when calling virt&minus;v2v from other programs, GUIs
etc.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to use this option.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly use the
option on its own to query the capabilities of the
virt&minus;v2v binary. Typical output looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;&minus;machine&minus;readable
 virt&minus;v2v
 libguestfs&minus;rewrite
 input:disk
 [...]
 output:local
 [...]
 convert:enterprise&minus;linux
 convert:windows</pre>


<p style="margin-left:11%; margin-top: 1em">A list of
features is printed, one per line, and the program exits
with status 0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;input:&quot;</tt> and <tt>&quot;output:&quot;</tt>
features refer to <i>&minus;i</i> and <i>&minus;o</i> (input
and output mode) options supported by this binary. The
<tt>&quot;convert:&quot;</tt> features refer to guest types
that this binary knows how to convert.</p>

<p style="margin-left:11%; margin-top: 1em">Secondly use
the option in conjunction with other options to make the
regular program output more machine friendly.</p>

<p style="margin-left:11%; margin-top: 1em">At the moment
this means:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Progress bar messages can be parsed from stdout by
looking for this regular expression:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ^[0&minus;9]+/[0&minus;9]+$</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">The calling program should treat
messages sent to stdout (except for progress bar messages)
as status messages. They can be logged and/or displayed to
the user.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The calling program should treat messages sent to stderr
as error messages. In addition, virt&minus;v2v exits with a
non-zero status code if there was a fatal error.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
&le; 0.9.1 did not support the
<i>&minus;&minus;machine&minus;readable</i> option at all.
The option was added when virt&minus;v2v was rewritten in
2014.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;/usr/share/virtio&minus;win&quot;</p>

<p style="margin-left:17%;">(Optional)</p>

<p style="margin-left:17%; margin-top: 1em">If this
directory is present, then virtio drivers for Windows guests
will be found from this directory and installed in the guest
during conversion.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;TMPDIR&quot;</p>

<p style="margin-left:17%;">Location of the temporary
directory used for the potentially large temporary overlay
file.</p>

<p style="margin-left:17%; margin-top: 1em">See the
&quot;Disk space&quot; section above.</p>


<p style="margin-left:11%;">&quot;VIRT_TOOLS_DATA_DIR&quot;</p>

<p style="margin-left:17%;">This can point to the directory
containing data files used for Windows conversion.</p>

<p style="margin-left:17%; margin-top: 1em">Normally you do
not need to set this. If not set, a compiled-in default will
be used (something like
<tt>&quot;/usr/share/virt&minus;tools&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">This directory
may contain the following files: <br>
&quot;rhsrvany.exe&quot;</p>

<p style="margin-left:23%;">(Required when doing
conversions of Windows guests)</p>

<p style="margin-left:23%; margin-top: 1em">This is the
RHSrvAny Windows binary, used to install a
&quot;firstboot&quot; script in the guest during conversion
of Windows guests.</p>

<p style="margin-left:23%; margin-top: 1em">See also:
<tt>&quot;https://github.com/rwmjones/rhsrvany&quot;</tt></p>


<p style="margin-left:17%;">&quot;rhev&minus;apt.exe&quot;</p>

<p style="margin-left:23%;">(Optional)</p>

<p style="margin-left:23%; margin-top: 1em">The
<small>RHEV</small> Application Provisioning Tool (
<small>RHEV APT</small> ). If this file is present, then
<small>RHEV APT</small> will be installed in the Windows
guest during conversion. This tool is a guest agent which
ensures that the virtio drivers remain up to date when the
guest is running on Red Hat Enterprise Virtualization (
<small>RHEV</small> ).</p>

<p style="margin-left:23%; margin-top: 1em">This file comes
from Red Hat Enterprise Virtualization ( <small>RHEV</small>
), and is not distributed with virt&minus;v2v.</p>

<p style="margin-left:11%;">&quot;VIRTIO_WIN&quot;</p>

<p style="margin-left:17%;">This is where VirtIO drivers
for Windows are searched for
(<i>/usr/share/virtio&minus;win</i> if unset). It can be a
directory <i>or</i> point to <i>virtio&minus;win.iso</i> (
<small>CD ROM</small> image containing drivers).</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>ENABLING VIRTIO&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em">For other
environment variables, see &quot; <small>ENVIRONMENT
VARIABLES&quot;</small> in <i>guestfs</i>(3).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>virt&minus;p2v</i>(1),
<i>virt&minus;customize</i>(1), <i>virt&minus;df</i>(1),
<i>virt&minus;filesystems</i>(1),
<i>virt&minus;sparsify</i>(1), <i>virt&minus;sysprep</i>(1),
<i>guestfs</i>(3), <i>guestfish</i>(1),
<i>qemu&minus;img</i>(1), <i>fstrim</i>(8),
http://libguestfs.org/.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Richard W.M.
Jones http://people.redhat.com/~rjones/</p>

<p style="margin-left:11%; margin-top: 1em">Matthew
Booth</p>

<p style="margin-left:11%; margin-top: 1em">Mike
Latimer</p>

<p style="margin-left:11%; margin-top: 1em">Shahar
Havivi</p>

<p style="margin-left:11%; margin-top: 1em">Tingting
Zheng</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2009&minus;2014 Red Hat Inc.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of the <small>GNU</small> General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the
<small>GNU</small> General Public License for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the <small>GNU</small> General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, <small>MA 02110&minus;1301 USA.</small></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To get a list
of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">To report a new
bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">When reporting
a bug, please supply:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The version of libguestfs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Where you got libguestfs (eg. which Linux distro,
compiled from source, etc)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Describe the bug accurately and give a way to reproduce
it.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Run <i>libguestfs&minus;test&minus;tool</i>(1) and paste
the <b>complete, unedited</b> output into the bug
report.</p> </td></tr>
 </table>
<hr>
</body>
</html>
