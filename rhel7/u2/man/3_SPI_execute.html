<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:24:11 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SPI_EXECUTE</title>

</head>
<body>

<h1 align="center">SPI_EXECUTE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SPI_execute
&minus; execute a command</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">int
SPI_execute(const char * <i>command</i>, bool
<i>read_only</i>, long <i>count</i>)</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SPI_execute</b>
executes the specified SQL command for <i>count</i> rows. If
<i>read_only</i> is true, the command must be
read&minus;only, and execution overhead is somewhat
reduced.</p>

<p style="margin-left:11%; margin-top: 1em">This function
can only be called from a connected procedure.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>count</i>
is zero then the command is executed for all rows that it
applies to. If <i>count</i> is greater than zero, then no
more than <i>count</i> rows will be retrieved; execution
stops when the count is reached, much like adding a LIMIT
clause to the query. For example,</p>


<p style="margin-left:17%; margin-top: 1em">SPI_execute(&quot;SELECT
* FROM foo&quot;, true, 5);</p>

<p style="margin-left:11%; margin-top: 1em">will retrieve
at most 5 rows from the table. Note that such a limit is
only effective when the command actually returns rows. For
example,</p>


<p style="margin-left:17%; margin-top: 1em">SPI_execute(&quot;INSERT
INTO foo SELECT * FROM bar&quot;, false, 5);</p>

<p style="margin-left:11%; margin-top: 1em">inserts all
rows from bar, ignoring the <i>count</i> parameter. However,
with</p>


<p style="margin-left:17%; margin-top: 1em">SPI_execute(&quot;INSERT
INTO foo SELECT * FROM bar RETURNING *&quot;, false, 5);</p>

<p style="margin-left:11%; margin-top: 1em">at most 5 rows
would be inserted, since execution would stop after the
fifth RETURNING result row is retrieved.</p>

<p style="margin-left:11%; margin-top: 1em">You can pass
multiple commands in one string; <b>SPI_execute</b> returns
the result for the command executed last. The <i>count</i>
limit applies to each command separately (even though only
the last result will actually be returned). The limit is not
applied to any hidden commands generated by rules.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>read_only</i> is false, <b>SPI_execute</b> increments the
command counter and computes a new snapshot before executing
each command in the string. The snapshot does not actually
change if the current transaction isolation level is
SERIALIZABLE or REPEATABLE READ, but in READ COMMITTED mode
the snapshot update allows each command to see the results
of newly committed transactions from other sessions. This is
essential for consistent behavior when the commands are
modifying the database.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>read_only</i> is true, <b>SPI_execute</b> does not update
either the snapshot or the command counter, and it allows
only plain <b>SELECT</b> commands to appear in the command
string. The commands are executed using the snapshot
previously established for the surrounding query. This
execution mode is somewhat faster than the read/write mode
due to eliminating per&minus;command overhead. It also
allows genuinely stable functions to be built: since
successive executions will all use the same snapshot, there
will be no change in the results.</p>

<p style="margin-left:11%; margin-top: 1em">It is generally
unwise to mix read&minus;only and read&minus;write commands
within a single function using SPI; that could result in
very confusing behavior, since the read&minus;only queries
would not see the results of any database updates done by
the read&minus;write queries.</p>

<p style="margin-left:11%; margin-top: 1em">The actual
number of rows for which the (last) command was executed is
returned in the global variable <i>SPI_processed</i>. If the
return value of the function is SPI_OK_SELECT,
SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING, or
SPI_OK_UPDATE_RETURNING, then you can use the global pointer
SPITupleTable *SPI_tuptable to access the result rows. Some
utility commands (such as <b>EXPLAIN</b>) also return row
sets, and SPI_tuptable will contain the result in these
cases too.</p>

<p style="margin-left:11%; margin-top: 1em">The structure
SPITupleTable is defined thus:</p>

<p style="margin-left:17%; margin-top: 1em">typedef struct
<br>
{ <br>
MemoryContext tuptabcxt; /* memory context of result table
*/ <br>
uint32 alloced; /* number of alloced vals */ <br>
uint32 free; /* number of free vals */ <br>
TupleDesc tupdesc; /* row descriptor */ <br>
HeapTuple *vals; /* rows */ <br>
} SPITupleTable;</p>

<p style="margin-left:11%; margin-top: 1em">vals is an
array of pointers to rows. (The number of valid entries is
given by <i>SPI_processed</i>.) tupdesc is a row descriptor
which you can pass to SPI functions dealing with rows.
tuptabcxt, alloced, and free are internal fields not
intended for use by SPI callers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SPI_finish</b>
frees all SPITupleTables allocated during the current
procedure. You can free a particular result table earlier,
if you are done with it, by calling
<b>SPI_freetuptable</b>.</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">const char *
<i>command</i></p>

<p style="margin-left:17%;">string containing command to
execute</p>

<p style="margin-left:11%; margin-top: 1em">bool
<i>read_only</i></p>

<p style="margin-left:17%;">true for read&minus;only
execution</p>

<p style="margin-left:11%; margin-top: 1em">long
<i>count</i></p>

<p style="margin-left:17%;">maximum number of rows to
return, or 0 for no limit</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the
execution of the command was successful then one of the
following (nonnegative) values will be returned:</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_SELECT</p>

<p style="margin-left:17%;">if a <b>SELECT</b> (but not
<b>SELECT INTO</b>) was executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_SELINTO</p>

<p style="margin-left:17%;">if a <b>SELECT INTO</b> was
executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_INSERT</p>

<p style="margin-left:17%;">if an <b>INSERT</b> was
executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_DELETE</p>

<p style="margin-left:17%;">if a <b>DELETE</b> was
executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_UPDATE</p>

<p style="margin-left:17%;">if an <b>UPDATE</b> was
executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_INSERT_RETURNING</p>

<p style="margin-left:17%;">if an <b>INSERT RETURNING</b>
was executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_DELETE_RETURNING</p>

<p style="margin-left:17%;">if a <b>DELETE RETURNING</b>
was executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_UPDATE_RETURNING</p>

<p style="margin-left:17%;">if an <b>UPDATE RETURNING</b>
was executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_UTILITY</p>

<p style="margin-left:17%;">if a utility command (e.g.,
<b>CREATE TABLE</b>) was executed</p>


<p style="margin-left:11%; margin-top: 1em">SPI_OK_REWRITTEN</p>

<p style="margin-left:17%;">if the command was rewritten
into another kind of command (e.g., <b>UPDATE</b> became an
<b>INSERT</b>) by a rule.</p>

<p style="margin-left:11%; margin-top: 1em">On error, one
of the following negative values is returned:</p>


<p style="margin-left:11%; margin-top: 1em">SPI_ERROR_ARGUMENT</p>

<p style="margin-left:17%;">if <i>command</i> is NULL or
<i>count</i> is less than 0</p>


<p style="margin-left:11%; margin-top: 1em">SPI_ERROR_COPY</p>

<p style="margin-left:17%;">if <b>COPY TO stdout</b> or
<b>COPY FROM stdin</b> was attempted</p>


<p style="margin-left:11%; margin-top: 1em">SPI_ERROR_TRANSACTION</p>

<p style="margin-left:17%;">if a transaction manipulation
command was attempted (<b>BEGIN</b>, <b>COMMIT</b>,
<b>ROLLBACK</b>, <b>SAVEPOINT</b>, <b>PREPARE
TRANSACTION</b>, <b>COMMIT PREPARED</b>, <b>ROLLBACK
PREPARED</b>, or any variant thereof)</p>


<p style="margin-left:11%; margin-top: 1em">SPI_ERROR_OPUNKNOWN</p>

<p style="margin-left:17%;">if the command type is unknown
(shouldn't happen)</p>


<p style="margin-left:11%; margin-top: 1em">SPI_ERROR_UNCONNECTED</p>

<p style="margin-left:17%;">if called from an unconnected
procedure</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All SPI
query&minus;execution functions set both
<i>SPI_processed</i> and <i>SPI_tuptable</i> (just the
pointer, not the contents of the structure). Save these two
global variables into local procedure variables if you need
to access the result table of <b>SPI_execute</b> or another
query&minus;execution function across later calls.</p>
<hr>
</body>
</html>
