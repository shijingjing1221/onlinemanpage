<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:02:03 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Util</title>

</head>
<body>

<h1 align="center">Util</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#INSTALLATION">INSTALLATION</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#EXPORT_OK">EXPORT_OK</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">NetAddr::IP::Util
&minus;&minus; IPv4/6 and 128 bit number utilities</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP::Util qw(
        inet_aton
        inet_ntoa
        ipv6_aton
        ipv6_ntoa
        ipv6_n2x
        ipv6_n2d
        inet_any2n
        hasbits
        isIPv4
        isNewIPv4
        isAnyIPv4
        inet_n2dx
        inet_n2ad
        inet_pton
        inet_ntop
        inet_4map6
        ipv4to6
        mask4to6
        ipanyto6
        maskanyto6
        ipv6to4
        packzeros
        shiftleft
        addconst
        add128
        sub128
        notcontiguous
        bin2bcd
        bcd2bin
        mode
        AF_INET
        AF_INET6
        naip_gethostbyname
  );
  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
  :inet   =&gt;    inet_aton, inet_ntoa, ipv6_aton
                ipv6_ntoa, ipv6_n2x, ipv6_n2d,
                inet_any2n, inet_n2dx, inet_n2ad,
                inet_pton, inet_ntop, inet_4map6,
                ipv4to6, mask4to6, ipanyto6, packzeros
                maskanyto6, ipv6to4, naip_gethostbyname
  :ipv4   =&gt;    inet_aton, inet_ntoa
  :ipv6   =&gt;    ipv6_aton, ipv6_ntoa, ipv6_n2x,
                ipv6_n2d, inet_any2n, inet_n2dx,
                inet_n2ad, inet_pton, inet_ntop,
                inet_4map6, ipv4to6, mask4to6,
                ipanyto6, maskanyto6, ipv6to4,
                packzeros, naip_gethostbyname
  :math   =&gt;    hasbits, isIPv4, isNewIPv4, isAnyIPv4,
                addconst, add128, sub128, notcontiguous,
                bin2bcd, bcd2bin, shiftleft
  $dotquad = inet_ntoa($netaddr);
  $netaddr = inet_aton($dotquad);
  $ipv6naddr = ipv6_aton($ipv6_text);
  $ipv6_text = ipvt_ntoa($ipv6naddr);
  $hex_text = ipv6_n2x($ipv6naddr);
  $dec_text = ipv6_n2d($ipv6naddr);
  $hex_text = packzeros($hex_text);
  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
  $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
  $rv = hasbits($bits128);
  $rv = isIPv4($bits128);
  $rv = isNewIPv4($bits128);
  $rv = isAnyIPv4($bits128);
  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
  $netaddr = inet_pton($AF_family,$hex_text);
  $hex_text = inet_ntop($AF_family,$netaddr);
  $ipv6naddr = ipv4to6($netaddr);
  $ipv6naddr = mask4to6($netaddr);
  $ipv6naddr = ipanyto6($netaddr);
  $ipv6naddr = maskanyto6($netaddr);
  $netaddr = ipv6to4($pv6naddr);
  $bitsX2 = shiftleft($bits128,$n);
  $carry = addconst($ipv6naddr,$signed_32con);
  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
  $carry = add128($ipv6naddr1,$ipv6naddr2);
  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
  $carry = sub128($ipv6naddr1,$ipv6naddr2);
  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
  ($spurious,$cidr) = notcontiguous($mask128);
  $bcdtext = bin2bcd($bits128);
  $bits128 = bcd2bin($bcdtxt);
  $modetext = mode;
  ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
  $trueif = havegethostbyname2();
  NetAddr::IP::Util::lower();
  NetAddr::IP::Util::upper();</pre>


<h2>INSTALLATION
<a name="INSTALLATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Un-tar the
distribution in an appropriate directory and type:</p>

<pre style="margin-left:11%; margin-top: 1em">        perl Makefile.PL
        make
        make test
        make install</pre>



<p style="margin-left:11%; margin-top: 1em"><b>NetAddr::IP::Util</b>
installs by default with its primary functions compiled
using Perl&rsquo;s <small>XS</small> extensions to build a
&rsquo;C&rsquo; library. If you do not have a
&rsquo;C&rsquo; complier available or would like the slower
Pure Perl version for some other reason, then type:</p>

<pre style="margin-left:11%; margin-top: 1em">        perl Makefile.PL &minus;noxs
        make
        make test
        make install</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>NetAddr::IP::Util</b>
provides a suite of tools for manipulating and converting
IPv4 and IPv6 addresses into 128 bit string context and back
to text. The strings can be manipulated with Perl&rsquo;s
logical operators:</p>

<pre style="margin-left:11%; margin-top: 1em">        and     &amp;
        or      |
        xor     ^
                ~       compliment</pre>


<p style="margin-left:11%; margin-top: 1em">in the same
manner as &rsquo;vec&rsquo; strings.</p>

<p style="margin-left:11%; margin-top: 1em">The IPv6
functions support all rfc1884 formats.</p>

<pre style="margin-left:11%; margin-top: 1em">  i.e.  x:x:x:x:x:x:x:x:x
        x:x:x:x:x:x:x:d.d.d.d
        ::x:x:x
        ::x:d.d.d.d
  and so on...</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="48%">


<p><tt>$dotquad</tt> = inet_ntoa($netaddr);</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert a
packed IPv4 network address to a dot-quad <small>IP</small>
address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        packed network address
  returns:      IP address i.e. 10.4.12.123</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>$netaddr</tt> =
inet_aton($dotquad);</p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert a
dot-quad <small>IP</small> address into an IPv4 packed
network address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        IP address i.e. 192.5.16.32
  returns:      packed network address</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>$ipv6addr</tt> =
ipv6_aton($ipv6_text);</p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Takes an IPv6
address of the form described in rfc1884 and returns a 128
bit binary <small>RDATA</small> string.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        ipv6 text
  returns:      128 bit RDATA string</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>$ipv6_text</tt> =
ipv6_ntoa($ipv6naddr);</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert a 128
bit binary IPv6 address to compressed rfc 1884 text
representation.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit RDATA string
  returns:      ipv6 text</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>$hex_text</tt> =
ipv6_n2x($ipv6addr);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Takes an IPv6
<small>RDATA</small> string and returns an 8 segment IPv6
hex address</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit RDATA string
  returns:      x:x:x:x:x:x:x:x</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>$dec_text</tt> =
ipv6_n2d($ipv6addr);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Takes an IPv6
<small>RDATA</small> string and returns a mixed hex &minus;
decimal IPv6 address with the 6 uppermost chunks in hex and
the lower 32 bits in dot-quad representation.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit RDATA string
  returns:      x:x:x:x:x:x:d.d.d.d</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
inet_any2n($dotquad or <tt>$ipv6_text</tt>);</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It
prefixes any dot-quad address (if found) with
&rsquo;::&rsquo; and passes it to <b>ipv6_aton</b>.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        dot&minus;quad or rfc1844 address
  returns:      128 bit IPv6 string</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>$rv</tt> =
hasbits($bits128);</p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
returns true if there are one&rsquo;s present in the 128 bit
string and false if all the bits are zero.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  if (hasbits($bits128)) {
          &amp;do_something;
        }
  or    if (hasbits($bits128 &amp; $mask128) {
          &amp;do_something;
        }</pre>


<p style="margin-left:17%; margin-top: 1em">This allows the
implementation of logical functions of the form of:</p>

<pre style="margin-left:17%; margin-top: 1em">        if ($bits128 &amp; $mask128) {
            ...
  input:        128 bit IPv6 string
  returns:      true if any bits are present</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
inet_4map6($netaddr or <tt>$ipv6naddr</tt></p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
returns an ipV6 network address with the first 80 bits set
to zero and the next 16 bits set to one, while the last 32
bits are filled with the ipV4 address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        ipV4 netaddr
            or  ipV6 netaddr
  returns:      ipV6 netaddr
  returns: undef on error</pre>


<p style="margin-left:17%; margin-top: 1em">An ipV6 network
address must be in one of the two compatible ipV4 mapped
address spaces. i.e.</p>

<pre style="margin-left:17%; margin-top: 1em">        ::ffff::d.d.d.d    or    ::d.d.d.d</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>$rv</tt> =
isIPv4($bits128);</p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  the address must be of the form &minus; ::d.d.d.d</pre>


<p style="margin-left:17%; margin-top: 1em">Note: this is
an old and deprecated ipV4 compatible ipV6 address</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>$rv</tt> =
isNewIPv4($bits128);</p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
return true if the IPv6 128 bit string is of the form</p>

<pre style="margin-left:17%; margin-top: 1em">        ::ffff::d.d.d.d</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>$rv</tt> =
isAnyIPv4($bits128);</p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
return true if the IPv6 bit string is of the form</p>

<pre style="margin-left:17%; margin-top: 1em">        ::d.d.d.d       or      ::ffff::d.d.d.d</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>$dotquad</tt> or
<tt>$hex_text</tt> = inet_n2dx($ipv6naddr);</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
<b>does the right thing</b> and returns the text for either
a dot-quad IPv4 or a hex notation IPv6 address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit IPv6 string
  returns:      ddd.ddd.ddd.ddd
            or  x:x:x:x:x:x:x:x</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>$dotquad</tt> or
<tt>$dec_text</tt> = inet_n2ad($ipv6naddr);</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
<b>does the right thing</b> and returns the text for either
a dot-quad IPv4 or a hex::decimal notation IPv6 address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit IPv6 string
  returns:      ddd.ddd.ddd.ddd
            or  x:x:x:x:x:x:ddd.ddd.ddd.dd</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>$netaddr</tt> =
inet_pton($AF_family,$hex_text);</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
takes an <small>IP</small> address in IPv4 or IPv6 text
format and converts it into binary format. The type of
<small>IP</small> address conversion is controlled by the
<small>FAMILY</small> argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>$hex_text</tt> =
inet_ntop($AF_family,$netaddr);</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
takes and <small>IP</small> address in binary format and
converts it into text format. The type of <small>IP</small>
address conversion is controlled by the
<small>FAMILY</small> argument.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
inet_ntop <small>ALWAYS</small> returns lowercase
characters.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p style="margin-top: 1em"><tt>$hex_text</tt> =
packzeros($hex_text);</p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
optimizes and rfc 1884 IPv6 hex address to reduce the number
of long strings of zero bits as specified in rfc 1884, 2.2
(2) by substituting <b>::</b> for the first occurence of the
longest string of zeros in the address.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
ipv4to6($netaddr);</p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert an ipv4
network address into an IPv6 network address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        32 bit network address
  returns:      128 bit network address</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
mask4to6($netaddr);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert an ipv4
network address/mask into an ipv6 network mask.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        32 bit network/mask address
  returns:      128 bit network/mask address</pre>



<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
returns the high 96 bits as one&rsquo;s</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
ipanyto6($netaddr);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Similar to
ipv4to6 except that this function takes either an IPv4 or
IPv6 input and always returns a 128 bit IPv6 network
address.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        32 or 128 bit network address
  returns:      128 bit network address</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>$ipv6naddr</tt> =
maskanyto6($netaddr);</p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Similar to
mask4to6 except that this function takes either an IPv4 or
IPv6 netmask and always returns a 128 bit IPv6 netmask.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        32 or 128 bit network mask
  returns:      128 bit network mask</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>$netaddr</tt> =
ipv6to4($pv6naddr);</p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Truncate the
upper 96 bits of a 128 bit address and return the lower 32
bits. Returns an IPv4 address as returned by inet_aton.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit network address
  returns:      32 bit inet_aton network address</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p style="margin-top: 1em"><tt>$bitsXn</tt> =
shiftleft($bits128,$n);</p> </td>
<td width="32%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit string variable,
                number of shifts [optional]
  returns:      bits X n shifts
  NOTE: a single shift is performed
        if $n is not specified</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">



<p style="margin-top: 1em">addconst($ipv6naddr,$signed_32con);</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Add a signed
constant to a 128 bit string variable.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit IPv6 string,
                signed 32 bit integer
  returns:  scalar      carry
            array       (carry, result)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">



<p style="margin-top: 1em">add128($ipv6naddr1,$ipv6naddr2);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Add two 128 bit
string variables.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit string var1,
                128 bit string var2
  returns:  scalar      carry
            array       (carry, result)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">



<p style="margin-top: 1em">sub128($ipv6naddr1,$ipv6naddr2);</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Subtract two
128 bit string variables.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit string var1,
                128 bit string var2
  returns:  scalar      carry
            array       (carry, result)</pre>


<p style="margin-left:17%; margin-top: 1em">Note: The carry
from this operation is the result of adding the one&rsquo;s
complement of <small>ARG2 +1</small> to the
<small>ARG1.</small> It is logically <b><small>NOT</small>
borrow</b>.</p>

<pre style="margin-left:17%; margin-top: 1em">        i.e.    if ARG1 &gt;= ARG2 then carry = 1
        or      if ARG1  &lt; ARG2 then carry = 0</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="68%">


<p style="margin-top: 1em">($spurious,$cidr) =
notcontiguous($mask128);</p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
counts the bit positions remaining in the mask when the
rightmost &rsquo;0&rsquo;s are removed.</p>

<pre style="margin-left:17%; margin-top: 1em">        input:  128 bit netmask
        returns true if there are spurious
                    zero bits remaining in the
                    mask, false if the mask is
                    contiguous one's,
                128 bit cidr number</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="45%">


<p style="margin-top: 1em"><tt>$bcdtext</tt> =
bin2bcd($bits128);</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert a 128
bit binary string into binary coded decimal text digits.</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        128 bit string variable
  returns:      string of bcd text digits</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>$bits128</tt> =
bcd2bin($bcdtxt);</p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Convert a bcd
text string to 128 bit string variable</p>

<pre style="margin-left:17%; margin-top: 1em">  input:        string of bcd text digits
  returns:      128 bit string variable</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em"><tt>$modetext</tt> = mode;</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Returns the
operating mode of this module.</p>

<pre style="margin-left:17%; margin-top: 1em">        input:          none
        returns:        &quot;Pure Perl&quot;
                   or   &quot;CC XS&quot;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">



<p style="margin-top: 1em">($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(
<small>NAME</small> );</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Replacement for
Perl&rsquo;s gethostbyname if Socket6 is available</p>

<p style="margin-left:17%; margin-top: 1em">In
<small>ARRAY</small> context, returns a list of five
elements, the hostname or <small>NAME,</small> a space
separated list of C_NAMES, <small>AF</small> family, length
of the address structure, and an array of one or more
netaddr&rsquo;s</p>

<p style="margin-left:17%; margin-top: 1em">In
<small>SCALAR</small> context, returns the first
netaddr.</p>

<p style="margin-left:17%; margin-top: 1em">This function
<small>ALWAYS</small> returns an IPv6 address, even on IPv4
only systems. IPv4 addresses are mapped into IPv6 space in
the form:</p>

<pre style="margin-left:17%; margin-top: 1em">        ::FFFF:FFFF:d.d.d.d</pre>


<p style="margin-left:17%; margin-top: 1em">This is
<small>NOT</small> the expected result from Perl&rsquo;s
gethostbyname2. It is instead equivalent to:</p>

<pre style="margin-left:17%; margin-top: 1em">  On an IPv4 only system:
    $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
  On a system with Socket6 and a working gethostbyname2:
    $ipv6naddr = gethostbyname2( name, AF_INET6 );
  and if that fails, the IPv4 conversion above.</pre>


<p style="margin-left:17%; margin-top: 1em">For a
gethostbyname2 emulator that behave like Socket6, see:
Net::DNS::Dig</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>$trueif</tt> =
<i>havegethostbyname2()</i>;</p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This function
returns <small>TRUE</small> if Socket6 has a functioning
<b>gethostbyname2</b>, otherwise it returns
<small>FALSE.</small> See the comments above about the
behavior of <b>naip_gethostbyname</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">



<p style="margin-top: 1em"><i>NetAddr::IP::Util::lower()</i>;</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Return IPv6
strings in lowercase.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">



<p style="margin-top: 1em"><i>NetAddr::IP::Util::upper()</i>;</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Return IPv6
strings in uppercase. This is the default.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  # convert any textual IP address into a 128 bit vector
  #
  sub text2vec {
    my($anyIP,$anyMask) = @_;
  # not IPv4 bit mask
    my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
    my $vecip   = inet_any2n($anyIP);
    my $mask    = inet_any2n($anyMask);
  # extend mask bits for IPv4
    my $bits = 128;     # default
    unless (hasbits($mask &amp; $notiv4)) {
      $mask |= $notiv4;
      $bits = 32;
    }
    return ($vecip, $mask, $bits);
  }
  ... alternate implementation, a little faster
  sub text2vec {
    my($anyIP,$anyMask) = @_;
  # not IPv4 bit mask
    my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
    my $vecip   = inet_any2n($anyIP);
    my $mask    = inet_any2n($anyMask);
  # extend mask bits for IPv4
    my $bits = 128;     # default
    if (isIPv4($mask)) {
      $mask |= $notiv4;
      $bits = 32;
    }
    return ($vecip, $mask, $bits);
  }
  ... elsewhere
    $nip = {
        addr    =&gt; $vecip,
        mask    =&gt; $mask,
        bits    =&gt; $bits,
    };
  # return network and broadcast addresses from IP and Mask
  #
  sub netbroad {
    my($nip) = shift;
    my $notmask = ~ $nip&minus;&gt;{mask};
    my $bcast   = $nip&minus;&gt;{addr} | $notmask;
    my $network = $nip&minus;&gt;{addr} &amp; $nip&minus;&gt;{mask};
    return ($network, $broadcast);
  }
  # check if address is within a network
  #
  sub within {
    my($nip,$net) = @_;
    my $addr = $nip&minus;&gt;{addr}
    my($nw,$bc) = netbroad($net);
  # arg1 &gt;= arg2, sub128 returns true
    return (sub128($addr,$nw) &amp;&amp; sub128($bc,$addr))
        ? 1 : 0;
  }
  # truely hard way to do $ip++
  # add a constant, wrapping at netblock boundaries
  # to subtract the constant, negate it before calling
  # 'addwrap' since 'addconst' will extend the sign bits
  #
  sub addwrap {
    my($nip,$const) = @_;
    my $addr    = $nip&minus;&gt;{addr};
    my $mask    = $nip&minus;&gt;{mask};
    my $bits    = $nip&minus;&gt;{bits};
    my $notmask = ~ $mask;
    my $hibits  = $addr &amp; $mask;
    $addr = addconst($addr,$const);
    my $wraponly = $addr &amp; $notmask;
    my $newip = {
        addr    =&gt; $hibits | $wraponly,
        mask    =&gt; $mask,
        bits    =&gt; $bits,
    };
    # bless $newip as appropriate
    return $newip;
  }
  # something more useful
  # increment a /24 net to the NEXT net at the boundry
  my $nextnet = 256;    # for /24
  LOOP:
  while (...continuing) {
    your code....
    ...
    my $lastip = $ip&minus;copy();
    $ip++;
    if ($ip &lt; $lastip) {        # host part wrapped?
  # discard carry
      (undef, $ip&minus;&gt;{addr} = addconst($ip&minus;&gt;{addr}, $nextnet);
    }
    next LOOP;
  }</pre>


<h2>EXPORT_OK
<a name="EXPORT_OK"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">        inet_aton
        inet_ntoa
        ipv6_aton
        ipv6_ntoa
        ipv6_n2x
        ipv6_n2d
        inet_any2n
        hasbits
        isIPv4
        isNewIPv4
        isAnyIPv4
        inet_n2dx
        inet_n2ad
        inet_pton
        inet_ntop
        inet_4map6
        ipv4to6
        mask4to6
        ipanyto6
        maskanyto6
        ipv6to4
        packzeros
        shiftleft
        addconst
        add128
        sub128
        notcontiguous
        bin2bcd
        bcd2bin
        mode
        naip_gethostbyname
        havegethostbyname2</pre>


<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Michael
Robinton &lt;michael@bizsystems.com&gt;</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright 2003
&minus; 2013, Michael Robinton
&lt;michael@bizsystems.com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">All rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of either:</p>

<pre style="margin-left:11%; margin-top: 1em">  a) the GNU General Public License as published by the Free
  Software Foundation; either version 2, or (at your option) any
  later version, or
  b) the &quot;Artistic License&quot; which comes with this distribution.</pre>


<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See either
the <small>GNU</small> General Public License or the
Artistic License for more details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the Artistic License with this
distribution, in the file named &quot;Artistic&quot;. If
not, I&rsquo;ll be glad to provide one.</p>

<p style="margin-left:11%; margin-top: 1em">You should also
have received a copy of the <small>GNU</small> General
Public License along with this program in the file named
&quot;Copying&quot;. If not, write to the</p>

<pre style="margin-left:11%; margin-top: 1em">        Free Software Foundation, Inc.
        51 Franklin Street, Fifth Floor
        Boston, MA 02110&minus;1301 USA.</pre>


<p style="margin-left:11%; margin-top: 1em">or visit their
web page on the internet at:</p>

<pre style="margin-left:11%; margin-top: 1em">        http://www.gnu.org/copyleft/gpl.html.</pre>


<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Michael
Robinton &lt;michael@bizsystems.com&gt;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>NetAddr::IP</i>(3),
<i>NetAddr::IP::Lite</i>(3),
<i>NetAddr::IP::InetBase</i>(3)</p>
<hr>
</body>
</html>
