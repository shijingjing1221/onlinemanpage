<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:26:15 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::_Hashtable&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</title>

</head>
<body>

<h1 align="center">std::_Hashtable&lt; _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::_Hashtable&lt;
_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
_RehashPolicy, _Traits &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::__detail::_Hashtable_base&lt; _Key, _Value,
_ExtractKey, _Equal, _H1, _H2, _Hash, _Traits &gt;</b>,
<b>std::__detail::_Map_base&lt; _Key, _Value, _Alloc,
_ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits
&gt;</b>, <b>std::__detail::_Insert&lt; _Key, _Value,
_Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy,
_Traits &gt;</b>, <b>std::__detail::_Rehash_base&lt; _Key,
_Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
_RehashPolicy, _Traits &gt;</b>, and
<b>std::__detail::_Equality&lt; _Key, _Value, _Alloc,
_ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits
&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
using <b>const_iterator</b> = typename
<b>__hashtable_base::const_iterator</b> <br>
using <b>const_local_iterator</b> = typename
<b>__hashtable_base::const_local_iterator</b> <br>
typedef _Alloc::const_pointer <b>const_pointer</b> <br>
typedef _Alloc::const_reference <b>const_reference</b> <br>
using <b>difference_type</b> = typename
__hashtable_base::difference_type <br>
using <b>iterator</b> = typename
<b>__hashtable_base::iterator</b> <br>
typedef _Equal <b>key_equal</b> <br>
typedef _Key <b>key_type</b> <br>
using <b>local_iterator</b> = typename
<b>__hashtable_base::local_iterator</b> <br>
typedef _Alloc::pointer <b>pointer</b> <br>
typedef _Alloc::reference <b>reference</b> <br>
using <b>size_type</b> = typename
__hashtable_base::size_type <br>
typedef _Value <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>_Hashtable</b> (size_type
__bucket_hint, const _H1 &amp;, const _H2 &amp;, const _Hash
&amp;, const _Equal &amp;, const _ExtractKey &amp;, const
allocator_type &amp;) <br>
template&lt;typename _InputIterator &gt; <b>_Hashtable</b>
(_InputIterator __first, _InputIterator __last, size_type
__bucket_hint, const _H1 &amp;, const _H2 &amp;, const _Hash
&amp;, const _Equal &amp;, const _ExtractKey &amp;, const
allocator_type &amp;) <b><br>
_Hashtable</b> (const <b>_Hashtable</b> &amp;) <b><br>
_Hashtable</b> (<b>_Hashtable</b> &amp;&amp;) <b><br>
_Hashtable</b> (size_type __n=10, const _H1 &amp;__hf=_H1(),
const key_equal &amp;__eql=key_equal(), const allocator_type
&amp;__a=allocator_type()) <br>
template&lt;typename _InputIterator &gt; <b>_Hashtable</b>
(_InputIterator __f, _InputIterator __l, size_type __n=0,
const _H1 &amp;__hf=_H1(), const key_equal
&amp;__eql=key_equal(), const allocator_type
&amp;__a=allocator_type()) <b><br>
_Hashtable</b> (<b>initializer_list</b>&lt; value_type &gt;
__l, size_type __n=0, const _H1 &amp;__hf=_H1(), const
key_equal &amp;__eql=key_equal(), const allocator_type
&amp;__a=allocator_type()) <br>
const _RehashPolicy &amp; <b>__rehash_policy</b> () const
<br>
void <b>__rehash_policy</b> (const _RehashPolicy &amp;) <br>
template&lt;typename... _Args&gt; <b>_Hashtable</b>&lt;
_Key, _Value, <br>
_Alloc, _ExtractKey, _Equal, <br>
_H1, _H2, _Hash, _RehashPolicy, <br>
_Traits &gt;::__node_type * <b>_M_allocate_node</b> (_Args
&amp;&amp;...__args)&quot; <br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
typename <b>_Hashtable</b> <br>
&lt; _Key, _Value, _Alloc, <br>
_ExtractKey, _Equal, _H1, _H2, <br>
_Hash, _RehashPolicy, _Traits &gt; <br>
::iterator, bool &gt; <b>_M_emplace</b>
(<b>std::true_type</b>, _Args &amp;&amp;...__args)&quot;
<br>
template&lt;typename... _Args&gt; <b>_Hashtable</b>&lt;
_Key, _Value, <br>
_Alloc, _ExtractKey, _Equal, <br>
_H1, _H2, _Hash, _RehashPolicy, <br>
_Traits &gt;::iterator <b>_M_emplace</b>
(<b>std::false_type</b>, _Args &amp;&amp;...__args)&quot;
<br>
template&lt;typename _Arg &gt; <b>std::pair</b>&lt; typename
<b>_Hashtable</b> <br>
&lt; _Key, _Value, _Alloc, <br>
_ExtractKey, _Equal, _H1, _H2, <br>
_Hash, _RehashPolicy, _Traits &gt; <br>
::iterator, bool &gt; <b>_M_insert</b> (_Arg &amp;&amp;__v,
<b>std::true_type</b>)&quot; <br>
template&lt;typename _Arg &gt; <b>_Hashtable</b>&lt; _Key,
_Value, <br>
_Alloc, _ExtractKey, _Equal, <br>
_H1, _H2, _Hash, _RehashPolicy, <br>
_Traits &gt;::iterator <b>_M_insert</b> (_Arg &amp;&amp;__v,
<b>std::false_type</b>)&quot; <br>
iterator <b>begin</b> () noexcept <br>
const_iterator <b>begin</b> () const noexcept <br>
local_iterator <b>begin</b> (size_type __n) <br>
const_local_iterator <b>begin</b> (size_type __n) const <br>
size_type <b>bucket</b> (const key_type &amp;__k) const <br>
size_type <b>bucket_count</b> () const noexcept <br>
size_type <b>bucket_size</b> (size_type __n) const <br>
const_iterator <b>cbegin</b> () const noexcept <br>
const_local_iterator <b>cbegin</b> (size_type __n) const
<br>
const_iterator <b>cend</b> () const noexcept <br>
const_local_iterator <b>cend</b> (size_type __n) const <br>
void <b>clear</b> () noexcept <br>
size_type <b>count</b> (const key_type &amp;__k) const <br>
template&lt;typename... _Args&gt; __ireturn_type
<b>emplace</b> (_Args &amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; iterator
<b>emplace_hint</b> (const_iterator, _Args
&amp;&amp;...__args) <br>
bool <b>empty</b> () const noexcept <br>
iterator <b>end</b> () noexcept <br>
const_iterator <b>end</b> () const noexcept <br>
local_iterator <b>end</b> (size_type __n) <br>
const_local_iterator <b>end</b> (size_type __n) const
<b><br>
std::pair</b>&lt; iterator, iterator &gt; <b>equal_range</b>
(const key_type &amp;__k) <b><br>
std::pair</b>&lt; const_iterator, <br>
const_iterator &gt; <b>equal_range</b> (const key_type
&amp;__k) const &quot; <br>
iterator <b>erase</b> (const_iterator) <br>
iterator <b>erase</b> (iterator __it) <br>
size_type <b>erase</b> (const key_type &amp;__k) <br>
iterator <b>erase</b> (const_iterator, const_iterator) <br>
iterator <b>find</b> (const key_type &amp;__k) <br>
const_iterator <b>find</b> (const key_type &amp;__k) const
<br>
allocator_type <b>get_allocator</b> () const noexcept <br>
key_equal <b>key_eq</b> () const <br>
float <b>load_factor</b> () const noexcept <br>
size_type <b>max_bucket_count</b> () const noexcept <br>
size_type <b>max_size</b> () const noexcept <b><br>
_Hashtable</b> &amp; <b>operator=</b> (const
<b>_Hashtable</b> &amp;__ht) <b><br>
_Hashtable</b> &amp; <b>operator=</b> (<b>_Hashtable</b>
&amp;&amp;__ht) <b><br>
_Hashtable</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; value_type &gt; __l) <br>
void <b>rehash</b> (size_type __n) <br>
size_type <b>size</b> () const noexcept <br>
void <b>swap</b> (<b>_Hashtable</b> &amp;)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">size_type
<b>_M_bucket_index</b> (__node_type *__n) const <br>
size_type <b>_M_bucket_index</b> (const key_type &amp;__k,
__hash_code __c) const <br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
iterator, bool &gt; <b>_M_emplace</b>
(<b>std::true_type</b>, _Args &amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; iterator <b>_M_emplace</b>
(<b>std::false_type</b>, _Args &amp;&amp;...__args) <br>
const _Equal &amp; <b>_M_eq</b> () const <br>
_Equal &amp; <b>_M_eq</b> () <br>
bool <b>_M_equals</b> (const _Key &amp;__k, __hash_code __c,
__node_type *__n) const <br>
size_type <b>_M_erase</b> (<b>std::true_type</b>, const
key_type &amp;) <br>
size_type <b>_M_erase</b> (<b>std::false_type</b>, const
key_type &amp;) <br>
iterator <b>_M_erase</b> (size_type __bkt, __node_base
*__prev_n, __node_type *__n) <br>
__node_base * <b>_M_find_before_node</b> (size_type, const
key_type &amp;, __hash_code) const <br>
__node_type * <b>_M_find_node</b> (size_type __bkt, const
key_type &amp;__key, __hash_code __c) const <br>
__node_base * <b>_M_get_previous_node</b> (size_type __bkt,
__node_base *__n) <br>
template&lt;typename _Arg &gt; <b>std::pair</b>&lt;
iterator, bool &gt; <b>_M_insert</b> (_Arg &amp;&amp;,
<b>std::true_type</b>) <br>
template&lt;typename _Arg &gt; iterator <b>_M_insert</b>
(_Arg &amp;&amp;, <b>std::false_type</b>) <br>
void <b>_M_insert_bucket_begin</b> (size_type, __node_type
*) <br>
iterator <b>_M_insert_multi_node</b> (__hash_code __code,
__node_type *__n) <br>
iterator <b>_M_insert_unique_node</b> (size_type __bkt,
__hash_code __code, __node_type *__n) <br>
void <b>_M_remove_bucket_begin</b> (size_type __bkt,
__node_type *__next_n, size_type __next_bkt) <br>
void <b>_M_swap</b> (_Hashtable_base &amp;__x)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Keya ,
typename _Valuea , typename _Alloca , typename _ExtractKeya
, typename _Equala , typename _H1a , typename _H2a ,
typename _Hasha , typename _RehashPolicya , typename
_Traitsa , bool _Constant_iteratorsa, bool _Unique_keysa&gt;
struct <b>__detail::_Insert</b> <br>
template&lt;typename _Keya , typename _Valuea , typename
_Alloca , typename _ExtractKeya , typename _Equala ,
typename _H1a , typename _H2a , typename _Hasha , typename
_RehashPolicya , typename _Traitsa &gt; struct
<b>__detail::_Insert_base</b> <br>
template&lt;typename _Keya , typename _Valuea , typename
_Alloca , typename _ExtractKeya , typename _Equala ,
typename _H1a , typename _H2a , typename _Hasha , typename
_RehashPolicya , typename _Traitsa , bool _Unique_keysa&gt;
struct <b>__detail::_Map_base</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key, typename _Value, typename _Alloc, typename
_ExtractKey, typename _Equal, typename _H1, typename _H2,
typename _Hash, typename _RehashPolicy, typename
_Traits&gt;class std::_Hashtable&lt; _Key, _Value, _Alloc,
_ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits
&gt;</b> <br>
Primary class template _Hashtable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters:</b></p>

<p style="margin-left:17%;"><i>_Value</i> CopyConstructible
type. <i><br>
_Key</i> CopyConstructible type. <i><br>
_Alloc</i> An allocator type ([lib.allocator.requirements])
whose _Alloc::value_type is _Value. As a conforming
extension, we allow for _Alloc::value_type != _Value.
<i><br>
_ExtractKey</i> Function object that takes an object of type
_Value and returns a value of type _Key. <i><br>
_Equal</i> Function object that takes two objects of type k
and returns a bool-like value that is true if the two
objects are considered equal. <i><br>
_H1</i> The hash function. A unary function object with
argument type _Key and result type size_t. Return values
should be distributed over the entire range [0,
numeric_limits&lt;size_t&gt;:max()]. <i><br>
_H2</i> The range-hashing function (in the terminology of
Tavori and Dreizin). A binary function object whose argument
types and result type are all size_t. Given arguments r and
N, the return value is in the range [0, N). <i><br>
_Hash</i> The ranged hash function (Tavori and Dreizin). A
binary function whose argument types are _Key and size_t and
whose result type is size_t. Given arguments k and N, the
return value is in the range [0, N). Default: hash(k, N) =
h2(h1(k), N). If _Hash is anything other than the default,
_H1 and _H2 are ignored. <i><br>
_RehashPolicy</i> Policy class with three members, all of
which govern the bucket count. _M_next_bkt(n) returns a
bucket count no smaller than n. _M_bkt_for_elements(n)
returns a bucket count appropriate for an element count of
n. _M_need_rehash(n_bkt, n_elt, n_ins) determines whether,
if the current bucket count is n_bkt and the current element
count is n_elt, we need to increase the bucket count. If so,
returns make_pair(true, n), where n is the new bucket count.
If not, returns make_pair(false, &lt;anything&gt;) <i><br>
_Traits</i> Compile-time class with three boolean
std::integral_constant members: __cache_hash_code,
__constant_iterators, __unique_keys.</p>

<p style="margin-left:11%; margin-top: 1em">Each _Hashtable
data structure has:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p>_Bucket[] _M_buckets</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p>_Hash_node_base _M_bbegin</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p>size_type _M_bucket_count</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p>size_type _M_element_count</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">with _Bucket
being _Hash_node* and _Hash_node containing:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em">_Hash_node* _M_next</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p>Tp _M_value</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p>size_t _M_hash_code if cache_hash_code is true</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In terms of
Standard containers the hashtable is like the aggregation
of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">std::forward_list&lt;_Node&gt;
containing the elements</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">



<p>std::vector&lt;std::forward_list&lt;_Node&gt;::iterator&gt;
representing the buckets</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The non-empty
buckets contain the node before the first node in the
bucket. This design makes it possible to implement something
like a std::forward_list::insert_after on container
insertion and std::forward_list::erase_after on container
erase calls. _M_before_begin is equivalent to
std::forward_list::before_begin. Empty buckets contain
nullptr. Note that one of the non-empty buckets contains
&amp;_M_before_begin which is not a dereferenceable node so
the node pointer in a bucket shall never be dereferenced,
only its next node can be.</p>

<p style="margin-left:11%; margin-top: 1em">Walking through
a bucket&rsquo;s nodes requires a check on the hash code to
see if each node is still in the bucket. Such a design
assumes a quite efficient hash functor and is one of the
reasons it is highly advisable to set __cache_hash_code to
true.</p>

<p style="margin-left:11%; margin-top: 1em">The container
iterators are simply built from nodes. This way incrementing
the iterator is perfectly efficient independent of how many
empty buckets there are in the container.</p>

<p style="margin-left:11%; margin-top: 1em">On insert we
compute the element&rsquo;s hash code and use it to find the
bucket index. If the element must be inserted in an empty
bucket we add it at the beginning of the singly linked list
and make the bucket point to _M_before_begin. The bucket
that used to point to _M_before_begin, if any, is updated to
point to its new before begin node.</p>

<p style="margin-left:11%; margin-top: 1em">On erase, the
simple iterator design requires using the hash functor to
get the index of the bucket to update. For this reason, when
__cache_hash_code is set to false the hash functor must not
throw and this is enforced by a static assertion.</p>

<p style="margin-left:11%; margin-top: 1em">Functionality
is implemented by decomposition into base classes, where the
derived _Hashtable class is used in _Map_base, _Insert,
_Rehash_base, and _Equality base classes to access the
&rsquo;this&rsquo; pointer. _Hashtable_base is used in the
base classes as a non-recursive, fully-completed-type so
that detailed nested type information, such as iterator type
and node type, can be used. This is similar to the
&rsquo;Curiously Recurring Template Pattern&rsquo; (CRTP)
technique, but uses a reconstructed, not explicitly passed,
template pattern.</p>

<p style="margin-left:11%; margin-top: 1em">Base class
templates are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em">__detail::_Hashtable_base</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p>__detail::_Map_base</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p>__detail::_Insert</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p>__detail::_Rehash_base</p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p>__detail::_Equality</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 174 of file bits/hashtable.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
