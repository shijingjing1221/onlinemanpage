<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:26:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::__debug</title>

</head>
<body>

<h1 align="center">std::__debug</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Function Documentation">Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::__debug
&minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>bitset</b> <br>
class <b>deque</b> <br>
class <b>forward_list</b> <br>
class <b>list</b> <br>
class <b>map</b> <br>
class <b>multimap</b> <br>
class <b>multiset</b> <br>
class <b>set</b> <br>
class <b>unordered_map</b> <br>
class <b>unordered_multimap</b> <br>
class <b>unordered_multiset</b> <br>
class <b>unordered_set</b> <br>
class <b>vector</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Key ,
typename _Compare , typename _Allocator &gt; bool
<b>operator!=</b> (const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__lhs, const <b>multiset</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator!=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator!=</b> (const <b>set</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__lhs, const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__rhs)
<br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator!=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator!=</b> (const
<b>unordered_set</b>&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;__x, const <b>unordered_set</b>&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator!=</b>
(const <b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x, const <b>unordered_map</b>&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__ly) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator!=</b> (const
<b>unordered_multiset</b>&lt; _Value, _Hash, _Pred, _Alloc
&gt; &amp;__x, const <b>unordered_multiset</b>&lt; _Value,
_Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator!=</b>
(const <b>unordered_multimap</b>&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;__x, const
<b>unordered_multimap</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__y) <br>
template&lt;size_t _Nb&gt; <b>bitset</b>&lt; _Nb &gt;
<b>operator&amp;</b> (const <b>bitset</b>&lt; _Nb &gt;
&amp;__x, const <b>bitset</b>&lt; _Nb &gt; &amp;__y)
noexcept <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
template&lt;typename _CharT , typename _Traits , size_t
_Nb&gt; <b>std::basic_ostream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>operator&lt;&lt;</b>
(<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
&amp;__os, const <b>bitset</b>&lt; _Nb &gt; &amp;__x)&quot;
<br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator==</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator==</b> (const <b>set</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__lhs, const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__rhs)
<br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator==</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator==</b> (const
<b>unordered_set</b>&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;__x, const <b>unordered_set</b>&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator==</b>
(const <b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x, const <b>unordered_map</b>&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__ly) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator==</b> (const
<b>unordered_multiset</b>&lt; _Value, _Hash, _Pred, _Alloc
&gt; &amp;__x, const <b>unordered_multiset</b>&lt; _Value,
_Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator==</b>
(const <b>unordered_multimap</b>&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;__x, const
<b>unordered_multimap</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
template&lt;typename _CharT , typename _Traits , size_t
_Nb&gt; <b>std::basic_istream</b>&lt; _CharT, <br>
_Traits &gt; &amp; <b>operator&gt;&gt;</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>bitset</b>&lt; _Nb &gt; &amp;__x)&quot; <br>
template&lt;size_t _Nb&gt; <b>bitset</b>&lt; _Nb &gt;
<b>operator^</b> (const <b>bitset</b>&lt; _Nb &gt; &amp;__x,
const <b>bitset</b>&lt; _Nb &gt; &amp;__y) noexcept <br>
template&lt;size_t _Nb&gt; <b>bitset</b>&lt; _Nb &gt;
<b>operator|</b> (const <b>bitset</b>&lt; _Nb &gt; &amp;__x,
const <b>bitset</b>&lt; _Nb &gt; &amp;__y) noexcept <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_set</b>&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;__x, <b>unordered_set</b>&lt; _Value, _Hash, _Pred,
_Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; void <b>swap</b> (<b>multiset</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__x, <b>multiset</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt; &amp;__x, <b>unordered_map</b>&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; void <b>swap</b> (<b>set</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__x, <b>set</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; void <b>swap</b>
(<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; void <b>swap</b> (<b>map</b>&lt;
_Key, _Tp, _Compare, _Allocator &gt; &amp;__lhs,
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>list</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>list</b>&lt; _Tp, _Alloc &gt; &amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>forward_list</b>&lt; _Tp, _Alloc &gt;
&amp;__lx, <b>forward_list</b>&lt; _Tp, _Alloc &gt;
&amp;__ly) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_multiset</b>&lt; _Value, _Hash, _Pred, _Alloc
&gt; &amp;__x, <b>unordered_multiset</b>&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_multimap</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x, <b>unordered_multimap</b>&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;__y)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GNU debug code,
replaces standard behavior with debug behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Macros and
namespaces used by the implementation outside of debug
wrappers to verify certain properties. The
__glibcxx_requires_xxx macros are merely wrappers around the
__glibcxx_check_xxx wrappers when we are compiling with
debug mode, but disappear when we are in release mode so
that there is no checking performed in, e.g., the standard
library algorithms.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&lt;=
(const forward_list&lt; _Tp, _Alloc &gt; &amp;__lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp;__ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 768 of file debug/forward_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&gt;
(const forward_list&lt; _Tp, _Alloc &gt; &amp;__lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp;__ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 754 of file debug/forward_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&gt;=
(const forward_list&lt; _Tp, _Alloc &gt; &amp;__lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp;__ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 761 of file debug/forward_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void std::__debug::swap
(forward_list&lt; _Tp, _Alloc &gt; &amp;__lx,
forward_list&lt; _Tp, _Alloc &gt; &amp;__ly)</b>
<tt>[inline]</tt> <br>
See std::forward_list::swap().</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 775 of file debug/forward_list.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::swap().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
