<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov  5 22:01:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DOCKER</title>

</head>
<body>

<h1 align="center">DOCKER</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#Exposing log messages from the container to the host&rsquo;s log">Exposing log messages from the container to the host&rsquo;s log</a><br>
<a href="#Attaching to one or more from STDIN, STDOUT, STDERR">Attaching to one or more from STDIN, STDOUT, STDERR</a><br>
<a href="#Sharing IPC between containers">Sharing IPC between containers</a><br>
<a href="#Linking Containers">Linking Containers</a><br>
<a href="#Mapping Ports for External Usage">Mapping Ports for External Usage</a><br>
<a href="#Creating and Mounting a Data Volume Container">Creating and Mounting a Data Volume Container</a><br>
<a href="#Mounting External Volumes">Mounting External Volumes</a><br>
<a href="#Using alternative security labeling">Using alternative security labeling</a><br>
<a href="#HISTORY">HISTORY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">docker&minus;run
&minus; Run a command in a new container</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>docker
run</b>
[<b>&minus;a</b>|<b>&minus;&minus;attach</b>[=<i>[]</i>]]
[<b>&minus;&minus;add&minus;host</b>[=<i>[]</i>]]
[<b>&minus;&minus;blkio&minus;weight</b>[=<i>[BLKIO&minus;WEIGHT]</i>]]
[<b>&minus;&minus;cpu&minus;shares</b>[=<i>0</i>]]
[<b>&minus;&minus;cap&minus;add</b>[=<i>[]</i>]]
[<b>&minus;&minus;cap&minus;drop</b>[=<i>[]</i>]]
[<b>&minus;&minus;cgroup&minus;parent</b>[=<i>CGROUP&minus;PATH</i>]]
[<b>&minus;&minus;cidfile</b>[=<i>CIDFILE</i>]]
[<b>&minus;&minus;cpu&minus;period</b>[=<i>0</i>]]
[<b>&minus;&minus;cpu&minus;quota</b>[=<i>0</i>]]
[<b>&minus;&minus;cpuset&minus;cpus</b>[=<i>CPUSET&minus;CPUS</i>]]
[<b>&minus;&minus;cpuset&minus;mems</b>[=<i>CPUSET&minus;MEMS</i>]]
[<b>&minus;d</b>|<b>&minus;&minus;detach</b>[=<i>false</i>]]
[<b>&minus;&minus;device</b>[=<i>[]</i>]]
[<b>&minus;&minus;dns</b>[=<i>[]</i>]]
[<b>&minus;&minus;dns&minus;opt</b>[=<i>[]</i>]]
[<b>&minus;&minus;dns&minus;search</b>[=<i>[]</i>]]
[<b>&minus;e</b>|<b>&minus;&minus;env</b>[=<i>[]</i>]]
[<b>&minus;&minus;entrypoint</b>[=<i>ENTRYPOINT</i>]]
[<b>&minus;&minus;env&minus;file</b>[=<i>[]</i>]]
[<b>&minus;&minus;expose</b>[=<i>[]</i>]]
[<b>&minus;&minus;group&minus;add</b>[=<i>[]</i>]]
[<b>&minus;h</b>|<b>&minus;&minus;hostname</b>[=<i>HOSTNAME</i>]]
[<b>&minus;&minus;help</b>]
[<b>&minus;i</b>|<b>&minus;&minus;interactive</b>[=<i>false</i>]]
[<b>&minus;&minus;ipc</b>[=<i>IPC</i>]]
[<b>&minus;&minus;kernel&minus;memory</b>[=<i>KERNEL&minus;MEMORY</i>]]
[<b>&minus;l</b>|<b>&minus;&minus;label</b>[=<i>[]</i>]]
[<b>&minus;&minus;label&minus;file</b>[=<i>[]</i>]]
[<b>&minus;&minus;link</b>[=<i>[]</i>]]
[<b>&minus;&minus;log&minus;driver</b>[=<i>[]</i>]]
[<b>&minus;&minus;log&minus;opt</b>[=<i>[]</i>]]
[<b>&minus;&minus;lxc&minus;conf</b>[=<i>[]</i>]]
[<b>&minus;m</b>|<b>&minus;&minus;memory</b>[=<i>MEMORY</i>]]
[<b>&minus;&minus;mac&minus;address</b>[=<i>MAC&minus;ADDRESS</i>]]
[<b>&minus;&minus;memory&minus;reservation</b>[=<i>MEMORY&minus;RESERVATION</i>]]
[<b>&minus;&minus;memory&minus;swap</b>[=<i>MEMORY&minus;SWAP</i>]]
[<b>&minus;&minus;memory&minus;swappiness</b>[=<i>MEMORY&minus;SWAPPINESS</i>]]
[<b>&minus;&minus;name</b>[=<i>NAME</i>]]
[<b>&minus;&minus;net</b>[=<i>&quot;bridge&quot;</i>]]
[<b>&minus;&minus;oom&minus;kill&minus;disable</b>[=<i>false</i>]]
[<b>&minus;P</b>|<b>&minus;&minus;publish&minus;all</b>[=<i>false</i>]]
[<b>&minus;p</b>|<b>&minus;&minus;publish</b>[=<i>[]</i>]]
[<b>&minus;&minus;pid</b>[=<i>[]</i>]]
[<b>&minus;&minus;privileged</b>[=<i>false</i>]]
[<b>&minus;&minus;read&minus;only</b>[=<i>false</i>]]
[<b>&minus;&minus;restart</b>[=<i>RESTART</i>]]
[<b>&minus;&minus;rm</b>[=<i>false</i>]]
[<b>&minus;&minus;security&minus;opt</b>[=<i>[]</i>]]
[<b>&minus;&minus;stop&minus;signal</b>[=<i>SIGNAL</i>]]
[<b>&minus;&minus;sig&minus;proxy</b>[=<i>true</i>]]
[<b>&minus;t</b>|<b>&minus;&minus;tty</b>[=<i>false</i>]]
[<b>&minus;u</b>|<b>&minus;&minus;user</b>[=<i>USER</i>]]
[<b>&minus;v</b>|<b>&minus;&minus;volume</b>[=<i>[]</i>]]
[<b>&minus;&minus;ulimit</b>[=<i>[]</i>]]
[<b>&minus;&minus;uts</b>[=<i>[]</i>]]
[<b>&minus;&minus;volumes&minus;from</b>[=<i>[]</i>]]
[<b>&minus;w</b>|<b>&minus;&minus;workdir</b>[=<i>WORKDIR</i>]]
IMAGE [COMMAND] [ARG...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Run a process
in a new container. <b>docker run</b> starts a process with
its own file system, its own networking, and its own
isolated process tree. The IMAGE which starts the process
may define defaults related to the process that will be run
in the container, the networking to expose, and more, but
<b>docker run</b> gives final control to the operator or
administrator who starts the container from the image. For
that reason <b>docker run</b> has more options than any
other Docker command.</p>

<p style="margin-left:11%; margin-top: 1em">If the IMAGE is
not already loaded then <b>docker run</b> will pull the
IMAGE, and all image dependencies, from the repository in
the same way running <b>docker pull</b> IMAGE, before it
starts the container from that image.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;a</b>,
<b>&minus;&minus;attach</b>=[] <br>
Attach to STDIN, STDOUT or STDERR.</p>

<p style="margin-left:11%; margin-top: 1em">In foreground
mode (the default when <b>&minus;d</b> is not specified),
<b>docker run</b> can start the process in the container and
attach the console to the process&rsquo;s standard input,
output, and standard error. It can even pretend to be a TTY
(this is what most commandline executables expect) and pass
along signals. The <b>&minus;a</b> option can be set for
each of stdin, stdout, and stderr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;add&minus;host</b>=[]
<br>
Add a custom host&minus;to&minus;IP mapping (host:ip)</p>

<p style="margin-left:11%; margin-top: 1em">Add a line to
/etc/hosts. The format is hostname:ip. The
<b>&minus;&minus;add&minus;host</b> option can be set
multiple times.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;blkio&minus;weight</b>=0
<br>
Block IO weight (relative weight) accepts a weight value
between 10 and 1000.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;shares</b>=0
<br>
CPU shares (relative weight)</p>

<p style="margin-left:11%; margin-top: 1em">By default, all
containers get the same proportion of CPU cycles. This
proportion can be modified by changing the container&rsquo;s
CPU share weighting relative to the weighting of all other
running containers.</p>

<p style="margin-left:11%; margin-top: 1em">To modify the
proportion from the default of 1024, use the
<b>&minus;&minus;cpu&minus;shares</b> flag to set the
weighting to 2 or higher.</p>

<p style="margin-left:11%; margin-top: 1em">The proportion
will only apply when CPU&minus;intensive processes are
running. When tasks in one container are idle, other
containers can use the left&minus;over CPU time. The actual
amount of CPU time will vary depending on the number of
containers running on the system.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider three containers, one has a cpu&minus;share of 1024
and two others have a cpu&minus;share setting of 512. When
processes in all three containers attempt to use 100% of
CPU, the first container would receive 50% of the total CPU
time. If you add a fourth container with a cpu&minus;share
of 1024, the first container only gets 33% of the CPU. The
remaining containers receive 16.5%, 16.5% and 33% of the
CPU.</p>

<p style="margin-left:11%; margin-top: 1em">On a
multi&minus;core system, the shares of CPU time are
distributed over all CPU cores. Even if a container is
limited to less than 100% of CPU time, it can use 100% of
each individual CPU core.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider a system with more than three cores. If you start
one container <b>{C0}</b> with <b>&minus;c=512</b> running
one process, and another container <b>{C1}</b> with
<b>&minus;c=1024</b> running two processes, this can result
in the following division of CPU shares:</p>

<p style="margin-left:22%; margin-top: 1em">PID container
CPU CPU share <br>
100 {C0} 0 100% of CPU0 <br>
101 {C1} 1 100% of CPU1 <br>
102 {C1} 2 100% of CPU2</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cap&minus;add</b>=[]
<br>
Add Linux capabilities</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cap&minus;drop</b>=[]
<br>
Drop Linux capabilities</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cgroup&minus;parent</b>=&quot;&quot;
<br>
Path to cgroups under which the cgroup for the container
will be created. If the path is not absolute, the path is
considered to be relative to the cgroups path of the init
process. Cgroups will be created if they do not already
exist.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cidfile</b>=&quot;&quot;
<br>
Write the container ID to the file</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;period</b>=0
<br>
Limit the CPU CFS (Completely Fair Scheduler) period</p>

<p style="margin-left:11%; margin-top: 1em">Limit the
container&rsquo;s CPU usage. This flag tell the kernel to
restrict the container&rsquo;s CPU usage to the period you
specify.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpuset&minus;cpus</b>=&quot;&quot;
<br>
CPUs in which to allow execution (0&minus;3, 0,1)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpuset&minus;mems</b>=&quot;&quot;
<br>
Memory nodes (MEMs) in which to allow execution (0&minus;3,
0,1). Only effective on NUMA systems.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
four memory nodes on your system (0&minus;3), use
<tt>&minus;&minus;cpuset&minus;mems=0,1</tt> then processes
in your Docker container will only use memory from the first
two memory nodes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;quota</b>=0
<br>
Limit the CPU CFS (Completely Fair Scheduler) quota</p>

<p style="margin-left:11%; margin-top: 1em">Limit the
container&rsquo;s CPU usage. By default, containers run with
the full CPU resource. This flag tell the kernel to restrict
the container&rsquo;s CPU usage to the quota you
specify.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;d</b>,
<b>&minus;&minus;detach</b>=<i>true</i>|<i>false</i> <br>
Detached mode: run the container in the background and print
the new container ID. The default is <i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">At any time you
can run <b>docker ps</b> in the other shell to view a list
of the running containers. You can reattach to a detached
container with <b>docker attach</b>. If you choose to run a
container in the detached mode, then you cannot use the
<b>&minus;rm</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">When attached
in the tty mode, you can detach from a running container
without stopping the process by pressing the keys
CTRL&minus;P CTRL&minus;Q.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;device</b>=[]
<br>
Add a host device to the container (e.g.
&minus;&minus;device=/dev/sdc:/dev/xvdc:rwm)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dns&minus;search</b>=[]
<br>
Set custom DNS search domains (Use
&minus;&minus;dns&minus;search=. if you don&rsquo;t wish to
set the search domain)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dns&minus;opt</b>=[]
<br>
Set custom DNS options</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;dns</b>=[]
<br>
Set custom DNS servers</p>

<p style="margin-left:11%; margin-top: 1em">This option can
be used to override the DNS configuration passed to the
container. Typically this is necessary when the host DNS
configuration is invalid for the container (e.g.,
127.0.0.1). When this is the case the
<b>&minus;&minus;dns</b> flags is necessary for every
run.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;e</b>,
<b>&minus;&minus;env</b>=[] <br>
Set environment variables</p>

<p style="margin-left:11%; margin-top: 1em">This option
allows you to specify arbitrary environment variables that
are available for the process that will be launched inside
of the container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;entrypoint</b>=&quot;&quot;
<br>
Overwrite the default ENTRYPOINT of the image</p>

<p style="margin-left:11%; margin-top: 1em">This option
allows you to overwrite the default entrypoint of the image
that is set in the Dockerfile. The ENTRYPOINT of an image is
similar to a COMMAND because it specifies what executable to
run when the container starts, but it is (purposely) more
difficult to override. The ENTRYPOINT gives a container its
default nature or behavior, so that when you set an
ENTRYPOINT you can run the container as if it were that
binary, complete with default options, and you can pass in
more options via the COMMAND. But, sometimes an operator may
want to run something else inside the container, so you can
override the default ENTRYPOINT at runtime by using a
<b>&minus;&minus;entrypoint</b> and a string to specify the
new ENTRYPOINT.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;env&minus;file</b>=[]
<br>
Read in a line delimited file of environment variables</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;expose</b>=[]
<br>
Expose a port, or a range of ports (e.g.
&minus;&minus;expose=3300&minus;3310) informs Docker that
the container listens on the specified network ports at
runtime. Docker uses this information to interconnect
containers using links and to set up port redirection on the
host system.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;group&minus;add</b>=[]
<br>
Add additional groups to run as</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;hostname</b>=&quot;&quot; <br>
Container host name</p>

<p style="margin-left:11%; margin-top: 1em">Sets the
container host name that is available inside the
container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help</b>
<br>
Print usage statement</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;i</b>,
<b>&minus;&minus;interactive</b>=<i>true</i>|<i>false</i>
<br>
Keep STDIN open even if not attached. The default is
<i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When set to
true, keep stdin open even if not attached. The default is
false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ipc</b>=&quot;&quot;
<br>
Default is to create a private IPC namespace (POSIX SysV
IPC) for the container <br>
&rsquo;container:&lt;name|id&gt;&rsquo;: reuses another
container shared memory, semaphores and message queues <br>
&rsquo;host&rsquo;: use the host shared memory,semaphores
and message queues inside the container. Note: the host mode
gives the container full access to local shared memory and
is therefore considered insecure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;l</b>,
<b>&minus;&minus;label</b>=[] <br>
Set metadata on the container (e.g., &minus;&minus;label
com.example.key=value)</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;kernel&minus;memory</b>=&quot;&quot;
<br>
Kernel memory limit (format:
<tt>&lt;number&gt;[&lt;unit&gt;]</tt>, where unit = b, k, m
or g)</p>

<p style="margin-left:11%; margin-top: 1em">Constrains the
kernel memory available to a container. If a limit of 0 is
specified (not using
<tt>&minus;&minus;kernel&minus;memory</tt>), the
container&rsquo;s kernel memory is not limited. If you
specify a limit, it may be rounded up to a multiple of the
operating system&rsquo;s page size and the value can be very
large, millions of trillions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;label&minus;file</b>=[]
<br>
Read in a line delimited file of labels</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;link</b>=[]
<br>
Add link to another container in the form of &lt;name or
id&gt;:alias or just &lt;name or id&gt; in which case the
alias will match the name</p>

<p style="margin-left:11%; margin-top: 1em">If the operator
uses <b>&minus;&minus;link</b> when starting the new client
container, then the client container can access the exposed
port via a private networking interface. Docker will set
some environment variables in the client container to help
indicate which interface and port to use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;lxc&minus;conf</b>=[]
<br>
(lxc exec&minus;driver only) Add custom lxc options
&minus;&minus;lxc&minus;conf=&quot;lxc.cgroup.cpuset.cpus =
0,1&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;log&minus;driver</b>=&quot;|<i>json&minus;file</i>|<i>syslog</i>|<i>journald</i>|<i>gelf</i>|<i>fluentd</i>|<i>awslogs</i>|<i>none</i>&quot;
<br>
Logging driver for container. Default is defined by daemon
<tt>&minus;&minus;log&minus;driver</tt> flag. <b><br>
Warning</b>: the <tt>docker logs</tt> command works only for
the <tt>json&minus;file</tt> and <tt><br>
journald</tt> logging drivers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;log&minus;opt</b>=[]
<br>
Logging driver specific options.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;m</b>,
<b>&minus;&minus;memory</b>=&quot;&quot; <br>
Memory limit (format: &lt;number&gt;[&lt;unit&gt;], where
unit = b, k, m or g)</p>

<p style="margin-left:11%; margin-top: 1em">Allows you to
constrain the memory available to a container. If the host
supports swap memory, then the <b>&minus;m</b> memory
setting can be larger than physical RAM. If a limit of 0 is
specified (not using <b>&minus;m</b>), the container&rsquo;s
memory is not limited. The actual limit may be rounded up to
a multiple of the operating system&rsquo;s page size (the
value would be very large, that&rsquo;s millions of
trillions).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;memory&minus;reservation</b>=&quot;&quot;
<br>
Memory soft limit (format: &lt;number&gt;[&lt;unit&gt;],
where unit = b, k, m or g)</p>

<p style="margin-left:11%; margin-top: 1em">After setting
memory reservation, when the system detects memory
contention or low memory, containers are forced to restrict
their consumption to their reservation. So you should always
set the value below <b>&minus;&minus;memory</b>, otherwise
the hard limit will take precedence. By default, memory
reservation will be the same as memory limit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;memory&minus;swap</b>=&quot;&quot;
<br>
Total memory limit (memory + swap)</p>

<p style="margin-left:11%; margin-top: 1em">Set
<tt>&minus;1</tt> to disable swap (format:
&lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g).
This value should always larger than <b>&minus;m</b>, so you
should always use this with <b>&minus;m</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;mac&minus;address</b>=&quot;&quot;
<br>
Container MAC address (e.g. 92:d0:c6:0a:29:33)</p>

<p style="margin-left:11%; margin-top: 1em">Remember that
the MAC address in an Ethernet network must be unique. The
IPv6 link&minus;local address will be based on the
device&rsquo;s MAC address according to RFC4862.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;name</b>=&quot;&quot;
<br>
Assign a name to the container</p>

<p style="margin-left:11%; margin-top: 1em">The operator
can identify a container in three ways: <br>
UUID long identifier
(&ldquo;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&rdquo;)
<br>
UUID short identifier (&ldquo;f78375b1c487&rdquo;) <br>
Name (&ldquo;jonah&rdquo;)</p>

<p style="margin-left:11%; margin-top: 1em">The UUID
identifiers come from the Docker daemon, and if a name is
not assigned to the container with <b>&minus;&minus;name</b>
then the daemon will also generate a random string name. The
name is useful when defining links (see
<b>&minus;&minus;link</b>) (or any other place you need to
identify a container). This works for both background and
foreground Docker containers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;net</b>=&quot;bridge&quot;
<br>
Set the Network mode for the container <br>
&rsquo;bridge&rsquo;: creates a new network stack for the
container on the docker bridge <br>
&rsquo;none&rsquo;: no networking for this container <br>
&rsquo;container:&lt;name|id&gt;&rsquo;: reuses another
container network stack <br>
&rsquo;host&rsquo;: use the host network stack inside the
container. Note: the host mode gives the container full
access to local system services such as D&minus;bus and is
therefore considered insecure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;oom&minus;kill&minus;disable</b>=<i>true</i>|<i>false</i>
<br>
Whether to disable OOM Killer for the container or not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;P</b>,
<b>&minus;&minus;publish&minus;all</b>=<i>true</i>|<i>false</i>
<br>
Publish all exposed ports to random ports on the host
interfaces. The default is <i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When set to
true publish all exposed ports to the host interfaces. The
default is false. If the operator uses &minus;P (or
&minus;p) then Docker will make the exposed port accessible
on the host and the ports will be available to any client
that can reach the host. When using &minus;P, Docker will
bind any exposed port to a random port on the host within an
<i>ephemeral port range</i> defined by
<tt>/proc/sys/net/ipv4/ip_local_port_range</tt>. To find the
mapping between the host ports and the exposed ports, use
<tt>docker port</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;p</b>,
<b>&minus;&minus;publish</b>=[] <br>
Publish a container&rsquo;s port, or range of ports, to the
host.</p>

<p style="margin-left:11%; margin-top: 1em">Format:
<tt>ip:hostPort:containerPort | ip::containerPort |
hostPort:containerPort | containerPort</tt> Both hostPort
and containerPort can be specified as a range of ports. When
specifying ranges for both, the number of container ports in
the range must match the number of host ports in the range.
(e.g., <tt>docker run &minus;p
1234&minus;1236:1222&minus;1224 &minus;&minus;name thisWorks
&minus;t busybox</tt> but not <tt>docker run &minus;p
1230&minus;1236:1230&minus;1240 &minus;&minus;name
RangeContainerPortsBiggerThanRangeHostPorts &minus;t
busybox</tt>) With ip: <tt>docker run &minus;p
127.0.0.1:$HOSTPORT:$CONTAINERPORT &minus;&minus;name
CONTAINER &minus;t someimage</tt> Use <tt>docker port</tt>
to see the actual mapping: <tt>docker port CONTAINER
$CONTAINERPORT</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;pid</b>=host
<br>
Set the PID mode for the container <b><br>
host</b>: use the host&rsquo;s PID namespace inside the
container. <br>
Note: the host mode gives the container full access to local
PID and is therefore considered insecure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;uts</b>=host
<br>
Set the UTS mode for the container <b><br>
host</b>: use the host&rsquo;s UTS namespace inside the
container. <br>
Note: the host mode gives the container access to changing
the host&rsquo;s hostname and is therefore considered
insecure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;privileged</b>=<i>true</i>|<i>false</i>
<br>
Give extended privileges to this container. The default is
<i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Docker containers are &ldquo;unprivileged&rdquo; (=false)
and cannot, for example, run a Docker daemon inside the
Docker container. This is because by default a container is
not allowed to access any devices. A
&ldquo;privileged&rdquo; container is given access to all
devices.</p>

<p style="margin-left:11%; margin-top: 1em">When the
operator executes <b>docker run
&minus;&minus;privileged</b>, Docker will enable access to
all devices on the host as well as set some configuration in
AppArmor to allow the container nearly all the same access
to the host as processes running outside of a container on
the host.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;read&minus;only</b>=<i>true</i>|<i>false</i>
<br>
Mount the container&rsquo;s root filesystem as read
only.</p>

<p style="margin-left:11%; margin-top: 1em">By default a
container will have its root filesystem writable allowing
processes to write files anywhere. By specifying the
<tt>&minus;&minus;read&minus;only</tt> flag the container
will have its root filesystem mounted as read only
prohibiting any writes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;restart</b>=&quot;no&quot;
<br>
Restart policy to apply when a container exits (no,
on&minus;failure[:max&minus;retry], always,
unless&minus;stopped).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;rm</b>=<i>true</i>|<i>false</i>
<br>
Automatically remove the container when it exits
(incompatible with &minus;d). The default is
<i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;security&minus;opt</b>=[]
<br>
Security Options</p>


<p style="margin-left:11%; margin-top: 1em">&quot;label:user:USER&quot;
: Set the label user for the container <br>
&quot;label:role:ROLE&quot; : Set the label role for the
container <br>
&quot;label:type:TYPE&quot; : Set the label type for the
container <br>
&quot;label:level:LEVEL&quot; : Set the label level for the
container <br>
&quot;label:disable&quot; : Turn off label confinement for
the container</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;stop&minus;signal</b>=SIGTERM
<br>
Signal to stop a container. Default is SIGTERM.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;sig&minus;proxy</b>=<i>true</i>|<i>false</i>
<br>
Proxy received signals to the process (non&minus;TTY mode
only). SIGCHLD, SIGSTOP, and SIGKILL are not proxied. The
default is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;memory&minus;swappiness</b>=&quot;&quot;
<br>
Tune a container&rsquo;s memory swappiness behavior. Accepts
an integer between 0 and 100.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;tty</b>=<i>true</i>|<i>false</i> <br>
Allocate a pseudo&minus;TTY. The default is
<i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">When set to
true Docker can allocate a pseudo&minus;tty and attach to
the standard input of any container. This can be used, for
example, to run a throwaway interactive shell. The default
is value is false.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;t</b> option is incompatible with a redirection of
the docker client standard input.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;u</b>,
<b>&minus;&minus;user</b>=&quot;&quot; <br>
Sets the username or UID used and optionally the groupname
or GID for the specified command.</p>

<p style="margin-left:11%; margin-top: 1em">The followings
examples are all valid: <br>
&minus;&minus;user [user | user:group | uid | uid:gid |
user:gid | uid:group ]</p>

<p style="margin-left:11%; margin-top: 1em">Without this
argument the command will be run as root in the
container.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;&quot;&minus;&minus;ulimit&quot;&quot;=[]
<br>
Ulimit options</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;v</b>,
<b>&minus;&minus;volume</b>=[] Create a bind mount <br>
(format:
<tt>[host&minus;dir:]container&minus;dir[:&lt;suffix
options&gt;]</tt>, where suffix options are comma delimited
and selected from [rw|ro] and [z|Z].)</p>

<p style="margin-left:11%; margin-top: 1em">(e.g., using
&minus;v /host&minus;dir:/container&minus;dir, bind mounts
/host&minus;dir in the host to /container&minus;dir in the
Docker container)</p>

<p style="margin-left:11%; margin-top: 1em">If
&rsquo;host&minus;dir&rsquo; is missing, then docker
automatically creates the new volume on the host. <b>This
auto&minus;creation of the host path has been deprecated in
Release: v1.9.</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;v</b> option can be used one or more times to add
one or more mounts to a container. These mounts can then be
used in other containers using the
<b>&minus;&minus;volumes&minus;from</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">The volume may
be optionally suffixed with :ro or :rw to mount the volumes
in read&minus;only or read&minus;write mode, respectively.
By default, the volumes are mounted read&minus;write. See
examples.</p>

<p style="margin-left:11%; margin-top: 1em">Labeling
systems like SELinux require that proper labels are placed
on volume content mounted into a container. Without a label,
the security system might prevent the processes running
inside the container from using the content. By default,
Docker does not change the labels set by the OS.</p>

<p style="margin-left:11%; margin-top: 1em">To change a
label in the container context, you can add either of two
suffixes <tt>:z</tt> or <tt>:Z</tt> to the volume mount.
These suffixes tell Docker to relabel file objects on the
shared volumes. The <tt>z</tt> option tells Docker that two
containers share the volume content. As a result, Docker
labels the content with a shared content label. Shared
volume labels allow all containers to read/write content.
The <tt>Z</tt> option tells Docker to label the content with
a private unshared label. Only the current container can use
a private volume.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>container&minus;dir</tt> must always be an absolute path
such as <tt>/src/docs</tt>. The <tt>host&minus;dir</tt> can
either be an absolute path or a <tt>name</tt> value. If you
supply an absolute path for the <tt>host&minus;dir</tt>,
Docker bind&minus;mounts to the path you specify. If you
supply a <tt>name</tt>, Docker creates a named volume by
that <tt>name</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">A <tt>name</tt>
value must start with start with an alphanumeric character,
followed by <tt>a&minus;z0&minus;9</tt>, <tt>_</tt>
(underscore), <tt>.</tt> (period) or <tt>&minus;</tt>
(hyphen). An absolute path starts with a <tt>/</tt> (forward
slash).</p>

<p style="margin-left:11%; margin-top: 1em">For example,
you can specify either <tt>/foo</tt> or <tt>foo</tt> for a
<tt>host&minus;dir</tt> value. If you supply the
<tt>/foo</tt> value, Docker creates a bind&minus;mount. If
you supply the <tt>foo</tt> specification, Docker creates a
named volume.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;volumes&minus;from</b>=[]
<br>
Mount volumes from the specified container(s)</p>

<p style="margin-left:11%; margin-top: 1em">Mounts already
mounted volumes from a source container onto another <br>
container. You must supply the source&rsquo;s
container&minus;id. To share <br>
a volume, use the <b>&minus;&minus;volumes&minus;from</b>
option when running <br>
the target container. You can share volumes even if the
source container <br>
is not running.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Docker mounts the volumes in the same mode (read&minus;write
or <br>
read&minus;only) as it is mounted in the source container.
Optionally, you <br>
can change this by suffixing the container&minus;id with
either the <tt>:ro</tt> or <tt><br>
:rw</tt> keyword.</p>

<p style="margin-left:11%; margin-top: 1em">If the location
of the volume from the source container overlaps with <br>
data residing on a target container, then the volume hides
<br>
that data on the target.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;w</b>,
<b>&minus;&minus;workdir</b>=&quot;&quot; <br>
Working directory inside the container</p>

<p style="margin-left:11%; margin-top: 1em">The default
working directory for running binaries within a container is
the root directory (/). The developer can set a different
default with the Dockerfile WORKDIR instruction. The
operator can override the working directory by using the
<b>&minus;w</b> option.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<h2>Exposing log messages from the container to the host&rsquo;s log
<a name="Exposing log messages from the container to the host&rsquo;s log"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you want
messages that are logged in your container to show up in the
host&rsquo;s syslog/journal then you should bind mount the
/dev/log directory as follows.</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;v /dev/log:/dev/log &minus;i &minus;t fedora
/bin/bash</p>

<p style="margin-left:11%; margin-top: 1em">From inside the
container you can test this by sending a message to the
log.</p>

<p style="margin-left:22%; margin-top: 1em">(bash)# logger
&quot;Hello from my container&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Then exit and
check the journal.</p>

<p style="margin-left:22%; margin-top: 1em"># exit</p>

<p style="margin-left:22%; margin-top: 1em"># journalctl
&minus;b | grep Hello</p>

<p style="margin-left:11%; margin-top: 1em">This should
list the message sent to logger.</p>

<h2>Attaching to one or more from STDIN, STDOUT, STDERR
<a name="Attaching to one or more from STDIN, STDOUT, STDERR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you do not
specify &minus;a then Docker will attach everything
(stdin,stdout,stderr) you&rsquo;d like to connect instead,
as in:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;a stdin &minus;a stdout &minus;i &minus;t fedora
/bin/bash</p>

<h2>Sharing IPC between containers
<a name="Sharing IPC between containers"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Using
shm_server.c available here: &lang;
https://www.cs.cf.ac.uk/Dave/C/node27.html&rang;</p>

<p style="margin-left:11%; margin-top: 1em">Testing
<tt>&minus;&minus;ipc=host</tt> mode:</p>

<p style="margin-left:11%; margin-top: 1em">Host shows a
shared memory segment with 7 pids attached, happens to be
from httpd:</p>

<p style="margin-left:22%; margin-top: 1em">$ sudo ipcs
&minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status <br>
0x01128e25 0 root 600 1000 7</p>

<p style="margin-left:11%; margin-top: 1em">Now run a
regular container, and it correctly does NOT see the shared
memory segment from the host:</p>

<p style="margin-left:22%; margin-top: 1em">$ docker run
&minus;it shm ipcs &minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status</p>

<p style="margin-left:11%; margin-top: 1em">Run a container
with the new <tt>&minus;&minus;ipc=host</tt> option, and it
now sees the shared memory segment from the host httpd:</p>

<p style="margin-left:22%; margin-top: 1em">$ docker run
&minus;it &minus;&minus;ipc=host shm ipcs &minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status <br>
0x01128e25 0 root 600 1000 7</p>

<p style="margin-left:11%; margin-top: 1em">Testing
<tt>&minus;&minus;ipc=container:CONTAINERID</tt> mode:</p>

<p style="margin-left:11%; margin-top: 1em">Start a
container with a program to create a shared memory
segment:</p>

<p style="margin-left:22%; margin-top: 1em">$ docker run
&minus;it shm bash <br>
$ sudo shm/shm_server <br>
$ sudo ipcs &minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status <br>
0x0000162e 0 root 666 27 1</p>

<p style="margin-left:11%; margin-top: 1em">Create a 2nd
container correctly shows no shared memory segment from 1st
container:</p>

<p style="margin-left:22%; margin-top: 1em">$ docker run
shm ipcs &minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status</p>

<p style="margin-left:11%; margin-top: 1em">Create a 3rd
container using the new
&minus;&minus;ipc=container:CONTAINERID option, now it shows
the shared memory segment from the first:</p>

<p style="margin-left:22%; margin-top: 1em">$ docker run
&minus;it &minus;&minus;ipc=container:ed735b2264ac shm ipcs
&minus;m <br>
$ sudo ipcs &minus;m</p>


<p style="margin-left:22%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;&minus;
Shared Memory Segments
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
key shmid owner perms bytes nattch status <br>
0x0000162e 0 root 666 27 1</p>

<h2>Linking Containers
<a name="Linking Containers"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The link
feature allows multiple containers to communicate with each
other. For example, a container whose Dockerfile has exposed
port 80 can be run and named as follows:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;name=link&minus;test &minus;d &minus;i
&minus;t fedora/httpd</p>

<p style="margin-left:11%; margin-top: 1em">A second
container, in this case called linker, can communicate with
the httpd container, named link&minus;test, by running with
the <b>&minus;&minus;link=&lt;name&gt;:&lt;alias&gt;</b></p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;t &minus;i &minus;&minus;link=link&minus;test:lt
&minus;&minus;name=linker fedora /bin/bash</p>

<p style="margin-left:11%; margin-top: 1em">Now the
container linker is linked to container link&minus;test with
the alias lt. Running the <b>env</b> command in the linker
container shows environment variables <br>
with the LT (alias) context (<b>LT_</b>)</p>

<p style="margin-left:22%; margin-top: 1em"># env <br>
HOSTNAME=668231cb0978 <br>
TERM=xterm <br>
LT_PORT_80_TCP=tcp://172.17.0.3:80 <br>
LT_PORT_80_TCP_PORT=80 <br>
LT_PORT_80_TCP_PROTO=tcp <br>
LT_PORT=tcp://172.17.0.3:80 <br>

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<br>
PWD=/ <br>
LT_NAME=/linker/lt <br>
SHLVL=1 <br>
HOME=/ <br>
LT_PORT_80_TCP_ADDR=172.17.0.3 <br>
_=/usr/bin/env</p>

<p style="margin-left:11%; margin-top: 1em">When linking
two containers Docker will use the exposed ports of the
container to create a secure tunnel for the parent to
access.</p>

<p style="margin-left:11%; margin-top: 1em">If a container
is connected to the default bridge network and
<tt>linked</tt> with other containers, then the
container&rsquo;s <tt>/etc/hosts</tt> file is updated with
the linked container&rsquo;s name.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Note</b>
Since Docker may live update the container&rsquo;s
<tt>/etc/hosts</tt> file, there may be situations when
processes inside the container can end up reading an empty
or incomplete <tt>/etc/hosts</tt> file. In most cases,
retrying the read again should fix the problem.</p>

<h2>Mapping Ports for External Usage
<a name="Mapping Ports for External Usage"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The exposed
port of an application can be mapped to a host port using
the <b>&minus;p</b> flag. For example, a httpd port 80 can
be mapped to the host port 8080 using the following:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;p 8080:80 &minus;d &minus;i &minus;t fedora/httpd</p>

<h2>Creating and Mounting a Data Volume Container
<a name="Creating and Mounting a Data Volume Container"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many
applications require the sharing of persistent data across
several containers. Docker allows you to create a Data
Volume Container that other containers can mount from. For
example, create a named container that contains directories
/var/volume1 and /tmp/volume2. The image will need to
contain these directories so a couple of RUN mkdir
instructions might be required for you fedora&minus;data
image:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;name=data &minus;v /var/volume1 &minus;v
/tmp/volume2 &minus;i &minus;t fedora&minus;data true <br>
# docker run &minus;&minus;volumes&minus;from=data
&minus;&minus;name=fedora&minus;container1 &minus;i &minus;t
fedora bash</p>

<p style="margin-left:11%; margin-top: 1em">Multiple
&minus;&minus;volumes&minus;from parameters will bring
together multiple data volumes from multiple containers. And
it&rsquo;s possible to mount the volumes that came from the
DATA container in yet another container via the
fedora&minus;container1 intermediary container, allowing to
abstract the actual data source from users of that data:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;volumes&minus;from=fedora&minus;container1
&minus;&minus;name=fedora&minus;container2 &minus;i &minus;t
fedora bash</p>

<h2>Mounting External Volumes
<a name="Mounting External Volumes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To mount a host
directory as a container volume, specify the absolute path
to the directory and the absolute path for the container
directory separated by a colon:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;v /var/db:/data1 &minus;i &minus;t fedora bash</p>

<p style="margin-left:11%; margin-top: 1em">When using
SELinux, be aware that the host has no knowledge of
container SELinux policy. Therefore, in the above example,
if SELinux policy is enforced, the <tt>/var/db</tt>
directory is not writable to the container. A
&quot;Permission Denied&quot; message will occur and an avc:
message in the host&rsquo;s syslog.</p>

<p style="margin-left:11%; margin-top: 1em">To work around
this, at time of writing this man page, the following
command needs to be run in order for the proper SELinux
policy type label to be attached to the host directory:</p>

<p style="margin-left:22%; margin-top: 1em"># chcon
&minus;Rt svirt_sandbox_file_t /var/db</p>

<p style="margin-left:11%; margin-top: 1em">Now, writing to
the /data1 volume in the container will be allowed and the
changes will also be reflected on the host in /var/db.</p>

<h2>Using alternative security labeling
<a name="Using alternative security labeling"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can
override the default labeling scheme for each container by
specifying the <tt>&minus;&minus;security&minus;opt</tt>
flag. For example, you can specify the MCS/MLS level, a
requirement for MLS systems. Specifying the level in the
following command allows you to share the same content
between containers.</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;security&minus;opt label:level:s0:c100,c200
&minus;i &minus;t fedora bash</p>

<p style="margin-left:11%; margin-top: 1em">An MLS example
might be:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;security&minus;opt label:level:TopSecret
&minus;i &minus;t rhel7 bash</p>

<p style="margin-left:11%; margin-top: 1em">To disable the
security labeling for this container versus running with the
<tt>&minus;&minus;permissive</tt> flag, use the following
command:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;security&minus;opt label:disable &minus;i
&minus;t fedora bash</p>

<p style="margin-left:11%; margin-top: 1em">If you want a
tighter security policy on the processes within a container,
you can specify an alternate type for the container. You
could run a container that is only allowed to listen on
Apache ports by executing the following command:</p>

<p style="margin-left:22%; margin-top: 1em"># docker run
&minus;&minus;security&minus;opt label:type:svirt_apache_t
&minus;i &minus;t centos bash</p>

<p style="margin-left:11%; margin-top: 1em">Note:</p>

<p style="margin-left:11%; margin-top: 1em">You would have
to write policy defining a <tt>svirt_apache_t</tt> type.</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">April 2014,
Originally compiled by William Henry (whenry at redhat dot
com) based on docker.com source material and internal work.
June 2014, updated by Sven Dowideit &lang;
SvenDowideit@home.org.au&rang; July 2014, updated by Sven
Dowideit &lang; SvenDowideit@home.org.au&rang;</p>
<hr>
</body>
</html>
