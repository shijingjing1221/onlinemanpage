<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 01:08:16 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FANOTIFY</title>

</head>
<body>

<h1 align="center">FANOTIFY</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#VERSIONS">VERSIONS</a><br>
<a href="#CONFORMING TO">CONFORMING TO</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COLOPHON">COLOPHON</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fanotify
&minus; monitoring filesystem events</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API provides notification and interception of filesystem
events. Use cases include virus scanning and hierarchical
storage management. Currently, only a limited set of events
is supported. In particular, there is no support for create,
delete, and move events. (See <b>inotify</b>(7) for details
of an API that does notify those events.)</p>

<p style="margin-left:11%; margin-top: 1em">Additional
capabilities compared to the <b>inotify</b>(7) API include
the ability to monitor all of the objects in a mounted
filesystem, the ability to make access permission decisions,
and the possibility to read or modify files before access by
other applications.</p>

<p style="margin-left:11%; margin-top: 1em">The following
system calls are used with this API:
<b>fanotify_init</b>(2), <b>fanotify_mark</b>(2),
<b>read</b>(2), <b>write</b>(2), and <b>close</b>(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>fanotify_init(),
fanotify_mark(), and notification groups</b> <br>
The <b>fanotify_init</b>(2) system call creates and
initializes an fanotify notification group and returns a
file descriptor referring to it.</p>

<p style="margin-left:11%; margin-top: 1em">An fanotify
notification group is a kernel-internal object that holds a
list of files, directories, and mount points for which
events shall be created.</p>

<p style="margin-left:11%; margin-top: 1em">For each entry
in an fanotify notification group, two bit masks exist: the
<i>mark</i> mask and the <i>ignore</i> mask. The mark mask
defines file activities for which an event shall be created.
The ignore mask defines activities for which no event shall
be generated. Having these two types of masks permits a
mount point or directory to be marked for receiving events,
while at the same time ignoring events for specific objects
under that mount point or directory.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fanotify_mark</b>(2) system call adds a file, directory,
or mount to a notification group and specifies which events
shall be reported (or ignored), or removes or modifies such
an entry.</p>

<p style="margin-left:11%; margin-top: 1em">A possible
usage of the ignore mask is for a file cache. Events of
interest for a file cache are modification of a file and
closing of the same. Hence, the cached directory or mount
point is to be marked to receive these events. After
receiving the first event informing that a file has been
modified, the corresponding cache entry will be invalidated.
No further modification events for this file are of interest
until the file is closed. Hence, the modify event can be
added to the ignore mask. Upon receiving the close event,
the modify event can be removed from the ignore mask and the
file cache entry can be updated.</p>

<p style="margin-left:11%; margin-top: 1em">The entries in
the fanotify notification groups refer to files and
directories via their inode number and to mounts via their
mount ID. If files or directories are renamed or moved, the
respective entries survive. If files or directories are
deleted or mounts are unmounted, the corresponding entries
are deleted.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The event
queue</b> <br>
As events occur on the filesystem objects monitored by a
notification group, the fanotify system generates events
that are collected in a queue. These events can then be read
(using <b>read</b>(2) or similar) from the fanotify file
descriptor returned by <b>fanotify_init</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Two types of
events are generated: <i>notification</i> events and
<i>permission</i> events. Notification events are merely
informative and require no action to be taken by the
receiving application except for closing the file descriptor
passed in the event (see below). Permission events are
requests to the receiving application to decide whether
permission for a file access shall be granted. For these
events, the recipient must write a response which decides
whether access is granted or not.</p>

<p style="margin-left:11%; margin-top: 1em">An event is
removed from the event queue of the fanotify group when it
has been read. Permission events that have been read are
kept in an internal list of the fanotify group until either
a permission decision has been taken by writing to the
fanotify file descriptor or the fanotify file descriptor is
closed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reading
fanotify events</b> <br>
Calling <b>read</b>(2) for the file descriptor returned by
<b>fanotify_init</b>(2) blocks (if the flag
<b>FAN_NONBLOCK</b> is not specified in the call to
<b>fanotify_init</b>(2)) until either a file event occurs or
the call is interrupted by a signal (see
<b>signal</b>(7)).</p>

<p style="margin-left:11%; margin-top: 1em">After a
successful <b>read</b>(2), the read buffer contains one or
more of the following structures:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_metadata { <br>
__u32 event_len; <br>
__u8 vers; <br>
__u8 reserved; <br>
__u16 metadata_len; <br>
__aligned_u64 mask; <br>
__s32 fd; <br>
__s32 pid; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">For performance
reasons, it is recommended to use a large buffer size (for
example, 4096 bytes), so that multiple events can be
retrieved by a single <b>read</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The return
value of <b>read</b>(2) is the number of bytes placed in the
buffer, or &minus;1 in case of an error (but see BUGS).</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>fanotify_event_metadata</i> structure are as follows:
<i><br>
event_len</i></p>

<p style="margin-left:22%;">This is the length of the data
for the current event and the offset to the next event in
the buffer. In the current implementation, the value of
<i>event_len</i> is always <b>FAN_EVENT_METADATA_LEN</b>.
However, the API is designed to allow variable-length
structures to be returned in the future.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>vers</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This field holds a version number for the structure. It
must be compared to <b>FANOTIFY_METADATA_VERSION</b> to
verify that the structures returned at runtime match the
structures defined at compile time. In case of a mismatch,
the application should abandon trying to use the fanotify
file descriptor.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>reserved</i></p>

<p style="margin-left:22%;">This field is not used.</p>

<p style="margin-left:11%;"><i>metadata_len</i></p>

<p style="margin-left:22%;">This is the length of the
structure. The field was introduced to facilitate the
implementation of optional headers per event type. No such
optional headers exist in the current implementation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>mask</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This is a bit mask describing the event (see below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>fd</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This is an open file descriptor for the object being
accessed, or <b>FAN_NOFD</b> if a queue overflow occurred.
The file descriptor can be used to access the contents of
the monitored file or directory. The reading application is
responsible for closing this file descriptor.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When calling
<b>fanotify_init</b>(2), the caller may specify (via the
<i>event_f_flags</i> argument) various file status flags
that are to be set on the open file description that
corresponds to this file descriptor. In addition, the
(kernel-internal) <b>FMODE_NONOTIFY</b> file status flag is
set on the open file description. This flag suppresses
fanotify event generation. Hence, when the receiver of the
fanotify event accesses the notified file or directory using
this file descriptor, no additional events will be
created.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><i>pid</i></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">This is the ID of the process
that caused the event. A program listening to fanotify
events can compare this PID to the PID returned by
<b>getpid</b>(2), to determine whether the event is caused
by the listener itself, or is due to a file access by
another process.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The bit mask in
<i>mask</i> indicates which events have occurred for a
single filesystem object. Multiple bits may be set in this
mask, if more than one event occurred for the monitored
filesystem object. In particular, consecutive events for the
same filesystem object and originating from the same process
may be merged into a single event, with the exception that
two permission events are never merged into one queue
entry.</p>

<p style="margin-left:11%; margin-top: 1em">The bits that
may appear in <i>mask</i> are as follows: <b><br>
FAN_ACCESS</b></p>

<p style="margin-left:22%;">A file or a directory (but see
BUGS) was accessed (read).</p>

<p style="margin-left:11%;"><b>FAN_OPEN</b></p>

<p style="margin-left:22%;">A file or a directory was
opened.</p>

<p style="margin-left:11%;"><b>FAN_MODIFY</b></p>

<p style="margin-left:22%;">A file was modified.</p>

<p style="margin-left:11%;"><b>FAN_CLOSE_WRITE</b></p>

<p style="margin-left:22%;">A file that was opened for
writing (<b>O_WRONLY</b> or <b>O_RDWR</b>) was closed.</p>

<p style="margin-left:11%;"><b>FAN_CLOSE_NOWRITE</b></p>

<p style="margin-left:22%;">A file or directory that was
opened read-only (<b>O_RDONLY</b>) was closed.</p>

<p style="margin-left:11%;"><b>FAN_Q_OVERFLOW</b></p>

<p style="margin-left:22%;">The event queue exceeded the
limit of 16384 entries. This limit can be overridden by
specifying the <b>FAN_UNLIMITED_QUEUE</b> flag when calling
<b>fanotify_init</b>(2).</p>

<p style="margin-left:11%;"><b>FAN_ACCESS_PERM</b></p>

<p style="margin-left:22%;">An application wants to read a
file or directory, for example using <b>read</b>(2) or
<b>readdir</b>(2). The reader must write a response (as
described below) that determines whether the permission to
access the filesystem object shall be granted.</p>

<p style="margin-left:11%;"><b>FAN_OPEN_PERM</b></p>

<p style="margin-left:22%;">An application wants to open a
file or directory. The reader must write a response that
determines whether the permission to open the filesystem
object shall be granted.</p>

<p style="margin-left:11%; margin-top: 1em">To check for
any close event, the following bit mask may be used: <b><br>
FAN_CLOSE</b></p>

<p style="margin-left:22%;">A file was closed. This is a
synonym for:</p>


<p style="margin-left:22%; margin-top: 1em">FAN_CLOSE_WRITE
| FAN_CLOSE_NOWRITE</p>

<p style="margin-left:11%; margin-top: 1em">The following
macros are provided to iterate over a buffer containing
fanotify event metadata returned by a <b>read</b>(2) from an
fanotify file descriptor: <b><br>
FAN_EVENT_OK(meta, len)</b></p>

<p style="margin-left:22%;">This macro checks the remaining
length <i>len</i> of the buffer <i>meta</i> against the
length of the metadata structure and the <i>event_len</i>
field of the first metadata structure in the buffer.</p>

<p style="margin-left:11%;"><b>FAN_EVENT_NEXT(meta,
len)</b></p>

<p style="margin-left:22%;">This macro uses the length
indicated in the <i>event_len</i> field of the metadata
structure pointed to by <i>meta</i> to calculate the address
of the next metadata structure that follows <i>meta</i>.
<i>len</i> is the number of bytes of metadata that currently
remain in the buffer. The macro returns a pointer to the
next metadata structure that follows <i>meta</i>, and
reduces <i>len</i> by the number of bytes in the the
metadata structure that has been skipped over (i.e., it
subtracts <i>meta&minus;&gt;event_len</i> from
<i>len</i>).</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
there is: <b><br>
FAN_EVENT_METADATA_LEN</b></p>

<p style="margin-left:22%;">This macro returns the size (in
bytes) of the structure <i>fanotify_event_metadata</i>. This
is the minimum size (and currently the only size) of any
event metadata.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Monitoring
an fanotify file descriptor for events</b> <br>
When an fanotify event occurs, the fanotify file descriptor
indicates as readable when passed to <b>epoll</b>(7),
<b>poll</b>(2), or <b>select</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Dealing with
permission events</b> <br>
For permission events, the application must <b>write</b>(2)
a structure of the following form to the fanotify file
descriptor:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_response { <br>
__s32 fd; <br>
__u32 response; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
this structure are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>fd</i></p></td>
<td width="8%"></td>
<td width="78%">


<p>This is the file descriptor from the structure
<i>fanotify_event_metadata</i>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>response</i></p>

<p style="margin-left:22%;">This field indicates whether or
not the permission is to be granted. Its value must be
either <b>FAN_ALLOW</b> to allow the file operation or
<b>FAN_DENY</b> to deny the file operation.</p>

<p style="margin-left:11%; margin-top: 1em">If access is
denied, the requesting application call will receive an
<b>EPERM</b> error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Closing the
fanotify file descriptor</b> <br>
When all file descriptors referring to the fanotify
notification group are closed, the fanotify group is
released and its resources are freed for reuse by the
kernel. Upon <b>close</b>(2), outstanding permission events
will be set to allowed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>/proc/[pid]/fdinfo</b>
<br>
The file <i>/proc/[pid]/fdinfo/[fd]</i> contains information
about fanotify marks for file descriptor <i>fd</i> of
process <i>pid</i>. See the kernel source file
<i>Documentation/filesystems/proc.txt</i> for details.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In addition to
the usual errors for <b>read</b>(2), the following errors
can occur when reading from the fanotify file
descriptor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The buffer is too small to hold the event.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The per-process limit on the number of open files has
been reached. See the description of <b>RLIMIT_NOFILE</b> in
<b>getrlimit</b>(2).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system-wide limit on the number of open files has
been reached. See <i>/proc/sys/fs/file-max</i> in
<b>proc</b>(5).</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;">This error is returned by
<b>read</b>(2) if <b>O_RDWR</b> or <b>O_WRONLY</b> was
specified in the <i>event_f_flags</i> argument when calling
<b>fanotify_init</b>(2) and an event occurred for a
monitored file that is currently being executed.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the usual errors for <b>write</b>(2), the following errors
can occur when writing to the fanotify file descriptor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Fanotify access permissions are not enabled in the
kernel configuration or the value of <i>response</i> in the
response structure is not valid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The file descriptor <i>fd</i> in the response structure
is not valid. This may occur when a response for the
permission event has already been written.</p></td></tr>
</table>

<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API was introduced in version 2.6.36 of the Linux kernel and
enabled in version 2.6.37. Fdinfo support was added in
version 3.8.</p>

<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API is Linux-specific.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API is available only if the kernel was built with the
<b>CONFIG_FANOTIFY</b> configuration option enabled. In
addition, fanotify permission handling is available only if
the <b>CONFIG_FANOTIFY_ACCESS_PERMISSIONS</b> configuration
option is enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limitations
and caveats</b> <br>
Fanotify reports only events that a user-space program
triggers through the filesystem API. As a result, it does
not catch remote events that occur on network
filesystems.</p>

<p style="margin-left:11%; margin-top: 1em">The fanotify
API does not report file accesses and modifications that may
occur because of <b>mmap</b>(2), <b>msync</b>(2), and
<b>munmap</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Events for
directories are created only if the directory itself is
opened, read, and closed. Adding, removing, or changing
children of a marked directory does not create events for
the monitored directory itself.</p>

<p style="margin-left:11%; margin-top: 1em">Fanotify
monitoring of directories is not recursive: to monitor
subdirectories under a directory, additional marks must be
created. (But note that the fanotify API provides no way of
detecting when a subdirectory has been created under a
marked directory, which makes recursive monitoring
difficult.) Monitoring mounts offers the capability to
monitor a whole directory tree.</p>

<p style="margin-left:11%; margin-top: 1em">The event queue
can overflow. In this case, events are lost.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As of Linux
3.15, the following bugs exist:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">*</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">When an event is generated, no
check is made to see whether the user ID of the receiving
process has authorization to read or write the file before
passing a file descriptor for that file. This poses a
security risk, when the <b>CAP_SYS_ADMIN</b> capability is
set for programs executed by unprivileged users.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="3%"></td>
<td width="85%">


<p>If a call to <b>read</b>(2) processes multiple events
from the fanotify queue and an error occurs, the return
value will be the total length of the events successfully
copied to the user-space buffer before the error occurred.
The return value will not be &minus;1, and <i>errno</i> will
not be set. Thus, the reading application has no way to
detect the error.</p></td></tr>
</table>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
program demonstrates the usage of the fanotify API. It marks
the mount point passed as a command-line argument and waits
for events of type <b>FAN_PERM_OPEN</b> and
<b>FAN_CLOSE_WRITE</b>. When a permission event occurs, a
<b>FAN_ALLOW</b> response is given.</p>

<p style="margin-left:11%; margin-top: 1em">The following
output was recorded while editing the file
<i>/home/user/temp/notes</i>. Before the file was opened, a
<b>FAN_OPEN_PERM</b> event occurred. After the file was
closed, a <b>FAN_CLOSE_WRITE</b> event occurred. Execution
of the program ends when the user presses the ENTER key.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
output</b></p>

<p style="margin-left:17%;"># ./fanotify_example /home <br>
Press enter key to terminate. <br>
Listening for events. <br>
FAN_OPEN_PERM: File /home/user/temp/notes <br>
FAN_CLOSE_WRITE: File /home/user/temp/notes</p>

<p style="margin-left:17%; margin-top: 1em">Listening for
events stopped.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source</b> <br>
#define _GNU_SOURCE /* Needed to get O_LARGEFILE definition
*/ <br>
#include &lt;errno.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;limits.h&gt; <br>
#include &lt;poll.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;sys/fanotify.h&gt; <br>
#include &lt;unistd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">/* Read all
available fanotify events from the file descriptor
&rsquo;fd&rsquo; */</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
handle_events(int fd) <br>
{ <br>
const struct fanotify_event_metadata *metadata; <br>
struct fanotify_event_metadata buf[200]; <br>
ssize_t len; <br>
char path[PATH_MAX]; <br>
ssize_t path_len; <br>
char procfd_path[PATH_MAX]; <br>
struct fanotify_response response;</p>

<p style="margin-left:11%; margin-top: 1em">/* Loop while
events can be read from fanotify file descriptor */</p>

<p style="margin-left:11%; margin-top: 1em">for(;;) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Read some
events */</p>

<p style="margin-left:11%; margin-top: 1em">len = read(fd,
(void *) &amp;buf, sizeof(buf)); <br>
if (len == &minus;1 &amp;&amp; errno != EAGAIN) { <br>
perror(&quot;read&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Check if end
of available data reached */</p>

<p style="margin-left:11%; margin-top: 1em">if (len &lt;=
0) <br>
break;</p>

<p style="margin-left:11%; margin-top: 1em">/* Point to the
first event in the buffer */</p>

<p style="margin-left:11%; margin-top: 1em">metadata =
buf;</p>

<p style="margin-left:11%; margin-top: 1em">/* Loop over
all events in the buffer */</p>

<p style="margin-left:11%; margin-top: 1em">while
(FAN_EVENT_OK(metadata, len)) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Check that
run&minus;time and compile&minus;time structures match
*/</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;vers != FANOTIFY_METADATA_VERSION) {
<br>
fprintf(stderr, <br>
&quot;Mismatch of fanotify metadata version.\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/*
metadata&minus;&gt;fd contains either FAN_NOFD, indicating a
<br>
queue overflow, or a file descriptor (a nonnegative <br>
integer). Here, we simply ignore queue overflow. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;fd &gt;= 0) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Handle open
permission event */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask &amp; FAN_OPEN_PERM) { <br>
printf(&quot;FAN_OPEN_PERM: &quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Allow file
to be opened */</p>

<p style="margin-left:11%; margin-top: 1em">response.fd =
metadata&minus;&gt;fd; <br>
response.response = FAN_ALLOW; <br>
write(fd, &amp;response, <br>
sizeof(struct fanotify_response)); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Handle
closing of writable file event */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask &amp; FAN_CLOSE_WRITE) <br>
printf(&quot;FAN_CLOSE_WRITE: &quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Retrieve and
print pathname of the accessed file */</p>


<p style="margin-left:11%; margin-top: 1em">snprintf(procfd_path,
sizeof(procfd_path), <br>
&quot;/proc/self/fd/%d&quot;, metadata&minus;&gt;fd); <br>
path_len = readlink(procfd_path, path, <br>
sizeof(path) &minus; 1); <br>
if (path_len == &minus;1) { <br>
perror(&quot;readlink&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">path[path_len]
= &rsquo;\0&rsquo;; <br>
printf(&quot;File %s\n&quot;, path);</p>

<p style="margin-left:11%; margin-top: 1em">/* Close the
file descriptor of the event */</p>


<p style="margin-left:11%; margin-top: 1em">close(metadata&minus;&gt;fd);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Advance to
next event */</p>

<p style="margin-left:11%; margin-top: 1em">metadata =
FAN_EVENT_NEXT(metadata, len); <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
char buf; <br>
int fd, poll_num; <br>
nfds_t nfds; <br>
struct pollfd fds[2];</p>

<p style="margin-left:11%; margin-top: 1em">/* Check mount
point is supplied */</p>

<p style="margin-left:11%; margin-top: 1em">if (argc != 2)
{ <br>
fprintf(stderr, &quot;Usage: %s MOUNT\n&quot;, argv[0]);
<br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Press
enter key to terminate.\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Create the
file descriptor for accessing the fanotify API */</p>

<p style="margin-left:11%; margin-top: 1em">fd =
fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT |
FAN_NONBLOCK, <br>
O_RDONLY | O_LARGEFILE); <br>
if (fd == &minus;1) { <br>
perror(&quot;fanotify_init&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Mark the
mount for: <br>
&minus; permission events before opening files <br>
&minus; notification events after closing a
write&minus;enabled <br>
file descriptor */</p>

<p style="margin-left:11%; margin-top: 1em">if
(fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT, <br>
FAN_OPEN_PERM | FAN_CLOSE_WRITE, &minus;1, <br>
argv[1]) == &minus;1) { <br>
perror(&quot;fanotify_mark&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Prepare for
polling */</p>

<p style="margin-left:11%; margin-top: 1em">nfds = 2;</p>

<p style="margin-left:11%; margin-top: 1em">/* Console
input */</p>

<p style="margin-left:11%; margin-top: 1em">fds[0].fd =
STDIN_FILENO; <br>
fds[0].events = POLLIN;</p>

<p style="margin-left:11%; margin-top: 1em">/* Fanotify
input */</p>

<p style="margin-left:11%; margin-top: 1em">fds[1].fd = fd;
<br>
fds[1].events = POLLIN;</p>

<p style="margin-left:11%; margin-top: 1em">/* This is the
loop to wait for incoming events */</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Listening
for events.\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">while (1) {
<br>
poll_num = poll(fds, nfds, &minus;1); <br>
if (poll_num == &minus;1) { <br>
if (errno == EINTR) /* Interrupted by a signal */ <br>
continue; /* Restart poll() */</p>


<p style="margin-left:11%; margin-top: 1em">perror(&quot;poll&quot;);
/* Unexpected error */ <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if (poll_num
&gt; 0) { <br>
if (fds[0].revents &amp; POLLIN) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Console
input is available: empty stdin and quit */</p>

<p style="margin-left:11%; margin-top: 1em">while
(read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf !=
&rsquo;\n&rsquo;) <br>
continue; <br>
break; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(fds[1].revents &amp; POLLIN) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Fanotify
events are available */</p>


<p style="margin-left:11%; margin-top: 1em">handle_events(fd);
<br>
} <br>
} <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Listening
for events stopped.\n&quot;); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>fanotify_init</b>(2),
<b>fanotify_mark</b>(2), <b>inotify</b>(7)</p>

<h2>COLOPHON
<a name="COLOPHON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page is
part of release 3.75 of the Linux <i>man-pages</i> project.
A description of the project, information about reporting
bugs, and the latest version of this page, can be found at
http://www.kernel.org/doc/man&minus;pages/.</p>
<hr>
</body>
</html>
