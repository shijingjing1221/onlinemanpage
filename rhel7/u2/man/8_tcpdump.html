<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:32:29 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TCPDUMP</title>

</head>
<body>

<h1 align="center">TCPDUMP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#OUTPUT FORMAT">OUTPUT FORMAT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">tcpdump &minus;
dump traffic on a network</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>tcpdump</b>
[ <b>&minus;AbdDefhHIJKlLnNOpqRStuUvxX</b> ] [
<b>&minus;B</b> <i>buffer_size</i> ] [ <b>&minus;c</b>
<i>count</i> ] <br>
[ <b>&minus;C</b> <i>file_size</i> ] [ <b>&minus;G</b>
<i>rotate_seconds</i> ] [ <b>&minus;F</b> <i>file</i> ] <br>
[ <b>&minus;i</b> <i>interface</i> ] [ <b>&minus;j</b>
<i>tstamp_type</i> ] [ <b>&minus;m</b> <i>module</i> ] [
<b>&minus;M</b> <i>secret</i> ] <br>
[ <b>&minus;P</b> <i>in|out|inout</i> ] <br>
[ <b>&minus;r</b> <i>file</i> ] [ <b>&minus;V</b>
<i>file</i> ] [ <b>&minus;s</b> <i>snaplen</i> ] [
<b>&minus;T</b> <i>type</i> ] [ <b>&minus;w</b> <i>file</i>
] <br>
[ <b>&minus;W</b> <i>filecount</i> ] <br>
[ <b>&minus;E</b> <i>spi@ipaddr algo:secret,...</i> ] <br>
[ <b>&minus;y</b> <i>datalinktype</i> ] [ <b>&minus;z</b>
<i>postrotate-command</i> ] [ <b>&minus;Z</b> <i>user</i> ]
<br>
[ <i>expression</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>Tcpdump</i>
prints out a description of the contents of packets on a
network interface that match the boolean <i>expression</i>.
It can also be run with the <b>&minus;w</b> flag, which
causes it to save the packet data to a file for later
analysis, and/or with the <b>&minus;r</b> flag, which causes
it to read from a saved packet file rather than to read
packets from a network interface. It can also be run with
the <b>&minus;V</b> flag, which causes it to read a list of
saved packet files. In all cases, only packets that match
<i>expression</i> will be processed by <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Tcpdump</i>
will, if not run with the <b>&minus;c</b> flag, continue
capturing packets until it is interrupted by a SIGINT signal
(generated, for example, by typing your interrupt character,
typically control-C) or a SIGTERM signal (typically
generated with the <b>kill</b>(1) command); if run with the
<b>&minus;c</b> flag, it will capture packets until it is
interrupted by a SIGINT or SIGTERM signal or the specified
number of packets have been processed.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>tcpdump</i> finishes capturing packets, it will report
counts of:</p>

<p style="margin-left:22%; margin-top: 1em">packets
&lsquo;&lsquo;captured&rsquo;&rsquo; (this is the number of
packets that <i>tcpdump</i> has received and processed);</p>

<p style="margin-left:22%; margin-top: 1em">packets
&lsquo;&lsquo;received by filter&rsquo;&rsquo; (the meaning
of this depends on the OS on which you&rsquo;re running
<i>tcpdump</i>, and possibly on the way the OS was
configured - if a filter was specified on the command line,
on some OSes it counts packets regardless of whether they
were matched by the filter expression and, even if they were
matched by the filter expression, regardless of whether
<i>tcpdump</i> has read and processed them yet, on other
OSes it counts only packets that were matched by the filter
expression regardless of whether <i>tcpdump</i> has read and
processed them yet, and on other OSes it counts only packets
that were matched by the filter expression and were
processed by <i>tcpdump</i>);</p>

<p style="margin-left:22%; margin-top: 1em">packets
&lsquo;&lsquo;dropped by kernel&rsquo;&rsquo; (this is the
number of packets that were dropped, due to a lack of buffer
space, by the packet capture mechanism in the OS on which
<i>tcpdump</i> is running, if the OS reports that
information to applications; if not, it will be reported as
0).</p>

<p style="margin-left:11%; margin-top: 1em">On platforms
that support the SIGINFO signal, such as most BSDs
(including Mac OS X) and Digital/Tru64 UNIX, it will report
those counts when it receives a SIGINFO signal (generated,
for example, by typing your
&lsquo;&lsquo;status&rsquo;&rsquo; character, typically
control-T, although on some platforms, such as Mac OS X, the
&lsquo;&lsquo;status&rsquo;&rsquo; character is not set by
default, so you must set it with <b>stty</b>(1) in order to
use it) and will continue capturing packets.</p>

<p style="margin-left:11%; margin-top: 1em">Reading packets
from a network interface may require that you have special
privileges; see the <b>pcap (3PCAP)</b> man page for
details. Reading a saved packet file doesn&rsquo;t require
special privileges.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;A</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print each packet (minus its
link level header) in ASCII. Handy for capturing web
pages.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;b</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Print the AS number in BGP packets in ASDOT notation
rather than ASPLAIN notation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;B</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Set the operating system capture buffer size to
<i>buffer_size</i>, in units of KiB (1024 bytes).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Exit after receiving <i>count</i> packets.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;C</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Before writing a raw packet to a savefile, check whether
the file is currently larger than <i>file_size</i> and, if
so, close the current savefile and open a new one. Savefiles
after the first savefile will have the name specified with
the <b>&minus;w</b> flag, with a number after it, starting
at 1 and continuing upward. The units of <i>file_size</i>
are millions of bytes (1,000,000 bytes, not 1,048,576
bytes).</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that when
used with <b>&minus;Z</b> option (enabled by default),
privileges are dropped before opening first savefile.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>&minus;d</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Dump the compiled
packet-matching code in a human readable form to standard
output and stop.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;dd</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Dump packet-matching code as a <b>C</b> program
fragment.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;ddd</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Dump packet-matching code as decimal numbers (preceded
with a count).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;D</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Print the list of the network interfaces available on
the system and on which <i>tcpdump</i> can capture packets.
For each network interface, a number and an interface name,
possibly followed by a text description of the interface, is
printed. The interface name or the number can be supplied to
the <b>&minus;i</b> flag to specify an interface on which to
capture.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This can be
useful on systems that don&rsquo;t have a command to list
them (e.g., Windows systems, or UNIX systems lacking
<b>ifconfig &minus;a</b>); the number can be useful on
Windows 2000 and later systems, where the interface name is
a somewhat complex string.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>&minus;D</b> flag will not be supported if <i>tcpdump</i>
was built with an older version of <i>libpcap</i> that lacks
the <b>pcap_findalldevs()</b> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;e</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print the link-level header on
each dump line. This can be used, for example, to print MAC
layer addresses for protocols such as Ethernet and IEEE
802.11.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;E</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Use <i>spi@ipaddr algo:secret</i> for decrypting IPsec
ESP packets that are addressed to <i>addr</i> and contain
Security Parameter Index value <i>spi</i>. This combination
may be repeated with comma or newline separation.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that
setting the secret for IPv4 ESP packets is supported at this
time.</p>

<p style="margin-left:22%; margin-top: 1em">Algorithms may
be <b>des-cbc</b>, <b>3des-cbc</b>, <b>blowfish-cbc</b>,
<b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>. The
default is <b>des-cbc</b>. The ability to decrypt packets is
only present if <i>tcpdump</i> was compiled with
cryptography enabled.</p>

<p style="margin-left:22%; margin-top: 1em"><i>secret</i>
is the ASCII text for ESP secret key. If preceded by 0x,
then a hex value will be read.</p>

<p style="margin-left:22%; margin-top: 1em">The option
assumes RFC2406 ESP, not RFC1827 ESP. The option is only for
debugging purposes, and the use of this option with a true
&lsquo;secret&rsquo; key is discouraged. By presenting IPsec
secret key onto command line you make it visible to others,
via <i>ps</i>(1) and other occasions.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
the above syntax, the syntax <i>file name</i> may be used to
have tcpdump read the provided file in. The file is opened
upon receiving the first ESP packet, so any special
permissions that tcpdump may have been given should already
have been given up.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;f</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print &lsquo;foreign&rsquo; IPv4
addresses numerically rather than symbolically (this option
is intended to get around serious brain damage in
Sun&rsquo;s NIS server &mdash; usually it hangs forever
translating non-local internet numbers).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The test for
&lsquo;foreign&rsquo; IPv4 addresses is done using the IPv4
address and netmask of the interface on which capture is
being done. If that address or netmask are not available,
available, either because the interface on which capture is
being done has no address or netmask or because the capture
is being done on the Linux &quot;any&quot; interface, which
can capture on more than one interface, this option will not
work correctly.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;F</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Use <i>file</i> as input for the
filter expression. An additional expression given on the
command line is ignored.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;G</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>If specified, rotates the dump file specified with the
<b>&minus;w</b> option every <i>rotate_seconds</i> seconds.
Savefiles will have the name specified by <b>&minus;w</b>
which should include a time format as defined by
<b>strftime</b>(3). If no time format is specified, each new
file will overwrite the previous.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">If used in
conjunction with the <b>&minus;C</b> option, filenames will
take the form of &lsquo;<i>file</i>&lt;count&gt;&rsquo;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;h</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print the tcpdump and libpcap
version strings, print a usage message, and exit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;H</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Attempt to detect 802.11s draft mesh headers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;i</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Listen on <i>interface</i>. If unspecified,
<i>tcpdump</i> searches the system interface list for the
lowest numbered, configured up interface (excluding
loopback), which may turn out to be, for example,
&lsquo;&lsquo;eth0&rsquo;&rsquo;.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">On Linux
systems with 2.2 or later kernels, an <i>interface</i>
argument of &lsquo;&lsquo;any&rsquo;&rsquo; can be used to
capture packets from all interfaces. Note that captures on
the &lsquo;&lsquo;any&rsquo;&rsquo; device will not be done
in promiscuous mode.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>&minus;D</b> flag is supported, an interface number as
printed by that flag can be used as the <i>interface</i>
argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;I</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Put the interface in
&quot;monitor mode&quot;; this is supported only on IEEE
802.11 Wi-Fi interfaces, and supported only on some
operating systems.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that in
monitor mode the adapter might disassociate from the network
with which it&rsquo;s associated, so that you will not be
able to use any wireless networks with that adapter. This
could prevent accessing files on a network server, or
resolving host names or network addresses, if you are
capturing in monitor mode and are not connected to another
network with another adapter.</p>

<p style="margin-left:22%; margin-top: 1em">This flag will
affect the output of the <b>&minus;L</b> flag. If
<b>&minus;I</b> isn&rsquo;t specified, only those link-layer
types available when not in monitor mode will be shown; if
<b>&minus;I</b> is specified, only those link-layer types
available when in monitor mode will be shown.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;j</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Set the time stamp type for the
capture to <i>tstamp_type</i>. The names to use for the time
stamp types are given in <b>pcap-tstamp-type</b>(7); not all
the types listed there will necessarily be valid for any
given interface.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;J</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>List the supported time stamp types for the interface
and exit. If the time stamp type cannot be set for the
interface, no time stamp types are listed.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;time&minus;stamp&minus;precision=</b><i>tstamp_precision</i></p>

<p style="margin-left:22%;">When capturing, set the time
stamp precision for the capture to <i>tstamp_precision</i>.
Note that availability of high precision time stamps
(nanoseconds) and their actual accuracy is platform and
hardware dependent. Also note that when writing captures
made with nanosecond accuracy to a savefile, the time stamps
are written with nanosecond resolution, and the file is
written with a different magic number, to indicate that the
time stamps are in seconds and nanoseconds; not all programs
that read pcap savefiles will be able to read those
captures.</p>

<p style="margin-left:22%; margin-top: 1em">When reading a
savefile, convert time stamps to the precision specified by
<i>timestamp_precision</i>, and display them with that
resolution. If the precision specified is less than the
precision of time stamps in the file, the conversion will
lose precision.</p>

<p style="margin-left:22%; margin-top: 1em">The supported
values for <i>timestamp_precision</i> are <b>micro</b> for
microsecond resolution and <b>nano</b> for nanosecond
resolution. The default is microsecond resolution.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;K</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Don&rsquo;t attempt to verify IP, TCP, or UDP checksums.
This is useful for interfaces that perform some or all of
those checksum calculation in hardware; otherwise, all
outgoing TCP checksums will be flagged as bad.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;l</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Make stdout line buffered. Useful if you want to see the
data while capturing it. E.g.,</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em"><b>tcpdump
&minus;l | tee dat</b></p>

<p style="margin-left:22%; margin-top: 1em">or</p>

<p style="margin-left:32%; margin-top: 1em"><b>tcpdump
&minus;l &gt; dat &amp; tail &minus;f dat</b></p>

<p style="margin-left:22%; margin-top: 1em">Note that on
Windows,&lsquo;&lsquo;line buffered&rsquo;&rsquo; means
&lsquo;&lsquo;unbuffered&rsquo;&rsquo;, so that WinDump will
write each character individually if <b>&minus;l</b> is
specified.</p>


<p style="margin-left:22%; margin-top: 1em"><b>&minus;U</b>
is similar to <b>&minus;l</b> in its behavior, but it will
cause output to be
&lsquo;&lsquo;packet-buffered&rsquo;&rsquo;, so that the
output is written to stdout at the end of each packet rather
than at the end of each line; this is buffered on all
platforms, including Windows.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>&minus;L</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">List the known data link types
for the interface, in the specified mode, and exit. The list
of known data link types may be dependent on the specified
mode; for example, on some platforms, a Wi-Fi interface
might support one set of data link types when not in monitor
mode (for example, it might support only fake Ethernet
headers, or might support 802.11 headers but not support
802.11 headers with radio information) and another set of
data link types when in monitor mode (for example, it might
support 802.11 headers, or 802.11 headers with radio
information, only in monitor mode).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;m</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Load SMI MIB module definitions from file <i>module</i>.
This option can be used several times to load several MIB
modules into <i>tcpdump</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;M</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Use <i>secret</i> as a shared secret for validating the
digests found in TCP segments with the TCP-MD5 option (RFC
2385), if present.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;n</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Don&rsquo;t convert host addresses to names. This can be
used to avoid DNS lookups.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;nn</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Don&rsquo;t convert protocol and port numbers etc. to
names either.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;N</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Don&rsquo;t print domain name qualification of host
names. E.g., if you give this flag then <i>tcpdump</i> will
print &lsquo;&lsquo;nic&rsquo;&rsquo; instead of
&lsquo;&lsquo;nic.ddn.mil&rsquo;&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;O</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Do not run the packet-matching code optimizer. This is
useful only if you suspect a bug in the optimizer.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;p</b></p></td>
<td width="7%"></td>
<td width="78%">


<p><i>Don&rsquo;t</i> put the interface into promiscuous
mode. Note that the interface might be in promiscuous mode
for some other reason; hence, &lsquo;-p&rsquo; cannot be
used as an abbreviation for &lsquo;ether host
{local-hw-addr} or ether broadcast&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;P</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Choose send/receive direction <i>direction</i> for which
packets should be captured. Possible values are
&lsquo;in&rsquo;, &lsquo;out&rsquo; and &lsquo;inout&rsquo;.
Not available on all platforms.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;q</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Quick (quiet?) output. Print less protocol information
so output lines are shorter.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;R</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Assume ESP/AH packets to be based on old specification
(RFC1825 to RFC1829). If specified, <i>tcpdump</i> will not
print replay prevention field. Since there is no protocol
version field in ESP/AH specification, <i>tcpdump</i> cannot
deduce the version of ESP/AH protocol.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;r</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Read packets from <i>file</i> (which was created with
the <b>&minus;w</b> option). Standard input is used if
<i>file</i> is &lsquo;&lsquo;-&rsquo;&rsquo;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;S</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Print absolute, rather than relative, TCP sequence
numbers.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;s</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Snarf <i>snaplen</i> bytes of data from each packet
rather than the default of 65535 bytes. Packets truncated
because of a limited snapshot are indicated in the output
with &lsquo;&lsquo;[|<i>proto</i>]&rsquo;&rsquo;, where
<i>proto</i> is the name of the protocol level at which the
truncation has occurred. Note that taking larger snapshots
both increases the amount of time it takes to process
packets and, effectively, decreases the amount of packet
buffering. This may cause packets to be lost. You should
limit <i>snaplen</i> to the smallest number that will
capture the protocol information you&rsquo;re interested in.
Setting <i>snaplen</i> to 0 sets it to the default of 65535,
for backwards compatibility with recent older versions of
<i>tcpdump</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;T</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Force packets selected by &quot;<i>expression</i>&quot;
to be interpreted the specified <i>type</i>. Currently known
types are <b>aodv</b> (Ad-hoc On-demand Distance Vector
protocol), <b>carp</b> (Common Address Redundancy Protocol),
<b>cnfp</b> (Cisco NetFlow protocol), <b>lmp</b> (Link
Management Protocol), <b>pgm</b> (Pragmatic General
Multicast), <b>pgm_zmtp1</b> (ZMTP/1.0 inside PGM/EPGM),
<b>radius</b> (RADIUS), <b>rpc</b> (Remote Procedure Call),
<b>rtp</b> (Real-Time Applications protocol), <b>rtcp</b>
(Real-Time Applications control protocol), <b>snmp</b>
(Simple Network Management Protocol), <b>tftp</b> (Trivial
File Transfer Protocol), <b>vat</b> (Visual Audio Tool),
<b>wb</b> (distributed White Board), <b>zmtp1</b> (ZeroMQ
Message Transport Protocol 1.0) and <b>vxlan</b> (Virtual
eXtensible Local Area Network).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that the
<b>pgm</b> type above affects UDP interpretation only, the
native PGM is always recognised as IP protocol 113
regardless. UDP-encapsulated PGM is often called
&quot;EPGM&quot; or &quot;PGM/UDP&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
<b>pgm_zmtp1</b> type above affects interpretation of both
native PGM and UDP at once. During the native PGM decoding
the application data of an ODATA/RDATA packet would be
decoded as a ZeroMQ datagram with ZMTP/1.0 frames. During
the UDP decoding in addition to that any UDP packet would be
treated as an encapsulated PGM packet.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&minus;t</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>Don&rsquo;t</i> print a
timestamp on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;tt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print an unformatted timestamp on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;ttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a delta (micro-second resolution) between current
and previous line on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;tttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a timestamp in default format proceeded by date on
each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;ttttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a delta (micro-second resolution) between current
and first line on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;u</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print undecoded NFS handles.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;U</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If the <b>&minus;w</b> option is not specified, make the
printed packet output
&lsquo;&lsquo;packet-buffered&rsquo;&rsquo;; i.e., as the
description of the contents of each packet is printed, it
will be written to the standard output, rather than, when
not writing to a terminal, being written only when the
output buffer fills.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">If the
<b>&minus;w</b> option is specified, make the saved raw
packet output &lsquo;&lsquo;packet-buffered&rsquo;&rsquo;;
i.e., as each packet is saved, it will be written to the
output file, rather than being written only when the output
buffer fills.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>&minus;U</b> flag will not be supported if <i>tcpdump</i>
was built with an older version of <i>libpcap</i> that lacks
the <b>pcap_dump_flush()</b> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;v</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">When parsing and printing,
produce (slightly more) verbose output. For example, the
time to live, identification, total length and options in an
IP packet are printed. Also enables additional packet
integrity checks such as verifying the IP and ICMP header
checksum.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When writing to
a file with the <b>&minus;w</b> option, report, every 10
seconds, the number of packets captured.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>&minus;vv</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Even more verbose output. For
example, additional fields are printed from NFS reply
packets, and SMB packets are fully decoded.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;vvv</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Even more verbose output. For example, telnet <b>SB</b>
... <b>SE</b> options are printed in full. With
<b>&minus;X</b> Telnet options are printed in hex as
well.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;V</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Read a list of filenames from <i>file</i>. Standard
input is used if <i>file</i> is
&lsquo;&lsquo;-&rsquo;&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>&minus;w</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Write the raw packets to <i>file</i> rather than parsing
and printing them out. They can later be printed with the
&minus;r option. Standard output is used if <i>file</i> is
&lsquo;&lsquo;-&rsquo;&rsquo;.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This output
will be buffered if written to a file or pipe, so a program
reading from the file or pipe may not see packets for an
arbitrary amount of time after they are received. Use the
<b>&minus;U</b> flag to cause packets to be written as soon
as they are received.</p>

<p style="margin-left:22%; margin-top: 1em">The MIME type
<i>application/vnd.tcpdump.pcap</i> has been registered with
IANA for <i>pcap</i> files. The filename extension
<i>.pcap</i> appears to be the most commonly used along with
<i>.cap</i> and <i>.dmp</i>. <i>Tcpdump</i> itself
doesn&rsquo;t check the extension when reading capture files
and doesn&rsquo;t add an extension when writing them (it
uses magic numbers in the file header instead). However,
many operating systems and applications will use the
extension if it is present and adding one (e.g. .pcap) is
recommended.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>pcap-savefile</b>(5) for a description of the file
format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;W</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Used in conjunction with the
<b>&minus;C</b> option, this will limit the number of files
created to the specified number, and begin overwriting files
from the beginning, thus creating a &rsquo;rotating&rsquo;
buffer. In addition, it will name the files with enough
leading 0s to support the maximum number of files, allowing
them to sort correctly.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Used in
conjunction with the <b>&minus;G</b> option, this will limit
the number of rotated dump files that get created, exiting
with status 0 when reaching the limit. If used with
<b>&minus;C</b> as well, the behavior will result in
cyclical files per timeslice.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>&minus;x</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">When parsing and printing, in
addition to printing the headers of each packet, print the
data of each packet (minus its link level header) in hex.
The smaller of the entire packet or <i>snaplen</i> bytes
will be printed. Note that this is the entire link-layer
packet, so for link layers that pad (e.g. Ethernet), the
padding bytes will also be printed when the higher layer
packet is shorter than the required padding.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;xx</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet,
<i>including</i> its link level header, in hex.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;X</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet (minus
its link level header) in hex and ASCII. This is very handy
for analysing new protocols.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;XX</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet,
<i>including</i> its link level header, in hex and
ASCII.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;y</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Set the data link type to use while capturing packets to
<i>datalinktype</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&minus;z</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Used in conjunction with the <b>-C</b> or <b>-G</b>
options, this will make <i>tcpdump</i> run &quot; <i>command
file</i> &quot; where <i>file</i> is the savefile being
closed after each rotation. For example, specifying
<b>&minus;z gzip</b> or <b>&minus;z bzip2</b> will compress
each savefile using gzip or bzip2.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that
tcpdump will run the command in parallel to the capture,
using the lowest priority so that this doesn&rsquo;t disturb
the capture process.</p>

<p style="margin-left:22%; margin-top: 1em">And in case you
would like to use a command that itself takes flags or
different arguments, you can always write a shell script
that will take the savefile name as the only argument, make
the flags &amp; arguments arrangements and execute the
command that you want.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;Z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">If <i>tcpdump</i> is running as
root, after opening the capture device or input savefile,
but before opening any savefiles for output, change the user
ID to <i>user</i> and the group ID to the primary group of
<i>user</i>.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This behavior
is enabled by default (<b>&minus;Z tcpdump</b>), and can be
disabled by <b>&minus;Z root</b>.</p>

<p style="margin-left:11%;"><i>expression</i></p>

<p style="margin-left:22%;">selects which packets will be
dumped. If no <i>expression</i> is given, all packets on the
net will be dumped. Otherwise, only packets for which
<i>expression</i> is &lsquo;true&rsquo; will be dumped.</p>

<p style="margin-left:22%; margin-top: 1em">For the
<i>expression</i> syntax, see <b>pcap-filter</b>(7).</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>expression</i> argument can be passed to <i>tcpdump</i>
as either a single Shell argument, or as multiple Shell
arguments, whichever is more convenient. Generally, if the
expression contains Shell metacharacters, such as
backslashes used to escape protocol names, it is easier to
pass it as a single, quoted argument rather than to escape
the Shell metacharacters. Multiple arguments are
concatenated with spaces before being parsed.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To print all
packets arriving at or departing from <i>sundown</i>:</p>

<p style="margin-left:22%;"><b>tcpdump host sundown</b></p>

<p style="margin-left:11%; margin-top: 1em">To print
traffic between <i>helios</i> and either <i>hot</i> or
<i>ace</i>:</p>

<p style="margin-left:22%;"><b>tcpdump host helios and \(
hot or ace \)</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all IP
packets between <i>ace</i> and any host except
<i>helios</i>:</p>

<p style="margin-left:22%;"><b>tcpdump ip host ace and not
helios</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
traffic between local hosts and hosts at Berkeley:</p>

<p style="margin-left:22%;"><b>tcpdump net
ucb-ether</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
ftp traffic through internet gateway <i>snup</i>: (note that
the expression is quoted to prevent the shell from
(mis-)interpreting the parentheses):</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;gateway snup
and (port ftp or ftp-data)&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print
traffic neither sourced from nor destined for local hosts
(if you gateway to one other net, this stuff should never
make it onto your local net).</p>

<p style="margin-left:22%;"><b>tcpdump ip and not net</b>
<i>localnet</i></p>

<p style="margin-left:11%; margin-top: 1em">To print the
start and end packets (the SYN and FIN packets) of each TCP
conversation that involves a non-local host.</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;tcp[tcpflags]
&amp; (tcp-syn|tcp-fin) != 0 and not src and dst net</b>
<i>localnet</i><b>&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
IPv4 HTTP packets to and from port 80, i.e. print only
packets that contain data, not, for example, SYN and FIN
packets and ACK-only packets. (IPv6 is left as an exercise
for the reader.)</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;tcp port 80
and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) -
((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print IP
packets longer than 576 bytes sent through gateway
<i>snup</i>:</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;gateway snup
and ip[2:2] &gt; 576&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print IP
broadcast or multicast packets that were <i>not</i> sent via
Ethernet broadcast or multicast:</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;ether[0]
&amp; 1 = 0 and ip[16] &gt;= 224&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
ICMP packets that are not echo requests/replies (i.e., not
ping packets):</p>

<p style="margin-left:22%;"><b>tcpdump
&rsquo;icmp[icmptype] != icmp-echo and icmp[icmptype] !=
icmp-echoreply&rsquo;</b></p>

<h2>OUTPUT FORMAT
<a name="OUTPUT FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The output of
<i>tcpdump</i> is protocol dependent. The following gives a
brief description and examples of most of the formats.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Link Level
Headers</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
&rsquo;-e&rsquo; option is given, the link level header is
printed out. On Ethernets, the source and destination
addresses, protocol, and packet length are printed.</p>

<p style="margin-left:11%; margin-top: 1em">On FDDI
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &lsquo;frame control&rsquo; field, the source
and destination addresses, and the packet length. (The
&lsquo;frame control&rsquo; field governs the interpretation
of the rest of the packet. Normal packets (such as those
containing IP datagrams) are &lsquo;async&rsquo; packets,
with a priority value between 0 and 7; for example,
&lsquo;<b>async4</b>&rsquo;. Such packets are assumed to
contain an 802.2 Logical Link Control (LLC) packet; the LLC
header is printed if it is <i>not</i> an ISO datagram or a
so-called SNAP packet.</p>

<p style="margin-left:11%; margin-top: 1em">On Token Ring
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &lsquo;access control&rsquo; and &lsquo;frame
control&rsquo; fields, the source and destination addresses,
and the packet length. As on FDDI networks, packets are
assumed to contain an LLC packet. Regardless of whether the
&rsquo;-e&rsquo; option is specified or not, the source
routing information is printed for source-routed
packets.</p>

<p style="margin-left:11%; margin-top: 1em">On 802.11
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &lsquo;frame control&rsquo; fields, all of the
addresses in the 802.11 header, and the packet length. As on
FDDI networks, packets are assumed to contain an LLC
packet.</p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.: The
following description assumes familiarity with the SLIP
compression algorithm described in RFC-1144.)</i></p>

<p style="margin-left:11%; margin-top: 1em">On SLIP links,
a direction indicator (&lsquo;&lsquo;I&rsquo;&rsquo; for
inbound, &lsquo;&lsquo;O&rsquo;&rsquo; for outbound), packet
type, and compression information are printed out. The
packet type is printed first. The three types are <i>ip</i>,
<i>utcp</i>, and <i>ctcp</i>. No further link information is
printed for <i>ip</i> packets. For TCP packets, the
connection identifier is printed following the type. If the
packet is compressed, its encoded header is printed out. The
special cases are printed out as <b>*S+</b><i>n</i> and
<b>*SA+</b><i>n</i>, where <i>n</i> is the amount by which
the sequence number (or sequence number and ack) has
changed. If it is not a special case, zero or more changes
are printed. A change is indicated by U (urgent pointer), W
(window), A (ack), S (sequence number), and I (packet ID),
followed by a delta (+n or -n), or a new value (=n).
Finally, the amount of data in the packet and compressed
header length are printed.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following line shows an outbound compressed TCP packet,
with an implicit connection identifier; the ack has changed
by 6, the sequence number by 49, and the packet ID by 6;
there are 3 bytes of data and 6 bytes of compressed
header:</p>

<p style="margin-left:22%;"><b>O ctcp * A+6 S+49 I+6 3
(6)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ARP/RARP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em">Arp/rarp output
shows the type of request and its arguments. The format is
intended to be self explanatory. Here is a short sample
taken from the start of an &lsquo;rlogin&rsquo; from host
<i>rtsg</i> to host <i>csam</i>:</p>

<pre style="margin-left:22%;">arp who-has csam tell rtsg
arp reply csam is-at CSAM</pre>


<p style="margin-left:11%;">The first line says that rtsg
sent an arp packet asking for the Ethernet address of
internet host csam. Csam replies with its Ethernet address
(in this example, Ethernet addresses are in caps and
internet addresses in lower case).</p>

<p style="margin-left:11%; margin-top: 1em">This would look
less redundant if we had done <i>tcpdump &minus;n</i>:</p>

<pre style="margin-left:22%;">arp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</pre>


<p style="margin-left:11%; margin-top: 1em">If we had done
<i>tcpdump &minus;e</i>, the fact that the first packet is
broadcast and the second is point-to-point would be
visible:</p>

<pre style="margin-left:22%;">RTSG Broadcast 0806  64: arp who-has csam tell rtsg
CSAM RTSG 0806  64: arp reply csam is-at CSAM</pre>


<p style="margin-left:11%;">For the first packet this says
the Ethernet source address is RTSG, the destination is the
Ethernet broadcast address, the type field contained hex
0806 (type ETHER_ARP) and the total length was 64 bytes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TCP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.:The
following description assumes familiarity with the TCP
protocol described in RFC-793. If you are not familiar with
the protocol, neither this description nor tcpdump will be
of much use to you.)</i></p>

<p style="margin-left:11%; margin-top: 1em">The general
format of a tcp protocol line is:</p>

<p style="margin-left:22%;"><i>src &gt; dst: flags
data-seqno ack window urgent options</i></p>

<p style="margin-left:11%;"><i>Src</i> and <i>dst</i> are
the source and destination IP addresses and ports.
<i>Flags</i> are some combination of S (SYN), F (FIN), P
(PUSH), R (RST), U (URG), W (ECN CWR), E (ECN-Echo) or
&lsquo;.&rsquo; (ACK), or &lsquo;none&rsquo; if no flags are
set. <i>Data-seqno</i> describes the portion of sequence
space covered by the data in this packet (see example
below). <i>Ack</i> is sequence number of the next data
expected the other direction on this connection.
<i>Window</i> is the number of bytes of receive buffer space
available the other direction on this connection. <i>Urg</i>
indicates there is &lsquo;urgent&rsquo; data in the packet.
<i>Options</i> are tcp options enclosed in angle brackets
(e.g., &lt;mss 1024&gt;).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Src, dst</i>
and <i>flags</i> are always present. The other fields depend
on the contents of the packet&rsquo;s tcp protocol header
and are output only if appropriate.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
opening portion of an rlogin from host <i>rtsg</i> to host
<i>csam</i>.</p>

<pre style="margin-left:22%;">rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;
csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;
rtsg.1023 &gt; csam.login: . ack 1 win 4096
rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096
csam.login &gt; rtsg.1023: . ack 2 win 4096
rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096
csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077
csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1</pre>


<p style="margin-left:11%;">The first line says that tcp
port 1023 on rtsg sent a packet to port <i>login</i> on
csam. The <b>S</b> indicates that the <i>SYN</i> flag was
set. The packet sequence number was 768512 and it contained
no data. (The notation is &lsquo;first:last(nbytes)&rsquo;
which means &lsquo;sequence numbers <i>first</i> up to but
not including <i>last</i> which is <i>nbytes</i> bytes of
user data&rsquo;.) There was no piggy-backed ack, the
available receive window was 4096 bytes and there was a
max-segment-size option requesting an mss of 1024 bytes.</p>

<p style="margin-left:11%; margin-top: 1em">Csam replies
with a similar packet except it includes a piggy-backed ack
for rtsg&rsquo;s SYN. Rtsg then acks csam&rsquo;s SYN. The
&lsquo;.&rsquo; means the ACK flag was set. The packet
contained no data so there is no data sequence number. Note
that the ack sequence number is a small integer (1). The
first time <i>tcpdump</i> sees a tcp
&lsquo;conversation&rsquo;, it prints the sequence number
from the packet. On subsequent packets of the conversation,
the difference between the current packet&rsquo;s sequence
number and this initial sequence number is printed. This
means that sequence numbers after the first can be
interpreted as relative byte positions in the
conversation&rsquo;s data stream (with the first data byte
each direction being &lsquo;1&rsquo;). &lsquo;-S&rsquo; will
override this feature, causing the original sequence numbers
to be output.</p>

<p style="margin-left:11%; margin-top: 1em">On the 6th
line, rtsg sends csam 19 bytes of data (bytes 2 through 20
in the rtsg &rarr; csam side of the conversation). The PUSH
flag is set in the packet. On the 7th line, csam says
it&rsquo;s received data sent by rtsg up to but not
including byte 21. Most of this data is apparently sitting
in the socket buffer since csam&rsquo;s receive window has
gotten 19 bytes smaller. Csam also sends one byte of data to
rtsg in this packet. On the 8th and 9th lines, csam sends
two bytes of urgent, pushed data to rtsg.</p>

<p style="margin-left:11%; margin-top: 1em">If the snapshot
was small enough that <i>tcpdump</i> didn&rsquo;t capture
the full TCP header, it interprets as much of the header as
it can and then reports
&lsquo;&lsquo;[|<i>tcp</i>]&rsquo;&rsquo; to indicate the
remainder could not be interpreted. If the header contains a
bogus option (one with a length that&rsquo;s either too
small or beyond the end of the header), <i>tcpdump</i>
reports it as &lsquo;&lsquo;[<i>bad opt</i>]&rsquo;&rsquo;
and does not interpret any further options (since it&rsquo;s
impossible to tell where they start). If the header length
indicates options are present but the IP datagram length is
not long enough for the options to actually be there,
<i>tcpdump</i> reports it as &lsquo;&lsquo;[<i>bad hdr
length</i>]&rsquo;&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capturing
TCP packets with particular flag combinations (SYN-ACK,
URG-ACK, etc.)</b></p>

<p style="margin-left:11%; margin-top: 1em">There are 8
bits in the control bits section of the TCP header:</p>

<p style="margin-left:22%; margin-top: 1em"><i>CWR | ECE |
URG | ACK | PSH | RST | SYN | FIN</i></p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
assume that we want to watch packets used in establishing a
TCP connection. Recall that TCP uses a 3-way handshake
protocol when it initializes a new connection; the
connection sequence with regard to the TCP control bits
is</p>

<p style="margin-left:22%; margin-top: 1em">1) Caller sends
SYN <br>
2) Recipient responds with SYN, ACK <br>
3) Caller sends ACK</p>

<p style="margin-left:11%; margin-top: 1em">Now we&rsquo;re
interested in capturing packets that have only the SYN bit
set (Step 1). Note that we don&rsquo;t want packets from
step 2 (SYN-ACK), just a plain initial SYN. What we need is
a correct filter expression for <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Recall the
structure of a TCP header without options:</p>

<p style="margin-left:11%; margin-top: 1em">0 15 31 <br>

-----------------------------------------------------------------
<br>
| source port | destination port | <br>

-----------------------------------------------------------------
<br>
| sequence number | <br>

-----------------------------------------------------------------
<br>
| acknowledgment number | <br>

-----------------------------------------------------------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

-----------------------------------------------------------------
<br>
| TCP checksum | urgent pointer | <br>

-----------------------------------------------------------------</p>

<p style="margin-left:11%; margin-top: 1em">A TCP header
usually holds 20 octets of data, unless options are present.
The first line of the graph contains octets 0 - 3, the
second line shows octets 4 - 7 etc.</p>

<p style="margin-left:11%; margin-top: 1em">Starting to
count with 0, the relevant TCP control bits are contained in
octet 13:</p>

<p style="margin-left:11%; margin-top: 1em">0 7| 15| 23| 31
<br>

----------------|---------------|---------------|----------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

----------------|---------------|---------------|----------------
<br>
| | 13th octet | | |</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
have a closer look at octet no. 13:</p>

<p style="margin-left:11%; margin-top: 1em">| | <br>
|---------------| <br>
|C|E|U|A|P|R|S|F| <br>
|---------------| <br>
|7 5 3 0|</p>

<p style="margin-left:11%; margin-top: 1em">These are the
TCP control bits we are interested in. We have numbered the
bits in this octet from 0 to 7, right to left, so the PSH
bit is bit number 3, while the URG bit is number 5.</p>

<p style="margin-left:11%; margin-top: 1em">Recall that we
want to capture packets with only SYN set. Let&rsquo;s see
what happens to octet 13 if a TCP datagram arrives with the
SYN bit set in its header:</p>


<p style="margin-left:11%; margin-top: 1em">|C|E|U|A|P|R|S|F|
<br>
|---------------| <br>
|0 0 0 0 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-left:11%; margin-top: 1em">Looking at the
control bits section we see that only bit number 1 (SYN) is
set.</p>

<p style="margin-left:11%; margin-top: 1em">Assuming that
octet number 13 is an 8-bit unsigned integer in network byte
order, the binary value of this octet is</p>

<p style="margin-left:22%; margin-top: 1em">00000010</p>

<p style="margin-left:11%; margin-top: 1em">and its decimal
representation is</p>

<p style="margin-left:11%; margin-top: 1em">7 6 5 4 3 2 1 0
<br>
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2 = 2</p>

<p style="margin-left:11%; margin-top: 1em">We&rsquo;re
almost done, because now we know that if only SYN is set,
the value of the 13th octet in the TCP header, when
interpreted as a 8-bit unsigned integer in network byte
order, must be exactly 2.</p>

<p style="margin-left:11%; margin-top: 1em">This
relationship can be expressed as</p>

<p style="margin-left:22%;"><b>tcp[13] == 2</b></p>

<p style="margin-left:11%; margin-top: 1em">We can use this
expression as the filter for <i>tcpdump</i> in order to
watch packets which have only SYN set:</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0 tcp[13] ==
2</b></p>

<p style="margin-left:11%; margin-top: 1em">The expression
says &quot;let the 13th octet of a TCP datagram have the
decimal value 2&quot;, which is exactly what we want.</p>

<p style="margin-left:11%; margin-top: 1em">Now,
let&rsquo;s assume that we need to capture SYN packets, but
we don&rsquo;t care if ACK or any other TCP control bit is
set at the same time. Let&rsquo;s see what happens to octet
13 when a TCP datagram with SYN-ACK set arrives:</p>


<p style="margin-left:11%; margin-top: 1em">|C|E|U|A|P|R|S|F|
<br>
|---------------| <br>
|0 0 0 1 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-left:11%; margin-top: 1em">Now bits 1 and
4 are set in the 13th octet. The binary value of octet 13
is</p>

<p style="margin-left:22%; margin-top: 1em">00010010</p>

<p style="margin-left:11%; margin-top: 1em">which
translates to decimal</p>

<p style="margin-left:11%; margin-top: 1em">7 6 5 4 3 2 1 0
<br>
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2 = 18</p>

<p style="margin-left:11%; margin-top: 1em">Now we
can&rsquo;t just use &rsquo;tcp[13] == 18&rsquo; in the
<i>tcpdump</i> filter expression, because that would select
only those packets that have SYN-ACK set, but not those with
only SYN set. Remember that we don&rsquo;t care if ACK or
any other control bit is set as long as SYN is set.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
achieve our goal, we need to logically AND the binary value
of octet 13 with some other value to preserve the SYN bit.
We know that we want SYN to be set in any case, so
we&rsquo;ll logically AND the value in the 13th octet with
the binary value of a SYN:</p>

<p style="margin-left:11%; margin-top: 1em">00010010
SYN-ACK 00000010 SYN <br>
AND 00000010 (we want SYN) AND 00000010 (we want SYN) <br>
-------- -------- <br>
= 00000010 = 00000010</p>

<p style="margin-left:11%; margin-top: 1em">We see that
this AND operation delivers the same result regardless
whether ACK or another TCP control bit is set. The decimal
representation of the AND value as well as the result of
this operation is 2 (binary 00000010), so we know that for
packets with SYN set the following relation must hold
true:</p>

<p style="margin-left:22%; margin-top: 1em">( ( value of
octet 13 ) AND ( 2 ) ) == ( 2 )</p>

<p style="margin-left:11%; margin-top: 1em">This points us
to the <i>tcpdump</i> filter expression</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0
&rsquo;tcp[13] &amp; 2 == 2&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">Some offsets
and field values may be expressed as names rather than as
numeric values. For example tcp[13] may be replaced with
tcp[tcpflags]. The following TCP flag field values are also
available: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-act,
tcp-urg.</p>

<p style="margin-left:11%; margin-top: 1em">This can be
demonstrated as:</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0
&rsquo;tcp[tcpflags] &amp; tcp-push != 0&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">Note that you
should use single quotes or a backslash in the expression to
hide the AND (&rsquo;&amp;&rsquo;) special character from
the shell.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em">UDP format is
illustrated by this rwho packet:</p>

<pre style="margin-left:22%;">actinide.who &gt; broadcast.who: udp 84</pre>


<p style="margin-left:11%;">This says that port <i>who</i>
on host <i>actinide</i> sent a udp datagram to port
<i>who</i> on host <i>broadcast</i>, the Internet broadcast
address. The packet contained 84 bytes of user data.</p>

<p style="margin-left:11%; margin-top: 1em">Some UDP
services are recognized (from the source or destination port
number) and the higher level protocol information printed.
In particular, Domain Name service requests (RFC-1034/1035)
and Sun RPC calls (RFC-1050) to NFS.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP Name
Server Requests</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.:The
following description assumes familiarity with the Domain
Service protocol described in RFC-1035. If you are not
familiar with the protocol, the following description will
appear to be written in greek.)</i></p>

<p style="margin-left:11%; margin-top: 1em">Name server
requests are formatted as</p>

<p style="margin-left:22%;"><i>src &gt; dst: id op? flags
qtype qclass name (len)</i></p>

<pre style="margin-left:22%;">h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</pre>


<p style="margin-left:11%;">Host <i>h2opolo</i> asked the
domain server on <i>helios</i> for an address record
(qtype=A) associated with the name
<i>ucbvax.berkeley.edu.</i> The query id was
&lsquo;3&rsquo;. The &lsquo;+&rsquo; indicates the
<i>recursion desired</i> flag was set. The query length was
37 bytes, not including the UDP and IP protocol headers. The
query operation was the normal one, <i>Query</i>, so the op
field was omitted. If the op had been anything else, it
would have been printed between the &lsquo;3&rsquo; and the
&lsquo;+&rsquo;. Similarly, the qclass was the normal one,
<i>C_IN</i>, and omitted. Any other qclass would have been
printed immediately after the &lsquo;A&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">A few anomalies
are checked and may result in extra fields enclosed in
square brackets: If a query contains an answer, authority
records or additional records section, <i>ancount</i>,
<i>nscount</i>, or <i>arcount</i> are printed as
&lsquo;[<i>n</i>a]&rsquo;, &lsquo;[<i>n</i>n]&rsquo; or
&lsquo;[<i>n</i>au]&rsquo; where <i>n</i> is the appropriate
count. If any of the response bits are set (AA, RA or rcode)
or any of the &lsquo;must be zero&rsquo; bits are set in
bytes two and three, &lsquo;[b2&amp;3=<i>x</i>]&rsquo; is
printed, where <i>x</i> is the hex value of header bytes two
and three.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP Name
Server Responses</b></p>

<p style="margin-left:11%; margin-top: 1em">Name server
responses are formatted as</p>

<p style="margin-left:22%;"><i>src &gt; dst: id op rcode
flags a/n/au type class data (len)</i></p>

<pre style="margin-left:22%;">helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</pre>


<p style="margin-left:11%;">In the first example,
<i>helios</i> responds to query id 3 from <i>h2opolo</i>
with 3 answer records, 3 name server records and 7
additional records. The first answer record is type A
(address) and its data is internet address 128.32.137.3. The
total size of the response was 273 bytes, excluding UDP and
IP headers. The op (Query) and response code (NoError) were
omitted, as was the class (C_IN) of the A record.</p>

<p style="margin-left:11%; margin-top: 1em">In the second
example, <i>helios</i> responds to query 2 with a response
code of non-existent domain (NXDomain) with no answers, one
name server and no authority records. The &lsquo;*&rsquo;
indicates that the <i>authoritative answer</i> bit was set.
Since there were no answers, no type, class or data were
printed.</p>

<p style="margin-left:11%; margin-top: 1em">Other flag
characters that might appear are &lsquo;&minus;&rsquo;
(recursion available, RA, <i>not</i> set) and
&lsquo;|&rsquo; (truncated message, TC, set). If the
&lsquo;question&rsquo; section doesn&rsquo;t contain exactly
one entry, &lsquo;[<i>n</i>q]&rsquo; is printed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SMB/CIFS
decoding</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>tcpdump</i>
now includes fairly extensive SMB/CIFS/NBT decoding for data
on UDP/137, UDP/138 and TCP/139. Some primitive decoding of
IPX and NetBEUI SMB data is also done.</p>

<p style="margin-left:11%; margin-top: 1em">By default a
fairly minimal decode is done, with a much more detailed
decode done if -v is used. Be warned that with -v a single
SMB packet may take up a page or more, so only use -v if you
really want all the gory details.</p>

<p style="margin-left:11%; margin-top: 1em">For information
on SMB packet formats and what all the fields mean see
www.cifs.org or the pub/samba/specs/ directory on your
favorite samba.org mirror site. The SMB patches were written
by Andrew Tridgell (tridge@samba.org).</p>

<p style="margin-left:11%; margin-top: 1em"><b>NFS Requests
and Replies</b></p>

<p style="margin-left:11%; margin-top: 1em">Sun NFS
(Network File System) requests and replies are printed
as:</p>

<p style="margin-left:22%;"><i>src.xid &gt; dst.nfs: len op
args <br>
src.nfs &gt; dst.xid: reply stat len op results</i></p>

<pre style="margin-left:22%;">sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165
wrl.nfs &gt; sushi.6709: reply ok 40 readlink &quot;../var&quot;
sushi.201b &gt; wrl.nfs:
     144 lookup fh 9,74/4096.6878 &quot;xcolors&quot;
wrl.nfs &gt; sushi.201b:
     reply ok 128 lookup fh 9,74/4134.3150</pre>


<p style="margin-left:11%;">In the first line, host
<i>sushi</i> sends a transaction with id <i>6709</i> to
<i>wrl</i> (note that the number following the src host is a
transaction id, <i>not</i> the source port). The request was
112 bytes, excluding the UDP and IP headers. The operation
was a <i>readlink</i> (read symbolic link) on file handle
(<i>fh</i>) 21,24/10.731657119. (If one is lucky, as in this
case, the file handle can be interpreted as a major,minor
device number pair, followed by the inode number and
generation number.) <i>Wrl</i> replies &lsquo;ok&rsquo; with
the contents of the link.</p>

<p style="margin-left:11%; margin-top: 1em">In the third
line, <i>sushi</i> asks <i>wrl</i> to lookup the name
&lsquo;<i>xcolors</i>&rsquo; in directory file
9,74/4096.6878. Note that the data printed depends on the
operation type. The format is intended to be self
explanatory if read in conjunction with an NFS protocol
spec.</p>

<p style="margin-left:11%; margin-top: 1em">If the &minus;v
(verbose) flag is given, additional information is printed.
For example:</p>

<pre style="margin-left:22%;">sushi.1372a &gt; wrl.nfs:
     148 read fh 21,11/12.195 8192 bytes @ 24576
wrl.nfs &gt; sushi.1372a:
     reply ok 1472 read REG 100664 ids 417/0 sz 29388</pre>


<p style="margin-left:11%;">(&minus;v also prints the IP
header TTL, ID, length, and fragmentation fields, which have
been omitted from this example.) In the first line,
<i>sushi</i> asks <i>wrl</i> to read 8192 bytes from file
21,11/12.195, at byte offset 24576. <i>Wrl</i> replies
&lsquo;ok&rsquo;; the packet shown on the second line is the
first fragment of the reply, and hence is only 1472 bytes
long (the other bytes will follow in subsequent fragments,
but these fragments do not have NFS or even UDP headers and
so might not be printed, depending on the filter expression
used). Because the &minus;v flag is given, some of the file
attributes (which are returned in addition to the file data)
are printed: the file type (&lsquo;&lsquo;REG&rsquo;&rsquo;,
for regular file), the file mode (in octal), the uid and
gid, and the file size.</p>

<p style="margin-left:11%; margin-top: 1em">If the &minus;v
flag is given more than once, even more details are
printed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that NFS
requests are very large and much of the detail won&rsquo;t
be printed unless <i>snaplen</i> is increased. Try using
&lsquo;<b>&minus;s 192</b>&rsquo; to watch NFS traffic.</p>

<p style="margin-left:11%; margin-top: 1em">NFS reply
packets do not explicitly identify the RPC operation.
Instead, <i>tcpdump</i> keeps track of
&lsquo;&lsquo;recent&rsquo;&rsquo; requests, and matches
them to the replies using the transaction ID. If a reply
does not closely follow the corresponding request, it might
not be parsable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>AFS Requests
and Replies</b></p>

<p style="margin-left:11%; margin-top: 1em">Transarc AFS
(Andrew File System) requests and replies are printed
as:</p>

<p style="margin-left:22%; margin-top: 1em"><i>src.sport
&gt; dst.dport: rx packet-type <br>
src.sport &gt; dst.dport: rx packet-type service call
call-name args <br>
src.sport &gt; dst.dport: rx packet-type service reply
call-name args</i></p>

<pre style="margin-left:22%;">elvis.7001 &gt; pike.afsfs:
     rx data fs call rename old fid 536876964/1/1 &quot;.newsrc.new&quot;
     new fid 536876964/1/1 &quot;.newsrc&quot;
pike.afsfs &gt; elvis.7001: rx data fs reply rename</pre>


<p style="margin-left:11%;">In the first line, host elvis
sends a RX packet to pike. This was a RX data packet to the
fs (fileserver) service, and is the start of an RPC call.
The RPC call was a rename, with the old directory file id of
536876964/1/1 and an old filename of
&lsquo;.newsrc.new&rsquo;, and a new directory file id of
536876964/1/1 and a new filename of &lsquo;.newsrc&rsquo;.
The host pike responds with a RPC reply to the rename call
(which was successful, because it was a data packet and not
an abort packet).</p>

<p style="margin-left:11%; margin-top: 1em">In general, all
AFS RPCs are decoded at least by RPC call name. Most AFS
RPCs have at least some of the arguments decoded (generally
only the &lsquo;interesting&rsquo; arguments, for some
definition of interesting).</p>

<p style="margin-left:11%; margin-top: 1em">The format is
intended to be self-describing, but it will probably not be
useful to people who are not familiar with the workings of
AFS and RX.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v
(verbose) flag is given twice, acknowledgement packets and
additional header information is printed, such as the RX
call ID, call number, sequence number, serial number, and
the RX packet flags.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v flag
is given twice, additional information is printed, such as
the RX call ID, serial number, and the RX packet flags. The
MTU negotiation information is also printed from RX ack
packets.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v flag
is given three times, the security index and service id are
printed.</p>

<p style="margin-left:11%; margin-top: 1em">Error codes are
printed for abort packets, with the exception of Ubik beacon
packets (because abort packets are used to signify a yes
vote for the Ubik protocol).</p>

<p style="margin-left:11%; margin-top: 1em">Note that AFS
requests are very large and many of the arguments
won&rsquo;t be printed unless <i>snaplen</i> is increased.
Try using &lsquo;<b>-s 256</b>&rsquo; to watch AFS
traffic.</p>

<p style="margin-left:11%; margin-top: 1em">AFS reply
packets do not explicitly identify the RPC operation.
Instead, <i>tcpdump</i> keeps track of
&lsquo;&lsquo;recent&rsquo;&rsquo; requests, and matches
them to the replies using the call number and service ID. If
a reply does not closely follow the corresponding request,
it might not be parsable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIP
AppleTalk (DDP in UDP)</b></p>

<p style="margin-left:11%; margin-top: 1em">AppleTalk DDP
packets encapsulated in UDP datagrams are de-encapsulated
and dumped as DDP packets (i.e., all the UDP header
information is discarded). The file <i>/etc/atalk.names</i>
is used to translate AppleTalk net and node numbers to
names. Lines in this file have the form</p>

<p style="margin-left:22%;"><i>number name</i></p>

<pre style="margin-left:22%; margin-top: 1em">1.254          ether
16.1      icsd-net
1.254.110 ace</pre>


<p style="margin-left:11%;">The first two lines give the
names of AppleTalk networks. The third line gives the name
of a particular host (a host is distinguished from a net by
the 3rd octet in the number &minus; a net number <i>must</i>
have two octets and a host number <i>must</i> have three
octets.) The number and name should be separated by
whitespace (blanks or tabs). The <i>/etc/atalk.names</i>
file may contain blank lines or comment lines (lines
starting with a &lsquo;#&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">AppleTalk
addresses are printed in the form</p>

<p style="margin-left:22%;"><i>net.host.port</i></p>

<pre style="margin-left:22%; margin-top: 1em">144.1.209.2 &gt; icsd-net.112.220
office.2 &gt; icsd-net.112.220
jssmag.149.235 &gt; icsd-net.2</pre>


<p style="margin-left:11%;">(If the <i>/etc/atalk.names</i>
doesn&rsquo;t exist or doesn&rsquo;t contain an entry for
some AppleTalk host/net number, addresses are printed in
numeric form.) In the first example, NBP (DDP port 2) on net
144.1 node 209 is sending to whatever is listening on port
220 of net icsd node 112. The second line is the same except
the full name of the source node is known
(&lsquo;office&rsquo;). The third line is a send from port
235 on net jssmag node 149 to broadcast on the icsd-net NBP
port (note that the broadcast address (255) is indicated by
a net name with no host number &minus; for this reason
it&rsquo;s a good idea to keep node names and net names
distinct in /etc/atalk.names).</p>

<p style="margin-left:11%; margin-top: 1em">NBP (name
binding protocol) and ATP (AppleTalk transaction protocol)
packets have their contents interpreted. Other protocols
just dump the protocol name (or number if no name is
registered for the protocol) and packet size.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NBP
packets</b> are formatted like the following examples:</p>

<pre style="margin-left:22%;">icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot;
jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;RM1140:LaserWriter@*&quot; 250
techpit.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;techpit:LaserWriter@*&quot; 186</pre>


<p style="margin-left:11%;">The first line is a name lookup
request for laserwriters sent by net icsd host 112 and
broadcast on net jssmag. The nbp id for the lookup is 190.
The second line shows a reply for this request (note that it
has the same id) from host jssmag.209 saying that it has a
laserwriter resource named &quot;RM1140&quot; registered on
port 250. The third line is another reply to the same
request saying host techpit has laserwriter
&quot;techpit&quot; registered on port 186.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ATP
packet</b> formatting is demonstrated by the following
example:</p>

<pre style="margin-left:22%;">jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</pre>


<p style="margin-left:11%;">Jssmag.209 initiates
transaction id 12266 with host helios by requesting up to 8
packets (the &lsquo;&lt;0-7&gt;&rsquo;). The hex number at
the end of the line is the value of the
&lsquo;userdata&rsquo; field in the request.</p>

<p style="margin-left:11%; margin-top: 1em">Helios responds
with 8 512-byte packets. The &lsquo;:digit&rsquo; following
the transaction id gives the packet sequence number in the
transaction and the number in parens is the amount of data
in the packet, excluding the atp header. The &lsquo;*&rsquo;
on packet 7 indicates that the EOM bit was set.</p>

<p style="margin-left:11%; margin-top: 1em">Jssmag.209 then
requests that packets 3 &amp; 5 be retransmitted. Helios
resends them then jssmag.209 releases the transaction.
Finally, jssmag.209 initiates the next request. The
&lsquo;*&rsquo; on the request indicates that XO
(&lsquo;exactly once&rsquo;) was <i>not</i> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>IP
Fragmentation</b></p>

<p style="margin-left:11%; margin-top: 1em">Fragmented
Internet datagrams are printed as</p>

<p style="margin-left:22%;"><b>(frag</b>
<i>id</i><b>:</b><i>size</i><b>@</b><i>offset</i><b>+) <br>
(frag</b>
<i>id</i><b>:</b><i>size</i><b>@</b><i>offset</i><b>)</b></p>

<p style="margin-left:11%;">(The first form indicates there
are more fragments. The second indicates this is the last
fragment.)</p>

<p style="margin-left:11%; margin-top: 1em"><i>Id</i> is
the fragment id. <i>Size</i> is the fragment size (in bytes)
excluding the IP header. <i>Offset</i> is this
fragment&rsquo;s offset (in bytes) in the original
datagram.</p>

<p style="margin-left:11%; margin-top: 1em">The fragment
information is output for each fragment. The first fragment
contains the higher level protocol header and the frag info
is printed after the protocol info. Fragments after the
first contain no higher level protocol header and the frag
info is printed after the source and destination addresses.
For example, here is part of an ftp from arizona.edu to
lbl-rtsg.arpa over a CSNET connection that doesn&rsquo;t
appear to handle 576 byte datagrams:</p>

<pre style="margin-left:22%;">arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
arizona &gt; rtsg: (frag 595a:204@328)
rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560</pre>


<p style="margin-left:11%;">There are a couple of things to
note here: First, addresses in the 2nd line don&rsquo;t
include port numbers. This is because the TCP protocol
information is all in the first fragment and we have no idea
what the port or sequence numbers are when we print the
later fragments. Second, the tcp sequence information in the
first line is printed as if there were 308 bytes of user
data when, in fact, there are 512 bytes (308 in the first
frag and 204 in the second). If you are looking for holes in
the sequence space or trying to match up acks with packets,
this can fool you.</p>

<p style="margin-left:11%; margin-top: 1em">A packet with
the IP <i>don&rsquo;t fragment</i> flag is marked with a
trailing <b>(DF)</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Timestamps</b></p>

<p style="margin-left:11%; margin-top: 1em">By default, all
output lines are preceded by a timestamp. The timestamp is
the current clock time in the form</p>

<p style="margin-left:22%;"><i>hh:mm:ss.frac</i></p>

<p style="margin-left:11%;">and is as accurate as the
kernel&rsquo;s clock. The timestamp reflects the time the
kernel first saw the packet. No attempt is made to account
for the time lag between when the Ethernet interface removed
the packet from the wire and when the kernel serviced the
&lsquo;new packet&rsquo; interrupt.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stty(1),
pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5),
pcap-filter(7), pcap-tstamp-type(7)</p>


<p style="margin-left:22%; margin-top: 1em"><i>http://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</i></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The original
authors are:</p>

<p style="margin-left:11%; margin-top: 1em">Van Jacobson,
Craig Leres and Steven McCanne, all of the Lawrence Berkeley
National Laboratory, University of California, Berkeley,
CA.</p>

<p style="margin-left:11%; margin-top: 1em">It is currently
being maintained by tcpdump.org.</p>

<p style="margin-left:11%; margin-top: 1em">The current
version is available via http:</p>


<p style="margin-left:22%; margin-top: 1em"><i>http://www.tcpdump.org/</i></p>

<p style="margin-left:11%; margin-top: 1em">The original
distribution is available via anonymous ftp:</p>


<p style="margin-left:22%; margin-top: 1em"><i>ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</i></p>

<p style="margin-left:11%; margin-top: 1em">IPv6/IPsec
support is added by WIDE/KAME project. This program uses
Eric Young&rsquo;s SSLeay library, under specific
configurations.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please send
problems, bugs, questions, desirable enhancements, patches
etc. to:</p>


<p style="margin-left:22%; margin-top: 1em">tcpdump-workers@lists.tcpdump.org</p>

<p style="margin-left:11%; margin-top: 1em">NIT
doesn&rsquo;t let you watch your own outbound traffic, BPF
will. We recommend that you use the latter.</p>

<p style="margin-left:11%; margin-top: 1em">On Linux
systems with 2.0[.x] kernels:</p>

<p style="margin-left:22%; margin-top: 1em">packets on the
loopback device will be seen twice;</p>

<p style="margin-left:22%; margin-top: 1em">packet
filtering cannot be done in the kernel, so that all packets
must be copied from the kernel in order to be filtered in
user mode;</p>

<p style="margin-left:22%; margin-top: 1em">all of a
packet, not just the part that&rsquo;s within the snapshot
length, will be copied from the kernel (the 2.0[.x] packet
capture mechanism, if asked to copy only part of a packet to
userland, will not report the true length of the packet;
this would cause most IP packets to get an error from
<b>tcpdump</b>);</p>

<p style="margin-left:22%; margin-top: 1em">capturing on
some PPP devices won&rsquo;t work correctly.</p>

<p style="margin-left:11%; margin-top: 1em">We recommend
that you upgrade to a 2.2 or later kernel.</p>

<p style="margin-left:11%; margin-top: 1em">Some attempt
should be made to reassemble IP fragments or, at least to
compute the right length for the higher level protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Name server
inverse queries are not dumped correctly: the (empty)
question section is printed rather than real query in the
answer section. Some believe that inverse queries are
themselves a bug and prefer to fix the program generating
them rather than <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A packet trace
that crosses a daylight savings time change will give skewed
time stamps (the time change is ignored).</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in Token Ring headers
will not correctly handle source-routed Token Ring
packets.</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in 802.11 headers
will not correctly handle 802.11 data packets with both To
DS and From DS set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ip6
proto</b> should chase header chain, but at this moment it
does not. <b>ip6 protochain</b> is supplied for this
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Arithmetic
expression against transport layer headers, like
<b>tcp[0]</b>, does not work against IPv6 packets. It only
looks at IPv4 packets.</p>
<hr>
</body>
</html>
