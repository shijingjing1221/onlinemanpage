<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:26:19 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::auto_ptr&lt; _Tp &gt;</title>

</head>
<body>

<h1 align="center">std::auto_ptr&lt; _Tp &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Member Typedef Documentation">Member Typedef Documentation</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::auto_ptr&lt;
_Tp &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Tp
<b>element_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>auto_ptr</b>
(<b>element_type</b> *__p=0) throw () <b><br>
auto_ptr</b> (<b>auto_ptr</b> &amp;__a) throw () <br>
template&lt;typename _Tp1 &gt; <b>auto_ptr</b>
(<b>auto_ptr</b>&lt; _Tp1 &gt; &amp;__a) throw () <b><br>
auto_ptr</b> (<b>auto_ptr_ref</b>&lt; <b>element_type</b>
&gt; __ref) throw () <b><br>
~auto_ptr</b> () <b><br>
element_type</b> * <b>get</b> () const throw () <br>
template&lt;typename _Tp1 &gt; <b>operator auto_ptr&lt; _Tp1
&gt;</b> () throw () <br>
template&lt;typename _Tp1 &gt; <b>operator auto_ptr_ref&lt;
_Tp1 &gt;</b> () throw () <b><br>
element_type</b> &amp; <b>operator*</b> () const throw ()
<b><br>
element_type</b> * <b>operator-&gt;</b> () const throw ()
<b><br>
auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr</b>
&amp;__a) throw () <br>
template&lt;typename _Tp1 &gt; <b>auto_ptr</b> &amp;
<b>operator=</b> (<b>auto_ptr</b>&lt; _Tp1 &gt; &amp;__a)
throw () <b><br>
auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr_ref</b>&lt;
<b>element_type</b> &gt; __ref) throw () <b><br>
element_type</b> * <b>release</b> () throw () <br>
void <b>reset</b> (<b>element_type</b> *__p=0) throw ()</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt;class std::auto_ptr&lt; _Tp &gt;</b> <br>
A simple smart pointer providing strict ownership
semantics.</p>

<p style="margin-left:11%; margin-top: 1em">The Standard
says:</p>

<p style="margin-left:11%; margin-top: 1em">An
<tt>auto_ptr</tt> owns the object it holds a pointer to.
Copying <br>
an <tt>auto_ptr</tt> copies the pointer and transfers
ownership to the <br>
destination. If more than one <tt>auto_ptr</tt> owns the
same object <br>
at the same time the behavior of the program is
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">The uses of
<tt>auto_ptr</tt> include providing temporary <br>
exception-safety for dynamically allocated memory, passing
<br>
ownership of dynamically allocated memory to a function, and
<br>
returning dynamically allocated memory from a function.
<tt>auto_ptr</tt> does not meet the CopyConstructible and
Assignable <br>
requirements for Standard Library <tt>container</tt>
elements and thus <br>
instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Quoted from
[20.4.5]/3.</p>

<p style="margin-left:11%; margin-top: 1em">Good examples
of what can and cannot be done with auto_ptr can be found in
the libstdc++ testsuite.</p>


<p style="margin-left:11%; margin-top: 1em">_GLIBCXX_RESOLVE_LIB_DEFECTS
127. auto_ptr&lt;&gt; conversion issues These resolutions
have all been incorporated.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 87 of file auto_ptr.h.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; typedef _Tp std::auto_ptr&lt; _Tp
&gt;::element_type</b> <br>
The pointed-to type.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 94 of file auto_ptr.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr (element_type
*__p =</b> <tt>0</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
An auto_ptr is usually constructed from a raw pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer (defaults
to NULL).</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object pointed to by <i>__p</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 103 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr (auto_ptr&lt;
_Tp &gt; &amp;__a)</b> <tt>[inline]</tt> <br>
An auto_ptr can be constructed from another auto_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
the same type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 112 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 &gt; std::auto_ptr&lt; _Tp
&gt;::auto_ptr (auto_ptr&lt; _Tp1 &gt; &amp;__a)</b>
<tt>[inline]</tt> <br>
An auto_ptr can be constructed from another auto_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
a different but related type.</p>

<p style="margin-left:11%; margin-top: 1em">A
pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 125 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; std::auto_ptr&lt; _Tp &gt;::~auto_ptr ()</b>
<tt>[inline]</tt> <br>
When the auto_ptr goes out of scope, the object it owns is
deleted. If it no longer owns anything (i.e., <tt>get()</tt>
is <tt>NULL</tt>), then this has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">The C++
standard says there is supposed to be an empty throw
specification here, but omitting it is standard conforming.
Its presence can be detected only if _Tp::~_Tp() throws, but
this is prohibited. [17.4.3.6]/2</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 170 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr
(auto_ptr_ref&lt; element_type &gt;__ref)</b>
<tt>[inline]</tt> <br>
Automatic conversions. These operations convert an auto_ptr
into and from an auto_ptr_ref automatically as needed. This
allows constructs such as</p>

<p style="margin-left:11%; margin-top: 1em">*
auto_ptr&lt;Derived&gt; func_returning_auto_ptr(.....); <br>
* ... <br>
* auto_ptr&lt;Base&gt; ptr = func_returning_auto_ptr(.....);
<br>
*</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 260 of file auto_ptr.h.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; element_type* std::auto_ptr&lt; _Tp &gt;::get (void)
const</b> <tt>[inline]</tt> <br>
Bypassing the smart pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The raw pointer being
managed.</p>

<p style="margin-left:11%; margin-top: 1em">You can get a
copy of the pointer that this object owns, for situations
such as passing to a function which only accepts a raw
pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note:</b></p>

<p style="margin-left:17%;">This auto_ptr still owns the
memory.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 211 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; element_type&amp; std::auto_ptr&lt; _Tp
&gt;::operator* () const</b> <tt>[inline]</tt> <br>
Smart pointer dereferencing. If this auto_ptr no longer owns
anything, then this operation will crash. (For a smart
pointer, <i>no longer owns anything</i> is the same as being
a null pointer, and you know what happens when you
dereference one of those...)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 181 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; element_type* std::auto_ptr&lt; _Tp
&gt;::operator-&gt; () const</b> <tt>[inline]</tt> <br>
Smart pointer dereferencing. This returns the pointer
itself, which the language then will automatically cause to
be dereferenced.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 194 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; auto_ptr&amp; std::auto_ptr&lt; _Tp &gt;::operator=
(auto_ptr&lt; _Tp &gt; &amp;__a)</b> <tt>[inline]</tt> <br>
auto_ptr assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
the same type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership. The object that this one <i>used</i>
to own and track has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 136 of file auto_ptr.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::auto_ptr&lt; _Tp &gt;::reset().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 &gt; auto_ptr&amp;
std::auto_ptr&lt; _Tp &gt;::operator= (auto_ptr&lt; _Tp1
&gt; &amp;__a)</b> <tt>[inline]</tt> <br>
auto_ptr assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
a different but related type.</p>

<p style="margin-left:11%; margin-top: 1em">A
pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership. The object that this one <i>used</i>
to own and track has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 154 of file auto_ptr.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::auto_ptr&lt; _Tp &gt;::reset().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; element_type* std::auto_ptr&lt; _Tp &gt;::release
()</b> <tt>[inline]</tt> <br>
Bypassing the smart pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The raw pointer being
managed.</p>

<p style="margin-left:11%; margin-top: 1em">You can get a
copy of the pointer that this object owns, for situations
such as passing to a function which only accepts a raw
pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note:</b></p>

<p style="margin-left:17%;">This auto_ptr no longer owns
the memory. When this object goes out of scope, nothing will
happen.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 225 of file auto_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; void std::auto_ptr&lt; _Tp &gt;::reset (element_type
*__p =</b> <tt>0</tt><b>)</b> <tt>[inline]</tt> <br>
Forcibly deletes the managed object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer (defaults
to NULL).</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object pointed to by <i>__p</i>. The
previous object has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 240 of file auto_ptr.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::auto_ptr&lt; _Tp &gt;::operator=().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
