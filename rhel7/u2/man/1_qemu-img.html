<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:12:55 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>QEMU-IMG</title>

</head>
<body>

<h1 align="center">QEMU-IMG</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">qemu&minus;img
&minus; QEMU disk image utility</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">usage: qemu-img
command [command options]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">qemu-img allows
you to create, convert and modify images offline. It can
handle all image formats supported by
<small>QEMU.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>Warning:</b>
Never use qemu-img to modify images in use by a running
virtual machine or any other process; this may destroy the
image. Also, be aware that querying an image that is being
modified by another process may encounter inconsistent
state.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
commands are supported: <b><br>
check [&minus;q] [&minus;f</b> <i>fmt</i><b>]
[&minus;&minus;output=</b><i>ofmt</i><b>] [&minus;r [leaks |
all]] [&minus;T</b> <i>src_cache</i><b>]</b> <i><br>
filename</i> <b><br>
create [&minus;q] [&minus;f</b> <i>fmt</i><b>] [&minus;o</b>
<i>options</i><b>]</b> <i>filename</i>
<b>[</b><i>size</i><b>] <br>
commit [&minus;q] [&minus;f</b> <i>fmt</i><b>] [&minus;t</b>
<i>cache</i><b>]</b> <i>filename</i> <b><br>
compare [&minus;f</b> <i>fmt</i><b>] [&minus;F</b>
<i>fmt</i><b>] [&minus;T</b> <i>src_cache</i><b>] [&minus;p]
[&minus;q] [&minus;s]</b> <i>filename1 <br>
filename2</i> <b><br>
convert [&minus;c] [&minus;p] [&minus;q] [&minus;n]
[&minus;f</b> <i>fmt</i><b>] [&minus;t</b> <i>cache</i><b>]
[&minus;T</b> <i>src_cache</i><b>] [&minus;O</b> <i><br>
output_fmt</i><b>] [&minus;o</b> <i>options</i><b>]
[&minus;s</b> <i>snapshot_name</i><b>] [&minus;S</b>
<i>sparse_size</i><b>]</b> <i>filename</i> <b><br>
[</b><i>filename2</i> <b>[...]]</b> <i>output_filename</i>
<b><br>
info [&minus;f</b> <i>fmt</i><b>]
[&minus;&minus;output=</b><i>ofmt</i><b>]
[&minus;&minus;backing&minus;chain]</b> <i>filename</i>
<b><br>
map [&minus;f</b> <i>fmt</i><b>]
[&minus;&minus;output=</b><i>ofmt</i><b>]</b>
<i>filename</i> <b><br>
snapshot [&minus;q] [&minus;l | &minus;a</b> <i>snapshot</i>
<b>| &minus;c</b> <i>snapshot</i> <b>| &minus;d</b>
<i>snapshot</i><b>]</b> <i>filename</i> <b><br>
rebase [&minus;q] [&minus;f</b> <i>fmt</i><b>] [&minus;t</b>
<i>cache</i><b>] [&minus;T</b> <i>src_cache</i><b>]
[&minus;p] [&minus;u] &minus;b</b> <i><br>
backing_file</i> <b>[&minus;F</b> <i>backing_fmt</i><b>]</b>
<i>filename</i> <b><br>
resize [&minus;q]</b> <i>filename</i> <b>[+ |
&minus;]</b><i>size</i> <b><br>
amend [&minus;q] [&minus;f</b> <i>fmt</i><b>] [&minus;t</b>
<i>cache</i><b>] &minus;o</b> <i>options filename</i></p>

<p style="margin-left:11%; margin-top: 1em">Command
parameters: <i><br>
filename</i></p>

<pre style="margin-left:17%;"> is a disk image filename</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>fmt</i></p></td>
<td width="2%"></td>
<td width="83%">


<p>is the disk image format. It is guessed automatically in
most cases. See below for a description of the supported
disk formats.</p></td></tr>
</table>


<p style="margin-left:11%;"><i>&minus;&minus;backing&minus;chain</i></p>

<p style="margin-left:17%;">will enumerate information
about backing files in a disk image chain. Refer below for
further description.</p>

<p style="margin-left:11%;"><i>size</i></p>

<p style="margin-left:17%;">is the disk image size in
bytes. Optional suffixes <tt>&quot;k&quot;</tt> or
<tt>&quot;K&quot;</tt> (kilobyte, 1024)
<tt>&quot;M&quot;</tt> (megabyte, 1024k) and
<tt>&quot;G&quot;</tt> (gigabyte, 1024M) and T (terabyte,
1024G) are supported. <tt>&quot;b&quot;</tt> is ignored.</p>

<p style="margin-left:11%;"><i>output_filename</i></p>

<p style="margin-left:17%;">is the destination disk image
filename</p>

<p style="margin-left:11%;"><i>output_fmt</i></p>

<pre style="margin-left:17%;"> is the destination format</pre>


<p style="margin-left:11%;"><i>options</i></p>

<p style="margin-left:17%;">is a comma separated list of
format specific options in a name=value format. Use
<tt>&quot;&minus;o ?&quot;</tt> for an overview of the
options supported by the used format or see the format
descriptions below for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>&minus;c</i></p></td>
<td width="3%"></td>
<td width="83%">


<p>indicates that target image must be compressed (qcow
format only)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>&minus;h</i></p></td>
<td width="3%"></td>
<td width="83%">


<p>with or without a command shows help and lists the
supported formats</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>&minus;p</i></p></td>
<td width="3%"></td>
<td width="83%">


<p>display progress bar (compare, convert and rebase
commands only). If the <i>&minus;p</i> option is not used
for a command that supports it, the progress is reported
when the process receives a <tt>&quot;SIGUSR1&quot;</tt>
signal.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>&minus;q</i></p></td>
<td width="3%"></td>
<td width="83%">


<p>Quiet mode &minus; do not print any output (except
errors). There&rsquo;s no progress bar in case both
<i>&minus;q</i> and <i>&minus;p</i> options are used.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>&minus;S size</i></p>

<p style="margin-left:17%;">indicates the consecutive
number of bytes that must contain only zeros for qemu-img to
create a sparse image during conversion. This value is
rounded down to the nearest 512 bytes. You may use the
common size suffixes like <tt>&quot;k&quot;</tt> for
kilobytes.</p>

<p style="margin-left:11%;"><i>&minus;t cache</i></p>

<p style="margin-left:17%;">specifies the cache mode that
should be used with the (destination) file. See the
documentation of the emulator&rsquo;s <tt>&quot;&minus;drive
cache=...&quot;</tt> option for allowed values.</p>

<p style="margin-left:11%;"><i>&minus;T src_cache</i></p>

<p style="margin-left:17%;">specifies the cache mode that
should be used with the source file(s). See the
documentation of the emulator&rsquo;s <tt>&quot;&minus;drive
cache=...&quot;</tt> option for allowed values.</p>

<p style="margin-left:11%; margin-top: 1em">Parameters to
snapshot subcommand: <b><br>
snapshot</b></p>

<p style="margin-left:17%;">is the name of the snapshot to
create, apply or delete</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;a</b></p></td>
<td width="3%"></td>
<td width="72%">


<p>applies a snapshot (revert disk to saved state)</p></td>
<td width="11%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="3%"></td>
<td width="72%">


<p>creates a snapshot</p></td>
<td width="11%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;d</b></p></td>
<td width="3%"></td>
<td width="72%">


<p>deletes a snapshot</p></td>
<td width="11%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;l</b></p></td>
<td width="3%"></td>
<td width="72%">


<p>lists all snapshots in the given image</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Parameters to
compare subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;f</b></p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">First image format</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;F</b></p></td>
<td width="3%"></td>
<td width="83%">


<p>Second image format</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;s</b></p></td>
<td width="3%"></td>
<td width="83%">


<p>Strict mode &minus; fail on on different image size or
sector allocation</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Parameters to
convert subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;n</b></p></td>
<td width="3%"></td>
<td width="58%">


<p style="margin-top: 1em">Skip the creation of the target
volume</p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Command
description: <b><br>
check [&minus;f</b> <i>fmt</i><b>]
[&minus;&minus;output=</b><i>ofmt</i><b>] [&minus;r [leaks |
all]] [&minus;T</b> <i>src_cache</i><b>]</b> <i><br>
filename</i></p>

<p style="margin-left:17%;">Perform a consistency check on
the disk image <i>filename</i>. The command can output in
the format <i>ofmt</i> which is either
<tt>&quot;human&quot;</tt> or <tt>&quot;json&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;&minus;r&quot;</tt> is specified, qemu-img tries
to repair any inconsistencies found during the check.
<tt>&quot;&minus;r leaks&quot;</tt> repairs only cluster
leaks, whereas <tt>&quot;&minus;r all&quot;</tt> fixes all
kinds of errors, with a higher risk of choosing the wrong
fix or hiding corruption that has already occurred.</p>

<p style="margin-left:17%; margin-top: 1em">Only the
formats <tt>&quot;qcow2&quot;</tt>, <tt>&quot;qed&quot;</tt>
and <tt>&quot;vdi&quot;</tt> support consistency checks.</p>

<p style="margin-left:11%;"><b>create [&minus;f</b>
<i>fmt</i><b>] [&minus;o</b> <i>options</i><b>]</b>
<i>filename</i> <b>[</b><i>size</i><b>]</b></p>

<p style="margin-left:17%;">Create the new disk image
<i>filename</i> of size <i>size</i> and format <i>fmt</i>.
Depending on the file format, you can add one or more
<i>options</i> that enable additional features of this
format.</p>

<p style="margin-left:17%; margin-top: 1em">If the option
<i>backing_file</i> is specified, then the image will record
only the differences from <i>backing_file</i>. No size needs
to be specified in this case. <i>backing_file</i> will never
be modified unless you use the <tt>&quot;commit&quot;</tt>
monitor command (or qemu-img commit).</p>

<p style="margin-left:17%; margin-top: 1em">The size can
also be specified using the <i>size</i> option with
<tt>&quot;&minus;o&quot;</tt>, it doesn&rsquo;t need to be
specified separately in this case.</p>

<p style="margin-left:11%;"><b>commit [&minus;f</b>
<i>fmt</i><b>] [&minus;t</b> <i>cache</i><b>]</b>
<i>filename</i></p>

<p style="margin-left:17%;">Commit the changes recorded in
<i>filename</i> in its base image or backing file. If the
backing file is smaller than the snapshot, then the backing
file will be resized to be the same size as the snapshot. If
the snapshot is smaller than the backing file, the backing
file will not be truncated. If you want the backing file to
match the size of the smaller snapshot, you can safely
truncate it yourself once the commit operation successfully
completes.</p>

<p style="margin-left:11%;"><b>compare [&minus;f</b>
<i>fmt</i><b>] [&minus;F</b> <i>fmt</i><b>] [&minus;T</b>
<i>src_cache</i><b>] [&minus;p] [&minus;s] [&minus;q]</b>
<i>filename1 <br>
filename2</i></p>

<p style="margin-left:17%;">Check if two images have the
same content. You can compare images with different format
or settings.</p>

<p style="margin-left:17%; margin-top: 1em">The format is
probed unless you specify it by <i>&minus;f</i> (used for
<i>filename1</i>) and/or <i>&minus;F</i> (used for
<i>filename2</i>) option.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
images with different size are considered identical if the
larger image contains only unallocated and/or zeroed sectors
in the area after the end of the other image. In addition,
if any sector is not allocated in one image and contains
only zero bytes in the second one, it is evaluated as equal.
You can use Strict mode by specifying the <i>&minus;s</i>
option. When compare runs in Strict mode, it fails in case
image size differs or a sector is allocated in one image and
is not allocated in the second one.</p>

<p style="margin-left:17%; margin-top: 1em">By default,
compare prints out a result message. This message displays
information that both images are same or the position of the
first different byte. In addition, result message can report
different image size in case Strict mode is used.</p>

<p style="margin-left:17%; margin-top: 1em">Compare exits
with <tt>0</tt> in case the images are equal and with
<tt>1</tt> in case the images differ. Other exit codes mean
an error occurred during execution and standard error output
should contain an error message. The following table
sumarizes all exit codes of the compare subcommand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><b>0</b></p></td>
<td width="5%"></td>
<td width="57%">


<p>Images are identical</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><b>1</b></p></td>
<td width="5%"></td>
<td width="57%">


<p>Images differ</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><b>2</b></p></td>
<td width="5%"></td>
<td width="57%">


<p>Error on opening an image</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><b>3</b></p></td>
<td width="5%"></td>
<td width="57%">


<p>Error on checking a sector allocation</p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><b>4</b></p></td>
<td width="5%"></td>
<td width="57%">


<p>Error on reading data</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>convert [&minus;c]
[&minus;p] [&minus;n] [&minus;f</b> <i>fmt</i><b>]
[&minus;t</b> <i>cache</i><b>] [&minus;T</b>
<i>src_cache</i><b>] [&minus;O</b> <i><br>
output_fmt</i><b>] [&minus;o</b> <i>options</i><b>]
[&minus;s</b> <i>snapshot_name</i><b>] [&minus;S</b>
<i>sparse_size</i><b>]</b> <i>filename</i> <b><br>
[</b><i>filename2</i> <b>[...]]</b>
<i>output_filename</i></p>

<p style="margin-left:17%;">Convert the disk image
<i>filename</i> or a snapshot <i>snapshot_name</i> to disk
image <i>output_filename</i> using format <i>output_fmt</i>.
It can be optionally compressed
(<tt>&quot;&minus;c&quot;</tt> option) or use any format
specific options like encryption
(<tt>&quot;&minus;o&quot;</tt> option).</p>

<p style="margin-left:17%; margin-top: 1em">Only the
formats <tt>&quot;qcow&quot;</tt> and
<tt>&quot;qcow2&quot;</tt> support compression. The
compression is read-only. It means that if a compressed
sector is rewritten, then it is rewritten as uncompressed
data.</p>

<p style="margin-left:17%; margin-top: 1em">Image
conversion is also useful to get smaller image when using a
growable format such as <tt>&quot;qcow&quot;</tt>: the empty
sectors are detected and suppressed from the destination
image.</p>


<p style="margin-left:17%; margin-top: 1em"><i>sparse_size</i>
indicates the consecutive number of bytes (defaults to 4k)
that must contain only zeros for qemu-img to create a sparse
image during conversion. If <i>sparse_size</i> is 0, the
source will not be scanned for unallocated or zero sectors,
and the destination image will always be fully
allocated.</p>

<p style="margin-left:17%; margin-top: 1em">You can use the
<i>backing_file</i> option to force the output image to be
created as a copy on write image of the specified base
image; the <i>backing_file</i> should have the same content
as the input&rsquo;s base image, however the path, image
format, etc may differ.</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>&quot;&minus;n&quot;</tt> option is specified, the
target volume creation will be skipped. This is useful for
formats such as <tt>&quot;rbd&quot;</tt> if the target
volume has already been created with site specific options
that cannot be supplied through qemu-img.</p>

<p style="margin-left:11%;"><b>info [&minus;f</b>
<i>fmt</i><b>] [&minus;&minus;output=</b><i>ofmt</i><b>]
[&minus;&minus;backing&minus;chain]</b> <i>filename</i></p>

<p style="margin-left:17%;">Give information about the disk
image <i>filename</i>. Use it in particular to know the size
reserved on disk which can be different from the displayed
size. If <small>VM</small> snapshots are stored in the disk
image, they are displayed too. The command can output in the
format <i>ofmt</i> which is either
<tt>&quot;human&quot;</tt> or <tt>&quot;json&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">If a disk image
has a backing file chain, information about each disk image
in the chain can be recursively enumerated by using the
option
<tt>&quot;&minus;&minus;backing&minus;chain&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">For instance,
if you have an image chain like:</p>

<pre style="margin-left:17%; margin-top: 1em">        base.qcow2 &lt;&minus; snap1.qcow2 &lt;&minus; snap2.qcow2</pre>


<p style="margin-left:17%; margin-top: 1em">To enumerate
information about each disk image in the above chain,
starting from top to base, do:</p>

<pre style="margin-left:17%; margin-top: 1em">        qemu&minus;img info &minus;&minus;backing&minus;chain snap2.qcow2</pre>


<p style="margin-left:11%;"><b>map [&minus;f</b>
<i>fmt</i><b>] [&minus;&minus;output=</b><i>ofmt</i><b>]</b>
<i>filename</i></p>

<p style="margin-left:17%;">Dump the metadata of image
<i>filename</i> and its backing file chain. In particular,
this commands dumps the allocation state of every sector of
<i>filename</i>, together with the topmost file that
allocates it in the backing file chain.</p>

<p style="margin-left:17%; margin-top: 1em">Two option
formats are possible. The default format
(<tt>&quot;human&quot;</tt>) only dumps known-nonzero areas
of the file. Known-zero parts of the file are omitted
altogether, and likewise for parts that are not allocated
throughout the chain. <b>qemu-img</b> output will identify a
file from where the data can be read, and the offset in the
file. Each line will include four fields, the first three of
which are hexadecimal numbers. For example the first line
of:</p>

<pre style="margin-left:17%; margin-top: 1em">        Offset          Length          Mapped to       File
        0               0x20000         0x50000         /tmp/overlay.qcow2
        0x100000        0x10000         0x95380000      /tmp/backing.qcow2</pre>


<p style="margin-left:17%; margin-top: 1em">means that
0x20000 (131072) bytes starting at offset 0 in the image are
available in /tmp/overlay.qcow2 (opened in
<tt>&quot;raw&quot;</tt> format) starting at offset 0x50000
(327680). Data that is compressed, encrypted, or otherwise
not available in raw format will cause an error if
<tt>&quot;human&quot;</tt> format is in use. Note that file
names can include newlines, thus it is not safe to parse
this output format in scripts.</p>

<p style="margin-left:17%; margin-top: 1em">The alternative
format <tt>&quot;json&quot;</tt> will return an array of
dictionaries in <small>JSON</small> format. It will include
similar information in the <tt>&quot;start&quot;</tt>,
<tt>&quot;length&quot;</tt>, <tt>&quot;offset&quot;</tt>
fields; it will also include other more specific
information:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="5%"></td>
<td width="77%">


<p>whether the sectors contain actual data or not (boolean
field <tt>&quot;data&quot;</tt>; if false, the sectors are
either unallocated or stored as optimized all-zero
clusters);</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="5%"></td>
<td width="77%">


<p>whether the data is known to read as zero (boolean field
<tt>&quot;zero&quot;</tt>);</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&minus;</p></td>
<td width="5%"></td>
<td width="77%">


<p>in order to make the output shorter, the target file is
expressed as a <tt>&quot;depth&quot;</tt>; for example, a
depth of 2 refers to the backing file of the backing file of
<i>filename</i>.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In
<small>JSON</small> format, the <tt>&quot;offset&quot;</tt>
field is optional; it is absent in cases where
<tt>&quot;human&quot;</tt> format would omit the entry or
exit with an error. If <tt>&quot;data&quot;</tt> is false
and the <tt>&quot;offset&quot;</tt> field is present, the
corresponding sectors in the file are not yet in use, but
they are preallocated.</p>

<p style="margin-left:17%; margin-top: 1em">For more
information, consult <i>include/block/block.h</i> in
<small>QEMU</small> &rsquo;s source code.</p>

<p style="margin-left:11%;"><b>snapshot [&minus;l |
&minus;a</b> <i>snapshot</i> <b>| &minus;c</b>
<i>snapshot</i> <b>| &minus;d</b> <i>snapshot</i> <b>]</b>
<i>filename</i></p>

<p style="margin-left:17%;">List, apply, create or delete
snapshots in image <i>filename</i>.</p>

<p style="margin-left:11%;"><b>rebase [&minus;f</b>
<i>fmt</i><b>] [&minus;t</b> <i>cache</i><b>] [&minus;T</b>
<i>src_cache</i><b>] [&minus;p] [&minus;u] &minus;b</b>
<i>backing_file</i> <b>[&minus;F</b> <i><br>
backing_fmt</i><b>]</b> <i>filename</i></p>

<p style="margin-left:17%;">Changes the backing file of an
image. Only the formats <tt>&quot;qcow2&quot;</tt> and
<tt>&quot;qed&quot;</tt> support changing the backing
file.</p>

<p style="margin-left:17%; margin-top: 1em">The backing
file is changed to <i>backing_file</i> and (if the image
format of <i>filename</i> supports this) the backing file
format is changed to <i>backing_fmt</i>. If
<i>backing_file</i> is specified as &quot;&quot; (the empty
string), then the image is rebased onto no backing file
(i.e. it will exist independently of any backing file).</p>

<p style="margin-left:17%; margin-top: 1em"><i>cache</i>
specifies the cache mode to be used for <i>filename</i>,
whereas <i>src_cache</i> specifies the cache mode for
reading backing files.</p>

<p style="margin-left:17%; margin-top: 1em">There are two
different modes in which <tt>&quot;rebase&quot;</tt> can
operate: <b><br>
Safe mode</b></p>

<p style="margin-left:23%;">This is the default mode and
performs a real rebase operation. The new backing file may
differ from the old one and qemu-img rebase will take care
of keeping the guest-visible content of <i>filename</i>
unchanged.</p>

<p style="margin-left:23%; margin-top: 1em">In order to
achieve this, any clusters that differ between
<i>backing_file</i> and the old backing file of
<i>filename</i> are merged into <i>filename</i> before
actually changing the backing file.</p>

<p style="margin-left:23%; margin-top: 1em">Note that the
safe mode is an expensive operation, comparable to
converting an image. It only works if the old backing file
still exists.</p>

<p style="margin-left:17%;"><b>Unsafe mode</b></p>

<p style="margin-left:23%;">qemu-img uses the unsafe mode
if <tt>&quot;&minus;u&quot;</tt> is specified. In this mode,
only the backing file name and format of <i>filename</i> is
changed without any checks on the file contents. The user
must take care of specifying the correct new backing file,
or the guest-visible content of the image will be
corrupted.</p>

<p style="margin-left:23%; margin-top: 1em">This mode is
useful for renaming or moving the backing file to somewhere
else. It can be used without an accessible old backing file,
i.e. you can use it to fix an image whose backing file has
already been moved/renamed.</p>

<p style="margin-left:17%; margin-top: 1em">You can use
<tt>&quot;rebase&quot;</tt> to perform a &quot;diff&quot;
operation on two disk images. This can be useful when you
have copied or cloned a guest, and you want to get back to a
thin image on top of a template or base image.</p>

<p style="margin-left:17%; margin-top: 1em">Say that
<tt>&quot;base.img&quot;</tt> has been cloned as
<tt>&quot;modified.img&quot;</tt> by copying it, and that
the <tt>&quot;modified.img&quot;</tt> guest has run so there
are now some changes compared to
<tt>&quot;base.img&quot;</tt>. To construct a thin image
called <tt>&quot;diff.qcow2&quot;</tt> that contains just
the differences, do:</p>

<pre style="margin-left:17%; margin-top: 1em">        qemu&minus;img create &minus;f qcow2 &minus;b modified.img diff.qcow2
        qemu&minus;img rebase &minus;b base.img diff.qcow2</pre>


<p style="margin-left:17%; margin-top: 1em">At this point,
<tt>&quot;modified.img&quot;</tt> can be discarded, since
<tt>&quot;base.img + diff.qcow2&quot;</tt> contains the same
information.</p>

<p style="margin-left:11%;"><b>resize</b> <i>filename</i>
<b>[+ | &minus;]</b><i>size</i></p>

<p style="margin-left:17%;">Change the disk image as if it
had been created with <i>size</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Before using
this command to shrink a disk image, you <small>MUST</small>
use file system and partitioning tools inside the
<small>VM</small> to reduce allocated file systems and
partition sizes accordingly. Failure to do so will result in
data loss!</p>

<p style="margin-left:17%; margin-top: 1em">After using
this command to grow a disk image, you must use file system
and partitioning tools inside the <small>VM</small> to
actually begin using the new space on the device.</p>

<p style="margin-left:11%;"><b>amend [&minus;f</b>
<i>fmt</i><b>] [&minus;t</b> <i>cache</i><b>] &minus;o</b>
<i>options filename</i></p>

<p style="margin-left:17%;">Amends the image format
specific <i>options</i> for the image file <i>filename</i>.
Not all file formats support this operation.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Supported image
file formats:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>raw</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Raw disk image format (default). This format has the
advantage of being simple and easily exportable to all other
emulators. If your file system supports <i>holes</i> (for
example in ext2 or ext3 on Linux or <small>NTFS</small> on
Windows), then only the written sectors will reserve space.
Use <tt>&quot;qemu&minus;img info&quot;</tt> to know the
real size used by the image or <tt>&quot;ls
&minus;ls&quot;</tt> on Unix/Linux.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Supported
options: <br>
&quot;preallocation&quot;</p>

<p style="margin-left:23%;">Preallocation mode (allowed
values: <tt>&quot;off&quot;</tt>,
<tt>&quot;falloc&quot;</tt>, <tt>&quot;full&quot;</tt>).
<tt>&quot;falloc&quot;</tt> mode preallocates space for
image by calling <i>posix_fallocate()</i>.
<tt>&quot;full&quot;</tt> mode preallocates space for image
by writing zeros to underlying storage.</p>

<p style="margin-left:11%;"><b>qcow2</b></p>

<p style="margin-left:17%;"><small>QEMU</small> image
format, the most versatile format. Use it to have smaller
images (useful if your filesystem does not supports holes,
for example on Windows), optional <small>AES</small>
encryption, zlib based compression and support of multiple
<small>VM</small> snapshots.</p>

<p style="margin-left:17%; margin-top: 1em">Supported
options: <br>
&quot;compat&quot;</p>

<p style="margin-left:23%;">Determines the qcow2 version to
use. <tt>&quot;compat=0.10&quot;</tt> uses the traditional
image format that can be read by any <small>QEMU</small>
since 0.10. <tt>&quot;compat=1.1&quot;</tt> enables image
format extensions that only <small>QEMU 1.1</small> and
newer understand (this is the default). Amongst others, this
includes zero clusters, which allow efficient copy-on-read
for sparse images.</p>

<p style="margin-left:17%;">&quot;backing_file&quot;</p>

<p style="margin-left:23%;">File name of a base image (see
<b>create</b> subcommand)</p>

<p style="margin-left:17%;">&quot;backing_fmt&quot;</p>

<p style="margin-left:23%;">Image format of the base
image</p>

<p style="margin-left:17%;">&quot;encryption&quot;</p>

<p style="margin-left:23%;">If this option is set to
<tt>&quot;on&quot;</tt>, the image is encrypted.</p>

<p style="margin-left:23%; margin-top: 1em">Encryption uses
the <small>AES</small> format which is very secure (128 bit
keys). Use a long password (16 characters) to get maximum
protection.</p>

<p style="margin-left:17%;">&quot;cluster_size&quot;</p>

<p style="margin-left:23%;">Changes the qcow2 cluster size
(must be between 512 and 2M). Smaller cluster sizes can
improve the image file size whereas larger cluster sizes
generally provide better performance.</p>

<p style="margin-left:17%;">&quot;preallocation&quot;</p>

<p style="margin-left:23%;">Preallocation mode (allowed
values: <tt>&quot;off&quot;</tt>,
<tt>&quot;metadata&quot;</tt>, <tt>&quot;falloc&quot;</tt>,
<tt>&quot;full&quot;</tt>). An image with preallocated
metadata is initially larger but can improve performance
when the image needs to grow. <tt>&quot;falloc&quot;</tt>
and <tt>&quot;full&quot;</tt> preallocations are like the
same options of <tt>&quot;raw&quot;</tt> format, but sets up
metadata also.</p>

<p style="margin-left:17%;">&quot;lazy_refcounts&quot;</p>

<p style="margin-left:23%;">If this option is set to
<tt>&quot;on&quot;</tt>, reference count updates are
postponed with the goal of avoiding metadata I/O and
improving performance. This is particularly interesting with
<b>cache=writethrough</b> which doesn&rsquo;t batch metadata
updates. The tradeoff is that after a host crash, the
reference count tables must be rebuilt, i.e. on the next
open an (automatic) <tt>&quot;qemu&minus;img check &minus;r
all&quot;</tt> is required, which may take some time.</p>

<p style="margin-left:23%; margin-top: 1em">This option can
only be enabled if <tt>&quot;compat=1.1&quot;</tt> is
specified.</p>

<p style="margin-left:11%;"><b>Other</b></p>

<p style="margin-left:17%;"><small>QEMU</small> also
supports various other image file formats for compatibility
with older <small>QEMU</small> versions or other
hypervisors, including <small>VMDK, VDI, VHD</small> (vpc),
<small>VHDX,</small> qcow1 and <small>QED.</small> For a
full list of supported formats see <tt>&quot;qemu&minus;img
&minus;&minus;help&quot;</tt>. For a more detailed
description of these formats, see the <small>QEMU</small>
Emulation User Documentation.</p>

<p style="margin-left:17%; margin-top: 1em">The main
purpose of the block drivers for these formats is image
conversion. For running VMs, it is recommended to convert
the disk images to either raw or qcow2 in order to achieve
good performance.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>HTML</small> documentation of <small>QEMU</small> for
more precise information and Linux user mode emulator
invocation.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Fabrice
Bellard</p>
<hr>
</body>
</html>
