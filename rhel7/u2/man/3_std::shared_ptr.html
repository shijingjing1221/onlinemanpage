<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:27:12 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::shared_ptr&lt; _Tp &gt;</title>

</head>
<body>

<h1 align="center">std::shared_ptr&lt; _Tp &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Friends And Related Function Documentation">Friends And Related Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::shared_ptr&lt;
_Tp &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
std::__shared_ptr&lt; _Tp, _Lp &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Tp
<b>element_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">constexpr <b>shared_ptr</b> ()
noexcept <b><br>
shared_ptr</b> (const <b>shared_ptr</b> &amp;)
noexcept=default <br>
template&lt;typename _Tp1 &gt; <b>shared_ptr</b> (_Tp1 *__p)
<br>
template&lt;typename _Tp1 , typename _Deleter &gt;
<b>shared_ptr</b> (_Tp1 *__p, _Deleter __d) <br>
template&lt;typename _Deleter &gt; <b>shared_ptr</b>
(nullptr_t __p, _Deleter __d) <br>
template&lt;typename _Tp1 , typename _Deleter , typename
_Alloc &gt; <b>shared_ptr</b> (_Tp1 *__p, _Deleter __d,
_Alloc __a) <br>
template&lt;typename _Deleter , typename _Alloc &gt;
<b>shared_ptr</b> (nullptr_t __p, _Deleter __d, _Alloc __a)
<br>
template&lt;typename _Tp1 &gt; <b>shared_ptr</b> (const
<b>shared_ptr</b>&lt; _Tp1 &gt; &amp;__r, _Tp *__p) noexcept
<br>
template&lt;typename _Tp1 , typename = typename
std::enable_if&lt;std::is_convertible&lt;_Tp1*,
_Tp*&gt;::value&gt;::type&gt; <b>shared_ptr</b> (const
<b>shared_ptr</b>&lt; _Tp1 &gt; &amp;__r) noexcept <b><br>
shared_ptr</b> (<b>shared_ptr</b> &amp;&amp;__r) noexcept
<br>
template&lt;typename _Tp1 , typename = typename
std::enable_if&lt;std::is_convertible&lt;_Tp1*,
_Tp*&gt;::value&gt;::type&gt; <b>shared_ptr</b>
(<b>shared_ptr</b>&lt; _Tp1 &gt; &amp;&amp;__r) noexcept
<br>
template&lt;typename _Tp1 &gt; <b>shared_ptr</b> (const
<b>weak_ptr</b>&lt; _Tp1 &gt; &amp;__r) <br>
template&lt;typename _Tp1 , typename _Del &gt;
<b>shared_ptr</b> (<b>std::unique_ptr</b>&lt; _Tp1, _Del
&gt; &amp;&amp;__r) <br>
constexpr <b>shared_ptr</b> (nullptr_t __p) noexcept <br>
template&lt;typename _Tp1 &gt; <b>shared_ptr</b>
(<b>std::auto_ptr</b>&lt; _Tp1 &gt; &amp;&amp;__r) <br>
_Tp * <b>get</b> () const noexcept <b><br>
operator bool</b> () const <b><br>
std::add_lvalue_reference</b>&lt; _Tp &gt; <br>
::type <b>operator*</b> () const noexcept&quot; <br>
_Tp * <b>operator-&gt;</b> () const noexcept <b><br>
shared_ptr</b> &amp; <b>operator=</b> (const
<b>shared_ptr</b> &amp;) noexcept=default <br>
template&lt;typename _Tp1 &gt; <b>shared_ptr</b> &amp;
<b>operator=</b> (const <b>shared_ptr</b>&lt; _Tp1 &gt;
&amp;__r) noexcept <b><br>
shared_ptr</b> &amp; <b>operator=</b> (<b>shared_ptr</b>
&amp;&amp;__r) noexcept <br>
template&lt;class _Tp1 &gt; <b>shared_ptr</b> &amp;
<b>operator=</b> (<b>shared_ptr</b>&lt; _Tp1 &gt;
&amp;&amp;__r) noexcept <br>
template&lt;typename _Tp1 , typename _Del &gt;
<b>shared_ptr</b> &amp; <b>operator=</b>
(<b>std::unique_ptr</b>&lt; _Tp1, _Del &gt; &amp;&amp;__r)
<br>
template&lt;typename _Tp1 &gt; bool <b>owner_before</b>
(__shared_ptr&lt; _Tp1, _Lp &gt; const &amp;__rhs) const
<br>
template&lt;typename _Tp1 &gt; bool <b>owner_before</b>
(__weak_ptr&lt; _Tp1, _Lp &gt; const &amp;__rhs) const <br>
void <b>reset</b> () noexcept <br>
template&lt;typename _Tp1 &gt; void <b>reset</b> (_Tp1 *__p)
<br>
template&lt;typename _Tp1 , typename _Deleter &gt; void
<b>reset</b> (_Tp1 *__p, _Deleter __d) <br>
template&lt;typename _Tp1 , typename _Deleter , typename
_Alloc &gt; void <b>reset</b> (_Tp1 *__p, _Deleter __d,
_Alloc __a) <br>
void <b>swap</b> (__shared_ptr&lt; _Tp, _Lp &gt;
&amp;__other) noexcept <br>
bool <b>unique</b> () const noexcept <br>
long <b>use_count</b> () const noexcept</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Tp1 ,
typename _Alloc , typename... _Args&gt;
<b>shared_ptr</b>&lt; _Tp1 &gt; <b>allocate_shared</b>
(const _Alloc &amp;__a, _Args &amp;&amp;...__args)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt;class std::shared_ptr&lt; _Tp &gt;</b> <br>
A smart pointer with reference-counted copy semantics.</p>

<p style="margin-left:11%; margin-top: 1em">The object
pointed to is deleted when the last shared_ptr pointing to
it is destroyed or reset.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 93 of file shared_ptr.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; constexpr std::shared_ptr&lt; _Tp &gt;::shared_ptr
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Construct an empty shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count()==0 &amp;&amp;
get()==0</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 100 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 &gt; std::shared_ptr&lt;
_Tp &gt;::shared_ptr (_Tp1 *__p)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer that is
convertible to element_type*.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <tt>delete</tt> <i>__p</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 112 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 , typename _Deleter &gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (_Tp1 *__p,
_Deleter__d)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer. <i><br>
__d</i> A deleter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw</p>

<p style="margin-left:11%; margin-top: 1em">__shared_ptr
will release __p by calling __d(__p)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 129 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Deleter &gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (nullptr_t__p,
_Deleter__d)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A null pointer
constant. <i><br>
__d</i> A deleter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw</p>

<p style="margin-left:11%; margin-top: 1em">The last owner
will call __d(__p)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 146 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 , typename _Deleter ,
typename _Alloc &gt; std::shared_ptr&lt; _Tp
&gt;::shared_ptr (_Tp1 *__p, _Deleter__d, _Alloc__a)</b>
<tt>[inline]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer. <i><br>
__d</i> A deleter. <i><br>
__a</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw _Alloc&rsquo;s copy constructor and destructor must
not throw.</p>

<p style="margin-left:11%; margin-top: 1em">__shared_ptr
will release __p by calling __d(__p)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 165 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Deleter , typename _Alloc &gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (nullptr_t__p,
_Deleter__d, _Alloc__a)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A null pointer
constant. <i><br>
__d</i> A deleter. <i><br>
__a</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw _Alloc&rsquo;s copy constructor and destructor must
not throw.</p>

<p style="margin-left:11%; margin-top: 1em">The last owner
will call __d(__p)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 184 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 &gt; std::shared_ptr&lt;
_Tp &gt;::shared_ptr (const shared_ptr&lt; _Tp1 &gt;
&amp;__r, _Tp *__p)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Constructs a shared_ptr instance that stores <i>__p</i> and
shares ownership with <i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr.
<i><br>
__p</i> A pointer that will remain valid while <i>*__r</i>
is valid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">get() == __p &amp;&amp;
use_count() == __r.use_count()</p>

<p style="margin-left:11%; margin-top: 1em">This can be
used to construct a <tt>shared_ptr</tt> to a sub-object of
an object managed by an existing <tt>shared_ptr</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">*
shared_ptr&lt; pair&lt;int,int&gt; &gt; pii(new
pair&lt;int,int&gt;()); <br>
* shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first); <br>
* assert(pii.use_count() == 2); <br>
*</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 206 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 , typename = typename
std::enable_if&lt;std::is_convertible&lt;_Tp1*,
_Tp*&gt;::value&gt;::type&gt; std::shared_ptr&lt; _Tp
&gt;::shared_ptr (const shared_ptr&lt; _Tp1 &gt;
&amp;__r)</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
If <i>__r</i> is empty, constructs an empty shared_ptr;
otherwise construct a shared_ptr that shares ownership with
<i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">get() == __r.get() &amp;&amp;
use_count() == __r.use_count()</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 218 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; std::shared_ptr&lt; _Tp &gt;::shared_ptr
(shared_ptr&lt; _Tp &gt; &amp;&amp;__r)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move-constructs a shared_ptr instance from <i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr
rvalue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">*this contains the old value of
<i>__r</i>, <i>__r</i> is empty.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 226 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 , typename = typename
std::enable_if&lt;std::is_convertible&lt;_Tp1*,
_Tp*&gt;::value&gt;::type&gt; std::shared_ptr&lt; _Tp
&gt;::shared_ptr (shared_ptr&lt; _Tp1 &gt;
&amp;&amp;__r)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Move-constructs a shared_ptr instance from <i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr
rvalue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">*this contains the old value of
<i>__r</i>, <i>__r</i> is empty.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 236 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 &gt; std::shared_ptr&lt;
_Tp &gt;::shared_ptr (const weak_ptr&lt; _Tp1 &gt;
&amp;__r)</b> <tt>[inline]</tt><b>,</b> <tt>[explicit]</tt>
<br>
Constructs a shared_ptr that shares ownership with
<i>__r</i> and stores a copy of the pointer stored in
<i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__r</i> A weak_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() ==
__r.use_count()</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>bad_weak_ptr</i> when
__r.expired(), in which case the constructor has no
effect.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 248 of file shared_ptr.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; constexpr std::shared_ptr&lt; _Tp &gt;::shared_ptr
(nullptr_t__p)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Construct an empty shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> A null pointer
constant.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition:</b></p>

<p style="margin-left:17%;">use_count() == 0 &amp;&amp;
get() == nullptr</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 265 of file shared_ptr.h.</p>

<h2>Friends And Related Function Documentation
<a name="Friends And Related Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt; template&lt;typename _Tp1 , typename _Alloc ,
typename... _Args&gt; shared_ptr&lt;_Tp1&gt; allocate_shared
(const _Alloc &amp;__a, _Args &amp;&amp;...__args)</b>
<tt>[friend]</tt> <br>
Create an object that is owned by a shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator.
<i><br>
__args</i> Arguments for the <i>_Tp</i> object&rsquo;s
constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A shared_ptr that owns the
newly created object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>An</i> exception thrown from
<i>_Alloc::allocate</i> or from the constructor of
<i>_Tp</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A copy of
<i>__a</i> will be used to allocate memory for the
shared_ptr and the new object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 595 of file shared_ptr.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
