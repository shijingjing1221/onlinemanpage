<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:03:25 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OPENSM</title>

</head>
<body>

<h1 align="center">OPENSM</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#PARTITION CONFIGURATION">PARTITION CONFIGURATION</a><br>
<a href="#QOS CONFIGURATION">QOS CONFIGURATION</a><br>
<a href="#PREFIX ROUTES">PREFIX ROUTES</a><br>
<a href="#MKEY CONFIGURATION">MKEY CONFIGURATION</a><br>
<a href="#ROUTING">ROUTING</a><br>
<a href="#PER MODULE LOGGING CONFIGURATION">PER MODULE LOGGING CONFIGURATION</a><br>
<a href="#FILES">FILES</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">opensm &minus;
InfiniBand subnet manager and administration (SM/SA)</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>opensm</b>
[&minus;&minus;version]] [&minus;F | &minus;&minus;config
&lt;file_name&gt;] [&minus;c | &minus;&minus;create-config
&lt;file_name&gt;] [&minus;g | &minus;&minus;guid &lt;GUID
in hex&gt;] [&minus;l | &minus;&minus;lmc &lt;LMC&gt;]
[&minus;p | &minus;&minus;priority &lt;PRIORITY&gt;]
[&minus;&minus;subnet_prefix &lt;PREFIX in hex&gt;]
[&minus;&minus;smkey &lt;SM_Key&gt;] [&minus;&minus;sm_sl
&lt;SL number&gt;] [&minus;r | &minus;&minus;reassign_lids]
[&minus;R &lt;engine name(s)&gt; |
&minus;&minus;routing_engine &lt;engine name(s)&gt;]
[&minus;&minus;do_mesh_analysis]
[&minus;&minus;lash_start_vl &lt;vl number&gt;] [&minus;A |
&minus;&minus;ucast_cache] [&minus;z |
&minus;&minus;connect_roots] [&minus;M &lt;file name&gt; |
&minus;&minus;lid_matrix_file &lt;file name&gt;] [&minus;U
&lt;file name&gt; | &minus;&minus;lfts_file &lt;file
name&gt;] [&minus;S | &minus;&minus;sadb_file &lt;file
name&gt;] [&minus;a | &minus;&minus;root_guid_file &lt;path
to file&gt;] [&minus;u | &minus;&minus;cn_guid_file &lt;path
to file&gt;] [&minus;G | &minus;&minus;io_guid_file &lt;path
to file&gt;] [&minus;&minus;port&minus;shifting]
[&minus;&minus;scatter&minus;ports &lt;random seed&gt;]
[&minus;H | &minus;&minus;max_reverse_hops &lt;max reverse
hops allowed&gt;] [&minus;X |
&minus;&minus;guid_routing_order_file &lt;path to file&gt;]
[&minus;m | &minus;&minus;ids_guid_file &lt;path to
file&gt;] [&minus;o | &minus;&minus;once] [&minus;s |
&minus;&minus;sweep &lt;interval&gt;] [&minus;t |
&minus;&minus;timeout &lt;milliseconds&gt;]
[&minus;&minus;retries &lt;number&gt;]
[&minus;&minus;maxsmps &lt;number&gt;]
[&minus;&minus;console [off | local | socket | loopback]]
[&minus;&minus;console-port &lt;port&gt;] [&minus;i |
&minus;&minus;ignore-guids
&lt;equalize-ignore-guids-file&gt;] [&minus;w |
&minus;&minus;hop_weights_file &lt;path to file&gt;]
[&minus;O | &minus;&minus;port_search_ordering_file &lt;path
to file&gt;] [&minus;O | &minus;&minus;dimn_ports_file
&lt;path to file&gt;] (DEPRECATED) [&minus;f |
&minus;&minus;log_file &lt;log file path&gt; ] [&minus;L |
&minus;&minus;log_limit &lt;size in MB&gt;] [&minus;e |
&minus;&minus;erase_log_file] [&minus;P |
&minus;&minus;Pconfig &lt;partition config file&gt; ]
[&minus;N | &minus;&minus;no_part_enforce] (DEPRECATED)
[&minus;Z | &minus;&minus;part_enforce [both | in | out |
off]] [&minus;W | &minus;&minus;allow_both_pkeys] [&minus;Q
| &minus;&minus;qos [&minus;Y |
&minus;&minus;qos_policy_file &lt;file name&gt;]]
[&minus;&minus;congestion&minus;control]
[&minus;&minus;cckey &lt;key&gt;] [&minus;y |
&minus;&minus;stay_on_fatal] [&minus;B |
&minus;&minus;daemon] [&minus;J | &minus;&minus;pidfile
&lt;file_name&gt;] [&minus;I | &minus;&minus;inactive]
[&minus;&minus;perfmgr] [&minus;&minus;perfmgr_sweep_time_s
&lt;seconds&gt;] [&minus;&minus;prefix_routes_file
&lt;path&gt;] [&minus;&minus;consolidate_ipv6_snm_req]
[&minus;&minus;log_prefix &lt;prefix text&gt;]
[&minus;&minus;torus_config &lt;path to file&gt;] [&minus;v
| &minus;&minus;verbose] [&minus;V] [&minus;D &lt;flags&gt;]
[&minus;d | &minus;&minus;debug &lt;number&gt;] [&minus;h |
&minus;? | &minus;&minus;help]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">opensm is an
InfiniBand compliant Subnet Manager and Administration, and
runs on top of OpenIB.</p>

<p style="margin-left:11%; margin-top: 1em">opensm provides
an implementation of an InfiniBand Subnet Manager and
Administration. Such a software entity is required to run
for in order to initialize the InfiniBand hardware (at least
one per each InfiniBand subnet).</p>

<p style="margin-left:11%; margin-top: 1em">opensm also now
contains an experimental version of a performance manager as
well.</p>

<p style="margin-left:11%; margin-top: 1em">opensm defaults
were designed to meet the common case usage on clusters with
up to a few hundred nodes. Thus, in this default mode,
opensm will scan the IB fabric, initialize it, and sweep
occasionally for changes.</p>

<p style="margin-left:11%; margin-top: 1em">opensm attaches
to a specific IB port on the local machine and configures
only the fabric connected to it. (If the local machine has
other IB ports, opensm will ignore the fabrics connected to
those other ports). If no port is specified, it will select
the first &quot;best&quot; available port.</p>

<p style="margin-left:11%; margin-top: 1em">opensm can
present the available ports and prompt for a port number to
attach to.</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
run is logged to two files: /var/log/messages and
/var/log/opensm.log. The first file will register only
general major events, whereas the second will include
details of reported errors. All errors reported in this
second file should be treated as indicators of IB fabric
health issues. (Note that when a fatal and non-recoverable
error occurs, opensm will exit.) Both log files should
include the message &quot;SUBNET UP&quot; if opensm was able
to setup the subnet correctly.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;version</b></p>

<p style="margin-left:22%;">Prints OpenSM version and
exits.</p>

<p style="margin-left:11%;"><b>&minus;F</b>,
<b>&minus;&minus;config</b> &lt;config file&gt;</p>

<p style="margin-left:22%;">The name of the OpenSM config
file. When not specified <b>/etc/rdma/opensm.conf</b> will
be used (if exists).</p>

<p style="margin-left:11%;"><b>&minus;c</b>,
<b>&minus;&minus;create-config</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">OpenSM will dump its
configuration to the specified file and exit. This is a way
to generate OpenSM configuration file template.</p>

<p style="margin-left:11%;"><b>&minus;g</b>,
<b>&minus;&minus;guid</b> &lt;GUID in hex&gt;</p>

<p style="margin-left:22%;">This option specifies the local
port GUID value with which OpenSM should bind. OpenSM may be
bound to 1 port at a time. If GUID given is 0, OpenSM
displays a list of possible port GUIDs and waits for user
input. Without -g, OpenSM tries to use the default port.</p>

<p style="margin-left:11%;"><b>&minus;l</b>,
<b>&minus;&minus;lmc</b> &lt;LMC value&gt;</p>

<p style="margin-left:22%;">This option specifies the
subnet&rsquo;s LMC value. The number of LIDs assigned to
each port is 2^LMC. The LMC value must be in the range 0-7.
LMC values &gt; 0 allow multiple paths between ports. LMC
values &gt; 0 should only be used if the subnet topology
actually provides multiple paths between ports, i.e.
multiple interconnects between switches. Without -l, OpenSM
defaults to LMC = 0, which allows one path between any two
ports.</p>

<p style="margin-left:11%;"><b>&minus;p</b>,
<b>&minus;&minus;priority</b> &lt;Priority value&gt;</p>

<p style="margin-left:22%;">This option specifies the
SM&acute;s PRIORITY. This will effect the handover cases,
where master is chosen by priority and GUID. Range goes from
0 (default and lowest priority) to 15 (highest).</p>


<p style="margin-left:11%;"><b>&minus;&minus;subnet_prefix</b>
&lt;PREFIX in hex&gt;</p>

<p style="margin-left:22%;">This option specifies the
subnet prefix to use on the fabric. The default prefix is
0xfe80000000000000. OpenMPI in particular requires separate
fabrics plugged into different ports to have different
prefixes or else it won&rsquo;t run.</p>

<p style="margin-left:11%;"><b>&minus;&minus;smkey</b>
&lt;SM_Key value&gt;</p>

<p style="margin-left:22%;">This option specifies the
SM&acute;s SM_Key (64 bits). This will effect SM
authentication. Note that OpenSM version 3.2.1 and below
used the default value &rsquo;1&rsquo; in a host byte order,
it is fixed now but you may need this option to interoperate
with old OpenSM running on a little endian machine.</p>

<p style="margin-left:11%;"><b>&minus;&minus;sm_sl</b>
&lt;SL number&gt;</p>

<p style="margin-left:22%;">This option sets the SL to use
for communication with the SM/SA. Defaults to 0.</p>

<p style="margin-left:11%;"><b>&minus;r</b>,
<b>&minus;&minus;reassign_lids</b></p>

<p style="margin-left:22%;">This option causes OpenSM to
reassign LIDs to all end nodes. Specifying -r on a running
subnet may disrupt subnet traffic. Without -r, OpenSM
attempts to preserve existing LID assignments resolving
multiple use of same LID.</p>

<p style="margin-left:11%;"><b>&minus;R</b>,
<b>&minus;&minus;routing_engine</b> &lt;Routing engine
names&gt;</p>

<p style="margin-left:22%;">This option chooses routing
engine(s) to use instead of Min Hop algorithm (default).
Multiple routing engines can be specified separated by
commas so that specific ordering of routing algorithms will
be tried if earlier routing engines fail. If all configured
routing engines fail, OpenSM will always attempt to route
with Min Hop unless &rsquo;no_fallback&rsquo; is included in
the list of routing engines. Supported engines: minhop,
updn, dnup, file, ftree, lash, dor, torus-2QoS, dfsssp,
sssp.</p>


<p style="margin-left:11%;"><b>&minus;&minus;do_mesh_analysis</b></p>

<p style="margin-left:22%;">This option enables additional
analysis for the lash routing engine to precondition switch
port assignments in regular cartesian meshes which may
reduce the number of SLs required to give a deadlock free
routing.</p>


<p style="margin-left:11%;"><b>&minus;&minus;lash_start_vl</b>
&lt;vl number&gt;</p>

<p style="margin-left:22%;">This option sets the starting
VL to use for the lash routing algorithm. Defaults to 0.</p>

<p style="margin-left:11%;"><b>&minus;A</b>,
<b>&minus;&minus;ucast_cache</b></p>

<p style="margin-left:22%;">This option enables unicast
routing cache and prevents routing recalculation (which is a
heavy task in a large cluster) when there was no topology
change detected during the heavy sweep, or when the topology
change does not require new routing calculation, e.g. when
one or more CAs/RTRs/leaf switches going down, or one or
more of these nodes coming back after being down. A very
common case that is handled by the unicast routing cache is
host reboot, which otherwise would cause two full routing
recalculations: one when the host goes down, and the other
when the host comes back online.</p>

<p style="margin-left:11%;"><b>&minus;z</b>,
<b>&minus;&minus;connect_roots</b></p>

<p style="margin-left:22%;">This option enforces routing
engines (up/down and fat-tree) to make connectivity between
root switches and in this way to be fully IBA compliant. In
many cases this can violate &quot;pure&quot; deadlock free
algorithm, so use it carefully.</p>

<p style="margin-left:11%;"><b>&minus;M</b>,
<b>&minus;&minus;lid_matrix_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">This option specifies the name
of the lid matrix dump file from where switch lid matrices
(min hops tables will be loaded.</p>

<p style="margin-left:11%;"><b>&minus;U</b>,
<b>&minus;&minus;lfts_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">This option specifies the name
of the LFTs file from where switch forwarding tables will be
loaded when using &quot;file&quot; routing engine.</p>

<p style="margin-left:11%;"><b>&minus;S</b>,
<b>&minus;&minus;sadb_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">This option specifies the name
of the SA DB dump file from where SA database will be
loaded.</p>

<p style="margin-left:11%;"><b>&minus;a</b>,
<b>&minus;&minus;root_guid_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">Set the root nodes for the
Up/Down or Fat-Tree routing algorithm to the guids provided
in the given file (one to a line).</p>

<p style="margin-left:11%;"><b>&minus;u</b>,
<b>&minus;&minus;cn_guid_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">Set the compute nodes for the
Fat-Tree or DFSSSP/SSSP routing algorithms to the port GUIDs
provided in the given file (one to a line).</p>

<p style="margin-left:11%;"><b>&minus;G</b>,
<b>&minus;&minus;io_guid_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">Set the I/O nodes for the
Fat-Tree or DFSSSP/SSSP routing algorithms to the port GUIDs
provided in the given file (one to a line). <br>
In the case of Fat-Tree routing: <br>
I/O nodes are non-CN nodes allowed to use up to
max_reverse_hops switches the wrong way around to improve
connectivity. <br>
In the case of (DF)SSSP routing: <br>
Providing guids of compute and/or I/O nodes will ensure that
paths towards those nodes are as much separated as possible
within their node category, i.e., I/O traffic will not share
the same link if multiple links are available.</p>


<p style="margin-left:11%;"><b>&minus;&minus;port&minus;shifting</b></p>

<p style="margin-left:22%;">This option enables a feature
called <b>port shifting</b>. In some fabrics, particularly
cluster environments, routes commonly align and congest with
other routes due to algorithmically unchanging traffic
patterns. This routing option will &quot;shift&quot; routing
around in an attempt to alleviate this problem.</p>


<p style="margin-left:11%;"><b>&minus;&minus;scatter&minus;ports</b>
&lt;random seed&gt;</p>

<p style="margin-left:22%;">This option is used to
randomize port selection in routing rather than using a
round-robin algorithm (which is the default). Value supplied
with option is used as a random seed. If value is 0, which
is the default, the scatter ports option is disabled.</p>

<p style="margin-left:11%;"><b>&minus;H</b>,
<b>&minus;&minus;max_reverse_hops</b> &lt;max reverse hops
allowed&gt;</p>

<p style="margin-left:22%;">Set the maximum number of
reverse hops an I/O node is allowed to make. A reverse hop
is the use of a switch the wrong way around.</p>

<p style="margin-left:11%;"><b>&minus;m</b>,
<b>&minus;&minus;ids_guid_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">Name of the map file with set
of the IDs which will be used by Up/Down routing algorithm
instead of node GUIDs (format: &lt;guid&gt; &lt;id&gt; per
line).</p>

<p style="margin-left:11%;"><b>&minus;X</b>,
<b>&minus;&minus;guid_routing_order_file</b> &lt;file
name&gt;</p>

<p style="margin-left:22%;">Set the order port guids will
be routed for the MinHop and Up/Down routing algorithms to
the guids provided in the given file (one to a line).</p>

<p style="margin-left:11%;"><b>&minus;o</b>,
<b>&minus;&minus;once</b></p>

<p style="margin-left:22%;">This option causes OpenSM to
configure the subnet once, then exit. Ports remain in the
ACTIVE state.</p>

<p style="margin-left:11%;"><b>&minus;s</b>,
<b>&minus;&minus;sweep</b> &lt;interval value&gt;</p>

<p style="margin-left:22%;">This option specifies the
number of seconds between subnet sweeps. Specifying -s 0
disables sweeping. Without -s, OpenSM defaults to a sweep
interval of 10 seconds.</p>

<p style="margin-left:11%;"><b>&minus;t</b>,
<b>&minus;&minus;timeout</b> &lt;value&gt;</p>

<p style="margin-left:22%;">This option specifies the time
in milliseconds used for transaction timeouts. Timeout
values should be &gt; 0. Without -t, OpenSM defaults to a
timeout value of 200 milliseconds.</p>

<p style="margin-left:11%;"><b>&minus;&minus;retries</b>
&lt;number&gt;</p>

<p style="margin-left:22%;">This option specifies the
number of retries used for transactions. Without --retries,
OpenSM defaults to 3 retries for transactions.</p>

<p style="margin-left:11%;"><b>&minus;&minus;maxsmps</b>
&lt;number&gt;</p>

<p style="margin-left:22%;">This option specifies the
number of VL15 SMP MADs allowed on the wire at any one time.
Specifying &minus;&minus;maxsmps 0 allows unlimited
outstanding SMPs. Without &minus;&minus;maxsmps, OpenSM
defaults to a maximum of 4 outstanding SMPs.</p>

<p style="margin-left:11%;"><b>&minus;&minus;console [off |
local | loopback | socket]</b></p>

<p style="margin-left:22%;">This option brings up the
OpenSM console (default off). Note, loopback and socket open
a socket which can be connected to WITHOUT CREDENTIALS.
Loopback is safer if access to your SM host is controlled.
tcp_wrappers (hosts.[allow|deny]) is used with loopback and
socket. loopback and socket will only be available if OpenSM
was built with --enable-console-loopback (default yes) and
--enable-console-socket (default no) respectively.</p>


<p style="margin-left:11%;"><b>&minus;&minus;console-port</b>
&lt;port&gt;</p>

<p style="margin-left:22%;">Specify an alternate telnet
port for the socket console (default 10000). Note that this
option only appears if OpenSM was built with
--enable-console-socket.</p>

<p style="margin-left:11%;"><b>&minus;i</b>,
<b>&minus;&minus;ignore-guids</b>
&lt;equalize-ignore-guids-file&gt;</p>

<p style="margin-left:22%;">This option provides the means
to define a set of ports (by node guid and port number) that
will be ignored by the link load equalization algorithm.</p>

<p style="margin-left:11%;"><b>&minus;w</b>,
<b>&minus;&minus;hop_weights_file</b> &lt;path to
file&gt;</p>

<p style="margin-left:22%;">This option provides weighting
factors per port representing a hop cost in computing the
lid matrix. The file consists of lines containing a switch
port GUID (specified as a 64 bit hex number, with leading
0x), output port number, and weighting factor. Any port not
listed in the file defaults to a weighting factor of 1.
Lines starting with # are comments. Weights affect only the
output route from the port, so many useful configurations
will require weights to be specified in pairs.</p>

<p style="margin-left:11%;"><b>&minus;O</b>,
<b>&minus;&minus;port_search_ordering_file</b> &lt;path to
file&gt;</p>

<p style="margin-left:22%;">This option tweaks the routing.
It suitable for two cases: 1. While using DOR routing
algorithm. This option provides a mapping between hypercube
dimensions and ports on a per switch basis for the DOR
routing engine. The file consists of lines containing a
switch node GUID (specified as a 64 bit hex number, with
leading 0x) followed by a list of non-zero port numbers,
separated by spaces, one switch per line. The order for the
port numbers is in one to one correspondence to the
dimensions. Ports not listed on a line are assigned to the
remaining dimensions, in port order. Anything after a # is a
comment. 2. While using general routing algorithm. This
option provides the order of the ports that would be chosen
for routing, from each switch rather than searching for an
appropriate port from port 1 to N. The file consists of
lines containing a switch node GUID (specified as a 64 bit
hex number, with leading 0x) followed by a list of non-zero
port numbers, separated by spaces, one switch per line. In
case of DOR, the order for the port numbers is in one to one
correspondence to the dimensions. Ports not listed on a line
are assigned to the remaining dimensions, in port order.
Anything after a # is a comment.</p>

<p style="margin-left:11%;"><b>&minus;O</b>,
<b>&minus;&minus;dimn_ports_file</b> &lt;path to file&gt;
<b>(DEPRECATED)</b></p>

<p style="margin-left:22%;">This is a deprecated flag.
Please use <b>&minus;&minus;port_search_ordering_file</b>
instead. This option provides a mapping between hypercube
dimensions and ports on a per switch basis for the DOR
routing engine. The file consists of lines containing a
switch node GUID (specified as a 64 bit hex number, with
leading 0x) followed by a list of non-zero port numbers,
separated by spaces, one switch per line. The order for the
port numbers is in one to one correspondence to the
dimensions. Ports not listed on a line are assigned to the
remaining dimensions, in port order. Anything after a # is a
comment.</p>

<p style="margin-left:11%;"><b>&minus;x</b>,
<b>&minus;&minus;honor_guid2lid</b></p>

<p style="margin-left:22%;">This option forces OpenSM to
honor the guid2lid file, when it comes out of Standby state,
if such file exists under OSM_CACHE_DIR, and is valid. By
default, this is FALSE.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;log_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">This option defines the log to
be the given file. By default, the log goes to
/var/log/opensm.log. For the log to go to standard output
use -f stdout.</p>

<p style="margin-left:11%;"><b>&minus;L</b>,
<b>&minus;&minus;log_limit</b> &lt;size in MB&gt;</p>

<p style="margin-left:22%;">This option defines maximal log
file size in MB. When specified the log file will be
truncated upon reaching this limit.</p>

<p style="margin-left:11%;"><b>&minus;e</b>,
<b>&minus;&minus;erase_log_file</b></p>

<p style="margin-left:22%;">This option will cause deletion
of the log file (if it previously exists). By default, the
log file is accumulative.</p>

<p style="margin-left:11%;"><b>&minus;P</b>,
<b>&minus;&minus;Pconfig</b> &lt;partition config
file&gt;</p>

<p style="margin-left:22%;">This option defines the
optional partition configuration file. The default name is
<b>/etc/rdma/partitions.conf</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;prefix_routes_file</b>
&lt;file name&gt;</p>

<p style="margin-left:22%;">Prefix routes control how the
SA responds to path record queries for off-subnet DGIDs. By
default, the SA fails such queries. The <b>PREFIX ROUTES</b>
section below describes the format of the configuration
file. The default path is
<b>/etc/rdma/prefix&minus;routes.conf</b>.</p>

<p style="margin-left:11%;"><b>&minus;Q</b>,
<b>&minus;&minus;qos</b></p>

<p style="margin-left:22%;">This option enables QoS setup.
It is disabled by default.</p>

<p style="margin-left:11%;"><b>&minus;Y</b>,
<b>&minus;&minus;qos_policy_file</b> &lt;file name&gt;</p>

<p style="margin-left:22%;">This option defines the
optional QoS policy file. The default name is
<b>/etc/rdma/qos-policy.conf</b>. See
QoS_management_in_OpenSM.txt in opensm doc for more
information on configuring QoS policy via this file.</p>


<p style="margin-left:11%;"><b>&minus;&minus;congestion_control</b></p>

<p style="margin-left:22%;">(EXPERIMENTAL) This option
enables congestion control configuration. It is disabled by
default. See config file for congestion control
configuration options. <b>&minus;&minus;cc_key</b>
&lt;key&gt; (EXPERIMENTAL) This option configures the CCkey
to use when configuring congestion control. Note that this
option does not configure a new CCkey into switches and CAs.
Defaults to 0.</p>

<p style="margin-left:11%;"><b>&minus;N</b>,
<b>&minus;&minus;no_part_enforce (DEPRECATED)</b></p>

<p style="margin-left:22%;">This is a deprecated flag.
Please use <b>&minus;&minus;part_enforce</b> instead. This
option disables partition enforcement on switch external
ports.</p>

<p style="margin-left:11%;"><b>&minus;Z</b>,
<b>&minus;&minus;part_enforce</b> [both | in | out |
off]</p>

<p style="margin-left:22%;">This option indicates the
partition enforcement type (for switches). Enforcement type
can be inbound only (in), outbound only (out), both or
disabled (off). Default is both.</p>

<p style="margin-left:11%;"><b>&minus;W</b>,
<b>&minus;&minus;allow_both_pkeys</b></p>

<p style="margin-left:22%;">This option indicates whether
both full and limited membership on the same partition can
be configured in the PKeyTable. Default is not to allow both
pkeys.</p>

<p style="margin-left:11%;"><b>&minus;y</b>,
<b>&minus;&minus;stay_on_fatal</b></p>

<p style="margin-left:22%;">This option will cause SM not
to exit on fatal initialization issues: if SM discovers
duplicated guids or a 12x link with lane reversal badly
configured. By default, the SM will exit on these
errors.</p>

<p style="margin-left:11%;"><b>&minus;B</b>,
<b>&minus;&minus;daemon</b></p>

<p style="margin-left:22%;">Run in daemon mode - OpenSM
will run in the background.</p>

<p style="margin-left:11%;"><b>&minus;J</b>,
<b>&minus;&minus;pidfile &lt;file_name&gt;</b></p>

<p style="margin-left:22%;">Makes the SM write its own PID
to the specified file when started in daemon mode.</p>

<p style="margin-left:11%;"><b>&minus;I</b>,
<b>&minus;&minus;inactive</b></p>

<p style="margin-left:22%;">Start SM in inactive rather
than init SM state. This option can be used in conjunction
with the perfmgr so as to run a standalone performance
manager without SM/SA. However, this is NOT currently
implemented in the performance manager.</p>


<p style="margin-left:11%;"><b>&minus;&minus;perfmgr</b></p>

<p style="margin-left:22%;">Enable the perfmgr. Only takes
effect if --enable-perfmgr was specified at configure time.
See performance-manager-HOWTO.txt in opensm doc for more
information on running perfmgr.</p>


<p style="margin-left:11%;"><b>&minus;&minus;perfmgr_sweep_time_s</b>
&lt;seconds&gt;</p>

<p style="margin-left:22%;">Specify the sweep time for the
performance manager in seconds (default is 180 seconds).
Only takes effect if --enable-perfmgr was specified at
configure time.</p>


<p style="margin-left:11%;"><b>--consolidate_ipv6_snm_req</b></p>

<p style="margin-left:22%;">Use shared MLID for IPv6
Solicited Node Multicast groups per MGID scope and
P_Key.</p>


<p style="margin-left:11%;"><b>&minus;&minus;log_prefix</b>
&lt;prefix text&gt;</p>

<p style="margin-left:22%;">This option specifies the
prefix to the syslog messages from OpenSM. A suitable prefix
can be used to identify the IB subnet in syslog messages
when two or more instances of OpenSM run in a single node to
manage multiple fabrics. For example, in a dual-fabric (or
dual-rail) IB cluster, the prefix for the first fabric could
be &quot;mpi&quot; and the other fabric could be
&quot;storage&quot;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;torus_config</b>
&lt;path to torus&minus;2QoS config file&gt;</p>

<p style="margin-left:22%;">This option defines the file
name for the extra configuration information needed for the
torus-2QoS routing engine. The default name is
<b>/etc/rdma/torus-2QoS.conf</b></p>

<p style="margin-left:11%;"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:22%;">This option increases the log
verbosity level. The -v option may be specified multiple
times to further increase the verbosity level. See the -D
option for more information about log verbosity.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>This option sets the maximum verbosity level and forces
log flushing. The -V option is equivalent to &acute;-D 0xFF
-d 2&acute;. See the -D option for more information about
log verbosity.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;D</b>
&lt;value&gt;</p>

<p style="margin-left:22%;">This option sets the log
verbosity level. A flags field must follow the -D option. A
bit set/clear in the flags enables/disables a specific log
level as follows:</p>

<p style="margin-left:22%; margin-top: 1em">BIT LOG LEVEL
ENABLED <br>
---- ----------------- <br>
0x01 - ERROR (error messages) <br>
0x02 - INFO (basic messages, low volume) <br>
0x04 - VERBOSE (interesting stuff, moderate volume) <br>
0x08 - DEBUG (diagnostic, high volume) <br>
0x10 - FUNCS (function entry/exit, very high volume) <br>
0x20 - FRAMES (dumps all SMP and GMP frames) <br>
0x40 - ROUTING (dump FDB routing information) <br>
0x80 - SYS (syslog at LOG_INFO level in addition to OpenSM
logging)</p>

<p style="margin-left:22%; margin-top: 1em">Without -D,
OpenSM defaults to ERROR + INFO (0x3). Specifying -D 0
disables all messages. Specifying -D 0xFF enables all
messages (see -V). High verbosity levels may require
increasing the transaction timeout with the -t option.</p>

<p style="margin-left:11%;"><b>&minus;d</b>,
<b>&minus;&minus;debug</b> &lt;value&gt;</p>

<p style="margin-left:22%;">This option specifies a debug
option. These options are not normally needed. The number
following -d selects the debug option to enable as
follows:</p>

<p style="margin-left:22%; margin-top: 1em">OPT Description
<br>
--- ----------------- <br>
-d0 - Ignore other SM nodes <br>
-d1 - Force single threaded dispatching <br>
-d2 - Force log flushing after each log message <br>
-d3 - Disable multicast support</p>

<p style="margin-left:11%;"><b>&minus;h</b>,
<b>&minus;&minus;help</b>, <b>&minus;?</b></p>

<p style="margin-left:22%;">Display this usage info then
exit.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
environment variables control opensm behavior:</p>

<p style="margin-left:11%; margin-top: 1em">OSM_TMP_DIR -
controls the directory in which the temporary files
generated by opensm are created. These files are:
opensm-subnet.lst, opensm.fdbs, and opensm.mcfdbs. By
default, this directory is /var/log.</p>

<p style="margin-left:11%; margin-top: 1em">OSM_CACHE_DIR -
opensm stores certain data to the disk such that subsequent
runs are consistent. The default directory used is
/var/cache/opensm. The following files are included in
it:</p>

<p style="margin-left:11%; margin-top: 1em">guid2lid -
stores the LID range assigned to each GUID <br>
guid2mkey - stores the MKey previously assiged to each GUID
<br>
neighbors - stores a map of the GUIDs at either end of each
link <br>
in the fabric</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When opensm
receives a HUP signal, it starts a new heavy sweep as if a
trap was received or a topology change was found.</p>

<p style="margin-left:11%; margin-top: 1em">Also, SIGUSR1
can be used to trigger a reopen of /var/log/opensm.log for
logrotate purposes.</p>

<h2>PARTITION CONFIGURATION
<a name="PARTITION CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The default
name of OpenSM partitions configuration file is
<b>/etc/rdma/partitions.conf</b>. The default may be changed
by using the --Pconfig (-P) option with OpenSM.</p>

<p style="margin-left:11%; margin-top: 1em">The default
partition will be created by OpenSM unconditionally even
when partition configuration file does not exist or cannot
be accessed.</p>

<p style="margin-left:11%; margin-top: 1em">The default
partition has P_Key value 0x7fff. OpenSM&acute;s port will
always have full membership in default partition. All other
end ports will have full membership if the partition
configuration file is not found or cannot be accessed, or
limited membership if the file exists and can be accessed
but there is no rule for the Default partition.</p>

<p style="margin-left:11%; margin-top: 1em">Effectively,
this amounts to the same as if one of the following rules
below appear in the partition configuration file.</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
no rule for the Default partition:</p>

<p style="margin-left:11%; margin-top: 1em">Default=0x7fff
: ALL=limited, SELF=full ;</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
no partition configuration file or file cannot be
accessed:</p>

<p style="margin-left:11%; margin-top: 1em">Default=0x7fff
: ALL=full ;</p>

<p style="margin-left:11%; margin-top: 1em">File Format</p>

<p style="margin-left:11%; margin-top: 1em">Comments:</p>

<p style="margin-left:11%; margin-top: 1em">Line content
followed after &acute;#&acute; character is comment and
ignored by parser.</p>

<p style="margin-left:11%; margin-top: 1em">General file
format:</p>

<p style="margin-left:11%; margin-top: 1em">&lt;Partition
Definition&gt;:[&lt;newline&gt;]&lt;Partition
Properties&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">Partition
Definition: <br>

[PartitionName][=PKey][,ipoib_bc_flags][,defmember=full|limited]</p>

<p style="margin-left:11%; margin-top: 1em">PartitionName -
string, will be used with logging. When <br>
omitted, empty string will be used. <br>
PKey - P_Key value for this partition. Only low 15 <br>
bits will be used. When omitted will be <br>
autogenerated. <br>
ipoib_bc_flags - used to indicate/specify IPoIB capability
of <br>
this partition.</p>


<p style="margin-left:11%; margin-top: 1em">defmember=full|limited|both
- specifies default membership for <br>
port guid list. Default is limited.</p>


<p style="margin-left:11%; margin-top: 1em">ipoib_bc_flags:
<br>
ipoib_flag|[mgroup_flag]*</p>

<p style="margin-left:11%; margin-top: 1em">ipoib_flag:
<br>
ipoib - indicates that this partition may be used for <br>
IPoIB, as a result the IPoIB broadcast group will <br>
be created with the mgroup_flag flags given, <br>
if any.</p>

<p style="margin-left:11%; margin-top: 1em">Partition
Properties: <br>
[&lt;Port list&gt;|&lt;MCast Group&gt;]* | &lt;Port
list&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Port list: <br>
&lt;Port Specifier&gt;[,&lt;Port Specifier&gt;]</p>

<p style="margin-left:11%; margin-top: 1em">Port Specifier:
<br>
&lt;PortGUID&gt;[=[full|limited|both]]</p>

<p style="margin-left:11%; margin-top: 1em">PortGUID - GUID
of partition member EndPort. <br>
Hexadecimal numbers should start from <br>
0x, decimal numbers are accepted too. <br>
full, limited, - indicates full and/or limited membership
for <br>
both this port. When omitted (or unrecognized) <br>
limited membership is assumed. Both <br>
indicates both full and limited membership <br>
for this port.</p>

<p style="margin-left:11%; margin-top: 1em">MCast Group:
<br>
mgid=gid[,mgroup_flag]*&lt;newline&gt;</p>

<p style="margin-left:11%; margin-top: 1em">- gid specified
is verified to be a Multicast <br>
address. IP groups are verified to match <br>
the rate and mtu of the broadcast group. <br>
The P_Key bits of the mgid for IP groups are <br>
verified to either match the P_Key specified <br>
in by &quot;Partition Definition&quot; or if they are <br>
0x0000 the P_Key will be copied into those <br>
bits.</p>

<p style="margin-left:11%; margin-top: 1em">mgroup_flag:
<br>
rate=&lt;val&gt; - specifies rate for this MC group <br>
(default is 3 (10GBps)) <br>
mtu=&lt;val&gt; - specifies MTU for this MC group <br>
(default is 4 (2048)) <br>
sl=&lt;val&gt; - specifies SL for this MC group <br>
(default is 0) <br>
scope=&lt;val&gt; - specifies scope for this MC group <br>
(default is 2 (link local)). Multiple scope <br>
settings are permitted for a partition. <br>
NOTE: This overwrites the scope nibble of the <br>
specified mgid. Furthermore specifying <br>
multiple scope settings will result in <br>
multiple MC groups being created. <br>
Q_Key=&lt;val&gt; - specifies the Q_Key for this MC group
<br>
(default: 0x0b1b for IP groups, 0 for other <br>
groups) <br>
WARNING: changing this for the broadcast <br>
group may break IPoIB on client <br>
nodes!! <br>
TClass=&lt;val&gt; - specifies tclass for this MC group <br>
(default is 0) <br>
FlowLabel=&lt;val&gt; - specifies FlowLabel for this MC
group <br>
(default is 0)</p>

<p style="margin-left:11%; margin-top: 1em">Note that
values for rate, mtu, and scope, for both partitions and
multicast groups, should be specified as defined in the IBTA
specification (for example, mtu=4 for 2048).</p>

<p style="margin-left:11%; margin-top: 1em">There are
several useful keywords for PortGUID definition:</p>

<p style="margin-left:11%; margin-top: 1em">-
&rsquo;ALL&rsquo; means all end ports in this subnet. <br>
- &rsquo;ALL_CAS&rsquo; means all Channel Adapter end ports
in this subnet. <br>
- &rsquo;ALL_SWITCHES&rsquo; means all Switch end ports in
this subnet. <br>
- &rsquo;ALL_ROUTERS&rsquo; means all Router end ports in
this subnet. <br>
- &rsquo;SELF&rsquo; means subnet manager&rsquo;s port.</p>

<p style="margin-left:11%; margin-top: 1em">Empty list
means no ports in this partition.</p>

<p style="margin-left:11%; margin-top: 1em">Notes:</p>

<p style="margin-left:11%; margin-top: 1em">White space is
permitted between delimiters (&rsquo;=&rsquo;,
&rsquo;,&rsquo;,&rsquo;:&rsquo;,&rsquo;;&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">PartitionName
does not need to be unique, PKey does need to be unique. If
PKey is repeated then those partition configurations will be
merged and first PartitionName will be used (see also next
note).</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to split partition configuration in more than one
definition, but then PKey should be explicitly specified
(otherwise different PKey values will be generated for those
definitions).</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">Default=0x7fff
: ALL, SELF=full ; <br>
Default=0x7fff : ALL, ALL_SWITCHES=full, SELF=full ;</p>

<p style="margin-left:11%; margin-top: 1em">NewPartition ,
ipoib : 0x123456=full, 0x3456789034=limi, 0x2134af2306 ;</p>

<p style="margin-left:11%; margin-top: 1em">YetAnotherOne =
0x300 : SELF=full ; <br>
YetAnotherOne = 0x300 : ALL=limited ;</p>

<p style="margin-left:11%; margin-top: 1em">ShareIO = 0x80
, defmember=full : 0x123451, 0x123452; <br>
# 0x123453, 0x123454 will be limited <br>
ShareIO = 0x80 : 0x123453, 0x123454, 0x123455=full; <br>
# 0x123456, 0x123457 will be limited <br>
ShareIO = 0x80 : defmember=limited : 0x123456, 0x123457,
0x123458=full; <br>
ShareIO = 0x80 , defmember=full : 0x123459, 0x12345a; <br>
ShareIO = 0x80 , defmember=full : 0x12345b,
0x12345c=limited, 0x12345d;</p>

<p style="margin-left:11%; margin-top: 1em"># multicast
groups added to default <br>
Default=0x7fff,ipoib: <br>
mgid=ff12:401b::0707,sl=1 # random IPv4 group <br>
mgid=ff12:601b::16 # MLDv2-capable routers <br>
mgid=ff12:401b::16 # IGMP <br>
mgid=ff12:601b::2 # All routers <br>
mgid=ff12::1,sl=1,Q_Key=0xDEADBEEF,rate=3,mtu=2 # random
group <br>
ALL=full;</p>

<p style="margin-left:11%; margin-top: 1em">Note:</p>

<p style="margin-left:11%; margin-top: 1em">The following
rule is equivalent to how OpenSM used to run prior to the
partition manager:</p>


<p style="margin-left:11%; margin-top: 1em">Default=0x7fff,ipoib:ALL=full;</p>

<h2>QOS CONFIGURATION
<a name="QOS CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a set
of QoS related low-level configuration parameters. All these
parameter names are prefixed by &quot;qos_&quot; string.
Here is a full list of these parameters:</p>

<p style="margin-left:11%; margin-top: 1em">qos_max_vls -
The maximum number of VLs that will be on the subnet <br>
qos_high_limit - The limit of High Priority component of VL
<br>
Arbitration table (IBA 7.6.9) <br>
qos_vlarb_low - Low priority VL Arbitration table (IBA
7.6.9) <br>
template <br>
qos_vlarb_high - High priority VL Arbitration table (IBA
7.6.9) <br>
template <br>
Both VL arbitration templates are pairs of <br>
VL and weight <br>
qos_sl2vl - SL2VL Mapping table (IBA 7.6.6) template. It is
<br>
a list of VLs corresponding to SLs 0-15 (Note <br>
that VL15 used here means drop this SL)</p>

<p style="margin-left:11%; margin-top: 1em">Typical default
values (hard-coded in OpenSM initialization) are:</p>

<p style="margin-left:11%; margin-top: 1em">qos_max_vls 15
<br>
qos_high_limit 0 <br>
qos_vlarb_low
0:0,1:4,2:4,3:4,4:4,5:4,6:4,7:4,8:4,9:4,10:4,11:4,12:4,13:4,14:4
<br>
qos_vlarb_high
0:4,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0
<br>
qos_sl2vl 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,7</p>

<p style="margin-left:11%; margin-top: 1em">The syntax is
compatible with rest of OpenSM configuration options and
values may be stored in OpenSM config file (cached options
file).</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the above, we may define separate QoS configuration
parameters sets for various target types. As targets, we
currently support CAs, routers, switch external ports, and
switch&rsquo;s enhanced port 0. The names of such
specialized parameters are prefixed by
&quot;qos_&lt;type&gt;_&quot; string. Here is a full list of
the currently supported sets:</p>

<p style="margin-left:11%; margin-top: 1em">qos_ca_ - QoS
configuration parameters set for CAs. <br>
qos_rtr_ - parameters set for routers. <br>
qos_sw0_ - parameters set for switches&rsquo; port 0. <br>
qos_swe_ - parameters set for switches&rsquo; external
ports.</p>

<p style="margin-left:11%; margin-top: 1em">Examples: <br>
qos_sw0_max_vls=2 <br>
qos_ca_sl2vl=0,1,2,3,5,5,5,12,12,0, <br>
qos_swe_high_limit=0</p>

<h2>PREFIX ROUTES
<a name="PREFIX ROUTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Prefix routes
control how the SA responds to path record queries for
off-subnet DGIDs. By default, the SA fails such queries.
Note that IBA does not specify how the SA should obtain
off-subnet path record information. The prefix routes
configuration is meant as a stop-gap until the specification
is completed.</p>

<p style="margin-left:11%; margin-top: 1em">Each line in
the configuration file is a 64-bit prefix followed by a
64-bit GUID, separated by white space. The GUID specifies
the router port on the local subnet that will handle the
prefix. Blank lines are ignored, as is anything between a
<b>#</b> character and the end of the line. The prefix and
GUID are both in hex, the leading 0x is optional. Either, or
both, can be wild-carded by specifying an asterisk instead
of an explicit prefix or GUID.</p>

<p style="margin-left:11%; margin-top: 1em">When responding
to a path record query for an off-subnet DGID, opensm
searches for the first prefix match in the configuration
file. Therefore, the order of the lines in the configuration
file is important: a wild-carded prefix at the beginning of
the configuration file renders all subsequent lines useless.
If there is no match, then opensm fails the query. It is
legal to repeat prefixes in the configuration file, opensm
will return the path to the first available matching router.
A configuration file with a single line where both prefix
and GUID are wild-carded means that a path record query
specifying any off-subnet DGID should return a path to the
first available router. This configuration yields the same
behavior formerly achieved by compiling opensm with
-DROUTER_EXP which has been obsoleted.</p>

<h2>MKEY CONFIGURATION
<a name="MKEY CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">OpenSM supports
configuring a single management key (MKey) for use across
the subnet.</p>

<p style="margin-left:11%; margin-top: 1em">The following
configuration options are available:</p>

<p style="margin-left:11%; margin-top: 1em">m_key - the
64-bit MKey to be used on the subnet <br>
(IBA 14.2.4) <br>
m_key_protection_level - the numeric value of the MKey
ProtectBits <br>
(IBA 14.2.4.1) <br>
m_key_lease_period - the number of seconds a CA will wait
for a <br>
response from the SM before resetting the <br>
protection level to 0 (IBA 14.2.4.2).</p>

<p style="margin-left:11%; margin-top: 1em">OpenSM will
configure all ports with the MKey specified by m_key,
defaulting to a value of 0. A m_key value of 0 disables MKey
protection on the subnet. Switches and HCAs with a non-zero
MKey will not accept requests to change their configuration
unless the request includes the proper MKey.</p>

<p style="margin-left:11%; margin-top: 1em">MKey Protection
Levels</p>

<p style="margin-left:11%; margin-top: 1em">MKey protection
levels modify how switches and CAs respond to SMPs lacking a
valid MKey. OpenSM will configure each port&rsquo;s
ProtectBits to support the level defined by the
m_key_protection_level parameter. If no parameter is
specified, OpenSM defaults to operating at protection level
0.</p>

<p style="margin-left:11%; margin-top: 1em">There are
currently 4 protection levels defined by the IBA:</p>

<p style="margin-left:11%; margin-top: 1em">0 - Queries
return valid data, including MKey. Configuration changes
<br>
are not allowed unless the request contains a valid MKey.
<br>
1 - Like level 0, but the MKey is set to 0 (0x00000000) in
queries, <br>
unless the request contains a valid MKey. <br>
2 - Neither queries nor configuration changes are allowed,
unless the <br>
request contains a valid MKey. <br>
3 - Identical to 2. Maintained for backwards
compatibility.</p>

<p style="margin-left:11%; margin-top: 1em">MKey Lease
Period</p>

<p style="margin-left:11%; margin-top: 1em">InfiniBand
supports a MKey lease timeout, which is intended to allow
administrators or a new SM to recover/reset lost MKeys on a
fabric.</p>

<p style="margin-left:11%; margin-top: 1em">If MKeys are
enabled on the subnet and a switch or CA receives a request
that requires a valid MKey but does not contain one, it
warns the SM by sending a trap (Bad M_Key, Trap 256). If the
MKey lease period is non-zero, it also starts a countdown
timer for the time specified by the lease period. If a SM
(or other agent) responds with the correct MKey, the timer
is stopped and reset. Should the timer reach zero, the
switch or CA will reset its MKey protection level to 0,
exposing the MKey and allowing recovery.</p>

<p style="margin-left:11%; margin-top: 1em">OpenSM will
initialize all ports to use a mkey lease period of the
number of seconds specified in the config file. If no
mkey_lease_period is specified, a default of 0 will be
used.</p>

<p style="margin-left:11%; margin-top: 1em">OpenSM normally
quickly responds to all Bad_M_Key traps, resetting the lease
timers. Additionally, OpenSM&rsquo;s subnet sweeps will also
cancel any running timers. For maximum protection against
accidentally-exposed MKeys, the MKey lease time should be a
few multiples of the subnet sweep time. If OpenSM detects at
startup that your sweep interval is greater than your MKey
lease period, it will reset the lease period to be greater
than the sweep interval. Similarly, if sweeping is disabled
at startup, it will be re-enabled with an interval less than
the Mkey lease period.</p>

<p style="margin-left:11%; margin-top: 1em">If OpenSM is
required to recover a subnet for which it is missing mkeys,
it must do so one switch level at a time. As such, the total
time to recover the subnet may be as long as the mkey lease
period multiplied by the maximum number of hops between the
SM and an endpoint, plus one.</p>

<p style="margin-left:11%; margin-top: 1em">MKey Effects on
Diagnostic Utilities</p>

<p style="margin-left:11%; margin-top: 1em">Setting a MKey
may have a detrimental effect on diagnostic software run on
the subnet, unless your diagnostic software is able to
retrieve MKeys from the SA or can be explicitly configured
with the proper MKey. This is particularly true at
protection level 2, where CAs will ignore queries for
management information that do not contain the proper
MKey.</p>

<h2>ROUTING
<a name="ROUTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">OpenSM now
offers nine routing engines:</p>

<p style="margin-left:11%; margin-top: 1em">1. Min Hop
Algorithm - based on the minimum hops to each node where the
path length is optimized.</p>

<p style="margin-left:11%; margin-top: 1em">2. UPDN Unicast
routing algorithm - also based on the minimum hops to each
node, but it is constrained to ranking rules. This algorithm
should be chosen if the subnet is not a pure Fat Tree, and
deadlock may occur due to a loop in the subnet.</p>

<p style="margin-left:11%; margin-top: 1em">3. DNUP Unicast
routing algorithm - similar to UPDN but allows routing in
fabrics which have some CA nodes attached closer to the
roots than some switch nodes.</p>

<p style="margin-left:11%; margin-top: 1em">4. Fat Tree
Unicast routing algorithm - this algorithm optimizes routing
for congestion-free &quot;shift&quot; communication pattern.
It should be chosen if a subnet is a symmetrical or almost
symmetrical fat-tree of various types, not just
K-ary-N-Trees: non-constant K, not fully staffed, any
Constant Bisectional Bandwidth (CBB) ratio. Similar to UPDN,
Fat Tree routing is constrained to ranking rules.</p>

<p style="margin-left:11%; margin-top: 1em">5. LASH unicast
routing algorithm - uses Infiniband virtual layers (SL) to
provide deadlock-free shortest-path routing while also
distributing the paths between layers. LASH is an
alternative deadlock-free topology-agnostic routing
algorithm to the non-minimal UPDN algorithm avoiding the use
of a potentially congested root node.</p>

<p style="margin-left:11%; margin-top: 1em">6. DOR Unicast
routing algorithm - based on the Min Hop algorithm, but
avoids port equalization except for redundant links between
the same two switches. This provides deadlock free routes
for hypercubes when the fabric is cabled as a hypercube and
for meshes when cabled as a mesh (see details below).</p>

<p style="margin-left:11%; margin-top: 1em">7. Torus-2QoS
unicast routing algorithm - a DOR-based routing algorithm
specialized for 2D/3D torus topologies. Torus-2QoS provides
deadlock-free routing while supporting two quality of
service (QoS) levels. In addition it is able to route around
multiple failed fabric links or a single failed fabric
switch without introducing deadlocks, and without changing
path SL values granted before the failure.</p>

<p style="margin-left:11%; margin-top: 1em">8. DFSSSP
unicast routing algorithm - a deadlock-free
single-source-shortest-path routing, which uses the SSSP
algorithm (see algorithm 9.) as the base to optimize link
utilization and uses Infiniband virtual lanes (SL) to
provide deadlock-freedom.</p>

<p style="margin-left:11%; margin-top: 1em">9. SSSP unicast
routing algorithm - a single-source-shortest-path routing
algorithm, which globally balances the number of routes per
link to optimize link utilization. This routing algorithm
has no restrictions in terms of the underlying topology.</p>

<p style="margin-left:11%; margin-top: 1em">OpenSM also
supports a file method which can load routes from a table.
See &acute;Modular Routing Engine&acute; for more
information on this.</p>

<p style="margin-left:11%; margin-top: 1em">The basic
routing algorithm is comprised of two stages:</p>

<p style="margin-left:11%; margin-top: 1em">1. MinHop
matrix calculation <br>
How many hops are required to get from each port to each LID
? <br>
The algorithm to fill these tables is different if you run
standard (min hop) or Up/Down. <br>
For standard routing, a &quot;relaxation&quot; algorithm is
used to propagate min hop from every destination LID through
neighbor switches <br>
For Up/Down routing, a BFS from every target is used. The
BFS tracks link direction (up or down) and avoid steps that
will perform up after a down step was used.</p>

<p style="margin-left:11%; margin-top: 1em">2. Once MinHop
matrices exist, each switch is visited and for each target
LID a decision is made as to what port should be used to get
to that LID. <br>
This step is common to standard and Up/Down routing. Each
port has a counter counting the number of target LIDs going
through it. <br>
When there are multiple alternative ports with same MinHop
to a LID, the one with less previously assigned LIDs is
selected. <br>
If LMC &gt; 0, more checks are added: Within each group of
LIDs assigned to same target port, <br>
a. use only ports which have same MinHop <br>
b. first prefer the ones that go to different
systemImageGuid (then the previous LID of the same LMC
group) <br>
c. if none - prefer those which go through another NodeGuid
<br>
d. fall back to the number of paths method (if all go to
same node).</p>

<p style="margin-left:11%; margin-top: 1em">Effect of
Topology Changes</p>

<p style="margin-left:11%; margin-top: 1em">OpenSM will
preserve existing routing in any case where there is no
change in the fabric switches unless the -r
(--reassign_lids) option is specified.</p>

<p style="margin-left:11%; margin-top: 1em">-r <br>
--reassign_lids <br>
This option causes OpenSM to reassign LIDs to all <br>
end nodes. Specifying -r on a running subnet <br>
may disrupt subnet traffic. <br>
Without -r, OpenSM attempts to preserve existing <br>
LID assignments resolving multiple use of same LID.</p>

<p style="margin-left:11%; margin-top: 1em">If a link is
added or removed, OpenSM does not recalculate the routes
that do not have to change. A route has to change if the
port is no longer UP or no longer the MinHop. When routing
changes are performed, the same algorithm for balancing the
routes is invoked.</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
using the file based routing, any topology changes are
currently ignored The &rsquo;file&rsquo; routing engine just
loads the LFTs from the file specified, with no reaction to
real topology. Obviously, this will not be able to recheck
LIDs (by GUID) for disconnected nodes, and LFTs for
non-existent switches will be skipped. Multicast is not
affected by &rsquo;file&rsquo; routing engine (this uses min
hop tables).</p>

<p style="margin-left:11%; margin-top: 1em">Min Hop
Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The Min Hop
algorithm is invoked by default if no routing algorithm is
specified. It can also be invoked by specifying &rsquo;-R
minhop&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">The Min Hop
algorithm is divided into two stages: computation of min-hop
tables on every switch and LFT output port assignment. Link
subscription is also equalized with the ability to override
based on port GUID. The latter is supplied by:</p>

<p style="margin-left:11%; margin-top: 1em">-i
&lt;equalize-ignore-guids-file&gt; <br>
&minus;&minus;ignore-guids
&lt;equalize-ignore-guids-file&gt; <br>
This option provides the means to define a set of ports <br>
(by guid) that will be ignored by the link load <br>
equalization algorithm. Note that only endports (CA, <br>
switch port 0, and router ports) and not switch external
<br>
ports are supported.</p>

<p style="margin-left:11%; margin-top: 1em">LMC awareness
routes based on (remote) system or switch basis.</p>

<p style="margin-left:11%; margin-top: 1em">Purpose of UPDN
Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The UPDN
algorithm is designed to prevent deadlocks from occurring in
loops of the subnet. A loop-deadlock is a situation in which
it is no longer possible to send data between any two hosts
connected through the loop. As such, the UPDN routing
algorithm should be used if the subnet is not a pure Fat
Tree, and one of its loops may experience a deadlock (due,
for example, to high pressure).</p>

<p style="margin-left:11%; margin-top: 1em">The UPDN
algorithm is based on the following main stages:</p>

<p style="margin-left:11%; margin-top: 1em">1. Auto-detect
root nodes - based on the CA hop length from any switch in
the subnet, a statistical histogram is built for each switch
(hop num vs number of occurrences). If the histogram
reflects a specific column (higher than others) for a
certain node, then it is marked as a root node. Since the
algorithm is statistical, it may not find any root nodes.
The list of the root nodes found by this auto-detect stage
is used by the ranking process stage.</p>

<p style="margin-left:11%; margin-top: 1em">Note 1: The
user can override the node list manually. <br>
Note 2: If this stage cannot find any root nodes, and the
user did <br>
not specify a guid list file, OpenSM defaults back to the
<br>
Min Hop routing algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">2. Ranking
process - All root switch nodes (found in stage 1) are
assigned a rank of 0. Using the BFS algorithm, the rest of
the switch nodes in the subnet are ranked incrementally.
This ranking aids in the process of enforcing rules that
ensure loop-free paths.</p>

<p style="margin-left:11%; margin-top: 1em">3. Min Hop
Table setting - after ranking is done, a BFS algorithm is
run from each (CA or switch) node in the subnet. During the
BFS process, the FDB table of each switch node traversed by
BFS is updated, in reference to the starting node, based on
the ranking rules and guid values.</p>

<p style="margin-left:11%; margin-top: 1em">At the end of
the process, the updated FDB tables ensure loop-free paths
through the subnet.</p>

<p style="margin-left:11%; margin-top: 1em">Note: Up/Down
routing does not allow LID routing communication between
switches that are located inside spine &quot;switch
systems&quot;. The reason is that there is no way to allow a
LID route between them that does not break the Up/Down rule.
One ramification of this is that you cannot run SM on
switches other than the leaf switches of the fabric.</p>

<p style="margin-left:11%; margin-top: 1em">UPDN Algorithm
Usage</p>

<p style="margin-left:11%; margin-top: 1em">Activation
through OpenSM</p>

<p style="margin-left:11%; margin-top: 1em">Use &rsquo;-R
updn&rsquo; option (instead of old &rsquo;-u&rsquo;) to
activate the UPDN algorithm. Use &rsquo;-a
&lt;root_guid_file&gt;&rsquo; for adding an UPDN guid file
that contains the root nodes for ranking. If the
&lsquo;-a&rsquo; option is not used, OpenSM uses its
auto-detect root nodes algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">Notes on the
guid list file:</p>

<p style="margin-left:11%; margin-top: 1em">1. A valid guid
file specifies one guid in each line. Lines with an invalid
format will be discarded. <br>
2. The user should specify the root switch guids. However,
it is also possible to specify CA guids; OpenSM will use the
guid of the switch (if it exists) that connects the CA to
the subnet as a root node.</p>

<p style="margin-left:11%; margin-top: 1em">Purpose of DNUP
Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The DNUP
algorithm is designed to serve a similar purpose to UPDN.
However it is intended to work in network topologies which
are unsuited to UPDN due to nodes being connected closer to
the roots than some of the switches. An example would be a
fabric which contains nodes and uplinks connected to the
same switch. The operation of DNUP is the same as UPDN with
the exception of the ranking process. In DNUP all switch
nodes are ranked based solely on their distance from CA
Nodes, all switch nodes directly connected to at least one
CA are assigned a value of 1 all other switch nodes are
assigned a value of one more than the minimum rank of all
neighbor switch nodes.</p>

<p style="margin-left:11%; margin-top: 1em">Fat-tree
Routing Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The fat-tree
algorithm optimizes routing for &quot;shift&quot;
communication pattern. It should be chosen if a subnet is a
symmetrical or almost symmetrical fat-tree of various types.
It supports not just K-ary-N-Trees, by handling for
non-constant K, cases where not all leafs (CAs) are present,
any CBB ratio. As in UPDN, fat-tree also prevents
credit-loop-deadlocks.</p>

<p style="margin-left:11%; margin-top: 1em">If the root
guid file is not provided (&rsquo;-a&rsquo; or
&rsquo;--root_guid_file&rsquo; options), the topology has to
be pure fat-tree that complies with the following rules:
<br>
- Tree rank should be between two and eight (inclusively)
<br>
- Switches of the same rank should have the same number <br>
of UP-going port groups*, unless they are root switches,
<br>
in which case the shouldn&rsquo;t have UP-going ports at
all. <br>
- Switches of the same rank should have the same number <br>
of DOWN-going port groups, unless they are leaf switches.
<br>
- Switches of the same rank should have the same number <br>
of ports in each UP-going port group. <br>
- Switches of the same rank should have the same number <br>
of ports in each DOWN-going port group. <br>
- All the CAs have to be at the same tree level (rank).</p>

<p style="margin-left:11%; margin-top: 1em">If the root
guid file is provided, the topology doesn&rsquo;t have to be
pure fat-tree, and it should only comply with the following
rules: <br>
- Tree rank should be between two and eight (inclusively)
<br>
- All the Compute Nodes** have to be at the same tree level
(rank). <br>
Note that non-compute node CAs are allowed here to be at
different <br>
tree ranks.</p>

<p style="margin-left:11%; margin-top: 1em">* ports that
are connected to the same remote switch are referenced as
&acute;port group&acute;.</p>

<p style="margin-left:11%; margin-top: 1em">** list of
compute nodes (CNs) can be specified by &acute;-u&acute; or
&acute;--cn_guid_file&acute; OpenSM options.</p>

<p style="margin-left:11%; margin-top: 1em">Topologies that
do not comply cause a fallback to min hop routing. Note that
this can also occur on link failures which cause the
topology to no longer be &quot;pure&quot; fat-tree.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
although fat-tree algorithm supports trees with non-integer
CBB ratio, the routing will not be as balanced as in case of
integer CBB ratio. In addition to this, although the
algorithm allows leaf switches to have any number of CAs,
the closer the tree is to be fully populated, the more
effective the &quot;shift&quot; communication pattern will
be. In general, even if the root list is provided, the
closer the topology to a pure and symmetrical fat-tree, the
more optimal the routing will be.</p>

<p style="margin-left:11%; margin-top: 1em">The algorithm
also dumps compute node ordering file
(opensm-ftree-ca-order.dump) in the same directory where the
OpenSM log resides. This ordering file provides the CN order
that may be used to create efficient communication pattern,
that will match the routing tables.</p>

<p style="margin-left:11%; margin-top: 1em">Routing between
non-CN nodes</p>

<p style="margin-left:11%; margin-top: 1em">The use of the
cn_guid_file option allows non-CN nodes to be located on
different levels in the fat tree. In such case, it is not
guaranteed that the Fat Tree algorithm will route between
two non-CN nodes. To solve this problem, a list of non-CN
nodes can be specified by &acute;-G&acute; or
&acute;--io_guid_file&acute; option. Theses nodes will be
allowed to use switches the wrong way round a specific
number of times (specified by &acute;-H&acute; or
&acute;--max_reverse_hops&acute;. With the proper
max_reverse_hops and io_guid_file values, you can ensure
full connectivity in the Fat Tree.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that using max_reverse_hops creates routes that use the
switch in a counter-stream way. This option should never be
used to connect nodes with high bandwidth traffic between
them ! It should only be used to allow connectivity for HA
purposes or similar. Also having routes the other way around
can in theory cause credit loops.</p>

<p style="margin-left:11%; margin-top: 1em">Use these
options with extreme care !</p>

<p style="margin-left:11%; margin-top: 1em">Activation
through OpenSM</p>

<p style="margin-left:11%; margin-top: 1em">Use &rsquo;-R
ftree&rsquo; option to activate the fat-tree algorithm. Use
&rsquo;-a &lt;root_guid_file&gt;&rsquo; to provide root
nodes for ranking. If the &lsquo;-a&rsquo; option is not
used, routing algorithm will detect roots automatically. Use
&rsquo;-u &lt;root_cn_file&gt;&rsquo; to provide the list of
compute nodes. If the &lsquo;-u&rsquo; option is not used,
all the CAs are considered as compute nodes.</p>

<p style="margin-left:11%; margin-top: 1em">Note: LMC &gt;
0 is not supported by fat-tree routing. If this is
specified, the default routing algorithm is invoked
instead.</p>

<p style="margin-left:11%; margin-top: 1em">LASH Routing
Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">LASH is an
acronym for LAyered SHortest Path Routing. It is a
deterministic shortest path routing algorithm that enables
topology agnostic deadlock-free routing within communication
networks.</p>

<p style="margin-left:11%; margin-top: 1em">When computing
the routing function, LASH analyzes the network topology for
the shortest-path routes between all pairs of sources /
destinations and groups these paths into virtual layers in
such a way as to avoid deadlock.</p>

<p style="margin-left:11%; margin-top: 1em">Note LASH
analyzes routes and ensures deadlock freedom between switch
pairs. The link from HCA between and switch does not need
virtual layers as deadlock will not arise between switch and
HCA.</p>

<p style="margin-left:11%; margin-top: 1em">In more detail,
the algorithm works as follows:</p>

<p style="margin-left:11%; margin-top: 1em">1) LASH
determines the shortest-path between all pairs of source /
destination switches. Note, LASH ensures the same SL is used
for all SRC/DST - DST/SRC pairs and there is no guarantee
that the return path for a given DST/SRC will be the reverse
of the route SRC/DST.</p>

<p style="margin-left:11%; margin-top: 1em">2) LASH then
begins an SL assignment process where a route is assigned to
a layer (SL) if the addition of that route does not cause
deadlock within that layer. This is achieved by maintaining
and analysing a channel dependency graph for each layer.
Once the potential addition of a path could lead to
deadlock, LASH opens a new layer and continues the
process.</p>

<p style="margin-left:11%; margin-top: 1em">3) Once this
stage has been completed, it is highly likely that the first
layers processed will contain more paths than the latter
ones. To better balance the use of layers, LASH moves paths
from one layer to another so that the number of paths in
each layer averages out.</p>

<p style="margin-left:11%; margin-top: 1em">Note, the
implementation of LASH in opensm attempts to use as few
layers as possible. This number can be less than the number
of actual layers available.</p>

<p style="margin-left:11%; margin-top: 1em">In general LASH
is a very flexible algorithm. It can, for example, reduce to
Dimension Order Routing in certain topologies, it is
topology agnostic and fares well in the face of faults.</p>

<p style="margin-left:11%; margin-top: 1em">It has been
shown that for both regular and irregular topologies, LASH
outperforms Up/Down. The reason for this is that LASH
distributes the traffic more evenly through a network,
avoiding the bottleneck issues related to a root node and
always routes shortest-path.</p>

<p style="margin-left:11%; margin-top: 1em">The algorithm
was developed by Simula Research Laboratory.</p>

<p style="margin-left:11%; margin-top: 1em">Use &rsquo;-R
lash -Q &rsquo; option to activate the LASH algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">Note: QoS
support has to be turned on in order that SL/VL mappings are
used.</p>

<p style="margin-left:11%; margin-top: 1em">Note: LMC &gt;
0 is not supported by the LASH routing. If this is
specified, the default routing algorithm is invoked
instead.</p>

<p style="margin-left:11%; margin-top: 1em">For open
regular cartesian meshes the DOR algorithm is the ideal
routing algorithm. For toroidal meshes on the other hand
there are routing loops that can cause deadlocks. LASH can
be used to route these cases. The performance of LASH can be
improved by preconditioning the mesh in cases where there
are multiple links connecting switches and also in cases
where the switches are not cabled consistently. An option
exists for LASH to do this. To invoke this use &rsquo;-R
lash -Q --do_mesh_analysis&rsquo;. This will add an
additional phase that analyses the mesh to try to determine
the dimension and size of a mesh. If it determines that the
mesh looks like an open or closed cartesian mesh it reorders
the ports in dimension order before the rest of the LASH
algorithm runs.</p>

<p style="margin-left:11%; margin-top: 1em">DOR Routing
Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The Dimension
Order Routing algorithm is based on the Min Hop algorithm
and so uses shortest paths. Instead of spreading traffic out
across different paths with the same shortest distance, it
chooses among the available shortest paths based on an
ordering of dimensions. Each port must be consistently
cabled to represent a hypercube dimension or a mesh
dimension. Alternatively, the -O option can be used to
assign a custom mapping between the ports on a given switch,
and the associated dimension. Paths are grown from a
destination back to a source using the lowest dimension
(port) of available paths at each step. This provides the
ordering necessary to avoid deadlock. When there are
multiple links between any two switches, they still
represent only one dimension and traffic is balanced across
them unless port equalization is turned off. In the case of
hypercubes, the same port must be used throughout the fabric
to represent the hypercube dimension and match on both ends
of the cable, or the -O option used to accomplish the
alignment. In the case of meshes, the dimension should
consistently use the same pair of ports, one port on one end
of the cable, and the other port on the other end,
continuing along the mesh dimension, or the -O option used
as an override.</p>

<p style="margin-left:11%; margin-top: 1em">Use &rsquo;-R
dor&rsquo; option to activate the DOR algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">DFSSSP and SSSP
Routing Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">The
(Deadlock-Free) Single-Source-Shortest-Path routing
algorithm is designed to optimize link utilization thru
global balancing of routes, while supporting arbitrary
topologies. The DFSSSP routing algorithm uses Infiniband
virtual lanes (SL) to provide deadlock-freedom.</p>

<p style="margin-left:11%; margin-top: 1em">The DFSSSP
algorithm consists of five major steps: <br>
1) It discovers the subnet and models the subnet as a
directed multigraph in which each node represents a node of
the physical network and each edge represents one direction
of the full-duplex links used to connect the nodes. <br>
2) A loop, which iterates over all CA and switches of the
subnet, will perform three steps to generate the linear
forwarding tables for each switch: <br>
2.1) use Dijkstra&rsquo;s algorithm to find the shortest
path from all nodes to the current selected destination;
<br>
2.2) update the egde weights in the graph, i.e. add the
number of routes, which use a link to reach the destination,
to the link/edge; <br>
2.3) update the LFT of each switch with the outgoing port
which was used in the current step to route the traffic to
the destination node. <br>
3) After the number of available virtual lanes or layers in
the subnet is detected and a channel dependency graph is
initialized for each layer, the algorithm will put each
possible route of the subnet into the first layer. <br>
4) A loop iterates over all channel dependency graphs (CDG)
and performs the following substeps: <br>
4.1) search for a cycle in the current CDG; <br>
4.2) when a cycle is found, i.e. a possible deadlock is
present, one edge is selected and all routes, which induced
this egde, are moved to the &quot;next higher&quot; virtual
layer (CDG[i+1]); <br>
4.3) the cycle search is continued until all cycles are
broken and routes are moved &quot;up&quot;. <br>
5) When the number of needed layers does not exceeds the
number of available SL/VL to remove all cycles in all CDGs,
the rounting is deadlock-free and an relation table is
generated, which contains the assignment of routes from
source to destination to a SL</p>

<p style="margin-left:11%; margin-top: 1em">Note on SSSP:
<br>
This algorithm does not perform the steps 3)-5) and can not
be considered to be deadlock-free for all topologies. But on
the one hand, you can choose this algorithm for really large
networks (5,000+ CAs and deadlock-free by design) to reduce
the runtime of the algorithm. On the other hand, you might
use the SSSP routing algorithm as an alternative, when all
deadlock-free routing algorithms fail to route the network
for whatever reason. In the last case, SSSP was designed to
deliver an equal or higher bandwidth due to better
congestion avoidance than the Min Hop routing algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">Notes for
usage: <br>
a) running DFSSSP: &rsquo;-R dfsssp -Q&rsquo; <br>
a.1) QoS has to be configured to equally spread the load on
the available SL or virtual lanes <br>
a.2) applications must perform a path record query to get
path SL for each route, which the application will use to
transmite packages <br>
b) running SSSP: &rsquo;-R sssp&rsquo; <br>
c) both algorithms support LMC &gt; 0</p>

<p style="margin-left:11%; margin-top: 1em">Hints for
optimizing I/O traffic: <br>
Having more nodes (I/O and compute) connected to a switch
than incoming links can result in a &rsquo;bad&rsquo;
routing of the I/O traffic as long as (DF)SSSP routing is
not aware of the dedicated I/O nodes, i.e., in the following
network configuration CN1-CN3 might send all I/O traffic via
Link2 to IO1,IO2:</p>

<p style="margin-left:11%; margin-top: 1em">CN1 Link1 IO1
<br>
\ /----\ / <br>
CN2 -- Switch1 Switch2 -- CN4 <br>
/ \----/ \ <br>
CN3 Link2 IO2</p>

<p style="margin-left:11%; margin-top: 1em">To prevent this
from happening (DF)SSSP can use both the compute node guid
file and the I/O guid file specified by the &acute;-u&acute;
or &acute;--cn_guid_file&acute; and &acute;-G&acute; or
&acute;--io_guid_file&acute; options (similar to the
Fat-Tree routing). This ensures that traffic towards compute
nodes and I/O nodes is balanced separately and therefore
distributed as much as possible across the available links.
Port GUIDs, as listed by ibstat, must be specified (not Node
GUIDs). <br>
The priority for the optimization is as follows: <br>
compute nodes -&gt; I/O nodes -&gt; other nodes <br>
Possible use case szenarios: <br>
a) neither &acute;-u&acute; nor &acute;-G&acute; are
specified: all nodes a treated as &acute;other nodes&acute;
and therefore balanced equally; <br>
b) &acute;-G&acute; is specified: traffic towards I/O nodes
will be balanced optimally; <br>
c) the system has three node types, such as login/admin,
compute and I/O, but the balancing focus should be I/O, then
one has to use &acute;-u&acute; and &acute;-G&acute; with
I/O guids listed in cn_guid_file and compute node guids
listed in io_guid_file; <br>
d) ...</p>

<p style="margin-left:11%; margin-top: 1em">Torus-2QoS
Routing Algorithm</p>

<p style="margin-left:11%; margin-top: 1em">Torus-2QoS is
routing algorithm designed for large-scale 2D/3D torus
fabrics; see torus-2QoS(8) for full documentation.</p>

<p style="margin-left:11%; margin-top: 1em">Use &rsquo;-R
torus-2QoS -Q&rsquo; or &rsquo;-R torus-2QoS,no_fallback
-Q&rsquo; to activate the torus-2QoS algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">Routing
References</p>

<p style="margin-left:11%; margin-top: 1em">To learn more
about deadlock-free routing, see the article &quot;Deadlock
Free Message Routing in Multiprocessor Interconnection
Networks&quot; by William J Dally and Charles L Seitz
(1985).</p>

<p style="margin-left:11%; margin-top: 1em">To learn more
about the up/down algorithm, see the article &quot;Effective
Strategy to Compute Forwarding Tables for InfiniBand
Networks&quot; by Jose Carlos Sancho, Antonio Robles, and
Jose Duato at the Universidad Politecnica de Valencia.</p>

<p style="margin-left:11%; margin-top: 1em">To learn more
about LASH and the flexibility behind it, the requirement
for layers, performance comparisons to other algorithms, see
the following articles:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Layered
Routing in Irregular Networks&quot;, Lysne et al, IEEE
Transactions on Parallel and Distributed Systems, VOL.16,
No12, December 2005.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Routing
for the ASI Fabric Manager&quot;, Solheim et al. IEEE
Communications Magazine, Vol.44, No.7, July 2006.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Layered
Shortest Path (LASH) Routing in Irregular System Area
Networks&quot;, Skeie et al. IEEE Computer Society
Communication Architecture for Clusters 2002.</p>

<p style="margin-left:11%; margin-top: 1em">To learn more
about the DFSSSP and SSSP routing algorithm, see the
articles: <br>
J. Domke, T. Hoefler and W. Nagel: Deadlock-Free Oblivious
Routing for Arbitrary Topologies, In Proceedings of the 25th
IEEE International Parallel &amp; Distributed Processing
Symposium (IPDPS 2011) <br>
T. Hoefler, T. Schneider and A. Lumsdaine: Optimized Routing
for Large-Scale InfiniBand Networks, In 17th Annual IEEE
Symposium on High Performance Interconnects (HOTI 2009)</p>

<p style="margin-left:11%; margin-top: 1em">Modular Routine
Engine</p>

<p style="margin-left:11%; margin-top: 1em">Modular routing
engine structure allows for the ease of &quot;plugging&quot;
new routing modules.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, only
unicast callbacks are supported. Multicast can be added
later.</p>

<p style="margin-left:11%; margin-top: 1em">One existing
routing module is up-down &quot;updn&quot;, which may be
activated with &rsquo;-R updn&rsquo; option (instead of old
&rsquo;-u&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">General usage
is: $ opensm -R &rsquo;module-name&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">There is also a
trivial routing module which is able to load LFT tables from
a file.</p>

<p style="margin-left:11%; margin-top: 1em">Main
features:</p>

<p style="margin-left:11%; margin-top: 1em">- this will
load switch LFTs and/or LID matrices (min hops tables) <br>
- this will load switch LFTs according to the path entries
introduced <br>
in the file <br>
- no additional checks will be performed (such as &quot;is
port connected&quot;, <br>
etc.) <br>
- in case when fabric LIDs were changed this will try to
reconstruct <br>
LFTs correctly if endport GUIDs are represented in the file
<br>
(in order to disable this, GUIDs may be removed from the
file <br>
or zeroed)</p>

<p style="margin-left:11%; margin-top: 1em">The file format
is compatible with output of &rsquo;ibroute&rsquo; util and
for whole fabric can be generated with dump_lfts.sh
script.</p>

<p style="margin-left:11%; margin-top: 1em">To activate
file based routing module, use:</p>

<p style="margin-left:11%; margin-top: 1em">opensm -R file
-U /path/to/lfts_file</p>

<p style="margin-left:11%; margin-top: 1em">If the
lfts_file is not found or is in error, the default routing
algorithm is utilized.</p>

<p style="margin-left:11%; margin-top: 1em">The ability to
dump switch lid matrices (aka min hops tables) to file and
later to load these is also supported.</p>

<p style="margin-left:11%; margin-top: 1em">The usage is
similar to unicast forwarding tables loading from a lfts
file (introduced by &rsquo;file&rsquo; routing engine), but
new lid matrix file name should be specified by -M or
--lid_matrix_file option. For example:</p>

<p style="margin-left:11%; margin-top: 1em">opensm -R file
-M ./opensm-lid-matrix.dump</p>

<p style="margin-left:11%; margin-top: 1em">The dump file
is named &acute;opensm-lid-matrix.dump&acute; and will be
generated in standard opensm dump directory (/var/log by
default) when OSM_LOG_ROUTING logging flag is set.</p>

<p style="margin-left:11%; margin-top: 1em">When routing
engine &rsquo;file&rsquo; is activated, but the lfts file is
not specified or not cannot be open default lid matrix
algorithm will be used.</p>

<p style="margin-left:11%; margin-top: 1em">There is also a
switch forwarding tables dumper which generates a file
compatible with dump_lfts.sh output. This file can be used
as input for forwarding tables loading by &rsquo;file&rsquo;
routing engine. Both or one of options -U and -M can be
specified together with &acute;-R file&acute;.</p>

<h2>PER MODULE LOGGING CONFIGURATION
<a name="PER MODULE LOGGING CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To enable per
module logging, configure per_module_logging_file to the per
module logging config file name in the opensm options file.
To disable, configure per_module_logging_file to (null)
there.</p>

<p style="margin-left:11%; margin-top: 1em">The per module
logging config file format is a set of lines with module
name and logging level as follows:</p>

<p style="margin-left:11%; margin-top: 1em">&lt;module
name&gt;&lt;separator&gt;&lt;logging level&gt;</p>

<p style="margin-left:11%; margin-top: 1em">&lt;module
name&gt; is the file name including .c <br>
&lt;separator&gt; is either = , space, or tab <br>
&lt;logging level&gt; is the same levels as used in the
coarse/overall <br>
logging as follows:</p>

<p style="margin-left:11%; margin-top: 1em">BIT LOG LEVEL
ENABLED <br>
---- ----------------- <br>
0x01 - ERROR (error messages) <br>
0x02 - INFO (basic messages, low volume) <br>
0x04 - VERBOSE (interesting stuff, moderate volume) <br>
0x08 - DEBUG (diagnostic, high volume) <br>
0x10 - FUNCS (function entry/exit, very high volume) <br>
0x20 - FRAMES (dumps all SMP and GMP frames) <br>
0x40 - ROUTING (dump FDB routing information) <br>
0x80 - SYS (syslog at LOG_INFO level in addition to OpenSM
logging)</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>/etc/rdma/opensm.conf</b></p>

<p style="margin-left:22%;">default OpenSM config file.</p>


<p style="margin-left:11%;"><b>/etc/rdma/ib-node-name-map</b></p>

<p style="margin-left:22%;">default node name map file. See
ibnetdiscover for more information on format.</p>


<p style="margin-left:11%;"><b>/etc/rdma/partitions.conf</b></p>

<p style="margin-left:22%;">default partition config
file</p>


<p style="margin-left:11%;"><b>/etc/rdma/qos-policy.conf</b></p>

<p style="margin-left:22%;">default QOS policy config
file</p>


<p style="margin-left:11%;"><b>/etc/rdma/prefix-routes.conf</b></p>

<p style="margin-left:22%;">default prefix routes file</p>


<p style="margin-left:11%;"><b>/etc/rdma/per-module-logging.conf</b></p>

<p style="margin-left:22%;">default per module logging
config file</p>


<p style="margin-left:11%;"><b>/etc/rdma/torus-2QoS.conf</b></p>

<p style="margin-left:22%;">default torus-2QoS config
file</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hal
Rosenstock</p>


<p style="margin-left:22%;">&lt;<i>hal@mellanox.com</i>&gt;</p>

<p style="margin-left:11%;">Sasha Khapyorsky</p>


<p style="margin-left:22%;">&lt;<i>sashak@voltaire.com</i>&gt;</p>

<p style="margin-left:11%;">Eitan Zahavi</p>


<p style="margin-left:22%;">&lt;<i>eitan@mellanox.co.il</i>&gt;</p>

<p style="margin-left:11%;">Yevgeny Kliteynik</p>


<p style="margin-left:22%;">&lt;<i>kliteyn@mellanox.co.il</i>&gt;</p>

<p style="margin-left:11%;">Thomas Sodring</p>


<p style="margin-left:22%;">&lt;<i>tsodring@simula.no</i>&gt;</p>

<p style="margin-left:11%;">Ira Weiny</p>


<p style="margin-left:22%;">&lt;<i>weiny2@llnl.gov</i>&gt;</p>

<p style="margin-left:11%;">Dale Purdy</p>


<p style="margin-left:22%;">&lt;<i>purdy@sgi.com</i>&gt;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">torus-2QoS(8),
torus-2QoS.conf(5).</p>
<hr>
</body>
</html>
