<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 01:12:09 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__GET_USER_PAGES</title>

</head>
<body>

<h1 align="center">__GET_USER_PAGES</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__get_user_pages
&minus; pin user pages in memory</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>long
__get_user_pages(struct&nbsp;task_struct&nbsp;*&nbsp;</b><i>tsk</i><b>,
struct&nbsp;mm_struct&nbsp;*&nbsp;</b><i>mm</i><b>,
unsigned&nbsp;long&nbsp;</b><i>start</i><b>,
unsigned&nbsp;long&nbsp;</b><i>nr_pages</i><b>,
unsigned&nbsp;int&nbsp;</b><i>gup_flags</i><b>,
struct&nbsp;page&nbsp;**&nbsp;</b><i>pages</i><b>,
struct&nbsp;vm_area_struct&nbsp;**&nbsp;</b><i>vmas</i><b>,
int&nbsp;*&nbsp;</b><i>nonblocking</i><b>);</b></p> </td></tr>
</table>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><i>tsk</i></b></p>

<p style="margin-left:17%;">task_struct of target task</p>

<p style="margin-left:11%; margin-top: 1em"><i>mm</i></p>

<p style="margin-left:17%;">mm_struct of target mm</p>


<p style="margin-left:11%; margin-top: 1em"><i>start</i></p>

<p style="margin-left:17%;">starting user address</p>


<p style="margin-left:11%; margin-top: 1em"><i>nr_pages</i></p>

<p style="margin-left:17%;">number of pages from start to
pin</p>


<p style="margin-left:11%; margin-top: 1em"><i>gup_flags</i></p>

<p style="margin-left:17%;">flags modifying pin
behaviour</p>


<p style="margin-left:11%; margin-top: 1em"><i>pages</i></p>

<p style="margin-left:17%;">array that receives pointers to
the pages pinned. Should be at least nr_pages long. Or NULL,
if caller only intends to ensure the pages are faulted
in.</p>


<p style="margin-left:11%; margin-top: 1em"><i>vmas</i></p>

<p style="margin-left:17%;">array of pointers to vmas
corresponding to each page. Or NULL if the caller does not
require them.</p>


<p style="margin-left:11%; margin-top: 1em"><i>nonblocking</i></p>

<p style="margin-left:17%;">whether waiting for disk IO or
mmap_sem contention</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Returns number
of pages pinned. This may be fewer than the number
requested. If nr_pages is 0 or negative, returns 0. If no
pages were pinned, returns &minus;errno. Each page returned
must be released with a <b>put_page</b> call when it is
finished with. vmas will only remain valid while mmap_sem is
held.</p>

<p style="margin-left:11%; margin-top: 1em">Must be called
with mmap_sem held for read or write.</p>


<p style="margin-left:11%; margin-top: 1em">__get_user_pages
walks a process's page tables and takes a reference to each
struct page that each user address corresponds to at a given
instant. That is, it takes the page that would be accessed
if a user thread accesses the given user virtual address at
that instant.</p>

<p style="margin-left:11%; margin-top: 1em">This does not
guarantee that the page exists in the user mappings when
__get_user_pages returns, and there may even be a completely
different page there in some cases (eg. if mmapped pagecache
has been invalidated and subsequently re faulted). However
it does guarantee that the page won't be freed completely.
And mostly callers simply care that the page contains data
that was valid *at some point in time*. Typically, an IO or
similar operation cannot guarantee anything stronger anyway
because locks can't be held over the syscall boundary.</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>gup_flags</i> &amp; FOLL_WRITE == 0, the page must not be
written to. If the page is written to, set_page_dirty (or
set_page_dirty_lock, as appropriate) must be called after
the page is finished with, and before put_page is
called.</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>nonblocking</i> != NULL, __get_user_pages will not wait
for disk IO or mmap_sem contention, and if waiting is needed
to pin all pages, *<i>nonblocking</i> will be set to 0.</p>

<p style="margin-left:11%; margin-top: 1em">In most cases,
get_user_pages or get_user_pages_fast should be used instead
of __get_user_pages. __get_user_pages should be used only if
you need some special <i>gup_flags</i>.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<hr>
</body>
</html>
