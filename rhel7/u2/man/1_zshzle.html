<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:55:13 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ZSHZLE</title>

</head>
<body>

<h1 align="center">ZSHZLE</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#KEYMAPS">KEYMAPS</a><br>
<a href="#ZLE BUILTINS">ZLE BUILTINS</a><br>
<a href="#WIDGETS">WIDGETS</a><br>
<a href="#USER&minus;DEFINED WIDGETS">USER&minus;DEFINED WIDGETS</a><br>
<a href="#STANDARD WIDGETS">STANDARD WIDGETS</a><br>
<a href="#CHARACTER HIGHLIGHTING">CHARACTER HIGHLIGHTING</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">zshzle &minus;
zsh command line editor</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the
<b>ZLE</b> option is set (which it is by default in
interactive shells) and the shell input is attached to the
terminal, the user is able to edit command lines.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
display modes. The first, multiline mode, is the default. It
only works if the <b>TERM</b> parameter is set to a valid
terminal type that can move the cursor up. The second,
single line mode, is used if <b>TERM</b> is invalid or
incapable of moving the cursor up, or if the
<b>SINGLE_LINE_ZLE</b> option is set. This mode is similar
to <b>ksh</b>, and uses no termcap sequences. If <b>TERM</b>
is &quot;emacs&quot;, the <b>ZLE</b> option will be unset by
default.</p>

<p style="margin-left:11%; margin-top: 1em">The parameters
<b>BAUD</b>, <b>COLUMNS</b>, and <b>LINES</b> are also used
by the line editor. See <i>Parameters Used By The Shell</i>
in <i>zshparam</i>(1).</p>

<p style="margin-left:11%; margin-top: 1em">The parameter
<b>zle_highlight</b> is also used by the line editor; see
<i>Character Highlighting</i> below. Highlighting of special
characters and the region between the cursor and the mark
(as set with <b>set&minus;mark&minus;command</b> in Emacs
mode) is enabled by default; consult this reference for more
information. Irascible conservatives will wish to know that
all highlighting may be disabled by the following
setting:</p>


<p style="margin-left:22%; margin-top: 1em"><b>zle_highlight=(none)</b></p>

<h2>KEYMAPS
<a name="KEYMAPS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A keymap in ZLE
contains a set of bindings between key sequences and ZLE
commands. The empty key sequence cannot be bound.</p>

<p style="margin-left:11%; margin-top: 1em">There can be
any number of keymaps at any time, and each keymap has one
or more names. If all of a keymap&rsquo;s names are deleted,
it disappears. <b>bindkey</b> can be used to manipulate
keymap names.</p>

<p style="margin-left:11%; margin-top: 1em">Initially,
there are six keymaps:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>emacs</b></p></td>
<td width="4%"></td>
<td width="41%">


<p>EMACS emulation</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>viins</b></p></td>
<td width="4%"></td>
<td width="41%">


<p>vi emulation &minus; insert mode</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>vicmd</b></p></td>
<td width="4%"></td>
<td width="41%">


<p>vi emulation &minus; command mode</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>isearch</b></p>

<p style="margin-left:22%;">incremental search mode</p>

<p style="margin-left:11%;"><b>command</b></p>

<p style="margin-left:22%;">read a command name</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>.safe</b></p></td>
<td width="4%"></td>
<td width="23%">


<p>fallback keymap</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
&lsquo;<b>.safe</b>&rsquo; keymap is special. It can never
be altered, and the name can never be removed. However, it
can be linked to other names, which can be removed. In the
future other special keymaps may be added; users should
avoid using names beginning with &lsquo;<b>.</b>&rsquo; for
their own keymaps.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
these names, either &lsquo;<b>emacs</b>&rsquo; or
&lsquo;<b>viins</b>&rsquo; is also linked to the name
&lsquo;<b>main</b>&rsquo;. If one of the <b>VISUAL</b> or
<b>EDITOR</b> environment variables contain the string
&lsquo;<b>vi</b>&rsquo; when the shell starts up then it
will be &lsquo;<b>viins</b>&rsquo;, otherwise it will be
&lsquo;<b>emacs</b>&rsquo;. <b>bindkey</b>&rsquo;s
<b>&minus;e</b> and <b>&minus;v</b> options provide a
convenient way to override this default choice.</p>

<p style="margin-left:11%; margin-top: 1em">When the editor
starts up, it will select the &lsquo;<b>main</b>&rsquo;
keymap. If that keymap doesn&rsquo;t exist, it will use
&lsquo;<b>.safe</b>&rsquo; instead.</p>

<p style="margin-left:11%; margin-top: 1em">In the
&lsquo;<b>.safe</b>&rsquo; keymap, each single key is bound
to <b>self&minus;insert</b>, except for ^J (line feed) and
^M (return) which are bound to <b>accept&minus;line</b>.
This is deliberately not pleasant to use; if you are using
it, it means you deleted the main keymap, and you should put
it back.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reading
Commands</b> <br>
When ZLE is reading a command from the terminal, it may read
a sequence that is bound to some command and is also a
prefix of a longer bound string. In this case ZLE will wait
a certain time to see if more characters are typed, and if
not (or they don&rsquo;t match any longer string) it will
execute the binding. This timeout is defined by the
<b>KEYTIMEOUT</b> parameter; its default is 0.4 sec. There
is no timeout if the prefix string is not itself bound to a
command.</p>

<p style="margin-left:11%; margin-top: 1em">The key timeout
is also applied when ZLE is reading the bytes from a
multibyte character string when it is in the appropriate
mode. (This requires that the shell was compiled with
multibyte mode enabled; typically also the locale has
characters with the UTF&minus;8 encoding, although any
multibyte encoding known to the operating system is
supported.) If the second or a subsequent byte is not read
within the timeout period, the shell acts as if <b>?</b>
were typed and resets the input state.</p>

<p style="margin-left:11%; margin-top: 1em">As well as ZLE
commands, key sequences can be bound to other strings, by
using &lsquo;<b>bindkey &minus;s</b>&rsquo;. When such a
sequence is read, the replacement string is pushed back as
input, and the command reading process starts again using
these fake keystrokes. This input can itself invoke further
replacement strings, but in order to detect loops the
process will be stopped if there are twenty such
replacements without a real command being read.</p>

<p style="margin-left:11%; margin-top: 1em">A key sequence
typed by the user can be turned into a command name for use
in user&minus;defined widgets with the
<b>read&minus;command</b> widget, described below.</p>

<h2>ZLE BUILTINS
<a name="ZLE BUILTINS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The ZLE module
contains three related builtin commands. The <b>bindkey</b>
command manipulates keymaps and key bindings; the
<b>vared</b> command invokes ZLE on the value of a shell
parameter; and the <b>zle</b> command manipulates editing
widgets and allows command line access to ZLE commands from
within shell functions. <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;l</b> [
<b>&minus;L</b> ] [ <i>keymap</i> ... ] <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;d <br>
bindkey</b> [ <i>options</i> ] <b>&minus;D</b> <i>keymap</i>
... <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;A</b>
<i>old&minus;keymap new&minus;keymap</i> <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;N</b>
<i>new&minus;keymap</i> [ <i>old&minus;keymap</i> ] <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;m <br>
bindkey</b> [ <i>options</i> ] <b>&minus;r</b>
<i>in&minus;string</i> ... <b><br>
bindkey</b> [ <i>options</i> ] <b>&minus;s</b>
<i>in&minus;string out&minus;string</i> ... <b><br>
bindkey</b> [ <i>options</i> ] <i>in&minus;string
command</i> ... <b><br>
bindkey</b> [ <i>options</i> ] [ <i>in&minus;string</i>
]</p>

<p style="margin-left:22%;"><b>bindkey</b>&rsquo;s options
can be divided into three categories: keymap selection for
the current command, operation selection, and others. The
keymap selection options are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;e</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Selects keymap &lsquo;<b>emacs</b>&rsquo; for any
operations by the current command, and also links
&lsquo;<b>emacs</b>&rsquo; to &lsquo;<b>main</b>&rsquo; so
that it is selected by default the next time the editor
starts.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Selects keymap &lsquo;<b>viins</b>&rsquo; for any
operations by the current command, and also links
&lsquo;<b>viins</b>&rsquo; to &lsquo;<b>main</b>&rsquo; so
that it is selected by default the next time the editor
starts.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;a</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Selects keymap &lsquo;<b>vicmd</b>&rsquo; for any
operations by the current command.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>&minus;M</b>
<i>keymap</i></p>

<p style="margin-left:32%;">The <i>keymap</i> specifies a
keymap name that is selected for any operations by the
current command.</p>

<p style="margin-left:22%; margin-top: 1em">If a keymap
selection is required and none of the options above are
used, the &lsquo;<b>main</b>&rsquo; keymap is used. Some
operations do not permit a keymap to be selected,
namely:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;l</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>List all existing keymap names; if any arguments are
given, list just those keymaps.</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">If the
<b>&minus;L</b> option is also used, list in the form of
<b>bindkey</b> commands to create or link the keymaps.
&lsquo;<b>bindkey &minus;lL main</b>&rsquo; shows which
keymap is linked to &lsquo;<b>main</b>&rsquo;, if any, and
hence if the standard emacs or vi emulation is in effect.
This option does not show the <b>.safe</b> keymap because it
cannot be created in that fashion; however, neither is
&lsquo;<b>bindkey &minus;lL .safe</b>&rsquo; reported as an
error, it simply outputs nothing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;d</b></p></td>
<td width="7%"></td>
<td width="68%">


<p style="margin-top: 1em">Delete all existing keymaps and
reset to the default state.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>&minus;D</b> <i>keymap</i>
...</p>

<p style="margin-left:32%;">Delete the named
<i>keymap</i>s.</p>

<p style="margin-left:22%;"><b>&minus;A</b>
<i>old&minus;keymap new&minus;keymap</i></p>

<p style="margin-left:32%;">Make the
<i>new&minus;keymap</i> name an alias for
<i>old&minus;keymap</i>, so that both names refer to the
same keymap. The names have equal standing; if either is
deleted, the other remains. If there is already a keymap
with the <i>new&minus;keymap</i> name, it is deleted.</p>

<p style="margin-left:22%;"><b>&minus;N</b>
<i>new&minus;keymap</i> [ <i>old&minus;keymap</i> ]</p>

<p style="margin-left:32%;">Create a new keymap, named
<i>new&minus;keymap</i>. If a keymap already has that name,
it is deleted. If an <i>old&minus;keymap</i> name is given,
the new keymap is initialized to be a duplicate of it,
otherwise the new keymap will be empty.</p>

<p style="margin-left:22%; margin-top: 1em">To use a newly
created keymap, it should be linked to <b>main</b>. Hence
the sequence of commands to create and use a new keymap
&lsquo;<b>mymap</b>&rsquo; initialized from the <b>emacs</b>
keymap (which remains unchanged) is:</p>

<p style="margin-left:32%; margin-top: 1em"><b>bindkey
&minus;N mymap emacs <br>
bindkey &minus;A mymap main</b></p>

<p style="margin-left:22%; margin-top: 1em">Note that while
&lsquo;<b>bindkey &minus;A</b> <i>newmap</i>
<b>main</b>&rsquo; will work when <i>newmap</i> is
<b>emacs</b> or <b>viins</b>, it will not work for
<b>vicmd</b>, as switching from vi insert to command mode
becomes impossible.</p>

<p style="margin-left:22%; margin-top: 1em">The following
operations act on the &lsquo;<b>main</b>&rsquo; keymap if no
keymap selection option was given:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;m</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Add the built&minus;in set of meta&minus;key bindings to
the selected keymap. Only keys that are unbound or bound to
<b>self&minus;insert</b> are affected.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>&minus;r</b>
<i>in&minus;string</i> ...</p>

<p style="margin-left:32%;">Unbind the specified
<i>in&minus;string</i>s in the selected keymap. This is
exactly equivalent to binding the strings to
<b>undefined&minus;key</b>.</p>

<p style="margin-left:32%; margin-top: 1em">When
<b>&minus;R</b> is also used, interpret the
<i>in&minus;string</i>s as ranges.</p>

<p style="margin-left:32%; margin-top: 1em">When
<b>&minus;p</b> is also used, the <i>in&minus;string</i>s
specify prefixes. Any binding that has the given
<i>in&minus;string</i> as a prefix, not including the
binding for the <i>in&minus;string</i> itself, if any, will
be removed. For example,</p>

<p style="margin-left:43%; margin-top: 1em"><b>bindkey
&minus;rpM viins &rsquo;^[&rsquo;</b></p>

<p style="margin-left:32%; margin-top: 1em">will remove all
bindings in the vi&minus;insert keymap beginning with an
escape character (probably cursor keys), but leave the
binding for the escape character itself (probably
<b>vi&minus;cmd&minus;mode</b>). This is incompatible with
the option <b>&minus;R</b>.</p>

<p style="margin-left:22%;"><b>&minus;s</b>
<i>in&minus;string out&minus;string</i> ...</p>

<p style="margin-left:32%;">Bind each
<i>in&minus;string</i> to each <i>out&minus;string</i>. When
<i>in&minus;string</i> is typed, <i>out&minus;string</i>
will be pushed back and treated as input to the line editor.
When <b>&minus;R</b> is also used, interpret the
<i>in&minus;string</i>s as ranges.</p>

<p style="margin-left:22%;"><i>in&minus;string command</i>
...</p>

<p style="margin-left:32%;">Bind each
<i>in&minus;string</i> to each <i>command</i>. When
<b>&minus;R</b> is used, interpret the
<i>in&minus;string</i>s as ranges.</p>

<p style="margin-left:22%;">[ <i>in&minus;string</i> ]</p>

<p style="margin-left:32%;">List key bindings. If an
<i>in&minus;string</i> is specified, the binding of that
string in the selected keymap is displayed. Otherwise, all
key bindings in the selected keymap are displayed. (As a
special case, if the <b>&minus;e</b> or <b>&minus;v</b>
option is used alone, the keymap is <i>not</i> displayed
&minus; the implicit linking of keymaps is the only thing
that happens.)</p>

<p style="margin-left:32%; margin-top: 1em">When the option
<b>&minus;p</b> is used, the <i>in&minus;string</i> must be
present. The listing shows all bindings which have the given
key sequence as a prefix, not including any bindings for the
key sequence itself.</p>

<p style="margin-left:32%; margin-top: 1em">When the
<b>&minus;L</b> option is used, the list is in the form of
<b>bindkey</b> commands to create the key bindings.</p>

<p style="margin-left:11%; margin-top: 1em">When the
<b>&minus;R</b> option is used as noted above, a valid range
consists of two characters, with an optional
&lsquo;<b>&minus;</b>&rsquo; between them. All characters
between the two specified, inclusive, are bound as
specified.</p>

<p style="margin-left:11%; margin-top: 1em">For either
<i>in&minus;string</i> or <i>out&minus;string</i>, the
following escape sequences are recognised:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\a</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>bell character</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\b</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>backspace</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\e</b>, <b>\E</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>escape</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\f</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>form feed</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\n</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>linefeed (newline)</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\r</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>carriage return</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\t</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>horizontal tab</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\v</b></p></td>
<td width="2%"></td>
<td width="44%">


<p>vertical tab</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\</b><i>NNN</i></p></td>
<td width="2%"></td>
<td width="44%">


<p>character code in octal</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\x</b><i>NN</i></p></td>
<td width="2%"></td>
<td width="44%">


<p>character code in hexadecimal</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\M</b>[<b>&minus;</b>]<i>X</i></p></td>
<td width="2%"></td>
<td width="44%">


<p>character with meta bit set</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>\C</b>[<b>&minus;</b>]<i>X</i></p></td>
<td width="2%"></td>
<td width="44%">


<p>control character</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>^</b><i>X</i></p></td>
<td width="2%"></td>
<td width="44%">


<p>control character</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In all other
cases, &lsquo;<b>\</b>&rsquo; escapes the following
character. Delete is written as &lsquo;<b>^?</b>&rsquo;.
Note that &lsquo;<b>\M^?</b>&rsquo; and
&lsquo;<b>^\M?</b>&rsquo; are not the same, and that (unlike
emacs), the bindings &lsquo;<b>\M&minus;</b><i>X</i>&rsquo;
and &lsquo;<b>\e</b><i>X</i>&rsquo; are entirely distinct,
although they are initialized to the same bindings by
&lsquo;<b>bindkey &minus;m</b>&rsquo;. <b><br>
vared</b> [ <b>&minus;Aache</b> ] [ <b>&minus;p</b>
<i>prompt</i> ] [ <b>&minus;r</b> <i>rprompt</i> ] <br>
[ <b>&minus;M</b> <i>main&minus;keymap</i> ] [
<b>&minus;m</b> <i>vicmd&minus;keymap</i> ] <br>
[ <b>&minus;t</b> <i>tty</i> ] <i>name</i></p>

<p style="margin-left:22%;">The value of the parameter
<i>name</i> is loaded into the edit buffer, and the line
editor is invoked. When the editor exits, <i>name</i> is set
to the string value returned by the editor. When the
<b>&minus;c</b> flag is given, the parameter is created if
it doesn&rsquo;t already exist. The <b>&minus;a</b> flag may
be given with <b>&minus;c</b> to create an array parameter,
or the <b>&minus;A</b> flag to create an associative array.
If the type of an existing parameter does not match the type
to be created, the parameter is unset and recreated.</p>

<p style="margin-left:22%; margin-top: 1em">If an array or
array slice is being edited, separator characters as defined
in <b>$IFS</b> will be shown quoted with a backslash, as
will backslashes themselves. Conversely, when the edited
text is split into an array, a backslash quotes an
immediately following separator character or backslash; no
other special handling of backslashes, or any handling of
quotes, is performed.</p>

<p style="margin-left:22%; margin-top: 1em">Individual
elements of existing array or associative array parameters
may be edited by using subscript syntax on <i>name</i>. New
elements are created automatically, even without
<b>&minus;c</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>&minus;p</b> flag is given, the following string will be
taken as the prompt to display at the left. If the
<b>&minus;r</b> flag is given, the following string gives
the prompt to display at the right. If the <b>&minus;h</b>
flag is specified, the history can be accessed from ZLE. If
the <b>&minus;e</b> flag is given, typing <b>^D</b>
(Control&minus;D) on an empty line causes <b>vared</b> to
exit immediately with a non&minus;zero return value.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>&minus;M</b> option gives a keymap to link to the
<b>main</b> keymap during editing, and the <b>&minus;m</b>
option gives a keymap to link to the <b>vicmd</b> keymap
during editing. For vi&minus;style editing, this allows a
pair of keymaps to override <b>viins</b> and <b>vicmd</b>.
For emacs&minus;style editing, only <b>&minus;M</b> is
normally needed but the <b>&minus;m</b> option may still be
used. On exit, the previous keymaps will be restored.</p>

<p style="margin-left:22%; margin-top: 1em">If
&lsquo;<b>&minus;t</b> <i>tty</i>&rsquo; is given,
<i>tty</i> is the name of a terminal device to be used
instead of the default <b>/dev/tty</b>. If <i>tty</i> does
not refer to a terminal an error is reported.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>zle</b></p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>zle &minus;l</b> [
<b>&minus;L</b> | <b>&minus;a</b> ] [ <i>string</i> ... ]
<b><br>
zle &minus;D</b> <i>widget</i> ... <b><br>
zle &minus;A</b> <i>old&minus;widget new&minus;widget</i>
<b><br>
zle &minus;N</b> <i>widget</i> [ <i>function</i> ] <b><br>
zle &minus;C</b> <i>widget completion&minus;widget
function</i> <b><br>
zle &minus;R</b> [ <b>&minus;c</b> ] [
<i>display&minus;string</i> ] [ <i>string</i> ... ] <b><br>
zle &minus;M</b> <i>string</i> <b><br>
zle &minus;U</b> <i>string</i> <b><br>
zle &minus;K</b> <i>keymap</i> <b><br>
zle &minus;F</b> [ <b>&minus;L</b> ] [ <i>fd</i> [
<i>handler</i> ] ]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>zle &minus;I</b></p></td>
<td width="80%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>zle &minus;T</b> [ <b>tc</b>
<i>function</i> | <b>&minus;r tc</b> | <b>&minus;L</b> ]
<b><br>
zle</b> <i>widget</i> <b>[ &minus;n</b> <i>num</i> <b>] [
&minus;Nw ] [ &minus;K</b> <i>keymap</i> <b>]</b>
<i>args</i> ...</p>

<p style="margin-left:22%;">The <b>zle</b> builtin performs
a number of different actions concerning ZLE.</p>

<p style="margin-left:22%; margin-top: 1em">With no options
and no arguments, only the return status will be set. It is
zero if ZLE is currently active and widgets could be invoked
using this builtin command and non&minus;zero otherwise.
Note that even if non&minus;zero status is returned, zle may
still be active as part of the completion system; this does
not allow direct calls to ZLE widgets.</p>

<p style="margin-left:22%; margin-top: 1em">Otherwise,
which operation it performs depends on its options: <b><br>
&minus;l</b> [ <b>&minus;L</b> | <b>&minus;a</b> ]</p>

<p style="margin-left:32%;">List all existing
user&minus;defined widgets. If the <b>&minus;L</b> option is
used, list in the form of <b>zle</b> commands to create the
widgets.</p>

<p style="margin-left:32%; margin-top: 1em">When combined
with the <b>&minus;a</b> option, all widget names are
listed, including the builtin ones. In this case the
<b>&minus;L</b> option is ignored.</p>

<p style="margin-left:32%; margin-top: 1em">If at least one
<i>string</i> is given, and <b>&minus;a</b> is present or
<b>&minus;L</b> is not used, nothing will be printed. The
return status will be zero if all <i>string</i>s are names
of existing widgets and non&minus;zero if at least one
<i>string</i> is not a name of a defined widget. If
<b>&minus;a</b> is also present, all widget names are used
for the comparison including builtin widgets, else only
user&minus;defined widgets are used.</p>

<p style="margin-left:32%; margin-top: 1em">If at least one
<i>string</i> is present and the <b>&minus;L</b> option is
used, user&minus;defined widgets matching any <i>string</i>
are listed in the form of <b>zle</b> commands to create the
widgets.</p>

<p style="margin-left:22%;"><b>&minus;D</b> <i>widget</i>
...</p>

<p style="margin-left:32%;">Delete the named
<i>widget</i>s.</p>

<p style="margin-left:22%;"><b>&minus;A</b>
<i>old&minus;widget new&minus;widget</i></p>

<p style="margin-left:32%;">Make the
<i>new&minus;widget</i> name an alias for
<i>old&minus;widget</i>, so that both names refer to the
same widget. The names have equal standing; if either is
deleted, the other remains. If there is already a widget
with the <i>new&minus;widget</i> name, it is deleted.</p>

<p style="margin-left:22%;"><b>&minus;N</b> <i>widget</i> [
<i>function</i> ]</p>

<p style="margin-left:32%;">Create a user&minus;defined
widget. If there is already a widget with the specified
name, it is overwritten. When the new widget is invoked from
within the editor, the specified shell <i>function</i> is
called. If no function name is specified, it defaults to the
same name as the widget. For further information, see the
section <i>Widgets</i> in <i>zshzle</i>(1).</p>

<p style="margin-left:22%;"><b>&minus;C</b> <i>widget
completion&minus;widget function</i></p>

<p style="margin-left:32%;">Create a user&minus;defined
completion widget named <i>widget</i>. The completion widget
will behave like the built&minus;in completion&minus;widget
whose name is given as <i>completion&minus;widget</i>. To
generate the completions, the shell function <i>function</i>
will be called. For further information, see
<i>zshcompwid</i>(1).</p>

<p style="margin-left:22%;"><b>&minus;R</b> [
<b>&minus;c</b> ] [ <i>display&minus;string</i> ] [
<i>string</i> ... ]</p>

<p style="margin-left:32%;">Redisplay the command line;
this is to be called from within a user&minus;defined widget
to allow changes to become visible. If a
<i>display&minus;string</i> is given and not empty, this is
shown in the status line (immediately below the line being
edited).</p>

<p style="margin-left:32%; margin-top: 1em">If the optional
<i>string</i>s are given they are listed below the prompt in
the same way as completion lists are printed. If no
<i>string</i>s are given but the <b>&minus;c</b> option is
used such a list is cleared.</p>

<p style="margin-left:32%; margin-top: 1em">Note that this
option is only useful for widgets that do not exit
immediately after using it because the strings displayed
will be erased immediately after return from the widget.</p>

<p style="margin-left:32%; margin-top: 1em">This command
can safely be called outside user defined widgets; if zle is
active, the display will be refreshed, while if zle is not
active, the command has no effect. In this case there will
usually be no other arguments.</p>

<p style="margin-left:32%; margin-top: 1em">The status is
zero if zle was active, else one.</p>

<p style="margin-left:22%;"><b>&minus;M</b>
<i>string</i></p>

<p style="margin-left:32%;">As with the <b>&minus;R</b>
option, the <i>string</i> will be displayed below the
command line; unlike the <b>&minus;R</b> option, the string
will not be put into the status line but will instead be
printed normally below the prompt. This means that the
<i>string</i> will still be displayed after the widget
returns (until it is overwritten by subsequent
commands).</p>

<p style="margin-left:22%;"><b>&minus;U</b>
<i>string</i></p>

<p style="margin-left:32%;">This pushes the characters in
the <i>string</i> onto the input stack of ZLE. After the
widget currently executed finishes ZLE will behave as if the
characters in the <i>string</i> were typed by the user.</p>

<p style="margin-left:32%; margin-top: 1em">As ZLE uses a
stack, if this option is used repeatedly the last string
pushed onto the stack will be processed first. However, the
characters in each <i>string</i> will be processed in the
order in which they appear in the string.</p>

<p style="margin-left:22%;"><b>&minus;K</b>
<i>keymap</i></p>

<p style="margin-left:32%;">Selects the keymap named
<i>keymap</i>. An error message will be displayed if there
is no such keymap.</p>

<p style="margin-left:32%; margin-top: 1em">This keymap
selection affects the interpretation of following keystrokes
within this invocation of ZLE. Any following invocation
(e.g., the next command line) will start as usual with the
&lsquo;<b>main</b>&rsquo; keymap selected.</p>

<p style="margin-left:22%;"><b>&minus;F</b> [
<b>&minus;L</b> ] [ <i>fd</i> [ <i>handler</i> ] ]</p>

<p style="margin-left:32%;">Only available if your system
supports one of the &lsquo;poll&rsquo; or
&lsquo;select&rsquo; system calls; most modern systems
do.</p>

<p style="margin-left:32%; margin-top: 1em">Installs
<i>handler</i> (the name of a shell function) to handle
input from file descriptor <i>fd</i>. When zle is attempting
to read data, it will examine both the terminal and the list
of handled <i>fd</i>&rsquo;s. If data becomes available on a
handled <i>fd</i>, zle will call <i>handler</i> with the fd
which is ready for reading as the only argument. If the
handler produces output to the terminal, it should call
&lsquo;<b>zle &minus;I</b>&rsquo; before doing so (see
below). The handler should not attempt to read from the
terminal. Note that zle makes no attempt to check whether
this fd is actually readable when installing the handler.
The user must make their own arrangements for handling the
file descriptor when zle is not active.</p>

<p style="margin-left:32%; margin-top: 1em">Any number of
handlers for any number of readable file descriptors may be
installed. Installing a handler for an <i>fd</i> which is
already handled causes the existing handler to be
replaced.</p>

<p style="margin-left:32%; margin-top: 1em">If no
<i>handler</i> is given, but an <i>fd</i> is present, any
handler for that <i>fd</i> is removed. If there is none, an
error message is printed and status 1 is returned.</p>

<p style="margin-left:32%; margin-top: 1em">If no arguments
are given, or the <b>&minus;L</b> option is supplied, a list
of handlers is printed in a form which can be stored for
later execution.</p>

<p style="margin-left:32%; margin-top: 1em">An <i>fd</i>
(but not a <i>handler</i>) may optionally be given with the
<b>&minus;L</b> option; in this case, the function will list
the handler if any, else silently return status 1.</p>

<p style="margin-left:32%; margin-top: 1em">Note that this
feature should be used with care. Activity on one of the
<i>fd</i>&rsquo;s which is not properly handled can cause
the terminal to become unusable.</p>

<p style="margin-left:32%; margin-top: 1em">Here is a
simple example of using this feature. A connection to a
remote TCP port is created using the ztcp command; see the
description of the <b>zsh/net/tcp</b> module in
<i>zshmodules</i>(1). Then a handler is installed which
simply prints out any data which arrives on this connection.
Note that &lsquo;select&rsquo; will indicate that the file
descriptor needs handling if the remote side has closed the
connection; we handle that by testing for a failed read.</p>

<p style="margin-left:43%;"><b>if ztcp pwspc 2811; then
<br>
tcpfd=$REPLY <br>
handler() { <br>
zle &minus;I <br>
local line <br>
if ! read &minus;r line &lt;&amp;$1; then <br>
# select marks this fd if we reach EOF, <br>
# so handle this specially. <br>
print &quot;[Read on fd $1 failed, removing.]&quot;
&gt;&amp;2 <br>
zle &minus;F $1 <br>
return 1 <br>
fi <br>
print &minus;r &minus; $line <br>
} <br>
zle &minus;F $tcpfd handler <br>
fi</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>&minus;I</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>Unusually, this option is most useful outside ordinary
widget functions, though it may be used within if normal
output to the terminal is required. It invalidates the
current zle display in preparation for output; typically
this will be from a trap function. It has no effect if zle
is not active. When a trap exits, the shell checks to see if
the display needs restoring, hence the following will print
output in such a way as not to disturb the line being
edited:</p> </td></tr>
</table>

<p style="margin-left:43%; margin-top: 1em"><b>TRAPUSR1() {
<br>
# Invalidate zle display <br>
[[ &minus;o zle ]] &amp;&amp; zle &minus;I <br>
# Show output <br>
print Hello <br>
}</b></p>

<p style="margin-left:32%; margin-top: 1em">In general, the
trap function may need to test whether zle is active before
using this method (as shown in the example), since the
<b>zsh/zle</b> module may not even be loaded; if it is not,
the command can be skipped.</p>

<p style="margin-left:32%; margin-top: 1em">It is possible
to call &lsquo;<b>zle &minus;I</b>&rsquo; several times
before control is returned to the editor; the display will
only be invalidated the first time to minimise
disruption.</p>

<p style="margin-left:32%; margin-top: 1em">Note that there
are normally better ways of manipulating the display from
within zle widgets; see, for example, &lsquo;<b>zle
&minus;R</b>&rsquo; above.</p>

<p style="margin-left:32%; margin-top: 1em">The returned
status is zero if zle was invalidated, even though this may
have been by a previous call to &lsquo;<b>zle
&minus;I</b>&rsquo; or by a system notification. To test if
a zle widget may be called at this point, execute <b>zle</b>
with no arguments and examine the return status.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;T</b></p></td>
<td width="7%"></td>
<td width="68%">


<p style="margin-top: 1em">This is used to add, list or
remove internal transformations on the processing performed
by the line editor. It is typically used only for debugging
or testing and is therefore of little interest to the
general user.</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">&lsquo;<b>zle
&minus;T</b> <i>transformation func</i>&rsquo; specifies
that the given <i>transformation</i> (see below) is effected
by shell function <i>func</i>.</p>

<p style="margin-left:32%; margin-top: 1em">&lsquo;<b>zle
&minus;Tr</b> <i>transformation</i>&rsquo; removes the given
<i>transformation</i> if it was present (it is not an error
if none was).</p>

<p style="margin-left:32%; margin-top: 1em">&lsquo;<b>zle
&minus;TL</b>&rsquo; can be used to list all transformations
currently in operation.</p>

<p style="margin-left:32%; margin-top: 1em">Currently the
only transformation is <b>tc</b>. This is used instead of
outputting termcap codes to the terminal. When the
transformation is in operation the shell function is passed
the termcap code that would be output as its first argument;
if the operation required a numeric argument, that is passed
as a second argument. The function should set the shell
variable <b>REPLY</b> to the transformed termcap code.
Typically this is used to produce some simply formatted
version of the code and optional argument for debugging or
testing. Note that this transformation is not applied to
other non&minus;printing characters such as carriage returns
and newlines.</p>

<p style="margin-left:22%;"><i>widget</i> <b>[ &minus;n</b>
<i>num</i> <b>] [ &minus;Nw ] [ &minus;K</b> <i>keymap</i>
<b>]</b> <i>args</i> ...</p>

<p style="margin-left:32%;">Invoke the specified widget.
This can only be done when ZLE is active; normally this will
be within a user&minus;defined widget.</p>

<p style="margin-left:32%; margin-top: 1em">With the
options <b>&minus;n</b> and <b>&minus;N</b>, the current
numerical argument will be saved and then restored after the
call to <b>widget</b>; &lsquo;<b>&minus;n</b>
<i>num</i>&rsquo; sets the numerical argument temporarily to
<i>num</i>, while &lsquo;<b>&minus;N</b>&rsquo; sets it to
the default, i.e. as if there were none.</p>

<p style="margin-left:32%; margin-top: 1em">With the option
<b>&minus;K</b>, <i>keymap</i> will be used as the current
keymap during the execution of the widget. The previous
keymap will be restored when the widget exits.</p>

<p style="margin-left:32%; margin-top: 1em">Normally,
calling a widget in this way does not set the special
parameter <b>WIDGET</b> and related parameters, so that the
environment appears as if the top&minus;level widget called
by the user were still active. With the option
<b>&minus;w</b>, <b>WIDGET</b> and related parameters are
set to reflect the widget being executed by the <b>zle</b>
call.</p>

<p style="margin-left:32%; margin-top: 1em">Any further
arguments will be passed to the widget; note that as
standard argument handling is performed, any general
argument list should be preceded by <b>&minus;&minus;</b>.
If it is a shell function, these are passed down as
positional parameters; for builtin widgets it is up to the
widget in question what it does with them. Currently
arguments are only handled by the incremental&minus;search
commands, the <b>history&minus;search&minus;forward</b> and
<b>&minus;backward</b> and the corresponding functions
prefixed by <b>vi&minus;</b>, and by
<b>universal&minus;argument</b>. No error is flagged if the
command does not use the arguments, or only uses some of
them.</p>

<p style="margin-left:32%; margin-top: 1em">The return
status reflects the success or failure of the operation
carried out by the widget, or if it is a user&minus;defined
widget the return status of the shell function.</p>

<p style="margin-left:32%; margin-top: 1em">A
non&minus;zero return status causes the shell to beep when
the widget exits, unless the <b>BEEP</b> options was unset
or the widget was called via the <b>zle</b> command. Thus if
a user defined widget requires an immediate beep, it should
call the <b>beep</b> widget directly.</p>

<h2>WIDGETS
<a name="WIDGETS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All actions in
the editor are performed by &lsquo;widgets&rsquo;. A
widget&rsquo;s job is simply to perform some small action.
The ZLE commands that key sequences in keymaps are bound to
are in fact widgets. Widgets can be user&minus;defined or
built in.</p>

<p style="margin-left:11%; margin-top: 1em">The standard
widgets built into ZLE are listed in Standard Widgets below.
Other built&minus;in widgets can be defined by other modules
(see <i>zshmodules</i>(1)). Each built&minus;in widget has
two names: its normal canonical name, and the same name
preceded by a &lsquo;<b>.</b>&rsquo;. The
&lsquo;<b>.</b>&rsquo; name is special: it can&rsquo;t be
rebound to a different widget. This makes the widget
available even when its usual name has been redefined.</p>


<p style="margin-left:11%; margin-top: 1em">User&minus;defined
widgets are defined using &lsquo;<b>zle &minus;N</b>&rsquo;,
and implemented as shell functions. When the widget is
executed, the corresponding shell function is executed, and
can perform editing (or other) actions. It is recommended
that user&minus;defined widgets should not have names
starting with &lsquo;<b>.</b>&rsquo;.</p>

<h2>USER&minus;DEFINED WIDGETS
<a name="USER&minus;DEFINED WIDGETS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">User&minus;defined
widgets, being implemented as shell functions, can execute
any normal shell command. They can also run other widgets
(whether built&minus;in or user&minus;defined) using the
<b>zle</b> builtin command. The standard input of the
function is closed to prevent external commands from
unintentionally blocking ZLE by reading from the terminal,
but <b>read &minus;k</b> or <b>read &minus;q</b> can be used
to read characters. Finally, they can examine and edit the
ZLE buffer being edited by reading and setting the special
parameters described below.</p>

<p style="margin-left:11%; margin-top: 1em">These special
parameters are always available in widget functions, but are
not in any way special outside ZLE. If they have some normal
value outside ZLE, that value is temporarily inaccessible,
but will return when the widget function exits. These
special parameters in fact have local scope, like parameters
created in a function using <b>local</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inside
completion widgets and traps called while ZLE is active,
these parameters are available read&minus;only. <b><br>
BUFFER</b> (scalar)</p>

<p style="margin-left:22%;">The entire contents of the edit
buffer. If it is written to, the cursor remains at the same
offset, unless that would put it outside the buffer.</p>

<p style="margin-left:11%;"><b>BUFFERLINES</b>
(integer)</p>

<p style="margin-left:22%;">The number of screen lines
needed for the edit buffer currently displayed on screen
(i.e. without any changes to the preceding parameters done
after the last redisplay); read&minus;only.</p>

<p style="margin-left:11%;"><b>CONTEXT</b> (scalar)</p>

<p style="margin-left:22%;">The context in which zle was
called to read a line; read&minus;only. One of the
values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>start</p></td>
<td width="2%"></td>
<td width="75%">


<p>The start of a command line (at prompt <b>PS1</b>).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>cont</p></td>
<td width="2%"></td>
<td width="75%">


<p>A continuation to a command line (at prompt
<b>PS2</b>).</p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>select</p></td>
<td width="2%"></td>
<td width="75%">


<p>In a <b>select</b> loop.</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>vared</p></td>
<td width="2%"></td>
<td width="75%">


<p>Editing a variable in <b>vared</b>.</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>CURSOR</b> (integer)</p>

<p style="margin-left:22%;">The offset of the cursor,
within the edit buffer. This is in the range 0 to
<b>$#BUFFER</b>, and is by definition equal to
<b>$#LBUFFER</b>. Attempts to move the cursor outside the
buffer will result in the cursor being moved to the
appropriate end of the buffer.</p>

<p style="margin-left:11%;"><b>CUTBUFFER</b> (scalar)</p>

<p style="margin-left:22%;">The last item cut using one of
the &lsquo;<b>kill&minus;</b>&rsquo; commands; the string
which the next yank would insert in the line. Later entries
in the kill ring are in the array <b>killring</b>. Note that
the command &lsquo;<b>zle
copy&minus;region&minus;as&minus;kill</b>
<i>string</i>&rsquo; can be used to set the text of the cut
buffer from a shell function and cycle the kill ring in the
same way as interactively killing text.</p>

<p style="margin-left:11%;"><b>HISTNO</b> (integer)</p>

<p style="margin-left:22%;">The current history number.
Setting this has the same effect as moving up or down in the
history to the corresponding history line. An attempt to set
it is ignored if the line is not stored in the history. Note
this is not the same as the parameter <b>HISTCMD</b>, which
always gives the number of the history line being added to
the main shell&rsquo;s history. <b>HISTNO</b> refers to the
line being retrieved within zle.</p>

<p style="margin-left:11%;"><b>KEYMAP</b> (scalar)</p>

<p style="margin-left:22%;">The name of the currently
selected keymap; read&minus;only.</p>

<p style="margin-left:11%;"><b>KEYS</b> (scalar)</p>

<p style="margin-left:22%;">The keys typed to invoke this
widget, as a literal string; read&minus;only.</p>

<p style="margin-left:11%;"><b>killring</b> (array)</p>

<p style="margin-left:22%;">The array of previously killed
items, with the most recently killed first. This gives the
items that would be retrieved by a <b>yank&minus;pop</b> in
the same order. Note, however, that the most recently killed
item is in <b>$CUTBUFFER</b>; <b>$killring</b> shows the
array of previous entries.</p>

<p style="margin-left:22%; margin-top: 1em">The default
size for the kill ring is eight, however the length may be
changed by normal array operations. Any empty string in the
kill ring is ignored by the <b>yank&minus;pop</b> command,
hence the size of the array effectively sets the maximum
length of the kill ring, while the number of non&minus;zero
strings gives the current length, both as seen by the user
at the command line.</p>

<p style="margin-left:11%;"><b>LASTABORTEDSEARCH</b>
(scalar)</p>

<p style="margin-left:22%;">The last search string used by
an interactive search that was aborted by the user (status 3
returned by the search widget).</p>

<p style="margin-left:11%;"><b>LASTSEARCH</b> (scalar)</p>

<p style="margin-left:22%;">The last search string used by
an interactive search; read&minus;only. This is set even if
the search failed (status 0, 1 or 2 returned by the search
widget), but not if it was aborted by the user.</p>

<p style="margin-left:11%;"><b>LASTWIDGET</b> (scalar)</p>

<p style="margin-left:22%;">The name of the last widget
that was executed; read&minus;only.</p>

<p style="margin-left:11%;"><b>LBUFFER</b> (scalar)</p>

<p style="margin-left:22%;">The part of the buffer that
lies to the left of the cursor position. If it is assigned
to, only that part of the buffer is replaced, and the cursor
remains between the new <b>$LBUFFER</b> and the old
<b>$RBUFFER</b>.</p>

<p style="margin-left:11%;"><b>MARK</b> (integer)</p>

<p style="margin-left:22%;">Like <b>CURSOR</b>, but for the
mark.</p>

<p style="margin-left:11%;"><b>NUMERIC</b> (integer)</p>

<p style="margin-left:22%;">The numeric argument. If no
numeric argument was given, this parameter is unset. When
this is set inside a widget function, builtin widgets called
with the <b>zle</b> builtin command will use the value
assigned. If it is unset inside a widget function, builtin
widgets called behave as if no numeric argument was
given.</p>

<p style="margin-left:11%;"><b>PENDING</b> (integer)</p>

<p style="margin-left:22%;">The number of bytes pending for
input, i.e. the number of bytes which have already been
typed and can immediately be read. On systems where the
shell is not able to get this information, this parameter
will always have a value of zero. Read&minus;only.</p>

<p style="margin-left:11%;"><b>PREBUFFER</b> (scalar)</p>

<p style="margin-left:22%;">In a multi&minus;line input at
the secondary prompt, this read&minus;only parameter
contains the contents of the lines before the one the cursor
is currently in.</p>

<p style="margin-left:11%;"><b>PREDISPLAY</b> (scalar)</p>

<p style="margin-left:22%;">Text to be displayed before the
start of the editable text buffer. This does not have to be
a complete line; to display a complete line, a newline must
be appended explicitly. The text is reset on each new
invocation (but not recursive invocation) of zle.</p>

<p style="margin-left:11%;"><b>POSTDISPLAY</b> (scalar)</p>

<p style="margin-left:22%;">Text to be displayed after the
end of the editable text buffer. This does not have to be a
complete line; to display a complete line, a newline must be
prepended explicitly. The text is reset on each new
invocation (but not recursive invocation) of zle.</p>

<p style="margin-left:11%;"><b>RBUFFER</b> (scalar)</p>

<p style="margin-left:22%;">The part of the buffer that
lies to the right of the cursor position. If it is assigned
to, only that part of the buffer is replaced, and the cursor
remains between the old <b>$LBUFFER</b> and the new
<b>$RBUFFER</b>.</p>

<p style="margin-left:11%;"><b>REGION_ACTIVE</b>
(integer)</p>

<p style="margin-left:22%;">Indicates if the region is
currently active. It can be assigned 0 or 1 to deactivate
and activate the region respectively; see <i>Character
Highlighting</i> below.</p>

<p style="margin-left:11%;"><b>region_highlight</b>
(array)</p>

<p style="margin-left:22%;">Each element of this array may
be set to a string that describes highlighting for an
arbitrary region of the command line that will take effect
the next time the command line is redisplayed. Highlighting
of the non&minus;editable parts of the command line in
<b>PREDISPLAY</b> and <b>POSTDISPLAY</b> are possible, but
note that the <b>P</b> flag is needed for character indexing
to include <b>PREDISPLAY</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Each string
consists of the following parts: <br>
Optionally, a &lsquo;<b>P</b>&rsquo; to signify that the
start and end offset that</p>

<p style="margin-left:32%;">follow include any string set
by the <b>PREDISPLAY</b> special parameter; this is needed
if the predisplay string itself is to be highlighted.
Whitespace may follow the &lsquo;<b>P</b>&rsquo;.</p>

<p style="margin-left:22%;">A start offset in the same
units as <b>CURSOR</b>, terminated by</p>

<p style="margin-left:32%;">whitespace.</p>

<p style="margin-left:22%;">An end offset in the same units
as <b>CURSOR</b>, terminated by</p>

<p style="margin-left:32%;">whitespace.</p>

<p style="margin-left:22%;">A highlight specification in
the same format as</p>

<p style="margin-left:32%;">used for contexts in the
parameter <b>zle_highlight</b>, see Character Highlighting
below; for example, <b>standout</b> or
<b>fg=red,bold</b>.</p>

<p style="margin-left:22%; margin-top: 1em">For
example,</p>


<p style="margin-left:32%; margin-top: 1em"><b>region_highlight=(&quot;P0
20 bold&quot;)</b></p>

<p style="margin-left:22%; margin-top: 1em">specifies that
the first twenty characters of the text including any
predisplay string should be highlighted in bold.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
effect of <b>region_highlight</b> is not saved and
disappears as soon as the line is accepted.</p>

<p style="margin-left:11%;"><b>UNDO_CHANGE_NO</b>
(integer)</p>

<p style="margin-left:22%;">A number representing the state
of the undo history. The only use of this is passing as an
argument to the <b>undo</b> widget in order to undo back to
the recorded point. Read&minus;only.</p>

<p style="margin-left:11%;"><b>WIDGET</b> (scalar)</p>

<p style="margin-left:22%;">The name of the widget
currently being executed; read&minus;only.</p>

<p style="margin-left:11%;"><b>WIDGETFUNC</b> (scalar)</p>

<p style="margin-left:22%;">The name of the shell function
that implements a widget defined with either <b>zle
&minus;N</b> or <b>zle &minus;C</b>. In the former case,
this is the second argument to the <b>zle &minus;N</b>
command that defined the widget, or the first argument if
there was no second argument. In the latter case this is the
third argument to the <b>zle &minus;C</b> command that
defined the widget. Read&minus;only.</p>

<p style="margin-left:11%;"><b>WIDGETSTYLE</b> (scalar)</p>

<p style="margin-left:22%;">Describes the implementation
behind the completion widget currently being executed; the
second argument that followed <b>zle &minus;C</b> when the
widget was defined. This is the name of a builtin completion
widget. For widgets defined with <b>zle &minus;N</b> this is
set to the empty string. Read&minus;only.</p>

<p style="margin-left:11%;"><b>ZLE_STATE</b> (scalar)</p>

<p style="margin-left:22%;">Contains a set of
space&minus;separated words that describe the current
<b>zle</b> state.</p>

<p style="margin-left:22%; margin-top: 1em">Currently, the
states shown are the insert mode as set by the
<b>overwrite&minus;mode</b> or <b>vi&minus;replace</b>
widgets and whether history commands will visit imported
entries as controlled by the set&minus;local&minus;history
widget. The string contains &lsquo;<b>insert</b>&rsquo; if
characters to be inserted on the command line move existing
characters to the right or &lsquo;<b>overwrite</b>&rsquo; if
characters to be inserted overwrite existing characters. It
contains &lsquo;<b>localhistory</b>&rsquo; if only local
history commands will be visited or
&lsquo;<b>globalhistory</b>&rsquo; if imported history
commands will also be visited.</p>

<p style="margin-left:22%; margin-top: 1em">The substrings
are sorted in alphabetical order so that if you want to test
for two specific substrings in a future&minus;proof way, you
can do match by doing:</p>

<p style="margin-left:32%; margin-top: 1em"><b>if [[
$ZLE_STATE == *insert*globalhistory* ]]; then ...;
fi</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Special
Widgets</b> <br>
There are a few user&minus;defined widgets which are special
to the shell. If they do not exist, no special action is
taken. The environment provided is identical to that for any
other editing widget. <b><br>
zle&minus;isearch&minus;exit</b></p>

<p style="margin-left:22%;">Executed at the end of
incremental search at the point where the isearch prompt is
removed from the display. See
<b>zle&minus;isearch&minus;update</b> for an example.</p>


<p style="margin-left:11%;"><b>zle&minus;isearch&minus;update</b></p>

<p style="margin-left:22%;">Executed within incremental
search when the display is about to be redrawn. Additional
output below the incremental search prompt can be generated
by using &lsquo;<b>zle &minus;M</b>&rsquo; within the
widget. For example,</p>


<p style="margin-left:32%; margin-top: 1em"><b>zle&minus;isearch&minus;update()
{ zle &minus;M &quot;Line $HISTNO&quot;; } <br>
zle &minus;N zle&minus;isearch&minus;update</b></p>

<p style="margin-left:22%; margin-top: 1em">Note the line
output by &lsquo;<b>zle &minus;M</b>&rsquo; is not deleted
on exit from incremental search. This can be done from a
<b>zle&minus;isearch&minus;exit</b> widget:</p>


<p style="margin-left:32%; margin-top: 1em"><b>zle&minus;isearch&minus;exit()
{ zle &minus;M &quot;&quot;; } <br>
zle &minus;N zle&minus;isearch&minus;exit</b></p>


<p style="margin-left:11%;"><b>zle&minus;line&minus;init</b></p>

<p style="margin-left:22%;">Executed every time the line
editor is started to read a new line of input. The following
example puts the line editor into vi command mode when it
starts up.</p>


<p style="margin-left:32%; margin-top: 1em"><b>zle&minus;line&minus;init()
{ zle &minus;K vicmd; } <br>
zle &minus;N zle&minus;line&minus;init</b></p>

<p style="margin-left:22%; margin-top: 1em">(The command
inside the function sets the keymap directly; it is
equivalent to <b>zle vi&minus;cmd&minus;mode</b>.)</p>


<p style="margin-left:11%;"><b>zle&minus;line&minus;finish</b></p>

<p style="margin-left:22%;">This is similar to
<b>zle&minus;line&minus;init</b> but is executed every time
the line editor has finished reading a line of input.</p>


<p style="margin-left:11%;"><b>zle&minus;history&minus;line&minus;set</b></p>

<p style="margin-left:22%;">Executed when the history line
changes.</p>


<p style="margin-left:11%;"><b>zle&minus;keymap&minus;select</b></p>

<p style="margin-left:22%;">Executed every time the keymap
changes, i.e. the special parameter <b>KEYMAP</b> is set to
a different value, while the line editor is active.
Initialising the keymap when the line editor starts does not
cause the widget to be called.</p>

<p style="margin-left:22%; margin-top: 1em">The value
<b>$KEYMAP</b> within the function reflects the new keymap.
The old keymap is passed as the sole argument.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
used for detecting switches between the vi command
(<b>vicmd</b>) and insert (usually <b>main</b>) keymaps.</p>

<h2>STANDARD WIDGETS
<a name="STANDARD WIDGETS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
is a list of all the standard widgets, and their default
bindings in emacs mode, vi command mode and vi insert mode
(the &lsquo;<b>emacs</b>&rsquo;, &lsquo;<b>vicmd</b>&rsquo;
and &lsquo;<b>viins</b>&rsquo; keymaps, respectively).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
cursor keys are bound to movement keys in all three keymaps;
the shell assumes that the cursor keys send the key
sequences reported by the terminal&minus;handling library
(termcap or terminfo). The key sequences shown in the list
are those based on the VT100, common on many modern
terminals, but in fact these are not necessarily bound. In
the case of the <b>viins</b> keymap, the initial escape
character of the sequences serves also to return to the
<b>vicmd</b> keymap: whether this happens is determined by
the <b>KEYTIMEOUT</b> parameter, see <i>zshparam</i>(1).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Movement
<br>
vi&minus;backward&minus;blank&minus;word</b> (unbound) (B)
(unbound)</p>

<p style="margin-left:22%;">Move backward one word, where a
word is defined as a series of non&minus;blank
characters.</p>

<p style="margin-left:11%;"><b>backward&minus;char</b> (^B
ESC&minus;[D) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move backward one
character.</p>


<p style="margin-left:11%;"><b>vi&minus;backward&minus;char</b>
(unbound) (^H h ^?) (ESC&minus;[D)</p>

<p style="margin-left:22%;">Move backward one character,
without changing lines.</p>

<p style="margin-left:11%;"><b>backward&minus;word</b>
(ESC&minus;B ESC&minus;b) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the beginning of the
previous word.</p>


<p style="margin-left:11%;"><b>emacs&minus;backward&minus;word</b></p>

<p style="margin-left:22%;">Move to the beginning of the
previous word.</p>


<p style="margin-left:11%;"><b>vi&minus;backward&minus;word</b>
(unbound) (b) (unbound)</p>

<p style="margin-left:22%;">Move to the beginning of the
previous word, vi&minus;style.</p>


<p style="margin-left:11%;"><b>beginning&minus;of&minus;line</b>
(^A) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the beginning of the
line. If already at the beginning of the line, move to the
beginning of the previous line, if any.</p>


<p style="margin-left:11%;"><b>vi&minus;beginning&minus;of&minus;line</b></p>

<p style="margin-left:22%;">Move to the beginning of the
line, without changing lines.</p>

<p style="margin-left:11%;"><b>end&minus;of&minus;line</b>
(^E) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the line. If
already at the end of the line, move to the end of the next
line, if any.</p>


<p style="margin-left:11%;"><b>vi&minus;end&minus;of&minus;line</b>
(unbound) ($) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the line. If
an argument is given to this command, the cursor will be
moved to the end of the line (argument &minus; 1) lines
down.</p>


<p style="margin-left:11%;"><b>vi&minus;forward&minus;blank&minus;word</b>
(unbound) (W) (unbound)</p>

<p style="margin-left:22%;">Move forward one word, where a
word is defined as a series of non&minus;blank
characters.</p>


<p style="margin-left:11%;"><b>vi&minus;forward&minus;blank&minus;word&minus;end</b>
(unbound) (E) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the current
word, or, if at the end of the current word, to the end of
the next word, where a word is defined as a series of
non&minus;blank characters.</p>

<p style="margin-left:11%;"><b>forward&minus;char</b> (^F
ESC&minus;[C) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move forward one character.</p>


<p style="margin-left:11%;"><b>vi&minus;forward&minus;char</b>
(unbound) (space l) (ESC&minus;[C)</p>

<p style="margin-left:22%;">Move forward one character.</p>


<p style="margin-left:11%;"><b>vi&minus;find&minus;next&minus;char</b>
(^X^F) (f) (unbound)</p>

<p style="margin-left:22%;">Read a character from the
keyboard, and move to the next occurrence of it in the
line.</p>


<p style="margin-left:11%;"><b>vi&minus;find&minus;next&minus;char&minus;skip</b>
(unbound) (t) (unbound)</p>

<p style="margin-left:22%;">Read a character from the
keyboard, and move to the position just before the next
occurrence of it in the line.</p>


<p style="margin-left:11%;"><b>vi&minus;find&minus;prev&minus;char</b>
(unbound) (F) (unbound)</p>

<p style="margin-left:22%;">Read a character from the
keyboard, and move to the previous occurrence of it in the
line.</p>


<p style="margin-left:11%;"><b>vi&minus;find&minus;prev&minus;char&minus;skip</b>
(unbound) (T) (unbound)</p>

<p style="margin-left:22%;">Read a character from the
keyboard, and move to the position just after the previous
occurrence of it in the line.</p>


<p style="margin-left:11%;"><b>vi&minus;first&minus;non&minus;blank</b>
(unbound) (^) (unbound)</p>

<p style="margin-left:22%;">Move to the first
non&minus;blank character in the line.</p>


<p style="margin-left:11%;"><b>vi&minus;forward&minus;word</b>
(unbound) (w) (unbound)</p>

<p style="margin-left:22%;">Move forward one word,
vi&minus;style.</p>

<p style="margin-left:11%;"><b>forward&minus;word</b>
(ESC&minus;F ESC&minus;f) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the beginning of the
next word. The editor&rsquo;s idea of a word is specified
with the <b>WORDCHARS</b> parameter.</p>


<p style="margin-left:11%;"><b>emacs&minus;forward&minus;word</b></p>

<p style="margin-left:22%;">Move to the end of the next
word.</p>


<p style="margin-left:11%;"><b>vi&minus;forward&minus;word&minus;end</b>
(unbound) (e) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the next
word.</p>


<p style="margin-left:11%;"><b>vi&minus;goto&minus;column</b>
(ESC&minus;|) (|) (unbound)</p>

<p style="margin-left:22%;">Move to the column specified by
the numeric argument.</p>


<p style="margin-left:11%;"><b>vi&minus;goto&minus;mark</b>
(unbound) (&lsquo;) (unbound)</p>

<p style="margin-left:22%;">Move to the specified mark.</p>


<p style="margin-left:11%;"><b>vi&minus;goto&minus;mark&minus;line</b>
(unbound) (&rsquo;) (unbound)</p>

<p style="margin-left:22%;">Move to beginning of the line
containing the specified mark.</p>


<p style="margin-left:11%;"><b>vi&minus;repeat&minus;find</b>
(unbound) (;) (unbound)</p>

<p style="margin-left:22%;">Repeat the last
<b>vi&minus;find</b> command.</p>


<p style="margin-left:11%;"><b>vi&minus;rev&minus;repeat&minus;find</b>
(unbound) (,) (unbound)</p>

<p style="margin-left:22%;">Repeat the last
<b>vi&minus;find</b> command in the opposite direction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>History
Control <br>
beginning&minus;of&minus;buffer&minus;or&minus;history</b>
(ESC&minus;&lt;) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the beginning of the
buffer, or if already there, move to the first event in the
history list.</p>


<p style="margin-left:11%;"><b>beginning&minus;of&minus;line&minus;hist</b></p>

<p style="margin-left:22%;">Move to the beginning of the
line. If already at the beginning of the buffer, move to the
previous history line.</p>


<p style="margin-left:11%;"><b>beginning&minus;of&minus;history</b></p>

<p style="margin-left:22%;">Move to the first event in the
history list.</p>


<p style="margin-left:11%;"><b>down&minus;line&minus;or&minus;history</b>
(^N ESC&minus;[B) (j) (ESC&minus;[B)</p>

<p style="margin-left:22%;">Move down a line in the buffer,
or if already at the bottom line, move to the next event in
the history list.</p>


<p style="margin-left:11%;"><b>vi&minus;down&minus;line&minus;or&minus;history</b>
(unbound) (+) (unbound)</p>

<p style="margin-left:22%;">Move down a line in the buffer,
or if already at the bottom line, move to the next event in
the history list. Then move to the first non&minus;blank
character on the line.</p>


<p style="margin-left:11%;"><b>down&minus;line&minus;or&minus;search</b></p>

<p style="margin-left:22%;">Move down a line in the buffer,
or if already at the bottom line, search forward in the
history for a line beginning with the first word in the
buffer.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a function by the <b>zle</b> command with arguments, the
first argument is taken as the string for which to search,
rather than the first word in the buffer.</p>

<p style="margin-left:11%;"><b>down&minus;history</b>
(unbound) (^N) (unbound)</p>

<p style="margin-left:22%;">Move to the next event in the
history list.</p>


<p style="margin-left:11%;"><b>history&minus;beginning&minus;search&minus;backward</b></p>

<p style="margin-left:22%;">Search backward in the history
for a line beginning with the current line up to the cursor.
This leaves the cursor in its original position.</p>


<p style="margin-left:11%;"><b>end&minus;of&minus;buffer&minus;or&minus;history</b>
(ESC&minus;&gt;) (unbound) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the buffer,
or if already there, move to the last event in the history
list.</p>


<p style="margin-left:11%;"><b>end&minus;of&minus;line&minus;hist</b></p>

<p style="margin-left:22%;">Move to the end of the line. If
already at the end of the buffer, move to the next history
line.</p>


<p style="margin-left:11%;"><b>end&minus;of&minus;history</b></p>

<p style="margin-left:22%;">Move to the last event in the
history list.</p>


<p style="margin-left:11%;"><b>vi&minus;fetch&minus;history</b>
(unbound) (G) (unbound)</p>

<p style="margin-left:22%;">Fetch the history line
specified by the numeric argument. This defaults to the
current history line (i.e. the one that isn&rsquo;t history
yet).</p>


<p style="margin-left:11%;"><b>history&minus;incremental&minus;search&minus;backward</b>
(^R ^Xr) (unbound) (unbound)</p>

<p style="margin-left:22%;">Search backward incrementally
for a specified string. The search is case&minus;insensitive
if the search string does not have uppercase letters and no
numeric argument was given. The string may begin with
&lsquo;<b>^</b>&rsquo; to anchor the search to the beginning
of the line. When called from a user&minus;defined function
returns the following statuses: 0, if the search succeeded;
1, if the search failed; 2, if the search term was a bad
pattern; 3, if the search was aborted by the
<b>send&minus;break</b> command.</p>

<p style="margin-left:22%; margin-top: 1em">A restricted
set of editing functions is available in the
mini&minus;buffer. Keys are looked up in the special
<b>isearch</b> keymap, and if not found there in the main
keymap (note that by default the <b>isearch</b> keymap is
empty). An interrupt signal, as defined by the stty setting,
will stop the search and go back to the original line. An
undefined key will have the same effect. Note that the
following always perform the same task within incremental
searches and cannot be replaced by user defined widgets, nor
can the set of functions be extended. The supported
functions are: <b><br>
accept&minus;and&minus;hold <br>
accept&minus;and&minus;infer&minus;next&minus;history <br>
accept&minus;line <br>

accept&minus;line&minus;and&minus;down&minus;history</b></p>

<p style="margin-left:32%;">Perform the usual function
after exiting incremental search. The command line displayed
is executed.</p>


<p style="margin-left:22%;"><b>backward&minus;delete&minus;char
<br>
vi&minus;backward&minus;delete&minus;char</b></p>

<p style="margin-left:32%;">Back up one place in the search
history. If the search has been repeated this does not
immediately erase a character in the minibuffer.</p>

<p style="margin-left:22%;"><b>accept&minus;search</b></p>

<p style="margin-left:32%;">Exit incremental search,
retaining the command line but performing no further action.
Note that this function is not bound by default and has no
effect outside incremental search.</p>


<p style="margin-left:22%;"><b>backward&minus;delete&minus;word
<br>
backward&minus;kill&minus;word <br>
vi&minus;backward&minus;kill&minus;word</b></p>

<p style="margin-left:32%;">Back up one character in the
minibuffer; if multiple searches have been performed since
the character was inserted the search history is rewound to
the point just before the character was entered. Hence this
has the effect of repeating
<b>backward&minus;delete&minus;char</b>.</p>

<p style="margin-left:22%;"><b>clear&minus;screen</b></p>

<p style="margin-left:32%;">Clear the screen, remaining in
incremental search mode.</p>


<p style="margin-left:22%;"><b>history&minus;incremental&minus;search&minus;backward</b></p>

<p style="margin-left:32%;">Find the next occurrence of the
contents of the mini&minus;buffer.</p>


<p style="margin-left:22%;"><b>history&minus;incremental&minus;search&minus;forward</b></p>

<p style="margin-left:32%;">Invert the sense of the
search.</p>

<p style="margin-left:22%;"><b>magic&minus;space</b></p>

<p style="margin-left:32%;">Inserts a non&minus;magical
space.</p>

<p style="margin-left:22%;"><b>quoted&minus;insert <br>
vi&minus;quoted&minus;insert</b></p>

<p style="margin-left:32%;">Quote the character to insert
into the minibuffer.</p>

<p style="margin-left:22%;"><b>redisplay</b></p>

<p style="margin-left:32%;">Redisplay the command line,
remaining in incremental search mode.</p>


<p style="margin-left:22%;"><b>vi&minus;cmd&minus;mode</b></p>

<p style="margin-left:32%;">Toggle between the
&lsquo;<b>main</b>&rsquo; and &lsquo;<b>vicmd</b>&rsquo;
keymaps; the &lsquo;<b>main</b>&rsquo; keymap (insert mode)
will be selected initially.</p>


<p style="margin-left:22%;"><b>vi&minus;repeat&minus;search
<br>
vi&minus;rev&minus;repeat&minus;search</b></p>

<p style="margin-left:32%;">Repeat the search. The
direction of the search is indicated in the
mini&minus;buffer.</p>

<p style="margin-left:22%; margin-top: 1em">Any character
that is not bound to one of the above functions, or
<b>self&minus;insert</b> or
<b>self&minus;insert&minus;unmeta</b>, will cause the mode
to be exited. The character is then looked up and executed
in the keymap in effect at that point.</p>

<p style="margin-left:22%; margin-top: 1em">When called
from a widget function by the <b>zle</b> command, the
incremental search commands can take a string argument. This
will be treated as a string of keys, as for arguments to the
<b>bindkey</b> command, and used as initial input for the
command. Any characters in the string which are unused by
the incremental search will be silently ignored. For
example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>zle
history&minus;incremental&minus;search&minus;backward
forceps</b></p>

<p style="margin-left:22%; margin-top: 1em">will search
backwards for <b>forceps</b>, leaving the minibuffer
containing the string &lsquo;<b>forceps</b>&rsquo;.</p>


<p style="margin-left:11%;"><b>history&minus;incremental&minus;search&minus;forward</b>
(^S ^Xs) (unbound) (unbound)</p>

<p style="margin-left:22%;">Search forward incrementally
for a specified string. The search is case&minus;insensitive
if the search string does not have uppercase letters and no
numeric argument was given. The string may begin with
&lsquo;<b>^</b>&rsquo; to anchor the search to the beginning
of the line. The functions available in the
mini&minus;buffer are the same as for
<b>history&minus;incremental&minus;search&minus;backward</b>.</p>


<p style="margin-left:11%;"><b>history&minus;incremental&minus;pattern&minus;search&minus;backward
<br>

history&minus;incremental&minus;pattern&minus;search&minus;forward</b></p>

<p style="margin-left:22%;">These widgets behave similarly
to the corresponding widgets with no <b>&minus;pattern</b>,
but the search string typed by the user is treated as a
pattern, respecting the current settings of the various
options affecting pattern matching. See FILENAME GENERATION
in <i>zshexpn</i>(1) for a description of patterns. If no
numeric argument was given lowercase letters in the search
string may match uppercase letters in the history. The
string may begin with &lsquo;<b>^</b>&rsquo; to anchor the
search to the beginning of the line.</p>

<p style="margin-left:22%; margin-top: 1em">The prompt
changes to indicate an invalid pattern; this may simply
indicate the pattern is not yet complete.</p>

<p style="margin-left:22%; margin-top: 1em">Note that only
non&minus;overlapping matches are reported, so an expression
with wildcards may return fewer matches on a line than are
visible by inspection.</p>


<p style="margin-left:11%;"><b>history&minus;search&minus;backward</b>
(ESC&minus;P ESC&minus;p) (unbound) (unbound)</p>

<p style="margin-left:22%;">Search backward in the history
for a line beginning with the first word in the buffer.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a function by the <b>zle</b> command with arguments, the
first argument is taken as the string for which to search,
rather than the first word in the buffer.</p>


<p style="margin-left:11%;"><b>vi&minus;history&minus;search&minus;backward</b>
(unbound) (/) (unbound)</p>

<p style="margin-left:22%;">Search backward in the history
for a specified string. The string may begin with
&lsquo;<b>^</b>&rsquo; to anchor the search to the beginning
of the line.</p>

<p style="margin-left:22%; margin-top: 1em">A restricted
set of editing functions is available in the
mini&minus;buffer. An interrupt signal, as defined by the
stty setting, will stop the search. The functions available
in the mini&minus;buffer are: <b>accept&minus;line</b>,
<b>backward&minus;delete&minus;char</b>,
<b>vi&minus;backward&minus;delete&minus;char</b>,
<b>backward&minus;kill&minus;word</b>,
<b>vi&minus;backward&minus;kill&minus;word</b>,
<b>clear&minus;screen</b>, <b>redisplay</b>,
<b>quoted&minus;insert</b> and
<b>vi&minus;quoted&minus;insert</b>.</p>


<p style="margin-left:22%; margin-top: 1em"><b>vi&minus;cmd&minus;mode</b>
is treated the same as accept&minus;line, and
<b>magic&minus;space</b> is treated as a space. Any other
character that is not bound to self&minus;insert or
self&minus;insert&minus;unmeta will beep and be ignored. If
the function is called from vi command mode, the bindings of
the current insert mode will be used.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a function by the <b>zle</b> command with arguments, the
first argument is taken as the string for which to search,
rather than the first word in the buffer.</p>


<p style="margin-left:11%;"><b>history&minus;search&minus;forward</b>
(ESC&minus;N ESC&minus;n) (unbound) (unbound)</p>

<p style="margin-left:22%;">Search forward in the history
for a line beginning with the first word in the buffer.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a function by the <b>zle</b> command with arguments, the
first argument is taken as the string for which to search,
rather than the first word in the buffer.</p>


<p style="margin-left:11%;"><b>vi&minus;history&minus;search&minus;forward</b>
(unbound) (?) (unbound)</p>

<p style="margin-left:22%;">Search forward in the history
for a specified string. The string may begin with
&lsquo;<b>^</b>&rsquo; to anchor the search to the beginning
of the line. The functions available in the
mini&minus;buffer are the same as for
<b>vi&minus;history&minus;search&minus;backward</b>.
Argument handling is also the same as for that command.</p>


<p style="margin-left:11%;"><b>infer&minus;next&minus;history</b>
(^X^N) (unbound) (unbound)</p>

<p style="margin-left:22%;">Search in the history list for
a line matching the current one and fetch the event
following it.</p>


<p style="margin-left:11%;"><b>insert&minus;last&minus;word</b>
(ESC&minus;_ ESC&minus;.) (unbound) (unbound)</p>

<p style="margin-left:22%;">Insert the last word from the
previous history event at the cursor position. If a positive
numeric argument is given, insert that word from the end of
the previous history event. If the argument is zero or
negative insert that word from the left (zero inserts the
previous command word). Repeating this command replaces the
word just inserted with the last word from the history event
prior to the one just used; numeric arguments can be used in
the same way to pick a word from that event.</p>

<p style="margin-left:22%; margin-top: 1em">When called
from a shell function invoked from a user&minus;defined
widget, the command can take one to three arguments. The
first argument specifies a history offset which applies to
successive calls to this widget: if it is &minus;1, the
default behaviour is used, while if it is 1, successive
calls will move forwards through the history. The value 0
can be used to indicate that the history line examined by
the previous execution of the command will be reexamined.
Note that negative numbers should be preceded by a
&lsquo;<b>&minus;&minus;</b>&rsquo; argument to avoid
confusing them with options.</p>

<p style="margin-left:22%; margin-top: 1em">If two
arguments are given, the second specifies the word on the
command line in normal array index notation (as a more
natural alternative to the prefix argument). Hence 1 is the
first word, and &minus;1 (the default) is the last word.</p>

<p style="margin-left:22%; margin-top: 1em">If a third
argument is given, its value is ignored, but it is used to
signify that the history offset is relative to the current
history line, rather than the one remembered after the
previous invocations of
<b>insert&minus;last&minus;word</b>.</p>

<p style="margin-left:22%; margin-top: 1em">For example,
the default behaviour of the command corresponds to</p>

<p style="margin-left:32%; margin-top: 1em"><b>zle
insert&minus;last&minus;word &minus;&minus; &minus;1
&minus;1</b></p>

<p style="margin-left:22%; margin-top: 1em">while the
command</p>

<p style="margin-left:32%; margin-top: 1em"><b>zle
insert&minus;last&minus;word &minus;&minus; &minus;1 1
&minus;</b></p>

<p style="margin-left:22%; margin-top: 1em">always copies
the first word of the line in the history immediately before
the line being edited. This has the side effect that later
invocations of the widget will be relative to that line.</p>


<p style="margin-left:11%;"><b>vi&minus;repeat&minus;search</b>
(unbound) (n) (unbound)</p>

<p style="margin-left:22%;">Repeat the last vi history
search.</p>


<p style="margin-left:11%;"><b>vi&minus;rev&minus;repeat&minus;search</b>
(unbound) (N) (unbound)</p>

<p style="margin-left:22%;">Repeat the last vi history
search, but in reverse.</p>


<p style="margin-left:11%;"><b>up&minus;line&minus;or&minus;history</b>
(^P ESC&minus;[A) (k) (ESC&minus;[A)</p>

<p style="margin-left:22%;">Move up a line in the buffer,
or if already at the top line, move to the previous event in
the history list.</p>


<p style="margin-left:11%;"><b>vi&minus;up&minus;line&minus;or&minus;history</b>
(unbound) (&minus;) (unbound)</p>

<p style="margin-left:22%;">Move up a line in the buffer,
or if already at the top line, move to the previous event in
the history list. Then move to the first non&minus;blank
character on the line.</p>


<p style="margin-left:11%;"><b>up&minus;line&minus;or&minus;search</b></p>

<p style="margin-left:22%;">Move up a line in the buffer,
or if already at the top line, search backward in the
history for a line beginning with the first word in the
buffer.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a function by the <b>zle</b> command with arguments, the
first argument is taken as the string for which to search,
rather than the first word in the buffer.</p>

<p style="margin-left:11%;"><b>up&minus;history</b>
(unbound) (^P) (unbound)</p>

<p style="margin-left:22%;">Move to the previous event in
the history list.</p>


<p style="margin-left:11%;"><b>history&minus;beginning&minus;search&minus;forward</b></p>

<p style="margin-left:22%;">Search forward in the history
for a line beginning with the current line up to the cursor.
This leaves the cursor in its original position.</p>


<p style="margin-left:11%;"><b>set&minus;local&minus;history</b></p>

<p style="margin-left:22%;">By default, history movement
commands visit the imported lines as well as the local
lines. This widget lets you toggle this on and off, or set
it with the numeric argument. Zero for both local and
imported lines and nonzero for only local lines.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modifying
Text <br>
vi&minus;add&minus;eol</b> (unbound) (A) (unbound)</p>

<p style="margin-left:22%;">Move to the end of the line and
enter insert mode.</p>

<p style="margin-left:11%;"><b>vi&minus;add&minus;next</b>
(unbound) (a) (unbound)</p>

<p style="margin-left:22%;">Enter insert mode after the
current cursor position, without changing lines.</p>


<p style="margin-left:11%;"><b>backward&minus;delete&minus;char</b>
(^H ^?) (unbound) (unbound)</p>

<p style="margin-left:22%;">Delete the character behind the
cursor.</p>


<p style="margin-left:11%;"><b>vi&minus;backward&minus;delete&minus;char</b>
(unbound) (X) (^H)</p>

<p style="margin-left:22%;">Delete the character behind the
cursor, without changing lines. If in insert mode, this
won&rsquo;t delete past the point where insert mode was last
entered.</p>


<p style="margin-left:11%;"><b>backward&minus;delete&minus;word</b></p>

<p style="margin-left:22%;">Delete the word behind the
cursor.</p>


<p style="margin-left:11%;"><b>backward&minus;kill&minus;line</b></p>

<p style="margin-left:22%;">Kill from the beginning of the
line to the cursor position.</p>


<p style="margin-left:11%;"><b>backward&minus;kill&minus;word</b>
(^W ESC&minus;^H ESC&minus;^?) (unbound) (unbound)</p>

<p style="margin-left:22%;">Kill the word behind the
cursor.</p>


<p style="margin-left:11%;"><b>vi&minus;backward&minus;kill&minus;word</b>
(unbound) (unbound) (^W)</p>

<p style="margin-left:22%;">Kill the word behind the
cursor, without going past the point where insert mode was
last entered.</p>

<p style="margin-left:11%;"><b>capitalize&minus;word</b>
(ESC&minus;C ESC&minus;c) (unbound) (unbound)</p>

<p style="margin-left:22%;">Capitalize the current word and
move past it.</p>

<p style="margin-left:11%;"><b>vi&minus;change</b>
(unbound) (c) (unbound)</p>

<p style="margin-left:22%;">Read a movement command from
the keyboard, and kill from the cursor position to the
endpoint of the movement. Then enter insert mode. If the
command is <b>vi&minus;change</b>, change the current
line.</p>


<p style="margin-left:11%;"><b>vi&minus;change&minus;eol</b>
(unbound) (C) (unbound)</p>

<p style="margin-left:22%;">Kill to the end of the line and
enter insert mode.</p>


<p style="margin-left:11%;"><b>vi&minus;change&minus;whole&minus;line</b>
(unbound) (S) (unbound)</p>

<p style="margin-left:22%;">Kill the current line and enter
insert mode.</p>


<p style="margin-left:11%;"><b>copy&minus;region&minus;as&minus;kill</b>
(ESC&minus;W ESC&minus;w) (unbound) (unbound)</p>

<p style="margin-left:22%;">Copy the area from the cursor
to the mark to the kill buffer.</p>

<p style="margin-left:22%; margin-top: 1em">If called from
a ZLE widget function in the form &lsquo;<b>zle
copy&minus;region&minus;as&minus;kill</b>
<i>string</i>&rsquo; then <i>string</i> will be taken as the
text to copy to the kill buffer. The cursor, the mark and
the text on the command line are not used in this case.</p>


<p style="margin-left:11%;"><b>copy&minus;prev&minus;word</b>
(ESC&minus;^_) (unbound) (unbound)</p>

<p style="margin-left:22%;">Duplicate the word to the left
of the cursor.</p>


<p style="margin-left:11%;"><b>copy&minus;prev&minus;shell&minus;word</b></p>

<p style="margin-left:22%;">Like
<b>copy&minus;prev&minus;word</b>, but the word is found by
using shell parsing, whereas
<b>copy&minus;prev&minus;word</b> looks for blanks. This
makes a difference when the word is quoted and contains
spaces.</p>

<p style="margin-left:11%;"><b>vi&minus;delete</b>
(unbound) (d) (unbound)</p>

<p style="margin-left:22%;">Read a movement command from
the keyboard, and kill from the cursor position to the
endpoint of the movement. If the command is
<b>vi&minus;delete</b>, kill the current line.</p>

<p style="margin-left:11%;"><b>delete&minus;char</b></p>

<p style="margin-left:22%;">Delete the character under the
cursor.</p>


<p style="margin-left:11%;"><b>vi&minus;delete&minus;char</b>
(unbound) (x) (unbound)</p>

<p style="margin-left:22%;">Delete the character under the
cursor, without going past the end of the line.</p>

<p style="margin-left:11%;"><b>delete&minus;word</b></p>

<p style="margin-left:22%;">Delete the current word.</p>


<p style="margin-left:11%;"><b>down&minus;case&minus;word</b>
(ESC&minus;L ESC&minus;l) (unbound) (unbound)</p>

<p style="margin-left:22%;">Convert the current word to all
lowercase and move past it.</p>

<p style="margin-left:11%;"><b>kill&minus;word</b>
(ESC&minus;D ESC&minus;d) (unbound) (unbound)</p>

<p style="margin-left:22%;">Kill the current word.</p>


<p style="margin-left:11%;"><b>gosmacs&minus;transpose&minus;chars</b></p>

<p style="margin-left:22%;">Exchange the two characters
behind the cursor.</p>

<p style="margin-left:11%;"><b>vi&minus;indent</b>
(unbound) (&gt;) (unbound)</p>

<p style="margin-left:22%;">Indent a number of lines.</p>

<p style="margin-left:11%;"><b>vi&minus;insert</b>
(unbound) (i) (unbound)</p>

<p style="margin-left:22%;">Enter insert mode.</p>


<p style="margin-left:11%;"><b>vi&minus;insert&minus;bol</b>
(unbound) (I) (unbound)</p>

<p style="margin-left:22%;">Move to the first
non&minus;blank character on the line and enter insert
mode.</p>

<p style="margin-left:11%;"><b>vi&minus;join</b> (^X^J) (J)
(unbound)</p>

<p style="margin-left:22%;">Join the current line with the
next one.</p>

<p style="margin-left:11%;"><b>kill&minus;line</b> (^K)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Kill from the cursor to the end
of the line. If already on the end of the line, kill the
newline character.</p>


<p style="margin-left:11%;"><b>vi&minus;kill&minus;line</b>
(unbound) (unbound) (^U)</p>

<p style="margin-left:22%;">Kill from the cursor back to
wherever insert mode was last entered.</p>

<p style="margin-left:11%;"><b>vi&minus;kill&minus;eol</b>
(unbound) (D) (unbound)</p>

<p style="margin-left:22%;">Kill from the cursor to the end
of the line.</p>

<p style="margin-left:11%;"><b>kill&minus;region</b></p>

<p style="margin-left:22%;">Kill from the cursor to the
mark.</p>

<p style="margin-left:11%;"><b>kill&minus;buffer</b> (^X^K)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Kill the entire buffer.</p>


<p style="margin-left:11%;"><b>kill&minus;whole&minus;line</b>
(^U) (unbound) (unbound)</p>

<p style="margin-left:22%;">Kill the current line.</p>


<p style="margin-left:11%;"><b>vi&minus;match&minus;bracket</b>
(^X^B) (%) (unbound)</p>

<p style="margin-left:22%;">Move to the bracket character
(one of <b>{}</b>, <b>()</b> or <b>[]</b>) that matches the
one under the cursor. If the cursor is not on a bracket
character, move forward without going past the end of the
line to find one, and then go to the matching bracket.</p>


<p style="margin-left:11%;"><b>vi&minus;open&minus;line&minus;above</b>
(unbound) (O) (unbound)</p>

<p style="margin-left:22%;">Open a line above the cursor
and enter insert mode.</p>


<p style="margin-left:11%;"><b>vi&minus;open&minus;line&minus;below</b>
(unbound) (o) (unbound)</p>

<p style="margin-left:22%;">Open a line below the cursor
and enter insert mode.</p>


<p style="margin-left:11%;"><b>vi&minus;oper&minus;swap&minus;case</b></p>

<p style="margin-left:22%;">Read a movement command from
the keyboard, and swap the case of all characters from the
cursor position to the endpoint of the movement. If the
movement command is
<b>vi&minus;oper&minus;swap&minus;case</b>, swap the case of
all characters on the current line.</p>

<p style="margin-left:11%;"><b>overwrite&minus;mode</b>
(^X^O) (unbound) (unbound)</p>

<p style="margin-left:22%;">Toggle between overwrite mode
and insert mode.</p>


<p style="margin-left:11%;"><b>vi&minus;put&minus;before</b>
(unbound) (P) (unbound)</p>

<p style="margin-left:22%;">Insert the contents of the kill
buffer before the cursor. If the kill buffer contains a
sequence of lines (as opposed to characters), paste it above
the current line.</p>


<p style="margin-left:11%;"><b>vi&minus;put&minus;after</b>
(unbound) (p) (unbound)</p>

<p style="margin-left:22%;">Insert the contents of the kill
buffer after the cursor. If the kill buffer contains a
sequence of lines (as opposed to characters), paste it below
the current line.</p>

<p style="margin-left:11%;"><b>quoted&minus;insert</b> (^V)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Insert the next character typed
into the buffer literally. An interrupt character will not
be inserted.</p>


<p style="margin-left:11%;"><b>vi&minus;quoted&minus;insert</b>
(unbound) (unbound) (^Q ^V)</p>

<p style="margin-left:22%;">Display a
&lsquo;<b>^</b>&rsquo; at the cursor position, and insert
the next character typed into the buffer literally. An
interrupt character will not be inserted.</p>

<p style="margin-left:11%;"><b>quote&minus;line</b>
(ESC&minus;&rsquo;) (unbound) (unbound)</p>

<p style="margin-left:22%;">Quote the current line; that
is, put a &lsquo;<b>&rsquo;</b>&rsquo; character at the
beginning and the end, and convert all
&lsquo;<b>&rsquo;</b>&rsquo; characters to
&lsquo;<b>&rsquo;\&rsquo;&rsquo;</b>&rsquo;.</p>

<p style="margin-left:11%;"><b>quote&minus;region</b>
(ESC&minus;&quot;) (unbound) (unbound)</p>

<p style="margin-left:22%;">Quote the region from the
cursor to the mark.</p>

<p style="margin-left:11%;"><b>vi&minus;replace</b>
(unbound) (R) (unbound)</p>

<p style="margin-left:22%;">Enter overwrite mode.</p>


<p style="margin-left:11%;"><b>vi&minus;repeat&minus;change</b>
(unbound) (.) (unbound)</p>

<p style="margin-left:22%;">Repeat the last vi mode text
modification. If a count was used with the modification, it
is remembered. If a count is given to this command, it
overrides the remembered count, and is remembered for future
uses of this command. The cut buffer specification is
similarly remembered.</p>


<p style="margin-left:11%;"><b>vi&minus;replace&minus;chars</b>
(unbound) (r) (unbound)</p>

<p style="margin-left:22%;">Replace the character under the
cursor with a character read from the keyboard.</p>

<p style="margin-left:11%;"><b>self&minus;insert</b>
(printable characters) (unbound) (printable characters and
<br>
some control characters)</p>

<p style="margin-left:22%;">Insert a character into the
buffer at the cursor position.</p>


<p style="margin-left:11%;"><b>self&minus;insert&minus;unmeta</b>
(ESC&minus;^I ESC&minus;^J ESC&minus;^M) (unbound)
(unbound)</p>

<p style="margin-left:22%;">Insert a character into the
buffer after stripping the meta bit and converting ^M to
^J.</p>

<p style="margin-left:11%;"><b>vi&minus;substitute</b>
(unbound) (s) (unbound)</p>

<p style="margin-left:22%;">Substitute the next
character(s).</p>


<p style="margin-left:11%;"><b>vi&minus;swap&minus;case</b>
(unbound) (~) (unbound)</p>

<p style="margin-left:22%;">Swap the case of the character
under the cursor and move past it.</p>

<p style="margin-left:11%;"><b>transpose&minus;chars</b>
(^T) (unbound) (unbound)</p>

<p style="margin-left:22%;">Exchange the two characters to
the left of the cursor if at end of line, else exchange the
character under the cursor with the character to the
left.</p>

<p style="margin-left:11%;"><b>transpose&minus;words</b>
(ESC&minus;T ESC&minus;t) (unbound) (unbound)</p>

<p style="margin-left:22%;">Exchange the current word with
the one before it.</p>

<p style="margin-left:11%;"><b>vi&minus;unindent</b>
(unbound) (&lt;) (unbound)</p>

<p style="margin-left:22%;">Unindent a number of lines.</p>


<p style="margin-left:11%;"><b>up&minus;case&minus;word</b>
(ESC&minus;U ESC&minus;u) (unbound) (unbound)</p>

<p style="margin-left:22%;">Convert the current word to all
caps and move past it.</p>

<p style="margin-left:11%;"><b>yank</b> (^Y) (unbound)
(unbound)</p>

<p style="margin-left:22%;">Insert the contents of the kill
buffer at the cursor position.</p>

<p style="margin-left:11%;"><b>yank&minus;pop</b>
(ESC&minus;y) (unbound) (unbound)</p>

<p style="margin-left:22%;">Remove the text just yanked,
rotate the kill&minus;ring (the history of previously killed
text) and yank the new top. Only works following <b>yank</b>
or <b>yank&minus;pop</b>.</p>

<p style="margin-left:11%;"><b>vi&minus;yank</b> (unbound)
(y) (unbound)</p>

<p style="margin-left:22%;">Read a movement command from
the keyboard, and copy the region from the cursor position
to the endpoint of the movement into the kill buffer. If the
command is <b>vi&minus;yank</b>, copy the current line.</p>


<p style="margin-left:11%;"><b>vi&minus;yank&minus;whole&minus;line</b>
(unbound) (Y) (unbound)</p>

<p style="margin-left:22%;">Copy the current line into the
kill buffer.</p>


<p style="margin-left:11%;"><b>vi&minus;yank&minus;eol</b></p>

<p style="margin-left:22%;">Copy the region from the cursor
position to the end of the line into the kill buffer.
Arguably, this is what Y should do in vi, but it isn&rsquo;t
what it actually does.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Arguments
<br>
digit&minus;argument</b> (ESC&minus;0..ESC&minus;9)
(1&minus;9) (unbound)</p>

<p style="margin-left:22%;">Start a new numeric argument,
or add to the current one. See also
<b>vi&minus;digit&minus;or&minus;beginning&minus;of&minus;line</b>.
This only works if bound to a key sequence ending in a
decimal digit.</p>

<p style="margin-left:22%; margin-top: 1em">Inside a widget
function, a call to this function treats the last key of the
key sequence which called the widget as the digit.</p>

<p style="margin-left:11%;"><b>neg&minus;argument</b>
(ESC&minus;&minus;) (unbound) (unbound)</p>

<p style="margin-left:22%;">Changes the sign of the
following argument.</p>


<p style="margin-left:11%;"><b>universal&minus;argument</b></p>

<p style="margin-left:22%;">Multiply the argument of the
next command by 4. Alternatively, if this command is
followed by an integer (positive or negative), use that as
the argument for the next command. Thus digits cannot be
repeated using this command. For example, if this command
occurs twice, followed immediately by
<b>forward&minus;char</b>, move forward sixteen spaces; if
instead it is followed by <b>&minus;2</b>, then
<b>forward&minus;char</b>, move backward two spaces.</p>

<p style="margin-left:22%; margin-top: 1em">Inside a widget
function, if passed an argument, i.e. &lsquo;<b>zle
universal&minus;argument</b> <i>num</i>&rsquo;, the
numerical argument will be set to <i>num</i>; this is
equivalent to &lsquo;<b>NUMERIC=</b><i>num</i>&rsquo;.</p>

<p style="margin-left:11%;"><b>argument&minus;base</b></p>

<p style="margin-left:22%;">Use the existing numeric
argument as a numeric base, which must be in the range 2 to
36 inclusive. Subsequent use of <b>digit&minus;argument</b>
and <b>universal&minus;argument</b> will input a new prefix
in the given base. The usual hexadecimal convention is used:
the letter <b>a</b> or <b>A</b> corresponds to 10, and so
on. Arguments in bases requiring digits from 10 upwards are
more conveniently input with
<b>universal&minus;argument</b>, since <b>ESC&minus;a</b>
etc. are not usually bound to
<b>digit&minus;argument</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The function
can be used with a command argument inside a
user&minus;defined widget. The following code sets the base
to 16 and lets the user input a hexadecimal argument until a
key out of the digit range is typed:</p>

<p style="margin-left:32%; margin-top: 1em"><b>zle
argument&minus;base 16 <br>
zle universal&minus;argument</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Completion
<br>
accept&minus;and&minus;menu&minus;complete</b></p>

<p style="margin-left:22%;">In a menu completion, insert
the current completion into the buffer, and advance to the
next possible completion.</p>

<p style="margin-left:11%;"><b>complete&minus;word</b></p>

<p style="margin-left:22%;">Attempt completion on the
current word.</p>


<p style="margin-left:11%;"><b>delete&minus;char&minus;or&minus;list</b>
(^D) (unbound) (unbound)</p>

<p style="margin-left:22%;">Delete the character under the
cursor. If the cursor is at the end of the line, list
possible completions for the current word.</p>


<p style="margin-left:11%;"><b>expand&minus;cmd&minus;path</b></p>

<p style="margin-left:22%;">Expand the current command to
its full pathname.</p>


<p style="margin-left:11%;"><b>expand&minus;or&minus;complete</b>
(TAB) (unbound) (TAB)</p>

<p style="margin-left:22%;">Attempt shell expansion on the
current word. If that fails, attempt completion.</p>


<p style="margin-left:11%;"><b>expand&minus;or&minus;complete&minus;prefix</b></p>

<p style="margin-left:22%;">Attempt shell expansion on the
current word up to cursor.</p>

<p style="margin-left:11%;"><b>expand&minus;history</b>
(ESC&minus;space ESC&minus;!) (unbound) (unbound)</p>

<p style="margin-left:22%;">Perform history expansion on
the edit buffer.</p>

<p style="margin-left:11%;"><b>expand&minus;word</b> (^X*)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Attempt shell expansion on the
current word.</p>

<p style="margin-left:11%;"><b>list&minus;choices</b>
(ESC&minus;^D) (^D =) (^D)</p>

<p style="margin-left:22%;">List possible completions for
the current word.</p>

<p style="margin-left:11%;"><b>list&minus;expand</b> (^Xg
^XG) (^G) (^G)</p>

<p style="margin-left:22%;">List the expansion of the
current word.</p>

<p style="margin-left:11%;"><b>magic&minus;space</b></p>

<p style="margin-left:22%;">Perform history expansion and
insert a space into the buffer. This is intended to be bound
to space.</p>

<p style="margin-left:11%;"><b>menu&minus;complete</b></p>

<p style="margin-left:22%;">Like
<b>complete&minus;word</b>, except that menu completion is
used. See the <b>MENU_COMPLETE</b> option.</p>


<p style="margin-left:11%;"><b>menu&minus;expand&minus;or&minus;complete</b></p>

<p style="margin-left:22%;">Like
<b>expand&minus;or&minus;complete</b>, except that menu
completion is used.</p>


<p style="margin-left:11%;"><b>reverse&minus;menu&minus;complete</b></p>

<p style="margin-left:22%;">Perform menu completion, like
<b>menu&minus;complete</b>, except that if a menu completion
is already in progress, move to the <i>previous</i>
completion rather than the next.</p>


<p style="margin-left:11%;"><b>end&minus;of&minus;list</b></p>

<p style="margin-left:22%;">When a previous completion
displayed a list below the prompt, this widget can be used
to move the prompt below the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous
<br>
accept&minus;and&minus;hold</b> (ESC&minus;A ESC&minus;a)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Push the contents of the buffer
on the buffer stack and execute it.</p>


<p style="margin-left:11%;"><b>accept&minus;and&minus;infer&minus;next&minus;history</b></p>

<p style="margin-left:22%;">Execute the contents of the
buffer. Then search the history list for a line matching the
current one and push the event following onto the buffer
stack.</p>

<p style="margin-left:11%;"><b>accept&minus;line</b> (^J
^M) (^J ^M) (^J ^M)</p>

<p style="margin-left:22%;">Finish editing the buffer.
Normally this causes the buffer to be executed as a shell
command.</p>


<p style="margin-left:11%;"><b>accept&minus;line&minus;and&minus;down&minus;history</b>
(^O) (unbound) (unbound)</p>

<p style="margin-left:22%;">Execute the current line, and
push the next history event on the buffer stack.</p>


<p style="margin-left:11%;"><b>auto&minus;suffix&minus;remove</b></p>

<p style="margin-left:22%;">If the previous action added a
suffix (space, slash, etc.) to the word on the command line,
remove it. Otherwise do nothing. Removing the suffix ends
any active menu completion or menu selection.</p>

<p style="margin-left:22%; margin-top: 1em">This widget is
intended to be called from user&minus;defined widgets to
enforce a desired suffix&minus;removal behavior.</p>


<p style="margin-left:11%;"><b>auto&minus;suffix&minus;retain</b></p>

<p style="margin-left:22%;">If the previous action added a
suffix (space, slash, etc.) to the word on the command line,
force it to be preserved. Otherwise do nothing. Retaining
the suffix ends any active menu completion or menu
selection.</p>

<p style="margin-left:22%; margin-top: 1em">This widget is
intended to be called from user&minus;defined widgets to
enforce a desired suffix&minus;preservation behavior.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>beep</b></p></td>
<td width="5%"></td>
<td width="58%">


<p>Beep, unless the <b>BEEP</b> option is unset.</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>vi&minus;cmd&minus;mode</b>
(^X^V) (unbound) (^[)</p>

<p style="margin-left:22%;">Enter command mode; that is,
select the &lsquo;<b>vicmd</b>&rsquo; keymap. Yes, this is
bound by default in emacs mode.</p>


<p style="margin-left:11%;"><b>vi&minus;caps&minus;lock&minus;panic</b></p>

<p style="margin-left:22%;">Hang until any lowercase key is
pressed. This is for vi users without the mental capacity to
keep track of their caps lock key (like the author).</p>

<p style="margin-left:11%;"><b>clear&minus;screen</b> (^L
ESC&minus;^L) (^L) (^L)</p>

<p style="margin-left:22%;">Clear the screen and redraw the
prompt.</p>


<p style="margin-left:11%;"><b>describe&minus;key&minus;briefly</b></p>

<p style="margin-left:22%;">Reads a key sequence, then
prints the function bound to that sequence.</p>


<p style="margin-left:11%;"><b>exchange&minus;point&minus;and&minus;mark</b>
(^X^X) (unbound) (unbound)</p>

<p style="margin-left:22%;">Exchange the cursor position
(point) with the position of the mark. Unless a negative
prefix argument is given, the region between point and mark
is activated so that it can be highlighted. If a zero prefix
argument is given, the region is activated but point and
mark are not swapped.</p>


<p style="margin-left:11%;"><b>execute&minus;named&minus;cmd</b>
(ESC&minus;x) (:) (unbound)</p>

<p style="margin-left:22%;">Read the name of an editor
command and execute it. A restricted set of editing
functions is available in the mini&minus;buffer. Keys are
looked up in the special <b>command</b> keymap, and if not
found there in the main keymap. An interrupt signal, as
defined by the stty setting, will abort the function. Note
that the following always perform the same task within the
<b>executed&minus;named&minus;cmd</b> environment and cannot
be replaced by user defined widgets, nor can the set of
functions be extended. The allowed functions are:
<b>backward&minus;delete&minus;char</b>,
<b>vi&minus;backward&minus;delete&minus;char</b>,
<b>clear&minus;screen</b>, <b>redisplay</b>,
<b>quoted&minus;insert</b>,
<b>vi&minus;quoted&minus;insert</b>,
<b>backward&minus;kill&minus;word</b>,
<b>vi&minus;backward&minus;kill&minus;word</b>,
<b>kill&minus;whole&minus;line</b>,
<b>vi&minus;kill&minus;line</b>,
<b>backward&minus;kill&minus;line</b>,
<b>list&minus;choices</b>,
<b>delete&minus;char&minus;or&minus;list</b>,
<b>complete&minus;word</b>, <b>accept&minus;line</b>,
<b>expand&minus;or&minus;complete</b> and
<b>expand&minus;or&minus;complete&minus;prefix</b>.</p>


<p style="margin-left:22%; margin-top: 1em"><b>kill&minus;region</b>
kills the last word, and vi&minus;cmd&minus;mode is treated
the same as accept&minus;line. The space and tab characters,
if not bound to one of these functions, will complete the
name and then list the possibilities if the <b>AUTO_LIST</b>
option is set. Any other character that is not bound to
<b>self&minus;insert</b> or
<b>self&minus;insert&minus;unmeta</b> will beep and be
ignored. The bindings of the current insert mode will be
used.</p>

<p style="margin-left:22%; margin-top: 1em">Currently this
command may not be redefined or called by name.</p>


<p style="margin-left:11%;"><b>execute&minus;last&minus;named&minus;cmd</b>
(ESC&minus;z) (unbound) (unbound)</p>

<p style="margin-left:22%;">Redo the last function executed
with <b>execute&minus;named&minus;cmd</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Currently this
command may not be redefined or called by name.</p>

<p style="margin-left:11%;"><b>get&minus;line</b>
(ESC&minus;G ESC&minus;g) (unbound) (unbound)</p>

<p style="margin-left:22%;">Pop the top line off the buffer
stack and insert it at the cursor position.</p>

<p style="margin-left:11%;"><b>pound&minus;insert</b>
(unbound) (#) (unbound)</p>

<p style="margin-left:22%;">If there is no # character at
the beginning of the buffer, add one to the beginning of
each line. If there is one, remove a # from each line that
has one. In either case, accept the current line. The
<b>INTERACTIVE_COMMENTS</b> option must be set for this to
have any usefulness.</p>


<p style="margin-left:11%;"><b>vi&minus;pound&minus;insert</b></p>

<p style="margin-left:22%;">If there is no # character at
the beginning of the current line, add one. If there is one,
remove it. The <b>INTERACTIVE_COMMENTS</b> option must be
set for this to have any usefulness.</p>

<p style="margin-left:11%;"><b>push&minus;input</b></p>

<p style="margin-left:22%;">Push the entire current
multiline construct onto the buffer stack and return to the
top&minus;level (<b>PS1</b>) prompt. If the current parser
construct is only a single line, this is exactly like
<b>push&minus;line</b>. Next time the editor starts up or is
popped with <b>get&minus;line</b>, the construct will be
popped off the top of the buffer stack and loaded into the
editing buffer.</p>

<p style="margin-left:11%;"><b>push&minus;line</b> (^Q
ESC&minus;Q ESC&minus;q) (unbound) (unbound)</p>

<p style="margin-left:22%;">Push the current buffer onto
the buffer stack and clear the buffer. Next time the editor
starts up, the buffer will be popped off the top of the
buffer stack and loaded into the editing buffer.</p>


<p style="margin-left:11%;"><b>push&minus;line&minus;or&minus;edit</b></p>

<p style="margin-left:22%;">At the top&minus;level
(<b>PS1</b>) prompt, equivalent to <b>push&minus;line</b>.
At a secondary (<b>PS2</b>) prompt, move the entire current
multiline construct into the editor buffer. The latter is
equivalent to <b>push&minus;input</b> followed by
<b>get&minus;line</b>.</p>

<p style="margin-left:11%;"><b>read&minus;command</b></p>

<p style="margin-left:22%;">Only useful from a
user&minus;defined widget. A keystroke is read just as in
normal operation, but instead of the command being executed
the name of the command that would be executed is stored in
the shell parameter <b>REPLY</b>. This can be used as the
argument of a future <b>zle</b> command. If the key sequence
is not bound, status 1 is returned; typically, however,
<b>REPLY</b> is set to <b>undefined&minus;key</b> to
indicate a useless key sequence.</p>


<p style="margin-left:11%;"><b>recursive&minus;edit</b></p>

<p style="margin-left:22%;">Only useful from a
user&minus;defined widget. At this point in the function,
the editor regains control until one of the standard widgets
which would normally cause zle to exit (typically an
<b>accept&minus;line</b> caused by hitting the return key)
is executed. Instead, control returns to the
user&minus;defined widget. The status returned is
non&minus;zero if the return was caused by an error, but the
function still continues executing and hence may tidy up.
This makes it safe for the user&minus;defined widget to
alter the command line or key bindings temporarily.</p>

<p style="margin-left:22%; margin-top: 1em">The following
widget, <b>caps&minus;lock</b>, serves as an example.</p>


<p style="margin-left:32%;"><b>self&minus;insert&minus;ucase()
{ <br>
LBUFFER+=${(U)KEYS[&minus;1]} <br>
}</b></p>

<p style="margin-left:32%; margin-top: 1em">integer
stat</p>

<p style="margin-left:32%; margin-top: 1em">zle &minus;N
self&minus;insert self&minus;insert&minus;ucase <br>
zle &minus;A caps&minus;lock save&minus;caps&minus;lock <br>
zle &minus;A accept&minus;line caps&minus;lock</p>

<p style="margin-left:32%; margin-top: 1em">zle
recursive&minus;edit <br>
stat=$?</p>

<p style="margin-left:32%; margin-top: 1em">zle &minus;A
.self&minus;insert self&minus;insert <br>
zle &minus;A save&minus;caps&minus;lock caps&minus;lock <br>
zle &minus;D save&minus;caps&minus;lock</p>

<p style="margin-left:32%; margin-top: 1em">(( stat ))
&amp;&amp; zle send&minus;break</p>

<p style="margin-left:32%; margin-top: 1em">return
$stat</p>

<p style="margin-left:22%;">This causes typed letters to be
inserted capitalised until either <b>accept&minus;line</b>
(i.e. typically the return key) is typed or the
<b>caps&minus;lock</b> widget is invoked again; the later is
handled by saving the old definition of
<b>caps&minus;lock</b> as <b>save&minus;caps&minus;lock</b>
and then rebinding it to invoke <b>accept&minus;line</b>.
Note that an error from the recursive edit is detected as a
non&minus;zero return status and propagated by using the
<b>send&minus;break</b> widget.</p>

<p style="margin-left:11%;"><b>redisplay</b> (unbound) (^R)
(^R)</p>

<p style="margin-left:22%;">Redisplays the edit buffer.</p>

<p style="margin-left:11%;"><b>reset&minus;prompt</b>
(unbound) (unbound) (unbound)</p>

<p style="margin-left:22%;">Force the prompts on both the
left and right of the screen to be re&minus;expanded, then
redisplay the edit buffer. This reflects changes both to the
prompt variables themselves and changes in the expansion of
the values (for example, changes in time or directory, or
changes to the value of variables referred to by the
prompt).</p>

<p style="margin-left:22%; margin-top: 1em">Otherwise, the
prompt is only expanded each time zle starts, and when the
display as been interrupted by output from another part of
the shell (such as a job notification) which causes the
command line to be reprinted.</p>

<p style="margin-left:11%;"><b>send&minus;break</b> (^G
ESC&minus;^G) (unbound) (unbound)</p>

<p style="margin-left:22%;">Abort the current editor
function, e.g. <b>execute&minus;named&minus;command</b>, or
the editor itself, e.g. if you are in <b>vared</b>.
Otherwise abort the parsing of the current line; in this
case the aborted line is available in the shell variable
<b>ZLE_LINE_ABORTED</b>.</p>

<p style="margin-left:11%;"><b>run&minus;help</b>
(ESC&minus;H ESC&minus;h) (unbound) (unbound)</p>

<p style="margin-left:22%;">Push the buffer onto the buffer
stack, and execute the command &lsquo;<b>run&minus;help</b>
<i>cmd</i>&rsquo;, where <i>cmd</i> is the current command.
<b>run&minus;help</b> is normally aliased to <b>man</b>.</p>


<p style="margin-left:11%;"><b>vi&minus;set&minus;buffer</b>
(unbound) (&quot;) (unbound)</p>

<p style="margin-left:22%;">Specify a buffer to be used in
the following command. There are 35 buffers that can be
specified: the 26 &lsquo;named&rsquo; buffers <b>&quot;a</b>
to <b>&quot;z</b> and the nine &lsquo;queued&rsquo; buffers
<b>&quot;1</b> to <b>&quot;9</b>. The named buffers can also
be specified as <b>&quot;A</b> to <b>&quot;Z</b>.</p>

<p style="margin-left:22%; margin-top: 1em">When a buffer
is specified for a cut command, the text being cut replaces
the previous contents of the specified buffer. If a named
buffer is specified using a capital, the newly cut text is
appended to the buffer instead of overwriting it.</p>

<p style="margin-left:22%; margin-top: 1em">If no buffer is
specified for a cut command, <b>&quot;1</b> is used, and the
contents of <b>&quot;1</b> to <b>&quot;8</b> are each
shifted along one buffer; the contents of <b>&quot;9</b> is
lost.</p>

<p style="margin-left:11%;"><b>vi&minus;set&minus;mark</b>
(unbound) (m) (unbound)</p>

<p style="margin-left:22%;">Set the specified mark at the
cursor position.</p>


<p style="margin-left:11%;"><b>set&minus;mark&minus;command</b>
(^@) (unbound) (unbound)</p>

<p style="margin-left:22%;">Set the mark at the cursor
position. If called with a negative prefix argument, do not
set the mark but deactivate the region so that it is no
longer highlighted (it is still usable for other purposes).
Otherwise the region is marked as active.</p>

<p style="margin-left:11%;"><b>spell&minus;word</b>
(ESC&minus;$ ESC&minus;S ESC&minus;s) (unbound)
(unbound)</p>

<p style="margin-left:22%;">Attempt spelling correction on
the current word.</p>

<p style="margin-left:11%;"><b>undefined&minus;key</b></p>

<p style="margin-left:22%;">This command is executed when a
key sequence that is not bound to any command is typed. By
default it beeps.</p>

<p style="margin-left:11%;"><b>undo</b> (^_ ^Xu ^X^U)
(unbound) (unbound)</p>

<p style="margin-left:22%;">Incrementally undo the last
text modification. When called from a user&minus;defined
widget, takes an optional argument indicating a previous
state of the undo history as returned by the
<b>UNDO_CHANGE_NO</b> variable; modifications are undone
until that state is reached.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>redo</b></p></td>
<td width="5%"></td>
<td width="69%">


<p>Incrementally redo undone text modifications.</p></td>
<td width="9%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>vi&minus;undo&minus;change</b>
(unbound) (u) (unbound)</p>

<p style="margin-left:22%;">Undo the last text
modification. If repeated, redo the modification.</p>


<p style="margin-left:11%;"><b>what&minus;cursor&minus;position</b>
(^X=) (unbound) (unbound)</p>

<p style="margin-left:22%;">Print the character under the
cursor, its code as an octal, decimal and hexadecimal
number, the current cursor position within the buffer and
the column of the cursor in the current line.</p>

<p style="margin-left:11%;"><b>where&minus;is</b></p>

<p style="margin-left:22%;">Read the name of an editor
command and print the listing of key sequences that invoke
the specified command. A restricted set of editing functions
is available in the mini&minus;buffer. Keys are looked up in
the special <b>command</b> keymap, and if not found there in
the main keymap.</p>

<p style="margin-left:11%;"><b>which&minus;command</b>
(ESC&minus;?) (unbound) (unbound)</p>

<p style="margin-left:22%;">Push the buffer onto the buffer
stack, and execute the command
&lsquo;<b>which&minus;command</b> <i>cmd</i>&rsquo;. where
<i>cmd</i> is the current command.
<b>which&minus;command</b> is normally aliased to
<i>whence</i>.</p>


<p style="margin-left:11%;"><b>vi&minus;digit&minus;or&minus;beginning&minus;of&minus;line</b>
(unbound) (0) (unbound)</p>

<p style="margin-left:22%;">If the last command executed
was a digit as part of an argument, continue the argument.
Otherwise, execute
vi&minus;beginning&minus;of&minus;line.</p>

<h2>CHARACTER HIGHLIGHTING
<a name="CHARACTER HIGHLIGHTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The line editor
has the ability to highlight characters or regions of the
line that have a particular significance. This is controlled
by the array parameter <b>zle_highlight</b>, if it has been
set by the user.</p>

<p style="margin-left:11%; margin-top: 1em">If the
parameter contains the single entry <b>none</b> all
highlighting is turned off. Note the parameter is still
expected to be an array.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise each
entry of the array should consist of a word indicating a
context for highlighting, then a colon, then a
comma&minus;separated list of the types of highlighting to
apply in that context.</p>

<p style="margin-left:11%; margin-top: 1em">The contexts
available for highlighting are the following: <b><br>
default</b></p>

<p style="margin-left:22%;">Any text within the command
line not affected by any other highlighting. Text outside
the editable area of the command line is not affected.</p>

<p style="margin-left:11%;"><b>isearch</b></p>

<p style="margin-left:22%;">When one of the incremental
history search widgets is active, the area of the command
line matched by the search string or pattern.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>region</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The region between the cursor (point) and the mark as
set with <b>set&minus;mark&minus;command</b>. The region is
only highlighted if it is active, which is the case if
<b>set&minus;mark&minus;command</b> or
<b>exchange&minus;point&minus;and&minus;mark</b> has been
called and the line has not been subsequently modified. The
region can be deactivated by calling
<b>set&minus;mark&minus;command</b> with a negative prefix
argument, or reactivated by calling
<b>exchange&minus;point&minus;and&minus;mark</b> with a zero
prefix argument. Note that whether or not the region is
active has no effect on its use within widgets, it simply
determines whether it is highlighted.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>special</b></p>

<p style="margin-left:22%;">Individual characters that have
no direct printable representation but are shown in a
special manner by the line editor. These characters are
described below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>suffix</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This context is used in completion for characters that
are marked as suffixes that will be removed if the
completion ends at that point, the most obvious example
being a slash (<b>/</b>) after a directory name. Note that
suffix removal is configurable; the circumstances under
which the suffix will be removed may differ for different
completions.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>zle_highlight</b>
may contain additional fields for controlling how terminal
sequences to change colours are output. Each of the
following is followed by a colon and a string in the same
form as for key bindings. This will not be necessary for the
vast majority of terminals as the defaults shown in
parentheses are widely used. <b><br>
fg_start_code</b> (<b>\e[3</b>)</p>

<p style="margin-left:22%;">The start of the escape
sequence for the foreground colour. This is followed by an
ASCII digit representing the colour.</p>

<p style="margin-left:11%;"><b>fg_default_code</b>
(<b>9</b>)</p>

<p style="margin-left:22%;">The number to use instead of
the colour to reset the default foreground colour.</p>

<p style="margin-left:11%;"><b>fg_end_code</b>
(<b>m</b>)</p>

<p style="margin-left:22%;">The end of the escape sequence
for the foreground colour.</p>

<p style="margin-left:11%;"><b>bg_start_code</b>
(<b>\e[4</b>)</p>

<p style="margin-left:22%;">The start of the escape
sequence for the background colour. This is followed by an
ASCII digit representing the colour.</p>

<p style="margin-left:11%;"><b>bg_default_code</b>
(<b>9</b>)</p>

<p style="margin-left:22%;">The number to use instead of
the colour to reset the default background colour.</p>

<p style="margin-left:11%;"><b>bg_end_code</b>
(<b>m</b>)</p>

<p style="margin-left:22%;">The end of the escape sequence
for the background colour.</p>

<p style="margin-left:11%; margin-top: 1em">The available
types of highlighting are the following. Note that not all
types of highlighting are available on all terminals:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>none</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>No highlighting is applied to the given context. It is
not useful for this to appear with other types of
highlighting; it is used to override a default.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>fg=</b><i>colour</i></p>

<p style="margin-left:22%;">The foreground colour should be
set to <i>colour</i>, a decimal integer or the name of one
of the eight most widely&minus;supported colours.</p>

<p style="margin-left:22%; margin-top: 1em">Not all
terminals support this and, of those that do, not all
provide facilities to test the support, hence the user
should decide based on the terminal type. Most terminals
support the colours <b>black</b>, <b>red</b>, <b>green</b>,
<b>yellow</b>, <b>blue</b>, <b>magenta</b>, <b>cyan</b> and
<b>white</b>, which can be set by name. In addition.
<b>default</b> may be used to set the terminal&rsquo;s
default foreground colour. Abbreviations are allowed;
<b>b</b> or <b>bl</b> selects black. Some terminals may
generate additional colours if the <b>bold</b> attribute is
also present.</p>

<p style="margin-left:22%; margin-top: 1em">On recent
terminals and on systems with an up&minus;to&minus;date
terminal database the number of colours supported may be
tested by the command &lsquo;<b>echotc Co</b>&rsquo;; if
this succeeds, it indicates a limit on the number of colours
which will be enforced by the line editor. The number of
colours is in any case limited to 256 (i.e. the range 0 to
255).</p>

<p style="margin-left:22%; margin-top: 1em">Colour is also
known as color.</p>

<p style="margin-left:11%;"><b>bg=</b><i>colour</i></p>

<p style="margin-left:22%;">The background colour should be
set to <i>colour</i>. This works similarly to the foreground
colour, except the background is not usually affected by the
bold attribute.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>bold</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>The characters in the given context are shown in a bold
font. Not all terminals distinguish bold fonts.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>standout</b></p>

<p style="margin-left:22%;">The characters in the given
context are shown in the terminal&rsquo;s standout mode. The
actual effect is specific to the terminal; on many terminals
it is inverse video. On some such terminals, where the
cursor does not blink it appears with standout mode negated,
making it less than clear where the cursor actually is. On
such terminals one of the other effects may be preferable
for highlighting the region and matched search string.</p>

<p style="margin-left:11%;"><b>underline</b></p>

<p style="margin-left:22%;">The characters in the given
context are shown underlined. Some terminals show the
foreground in a different colour instead; in this case
whitespace will not be highlighted.</p>

<p style="margin-left:11%; margin-top: 1em">The characters
described above as &lsquo;special&rsquo; are as follows. The
formatting described here is used irrespective of whether
the characters are highlighted: <br>
ASCII control characters</p>

<p style="margin-left:22%;">Control characters in the ASCII
range are shown as &lsquo;<b>^</b>&rsquo; followed by the
base character.</p>

<p style="margin-left:11%;">Unprintable multibyte
characters</p>

<p style="margin-left:22%;">This item applies to control
characters not in the ASCII range, plus other characters as
follows. If the <b>MULTIBYTE</b> option is in effect,
multibyte characters not in the ASCII character set that are
reported as having zero width are treated as combining
characters when the option <b>COMBINING_CHARS</b> is on. If
the option is off, or if a character appears where a
combining character is not valid, the character is treated
as unprintable.</p>

<p style="margin-left:22%; margin-top: 1em">Unprintable
multibyte characters are shown as a hexadecimal number
between angle brackets. The number is the code point of the
character in the wide character set; this may or may not be
Unicode, depending on the operating system.</p>

<p style="margin-left:11%;">Invalid multibyte
characters</p>

<p style="margin-left:22%;">If the <b>MULTIBYTE</b> option
is in effect, any sequence of one or more bytes that does
not form a valid character in the current character set is
treated as a series of bytes each shown as a special
character. This case can be distinguished from other
unprintable characters as the bytes are represented as two
hexadecimal digits between angle brackets, as distinct from
the four or eight digits that are used for unprintable
characters that are nonetheless valid in the current
character set.</p>

<p style="margin-left:22%; margin-top: 1em">Not all systems
support this: for it to work, the system&rsquo;s
representation of wide characters must be code values from
the Universal Character Set, as defined by IS0 10646 (also
known as Unicode).</p>

<p style="margin-left:11%;">Wrapped double&minus;width
characters</p>

<p style="margin-left:22%;">When a double&minus;width
character appears in the final column of a line, it is
instead shown on the next line. The empty space left in the
original position is highlighted as a special character.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>zle_highlight</b> is not set or no value applies to a
particular context, the defaults applied are equivalent
to</p>


<p style="margin-left:22%; margin-top: 1em"><b>zle_highlight=(region:standout
special:standout <br>
suffix:bold isearch:underline)</b></p>

<p style="margin-left:11%; margin-top: 1em">i.e. both the
region and special characters are shown in standout
mode.</p>

<p style="margin-left:11%; margin-top: 1em">Within widgets,
arbitrary regions may be highlighted by setting the special
array parameter <b>region_highlight</b>; see above.</p>
<hr>
</body>
</html>
