<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:37:20 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>virt-resize</title>

</head>
<body>

<h1 align="center">virt-resize</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#DETAILED USAGE">DETAILED USAGE</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#MACHINE READABLE OUTPUT">MACHINE READABLE OUTPUT</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#ALTERNATIVE TOOLS">ALTERNATIVE TOOLS</a><br>
<a href="#EXIT STATUS">EXIT STATUS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">virt&minus;resize
&minus; Resize a virtual machine disk</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> virt&minus;resize [&minus;&minus;resize /dev/sdaN=[+/&minus;]&lt;size&gt;[%]]
   [&minus;&minus;expand /dev/sdaN] [&minus;&minus;shrink /dev/sdaN]
   [&minus;&minus;ignore /dev/sdaN] [&minus;&minus;delete /dev/sdaN] [...] indisk outdisk</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt-resize is
a tool which can resize a virtual machine disk, making it
larger or smaller overall, and resizing or deleting any
partitions contained within.</p>

<p style="margin-left:11%; margin-top: 1em">Virt-resize
<b>cannot</b> resize disk images in-place. Virt-resize
<b>should not</b> be used on live virtual machines &minus;
for consistent results, shut the virtual machine down before
resizing it.</p>

<p style="margin-left:11%; margin-top: 1em">If you are not
familiar with the associated tools:
<i>virt&minus;filesystems</i>(1) and
<i>virt&minus;df</i>(1), we recommend you go and read those
manual pages first.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Copy
<tt>&quot;olddisk&quot;</tt> to
<tt>&quot;newdisk&quot;</tt>, extending one of the
guest&rsquo;s partitions to fill the extra 5GB of space.</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;filesystems &minus;&minus;long &minus;h &minus;&minus;all &minus;a olddisk
 truncate &minus;r olddisk newdisk
 truncate &minus;s +5G newdisk
 # Note &quot;/dev/sda2&quot; is a partition inside the &quot;olddisk&quot; file.
 virt&minus;resize &minus;&minus;expand /dev/sda2 olddisk newdisk</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">As above, but make the /boot
partition 200MB bigger, while giving the remaining space to
/dev/sda2:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;resize &minus;&minus;resize /dev/sda1=+200M &minus;&minus;expand /dev/sda2 \
   olddisk newdisk</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">As in the first example, but
expand a logical volume as the final step. This is what you
would typically use for Linux guests that use
<small>LVM:</small></p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;resize &minus;&minus;expand /dev/sda2 &minus;&minus;LV&minus;expand /dev/vg_guest/lv_root \
   olddisk newdisk</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">As in the first example, but the
output format will be qcow2 instead of a raw disk:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> qemu&minus;img create &minus;f qcow2 &minus;o preallocation=metadata newdisk.qcow2 15G
 virt&minus;resize &minus;&minus;expand /dev/sda2 olddisk newdisk.qcow2</pre>


<h2>DETAILED USAGE
<a name="DETAILED USAGE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>EXPANDING
A VIRTUAL MACHINE DISK</small></b> <br>
1. Shut down the virtual machine <br>
2. Locate input disk image</p>

<p style="margin-left:17%;">Locate the input disk image
(ie. the file or device on the host containing the
guest&rsquo;s disk). If the guest is managed by libvirt, you
can use <tt>&quot;virsh dumpxml&quot;</tt> like this to find
the disk image name:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virsh dumpxml guestname | xpath /domain/devices/disk/source
 Found 1 nodes:
 &minus;&minus; NODE &minus;&minus;
 &lt;source dev=&quot;/dev/vg/lv_guest&quot; /&gt;</pre>


<p style="margin-left:11%;">3. Look at current sizing</p>

<p style="margin-left:17%;">Use
<i>virt&minus;filesystems</i>(1) to display the current
partitions and sizes:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virt&minus;filesystems &minus;&minus;long &minus;&minus;parts &minus;&minus;blkdevs &minus;h &minus;a /dev/vg/lv_guest
 Name       Type       Size  Parent
 /dev/sda1  partition  101M  /dev/sda
 /dev/sda2  partition  7.9G  /dev/sda
 /dev/sda   device     8.0G  &minus;</pre>


<p style="margin-left:17%; margin-top: 1em">(This example
is a virtual machine with an 8 <small>GB</small> disk which
we would like to expand up to 10 <small>GB</small> ).</p>

<p style="margin-left:11%;">4. Create output disk</p>

<p style="margin-left:17%;">Virt-resize cannot do in-place
disk modifications. You have to have space to store the
resized output disk.</p>

<p style="margin-left:17%; margin-top: 1em">To store the
resized disk image in a file, create a file of a suitable
size:</p>

<pre style="margin-left:17%; margin-top: 1em"> # rm &minus;f outdisk
 # truncate &minus;s 10G outdisk</pre>


<p style="margin-left:17%; margin-top: 1em">Or use
<i>lvcreate</i>(1) to create a logical volume:</p>

<pre style="margin-left:17%; margin-top: 1em"> # lvcreate &minus;L 10G &minus;n lv_name vg_name</pre>


<p style="margin-left:17%; margin-top: 1em">Or use
<i>virsh</i>(1) vol-create-as to create a libvirt storage
volume:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virsh pool&minus;list
 # virsh vol&minus;create&minus;as poolname newvol 10G</pre>


<p style="margin-left:11%;">5. Resize</p>

<p style="margin-left:17%;">virt-resize takes two mandatory
parameters, the input disk (eg. device, file, or a
<small>URI</small> to a remote disk) and the output disk.
The output disk is the one created in the previous step.</p>

<pre style="margin-left:17%; margin-top: 1em"> # virt&minus;resize indisk outdisk</pre>


<p style="margin-left:17%; margin-top: 1em">This command
just copies disk image <tt>&quot;indisk&quot;</tt> to disk
image <tt>&quot;outdisk&quot;</tt> <i>without</i> resizing
or changing any existing partitions. If
<tt>&quot;outdisk&quot;</tt> is larger, then an extra, empty
partition is created at the end of the disk covering the
extra space. If <tt>&quot;outdisk&quot;</tt> is smaller,
then it will give an error.</p>

<p style="margin-left:17%; margin-top: 1em">More
realistically you&rsquo;d want to expand existing partitions
in the disk image by passing extra options (for the full
list see the &quot; <small>OPTIONS&quot;</small> section
below).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;&minus;&minus;expand&quot;
is the most useful option. It expands the named partition
within the disk to fill any extra space:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virt&minus;resize &minus;&minus;expand /dev/sda2 indisk outdisk</pre>


<p style="margin-left:17%; margin-top: 1em">(In this case,
an extra partition is <i>not</i> created at the end of the
disk, because there will be no unused space).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;&minus;&minus;resize&quot;
is the other commonly used option. The following would
increase the size of /dev/sda1 by 200M, and expand /dev/sda2
to fill the rest of the available space:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virt&minus;resize &minus;&minus;resize /dev/sda1=+200M &minus;&minus;expand /dev/sda2 \
     indisk outdisk</pre>


<p style="margin-left:17%; margin-top: 1em">If the expanded
partition in the image contains a filesystem or <small>LVM
PV,</small> then if virt-resize knows how, it will resize
the contents, the equivalent of calling a command such as
<i>pvresize</i>(8), <i>resize2fs</i>(8),
<i>ntfsresize</i>(8), <i>btrfs</i>(8) or
<i>xfs_growfs</i>(8). However virt-resize does not know how
to resize some filesystems, so you would have to online
resize them after booting the guest.</p>

<pre style="margin-left:17%; margin-top: 1em"> # virt&minus;resize &minus;&minus;expand /dev/sda2 nbd://example.com outdisk</pre>


<p style="margin-left:17%; margin-top: 1em">The input disk
can be a <small>URI,</small> in order to use a remote disk
as the source. The <small>URI</small> format is compatible
with guestfish. See &quot; <small>ADDING REMOTE
STORAGE&quot;</small> in <i>guestfish</i>(1).</p>

<p style="margin-left:17%; margin-top: 1em">Other options
are covered below.</p>

<p style="margin-left:11%;">6. Test</p>

<p style="margin-left:17%;">Thoroughly test the new disk
image <i>before</i> discarding the old one.</p>

<p style="margin-left:17%; margin-top: 1em">If you are
using libvirt, edit the <small>XML</small> to point at the
new disk:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virsh edit guestname</pre>


<p style="margin-left:17%; margin-top: 1em">Change
&lt;source ...&gt;, see
http://libvirt.org/formatdomain.html#elementsDisks</p>

<p style="margin-left:17%; margin-top: 1em">Then start up
the domain with the new, resized disk:</p>

<pre style="margin-left:17%; margin-top: 1em"> # virsh start guestname</pre>


<p style="margin-left:17%; margin-top: 1em">and check that
it still works. See also the &quot;
<small>NOTES&quot;</small> section below for additional
information.</p>

<p style="margin-left:11%;">7. Resize LVs etc inside the
guest</p>

<p style="margin-left:17%;">(This can also be done offline
using <i>guestfish</i>(1))</p>

<p style="margin-left:17%; margin-top: 1em">Once the guest
has booted you should see the new space available, at least
for filesystems that virt-resize knows how to resize, and
for PVs. The user may need to resize LVs inside PVs, and
also resize filesystem types that virt-resize does not know
how to expand.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SHRINKING
A VIRTUAL MACHINE DISK</small></b> <br>
Shrinking is somewhat more complex than expanding, and only
an overview is given here.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly
virt-resize will not attempt to shrink any partition content
(PVs, filesystems). The user has to shrink content before
passing the disk image to virt-resize, and virt-resize will
check that the content has been shrunk properly.</p>

<p style="margin-left:11%; margin-top: 1em">(Shrinking can
also be done offline using <i>guestfish</i>(1))</p>

<p style="margin-left:11%; margin-top: 1em">After shrinking
PVs and filesystems, shut down the guest, and proceed with
steps 3 and 4 above to allocate a new disk image.</p>

<p style="margin-left:11%; margin-top: 1em">Then run
virt-resize with any of the <i>&minus;&minus;shrink</i>
and/or <i>&minus;&minus;resize</i> options.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>IGNORING
OR DELETING PARTITIONS</small></b> <br>
virt-resize also gives a convenient way to ignore or delete
partitions when copying from the input disk to the output
disk. Ignoring a partition speeds up the copy where you
don&rsquo;t care about the existing contents of a partition.
Deleting a partition removes it completely, but note that it
also renumbers any partitions after the one which is
deleted, which can leave some guests unbootable.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>QCOW2
AND</small> NON-SPARSE <small>RAW FORMATS</small></b> <br>
If the input disk is in qcow2 format, then you may prefer
that the output is in qcow2 format as well. Alternately,
virt-resize can convert the format on the fly. The output
format is simply determined by the format of the empty
output container that you provide. Thus to create qcow2
output, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> qemu&minus;img create &minus;f qcow2 &minus;o preallocation=metadata outdisk [size]</pre>


<p style="margin-left:11%; margin-top: 1em">instead of the
truncate command.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, to
get non-sparse raw output use:</p>

<pre style="margin-left:11%; margin-top: 1em"> fallocate &minus;l size outdisk</pre>


<p style="margin-left:11%; margin-top: 1em">(on older
systems that don&rsquo;t have the <i>fallocate</i>(1)
command use <tt>&quot;dd if=/dev/zero of=outdisk bs=1M
count=..&quot;</tt>)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>LOGICAL
PARTITIONS</small></b> <br>
Logical partitions (a.k.a. <tt>&quot;/dev/sda5+&quot;</tt>
on disks using <small>DOS</small> partition tables) cannot
be resized.</p>

<p style="margin-left:11%; margin-top: 1em">To understand
what is going on, firstly one of the four partitions
<tt>&quot;/dev/sda1&minus;4&quot;</tt> will have
<small>MBR</small> partition type <tt>05</tt> or
<tt>&quot;0f&quot;</tt>. This is called the <b>extended
partition</b>. Use <i>virt&minus;filesystems</i>(1) to see
the <small>MBR</small> partition type.</p>

<p style="margin-left:11%; margin-top: 1em">Logical
partitions live inside the extended partition.</p>

<p style="margin-left:11%; margin-top: 1em">The extended
partition can be expanded, but not shrunk (unless you force
it, which is not advisable). When the extended partition is
copied across, all the logical partitions contained inside
are copied over implicitly. Virt-resize does not look inside
the extended partition, so it copies the logical partitions
blindly.</p>

<p style="margin-left:11%; margin-top: 1em">You cannot
specify a logical partition
(<tt>&quot;/dev/sda5+&quot;</tt>) at all on the command
line. Doing so will give an error.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Display help.</p>


<p style="margin-left:11%;"><b>&minus;&minus;align&minus;first
auto <br>
&minus;&minus;align&minus;first never <br>
&minus;&minus;align&minus;first always</b></p>

<p style="margin-left:17%;">Align the first partition for
improved performance (see also the
<i>&minus;&minus;alignment</i> option).</p>

<p style="margin-left:17%; margin-top: 1em">The default is
<i>&minus;&minus;align&minus;first auto</i> which only
aligns the first partition if it is safe to do so. That is,
only when we know how to fix the bootloader automatically,
and at the moment that can only be done for Windows
guests.</p>


<p style="margin-left:17%; margin-top: 1em"><i>&minus;&minus;align&minus;first
never</i> means we never move the first partition. This is
the safest option. Try this if the guest does not boot after
resizing.</p>


<p style="margin-left:17%; margin-top: 1em"><i>&minus;&minus;align&minus;first
always</i> means we always align the first partition (if it
needs to be aligned). For some guests this will break the
bootloader, making the guest unbootable.</p>

<p style="margin-left:11%;"><b>&minus;&minus;alignment
N</b></p>

<p style="margin-left:17%;">Set the alignment of partitions
to <tt>&quot;N&quot;</tt> sectors. The default in
virt-resize &lt; 1.13.19 was 64 sectors, and after that is
128 sectors.</p>

<p style="margin-left:17%; margin-top: 1em">Assuming 512
byte sector size inside the guest, here are some suitable
values for this: <i><br>
&minus;&minus;alignment 1</i> (512 bytes)</p>

<p style="margin-left:23%;">The partitions would be packed
together as closely as possible, but would be completely
unaligned. In some cases this can cause very poor
performance. See <i>virt&minus;alignment&minus;scan</i>(1)
for further details.</p>

<p style="margin-left:17%;"><i>&minus;&minus;alignment
8</i> (4K)</p>

<p style="margin-left:23%;">This would be the minimum
acceptable alignment for reasonable performance on modern
hosts.</p>

<p style="margin-left:17%;"><i>&minus;&minus;alignment
128</i> (64K)</p>

<p style="margin-left:23%;">This alignment provides good
performance when the host is using high end network
storage.</p>

<p style="margin-left:17%;"><i>&minus;&minus;alignment
2048</i> (1M)</p>

<p style="margin-left:23%;">This is the standard alignment
used by all newly installed guests since around 2008.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;d</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;debug</b></p>

<p style="margin-left:17%;">(Deprecated: use
<i>&minus;v</i> option instead)</p>

<p style="margin-left:17%; margin-top: 1em">Enable
debugging messages.</p>


<p style="margin-left:11%;"><b>&minus;&minus;debug&minus;gc</b></p>

<p style="margin-left:17%;">Debug garbage collection and
memory allocation. This is only useful when debugging memory
problems in virt-resize or the OCaml libguestfs
bindings.</p>

<p style="margin-left:11%;"><b>&minus;&minus;delete
part</b></p>

<p style="margin-left:17%;">Delete the named partition. It
would be more accurate to describe this as &quot;don&rsquo;t
copy it over&quot;, since virt-resize doesn&rsquo;t do
in-place changes and the original disk image is left
intact.</p>

<p style="margin-left:17%; margin-top: 1em">Note that when
you delete a partition, then anything contained in the
partition is also deleted. Furthermore, this causes any
partitions that come after to be <i>renumbered</i>, which
can easily make your guest unbootable.</p>

<p style="margin-left:17%; margin-top: 1em">You can give
this option multiple times.</p>

<p style="margin-left:11%;"><b>&minus;&minus;expand
part</b></p>

<p style="margin-left:17%;">Expand the named partition so
it uses up all extra space (space left over after any other
resize changes that you request have been done).</p>

<p style="margin-left:17%; margin-top: 1em">If virt-resize
knows how, it will expand the direct content of the
partition. For example, if the partition is an <small>LVM
PV,</small> it will expand the <small>PV</small> to fit
(like calling <i>pvresize</i>(8)). Virt-resize leaves any
other content it doesn&rsquo;t know about alone.</p>

<p style="margin-left:17%; margin-top: 1em">Currently
virt-resize can resize:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>ext2, ext3 and ext4 filesystems.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p><small>NTFS</small> filesystems, if libguestfs was
compiled with support for <small>NTFS.</small></p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">The filesystem
must have been shut down consistently last time it was used.
Additionally, <i>ntfsresize</i>(8) marks the resized
filesystem as requiring a consistency check, so at the first
boot after resizing Windows will check the disk.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em"><small>LVM</small> PVs (physical
volumes). virt-resize does not usually resize anything
inside the <small>PV,</small> but see the
<i>&minus;&minus;LV&minus;expand</i> option. The user could
also resize LVs as desired after boot.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Btrfs filesystems, if libguestfs was compiled with
support for btrfs.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p><small>XFS</small> filesystems, if libguestfs was
compiled with support for <small>XFS.</small></p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note that you
cannot use <i>&minus;&minus;expand</i> and
<i>&minus;&minus;shrink</i> together.</p>

<p style="margin-left:11%;"><b>&minus;&minus;format</b>
raw</p>

<p style="margin-left:17%;">Specify the format of the input
disk image. If this flag is not given then it is
auto-detected from the image itself.</p>

<p style="margin-left:17%; margin-top: 1em">If working with
untrusted raw-format guest disk images, you should ensure
the format is always specified.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
option <i>does not</i> affect the output format. See &quot;
<small>QCOW2 AND</small> NON-SPARSE <small>RAW
FORMATS&quot;</small> .</p>

<p style="margin-left:11%;"><b>&minus;&minus;ignore
part</b></p>

<p style="margin-left:17%;">Ignore the named partition.
Effectively this means the partition is allocated on the
destination disk, but the content is not copied across from
the source disk. The content of the partition will be blank
(all zero bytes).</p>

<p style="margin-left:17%; margin-top: 1em">You can give
this option multiple times.</p>


<p style="margin-left:11%;"><b>&minus;&minus;LV&minus;expand
logvol</b></p>

<p style="margin-left:17%;">This takes the logical volume
and, as a final step, expands it to fill all the space
available in its volume group. A typical usage, assuming a
Linux guest with a single <small>PV</small>
<tt>&quot;/dev/sda2&quot;</tt> and a root device called
<tt>&quot;/dev/vg_guest/lv_root&quot;</tt> would be:</p>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;resize indisk outdisk \
   &minus;&minus;expand /dev/sda2 &minus;&minus;LV&minus;expand /dev/vg_guest/lv_root</pre>


<p style="margin-left:17%; margin-top: 1em">This would
first expand the partition (and <small>PV</small> ), and
then expand the root device to fill the extra space in the
<small>PV.</small></p>

<p style="margin-left:17%; margin-top: 1em">The contents of
the <small>LV</small> are also resized if virt-resize knows
how to do that. You can stop virt-resize from trying to
expand the content by using the option
<i>&minus;&minus;no&minus;expand&minus;content</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Use
<i>virt&minus;filesystems</i>(1) to list the filesystems in
the guest.</p>

<p style="margin-left:17%; margin-top: 1em">You can give
this option multiple times, <i>but</i> it doesn&rsquo;t make
sense to do this unless the logical volumes you specify are
all in different volume groups.</p>


<p style="margin-left:11%;"><b>&minus;&minus;machine&minus;readable</b></p>

<p style="margin-left:17%;">This option is used to make the
output more machine friendly when being parsed by other
programs. See &quot; <small>MACHINE READABLE
OUTPUT&quot;</small> below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;dryrun</b></p>

<p style="margin-left:17%;">Print a summary of what would
be done, but don&rsquo;t do anything.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;copy&minus;boot&minus;loader</b></p>

<p style="margin-left:17%;">By default, virt-resize copies
over some sectors at the start of the disk (up to the
beginning of the first partition). Commonly these sectors
contain the Master Boot Record ( <small>MBR</small> ) and
the boot loader, and are required in order for the guest to
boot correctly.</p>

<p style="margin-left:17%; margin-top: 1em">If you specify
this flag, then this initial copy is not done. You may need
to reinstall the boot loader in this case.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;extra&minus;partition</b></p>

<p style="margin-left:17%;">By default, virt-resize creates
an extra partition if there is any extra, unused space after
all resizing has happened. Use this option to prevent the
extra partition from being created. If you do this then the
extra space will be inaccessible until you run fdisk,
parted, or some other partitioning tool in the guest.</p>

<p style="margin-left:17%; margin-top: 1em">Note that if
the surplus space is smaller than 10 <small>MB,</small> no
extra partition will be created.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;expand&minus;content</b></p>

<p style="margin-left:17%;">By default, virt-resize will
try to expand the direct contents of partitions, if it knows
how (see <i>&minus;&minus;expand</i> option above).</p>

<p style="margin-left:17%; margin-top: 1em">If you give the
<i>&minus;&minus;no&minus;expand&minus;content</i> option
then virt-resize will not attempt this.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;sparse</b></p>

<p style="margin-left:17%;">Turn off sparse copying. See
&quot; <small>SPARSE COPYING&quot;</small> below.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ntfsresize&minus;force</b></p>

<p style="margin-left:17%;">Pass the
<i>&minus;&minus;force</i> option to <i>ntfsresize</i>(8),
allowing resizing even if the <small>NTFS</small> disk is
marked as needing a consistency check. You have to use this
option if you want to resize a Windows guest multiple times
without booting into Windows between each resize.</p>


<p style="margin-left:11%;"><b>&minus;&minus;output&minus;format</b>
raw</p>

<p style="margin-left:17%;">Specify the format of the
output disk image. If this flag is not given then it is
auto-detected from the image itself.</p>

<p style="margin-left:17%; margin-top: 1em">If working with
untrusted raw-format guest disk images, you should ensure
the format is always specified.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
option <i>does not create</i> the output format. This option
just tells libguestfs what it is so it doesn&rsquo;t try to
guess it. You still need to create the output disk with the
right format. See &quot; <small>QCOW2 AND</small> NON-SPARSE
<small>RAW FORMATS&quot;</small> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;q</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;quiet</b></p>

<p style="margin-left:17%;">Don&rsquo;t print the
summary.</p>

<p style="margin-left:11%;"><b>&minus;&minus;resize
part=size</b></p>

<p style="margin-left:17%;">Resize the named partition
(expanding or shrinking it) so that it has the given
size.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;size&quot;</tt>
can be expressed as an absolute number followed by b/K/M/G
to mean bytes, Kilobytes, Megabytes, or Gigabytes; or as a
percentage of the current size; or as a relative number or
percentage. For example:</p>

<pre style="margin-left:17%; margin-top: 1em"> &minus;&minus;resize /dev/sda2=10G
 &minus;&minus;resize /dev/sda4=90%
 &minus;&minus;resize /dev/sda2=+1G
 &minus;&minus;resize /dev/sda2=&minus;200M
 &minus;&minus;resize /dev/sda1=+128K
 &minus;&minus;resize /dev/sda1=+10%
 &minus;&minus;resize /dev/sda1=&minus;10%</pre>


<p style="margin-left:17%; margin-top: 1em">You can
increase the size of any partition. Virt-resize will expand
the direct content of the partition if it knows how (see
<i>&minus;&minus;expand</i> above).</p>

<p style="margin-left:17%; margin-top: 1em">You can only
<i>decrease</i> the size of partitions that contain
filesystems or PVs which have already been shrunk.
Virt-resize will check this has been done before proceeding,
or else will print an error (see also
<i>&minus;&minus;resize&minus;force</i>).</p>

<p style="margin-left:17%; margin-top: 1em">You can give
this option multiple times.</p>


<p style="margin-left:11%;"><b>&minus;&minus;resize&minus;force
part=size</b></p>

<p style="margin-left:17%;">This is the same as
<i>&minus;&minus;resize</i> except that it will let you
decrease the size of any partition. Generally this means you
will lose any data which was at the end of the partition you
shrink, but you may not care about that (eg. if shrinking an
unused partition, or if you can easily recreate it such as a
swap partition).</p>

<p style="margin-left:17%; margin-top: 1em">See also the
<i>&minus;&minus;ignore</i> option.</p>

<p style="margin-left:11%;"><b>&minus;&minus;shrink
part</b></p>

<p style="margin-left:17%;">Shrink the named partition
until the overall disk image fits in the destination. The
named partition <b>must</b> contain a filesystem or
<small>PV</small> which has already been shrunk using
another tool (eg. <i>guestfish</i>(1) or other online
tools). Virt-resize will check this and give an error if it
has not been done.</p>

<p style="margin-left:17%; margin-top: 1em">The amount by
which the overall disk must be shrunk (after carrying out
all other operations requested by the user) is called the
&quot;deficit&quot;. For example, a straight copy (assume no
other operations) from a 5GB disk image to a 4GB disk image
results in a 1GB deficit. In this case, virt-resize would
give an error unless the user specified a partition to
shrink and that partition had more than a gigabyte of free
space.</p>

<p style="margin-left:17%; margin-top: 1em">Note that you
cannot use <i>&minus;&minus;expand</i> and
<i>&minus;&minus;shrink</i> together.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Enable debugging messages.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:17%;">Display version number and
exit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;x</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Enable tracing of libguestfs <small>API</small>
calls.</p> </td>
<td width="23%">
</td></tr>
</table>

<h2>MACHINE READABLE OUTPUT
<a name="MACHINE READABLE OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>&minus;&minus;machine&minus;readable</i> option can be
used to make the output more machine friendly, which is
useful when calling virt-resize from other programs, GUIs
etc.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to use this option.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly use the
option on its own to query the capabilities of the
virt-resize binary. Typical output looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;resize &minus;&minus;machine&minus;readable
 virt&minus;resize
 ntfsresize&minus;force
 32bitok
 ntfs
 btrfs</pre>


<p style="margin-left:11%; margin-top: 1em">A list of
features is printed, one per line, and the program exits
with status 0.</p>

<p style="margin-left:11%; margin-top: 1em">Secondly use
the option in conjunction with other options to make the
regular program output more machine friendly.</p>

<p style="margin-left:11%; margin-top: 1em">At the moment
this means:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Progress bar messages can be
parsed from stdout by looking for this regular
expression:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ^[0&minus;9]+/[0&minus;9]+$</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">The calling program should treat
messages sent to stdout (except for progress bar messages)
as status messages. They can be logged and/or displayed to
the user.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The calling program should treat messages sent to stderr
as error messages. In addition, virt-resize exits with a
non-zero status code if there was a fatal error.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Versions of the
program prior to 1.13.9 did not support the
<i>&minus;&minus;machine&minus;readable</i> option and will
return an error.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;Partition
1 does not end on cylinder boundary.&quot;</b> <br>
Virt-resize aligns partitions to multiples of 128 sectors
(see the <i>&minus;&minus;alignment</i> parameter). Usually
this means the partitions will not be aligned to the ancient
<small>CHS</small> geometry. However <small>CHS</small>
geometry is meaningless for disks manufactured since the
early 1990s, and doubly so for virtual hard drives.
Alignment of partitions to cylinders is not required by any
modern operating system.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GUEST
BOOT STUCK AT &quot;GRUB&quot;</small></b> <br>
If a Linux guest does not boot after resizing, and the boot
is stuck after printing <tt>&quot;GRUB&quot;</tt> on the
console, try reinstalling grub.</p>

<pre style="margin-left:11%; margin-top: 1em"> guestfish &minus;i &minus;a newdisk
 &gt;&lt;fs&gt; cat /boot/grub/device.map
 # check the contents of this file are sensible or
 # edit the file if necessary
 &gt;&lt;fs&gt; grub&minus;install / /dev/vda
 &gt;&lt;fs&gt; exit</pre>


<p style="margin-left:11%; margin-top: 1em">For more
flexible guest reconfiguration, including if you need to
specify other parameters to grub-install, use
<i>virt&minus;rescue</i>(1).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>RESIZING
WINDOWS BOOT PARTITIONS</small></b> <br>
In Windows Vista and later versions, Microsoft switched to
using a separate boot partition. In these VMs, typically
<tt>&quot;/dev/sda1&quot;</tt> is the boot partition and
<tt>&quot;/dev/sda2&quot;</tt> is the main (C:) drive.
Resizing the first (boot) partition causes the bootloader to
fail with <tt>0xC0000225</tt> error. Resizing the second
partition (ie. C: drive) should work.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WINDOWS
CHKDSK</small></b> <br>
Windows disks which use <small>NTFS</small> must be
consistent before virt-resize can be used. If the ntfsresize
operation fails, try booting the original <small>VM</small>
and running <tt>&quot;chkdsk /f&quot;</tt> on all
<small>NTFS</small> partitions, then shut down the
<small>VM</small> cleanly. For further information see:
https://bugzilla.redhat.com/show_bug.cgi?id=975753</p>

<p style="margin-left:11%; margin-top: 1em"><i>After
resize</i> Windows may initiate a lengthy &quot;chkdsk&quot;
on first boot if <small>NTFS</small> partitions have been
expanded. This is just a safety check and (unless it find
errors) is nothing to worry about.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WINDOWS
UNMOUNTABLE_BOOT_VOLUME BSOD</small></b> <br>
After sysprepping a Windows guest and then resizing it with
virt-resize, you may see the guest fail to boot with an
<tt>&quot;UNMOUNTABLE_BOOT_VOLUME&quot;</tt>
<small>BSOD.</small> This error is caused by having
<tt>&quot;ExtendOemPartition=1&quot;</tt> in the sysprep.inf
file. Removing this line before sysprepping should fix the
problem.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WINDOWS
8</small></b> <br>
Windows 8 &quot;fast startup&quot; can prevent virt-resize
from resizing <small>NTFS</small> partitions. See &quot;
<small>WINDOWS HIBERNATION AND WINDOWS 8 FAST
STARTUP&quot;</small> in <i>guestfs</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SPARSE
COPYING</small></b> <br>
You should create a fresh, zeroed target disk image for
virt-resize to use.</p>

<p style="margin-left:11%; margin-top: 1em">Virt-resize by
default performs sparse copying. This means that it does not
copy blocks from the source disk which are all zeroes. This
improves speed and efficiency, but will produce incorrect
results if the target disk image contains unzeroed data.</p>

<p style="margin-left:11%; margin-top: 1em">The main time
this can be a problem is if the target is a host partition
(eg.
<tt>&quot;virt&minus;resize&nbsp;source.img&nbsp;/dev/sda4&quot;</tt>)
because the usual partitioning tools tend to leave whatever
data happened to be on the disk before.</p>

<p style="margin-left:11%; margin-top: 1em">If you have to
reuse a target which contains data already, you should use
the <i>&minus;&minus;no&minus;sparse</i> option. Note this
can be much slower.</p>

<h2>ALTERNATIVE TOOLS
<a name="ALTERNATIVE TOOLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
several proprietary tools for resizing partitions. We
won&rsquo;t mention any here.</p>


<p style="margin-left:11%; margin-top: 1em"><i>parted</i>(8)
and its graphical shell gparted can do some types of
resizing operations on disk images. They can resize and move
partitions, but I don&rsquo;t think they can do anything
with the contents, and they certainly don&rsquo;t understand
<small>LVM.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>guestfish</i>(1)
can do everything that virt-resize can do and a lot more,
but at a much lower level. You will probably end up
hand-calculating sector offsets, which is something that
virt-resize was designed to avoid. If you want to see the
guestfish-equivalent commands that virt-resize runs, use the
<i>&minus;&minus;debug</i> flag.</p>


<p style="margin-left:11%; margin-top: 1em"><i>dracut</i>(8)
includes a module called
<tt>&quot;dracut&minus;modules&minus;growroot&quot;</tt>
which can be used to grow the root partition when the guest
first boots up. There is documentation for this module in an
associated <small>README</small> file.</p>

<h2>EXIT STATUS
<a name="EXIT STATUS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program
returns 0 if successful, or non-zero if there was an
error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>virt&minus;filesystems</i>(1),
<i>virt&minus;df</i>(1), <i>guestfs</i>(3),
<i>guestfish</i>(1), <i>lvm</i>(8), <i>pvresize</i>(8),
<i>lvresize</i>(8), <i>resize2fs</i>(8),
<i>ntfsresize</i>(8), <i>btrfs</i>(8), <i>xfs_growfs</i>(8),
<i>virsh</i>(1), <i>parted</i>(8), <i>truncate</i>(1),
<i>fallocate</i>(1), <i>grub</i>(8),
<i>grub&minus;install</i>(8), <i>virt&minus;rescue</i>(1),
<i>virt&minus;sparsify</i>(1),
<i>virt&minus;alignment&minus;scan</i>(1),
http://libguestfs.org/.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Richard W.M.
Jones http://people.redhat.com/~rjones/</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2010&minus;2012 Red Hat Inc.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of the <small>GNU</small> General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the
<small>GNU</small> General Public License for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the <small>GNU</small> General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, <small>MA 02110&minus;1301 USA.</small></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To get a list
of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">To report a new
bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">When reporting
a bug, please supply:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The version of libguestfs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Where you got libguestfs (eg. which Linux distro,
compiled from source, etc)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Describe the bug accurately and give a way to reproduce
it.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Run <i>libguestfs&minus;test&minus;tool</i>(1) and paste
the <b>complete, unedited</b> output into the bug
report.</p> </td></tr>
 </table>
<hr>
</body>
</html>
