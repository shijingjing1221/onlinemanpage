<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:52:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>YAML</title>

</head>
<body>

<h1 align="center">YAML</h1>

<a href="#NAME">NAME</a><br>
<a href="#NOTE">NOTE</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#WHY YAML IS COOL">WHY YAML IS COOL</a><br>
<a href="#YAML IMPLEMENTATIONS IN PERL">YAML IMPLEMENTATIONS IN PERL</a><br>
<a href="#FUNCTIONAL USAGE">FUNCTIONAL USAGE</a><br>
<a href="#GLOBAL OPTIONS">GLOBAL OPTIONS</a><br>
<a href="#YAML TERMINOLOGY">YAML TERMINOLOGY</a><br>
<a href="#ysh &minus; The YAML Shell">ysh &minus; The YAML Shell</a><br>
<a href="#BUGS &amp; DEFICIENCIES">BUGS &amp; DEFICIENCIES</a><br>
<a href="#RESOURCES">RESOURCES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">YAML &minus;
YAML Ain&rsquo;t Markup Language (tm)</p>

<h2>NOTE
<a name="NOTE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module has
been released to <small>CPAN</small> as YAML::Old, and soon
<small>YAML</small> .pm will be changed to just be a
frontend interface module for all the various Perl
<small>YAML</small> implementation modules, including
YAML::Old.</p>

<p style="margin-left:11%; margin-top: 1em">If you want
robust and fast <small>YAML</small> processing using the
normal Dump/Load <small>API,</small> please consider
switching to <small>YAML::XS.</small> It is by far the best
Perl module for <small>YAML</small> at this time. It
requires that you have a C compiler, since it is written in
C.</p>

<p style="margin-left:11%; margin-top: 1em">If you really
need to use this version of <small>YAML</small> .pm it will
always be available as YAML::Old.</p>

<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t care which <small>YAML</small> module use, as
long as it&rsquo;s the best one installed on your system,
use YAML::Any.</p>

<p style="margin-left:11%; margin-top: 1em">The rest of
this documentation is left unchanged, until
<small>YAML</small> .pm is switched over to the new UI-only
version.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use YAML;
    # Load a YAML stream of 3 YAML documents into Perl data structures.
    my ($hashref, $arrayref, $string) = Load(&lt;&lt;'...');
    &minus;&minus;&minus;
    name: ingy
    age: old
    weight: heavy
    # I should comment that I also like pink, but don't tell anybody.
    favorite colors:
        &minus; red
        &minus; green
        &minus; blue
    &minus;&minus;&minus;
    &minus; Clark Evans
    &minus; Oren Ben&minus;Kiki
    &minus; Ingy doet Net
    &minus;&minus;&minus; &gt;
    You probably think YAML stands for &quot;Yet Another Markup Language&quot;. It
    ain't! YAML is really a data serialization language. But if you want
    to think of it as a markup, that's OK with me. A lot of people try
    to use XML as a serialization format.
    &quot;YAML&quot; is catchy and fun to say. Try it. &quot;YAML, YAML, YAML!!!&quot;
    ...
    # Dump the Perl data structures back into YAML.
    print Dump($string, $arrayref, $hashref);
    # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
    use Data::Dumper;
    print Dumper($string, $arrayref, $hashref);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>YAML</small> .pm module implements a
<small>YAML</small> Loader and Dumper based on the
<small>YAML 1.0</small> specification.
&lt;http://www.yaml.org/spec/&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
is a generic data serialization language that is optimized
for human readability. It can be used to express the data
structures of most modern programming languages. (Including
Perl!!!)</p>

<p style="margin-left:11%; margin-top: 1em">For information
on the <small>YAML</small> syntax, please refer to the
<small>YAML</small> specification.</p>

<h2>WHY YAML IS COOL
<a name="WHY YAML IS COOL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
is readable for people.</p>

<p style="margin-left:17%;">It makes clear sense out of
complex data structures. You should find that
<small>YAML</small> is an exceptional data dumping tool.
Structure is shown through indentation, <small>YAML</small>
supports recursive data, and hash keys are sorted by
default. In addition, <small>YAML</small> supports several
styles of scalar formatting for different types of data.</p>

<p style="margin-left:11%;"><small>YAML</small> is
editable.</p>

<p style="margin-left:17%;"><small>YAML</small> was
designed from the ground up to be an excellent syntax for
configuration files. Almost all programs need configuration
files, so why invent a new syntax for each one? And why
subject users to the complexities of <small>XML</small> or
native Perl code?</p>

<p style="margin-left:11%;"><small>YAML</small> is
multilingual.</p>

<p style="margin-left:17%;">Yes, <small>YAML</small>
supports Unicode. But I&rsquo;m actually referring to
programming languages. <small>YAML</small> was designed to
meet the serialization needs of Perl, Python, Ruby, Tcl,
<small>PHP,</small> Javascript and Java. It was also
designed to be interoperable between those languages. That
means <small>YAML</small> serializations produced by Perl
can be processed by Python.</p>

<p style="margin-left:11%;"><small>YAML</small> is taint
safe.</p>

<p style="margin-left:17%;">Using modules like Data::Dumper
for serialization is fine as long as you can be sure that
nobody can tamper with your data files or transmissions.
That&rsquo;s because you need to use Perl&rsquo;s
<tt>&quot;eval()&quot;</tt> built-in to deserialize the
data. Somebody could add a snippet of Perl to erase your
files.</p>


<p style="margin-left:17%; margin-top: 1em"><small>YAML</small>
&rsquo;s parser does not need to eval anything.</p>

<p style="margin-left:11%;"><small>YAML</small> is full
featured.</p>

<p style="margin-left:17%;"><small>YAML</small> can
accurately serialize all of the common Perl data structures
and deserialize them again without losing data
relationships. Although it is not 100% perfect (no
serializer is or can be perfect), it fares as well as the
popular current modules: Data::Dumper, Storable, XML::Dumper
and Data::Denter.</p>


<p style="margin-left:17%; margin-top: 1em"><small>YAML</small>
.pm also has the ability to handle code (subroutine)
references and typeglobs. (Still experimental) These
features are not found in Perl&rsquo;s other serialization
modules.</p>

<p style="margin-left:11%;"><small>YAML</small> is
extensible.</p>

<p style="margin-left:17%;">The <small>YAML</small>
language has been designed to be flexible enough to solve
it&rsquo;s own problems. The markup itself has 3 basic
construct which resemble Perl&rsquo;s hash, array and
scalar. By default, these map to their Perl equivalents. But
each <small>YAML</small> node also supports a tagging
mechanism (type system) which can cause that node to be
interpreted in a completely different manner. That&rsquo;s
how <small>YAML</small> can support object serialization and
oddball structures like Perl&rsquo;s typeglob.</p>

<h2>YAML IMPLEMENTATIONS IN PERL
<a name="YAML IMPLEMENTATIONS IN PERL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module,
<small>YAML</small> .pm, is really just the interface module
for <small>YAML</small> modules written in Perl. The basic
interface for <small>YAML</small> consists of two functions:
<tt>&quot;Dump&quot;</tt> and <tt>&quot;Load&quot;</tt>. The
real work is done by the modules YAML::Dumper and
YAML::Loader.</p>

<p style="margin-left:11%; margin-top: 1em">Different
<small>YAML</small> module distributions can be created by
subclassing <small>YAML</small> .pm and YAML::Loader and
YAML::Dumper. For example, YAML-Simple consists of
YAML::Simple YAML::Dumper::Simple and
YAML::Loader::Simple.</p>

<p style="margin-left:11%; margin-top: 1em">Why would there
be more than one implementation of <small>YAML</small> ?
Well, despite <small>YAML</small> &rsquo;s offering of being
a simple data format, <small>YAML</small> is actually very
deep and complex. Implementing the entirety of the
<small>YAML</small> specification is a daunting task.</p>

<p style="margin-left:11%; margin-top: 1em">For this reason
I am currently working on 3 different <small>YAML</small>
implementations. <small><br>
YAML</small></p>

<p style="margin-left:17%;">The main <small>YAML</small>
distribution will keeping evolving to support the entire
<small>YAML</small> specification in pure Perl. This may not
be the fastest or most stable module though. Currently,
<small>YAML</small> .pm has lots of known bugs. It is mostly
a great tool for dumping Perl data structures to a readable
form.</p>

<p style="margin-left:11%;">YAML::Tiny</p>

<p style="margin-left:17%;">The point of YAML::Tiny is to
strip <small>YAML</small> down to the 90% that people use
most and offer that in a small, fast, stable, pure Perl
form. YAML::Tiny will simply die when it is asked to do
something it can&rsquo;t.</p>

<p style="margin-left:11%;">YAML::Syck</p>

<p style="margin-left:17%;"><tt>&quot;libsyck&quot;</tt> is
the C based <small>YAML</small> processing library used by
the Ruby programming language (and also Python,
<small>PHP</small> and Pugs). YAML::Syck is the Perl binding
to <tt>&quot;libsyck&quot;</tt>. It should be very fast, but
may have problems of its own. It will also require C
compilation.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
Audrey Tang has actually completed this module and it works
great <br>
and is 10 times faster than <small>YAML</small> .pm.</p>

<p style="margin-left:11%; margin-top: 1em">In the future,
there will likely be even more <small>YAML</small> modules.
Remember, people other than Ingy are allowed to write
<small>YAML</small> modules!</p>

<h2>FUNCTIONAL USAGE
<a name="FUNCTIONAL USAGE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
is completely <small>OO</small> under the hood. Still it
exports a few useful top level functions so that it is dead
simple to use. These functions just do the <small>OO</small>
stuff for you. If you want direct access to the <small>OO
API</small> see the documentation for YAML::Dumper and
YAML::Loader.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exported
Functions</b> <br>
The following functions are exported by <small>YAML</small>
.pm by default. The reason they are exported is so that
<small>YAML</small> works much like Data::Dumper. If you
don&rsquo;t want functions to be imported, just use
<small>YAML</small> with an empty import list:</p>

<pre style="margin-left:11%; margin-top: 1em">    use YAML ();</pre>



<p style="margin-left:11%;">Dump(list&minus;of&minus;Perl&minus;data&minus;structures)</p>

<p style="margin-left:17%;">Turn Perl data into
<small>YAML.</small> This function works very much like
<i>Data::Dumper::Dumper()</i>. It takes a list of Perl data
strucures and dumps them into a serialized form. It returns
a string containing the <small>YAML</small> stream. The
structures can be references or plain scalars.</p>


<p style="margin-left:11%;">Load(string&minus;containing&minus;a&minus;YAML&minus;stream)</p>

<p style="margin-left:17%;">Turn <small>YAML</small> into
Perl data. This is the opposite of Dump. Just like
Storable&rsquo;s <i>thaw()</i> function or the <i>eval()</i>
function in relation to Data::Dumper. It parses a string
containing a valid <small>YAML</small> stream into a list of
Perl data structures.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exportable
Functions</b> <br>
These functions are not exported by default but you can
request them in an import list like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    use YAML qw'freeze thaw Bless';</pre>


<p style="margin-left:11%;"><i>freeze()</i> and
<i>thaw()</i></p>

<p style="margin-left:17%;">Aliases to <i>Dump()</i> and
<i>Load()</i> for Storable fans. This will also allow
<small>YAML</small> .pm to be plugged directly into modules
like <small>POE</small> .pm, that use the freeze/thaw
<small>API</small> for internal serialization.</p>

<p style="margin-left:11%;">DumpFile(filepath, list)</p>

<p style="margin-left:17%;">Writes the <small>YAML</small>
stream to a file instead of just returning a string.</p>

<p style="margin-left:11%;">LoadFile(filepath)</p>

<p style="margin-left:17%;">Reads the <small>YAML</small>
stream from a file instead of a string.</p>

<p style="margin-left:11%;">Bless(perl&minus;node,
[yaml&minus;node | class&minus;name])</p>

<p style="margin-left:17%;">Associate a normal Perl node,
with a yaml node. A yaml node is an object tied to the
YAML::Node class. The second argument is either a yaml node
that you&rsquo;ve already created or a class (package) name
that supports a <i>yaml_dump()</i> function. A
<i>yaml_dump()</i> function should take a perl node and
return a yaml node. If no second argument is provided, Bless
will create a yaml node. This node is not returned, but can
be retrieved with the <i>Blessed()</i> function.</p>

<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s an
example of how to use Bless. Say you have a hash containing
three keys, but you only want to dump two of them.
Furthermore the keys must be dumped in a certain order.
Here&rsquo;s how you do that:</p>

<pre style="margin-left:17%; margin-top: 1em">    use YAML qw(Dump Bless);
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};
    print Dump $hash;
    Bless($hash)&minus;&gt;keys(['banana', 'apple']);
    print Dump $hash;</pre>


<p style="margin-left:17%; margin-top: 1em">produces:</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;&minus;&minus;
    apple: good
    banana: bad
    cauliflower: ugly
    &minus;&minus;&minus;
    banana: bad
    apple: good</pre>


<p style="margin-left:17%; margin-top: 1em">Bless returns
the tied part of a yaml-node, so that you can call the
YAML::Node methods. This is the same thing that
<i>YAML::Node::ynode()</i> returns. So another way to do the
above example is:</p>

<pre style="margin-left:17%; margin-top: 1em">    use YAML qw(Dump Bless);
    use YAML::Node;
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};
    print Dump $hash;
    Bless($hash);
    $ynode = ynode(Blessed($hash));
    $ynode&minus;&gt;keys(['banana', 'apple']);
    print Dump $hash;</pre>


<p style="margin-left:17%; margin-top: 1em">Note that
Blessing a Perl data structure does not change it anyway.
The extra information is stored separately and looked up by
the Blessed node&rsquo;s memory address.</p>

<p style="margin-left:11%;">Blessed(perl&minus;node)</p>

<p style="margin-left:17%;">Returns the yaml node that a
particular perl node is associated with (see above). Returns
undef if the node is not ( <small>YAML</small> )
Blessed.</p>

<h2>GLOBAL OPTIONS
<a name="GLOBAL OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
options are set using a group of global variables in the
<small>YAML</small> namespace. This is similar to how
Data::Dumper works.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
change the indentation width, do something like:</p>

<pre style="margin-left:11%; margin-top: 1em">    local $YAML::Indent = 3;</pre>


<p style="margin-left:11%; margin-top: 1em">The current
options are: <br>
DumperClass</p>

<p style="margin-left:17%;">You can override which
module/class <small>YAML</small> uses for Dumping data.</p>

<p style="margin-left:11%;">LoaderClass</p>

<p style="margin-left:17%;">You can override which
module/class <small>YAML</small> uses for Loading data.</p>

<p style="margin-left:11%;">Indent</p>

<p style="margin-left:17%;">This is the number of space
characters to use for each indentation level when doing a
<i>Dump()</i>. The default is 2.</p>

<p style="margin-left:17%; margin-top: 1em">By the way,
<small>YAML</small> can use any number of characters for
indentation at any level. So if you are editing
<small>YAML</small> by hand feel free to do it anyway that
looks pleasing to you; just be consistent for a given
level.</p>

<p style="margin-left:11%;">SortKeys</p>

<p style="margin-left:17%;">Default is 1. (true)</p>

<p style="margin-left:17%; margin-top: 1em">Tells
<small>YAML</small> .pm whether or not to sort hash keys
when storing a document.</p>

<p style="margin-left:17%; margin-top: 1em">YAML::Node
objects can have their own sort order, which is usually what
you want. To override the YAML::Node order and sort the keys
anyway, set SortKeys to 2.</p>

<p style="margin-left:11%;">Stringify</p>

<p style="margin-left:17%;">Default is 0. (false)</p>

<p style="margin-left:17%; margin-top: 1em">Objects with
string overloading should honor the overloading and dump the
stringification of themselves, rather than the actual
object&rsquo;s guts.</p>

<p style="margin-left:11%;">UseHeader</p>

<p style="margin-left:17%;">Default is 1. (true)</p>

<p style="margin-left:17%; margin-top: 1em">This tells
<small>YAML</small> .pm whether to use a separator string
for a Dump operation. This only applies to the first
document in a stream. Subsequent documents must have a
<small>YAML</small> header by definition.</p>

<p style="margin-left:11%;">UseVersion</p>

<p style="margin-left:17%;">Default is 0. (false)</p>

<p style="margin-left:17%; margin-top: 1em">Tells
<small>YAML</small> .pm whether to include the
<small>YAML</small> version on the separator/header.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;&minus;&minus; %YAML:1.0</pre>


<p style="margin-left:11%;">AnchorPrefix</p>

<p style="margin-left:17%;">Default is &rsquo;&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">Anchor names
are normally numeric. <small>YAML</small> .pm simply starts
with &rsquo;1&rsquo; and increases by one for each new
anchor. This option allows you to specify a string to be
prepended to each anchor number.</p>

<p style="margin-left:11%;">UseCode</p>

<p style="margin-left:17%;">Setting the UseCode option is a
shortcut to set both the DumpCode and LoadCode options at
once. Setting UseCode to &rsquo;1&rsquo; tells
<small>YAML</small> .pm to dump Perl code references as Perl
(using B::Deparse) and to load them back into memory using
<i>eval()</i>. The reason this has to be an option is that
using <i>eval()</i> to parse untrusted code is, well,
untrustworthy.</p>

<p style="margin-left:11%;">DumpCode</p>

<p style="margin-left:17%;">Determines if and how
<small>YAML</small> .pm should serialize Perl code
references. By default <small>YAML</small> .pm will dump
code references as dummy placeholders (much like
Data::Dumper). If DumpCode is set to &rsquo;1&rsquo; or
&rsquo;deparse&rsquo;, code references will be dumped as
actual Perl code.</p>

<p style="margin-left:17%; margin-top: 1em">DumpCode can
also be set to a subroutine reference so that you can write
your own serializing routine. <small>YAML</small> .pm passes
you the code ref. You pass back the serialization (as a
string) and a format indicator. The format indicator is a
simple string like: &rsquo;deparse&rsquo; or
&rsquo;bytecode&rsquo;.</p>

<p style="margin-left:11%;">LoadCode</p>

<p style="margin-left:17%;">LoadCode is the opposite of
DumpCode. It tells <small>YAML</small> if and how to
deserialize code references. When set to &rsquo;1&rsquo; or
&rsquo;deparse&rsquo; it will use
<tt>&quot;eval()&quot;</tt>. Since this is potentially
risky, only use this option if you know where your
<small>YAML</small> has been.</p>

<p style="margin-left:17%; margin-top: 1em">LoadCode can
also be set to a subroutine reference so that you can write
your own deserializing routine. <small>YAML</small> .pm
passes the serialization (as a string) and a format
indicator. You pass back the code reference.</p>

<p style="margin-left:11%;">UseBlock</p>

<p style="margin-left:17%;"><small>YAML</small> .pm uses
heuristics to guess which scalar style is best for a given
node. Sometimes you&rsquo;ll want all multiline scalars to
use the &rsquo;block&rsquo; style. If so, set this option to
1.</p>

<p style="margin-left:17%; margin-top: 1em"><small>NOTE:
YAML</small> &rsquo;s block style is akin to Perl&rsquo;s
here-document.</p>

<p style="margin-left:11%;">UseFold</p>

<p style="margin-left:17%;">If you want to force
<small>YAML</small> to use the &rsquo;folded&rsquo; style
for all multiline scalars, then set <tt>$UseFold</tt> to
1.</p>

<p style="margin-left:17%; margin-top: 1em"><small>NOTE:
YAML</small> &rsquo;s folded style is akin to the way
<small>HTML</small> folds text, <br>
except smarter.</p>

<p style="margin-left:11%;">UseAliases</p>

<p style="margin-left:17%;"><small>YAML</small> has an
alias mechanism such that any given structure in memory gets
serialized once. Any other references to that structure are
serialized only as alias markers. This is how
<small>YAML</small> can serialize duplicate and recursive
structures.</p>

<p style="margin-left:17%; margin-top: 1em">Sometimes, when
you <small>KNOW</small> that your data is nonrecursive in
nature, you may want to serialize such that every node is
expressed in full. (ie as a copy of the original). Setting
<tt>$YAML::UseAliases</tt> to 0 will allow you to do this.
This also may result in faster processing because the lookup
overhead is by bypassed.</p>

<p style="margin-left:17%; margin-top: 1em"><small>THIS
OPTION CAN BE DANGEROUS.</small> *If* your data is
recursive, this option *will* cause <i>Dump()</i> to run in
an endless loop, chewing up your computers memory. You have
been warned.</p>

<p style="margin-left:11%;">CompressSeries</p>

<p style="margin-left:17%;">Default is 1.</p>

<p style="margin-left:17%; margin-top: 1em">Compresses the
formatting of arrays of hashes:</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;
      foo: bar
    &minus;
      bar: foo</pre>


<p style="margin-left:17%; margin-top: 1em">becomes:</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; foo: bar
    &minus; bar: foo</pre>


<p style="margin-left:17%; margin-top: 1em">Since this
output is usually more desirable, this option is turned on
by default.</p>

<h2>YAML TERMINOLOGY
<a name="YAML TERMINOLOGY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
is a full featured data serialization language, and thus has
its own terminology.</p>

<p style="margin-left:11%; margin-top: 1em">It is important
to remember that although <small>YAML</small> is heavily
influenced by Perl and Python, it is a language in its own
right, not merely just a representation of Perl
structures.</p>


<p style="margin-left:11%; margin-top: 1em"><small>YAML</small>
has three constructs that are conspicuously similar to
Perl&rsquo;s hash, array, and scalar. They are called
mapping, sequence, and string respectively. By default, they
do what you would expect. But each instance may have an
explicit or implicit tag (type) that makes it behave
differently. In this manner, <small>YAML</small> can be
extended to represent Perl&rsquo;s Glob or Python&rsquo;s
tuple, or Ruby&rsquo;s Bigint. <br>
stream</p>

<p style="margin-left:17%;">A <small>YAML</small> stream is
the full sequence of unicode characters that a
<small>YAML</small> parser would read or a
<small>YAML</small> emitter would write. A stream may
contain one or more <small>YAML</small> documents separated
by <small>YAML</small> headers.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;&minus;&minus;
    a: mapping
    foo: bar
    &minus;&minus;&minus;
    &minus; a
    &minus; sequence</pre>


<p style="margin-left:11%;">document</p>

<p style="margin-left:17%;">A <small>YAML</small> document
is an independent data structure representation within a
stream. It is a top level node. Each document in a
<small>YAML</small> stream must begin with a
<small>YAML</small> header line. Actually the header is
optional on the first document.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;&minus;&minus;
    This: top level mapping
    is:
        &minus; a
        &minus; YAML
        &minus; document</pre>


<p style="margin-left:11%;">header</p>

<p style="margin-left:17%;">A <small>YAML</small> header is
a line that begins a <small>YAML</small> document. It
consists of three dashes, possibly followed by more info.
Another purpose of the header line is that it serves as a
place to put top level tag and anchor information.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus;&minus;&minus; !recursive&minus;sequence &amp;001
    &minus; * 001
    &minus; * 001</pre>


<p style="margin-left:11%;">node</p>

<p style="margin-left:17%;">A <small>YAML</small> node is
the representation of a particular data stucture. Nodes may
contain other nodes. (In Perl terms, nodes are like scalars.
Strings, arrayrefs and hashrefs. But this refers to the
serialized format, not the in-memory structure.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>tag</p></td>
<td width="2%"></td>
<td width="83%">


<p>This is similar to a type. It indicates how a particular
<small>YAML</small> node serialization should be transferred
into or out of memory. For instance a Foo::Bar object would
use the tag &rsquo;perl/Foo::Bar&rsquo;:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">    &minus; !perl/Foo::Bar
        foo: 42
        bar: stool</pre>


<p style="margin-left:11%;">collection</p>

<p style="margin-left:17%;">A collection is the generic
term for a <small>YAML</small> data grouping.
<small>YAML</small> has two types of collections: mappings
and sequences. (Similar to hashes and arrays)</p>

<p style="margin-left:11%;">mapping</p>

<p style="margin-left:17%;">A mapping is a
<small>YAML</small> collection defined by unordered
key/value pairs with unique keys. By default
<small>YAML</small> mappings are loaded into Perl
hashes.</p>

<pre style="margin-left:17%; margin-top: 1em">    a mapping:
        foo: bar
        two: times two is 4</pre>


<p style="margin-left:11%;">sequence</p>

<p style="margin-left:17%;">A sequence is a
<small>YAML</small> collection defined by an ordered list of
elements. By default <small>YAML</small> sequences are
loaded into Perl arrays.</p>

<pre style="margin-left:17%; margin-top: 1em">    a sequence:
        &minus; one bourbon
        &minus; one scotch
        &minus; one beer</pre>


<p style="margin-left:11%;">scalar</p>

<p style="margin-left:17%;">A scalar is a
<small>YAML</small> node that is a single value. By default
<small>YAML</small> scalars are loaded into Perl
scalars.</p>

<pre style="margin-left:17%; margin-top: 1em">    a scalar key: a scalar value</pre>



<p style="margin-left:17%; margin-top: 1em"><small>YAML</small>
has many styles for representing scalars. This is important
because varying data will have varying formatting
requirements to retain the optimum human readability.</p>

<p style="margin-left:11%;">plain scalar</p>

<p style="margin-left:17%;">A plain scalar is unquoted. All
plain scalars are automatic candidates for &quot;implicit
tagging&quot;. This means that their tag may be determined
automatically by examination. The typical uses for this are
plain alpha strings, integers, real numbers, dates, times
and currency.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; a plain string
    &minus; &minus;42
    &minus; 3.1415
    &minus; 12:34
    &minus; 123 this is an error</pre>


<p style="margin-left:11%;">single quoted scalar</p>

<p style="margin-left:17%;">This is similar to Perl&rsquo;s
use of single quotes. It means no escaping except for single
quotes which are escaped by using two adjacent single
quotes.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; 'When I say ''\n'' I mean &quot;backslash en&quot;'</pre>


<p style="margin-left:11%;">double quoted scalar</p>

<p style="margin-left:17%;">This is similar to Perl&rsquo;s
use of double quotes. Character escaping can be used.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; &quot;This scalar\nhas two lines, and a bell &minus;&minus;&gt;\a&quot;</pre>


<p style="margin-left:11%;">folded scalar</p>

<p style="margin-left:17%;">This is a multiline scalar
which begins on the next line. It is indicated by a single
right angle bracket. It is unescaped like the single quoted
scalar. Line folding is also performed.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; &gt;
     This is a multiline scalar which begins on
     the next line. It is indicated by a single
     carat. It is unescaped like the single
     quoted scalar. Line folding is also
     performed.</pre>


<p style="margin-left:11%;">block scalar</p>

<p style="margin-left:17%;">This final multiline form is
akin to Perl&rsquo;s here-document except that (as in all
<small>YAML</small> data) scope is indicated by indentation.
Therefore, no ending marker is required. The data is
verbatim. No line folding.</p>

<pre style="margin-left:17%; margin-top: 1em">    &minus; |
        QTY  DESC          PRICE  TOTAL
        &minus;&minus;&minus;  &minus;&minus;&minus;&minus;          &minus;&minus;&minus;&minus;&minus;  &minus;&minus;&minus;&minus;&minus;
          1  Foo Fighters  $19.95 $19.95
          2  Bar Belles    $29.95 $59.90</pre>


<p style="margin-left:11%;">parser</p>

<p style="margin-left:17%;">A <small>YAML</small> processor
has four stages: parse, load, dump, emit.</p>

<p style="margin-left:17%; margin-top: 1em">A parser parses
a <small>YAML</small> stream. <small>YAML</small>
.pm&rsquo;s <i>Load()</i> function contains a parser.</p>

<p style="margin-left:11%;">loader</p>

<p style="margin-left:17%;">The other half of the
<i>Load()</i> function is a loader. This takes the
information from the parser and loads it into a Perl data
structure.</p>

<p style="margin-left:11%;">dumper</p>

<p style="margin-left:17%;">The <i>Dump()</i> function
consists of a dumper and an emitter. The dumper walks
through each Perl data structure and gives info to the
emitter.</p>

<p style="margin-left:11%;">emitter</p>

<p style="margin-left:17%;">The emitter takes info from the
dumper and turns it into a <small>YAML</small> stream.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
In <small>YAML</small> .pm the parser/loader and the
dumper/emitter code are currently very closely tied
together. In the future they may be broken into separate
stages.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information please refer to the immensely helpful
<small>YAML</small> specification available at
&lt;http://www.yaml.org/spec/&gt;.</p>

<h2>ysh &minus; The YAML Shell
<a name="ysh &minus; The YAML Shell"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>YAML</small> distribution ships with a script called
&rsquo;ysh&rsquo;, the <small>YAML</small> shell. ysh
provides a simple, interactive way to play with
<small>YAML.</small> If you type in Perl code, it displays
the result in <small>YAML.</small> If you type in
<small>YAML</small> it turns it into Perl code.</p>

<p style="margin-left:11%; margin-top: 1em">To run ysh,
(assuming you installed it along with <small>YAML</small>
.pm) simply type:</p>

<pre style="margin-left:11%; margin-top: 1em">    ysh [options]</pre>


<p style="margin-left:11%; margin-top: 1em">Please read the
<tt>&quot;ysh&quot;</tt> documentation for the full details.
There are lots of options.</p>

<h2>BUGS &amp; DEFICIENCIES
<a name="BUGS &amp; DEFICIENCIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you find a
bug in <small>YAML,</small> please try to recreate it in the
<small>YAML</small> Shell with logging turned on (&rsquo;ysh
&minus;L&rsquo;). When you have successfully reproduced the
bug, please mail the <small>LOG</small> file to the author
(ingy@cpan.org).</p>


<p style="margin-left:11%; margin-top: 1em"><small>WARNING:</small>
This is still *ALPHA* code. Well, most of this code has been
around for years...</p>

<p style="margin-left:11%; margin-top: 1em"><small>BIGGER
WARNING: YAML</small> .pm has been slow in the making, but I
am committed to having top notch <small>YAML</small> tools
in the Perl world. The <small>YAML</small> team is close to
finalizing the <small>YAML 1.1</small> spec. This version of
<small>YAML</small> .pm is based off of a very old pre 1.0
spec. In actuality there isn&rsquo;t a ton of difference,
and this <small>YAML</small> .pm is still fairly useful.
Things will get much better in the future.</p>

<h2>RESOURCES
<a name="RESOURCES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&lt;http://lists.sourceforge.net/lists/listinfo/yaml&minus;core&gt;
is the mailing list. This is where the language is discussed
and designed.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://www.yaml.org&gt;
is the official <small>YAML</small> website.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://www.yaml.org/spec/&gt;
is the <small>YAML 1.0</small> specification.</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://yaml.kwiki.org&gt;
is the official <small>YAML</small> wiki.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<small>YAML::XS.</small> Fast!</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Ingy doet Net
&lt;ingy@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">is resonsible
for <small>YAML</small> .pm.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>YAML</small> serialization language is the result of
years of collaboration between Oren Ben-Kiki, Clark Evans
and Ingy doet Net. Several others have added help along the
way.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2005, 2006, 2008, 2011&minus;2012. Ingy doet Net.</p>

<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2001, 2002, 2005. Brian Ingerson.</p>

<p style="margin-left:11%; margin-top: 1em">Some parts
copyright (c) 2009 &minus; 2010 Adam Kennedy</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">See
&lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
<hr>
</body>
</html>
