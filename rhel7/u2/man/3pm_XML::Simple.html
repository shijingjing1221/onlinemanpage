<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:49:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XML::Simple</title>

</head>
<body>

<h1 align="center">XML::Simple</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#STATUS OF THIS MODULE">STATUS OF THIS MODULE</a><br>
<a href="#QUICK START">QUICK START</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#OPTIONAL OO INTERFACE">OPTIONAL OO INTERFACE</a><br>
<a href="#STRICT MODE">STRICT MODE</a><br>
<a href="#SAX SUPPORT">SAX SUPPORT</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#ERROR HANDLING">ERROR HANDLING</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#WHERE TO FROM HERE?">WHERE TO FROM HERE?</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::Simple
&minus; Easily read/write XML (esp config files)</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use XML::Simple qw(:strict);
    my $ref = XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);
    my $xml = XMLout($hashref [, &lt;options&gt;]);</pre>


<p style="margin-left:11%; margin-top: 1em">Or the object
oriented way:</p>

<pre style="margin-left:11%; margin-top: 1em">    require XML::Simple qw(:strict);
    my $xs = XML::Simple&minus;&gt;new([&lt;options&gt;]);
    my $ref = $xs&minus;&gt;XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);
    my $xml = $xs&minus;&gt;XMLout($hashref [, &lt;options&gt;]);</pre>


<p style="margin-left:11%; margin-top: 1em">(or see &quot;
<small>SAX SUPPORT&quot;</small> for &rsquo;the
<small>SAX</small> way&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">Note, in these
examples, the square brackets are used to denote optional
items not to imply items should be supplied in
arrayrefs.</p>

<h2>STATUS OF THIS MODULE
<a name="STATUS OF THIS MODULE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The use of this
module in new code is discouraged. Other modules are
available which provide more straightforward and consistent
interfaces. In particular, XML::LibXML is highly
recommended.</p>

<p style="margin-left:11%; margin-top: 1em">The major
problems with this module are the large number of options
and the arbitrary ways in which these options interact
&minus; often with unexpected results.</p>

<p style="margin-left:11%; margin-top: 1em">Patches with
bug fixes and documentation fixes are welcome, but new
features are unlikely to be added.</p>

<h2>QUICK START
<a name="QUICK START"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Say you have a
script called <b>foo</b> and a file of configuration options
called <b>foo.xml</b> containing the following:</p>

<pre style="margin-left:11%; margin-top: 1em">  &lt;config logdir=&quot;/var/log/foo/&quot; debugfile=&quot;/tmp/foo.debug&quot;&gt;
    &lt;server name=&quot;sahara&quot; osname=&quot;solaris&quot; osversion=&quot;2.6&quot;&gt;
      &lt;address&gt;10.0.0.101&lt;/address&gt;
      &lt;address&gt;10.0.1.101&lt;/address&gt;
    &lt;/server&gt;
    &lt;server name=&quot;gobi&quot; osname=&quot;irix&quot; osversion=&quot;6.5&quot;&gt;
      &lt;address&gt;10.0.0.102&lt;/address&gt;
    &lt;/server&gt;
    &lt;server name=&quot;kalahari&quot; osname=&quot;linux&quot; osversion=&quot;2.0.34&quot;&gt;
      &lt;address&gt;10.0.0.103&lt;/address&gt;
      &lt;address&gt;10.0.1.103&lt;/address&gt;
    &lt;/server&gt;
  &lt;/config&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">The following
lines of code in <b>foo</b>:</p>

<pre style="margin-left:11%; margin-top: 1em">  use XML::Simple qw(:strict);
  my $config = XMLin(undef, KeyAttr =&gt; { server =&gt; 'name' }, ForceArray =&gt; [ 'server', 'address' ]);</pre>


<p style="margin-left:11%; margin-top: 1em">will
&rsquo;slurp&rsquo; the configuration options into the
hashref <tt>$config</tt> (because no filename or
<small>XML</small> string was passed as the first argument
to <tt>&quot;XMLin()&quot;</tt> the name and location of the
<small>XML</small> file will be inferred from name and
location of the script). You can dump out the contents of
the hashref using Data::Dumper:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Data::Dumper;
  print Dumper($config);</pre>


<p style="margin-left:11%; margin-top: 1em">which will
produce something like this (formatting has been adjusted
for brevity):</p>

<pre style="margin-left:11%; margin-top: 1em">  {
      'logdir'        =&gt; '/var/log/foo/',
      'debugfile'     =&gt; '/tmp/foo.debug',
      'server'        =&gt; {
          'sahara'        =&gt; {
              'osversion'     =&gt; '2.6',
              'osname'        =&gt; 'solaris',
              'address'       =&gt; [ '10.0.0.101', '10.0.1.101' ]
          },
          'gobi'          =&gt; {
              'osversion'     =&gt; '6.5',
              'osname'        =&gt; 'irix',
              'address'       =&gt; [ '10.0.0.102' ]
          },
          'kalahari'      =&gt; {
              'osversion'     =&gt; '2.0.34',
              'osname'        =&gt; 'linux',
              'address'       =&gt; [ '10.0.0.103', '10.0.1.103' ]
          }
      }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Your script
could then access the name of the log directory like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">  print $config&minus;&gt;{logdir};</pre>


<p style="margin-left:11%; margin-top: 1em">similarly, the
second address on the server &rsquo;kalahari&rsquo; could be
referenced as:</p>

<pre style="margin-left:11%; margin-top: 1em">  print $config&minus;&gt;{server}&minus;&gt;{kalahari}&minus;&gt;{address}&minus;&gt;[1];</pre>


<p style="margin-left:11%; margin-top: 1em">Note: If the
mapping between the output of Data::Dumper and the print
statements above is not obvious to you, then please refer to
the &rsquo;references&rsquo; tutorial ( <small>AKA:</small>
&quot;Mark&rsquo;s very short tutorial about
references&quot;) at perlreftut.</p>

<p style="margin-left:11%; margin-top: 1em">In this
example, the <tt>&quot;ForceArray&quot;</tt> option was used
to list elements that might occur multiple times and should
therefore be represented as arrayrefs (even when only one
element is present).</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;KeyAttr&quot;</tt> option was used to indicate
that each <tt>&quot;&lt;server&gt;&quot;</tt> element has a
unique identifier in the <tt>&quot;name&quot;</tt>
attribute. This allows you to index directly to a particular
server record using the name as a hash key (as shown
above).</p>

<p style="margin-left:11%; margin-top: 1em">For simple
requirements, that&rsquo;s really all there is to it. If you
want to store your <small>XML</small> in a different
directory or file, or pass it in as a string or even pass it
in via some derivative of an IO::Handle, you&rsquo;ll need
to check out &quot; <small>OPTIONS&quot;</small> . If you
want to turn off or tweak the array folding feature (that
neat little transformation that produced
<tt>$config</tt>&minus;&gt;{server}) you&rsquo;ll find
options for that as well.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
generate <small>XML</small> (for example to write a modified
version of <tt>$config</tt> back out as <small>XML</small>
), check out <tt>&quot;XMLout()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If your needs
are not so simple, this may not be the module for you. In
that case, you might want to read &quot; <small>WHERE TO
FROM HERE</small> ?&quot;.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The XML::Simple
module provides a simple <small>API</small> layer on top of
an underlying <small>XML</small> parsing module (either
XML::Parser or one of the <small>SAX2</small> parser
modules). Two functions are exported:
<tt>&quot;XMLin()&quot;</tt> and
<tt>&quot;XMLout()&quot;</tt>. Note: you can explicity
request the lower case versions of the function names:
<tt>&quot;xml_in()&quot;</tt> and
<tt>&quot;xml_out()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The simplest
approach is to call these two functions directly, but an
optional object oriented interface (see &quot;
<small>OPTIONAL OO INTERFACE&quot;</small> below) allows
them to be called as methods of an <b>XML::Simple</b>
object. The object interface can also be used at either end
of a <small>SAX</small> pipeline.</p>

<p style="margin-left:11%; margin-top: 1em"><i>XMLin()</i>
<br>
Parses <small>XML</small> formatted data and returns a
reference to a data structure which contains the same
information in a more readily accessible form. (Skip down to
&quot; <small>EXAMPLES&quot;</small> below, for more sample
code).</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;XMLin()&quot;</tt>
accepts an optional <small>XML</small> specifier followed by
zero or more &rsquo;name =&gt; value&rsquo; option pairs.
The <small>XML</small> specifier can be one of the
following: <br>
A filename</p>

<p style="margin-left:17%;">If the filename contains no
directory components <tt>&quot;XMLin()&quot;</tt> will look
for the file in each directory in the SearchPath (see &quot;
<small>OPTIONS&quot;</small> below) or in the current
directory if the SearchPath option is not defined. eg:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ref = XMLin('/etc/params.xml');</pre>


<p style="margin-left:17%; margin-top: 1em">Note, the
filename &rsquo;&minus;&rsquo; can be used to parse from
<small>STDIN.</small></p>

<p style="margin-left:11%;">undef</p>

<p style="margin-left:17%;">If there is no
<small>XML</small> specifier, <tt>&quot;XMLin()&quot;</tt>
will check the script directory and each of the SearchPath
directories for a file with the same name as the script but
with the extension &rsquo;.xml&rsquo;. Note: if you wish to
specify options, you must specify the value
&rsquo;undef&rsquo;. eg:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ref = XMLin(undef, ForceArray =&gt; 1);</pre>


<p style="margin-left:11%;">A string of
<small>XML</small></p>

<p style="margin-left:17%;">A string containing
<small>XML</small> (recognised by the presence of
&rsquo;&lt;&rsquo; and &rsquo;&gt;&rsquo; characters) will
be parsed directly. eg:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ref = XMLin('&lt;opt username=&quot;bob&quot; password=&quot;flurp&quot; /&gt;');</pre>


<p style="margin-left:11%;">An IO::Handle object</p>

<p style="margin-left:17%;">An IO::Handle object will be
read to <small>EOF</small> and its contents parsed. eg:</p>

<pre style="margin-left:17%; margin-top: 1em">  $fh = IO::File&minus;&gt;new('/etc/params.xml');
  $ref = XMLin($fh);</pre>



<p style="margin-left:11%; margin-top: 1em"><i>XMLout()</i>
<br>
Takes a data structure (generally a hashref) and returns an
<small>XML</small> encoding of that structure. If the
resulting <small>XML</small> is parsed using
<tt>&quot;XMLin()&quot;</tt>, it should return a data
structure equivalent to the original (see caveats
below).</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;XMLout()&quot;</tt> function can also be used to
output the <small>XML</small> as <small>SAX</small> events
see the <tt>&quot;Handler&quot;</tt> option and &quot;
<small>SAX SUPPORT&quot;</small> for more details).</p>

<p style="margin-left:11%; margin-top: 1em">When
translating hashes to <small>XML,</small> hash keys which
have a leading &rsquo;&minus;&rsquo; will be silently
skipped. This is the approved method for marking elements of
a data structure which should be ignored by
<tt>&quot;XMLout&quot;</tt>. (Note: If these items were not
skipped the key names would be emitted as element or
attribute names with a leading &rsquo;&minus;&rsquo; which
would not be valid <small>XML</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Caveats</b>
<br>
Some care is required in creating data structures which will
be passed to <tt>&quot;XMLout()&quot;</tt>. Hash keys from
the data structure will be encoded as either
<small>XML</small> element names or attribute names.
Therefore, you should use hash key names which conform to
the relatively strict <small>XML</small> naming rules:</p>

<p style="margin-left:11%; margin-top: 1em">Names in
<small>XML</small> must begin with a letter. The remaining
characters may be letters, digits, hyphens (&minus;),
underscores (_) or full stops (.). It is also allowable to
include one colon (:) in an element name but this should
only be used when working with namespaces
(<b>XML::Simple</b> can only usefully work with namespaces
when teamed with a <small>SAX</small> Parser).</p>

<p style="margin-left:11%; margin-top: 1em">You can use
other punctuation characters in hash values (just not in
hash keys) however <b>XML::Simple</b> does not support
dumping binary data.</p>

<p style="margin-left:11%; margin-top: 1em">If you break
these rules, the current implementation of
<tt>&quot;XMLout()&quot;</tt> will simply emit non-compliant
<small>XML</small> which will be rejected if you try to read
it back in. (A later version of <b>XML::Simple</b> might
take a more proactive approach).</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
although you can nest hashes and arrays to arbitrary levels,
circular data structures are not supported and will cause
<tt>&quot;XMLout()&quot;</tt> to die.</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
&rsquo;round&minus;trip&rsquo; arbitrary data structures
from Perl to <small>XML</small> and back to Perl, then you
should probably disable array folding (using the KeyAttr
option) both with <tt>&quot;XMLout()&quot;</tt> and with
<tt>&quot;XMLin()&quot;</tt>. If you still don&rsquo;t get
the expected results, you may prefer to use XML::Dumper
which is designed for exactly that purpose.</p>

<p style="margin-left:11%; margin-top: 1em">Refer to &quot;
<small>WHERE TO FROM HERE</small> ?&quot; if
<tt>&quot;XMLout()&quot;</tt> is too simple for your
needs.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XML::Simple</b>
supports a number of options (in fact as each release of
<b>XML::Simple</b> adds more options, the module&rsquo;s
claim to the name &rsquo;Simple&rsquo; becomes increasingly
tenuous). If you find yourself repeatedly having to specify
the same options, you might like to investigate &quot;
<small>OPTIONAL OO INTERFACE&quot;</small> below.</p>

<p style="margin-left:11%; margin-top: 1em">If you
can&rsquo;t be bothered reading the documentation, refer to
&quot; <small>STRICT MODE&quot;</small> to automatically
catch common mistakes.</p>

<p style="margin-left:11%; margin-top: 1em">Because there
are so many options, it&rsquo;s hard for new users to know
which ones are important, so here are the two you really
need to know about:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>check out <tt>&quot;ForceArray&quot;</tt> because
you&rsquo;ll almost certainly want to turn it on</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>make sure you know what the <tt>&quot;KeyAttr&quot;</tt>
option does and what its default value is because it may
surprise you otherwise (note in particular that
&rsquo;KeyAttr&rsquo; affects both
<tt>&quot;XMLin&quot;</tt> and
<tt>&quot;XMLout&quot;</tt>)</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The option name
headings below have a trailing &rsquo;comment&rsquo; &minus;
a hash followed by two pieces of metadata:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Options are marked with
&rsquo;<i>in</i>&rsquo; if they are recognised by
<tt>&quot;XMLin()&quot;</tt> and &rsquo;<i>out</i>&rsquo; if
they are recognised by <tt>&quot;XMLout()&quot;</tt>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Each option is also flagged to indicate whether it
is:</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> 'important'   &minus; don't use the module until you understand this one
 'handy'       &minus; you can skip this on the first time through
 'advanced'    &minus; you can skip this on the second time through
 'SAX only'    &minus; don't worry about this unless you're using SAX (or
                 alternatively if you need this, you also need SAX)
 'seldom used' &minus; you'll probably never use this unless you were the
                 person that requested the feature</pre>


<p style="margin-left:11%; margin-top: 1em">The options are
listed alphabetically:</p>

<p style="margin-left:11%; margin-top: 1em">Note: option
names are no longer case sensitive so you can use the mixed
case versions shown here; all lower case as required by
versions 2.03 and earlier; or you can add underscores
between the words (eg: key_attr).</p>

<p style="margin-left:11%; margin-top: 1em"><b>AttrIndent
=&gt; 1</b> <i># out &minus; handy</i> <br>
When you are using <tt>&quot;XMLout()&quot;</tt>, enable
this option to have attributes printed one-per-line with
sensible indentation rather than all on one line.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache =&gt;
[ cache schemes ]</b> <i># in &minus; advanced</i> <br>
Because loading the <b>XML::Parser</b> module and parsing an
<small>XML</small> file can consume a significant number of
<small>CPU</small> cycles, it is often desirable to cache
the output of <tt>&quot;XMLin()&quot;</tt> for later
reuse.</p>

<p style="margin-left:11%; margin-top: 1em">When parsing
from a named file, <b>XML::Simple</b> supports a number of
caching schemes. The &rsquo;Cache&rsquo; option may be used
to specify one or more schemes (using an anonymous array).
Each scheme will be tried in turn in the hope of finding a
cached pre-parsed representation of the <small>XML</small>
file. If no cached copy is found, the file will be parsed
and the first cache scheme in the list will be used to save
a copy of the results. The following cache schemes have been
implemented: <br>
storable</p>

<p style="margin-left:17%;">Utilises <b>Storable.pm</b> to
read/write a cache file with the same name as the
<small>XML</small> file but with the extension .stor</p>

<p style="margin-left:11%;">memshare</p>

<p style="margin-left:17%;">When a file is first parsed, a
copy of the resulting data structure is retained in memory
in the <b>XML::Simple</b> module&rsquo;s namespace.
Subsequent calls to parse the same file will return a
reference to this structure. This cached version will
persist only for the life of the Perl interpreter (which in
the case of mod_perl for example, may be some significant
time).</p>

<p style="margin-left:17%; margin-top: 1em">Because each
caller receives a reference to the same data structure, a
change made by one caller will be visible to all. For this
reason, the reference returned should be treated as
read-only.</p>

<p style="margin-left:11%;">memcopy</p>

<p style="margin-left:17%;">This scheme works identically
to &rsquo;memshare&rsquo; (above) except that each caller
receives a reference to a new data structure which is a copy
of the cached version. Copying the data structure will add a
little processing overhead, therefore this scheme should
only be used where the caller intends to modify the data
structure (or wishes to protect itself from others who
might). This scheme uses <b>Storable.pm</b> to perform the
copy.</p>

<p style="margin-left:11%; margin-top: 1em">Warning! The
memory-based caching schemes compare the timestamp on the
file to the time when it was last parsed. If the file is
stored on an <small>NFS</small> filesystem (or other network
share) and the clock on the file server is not exactly
synchronised with the clock where your script is run,
updates to the source <small>XML</small> file may appear to
be ignored.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ContentKey
=&gt; &rsquo;keyname&rsquo;</b> <i># in+out &minus; seldom
used</i> <br>
When text content is parsed to a hash value, this option
let&rsquo;s you specify a name for the hash key to override
the default &rsquo;content&rsquo;. So for example:</p>

<pre style="margin-left:11%; margin-top: 1em">  XMLin('&lt;opt one=&quot;1&quot;&gt;Text&lt;/opt&gt;', ContentKey =&gt; 'text')</pre>


<p style="margin-left:11%; margin-top: 1em">will parse
to:</p>

<pre style="margin-left:11%; margin-top: 1em">  { 'one' =&gt; 1, 'text' =&gt; 'Text' }</pre>


<p style="margin-left:11%; margin-top: 1em">instead of:</p>

<pre style="margin-left:11%; margin-top: 1em">  { 'one' =&gt; 1, 'content' =&gt; 'Text' }</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;XMLout()&quot;
will also honour the value of this option when converting a
hashref to <small>XML.</small></p>

<p style="margin-left:11%; margin-top: 1em">You can also
prefix your selected key name with a &rsquo;&minus;&rsquo;
character to have <tt>&quot;XMLin()&quot;</tt> try a little
harder to eliminate unnecessary &rsquo;content&rsquo; keys
after array folding. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  XMLin(
    '&lt;opt&gt;&lt;item name=&quot;one&quot;&gt;First&lt;/item&gt;&lt;item name=&quot;two&quot;&gt;Second&lt;/item&gt;&lt;/opt&gt;',
    KeyAttr =&gt; {item =&gt; 'name'},
    ForceArray =&gt; [ 'item' ],
    ContentKey =&gt; '&minus;content'
  )</pre>


<p style="margin-left:11%; margin-top: 1em">will parse
to:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    'item' =&gt; {
      'one' =&gt;  'First'
      'two' =&gt;  'Second'
    }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">rather than
this (without the &rsquo;&minus;&rsquo;):</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    'item' =&gt; {
      'one' =&gt; { 'content' =&gt; 'First' }
      'two' =&gt; { 'content' =&gt; 'Second' }
    }
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>DataHandler
=&gt; code_ref</b> <i># in &minus; <small>SAX</small>
only</i> <br>
When you use an <b>XML::Simple</b> object as a
<small>SAX</small> handler, it will return a &rsquo;simple
tree&rsquo; data structure in the same format as
<tt>&quot;XMLin()&quot;</tt> would return. If this option is
set (to a subroutine reference), then when the tree is built
the subroutine will be called and passed two arguments: a
reference to the <b>XML::Simple</b> object and a reference
to the data tree. The return value from the subroutine will
be returned to the <small>SAX</small> driver. (See &quot;
<small>SAX SUPPORT&quot;</small> for more details).</p>

<p style="margin-left:11%; margin-top: 1em"><b>ForceArray
=&gt; 1</b> <i># in &minus; important</i> <br>
This option should be set to &rsquo;1&rsquo; to force nested
elements to be represented as arrays even when there is only
one. Eg, with ForceArray enabled, this
<small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;name&gt;value&lt;/name&gt;
    &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">would parse to
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'name' =&gt; [
                  'value'
                ]
    }</pre>


<p style="margin-left:11%; margin-top: 1em">instead of this
(the default):</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'name' =&gt; 'value'
    }</pre>


<p style="margin-left:11%; margin-top: 1em">This option is
especially useful if the data structure is likely to be
written back out as <small>XML</small> and the default
behaviour of rolling single nested elements up into
attributes is not desirable.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using the array folding feature, you should almost certainly
enable this option. If you do not, single nested elements
will not be parsed to arrays and therefore will not be
candidates for folding to a hash. (Given that the default
value of &rsquo;KeyAttr&rsquo; enables array folding, the
default value of this option should probably also have been
enabled too &minus; sorry).</p>

<p style="margin-left:11%; margin-top: 1em"><b>ForceArray
=&gt; [ names ]</b> <i># in &minus; important</i> <br>
This alternative (and preferred) form of the
&rsquo;ForceArray&rsquo; option allows you to specify a list
of element names which should always be forced into an array
representation, rather than the &rsquo;all or nothing&rsquo;
approach above.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible (since version 2.05) to include compiled regular
expressions in the list &minus; any element names which
match the pattern will be forced to arrays. If the list
contains only a single regex, then it is not necessary to
enclose it in an arrayref. Eg:</p>

<pre style="margin-left:11%; margin-top: 1em">  ForceArray =&gt; qr/_list$/</pre>



<p style="margin-left:11%; margin-top: 1em"><b>ForceContent
=&gt; 1</b> <i># in &minus; seldom used</i> <br>
When <tt>&quot;XMLin()&quot;</tt> parses elements which have
text content as well as attributes, the text content must be
represented as a hash value rather than a simple scalar.
This option allows you to force text content to always parse
to a hash value even when there are no attributes. So for
example:</p>

<pre style="margin-left:11%; margin-top: 1em">  XMLin('&lt;opt&gt;&lt;x&gt;text1&lt;/x&gt;&lt;y a=&quot;2&quot;&gt;text2&lt;/y&gt;&lt;/opt&gt;', ForceContent =&gt; 1)</pre>


<p style="margin-left:11%; margin-top: 1em">will parse
to:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    'x' =&gt; {           'content' =&gt; 'text1' },
    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">instead of:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    'x' =&gt; 'text1',
    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>GroupTags
=&gt; { grouping tag =&gt; grouped tag }</b> <i># in+out
&minus; handy</i> <br>
You can use this option to eliminate extra levels of
indirection in your Perl data structure. For example this
<small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">  &lt;opt&gt;
   &lt;searchpath&gt;
     &lt;dir&gt;/usr/bin&lt;/dir&gt;
     &lt;dir&gt;/usr/local/bin&lt;/dir&gt;
     &lt;dir&gt;/usr/X11/bin&lt;/dir&gt;
   &lt;/searchpath&gt;
 &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Would normally
be read into a structure like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    searchpath =&gt; {
                    dir =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
                  }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">But when read
in with the appropriate value for
&rsquo;GroupTags&rsquo;:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $opt = XMLin($xml, GroupTags =&gt; { searchpath =&gt; 'dir' });</pre>


<p style="margin-left:11%; margin-top: 1em">It will return
this simpler structure:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    searchpath =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The grouping
element (<tt>&quot;&lt;searchpath&gt;&quot;</tt> in the
example) must not contain any attributes or elements other
than the grouped element.</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
multiple &rsquo;grouping element&rsquo; to &rsquo;grouped
element&rsquo; mappings in the same hashref. If this option
is combined with <tt>&quot;KeyAttr&quot;</tt>, the array
folding will occur first and then the grouped element names
will be eliminated.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;XMLout&quot;</tt>
will also use the grouptag mappings to re-introduce the tags
around the grouped elements. Beware though that this will
occur in all places that the &rsquo;grouping tag&rsquo; name
occurs &minus; you probably don&rsquo;t want to use the same
name for elements as well as attributes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Handler
=&gt; object_ref</b> <i># out &minus; <small>SAX</small>
only</i> <br>
Use the &rsquo;Handler&rsquo; option to have
<tt>&quot;XMLout()&quot;</tt> generate <small>SAX</small>
events rather than returning a string of <small>XML.</small>
For more details see &quot; <small>SAX SUPPORT&quot;</small>
below.</p>

<p style="margin-left:11%; margin-top: 1em">Note: the
current implementation of this option generates a string of
<small>XML</small> and uses a <small>SAX</small> parser to
translate it into <small>SAX</small> events. The normal
encoding rules apply here &minus; your data must be
<small>UTF8</small> encoded unless you specify an
alternative encoding via the &rsquo;XMLDecl&rsquo; option;
and by the time the data reaches the handler object, it will
be in <small>UTF8</small> form regardless of the encoding
you supply. A future implementation of this option may
generate the events directly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KeepRoot
=&gt; 1</b> <i># in+out &minus; handy</i> <br>
In its attempt to return a data structure free of
superfluous detail and unnecessary levels of indirection,
<tt>&quot;XMLin()&quot;</tt> normally discards the root
element name. Setting the &rsquo;KeepRoot&rsquo; option to
&rsquo;1&rsquo; will cause the root element name to be
retained. So after executing this code:</p>

<pre style="margin-left:11%; margin-top: 1em">  $config = XMLin('&lt;config tempdir=&quot;/tmp&quot; /&gt;', KeepRoot =&gt; 1)</pre>


<p style="margin-left:11%; margin-top: 1em">You&rsquo;ll be
able to reference the tempdir as
<tt>&quot;$config&minus;&gt;{config}&minus;&gt;{tempdir}&quot;</tt>
instead of the default
<tt>&quot;$config&minus;&gt;{tempdir}&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
setting the &rsquo;KeepRoot&rsquo; option to &rsquo;1&rsquo;
will tell <tt>&quot;XMLout()&quot;</tt> that the data
structure already contains a root element name and it is not
necessary to add another.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KeyAttr
=&gt; [ list ]</b> <i># in+out &minus; important</i> <br>
This option controls the &rsquo;array folding&rsquo; feature
which translates nested elements from an array to a hash. It
also controls the &rsquo;unfolding&rsquo; of hashes to
arrays.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
this <small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;
      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;
    &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">would, by
default, parse to this:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'user' =&gt; [
                  {
                    'login' =&gt; 'grep',
                    'fullname' =&gt; 'Gary R Epstein'
                  },
                  {
                    'login' =&gt; 'stty',
                    'fullname' =&gt; 'Simon T Tyson'
                  }
                ]
    }</pre>


<p style="margin-left:11%; margin-top: 1em">If the option
&rsquo;KeyAttr =&gt; &quot;login&quot;&rsquo; were used to
specify that the &rsquo;login&rsquo; attribute is a key, the
same <small>XML</small> would parse to:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein'
                            }
                }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The key
attribute names should be supplied in an arrayref if there
is more than one. <tt>&quot;XMLin()&quot;</tt> will attempt
to match attribute names in the order supplied.
<tt>&quot;XMLout()&quot;</tt> will use the first attribute
name supplied when &rsquo;unfolding&rsquo; a hash into an
array.</p>

<p style="margin-left:11%; margin-top: 1em">Note 1: The
default value for &rsquo;KeyAttr&rsquo; is
[&rsquo;name&rsquo;, &rsquo;key&rsquo;, &rsquo;id&rsquo;].
If you do not want folding on input or unfolding on output
you must set this option to an empty list to disable the
feature.</p>

<p style="margin-left:11%; margin-top: 1em">Note 2: If you
wish to use this option, you should also enable the
<tt>&quot;ForceArray&quot;</tt> option. Without
&rsquo;ForceArray&rsquo;, a single nested element will be
rolled up into a scalar rather than an array and therefore
will not be folded (since only arrays get folded).</p>

<p style="margin-left:11%; margin-top: 1em"><b>KeyAttr
=&gt; { list }</b> <i># in+out &minus; important</i> <br>
This alternative (and preferred) method of specifiying the
key attributes allows more fine grained control over which
elements are folded and on which attributes. For example the
option &rsquo;KeyAttr =&gt; { package =&gt; &rsquo;id&rsquo;
} will cause any package elements to be folded on the
&rsquo;id&rsquo; attribute. No other elements which have an
&rsquo;id&rsquo; attribute will be folded at all.</p>

<p style="margin-left:11%; margin-top: 1em">Note:
<tt>&quot;XMLin()&quot;</tt> will generate a warning (or a
fatal error in &quot; <small>STRICT MODE&quot;</small> ) if
this syntax is used and an element which does not have the
specified key attribute is encountered (eg: a
&rsquo;package&rsquo; element without an &rsquo;id&rsquo;
attribute, to use the example above). Warnings will only be
generated if <b>&minus;w</b> is in force.</p>

<p style="margin-left:11%; margin-top: 1em">Two further
variations are made possible by prefixing a &rsquo;+&rsquo;
or a &rsquo;&minus;&rsquo; character to the attribute
name:</p>

<p style="margin-left:11%; margin-top: 1em">The option
&rsquo;KeyAttr =&gt; { user =&gt; &quot;+login&quot;
}&rsquo; will cause this <small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;
      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;
    &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">to parse to
this data structure:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson',
                              'login'    =&gt; 'stty'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein',
                              'login'    =&gt; 'grep'
                            }
                }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
&rsquo;+&rsquo; indicates that the value of the key
attribute should be copied rather than moved to the folded
hash key.</p>

<p style="margin-left:11%; margin-top: 1em">A
&rsquo;&minus;&rsquo; prefix would produce this result:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson',
                              '&minus;login'    =&gt; 'stty'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein',
                              '&minus;login'    =&gt; 'grep'
                            }
                }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">As described
earlier, <tt>&quot;XMLout&quot;</tt> will ignore hash keys
starting with a &rsquo;&minus;&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NoAttr =&gt;
1</b> <i># in+out &minus; handy</i> <br>
When used with <tt>&quot;XMLout()&quot;</tt>, the generated
<small>XML</small> will contain no attributes. All hash
key/values will be represented as nested elements
instead.</p>

<p style="margin-left:11%; margin-top: 1em">When used with
<tt>&quot;XMLin()&quot;</tt>, any attributes in the
<small>XML</small> will be ignored.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NoEscape
=&gt; 1</b> <i># out &minus; seldom used</i> <br>
By default, <tt>&quot;XMLout()&quot;</tt> will translate the
characters &rsquo;&lt;&rsquo;, &rsquo;&gt;&rsquo;,
&rsquo;&amp;&rsquo; and &rsquo;&quot;&rsquo; to
&rsquo;&amp;lt;&rsquo;, &rsquo;&amp;gt;&rsquo;,
&rsquo;&amp;amp;&rsquo; and &rsquo;&amp;quot&rsquo;
respectively. Use this option to suppress escaping
(presumably because you&rsquo;ve already escaped the data in
some more sophisticated manner).</p>

<p style="margin-left:11%; margin-top: 1em"><b>NoIndent
=&gt; 1</b> <i># out &minus; seldom used</i> <br>
Set this option to 1 to disable
<tt>&quot;XMLout()&quot;</tt>&rsquo;s default &rsquo;pretty
printing&rsquo; mode. With this option enabled, the
<small>XML</small> output will all be on one line (unless
there are newlines in the data) &minus; this may be easier
for downstream processing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NoSort =&gt;
1</b> <i># out &minus; seldom used</i> <br>
Newer versions of XML::Simple sort elements and attributes
alphabetically (*), by default. Enable this option to
suppress the sorting &minus; possibly for backwards
compatibility.</p>

<p style="margin-left:11%; margin-top: 1em">* Actually,
sorting is alphabetical but &rsquo;key&rsquo; attribute or
element names (as in &rsquo;KeyAttr&rsquo;) sort first.
Also, when a hash of hashes is &rsquo;unfolded&rsquo;, the
elements are sorted alphabetically by the value of the key
field.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NormaliseSpace
=&gt; 0 | 1 | 2</b> <i># in &minus; handy</i> <br>
This option controls how whitespace in text content is
handled. Recognised values for the option are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>0 = (default) whitespace is passed through unaltered
(except of course for the normalisation of whitespace in
attribute values which is mandated by the <small>XML</small>
recommendation)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>1 = whitespace is normalised in any value used as a hash
key (normalising means removing leading and trailing
whitespace and collapsing sequences of whitespace characters
to a single space)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>2 = whitespace is normalised in all text content</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note: you can
spell this option with a &rsquo;z&rsquo; if that is more
natural for you.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NSExpand
=&gt; 1</b> <i># in+out handy &minus; <small>SAX</small>
only</i> <br>
This option controls namespace expansion &minus; the
translation of element and attribute names of the form
&rsquo;prefix:name&rsquo; to &rsquo;{uri}name&rsquo;. For
example the element name &rsquo;xsl:template&rsquo; might be
expanded to:
&rsquo;{http://www.w3.org/1999/XSL/Transform}template&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
<tt>&quot;XMLin()&quot;</tt> will return element names and
attribute names exactly as they appear in the
<small>XML.</small> Setting this option to 1 will cause all
element and attribute names to be expanded to include their
namespace prefix.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note: You
must be using a <small>SAX</small> parser for this option to
work (ie: it does not work with XML::Parser)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This option
also controls whether <tt>&quot;XMLout()&quot;</tt> performs
the reverse translation from &rsquo;{uri}name&rsquo; back to
&rsquo;prefix:name&rsquo;. The default is no translation. If
your data contains expanded names, you should set this
option to 1 otherwise <tt>&quot;XMLout&quot;</tt> will emit
<small>XML</small> which is not well formed.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note: You
must have the XML::NamespaceSupport module installed if you
want &quot;XMLout()&quot; to translate URIs back to
prefixes</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NumericEscape
=&gt; 0 | 1 | 2</b> <i># out &minus; handy</i> <br>
Use this option to have &rsquo;high&rsquo; (non-ASCII)
characters in your Perl data structure converted to numeric
entities (eg: &amp;#8364;) in the <small>XML</small> output.
Three levels are possible:</p>

<p style="margin-left:11%; margin-top: 1em">0 &minus;
default: no numeric escaping ( <small>OK</small> if
you&rsquo;re writing out <small>UTF8</small> )</p>

<p style="margin-left:11%; margin-top: 1em">1 &minus; only
characters above 0xFF are escaped (ie: characters in the
0x80&minus;FF range are not escaped), possibly useful with
<small>ISO8859&minus;1</small> output</p>

<p style="margin-left:11%; margin-top: 1em">2 &minus; all
characters above 0x7F are escaped (good for plain
<small>ASCII</small> output)</p>

<p style="margin-left:11%; margin-top: 1em"><b>OutputFile
=&gt; &lt;file specifier&gt;</b> <i># out &minus; handy</i>
<br>
The default behaviour of <tt>&quot;XMLout()&quot;</tt> is to
return the <small>XML</small> as a string. If you wish to
write the <small>XML</small> to a file, simply supply the
filename using the &rsquo;OutputFile&rsquo; option.</p>

<p style="margin-left:11%; margin-top: 1em">This option
also accepts an <small>IO</small> handle object &minus;
especially useful in Perl 5.8.0 and later for output using
an encoding other than <small>UTF&minus;8,</small> eg:</p>

<pre style="margin-left:11%; margin-top: 1em">  open my $fh, '&gt;:encoding(iso&minus;8859&minus;1)', $path or die &quot;open($path): $!&quot;;
  XMLout($ref, OutputFile =&gt; $fh);</pre>


<p style="margin-left:11%; margin-top: 1em">Note,
XML::Simple does not require that the object you pass in to
the OutputFile option inherits from IO::Handle &minus; it
simply assumes the object supports a
<tt>&quot;print&quot;</tt> method.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ParserOpts
=&gt; [ XML::Parser Options ]</b> <i># in &minus;
don&rsquo;t use this <br>
Note: This option is now officially deprecated. If you find
it useful, email the author with an example of what you use
it for. Do not use this option to set the ProtocolEncoding,
that&rsquo;s just plain wrong &minus; fix the
<small>XML</small></i> .</p>

<p style="margin-left:11%; margin-top: 1em">This option
allows you to pass parameters to the constructor of the
underlying XML::Parser object (which of course assumes
you&rsquo;re not using <small>SAX</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>RootName
=&gt; &rsquo;string&rsquo;</b> <i># out &minus; handy</i>
<br>
By default, when <tt>&quot;XMLout()&quot;</tt> generates
<small>XML,</small> the root element will be named
&rsquo;opt&rsquo;. This option allows you to specify an
alternative name.</p>

<p style="margin-left:11%; margin-top: 1em">Specifying
either undef or the empty string for the RootName option
will produce <small>XML</small> with no root elements. In
most cases the resulting <small>XML</small> fragment will
not be &rsquo;well formed&rsquo; and therefore could not be
read back in by <tt>&quot;XMLin()&quot;</tt>. Nevertheless,
the option has been found to be useful in certain
circumstances.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SearchPath
=&gt; [ list ]</b> <i># in &minus; handy</i> <br>
If you pass <tt>&quot;XMLin()&quot;</tt> a filename, but the
filename include no directory component, you can use this
option to specify which directories should be searched to
locate the file. You might use this option to search first
in the user&rsquo;s home directory, then in a global
directory such as /etc.</p>

<p style="margin-left:11%; margin-top: 1em">If a filename
is provided to <tt>&quot;XMLin()&quot;</tt> but SearchPath
is not defined, the file is assumed to be in the current
directory.</p>

<p style="margin-left:11%; margin-top: 1em">If the first
parameter to <tt>&quot;XMLin()&quot;</tt> is undefined, the
default SearchPath will contain only the directory in which
the script itself is located. Otherwise the default
SearchPath will be empty.</p>

<p style="margin-left:11%; margin-top: 1em"><b>StrictMode
=&gt; 1 | 0</b> <i># in+out seldom used</i> <br>
This option allows you to turn &quot; <small>STRICT
MODE&quot;</small> on or off for a particular call,
regardless of whether it was enabled at the time XML::Simple
was loaded.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SuppressEmpty
=&gt; 1 | &rsquo;&rsquo; | undef</b> <i># in+out &minus;
handy</i> <br>
This option controls what <tt>&quot;XMLin()&quot;</tt>
should do with empty elements (no attributes and no
content). The default behaviour is to represent them as
empty hashes. Setting this option to a true value (eg: 1)
will cause empty elements to be skipped altogether. Setting
the option to &rsquo;undef&rsquo; or the empty string will
cause empty elements to be represented as the undefined
value or the empty string respectively. The latter two
alternatives are a little easier to test for in your code
than a hash with no keys.</p>

<p style="margin-left:11%; margin-top: 1em">The option also
controls what <tt>&quot;XMLout()&quot;</tt> does with
undefined values. Setting the option to undef causes
undefined values to be output as empty elements (rather than
empty attributes), it also suppresses the generation of
warnings about undefined values. Setting the option to a
true value (eg: 1) causes undefined values to be skipped
altogether on output.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ValueAttr
=&gt; [ names ]</b> <i># in &minus; handy</i> <br>
Use this option to deal elements which always have a single
attribute and no content. Eg:</p>

<pre style="margin-left:11%; margin-top: 1em">  &lt;opt&gt;
    &lt;colour value=&quot;red&quot; /&gt;
    &lt;size   value=&quot;XXL&quot; /&gt;
  &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Setting
<tt>&quot;ValueAttr =&gt; [ 'value' ]&quot;</tt> will cause
the above <small>XML</small> to parse to:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    colour =&gt; 'red',
    size   =&gt; 'XXL'
  }</pre>


<p style="margin-left:11%; margin-top: 1em">instead of this
(the default):</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    colour =&gt; { value =&gt; 'red' },
    size   =&gt; { value =&gt; 'XXL' }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Note: This form
of the ValueAttr option is not compatible with
<tt>&quot;XMLout()&quot;</tt> &minus; since the attribute
name is discarded at parse time, the original
<small>XML</small> cannot be reconstructed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ValueAttr
=&gt; { element =&gt; attribute, ... }</b> <i># in+out
&minus; handy</i> <br>
This (preferred) form of the ValueAttr option requires you
to specify both the element and the attribute names. This is
not only safer, it also allows the original
<small>XML</small> to be reconstructed by
<tt>&quot;XMLout()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note: You
probably don&rsquo;t want to use this option and the NoAttr
option at the same time.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Variables
=&gt; { name =&gt; value }</b> <i># in &minus; handy</i>
<br>
This option allows variables in the <small>XML</small> to be
expanded when the file is read. (there is no facility for
putting the variable names back if you regenerate
<small>XML</small> using <tt>&quot;XMLout&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">A
&rsquo;variable&rsquo; is any text of the form
<tt>&quot;${name}&quot;</tt> which occurs in an attribute
value or in the text content of an element. If
&rsquo;name&rsquo; matches a key in the supplied hashref,
<tt>&quot;${name}&quot;</tt> will be replaced with the
corresponding value from the hashref. If no matching key is
found, the variable will not be replaced. Names must match
the regex: <tt>&quot;[\w.]+&quot;</tt> (ie: only
&rsquo;word&rsquo; characters and dots are allowed).</p>

<p style="margin-left:11%; margin-top: 1em"><b>VarAttr
=&gt; &rsquo;attr_name&rsquo;</b> <i># in &minus; handy</i>
<br>
In addition to the variables defined using
<tt>&quot;Variables&quot;</tt>, this option allows variables
to be defined in the <small>XML. A</small> variable
definition consists of an element with an attribute called
&rsquo;attr_name&rsquo; (the value of the
<tt>&quot;VarAttr&quot;</tt> option). The value of the
attribute will be used as the variable name and the text
content of the element will be used as the value. A variable
defined in this way will override a variable defined using
the <tt>&quot;Variables&quot;</tt> option. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  XMLin( '&lt;opt&gt;
            &lt;dir name=&quot;prefix&quot;&gt;/usr/local/apache&lt;/dir&gt;
            &lt;dir name=&quot;exec_prefix&quot;&gt;${prefix}&lt;/dir&gt;
            &lt;dir name=&quot;bindir&quot;&gt;${exec_prefix}/bin&lt;/dir&gt;
          &lt;/opt&gt;',
         VarAttr =&gt; 'name', ContentKey =&gt; '&minus;content'
        );</pre>


<p style="margin-left:11%; margin-top: 1em">produces the
following data structure:</p>

<pre style="margin-left:11%; margin-top: 1em">  {
    dir =&gt; {
             prefix      =&gt; '/usr/local/apache',
             exec_prefix =&gt; '/usr/local/apache',
             bindir      =&gt; '/usr/local/apache/bin',
           }
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>XMLDecl
=&gt; 1 or XMLDecl =&gt; &rsquo;string&rsquo;</b> <i># out
&minus; handy</i> <br>
If you want the output from <tt>&quot;XMLout()&quot;</tt> to
start with the optional <small>XML</small> declaration,
simply set the option to &rsquo;1&rsquo;. The default
<small>XML</small> declaration is:</p>

<pre style="margin-left:11%; margin-top: 1em">        &lt;?xml version='1.0' standalone='yes'?&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">If you want
some other string (for example to declare an encoding
value), set the value of this option to the complete string
you require.</p>

<h2>OPTIONAL OO INTERFACE
<a name="OPTIONAL OO INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The procedural
interface is both simple and convenient however there are a
couple of reasons why you might prefer to use the object
oriented ( <small>OO</small> ) interface:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">to define a set of default
values which should be used on all subsequent calls to
<tt>&quot;XMLin()&quot;</tt> or
<tt>&quot;XMLout()&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>to override methods in <b>XML::Simple</b> to provide
customised behaviour</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The default
values for the options described above are unlikely to suit
everyone. The <small>OO</small> interface allows you to
effectively override <b>XML::Simple</b>&rsquo;s defaults
with your preferred values. It works like this:</p>

<p style="margin-left:11%; margin-top: 1em">First create an
XML::Simple parser object with your preferred defaults:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $xs = XML::Simple&minus;&gt;new(ForceArray =&gt; 1, KeepRoot =&gt; 1);</pre>


<p style="margin-left:11%; margin-top: 1em">then call
<tt>&quot;XMLin()&quot;</tt> or
<tt>&quot;XMLout()&quot;</tt> as a method of that
object:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $ref = $xs&minus;&gt;XMLin($xml);
  my $xml = $xs&minus;&gt;XMLout($ref);</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
specify options when you make the method calls and these
values will be merged with the values specified when the
object was created. Values specified in a method call take
precedence.</p>

<p style="margin-left:11%; margin-top: 1em">Note: when
called as methods, the <tt>&quot;XMLin()&quot;</tt> and
<tt>&quot;XMLout()&quot;</tt> routines may be called as
<tt>&quot;xml_in()&quot;</tt> or
<tt>&quot;xml_out()&quot;</tt>. The method names are aliased
so the only difference is the aesthetics.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parsing
Methods</b> <br>
You can explicitly call one of the following methods rather
than rely on the <tt>&quot;xml_in()&quot;</tt> method
automatically determining whether the target to be parsed is
a string, a file or a filehandle: <br>
parse_string(text)</p>

<p style="margin-left:17%;">Works exactly like the
<tt>&quot;xml_in()&quot;</tt> method but assumes the first
argument is a string of <small>XML</small> (or a reference
to a scalar containing a string of <small>XML</small> ).</p>

<p style="margin-left:11%;">parse_file(filename)</p>

<p style="margin-left:17%;">Works exactly like the
<tt>&quot;xml_in()&quot;</tt> method but assumes the first
argument is the name of a file containing
<small>XML.</small></p>

<p style="margin-left:11%;">parse_fh(file_handle)</p>

<p style="margin-left:17%;">Works exactly like the
<tt>&quot;xml_in()&quot;</tt> method but assumes the first
argument is a filehandle which can be read to get
<small>XML.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Hook
Methods</b> <br>
You can make your own class which inherits from XML::Simple
and overrides certain behaviours. The following methods may
provide useful &rsquo;hooks&rsquo; upon which to hang your
modified behaviour. You may find other undocumented methods
by examining the source, but those may be subject to change
in future releases. <br>
handle_options(direction, name =&gt; value ...)</p>

<p style="margin-left:17%;">This method will be called when
one of the parsing methods or the
<tt>&quot;XMLout()&quot;</tt> method is called. The initial
argument will be a string (either &rsquo;in&rsquo; or
&rsquo;out&rsquo;) and the remaining arguments will be name
value pairs.</p>


<p style="margin-left:11%;"><i>default_config_file()</i></p>

<p style="margin-left:17%;">Calculates and returns the name
of the file which should be parsed if no filename is passed
to <tt>&quot;XMLin()&quot;</tt> (default:
<tt>&quot;$0.xml&quot;</tt>).</p>

<p style="margin-left:11%;">build_simple_tree(filename,
string)</p>

<p style="margin-left:17%;">Called from
<tt>&quot;XMLin()&quot;</tt> or any of the parsing methods.
Takes either a file name as the first argument or
<tt>&quot;undef&quot;</tt> followed by a
&rsquo;string&rsquo; as the second argument. Returns a
simple tree data structure. You could override this method
to apply your own transformations before the data structure
is returned to the caller.</p>

<p style="margin-left:11%;"><i>new_hashref()</i></p>

<p style="margin-left:17%;">When the &rsquo;simple
tree&rsquo; data structure is being built, this method will
be called to create any required anonymous hashrefs.</p>

<p style="margin-left:11%;">sorted_keys(name, hashref)</p>

<p style="margin-left:17%;">Called when
<tt>&quot;XMLout()&quot;</tt> is translating a hashref to
<small>XML.</small> This routine returns a list of hash keys
in the order that the corresponding attributes/elements
should appear in the output.</p>

<p style="margin-left:11%;">escape_value(string)</p>

<p style="margin-left:17%;">Called from
<tt>&quot;XMLout()&quot;</tt>, takes a string and returns a
copy of the string with <small>XML</small> character
escaping rules applied.</p>

<p style="margin-left:11%;">numeric_escape(string)</p>

<p style="margin-left:17%;">Called from
<tt>&quot;escape_value()&quot;</tt>, to handle non-ASCII
characters (depending on the value of the NumericEscape
option).</p>

<p style="margin-left:11%;">copy_hash(hashref, extra_key
=&gt; value, ...)</p>

<p style="margin-left:17%;">Called from
<tt>&quot;XMLout()&quot;</tt>, when &rsquo;unfolding&rsquo;
a hash of hashes into an array of hashes. You might wish to
override this method if you&rsquo;re using tied hashes and
don&rsquo;t want them to get untied.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache
Methods</b> <br>
XML::Simple implements three caching schemes
(&rsquo;storable&rsquo;, &rsquo;memshare&rsquo; and
&rsquo;memcopy&rsquo;). You can implement a custom caching
scheme by implementing two methods &minus; one for reading
from the cache and one for writing to it.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
you might implement a new &rsquo;dbm&rsquo; scheme that
stores cached data structures using the <small>MLDBM</small>
module. First, you would add a
<tt>&quot;cache_read_dbm()&quot;</tt> method which accepted
a filename for use as a lookup key and returned a data
structure on success, or undef on failure. Then, you would
implement a <tt>&quot;cache_read_dbm()&quot;</tt> method
which accepted a data structure and a filename.</p>

<p style="margin-left:11%; margin-top: 1em">You would use
this caching scheme by specifying the option:</p>

<pre style="margin-left:11%; margin-top: 1em">  Cache =&gt; [ 'dbm' ]</pre>


<h2>STRICT MODE
<a name="STRICT MODE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you import
the <b>XML::Simple</b> routines like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  use XML::Simple qw(:strict);</pre>


<p style="margin-left:11%; margin-top: 1em">the following
common mistakes will be detected and treated as fatal
errors</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Failing to explicitly set the
<tt>&quot;KeyAttr&quot;</tt> option &minus; if you
can&rsquo;t be bothered reading about this option, turn it
off with: KeyAttr =&gt; [ ]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Failing to explicitly set the
<tt>&quot;ForceArray&quot;</tt> option &minus; if you
can&rsquo;t be bothered reading about this option, set it to
the safest mode with: ForceArray =&gt; 1</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Setting ForceArray to an array, but failing to list all
the elements from the KeyAttr hash.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Data error &minus; KeyAttr is set to say { part =&gt;
&rsquo;partnum&rsquo; } but the <small>XML</small> contains
one or more &lt;part&gt; elements without a
&rsquo;partnum&rsquo; attribute (or nested element). Note:
if strict mode is not set but &minus;w is, this condition
triggers a warning.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Data error &minus; as above, but non-unique values are
present in the key attribute (eg: more than one &lt;part&gt;
element with the same partnum). This will also trigger a
warning if strict mode is not enabled.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Data error &minus; as above, but value of key attribute
(eg: partnum) is not a scalar string (due to nested elements
etc). This will also trigger a warning if strict mode is not
enabled.</p> </td></tr>
</table>

<h2>SAX SUPPORT
<a name="SAX SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">From version
1.08_01, <b>XML::Simple</b> includes support for
<small>SAX</small> (the Simple <small>API</small> for
<small>XML</small> ) &minus; specifically
<small>SAX2.</small></p>

<p style="margin-left:11%; margin-top: 1em">In a typical
<small>SAX</small> application, an <small>XML</small> parser
(or <small>SAX</small> &rsquo;driver&rsquo;) module
generates <small>SAX</small> events (start of element,
character data, end of element, etc) as it parses an
<small>XML</small> document and a &rsquo;handler&rsquo;
module processes the events to extract the required data.
This simple model allows for some interesting and powerful
possibilities:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Applications written to the
<small>SAX API</small> can extract data from huge
<small>XML</small> documents without the memory overheads of
a <small>DOM</small> or tree <small>API.</small></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <small>SAX API</small> allows for plug and play
interchange of parser modules without having to change your
code to fit a new module&rsquo;s <small>API. A</small>
number of <small>SAX</small> parsers are available with
capabilities ranging from extreme portability to blazing
performance.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A <small>SAX</small> &rsquo;filter&rsquo; module can
implement both a handler interface for receiving data and a
generator interface for passing modified data on to a
downstream handler. Filters can be chained together in
&rsquo;pipelines&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>One filter module might split a data stream to direct
data to two or more downstream handlers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Generating <small>SAX</small> events is not the
exclusive preserve of <small>XML</small> parsing modules.
For example, a module might extract data from a relational
database using <small>DBI</small> and pass it on to a
<small>SAX</small> pipeline for filtering and
formatting.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Simple</b>
can operate at either end of a <small>SAX</small> pipeline.
For example, you can take a data structure in the form of a
hashref and pass it into a <small>SAX</small> pipeline using
the &rsquo;Handler&rsquo; option on
<tt>&quot;XMLout()&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">  use XML::Simple;
  use Some::SAX::Filter;
  use XML::SAX::Writer;
  my $ref = {
               ....   # your data here
            };
  my $writer = XML::SAX::Writer&minus;&gt;new();
  my $filter = Some::SAX::Filter&minus;&gt;new(Handler =&gt; $writer);
  my $simple = XML::Simple&minus;&gt;new(Handler =&gt; $filter);
  $simple&minus;&gt;XMLout($ref);</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
put <b>XML::Simple</b> at the opposite end of the pipeline
to take advantage of the simple &rsquo;tree&rsquo; data
structure once the relevant data has been isolated through
filtering:</p>

<pre style="margin-left:11%; margin-top: 1em">  use XML::SAX;
  use Some::SAX::Filter;
  use XML::Simple;
  my $simple = XML::Simple&minus;&gt;new(ForceArray =&gt; 1, KeyAttr =&gt; ['partnum']);
  my $filter = Some::SAX::Filter&minus;&gt;new(Handler =&gt; $simple);
  my $parser = XML::SAX::ParserFactory&minus;&gt;parser(Handler =&gt; $filter);
  my $ref = $parser&minus;&gt;parse_uri('some_huge_file.xml');
  print $ref&minus;&gt;{part}&minus;&gt;{'555&minus;1234'};</pre>


<p style="margin-left:11%; margin-top: 1em">You can build a
filter by using an XML::Simple object as a handler and
setting its DataHandler option to point to a routine which
takes the resulting tree, modifies it and sends it off as
<small>SAX</small> events to a downstream handler:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $writer = XML::SAX::Writer&minus;&gt;new();
  my $filter = XML::Simple&minus;&gt;new(
                 DataHandler =&gt; sub {
                                  my $simple = shift;
                                  my $data = shift;
                                  # Modify $data here
                                  $simple&minus;&gt;XMLout($data, Handler =&gt; $writer);
                                }
               );
  my $parser = XML::SAX::ParserFactory&minus;&gt;parser(Handler =&gt; $filter);
  $parser&minus;&gt;parse_uri($filename);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Note: In
this last example, the &rsquo;Handler&rsquo; option was
specified in the call to &quot;XMLout()&quot; but it could
also have been specified in the constructor</i>.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t care which parser module <b>XML::Simple</b> uses
then skip this section entirely (it looks more complicated
than it really is).</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Simple</b>
will default to using a <b><small>SAX</small></b> parser if
one is available or <b>XML::Parser</b> if <small>SAX</small>
is not available.</p>

<p style="margin-left:11%; margin-top: 1em">You can dictate
which parser module is used by setting either the
environment variable &rsquo;
<small>XML_SIMPLE_PREFERRED_PARSER</small> &rsquo; or the
package variable <tt>$XML::Simple::PREFERRED_PARSER</tt> to
contain the module name. The following rules are used:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The package variable takes
precedence over the environment variable if both are
defined. To force <b>XML::Simple</b> to ignore the
environment settings and use its default rules, you can set
the package variable to an empty string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the &rsquo;preferred parser&rsquo; is set to the
string &rsquo;XML::Parser&rsquo;, then XML::Parser will be
used (or <tt>&quot;XMLin()&quot;</tt> will die if
XML::Parser is not installed).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the &rsquo;preferred parser&rsquo; is set to some
other value, then it is assumed to be the name of a
<small>SAX</small> parser module and is passed to
XML::SAX::ParserFactory. If <small>XML::SAX</small> is not
installed, or the requested parser module is not installed,
then <tt>&quot;XMLin()&quot;</tt> will die.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the &rsquo;preferred parser&rsquo; is not defined at
all (the normal default state), an attempt will be made to
load <small>XML::SAX</small> . If <small>XML::SAX</small> is
installed, then a parser module will be selected according
to XML::SAX::ParserFactory&rsquo;s normal rules (which
typically means the last <small>SAX</small> parser
installed).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>if the &rsquo;preferred parser&rsquo; is not defined and
<b><small>XML::SAX</small></b> is not installed, then
<b>XML::Parser</b> will be used.
<tt>&quot;XMLin()&quot;</tt> will die if XML::Parser is not
installed.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note: The
<b><small>XML::SAX</small></b> distribution includes an
<small>XML</small> parser written entirely in Perl. It is
very portable but it is not very fast. You should consider
installing XML::LibXML or XML::SAX::Expat if they are
available for your platform.</p>

<h2>ERROR HANDLING
<a name="ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>XML</small> standard is very clear on the issue of
non-compliant documents. An error in parsing any single
element (for example a missing end tag) must cause the whole
document to be rejected. <b>XML::Simple</b> will die with an
appropriate message if it encounters a parsing error.</p>

<p style="margin-left:11%; margin-top: 1em">If dying is not
appropriate for your application, you should arrange to call
<tt>&quot;XMLin()&quot;</tt> in an eval block and look for
errors in $@. eg:</p>

<pre style="margin-left:11%; margin-top: 1em">    my $config = eval { XMLin() };
    PopUpMessage($@) if($@);</pre>


<p style="margin-left:11%; margin-top: 1em">Note, there is
a common misconception that use of <b>eval</b> will
significantly slow down a script. While that may be true
when the code being eval&rsquo;d is in a string, it is not
true of code like the sample above.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When
<tt>&quot;XMLin()&quot;</tt> reads the following very simple
piece of <small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot;&gt;&lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">it returns the
following data structure:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
      'username' =&gt; 'testuser',
      'password' =&gt; 'frodo'
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The identical
result could have been produced with this alternative
<small>XML:</small></p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot; /&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Or this
(although see &rsquo;ForceArray&rsquo; option for
variations):</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;username&gt;testuser&lt;/username&gt;
      &lt;password&gt;frodo&lt;/password&gt;
    &lt;/opt&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Repeated nested
elements are represented as anonymous arrays:</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;person firstname=&quot;Joe&quot; lastname=&quot;Smith&quot;&gt;
        &lt;email&gt;joe@smith.com&lt;/email&gt;
        &lt;email&gt;jsmith@yahoo.com&lt;/email&gt;
      &lt;/person&gt;
      &lt;person firstname=&quot;Bob&quot; lastname=&quot;Smith&quot;&gt;
        &lt;email&gt;bob@smith.com&lt;/email&gt;
      &lt;/person&gt;
    &lt;/opt&gt;
    {
      'person' =&gt; [
                    {
                      'email' =&gt; [
                                   'joe@smith.com',
                                   'jsmith@yahoo.com'
                                 ],
                      'firstname' =&gt; 'Joe',
                      'lastname' =&gt; 'Smith'
                    },
                    {
                      'email' =&gt; 'bob@smith.com',
                      'firstname' =&gt; 'Bob',
                      'lastname' =&gt; 'Smith'
                    }
                  ]
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Nested elements
with a recognised key attribute are transformed (folded)
from an array into a hash keyed on the value of that
attribute (see the <tt>&quot;KeyAttr&quot;</tt> option):</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;person key=&quot;jsmith&quot; firstname=&quot;Joe&quot; lastname=&quot;Smith&quot; /&gt;
      &lt;person key=&quot;tsmith&quot; firstname=&quot;Tom&quot; lastname=&quot;Smith&quot; /&gt;
      &lt;person key=&quot;jbloggs&quot; firstname=&quot;Joe&quot; lastname=&quot;Bloggs&quot; /&gt;
    &lt;/opt&gt;
    {
      'person' =&gt; {
                    'jbloggs' =&gt; {
                                   'firstname' =&gt; 'Joe',
                                   'lastname' =&gt; 'Bloggs'
                                 },
                    'tsmith' =&gt; {
                                  'firstname' =&gt; 'Tom',
                                  'lastname' =&gt; 'Smith'
                                },
                    'jsmith' =&gt; {
                                  'firstname' =&gt; 'Joe',
                                  'lastname' =&gt; 'Smith'
                                }
                  }
    }</pre>


<p style="margin-left:11%; margin-top: 1em">The
&lt;anon&gt; tag can be used to form anonymous arrays:</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;
      &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;
      &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;
      &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;
    &lt;/opt&gt;
    {
      'head' =&gt; [
                  [ 'Col 1', 'Col 2', 'Col 3' ]
                ],
      'data' =&gt; [
                  [ 'R1C1', 'R1C2', 'R1C3' ],
                  [ 'R2C1', 'R2C2', 'R2C3' ],
                  [ 'R3C1', 'R3C2', 'R3C3' ]
                ]
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Anonymous
arrays can be nested to arbirtrary levels and as a special
case, if the surrounding tags for an <small>XML</small>
document contain only an anonymous array the arrayref will
be returned directly rather than the usual hashref:</p>

<pre style="margin-left:11%; margin-top: 1em">    &lt;opt&gt;
      &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;
      &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;
      &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;
    &lt;/opt&gt;
    [
      [ 'Col 1', 'Col 2' ],
      [ 'R1C1', 'R1C2' ],
      [ 'R2C1', 'R2C2' ]
    ]</pre>


<p style="margin-left:11%; margin-top: 1em">Elements which
only contain text content will simply be represented as a
scalar. Where an element has both attributes and text
content, the element will be represented as a hashref with
the text content in the &rsquo;content&rsquo; key (see the
<tt>&quot;ContentKey&quot;</tt> option):</p>

<pre style="margin-left:11%; margin-top: 1em">  &lt;opt&gt;
    &lt;one&gt;first&lt;/one&gt;
    &lt;two attr=&quot;value&quot;&gt;second&lt;/two&gt;
  &lt;/opt&gt;
  {
    'one' =&gt; 'first',
    'two' =&gt; { 'attr' =&gt; 'value', 'content' =&gt; 'second' }
  }</pre>


<p style="margin-left:11%; margin-top: 1em">Mixed content
(elements which contain both text content and nested
elements) will be not be represented in a useful way &minus;
element order and significant whitespace will be lost. If
you need to work with mixed content, then XML::Simple is not
the right tool for your job &minus; check out the next
section.</p>

<h2>WHERE TO FROM HERE?
<a name="WHERE TO FROM HERE?"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XML::Simple</b>
is able to present a simple <small>API</small> because it
makes some assumptions on your behalf. These include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You&rsquo;re not interested in
text content consisting only of whitespace</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You don&rsquo;t mind that when things get slurped into a
hash the order is lost</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You don&rsquo;t want fine-grained control of the
formatting of generated <small>XML</small></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You would never use a hash key that was not a legal
<small>XML</small> element name</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You don&rsquo;t need help converting between different
encodings</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In a serious
<small>XML</small> project, you&rsquo;ll probably outgrow
these assumptions fairly quickly. This section of the
document used to offer some advice on chosing a more
powerful option. That advice has now grown into the
&rsquo;Perl&minus;XML <small>FAQ</small> &rsquo; document
which you can find at:
&lt;http://perl&minus;xml.sourceforge.net/faq/&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The advice in
the <small>FAQ</small> boils down to a quick explanation of
tree versus event based parsers and then recommends:</p>

<p style="margin-left:11%; margin-top: 1em">For event based
parsing, use <small>SAX</small> (do not set out to write any
new code for XML::Parser&rsquo;s handler <small>API
&minus;</small> it is obselete).</p>

<p style="margin-left:11%; margin-top: 1em">For tree-based
parsing, you could choose between the &rsquo;Perlish&rsquo;
approach of XML::Twig and more standards based
<small>DOM</small> implementations &minus; preferably one
with XPath support such as XML::LibXML.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XML::Simple</b>
requires either XML::Parser or <small>XML::SAX</small> .</p>

<p style="margin-left:11%; margin-top: 1em">To generate
documents with namespaces, XML::NamespaceSupport is
required.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
caching functions require Storable.</p>

<p style="margin-left:11%; margin-top: 1em">Answers to
Frequently Asked Questions about XML::Simple are bundled
with this distribution as: XML::Simple::FAQ</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
1999&minus;2004 Grant McLean &lt;grantm@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
