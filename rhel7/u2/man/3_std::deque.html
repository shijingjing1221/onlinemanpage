<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:26:36 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::deque&lt; _Tp, _Alloc &gt;</title>

</head>
<body>

<h1 align="center">std::deque&lt; _Tp, _Alloc &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::deque&lt;
_Tp, _Alloc &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::_Deque_base&lt; _Tp, _Alloc &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef <b>_Base::const_iterator const_iterator</b> <br>
typedef <br>
_Tp_alloc_type::const_pointer <b>const_pointer</b>&quot;
<br>
typedef <br>
_Tp_alloc_type::const_reference <b>const_reference</b>&quot;
<br>
typedef <b>std::reverse_iterator</b> <br>
&lt; <b>const_iterator</b> &gt;
<b>const_reverse_iterator</b>&quot; <br>
typedef ptrdiff_t <b>difference_type</b> <br>
typedef <b>_Base::iterator iterator</b> <br>
typedef _Tp_alloc_type::pointer <b>pointer</b> <br>
typedef _Tp_alloc_type::reference <b>reference</b> <br>
typedef <b>std::reverse_iterator</b> <br>
&lt; <b>iterator</b> &gt; <b>reverse_iterator</b>&quot; <br>
typedef size_t <b>size_type</b> <br>
typedef _Tp <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>deque</b> () <b><br>
deque</b> (const allocator_type &amp;__a) <b><br>
deque</b> (size_type __n) <b><br>
deque</b> (size_type __n, const value_type &amp;__value,
const allocator_type &amp;__a=allocator_type()) <b><br>
deque</b> (const <b>deque</b> &amp;__x) <b><br>
deque</b> (<b>deque</b> &amp;&amp;__x) <b><br>
deque</b> (<b>initializer_list</b>&lt; value_type &gt; __l,
const allocator_type &amp;__a=allocator_type()) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
<b>deque</b> (_InputIterator __first, _InputIterator __last,
const allocator_type &amp;__a=allocator_type()) <b><br>
~deque</b> () noexcept <br>
template&lt;typename... _Args&gt; <b>deque</b>&lt; _Tp,
_Alloc &gt;::<b>iterator _M_insert_aux</b> (<b>iterator</b>
__pos, _Args &amp;&amp;...__args) <br>
void <b>assign</b> (size_type __n, const value_type
&amp;__val) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
<b>assign</b> (_InputIterator __first, _InputIterator
__last) <br>
void <b>assign</b> (<b>initializer_list</b>&lt; value_type
&gt; __l) <br>
reference <b>at</b> (size_type __n) <br>
const_reference <b>at</b> (size_type __n) const <br>
reference <b>back</b> () <br>
const_reference <b>back</b> () const <b><br>
iterator begin</b> () noexcept <b><br>
const_iterator begin</b> () const noexcept <b><br>
const_iterator cbegin</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept <br>
void <b>clear</b> () noexcept <b><br>
const_reverse_iterator crbegin</b> () const noexcept <b><br>
const_reverse_iterator crend</b> () const noexcept <br>
template&lt;typename... _Args&gt; <b>deque</b>&lt; _Tp,
_Alloc &gt;::<b>iterator emplace</b> (<b>iterator</b>
__position, _Args &amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; <b>iterator emplace</b>
(<b>iterator</b> __position, _Args &amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; void <b>emplace_back</b>
(_Args &amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; void <b>emplace_front</b>
(_Args &amp;&amp;...__args) <br>
bool <b>empty</b> () const noexcept <b><br>
iterator end</b> () noexcept <b><br>
const_iterator end</b> () const noexcept <b><br>
iterator erase</b> (<b>iterator</b> __position) <b><br>
iterator erase</b> (<b>iterator</b> __first, <b>iterator</b>
__last) <br>
reference <b>front</b> () <br>
const_reference <b>front</b> () const <br>
allocator_type <b>get_allocator</b> () const noexcept
<b><br>
iterator insert</b> (<b>iterator</b> __position, const
value_type &amp;__x) <b><br>
iterator insert</b> (<b>iterator</b> __position, value_type
&amp;&amp;__x) <br>
void <b>insert</b> (<b>iterator</b> __p,
<b>initializer_list</b>&lt; value_type &gt; __l) <br>
void <b>insert</b> (<b>iterator</b> __position, size_type
__n, const value_type &amp;__x) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
<b>insert</b> (<b>iterator</b> __position, _InputIterator
__first, _InputIterator __last) <br>
size_type <b>max_size</b> () const noexcept <b><br>
deque</b> &amp; <b>operator=</b> (const <b>deque</b>
&amp;__x) <b><br>
deque</b> &amp; <b>operator=</b> (<b>deque</b>
&amp;&amp;__x) <b><br>
deque</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; value_type &gt; __l) <br>
reference <b>operator[]</b> (size_type __n) <br>
const_reference <b>operator[]</b> (size_type __n) const <br>
void <b>pop_back</b> () <br>
void <b>pop_front</b> () <br>
void <b>push_back</b> (const value_type &amp;__x) <br>
void <b>push_back</b> (value_type &amp;&amp;__x) <br>
void <b>push_front</b> (const value_type &amp;__x) <br>
void <b>push_front</b> (value_type &amp;&amp;__x) <b><br>
reverse_iterator rbegin</b> () noexcept <b><br>
const_reverse_iterator rbegin</b> () const noexcept <b><br>
reverse_iterator rend</b> () noexcept <b><br>
const_reverse_iterator rend</b> () const noexcept <br>
void <b>resize</b> (size_type __new_size) <br>
void <b>resize</b> (size_type __new_size, const value_type
&amp;__x) <br>
void <b>shrink_to_fit</b> () <br>
size_type <b>size</b> () const noexcept <br>
void <b>swap</b> (<b>deque</b> &amp;__x)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">enum {
<b>_S_initial_map_size</b> } <br>
typedef _Alloc::template <br>
rebind&lt; _Tp * &gt;::other <b>_Map_alloc_type</b>&quot;
<br>
typedef pointer * <b>_Map_pointer</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">_Tp ** <b>_M_allocate_map</b>
(size_t __n) <br>
_Tp * <b>_M_allocate_node</b> () <br>
template&lt;typename _InputIterator &gt; void
<b>_M_assign_aux</b> (_InputIterator __first, _InputIterator
__last, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_assign_aux</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
template&lt;typename _Integer &gt; void
<b>_M_assign_dispatch</b> (_Integer __n, _Integer __val,
__true_type) <br>
template&lt;typename _InputIterator &gt; void
<b>_M_assign_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <br>
void <b>_M_create_nodes</b> (_Tp **__nstart, _Tp
**__nfinish) <br>
void <b>_M_deallocate_map</b> (_Tp **__p, size_t __n) <br>
void <b>_M_deallocate_node</b> (_Tp *__p) <br>
void <b>_M_default_append</b> (size_type __n) <br>
void <b>_M_default_initialize</b> () <br>
template&lt;typename _Alloc1 &gt; void
<b>_M_destroy_data</b> (<b>iterator</b> __first,
<b>iterator</b> __last, const _Alloc1 &amp;) <br>
void <b>_M_destroy_data</b> (<b>iterator</b> __first,
<b>iterator</b> __last, const <b>std::allocator</b>&lt; _Tp
&gt; &amp;) <br>
void <b>_M_destroy_data_aux</b> (<b>iterator</b> __first,
<b>iterator</b> __last) <br>
void <b>_M_destroy_nodes</b> (_Tp **__nstart, _Tp
**__nfinish) <br>
void <b>_M_erase_at_begin</b> (<b>iterator</b> __pos) <br>
void <b>_M_erase_at_end</b> (<b>iterator</b> __pos) <br>
void <b>_M_fill_assign</b> (size_type __n, const value_type
&amp;__val) <br>
void <b>_M_fill_initialize</b> (const value_type
&amp;__value) <br>
void <b>_M_fill_insert</b> (<b>iterator</b> __pos, size_type
__n, const value_type &amp;__x) <br>
_Map_alloc_type <b>_M_get_map_allocator</b> () const
noexcept <br>
_Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> () noexcept
<br>
const _Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> ()
const noexcept <br>
template&lt;typename _Integer &gt; void
<b>_M_initialize_dispatch</b> (_Integer __n, _Integer __x,
__true_type) <br>
template&lt;typename _InputIterator &gt; void
<b>_M_initialize_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <br>
void <b>_M_initialize_map</b> (size_t) <br>
template&lt;typename... _Args&gt; <b>iterator
_M_insert_aux</b> (<b>iterator</b> __pos, _Args
&amp;&amp;...__args) <br>
void <b>_M_insert_aux</b> (<b>iterator</b> __pos, size_type
__n, const value_type &amp;__x) <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_insert_aux</b> (<b>iterator</b> __pos,
_ForwardIterator __first, _ForwardIterator __last, size_type
__n) <br>
template&lt;typename _Integer &gt; void
<b>_M_insert_dispatch</b> (<b>iterator</b> __pos, _Integer
__n, _Integer __x, __true_type) <br>
template&lt;typename _InputIterator &gt; void
<b>_M_insert_dispatch</b> (<b>iterator</b> __pos,
_InputIterator __first, _InputIterator __last, __false_type)
<br>
void <b>_M_range_check</b> (size_type __n) const <br>
template&lt;typename _InputIterator &gt; void
<b>_M_range_insert_aux</b> (<b>iterator</b> __pos,
_InputIterator __first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_range_insert_aux</b> (<b>iterator</b> __pos,
_ForwardIterator __first, _ForwardIterator __last,
<b>std::forward_iterator_tag</b>) <br>
bool <b>_M_shrink_to_fit</b> ()</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_InputIterator &gt; void <b>_M_range_initialize</b>
(_InputIterator __first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_range_initialize</b> (_ForwardIterator __first,
_ForwardIterator __last,
<b>std::forward_iterator_tag</b>)</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename...
_Args&gt; void <b>_M_push_back_aux</b> (_Args
&amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; void
<b>_M_push_front_aux</b> (_Args &amp;&amp;...__args) <br>
void <b>_M_pop_back_aux</b> () <br>
void <b>_M_pop_front_aux</b> ()</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
_M_reserve_elements_at_front</b> (size_type __n) <b><br>
iterator _M_reserve_elements_at_back</b> (size_type __n)
<br>
void <b>_M_new_elements_at_front</b> (size_type
__new_elements) <br>
void <b>_M_new_elements_at_back</b> (size_type
__new_elements)</p>

<p style="margin-left:23%; margin-top: 1em">void
<b>_M_reserve_map_at_back</b> (size_type __nodes_to_add=1)
<br>
void <b>_M_reserve_map_at_front</b> (size_type
__nodes_to_add=1) <br>
void <b>_M_reallocate_map</b> (size_type __nodes_to_add,
bool __add_at_front)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static size_t
<b>_S_buffer_size</b> ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">_Deque_impl <b>_M_impl</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;class
std::deque&lt; _Tp, _Alloc &gt;</b> <br>
A standard container using fixed-size memory allocation and
constant-time manipulation of elements at either end.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters:</b></p>

<p style="margin-left:17%;"><i>_Tp</i> Type of element.
<i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, a <tt>reversible
container</tt>, and a <tt>sequence</tt>, including the
<tt>optional sequence requirements</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In previous
HP/SGI versions of deque, there was an extra template
parameter so users could control the node size. This
extension turned out to violate the C++ standard (it can be
detected using template template parameters), and it was
removed.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how a deque&lt;Tp&gt; manages memory. Each deque has 4
members:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>Tp** _M_map</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>size_t _M_map_size</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>iterator _M_start, _M_finish</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">map_size is at
least 8. map is an array of map_size
pointers-to-<i>nodes</i>. (The name map has nothing to do
with the std::map class, and <b>nodes</b> should not be
confused with std::list&rsquo;s usage of <i>node</i>.)</p>

<p style="margin-left:11%; margin-top: 1em">A <i>node</i>
has no specific type name as such, but it is referred to as
<i>node</i> in this file. It is a simple array-of-Tp. If Tp
is very large, there will be one Tp element per node (i.e.,
an <i>array</i> of one). For non-huge Tp&rsquo;s, node size
is inversely related to Tp size: the larger the Tp, the
fewer Tp&rsquo;s will fit in a node. The goal here is to
keep the total size of a node relatively small and constant
over different Tp&rsquo;s, to improve allocator
efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">Not every
pointer in the map array will point to a node. If the
initial number of elements in the deque is small, the
/middle/ map pointers will be valid, and the ones at the
edges will be unused. This same situation will arise as the
map grows: available map pointers, if any, will be on the
ends. As new nodes are created, only a subset of the
map&rsquo;s pointers need to be copied <i>outward</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Class
invariants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em">For any nonsingular iterator
i:</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">i.node points to a member of the
map array. (Yes, you read that correctly: i.node does not
actually point to a node.) The member of the map array is
what actually points to the node.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.first == *(i.node) (This points to the node (first Tp
element).)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.last == i.first + node_size</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.cur is a pointer in the range [i.first, i.last). NOTE:
the implication of this is that i.cur is always a
dereferenceable pointer, even if i is a past-the-end
iterator.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Start and
Finish are always nonsingular iterators. NOTE: this means
that an empty deque must have one node, a deque with &lt;N
elements (where N is the node buffer size) must have one
node, a deque with N through (2N-1) elements must have two
nodes, etc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">For every node other than
start.node and finish.node, every element in the node is an
initialized object. If start.node == finish.node, then
[start.cur, finish.cur) are initialized objects, and the
elements outside that range are uninitialized storage.
Otherwise, [start.cur, start.last) and [finish.first,
finish.cur) are initialized objects, and [start.first,
start.cur) and [finish.cur, finish.last) are uninitialized
storage.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>[map, map + map_size) is a valid, non-empty range.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>[start.node, finish.node] is a valid range contained
within [map, map + map_size).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>A pointer in the range [map, map + map_size) points to
an allocated node if and only if the pointer is in the range
[start.node, finish.node].</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
the magic: nothing in deque is <b>aware</b> of the
discontiguous storage!</p>

<p style="margin-left:11%; margin-top: 1em">The memory
setup and layout occurs in the parent, _Base, and the
iterator class is entirely responsible for <i>leaping</i>
from one node to the next. All the implementation routines
for deque itself work only through the start and finish
iterators. This keeps the routines simple and sane, and we
can use other standard algorithms as well.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 730 of file stl_deque.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque ()</b>
<tt>[inline]</tt> <br>
Default constructor creates no elements.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 782 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (const allocator_type
&amp;__a)</b> <tt>[inline]</tt><b>,</b> <tt>[explicit]</tt>
<br>
Creates a deque with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 790 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (size_type__n)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Creates a deque with default constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the deque with <i>n</i> default
constructed elements.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 802 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (size_type__n, const
value_type &amp;__value, const allocator_type &amp;__a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Creates a deque with copies of an exemplar element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__value</i> An element to copy. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the deque with <i>__n</i> copies of
<i>__value</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 814 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_fill_initialize().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (const deque&lt; _Tp,
_Alloc &gt; &amp;__x)</b> <tt>[inline]</tt> <br>
Deque copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created deque uses a copy of the allocation object
used by <i>__x</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 841 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin(), and std::deque&lt;
_Tp, _Alloc &gt;::end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (deque&lt; _Tp,
_Alloc &gt; &amp;&amp;__x)</b> <tt>[inline]</tt> <br>
Deque move constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created deque contains the exact contents of
<i>__x</i>. The contents of <i>__x</i> are a valid, but
unspecified deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 855 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (initializer_list&lt;
value_type &gt;__l, const allocator_type &amp;__a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a deque from an initializer list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a deque
consisting of copies of the elements in the initializer_list
<i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This will call
the element type&rsquo;s copy constructor N times (where N
is __l.size()) and do no memory reallocation.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 869 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_range_initialize().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque
(_InputIterator__first, _InputIterator__last, const
allocator_type &amp;__a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a deque from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a deque
consisting of copies of the elements from [__first,
__last).</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are forward, bidirectional, or random-access, then
this will call the elements&rsquo; copy constructor N times
(where N is distance(__first,__last)) and do no memory
reallocation. But if only input iterators are used, then
this will do at most 2N calls to the copy constructor, and
logN memory reallocations.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 896 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::~deque ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
The dtor only erases the elements, and note that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 917 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin(), and std::deque&lt;
_Tp, _Alloc &gt;::end().</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_fill_initialize
(const value_type &amp;__value)</b> <tt>[protected]</tt>
<br>
Fills the deque with copies of value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__value</i> Initial
value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Nothing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition:</b></p>

<p style="margin-left:17%;">_M_start and _M_finish have
already been initialized, but none of the deque&rsquo;s
elements have yet been constructed.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is called only when the user provides an explicit size (with
or without an explicit exemplar value).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 351 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::_Destroy().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::deque().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void std::_Deque_base&lt; _Tp,
_Alloc &gt;::_M_initialize_map (size_t__num_elements)</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Layout storage.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__num_elements</i> The count
of T&rsquo;s for which to allocate space at first.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Nothing.</p>

<p style="margin-left:11%; margin-top: 1em">The initial
underlying memory layout is a bit complicated...</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 582 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::max().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_back (size_type__new_elements)</b>
<tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 849 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::size().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_back().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_front
(size_type__new_elements)</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 824 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::size().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_pop_back_aux
()</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 505 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::pop_back().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_pop_front_aux
()</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 520 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::pop_front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename... _Args&gt; void std::deque&lt; _Tp,
_Alloc &gt;::_M_push_back_aux (_Args
&amp;&amp;...__args)</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::push_back().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename... _Args&gt; void std::deque&lt; _Tp,
_Alloc &gt;::_M_push_front_aux (_Args
&amp;&amp;...__args)</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::push_front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_range_check
(size_type__n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[protected]</tt> <br>
Safety check used only from at().</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1265 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::size().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::at().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_InputIterator &gt; void deque::_M_range_initialize
(_InputIterator__first, _InputIterator__last,
std::input_iterator_tag)</b> <tt>[protected]</tt> <br>
Fills the deque with whatever is in [first,last).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Nothing.</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are actually forward iterators (or better), then
the memory layout can be done all at once. Else we move
forward using push_back on each value from the iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 377 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::deque().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_ForwardIterator &gt; void deque::_M_range_initialize
(_ForwardIterator__first, _ForwardIterator__last,
std::forward_iterator_tag)</b> <tt>[protected]</tt> <br>
Fills the deque with whatever is in [first,last).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Nothing.</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are actually forward iterators (or better), then
the memory layout can be done all at once. Else we move
forward using push_back on each value from the iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 401 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::_Destroy(), std::advance(), and std::distance().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_reallocate_map
(size_type__nodes_to_add, bool__add_at_front)</b>
<tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 874 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::max().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_back(),
and std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_map_at_front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_back (size_type__n)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1898 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_front (size_type__n)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1888 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_back
(size_type__nodes_to_add =</b> <tt>1</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1924 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_reallocate_map().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_front
(size_type__nodes_to_add =</b> <tt>1</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1932 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_reallocate_map().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign (size_type__n, const
value_type &amp;__val)</b> <tt>[inline]</tt> <br>
Assigns a given value to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
to be assigned. <i><br>
__val</i> Value to be assigned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with <i>n</i> copies of the given value. Note
that the assignment completely changes the deque and that
the resulting deque&rsquo;s size is the same as the number
of elements assigned. Old data may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 978 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::assign(), and
std::deque&lt; _Tp, _Alloc &gt;::operator=().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign
(_InputIterator__first, _InputIterator__last)</b>
<tt>[inline]</tt> <br>
Assigns a range to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the range
[__first,__last).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned. Old data may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 997 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign
(initializer_list&lt; value_type &gt;__l)</b>
<tt>[inline]</tt> <br>
Assigns an initializer list to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the
initializer_list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned. Old data may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1022 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::assign().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::at
(size_type__n)</b> <tt>[inline]</tt> <br>
Provides access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the deque. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1284 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_range_check().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::at
(size_type__n) const</b> <tt>[inline]</tt> <br>
Provides access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the deque. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1302 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_range_check().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::back ()</b>
<tt>[inline]</tt> <br>
Returns a read/write reference to the data at the last
element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1329 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::back ()
const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) reference to the data at the
last element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1341 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::begin ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the deque. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1037 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::clear(), std::deque&lt;
_Tp, _Alloc &gt;::deque(), std::deque&lt; _Tp, _Alloc
&gt;::front(), std::deque&lt; _Tp, _Alloc &gt;::operator=(),
std::operator==(), and std::deque&lt; _Tp, _Alloc
&gt;::~deque().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::begin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the deque. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1045 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::cbegin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the deque. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1108 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::cend ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the deque. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1117 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::clear ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all the elements. Note that this function only erases
the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1616 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::operator=().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::crbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1126 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::crend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1135 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename... _Args&gt; iterator std::deque&lt;
_Tp, _Alloc &gt;::emplace (iterator__position, _Args
&amp;&amp;...__args)</b> <br>
Inserts an object in deque before specified iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the deque. <i><br>
__args</i> Arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert an object of type T constructed with
T(std::forward&lt;Args&gt;(args)...) before the specified
location.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::insert().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; bool
std::deque&lt; _Tp, _Alloc &gt;::empty () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the deque is empty. (Thus begin() would
equal end().)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1228 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::end ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the deque. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1054 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::back(), std::deque&lt; _Tp,
_Alloc &gt;::deque(), std::deque&lt; _Tp, _Alloc
&gt;::operator=(), std::operator==(), and std::deque&lt;
_Tp, _Alloc &gt;::~deque().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::end ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the deque. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1063 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc
&gt;::iterator deque::erase (iterator__position)</b> <br>
Remove element at given position.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> Iterator
pointing to element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator pointing to the
next element (or end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the element at the given position and thus
shorten the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">The user is
cautioned that this function only erases the element, and
that if the element is itself a pointer, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 194 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::begin(), std::end(), and std::size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc
&gt;::iterator deque::erase (iterator__first,
iterator__last)</b> <br>
Remove a range of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the first element to be erased. <i><br>
__last</i> Iterator pointing to one past the last element to
be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element pointed to by <i>last</i> prior to erasing (or
end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the elements in the range [__first,__last) and
shorten the deque accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">The user is
cautioned that this function only erases the elements, and
that if the elements themselves are pointers, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 217 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::begin(), std::end(), and std::size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::front ()</b>
<tt>[inline]</tt> <br>
Returns a read/write reference to the data at the first
element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1313 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::front ()
const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) reference to the data at the
first element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1321 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
allocator_type std::deque&lt; _Tp, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Get a copy of the memory allocation object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1028 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc
&gt;::iterator deque::insert (iterator__position, const
value_type &amp;__x)</b> <br>
Inserts given value into deque before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the deque. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given value before the specified
location.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 149 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::insert(), and
std::deque&lt; _Tp, _Alloc &gt;::resize().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::insert
(iterator__position, value_type &amp;&amp;__x)</b>
<tt>[inline]</tt> <br>
Inserts given rvalue into deque before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the deque. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given rvalue before the specified
location.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1492 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::emplace().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::insert (iterator__p,
initializer_list&lt; value_type &gt;__l)</b>
<tt>[inline]</tt> <br>
Inserts an initializer list into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__p</i> An iterator into the
deque. <i><br>
__l</i> An initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the initializer_list
<i>__l</i> into the deque before the location specified by
<i>__p</i>. This is known as <i>list insert</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1505 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::insert().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::insert (iterator__position,
size_type__n, const value_type &amp;__x)</b>
<tt>[inline]</tt> <br>
Inserts a number of copies of given data into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the deque. <i><br>
__n</i> Number of elements to be inserted. <i><br>
__x</i> Data to be inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a specified number of copies of the given data
before the location specified by <i>__position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1519 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::insert (iterator__position,
_InputIterator__first, _InputIterator__last)</b>
<tt>[inline]</tt> <br>
Inserts a range into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the deque. <i><br>
__first</i> An input iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the range [__first,__last)
into the deque before the location specified by
<i>__position</i>. This is known as <i>range insert</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1536 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::deque&lt; _Tp, _Alloc &gt;::max_size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the size() of the largest possible deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1147 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc &gt; &amp;
deque::operator= (const deque&lt; _Tp, _Alloc &gt;
&amp;__x)</b> <br>
Deque assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">All the
elements of <i>x</i> are copied, but unlike the copy
constructor, the allocator object is not copied.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 93 of file deque.tcc.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::begin(), std::deque&lt;
_Tp, _Alloc &gt;::end(), std::deque&lt; _Tp, _Alloc
&gt;::size(), and std::size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
deque&amp; std::deque&lt; _Tp, _Alloc &gt;::operator=
(deque&lt; _Tp, _Alloc &gt; &amp;&amp;__x)</b>
<tt>[inline]</tt> <br>
Deque move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
<i>__x</i> are moved into this deque (without copying).
<i>__x</i> is a valid, but unspecified deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 939 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::clear(), and std::deque&lt;
_Tp, _Alloc &gt;::swap().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
deque&amp; std::deque&lt; _Tp, _Alloc &gt;::operator=
(initializer_list&lt; value_type &gt;__l)</b>
<tt>[inline]</tt> <br>
Assigns an initializer list to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the
initializer_list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned. Old data may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 960 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::assign().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::operator[]
(size_type__n)</b> <tt>[inline]</tt> <br>
Subscript access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1244 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::operator[]
(size_type__n) const</b> <tt>[inline]</tt> <br>
Subscript access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1259 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::pop_back ()</b>
<tt>[inline]</tt> <br>
Removes last element. This is a typical stack operation. It
shrinks the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the last element&rsquo;s data is
needed, it should be retrieved before pop_back() is
called.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1442 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_pop_back_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::pop_front ()</b>
<tt>[inline]</tt> <br>
Removes first element. This is a typical stack operation. It
shrinks the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the first element&rsquo;s data is
needed, it should be retrieved before pop_front() is
called.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1421 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_pop_front_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::push_back (const value_type
&amp;__x)</b> <tt>[inline]</tt> <br>
Add data to the end of the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the end of the deque and assigns the given data to it. Due
to the nature of a deque this operation can be done in
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1390 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_push_back_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::push_front (const
value_type &amp;__x)</b> <tt>[inline]</tt> <br>
Add data to the front of the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the front of the deque and assigns the given data to it. Due
to the nature of a deque this operation can be done in
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1359 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::_M_push_front_aux().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rbegin
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to the
last element in the deque. Iteration is done in reverse
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1072 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::rbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1081 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rend
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to one
before the first element in the deque. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1090 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rend
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1099 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::resize
(size_type__new_size)</b> <tt>[inline]</tt> <br>
Resizes the deque to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the deque should contain.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the deque to the specified number of elements.
If the number is smaller than the deque&rsquo;s current size
the deque is truncated, otherwise default constructed
elements are appended.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1161 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::resize
(size_type__new_size, const value_type &amp;__x)</b>
<tt>[inline]</tt> <br>
Resizes the deque to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the deque should contain. <i><br>
__x</i> Data with which new elements should be
populated.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the deque to the specified number of elements.
If the number is smaller than the deque&rsquo;s current size
the deque is truncated, otherwise the deque is extended and
new elements are populated with given data.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1183 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::deque&lt; _Tp, _Alloc &gt;::insert(), and
std::deque&lt; _Tp, _Alloc &gt;::size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::shrink_to_fit ()</b>
<tt>[inline]</tt> <br>
A non-binding request to reduce memory use.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1219 of file stl_deque.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::deque&lt; _Tp, _Alloc &gt;::size () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of elements in the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1142 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::_M_range_check(),
std::deque&lt; _Tp, _Alloc &gt;::operator=(),
std::operator==(), and std::deque&lt; _Tp, _Alloc
&gt;::resize().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::swap (deque&lt; _Tp, _Alloc
&gt; &amp;__x)</b> <tt>[inline]</tt> <br>
Swaps data with another deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of the same
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two deques in constant time. (Four
pointers, so it should be quite fast.) Note that the global
std::swap() function is specialized such that
std::swap(d1,d2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 1596 of file stl_deque.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
std::swap().</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
std::deque&lt; _Tp, _Alloc &gt;::operator=(), and
std::swap().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
