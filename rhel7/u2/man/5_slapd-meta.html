<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:21:48 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SLAPD-META</title>

</head>
<body>

<h1 align="center">SLAPD-META</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#CONFIGURATION">CONFIGURATION</a><br>
<a href="#SPECIAL CONFIGURATION DIRECTIVES">SPECIAL CONFIGURATION DIRECTIVES</a><br>
<a href="#TARGET SPECIFICATION">TARGET SPECIFICATION</a><br>
<a href="#SCENARIOS">SCENARIOS</a><br>
<a href="#ACLs">ACLs</a><br>
<a href="#REWRITING">REWRITING</a><br>
<a href="#Passes">Passes</a><br>
<a href="#Pattern Matching Flags">Pattern Matching Flags</a><br>
<a href="#Action Flags">Action Flags</a><br>
<a href="#Pattern matching:">Pattern matching:</a><br>
<a href="#Substitution Pattern Syntax:">Substitution Pattern Syntax:</a><br>
<a href="#Rewrite context:">Rewrite context:</a><br>
<a href="#Basic configuration syntax">Basic configuration syntax</a><br>
<a href="#Additional configuration syntax:">Additional configuration syntax:</a><br>
<a href="#Configuration examples:">Configuration examples:</a><br>
<a href="#LDAP Proxy resolution (a possible evolution of slapd&minus;ldap(5)):">LDAP Proxy resolution (a possible evolution of slapd&minus;ldap(5)):</a><br>
<a href="#ACCESS CONTROL">ACCESS CONTROL</a><br>
<a href="#PROXY CACHE OVERLAY">PROXY CACHE OVERLAY</a><br>
<a href="#DEPRECATED STATEMENTS">DEPRECATED STATEMENTS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">slapd&minus;meta
&minus; metadirectory backend to slapd</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">/etc/openldap/slapd.conf</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <b>meta</b>
backend to <b>slapd</b>(8) performs basic LDAP proxying with
respect to a set of remote LDAP servers, called
&quot;targets&quot;. The information contained in these
servers can be presented as belonging to a single Directory
Information Tree (DIT).</p>

<p style="margin-left:11%; margin-top: 1em">A basic
knowledge of the functionality of the
<b>slapd&minus;ldap</b>(5) backend is recommended. This
backend has been designed as an enhancement of the ldap
backend. The two backends share many features (actually they
also share portions of code). While the <b>ldap</b> backend
is intended to proxy operations directed to a single server,
the <b>meta</b> backend is mainly intended for proxying of
multiple servers and possibly naming context masquerading.
These features, although useful in many scenarios, may
result in excessive overhead for some applications, so its
use should be carefully considered. In the examples section,
some typical scenarios will be discussed.</p>

<p style="margin-left:11%; margin-top: 1em">The proxy
instance of <b>slapd</b>(8) must contain schema information
for the attributes and objectClasses used in filters,
request DN and request-related data in general. It should
also contain schema information for the data returned by the
proxied server. It is the responsibility of the proxy
administrator to keep the schema of the proxy lined up with
that of the proxied server.</p>

<p style="margin-left:11%; margin-top: 1em">Note: When
looping back to the same instance of <b>slapd</b>(8), each
connection requires a new thread; as a consequence,
<b>slapd</b>(8) must be compiled with thread support, and
the <b>threads</b> parameter may need some tuning; in those
cases, unless the multiple target feature is required, one
may consider using <b>slapd&minus;relay</b>(5) instead,
which performs the relayed operation internally and thus
reuses the same connection.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
examples in various places in this document, as well as in
the slapd/back&minus;meta/data/ directory in the OpenLDAP
source tree.</p>

<h2>CONFIGURATION
<a name="CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These
<b>slapd.conf</b> options apply to the META backend
database. That is, they must follow a &quot;database
meta&quot; line and come before any subsequent
&quot;backend&quot; or &quot;database&quot; lines. Other
database options are described in the <b>slapd.conf</b>(5)
manual page.</p>

<p style="margin-left:11%; margin-top: 1em">Note: In early
versions of back-ldap and back-meta it was recommended to
always set</p>

<p style="margin-left:22%; margin-top: 1em">lastmod off</p>

<p style="margin-left:11%; margin-top: 1em">for <b>ldap</b>
and <b>meta</b> databases. This was required because
operational attributes related to entry creation and
modification should not be proxied, as they could be
mistakenly written to the target server(s), generating an
error. The current implementation automatically sets lastmod
to <b>off</b>, so its use is redundant and should be
omitted.</p>

<h2>SPECIAL CONFIGURATION DIRECTIVES
<a name="SPECIAL CONFIGURATION DIRECTIVES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Target
configuration starts with the &quot;uri&quot; directive. All
the configuration directives that are not specific to
targets should be defined first for clarity, including those
that are common to all backends. They are: <b><br>
conn&minus;ttl &lt;time&gt;</b></p>

<p style="margin-left:22%;">This directive causes a cached
connection to be dropped an recreated after a given ttl,
regardless of being idle or not.</p>

<p style="margin-left:11%;"><b>default&minus;target
none</b></p>

<p style="margin-left:22%;">This directive forces the
backend to reject all those operations that must resolve to
a single target in case none or multiple targets are
selected. They include: add, delete, modify, modrdn; compare
is not included, as well as bind since, as they don&rsquo;t
alter entries, in case of multiple matches an attempt is
made to perform the operation on any candidate target, with
the constraint that at most one must succeed. This directive
can also be used when processing targets to mark a specific
target as default.</p>

<p style="margin-left:11%;"><b>dncache&minus;ttl
{DISABLED|forever|&lt;ttl&gt;}</b></p>

<p style="margin-left:22%;">This directive sets the
time-to-live of the DN cache. This caches the target that
holds a given DN to speed up target selection in case
multiple targets would result from an uncached search;
forever means cache never expires; disabled means no DN
caching; otherwise a valid ( &gt; 0 ) ttl is required, in
the format illustrated for the <b>idle&minus;timeout</b>
directive.</p>

<p style="margin-left:11%;"><b>onerr
{CONTINUE|report|stop}</b></p>

<p style="margin-left:22%;">This directive allows to select
the behavior in case an error is returned by one target
during a search. The default, <b>continue</b>, consists in
continuing the operation, trying to return as much data as
possible. If the value is set to <b>stop</b>, the search is
terminated as soon as an error is returned by one target,
and the error is immediately propagated to the client. If
the value is set to <b>report</b>, the search is continuated
to the end but, in case at least one target returned an
error code, the first non-success error code is
returned.</p>

<p style="margin-left:11%;"><b>norefs
&lt;NO|yes&gt;</b></p>

<p style="margin-left:22%;">If <b>yes</b>, do not return
search reference responses. By default, they are returned
unless request is LDAPv2. If set before any target
specification, it affects all targets, unless overridden by
any per-target directive.</p>

<p style="margin-left:11%;"><b>noundeffilter
&lt;NO|yes&gt;</b></p>

<p style="margin-left:22%;">If <b>yes</b>, return success
instead of searching if a filter is undefined or contains
undefined portions. By default, the search is propagated
after replacing undefined portions with
<b>(!(objectClass=*))</b>, which corresponds to the empty
result set. If set before any target specification, it
affects all targets, unless overridden by any per-target
directive.</p>

<p style="margin-left:11%;"><b>protocol&minus;version
{0,2,3}</b></p>

<p style="margin-left:22%;">This directive indicates what
protocol version must be used to contact the remote server.
If set to 0 (the default), the proxy uses the same protocol
version used by the client, otherwise the requested protocol
is used. The proxy returns <i>unwillingToPerform</i> if an
operation that is incompatible with the requested protocol
is attempted. If set before any target specification, it
affects all targets, unless overridden by any per-target
directive.</p>


<p style="margin-left:11%;"><b>pseudoroot&minus;bind&minus;defer
{YES|no}</b></p>

<p style="margin-left:22%;">This directive, when set to
<b>yes</b>, causes the authentication to the remote servers
with the pseudo-root identity (the identity defined in each
<b>idassert-bind</b> directive) to be deferred until
actually needed by subsequent operations. Otherwise, all
binds as the rootdn are propagated to the targets.</p>

<p style="margin-left:11%;"><b>quarantine
&lt;interval&gt;,&lt;num&gt;[;&lt;interval&gt;,&lt;num&gt;[...]]</b></p>

<p style="margin-left:22%;">Turns on quarantine of URIs
that returned <i>LDAP_UNAVAILABLE</i>, so that an attempt to
reconnect only occurs at given intervals instead of any time
a client requests an operation. The pattern is: retry only
after at least <i>interval</i> seconds elapsed since last
attempt, for exactly <i>num</i> times; then use the next
pattern. If <i>num</i> for the last pattern is
&quot;<b>+</b>&quot;, it retries forever; otherwise, no more
retries occur. This directive must appear before any target
specification; it affects all targets with the same
pattern.</p>

<p style="margin-left:11%;"><b>rebind&minus;as&minus;user
{NO|yes}</b></p>

<p style="margin-left:22%;">If this option is given, the
client&rsquo;s bind credentials are remembered for rebinds,
when trying to re-establish a broken connection, or when
chasing a referral, if <b>chase&minus;referrals</b> is set
to <i>yes</i>.</p>


<p style="margin-left:11%;"><b>session&minus;tracking&minus;request
{NO|yes}</b></p>

<p style="margin-left:22%;">Adds session tracking control
for all requests. The client&rsquo;s IP and hostname, and
the identity associated to each request, if known, are sent
to the remote server for informational purposes. This
directive is incompatible with setting
<i>protocol&minus;version</i> to 2. If set before any target
specification, it affects all targets, unless overridden by
any per-target directive.</p>

<p style="margin-left:11%;"><b>single&minus;conn
{NO|yes}</b></p>

<p style="margin-left:22%;">Discards current cached
connection when the client rebinds.</p>


<p style="margin-left:11%;"><b>use&minus;temporary&minus;conn
{NO|yes}</b></p>

<p style="margin-left:22%;">when set to <b>yes</b>, create
a temporary connection whenever competing with other threads
for a shared one; otherwise, wait until the shared
connection is available.</p>

<h2>TARGET SPECIFICATION
<a name="TARGET SPECIFICATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Target
specification starts with a &quot;uri&quot; directive:
<b><br>
uri &lt;protocol&gt;://[&lt;host&gt;]/&lt;naming context&gt;
[...]</b></p>

<p style="margin-left:22%;">The &lt;protocol&gt; part can
be anything <b>ldap_initialize</b>(3) accepts
({ldap|ldaps|ldapi} and variants); the &lt;host&gt; may be
omitted, defaulting to whatever is set in
<b>ldap.conf</b>(5). The &lt;naming context&gt; part is
<i>mandatory</i> for the first URI, but it <i>must be
omitted</i> for subsequent ones, if any. The naming context
part must be within the naming context defined for the
backend, e.g.:</p>

<p style="margin-left:22%; margin-top: 1em">suffix
&quot;<b>dc=foo,dc=com</b>&quot; <br>
uri
&quot;ldap://x.foo.com/dc=x,<b>dc=foo,dc=com</b>&quot;</p>

<p style="margin-left:22%; margin-top: 1em">The &lt;naming
context&gt; part doesn&rsquo;t need to be unique across the
targets; it may also match one of the values of the
&quot;suffix&quot; directive. Multiple URIs may be defined
in a single URI statement. The additional URIs must be
separate arguments and must not have any &lt;naming
context&gt; part. This causes the underlying library to
contact the first server of the list that responds. For
example, if <i>l1.foo.com</i> and <i>l2.foo.com</i> are
shadows of the same server, the directive</p>

<p style="margin-left:22%; margin-top: 1em">suffix
&quot;<b>dc=foo,dc=com</b>&quot; <br>
uri &quot;ldap://l1.foo.com/<b>dc=foo,dc=com</b>&quot;
&quot;ldap://l2.foo.com/&quot;</p>

<p style="margin-left:22%; margin-top: 1em">causes
<i>l2.foo.com</i> to be contacted whenever <i>l1.foo.com</i>
does not respond. In that case, the URI list is internally
rearranged, by moving unavailable URIs to the end, so that
further connection attempts occur with respect to the last
URI that succeeded.</p>

<p style="margin-left:11%;"><b>acl&minus;authcDN
&lt;administrative DN for access control
purposes&gt;</b></p>

<p style="margin-left:22%;">DN which is used to query the
target server for acl checking, as in the LDAP backend; it
is supposed to have read access on the target server to
attributes used on the proxy for acl checking. There is no
risk of giving away such values; they are only used to check
permissions. <b>The acl&minus;authcDN identity is by no
means implicitly used by the proxy when the client connects
anonymously.</b></p>

<p style="margin-left:11%;"><b>acl&minus;passwd
&lt;password&gt;</b></p>

<p style="margin-left:22%;">Password used with the
<b>acl&minus;authcDN</b> above.</p>

<p style="margin-left:11%;"><b>bind&minus;timeout
&lt;microseconds&gt;</b></p>

<p style="margin-left:22%;">This directive defines the
timeout, in microseconds, used when polling for response
after an asynchronous bind connection. The initial call to
ldap_result(3) is performed with a trade-off timeout of
100000 us; if that results in a timeout exceeded, subsequent
calls use the value provided with <b>bind&minus;timeout</b>.
The default value is used also for subsequent calls if
<b>bind&minus;timeout</b> is not specified. If set before
any target specification, it affects all targets, unless
overridden by any per-target directive.</p>

<p style="margin-left:11%;"><b>chase&minus;referrals
{YES|no}</b></p>

<p style="margin-left:22%;">enable/disable automatic
referral chasing, which is delegated to the underlying
libldap, with rebinding eventually performed if the
<b>rebind&minus;as&minus;user</b> directive is used. The
default is to chase referrals. If set before any target
specification, it affects all targets, unless overridden by
any per-target directive.</p>

<p style="margin-left:11%;"><b>client&minus;pr
{accept-unsolicited|DISABLE|&lt;size&gt;}</b></p>

<p style="margin-left:22%;">This feature allows to use RFC
2696 Paged Results control when performing search operations
with a specific target, irrespective of the client&rsquo;s
request. When set to a numeric value, Paged Results control
is always used with <i>size</i> as the page size. When set
to <i>accept-unsolicited</i>, unsolicited Paged Results
control responses are accepted and honored for compatibility
with broken remote DSAs. The client is not exposed to paged
results handling between <b>slapd&minus;meta</b>(5) and the
remote servers. By default (disabled), Paged Results control
is not used and responses are not accepted. If set before
any target specification, it affects all targets, unless
overridden by any per-target directive.</p>

<p style="margin-left:11%;"><b>default&minus;target
[&lt;target&gt;]</b></p>

<p style="margin-left:22%;">The
&quot;default&minus;target&quot; directive can also be used
during target specification. With no arguments it marks the
current target as the default. The optional number marks
target &lt;target&gt; as the default one, starting from 1.
Target &lt;target&gt; must be defined.</p>

<p style="margin-left:11%;"><b>filter
&lt;pattern&gt;</b></p>

<p style="margin-left:22%;">This directive allows
specifying a <b>regex</b>(5) pattern to indicate what search
filter terms are actually served by a target.</p>

<p style="margin-left:22%; margin-top: 1em">In a search
request, if the search filter matches the <i>pattern</i> the
target is considered while fulfilling the request; otherwise
the target is ignored. There may be multiple occurrences of
the <b>filter</b> directive for each target.</p>

<p style="margin-left:11%;"><b>idassert&minus;authzFrom
&lt;authz-regexp&gt;</b></p>

<p style="margin-left:22%;">if defined, selects what
<i>local</i> identities are authorized to exploit the
identity assertion feature. The string
<b>&lt;authz-regexp&gt;</b> follows the rules defined for
the <i>authzFrom</i> attribute. See <b>slapd.conf</b>(5),
section related to <b>authz&minus;policy</b>, for details on
the syntax of this field.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>idassert&minus;bind</b></p></td>
<td width="6%"></td>
<td width="63%">


<p style="margin-top: 1em"><b>bindmethod=none|simple|sasl
[binddn=&lt;simple DN&gt;]</b></p></td></tr>
</table>

<p style="margin-left:11%;"><b>[credentials=&lt;simple
password&gt;] [saslmech=&lt;SASL mech&gt;]
[secprops=&lt;properties&gt;] [realm=&lt;realm&gt;]
[authcId=&lt;authentication ID&gt;]
[authzId=&lt;authorization ID&gt;]
[authz={native|proxyauthz}] [mode=&lt;mode&gt;]
[flags=&lt;flags&gt;] [starttls=no|yes|critical]
[tls_cert=&lt;file&gt;] [tls_key=&lt;file&gt;]
[tls_cacert=&lt;file&gt;] [tls_cacertdir=&lt;path&gt;]
[tls_reqcert=never|allow|try|demand]
[tls_ciphersuite=&lt;ciphers&gt;]
[tls_protocol_min=&lt;major&gt;[.&lt;minor&gt;]]
[tls_crlcheck=none|peer|all]</b></p>

<p style="margin-left:22%;">Allows to define the parameters
of the authentication method that is internally used by the
proxy to authorize connections that are authenticated by
other databases. The identity defined by this directive,
according to the properties associated to the authentication
method, is supposed to have auth access on the target server
to attributes used on the proxy for authentication and
authorization, and to be allowed to authorize the users.
This requires to have <b>proxyAuthz</b> privileges on a wide
set of DNs, e.g. <b>authzTo=dn.subtree:&quot;&quot;</b>, and
the remote server to have <b>authz&minus;policy</b> set to
<b>to</b> or <b>both</b>. See <b>slapd.conf</b>(5) for
details on these statements and for remarks and drawbacks
about their usage. The supported bindmethods are</p>


<p style="margin-left:22%; margin-top: 1em"><b>none|simple|sasl</b></p>

<p style="margin-left:22%; margin-top: 1em">where
<b>none</b> is the default, i.e. no <i>identity
assertion</i> is performed.</p>

<p style="margin-left:22%; margin-top: 1em">The authz
parameter is used to instruct the SASL bind to exploit
<b>native</b> SASL authorization, if available; since
connections are cached, this should only be used when
authorizing with a fixed identity (e.g. by means of the
<b>authzDN</b> or <b>authzID</b> parameters). Otherwise, the
default <b>proxyauthz</b> is used, i.e. the proxyAuthz
control (Proxied Authorization, RFC 4370) is added to all
operations.</p>

<p style="margin-left:22%; margin-top: 1em">The supported
modes are:</p>


<p style="margin-left:22%; margin-top: 1em"><b>&lt;mode&gt;
:= {legacy|anonymous|none|self}</b></p>

<p style="margin-left:22%; margin-top: 1em">If
<b>&lt;mode&gt;</b> is not present, and <b>authzId</b> is
given, the proxy always authorizes that identity.
<b>&lt;authorization ID&gt;</b> can be</p>


<p style="margin-left:22%; margin-top: 1em"><b>u:&lt;user&gt;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>[dn:]&lt;DN&gt;</b></p>

<p style="margin-left:22%; margin-top: 1em">The former is
supposed to be expanded by the remote server according to
the authz rules; see <b>slapd.conf</b>(5) for details. In
the latter case, whether or not the <b>dn:</b> prefix is
present, the string must pass DN validation and
normalization.</p>

<p style="margin-left:22%; margin-top: 1em">The default
mode is <b>legacy</b>, which implies that the proxy will
either perform a simple bind as the <i>authcDN</i> or a SASL
bind as the <i>authcID</i> and assert the client&rsquo;s
identity when it is not anonymous. Direct binds are always
proxied. The other modes imply that the proxy will always
either perform a simple bind as the <i>authcDN</i> or a SASL
bind as the <i>authcID</i>, unless restricted by
<b>idassert&minus;authzFrom</b> rules (see below), in which
case the operation will fail; eventually, it will assert
some other identity according to <b>&lt;mode&gt;</b>. Other
identity assertion modes are <b>anonymous</b> and
<b>self</b>, which respectively mean that the <i>empty</i>
or the <i>client</i>&rsquo;s identity will be asserted;
<b>none</b>, which means that no proxyAuthz control will be
used, so the <i>authcDN</i> or the <i>authcID</i> identity
will be asserted. For all modes that require the use of the
<i>proxyAuthz</i> control, on the remote server the proxy
identity must have appropriate <i>authzTo</i> permissions,
or the asserted identities must have appropriate
<i>authzFrom</i> permissions. Note, however, that the ID
assertion feature is mostly useful when the asserted
identities do not exist on the remote server.</p>

<p style="margin-left:22%; margin-top: 1em">Flags can
be</p>


<p style="margin-left:22%; margin-top: 1em"><b>override,[non&minus;]prescriptive,proxy&minus;authz&minus;[non&minus;]critical</b></p>

<p style="margin-left:22%; margin-top: 1em">When the
<b>override</b> flag is used, identity assertion takes place
even when the database is authorizing for the identity of
the client, i.e. after binding with the provided identity,
and thus authenticating it, the proxy performs the identity
assertion using the configured identity and authentication
method.</p>

<p style="margin-left:22%; margin-top: 1em">When the
<b>prescriptive</b> flag is used (the default), operations
fail with <i>inappropriateAuthentication</i> for those
identities whose assertion is not allowed by the
<b>idassert&minus;authzFrom</b> patterns. If the
<b>non&minus;prescriptive</b> flag is used, operations are
performed anonymously for those identities whose assertion
is not allowed by the <b>idassert&minus;authzFrom</b>
patterns.</p>

<p style="margin-left:22%; margin-top: 1em">When the
<b>proxy&minus;authz&minus;non&minus;critical</b> flag is
used (the default), the proxyAuthz control is not marked as
critical, in violation of RFC 4370. Use of
<b>proxy&minus;authz&minus;critical</b> is recommended.</p>

<p style="margin-left:22%; margin-top: 1em">The TLS
settings default to the same as the main slapd TLS settings,
except for <b>tls_reqcert</b> which defaults to
&quot;demand&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">The identity
associated to this directive is also used for privileged
operations whenever <b>idassert&minus;bind</b> is defined
and <b>acl&minus;bind</b> is not. See <b>acl&minus;bind</b>
for details.</p>

<p style="margin-left:11%;"><b>idle&minus;timeout
&lt;time&gt;</b></p>

<p style="margin-left:22%;">This directive causes a cached
connection to be dropped an recreated after it has been idle
for the specified time. The value can be specified as</p>


<p style="margin-left:22%; margin-top: 1em">[&lt;d&gt;d][&lt;h&gt;h][&lt;m&gt;m][&lt;s&gt;[s]]</p>

<p style="margin-left:22%; margin-top: 1em">where
&lt;d&gt;, &lt;h&gt;, &lt;m&gt; and &lt;s&gt; are
respectively treated as days, hours, minutes and seconds. If
set before any target specification, it affects all targets,
unless overridden by any per-target directive.</p>

<p style="margin-left:11%;"><b>keepalive
&lt;idle&gt;:&lt;probes&gt;:&lt;interval&gt;</b></p>

<p style="margin-left:22%;">The <b>keepalive</b> parameter
sets the values of <i>idle</i>, <i>probes</i>, and
<i>interval</i> used to check whether a socket is alive;
<i>idle</i> is the number of seconds a connection needs to
remain idle before TCP starts sending keepalive probes;
<i>probes</i> is the maximum number of keepalive probes TCP
should send before dropping the connection; <i>interval</i>
is interval in seconds between individual keepalive probes.
Only some systems support the customization of these values;
the <b>keepalive</b> parameter is ignored otherwise, and
system-wide settings are used.</p>

<p style="margin-left:11%;"><b>map {attribute|objectclass}
[&lt;local name&gt;|*] {&lt;foreign name&gt;|*}</b></p>

<p style="margin-left:22%;">This maps object classes and
attributes as in the LDAP backend. See
<b>slapd&minus;ldap</b>(5).</p>

<p style="margin-left:11%;"><b>network&minus;timeout
&lt;time&gt;</b></p>

<p style="margin-left:22%;">Sets the network timeout value
after which <b>poll</b>(2)/<b>select</b>(2) following a
<b>connect</b>(2) returns in case of no activity. The value
is in seconds, and it can be specified as for
<b>idle&minus;timeout</b>. If set before any target
specification, it affects all targets, unless overridden by
any per-target directive.</p>

<p style="margin-left:11%;"><b>nretries
{forever|never|&lt;nretries&gt;}</b></p>

<p style="margin-left:22%;">This directive defines how many
times a bind should be retried in case of temporary failure
in contacting a target. If defined before any target
specification, it applies to all targets (by default,
<b>3</b> times); the global value can be overridden by
redefinitions inside each target specification.</p>

<p style="margin-left:11%;"><b>rewrite* ...</b></p>

<p style="margin-left:22%;">The rewrite options are
described in the &quot;REWRITING&quot; section.</p>


<p style="margin-left:11%;"><b>subtree&minus;{exclude|include}
&lt;rule&gt;</b></p>

<p style="margin-left:22%;">This directive allows to
indicate what subtrees are actually served by a target. The
syntax of the supported rules is</p>


<p style="margin-left:22%; margin-top: 1em"><b>&lt;rule&gt;:
[dn[.&lt;style&gt;]:]&lt;pattern&gt;</b></p>


<p style="margin-left:22%; margin-top: 1em"><b>&lt;style&gt;:
subtree|children|regex</b></p>

<p style="margin-left:22%; margin-top: 1em">When
<b>&lt;style&gt;</b> is either <b>subtree</b> or
<b>children</b> the <b>&lt;pattern&gt;</b> is a DN that must
be within the naming context served by the target. When
<b>&lt;style&gt;</b> is <b>regex</b> the
<b>&lt;pattern&gt;</b> is a <b>regex</b>(5) pattern. If the
<b>dn.&lt;style&gt;:</b> prefix is omitted,
<b>dn.subtree:</b> is implicitly assumed for backward
compatibility.</p>

<p style="margin-left:22%; margin-top: 1em">In the
<b>subtree&minus;exclude</b> form if the <i>request DN</i>
matches at least one rule, the target is not considered
while fulfilling the request; otherwise, the target is
considered based on the value of the <i>request DN</i>. When
the request is a search, also the <i>scope</i> is
considered.</p>

<p style="margin-left:22%; margin-top: 1em">In the
<b>subtree&minus;include</b> form if the <i>request DN</i>
matches at least one rule, the target is considered while
fulfilling the request; otherwise the target is ignored.</p>

<p style="margin-left:22%; margin-top: 1em">| match |
exclude | <br>
+---------+---------+-------------------+ <br>
| T | T | not candidate | <br>
| F | T | continue checking | <br>
+---------+---------+-------------------+ <br>
| T | F | candidate | <br>
| F | F | not candidate | <br>
+---------+---------+-------------------+</p>

<p style="margin-left:22%; margin-top: 1em">There may be
multiple occurrences of the <b>subtree&minus;exclude</b> or
<b>subtree&minus;include</b> directive for each of the
targets, but they are mutually exclusive.</p>

<p style="margin-left:11%;"><b>suffixmassage &lt;virtual
naming context&gt; &lt;real naming context&gt;</b></p>

<p style="margin-left:22%;">All the directives starting
with &quot;rewrite&quot; refer to the rewrite engine that
has been added to slapd. The &quot;suffixmassage&quot;
directive was introduced in the LDAP backend to allow suffix
massaging while proxying. It has been obsoleted by the
rewriting tools. However, both for backward compatibility
and for ease of configuration when simple suffix massage is
required, it has been preserved. It wraps the basic
rewriting instructions that perform suffix massaging. See
the &quot;REWRITING&quot; section for a detailed list of the
rewrite rules it implies.</p>

<p style="margin-left:11%;"><b>t&minus;f&minus;support
{NO|yes|discover}</b></p>

<p style="margin-left:22%;">enable if the remote server
supports absolute filters (see <i>RFC 4526</i> for details).
If set to <b>discover</b>, support is detected by reading
the remote server&rsquo;s root DSE. If set before any target
specification, it affects all targets, unless overridden by
any per-target directive.</p>

<p style="margin-left:11%;"><b>timeout
[&lt;op&gt;=]&lt;val&gt; [...]</b></p>

<p style="margin-left:22%;">This directive allows to set
per-operation timeouts. Operations can be</p>

<p style="margin-left:22%; margin-top: 1em"><b>&lt;op&gt;
::= bind, add, delete, modrdn, modify, compare,
search</b></p>

<p style="margin-left:22%; margin-top: 1em">The overall
duration of the <b>search</b> operation is controlled either
by the <b>timelimit</b> parameter or by server-side enforced
time limits (see <b>timelimit</b> and <b>limits</b> in
<b>slapd.conf</b>(5) for details). This <b>timeout</b>
parameter controls how long the target can be irresponsive
before the operation is aborted. Timeout is meaningless for
the remaining operations, <b>unbind</b> and <b>abandon</b>,
which do not imply any response, while it is not yet
implemented in currently supported <b>extended</b>
operations. If no operation is specified, the timeout
<b>val</b> affects all supported operations. If specified
before any target definition, it affects all targets unless
overridden by per-target directives.</p>

<p style="margin-left:22%; margin-top: 1em">Note: if the
timeout is exceeded, the operation is cancelled (according
to the <b>cancel</b> directive); the protocol does not
provide any means to rollback operations, so the client will
not be notified about the result of the operation, which may
eventually succeeded or not. In case the timeout is exceeded
during a bind operation, the connection is destroyed,
according to RFC4511.</p>

<p style="margin-left:11%;"><b>tls
{[try&minus;]start|[try&minus;]propagate}</b></p>

<p style="margin-left:22%;">execute the StartTLS extended
operation when the connection is initialized; only works if
the URI directive protocol scheme is not <b>ldaps://</b>.
<b>propagate</b> issues the StartTLS operation only if the
original connection did. The <b>try&minus;</b> prefix
instructs the proxy to continue operations if the StartTLS
operation failed; its use is highly deprecated. If set
before any target specification, it affects all targets,
unless overridden by any per-target directive.</p>

<h2>SCENARIOS
<a name="SCENARIOS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A powerful (and
in some sense dangerous) rewrite engine has been added to
both the LDAP and Meta backends. While the former can gain
limited beneficial effects from rewriting stuff, the latter
can become an amazingly powerful tool.</p>

<p style="margin-left:11%; margin-top: 1em">Consider a
couple of scenarios first.</p>

<p style="margin-left:11%; margin-top: 1em">1) Two
directory servers share two levels of naming context; say
&quot;dc=a,dc=foo,dc=com&quot; and
&quot;dc=b,dc=foo,dc=com&quot;. Then, an unambiguous Meta
database can be configured as:</p>

<p style="margin-left:22%; margin-top: 1em">database meta
<br>
suffix &quot;<b>dc=foo,dc=com</b>&quot; <br>
uri &quot;ldap://a.foo.com/dc=a,<b>dc=foo,dc=com</b>&quot;
<br>
uri
&quot;ldap://b.foo.com/dc=b,<b>dc=foo,dc=com</b>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Operations
directed to a specific target can be easily resolved because
there are no ambiguities. The only operation that may
resolve to multiple targets is a search with base
&quot;dc=foo,dc=com&quot; and scope at least
&quot;one&quot;, which results in spawning two searches to
the targets.</p>

<p style="margin-left:11%; margin-top: 1em">2a) Two
directory servers don&rsquo;t share any portion of naming
context, but they&rsquo;d present as a single DIT [Caveat:
uniqueness of (massaged) entries among the two servers is
assumed; integrity checks risk to incur in excessive
overhead and have not been implemented]. Say we have
&quot;dc=bar,dc=org&quot; and &quot;o=Foo,c=US&quot;, and
we&rsquo;d like them to appear as branches of
&quot;dc=foo,dc=com&quot;, say
&quot;dc=a,dc=foo,dc=com&quot; and
&quot;dc=b,dc=foo,dc=com&quot;. Then we need to configure
our Meta backend as:</p>

<p style="margin-left:22%; margin-top: 1em">database meta
<br>
suffix &quot;dc=foo,dc=com&quot;</p>

<p style="margin-left:22%; margin-top: 1em">uri
&quot;ldap://a.bar.com/<b>dc=a,dc=foo,dc=com</b>&quot; <br>
suffixmassage &quot;<b>dc=a,dc=foo,dc=com</b>&quot;
&quot;dc=bar,dc=org&quot;</p>

<p style="margin-left:22%; margin-top: 1em">uri
&quot;ldap://b.foo.com/<b>dc=b,dc=foo,dc=com</b>&quot; <br>
suffixmassage &quot;<b>dc=b,dc=foo,dc=com</b>&quot;
&quot;o=Foo,c=US&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Again,
operations can be resolved without ambiguity, although some
rewriting is required. Notice that the virtual naming
context of each target is a branch of the database&rsquo;s
naming context; it is rewritten back and forth when
operations are performed towards the target servers. What
&quot;back and forth&quot; means will be clarified
later.</p>

<p style="margin-left:11%; margin-top: 1em">When a search
with base &quot;dc=foo,dc=com&quot; is attempted, if the
scope is &quot;base&quot; it fails with &quot;no such
object&quot;; in fact, the common root of the two targets
(prior to massaging) does not exist. If the scope is
&quot;one&quot;, both targets are contacted with the base
replaced by each target&rsquo;s base; the scope is derated
to &quot;base&quot;. In general, a scope &quot;one&quot;
search is honored, and the scope is derated, only when the
incoming base is at most one level lower of a target&rsquo;s
naming context (prior to massaging).</p>

<p style="margin-left:11%; margin-top: 1em">Finally, if the
scope is &quot;sub&quot; the incoming base is replaced by
each target&rsquo;s unmassaged naming context, and the scope
is not altered.</p>

<p style="margin-left:11%; margin-top: 1em">2b) Consider
the above reported scenario with the two servers sharing the
same naming context:</p>

<p style="margin-left:22%; margin-top: 1em">database meta
<br>
suffix &quot;<b>dc=foo,dc=com</b>&quot;</p>

<p style="margin-left:22%; margin-top: 1em">uri
&quot;ldap://a.bar.com/<b>dc=foo,dc=com</b>&quot; <br>
suffixmassage &quot;<b>dc=foo,dc=com</b>&quot;
&quot;dc=bar,dc=org&quot;</p>

<p style="margin-left:22%; margin-top: 1em">uri
&quot;ldap://b.foo.com/<b>dc=foo,dc=com</b>&quot; <br>
suffixmassage &quot;<b>dc=foo,dc=com</b>&quot;
&quot;o=Foo,c=US&quot;</p>

<p style="margin-left:11%; margin-top: 1em">All the
previous considerations hold, except that now there is no
way to unambiguously resolve a DN. In this case, all the
operations that require an unambiguous target selection will
fail unless the DN is already cached or a default target has
been set. Practical configurations may result as a
combination of all the above scenarios.</p>

<h2>ACLs
<a name="ACLs"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note on ACLs:
at present you may add whatever ACL rule you desire to to
the Meta (and LDAP) backends. However, the meaning of an ACL
on a proxy may require some considerations. Two philosophies
may be considered:</p>

<p style="margin-left:11%; margin-top: 1em">a) the remote
server dictates the permissions; the proxy simply passes
back what it gets from the remote server.</p>

<p style="margin-left:11%; margin-top: 1em">b) the remote
server unveils &quot;everything&quot;; the proxy is
responsible for protecting data from unauthorized
access.</p>

<p style="margin-left:11%; margin-top: 1em">Of course the
latter sounds unreasonable, but it is not. It is possible to
imagine scenarios in which a remote host discloses data that
can be considered &quot;public&quot; inside an intranet, and
a proxy that connects it to the internet may impose
additional constraints. To this purpose, the proxy should be
able to comply with all the ACL matching criteria that the
server supports. This has been achieved with regard to all
the criteria supported by slapd except a special subtle case
(please file an ITS if you can find other exceptions:
&lt;http://www.openldap.org/its/&gt;). The rule</p>

<p style="margin-left:22%; margin-top: 1em">access to
dn=&quot;&lt;dn&gt;&quot; attrs=&lt;attr&gt; <br>
by dnattr=&lt;dnattr&gt; read <br>
by * none</p>

<p style="margin-left:11%; margin-top: 1em">cannot be
matched iff the attribute that is being requested,
&lt;attr&gt;, is NOT &lt;dnattr&gt;, and the attribute that
determines membership, &lt;dnattr&gt;, has not been
requested (e.g. in a search)</p>

<p style="margin-left:11%; margin-top: 1em">In fact this
ACL is resolved by slapd using the portion of entry it
retrieved from the remote server without requiring any
further intervention of the backend, so, if the
&lt;dnattr&gt; attribute has not been fetched, the match
cannot be assessed because the attribute is not present, not
because no value matches the requirement!</p>

<p style="margin-left:11%; margin-top: 1em">Note on ACLs
and attribute mapping: ACLs are applied to the mapped
attributes; for instance, if the attribute locally known as
&quot;foo&quot; is mapped to &quot;bar&quot; on a remote
server, then local ACLs apply to attribute &quot;foo&quot;
and are totally unaware of its remote name. The remote
server will check permissions for &quot;bar&quot;, and the
local server will possibly enforce additional restrictions
to &quot;foo&quot;.</p>

<h2>REWRITING
<a name="REWRITING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A string is
rewritten according to a set of rules, called a
&lsquo;rewrite context&rsquo;. The rules are based on POSIX
(&rsquo;&rsquo;extended&rsquo;&rsquo;) regular expressions
(regex) with substring matching; basic variable substitution
and map resolution of substrings is allowed by specific
mechanisms detailed in the following. The behavior of
pattern matching/substitution can be altered by a set of
flags.</p>

<p style="margin-left:11%; margin-top: 1em">The underlying
concept is to build a lightweight rewrite module for the
slapd server (initially dedicated to the LDAP backend).</p>

<h2>Passes
<a name="Passes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An incoming
string is matched against a set of rules. Rules are made of
a regex match pattern, a substitution pattern and a set of
actions, described by a set of flags. In case of match a
string rewriting is performed according to the substitution
pattern that allows to refer to substrings matched in the
incoming string. The actions, if any, are finally performed.
The substitution pattern allows map resolution of
substrings. A map is a generic object that maps a
substitution pattern to a value. The flags are divided in
&quot;Pattern matching Flags&quot; and &quot;Action
Flags&quot;; the former alter the regex match pattern
behavior while the latter alter the action that is taken
after substitution.</p>

<h2>Pattern Matching Flags
<a name="Pattern Matching Flags"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&lsquo;C&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">honors case in matching (default
is case insensitive)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;R&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>use POSIX &rsquo;&rsquo;basic&rsquo;&rsquo; regular
expressions (default is
&rsquo;&rsquo;extended&rsquo;&rsquo;)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;M{n}&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>allow no more than <b>n</b> recursive passes for a
specific rule; does not alter the max total count of passes,
so it can only enforce a stricter limit for a specific
rule.</p> </td></tr>
</table>

<h2>Action Flags
<a name="Action Flags"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&lsquo;:&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">apply the rule once only
(default is recursive)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;@&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>stop applying rules in case of match; the current rule
is still applied recursively; combine with &lsquo;:&rsquo;
to apply the current rule only once and then stop.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;#&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>stop current operation if the rule matches, and issue an
&lsquo;unwilling to perform&rsquo; error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;G{n}&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>jump <b>n</b> rules back and forth (watch for loops!).
Note that &lsquo;G{1}&rsquo; is implicit in every rule.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;I&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>ignores errors in rule; this means, in case of error,
e.g. issued by a map, the error is treated as a missed
match. The &lsquo;unwilling to perform&rsquo; is not
overridden.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&lsquo;U{n}&rsquo;</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>uses <b>n</b> as return code if the rule matches; the
flag does not alter the recursive behavior of the rule, so,
to have it performed only once, it must be used in
combination with &lsquo;:&rsquo;, e.g.
<b>&lsquo;:U{16}&rsquo;</b> returns the value
&lsquo;16&rsquo; after exactly one execution of the rule, if
the pattern matches. As a consequence, its behavior is
equivalent to &lsquo;@&rsquo;, with the return code set to
<b>n</b>; or, in other words, &lsquo;@&rsquo; is equivalent
to &lsquo;U{0}&rsquo;. By convention, the freely available
codes are above 16 included; the others are reserved.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The ordering of
the flags can be significant. For instance:
&lsquo;IG{2}&rsquo; means ignore errors and jump two lines
ahead both in case of match and in case of error, while
&lsquo;G{2}I&rsquo; means ignore errors, but jump two lines
ahead only in case of match.</p>

<p style="margin-left:11%; margin-top: 1em">More flags
(mainly Action Flags) will be added as needed.</p>

<h2>Pattern matching:
<a name="Pattern matching:"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>regex</b>(7) and/or <b>re_format</b>(7).</p>

<h2>Substitution Pattern Syntax:
<a name="Substitution Pattern Syntax:"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Everything
starting with &lsquo;%&rsquo; requires substitution;</p>

<p style="margin-left:11%; margin-top: 1em">the only
obvious exception is &lsquo;%%&rsquo;, which is left as
is;</p>

<p style="margin-left:11%; margin-top: 1em">the basic
substitution is &lsquo;%d&rsquo;, where &lsquo;d&rsquo; is a
digit; 0 means the whole string, while 1-9 is a
submatch;</p>

<p style="margin-left:11%; margin-top: 1em">a
&lsquo;%&rsquo; followed by a &lsquo;{&rsquo; invokes an
advanced substitution. The pattern is:</p>


<p style="margin-left:22%; margin-top: 1em">&lsquo;%&rsquo;
&lsquo;{&rsquo; [ &lt;op&gt; ] &lt;name&gt; &lsquo;(&rsquo;
&lt;substitution&gt; &lsquo;)&rsquo; &lsquo;}&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">where
&lt;name&gt; must be a legal name for the map, i.e.</p>

<p style="margin-left:22%; margin-top: 1em">&lt;name&gt;
::= [a-z][a-z0-9]* (case insensitive) <br>
&lt;op&gt; ::= &lsquo;&gt;&rsquo; &lsquo;|&rsquo;
&lsquo;&amp;&rsquo; &lsquo;&amp;&amp;&rsquo; &lsquo;*&rsquo;
&lsquo;**&rsquo; &lsquo;$&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">and
&lt;substitution&gt; must be a legal substitution pattern,
with no limits on the nesting level.</p>

<p style="margin-left:11%; margin-top: 1em">The operators
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>&gt;</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">sub context invocation;
&lt;name&gt; must be a legal, already defined rewrite
context name</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>|</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>external command invocation; &lt;name&gt; must refer to
a legal, already defined command name (NOT IMPL.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>&amp;</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>variable assignment; &lt;name&gt; defines a variable in
the running operation structure which can be dereferenced
later; operator <b>&amp;</b> assigns a variable in the
rewrite context scope; operator <b>&amp;&amp;</b> assigns a
variable that scopes the entire session, e.g. its value can
be dereferenced later by other rewrite contexts</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>*</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>variable dereferencing; &lt;name&gt; must refer to a
variable that is defined and assigned for the running
operation; operator <b>*</b> dereferences a variable scoping
the rewrite context; operator <b>**</b> dereferences a
variable scoping the whole session, e.g. the value is passed
across rewrite contexts</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>$</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>parameter dereferencing; &lt;name&gt; must refer to an
existing parameter; the idea is to make some run-time
parameters set by the system available to the rewrite
engine, as the client host name, the bind DN if any,
constant parameters initialized at config time, and so on;
no parameter is currently set by either
<b>back&minus;ldap</b> or <b>back&minus;meta</b>, but
constant parameters can be defined in the configuration file
by using the <b>rewriteParam</b> directive.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Substitution
escaping has been delegated to the &lsquo;%&rsquo; symbol,
which is used instead of &lsquo;\&rsquo; in string
substitution patterns because &lsquo;\&rsquo; is already
escaped by slapd&rsquo;s low level parsing routines; as a
consequence, regex escaping requires two &lsquo;\&rsquo;
symbols, e.g. &lsquo;<b>.*\.foo\.bar</b>&rsquo; must be
written as &lsquo;<b>.*\\.foo\\.bar</b>&rsquo;.</p>

<h2>Rewrite context:
<a name="Rewrite context:"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A rewrite
context is a set of rules which are applied in sequence. The
basic idea is to have an application initialize a rewrite
engine (think of Apache&rsquo;s mod_rewrite ...) with a set
of rewrite contexts; when string rewriting is required, one
invokes the appropriate rewrite context with the input
string and obtains the newly rewritten one if no errors
occur.</p>

<p style="margin-left:11%; margin-top: 1em">Each basic
server operation is associated to a rewrite context; they
are divided in two main groups: client &minus;&gt; server
and server &minus;&gt; client rewriting.</p>

<p style="margin-left:11%; margin-top: 1em">client
&minus;&gt; server:</p>

<p style="margin-left:22%; margin-top: 1em">(default) if
defined and no specific context <br>
is available <br>
bindDN bind <br>
searchBase search <br>
searchFilter search <br>
searchFilterAttrDN search <br>
compareDN compare <br>
compareAttrDN compare AVA <br>
addDN add <br>
addAttrDN add AVA <br>
modifyDN modify <br>
modifyAttrDN modify AVA <br>
modrDN modrdn <br>
newSuperiorDN modrdn <br>
deleteDN delete <br>
exopPasswdDN password modify extended operation DN if
proxy</p>

<p style="margin-left:11%; margin-top: 1em">server
&minus;&gt; client:</p>

<p style="margin-left:22%; margin-top: 1em">searchResult
search (only if defined; no default; <br>
acts on DN and DN-syntax attributes <br>
of search results) <br>
searchAttrDN search AVA <br>
matchedDN all ops (only if applicable)</p>

<h2>Basic configuration syntax
<a name="Basic configuration syntax"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>rewriteEngine
{ on | off }</b></p>

<p style="margin-left:22%;">If &lsquo;on&rsquo;, the
requested rewriting is performed; if &lsquo;off&rsquo;, no
rewriting takes place (an easy way to stop rewriting without
altering too much the configuration file).</p>

<p style="margin-left:11%;"><b>rewriteContext &lt;context
name&gt; [ alias &lt;aliased context name&gt; ]</b></p>

<p style="margin-left:22%;">&lt;Context name&gt; is the
name that identifies the context, i.e. the name used by the
application to refer to the set of rules it contains. It is
used also to reference sub contexts in string rewriting. A
context may alias another one. In this case the alias
context contains no rule, and any reference to it will
result in accessing the aliased one.</p>

<p style="margin-left:11%;"><b>rewriteRule &lt;regex match
pattern&gt; &lt;substitution pattern&gt; [ &lt;flags&gt;
]</b></p>

<p style="margin-left:22%;">Determines how a string can be
rewritten if a pattern is matched. Examples are reported
below.</p>

<h2>Additional configuration syntax:
<a name="Additional configuration syntax:"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>rewriteMap
&lt;map type&gt; &lt;map name&gt; [ &lt;map attrs&gt;
]</b></p>

<p style="margin-left:22%;">Allows to define a map that
transforms substring rewriting into something else. The map
is referenced inside the substitution pattern of a rule.</p>

<p style="margin-left:11%;"><b>rewriteParam &lt;param
name&gt; &lt;param value&gt;</b></p>

<p style="margin-left:22%;">Sets a value with global scope,
that can be dereferenced by the command
&lsquo;%{$paramName}&rsquo;.</p>

<p style="margin-left:11%;"><b>rewriteMaxPasses &lt;number
of passes&gt; [&lt;number of passes per rule&gt;]</b></p>

<p style="margin-left:22%;">Sets the maximum number of
total rewriting passes that can be performed in a single
rewrite operation (to avoid loops). A safe default is set to
100; note that reaching this limit is still treated as a
success; recursive invocation of rules is simply
interrupted. The count applies to the rewriting operation as
a whole, not to any single rule; an optional per-rule limit
can be set. This limit is overridden by setting specific
per-rule limits with the &lsquo;M{n}&rsquo; flag.</p>

<h2>Configuration examples:
<a name="Configuration examples:"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"># set to
&lsquo;off&rsquo; to disable rewriting <br>
rewriteEngine on</p>

<p style="margin-left:11%; margin-top: 1em"># the rules the
&quot;suffixmassage&quot; directive implies <br>
rewriteEngine on <br>
# all dataflow from client to server referring to DNs <br>
rewriteContext default <br>
rewriteRule &quot;(.*)&lt;virtualnamingcontext&gt;$&quot;
&quot;%1&lt;realnamingcontext&gt;&quot; &quot;:&quot; <br>
# empty filter rule <br>
rewriteContext searchFilter <br>
# all dataflow from server to client <br>
rewriteContext searchResult <br>
rewriteRule &quot;(.*)&lt;realnamingcontext&gt;$&quot;
&quot;%1&lt;virtualnamingcontext&gt;&quot; &quot;:&quot;
<br>
rewriteContext searchAttrDN alias searchResult <br>
rewriteContext matchedDN alias searchResult</p>

<p style="margin-left:11%; margin-top: 1em"># Everything
defined here goes into the &lsquo;default&rsquo; context.
<br>
# This rule changes the naming context of anything sent <br>
# to &lsquo;dc=home,dc=net&rsquo; to &lsquo;dc=OpenLDAP,
dc=org&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">rewriteRule
&quot;(.*)dc=home,[ ]?dc=net&quot; <br>
&quot;%1dc=OpenLDAP, dc=org&quot; &quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># since a
pretty/normalized DN does not include spaces <br>
# after rdn separators, e.g. &lsquo;,&rsquo;, this rule
suffices:</p>

<p style="margin-left:11%; margin-top: 1em">rewriteRule
&quot;(.*)dc=home,dc=net&quot; <br>
&quot;%1dc=OpenLDAP,dc=org&quot; &quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># Start a new
context (ends input of the previous one). <br>
# This rule adds blanks between DN parts if not present.
<br>
rewriteContext addBlanks <br>
rewriteRule &quot;(.*),([^ ].*)&quot; &quot;%1, %2&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># This one eats
blanks <br>
rewriteContext eatBlanks <br>
rewriteRule &quot;(.*),[ ](.*)&quot; &quot;%1,%2&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># Here control
goes back to the default rewrite <br>
# context; rules are appended to the existing ones. <br>
# anything that gets here is piped into rule
&lsquo;addBlanks&rsquo; <br>
rewriteContext default <br>
rewriteRule &quot;.*&quot; &quot;%{&gt;addBlanks(%0)}&quot;
&quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># Rewrite the
search base according to &lsquo;default&rsquo; rules. <br>
rewriteContext searchBase alias default</p>

<p style="margin-left:11%; margin-top: 1em"># Search
results with OpenLDAP DN are rewritten back with <br>
# &lsquo;dc=home,dc=net&rsquo; naming context, with spaces
eaten. <br>
rewriteContext searchResult <br>
rewriteRule &quot;(.*[^ ]?)[ ]?dc=OpenLDAP,[ ]?dc=org&quot;
<br>
&quot;%{&gt;eatBlanks(%1)}dc=home,dc=net&quot;
&quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># Bind with
email instead of full DN: we first need <br>
# an ldap map that turns attributes into a DN (the <br>
# argument used when invoking the map is appended to <br>
# the URI and acts as the filter portion) <br>
rewriteMap ldap attr2dn
&quot;ldap://host/dc=my,dc=org?dn?sub&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># Then we need
to detect DN made up of a single email, <br>
# e.g. &lsquo;mail=someone@example.com&rsquo;; note that the
rule <br>
# in case of match stops rewriting; in case of error, <br>
# it is ignored. In case we are mapping virtual <br>
# to real naming contexts, we also need to rewrite <br>
# regular DNs, because the definition of a bindDn <br>
# rewrite context overrides the default definition. <br>
rewriteContext bindDN <br>
rewriteRule &quot;^mail=[^,]+@[^,]+$&quot;
&quot;%{attr2dn(%0)}&quot; &quot;:@I&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># This is a
rather sophisticated example. It massages a <br>
# search filter in case who performs the search has <br>
# administrative privileges. First we need to keep <br>
# track of the bind DN of the incoming request, which is
<br>
# stored in a variable called &lsquo;binddn&rsquo; with
session scope, <br>
# and left in place to allow regular binding: <br>
rewriteContext bindDN <br>
rewriteRule &quot;.+&quot;
&quot;%{&amp;&amp;binddn(%0)}%0&quot; &quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># A search
filter containing &lsquo;uid=&rsquo; is rewritten only <br>
# if an appropriate DN is bound. <br>
# To do this, in the first rule the bound DN is <br>
# dereferenced, while the filter is decomposed in a <br>
# prefix, in the value of the &lsquo;uid=&lt;arg&gt;&rsquo;
AVA, and <br>
# in a suffix. A tag &lsquo;&lt;&gt;&rsquo; is appended to
the DN. <br>
# If the DN refers to an entry in the &lsquo;ou=admin&rsquo;
subtree, <br>
# the filter is rewritten OR-ing the
&lsquo;uid=&lt;arg&gt;&rsquo; with <br>
# &lsquo;cn=&lt;arg&gt;&rsquo;; otherwise it is left as is.
This could be <br>
# useful, for instance, to allow apache&rsquo;s
auth_ldap-1.4 <br>
# module to authenticate users with both &lsquo;uid&rsquo;
and <br>
# &lsquo;cn&rsquo;, but only if the request comes from a
possible <br>
# &lsquo;cn=Web auth,ou=admin,dc=home,dc=net&rsquo; user.
<br>
rewriteContext searchFilter <br>
rewriteRule &quot;(.*\\()uid=([a-z0-9_]+)(\\).*)&quot; <br>

&quot;%{**binddn}&lt;&gt;%{&amp;prefix(%1)}%{&amp;arg(%2)}%{&amp;suffix(%3)}&quot;
<br>
&quot;:I&quot; <br>
rewriteRule &quot;[^,]+,ou=admin,dc=home,dc=net&quot; <br>
&quot;%{*prefix}|(uid=%{*arg})(cn=%{*arg})%{*suffix}&quot;
&quot;:@I&quot; <br>
rewriteRule &quot;.*&lt;&gt;&quot;
&quot;%{*prefix}uid=%{*arg}%{*suffix}&quot;
&quot;:&quot;</p>

<p style="margin-left:11%; margin-top: 1em"># This example
shows how to strip unwanted DN-valued <br>
# attribute values from a search result; the first rule <br>
# matches DN values below
&quot;ou=People,dc=example,dc=com&quot;; <br>
# in case of match the rewriting exits successfully. <br>
# The second rule matches everything else and causes <br>
# the value to be rejected. <br>
rewriteContext searchResult <br>
rewriteRule &quot;.*,ou=People,dc=example,dc=com&quot;
&quot;%0&quot; &quot;:@&quot; <br>
rewriteRule &quot;.*&quot; &quot;&quot; &quot;#&quot;</p>

<h2>LDAP Proxy resolution (a possible evolution of slapd&minus;ldap(5)):
<a name="LDAP Proxy resolution (a possible evolution of slapd&minus;ldap(5)):"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In case the
rewritten DN is an LDAP URI, the operation is initiated
towards the host[:port] indicated in the uri, if it does not
refer to the local server. E.g.:</p>

<p style="margin-left:11%; margin-top: 1em">rewriteRule
&rsquo;^cn=root,.*&rsquo; &rsquo;%0&rsquo;
&rsquo;G{3}&rsquo; <br>
rewriteRule &rsquo;^cn=[a-l].*&rsquo;
&rsquo;ldap://ldap1.my.org/%0&rsquo; &rsquo;:@&rsquo; <br>
rewriteRule &rsquo;^cn=[m-z].*&rsquo;
&rsquo;ldap://ldap2.my.org/%0&rsquo; &rsquo;:@&rsquo; <br>
rewriteRule &rsquo;.*&rsquo;
&rsquo;ldap://ldap3.my.org/%0&rsquo; &rsquo;:@&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">(Rule 1 is
simply there to illustrate the &lsquo;G{n}&rsquo; action; it
could have been written:</p>

<p style="margin-left:11%; margin-top: 1em">rewriteRule
&rsquo;^cn=root,.*&rsquo;
&rsquo;ldap://ldap3.my.org/%0&rsquo; &rsquo;:@&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">with the
advantage of saving one rewrite pass ...)</p>

<h2>ACCESS CONTROL
<a name="ACCESS CONTROL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <b>meta</b>
backend does not honor all ACL semantics as described in
<b>slapd.access</b>(5). In general, access checking is
delegated to the remote server(s). Only <b>read (=r)</b>
access to the <b>entry</b> pseudo-attribute and to the other
attribute values of the entries returned by the
<b>search</b> operation is honored, which is performed by
the frontend.</p>

<h2>PROXY CACHE OVERLAY
<a name="PROXY CACHE OVERLAY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The proxy cache
overlay allows caching of LDAP search requests (queries) in
a local database. See <b>slapo&minus;pcache</b>(5) for
details.</p>

<h2>DEPRECATED STATEMENTS
<a name="DEPRECATED STATEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
statements have been deprecated and should no longer be
used. <b><br>
pseudorootdn &lt;substitute DN in case of rootdn
bind&gt;</b></p>

<p style="margin-left:22%;">Use <b>idassert&minus;bind</b>
instead.</p>

<p style="margin-left:11%;"><b>pseudorootpw &lt;substitute
password in case of rootdn bind&gt;</b></p>

<p style="margin-left:22%;">Use <b>idassert&minus;bind</b>
instead.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">/etc/openldap/slapd.conf</p>

<p style="margin-left:22%;">default slapd configuration
file</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>slapd.conf</b>(5),
<b>slapd&minus;ldap</b>(5), <b>slapo&minus;pcache</b>(5),
<b>slapd</b>(8), <b>regex</b>(7), <b>re_format</b>(7).</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Pierangelo
Masarati, based on back-ldap by Howard Chu</p>
<hr>
</body>
</html>
