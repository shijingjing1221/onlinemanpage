<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:49:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Twig</title>

</head>
<body>

<h1 align="center">Twig</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#XML::Twig 101">XML::Twig 101</a><br>
<a href="#Simplifying XML processing">Simplifying XML processing</a><br>
<a href="#CLASSES">CLASSES</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#Globals">Globals</a><br>
<a href="#TODO">TODO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#POD ERRORS">POD ERRORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::Twig
&minus; A perl module for processing huge XML documents in
tree mode.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that this
documentation is intended as a reference to the module.</p>

<p style="margin-left:11%; margin-top: 1em">Complete docs,
including a tutorial, examples, an easier to use
<small>HTML</small> version, a quick reference card and a
<small>FAQ</small> are available at
&lt;http://www.xmltwig.org/xmltwig&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Small documents
(loaded in memory as a tree):</p>

<pre style="margin-left:11%; margin-top: 1em">  my $twig=XML::Twig&minus;&gt;new();    # create the twig
  $twig&minus;&gt;parsefile( 'doc.xml'); # build it
  my_process( $twig);           # use twig methods to process it
  $twig&minus;&gt;print;                 # output the twig</pre>


<p style="margin-left:11%; margin-top: 1em">Huge documents
(processed in combined stream/tree mode):</p>

<pre style="margin-left:11%; margin-top: 1em">  # at most one div will be loaded in memory
  my $twig=XML::Twig&minus;&gt;new(
    twig_handlers =&gt;
      { title   =&gt; sub { $_&minus;&gt;set_tag( 'h2') }, # change title tags to h2
        para    =&gt; sub { $_&minus;&gt;set_tag( 'p')  }, # change para to p
        hidden  =&gt; sub { $_&minus;&gt;delete;       },  # remove hidden elements
        list    =&gt; \&amp;my_list_process,          # process list elements
        div     =&gt; sub { $_[0]&minus;&gt;flush;     },  # output and free memory
      },
    pretty_print =&gt; 'indented',                # output will be nicely formatted
    empty_tags   =&gt; 'html',                    # outputs &lt;empty_tag /&gt;
                         );
  $twig&minus;&gt;parsefile( 'my_big.xml');</pre>


<p style="margin-left:11%; margin-top: 1em">See XML::Twig
101 for other ways to use the module, as a filter for
example.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module
provides a way to process <small>XML</small> documents. It
is build on top of <tt>&quot;XML::Parser&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The module
offers a tree interface to the document, while allowing you
to output the parts of it that have been completely
processed.</p>

<p style="margin-left:11%; margin-top: 1em">It allows
minimal resource ( <small>CPU</small> and memory) usage by
building the tree only for the parts of the documents that
need actual processing, through the use of the
<tt>&quot;twig_roots &quot;</tt> and
<tt>&quot;twig_print_outside_roots &quot;</tt> options. The
<tt>&quot;finish &quot;</tt> and <tt>&quot;finish_print
&quot;</tt> methods also help to increase performances.</p>

<p style="margin-left:11%; margin-top: 1em">XML::Twig tries
to make simple things easy so it tries its best to takes
care of a lot of the (usually) annoying (but sometimes
necessary) features that come with <small>XML</small> and
XML::Parser.</p>

<h2>XML::Twig 101
<a name="XML::Twig 101"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::Twig can
be used either on &quot;small&quot; <small>XML</small>
documents (that fit in memory) or on huge ones, by
processing parts of the document and outputting or
discarding them once they are processed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Loading an
<small>XML</small> document and processing it</b></p>

<pre style="margin-left:11%;">  my $t= XML::Twig&minus;&gt;new();
  $t&minus;&gt;parse( '&lt;d&gt;&lt;title&gt;title&lt;/title&gt;&lt;para&gt;p 1&lt;/para&gt;&lt;para&gt;p 2&lt;/para&gt;&lt;/d&gt;');
  my $root= $t&minus;&gt;root;
  $root&minus;&gt;set_tag( 'html');              # change doc to html
  $title= $root&minus;&gt;first_child( 'title'); # get the title
  $title&minus;&gt;set_tag( 'h1');               # turn it into h1
  my @para= $root&minus;&gt;children( 'para');   # get the para children
  foreach my $para (@para)
    { $para&minus;&gt;set_tag( 'p'); }           # turn them into p
  $t&minus;&gt;print;                            # output the document</pre>


<p style="margin-left:11%; margin-top: 1em">Other useful
methods include:</p>

<p style="margin-left:11%; margin-top: 1em">att:
<tt>&quot;$elt&minus;&gt;{'att'}&minus;&gt;{'foo'}&quot;</tt>
return the <tt>&quot;foo&quot;</tt> attribute for an
element,</p>

<p style="margin-left:11%; margin-top: 1em">set_att :
<tt>&quot;$elt&minus;&gt;set_att( foo =&gt;
&quot;bar&quot;)&quot;</tt> sets the
<tt>&quot;foo&quot;</tt> attribute to the
<tt>&quot;bar&quot;</tt> value,</p>

<p style="margin-left:11%; margin-top: 1em">next_sibling:
<tt>&quot;$elt&minus;&gt;{next_sibling}&quot;</tt> return
the next sibling in the document (in the example
<tt>&quot;$title&minus;&gt;{next_sibling}&quot;</tt> is the
first <tt>&quot;para&quot;</tt>, you can also (and actually
should) use <tt>&quot;$elt&minus;&gt;next_sibling(
'para')&quot;</tt> to get it</p>

<p style="margin-left:11%; margin-top: 1em">The document
can also be transformed through the use of the cut, copy,
paste and move methods: <tt>&quot;$title&minus;&gt;cut;
$title&minus;&gt;paste( after =&gt; $p);&quot;</tt> for
example</p>

<p style="margin-left:11%; margin-top: 1em">And much, much
more, see XML::Twig::Elt.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Processing
an <small>XML</small> document chunk by chunk</b> <br>
One of the strengths of XML::Twig is that it let you work
with files that do not fit in memory ( <small>BTW</small>
storing an <small>XML</small> document in memory as a tree
is quite memory-expensive, the expansion factor being often
around 10).</p>

<p style="margin-left:11%; margin-top: 1em">To do this you
can define handlers, that will be called once a specific
element has been completely parsed. In these handlers you
can access the element and process it as you see fit, using
the navigation and the cut-n-paste methods, plus lots of
convenient ones like <tt>&quot;prefix &quot;</tt>. Once the
element is completely processed you can then <tt>&quot;flush
&quot;</tt> it, which will output it and free the memory.
You can also <tt>&quot;purge &quot;</tt> it if you
don&rsquo;t need to output it (if you are just extracting
some data from the document for example). The handler will
be called again once the next relevant element has been
parsed.</p>

<pre style="margin-left:11%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( twig_handlers =&gt;
                          { section =&gt; \&amp;section,
                            para   =&gt; sub { $_&minus;&gt;set_tag( 'p'); }
                          },
                       );
  $t&minus;&gt;parsefile( 'doc.xml');
  # the handler is called once a section is completely parsed, ie when
  # the end tag for section is found, it receives the twig itself and
  # the element (including all its sub&minus;elements) as arguments
  sub section
    { my( $t, $section)= @_;      # arguments for all twig_handlers
      $section&minus;&gt;set_tag( 'div');  # change the tag name.4, my favourite method...
      # let's use the attribute nb as a prefix to the title
      my $title= $section&minus;&gt;first_child( 'title'); # find the title
      my $nb= $title&minus;&gt;{'att'}&minus;&gt;{'nb'}; # get the attribute
      $title&minus;&gt;prefix( &quot;$nb &minus; &quot;);  # easy isn't it?
      $section&minus;&gt;flush;            # outputs the section and frees memory
    }</pre>


<p style="margin-left:11%; margin-top: 1em">There is of
course more to it: you can trigger handlers on more
elaborate conditions than just the name of the element,
<tt>&quot;section/title&quot;</tt> for example.</p>

<pre style="margin-left:11%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( twig_handlers =&gt;
                           { 'section/title' =&gt; sub { $_&minus;&gt;print } }
                       )
                  &minus;&gt;parsefile( 'doc.xml');</pre>


<p style="margin-left:11%; margin-top: 1em">Here
<tt>&quot;sub { $_&minus;&gt;print }&quot;</tt> simply
prints the current element (<tt>$_</tt> is aliased to the
element in the handler).</p>

<p style="margin-left:11%; margin-top: 1em">You can also
trigger a handler on a test on an attribute:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( twig_handlers =&gt;
                      { 'section[@level=&quot;1&quot;]' =&gt; sub { $_&minus;&gt;print } }
                       );
                  &minus;&gt;parsefile( 'doc.xml');</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
use <tt>&quot;start_tag_handlers &quot;</tt> to process an
element as soon as the start tag is found. Besides
<tt>&quot;prefix &quot;</tt> you can also use
<tt>&quot;suffix &quot;</tt>,</p>

<p style="margin-left:11%; margin-top: 1em"><b>Processing
just parts of an <small>XML</small> document</b> <br>
The twig_roots mode builds only the required sub-trees from
the document Anything outside of the twig roots will just be
ignored:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new(
       # the twig will include just the root and selected titles
           twig_roots   =&gt; { 'section/title' =&gt; \&amp;print_n_purge,
                             'annex/title'   =&gt; \&amp;print_n_purge
           }
                      );
  $t&minus;&gt;parsefile( 'doc.xml');
  sub print_n_purge
    { my( $t, $elt)= @_;
      print $elt&minus;&gt;text;    # print the text (including sub&minus;element texts)
      $t&minus;&gt;purge;           # frees the memory
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You can use
that mode when you want to process parts of a documents but
are not interested in the rest and you don&rsquo;t want to
pay the price, either in time or memory, to build the tree
for the it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Building an
<small>XML</small> filter</b> <br>
You can combine the <tt>&quot;twig_roots&quot;</tt> and the
<tt>&quot;twig_print_outside_roots&quot;</tt> options to
build filters, which let you modify selected elements and
will output the rest of the document as is.</p>

<p style="margin-left:11%; margin-top: 1em">This would
convert prices in $ to prices in Euro in a document:</p>

<pre style="margin-left:11%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new(
           twig_roots   =&gt; { 'price' =&gt; \&amp;convert, },   # process prices
           twig_print_outside_roots =&gt; 1,               # print the rest
                      );
  $t&minus;&gt;parsefile( 'doc.xml');
  sub convert
    { my( $t, $price)= @_;
      my $currency=  $price&minus;&gt;{'att'}&minus;&gt;{'currency'};          # get the currency
      if( $currency eq 'USD')
        { $usd_price= $price&minus;&gt;text;                     # get the price
          # %rate is just a conversion table
          my $euro_price= $usd_price * $rate{usd2euro};
          $price&minus;&gt;set_text( $euro_price);               # set the new price
          $price&minus;&gt;set_att( currency =&gt; 'EUR');          # don't forget this!
        }
      $price&minus;&gt;print;                                    # output the price
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig
and various versions of Perl, XML::Parser and expat:</b>
<br>
XML::Twig is a lot more sensitive to variations in versions
of perl, XML::Parser and expat than to the
<small>OS,</small> so this should cover some reasonable
configurations.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;recommended configuration&quot; is perl 5.8.3+ (for
good Unicode support), XML::Parser 2.31+ and expat
1.95.5+</p>

<p style="margin-left:11%; margin-top: 1em">See
&lt;http://testers.cpan.org/search?request=dist&amp;dist=XML&minus;Twig&gt;
for the <small>CPAN</small> testers reports on XML::Twig,
which list all tested configurations.</p>

<p style="margin-left:11%; margin-top: 1em">An Atom feed of
the <small>CPAN</small> Testers results is available at
&lt;http://xmltwig.org/rss/twig_testers.rss&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Finally: <br>
XML::Twig does <b><small>NOT</small></b> work with expat
1.95.4 <br>
XML::Twig only works with XML::Parser 2.27 in perl 5.6.*</p>

<p style="margin-left:17%;">Note that I can&rsquo;t compile
XML::Parser 2.27 anymore, so I can&rsquo;t guarantee that it
still works</p>

<p style="margin-left:11%;">XML::Parser 2.28 does not
really work</p>

<p style="margin-left:11%; margin-top: 1em">When in doubt,
upgrade expat, XML::Parser and Scalar::Util</p>

<p style="margin-left:11%; margin-top: 1em">Finally, for
some optional features, XML::Twig depends on some additional
modules. The complete list, which depends somewhat on the
version of Perl that you are running, is given by running
<tt>&quot;t/zz_dump_config.t&quot;</tt></p>

<h2>Simplifying XML processing
<a name="Simplifying XML processing"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Whitespaces</p>

<p style="margin-left:17%;">Whitespaces that look
non-significant are discarded, this behaviour can be
controlled using the <tt>&quot;keep_spaces &quot;</tt>,
<tt>&quot;keep_spaces_in &quot;</tt> and
<tt>&quot;discard_spaces_in &quot;</tt> options.</p>

<p style="margin-left:11%;">Encoding</p>

<p style="margin-left:17%;">You can specify that you want
the output in the same encoding as the input (provided you
have valid <small>XML,</small> which means you have to
specify the encoding either in the document or when you
create the Twig object) using the <tt>&quot;keep_encoding
&quot;</tt> option</p>

<p style="margin-left:17%; margin-top: 1em">You can also
use <tt>&quot;output_encoding&quot;</tt> to convert the
internal <small>UTF&minus;8</small> format to the required
encoding.</p>

<p style="margin-left:11%;">Comments and Processing
Instructions ( <small>PI</small> )</p>

<p style="margin-left:17%;">Comments and <small>PI</small>
&rsquo;s can be hidden from the processing, but still appear
in the output (they are carried by the &quot;real&quot;
element closer to them)</p>

<p style="margin-left:11%;">Pretty Printing</p>

<p style="margin-left:17%;">XML::Twig can output the
document pretty printed so it is easier to read for us
humans.</p>

<p style="margin-left:11%;">Surviving an untimely death</p>

<p style="margin-left:17%;"><small>XML</small> parsers are
supposed to react violently when fed improper
<small>XML.</small> XML::Parser just dies.</p>

<p style="margin-left:17%; margin-top: 1em">XML::Twig
provides the <tt>&quot;safe_parse &quot;</tt> and the
<tt>&quot;safe_parsefile &quot;</tt> methods which wrap the
parse in an eval and return either the parsed twig or 0 in
case of failure.</p>

<p style="margin-left:11%;">Private attributes</p>

<p style="margin-left:17%;">Attributes with a name starting
with # (illegal in <small>XML</small> ) will not be output,
so you can safely use them to store temporary values during
processing. Note that you can store anything in a private
attribute, not just text, it&rsquo;s just a regular Perl
variable, so a reference to an object or a huge data
structure is perfectly fine.</p>

<h2>CLASSES
<a name="CLASSES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XML::Twig uses
a very limited number of classes. The ones you are most
likely to use are <tt>&quot;XML::Twig&quot;</tt> of course,
which represents a complete <small>XML</small> document,
including the document itself (the root of the document
itself is <tt>&quot;root&quot;</tt>), its handlers, its
input or output filters... The other main class is
<tt>&quot;XML::Twig::Elt&quot;</tt>, which models an
<small>XML</small> element. Element here has a very wide
definition: it can be a regular element, or but also text,
with an element <tt>&quot;tag&quot;</tt> of
<tt>&quot;#PCDATA&quot;</tt> (or
<tt>&quot;#CDATA&quot;</tt>), an entity (tag is
<tt>&quot;#ENT&quot;</tt>), a Processing Instruction
(<tt>&quot;#PI&quot;</tt>), a comment
(<tt>&quot;#COMMENT&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">Those are the 2
commonly used classes.</p>

<p style="margin-left:11%; margin-top: 1em">You might want
to look the <tt>&quot;elt_class&quot;</tt> option if you
want to subclass <tt>&quot;XML::Twig::Elt&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Attributes are
just attached to their parent element, they are not objects
per se. (Please use the provided methods
<tt>&quot;att&quot;</tt> and <tt>&quot;set_att&quot;</tt> to
access them, if you access them as a hash, then your code
becomes implementaion dependent and might break in the
future).</p>

<p style="margin-left:11%; margin-top: 1em">Other classes
that are seldom used are
<tt>&quot;XML::Twig::Entity_list&quot;</tt> and
<tt>&quot;XML::Twig::Entity&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If you use
<tt>&quot;XML::Twig::XPath&quot;</tt> instead of
<tt>&quot;XML::Twig&quot;</tt>, elements are then created as
<tt>&quot;XML::Twig::XPath::Elt&quot;</tt></p>

<h2>METHODS
<a name="METHODS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><tt><b>XML::Twig</b></tt>
<br>
A twig is a subclass of XML::Parser, so all XML::Parser
methods can be called on a twig object, including parse and
parsefile. <tt>&quot;setHandlers&quot;</tt> on the other
hand cannot be used, see <tt>&quot;BUGS &quot;</tt></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>new</p></td>
<td width="2%"></td>
<td width="83%">


<p>This is a class method, the constructor for XML::Twig.
Options are passed as keyword value pairs. Recognized
options are the same as XML::Parser, plus some (in fact a
lot!) XML::Twig specifics.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">New Options:
<br>
twig_handlers</p>

<p style="margin-left:23%;">This argument consists of a
hash <tt>&quot;{ expression =&quot;</tt> \&amp;handler}&gt;
where expression is a an <i>XPath-like expression</i> (+
some others).</p>

<p style="margin-left:23%; margin-top: 1em">XPath
expressions are limited to using the child and descendant
axis (indeed you can&rsquo;t specify an axis), and
predicates cannot be nested. You can use the
<tt>&quot;string&quot;</tt>, or
<tt>&quot;string(&lt;tag&gt;)&quot;</tt> function (except in
<tt>&quot;twig_roots&quot;</tt> triggers).</p>

<p style="margin-left:23%; margin-top: 1em">Additionally
you can use regexps (/ delimited) to match attribute and
string values.</p>

<p style="margin-left:23%; margin-top: 1em">Examples:</p>

<pre style="margin-left:23%; margin-top: 1em">  foo
  foo/bar
  foo//bar
  /foo/bar
  /foo//bar
  /foo/bar[@att1 = &quot;val1&quot; and @att2 = &quot;val2&quot;]/baz[@a &gt;= 1]
  foo[string()=~ /^duh!+/]
  /foo[string(bar)=~ /\d+/]/baz[@att != 3]</pre>


<p style="margin-left:23%; margin-top: 1em">#CDATA can be
used to call a handler for a <small>CDATA</small> section.
#COMMENT can be used to call a handler for comments</p>

<p style="margin-left:23%; margin-top: 1em">Some additional
(non-XPath) expressions are also provided for convenience:
<br>
processing instructions</p>

<p style="margin-left:29%;"><tt>'?'</tt> or <tt>'#PI'</tt>
triggers the handler for any processing instruction, and
<tt>'?&lt;target&gt;'</tt> or <tt>'#PI &lt;target&gt;'</tt>
triggers a handler for processing instruction with the given
target( ex: <tt>'#PI xml&minus;stylesheet'</tt>).</p>

<p style="margin-left:23%;">level(&lt;level&gt;)</p>

<p style="margin-left:29%;">Triggers the handler on any
element at that level in the tree (root is level 1)</p>

<p style="margin-left:23%;">_all_</p>

<p style="margin-left:29%;">Triggers the handler for
<b>all</b> elements in the tree</p>

<p style="margin-left:23%;">_default_</p>

<p style="margin-left:29%;">Triggers the handler for each
element that does <small>NOT</small> have any other
handler.</p>

<p style="margin-left:23%; margin-top: 1em">Expressions are
evaluated against the input document. Which means that even
if you have changed the tag of an element (changing the tag
of a parent element from a handler for example) the change
will not impact the expression evaluation. There is an
exception to this: &quot;private&quot; attributes (which
name start with a &rsquo;#&rsquo;, and can only be created
during the parsing, as they are not valid <small>XML</small>
) are checked against the current twig.</p>

<p style="margin-left:23%; margin-top: 1em">Handlers are
triggered in fixed order, sorted by their type (xpath
expressions first, then regexps, then level), then by
whether they specify a full path (starting at the root
element) or not, then by by number of steps in the
expression , then number of predicates, then number of tests
in predicates. Handlers where the last step does not specify
a step (<tt>&quot;foo/bar/*&quot;</tt>) are triggered after
other XPath handlers. Finally <tt>&quot;_all_&quot;</tt>
handlers are triggered last.</p>


<p style="margin-left:23%; margin-top: 1em"><b>Important</b>:
once a handler has been triggered if it returns 0 then no
other handler is called, except a <tt>&quot;_all_&quot;</tt>
handler which will be called anyway.</p>

<p style="margin-left:23%; margin-top: 1em">If a handler
returns a true value and other handlers apply, then the next
applicable handler will be called. Repeat, rinse, lather..;
The exception to that rule is when the
<tt>&quot;do_not_chain_handlers&quot;</tt> option is set, in
which case only the first handler will be called.</p>

<p style="margin-left:23%; margin-top: 1em">Note that it
might be a good idea to explicitly return a short true value
(like 1) from handlers: this ensures that other applicable
handlers are called even if the last statement for the
handler happens to evaluate to false. This might also
speedup the code by avoiding the result of the last
statement of the code to be copied and passed to the code
managing handlers. It can really pay to have 1 instead of a
long string returned.</p>

<p style="margin-left:23%; margin-top: 1em">When the
closing tag for an element is parsed the corresponding
handler is called, with 2 arguments: the twig and the
<tt>&quot;Element &quot;</tt>. The twig includes the
document tree that has been built so far, the element is the
complete sub-tree for the element. The fact that the handler
is called only when the closing tag for the element is found
means that handlers for inner elements are called before
handlers for outer elements.</p>

<p style="margin-left:23%; margin-top: 1em"><tt>$_</tt> is
also set to the element, so it is easy to write inline
handlers like</p>

<pre style="margin-left:23%; margin-top: 1em">  para =&gt; sub { $_&minus;&gt;set_tag( 'p'); }</pre>


<p style="margin-left:23%; margin-top: 1em">Text is stored
in elements whose tag name is #PCDATA (due to mixed content,
text and sub-element in an element there is no way to store
the text as just an attribute of the enclosing element).</p>


<p style="margin-left:23%; margin-top: 1em"><b>Warning</b>:
if you have used purge or flush on the twig the element
might not be complete, some of its children might have been
entirely flushed or purged, and the start tag might even
have been printed (by <tt>&quot;flush&quot;</tt>) already,
so changing its tag might not give the expected result.</p>

<p style="margin-left:17%;">twig_roots</p>

<p style="margin-left:23%;">This argument let&rsquo;s you
build the tree only for those elements you are interested
in.</p>

<pre style="margin-left:23%; margin-top: 1em">  Example: my $t= XML::Twig&minus;&gt;new( twig_roots =&gt; { title =&gt; 1, subtitle =&gt; 1});
           $t&minus;&gt;parsefile( file);
           my $t= XML::Twig&minus;&gt;new( twig_roots =&gt; { 'section/title' =&gt; 1});
           $t&minus;&gt;parsefile( file);</pre>


<p style="margin-left:23%; margin-top: 1em">return a twig
containing a document including only
<tt>&quot;title&quot;</tt> and <tt>&quot;subtitle&quot;</tt>
elements, as children of the root element.</p>

<p style="margin-left:23%; margin-top: 1em">You can use
<i>generic_attribute_condition</i>,
<i>attribute_condition</i>, <i>full_path</i>,
<i>partial_path</i>, <i>tag</i>, <i>tag_regexp</i>,
<i>_default_</i> and <i>_all_</i> to trigger the building of
the twig. <i>string_condition</i> and
<i>regexp_condition</i> cannot be used as the content of the
element, and the string, have not yet been parsed when the
condition is checked.</p>


<p style="margin-left:23%; margin-top: 1em"><b><small>WARNING</small></b>
: path are checked for the document. Even if the
<tt>&quot;twig_roots&quot;</tt> option is used they will be
checked against the full document tree, not the virtual tree
created by XML::Twig</p>


<p style="margin-left:23%; margin-top: 1em"><b><small>WARNING</small></b>
: twig_roots elements should <small>NOT</small> be nested,
that would hopelessly confuse XML::Twig ;&minus;&minus;(</p>

<p style="margin-left:23%; margin-top: 1em">Note: you can
set handlers (twig_handlers) using twig_roots <br>
Example: my <tt>$t</tt>= XML::Twig&minus;&gt;new( twig_roots
=&gt; <br>
{ title =&gt; sub { <tt>$_</tt>[1]&minus;&gt;print;}, <br>
subtitle =&gt; \&amp;process_subtitle <br>
} <br>
); <tt><br>
$t</tt>&minus;&gt;parsefile( file);</p>

<p style="margin-left:17%;">twig_print_outside_roots</p>

<p style="margin-left:23%;">To be used in conjunction with
the <tt>&quot;twig_roots&quot;</tt> argument. When set to a
true value this will print the document outside of the
<tt>&quot;twig_roots&quot;</tt> elements.</p>

<pre style="margin-left:23%; margin-top: 1em"> Example: my $t= XML::Twig&minus;&gt;new( twig_roots =&gt; { title =&gt; \&amp;number_title },
                                twig_print_outside_roots =&gt; 1,
                               );
           $t&minus;&gt;parsefile( file);
           { my $nb;
           sub number_title
             { my( $twig, $title);
               $nb++;
               $title&minus;&gt;prefix( &quot;$nb &quot;);
               $title&minus;&gt;print;
             }
           }</pre>


<p style="margin-left:23%; margin-top: 1em">This example
prints the document outside of the title element, calls
<tt>&quot;number_title&quot;</tt> for each
<tt>&quot;title&quot;</tt> element, prints it, and then
resumes printing the document. The twig is built only for
the <tt>&quot;title&quot;</tt> elements.</p>

<p style="margin-left:23%; margin-top: 1em">If the value is
a reference to a file handle then the document outside the
<tt>&quot;twig_roots&quot;</tt> elements will be output to
this file handle:</p>

<pre style="margin-left:23%; margin-top: 1em">  open( my $out, '&gt;', 'out_file.xml') or die &quot;cannot open out file.xml out_file:$!&quot;;
  my $t= XML::Twig&minus;&gt;new( twig_roots =&gt; { title =&gt; \&amp;number_title },
                         # default output to $out
                         twig_print_outside_roots =&gt; $out,
                       );
         { my $nb;
           sub number_title
             { my( $twig, $title);
               $nb++;
               $title&minus;&gt;prefix( &quot;$nb &quot;);
               $title&minus;&gt;print( $out);    # you have to print to \*OUT here
             }
           }</pre>


<p style="margin-left:17%;">start_tag_handlers</p>

<p style="margin-left:23%;">A hash <tt>&quot;{ expression
=&quot;</tt> \&amp;handler}&gt;. Sets element handlers that
are called when the element is open (at the end of the
XML::Parser <tt>&quot;Start&quot;</tt> handler). The
handlers are called with 2 params: the twig and the element.
The element is empty at that point, its attributes are
created though.</p>

<p style="margin-left:23%; margin-top: 1em">You can use
<i>generic_attribute_condition</i>,
<i>attribute_condition</i>, <i>full_path</i>,
<i>partial_path</i>, <i>tag</i>, <i>tag_regexp</i>,
<i>_default_</i> and <i>_all_</i> to trigger the
handler.</p>


<p style="margin-left:23%; margin-top: 1em"><i>string_condition</i>
and <i>regexp_condition</i> cannot be used as the content of
the element, and the string, have not yet been parsed when
the condition is checked.</p>

<p style="margin-left:23%; margin-top: 1em">The main uses
for those handlers are to change the tag name (you might
have to do it as soon as you find the open tag if you plan
to <tt>&quot;flush&quot;</tt> the twig at some point in the
element, and to create temporary attributes that will be
used when processing sub-element with
<tt>&quot;twig_hanlders&quot;</tt>.</p>

<p style="margin-left:23%; margin-top: 1em">You should also
use it to change tags if you use <tt>&quot;flush&quot;</tt>.
If you change the tag in a regular
<tt>&quot;twig_handler&quot;</tt> then the start tag might
already have been flushed.</p>

<p style="margin-left:23%; margin-top: 1em"><b>Note</b>:
<tt>&quot;start_tag&quot;</tt> handlers can be called
outside of <tt>&quot;twig_roots&quot;</tt> if this argument
is used, in this case handlers are called with the following
arguments: <tt>$t</tt> (the twig), <tt>$tag</tt> (the tag of
the element) and <tt>%att</tt> (a hash of the attributes of
the element).</p>

<p style="margin-left:23%; margin-top: 1em">If the
<tt>&quot;twig_print_outside_roots&quot;</tt> argument is
also used, if the last handler called returns a
<tt>&quot;true&quot;</tt> value, then the the start tag will
be output as it appeared in the original document, if the
handler returns a a <tt>&quot;false&quot;</tt> value then
the start tag will <b>not</b> be printed (so you can print a
modified string yourself for example).</p>

<p style="margin-left:23%; margin-top: 1em">Note that you
can use the ignore method in
<tt>&quot;start_tag_handlers&quot;</tt> (and only
there).</p>

<p style="margin-left:17%;">end_tag_handlers</p>

<p style="margin-left:23%;">A hash <tt>&quot;{ expression
=&quot;</tt> \&amp;handler}&gt;. Sets element handlers that
are called when the element is closed (at the end of the
XML::Parser <tt>&quot;End&quot;</tt> handler). The handlers
are called with 2 params: the twig and the tag of the
element.</p>


<p style="margin-left:23%; margin-top: 1em"><i>twig_handlers</i>
are called when an element is completely parsed, so why have
this redundant option? There is only one use for
<tt>&quot;end_tag_handlers&quot;</tt>: when using the
<tt>&quot;twig_roots&quot;</tt> option, to trigger a handler
for an element <b>outside</b> the roots. It is for example
very useful to number titles in a document using nested
sections:</p>

<pre style="margin-left:23%; margin-top: 1em">  my @no= (0);
  my $no;
  my $t= XML::Twig&minus;&gt;new(
          start_tag_handlers =&gt;
           { section =&gt; sub { $no[$#no]++; $no= join '.', @no; push @no, 0; } },
          twig_roots         =&gt;
           { title   =&gt; sub { $_[1]&minus;&gt;prefix( $no); $_[1]&minus;&gt;print; } },
          end_tag_handlers   =&gt; { section =&gt; sub { pop @no;  } },
          twig_print_outside_roots =&gt; 1
                      );
   $t&minus;&gt;parsefile( $file);</pre>


<p style="margin-left:23%; margin-top: 1em">Using the
<tt>&quot;end_tag_handlers&quot;</tt> argument without
<tt>&quot;twig_roots&quot;</tt> will result in an error.</p>

<p style="margin-left:17%;">do_not_chain_handlers</p>

<p style="margin-left:23%;">If this option is set to a true
value, then only one handler will be called for each
element, even if several satisfy the condition</p>

<p style="margin-left:23%; margin-top: 1em">Note that the
<tt>&quot;_all_&quot;</tt> handler will still be called
regardless</p>

<p style="margin-left:17%;">ignore_elts</p>

<p style="margin-left:23%;">This option lets you ignore
elements when building the twig. This is useful in cases
where you cannot use <tt>&quot;twig_roots&quot;</tt> to
ignore elements, for example if the element to ignore is a
sibling of elements you are interested in.</p>

<p style="margin-left:23%; margin-top: 1em">Example:</p>

<pre style="margin-left:23%; margin-top: 1em">  my $twig= XML::Twig&minus;&gt;new( ignore_elts =&gt; { elt =&gt; 'discard' });
  $twig&minus;&gt;parsefile( 'doc.xml');</pre>


<p style="margin-left:23%; margin-top: 1em">This will build
the complete twig for the document, except that all
<tt>&quot;elt&quot;</tt> elements (and their children) will
be left out.</p>

<p style="margin-left:23%; margin-top: 1em">The keys in the
hash are triggers, limited to the same subset as
<tt>&quot;start_tag_handlers&quot;</tt>. The values can be
<tt>&quot;discard&quot;</tt>, to discard the element,
<tt>&quot;print&quot;</tt>, to output the element as-is,
<tt>&quot;string&quot;</tt> to store the text of the ignored
element(s), including markup, in a field of the twig:
<tt>&quot;$t&minus;&gt;{twig_buffered_string}&quot;</tt> or
a reference to a scalar, in which case the text of the
ignored element(s), including markup, will be stored in the
scalar. Any other value will be treated as
<tt>&quot;discard&quot;</tt>.</p>

<p style="margin-left:17%;">char_handler</p>

<p style="margin-left:23%;">A reference to a subroutine
that will be called every time <tt>&quot;PCDATA&quot;</tt>
is found.</p>

<p style="margin-left:23%; margin-top: 1em">The subroutine
receives the string as argument, and returns the modified
string:</p>

<pre style="margin-left:23%; margin-top: 1em">  # we want all strings in upper case
  sub my_char_handler
    { my( $text)= @_;
      $text= uc( $text);
      return $text;
    }</pre>


<p style="margin-left:17%;">elt_class</p>

<p style="margin-left:23%;">The name of a class used to
store elements. this class should inherit from
<tt>&quot;XML::Twig::Elt&quot;</tt> (and by default it is
<tt>&quot;XML::Twig::Elt&quot;</tt>). This option is used to
subclass the element class and extend it with new
methods.</p>

<p style="margin-left:23%; margin-top: 1em">This option is
needed because during the parsing of the <small>XML,</small>
elements are created by <tt>&quot;XML::Twig&quot;</tt>,
without any control from the user code.</p>

<p style="margin-left:17%;">keep_atts_order</p>

<p style="margin-left:23%;">Setting this option to a true
value causes the attribute hash to be tied to a
<tt>&quot;Tie::IxHash&quot;</tt> object. This means that
<tt>&quot;Tie::IxHash&quot;</tt> needs to be installed for
this option to be available. It also means that the hash
keeps its order, so you will get the attributes in order.
This allows outputting the attributes in the same order as
they were in the original document.</p>

<p style="margin-left:17%;">keep_encoding</p>

<p style="margin-left:23%;">This is a (slightly?) evil
option: if the <small>XML</small> document is not
<small>UTF&minus;8</small> encoded and you want to keep it
that way, then setting keep_encoding will use
the<tt>&quot;Expat&quot;</tt> original_string method for
character, thus keeping the original encoding, as well as
the original entities in the strings.</p>

<p style="margin-left:23%; margin-top: 1em">See the
<tt>&quot;t/test6.t&quot;</tt> test file to see what results
you can expect from the various encoding options.</p>


<p style="margin-left:23%; margin-top: 1em"><b><small>WARNING</small></b>
: if the original encoding is multi-byte then attribute
parsing will be <small>EXTREMELY</small> unsafe under any
Perl before 5.6, as it uses regular expressions which do not
deal properly with multi-byte characters. You can specify an
alternate function to parse the start tags with the
<tt>&quot;parse_start_tag&quot;</tt> option (see below)</p>


<p style="margin-left:23%; margin-top: 1em"><b><small>WARNING</small></b>
: this option is <small>NOT</small> used when parsing with
the non-blocking parser (<tt>&quot;parse_start&quot;</tt>,
<tt>&quot;parse_more&quot;</tt>, parse_done methods) which
you probably should not use with XML::Twig anyway as they
are totally untested!</p>

<p style="margin-left:17%;">output_encoding</p>

<p style="margin-left:23%;">This option generates an
output_filter using <tt>&quot;Encode&quot;</tt>,
<tt>&quot;Text::Iconv&quot;</tt> or
<tt>&quot;Unicode::Map8&quot;</tt> and
<tt>&quot;Unicode::Strings&quot;</tt>, and sets the encoding
in the <small>XML</small> declaration. This is the easiest
way to deal with encodings, if you need more sophisticated
features, look at <tt>&quot;output_filter&quot;</tt>
below</p>

<p style="margin-left:17%;">output_filter</p>

<p style="margin-left:23%;">This option is used to convert
the character encoding of the output document. It is passed
either a string corresponding to a predefined filter or a
subroutine reference. The filter will be called every time a
document or element is processed by the &quot;print&quot;
functions (<tt>&quot;print&quot;</tt>,
<tt>&quot;sprint&quot;</tt>,
<tt>&quot;flush&quot;</tt>).</p>

<p style="margin-left:23%; margin-top: 1em">Pre-defined
filters: <br>
latin1</p>

<p style="margin-left:29%;">uses either
<tt>&quot;Encode&quot;</tt>,
<tt>&quot;Text::Iconv&quot;</tt> or
<tt>&quot;Unicode::Map8&quot;</tt> and
<tt>&quot;Unicode::String&quot;</tt> or a regexp (which
works only with XML::Parser 2.27), in this order, to convert
all characters to <small>ISO&minus;8859&minus;15</small>
(usually latin1 is synonym to
<small>ISO&minus;8859&minus;1,</small> but in practice it
seems that <small>ISO&minus;8859&minus;15,</small> which
includes the euro sign, is more useful and probably what
most people want).</p>

<p style="margin-left:23%;">html</p>

<p style="margin-left:29%;">does the same conversion as
<tt>&quot;latin1&quot;</tt>, plus encodes entities using
<tt>&quot;HTML::Entities&quot;</tt> (oddly enough you will
need to have HTML::Entities installed for it to be
available). This should only be used if the tags and
attribute names themselves are in US-ASCII, or they will be
converted and the output will not be valid
<small>XML</small> any more</p>

<p style="margin-left:23%;">safe</p>

<p style="margin-left:29%;">converts the output to
<small>ASCII</small> ( <small>US</small> ) only plus
<i>character entities</i> (<tt>&quot;&amp;#nnn;&quot;</tt>)
this should be used only if the tags and attribute names
themselves are in US-ASCII, or they will be converted and
the output will not be valid <small>XML</small> any more</p>

<p style="margin-left:23%;">safe_hex</p>

<p style="margin-left:29%;">same as
<tt>&quot;safe&quot;</tt> except that the character entities
are in hexa (<tt>&quot;&amp;#xnnn;&quot;</tt>)</p>

<p style="margin-left:23%;">encode_convert ($encoding)</p>

<p style="margin-left:29%;">Return a subref that can be
used to convert utf8 strings to <tt>$encoding</tt>). Uses
<tt>&quot;Encode&quot;</tt>.</p>

<pre style="margin-left:29%; margin-top: 1em">   my $conv = XML::Twig::encode_convert( 'latin1');
   my $t = XML::Twig&minus;&gt;new(output_filter =&gt; $conv);</pre>


<p style="margin-left:23%;">iconv_convert ($encoding)</p>

<p style="margin-left:29%;">this function is used to create
a filter subroutine that will be used to convert the
characters to the target encoding using
<tt>&quot;Text::Iconv&quot;</tt> (which needs to be
installed, look at the documentation for the module and for
the <tt>&quot;iconv&quot;</tt> library to find out which
encodings are available on your system)</p>

<pre style="margin-left:29%; margin-top: 1em">   my $conv = XML::Twig::iconv_convert( 'latin1');
   my $t = XML::Twig&minus;&gt;new(output_filter =&gt; $conv);</pre>


<p style="margin-left:23%;">unicode_convert ($encoding)</p>

<p style="margin-left:29%;">this function is used to create
a filter subroutine that will be used to convert the
characters to the target encoding using
<tt>&quot;Unicode::Strings&quot;</tt> and
<tt>&quot;Unicode::Map8&quot;</tt> (which need to be
installed, look at the documentation for the modules to find
out which encodings are available on your system)</p>

<pre style="margin-left:29%; margin-top: 1em">   my $conv = XML::Twig::unicode_convert( 'latin1');
   my $t = XML::Twig&minus;&gt;new(output_filter =&gt; $conv);</pre>


<p style="margin-left:23%; margin-top: 1em">The
<tt>&quot;text&quot;</tt> and <tt>&quot;att&quot;</tt>
methods do not use the filter, so their result are always in
unicode.</p>

<p style="margin-left:23%; margin-top: 1em">Those
predeclared filters are based on subroutines that can be
used by themselves (as <tt>&quot;XML::Twig::foo&quot;</tt>).
<br>
html_encode ($string)</p>

<p style="margin-left:29%;">Use
<tt>&quot;HTML::Entities&quot;</tt> to encode a utf8
string</p>

<p style="margin-left:23%;">safe_encode ($string)</p>

<p style="margin-left:29%;">Use either a regexp (perl &lt;
5.8) or <tt>&quot;Encode&quot;</tt> to encode non-ascii
characters in the string in
<tt>&quot;&amp;#&lt;nnnn&gt;;&quot;</tt> format</p>

<p style="margin-left:23%;">safe_encode_hex ($string)</p>

<p style="margin-left:29%;">Use either a regexp (perl &lt;
5.8) or <tt>&quot;Encode&quot;</tt> to encode non-ascii
characters in the string in
<tt>&quot;&amp;#x&lt;nnnn&gt;;&quot;</tt> format</p>

<p style="margin-left:23%;">regexp2latin1 ($string)</p>

<p style="margin-left:29%;">Use a regexp to encode a utf8
string into latin 1 ( <small>ISO&minus;8859&minus;1</small>
). Does not work with Perl 5.8.0!</p>

<p style="margin-left:17%;">output_text_filter</p>

<p style="margin-left:23%;">same as output_filter, except
it doesn&rsquo;t apply to the brackets and quotes around
attribute values. This is useful for all filters that could
change the tagging, basically anything that does not just
change the encoding of the output.
<tt>&quot;html&quot;</tt>, <tt>&quot;safe&quot;</tt> and
<tt>&quot;safe_hex&quot;</tt> are better used with this
option.</p>

<p style="margin-left:17%;">input_filter</p>

<p style="margin-left:23%;">This option is similar to
<tt>&quot;output_filter&quot;</tt> except the filter is
applied to the characters before they are stored in the
twig, at parsing time.</p>

<p style="margin-left:17%;">remove_cdata</p>

<p style="margin-left:23%;">Setting this option to a true
value will force the twig to output <small>CDATA</small>
sections as regular (escaped) <small>PCDATA</small></p>

<p style="margin-left:17%;">parse_start_tag</p>

<p style="margin-left:23%;">If you use the
<tt>&quot;keep_encoding&quot;</tt> option then this option
can be used to replace the default parsing function. You
should provide a coderef (a reference to a subroutine) as
the argument, this subroutine takes the original tag (given
by XML::Parser::Expat <tt>&quot;original_string()&quot;</tt>
method) and returns a tag and the attributes in a hash (or
in a list attribute_name/attribute value).</p>

<p style="margin-left:17%;">expand_external_ents</p>

<p style="margin-left:23%;">When this option is used
external entities (that are defined) are expanded when the
document is output using &quot;print&quot; functions such as
<tt>&quot;print &quot;</tt>, <tt>&quot;sprint &quot;</tt>,
<tt>&quot;flush &quot;</tt> and <tt>&quot;xml_string
&quot;</tt>. Note that in the twig the entity will be stored
as an element with a tag
&rsquo;<tt>&quot;#ENT&quot;</tt>&rsquo;, the entity will not
be expanded there, so you might want to process the entities
before outputting it.</p>

<p style="margin-left:23%; margin-top: 1em">If an external
entity is not available, then the parse will fail.</p>

<p style="margin-left:23%; margin-top: 1em">A special case
is when the value of this option is &minus;1. In that case a
missing entity will not cause the parser to die, but its
<tt>&quot;name&quot;</tt>, <tt>&quot;sysid&quot;</tt> and
<tt>&quot;pubid&quot;</tt> will be stored in the twig as
<tt>&quot;$twig&minus;&gt;{twig_missing_system_entities}&quot;</tt>
(a reference to an array of hashes { name =&gt;
&lt;name&gt;, sysid =&gt; &lt;sysid&gt;, pubid =&gt;
&lt;pubid&gt; }). Yes, this is a bit of a hack, but
it&rsquo;s useful in some cases.</p>

<p style="margin-left:17%;">load_DTD</p>

<p style="margin-left:23%;">If this argument is set to a
true value, <tt>&quot;parse&quot;</tt> or
<tt>&quot;parsefile&quot;</tt> on the twig will load the
<small>DTD</small> information. This information can then be
accessed through the twig, in a
<tt>&quot;DTD_handler&quot;</tt> for example. This will load
even an external <small>DTD.</small></p>

<p style="margin-left:23%; margin-top: 1em">Default and
fixed values for attributes will also be filled, based on
the <small>DTD.</small></p>

<p style="margin-left:23%; margin-top: 1em">Note that to do
this the module will generate a temporary file in the
current directory. If this is a problem let me know and I
will add an option to specify an alternate directory.</p>

<p style="margin-left:23%; margin-top: 1em">See &quot;
<small>DTD</small> Handling&quot; for more information</p>

<p style="margin-left:17%;">DTD_handler</p>

<p style="margin-left:23%;">Set a handler that will be
called once the doctype (and the <small>DTD</small> ) have
been loaded, with 2 arguments, the twig and the
<small>DTD.</small></p>

<p style="margin-left:17%;">no_prolog</p>

<p style="margin-left:23%;">Does not output a prolog (
<small>XML</small> declaration and <small>DTD</small> )</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>id</p></td>
<td width="3%"></td>
<td width="77%">


<p>This optional argument gives the name of an attribute
that can be used as an <small>ID</small> in the document.
Elements whose <small>ID</small> is known can be accessed
through the elt_id method. id defaults to &rsquo;id&rsquo;.
See <tt>&quot;BUGS &quot;</tt></p></td></tr>
</table>

<p style="margin-left:17%;">discard_spaces</p>

<p style="margin-left:23%;">If this optional argument is
set to a true value then spaces are discarded when they look
non-significant: strings containing only spaces and at least
one line feed are discarded. This argument is set to true by
default.</p>

<p style="margin-left:23%; margin-top: 1em">The exact
algorithm to drop spaces is: strings including only spaces
(perl \s) and at least one \n right before an open or close
tag are dropped.</p>

<p style="margin-left:17%;">discard_all_spaces</p>

<p style="margin-left:23%;">If this argument is set to a
true value, spaces are discarded more aggressively than with
<tt>&quot;discard_spaces&quot;</tt>: strings not including a
\n are also dropped. This option is appropriate for
data-oriented <small>XML.</small></p>

<p style="margin-left:17%;">keep_spaces</p>

<p style="margin-left:23%;">If this optional argument is
set to a true value then all spaces in the document are
kept, and stored as <tt>&quot;PCDATA&quot;</tt>.</p>


<p style="margin-left:23%; margin-top: 1em"><b>Warning</b>:
adding this option can result in changes in the twig
generated: space that was previously discarded might end up
in a new text element. see the difference by calling the
following code with 0 and 1 as arguments:</p>

<pre style="margin-left:23%; margin-top: 1em">  perl &minus;MXML::Twig &minus;e'print XML::Twig&minus;&gt;new( keep_spaces =&gt; shift)&minus;&gt;parse( &quot;&lt;d&gt; \n&lt;e/&gt;&lt;/d&gt;&quot;)&minus;&gt;_dump'</pre>



<p style="margin-left:23%; margin-top: 1em">&quot;keep_spaces&quot;
and <tt>&quot;discard_spaces&quot;</tt> cannot be both
set.</p>

<p style="margin-left:17%;">discard_spaces_in</p>

<p style="margin-left:23%;">This argument sets
<tt>&quot;keep_spaces&quot;</tt> to true but will cause the
twig builder to discard spaces in the elements listed.</p>

<p style="margin-left:23%; margin-top: 1em">The syntax for
using this argument is:</p>

<pre style="margin-left:23%; margin-top: 1em">  XML::Twig&minus;&gt;new( discard_spaces_in =&gt; [ 'elt1', 'elt2']);</pre>


<p style="margin-left:17%;">keep_spaces_in</p>

<p style="margin-left:23%;">This argument sets
<tt>&quot;discard_spaces&quot;</tt> to true but will cause
the twig builder to keep spaces in the elements listed.</p>

<p style="margin-left:23%; margin-top: 1em">The syntax for
using this argument is:</p>

<pre style="margin-left:23%; margin-top: 1em">  XML::Twig&minus;&gt;new( keep_spaces_in =&gt; [ 'elt1', 'elt2']);</pre>



<p style="margin-left:23%; margin-top: 1em"><b>Warning</b>:
adding this option can result in changes in the twig
generated: space that was previously discarded might end up
in a new text element.</p>

<p style="margin-left:17%;">pretty_print</p>

<p style="margin-left:23%;">Set the pretty print method,
amongst &rsquo;<tt>&quot;none&quot;</tt>&rsquo; (default),
&rsquo;<tt>&quot;nsgmls&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;nice&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented_c&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented_a&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented_close_tag&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;cvs&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;wrapped&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;record&quot;</tt>&rsquo; and
&rsquo;<tt>&quot;record_c&quot;</tt>&rsquo;</p>

<p style="margin-left:23%; margin-top: 1em">pretty_print
formats: <br>
none</p>

<p style="margin-left:29%;">The document is output as one
ling string, with no line breaks except those found within
text elements</p>

<p style="margin-left:23%;">nsgmls</p>

<p style="margin-left:29%;">Line breaks are inserted in
safe places: that is within tags, between a tag and an
attribute, between attributes and before the &gt; at the end
of a tag.</p>

<p style="margin-left:29%; margin-top: 1em">This is quite
ugly but better than <tt>&quot;none&quot;</tt>, and it is
very safe, the document will still be valid (conforming to
its <small>DTD</small> ).</p>

<p style="margin-left:29%; margin-top: 1em">This is how the
<small>SGML</small> parser <tt>&quot;sgmls&quot;</tt> splits
documents, hence the name.</p>

<p style="margin-left:23%;">nice</p>

<p style="margin-left:29%;">This option inserts line breaks
before any tag that does not contain text (so element with
textual content are not broken as the \n is the
significant).</p>


<p style="margin-left:29%; margin-top: 1em"><b><small>WARNING</small></b>
: this option leaves the document well-formed but might make
it invalid (not conformant to its <small>DTD</small> ). If
you have elements declared as</p>

<pre style="margin-left:29%; margin-top: 1em">  &lt;!ELEMENT foo (#PCDATA|bar)&gt;</pre>


<p style="margin-left:29%; margin-top: 1em">then a
<tt>&quot;foo&quot;</tt> element including a
<tt>&quot;bar&quot;</tt> one will be printed as</p>

<pre style="margin-left:29%; margin-top: 1em">  &lt;foo&gt;
  &lt;bar&gt;bar is just pcdata&lt;/bar&gt;
  &lt;/foo&gt;</pre>


<p style="margin-left:29%; margin-top: 1em">This is
invalid, as the parser will take the line break after the
<tt>&quot;foo&quot;</tt> tag as a sign that the element
contains <small>PCDATA,</small> it will then die when it
finds the <tt>&quot;bar&quot;</tt> tag. This may or may not
be important for you, but be aware of it!</p>

<p style="margin-left:23%;">indented</p>

<p style="margin-left:29%;">Same as
<tt>&quot;nice&quot;</tt> (and with the same warning) but
indents elements according to their level</p>

<p style="margin-left:23%;">indented_c</p>

<p style="margin-left:29%;">Same as
<tt>&quot;indented&quot;</tt> but a little more compact: the
closing tags are on the same line as the preceding text</p>

<p style="margin-left:23%;">indented_close_tag</p>

<p style="margin-left:29%;">Same as
<tt>&quot;indented&quot;</tt> except that the closing tag is
also indented, to line up with the tags within the
element</p>

<p style="margin-left:23%;">idented_a</p>

<p style="margin-left:29%;">This formats <small>XML</small>
files in a line-oriented version control friendly way. The
format is described in &lt;http://tinyurl.com/2kwscq&gt;
(that&rsquo;s an Oracle document with an insanely long
<small>URL</small> ).</p>

<p style="margin-left:29%; margin-top: 1em">Note that to be
totaly conformant to the &quot;spec&quot;, the order of
attributes should not be changed, so if they are not already
in alphabetical order you will need to use the
<tt>&quot;keep_atts_order&quot;</tt> option.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="5%">


<p>cvs</p></td>
<td width="1%"></td>
<td width="31%">


<p>Same as <tt>&quot;idented_a&quot;</tt>.</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:23%;">wrapped</p>

<p style="margin-left:29%;">Same as
<tt>&quot;indented_c&quot;</tt> but lines are wrapped using
Text::Wrap::wrap. The default length for lines is the
default for <tt>$Text::Wrap::columns</tt>, and can be
changed by changing that variable.</p>

<p style="margin-left:23%;">record</p>

<p style="margin-left:29%;">This is a record-oriented
pretty print, that display data in records, one field per
line (which looks a <small>LOT</small> like
<tt>&quot;indented&quot;</tt>)</p>

<p style="margin-left:23%;">record_c</p>

<p style="margin-left:29%;">Stands for record compact, one
record per line</p>

<p style="margin-left:17%;">empty_tags</p>

<p style="margin-left:23%;">Set the empty tag display style
(&rsquo;<tt>&quot;normal&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;html&quot;</tt>&rsquo; or
&rsquo;<tt>&quot;expand&quot;</tt>&rsquo;).</p>


<p style="margin-left:23%; margin-top: 1em"><tt>&quot;normal&quot;</tt>
outputs an empty tag
&rsquo;<tt>&quot;&lt;tag/&gt;&quot;</tt>&rsquo;,
<tt>&quot;html&quot;</tt> adds a space
&rsquo;<tt>&quot;&lt;tag /&gt;&quot;</tt>&rsquo; for
elements that can be empty in <small>XHTML</small> and
<tt>&quot;expand&quot;</tt> outputs
&rsquo;<tt>&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</tt>&rsquo;</p>

<p style="margin-left:17%;">quote</p>

<p style="margin-left:23%;">Set the quote character for
attributes (&rsquo;<tt>&quot;single&quot;</tt>&rsquo; or
&rsquo;<tt>&quot;double&quot;</tt>&rsquo;).</p>

<p style="margin-left:17%;">escape_gt</p>

<p style="margin-left:23%;">By default XML::Twig does not
escape the character &gt; in its output, as it is not
mandated by the <small>XML</small> spec. With this option
on, &gt; will be replaced by
<tt>&quot;&amp;gt;&quot;</tt></p>

<p style="margin-left:17%;">comments</p>

<p style="margin-left:23%;">Set the way comments are
processed: &rsquo;<tt>&quot;drop&quot;</tt>&rsquo;
(default), &rsquo;<tt>&quot;keep&quot;</tt>&rsquo; or
&rsquo;<tt>&quot;process&quot;</tt>&rsquo;</p>

<p style="margin-left:23%; margin-top: 1em">Comments
processing options: <br>
drop</p>

<p style="margin-left:29%;">drops the comments, they are
not read, nor printed to the output</p>

<p style="margin-left:23%;">keep</p>

<p style="margin-left:29%;">comments are loaded and will
appear on the output, they are not accessible within the
twig and will not interfere with processing though</p>

<p style="margin-left:29%; margin-top: 1em"><b>Note</b>:
comments in the middle of a text element such as</p>

<pre style="margin-left:29%; margin-top: 1em">  &lt;p&gt;text &lt;!&minus;&minus; comment &minus;&minus;&gt; more text &minus;&minus;&gt;&lt;/p&gt;</pre>


<p style="margin-left:29%; margin-top: 1em">are kept at
their original position in the text. Using
X&quot;print&quot; methods like <tt>&quot;print&quot;</tt>
or <tt>&quot;sprint&quot;</tt> will return the comments in
the text. Using <tt>&quot;text&quot;</tt> or
<tt>&quot;field&quot;</tt> on the other hand will not.</p>

<p style="margin-left:29%; margin-top: 1em">Any use of
<tt>&quot;set_pcdata&quot;</tt> on the
<tt>&quot;#PCDATA&quot;</tt> element (directly or through
other methods like <tt>&quot;set_content&quot;</tt>) will
delete the comment(s).</p>

<p style="margin-left:23%;">process</p>

<p style="margin-left:29%;">comments are loaded in the twig
and will be treated as regular elements (their
<tt>&quot;tag&quot;</tt> is <tt>&quot;#COMMENT&quot;</tt>)
this can interfere with processing if you expect
<tt>&quot;$elt&minus;&gt;{first_child}&quot;</tt> to be an
element but find a comment there. Validation will not
protect you from this as comments can happen anywhere. You
can use <tt>&quot;$elt&minus;&gt;first_child(
'tag')&quot;</tt> (which is a good habit anyway) to get
where you want.</p>

<p style="margin-left:29%; margin-top: 1em">Consider using
<tt>&quot;process&quot;</tt> if you are outputting
<small>SAX</small> events from XML::Twig.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>pi</p></td>
<td width="3%"></td>
<td width="77%">


<p>Set the way processing instructions are processed:
&rsquo;<tt>&quot;drop&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;keep&quot;</tt>&rsquo; (default) or
&rsquo;<tt>&quot;process&quot;</tt>&rsquo;</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Note that you
can also set <small>PI</small> handlers in the
<tt>&quot;twig_handlers&quot;</tt> option:</p>

<pre style="margin-left:23%; margin-top: 1em">  '?'       =&gt; \&amp;handler
  '?target' =&gt; \&amp;handler 2</pre>


<p style="margin-left:23%; margin-top: 1em">The handlers
will be called with 2 parameters, the twig and the
<small>PI</small> element if <tt>&quot;pi&quot;</tt> is set
to <tt>&quot;process&quot;</tt>, and with 3, the twig, the
target and the data if <tt>&quot;pi&quot;</tt> is set to
<tt>&quot;keep&quot;</tt>. Of course they will not be called
if <tt>&quot;pi&quot;</tt> is set to
<tt>&quot;drop&quot;</tt>.</p>

<p style="margin-left:23%; margin-top: 1em">If
<tt>&quot;pi&quot;</tt> is set to <tt>&quot;keep&quot;</tt>
the handler should return a string that will be used as-is
as the <small>PI</small> text (it should look like
&quot;<tt>&quot; &lt;?target data?&quot;</tt> &gt;&quot; or
&rsquo;&rsquo; if you want to remove the <small>PI</small>
),</p>

<p style="margin-left:23%; margin-top: 1em">Only one
handler will be called, <tt>&quot;?target&quot;</tt> or
<tt>&quot;?&quot;</tt> if no specific handler for that
target is available.</p>

<p style="margin-left:17%;">map_xmlns</p>

<p style="margin-left:23%;">This option is passed a hashref
that maps uri&rsquo;s to prefixes. The prefixes in the
document will be replaced by the ones in the map. The mapped
prefixes can (actually have to) be used to trigger handlers,
navigate or query the document.</p>

<p style="margin-left:23%; margin-top: 1em">Here is an
example:</p>

<pre style="margin-left:23%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( map_xmlns =&gt; {'http://www.w3.org/2000/svg' =&gt; &quot;svg&quot;},
                         twig_handlers =&gt;
                           { 'svg:circle' =&gt; sub { $_&minus;&gt;set_att( r =&gt; 20) } },
                         pretty_print =&gt; 'indented',
                       )
                  &minus;&gt;parse( '&lt;doc xmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt;
                              &lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot; r=&quot;10&quot;/&gt;
                           &lt;/doc&gt;'
                         )
                  &minus;&gt;print;</pre>


<p style="margin-left:23%; margin-top: 1em">This will
output:</p>

<pre style="margin-left:23%; margin-top: 1em">  &lt;doc xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
     &lt;svg:circle cx=&quot;10&quot; cy=&quot;90&quot; r=&quot;20&quot;/&gt;
  &lt;/doc&gt;</pre>


<p style="margin-left:17%;">keep_original_prefix</p>

<p style="margin-left:23%;">When used with
<tt>&quot;map_xmlns&quot;</tt> this option will make
<tt>&quot;XML::Twig&quot;</tt> use the original namespace
prefixes when outputting a document. The mapped prefix will
still be used for triggering handlers and in navigation and
query methods.</p>

<pre style="margin-left:23%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( map_xmlns =&gt; {'http://www.w3.org/2000/svg' =&gt; &quot;svg&quot;},
                         twig_handlers =&gt;
                           { 'svg:circle' =&gt; sub { $_&minus;&gt;set_att( r =&gt; 20) } },
                         keep_original_prefix =&gt; 1,
                         pretty_print =&gt; 'indented',
                       )
                  &minus;&gt;parse( '&lt;doc xmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt;
                              &lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot; r=&quot;10&quot;/&gt;
                           &lt;/doc&gt;'
                         )
                  &minus;&gt;print;</pre>


<p style="margin-left:23%; margin-top: 1em">This will
output:</p>

<pre style="margin-left:23%; margin-top: 1em">  &lt;doc xmlns:gr=&quot;http://www.w3.org/2000/svg&quot;&gt;
     &lt;gr:circle cx=&quot;10&quot; cy=&quot;90&quot; r=&quot;20&quot;/&gt;
  &lt;/doc&gt;</pre>


<p style="margin-left:17%;">original_uri ($prefix)</p>

<p style="margin-left:23%;">called within a handler, this
will return the uri bound to the namespace prefix in the
original document.</p>

<p style="margin-left:17%;">index ($arrayref or
$hashref)</p>

<p style="margin-left:23%;">This option creates lists of
specific elements during the parsing of the
<small>XML.</small> It takes a reference to either a list of
triggering expressions or to a hash name =&gt; expression,
and for each one generates the list of elements that match
the expression. The list can be accessed through the
<tt>&quot;index&quot;</tt> method.</p>

<p style="margin-left:23%; margin-top: 1em">example:</p>

<pre style="margin-left:23%; margin-top: 1em">  # using an array ref
  my $t= XML::Twig&minus;&gt;new( index =&gt; [ 'div', 'table' ])
                  &minus;&gt;parsefile( &quot;foo.xml&quot;);
  my $divs= $t&minus;&gt;index( 'div');
  my $first_div= $divs&minus;&gt;[0];
  my $last_table= $t&minus;&gt;index( table =&gt; &minus;1);
  # using a hashref to name the indexes
  my $t= XML::Twig&minus;&gt;new( index =&gt; { email =&gt; 'a[@href=~/^ \s*mailto:/]'})
                  &minus;&gt;parsefile( &quot;foo.xml&quot;);
  my $last_emails= $t&minus;&gt;index( email =&gt; &minus;1);</pre>


<p style="margin-left:23%; margin-top: 1em">Note that the
index is not maintained after the parsing. If elements are
deleted, renamed or otherwise hurt during processing, the
index is <small>NOT</small> updated. (changing the id
element <small>OTOH</small> will update the index)</p>

<p style="margin-left:17%;">att_accessors &lt;list of
attribute names&gt;</p>

<p style="margin-left:23%;">creates methods that give
direct access to attribute:</p>

<pre style="margin-left:23%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new( att_accessors =&gt; [ 'href', 'src'])
                  &minus;&gt;parsefile( $file);
  my $first_href= $t&minus;&gt;first_elt( 'img')&minus;&gt;src; # same as &minus;&gt;att( 'src')
  $t&minus;&gt;first_elt( 'img')&minus;&gt;src( 'new_logo.png') # changes the attribute value</pre>


<p style="margin-left:17%;">elt_accessors</p>

<p style="margin-left:23%;">creates methods that give
direct access to the first child element (in scalar context)
or the list of elements (in list context):</p>

<p style="margin-left:23%; margin-top: 1em">the list of
accessors to create can be given 1 2 different ways: in an
array, or in a hash alias =&gt; expression <br>
my <tt>$t</tt>= XML::Twig&minus;&gt;new( elt_accessors =&gt;
[ &rsquo;head&rsquo;]) <br>
&minus;&gt;parsefile( <tt>$file</tt>); <br>
my <tt>$title_text</tt>=
<tt>$t</tt>&minus;&gt;root&minus;&gt;head&minus;&gt;field(
&rsquo;title&rsquo;); <br>
# same as <tt>$title_text</tt>=
<tt>$t</tt>&minus;&gt;root&minus;&gt;first_child(
&rsquo;head&rsquo;)&minus;&gt;field(
&rsquo;title&rsquo;);</p>

<pre style="margin-left:23%; margin-top: 1em">  my $t=  XML::Twig&minus;&gt;new( elt_accessors =&gt; { warnings =&gt; 'p[@class=&quot;warning&quot;]', d2 =&gt; 'div[2]'}, )
                  &minus;&gt;parsefile( $file);
  my $body= $t&minus;&gt;first_elt( 'body');
  my @warnings= $body&minus;&gt;warnings; # same as $body&minus;&gt;children( 'p[@class=&quot;warning&quot;]');
  my $s2= $body&minus;&gt;d2;             # same as $body&minus;&gt;first_child( 'div[2]')</pre>


<p style="margin-left:17%;">field_accessors</p>

<p style="margin-left:23%;">creates methods that give
direct access to the first child element text:</p>

<pre style="margin-left:23%; margin-top: 1em">  my $t=  XML::Twig&minus;&gt;new( field_accessors =&gt; [ 'h1'])
                  &minus;&gt;parsefile( $file);
  my $div_title_text= $t&minus;&gt;first_elt( 'div')&minus;&gt;title;
  # same as $title_text= $t&minus;&gt;first_elt( 'div')&minus;&gt;field( 'title');</pre>


<p style="margin-left:17%;">use_tidy</p>

<p style="margin-left:23%;">set this option to use
HTML::Tidy instead of HTML::TreeBuilder to convert
<small>HTML</small> to <small>XML. HTML,</small> especially
real (real &quot;crap&quot;) <small>HTML</small> found in
the wild, so depending on the data, one module or the other
does a better job at the conversion. Also, HTML::Tidy can be
a bit difficult to install, so XML::Twig offers both option.
<small>TIMTOWTDI</small></p>

<p style="margin-left:17%;">output_html_doctype</p>

<p style="margin-left:23%;">when using HTML::TreeBuilder to
convert <small>HTML,</small> this option causes the
<small>DOCTYPE</small> declaration to be output, which may
be important for some legacy browsers. Without that option
the <small>DOCTYPE</small> definition is <small>NOT</small>
output. Also if the definition is completely wrong (ie not
easily parsable), it is not output either.</p>

<p style="margin-left:17%; margin-top: 1em"><b>Note</b>: I
_HATE_ the Java-like name of arguments used by most
<small>XML</small> modules. So in pure
<small>TIMTOWTDI</small> fashion all arguments can be
written either as <tt>&quot;UglyJavaLikeName&quot;</tt> or
as <tt>&quot;readable_perl_name&quot;</tt>:
<tt>&quot;twig_print_outside_roots&quot;</tt> or
<tt>&quot;TwigPrintOutsideRoots&quot;</tt> (or even
<tt>&quot;twigPrintOutsideRoots&quot;</tt> {shudder}).
XML::Twig normalizes them before processing them.</p>

<p style="margin-left:11%;">parse ( $source)</p>

<p style="margin-left:17%;">The <tt>$source</tt> parameter
should either be a string containing the whole
<small>XML</small> document, or it should be an open
<tt>&quot;IO::Handle&quot;</tt> (aka a filehandle).</p>

<p style="margin-left:17%; margin-top: 1em">A die call is
thrown if a parse error occurs. Otherwise it will return the
twig built by the parse. Use <tt>&quot;safe_parse&quot;</tt>
if you want the parsing to return even when an error
occurs.</p>

<p style="margin-left:17%; margin-top: 1em">If this method
is called as a class method
(<tt>&quot;XML::Twig&minus;&gt;parse(
$some_xml_or_html)&quot;</tt>) then an XML::Twig object is
created, using the parameters except the last one (eg
<tt>&quot;XML::Twig&minus;&gt;parse( pretty_print =&gt;
'indented', $some_xml_or_html)&quot;</tt>) and
<tt>&quot;xparse&quot;</tt> is called on it.</p>

<p style="margin-left:17%; margin-top: 1em">Note that when
parsing a filehandle, the handle should <small>NOT</small>
be open with an encoding (ie open with <tt>&quot;open( my
$in, '&lt;', $filename)&quot;</tt>. The file will be parsed
by <tt>&quot;expat&quot;</tt>, so specifying the encoding
actually causes problems for the parser (as in: it can crash
it, see https://rt.cpan.org/Ticket/Display.html?id=78877).
For parsing a file it is actually recommended to use
<tt>&quot;parsefile&quot;</tt> on the file name, instead of
&lt;parse&gt; on the open file.</p>

<p style="margin-left:11%;">parsestring</p>

<p style="margin-left:17%;">This is just an alias for
<tt>&quot;parse&quot;</tt> for backwards compatibility.</p>

<p style="margin-left:11%;">parsefile ( <small>FILE</small>
[, <small>OPT</small> =&gt; <small>OPT_VALUE</small>
[...]])</p>

<p style="margin-left:17%;">Open <tt>&quot;FILE&quot;</tt>
for reading, then call <tt>&quot;parse&quot;</tt> with the
open handle. The file is closed no matter how
<tt>&quot;parse&quot;</tt> returns.</p>

<p style="margin-left:17%; margin-top: 1em">A
<tt>&quot;die&quot;</tt> call is thrown if a parse error
occurs. Otherwise it will return the twig built by the
parse. Use <tt>&quot;safe_parsefile&quot;</tt> if you want
the parsing to return even when an error occurs.</p>

<p style="margin-left:11%;">parsefile_inplace ( $file,
$optional_extension)</p>

<p style="margin-left:17%;">Parse and update a file
&quot;in place&quot;. It does this by creating a temp file,
selecting it as the default for <i>print()</i> statements
(and methods), then parsing the input file. If the parsing
is successful, then the temp file is moved to replace the
input file.</p>

<p style="margin-left:17%; margin-top: 1em">If an extension
is given then the original file is backed-up (the rules for
the extension are the same as the rule for the &minus;i
option in perl).</p>

<p style="margin-left:11%;">parsefile_html_inplace ( $file,
$optional_extension)</p>

<p style="margin-left:17%;">Same as parsefile_inplace,
except that it parses <small>HTML</small> instead of
<small>XML</small></p>

<p style="margin-left:11%;">parseurl ($url
$optional_user_agent)</p>

<p style="margin-left:17%;">Gets the data from
<tt>$url</tt> and parse it. The data is piped to the parser
in chunks the size of the XML::Parser::Expat buffer, so
memory consumption and hopefully speed are optimal.</p>

<p style="margin-left:17%; margin-top: 1em">For most (read
&quot;small&quot;) <small>XML</small> it is probably as
efficient (and easier to debug) to just
<tt>&quot;get&quot;</tt> the <small>XML</small> file and
then parse it as a string.</p>

<pre style="margin-left:17%; margin-top: 1em">  use XML::Twig;
  use LWP::Simple;
  my $twig= XML::Twig&minus;&gt;new();
  $twig&minus;&gt;parse( LWP::Simple::get( $URL ));</pre>


<p style="margin-left:17%; margin-top: 1em">or</p>

<pre style="margin-left:17%; margin-top: 1em">  use XML::Twig;
  my $twig= XML::Twig&minus;&gt;nparse( $URL);</pre>


<p style="margin-left:17%; margin-top: 1em">If the
<tt>$optional_user_agent</tt> argument is used then it is
used, otherwise a new one is created.</p>

<p style="margin-left:11%;">safe_parse (
<small>SOURCE</small> [, <small>OPT</small> =&gt;
<small>OPT_VALUE</small> [...]])</p>

<p style="margin-left:17%;">This method is similar to
<tt>&quot;parse&quot;</tt> except that it wraps the parsing
in an <tt>&quot;eval&quot;</tt> block. It returns the twig
on success and 0 on failure (the twig object also contains
the parsed twig). <tt>$@</tt> contains the error message on
failure.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
parsing still stops as soon as an error is detected, there
is no way to keep going after an error.</p>

<p style="margin-left:11%;">safe_parsefile (
<small>FILE</small> [, <small>OPT</small> =&gt;
<small>OPT_VALUE</small> [...]])</p>

<p style="margin-left:17%;">This method is similar to
<tt>&quot;parsefile&quot;</tt> except that it wraps the
parsing in an <tt>&quot;eval&quot;</tt> block. It returns
the twig on success and 0 on failure (the twig object also
contains the parsed twig) . <tt>$@</tt> contains the error
message on failure</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
parsing still stops as soon as an error is detected, there
is no way to keep going after an error.</p>

<p style="margin-left:11%;">safe_parseurl ($url
$optional_user_agent)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;parseurl&quot;</tt> except that it wraps the
parsing in an <tt>&quot;eval&quot;</tt> block. It returns
the twig on success and 0 on failure (the twig object also
contains the parsed twig) . <tt>$@</tt> contains the error
message on failure</p>

<p style="margin-left:11%;">parse_html ($string_or_fh)</p>

<p style="margin-left:17%;">parse an <small>HTML</small>
string or file handle (by converting it to
<small>XML</small> using HTML::TreeBuilder, which needs to
be available).</p>

<p style="margin-left:17%; margin-top: 1em">This works
nicely, but some information gets lost in the process:
newlines are removed, and (at least on the version I use),
comments get get an extra <small>CDATA</small> section
inside ( &lt;!&minus;&minus; foo &minus;&minus;&gt; becomes
&lt;!&minus;&minus; &lt;![CDATA[ foo ]]&gt;
&minus;&minus;&gt;</p>

<p style="margin-left:11%;">parsefile_html ($file)</p>

<p style="margin-left:17%;">parse an <small>HTML</small>
file (by converting it to <small>XML</small> using
HTML::TreeBuilder, which needs to be available, or
HTML::Tidy if the <tt>&quot;use_tidy&quot;</tt> option was
used). The file is loaded completely in memory and converted
to <small>XML</small> before being parsed.</p>

<p style="margin-left:17%; margin-top: 1em">this method is
to be used with caution though, as it doesn&rsquo;t know
about the file encoding, it is usually better to use
<tt>&quot;parse_html&quot;</tt>, which gives you a chance to
open the file with the proper encoding layer.</p>

<p style="margin-left:11%;">parseurl_html ($url
$optional_user_agent)</p>

<p style="margin-left:17%;">parse an <small>URL</small> as
html the same way <tt>&quot;parse_html&quot;</tt> does</p>

<p style="margin-left:11%;">safe_parseurl_html ($url
$optional_user_agent)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;parseurl_html&quot;</tt>&gt; except that it wraps
the parsing in an <tt>&quot;eval&quot;</tt> block. It
returns the twig on success and 0 on failure (the twig
object also contains the parsed twig) . <tt>$@</tt> contains
the error message on failure</p>

<p style="margin-left:11%;">safe_parsefile_html ($file
$optional_user_agent)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;parsefile_html&quot;</tt>&gt; except that it wraps
the parsing in an <tt>&quot;eval&quot;</tt> block. It
returns the twig on success and 0 on failure (the twig
object also contains the parsed twig) . <tt>$@</tt> contains
the error message on failure</p>

<p style="margin-left:11%;">safe_parse_html
($string_or_fh)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;parse_html&quot;</tt> except that it wraps the
parsing in an <tt>&quot;eval&quot;</tt> block. It returns
the twig on success and 0 on failure (the twig object also
contains the parsed twig) . <tt>$@</tt> contains the error
message on failure</p>

<p style="margin-left:11%;">xparse ($thing_to_parse)</p>

<p style="margin-left:17%;">parse the
<tt>$thing_to_parse</tt>, whether it is a filehandle, a
string, an <small>HTML</small> file, an <small>HTML
URL,</small> an <small>URL</small> or a file.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
is mostly a convenience method for one-off scripts. For
example files that end in &rsquo;.htm&rsquo; or
&rsquo;.html&rsquo; are parsed first as <small>XML,</small>
and if this fails as <small>HTML.</small> This is certainly
not the most efficient way to do this in general.</p>

<p style="margin-left:11%;">nparse ($optional_twig_options,
$thing_to_parse)</p>

<p style="margin-left:17%;">create a twig with the
<tt>$optional_options</tt>, and parse the
<tt>$thing_to_parse</tt>, whether it is a filehandle, a
string, an <small>HTML</small> file, an <small>HTML
URL,</small> an <small>URL</small> or a file.</p>

<p style="margin-left:17%; margin-top: 1em">Examples:</p>

<pre style="margin-left:17%; margin-top: 1em">   XML::Twig&minus;&gt;nparse( &quot;file.xml&quot;);
   XML::Twig&minus;&gt;nparse( error_context =&gt; 1, &quot;file://file.xml&quot;);</pre>


<p style="margin-left:11%;">nparse_pp
($optional_twig_options, $thing_to_parse)</p>

<p style="margin-left:17%;">same as
<tt>&quot;nparse&quot;</tt> but also sets the
<tt>&quot;pretty_print&quot;</tt> option to
<tt>&quot;indented&quot;</tt>.</p>

<p style="margin-left:11%;">nparse_e
($optional_twig_options, $thing_to_parse)</p>

<p style="margin-left:17%;">same as
<tt>&quot;nparse&quot;</tt> but also sets the
<tt>&quot;error_context&quot;</tt> option to 1.</p>

<p style="margin-left:11%;">nparse_ppe
($optional_twig_options, $thing_to_parse)</p>

<p style="margin-left:17%;">same as
<tt>&quot;nparse&quot;</tt> but also sets the
<tt>&quot;pretty_print&quot;</tt> option to
<tt>&quot;indented&quot;</tt> and the
<tt>&quot;error_context&quot;</tt> option to 1.</p>

<p style="margin-left:11%;">parser</p>

<p style="margin-left:17%;">This method returns the
<tt>&quot;expat&quot;</tt> object (actually the
XML::Parser::Expat object) used during parsing. It is useful
for example to call XML::Parser::Expat methods on it. To get
the line of a tag for example use
<tt>&quot;$t&minus;&gt;parser&minus;&gt;current_line&quot;</tt>.</p>

<p style="margin-left:11%;">setTwigHandlers ($handlers)</p>

<p style="margin-left:17%;">Set the twig_handlers.
<tt>$handlers</tt> is a reference to a hash similar to the
one in the <tt>&quot;twig_handlers&quot;</tt> option of new.
All previous handlers are unset. The method returns the
reference to the previous handlers.</p>

<p style="margin-left:11%;">setTwigHandler ($exp
$handler)</p>

<p style="margin-left:17%;">Set a single twig_handler for
elements matching <tt>$exp</tt>. <tt>$handler</tt> is a
reference to a subroutine. If the handler was previously set
then the reference to the previous handler is returned.</p>

<p style="margin-left:11%;">setStartTagHandlers
($handlers)</p>

<p style="margin-left:17%;">Set the start_tag handlers.
<tt>$handlers</tt> is a reference to a hash similar to the
one in the <tt>&quot;start_tag_handlers&quot;</tt> option of
new. All previous handlers are unset. The method returns the
reference to the previous handlers.</p>

<p style="margin-left:11%;">setStartTagHandler ($exp
$handler)</p>

<p style="margin-left:17%;">Set a single start_tag handlers
for elements matching <tt>$exp</tt>. <tt>$handler</tt> is a
reference to a subroutine. If the handler was previously set
then the reference to the previous handler is returned.</p>

<p style="margin-left:11%;">setEndTagHandlers
($handlers)</p>

<p style="margin-left:17%;">Set the end_tag handlers.
<tt>$handlers</tt> is a reference to a hash similar to the
one in the <tt>&quot;end_tag_handlers&quot;</tt> option of
new. All previous handlers are unset. The method returns the
reference to the previous handlers.</p>

<p style="margin-left:11%;">setEndTagHandler ($exp
$handler)</p>

<p style="margin-left:17%;">Set a single end_tag handlers
for elements matching <tt>$exp</tt>. <tt>$handler</tt> is a
reference to a subroutine. If the handler was previously set
then the reference to the previous handler is returned.</p>

<p style="margin-left:11%;">setTwigRoots ($handlers)</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;twig_roots&quot;</tt> option when creating the
twig</p>

<p style="margin-left:11%;">setCharHandler ($exp
$handler)</p>

<p style="margin-left:17%;">Set a
<tt>&quot;char_handler&quot;</tt></p>

<p style="margin-left:11%;">setIgnoreEltsHandler ($exp)</p>

<p style="margin-left:17%;">Set a
<tt>&quot;ignore_elt&quot;</tt> handler (elements that match
<tt>$exp</tt> will be ignored</p>

<p style="margin-left:11%;">setIgnoreEltsHandlers
($exp)</p>

<p style="margin-left:17%;">Set all
<tt>&quot;ignore_elt&quot;</tt> handlers (previous handlers
are replaced)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>dtd</p></td>
<td width="2%"></td>
<td width="78%">


<p>Return the dtd (an XML::Twig::DTD object) of a twig</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:11%;">xmldecl</p>

<p style="margin-left:17%;">Return the <small>XML</small>
declaration for the document, or a default one if it
doesn&rsquo;t have one</p>

<p style="margin-left:11%;">doctype</p>

<p style="margin-left:17%;">Return the doctype for the
document</p>

<p style="margin-left:11%;">doctype_name</p>

<p style="margin-left:17%;">returns the doctype of the
document from the doctype declaration</p>

<p style="margin-left:11%;">system_id</p>

<p style="margin-left:17%;">returns the system value of the
<small>DTD</small> of the document from the doctype
declaration</p>

<p style="margin-left:11%;">public_id</p>

<p style="margin-left:17%;">returns the public doctype of
the document from the doctype declaration</p>

<p style="margin-left:11%;">internal_subset</p>

<p style="margin-left:17%;">returns the internal subset of
the <small>DTD</small></p>

<p style="margin-left:11%;">dtd_text</p>

<p style="margin-left:17%;">Return the <small>DTD</small>
text</p>

<p style="margin-left:11%;">dtd_print</p>

<p style="margin-left:17%;">Print the
<small>DTD</small></p>

<p style="margin-left:11%;">model ($tag)</p>

<p style="margin-left:17%;">Return the model (in the
<small>DTD</small> ) for the element <tt>$tag</tt></p>

<p style="margin-left:11%;">root</p>

<p style="margin-left:17%;">Return the root element of a
twig</p>

<p style="margin-left:11%;">set_root ($elt)</p>

<p style="margin-left:17%;">Set the root of a twig</p>

<p style="margin-left:11%;">first_elt
($optional_condition)</p>

<p style="margin-left:17%;">Return the first element
matching <tt>$optional_condition</tt> of a twig, if no
condition is given then the root is returned</p>

<p style="margin-left:11%;">last_elt
($optional_condition)</p>

<p style="margin-left:17%;">Return the last element
matching <tt>$optional_condition</tt> of a twig, if no
condition is given then the last element of the twig is
returned</p>

<p style="margin-left:11%;">elt_id ($id)</p>

<p style="margin-left:17%;">Return the element whose
<tt>&quot;id&quot;</tt> attribute is <tt>$id</tt></p>

<p style="margin-left:11%;">getEltById</p>

<p style="margin-left:17%;">Same as
<tt>&quot;elt_id&quot;</tt></p>

<p style="margin-left:11%;">index ($index_name,
$optional_index)</p>

<p style="margin-left:17%;">If the <tt>$optional_index</tt>
argument is present, return the corresponding element in the
index (created using the <tt>&quot;index&quot;</tt> option
for <tt>&quot;XML::Twig&minus;&quot;</tt>new&gt;)</p>

<p style="margin-left:17%; margin-top: 1em">If the argument
is not present, return an arrayref to the index</p>

<p style="margin-left:11%;">normalize</p>

<p style="margin-left:17%;">merge together all consecutive
pcdata elements in the document (if for example you have
turned some elements into pcdata using
<tt>&quot;erase&quot;</tt>, this will give you a
&quot;clean&quot; document in which there all text elements
are as long as possible).</p>

<p style="margin-left:11%;">encoding</p>

<p style="margin-left:17%;">This method returns the
encoding of the <small>XML</small> document, as defined by
the <tt>&quot;encoding&quot;</tt> attribute in the
<small>XML</small> declaration (ie it is
<tt>&quot;undef&quot;</tt> if the attribute is not
defined)</p>

<p style="margin-left:11%;">set_encoding</p>

<p style="margin-left:17%;">This method sets the value of
the <tt>&quot;encoding&quot;</tt> attribute in the
<small>XML</small> declaration. Note that if the document
did not have a declaration it is generated (with an
<small>XML</small> version of 1.0)</p>

<p style="margin-left:11%;">xml_version</p>

<p style="margin-left:17%;">This method returns the
<small>XML</small> version, as defined by the
<tt>&quot;version&quot;</tt> attribute in the
<small>XML</small> declaration (ie it is
<tt>&quot;undef&quot;</tt> if the attribute is not
defined)</p>

<p style="margin-left:11%;">set_xml_version</p>

<p style="margin-left:17%;">This method sets the value of
the <tt>&quot;version&quot;</tt> attribute in the
<small>XML</small> declaration. If the declaration did not
exist it is created.</p>

<p style="margin-left:11%;">standalone</p>

<p style="margin-left:17%;">This method returns the value
of the <tt>&quot;standalone&quot;</tt> declaration for the
document</p>

<p style="margin-left:11%;">set_standalone</p>

<p style="margin-left:17%;">This method sets the value of
the <tt>&quot;standalone&quot;</tt> attribute in the
<small>XML</small> declaration. Note that if the document
did not have a declaration it is generated (with an
<small>XML</small> version of 1.0)</p>

<p style="margin-left:11%;">set_output_encoding</p>

<p style="margin-left:17%;">Set the
<tt>&quot;encoding&quot;</tt> &quot;attribute&quot; in the
<small>XML</small> declaration</p>

<p style="margin-left:11%;">set_doctype ($name, $system,
$public, $internal)</p>

<p style="margin-left:17%;">Set the doctype of the element.
If an argument is <tt>&quot;undef&quot;</tt> (or not
present) then its former value is retained, if a false
(&rsquo;&rsquo; or 0) value is passed then the former value
is deleted;</p>

<p style="margin-left:11%;">entity_list</p>

<p style="margin-left:17%;">Return the entity list of a
twig</p>

<p style="margin-left:11%;">entity_names</p>

<p style="margin-left:17%;">Return the list of all defined
entities</p>

<p style="margin-left:11%;">entity ($entity_name)</p>

<p style="margin-left:17%;">Return the entity</p>

<p style="margin-left:11%;">change_gi ($old_gi,
$new_gi)</p>

<p style="margin-left:17%;">Performs a (very fast) global
change. All elements <tt>$old_gi</tt> are now
<tt>$new_gi</tt>. This is a bit dangerous though and should
be avoided if &lt; possible, as the new tag might be ignored
in subsequent processing.</p>

<p style="margin-left:17%; margin-top: 1em">See
<tt>&quot;BUGS &quot;</tt></p>

<p style="margin-left:11%;">flush ($optional_filehandle,
%options)</p>

<p style="margin-left:17%;">Flushes a twig up to (and
including) the current element, then deletes all unnecessary
elements from the tree that&rsquo;s kept in memory.
<tt>&quot;flush&quot;</tt> keeps track of which elements
need to be open/closed, so if you flush from handlers you
don&rsquo;t have to worry about anything. Just keep flushing
the twig every time you&rsquo;re done with a sub-tree and it
will come out well-formed. After the whole parsing
don&rsquo;t forget to<tt>&quot;flush&quot;</tt> one more
time to print the end of the document. The doctype and
entity declarations are also printed.</p>

<p style="margin-left:17%; margin-top: 1em">flush take an
optional filehandle as an argument.</p>

<p style="margin-left:17%; margin-top: 1em">If you use
<tt>&quot;flush&quot;</tt> at any point during parsing, the
document will be flushed one last time at the end of the
parsing, to the proper filehandle.</p>

<p style="margin-left:17%; margin-top: 1em">options: use
the <tt>&quot;update_DTD&quot;</tt> option if you have
updated the (internal) <small>DTD</small> and/or the entity
list and you want the updated <small>DTD</small> to be
output</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;pretty_print&quot;</tt> option sets the pretty
printing of the document.</p>

<pre style="margin-left:17%; margin-top: 1em">   Example: $t&minus;&gt;flush( Update_DTD =&gt; 1);
            $t&minus;&gt;flush( $filehandle, pretty_print =&gt; 'indented');
            $t&minus;&gt;flush( \*FILE);</pre>


<p style="margin-left:11%;">flush_up_to ($elt,
$optional_filehandle, %options)</p>

<p style="margin-left:17%;">Flushes up to the <tt>$elt</tt>
element. This allows you to keep part of the tree in memory
when you <tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
flush.</p>

<p style="margin-left:11%;">purge</p>

<p style="margin-left:17%;">Does the same as a
<tt>&quot;flush&quot;</tt> except it does not print the
twig. It just deletes all elements that have been completely
parsed so far.</p>

<p style="margin-left:11%;">purge_up_to ($elt)</p>

<p style="margin-left:17%;">Purges up to the <tt>$elt</tt>
element. This allows you to keep part of the tree in memory
when you <tt>&quot;purge&quot;</tt>.</p>

<p style="margin-left:11%;">print ($optional_filehandle,
%options)</p>

<p style="margin-left:17%;">Prints the whole document
associated with the twig. To be used only
<small>AFTER</small> the parse.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:11%;">print_to_file ($filename,
%options)</p>

<p style="margin-left:17%;">Prints the whole document
associated with the twig to file <tt>$filename</tt>. To be
used only <small>AFTER</small> the parse.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:11%;">sprint</p>

<p style="margin-left:17%;">Return the text of the whole
document associated with the twig. To be used only
<small>AFTER</small> the parse.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:11%;">trim</p>

<p style="margin-left:17%;">Trim the document: gets rid of
initial and trailing spaces, and replaces multiple spaces by
a single one.</p>

<p style="margin-left:11%;">toSAX1 ($handler)</p>

<p style="margin-left:17%;">Send <small>SAX</small> events
for the twig to the <small>SAX1</small> handler
<tt>$handler</tt></p>

<p style="margin-left:11%;">toSAX2 ($handler)</p>

<p style="margin-left:17%;">Send <small>SAX</small> events
for the twig to the <small>SAX2</small> handler
<tt>$handler</tt></p>

<p style="margin-left:11%;">flush_toSAX1 ($handler)</p>

<p style="margin-left:17%;">Same as flush, except that
<small>SAX</small> events are sent to the
<small>SAX1</small> handler <tt>$handler</tt> instead of the
twig being printed</p>

<p style="margin-left:11%;">flush_toSAX2 ($handler)</p>

<p style="margin-left:17%;">Same as flush, except that
<small>SAX</small> events are sent to the
<small>SAX2</small> handler <tt>$handler</tt> instead of the
twig being printed</p>

<p style="margin-left:11%;">ignore</p>

<p style="margin-left:17%;">This method should be called
during parsing, usually in
<tt>&quot;start_tag_handlers&quot;</tt>. It causes the
element to be skipped during the parsing: the twig is not
built for this element, it will not be accessible during
parsing or after it. The element will not take up any memory
and parsing will be faster.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
method can also be called on an element. If the element is a
parent of the current element then this element will be
ignored (the twig will not be built any more for it and what
has already been built will be deleted).</p>

<p style="margin-left:11%;">set_pretty_print ($style)</p>

<p style="margin-left:17%;">Set the pretty print method,
amongst &rsquo;<tt>&quot;none&quot;</tt>&rsquo; (default),
&rsquo;<tt>&quot;nsgmls&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;nice&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented&quot;</tt>&rsquo;,
<tt>&quot;indented_c&quot;</tt>,
&rsquo;<tt>&quot;wrapped&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;record&quot;</tt>&rsquo; and
&rsquo;<tt>&quot;record_c&quot;</tt>&rsquo;</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING:</small></b>
the pretty print style is a <b><small>GLOBAL</small></b>
variable, so once set it&rsquo;s applied to
<b><small>ALL</small></b> <tt>&quot;print&quot;</tt>&rsquo;s
(and <tt>&quot;sprint&quot;</tt>&rsquo;s). Same goes if you
use XML::Twig with <tt>&quot;mod_perl&quot;</tt> . This
should not be a problem as the <small>XML</small>
that&rsquo;s generated is valid anyway, and
<small>XML</small> processors (as well as
<small>HTML</small> processors, including browsers) should
not care. Let me know if this is a big problem, but at the
moment the performance/cleanliness trade-off clearly favors
the global approach.</p>

<p style="margin-left:11%;">set_empty_tag_style
($style)</p>

<p style="margin-left:17%;">Set the empty tag display style
(&rsquo;<tt>&quot;normal&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;html&quot;</tt>&rsquo; or
&rsquo;<tt>&quot;expand&quot;</tt>&rsquo;). As with
<tt>&quot;set_pretty_print&quot;</tt> this sets a global
flag.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;normal&quot;</tt>
outputs an empty tag
&rsquo;<tt>&quot;&lt;tag/&gt;&quot;</tt>&rsquo;,
<tt>&quot;html&quot;</tt> adds a space
&rsquo;<tt>&quot;&lt;tag /&gt;&quot;</tt>&rsquo; for
elements that can be empty in <small>XHTML</small> and
<tt>&quot;expand&quot;</tt> outputs
&rsquo;<tt>&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">set_remove_cdata ($flag)</p>

<p style="margin-left:17%;">set (or unset) the flag that
forces the twig to output <small>CDATA</small> sections as
regular (escaped) <small>PCDATA</small></p>

<p style="margin-left:11%;">print_prolog
($optional_filehandle, %options)</p>

<p style="margin-left:17%;">Prints the prolog (
<small>XML</small> declaration + <small>DTD +</small> entity
declarations) of a document.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:11%;">prolog ($optional_filehandle,
%options)</p>

<p style="margin-left:17%;">Return the prolog (
<small>XML</small> declaration + <small>DTD +</small> entity
declarations) of a document.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>.</p>

<p style="margin-left:11%;">finish</p>

<p style="margin-left:17%;">Call Expat
<tt>&quot;finish&quot;</tt> method. Unsets all handlers
(including internal ones that set context), but expat
continues parsing to the end of the document or until it
finds an error. It should finish up a lot faster than with
the handlers set.</p>

<p style="margin-left:11%;">finish_print</p>

<p style="margin-left:17%;">Stops twig processing, flush
the twig and proceed to finish printing the document as fast
as possible. Use this method when modifying a document and
the modification is done.</p>

<p style="margin-left:11%;">finish_now</p>

<p style="margin-left:17%;">Stops twig processing, does not
finish parsing the document (which could actually be not
well-formed after the point where
<tt>&quot;finish_now&quot;</tt> is called). Execution
resumes after the <tt>&quot;Lparse&quot;</tt>&gt; or
<tt>&quot;parsefile&quot;</tt> call. The content of the twig
is what has been parsed so far (all open elements at the
time <tt>&quot;finish_now&quot;</tt> is called are
considered closed).</p>


<p style="margin-left:11%;">set_expand_external_entities</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;expand_external_ents&quot;</tt> option when
creating the twig</p>

<p style="margin-left:11%;">set_input_filter</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;input_filter&quot;</tt> option when creating the
twig</p>

<p style="margin-left:11%;">set_keep_atts_order</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;keep_atts_order&quot;</tt> option when creating
the twig</p>

<p style="margin-left:11%;">set_keep_encoding</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;keep_encoding&quot;</tt> option when creating the
twig</p>

<p style="margin-left:11%;">escape_gt</p>

<p style="margin-left:17%;">usually XML::Twig does not
escape &gt; in its output. Using this option makes it
replace &gt; by &amp;gt;</p>

<p style="margin-left:11%;">do_not_escape_gt</p>

<p style="margin-left:17%;">reverts XML::Twig behavior to
its default of not escaping &gt; in its output.</p>

<p style="margin-left:11%;">set_output_filter</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;output_filter&quot;</tt> option when creating the
twig</p>

<p style="margin-left:11%;">set_output_text_filter</p>

<p style="margin-left:17%;">Same as using the
<tt>&quot;output_text_filter&quot;</tt> option when creating
the twig</p>

<p style="margin-left:11%;">add_stylesheet ($type,
@options)</p>

<p style="margin-left:17%;">Adds an external stylesheet to
an <small>XML</small> document.</p>

<p style="margin-left:17%; margin-top: 1em">Supported types
and options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p>xsl</p></td>
<td width="1%"></td>
<td width="51%">


<p>option: the url of the stylesheet</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Example:</p>

<pre style="margin-left:23%; margin-top: 1em">  $t&minus;&gt;add_stylesheet( xsl =&gt; &quot;xsl_style.xsl&quot;);</pre>


<p style="margin-left:23%; margin-top: 1em">will generate
the following <small>PI</small> at the beginning of the
document:</p>

<pre style="margin-left:23%; margin-top: 1em">  &lt;?xml&minus;stylesheet type=&quot;text/xsl&quot; href=&quot;xsl_style.xsl&quot;?&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p style="margin-top: 1em">css</p></td>
<td width="1%"></td>
<td width="51%">


<p style="margin-top: 1em">option: the url of the
stylesheet</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">active_twig</p>

<p style="margin-left:23%;">a class method that returns the
last processed twig, so you don&rsquo;t necessarily need the
object to call methods on it.</p>

<p style="margin-left:11%;">Methods inherited from
XML::Parser::Expat</p>

<p style="margin-left:17%;">A twig inherits all the
relevant methods from XML::Parser::Expat. These methods can
only be used during the parsing phase (they will generate a
fatal error otherwise).</p>

<p style="margin-left:17%; margin-top: 1em">Inherited
methods are: <br>
depth</p>

<p style="margin-left:23%;">Returns the size of the context
list.</p>

<p style="margin-left:17%;">in_element</p>

<p style="margin-left:23%;">Returns true if
<small>NAME</small> is equal to the name of the innermost
curX rently opened element. If namespace processing is being
used and you want to check against a name that may be in a
namespace, then use the generate_ns_name method to create
the <small>NAME</small> argument.</p>

<p style="margin-left:17%;">within_element</p>

<p style="margin-left:23%;">Returns the number of times the
given name appears in the context list. If namespace
processing is being used and you want to check against a
name that may be in a namespace, then use the generX
ate_ns_name method to create the <small>NAME</small>
argument.</p>

<p style="margin-left:17%;">context</p>

<p style="margin-left:23%;">Returns a list of element names
that represent open elements, with the last one being the
innermost. Inside start and end tag hanX dlers, this will be
the tag of the parent element.</p>

<p style="margin-left:17%;">current_line</p>

<p style="margin-left:23%;">Returns the line number of the
current position of the parse.</p>

<p style="margin-left:17%;">current_column</p>

<p style="margin-left:23%;">Returns the column number of
the current position of the parse.</p>

<p style="margin-left:17%;">current_byte</p>

<p style="margin-left:23%;">Returns the current position of
the parse.</p>

<p style="margin-left:17%;">position_in_context</p>

<p style="margin-left:23%;">Returns a string that shows the
current parse position. <small>LINES</small> should be an
integer &gt;= 0 that represents the number of lines on
either side of the current parse line to place into the
returned string.</p>

<p style="margin-left:17%;">base ([ <small>NEWBASE</small>
])</p>

<p style="margin-left:23%;">Returns the current value of
the base for resolving relative URIs. If
<small>NEWBASE</small> is supplied, changes the base to that
value.</p>

<p style="margin-left:17%;">current_element</p>

<p style="margin-left:23%;">Returns the name of the
innermost currently opened element. Inside start or end
handlers, returns the parent of the element associated with
those tags.</p>

<p style="margin-left:17%;">element_index</p>

<p style="margin-left:23%;">Returns an integer that is the
depth-first visit order of the curX rent element. This will
be zero outside of the root element. For example, this will
return 1 when called from the start handler for the root
element start tag.</p>

<p style="margin-left:17%;">recognized_string</p>

<p style="margin-left:23%;">Returns the string from the
document that was recognized in order to call the current
handler. For instance, when called from a start handler, it
will give us the the start-tag string. The string is encoded
in <small>UTF&minus;8.</small> This method doesn&rsquo;t
return a meaningful string inside declaration handlers.</p>

<p style="margin-left:17%;">original_string</p>

<p style="margin-left:23%;">Returns the verbatim string
from the document that was recognized in order to call the
current handler. The string is in the original document
encoding. This method doesn&rsquo;t return a meaningful
string inside declaration handlers.</p>

<p style="margin-left:17%;">xpcroak</p>

<p style="margin-left:23%;">Concatenate onto the given
message the current line number within the
<small>XML</small> document plus the message implied by
ErrorContext. Then croak with the formed message.</p>

<p style="margin-left:17%;">xpcarp</p>

<p style="margin-left:23%;">Concatenate onto the given
message the current line number within the
<small>XML</small> document plus the message implied by
ErrorContext. Then carp with the formed message.</p>

<p style="margin-left:17%;">xml_escape( <small>TEXT</small>
[, <small>CHAR</small> [, <small>CHAR ...</small> ]])</p>

<p style="margin-left:23%;">Returns <small>TEXT</small>
with markup characters turned into character entities. Any
additional characters provided as arguments are also turned
into character references where found in
<small>TEXT.</small></p>

<p style="margin-left:23%; margin-top: 1em">(this method is
broken on some versions of expat/XML::Parser)</p>

<p style="margin-left:11%;">path ( $optional_tag)</p>

<p style="margin-left:17%;">Return the element context in a
form similar to XPath&rsquo;s short form:
&rsquo;<tt>&quot;/root/tag1/../tag&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">get_xpath (
$optional_array_ref, $xpath, $optional_offset)</p>

<p style="margin-left:17%;">Performs a
<tt>&quot;get_xpath&quot;</tt> on the document root (see
&lt;Elt|&quot;Elt&quot;&gt;)</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>$optional_array_ref</tt> argument is used the array must
contain elements. The <tt>$xpath</tt> expression is applied
to each element in turn and the result is union of all
results. This way a first query can be refined in further
steps.</p>

<p style="margin-left:11%;">find_nodes (
$optional_array_ref, $xpath, $optional_offset)</p>

<p style="margin-left:17%;">same as
<tt>&quot;get_xpath&quot;</tt></p>

<p style="margin-left:11%;">findnodes (
$optional_array_ref, $xpath, $optional_offset)</p>

<p style="margin-left:17%;">same as
<tt>&quot;get_xpath&quot;</tt> (similar to the XML::LibXML
method)</p>

<p style="margin-left:11%;">findvalue (
$optional_array_ref, $xpath, $optional_offset)</p>

<p style="margin-left:17%;">Return the
<tt>&quot;join&quot;</tt> of all texts of the results of
applying <tt>&quot;get_xpath&quot;</tt> to the node (similar
to the XML::LibXML method)</p>

<p style="margin-left:11%;">findvalues (
$optional_array_ref, $xpath, $optional_offset)</p>

<p style="margin-left:17%;">Return an array of all texts of
the results of applying <tt>&quot;get_xpath&quot;</tt> to
the node</p>

<p style="margin-left:11%;">subs_text ($regexp,
$replace)</p>

<p style="margin-left:17%;">subs_text does text
substitution on the whole document, similar to perl&rsquo;s
<tt>&quot; s///&quot;</tt> operator.</p>

<p style="margin-left:11%;">dispose</p>

<p style="margin-left:17%;">Useful only if you don&rsquo;t
have <tt>&quot;Scalar::Util&quot;</tt> or
<tt>&quot;WeakRef&quot;</tt> installed.</p>

<p style="margin-left:17%; margin-top: 1em">Reclaims
properly the memory used by an XML::Twig object. As the
object has circular references it never goes out of scope,
so if you want to parse lots of <small>XML</small> documents
then the memory leak becomes a problem. Use
<tt>&quot;$twig&minus;&gt;dispose&quot;</tt> to clear this
problem.</p>

<p style="margin-left:11%;">att_accessors
(list_of_attribute_names)</p>

<p style="margin-left:17%;">A convenience method that
creates l&minus;valued accessors for attributes. So
<tt>&quot;$twig&minus;&gt;create_accessors(
'foo')&quot;</tt> will create a <tt>&quot;foo&quot;</tt>
method that can be called on elements:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;foo;         # equivalent to $elt&minus;&gt;{'att'}&minus;&gt;{'foo'};
  $elt&minus;&gt;foo( 'bar'); # equivalent to $elt&minus;&gt;set_att( foo =&gt; 'bar');</pre>


<p style="margin-left:17%; margin-top: 1em">The methods are
l&minus;valued only under those perl&rsquo;s that support
this feature (5.6 and above)</p>

<p style="margin-left:11%;">create_accessors
(list_of_attribute_names)</p>

<p style="margin-left:17%;">Same as att_accessors</p>

<p style="margin-left:11%;">elt_accessors
(list_of_attribute_names)</p>

<p style="margin-left:17%;">A convenience method that
creates accessors for elements. So
<tt>&quot;$twig&minus;&gt;create_accessors(
'foo')&quot;</tt> will create a <tt>&quot;foo&quot;</tt>
method that can be called on elements:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;foo;         # equivalent to $elt&minus;&gt;first_child( 'foo');</pre>


<p style="margin-left:11%;">field_accessors
(list_of_attribute_names)</p>

<p style="margin-left:17%;">A convenience method that
creates accessors for element values
(<tt>&quot;field&quot;</tt>). So
<tt>&quot;$twig&minus;&gt;create_accessors(
'foo')&quot;</tt> will create a <tt>&quot;foo&quot;</tt>
method that can be called on elements:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;foo;         # equivalent to $elt&minus;&gt;field( 'foo');</pre>



<p style="margin-left:11%;">set_do_not_escape_amp_in_atts</p>

<p style="margin-left:17%;">An evil method, that I only
document because Test::Pod::Coverage complaints otherwise,
but really, you don&rsquo;t want to know about it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig::Elt</b>
<br>
new ($optional_tag, $optional_atts, @optional_content)</p>

<p style="margin-left:17%;">The <tt>&quot;tag&quot;</tt> is
optional (but then you can&rsquo;t have a content ), the
<tt>$optional_atts</tt> argument is a reference to a hash of
attributes, the content can be just a string or a list of
strings and element. A content of
&rsquo;<tt>&quot;#EMPTY&quot;</tt>&rsquo; creates an empty
element;</p>

<pre style="margin-left:17%; margin-top: 1em"> Examples: my $elt= XML::Twig::Elt&minus;&gt;new();
           my $elt= XML::Twig::Elt&minus;&gt;new( para =&gt; { align =&gt; 'center' });
           my $elt= XML::Twig::Elt&minus;&gt;new( para =&gt; { align =&gt; 'center' }, 'foo');
           my $elt= XML::Twig::Elt&minus;&gt;new( br   =&gt; '#EMPTY');
           my $elt= XML::Twig::Elt&minus;&gt;new( 'para');
           my $elt= XML::Twig::Elt&minus;&gt;new( para =&gt; 'this is a para');
           my $elt= XML::Twig::Elt&minus;&gt;new( para =&gt; $elt3, 'another para');</pre>


<p style="margin-left:17%; margin-top: 1em">The strings are
not parsed, the element is not attached to any twig.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: if you rely on <small>ID</small> &rsquo;s then you will
have to set the id yourself. At this point the element does
not belong to a twig yet, so the <small>ID</small> attribute
is not known so it won&rsquo;t be stored in the
<small>ID</small> list.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>&quot;#COMMENT&quot;</tt>, <tt>&quot;#PCDATA&quot;</tt>
or <tt>&quot;#CDATA&quot;</tt> are valid tag names, that
will create text elements.</p>

<p style="margin-left:17%; margin-top: 1em">To create an
element <tt>&quot;foo&quot;</tt> containing a
<small>CDATA</small> section:</p>

<pre style="margin-left:17%; margin-top: 1em">           my $foo= XML::Twig::Elt&minus;&gt;new( '#CDATA' =&gt; &quot;content of the CDATA section&quot;)
                                  &minus;&gt;wrap_in( 'foo');</pre>


<p style="margin-left:17%; margin-top: 1em">An attribute of
&rsquo;#CDATA&rsquo;, will create the content of the element
as <small>CDATA:</small></p>

<pre style="margin-left:17%; margin-top: 1em">  my $elt= XML::Twig::Elt&minus;&gt;new( 'p' =&gt; { '#CDATA' =&gt; 1}, 'foo &lt; bar');</pre>


<p style="margin-left:17%; margin-top: 1em">creates an
element</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;p&gt;&lt;![CDATA[foo &lt; bar]]&gt;&lt;/&gt;</pre>


<p style="margin-left:11%;">parse ($string, %args)</p>

<p style="margin-left:17%;">Creates an element from an
<small>XML</small> string. The string is actually parsed as
a new twig, then the root of that twig is returned. The
arguments in <tt>%args</tt> are passed to the twig. As
always if the parse fails the parser will die, so use an
eval if you want to trap syntax errors.</p>

<p style="margin-left:17%; margin-top: 1em">As obviously
the element does not exist beforehand this method has to be
called on the class:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $elt= parse XML::Twig::Elt( &quot;&lt;a&gt; string to parse, with &lt;sub/&gt;
                                  &lt;elements&gt;, actually tons of &lt;/elements&gt;
                  h&lt;/a&gt;&quot;);</pre>


<p style="margin-left:11%;">set_inner_xml ($string)</p>

<p style="margin-left:17%;">Sets the content of the element
to be the tree created from the string</p>

<p style="margin-left:11%;">set_inner_html ($string)</p>

<p style="margin-left:17%;">Sets the content of the
element, after parsing the string with an
<small>HTML</small> parser (HTML::Parser)</p>

<p style="margin-left:11%;">set_outer_xml ($string)</p>

<p style="margin-left:17%;">Replaces the element with the
tree created from the string</p>

<p style="margin-left:11%;">print ($optional_filehandle,
$optional_pretty_print_style)</p>

<p style="margin-left:17%;">Prints an entire element,
including the tags, optionally to a
<tt>$optional_filehandle</tt>, optionally with a
<tt>$pretty_print_style</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">The print
outputs <small>XML</small> data so base entities are
escaped.</p>

<p style="margin-left:11%;">print_to_file ($filename,
%options)</p>

<p style="margin-left:17%;">Prints the element to file
<tt>$filename</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">options: see
<tt>&quot;flush&quot;</tt>. =item sprint ($elt,
<tt>$optional_no_enclosing_tag</tt>)</p>

<p style="margin-left:17%; margin-top: 1em">Return the xml
string for an entire element, including the tags. If the
optional second argument is true then only the string inside
the element is returned (the start and end tag for
<tt>$elt</tt> are not). The text is XML-escaped: base
entities (&amp; and &lt; in text, &amp; &lt; and &quot; in
attribute values) are turned into entities.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>gi</p></td>
<td width="3%"></td>
<td width="83%">


<p>Return the gi of the element (the gi is the
<tt>&quot;generic identifier&quot;</tt> the tag name in
<small>SGML</small> parlance).</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;tag&quot;</tt>
and <tt>&quot;name&quot;</tt> are synonyms of
<tt>&quot;gi&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">tag</p></td>
<td width="2%"></td>
<td width="18%">


<p style="margin-top: 1em">Same as
<tt>&quot;gi&quot;</tt></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:11%;">name</p>

<p style="margin-left:17%;">Same as
<tt>&quot;tag&quot;</tt></p>

<p style="margin-left:11%;">set_gi ($tag)</p>

<p style="margin-left:17%;">Set the gi (tag) of an
element</p>

<p style="margin-left:11%;">set_tag ($tag)</p>

<p style="margin-left:17%;">Set the tag
(=<tt>&quot;tag&quot;</tt>) of an element</p>

<p style="margin-left:11%;">set_name ($name)</p>

<p style="margin-left:17%;">Set the name
(=<tt>&quot;tag&quot;</tt>) of an element</p>

<p style="margin-left:11%;">root</p>

<p style="margin-left:17%;">Return the root of the twig in
which the element is contained.</p>

<p style="margin-left:11%;">twig</p>

<p style="margin-left:17%;">Return the twig containing the
element.</p>

<p style="margin-left:11%;">parent
($optional_condition)</p>

<p style="margin-left:17%;">Return the parent of the
element, or the first ancestor matching the
<tt>$optional_condition</tt></p>

<p style="margin-left:11%;">first_child
($optional_condition)</p>

<p style="margin-left:17%;">Return the first child of the
element, or the first child matching the
<tt>$optional_condition</tt></p>

<p style="margin-left:11%;">has_child
($optional_condition)</p>

<p style="margin-left:17%;">Return the first child of the
element, or the first child matching the
<tt>$optional_condition</tt> (same as first_child)</p>

<p style="margin-left:11%;">has_children
($optional_condition)</p>

<p style="margin-left:17%;">Return the first child of the
element, or the first child matching the
<tt>$optional_condition</tt> (same as first_child)</p>

<p style="margin-left:11%;">first_child_text
($optional_condition)</p>

<p style="margin-left:17%;">Return the text of the first
child of the element, or the first child <br>
matching the <tt>$optional_condition</tt> If there is no
first_child then returns &rsquo;&rsquo;. This avoids getting
the child, checking for its existence then getting the text
for trivial cases.</p>

<p style="margin-left:17%; margin-top: 1em">Similar methods
are available for the other navigation methods: <br>
last_child_text <br>
prev_sibling_text <br>
next_sibling_text <br>
prev_elt_text <br>
next_elt_text <br>
child_text <br>
parent_text</p>

<p style="margin-left:17%; margin-top: 1em">All this
methods also exist in &quot;trimmed&quot; variant: <br>
first_child_trimmed_text <br>
last_child_trimmed_text <br>
prev_sibling_trimmed_text <br>
next_sibling_trimmed_text <br>
prev_elt_trimmed_text <br>
next_elt_trimmed_text <br>
child_trimmed_text <br>
parent_trimmed_text</p>

<p style="margin-left:11%;">field ($condition)</p>

<p style="margin-left:17%;">Same method as
<tt>&quot;first_child_text&quot;</tt> with a different
name</p>

<p style="margin-left:11%;">fields ($condition_list)</p>

<p style="margin-left:17%;">Return the list of field (text
of first child matching the conditions), missing fields are
returned as the empty string.</p>

<p style="margin-left:17%; margin-top: 1em">Same method as
<tt>&quot;first_child_text&quot;</tt> with a different
name</p>

<p style="margin-left:11%;">trimmed_field
($optional_condition)</p>

<p style="margin-left:17%;">Same method as
<tt>&quot;first_child_trimmed_text&quot;</tt> with a
different name</p>

<p style="margin-left:11%;">set_field ($condition,
$optional_atts, @list_of_elt_and_strings)</p>

<p style="margin-left:17%;">Set the content of the first
child of the element that matches <tt>$condition</tt>, the
rest of the arguments is the same as for
<tt>&quot;set_content&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">If no child
matches <tt>$condition</tt> _and_ if <tt>$condition</tt> is
a valid <small>XML</small> element name, then a new element
by that name is created and inserted as the last child.</p>

<p style="margin-left:11%;">first_child_matches
($optional_condition)</p>

<p style="margin-left:17%;">Return the element if the first
child of the element (if it exists) passes the
<tt>$optional_condition &quot;undef&quot;</tt> otherwise</p>

<pre style="margin-left:17%; margin-top: 1em">  if( $elt&minus;&gt;first_child_matches( 'title')) ...</pre>


<p style="margin-left:17%; margin-top: 1em">is equivalent
to</p>

<pre style="margin-left:17%; margin-top: 1em">  if( $elt&minus;&gt;{first_child} &amp;&amp; $elt&minus;&gt;{first_child}&minus;&gt;passes( 'title'))</pre>



<p style="margin-left:17%; margin-top: 1em">&quot;first_child_is&quot;
is an other name for this method</p>

<p style="margin-left:17%; margin-top: 1em">Similar methods
are available for the other navigation methods: <br>
last_child_matches <br>
prev_sibling_matches <br>
next_sibling_matches <br>
prev_elt_matches <br>
next_elt_matches <br>
child_matches <br>
parent_matches</p>

<p style="margin-left:11%;">is_first_child
($optional_condition)</p>

<p style="margin-left:17%;">returns true (the element) if
the element is the first child of its parent (optionally
that satisfies the <tt>$optional_condition</tt>)</p>

<p style="margin-left:11%;">is_last_child
($optional_condition)</p>

<p style="margin-left:17%;">returns true (the element) if
the element is the last child of its parent (optionally that
satisfies the <tt>$optional_condition</tt>)</p>

<p style="margin-left:11%;">prev_sibling
($optional_condition)</p>

<p style="margin-left:17%;">Return the previous sibling of
the element, or the previous sibling matching
<tt>$optional_condition</tt></p>

<p style="margin-left:11%;">next_sibling
($optional_condition)</p>

<p style="margin-left:17%;">Return the next sibling of the
element, or the first one matching
<tt>$optional_condition</tt>.</p>

<p style="margin-left:11%;">next_elt ($optional_elt,
$optional_condition)</p>

<p style="margin-left:17%;">Return the next elt (optionally
matching <tt>$optional_condition</tt>) of the element. This
is defined as the next element which opens after the current
element opens. Which usually means the first child of the
element. Counter-intuitive as it might look this allows you
to loop through the whole document by starting from the
root.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$optional_elt</tt> is the root of a subtree. When the
<tt>&quot;next_elt&quot;</tt> is out of the subtree then the
method returns undef. You can then walk a sub-tree with:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $elt= $subtree_root;
  while( $elt= $elt&minus;&gt;next_elt( $subtree_root))
    { # insert processing code here
    }</pre>


<p style="margin-left:11%;">prev_elt
($optional_condition)</p>

<p style="margin-left:17%;">Return the previous elt
(optionally matching <tt>$optional_condition</tt>) of the
element. This is the first element which opens before the
current one. It is usually either the last descendant of the
previous sibling or simply the parent</p>

<p style="margin-left:11%;">next_n_elt ($offset,
$optional_condition)</p>

<p style="margin-left:17%;">Return the
<tt>$offset</tt>&minus;th element that matches the
<tt>$optional_condition</tt></p>

<p style="margin-left:11%;">following_elt</p>

<p style="margin-left:17%;">Return the following element
(as per the XPath following axis)</p>

<p style="margin-left:11%;">preceding_elt</p>

<p style="margin-left:17%;">Return the preceding element
(as per the XPath preceding axis)</p>

<p style="margin-left:11%;">following_elts</p>

<p style="margin-left:17%;">Return the list of following
elements (as per the XPath following axis)</p>

<p style="margin-left:11%;">preceding_elts</p>

<p style="margin-left:17%;">Return the pst of preceding
elements (as per the XPath preceding axis)</p>

<p style="margin-left:11%;">children
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of children
(optionally which matches <tt>$optional_condition</tt>) of
the element. The list is in document order.</p>

<p style="margin-left:11%;">children_count
($optional_condition)</p>

<p style="margin-left:17%;">Return the number of children
of the element (optionally which matches
<tt>$optional_condition</tt>)</p>

<p style="margin-left:11%;">children_text
($optional_condition)</p>

<p style="margin-left:17%;">In array context, reeturns an
array containing the text of children of the element
(optionally which matches <tt>$optional_condition</tt>)</p>

<p style="margin-left:17%; margin-top: 1em">In scalar
context, returns the concatenation of the text of children
of the element</p>

<p style="margin-left:11%;">children_trimmed_text
($optional_condition)</p>

<p style="margin-left:17%;">In array context, returns an
array containing the trimmed text of children of the element
(optionally which matches <tt>$optional_condition</tt>)</p>

<p style="margin-left:17%; margin-top: 1em">In scalar
context, returns the concatenation of the trimmed text of
children of the element</p>

<p style="margin-left:11%;">children_copy
($optional_condition)</p>

<p style="margin-left:17%;">Return a list of elements that
are copies of the children of the element, optionally which
matches <tt>$optional_condition</tt></p>

<p style="margin-left:11%;">descendants
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of all
descendants (optionally which matches
<tt>$optional_condition</tt>) of the element. This is the
equivalent of the <tt>&quot;getElementsByTagName&quot;</tt>
of the <small>DOM</small> (by the way, if you are really a
<small>DOM</small> addict, you can use
<tt>&quot;getElementsByTagName&quot;</tt> instead)</p>

<p style="margin-left:11%;">getElementsByTagName
($optional_condition)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;descendants&quot;</tt></p>

<p style="margin-left:11%;">find_by_tag_name
($optional_condition)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;descendants&quot;</tt></p>

<p style="margin-left:11%;">descendants_or_self
($optional_condition)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;descendants&quot;</tt> except that the element
itself is included in the list if it matches the
<tt>$optional_condition</tt></p>

<p style="margin-left:11%;">first_descendant
($optional_condition)</p>

<p style="margin-left:17%;">Return the first descendant of
the element that matches the condition</p>

<p style="margin-left:11%;">last_descendant
($optional_condition)</p>

<p style="margin-left:17%;">Return the last descendant of
the element that matches the condition</p>

<p style="margin-left:11%;">ancestors
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of ancestors
(optionally matching <tt>$optional_condition</tt>) of the
element. The list is ordered from the innermost ancestor to
the outermost one</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the element itself is not part of the list, in order to
include it you will have to use ancestors_or_self</p>

<p style="margin-left:11%;">ancestors_or_self
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of ancestors
(optionally matching <tt>$optional_condition</tt>) of the
element, including the element (if it matches the
condition&gt;). The list is ordered from the innermost
ancestor to the outermost one</p>

<p style="margin-left:11%;">passes ($condition)</p>

<p style="margin-left:17%;">Return the element if it passes
the <tt>$condition</tt></p>

<p style="margin-left:11%;">att ($att)</p>

<p style="margin-left:17%;">Return the value of attribute
<tt>$att</tt> or <tt>&quot;undef&quot;</tt></p>

<p style="margin-left:11%;">latt ($att)</p>

<p style="margin-left:17%;">Return the value of attribute
<tt>$att</tt> or <tt>&quot;undef&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">this method is
an lvalue, so you can do <tt>&quot;$elt&minus;&gt;latt(
'foo')= 'bar'&quot;</tt> or <tt>&quot;$elt&minus;&gt;latt(
'foo')++;&quot;</tt></p>

<p style="margin-left:11%;">set_att ($att, $att_value)</p>

<p style="margin-left:17%;">Set the attribute of the
element to the given value</p>

<p style="margin-left:17%; margin-top: 1em">You can
actually set several attributes this way:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;set_att( att1 =&gt; &quot;val1&quot;, att2 =&gt; &quot;val2&quot;);</pre>


<p style="margin-left:11%;">del_att ($att)</p>

<p style="margin-left:17%;">Delete the attribute for the
element</p>

<p style="margin-left:17%; margin-top: 1em">You can
actually delete several attributes at once:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;del_att( 'att1', 'att2', 'att3');</pre>


<p style="margin-left:11%;">att_exists ($att)</p>

<p style="margin-left:17%;">Returns true if the attribute
<tt>$att</tt> exists for the element, false otherwise</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>cut</p></td>
<td width="2%"></td>
<td width="83%">


<p>Cut the element from the tree. The element still exists,
it can be copied or pasted somewhere else, it is just not
attached to the tree anymore.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note that the
&quot;old&quot; links to the parent, previous and next
siblings can still be accessed using the former_*
methods</p>

<p style="margin-left:11%;">former_next_sibling</p>

<p style="margin-left:17%;">Returns the former next sibling
of a cut node (or undef if the node has not been cut)</p>

<p style="margin-left:17%; margin-top: 1em">This makes it
easier to write loops where you cut elements:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $child= $parent&minus;&gt;first_child( 'achild');
    while( $child&minus;&gt;{'att'}&minus;&gt;{'cut'})
      { $child&minus;&gt;cut; $child= ($child&minus;&gt;{former} &amp;&amp; $child&minus;&gt;{former}&minus;&gt;{next_sibling}); }</pre>


<p style="margin-left:11%;">former_prev_sibling</p>

<p style="margin-left:17%;">Returns the former previous
sibling of a cut node (or undef if the node has not been
cut)</p>

<p style="margin-left:11%;">former_parent</p>

<p style="margin-left:17%;">Returns the former parent of a
cut node (or undef if the node has not been cut)</p>

<p style="margin-left:11%;">cut_children
($optional_condition)</p>

<p style="margin-left:17%;">Cut all the children of the
element (or all of those which satisfy the
<tt>$optional_condition</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Return the list
of children</p>

<p style="margin-left:11%;">cut_descendants
($optional_condition)</p>

<p style="margin-left:17%;">Cut all the descendants of the
element (or all of those which satisfy the
<tt>$optional_condition</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Return the list
of descendants</p>

<p style="margin-left:11%;">copy ($elt)</p>

<p style="margin-left:17%;">Return a copy of the element.
The copy is a &quot;deep&quot; copy: all sub-elements of the
element are duplicated.</p>

<p style="margin-left:11%;">paste ($optional_position,
$ref)</p>

<p style="margin-left:17%;">Paste a (previously
<tt>&quot;cut&quot;</tt> or newly generated) element. Die if
the element already belongs to a tree.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
calling element is pasted:</p>

<pre style="margin-left:17%; margin-top: 1em">  $child&minus;&gt;paste( first_child =&gt; $existing_parent);
  $new_sibling&minus;&gt;paste( after =&gt; $this_sibling_is_already_in_the_tree);</pre>


<p style="margin-left:17%; margin-top: 1em">or</p>

<pre style="margin-left:17%; margin-top: 1em">  my $new_elt= XML::Twig::Elt&minus;&gt;new( tag =&gt; $content);
  $new_elt&minus;&gt;paste( $position =&gt; $existing_elt);</pre>


<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $t= XML::Twig&minus;&gt;new&minus;&gt;parse( 'doc.xml')
  my $toc= $t&minus;&gt;root&minus;&gt;new( 'toc');
  $toc&minus;&gt;paste( $t&minus;&gt;root); # $toc is pasted as first child of the root
  foreach my $title ($t&minus;&gt;findnodes( '/doc/section/title'))
    { my $title_toc= $title&minus;&gt;copy;
      # paste $title_toc as the last child of toc
      $title_toc&minus;&gt;paste( last_child =&gt; $toc)
    }</pre>


<p style="margin-left:17%; margin-top: 1em">Position
options: <br>
first_child (default)</p>

<p style="margin-left:23%;">The element is pasted as the
first child of <tt>$ref</tt></p>

<p style="margin-left:17%;">last_child</p>

<p style="margin-left:23%;">The element is pasted as the
last child of <tt>$ref</tt></p>

<p style="margin-left:17%;">before</p>

<p style="margin-left:23%;">The element is pasted before
<tt>$ref</tt>, as its previous sibling.</p>

<p style="margin-left:17%;">after</p>

<p style="margin-left:23%;">The element is pasted after
<tt>$ref</tt>, as its next sibling.</p>

<p style="margin-left:17%;">within</p>

<p style="margin-left:23%;">In this case an extra argument,
<tt>$offset</tt>, should be supplied. The element will be
pasted in the reference element (or in its first text child)
at the given offset. To achieve this the reference element
will be split at the offset.</p>

<p style="margin-left:17%; margin-top: 1em">Note that you
can call directly the underlying method: <br>
paste_before <br>
paste_after <br>
paste_first_child <br>
paste_last_child <br>
paste_within</p>

<p style="margin-left:11%;">move ($optional_position,
$ref)</p>

<p style="margin-left:17%;">Move an element in the tree.
This is just a <tt>&quot;cut&quot;</tt> then a
<tt>&quot;paste&quot;</tt>. The syntax is the same as
<tt>&quot;paste&quot;</tt>.</p>

<p style="margin-left:11%;">replace ($ref)</p>

<p style="margin-left:17%;">Replaces an element in the
tree. Sometimes it is just not possible
to<tt>&quot;cut&quot;</tt> an element then
<tt>&quot;paste&quot;</tt> another in its place, so
<tt>&quot;replace&quot;</tt> comes in handy. The calling
element replaces <tt>$ref</tt>.</p>

<p style="margin-left:11%;">replace_with (@elts)</p>

<p style="margin-left:17%;">Replaces the calling element
with one or more elements</p>

<p style="margin-left:11%;">delete</p>

<p style="margin-left:17%;">Cut the element and frees the
memory.</p>

<p style="margin-left:11%;">prefix ($text,
$optional_option)</p>

<p style="margin-left:17%;">Add a prefix to an element. If
the element is a <tt>&quot;PCDATA&quot;</tt> element the
text is added to the pcdata, if the elements first child is
a <tt>&quot;PCDATA&quot;</tt> then the text is added to
it&rsquo;s pcdata, otherwise a new
<tt>&quot;PCDATA&quot;</tt> element is created and pasted as
the first child of the element.</p>

<p style="margin-left:17%; margin-top: 1em">If the option
is <tt>&quot;asis&quot;</tt> then the prefix is added asis:
it is created in a separate <tt>&quot;PCDATA&quot;</tt>
element with an <tt>&quot;asis&quot;</tt> property. You can
then write:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt1&minus;&gt;prefix( '&lt;b&gt;', 'asis');</pre>


<p style="margin-left:17%; margin-top: 1em">to create a
<tt>&quot;&lt;b&gt;&quot;</tt> in the output of
<tt>&quot;print&quot;</tt>.</p>

<p style="margin-left:11%;">suffix ($text,
$optional_option)</p>

<p style="margin-left:17%;">Add a suffix to an element. If
the element is a <tt>&quot;PCDATA&quot;</tt> element the
text is added to the pcdata, if the elements last child is a
<tt>&quot;PCDATA&quot;</tt> then the text is added to
it&rsquo;s pcdata, otherwise a new <small>PCDATA</small>
element is created and pasted as the last child of the
element.</p>

<p style="margin-left:17%; margin-top: 1em">If the option
is <tt>&quot;asis&quot;</tt> then the suffix is added asis:
it is created in a separate <tt>&quot;PCDATA&quot;</tt>
element with an <tt>&quot;asis&quot;</tt> property. You can
then write:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt2&minus;&gt;suffix( '&lt;/b&gt;', 'asis');</pre>


<p style="margin-left:11%;">trim</p>

<p style="margin-left:17%;">Trim the element in-place:
spaces at the beginning and at the end of the element are
discarded and multiple spaces within the element (or its
descendants) are replaced by a single space.</p>

<p style="margin-left:17%; margin-top: 1em">Note that in
some cases you can still end up with multiple spaces, if
they are split between several elements:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;doc&gt;  text &lt;b&gt;  hah! &lt;/b&gt;  yep&lt;/doc&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">gets trimmed
to</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;doc&gt;text &lt;b&gt; hah! &lt;/b&gt; yep&lt;/doc&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">This is
somewhere in between a bug and a feature.</p>

<p style="margin-left:11%;">normalize</p>

<p style="margin-left:17%;">merge together all consecutive
pcdata elements in the element (if for example you have
turned some elements into pcdata using
<tt>&quot;erase&quot;</tt>, this will give you a
&quot;clean&quot; element in which there all text fragments
are as long as possible).</p>

<p style="margin-left:11%;">simplify (%options)</p>

<p style="margin-left:17%;">Return a data structure
suspiciously similar to XML::Simple&rsquo;s. Options are
identical to XMLin options, see XML::Simple doc for more
details (or use DATA::dumper or <small>YAML</small> to dump
the data structure)</p>

<p style="margin-left:17%; margin-top: 1em"><b>Note</b>:
there is no magic here, if you write
<tt>&quot;$twig&minus;&gt;parsefile( $file
)&minus;&gt;simplify();&quot;</tt> then it will load the
entire document in memory. I am afraid you will have to put
some work into it to get just the bits you want and discard
the rest. Look at the synopsys or the XML::Twig 101 section
at the top of the docs for more information. <br>
content_key <br>
forcearray <br>
keyattr <br>
noattr <br>
normalize_space</p>

<p style="margin-left:23%;">aka normalise_space</p>

<p style="margin-left:17%;">variables (%var_hash)</p>

<p style="margin-left:23%;"><tt>%var_hash</tt> is a hash {
name =&gt; value }</p>

<p style="margin-left:23%; margin-top: 1em">This option
allows variables in the <small>XML</small> to be expanded
when the file is read. (there is no facility for putting the
variable names back if you regenerate <small>XML</small>
using XMLout).</p>

<p style="margin-left:23%; margin-top: 1em">A
&rsquo;variable&rsquo; is any text of the form ${name} (or
<tt>$name</tt>) which occurs in an attribute value or in the
text content of an element. If &rsquo;name&rsquo; matches a
key in the supplied hashref, ${name} will be replaced with
the corresponding value from the hashref. If no matching key
is found, the variable will not be replaced.</p>

<p style="margin-left:17%;">var_att ($attribute_name)</p>

<p style="margin-left:23%;">This option gives the name of
an attribute that will be used to create variables in the
<small>XML:</small></p>

<pre style="margin-left:23%; margin-top: 1em">  &lt;dirs&gt;
    &lt;dir name=&quot;prefix&quot;&gt;/usr/local&lt;/dir&gt;
    &lt;dir name=&quot;exec_prefix&quot;&gt;$prefix/bin&lt;/dir&gt;
  &lt;/dirs&gt;</pre>


<p style="margin-left:23%; margin-top: 1em">use
<tt>&quot;var =&gt; 'name'&quot;</tt> to get
<tt>$prefix</tt> replaced by /usr/local in the generated
data structure</p>

<p style="margin-left:23%; margin-top: 1em">By default
variables are captured by the following regexp: /$(\w+)/</p>

<p style="margin-left:17%;">var_regexp (regexp)</p>

<p style="margin-left:23%;">This option changes the regexp
used to capture variables. The variable name should be in
<tt>$1</tt></p>

<p style="margin-left:17%;">group_tags { grouping tag =&gt;
grouped tag, grouping tag 2 =&gt; grouped <br>
tag 2...}</p>

<p style="margin-left:23%;">Option used to simplify the
structure: elements listed will not be used. Their children
will be, they will be considered children of the element
parent.</p>

<p style="margin-left:23%; margin-top: 1em">If the element
is:</p>

<pre style="margin-left:23%; margin-top: 1em">  &lt;config host=&quot;laptop.xmltwig.org&quot;&gt;
    &lt;server&gt;localhost&lt;/server&gt;
    &lt;dirs&gt;
      &lt;dir name=&quot;base&quot;&gt;/home/mrodrigu/standards&lt;/dir&gt;
      &lt;dir name=&quot;tools&quot;&gt;$base/tools&lt;/dir&gt;
    &lt;/dirs&gt;
    &lt;templates&gt;
      &lt;template name=&quot;std_def&quot;&gt;std_def.templ&lt;/template&gt;
      &lt;template name=&quot;dummy&quot;&gt;dummy&lt;/template&gt;
    &lt;/templates&gt;
  &lt;/config&gt;</pre>


<p style="margin-left:23%; margin-top: 1em">Then calling
simplify with <tt>&quot;group_tags =&gt; { dirs =&gt; 'dir',
templates =&gt; 'template'}&quot;</tt> makes the data
structure be exactly as if the start and end tags for
<tt>&quot;dirs&quot;</tt> and <tt>&quot;templates&quot;</tt>
were not there.</p>

<p style="margin-left:23%; margin-top: 1em">A
<small>YAML</small> dump of the structure</p>

<pre style="margin-left:23%; margin-top: 1em">  base: '/home/mrodrigu/standards'
  host: laptop.xmltwig.org
  server: localhost
  template:
    &minus; std_def.templ
    &minus; dummy.templ
  tools: '$base/tools'</pre>


<p style="margin-left:11%;">split_at ($offset)</p>

<p style="margin-left:17%;">Split a text
(<tt>&quot;PCDATA&quot;</tt> or <tt>&quot;CDATA&quot;</tt>)
element in 2 at <tt>$offset</tt>, the original element now
holds the first part of the string and a new element holds
the right part. The new element is returned</p>

<p style="margin-left:17%; margin-top: 1em">If the element
is not a text element then the first text child of the
element is split</p>

<p style="margin-left:11%;">split ( $optional_regexp,
$tag1, $atts1, $tag2, $atts2...)</p>

<p style="margin-left:17%;">Split the text descendants of
an element in place, the text is split using the
<tt>$regexp</tt>, if the regexp includes () then the matched
separators will be wrapped in elements. <tt>$1</tt> is
wrapped in <tt>$tag1</tt>, with attributes <tt>$atts1</tt>
if <tt>$atts1</tt> is given (as a hashref), <tt>$2</tt> is
wrapped in <tt>$tag2</tt>...</p>

<p style="margin-left:17%; margin-top: 1em">if
<tt>$elt</tt> is <tt>&quot;&lt;p&gt;tati tata &lt;b&gt;tutu
tati titi&lt;/b&gt; tata tati tata&lt;/p&gt;&quot;</tt></p>


<p style="margin-left:17%; margin-top: 1em"><tt>$elt&minus;&gt;split(
qr/(ta)ti/, 'foo', {type =&gt; 'toto'} )</tt></p>

<p style="margin-left:17%; margin-top: 1em">will change
<tt>$elt</tt> to</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;p&gt;&lt;foo type=&quot;toto&quot;&gt;ta&lt;/foo&gt; tata &lt;b&gt;tutu &lt;foo type=&quot;toto&quot;&gt;ta&lt;/foo&gt;
      titi&lt;/b&gt; tata &lt;foo type=&quot;toto&quot;&gt;ta&lt;/foo&gt; tata&lt;/p&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">The regexp can
be passed either as a string or as <tt>&quot;qr//&quot;</tt>
(perl 5.005 and later), it defaults to \s+ just as the
<tt>&quot;split&quot;</tt> built-in (but this would be quite
a useless behaviour without the <tt>$optional_tag</tt>
parameter)</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$optional_tag</tt>
defaults to <small>PCDATA</small> or <small>CDATA,</small>
depending on the initial element type</p>

<p style="margin-left:17%; margin-top: 1em">The list of
descendants is returned (including un-touched original
elements and newly created ones)</p>

<p style="margin-left:11%;">mark ( $regexp, $optional_tag,
$optional_attribute_ref)</p>

<p style="margin-left:17%;">This method behaves exactly as
split, except only the newly created elements are
returned</p>

<p style="margin-left:11%;">wrap_children ( $regexp_string,
$tag, $optional_attribute_hashref)</p>

<p style="margin-left:17%;">Wrap the children of the
element that match the regexp in an element <tt>$tag</tt>.
If <tt>$optional_attribute_hashref</tt> is passed then the
new element will have these attributes.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$regexp_string</tt> includes tags, within pointy
brackets, as in
<tt>&quot;&lt;title&gt;&lt;para&gt;+&quot;</tt> and the
usual Perl modifiers (+*?...). Tags can be further qualified
with attributes: <tt>&quot;&lt;para type=&quot;warning&quot;
classif=&quot;cosmic_secret&quot;&gt;+&quot;</tt>. The
values for attributes should be xml-escaped:
<tt>&quot;&lt;candy
type=&quot;M&amp;amp;Ms&quot;&gt;*&quot;</tt>
(<tt>&quot;&lt;&quot;</tt>, <tt>&quot;&amp;&quot;</tt>
<b>&quot;&gt;&quot;</b> and <tt>&quot;&quot;&quot;</tt>
should be escaped).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
elements might get extra <tt>&quot;id&quot;</tt> attributes
in the process. See add_id. Use strip_att to remove unwanted
id&rsquo;s.</p>

<p style="margin-left:17%; margin-top: 1em">Here is an
example:</p>

<p style="margin-left:17%; margin-top: 1em">If the element
<tt>$elt</tt> has the following content:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;elt&gt;
   &lt;p&gt;para 1&lt;/p&gt;
   &lt;l_l1_1&gt;list 1 item 1 para 1&lt;/l_l1_1&gt;
     &lt;l_l1&gt;list 1 item 1 para 2&lt;/l_l1&gt;
   &lt;l_l1_n&gt;list 1 item 2 para 1 (only para)&lt;/l_l1_n&gt;
   &lt;l_l1_n&gt;list 1 item 3 para 1&lt;/l_l1_n&gt;
     &lt;l_l1&gt;list 1 item 3 para 2&lt;/l_l1&gt;
     &lt;l_l1&gt;list 1 item 3 para 3&lt;/l_l1&gt;
   &lt;l_l1_1&gt;list 2 item 1 para 1&lt;/l_l1_1&gt;
     &lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt;
   &lt;l_l1_n&gt;list 2 item 2 para 1 (only para)&lt;/l_l1_n&gt;
   &lt;l_l1_n&gt;list 2 item 3 para 1&lt;/l_l1_n&gt;
     &lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt;
     &lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt;
  &lt;/elt&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">Then the
code</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;wrap_children( q{&lt;l_l1_1&gt;&lt;l_l1&gt;*} , li =&gt; { type =&gt; &quot;ul1&quot; });
  $elt&minus;&gt;wrap_children( q{&lt;l_l1_n&gt;&lt;l_l1&gt;*} , li =&gt; { type =&gt; &quot;ul&quot; });
  $elt&minus;&gt;wrap_children( q{&lt;li type=&quot;ul1&quot;&gt;&lt;li type=&quot;ul&quot;&gt;+}, &quot;ul&quot;);
  $elt&minus;&gt;strip_att( 'id');
  $elt&minus;&gt;strip_att( 'type');
  $elt&minus;&gt;print;</pre>


<p style="margin-left:17%; margin-top: 1em">will
output:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;elt&gt;
     &lt;p&gt;para 1&lt;/p&gt;
     &lt;ul&gt;
       &lt;li&gt;
         &lt;l_l1_1&gt;list 1 item 1 para 1&lt;/l_l1_1&gt;
         &lt;l_l1&gt;list 1 item 1 para 2&lt;/l_l1&gt;
       &lt;/li&gt;
       &lt;li&gt;
         &lt;l_l1_n&gt;list 1 item 2 para 1 (only para)&lt;/l_l1_n&gt;
       &lt;/li&gt;
       &lt;li&gt;
         &lt;l_l1_n&gt;list 1 item 3 para 1&lt;/l_l1_n&gt;
         &lt;l_l1&gt;list 1 item 3 para 2&lt;/l_l1&gt;
         &lt;l_l1&gt;list 1 item 3 para 3&lt;/l_l1&gt;
       &lt;/li&gt;
     &lt;/ul&gt;
     &lt;ul&gt;
       &lt;li&gt;
         &lt;l_l1_1&gt;list 2 item 1 para 1&lt;/l_l1_1&gt;
         &lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt;
       &lt;/li&gt;
       &lt;li&gt;
         &lt;l_l1_n&gt;list 2 item 2 para 1 (only para)&lt;/l_l1_n&gt;
       &lt;/li&gt;
       &lt;li&gt;
         &lt;l_l1_n&gt;list 2 item 3 para 1&lt;/l_l1_n&gt;
         &lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt;
         &lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt;
       &lt;/li&gt;
     &lt;/ul&gt;
  &lt;/elt&gt;</pre>


<p style="margin-left:11%;">subs_text ($regexp,
$replace)</p>

<p style="margin-left:17%;">subs_text does text
substitution, similar to perl&rsquo;s <tt>&quot;
s///&quot;</tt> operator.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$regexp</tt>
must be a perl regexp, created with the
<tt>&quot;qr&quot;</tt> operator.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$replace</tt>
can include <tt>&quot;$1, $2&quot;</tt>... from the
<tt>$regexp</tt>. It can also be used to create element and
entities, by using <tt>&quot;&amp;elt( tag =&gt; { att =&gt;
val }, text)&quot;</tt> (similar syntax as
<tt>&quot;new&quot;</tt>) and <tt>&quot;&amp;ent(
name)&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Here is a
rather complex example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;subs_text( qr{(?&lt;!do not )link to (http://([^\s,]*))},
                   'see &amp;elt( a =&gt;{ href =&gt; $1 }, $2)'
                 );</pre>


<p style="margin-left:17%; margin-top: 1em">This will
replace text like <i>link to http://www.xmltwig.org</i> by
<i>see &lt;a
href=&quot;www.xmltwig.org&quot;&gt;www.xmltwig.org&lt;/a&gt;</i>,
but not <i>do not link to...</i></p>

<p style="margin-left:17%; margin-top: 1em">Generating
entities (here replacing spaces with &amp;nbsp;):</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;subs_text( qr{ }, '&amp;ent( &quot;&amp;nbsp;&quot;)');</pre>


<p style="margin-left:17%; margin-top: 1em">or, using a
variable:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $ent=&quot;&amp;nbsp;&quot;;
  $elt&minus;&gt;subs_text( qr{ }, &quot;&amp;ent( '$ent')&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">Note that the
substitution is always global, as in using the
<tt>&quot;g&quot;</tt> modifier in a perl substitution, and
that it is performed on all text descendants of the
element.</p>

<p style="margin-left:17%; margin-top: 1em"><b>Bug</b>: in
the <tt>$regexp</tt>, you can only use
<tt>&quot;\1&quot;</tt>, <tt>&quot;\2&quot;</tt>... if the
replacement expression does not include elements or
attributes. eg</p>

<pre style="margin-left:17%; margin-top: 1em">  $t&minus;&gt;subs_text( qr/((t[aiou])\2)/, '$2');             # ok, replaces toto, tata, titi, tutu by to, ta, ti, tu
  $t&minus;&gt;subs_text( qr/((t[aiou])\2)/, '&amp;elt(p =&gt; $1)' ); # NOK, does not find toto...</pre>


<p style="margin-left:11%;">add_id ($optional_coderef)</p>

<p style="margin-left:17%;">Add an id to the element.</p>

<p style="margin-left:17%; margin-top: 1em">The id is an
attribute, <tt>&quot;id&quot;</tt> by default, see the
<tt>&quot;id&quot;</tt> option for XML::Twig
<tt>&quot;new&quot;</tt> to change it. Use an id starting
with <tt>&quot;#&quot;</tt> to get an id that&rsquo;s not
output by print, flush or sprint, yet that allows you to use
the elt_id method to get the element easily.</p>

<p style="margin-left:17%; margin-top: 1em">If the element
already has an id, no new id is generated.</p>

<p style="margin-left:17%; margin-top: 1em">By default the
method create an id of the form
<tt>&quot;twig_id_&lt;nnnn&gt;&quot;</tt>, where
<tt>&quot;&lt;nnnn&gt;&quot;</tt> is a number, incremented
each time the method is called successfully.</p>

<p style="margin-left:11%;">set_id_seed ($prefix)</p>

<p style="margin-left:17%;">by default the id generated by
<tt>&quot;add_id&quot;</tt> is
<tt>&quot;twig_id_&lt;nnnn&gt;&quot;</tt>,
<tt>&quot;set_id_seed&quot;</tt> changes the prefix to
<tt>$prefix</tt> and resets the number to 1</p>

<p style="margin-left:11%;">strip_att ($att)</p>

<p style="margin-left:17%;">Remove the attribute
<tt>$att</tt> from all descendants of the element (including
the element)</p>

<p style="margin-left:17%; margin-top: 1em">Return the
element</p>

<p style="margin-left:11%;">change_att_name ($old_name,
$new_name)</p>

<p style="margin-left:17%;">Change the name of the
attribute from <tt>$old_name</tt> to <tt>$new_name</tt>. If
there is no attribute <tt>$old_name</tt> nothing
happens.</p>

<p style="margin-left:11%;">lc_attnames</p>

<p style="margin-left:17%;">Lower cases the name all the
attributes of the element.</p>

<p style="margin-left:11%;">sort_children_on_value(
%options)</p>

<p style="margin-left:17%;">Sort the children of the
element in place according to their text. All children are
sorted.</p>

<p style="margin-left:17%; margin-top: 1em">Return the
element, with its children sorted.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>%options</tt>
are</p>

<pre style="margin-left:17%; margin-top: 1em">  type  : numeric |  alpha     (default: alpha)
  order : normal  |  reverse   (default: normal)</pre>


<p style="margin-left:17%; margin-top: 1em">Return the
element, with its children sorted</p>

<p style="margin-left:11%;">sort_children_on_att ($att,
%options)</p>

<p style="margin-left:17%;">Sort the children of the
element in place according to attribute <tt>$att</tt>.
<tt>%options</tt> are the same as for
<tt>&quot;sort_children_on_value&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">Return the
element.</p>

<p style="margin-left:11%;">sort_children_on_field ($tag,
%options)</p>

<p style="margin-left:17%;">Sort the children of the
element in place, according to the field <tt>$tag</tt> (the
text of the first child of the child with this tag).
<tt>%options</tt> are the same as for
<tt>&quot;sort_children_on_value&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Return the
element, with its children sorted</p>

<p style="margin-left:11%;">sort_children( $get_key,
%options)</p>

<p style="margin-left:17%;">Sort the children of the
element in place. The <tt>$get_key</tt> argument is a
reference to a function that returns the sort key when
passed an element.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;sort_children( sub { $_[0]&minus;&gt;{'att'}&minus;&gt;{&quot;nb&quot;} + $_[0]&minus;&gt;text },
                       type =&gt; 'numeric', order =&gt; 'reverse'
                     );</pre>


<p style="margin-left:11%;">field_to_att ($cond, $att)</p>

<p style="margin-left:17%;">Turn the text of the first
sub-element matched by <tt>$cond</tt> into the value of
attribute <tt>$att</tt> of the element. If <tt>$att</tt> is
omitted then <tt>$cond</tt> is used as the name of the
attribute, which makes sense only if <tt>$cond</tt> is a
valid element (and attribute) name.</p>

<p style="margin-left:17%; margin-top: 1em">The sub-element
is then cut.</p>

<p style="margin-left:11%;">att_to_field ($att, $tag)</p>

<p style="margin-left:17%;">Take the value of attribute
<tt>$att</tt> and create a sub-element <tt>$tag</tt> as
first child of the element. If <tt>$tag</tt> is omitted then
<tt>$att</tt> is used as the name of the sub-element.</p>

<p style="margin-left:11%;">get_xpath ($xpath,
$optional_offset)</p>

<p style="margin-left:17%;">Return a list of elements
satisfying the <tt>$xpath</tt>. <tt>$xpath</tt> is an
XPATH-like expression.</p>

<p style="margin-left:17%; margin-top: 1em">A subset of the
<small>XPATH</small> abbreviated syntax is covered:</p>

<pre style="margin-left:17%; margin-top: 1em">  tag
  tag[1] (or any other positive number)
  tag[last()]
  tag[@att] (the attribute exists for the element)
  tag[@att=&quot;val&quot;]
  tag[@att=~ /regexp/]
  tag[att1=&quot;val1&quot; and att2=&quot;val2&quot;]
  tag[att1=&quot;val1&quot; or att2=&quot;val2&quot;]
  tag[string()=&quot;toto&quot;] (returns tag elements which text (as per the text method)
                       is toto)
  tag[string()=~/regexp/] (returns tag elements which text (as per the text
                          method) matches regexp)
  expressions can start with / (search starts at the document root)
  expressions can start with . (search starts at the current element)
  // can be used to get all descendants instead of just direct children
  * matches any tag</pre>


<p style="margin-left:17%; margin-top: 1em">So the
following examples from the <i>XPath
recommendation&lt;http://www.w3.org/TR/xpath.html#path&minus;abbrev&gt;</i>
work:</p>

<pre style="margin-left:17%; margin-top: 1em">  para selects the para element children of the context node
  * selects all element children of the context node
  para[1] selects the first para child of the context node
  para[last()] selects the last para child of the context node
  */para selects all para grandchildren of the context node
  /doc/chapter[5]/section[2] selects the second section of the fifth chapter
     of the doc
  chapter//para selects the para element descendants of the chapter element
     children of the context node
  //para selects all the para descendants of the document root and thus selects
     all para elements in the same document as the context node
  //olist/item selects all the item elements in the same document as the
     context node that have an olist parent
  .//para selects the para element descendants of the context node
  .. selects the parent of the context node
  para[@type=&quot;warning&quot;] selects all para children of the context node that have
     a type attribute with value warning
  employee[@secretary and @assistant] selects all the employee children of the
     context node that have both a secretary attribute and an assistant
     attribute</pre>


<p style="margin-left:17%; margin-top: 1em">The elements
will be returned in the document order.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$optional_offset</tt> is used then only one element will
be returned, the one with the appropriate offset in the
list, starting at 0</p>

<p style="margin-left:17%; margin-top: 1em">Quoting and
interpolating variables can be a pain when the Perl syntax
and the <small>XPATH</small> syntax collide, so use
alternate quoting mechanisms like q or qq (I like q{} and
qq{} myself).</p>

<p style="margin-left:17%; margin-top: 1em">Here are some
more examples to get you started:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $p1= &quot;p1&quot;;
  my $p2= &quot;p2&quot;;
  my @res= $t&minus;&gt;get_xpath( qq{p[string( &quot;$p1&quot;) or string( &quot;$p2&quot;)]});
  my $a= &quot;a1&quot;;
  my @res= $t&minus;&gt;get_xpath( qq{//*[@att=&quot;$a&quot;]});
  my $val= &quot;a1&quot;;
  my $exp= qq{//p[ \@att='$val']}; # you need to use \@ or you will get a warning
  my @res= $t&minus;&gt;get_xpath( $exp);</pre>


<p style="margin-left:17%; margin-top: 1em">Note that the
only supported regexps delimiters are / and that you must
backslash all / in regexps <small>AND</small> in regular
strings.</p>

<p style="margin-left:17%; margin-top: 1em">XML::Twig does
not provide natively full <small>XPATH</small> support, but
you can use <tt>&quot;XML::Twig::XPath&quot;</tt> to get
<tt>&quot;findnodes&quot;</tt> to use
<tt>&quot;XML::XPath&quot;</tt> as the XPath engine, with
full coverage of the spec.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;XML::Twig::XPath&quot;</tt>
to get <tt>&quot;findnodes&quot;</tt> to use
<tt>&quot;XML::XPath&quot;</tt> as the XPath engine, with
full coverage of the spec.</p>

<p style="margin-left:11%;">find_nodes</p>

<p style="margin-left:17%;">same
as<tt>&quot;get_xpath&quot;</tt></p>

<p style="margin-left:11%;">findnodes</p>

<p style="margin-left:17%;">same as
<tt>&quot;get_xpath&quot;</tt></p>

<p style="margin-left:11%;">text @optional_options</p>

<p style="margin-left:17%;">Return a string consisting of
all the <tt>&quot;PCDATA&quot;</tt> and
<tt>&quot;CDATA&quot;</tt> in an element, without any tags.
The text is not XML-escaped: base entities such as
<tt>&quot;&amp;&quot;</tt> and <tt>&quot;&lt;&quot;</tt> are
not escaped.</p>

<p style="margin-left:17%; margin-top: 1em">The
&rsquo;<tt>&quot;no_recurse&quot;</tt>&rsquo; option will
only return the text of the element, not of any included
sub-elements (same as <tt>&quot;text_only&quot;</tt>).</p>

<p style="margin-left:11%;">text_only</p>

<p style="margin-left:17%;">Same as
<tt>&quot;text&quot;</tt> except that the text returned
doesn&rsquo;t include the text of sub-elements.</p>

<p style="margin-left:11%;">trimmed_text</p>

<p style="margin-left:17%;">Same as
<tt>&quot;text&quot;</tt> except that the text is trimmed:
leading and trailing spaces are discarded, consecutive
spaces are collapsed</p>

<p style="margin-left:11%;">set_text ($string)</p>

<p style="margin-left:17%;">Set the text for the element:
if the element is a <tt>&quot;PCDATA&quot;</tt>, just set
its text, otherwise cut all the children of the element and
create a single <tt>&quot;PCDATA&quot;</tt> child for it,
which holds the text.</p>

<p style="margin-left:11%;">merge ($elt2)</p>

<p style="margin-left:17%;">Move the content of
<tt>$elt2</tt> within the element</p>

<p style="margin-left:11%;">insert ($tag1,
[$optional_atts1], $tag2, [$optional_atts2],...)</p>

<p style="margin-left:17%;">For each tag in the list
inserts an element <tt>$tag</tt> as the only child of the
element. The element gets the optional attributes
in<tt>&quot;$optional_atts&lt;n&gt;.&quot;</tt> All children
of the element are set as children of the new element. The
upper level element is returned.</p>

<pre style="margin-left:17%; margin-top: 1em">  $p&minus;&gt;insert( table =&gt; { border=&gt; 1}, 'tr', 'td')</pre>


<p style="margin-left:17%; margin-top: 1em">put <tt>$p</tt>
in a table with a visible border, a single
<tt>&quot;tr&quot;</tt> and a single <tt>&quot;td&quot;</tt>
and return the <tt>&quot;table&quot;</tt> element:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;p&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;original content of p&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;</pre>


<p style="margin-left:11%;">wrap_in (@tag)</p>

<p style="margin-left:17%;">Wrap elements in <tt>@tag</tt>
as the successive ancestors of the element, returns the new
element. <tt>&quot;$elt&minus;&gt;wrap_in( 'td', 'tr',
'table')&quot;</tt> wraps the element as a single cell in a
table for example.</p>

<p style="margin-left:17%; margin-top: 1em">Optionally each
tag can be followed by a hashref of attributes, that will be
set on the wrapping element:</p>

<pre style="margin-left:17%; margin-top: 1em">  $elt&minus;&gt;wrap_in( p =&gt; { class =&gt; &quot;advisory&quot; }, div =&gt; { class =&gt; &quot;intro&quot;, id =&gt; &quot;div_intro&quot; });</pre>


<p style="margin-left:11%;">insert_new_elt ($opt_position,
$tag, $opt_atts_hashref, @opt_content)</p>

<p style="margin-left:17%;">Combines a <tt>&quot;new
&quot;</tt> and a <tt>&quot;paste &quot;</tt>: creates a new
element using <tt>$tag</tt>, <tt>$opt_atts_hashref</tt> and
<tt>@opt_content</tt> which are arguments similar to those
for <tt>&quot;new&quot;</tt>, then paste it, using
<tt>$opt_position</tt> or <tt>'first_child'</tt>, relative
to <tt>$elt</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Return the
newly created element</p>

<p style="margin-left:11%;">erase</p>

<p style="margin-left:17%;">Erase the element: the element
is deleted and all of its children are pasted in its
place.</p>

<p style="margin-left:11%;">set_content ( $optional_atts,
@list_of_elt_and_strings) ( <br>
$optional_atts, &rsquo;#EMPTY&rsquo;)</p>

<p style="margin-left:17%;">Set the content for the
element, from a list of strings and elements. Cuts all the
element children, then pastes the list elements as the
children. This method will create a
<tt>&quot;PCDATA&quot;</tt> element for any strings in the
list.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$optional_atts</tt> argument is the ref of a hash of
attributes. If this argument is used then the previous
attributes are deleted, otherwise they are left
untouched.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: if you rely on <small>ID</small> &rsquo;s then you will
have to set the id yourself. At this point the element does
not belong to a twig yet, so the <small>ID</small> attribute
is not known so it won&rsquo;t be stored in the
<small>ID</small> list.</p>

<p style="margin-left:17%; margin-top: 1em">A content of
&rsquo;<tt>&quot;#EMPTY&quot;</tt>&rsquo; creates an empty
element;</p>

<p style="margin-left:11%;">namespace
($optional_prefix)</p>

<p style="margin-left:17%;">Return the <small>URI</small>
of the namespace that <tt>$optional_prefix</tt> or the
element name belongs to. If the name doesn&rsquo;t belong to
any namespace, <tt>&quot;undef&quot;</tt> is returned.</p>

<p style="margin-left:11%;">local_name</p>

<p style="margin-left:17%;">Return the local name (without
the prefix) for the element</p>

<p style="margin-left:11%;">ns_prefix</p>

<p style="margin-left:17%;">Return the namespace prefix for
the element</p>

<p style="margin-left:11%;">current_ns_prefixes</p>

<p style="margin-left:17%;">Return a list of namespace
prefixes valid for the element. The order of the prefixes in
the list has no meaning. If the default namespace is
currently bound, &rsquo;&rsquo; appears in the list.</p>

<p style="margin-left:11%;">inherit_att ($att,
@optional_tag_list)</p>

<p style="margin-left:17%;">Return the value of an
attribute inherited from parent tags. The value returned is
found by looking for the attribute in the element then in
turn in each of its ancestors. If the
<tt>@optional_tag_list</tt> is supplied only those ancestors
whose tag is in the list will be checked.</p>

<p style="margin-left:11%;">all_children_are
($optional_condition)</p>

<p style="margin-left:17%;">return 1 if all children of the
element pass the <tt>$optional_condition</tt>, 0
otherwise</p>

<p style="margin-left:11%;">level ($optional_condition)</p>

<p style="margin-left:17%;">Return the depth of the element
in the twig (root is 0). If <tt>$optional_condition</tt> is
given then only ancestors that match the condition are
counted.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: in a tree created using the
<tt>&quot;twig_roots&quot;</tt> option this will not return
the level in the document tree, level 0 will be the document
root, level 1 will be the <tt>&quot;twig_roots&quot;</tt>
elements. During the parsing (in a
<tt>&quot;twig_handler&quot;</tt>) you can use the
<tt>&quot;depth&quot;</tt> method on the twig object to get
the real parsing depth.</p>

<p style="margin-left:11%;">in ($potential_parent)</p>

<p style="margin-left:17%;">Return true if the element is
in the potential_parent (<tt>$potential_parent</tt> is an
element)</p>

<p style="margin-left:11%;">in_context ($cond,
$optional_level)</p>

<p style="margin-left:17%;">Return true if the element is
included in an element which passes <tt>$cond</tt>
optionally within <tt>$optional_level</tt> levels. The
returned value is the including element.</p>

<p style="margin-left:11%;">pcdata</p>

<p style="margin-left:17%;">Return the text of a
<tt>&quot;PCDATA&quot;</tt> element or
<tt>&quot;undef&quot;</tt> if the element is not
<tt>&quot;PCDATA&quot;</tt>.</p>

<p style="margin-left:11%;">pcdata_xml_string</p>

<p style="margin-left:17%;">Return the text of a
<tt>&quot;PCDATA&quot;</tt> element or undef if the element
is not <tt>&quot;PCDATA&quot;</tt>. The text is
&quot;XML-escaped&quot; (&rsquo;&amp;&rsquo; and
&rsquo;&lt;&rsquo; are replaced by &rsquo;&amp;amp;&rsquo;
and &rsquo;&amp;lt;&rsquo;)</p>

<p style="margin-left:11%;">set_pcdata ($text)</p>

<p style="margin-left:17%;">Set the text of a
<tt>&quot;PCDATA&quot;</tt> element. This method does not
check that the element is indeed a
<tt>&quot;PCDATA&quot;</tt> so usually you should use
<tt>&quot;set_text&quot;</tt> instead.</p>

<p style="margin-left:11%;">append_pcdata ($text)</p>

<p style="margin-left:17%;">Add the text at the end of a
<tt>&quot;PCDATA&quot;</tt> element.</p>

<p style="margin-left:11%;">is_cdata</p>

<p style="margin-left:17%;">Return 1 if the element is a
<tt>&quot;CDATA&quot;</tt> element, returns 0 otherwise.</p>

<p style="margin-left:11%;">is_text</p>

<p style="margin-left:17%;">Return 1 if the element is a
<tt>&quot;CDATA&quot;</tt> or <tt>&quot;PCDATA&quot;</tt>
element, returns 0 otherwise.</p>

<p style="margin-left:11%;">cdata</p>

<p style="margin-left:17%;">Return the text of a
<tt>&quot;CDATA&quot;</tt> element or
<tt>&quot;undef&quot;</tt> if the element is not
<tt>&quot;CDATA&quot;</tt>.</p>

<p style="margin-left:11%;">cdata_string</p>

<p style="margin-left:17%;">Return the <small>XML</small>
string of a <tt>&quot;CDATA&quot;</tt> element, including
the opening and closing markers.</p>

<p style="margin-left:11%;">set_cdata ($text)</p>

<p style="margin-left:17%;">Set the text of a
<tt>&quot;CDATA&quot;</tt> element.</p>

<p style="margin-left:11%;">append_cdata ($text)</p>

<p style="margin-left:17%;">Add the text at the end of a
<tt>&quot;CDATA&quot;</tt> element.</p>

<p style="margin-left:11%;">remove_cdata</p>

<p style="margin-left:17%;">Turns all
<tt>&quot;CDATA&quot;</tt> sections in the element into
regular <tt>&quot;PCDATA&quot;</tt> elements. This is useful
when converting <small>XML</small> to <small>HTML,</small>
as browsers do not support <small>CDATA</small>
sections.</p>

<p style="margin-left:11%;">extra_data</p>

<p style="margin-left:17%;">Return the extra_data (comments
and <small>PI</small> &rsquo;s) attached to an element</p>

<p style="margin-left:11%;">set_extra_data
($extra_data)</p>

<p style="margin-left:17%;">Set the extra_data (comments
and <small>PI</small> &rsquo;s) attached to an element</p>

<p style="margin-left:11%;">append_extra_data
($extra_data)</p>

<p style="margin-left:17%;">Append extra_data to the
existing extra_data before the element (if no previous
extra_data exists then it is created)</p>

<p style="margin-left:11%;">set_asis</p>

<p style="margin-left:17%;">Set a property of the element
that causes it to be output without being <small>XML</small>
escaped by the print functions: if it contains <tt>&quot;a
&lt; b&quot;</tt> it will be output as such and not as
<tt>&quot;a &amp;lt; b&quot;</tt>. This can be useful to
create text elements that will be output as markup. Note
that all <tt>&quot;PCDATA&quot;</tt> descendants of the
element are also marked as having the property (they are the
ones that are actually impacted by the change).</p>

<p style="margin-left:17%; margin-top: 1em">If the element
is a <tt>&quot;CDATA&quot;</tt> element it will also be
output asis, without the <tt>&quot;CDATA&quot;</tt> markers.
The same goes for any <tt>&quot;CDATA&quot;</tt> descendant
of the element</p>

<p style="margin-left:11%;">set_not_asis</p>

<p style="margin-left:17%;">Unsets the
<tt>&quot;asis&quot;</tt> property for the element and its
text descendants.</p>

<p style="margin-left:11%;">is_asis</p>

<p style="margin-left:17%;">Return the
<tt>&quot;asis&quot;</tt> property status of the element ( 1
or <tt>&quot;undef&quot;</tt>)</p>

<p style="margin-left:11%;">closed</p>

<p style="margin-left:17%;">Return true if the element has
been closed. Might be useful if you are somewhere in the
tree, during the parse, and have no idea whether a parent
element is completely loaded or not.</p>

<p style="margin-left:11%;">get_type</p>

<p style="margin-left:17%;">Return the type of the element:
&rsquo;<tt>&quot;#ELT&quot;</tt>&rsquo; for &quot;real&quot;
elements, or &rsquo;<tt>&quot;#PCDATA&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;#CDATA&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;#COMMENT&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;#ENT&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;#PI&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">is_elt</p>

<p style="margin-left:17%;">Return the tag if the element
is a &quot;real&quot; element, or 0 if it is
<tt>&quot;PCDATA&quot;</tt>,
<tt>&quot;CDATA&quot;</tt>...</p>

<p style="margin-left:11%;">contains_only_text</p>

<p style="margin-left:17%;">Return 1 if the element does
not contain any other &quot;real&quot; element</p>

<p style="margin-left:11%;">contains_only ($exp)</p>

<p style="margin-left:17%;">Return the list of children if
all children of the element match the expression
<tt>$exp</tt></p>

<p style="margin-left:17%; margin-top: 1em"><tt>if(
$para&minus;&gt;contains_only( 'tt')) { ... }</tt></p>

<p style="margin-left:11%;">contains_a_single ($exp)</p>

<p style="margin-left:17%;">If the element contains a
single child that matches the expression <tt>$exp</tt>
returns that element. Otherwise returns 0.</p>

<p style="margin-left:11%;">is_field</p>

<p style="margin-left:17%;">same as
<tt>&quot;contains_only_text&quot;</tt></p>

<p style="margin-left:11%;">is_pcdata</p>

<p style="margin-left:17%;">Return 1 if the element is a
<tt>&quot;PCDATA&quot;</tt> element, returns 0
otherwise.</p>

<p style="margin-left:11%;">is_ent</p>

<p style="margin-left:17%;">Return 1 if the element is an
entity (an unexpanded entity) element, return 0
otherwise.</p>

<p style="margin-left:11%;">is_empty</p>

<p style="margin-left:17%;">Return 1 if the element is
empty, 0 otherwise</p>

<p style="margin-left:11%;">set_empty</p>

<p style="margin-left:17%;">Flags the element as empty. No
further check is made, so if the element is actually not
empty the output will be messed. The only effect of this
method is that the output will be <tt>&quot;&lt;tag
att=&quot;value&quot;&quot;/&gt;&quot;</tt>.</p>

<p style="margin-left:11%;">set_not_empty</p>

<p style="margin-left:17%;">Flags the element as not empty.
if it is actually empty then the element will be output as
<tt>&quot;&lt;tag
att=&quot;value&quot;&quot;&gt;&lt;/tag&gt;&quot;</tt></p>

<p style="margin-left:11%;">is_pi</p>

<p style="margin-left:17%;">Return 1 if the element is a
processing instruction (<tt>&quot;#PI&quot;</tt>) element,
return 0 otherwise.</p>

<p style="margin-left:11%;">target</p>

<p style="margin-left:17%;">Return the target of a
processing instruction</p>

<p style="margin-left:11%;">set_target ($target)</p>

<p style="margin-left:17%;">Set the target of a processing
instruction</p>

<p style="margin-left:11%;">data</p>

<p style="margin-left:17%;">Return the data part of a
processing instruction</p>

<p style="margin-left:11%;">set_data ($data)</p>

<p style="margin-left:17%;">Set the data of a processing
instruction</p>

<p style="margin-left:11%;">set_pi ($target, $data)</p>

<p style="margin-left:17%;">Set the target and data of a
processing instruction</p>

<p style="margin-left:11%;">pi_string</p>

<p style="margin-left:17%;">Return the string form of a
processing instruction (<tt>&quot;&lt;?target
data?&gt;&quot;</tt>)</p>

<p style="margin-left:11%;">is_comment</p>

<p style="margin-left:17%;">Return 1 if the element is a
comment (<tt>&quot;#COMMENT&quot;</tt>) element, return 0
otherwise.</p>

<p style="margin-left:11%;">set_comment ($comment_text)</p>

<p style="margin-left:17%;">Set the text for a comment</p>

<p style="margin-left:11%;">comment</p>

<p style="margin-left:17%;">Return the content of a comment
(just the text, not the
<tt>&quot;&lt;!&minus;&minus;&quot;</tt> and
<tt>&quot;&minus;&minus;&gt;&quot;</tt>)</p>

<p style="margin-left:11%;">comment_string</p>

<p style="margin-left:17%;">Return the <small>XML</small>
string for a comment (<tt>&quot;&lt;!&minus;&minus; comment
&minus;&minus;&gt;&quot;</tt>)</p>

<p style="margin-left:17%; margin-top: 1em">Note that an
<small>XML</small> comment cannot start or end with a
&rsquo;&minus;&rsquo;, or include
&rsquo;&minus;&minus;&rsquo;
(http://www.w3.org/TR/2008/REC&minus;xml&minus;20081126/#sec&minus;comments),
if that is the case (because you have created the comment
yourself presumably, as it could not be in the input
<small>XML</small> ), then a space will be inserted before
an initial &rsquo;&minus;&rsquo;, after a trailing one or
between two &rsquo;&minus;&rsquo; in the comment (which
could presumably mangle javascript &quot;hidden&quot; in an
<small>XHTML</small> comment);</p>

<p style="margin-left:11%;">set_ent ($entity)</p>

<p style="margin-left:17%;">Set an (non-expanded) entity
(<tt>&quot;#ENT&quot;</tt>). <tt>$entity</tt>) is the entity
text (<tt>&quot;&amp;ent;&quot;</tt>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>ent</p></td>
<td width="2%"></td>
<td width="83%">


<p>Return the entity for an entity
(<tt>&quot;#ENT&quot;</tt>) element
(<tt>&quot;&amp;ent;&quot;</tt>)</p> </td></tr>
</table>

<p style="margin-left:11%;">ent_name</p>

<p style="margin-left:17%;">Return the entity name for an
entity (<tt>&quot;#ENT&quot;</tt>) element
(<tt>&quot;ent&quot;</tt>)</p>

<p style="margin-left:11%;">ent_string</p>

<p style="margin-left:17%;">Return the entity, either
expanded if the expanded version is available, or
non-expanded (<tt>&quot;&amp;ent;&quot;</tt>) otherwise</p>

<p style="margin-left:11%;">child ($offset,
$optional_condition)</p>

<p style="margin-left:17%;">Return the
<tt>$offset</tt>&minus;th child of the element, optionally
the <tt>$offset</tt>&minus;th child that matches
<tt>$optional_condition</tt>. The children are treated as a
list, so <tt>&quot;$elt&minus;&gt;child( 0)&quot;</tt> is
the first child, while <tt>&quot;$elt&minus;&gt;child(
&minus;1)&quot;</tt> is the last child.</p>

<p style="margin-left:11%;">child_text ($offset,
$optional_condition)</p>

<p style="margin-left:17%;">Return the text of a child or
<tt>&quot;undef&quot;</tt> if the sibling does not exist.
Arguments are the same as child.</p>

<p style="margin-left:11%;">last_child
($optional_condition)</p>

<p style="margin-left:17%;">Return the last child of the
element, or the last child matching
<tt>$optional_condition</tt> (ie the last of the element
children matching the condition).</p>

<p style="margin-left:11%;">last_child_text
($optional_condition)</p>

<p style="margin-left:17%;">Same as
<tt>&quot;first_child_text&quot;</tt> but for the last
child.</p>

<p style="margin-left:11%;">sibling ($offset,
$optional_condition)</p>

<p style="margin-left:17%;">Return the next or previous
<tt>$offset</tt>&minus;th sibling of the element, or the
<tt>$offset</tt>&minus;th one matching
<tt>$optional_condition</tt>. If <tt>$offset</tt> is
negative then a previous sibling is returned, if
<tt>$offset</tt> is positive then a next sibling is
returned. <tt>&quot;$offset=0&quot;</tt> returns the element
if there is no condition or if the element matches the
condition&gt;, <tt>&quot;undef&quot;</tt> otherwise.</p>

<p style="margin-left:11%;">sibling_text ($offset,
$optional_condition)</p>

<p style="margin-left:17%;">Return the text of a sibling or
<tt>&quot;undef&quot;</tt> if the sibling does not exist.
Arguments are the same as <tt>&quot;sibling&quot;</tt>.</p>

<p style="margin-left:11%;">prev_siblings
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of previous
siblings (optionally matching <tt>$optional_condition</tt>)
for the element. The elements are ordered in document
order.</p>

<p style="margin-left:11%;">next_siblings
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of siblings
(optionally matching <tt>$optional_condition</tt>) following
the element. The elements are ordered in document order.</p>

<p style="margin-left:11%;">siblings
($optional_condition)</p>

<p style="margin-left:17%;">Return the list of siblings
(optionally matching <tt>$optional_condition</tt>) of the
element (excluding the element itself). The elements are
ordered in document order.</p>

<p style="margin-left:11%;">pos ($optional_condition)</p>

<p style="margin-left:17%;">Return the position of the
element in the children list. The first child has a position
of 1 (as in XPath).</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>$optional_condition</tt> is given then only siblings
that match the condition are counted. If the element itself
does not match the condition then 0 is returned.</p>

<p style="margin-left:11%;">atts</p>

<p style="margin-left:17%;">Return a hash ref containing
the element attributes</p>

<p style="margin-left:11%;">set_atts ({ att1=&gt;$att1_val,
att2=&gt; $att2_val... })</p>

<p style="margin-left:17%;">Set the element attributes with
the hash ref supplied as the argument. The previous
attributes are lost (ie the attributes set by
<tt>&quot;set_atts&quot;</tt> replace all of the attributes
of the element).</p>

<p style="margin-left:17%; margin-top: 1em">You can also
pass a list instead of a hashref:
<tt>&quot;$elt&minus;&gt;set_atts( att1 =&gt;
'val1',...)&quot;</tt></p>

<p style="margin-left:11%;">del_atts</p>

<p style="margin-left:17%;">Deletes all the element
attributes.</p>

<p style="margin-left:11%;">att_nb</p>

<p style="margin-left:17%;">Return the number of attributes
for the element</p>

<p style="margin-left:11%;">has_atts</p>

<p style="margin-left:17%;">Return true if the element has
attributes (in fact return the number of attributes, thus
being an alias to <tt>&quot;att_nb&quot;</tt></p>

<p style="margin-left:11%;">has_no_atts</p>

<p style="margin-left:17%;">Return true if the element has
no attributes, false (0) otherwise</p>

<p style="margin-left:11%;">att_names</p>

<p style="margin-left:17%;">return a list of the attribute
names for the element</p>

<p style="margin-left:11%;">att_xml_string ($att,
$options)</p>

<p style="margin-left:17%;">Return the attribute value,
where &rsquo;&amp;&rsquo;, &rsquo;&lt;&rsquo; and quote
(&quot; or the value of the quote option at twig creation)
are XML-escaped.</p>

<p style="margin-left:17%; margin-top: 1em">The options are
passed as a hashref, setting <tt>&quot;escape_gt&quot;</tt>
to a true value will also escape &rsquo;&gt;&rsquo; ($elt(
&rsquo;myatt&rsquo;, { escape_gt =&gt; 1 });</p>

<p style="margin-left:11%;">set_id ($id)</p>

<p style="margin-left:17%;">Set the <tt>&quot;id&quot;</tt>
attribute of the element to the value. See <tt>&quot;elt_id
&quot;</tt> to change the id attribute name</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>id</p></td>
<td width="3%"></td>
<td width="41%">


<p>Gets the id attribute value</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%;">del_id ($id)</p>

<p style="margin-left:17%;">Deletes the
<tt>&quot;id&quot;</tt> attribute of the element and remove
it from the id list for the document</p>

<p style="margin-left:11%;">class</p>

<p style="margin-left:17%;">Return the
<tt>&quot;class&quot;</tt> attribute for the element
(methods on the <tt>&quot;class&quot;</tt> attribute are
quite convenient when dealing with <small>XHTML,</small> or
plain <small>XML</small> that will eventually be displayed
using <small>CSS</small> )</p>

<p style="margin-left:11%;">lclass</p>

<p style="margin-left:17%;">same as class, except that this
method is an lvalue, so you can do
<tt>&quot;$elt&minus;&gt;lclass=
&quot;foo&quot;&quot;</tt></p>

<p style="margin-left:11%;">set_class ($class)</p>

<p style="margin-left:17%;">Set the
<tt>&quot;class&quot;</tt> attribute for the element to
<tt>$class</tt></p>

<p style="margin-left:11%;">add_class ($class)</p>

<p style="margin-left:17%;">Add <tt>$class</tt> to the
element <tt>&quot;class&quot;</tt> attribute: the new class
is added only if it is not already present.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
classes are then sorted alphabetically, so the
<tt>&quot;class&quot;</tt> attribute can be changed even if
the class is already there</p>

<p style="margin-left:11%;">remove_class ($class)</p>

<p style="margin-left:17%;">Remove <tt>$class</tt> from the
element <tt>&quot;class&quot;</tt> attribute.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
classes are then sorted alphabetically, so the
<tt>&quot;class&quot;</tt> attribute can be changed even if
the class is already there</p>

<p style="margin-left:11%;">add_to_class ($class)</p>

<p style="margin-left:17%;">alias for add_class</p>

<p style="margin-left:11%;">att_to_class ($att)</p>

<p style="margin-left:17%;">Set the
<tt>&quot;class&quot;</tt> attribute to the value of
attribute <tt>$att</tt></p>

<p style="margin-left:11%;">add_att_to_class ($att)</p>

<p style="margin-left:17%;">Add the value of attribute
<tt>$att</tt> to the <tt>&quot;class&quot;</tt> attribute of
the element</p>

<p style="margin-left:11%;">move_att_to_class ($att)</p>

<p style="margin-left:17%;">Add the value of attribute
<tt>$att</tt> to the <tt>&quot;class&quot;</tt> attribute of
the element and delete the attribute</p>

<p style="margin-left:11%;">tag_to_class</p>

<p style="margin-left:17%;">Set the
<tt>&quot;class&quot;</tt> attribute of the element to the
element tag</p>

<p style="margin-left:11%;">add_tag_to_class</p>

<p style="margin-left:17%;">Add the element tag to its
<tt>&quot;class&quot;</tt> attribute</p>

<p style="margin-left:11%;">set_tag_class ($new_tag)</p>

<p style="margin-left:17%;">Add the element tag to its
<tt>&quot;class&quot;</tt> attribute and sets the tag to
<tt>$new_tag</tt></p>

<p style="margin-left:11%;">in_class ($class)</p>

<p style="margin-left:17%;">Return true (<tt>1</tt>) if the
element is in the class <tt>$class</tt> (if <tt>$class</tt>
is one of the tokens in the element
<tt>&quot;class&quot;</tt> attribute)</p>

<p style="margin-left:11%;">tag_to_span</p>

<p style="margin-left:17%;">Change the element tag tp
<tt>&quot;span&quot;</tt> and set its class to the old
tag</p>

<p style="margin-left:11%;">tag_to_div</p>

<p style="margin-left:17%;">Change the element tag tp
<tt>&quot;div&quot;</tt> and set its class to the old
tag</p>

<p style="margin-left:11%;"><small>DESTROY</small></p>

<p style="margin-left:17%;">Frees the element from
memory.</p>

<p style="margin-left:11%;">start_tag</p>

<p style="margin-left:17%;">Return the string for the start
tag for the element, including the
<tt>&quot;/&gt;&quot;</tt> at the end of an empty element
tag</p>

<p style="margin-left:11%;">end_tag</p>

<p style="margin-left:17%;">Return the string for the end
tag of an element. For an empty element, this returns the
empty string (&rsquo;&rsquo;).</p>

<p style="margin-left:11%;">xml_string
@optional_options</p>

<p style="margin-left:17%;">Equivalent to
<tt>&quot;$elt&minus;&gt;sprint( 1)&quot;</tt>, returns the
string for the entire element, excluding the element&rsquo;s
tags (but nested element tags are present)</p>

<p style="margin-left:17%; margin-top: 1em">The
&rsquo;<tt>&quot;no_recurse&quot;</tt>&rsquo; option will
only return the text of the element, not of any included
sub-elements (same as
<tt>&quot;xml_text_only&quot;</tt>).</p>

<p style="margin-left:11%;">inner_xml</p>

<p style="margin-left:17%;">Another synonym for
xml_string</p>

<p style="margin-left:11%;">outer_xml</p>

<p style="margin-left:17%;">An other synonym for sprint</p>

<p style="margin-left:11%;">xml_text</p>

<p style="margin-left:17%;">Return the text of the element,
encoded (and processed by the current
<tt>&quot;output_filter&quot;</tt> or
<tt>&quot;output_encoding&quot;</tt> options, without any
tag.</p>

<p style="margin-left:11%;">xml_text_only</p>

<p style="margin-left:17%;">Same as
<tt>&quot;xml_text&quot;</tt> except that the text returned
doesn&rsquo;t include the text of sub-elements.</p>

<p style="margin-left:11%;">set_pretty_print ($style)</p>

<p style="margin-left:17%;">Set the pretty print method,
amongst &rsquo;<tt>&quot;none&quot;</tt>&rsquo; (default),
&rsquo;<tt>&quot;nsgmls&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;nice&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;indented&quot;</tt>&rsquo;,
&rsquo;<tt>&quot;record&quot;</tt>&rsquo; and
&rsquo;<tt>&quot;record_c&quot;</tt>&rsquo;</p>

<p style="margin-left:17%; margin-top: 1em">pretty_print
styles: <br>
none</p>

<p style="margin-left:23%;">the default, no
<tt>&quot;\n&quot;</tt> is used</p>

<p style="margin-left:17%;">nsgmls</p>

<p style="margin-left:23%;">nsgmls style, with
<tt>&quot;\n&quot;</tt> added within tags</p>

<p style="margin-left:17%;">nice</p>

<p style="margin-left:23%;">adds <tt>&quot;\n&quot;</tt>
wherever possible ( <small>NOT SAFE,</small> can lead to
invalid <small>XML</small> )</p>

<p style="margin-left:17%;">indented</p>

<p style="margin-left:23%;">same as
<tt>&quot;nice&quot;</tt> plus indents elements ( <small>NOT
SAFE,</small> can lead to invalid <small>XML</small> )</p>

<p style="margin-left:17%;">record</p>

<p style="margin-left:23%;">table-oriented pretty print,
one field per line</p>

<p style="margin-left:17%;">record_c</p>

<p style="margin-left:23%;">table-oriented pretty print,
more compact than <tt>&quot;record&quot;</tt>, one record
per line</p>

<p style="margin-left:11%;">set_empty_tag_style
($style)</p>

<p style="margin-left:17%;">Set the method to output empty
tags, amongst &rsquo;<tt>&quot;normal&quot;</tt>&rsquo;
(default), &rsquo;<tt>&quot;html&quot;</tt>&rsquo;, and
&rsquo;<tt>&quot;expand&quot;</tt>&rsquo;,</p>


<p style="margin-left:17%; margin-top: 1em"><tt>&quot;normal&quot;</tt>
outputs an empty tag
&rsquo;<tt>&quot;&lt;tag/&gt;&quot;</tt>&rsquo;,
<tt>&quot;html&quot;</tt> adds a space
&rsquo;<tt>&quot;&lt;tag /&gt;&quot;</tt>&rsquo; for
elements that can be empty in <small>XHTML</small> and
<tt>&quot;expand&quot;</tt> outputs
&rsquo;<tt>&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">set_remove_cdata ($flag)</p>

<p style="margin-left:17%;">set (or unset) the flag that
forces the twig to output <small>CDATA</small> sections as
regular (escaped) <small>PCDATA</small></p>

<p style="margin-left:11%;">set_indent ($string)</p>

<p style="margin-left:17%;">Set the indentation for the
indented pretty print style (default is 2 spaces)</p>

<p style="margin-left:11%;">set_quote ($quote)</p>

<p style="margin-left:17%;">Set the quotes used for
attributes. can be &rsquo;<tt>&quot;double&quot;</tt>&rsquo;
(default) or &rsquo;<tt>&quot;single&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">cmp ($elt)</p>

<pre style="margin-left:17%;">  Compare the order of the 2 elements in a twig.
  C&lt;$a&gt; is the &lt;A&gt;..&lt;/A&gt; element, C&lt;$b&gt; is the &lt;B&gt;...&lt;/B&gt; element
  document                        $a&minus;&gt;cmp( $b)
  &lt;A&gt; ... &lt;/A&gt; ... &lt;B&gt;  ... &lt;/B&gt;     &minus;1
  &lt;A&gt; ... &lt;B&gt;  ... &lt;/B&gt; ... &lt;/A&gt;     &minus;1
  &lt;B&gt; ... &lt;/B&gt; ... &lt;A&gt;  ... &lt;/A&gt;      1
  &lt;B&gt; ... &lt;A&gt;  ... &lt;/A&gt; ... &lt;/B&gt;      1
   $a == $b                           0
   $a and $b not in the same tree   undef</pre>


<p style="margin-left:11%;">before ($elt)</p>

<p style="margin-left:17%;">Return 1 if <tt>$elt</tt>
starts before the element, 0 otherwise. If the 2 elements
are not in the same twig then return
<tt>&quot;undef&quot;</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">    if( $a&minus;&gt;cmp( $b) == &minus;1) { return 1; } else { return 0; }</pre>


<p style="margin-left:11%;">after ($elt)</p>

<p style="margin-left:17%;">Return 1 if <tt>$elt</tt>
starts after the element, 0 otherwise. If the 2 elements are
not in the same twig then return
<tt>&quot;undef&quot;</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">    if( $a&minus;&gt;cmp( $b) == &minus;1) { return 1; } else { return 0; }</pre>


<p style="margin-left:11%;">other comparison methods</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>lt</p></td>
<td width="80%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>le</p></td>
<td width="80%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>gt</p></td>
<td width="80%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>ge</p></td>
<td width="80%">
</td></tr>
</table>

<p style="margin-left:11%;">path</p>

<p style="margin-left:17%;">Return the element context in a
form similar to XPath&rsquo;s short form:
&rsquo;<tt>&quot;/root/tag1/../tag&quot;</tt>&rsquo;</p>

<p style="margin-left:11%;">xpath</p>

<p style="margin-left:17%;">Return a unique XPath
expression that can be used to find the element again.</p>

<p style="margin-left:17%; margin-top: 1em">It looks like
<tt>&quot;/doc/sect[3]/title&quot;</tt>: unique elements do
not have an index, the others do.</p>

<p style="margin-left:11%;">flush</p>

<p style="margin-left:17%;">flushes the twig up to the
current element (strictly equivalent to
<tt>&quot;$elt&minus;&gt;root&minus;&gt;flush&quot;</tt>)</p>

<p style="margin-left:11%;">private methods</p>

<p style="margin-left:17%;">Low-level methods on the twig:
<br>
set_parent ($parent) <br>
set_first_child ($first_child) <br>
set_last_child ($last_child) <br>
set_prev_sibling ($prev_sibling) <br>
set_next_sibling ($next_sibling) <br>
set_twig_current <br>
del_twig_current <br>
twig_current <br>
contains_text</p>

<p style="margin-left:17%; margin-top: 1em">Those methods
should not be used, unless of course you find some creative
and interesting, not to mention useful, ways to do it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>cond</b>
<br>
Most of the navigation functions accept a condition as an
optional argument The first element (or all elements for
<tt>&quot;children &quot;</tt> or <tt>&quot;ancestors
&quot;</tt>) that passes the condition is returned.</p>

<p style="margin-left:11%; margin-top: 1em">The condition
is a single step of an XPath expression using the XPath
subset defined by <tt>&quot;get_xpath&quot;</tt>. Additional
conditions are:</p>

<p style="margin-left:11%; margin-top: 1em">The condition
can be <br>
#ELT</p>

<p style="margin-left:17%;">return a &quot;real&quot;
element (not a <small>PCDATA, CDATA,</small> comment or pi
element)</p>

<p style="margin-left:11%;">#TEXT</p>

<p style="margin-left:17%;">return a <small>PCDATA</small>
or <small>CDATA</small> element</p>

<p style="margin-left:11%;">regular expression</p>

<p style="margin-left:17%;">return an element whose tag
matches the regexp. The regexp has to be created with
<tt>&quot;qr//&quot;</tt> (hence this is available only on
perl 5.005 and above)</p>

<p style="margin-left:11%;">code reference</p>

<p style="margin-left:17%;">applies the code, passing the
current element as argument, if the code returns true then
the element is returned, if it returns false then the code
is applied to the next candidate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig::XPath</b>
<br>
XML::Twig implements a subset of XPath through the
<tt>&quot;get_xpath&quot;</tt> method.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
use the whole XPath power, then you can use
<tt>&quot;XML::Twig::XPath&quot;</tt> instead. In this case
<tt>&quot;XML::Twig&quot;</tt> uses
<tt>&quot;XML::XPath&quot;</tt> to execute XPath queries.
You will of course need <tt>&quot;XML::XPath&quot;</tt>
installed to be able to use
<tt>&quot;XML::Twig::XPath&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">See XML::XPath
for more information.</p>

<p style="margin-left:11%; margin-top: 1em">The methods you
can use are: <br>
findnodes ($path)</p>

<p style="margin-left:17%;">return a list of nodes found by
<tt>$path</tt>.</p>

<p style="margin-left:11%;">findnodes_as_string ($path)</p>

<p style="margin-left:17%;">return the nodes found
reproduced as <small>XML.</small> The result is not
guaranteed to be valid <small>XML</small> though.</p>

<p style="margin-left:11%;">findvalue ($path)</p>

<p style="margin-left:17%;">return the concatenation of the
text content of the result nodes</p>

<p style="margin-left:11%; margin-top: 1em">In order for
<tt>&quot;XML::XPath&quot;</tt> to be used as the XPath
engine the following methods are included in
<tt>&quot;XML::Twig&quot;</tt>:</p>

<p style="margin-left:11%; margin-top: 1em">in XML::Twig
<br>
getRootNode <br>
getParentNode <br>
getChildNodes</p>

<p style="margin-left:11%; margin-top: 1em">in
XML::Twig::Elt <br>
string_value <br>
toString <br>
getName <br>
getRootNode <br>
getNextSibling <br>
getPreviousSibling <br>
isElementNode <br>
isTextNode <br>
isPI <br>
isPINode <br>
isProcessingInstructionNode <br>
isComment <br>
isCommentNode <br>
getTarget <br>
getChildNodes <br>
getElementById</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig::XPath::Elt</b>
<br>
The methods you can use are the same as on
<tt>&quot;XML::Twig::XPath&quot;</tt> elements: <br>
findnodes ($path)</p>

<p style="margin-left:17%;">return a list of nodes found by
<tt>$path</tt>.</p>

<p style="margin-left:11%;">findnodes_as_string ($path)</p>

<p style="margin-left:17%;">return the nodes found
reproduced as <small>XML.</small> The result is not
guaranteed to be valid <small>XML</small> though.</p>

<p style="margin-left:11%;">findvalue ($path)</p>

<p style="margin-left:17%;">return the concatenation of the
text content of the result nodes</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig::Entity_list</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>new</p></td>
<td width="2%"></td>
<td width="34%">


<p>Create an entity list.</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:11%;">add ($ent)</p>

<p style="margin-left:17%;">Add an entity to an entity
list.</p>

<p style="margin-left:11%;">add_new_ent ($name, $val,
$sysid, $pubid, $ndata, $param)</p>

<p style="margin-left:17%;">Create a new entity and add it
to the entity list</p>

<p style="margin-left:11%;">delete ($ent or $tag).</p>

<p style="margin-left:17%;">Delete an entity (defined by
its name or by the Entity object) from the list.</p>

<p style="margin-left:11%;">print
($optional_filehandle)</p>

<p style="margin-left:17%;">Print the entity list.</p>

<p style="margin-left:11%;">list</p>

<p style="margin-left:17%;">Return the list as an array</p>


<p style="margin-left:11%; margin-top: 1em"><b>XML::Twig::Entity</b>
<br>
new ($name, $val, $sysid, $pubid, $ndata, $param)</p>

<p style="margin-left:17%;">Same arguments as the Entity
handler for XML::Parser.</p>

<p style="margin-left:11%;">print
($optional_filehandle)</p>

<p style="margin-left:17%;">Print an entity
declaration.</p>

<p style="margin-left:11%;">name</p>

<p style="margin-left:17%;">Return the name of the
entity</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>val</p></td>
<td width="2%"></td>
<td width="46%">


<p>Return the value of the entity</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%;">sysid</p>

<p style="margin-left:17%;">Return the system id for the
entity (for <small>NDATA</small> entities)</p>

<p style="margin-left:11%;">pubid</p>

<p style="margin-left:17%;">Return the public id for the
entity (for <small>NDATA</small> entities)</p>

<p style="margin-left:11%;">ndata</p>

<p style="margin-left:17%;">Return true if the entity is an
<small>NDATA</small> entity</p>

<p style="margin-left:11%;">param</p>

<p style="margin-left:17%;">Return true if the entity is a
parameter entity</p>

<p style="margin-left:11%;">text</p>

<p style="margin-left:17%;">Return the entity declaration
text.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Additional
examples (and a complete tutorial) can be found on the
<i>XML::Twig
Page&lt;http://www.xmltwig.org/xmltwig/&gt;</i></p>

<p style="margin-left:11%; margin-top: 1em">To figure out
what flush does call the following script with an
<small>XML</small> file and an element name as arguments</p>

<pre style="margin-left:11%; margin-top: 1em">  use XML::Twig;
  my ($file, $elt)= @ARGV;
  my $t= XML::Twig&minus;&gt;new( twig_handlers =&gt;
      { $elt =&gt; sub {$_[0]&minus;&gt;flush; print &quot;\n[flushed here]\n&quot;;} });
  $t&minus;&gt;parsefile( $file, ErrorContext =&gt; 2);
  $t&minus;&gt;flush;
  print &quot;\n&quot;;</pre>


<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Subclassing
XML::Twig</b> <br>
Useful methods: <br>
elt_class</p>

<p style="margin-left:17%;">In order to subclass
<tt>&quot;XML::Twig&quot;</tt> you will probably need to
subclass also <tt>&quot;XML::Twig::Elt&quot;</tt>. Use the
<tt>&quot;elt_class&quot;</tt> option when you create the
<tt>&quot;XML::Twig&quot;</tt> object to get the elements
created in a different class (which should be a subclass of
<tt>&quot;XML::Twig::Elt&quot;</tt>.</p>

<p style="margin-left:11%;">add_options</p>

<p style="margin-left:17%;">If you inherit
<tt>&quot;XML::Twig&quot;</tt> new method but want to add
more options to it you can use this method to prevent
XML::Twig to issue warnings for those additional
options.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DTD</small>
Handling</b> <br>
There are 3 possibilities here. They are: <br>
No <small>DTD</small></p>

<p style="margin-left:17%;">No doctype, no
<small>DTD</small> information, no entity information, the
world is simple...</p>

<p style="margin-left:11%;">Internal <small>DTD</small></p>

<p style="margin-left:17%;">The <small>XML</small> document
includes an internal <small>DTD,</small> and maybe entity
declarations.</p>

<p style="margin-left:17%; margin-top: 1em">If you use the
load_DTD option when creating the twig the
<small>DTD</small> information and the entity declarations
can be accessed.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>DTD</small> and the entity declarations will be
<tt>&quot;flush&quot;</tt>&rsquo;ed (or
<tt>&quot;print&quot;</tt>&rsquo;ed) either as is (if they
have not been modified) or as reconstructed (poorly,
comments are lost, order is not kept, due to it&rsquo;s
content this <small>DTD</small> should not be viewed by
anyone) if they have been modified. You can also modify them
directly by changing the
<tt>&quot;$twig&minus;&gt;{twig_doctype}&minus;&gt;{internal}&quot;</tt>
field (straight from XML::Parser, see the
<tt>&quot;Doctype&quot;</tt> handler doc)</p>

<p style="margin-left:11%;">External <small>DTD</small></p>

<p style="margin-left:17%;">The <small>XML</small> document
includes a reference to an external <small>DTD,</small> and
maybe entity declarations.</p>

<p style="margin-left:17%; margin-top: 1em">If you use the
<tt>&quot;load_DTD&quot;</tt> when creating the twig the
<small>DTD</small> information and the entity declarations
can be accessed. The entity declarations will be
<tt>&quot;flush&quot;</tt>&rsquo;ed (or
<tt>&quot;print&quot;</tt>&rsquo;ed) either as is (if they
have not been modified) or as reconstructed (badly, comments
are lost, order is not kept).</p>

<p style="margin-left:17%; margin-top: 1em">You can change
the doctype through the
<tt>&quot;$twig&minus;&gt;set_doctype&quot;</tt> method and
print the dtd through the
<tt>&quot;$twig&minus;&gt;dtd_text&quot;</tt> or
<tt>&quot;$twig&minus;&gt;dtd_print&quot;</tt> <br>
methods.</p>

<p style="margin-left:17%; margin-top: 1em">If you need to
modify the entity list this is probably the easiest way to
do it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Flush</b>
<br>
Remember that element handlers are called when the element
is <small>CLOSED,</small> so if you have handlers for nested
elements the inner handlers will be called first. It makes
it for example trickier than it would seem to number nested
sections (or clauses, or divs), as the titles in the inner
sections are handled before the outer sections.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">segfault during
parsing</p>

<p style="margin-left:17%;">This happens when parsing huge
documents, or lots of small ones, with a version of Perl
before 5.16.</p>

<p style="margin-left:17%; margin-top: 1em">This is due to
a bug in the way weak references are handled in Perl
itself.</p>

<p style="margin-left:17%; margin-top: 1em">The fix is
either to upgrade to Perl 5.16 or later
(<tt>&quot;perlbrew&quot;</tt> is a great tool to manage
several installations of perl on the same machine).</p>

<p style="margin-left:17%; margin-top: 1em">An other,
<small>NOT RECOMMENDED,</small> way of fixing the problem,
is to switch off weak references by writing
<tt>&quot;XML::Twig::_set_weakrefs( 0);&quot;</tt> at the
top of the code. This is totally unsupported, and may lead
to other problems though,</p>

<p style="margin-left:11%;">entity handling</p>

<p style="margin-left:17%;">Due to XML::Parser behaviour,
non-base entities in attribute values disappear if they are
not declared in the document:
<tt>&quot;att=&quot;val&amp;ent;&quot;&quot;</tt> will be
turned into <tt>&quot;att =&gt; val&quot;</tt>, unless you
use the <tt>&quot;keep_encoding&quot;</tt> argument to
<tt>&quot;XML::Twig&minus;&gt;new&quot;</tt></p>

<p style="margin-left:11%;"><small>DTD</small> handling</p>

<p style="margin-left:17%;">The <small>DTD</small> handling
methods are quite bugged. No one uses them and it seems very
difficult to get them to work in all cases, including with
several slightly incompatible versions of XML::Parser and of
libexpat.</p>

<p style="margin-left:17%; margin-top: 1em">Basically you
can read the <small>DTD,</small> output it back properly,
and update entities, but not much more.</p>

<p style="margin-left:17%; margin-top: 1em">So use
XML::Twig with standalone documents, or with documents
refering to an external <small>DTD,</small> but don&rsquo;t
expect it to properly parse and even output back the
<small>DTD.</small></p>

<p style="margin-left:11%;">memory leak</p>

<p style="margin-left:17%;">If you use a
<small>REALLY</small> old Perl (5.005!) and a lot of twigs
you might find that you leak quite a lot of memory (about
2Ks per twig). You can use the <tt>&quot;dispose &quot;</tt>
method to free that memory after you are done.</p>

<p style="margin-left:17%; margin-top: 1em">If you create
elements the same thing might happen, use the
<tt>&quot;delete&quot;</tt> method to get rid of them.</p>

<p style="margin-left:17%; margin-top: 1em">Alternatively
installing the <tt>&quot;Scalar::Util&quot;</tt> (or
<tt>&quot;WeakRef&quot;</tt>) module on a version of Perl
that supports it (&gt;5.6.0) will get rid of the memory
leaks automagically.</p>

<p style="margin-left:11%;"><small>ID</small> list</p>

<p style="margin-left:17%;">The <small>ID</small> list is
<small>NOT</small> updated when elements are cut or
deleted.</p>

<p style="margin-left:11%;">change_gi</p>

<p style="margin-left:17%;">This method will not function
properly if you do:</p>

<pre style="margin-left:17%; margin-top: 1em">     $twig&minus;&gt;change_gi( $old1, $new);
     $twig&minus;&gt;change_gi( $old2, $new);
     $twig&minus;&gt;change_gi( $new, $even_newer);</pre>


<p style="margin-left:11%;">sanity check on XML::Parser
method calls</p>

<p style="margin-left:17%;">XML::Twig should really prevent
calls to some XML::Parser methods, especially the
<tt>&quot;setHandlers&quot;</tt> method.</p>

<p style="margin-left:11%;">pretty printing</p>

<p style="margin-left:17%;">Pretty printing (at least using
the &rsquo;<tt>&quot;indented&quot;</tt>&rsquo; style) is
hard to get right! Only elements that belong to the document
will be properly indented. Printing elements that do not
belong to the twig makes it impossible for XML::Twig to
figure out their depth, and thus their indentation
level.</p>

<p style="margin-left:17%; margin-top: 1em">Also there is
an unavoidable bug when using <tt>&quot;flush&quot;</tt> and
pretty printing for elements with mixed content that start
with an embedded element:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;elt&gt;&lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt;
  will be output as
  &lt;elt&gt;
    &lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">if you flush
the twig when you find the <tt>&quot;&lt;b&gt;&quot;</tt>
element</p>

<h2>Globals
<a name="Globals"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These are the
things that can mess up calling code, especially if
threaded. They might also cause problem under mod_perl. <br>
Exported constants</p>

<p style="margin-left:17%;">Whether you want them or not
you get them! These are subroutines to use as constant when
creating or testing elements</p>

<pre style="margin-left:17%; margin-top: 1em">  PCDATA  return '#PCDATA'
  CDATA   return '#CDATA'
  PI      return '#PI', I had the choice between PROC and PI :&minus;&minus;(</pre>


<p style="margin-left:11%;">Module scoped values:
constants</p>

<p style="margin-left:17%;">these should cause no
trouble:</p>

<pre style="margin-left:17%; margin-top: 1em">  %base_ent= ( '&gt;' =&gt; '&amp;gt;',
               '&lt;' =&gt; '&amp;lt;',
               '&amp;' =&gt; '&amp;amp;',
               &quot;'&quot; =&gt; '&amp;apos;',
               '&quot;' =&gt; '&amp;quot;',
             );
  CDATA_START   = &quot;&lt;![CDATA[&quot;;
  CDATA_END     = &quot;]]&gt;&quot;;
  PI_START      = &quot;&lt;?&quot;;
  PI_END        = &quot;?&gt;&quot;;
  COMMENT_START = &quot;&lt;!&minus;&minus;&quot;;
  COMMENT_END   = &quot;&minus;&minus;&gt;&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">pretty print
styles</p>

<pre style="margin-left:17%; margin-top: 1em">  ( $NSGMLS, $NICE, $INDENTED, $INDENTED_C, $WRAPPED, $RECORD1, $RECORD2)= (1..7);</pre>


<p style="margin-left:17%; margin-top: 1em">empty tag
output style</p>

<pre style="margin-left:17%; margin-top: 1em">  ( $HTML, $EXPAND)= (1..2);</pre>


<p style="margin-left:11%;">Module scoped values: might be
changed</p>

<p style="margin-left:17%;">Most of these deal with pretty
printing, so the worst that can happen is probably that
<small>XML</small> output does not look right, but is still
valid and processed identically by <small>XML</small>
processors.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$empty_tag_style</tt>
can mess up <small>HTML</small> bowsers though and changing
<tt>$ID</tt> would most likely create problems.</p>

<pre style="margin-left:17%; margin-top: 1em">  $pretty=0;           # pretty print style
  $quote='&quot;';          # quote for attributes
  $INDENT= '  ';       # indent for indented pretty print
  $empty_tag_style= 0; # how to display empty tags
  $ID                  # attribute used as an id ('id' by default)</pre>


<p style="margin-left:11%;">Module scoped values:
definitely changed</p>

<p style="margin-left:17%;">These 2 variables are used to
replace tags by an index, thus saving some space when
creating a twig. If they really cause you too much trouble,
let me know, it is probably possible to create either a
switch or at least a version of XML::Twig that does not
perform this optimization.</p>

<pre style="margin-left:17%; margin-top: 1em">  %gi2index;     # tag =&gt; index
  @index2gi;     # list of tags</pre>


<p style="margin-left:11%; margin-top: 1em">If you need to
manipulate all those values, you can use the following
methods on the XML::Twig object: <br>
global_state</p>

<p style="margin-left:17%;">Return a hashref with all the
global variables used by XML::Twig</p>

<p style="margin-left:17%; margin-top: 1em">The hash has
the following fields: <tt>&quot;pretty&quot;</tt>,
<tt>&quot;quote&quot;</tt>, <tt>&quot;indent&quot;</tt>,
<tt>&quot;empty_tag_style&quot;</tt>,
<tt>&quot;keep_encoding&quot;</tt>,
<tt>&quot;expand_external_entities&quot;</tt>,
<tt>&quot;output_filter&quot;</tt>,
<tt>&quot;output_text_filter&quot;</tt>,
<tt>&quot;keep_atts_order&quot;</tt></p>

<p style="margin-left:11%;">set_global_state ($state)</p>

<p style="margin-left:17%;">Set the global state,
<tt>$state</tt> is a hashref</p>

<p style="margin-left:11%;">save_global_state</p>

<p style="margin-left:17%;">Save the current global
state</p>

<p style="margin-left:11%;">restore_global_state</p>

<p style="margin-left:17%;">Restore the previously saved
(using <tt>&quot;Lsave_global_state&quot;</tt>&gt; state</p>

<h2>TODO
<a name="TODO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>SAX</small>
handlers</p>

<p style="margin-left:17%;">Allowing XML::Twig to work on
top of any <small>SAX</small> parser</p>

<p style="margin-left:11%;">multiple twigs are not well
supported</p>

<p style="margin-left:17%;">A number of twig features are
just global at the moment. These include the
<small>ID</small> list and the &quot;tag pool&quot; (if you
use <tt>&quot;change_gi&quot;</tt> then you change the tag
for <small>ALL</small> twigs).</p>

<p style="margin-left:17%; margin-top: 1em">A future
version will try to support this while trying not to be to
hard on performance (at least when a single twig is
used!).</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Michel
Rodriguez &lt;mirod@cpan.org&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">Bug reports
should be sent using: <i><small>RT</small>
&lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML&minus;Twig&gt;</i></p>

<p style="margin-left:11%; margin-top: 1em">Comments can be
sent to mirod@cpan.org</p>

<p style="margin-left:11%; margin-top: 1em">The XML::Twig
page is at &lt;http://www.xmltwig.org/xmltwig/&gt; It
includes the development version of the module, a slightly
better version of the documentation, examples, a tutorial
and a: <i>Processing <small>XML</small> efficiently with
Perl and XML::Twig:
&lt;http://www.xmltwig.org/xmltwig/tutorial/index.html&gt;</i></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Complete docs,
including a tutorial, examples, an easier to use
<small>HTML</small> version of the docs, a quick reference
card and a <small>FAQ</small> are available at
&lt;http://www.xmltwig.org/xmltwig/&gt;</p>

<p style="margin-left:11%; margin-top: 1em">git repository
at &lt;http://github.com/mirod/xmltwig&gt;</p>

<p style="margin-left:11%; margin-top: 1em">XML::Parser,
XML::Parser::Expat, XML::XPath, Encode, Text::Iconv,
Scalar::Utils</p>

<p style="margin-left:11%; margin-top: 1em"><b>Alternative
Modules</b> <br>
XML::Twig is not the only XML::Processing module available
on <small>CPAN</small> (far from it!).</p>

<p style="margin-left:11%; margin-top: 1em">The main
alternative I would recommend is XML::LibXML.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a quick
comparison of the 2 modules:</p>

<p style="margin-left:11%; margin-top: 1em">XML::LibXML,
actually <tt>&quot;libxml2&quot;</tt> on which it is based,
sticks to the standards, and implements a good number of
them in a rather strict way: <small>XML,</small> XPath,
<small>DOM,</small> RelaxNG, I must be forgetting a couple
(XInclude?). It is fast and rather frugal memory-wise.</p>

<p style="margin-left:11%; margin-top: 1em">XML::Twig is
older: when I started writing it XML::Parser/expat was the
only game in town. It implements <small>XML</small> and
that&rsquo;s about it (plus a subset of XPath, and you can
use XML::Twig::XPath if you have XML::XPathEngine installed
for full support). It is slower and requires more memory for
a full tree than XML::LibXML. On the plus side (yes, there
is a plus side!) it lets you process a big document in
chunks, and thus let you tackle documents that
couldn&rsquo;t be loaded in memory by XML::LibXML, and it
offers a lot (and I mean a <small>LOT</small> !) of
higher-level methods, for everything, from adding structure
to &quot;low-level&quot; <small>XML,</small> to shortcuts
for <small>XHTML</small> conversions and more. It also DWIMs
quite a bit, getting comments and non-significant
whitespaces out of the way but preserving them in the output
for example. As it does not stick to the <small>DOM,</small>
is also usually leads to shorter code than in
XML::LibXML.</p>

<p style="margin-left:11%; margin-top: 1em">Beyond the pure
features of the 2 modules, XML::LibXML seems to be prefered
by &quot;XML-purists&quot;, while XML::Twig seems to be more
used by Perl Hackers who have to deal with
<small>XML.</small> As you have noted, XML::Twig also comes
with quite a lot of docs, but I am sure if you ask for help
about XML::LibXML here or on Perlmonks you will get
answers.</p>

<p style="margin-left:11%; margin-top: 1em">Note that it is
actually quite hard for me to compare the 2 modules: on one
hand I know XML::Twig inside-out and I can get it to do
pretty much anything I need to (or I improve it
;&minus;&minus;), while I have a very basic knowledge of
XML::LibXML. So feature-wise, I&rsquo;d rather use XML::Twig
;&minus;&minus;). On the other hand, I am painfully aware of
some of the deficiencies, potential bugs and plain ugly code
that lurk in XML::Twig, even though you are unlikely to be
affected by them (unless for example you need to change the
<small>DTD</small> of a document programatically), while I
haven&rsquo;t looked much into XML::LibXML so it still looks
shinny and clean to me.</p>

<p style="margin-left:11%; margin-top: 1em">That said, if
you need to process a document that is too big to fit memory
and XML::Twig is too slow for you, my reluctant advice would
be to use &quot;bare&quot; XML::Parser. It won&rsquo;t be as
easy to use as XML::Twig: basically with XML::Twig you trade
some speed (depending on what you do from a factor 3 to...
none) for ease-of-use, but it will be easier
<small>IMHO</small> than using <small>SAX</small> (albeit
not standard), and at this point a <small>LOT</small> faster
(see the last test in
&lt;http://www.xmltwig.org/article/simple_benchmark/&gt;).</p>

<h2>POD ERRORS
<a name="POD ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hey! <b>The
above document had some coding errors, which are explained
below:</b> <br>
Around line 9528:</p>

<p style="margin-left:17%;">Invalid =encoding syntax: utf8
# &gt; perl 5.10.0</p>

<p style="margin-left:11%;">Around line 10517:</p>

<p style="margin-left:17%;">Non-ASCII character seen before
=encoding in &rsquo;X&quot;print&quot;&rsquo;. Assuming
<small>UTF&minus;8</small></p>
<hr>
</body>
</html>
