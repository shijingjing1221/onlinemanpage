<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:16:49 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>scrub</title>

</head>
<body>

<h1 align="center">scrub</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#SCRUB METHODS">SCRUB METHODS</a><br>
<a href="#CAVEATS">CAVEATS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">scrub &minus;
write patterns on disk/file</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>scrub</b>
<i>[OPTIONS] special-file</i> <b><br>
scrub</b> <i>[OPTIONS] file</i> <b><br>
scrub</b> <i>-X [OPTIONS] directory</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>Scrub</b></i>
iteratively writes patterns on files or disk devices to make
retrieving the data more difficult. <b>Scrub</b> operates in
one of three modes:</p>

<p style="margin-left:11%; margin-top: 1em">1) The special
file corresponding to an entire disk is scrubbed and all
data on it is destroyed. This mode is selected if
<i>file</i> is a character or block special file. This is
the most effective method.</p>

<p style="margin-left:11%; margin-top: 1em">2) A regular
file is scrubbed and only the data in the file (and
optionally its name in the directory entry) is destroyed.
The file size is rounded up to fill out the last file system
block. This mode is selected if <i>file</i> is a regular
file. See CAVEATS below.</p>

<p style="margin-left:11%; margin-top: 1em">3)
<i>directory</i> is created and filled with files until the
file system is full, then the files are scrubbed as in 2).
This mode is selected with the <i>-X</i> option. See CAVEATS
below.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Scrub</b>
accepts the following options: <i><br>
-v</i>, <i>--version</i></p>

<p style="margin-left:22%;">Print scrub version and
exit.</p>

<p style="margin-left:11%;"><i>-r</i>, <i>--remove</i></p>

<p style="margin-left:22%;">Remove the file after
scrubbing.</p>

<p style="margin-left:11%;"><i>-p</i>, <i>--pattern
PATTERN</i></p>

<p style="margin-left:22%;">Select the patterns to write.
See SCRUB METHODS below. The default, <i>nnsa</i>, is
reasonable for sanitizing modern PRML/EPRML encoded disk
devices.</p>

<p style="margin-left:11%;"><i>-b</i>, <i>--blocksize
blocksize</i></p>

<p style="margin-left:22%;">Perform read(2) and write(2)
calls using the specified blocksize (in bytes). <i>K, M,</i>
or <i>G</i> may be appended to the number to change the
units to KiBytes, MiBytes, or GiBytes, respectively.
Default: 4M.</p>

<p style="margin-left:11%;"><i>-f</i>, <i>--force</i></p>

<p style="margin-left:22%;">Scrub even if target contains
signature indicating it has already been scrubbed.</p>

<p style="margin-left:11%;"><i>-S</i>,
<i>--no-signature</i></p>

<p style="margin-left:22%;">Do not write scrub signature.
Later, <b>scrub</b> will not be able to ascertain if the
disk has already been scrubbed.</p>

<p style="margin-left:11%;"><i>-X</i>,
<i>--freespace</i></p>

<p style="margin-left:22%;">Create specified directory and
fill it with files until write returns ENOSPC (file system
full), then scrub the files as usual. The size of each file
can be set with <i>-s</i>, otherwise it will be the maximum
file size creatable given the user&rsquo;s file size limit
or 1g if unlimited.</p>

<p style="margin-left:11%;"><i>-D</i>, <i>--dirent
newname</i></p>

<p style="margin-left:22%;">After scrubbing the file, scrub
its name in the directory entry, then rename it to the new
name. The scrub patterns used on the directory entry are
constrained by the operating system and thus are not
compliant with cited standards.</p>

<p style="margin-left:11%;"><i>-s</i>, <i>--device-size
size</i></p>

<p style="margin-left:22%;">Override the device size (in
bytes). Without this option, <b>scrub</b> determines media
capacity using OS-specific ioctl(2) calls. <i>K, M,</i> or
<i>G</i> may be appended to the number to change the units
to KiBytes, MiBytes, or GiBytes, respectively.</p>

<p style="margin-left:11%;"><i>-L</i>, <i>--no-link</i></p>

<p style="margin-left:22%;">If <i>file</i> is a symbolic
link, do not scrub the link target. Do remove it, however,
if <i>--remove</i> is specified.</p>

<p style="margin-left:11%;"><i>-R</i>,
<i>--no-hwrand</i></p>

<p style="margin-left:22%;">Don&rsquo;t use a hardware
random number generator even if one is available.</p>

<p style="margin-left:11%;"><i>-t</i>,
<i>--no-threads</i></p>

<p style="margin-left:22%;">Don&rsquo;t generate random
data in parallel with I/O.</p>

<p style="margin-left:11%;"><i>-h</i>, <i>--help</i></p>

<p style="margin-left:22%;">Print a summary of command line
options on stderr.</p>

<h2>SCRUB METHODS
<a name="SCRUB METHODS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><i>nnsa</i></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">4-pass NNSA Policy Letter
NAP-14.1-C (XVI-8) for sanitizing removable and
non-removable hard disks, which requires overwriting all
locations with a pseudorandom pattern twice and then with a
known pattern: <b>random(x2), 0x00, verify</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>dod</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>4-pass DoD 5220.22-M section 8-306 procedure (d) for
sanitizing removable and non-removable rigid disks which
requires overwriting all addressable locations with a
character, its complement, a random character, then verify.
NOTE: <b>scrub</b> performs the random pass first to make
verification easier: <b>random, 0x00, 0xff, verify</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>bsi</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>9-pass method recommended by the German Center of
Security in Information Technologies
(http://www.bsi.bund.de): <b>0xff, 0xfe, 0xfd, 0xfb, 0xf7,
0xef, 0xdf, 0xbf, 0x7f</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>gutmann</i></p>

<p style="margin-left:22%;">The canonical 35-pass sequence
described in Gutmann&rsquo;s paper cited below.</p>

<p style="margin-left:11%;"><i>schneier</i></p>

<p style="margin-left:22%;">7-pass method described by
Bruce Schneier in &quot;Applied Cryptography&quot; (1996):
<b>0x00, 0xff, random(x5)</b></p>

<p style="margin-left:11%;"><i>pfitzner7</i></p>

<p style="margin-left:22%;">Roy Pfitzner&rsquo;s
7-random-pass method: <b>random(x7)</b>.</p>

<p style="margin-left:11%;"><i>pfitzner33</i></p>

<p style="margin-left:22%;">Roy Pfitzner&rsquo;s
33-random-pass method: <b>random(x33)</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>usarmy</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>US Army AR380-19 method: <b>0x00, 0xff, random</b>.
(Note: identical to DoD 522.22-M section 8-306 procedure (e)
for sanitizing magnetic core memory).</p></td></tr>
</table>

<p style="margin-left:11%;"><i>fillzero</i></p>

<p style="margin-left:22%;">1-pass pattern:
<b>0x00</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>fillff</i></p></td>
<td width="2%"></td>
<td width="41%">


<p>1-pass pattern: <b>0xff</b>.</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>random</i></p></td>
<td width="2%"></td>
<td width="41%">


<p>1-pass pattern: <b>random(x1)</b>.</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%;"><i>random2</i></p>

<p style="margin-left:22%;">2-pass pattern:
<b>random(x2)</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>old</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>6-pass pre-version 1.7 scrub method: <b>0x00, 0xff,
0xaa, 0x00, 0x55, verify</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>fastold</i></p>

<p style="margin-left:22%;">5-pass pattern: <b>0x00, 0xff,
0xaa, 0x55, verify</b>.</p>

<p style="margin-left:11%;"><i>custom=string</i></p>

<p style="margin-left:22%;">1-pass custom pattern. String
may contain C-style numerical escapes: \nnn (octal) or \xnn
(hex).</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Scrub</b>
may be insufficient to thwart heroic efforts to recover data
in an appropriately equipped lab. If you need this level of
protection, physical destruction is your best bet.</p>

<p style="margin-left:11%; margin-top: 1em">The
effectiveness of scrubbing regular files through a file
system will be limited by the OS and file system. File
systems that are known to be problematic are journaled, log
structured, copy-on-write, versioned, and network file
systems. If in doubt, scrub the raw disk device.</p>

<p style="margin-left:11%; margin-top: 1em">Scrubbing free
blocks in a file system with the <i>-X</i> method is subject
to the same caveats as scrubbing regular files, and in
addition, is only useful to the extent the file system
allows you to reallocate the target blocks as data blocks in
a new file. If in doubt, scrub the raw disk device.</p>

<p style="margin-left:11%; margin-top: 1em">On MacOS X HFS
file system, <b>scrub</b> attempts to overwrite a
file&rsquo;s resource fork if it exists. Although MacOS X
claims it will support additional named forks in the future,
<b>scrub</b> is only aware of the traditional data and
resource forks.</p>

<p style="margin-left:11%; margin-top: 1em"><b>scrub</b>
cannot access disk blocks that have been spared out by the
disk controller. For SATA/PATA drives, the ATA
&quot;security erase&quot; command built into the drive
controller can do this. Similarly, the ATA &quot;enhanced
security erase&quot; can erase data on track edges and
between tracks. The DOS utility HDDERASE from the UCSD
Center for Magnetic Recording Research can issue these
commands, as can modern versions of Linux <b>hdparm</b>.
Unfortunately, the analogous SCSI command is optional
according to T-10, and not widely implemented.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To scrub a raw
device <i>/dev/sdf1</i> with default NNSA patterns:</p>

<p style="margin-left:22%; margin-top: 1em"># scrub
/dev/sdf1 <br>
scrub: using NNSA NAP-14.1-C patterns <br>
scrub: please verify that device size below is correct! <br>
scrub: scrubbing /dev/sdf1 1995650048 bytes (~1GB) <br>
scrub: random
|................................................| <br>
scrub: random
|................................................| <br>
scrub: 0x00
|................................................| <br>
scrub: verify
|................................................|</p>

<p style="margin-left:11%; margin-top: 1em">To scrub the
file <i>/tmp/scrubme</i> with a sequence of 0xff 0xaa
bytes:</p>

<p style="margin-left:22%; margin-top: 1em"># scrub -p
custom=&quot;\xff\xaa&quot; /tmp/scrubme <br>
scrub: using Custom single-pass patterns <br>
scrub: scrubbing /tmp/scrubme 78319616 bytes (~74MB) <br>
scrub: 0xffaa
|................................................|</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jim Garlick
&lt;garlick@llnl.gov&gt;</p>

<p style="margin-left:11%; margin-top: 1em">This work was
produced at the University of California, Lawrence Livermore
National Laboratory under Contract No. W-7405-ENG-48 with
the DOE. Designated UCRL-CODE-2003-006, scrub is licensed
under terms of the GNU General Public License.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DoD 5220.22-M,
&quot;National Industrial Security Program Operating
Manual&quot;, Chapter 8, 01/1995.</p>

<p style="margin-left:11%; margin-top: 1em">NNSA Policy
Letter: NAP-14.1-C, &quot;Clearing, Sanitizing, and
Destroying Information System Storage Media, Memory Devices,
and other Related Hardware&quot;, 05-02-08, page XVI-8.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Secure
Deletion of Data from Magnetic and Solid-State Memory&quot;,
by Peter Gutmann, Sixth USENIX Security Symposium, San Jose,
CA, July 22-25, 1996.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Gutmann
Method&quot;, Wikipedia,
http://en.wikipedia.org/wiki/Gutmann_method.</p>

<p style="margin-left:11%; margin-top: 1em">Darik&rsquo;s
boot and Nuke FAQ:
http://dban.sourceforge.net/faq/index.html</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Tutorial
on Disk Drive Data Sanitization&quot;, by Gordon Hugues and
Tom Coughlin, <br>

http://cmrr.ucsd.edu/people/Hughes/DataSanitizationTutorial.pdf.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Guidelines
for Media Sanitization&quot;, NIST special publication
800-88, Kissel et al, September, 2006.</p>

<p style="margin-left:11%; margin-top: 1em">shred(1),
hdparm(8)</p>
<hr>
</body>
</html>
