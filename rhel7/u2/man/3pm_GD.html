<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 01:37:46 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GD</title>

</head>
<body>

<h1 align="center">GD</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Object Constructors: Creating Images">Object Constructors: Creating Images</a><br>
<a href="#GD::Image Methods">GD::Image Methods</a><br>
<a href="#Polygons">Polygons</a><br>
<a href="#Font Utilities">Font Utilities</a><br>
<a href="#Obtaining the C&minus;language version of gd">Obtaining the C&minus;language version of gd</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#POD ERRORS">POD ERRORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GD.pm &minus;
Interface to Gd Graphics Library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use GD;
    # create a new image
    $im = new GD::Image(100,100);
    # allocate some colors
    $white = $im&minus;&gt;colorAllocate(255,255,255);
    $black = $im&minus;&gt;colorAllocate(0,0,0);
    $red = $im&minus;&gt;colorAllocate(255,0,0);
    $blue = $im&minus;&gt;colorAllocate(0,0,255);
    # make the background transparent and interlaced
    $im&minus;&gt;transparent($white);
    $im&minus;&gt;interlaced('true');
    # Put a black frame around the picture
    $im&minus;&gt;rectangle(0,0,99,99,$black);
    # Draw a blue oval
    $im&minus;&gt;arc(50,50,95,75,0,360,$blue);
    # And fill it with red
    $im&minus;&gt;fill(50,50,$red);
    # make sure we are writing to a binary stream
    binmode STDOUT;
    # Convert the image to PNG and print it on standard output
    print $im&minus;&gt;png;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>GD</small>
.pm</b> is a Perl interface to Thomas Boutell&rsquo;s gd
graphics library (version 2.01 or higher; see below).
<small>GD</small> allows you to create color drawings using
a large number of graphics primitives, and emit the drawings
as <small>PNG</small> files.</p>


<p style="margin-left:11%; margin-top: 1em"><small>GD</small>
defines the following four classes: <br>
&quot;GD::Image&quot;</p>

<p style="margin-left:18%;">An image class, which holds the
image data and accepts graphic primitive method calls.</p>

<p style="margin-left:11%;">&quot;GD::Font&quot;</p>

<p style="margin-left:18%;">A font class, which holds
static font information and used for text rendering.</p>

<p style="margin-left:11%;">&quot;GD::Polygon&quot;</p>

<p style="margin-left:18%;">A simple polygon object, used
for storing lists of vertices prior to rendering a polygon
into an image.</p>

<p style="margin-left:11%;">&quot;GD::Simple&quot;</p>

<p style="margin-left:18%;">A &quot;simple&quot; class that
simplifies the GD::Image <small>API</small> and then adds a
set of object-oriented drawing methods using turtle
graphics, simplified font handling, ability to work in polar
coordinates, <small>HSV</small> color spaces, and
human-readable color names like &quot;lightblue&quot;.
Please see GD::Simple for a description of these
methods.</p>

<p style="margin-left:11%; margin-top: 1em">A Simple
Example:</p>

<pre style="margin-left:11%; margin-top: 1em">        #!/usr/local/bin/perl
        use GD;
        # create a new image
        $im = new GD::Image(100,100);
        # allocate some colors
        $white = $im&minus;&gt;colorAllocate(255,255,255);
        $black = $im&minus;&gt;colorAllocate(0,0,0);
        $red = $im&minus;&gt;colorAllocate(255,0,0);
        $blue = $im&minus;&gt;colorAllocate(0,0,255);
        # make the background transparent and interlaced
        $im&minus;&gt;transparent($white);
        $im&minus;&gt;interlaced('true');
        # Put a black frame around the picture
        $im&minus;&gt;rectangle(0,0,99,99,$black);
        # Draw a blue oval
        $im&minus;&gt;arc(50,50,95,75,0,360,$blue);
        # And fill it with red
        $im&minus;&gt;fill(50,50,$red);
        # make sure we are writing to a binary stream
        binmode STDOUT;
        # Convert the image to PNG and print it on standard output
        print $im&minus;&gt;png;</pre>


<p style="margin-left:11%; margin-top: 1em">Notes: <br>
1. To create a new, empty image, send a <i>new()</i> message
to GD::Image, <br>
passing it the width and height of the image you want to
create. An <br>
image object will be returned. Other class methods allow you
to <br>
initialize an image from a preexisting <small>JPG, PNG, GD,
GD2</small> or <small>XBM</small> file. <br>
2. Next you will ordinarily add colors to the image&rsquo;s
color table. <br>
colors are added using a <i>colorAllocate()</i> method call.
The three <br>
parameters in each call are the red, green and blue (rgb)
triples for <br>
the desired color. The method returns the index of that
color in the <br>
image&rsquo;s color table. You should store these indexes
for later use. <br>
3. Now you can do some drawing! The various graphics
primitives are <br>
described below. In this example, we do some text drawing,
create an <br>
oval, and create and draw a polygon. <br>
4. Polygons are created with a <i>new()</i> message to
GD::Polygon. You can <br>
add points to the returned polygon one at a time using the
<i>addPt()</i> <br>
method. The polygon can then be passed to an image for
rendering. <br>
5. When you&rsquo;re done drawing, you can convert the image
into <small>PNG</small> format <br>
by sending it a <i>png()</i> message. It will return a
(potentially large) <br>
scalar value containing the binary data for the image.
Ordinarily you <br>
will print it out at this point or write it to a file. To
ensure <br>
portability to platforms that differentiate between text and
binary <br>
files, be sure to call &quot;binmode()&quot; on the file you
are writing the <br>
image to.</p>

<h2>Object Constructors: Creating Images
<a name="Object Constructors: Creating Images"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
class methods allow you to create new GD::Image objects.
<b><br>
$image =
GD::Image&minus;&gt;new([$width,$height],[$truecolor]) <br>
$image = GD::Image&minus;&gt;new(*FILEHANDLE) <br>
$image = GD::Image&minus;&gt;new($filename) <br>
$image = GD::Image&minus;&gt;new($data)</b></p>

<p style="margin-left:17%;">The <i>new()</i> method is the
main constructor for the GD::Image class. Called with two
integer arguments, it creates a new blank image of the
specified width and height. For example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = new GD::Image(100,100) || die;</pre>


<p style="margin-left:17%; margin-top: 1em">This will
create an image that is 100 x 100 pixels wide. If you
don&rsquo;t specify the dimensions, a default of 64 x 64
will be chosen.</p>

<p style="margin-left:17%; margin-top: 1em">The optional
third argument, <tt>$truecolor</tt>, tells <i>new()</i> to
create a truecolor GD::Image object. Truecolor images have
24 bits of color data (eight bits each in the red, green and
blue channels respectively), allowing for precise
photograph-quality color usage. If not specified, the image
will use an 8&minus;bit palette for compatibility with older
versions of libgd.</p>

<p style="margin-left:17%; margin-top: 1em">Alternatively,
you may create a GD::Image object based on an existing image
by providing an open filehandle, a filename, or the image
data itself. The image formats automatically recognized and
accepted are: <small>PNG, JPEG, XPM</small> and
<small>GD2.</small> Other formats, including
<small>WBMP,</small> and <small>GD</small> version 1, cannot
be recognized automatically at this time.</p>

<p style="margin-left:17%; margin-top: 1em">If something
goes wrong (e.g. insufficient memory), this call will return
undef.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;trueColor([0,1])</b></p>

<p style="margin-left:17%;">For backwards compatibility
with scripts previous versions of <small>GD,</small> new
images created from scratch (width, height) are palette
based by default. To change this default to create true
color images use:</p>

<pre style="margin-left:17%; margin-top: 1em">        GD::Image&minus;&gt;trueColor(1);</pre>


<p style="margin-left:17%; margin-top: 1em">somewhere
before creating new images. To switch back to palette based
by default, use:</p>

<pre style="margin-left:17%; margin-top: 1em">        GD::Image&minus;&gt;trueColor(0);</pre>


<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newPalette([$width,$height]) <br>
$image =
GD::Image&minus;&gt;newTrueColor([$width,$height])</b></p>

<p style="margin-left:17%;">The <i>newPalette()</i> and
<i>newTrueColor()</i> methods can be used to explicitly
create an palette based or true color image regardless of
the current setting of <i>trueColor()</i>.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromPng($file, [$truecolor]) <br>
$image = GD::Image&minus;&gt;newFromPngData($data,
[$truecolor])</b></p>

<p style="margin-left:17%;">The <i>newFromPng()</i> method
will create an image from a <small>PNG</small> file read in
through the provided filehandle or file path. The filehandle
must previously have been opened on a valid
<small>PNG</small> file or pipe. If successful, this call
will return an initialized image which you can then
manipulate as you please. If it fails, which usually happens
if the thing at the other end of the filehandle is not a
valid <small>PNG</small> file, the call returns undef.
Notice that the call doesn&rsquo;t automatically close the
filehandle for you. But it does call
<tt>&quot;binmode(FILEHANDLE)&quot;</tt> for you, on
platforms where this matters.</p>

<p style="margin-left:17%; margin-top: 1em">You may use any
of the following as the argument:</p>

<pre style="margin-left:17%; margin-top: 1em">  1) a simple filehandle, such as STDIN
  2) a filehandle glob, such as *PNG
  3) a reference to a glob, such as \*PNG
  4) an IO::Handle object
  5) the pathname of a file</pre>


<p style="margin-left:17%; margin-top: 1em">In the latter
case, <i>newFromPng()</i> will attempt to open the file for
you and read the <small>PNG</small> information from it.</p>

<pre style="margin-left:17%; margin-top: 1em">  Example1:
  open (PNG,&quot;barnswallow.png&quot;) || die;
  $myImage = newFromPng GD::Image(\*PNG) || die;
  close PNG;
  Example2:
  $myImage = newFromPng GD::Image('barnswallow.png');</pre>


<p style="margin-left:17%; margin-top: 1em">To get
information about the size and color usage of the
information, you can call the image query methods described
below. Images created by reading <small>PNG</small> images
will be truecolor if the image file itself is truecolor. To
force the image to be palette-based, pass a value of 0 in
the optional <tt>$truecolor</tt> argument.</p>

<p style="margin-left:17%; margin-top: 1em">The
<i>newFromPngData()</i> method will create a new GD::Image
initialized with the <small>PNG</small> format <b>data</b>
contained in <tt>$data</tt>.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromJpeg($file, [$truecolor]) <br>
$image = GD::Image&minus;&gt;newFromJpegData($data,
[$truecolor])</b></p>

<p style="margin-left:17%;">These methods will create an
image from a <small>JPEG</small> file. They work just like
<i>newFromPng()</i> and <i>newFromPngData()</i>, and will
accept the same filehandle and pathname arguments.</p>

<p style="margin-left:17%; margin-top: 1em">Images created
by reading <small>JPEG</small> images will always be
truecolor. To force the image to be palette-based, pass a
value of 0 in the optional <tt>$truecolor</tt> argument.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromGif($file) <br>
$image = GD::Image&minus;&gt;newFromGifData($data)</b></p>

<p style="margin-left:17%;">These methods will create an
image from a <small>GIF</small> file. They work just like
<i>newFromPng()</i> and <i>newFromPngData()</i>, and will
accept the same filehandle and pathname arguments.</p>

<p style="margin-left:17%; margin-top: 1em">Images created
from GIFs are always 8&minus;bit palette images. To convert
to truecolor, you must create a truecolor image and then
perform a copy.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromXbm($file)</b></p>

<p style="margin-left:17%;">This works in exactly the same
way as <tt>&quot;newFromPng&quot;</tt>, but reads the
contents of an X Bitmap (black &amp; white) file:</p>

<pre style="margin-left:17%; margin-top: 1em">        open (XBM,&quot;coredump.xbm&quot;) || die;
        $myImage = newFromXbm GD::Image(\*XBM) || die;
        close XBM;</pre>


<p style="margin-left:17%; margin-top: 1em">There is no
<i>newFromXbmData()</i> function, because there is no
corresponding function in the gd library.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromGd($file) <br>
$image = GD::Image&minus;&gt;newFromGdData($data)</b></p>

<p style="margin-left:17%;">These methods initialize a
GD::Image from a Gd file, filehandle, or data. Gd is Tom
Boutell&rsquo;s disk-based storage format, intended for the
rare case when you need to read and write the image to disk
quickly. It&rsquo;s not intended for regular use, because,
unlike <small>PNG</small> or <small>JPEG,</small> no image
compression is performed and these files can become
<b><small>BIG</small></b> .</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = newFromGd GD::Image(&quot;godzilla.gd&quot;) || die;
        close GDF;</pre>


<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromGd2($file) <br>
$image = GD::Image&minus;&gt;newFromGd2Data($data)</b></p>

<p style="margin-left:17%;">This works in exactly the same
way as <tt>&quot;newFromGd()&quot;</tt> and newFromGdData,
but use the new compressed <small>GD2</small> image
format.</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromGd2Part($file,srcX,srcY,width,height)</b></p>

<p style="margin-left:17%;">This class method allows you to
read in just a portion of a <small>GD2</small> image file.
In addition to a filehandle, it accepts the top-left corner
and dimensions (width,height) of the region of the image to
read. For example:</p>

<pre style="margin-left:17%; margin-top: 1em">        open (GDF,&quot;godzilla.gd2&quot;) || die;
        $myImage = GD::Image&minus;&gt;newFromGd2Part(\*GDF,10,20,100,100) || die;
        close GDF;</pre>


<p style="margin-left:17%; margin-top: 1em">This reads a
100x100 square portion of the image starting from position
(10,20).</p>

<p style="margin-left:11%;"><b>$image =
GD::Image&minus;&gt;newFromXpm($filename)</b></p>

<p style="margin-left:17%;">This creates a new GD::Image
object starting from a <b>filename</b>. This is unlike the
other <i>newFrom()</i> functions because it does not take a
filehandle. This difference comes from an inconsistency in
the underlying gd library.</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = newFromXpm GD::Image('earth.xpm') || die;</pre>


<p style="margin-left:17%; margin-top: 1em">This function
is only available if libgd was compiled with
<small>XPM</small> support.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
The libgd library is unable to read certain
<small>XPM</small> files, returning an all-black image
instead.</p>

<h2>GD::Image Methods
<a name="GD::Image Methods"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Once a
GD::Image object is created, you can draw with it, copy it,
and merge two images. When you are finished manipulating the
object, you can convert it into a standard image file format
to output or save to a file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Image Data
Output Methods</b> <br>
The following methods convert the internal drawing format
into standard output file formats. <b><br>
$pngdata =</b>
<b><i>$image</i></b><b>&minus;&gt;png([$compression_level])</b></p>

<p style="margin-left:17%;">This returns the image data in
<small>PNG</small> format. You can then print it, pipe it to
a display program, or write it to a file. Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $png_data = $myImage&minus;&gt;png;
        open (DISPLAY,&quot;| display &minus;&quot;) || die;
        binmode DISPLAY;
        print DISPLAY $png_data;
        close DISPLAY;</pre>


<p style="margin-left:17%; margin-top: 1em">Note the use of
<tt>&quot;binmode()&quot;</tt>. This is crucial for
portability to DOSish platforms.</p>

<p style="margin-left:17%; margin-top: 1em">The optional
<tt>$compression_level</tt> argument controls the amount of
compression to apply to the output <small>PNG</small> image.
Values range from 0&minus;9, where 0 means no compression
(largest files, highest quality) and 9 means maximum
compression (smallest files, worst quality). A compression
level of &minus;1 uses the default compression level
selected when zlib was compiled on your system, and is the
same as calling <i>png()</i> with no argument. Be careful
not to confuse this argument with the <i>jpeg()</i> quality
argument, which ranges from 0&minus;100 and has the opposite
meaning from compression (higher numbers give higher
quality).</p>

<p style="margin-left:11%;"><b>$gifdata =</b>
<b><i>$image</i></b><b>&minus;&gt;gifanimbegin([$GlobalCM [,
$Loops]])</b></p>

<p style="margin-left:17%;">For libgd version 2.0.33 and
higher, this call begins an animated <small>GIF</small> by
returning the data that comprises animated gif image file
header. After you call this method, call <i>gifanimadd()</i>
one or more times to add the frames of the image. Then call
<i>gifanimend()</i>. Each frame must be the same width and
height.</p>

<p style="margin-left:17%; margin-top: 1em">A typical
sequence will look like this:</p>

<pre style="margin-left:17%; margin-top: 1em">  my $gifdata = $image&minus;&gt;gifanimbegin;
  $gifdata   .= $image&minus;&gt;gifanimadd;    # first frame
  for (1..100) {
     # make a frame of right size
     my $frame  = GD::Image&minus;&gt;new($image&minus;&gt;getBounds);
     add_frame_data($frame);              # add the data for this frame
     $gifdata   .= $frame&minus;&gt;gifanimadd;     # add frame
  }
  $gifdata   .= $image&minus;&gt;gifanimend;   # finish the animated GIF
  print $gifdata;                     # write animated gif to STDOUT</pre>


<p style="margin-left:17%; margin-top: 1em">If you do not
wish to store the data in memory, you can print it to stdout
or a file.</p>

<p style="margin-left:17%; margin-top: 1em">The image that
you call gifanimbegin on is used to set the image size,
color resolution and color map. If argument
<tt>$GlobalCM</tt> is 1, the image color map becomes the
GIF89a global color map. If <tt>$Loops</tt> is given and
&gt;= 0, the <small>NETSCAPE2.0</small> application
extension is created, with looping count. Looping count 0
means forever.</p>

<p style="margin-left:11%;"><b>$gifdata =</b>
<b><i>$image</i></b><b>&minus;&gt;gifanimadd([$LocalCM [,
$LeftOfs [, $TopOfs [, <br>
$Delay [, $Disposal [, $previm]]]]]])</b></p>

<p style="margin-left:17%;">Returns the data that comprises
one animated gif image frame. You can then print it, pipe it
to a display program, or write it to a file. With
<tt>$LeftOfs</tt> and <tt>$TopOfs</tt> you can place this
frame in different offset than (0,0) inside the image
screen. Delay between the previous frame and this frame is
in 1/100s units. Disposal is usually and by default 1.
Compression is activated by giving the previous image as a
parameter. This function then compares the images and only
writes the changed pixels to the new frame in animation. The
Disposal parameter for optimized animations must be set to
1, also for the first frame. <tt>$LeftOfs</tt> and
<tt>$TopOfs</tt> parameters are ignored for optimized
frames.</p>

<p style="margin-left:11%;"><b>$gifdata =</b>
<b><i>$image</i></b><b>&minus;&gt;</b><b><i>gifanimend()</i></b></p>

<p style="margin-left:17%;">Returns the data for end
segment of animated gif file. It always returns string
&rsquo;;&rsquo;. This string must be printed to an animated
gif file after all image frames to properly terminate it
according to <small>GIF</small> file syntax. Image object is
not used at all in this method.</p>

<p style="margin-left:11%;"><b>$jpegdata =</b>
<b><i>$image</i></b><b>&minus;&gt;jpeg([$quality])</b></p>

<p style="margin-left:17%;">This returns the image data in
<small>JPEG</small> format. You can then print it, pipe it
to a display program, or write it to a file. You may pass an
optional quality score to <i>jpeg()</i> in order to control
the <small>JPEG</small> quality. This should be an integer
between 0 and 100. Higher quality scores give larger files
and better image quality. If you don&rsquo;t specify the
quality, <i>jpeg()</i> will choose a good default.</p>

<p style="margin-left:11%;"><b>$gifdata =</b>
<b><i>$image</i></b><b>&minus;&gt;</b><b><i>gif()</i></b>.</p>

<p style="margin-left:17%;">This returns the image data in
<small>GIF</small> format. You can then print it, pipe it to
a display program, or write it to a file.</p>

<p style="margin-left:11%;"><b>$gddata =</b>
<b><i>$image</i></b><b>&minus;&gt;gd</b></p>

<p style="margin-left:17%;">This returns the image data in
<small>GD</small> format. You can then print it, pipe it to
a display program, or write it to a file. Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        binmode MYOUTFILE;
        print MYOUTFILE $myImage&minus;&gt;gd;</pre>


<p style="margin-left:11%;"><b>$gd2data =</b>
<b><i>$image</i></b><b>&minus;&gt;gd2</b></p>

<p style="margin-left:17%;">Same as <i>gd()</i>, except
that it returns the data in compressed <small>GD2</small>
format.</p>

<p style="margin-left:11%;"><b>$wbmpdata =</b>
<b><i>$image</i></b><b>&minus;&gt;wbmp([$foreground])</b></p>

<p style="margin-left:17%;">This returns the image data in
<small>WBMP</small> format, which is a black-and-white image
format. Provide the index of the color to become the
foreground color. All other pixels will be considered
background.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Color
Control</b> <br>
These methods allow you to control and manipulate the
GD::Image color table. <b><br>
$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorAllocate(red,green,blue)</b></p>

<p style="margin-left:17%;">This allocates a color with the
specified red, green and blue components and returns its
index in the color table, if specified. The first color
allocated in this way becomes the image&rsquo;s background
color. (255,255,255) is white (all pixels on). (0,0,0) is
black (all pixels off). (255,0,0) is fully saturated red.
(127,127,127) is 50% gray. You can find plenty of examples
in /usr/X11/lib/X11/rgb.txt.</p>

<p style="margin-left:17%; margin-top: 1em">If no colors
are allocated, then this function returns &minus;1.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $white = $myImage&minus;&gt;colorAllocate(0,0,0); #background color
        $black = $myImage&minus;&gt;colorAllocate(255,255,255);
        $peachpuff = $myImage&minus;&gt;colorAllocate(255,218,185);</pre>


<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorAllocateAlpha(reg,green,blue,alpha)</b></p>

<p style="margin-left:17%;">This allocates a color with the
specified red, green, and blue components, plus the
specified alpha channel. The alpha value may range from 0
(opaque) to 127 (transparent). The
<tt>&quot;alphaBlending&quot;</tt> function changes the way
this alpha channel affects the resulting image.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;colorDeallocate(colorIndex)</b></p>

<p style="margin-left:17%;">This marks the color at the
specified index as being ripe for reallocation. The next
time colorAllocate is used, this entry will be replaced. You
can call this method several times to deallocate multiple
colors. There&rsquo;s no function result from this call.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage&minus;&gt;colorDeallocate($peachpuff);
        $peachy = $myImage&minus;&gt;colorAllocate(255,210,185);</pre>


<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorClosest(red,green,blue)</b></p>

<p style="margin-left:17%;">This returns the index of the
color closest in the color table to the red green and blue
components specified. If no colors have yet been allocated,
then this call returns &minus;1.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $apricot = $myImage&minus;&gt;colorClosest(255,200,180);</pre>


<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorClosestHWB(red,green,blue)</b></p>

<p style="margin-left:17%;">This also attempts to return
the color closest in the color table to the red green and
blue components specified. It uses a Hue/White/Black color
representation to make the selected color more likely to
match human perceptions of similar colors.</p>

<p style="margin-left:17%; margin-top: 1em">If no colors
have yet been allocated, then this call returns
&minus;1.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $mostred = $myImage&minus;&gt;colorClosestHWB(255,0,0);</pre>


<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorExact(red,green,blue)</b></p>

<p style="margin-left:17%;">This returns the index of a
color that exactly matches the specified red green and blue
components. If such a color is not in the color table, this
call returns &minus;1.</p>

<pre style="margin-left:17%; margin-top: 1em">        $rosey = $myImage&minus;&gt;colorExact(255,100,80);
        warn &quot;Everything's coming up roses.\n&quot; if $rosey &gt;= 0;</pre>


<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;colorResolve(red,green,blue)</b></p>

<p style="margin-left:17%;">This returns the index of a
color that exactly matches the specified red green and blue
components. If such a color is not in the color table and
there is room, then this method allocates the color in the
color table and returns its index.</p>

<pre style="margin-left:17%; margin-top: 1em">        $rosey = $myImage&minus;&gt;colorResolve(255,100,80);
        warn &quot;Everything's coming up roses.\n&quot; if $rosey &gt;= 0;</pre>


<p style="margin-left:11%;"><b>$colorsTotal =</b>
<b><i>$image</i></b><b>&minus;&gt;colorsTotal</b> <i>object
method</i></p>

<p style="margin-left:17%;">This returns the total number
of colors allocated in the object.</p>

<pre style="margin-left:17%; margin-top: 1em">        $maxColors = $myImage&minus;&gt;colorsTotal;</pre>


<p style="margin-left:17%; margin-top: 1em">In the case of
a TrueColor image, this call will return undef.</p>

<p style="margin-left:11%;"><b>$index =</b>
<b><i>$image</i></b><b>&minus;&gt;getPixel(x,y)</b>
<i>object method</i></p>

<p style="margin-left:17%;">This returns the color table
index underneath the specified point. It can be combined
with <i>rgb()</i> to obtain the rgb color underneath the
pixel.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $index = $myImage&minus;&gt;getPixel(20,100);
        ($r,$g,$b) = $myImage&minus;&gt;rgb($index);</pre>


<p style="margin-left:11%;"><b>($red,$green,$blue) =
$image&minus;&gt;rgb($index)</b></p>

<p style="margin-left:17%;">This returns a list containing
the red, green and blue components of the specified color
index.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        @RGB = $myImage&minus;&gt;rgb($peachy);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;transparent($colorIndex)</b></p>

<p style="margin-left:17%;">This marks the color at the
specified index as being transparent. Portions of the image
drawn in this color will be invisible. This is useful for
creating paintbrushes of odd shapes, as well as for making
<small>PNG</small> backgrounds transparent for displaying on
the Web. Only one color can be transparent at any time. To
disable transparency, specify &minus;1 for the index.</p>

<p style="margin-left:17%; margin-top: 1em">If you call
this method without any parameters, it will return the
current index of the transparent color, or &minus;1 if
none.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        open(PNG,&quot;test.png&quot;);
        $im = newFromPng GD::Image(PNG);
        $white = $im&minus;&gt;colorClosest(255,255,255); # find white
        $im&minus;&gt;transparent($white);
        binmode STDOUT;
        print $im&minus;&gt;png;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Special
Colors</b> <small><br>
GD</small> implements a number of special colors that can be
used to achieve special effects. They are constants defined
in the <small>GD::</small> namespace, but automatically
exported into your namespace when the <small>GD</small>
module is loaded. <b><br>
$image&minus;&gt;setBrush($image)</b></p>

<p style="margin-left:17%;">You can draw lines and shapes
using a brush pattern. Brushes are just images that you can
create and manipulate in the usual way. When you draw with
them, their contents are used for the color and shape of the
lines.</p>

<p style="margin-left:17%; margin-top: 1em">To make a
brushed line, you must create or load the brush first, then
assign it to the image using <i>setBrush()</i>. You can then
draw in that with that brush using the <b>gdBrushed</b>
special color. It&rsquo;s often useful to set the background
of the brush to transparent so that the non-colored parts
don&rsquo;t overwrite other parts of your image.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # Create a brush at an angle
        $diagonal_brush = new GD::Image(5,5);
        $white = $diagonal_brush&minus;&gt;colorAllocate(255,255,255);
        $black = $diagonal_brush&minus;&gt;colorAllocate(0,0,0);
        $diagonal_brush&minus;&gt;transparent($white);
        $diagonal_brush&minus;&gt;line(0,4,4,0,$black); # NE diagonal
        # Set the brush
        $myImage&minus;&gt;setBrush($diagonal_brush);
        # Draw a circle using the brush
        $myImage&minus;&gt;arc(50,50,25,25,0,360,gdBrushed);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;setThickness($thickness)</b></p>

<p style="margin-left:17%;">Lines drawn with <i>line()</i>,
<i>rectangle()</i>, <i>arc()</i>, and so forth are 1 pixel
thick by default. Call <i>setThickness()</i> to change the
line drawing width.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;setStyle(@colors)</b></p>

<p style="margin-left:17%;">Styled lines consist of an
arbitrary series of repeated colors and are useful for
generating dotted and dashed lines. To create a styled line,
use <i>setStyle()</i> to specify a repeating series of
colors. It accepts an array consisting of one or more color
indexes. Then draw using the <b>gdStyled</b> special color.
Another special color, <b>gdTransparent</b> can be used to
introduce holes in the line, as the example shows.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # Set a style consisting of 4 pixels of yellow,
        # 4 pixels of blue, and a 2 pixel gap
        $myImage&minus;&gt;setStyle($yellow,$yellow,$yellow,$yellow,
                           $blue,$blue,$blue,$blue,
                           gdTransparent,gdTransparent);
        $myImage&minus;&gt;arc(50,50,25,25,0,360,gdStyled);</pre>


<p style="margin-left:17%; margin-top: 1em">To combine the
<tt>&quot;gdStyled&quot;</tt> and
<tt>&quot;gdBrushed&quot;</tt> behaviors, you can specify
<tt>&quot;gdStyledBrushed&quot;</tt>. In this case, a pixel
from the current brush pattern is rendered wherever the
color specified in <i>setStyle()</i> is neither
gdTransparent nor 0.</p>

<p style="margin-left:11%;"><b>gdTiled</b></p>

<p style="margin-left:17%;">Draw filled shapes and flood
fills using a pattern. The pattern is just another image.
The image will be tiled multiple times in order to fill the
required space, creating wallpaper effects. You must call
<tt>&quot;setTile&quot;</tt> in order to define the
particular tile pattern you&rsquo;ll use for drawing when
you specify the gdTiled color. details.</p>

<p style="margin-left:11%;"><b>gdStyled</b></p>

<p style="margin-left:17%;">The gdStyled color is used for
creating dashed and dotted lines. A styled line can contain
any series of colors and is created using the
<i>setStyled()</i> command.</p>

<p style="margin-left:11%;"><b>gdAntiAliased</b></p>

<p style="margin-left:17%;">The
<tt>&quot;gdAntiAliased&quot;</tt> color is used for drawing
lines with antialiasing turned on. Antialiasing will blend
the jagged edges of lines with the background, creating a
smoother look. The actual color drawn is set with
<i>setAntiAliased()</i>.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;setAntiAliased($color)</b></p>

<p style="margin-left:17%;">&quot;Antialiasing&quot; is a
process by which jagged edges associated with line drawing
can be reduced by blending the foreground color with an
appropriate percentage of the background, depending on how
much of the pixel in question is actually within the
boundaries of the line being drawn. All line-drawing
methods, such as <i>line()</i> and polygon, will draw
antialiased lines if the special &quot;color&quot;
<b>gdAntiAliased</b> is used when calling them.</p>


<p style="margin-left:17%; margin-top: 1em"><i>setAntiAliased()</i>
is used to specify the actual foreground color to be used
when drawing antialiased lines. You may set any color to be
the foreground, however as of libgd version 2.0.12 an alpha
channel component is not supported.</p>

<p style="margin-left:17%; margin-top: 1em">Antialiased
lines can be drawn on both truecolor and palette-based
images. However, attempts to draw antialiased lines on
highly complex palette-based backgrounds may not give
satisfactory results, due to the limited number of colors
available in the palette. Antialiased line-drawing on simple
backgrounds should work well with palette-based images;
otherwise create or fetch a truecolor image instead. When
using palette-based images, be sure to allocate a broad
spectrum of colors in order to have sufficient colors for
the antialiasing to use.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;setAntiAliasedDontBlend($color,[$flag])</b></p>

<p style="margin-left:17%;">Normally, when drawing lines
with the special <b>gdAntiAliased</b> &quot;color,&quot;
blending with the background to reduce jagged edges is the
desired behavior. However, when it is desired that lines not
be blended with one particular color when it is encountered
in the background, the <i>setAntiAliasedDontBlend()</i>
method can be used to indicate the special color that the
foreground should stand out more clearly against.</p>

<p style="margin-left:17%; margin-top: 1em">Once turned on,
you can turn this feature off by calling
<i>setAntiAliasedDontBlend()</i> with a second argument of
0:</p>

<pre style="margin-left:17%; margin-top: 1em"> $image&minus;&gt;setAntiAliasedDontBlend($color,0);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Drawing
Commands</b> <br>
These methods allow you to draw lines, rectangles, and
ellipses, as well as to perform various special operations
like flood-fill. <b><br>
$image&minus;&gt;setPixel($x,$y,$color)</b></p>

<p style="margin-left:17%;">This sets the pixel at (x,y) to
the specified color index. No value is returned from this
method. The coordinate system starts at the upper left at
(0,0) and gets larger as you go down and to the right. You
can use a real color, or one of the special colors
gdBrushed, gdStyled and gdStyledBrushed can be
specified.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # This assumes $peach already allocated
        $myImage&minus;&gt;setPixel(50,50,$peach);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;line($x1,$y1,$x2,$y2,$color)</b></p>

<p style="margin-left:17%;">This draws a line from (x1,y1)
to (x2,y2) of the specified color. You can use a real color,
or one of the special colors gdBrushed, gdStyled and
gdStyledBrushed.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # Draw a diagonal line using the currently defined
        # paintbrush pattern.
        $myImage&minus;&gt;line(0,0,150,150,gdBrushed);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;dashedLine($x1,$y1,$x2,$y2,$color)</b></p>

<p style="margin-left:17%;"><small>DEPRECATED:</small> The
libgd library provides this method solely for backward
compatibility with libgd version 1.0, and there have been
reports that it no longer works as expected. Please use the
<i>setStyle()</i> and gdStyled methods as described
below.</p>

<p style="margin-left:17%; margin-top: 1em">This draws a
dashed line from (x1,y1) to (x2,y2) in the specified color.
A more powerful way to generate arbitrary dashed and dotted
lines is to use the <i>setStyle()</i> method described below
and to draw with the special color gdStyled.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage&minus;&gt;dashedLine(0,0,150,150,$blue);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;rectangle($x1,$y1,$x2,$y2,$color)</b></p>

<p style="margin-left:17%;">This draws a rectangle with the
specified color. (x1,y1) and (x2,y2) are the upper left and
lower right corners respectively. Both real color indexes
and the special colors gdBrushed, gdStyled and
gdStyledBrushed are accepted.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage&minus;&gt;rectangle(10,10,100,100,$rose);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;filledRectangle($x1,$y1,$x2,$y2,$color)</b></p>

<p style="margin-left:17%;">This draws a rectangle filed
with the specified color. You can use a real color, or the
special fill color gdTiled to fill the polygon with a
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # read in a fill pattern and set it
        $tile = newFromPng GD::Image('happyface.png');
        $myImage&minus;&gt;setTile($tile);
        # draw the rectangle, filling it with the pattern
        $myImage&minus;&gt;filledRectangle(10,10,150,200,gdTiled);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;openPolygon($polygon,$color)</b></p>

<p style="margin-left:17%;">This draws a polygon with the
specified color. The polygon must be created first (see
below). The polygon must have at least three vertices. If
the last vertex doesn&rsquo;t close the polygon, the method
will close it for you. Both real color indexes and the
special colors gdBrushed, gdStyled and gdStyledBrushed can
be specified.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $poly = new GD::Polygon;
        $poly&minus;&gt;addPt(50,0);
        $poly&minus;&gt;addPt(99,99);
        $poly&minus;&gt;addPt(0,99);
        $myImage&minus;&gt;openPolygon($poly,$blue);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;unclosedPolygon($polygon,$color)</b></p>

<p style="margin-left:17%;">This draws a sequence of
connected lines with the specified color, without connecting
the first and last point to a closed polygon. The polygon
must be created first (see below). The polygon must have at
least three vertices. Both real color indexes and the
special colors gdBrushed, gdStyled and gdStyledBrushed can
be specified.</p>

<p style="margin-left:17%; margin-top: 1em">You need libgd
2.0.33 or higher to use this feature.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $poly = new GD::Polygon;
        $poly&minus;&gt;addPt(50,0);
        $poly&minus;&gt;addPt(99,99);
        $poly&minus;&gt;addPt(0,99);
        $myImage&minus;&gt;unclosedPolygon($poly,$blue);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;filledPolygon($poly,$color)</b></p>

<p style="margin-left:17%;">This draws a polygon filled
with the specified color. You can use a real color, or the
special fill color gdTiled to fill the polygon with a
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # make a polygon
        $poly = new GD::Polygon;
        $poly&minus;&gt;addPt(50,0);
        $poly&minus;&gt;addPt(99,99);
        $poly&minus;&gt;addPt(0,99);
        # draw the polygon, filling it with a color
        $myImage&minus;&gt;filledPolygon($poly,$peachpuff);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;ellipse($cx,$cy,$width,$height,$color)
<br>

$image&minus;&gt;filledEllipse($cx,$cy,$width,$height,$color)</b></p>

<p style="margin-left:17%;">These <i>methods()</i> draw
ellipses. ($cx,$cy) is the center of the arc, and
($width,$height) specify the ellipse width and height,
respectively. <i>filledEllipse()</i> is like
<i>Ellipse()</i> except that the former produces filled
versions of the ellipse.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;arc($cx,$cy,$width,$height,$start,$end,$color)</b></p>

<p style="margin-left:17%;">This draws arcs and ellipses.
(cx,cy) are the center of the arc, and (width,height)
specify the width and height, respectively. The portion of
the ellipse covered by the arc are controlled by start and
end, both of which are given in degrees from 0 to 360. Zero
is at the top of the ellipse, and angles increase clockwise.
To specify a complete ellipse, use 0 and 360 as the starting
and ending angles. To draw a circle, use the same value for
width and height.</p>

<p style="margin-left:17%; margin-top: 1em">You can specify
a normal color or one of the special colors
<b>gdBrushed</b>, <b>gdStyled</b>, or
<b>gdStyledBrushed</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # draw a semicircle centered at 100,100
        $myImage&minus;&gt;arc(100,100,50,50,0,180,$blue);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;filledArc($cx,$cy,$width,$height,$start,$end,$color
<br>
[,$arc_style])</b></p>

<p style="margin-left:17%;">This method is like
<i>arc()</i> except that it colors in the pie wedge with the
selected color. <tt>$arc_style</tt> is optional. If present
it is a bitwise <small>OR</small> of the following
constants:</p>

<pre style="margin-left:17%; margin-top: 1em">  gdArc           connect start &amp; end points of arc with a rounded edge
  gdChord         connect start &amp; end points of arc with a straight line
  gdPie           synonym for gdChord
  gdNoFill        outline the arc or chord
  gdEdged         connect beginning and ending of the arc to the center</pre>


<p style="margin-left:17%; margin-top: 1em">gdArc and
gdChord are mutually exclusive. gdChord just connects the
starting and ending angles with a straight line, while gdArc
produces a rounded edge. gdPie is a synonym for gdArc.
gdNoFill indicates that the arc or chord should be outlined,
not filled. gdEdged, used together with gdNoFill, indicates
that the beginning and ending angles should be connected to
the center; this is a good way to outline (rather than fill)
a &quot;pie slice.&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $image&minus;&gt;filledArc(100,100,50,50,0,90,$blue,gdEdged|gdNoFill);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;fill($x,$y,$color)</b></p>

<p style="margin-left:17%;">This method flood-fills regions
with the specified color. The color will spread through the
image, starting at point (x,y), until it is stopped by a
pixel of a different color from the starting pixel (this is
similar to the &quot;paintbucket&quot; in many popular
drawing toys). You can specify a normal color, or the
special color gdTiled, to flood-fill with patterns.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # Draw a rectangle, and then make its interior blue
        $myImage&minus;&gt;rectangle(10,10,100,100,$black);
        $myImage&minus;&gt;fill(50,50,$blue);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;fillToBorder($x,$y,$bordercolor,$color)</b></p>

<p style="margin-left:17%;">Like <tt>&quot;fill&quot;</tt>,
this method flood-fills regions with the specified color,
starting at position (x,y). However, instead of stopping
when it hits a pixel of a different color than the starting
pixel, flooding will only stop when it hits the color
specified by bordercolor. You must specify a normal indexed
color for the bordercolor. However, you are free to use the
gdTiled color for the fill.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        # This has the same effect as the previous example
        $myImage&minus;&gt;rectangle(10,10,100,100,$black);
        $myImage&minus;&gt;fillToBorder(50,50,$black,$blue);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Image
Copying Commands</b> <br>
Two methods are provided for copying a rectangular region
from one image to another. One method copies a region
without resizing it. The other allows you to stretch the
region during the copy operation.</p>

<p style="margin-left:11%; margin-top: 1em">With either of
these methods it is important to know that the routines will
attempt to flesh out the destination image&rsquo;s color
table to match the colors that are being copied from the
source. If the destination&rsquo;s color table is already
full, then the routines will attempt to find the best match,
with varying results. <b><br>
$image&minus;&gt;copy($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$width,$height)</b></p>

<p style="margin-left:17%; margin-top: 1em">This is the
simplest of the several copy operations, copying the
specified region from the source image to the destination
image (the one performing the method call). (srcX,srcY)
specify the upper left corner of a rectangle in the source
image, and (width,height) give the width and height of the
region to copy. (dstX,dstY) control where in the destination
image to stamp the copy. You can use the same image for both
the source and the destination, but the source and
destination regions must not overlap or strange things will
happen.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = new GD::Image(100,100);
        ... various drawing stuff ...
        $srcImage = new GD::Image(50,50);
        ... more drawing stuff ...
        # copy a 25x25 pixel region from $srcImage to
        # the rectangle starting at (10,10) in $myImage
        $myImage&minus;&gt;copy($srcImage,10,10,0,0,25,25);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;</b><b><i>clone()</i></b></p>

<p style="margin-left:17%;">Make a copy of the image and
return it as a new object. The new image will look
identical. However, it may differ in the size of the color
palette and other nonessential details.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = new GD::Image(100,100);
        ... various drawing stuff ...
        $copy = $myImage&minus;&gt;clone;</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;copyMerge($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$width,$height,$percent)</b></p>

<p style="margin-left:17%; margin-top: 1em">This copies the
indicated rectangle from the source image to the destination
image, merging the colors to the extent specified by percent
(an integer between 0 and 100). Specifying 100% has the same
effect as <i>copy()</i> -- replacing the destination pixels
with the source image. This is most useful for highlighting
an area by merging in a solid rectangle.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = new GD::Image(100,100);
        ... various drawing stuff ...
        $redImage = new GD::Image(50,50);
        ... more drawing stuff ...
        # copy a 25x25 pixel region from $srcImage to
        # the rectangle starting at (10,10) in $myImage, merging 50%
        $myImage&minus;&gt;copyMerge($srcImage,10,10,0,0,25,25,50);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;copyMergeGray($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$width,$height,$percent)</b></p>

<p style="margin-left:17%; margin-top: 1em">This is
identical to <i>copyMerge()</i> except that it preserves the
hue of the source by converting all the pixels of the
destination rectangle to grayscale before merging.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;copyResized($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$destW,$destH,$srcW,$srcH)</b></p>

<p style="margin-left:17%; margin-top: 1em">This method is
similar to <i>copy()</i> but allows you to choose different
sizes for the source and destination rectangles. The source
and destination rectangle&rsquo;s are specified
independently by (srcW,srcH) and (destW,destH) respectively.
<i>copyResized()</i> will stretch or shrink the image to
accommodate the size requirements.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage = new GD::Image(100,100);
        ... various drawing stuff ...
        $srcImage = new GD::Image(50,50);
        ... more drawing stuff ...
        # copy a 25x25 pixel region from $srcImage to
        # a larger rectangle starting at (10,10) in $myImage
        $myImage&minus;&gt;copyResized($srcImage,10,10,0,0,50,50,25,25);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;copyResampled($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$destW,$destH,$srcW,$srcH)</b></p>

<p style="margin-left:17%; margin-top: 1em">This method is
similar to <i>copyResized()</i> but provides
&quot;smooth&quot; copying from a large image to a smaller
one, using a weighted average of the pixels of the source
area rather than selecting one representative pixel. This
method is identical to <i>copyResized()</i> when the
destination image is a palette image.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;copyRotated($sourceImage,$dstX,$dstY,</b></p>


<p style="margin-left:17%;"><b>$srcX,$srcY,$width,$height,$angle)</b></p>

<p style="margin-left:17%; margin-top: 1em">Like
<i>copyResized()</i> but the <tt>$angle</tt> argument
specifies an arbitrary amount to rotate the image clockwise
(in degrees). In addition, <tt>$dstX</tt> and <tt>$dstY</tt>
species the <b>center</b> of the destination image, and not
the top left corner.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;trueColorToPalette([$dither],
[$colors])</b></p>

<p style="margin-left:17%;">This method converts a
truecolor image to a palette image. The code for this
function was originally drawn from the Independent
<small>JPEG</small> Group library code, which is excellent.
The code has been modified to preserve as much alpha channel
information as possible in the resulting palette, in
addition to preserving colors as well as possible. This does
not work as well as might be hoped. It is usually best to
simply produce a truecolor output image instead, which
guarantees the highest output quality. Both the dithering
(0/1, default=0) and maximum number of colors used
(&lt;=256, default = gdMaxColors) can be specified.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Image
Transformation Commands</b> <br>
Gd also provides some common image transformations: <b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyRotate90()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyRotate180()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyRotate270()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyFlipHorizontal()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyFlipVertical()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyTranspose()</i></b>
<b><br>
$image =</b>
<b><i>$sourceImage</i></b><b>&minus;&gt;</b><b><i>copyReverseTranspose()</i></b></p>

<p style="margin-left:17%;">These methods can be used to
rotate, flip, or transpose an image. The result of the
method is a copy of the image.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;</b><b><i>rotate180()</i></b>
<b><br>
$image&minus;&gt;</b><b><i>flipHorizontal()</i></b> <b><br>
$image&minus;&gt;</b><b><i>flipVertical()</i></b></p>

<p style="margin-left:17%;">These methods are similar to
the copy* versions, but instead modify the image in
place.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Character
and String Drawing</b> <small><br>
GD</small> allows you to draw characters and strings, either
in normal horizontal orientation or rotated 90 degrees.
These routines use a GD::Font object, described in more
detail below. There are four built-in monospaced fonts,
available in the global variables <b>gdGiantFont</b>,
<b>gdLargeFont</b>, <b>gdMediumBoldFont</b>,
<b>gdSmallFont</b> and <b>gdTinyFont</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
you can use the <i>load()</i> method to load GD-formatted
bitmap font files at runtime. You can create these bitmap
files from X11 BDF-format files using the bdf2gd.pl script,
which should have been installed with <small>GD</small> (see
the bdf_scripts directory if it wasn&rsquo;t). The format
happens to be identical to the old-style
<small>MSDOS</small> bitmap &quot;.fnt&quot; files, so you
can use one of those directly if you happen to have one.</p>

<p style="margin-left:11%; margin-top: 1em">For writing
proportional scaleable fonts, <small>GD</small> offers the
<i>stringFT()</i> method, which allows you to load and
render any TrueType font on your system. <b><br>
$image&minus;&gt;string($font,$x,$y,$string,$color)</b></p>

<p style="margin-left:17%;">This method draws a string
starting at position (x,y) in the specified font and color.
Your choices of fonts are gdSmallFont, gdMediumBoldFont,
gdTinyFont, gdLargeFont and gdGiantFont.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">        $myImage&minus;&gt;string(gdSmallFont,2,10,&quot;Peachy Keen&quot;,$peach);</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;stringUp($font,$x,$y,$string,$color)</b></p>

<p style="margin-left:17%;">Just like the previous call,
but draws the text rotated counterclockwise 90 degrees.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;char($font,$x,$y,$char,$color)
<br>
$image&minus;&gt;charUp($font,$x,$y,$char,$color)</b></p>

<p style="margin-left:17%;">These methods draw single
characters at position (x,y) in the specified font and
color. They&rsquo;re carry-overs from the C interface, where
there is a distinction between characters and strings. Perl
is insensible to such subtle distinctions.</p>

<p style="margin-left:11%;">$font =
<b>GD::Font&minus;&gt;load($fontfilepath)</b></p>

<p style="margin-left:17%;">This method dynamically loads a
font file, returning a font that you can use in subsequent
calls to drawing methods. For example:</p>

<pre style="margin-left:17%; margin-top: 1em">   my $courier = GD::Font&minus;&gt;load('./courierR12.fnt') or die &quot;Can't load font&quot;;
   $image&minus;&gt;string($courier,2,10,&quot;Peachy Keen&quot;,$peach);</pre>


<p style="margin-left:17%; margin-top: 1em">Font files must
be in <small>GD</small> binary format, as described
above.</p>

<p style="margin-left:11%;"><b>@bounds =</b> <b><i><br>

$image</i></b><b>&minus;&gt;stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)
<br>
@bounds = <br>

GD::Image&minus;&gt;stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)
<br>
@bounds =</b> <b><i><br>

$image</i></b><b>&minus;&gt;stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,\%options)</b></p>

<p style="margin-left:17%;">This method uses TrueType to
draw a scaled, antialiased string using the TrueType vector
font of your choice. It requires that libgd to have been
compiled with TrueType support, and for the appropriate
TrueType font to be installed on your system.</p>

<p style="margin-left:17%; margin-top: 1em">The arguments
are as follows:</p>

<pre style="margin-left:17%; margin-top: 1em">  fgcolor    Color index to draw the string in
  fontname   A path to the TrueType (.ttf) font file or a font pattern.
  ptsize     The desired point size (may be fractional)
  angle      The rotation angle, in radians (positive values rotate counter clockwise)
  x,y        X and Y coordinates to start drawing the string
  string     The string itself</pre>


<p style="margin-left:17%; margin-top: 1em">If successful,
the method returns an eight-element list giving the
boundaries of the rendered string:</p>

<pre style="margin-left:17%; margin-top: 1em"> @bounds[0,1]  Lower left corner (x,y)
 @bounds[2,3]  Lower right corner (x,y)
 @bounds[4,5]  Upper right corner (x,y)
 @bounds[6,7]  Upper left corner (x,y)</pre>


<p style="margin-left:17%; margin-top: 1em">In case of an
error (such as the font not being available, or
<small>FT</small> support not being available), the method
returns an empty list and sets $@ to the error message.</p>

<p style="margin-left:17%; margin-top: 1em">The string may
contain <small>UTF&minus;8</small> sequences like:
&quot;&amp;#192;&quot;</p>

<p style="margin-left:17%; margin-top: 1em">You may also
call this method from the GD::Image class name, in which
case it doesn&rsquo;t do any actual drawing, but returns the
bounding box using an inexpensive operation. You can use
this to perform layout operations prior to drawing.</p>

<p style="margin-left:17%; margin-top: 1em">Using a
negative color index will disable antialiasing, as described
in the libgd manual page at
&lt;http://www.boutell.com/gd/manual2.0.9.html#gdImageStringFT&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">An optional 8th
argument allows you to pass a hashref of options to
<i>stringFT()</i>. Several hashkeys are recognized:
<b>linespacing</b>, <b>charmap</b>, <b>resolution</b>, and
<b>kerning</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The value of
<b>linespacing</b> is supposed to be a multiple of the
character height, so setting linespacing to 2.0 will result
in double-spaced lines of text. However the current version
of libgd (2.0.12) does not do this. Instead the linespacing
seems to be double what is provided in this argument. So use
a spacing of 0.5 to get separation of exactly one line of
text. In practice, a spacing of 0.6 seems to give nice
results. Another thing to watch out for is that successive
lines of text should be separated by the &quot;\r\n&quot;
characters, not just &quot;\n&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The value of
<b>charmap</b> is one of &quot;Unicode&quot;,
&quot;Shift_JIS&quot; and &quot;Big5&quot;. The interaction
between Perl, Unicode and libgd is not clear to me, and you
should experiment a bit if you want to use this feature.</p>

<p style="margin-left:17%; margin-top: 1em">The value of
<b>resolution</b> is the vertical and horizontal resolution,
in <small>DPI,</small> in the format &quot;hdpi,vdpi&quot;.
If present, the resolution will be passed to the Freetype
rendering engine as a hint to improve the appearance of the
rendered font.</p>

<p style="margin-left:17%; margin-top: 1em">The value of
<b>kerning</b> is a flag. Set it to false to turn off the
default kerning of text.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em"> $gd&minus;&gt;stringFT($black,'/dosc/windows/Fonts/pala.ttf',40,0,20,90,
              &quot;hi there\r\nbye now&quot;,
              {linespacing=&gt;0.6,
               charmap  =&gt; 'Unicode',
              });</pre>


<p style="margin-left:17%; margin-top: 1em">If
<small>GD</small> was compiled with fontconfig support, and
the fontconfig library is available on your system, then you
can use a font name pattern instead of a path. Patterns are
described in fontconfig and will look something like this
&quot;Times:italic&quot;. For backward compatibility, this
feature is disabled by default. You must enable it by
calling <i>useFontConfig</i>(1) prior to the
<i>stringFT()</i> call.</p>

<pre style="margin-left:17%; margin-top: 1em">   $image&minus;&gt;useFontConfig(1);</pre>


<p style="margin-left:17%; margin-top: 1em">For backward
compatibility with older versions of the FreeType library,
the alias <i>stringTTF()</i> is also recognized.</p>

<p style="margin-left:11%;"><b>$hasfontconfig =</b>
<b><i>$image</i></b><b>&minus;&gt;useFontConfig($flag)</b></p>

<p style="margin-left:17%;">Call <i>useFontConfig()</i>
with a value of 1 in order to enable support for fontconfig
font patterns (see stringFT). Regardless of the value of
<tt>$flag</tt>, this method will return a true value if the
fontconfig library is present, or false otherwise.</p>

<p style="margin-left:11%;"><b>$result =</b> <b><i><br>

$image</i></b><b>&minus;</b>stringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)&gt;</p>

<p style="margin-left:17%;">This draws text in a circle.
Currently (libgd 2.0.33) this function does not work for me,
but the interface is provided for completeness. The call
signature is somewhat complex. Here is an excerpt from the
libgd manual page:</p>

<p style="margin-left:17%; margin-top: 1em">Draws the text
strings specified by top and bottom on the image, curved
along the edge of a circle of radius radius, with its center
at cx and cy. top is written clockwise along the top; bottom
is written counterclockwise along the bottom. textRadius
determines the &quot;height&quot; of each character; if
textRadius is 1/2 of radius, characters extend halfway from
the edge to the center. fillPortion varies from 0 to 1.0,
with useful values from about 0.4 to 0.9, and determines how
much of the 180 degrees of arc assigned to each section of
text is actually occupied by text; 0.9 looks better than 1.0
which is rather crowded. font is a freetype font; see
gdImageStringFT. points is passed to the freetype engine and
has an effect on hinting; although the size of the text is
determined by radius, textRadius, and fillPortion, you
should pass a point size that &quot;hints&quot;
appropriately -- if you know the text will be large, pass a
large point size such as 24.0 to get the best results.
fgcolor can be any color, and may have an alpha component,
do blending, etc.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a true
value on success.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Alpha
channels</b> <br>
The alpha channel methods allow you to control the way
drawings are processed according to the alpha channel. When
true color is turned on, colors are encoded as four bytes,
in which the last three bytes are the <small>RGB</small>
color values, and the first byte is the alpha channel.
Therefore the hexadecimal representation of a non
transparent <small>RGB</small> color will be:
C=0x00(rr)(bb)(bb)</p>

<p style="margin-left:11%; margin-top: 1em">When alpha
blending is turned on, you can use the first byte of the
color to control the transparency, meaning that a rectangle
painted with color 0x00(rr)(bb)(bb) will be opaque, and
another one painted with 0x7f(rr)(gg)(bb) will be
transparent. The Alpha value must be &gt;= 0 and &lt;= 0x7f.
<b><br>
$image&minus;&gt;alphaBlending($integer)</b></p>

<p style="margin-left:17%;">The <i>alphaBlending()</i>
method allows for two different modes of drawing on
truecolor images. In blending mode, which is on by default
(libgd 2.0.2 and above), the alpha channel component of the
color supplied to all drawing functions, such as
<tt>&quot;setPixel&quot;</tt>, determines how much of the
underlying color should be allowed to shine through. As a
result, <small>GD</small> automatically blends the existing
color at that point with the drawing color, and stores the
result in the image. The resulting pixel is opaque. In
non-blending mode, the drawing color is copied literally
with its alpha channel information, replacing the
destination pixel. Blending mode is not available when
drawing on palette images.</p>

<p style="margin-left:17%; margin-top: 1em">Pass a value of
1 for blending mode, and 0 for non-blending mode.</p>


<p style="margin-left:11%;"><b>$image&minus;&gt;saveAlpha($saveAlpha)</b></p>

<p style="margin-left:17%;">By default, <small>GD</small>
(libgd 2.0.2 and above) does not attempt to save full alpha
channel information (as opposed to single-color
transparency) when saving <small>PNG</small> images. (
<small>PNG</small> is currently the only output format
supported by gd which can accommodate alpha channel
information.) This saves space in the output file. If you
wish to create an image with alpha channel information for
use with tools that support it, call <tt>saveAlpha(1)</tt>
to turn on saving of such information, and call
<tt>alphaBlending(0)</tt> to turn off alpha blending within
the library so that alpha channel information is actually
stored in the image rather than being composited immediately
at the time that drawing functions are invoked.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous
Image Methods</b> <br>
These are various utility methods that are useful in some
circumstances. <b><br>
$image&minus;&gt;interlaced([$flag])</b></p>

<p style="margin-left:17%;">This method sets or queries the
image&rsquo;s interlaced setting. Interlace produces a cool
venetian blinds effect on certain viewers. Provide a true
parameter to set the interlace attribute. Provide undef to
disable it. Call the method without parameters to find out
the current setting.</p>

<p style="margin-left:11%;"><b>($width,$height) =
$image&minus;&gt;</b><b><i>getBounds()</i></b></p>

<p style="margin-left:17%;">This method will return a
two-member list containing the width and height of the
image. You query but not change the size of the image once
it&rsquo;s created.</p>

<p style="margin-left:11%;"><b>$width =</b>
<b><i>$image</i></b><b>&minus;&gt;width <br>
$height =</b>
<b><i>$image</i></b><b>&minus;&gt;height</b></p>

<p style="margin-left:17%;">Return the width and height of
the image, respectively.</p>

<p style="margin-left:11%;"><b>$is_truecolor =</b>
<b><i>$image</i></b><b>&minus;&gt;</b><b><i>isTrueColor()</i></b></p>

<p style="margin-left:17%;">This method will return a
Boolean representing whether the image is true color or
not.</p>

<p style="margin-left:11%;"><b>$flag =</b>
<b><i>$image1</i></b><b>&minus;&gt;compare($image2)</b></p>

<p style="margin-left:17%;">Compare two images and return a
bitmap describing the differences found, if any. The return
value must be logically ANDed with one or more constants in
order to determine the differences. The following constants
are available:</p>

<pre style="margin-left:17%; margin-top: 1em">  GD_CMP_IMAGE             The two images look different
  GD_CMP_NUM_COLORS        The two images have different numbers of colors
  GD_CMP_COLOR             The two images' palettes differ
  GD_CMP_SIZE_X            The two images differ in the horizontal dimension
  GD_CMP_SIZE_Y            The two images differ in the vertical dimension
  GD_CMP_TRANSPARENT       The two images have different transparency
  GD_CMP_BACKGROUND        The two images have different background colors
  GD_CMP_INTERLACE         The two images differ in their interlace
  GD_CMP_TRUECOLOR         The two images are not both true color</pre>


<p style="margin-left:17%; margin-top: 1em">The most
important of these is <small>GD_CMP_IMAGE,</small> which
will tell you whether the two images will look different,
ignoring differences in the order of colors in the color
palette and other invisible changes. The constants are not
imported by default, but must be imported individually or by
importing the :cmp tag. Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  use GD qw(:DEFAULT :cmp);
  # get $image1 from somewhere
  # get $image2 from somewhere
  if ($image1&minus;&gt;compare($image2) &amp; GD_CMP_IMAGE) {
     warn &quot;images differ!&quot;;
  }</pre>



<p style="margin-left:11%;"><b>$image&minus;&gt;clip($x1,$y1,$x2,$y2)
<br>
($x1,$y1,$x2,$y2) = $image&minus;&gt;clip</b></p>

<p style="margin-left:17%;">Set or get the clipping
rectangle. When the clipping rectangle is set, all drawing
will be clipped to occur within this rectangle. The clipping
rectangle is initially set to be equal to the boundaries of
the whole image. Change it by calling <i>clip()</i> with the
coordinates of the new clipping rectangle. Calling
<i>clip()</i> without any arguments will return the current
clipping rectangle.</p>

<p style="margin-left:11%;"><b>$flag =</b>
<b><i>$image</i></b><b>&minus;&gt;boundsSafe($x,$y)</b></p>

<p style="margin-left:17%;">The <i>boundsSafe()</i> method
will return true if the point indicated by ($x,$y) is within
the clipping rectangle, or false if it is not. If the
clipping rectangle has not been set, then it will return
true if the point lies within the image boundaries.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Grouping
Methods</b> <small><br>
GD</small> does not support grouping of objects, but
<small>GD::SVG</small> does. In that subclass, the following
methods declare new groups of graphical objects: <br>
$image&minus;&gt;startGroup([$id,\%style]) <br>
$image&minus;&gt;<i>endGroup()</i> <br>
$group = $image&minus;&gt;newGroup</p>

<p style="margin-left:17%;">See <small>GD::SVG</small> for
information.</p>

<h2>Polygons
<a name="Polygons"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A few primitive
polygon creation and manipulation methods are provided. They
aren&rsquo;t part of the Gd library, but I thought they
might be handy to have around (they&rsquo;re borrowed from
my qd.pl Quickdraw library). Also see GD::Polyline. <b><br>
$poly = GD::Polygon&minus;&gt;new</b></p>

<p style="margin-left:15%;">Create an empty polygon with no
vertices.</p>

<pre style="margin-left:15%; margin-top: 1em">        $poly = new GD::Polygon;</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;addPt($x,$y)</b></p>

<p style="margin-left:15%;">Add point (x,y) to the
polygon.</p>

<pre style="margin-left:15%; margin-top: 1em">        $poly&minus;&gt;addPt(0,0);
        $poly&minus;&gt;addPt(0,50);
        $poly&minus;&gt;addPt(25,25);
        $myImage&minus;&gt;fillPoly($poly,$blue);</pre>


<p style="margin-left:11%;"><b>($x,$y) =
$poly&minus;&gt;getPt($index)</b></p>

<p style="margin-left:15%;">Retrieve the point at the
specified vertex.</p>

<pre style="margin-left:15%; margin-top: 1em">        ($x,$y) = $poly&minus;&gt;getPt(2);</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;setPt($index,$x,$y)</b></p>

<p style="margin-left:15%;">Change the value of an already
existing vertex. It is an error to set a vertex that
isn&rsquo;t already defined.</p>

<pre style="margin-left:15%; margin-top: 1em">        $poly&minus;&gt;setPt(2,100,100);</pre>


<p style="margin-left:11%;"><b>($x,$y) =
$poly&minus;&gt;deletePt($index)</b></p>

<p style="margin-left:15%;">Delete the specified vertex,
returning its value.</p>

<pre style="margin-left:15%; margin-top: 1em">        ($x,$y) = $poly&minus;&gt;deletePt(1);</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;</b><b><i>clear()</i></b></p>

<p style="margin-left:15%;">Delete all vertices, restoring
the polygon to its initial empty state.</p>


<p style="margin-left:11%;"><b>$poly&minus;&gt;toPt($dx,$dy)</b></p>

<p style="margin-left:15%;">Draw from current vertex to a
new vertex, using relative (dx,dy) coordinates. If this is
the first point, act like <i>addPt()</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">        $poly&minus;&gt;addPt(0,0);
        $poly&minus;&gt;toPt(0,50);
        $poly&minus;&gt;toPt(25,&minus;25);
        $myImage&minus;&gt;fillPoly($poly,$blue);</pre>


<p style="margin-left:11%;"><b>$vertex_count =</b>
<b><i>$poly</i></b><b>&minus;&gt;length</b></p>

<p style="margin-left:15%;">Return the number of vertices
in the polygon.</p>

<pre style="margin-left:15%; margin-top: 1em">        $points = $poly&minus;&gt;length;</pre>


<p style="margin-left:11%;"><b>@vertices =</b>
<b><i>$poly</i></b><b>&minus;&gt;vertices</b></p>

<p style="margin-left:15%;">Return a list of all the
vertices in the polygon object. Each member of the list is a
reference to an (x,y) array.</p>

<pre style="margin-left:15%; margin-top: 1em">        @vertices = $poly&minus;&gt;vertices;
        foreach $v (@vertices)
           print join(&quot;,&quot;,@$v),&quot;\n&quot;;
        }</pre>


<p style="margin-left:11%;"><b>@rect =</b>
<b><i>$poly</i></b><b>&minus;&gt;bounds</b></p>

<p style="margin-left:15%;">Return the smallest rectangle
that completely encloses the polygon. The return value is an
array containing the (left,top,right,bottom) of the
rectangle.</p>

<pre style="margin-left:15%; margin-top: 1em">        ($left,$top,$right,$bottom) = $poly&minus;&gt;bounds;</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;offset($dx,$dy)</b></p>

<p style="margin-left:15%;">Offset all the vertices of the
polygon by the specified horizontal (dh) and vertical (dy)
amounts. Positive numbers move the polygon down and to the
right.</p>

<pre style="margin-left:15%; margin-top: 1em">        $poly&minus;&gt;offset(10,30);</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)</b></p>

<p style="margin-left:15%;">Map the polygon from a source
rectangle to an equivalent position in a destination
rectangle, moving it and resizing it as necessary. See
polys.pl for an example of how this works. Both the source
and destination rectangles are given in
(left,top,right,bottom) coordinates. For convenience, you
can use the polygon&rsquo;s own bounding box as the source
rectangle.</p>

<pre style="margin-left:15%; margin-top: 1em">        # Make the polygon really tall
        $poly&minus;&gt;map($poly&minus;&gt;bounds,0,0,50,200);</pre>



<p style="margin-left:11%;"><b>$poly&minus;&gt;scale($sx,$sy)</b></p>

<p style="margin-left:15%;">Scale each vertex of the
polygon by the X and Y factors indicated by sx and sy. For
example scale(2,2) will make the polygon twice as large. For
best results, move the center of the polygon to position
(0,0) before you scale, then move it back to its previous
position.</p>


<p style="margin-left:11%;"><b>$poly&minus;&gt;transform($sx,$rx,$sy,$ry,$tx,$ty)</b></p>

<p style="margin-left:15%;">Run each vertex of the polygon
through a transformation matrix, where sx and sy are the X
and Y scaling factors, rx and ry are the X and Y rotation
factors, and tx and ty are X and Y offsets. See the Adobe
PostScript Reference, page 154 for a full explanation, or
experiment.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GD::Polyline</b>
<br>
Please see GD::Polyline for information on creating open
polygons and splines.</p>

<h2>Font Utilities
<a name="Font Utilities"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The libgd
library (used by the Perl <small>GD</small> library) has
built-in support for about half a dozen fonts, which were
converted from public-domain X Windows fonts. For more
fonts, compile libgd with TrueType support and use the
<i>stringFT()</i> call.</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
add more built-in fonts, the directory bdf_scripts contains
two contributed utilities that may help you convert
X&minus;Windows BDF-format fonts into the format that libgd
uses internally. However these scripts were written for
earlier versions of <small>GD</small> which included its own
mini-gd library. These scripts will have to be adapted for
use with libgd, and the libgd library itself will have to be
recompiled and linked! Please do not contact me for help
with these scripts: they are unsupported.</p>

<p style="margin-left:11%; margin-top: 1em">Each of these
fonts is available both as an imported global (e.g.
<b>gdSmallFont</b>) and as a package method (e.g.
<b>GD::Font&minus;&gt;Small</b>). <b><br>
gdSmallFont <br>
GD::Font&minus;&gt;Small</b></p>

<p style="margin-left:18%;">This is the basic small font,
&quot;borrowed&quot; from a well known public domain 6x12
font.</p>

<p style="margin-left:11%;"><b>gdLargeFont <br>
GD::Font&minus;&gt;Large</b></p>

<p style="margin-left:18%;">This is the basic large font,
&quot;borrowed&quot; from a well known public domain 8x16
font.</p>

<p style="margin-left:11%;"><b>gdMediumBoldFont <br>
GD::Font&minus;&gt;MediumBold</b></p>

<p style="margin-left:18%;">This is a bold font
intermediate in size between the small and large fonts,
borrowed from a public domain 7x13 font;</p>

<p style="margin-left:11%;"><b>gdTinyFont <br>
GD::Font&minus;&gt;Tiny</b></p>

<p style="margin-left:18%;">This is a tiny, almost
unreadable font, 5x8 pixels wide.</p>

<p style="margin-left:11%;"><b>gdGiantFont <br>
GD::Font&minus;&gt;Giant</b></p>

<p style="margin-left:18%;">This is a 9x15 bold font
converted by Jan Pazdziora from a sans serif X11 font.</p>


<p style="margin-left:11%;"><b>$font&minus;&gt;nchars</b></p>

<p style="margin-left:18%;">This returns the number of
characters in the font.</p>

<pre style="margin-left:18%; margin-top: 1em">        print &quot;The large font contains &quot;,gdLargeFont&minus;&gt;nchars,&quot; characters\n&quot;;</pre>



<p style="margin-left:11%;"><b>$font&minus;&gt;offset</b></p>

<p style="margin-left:18%;">This returns the
<small>ASCII</small> value of the first character in the
font</p>

<p style="margin-left:11%;"><b>$width =</b>
<b><i>$font</i></b><b>&minus;&gt;width <br>
$height =</b> <b><i>$font</i></b><b>&minus;&gt;height</b>
<br>
&quot;height&quot;</p>

<p style="margin-left:18%;">These return the width and
height of the font.</p>

<pre style="margin-left:18%; margin-top: 1em">  ($w,$h) = (gdLargeFont&minus;&gt;width,gdLargeFont&minus;&gt;height);</pre>


<h2>Obtaining the C&minus;language version of gd
<a name="Obtaining the C&minus;language version of gd"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libgd, the
C&minus;language version of gd, can be obtained at
<small>URL</small> http://www.boutell.com/gd/. Directions
for installing and using it can be found at that site.
Please do not contact me for help with libgd.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>GD</small> .pm interface is copyright
1995&minus;2010, Lincoln D. Stein. This package and its
accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the
<small>GPL</small> (either version 1, or at your option, any
later version) or the Artistic License 2.0. Refer to
<small>LICENSE</small> for the full license text. package
for details.</p>

<p style="margin-left:11%; margin-top: 1em">The latest
versions of <small>GD</small> .pm are available at</p>

<pre style="margin-left:11%; margin-top: 1em">  http://stein.cshl.org/WWW/software/GD</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GD::Polyline,
<small>GD::SVG</small> , GD::Simple, Image::Magick</p>

<h2>POD ERRORS
<a name="POD ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hey! <b>The
above document had some coding errors, which are explained
below:</b> <br>
Around line 463:</p>

<p style="margin-left:17%;">You forgot a
&rsquo;=back&rsquo; before &rsquo;=head1&rsquo;</p>

<p style="margin-left:11%;">Around line 475:</p>

<p style="margin-left:17%;">&rsquo;=item&rsquo; outside of
any &rsquo;=over&rsquo;</p>
<hr>
</body>
</html>
