<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov  5 22:01:33 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DOCKER</title>

</head>
<body>

<h1 align="center">DOCKER</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#Building an image using a Dockerfile located inside the current directory">Building an image using a Dockerfile located inside the current directory</a><br>
<a href="#Building an image and naming that image">Building an image and naming that image</a><br>
<a href="#Building an image using a URL">Building an image using a URL</a><br>
<a href="#Building an image using a URL to a tarball&rsquo;ed context">Building an image using a URL to a tarball&rsquo;ed context</a><br>
<a href="#HISTORY">HISTORY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">docker&minus;build
&minus; Build a new image from the source code at PATH</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>docker
build</b> [<b>&minus;&minus;build&minus;arg</b>[=<i>[]</i>]]
[<b>&minus;&minus;cpu&minus;shares</b>[=<i>0</i>]]
[<b>&minus;&minus;cgroup&minus;parent</b>[=<i>CGROUP&minus;PARENT</i>]]
[<b>&minus;&minus;help</b>]
[<b>&minus;f</b>|<b>&minus;&minus;file</b>[=<i>PATH/Dockerfile</i>]]
[<b>&minus;&minus;force&minus;rm</b>[=<i>false</i>]]
[<b>&minus;&minus;no&minus;cache</b>[=<i>false</i>]]
[<b>&minus;&minus;pull</b>[=<i>false</i>]]
[<b>&minus;q</b>|<b>&minus;&minus;quiet</b>[=<i>false</i>]]
[<b>&minus;&minus;rm</b>[=<i>true</i>]]
[<b>&minus;t</b>|<b>&minus;&minus;tag</b>[=<i>TAG</i>]]
[<b>&minus;m</b>|<b>&minus;&minus;memory</b>[=<i>MEMORY</i>]]
[<b>&minus;&minus;memory&minus;swap</b>[=<i>MEMORY&minus;SWAP</i>]]
[<b>&minus;&minus;cpu&minus;period</b>[=<i>0</i>]]
[<b>&minus;&minus;cpu&minus;quota</b>[=<i>0</i>]]
[<b>&minus;&minus;cpuset&minus;cpus</b>[=<i>CPUSET&minus;CPUS</i>]]
[<b>&minus;&minus;cpuset&minus;mems</b>[=<i>CPUSET&minus;MEMS</i>]]
[<b>&minus;&minus;ulimit</b>[=<i>[]</i>]] PATH | URL |
&minus;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This will read
the Dockerfile from the directory specified in <b>PATH</b>.
It also sends any other files and directories found in the
current directory to the Docker daemon. The contents of this
directory would be used by <b>ADD</b> commands found within
the Dockerfile.</p>

<p style="margin-left:11%; margin-top: 1em">Warning, this
will send a lot of data to the Docker daemon depending on
the contents of the current directory. The build is run by
the Docker daemon, not by the CLI, so the whole context must
be transferred to the daemon. The Docker CLI reports
&quot;Sending build context to Docker daemon&quot; when the
context is sent to the daemon.</p>

<p style="margin-left:11%; margin-top: 1em">When the URL to
a tarball archive or to a single Dockerfile is given, no
context is sent from the client to the Docker daemon. In
this case, the Dockerfile at the root of the archive and the
rest of the archive will get used as the context of the
build. When a Git repository is set as the <b>URL</b>, the
repository is cloned locally and then sent as the
context.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;f</b>,
<b>&minus;&minus;file</b>=<i>PATH/Dockerfile</i> <br>
Path to the Dockerfile to use. If the path is a relative
path and you are <br>
building from a local directory, then the path must be
relative to that <br>
directory. If you are building from a remote URL pointing to
either a <br>
tarball or a Git repository, then the path must be relative
to the root of <br>
the remote context. In all cases, the file must be within
the build context. <br>
The default is <i>Dockerfile</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;build&minus;arg</b>=<i>variable</i>
<br>
name and value of a <b>buildarg</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
you want to pass a value for <tt>http_proxy</tt>, use
<tt><br>

&minus;&minus;build&minus;arg=http_proxy=&quot;http://some.proxy.url&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Users pass
these values at build&minus;time. Docker uses the
<tt>buildargs</tt> as the <br>
environment context for command(s) run via the
Dockerfile&rsquo;s <tt>RUN</tt> instruction <br>
or for variable expansion in other Dockerfile instructions.
This is not meant <br>
for passing secret values. &lang;
/reference/builder/#arg&rang;</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;force&minus;rm</b>=<i>true</i>|<i>false</i>
<br>
Always remove intermediate containers, even after
unsuccessful builds. The default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;no&minus;cache</b>=<i>true</i>|<i>false</i>
<br>
Do not use cache when building the image. The default is
<i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help</b>
<br>
Print usage statement</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;pull</b>=<i>true</i>|<i>false</i>
<br>
Always attempt to pull a newer version of the image. The
default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;q</b>,
<b>&minus;&minus;quiet</b>=<i>true</i>|<i>false</i> <br>
Suppress the verbose output generated by the containers. The
default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;rm</b>=<i>true</i>|<i>false</i>
<br>
Remove intermediate containers after a successful build. The
default is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;tag</b>=&quot;&quot; <br>
Repository name (and optionally a tag) to be applied to the
resulting image in case of success</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;m</b>,
<b>&minus;&minus;memory</b>=<i>MEMORY</i> <br>
Memory limit</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;memory&minus;swap</b>=<i>MEMORY&minus;SWAP</i>
<br>
Total memory (memory + swap), &rsquo;&minus;1&rsquo; to
disable swap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;shares</b>=<i>0</i>
<br>
CPU shares (relative weight).</p>

<p style="margin-left:11%; margin-top: 1em">By default, all
containers get the same proportion of CPU cycles. <br>
CPU shares is a &rsquo;relative weight&rsquo;, relative to
the default setting of 1024. <br>
This default value is defined here:</p>

<p style="margin-left:22%; margin-top: 1em">cat
/sys/fs/cgroup/cpu/cpu.shares <br>
1024</p>

<p style="margin-left:11%; margin-top: 1em">You can change
this proportion by adjusting the container&rsquo;s CPU share
<br>
weighting relative to the weighting of all other running
containers.</p>

<p style="margin-left:11%; margin-top: 1em">To modify the
proportion from the default of 1024, use the
<b>&minus;&minus;cpu&minus;shares</b> <br>
flag to set the weighting to 2 or higher.</p>

<p style="margin-left:22%; margin-top: 1em">Container CPU
share Flag <br>
{C0} 60% of CPU &minus;&minus;cpu&minus;shares=614 (614 is
60% of 1024) <br>
{C1} 40% of CPU &minus;&minus;cpu&minus;shares=410 (410 is
40% of 1024)</p>

<p style="margin-left:11%; margin-top: 1em">The proportion
is only applied when CPU&minus;intensive processes are
running. <br>
When tasks in one container are idle, the other containers
can use the <br>
left&minus;over CPU time. The actual amount of CPU time used
varies depending on <br>
the number of containers running on the system.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider three containers, where one has
<b>&minus;&minus;cpu&minus;shares=1024</b> and <br>
two others have <b>&minus;&minus;cpu&minus;shares=512</b>.
When processes in all three <br>
containers attempt to use 100% of CPU, the first container
would receive <br>
50% of the total CPU time. If you add a fourth container
with <b>&minus;&minus;cpu&minus;shares=1024</b>, <br>
the first container only gets 33% of the CPU. The remaining
containers <br>
receive 16.5%, 16.5% and 33% of the CPU.</p>

<p style="margin-left:22%; margin-top: 1em">Container CPU
share Flag CPU time <br>
{C0} 100% &minus;&minus;cpu&minus;shares=1024 33% <br>
{C1} 50% &minus;&minus;cpu&minus;shares=512 16.5% <br>
{C2} 50% &minus;&minus;cpu&minus;shares=512 16.5% <br>
{C4} 100% &minus;&minus;cpu&minus;shares=1024 33%</p>

<p style="margin-left:11%; margin-top: 1em">On a
multi&minus;core system, the shares of CPU time are
distributed across the CPU <br>
cores. Even if a container is limited to less than 100% of
CPU time, it can <br>
use 100% of each individual CPU core.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider a system with more than three cores. If you start
one <br>
container <b>{C0}</b> with
<b>&minus;&minus;cpu&minus;shares=512</b> running one
process, and another container <b><br>
{C1}</b> with <b>&minus;&minus;cpu&minus;shares=1024</b>
running two processes, this can result in the following <br>
division of CPU shares:</p>

<p style="margin-left:22%; margin-top: 1em">PID container
CPU CPU share <br>
100 {C0} 0 100% of CPU0 <br>
101 {C1} 1 100% of CPU1 <br>
102 {C1} 2 100% of CPU2</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;period</b>=<i>0</i>
<br>
Limit the CPU CFS (Completely Fair Scheduler) period.</p>

<p style="margin-left:11%; margin-top: 1em">Limit the
container&rsquo;s CPU usage. This flag causes the kernel to
restrict the <br>
container&rsquo;s CPU usage to the period you specify.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpu&minus;quota</b>=<i>0</i>
<br>
Limit the CPU CFS (Completely Fair Scheduler) quota.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
containers run with the full CPU resource. This flag causes
the kernel to restrict the container&rsquo;s CPU usage to
the quota you specify.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpuset&minus;cpus</b>=<i>CPUSET&minus;CPUS</i>
<br>
CPUs in which to allow execution (0&minus;3, 0,1).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cpuset&minus;mems</b>=<i>CPUSET&minus;MEMS</i>
<br>
Memory nodes (MEMs) in which to allow execution (0&minus;3,
0,1). Only effective on <br>
NUMA systems.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
you have four memory nodes on your system (0&minus;3), use
<tt>&minus;&minus;cpuset&minus;mems=0,1</tt> to ensure the
processes in your Docker container only use memory from the
first two memory nodes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;cgroup&minus;parent</b>=<i>CGROUP&minus;PARENT</i>
<br>
Path to <tt>cgroups</tt> under which the container&rsquo;s
<tt>cgroup</tt> are created.</p>

<p style="margin-left:11%; margin-top: 1em">If the path is
not absolute, the path is considered relative to the
<tt>cgroups</tt> path of the init process. Cgroups are
created if they do not already exist.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ulimit</b>=[]
<br>
Ulimit options</p>

<p style="margin-left:11%; margin-top: 1em">For more
information about <tt>ulimit</tt> see &lang;
https://docs.docker.com/reference/commandline/run/#setting-ulimits-in-a-container&rang;</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<h2>Building an image using a Dockerfile located inside the current directory
<a name="Building an image using a Dockerfile located inside the current directory"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Docker images
can be built using the build command and a Dockerfile:</p>

<p style="margin-left:22%; margin-top: 1em">docker build
.</p>

<p style="margin-left:11%; margin-top: 1em">During the
build process Docker creates intermediate images. In order
to keep them, you must explicitly set
<tt>&minus;&minus;rm=false</tt>.</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;&minus;rm=false .</p>

<p style="margin-left:11%; margin-top: 1em">A good practice
is to make a sub&minus;directory with a related name and
create the Dockerfile in that directory. For example, a
directory called mongo may contain a Dockerfile to create a
Docker MongoDB image. Likewise, another directory called
httpd may be used to store Dockerfiles for Apache web server
images.</p>

<p style="margin-left:11%; margin-top: 1em">It is also a
good practice to add the files required for the image to the
sub&minus;directory. These files will then be specified with
the <tt>COPY</tt> or <tt>ADD</tt> instructions in the
<tt>Dockerfile</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Note: If you
include a tar file (a good practice), then Docker will
automatically extract the contents of the tar file specified
within the <tt>ADD</tt> instruction into the specified
target.</p>

<h2>Building an image and naming that image
<a name="Building an image and naming that image"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A good practice
is to give a name to the image you are building. Note that
only a&minus;z0&minus;9&minus;_. should be used for
consistency. There are no hard rules here but it is best to
give the names consideration.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;t</b>/<b>&minus;&minus;tag</b> flag is used to
rename an image. Here are some examples:</p>

<p style="margin-left:11%; margin-top: 1em">Though it is
not a good practice, image names can be arbitrary:</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;t myimage .</p>

<p style="margin-left:11%; margin-top: 1em">A better
approach is to provide a fully qualified and meaningful
repository, name, and tag (where the tag in this context
means the qualifier after the &quot;:&quot;). In this
example we build a JBoss image for the Fedora repository and
give it the version 1.0:</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;t fedora/jboss:1.0 .</p>

<p style="margin-left:11%; margin-top: 1em">The next
example is for the &quot;whenry&quot; user repository and
uses Fedora and JBoss and gives it the version 2.1 :</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;t whenry/fedora&minus;jboss:v2.1 .</p>

<p style="margin-left:11%; margin-top: 1em">If you do not
provide a version tag then Docker will assign
<tt>latest</tt>:</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;t whenry/fedora&minus;jboss .</p>

<p style="margin-left:11%; margin-top: 1em">When you list
the images, the image above will have the tag
<tt>latest</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">So renaming an
image is arbitrary but consideration should be given to a
useful convention that makes sense for consumers and should
also take into account Docker community conventions.</p>

<h2>Building an image using a URL
<a name="Building an image using a URL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This will clone
the specified GitHub repository from the URL and use it as
context. The Dockerfile at the root of the repository is
used as Dockerfile. This only works if the GitHub repository
is a dedicated repository.</p>

<p style="margin-left:22%; margin-top: 1em">docker build
github.com/scollier/purpletest</p>

<p style="margin-left:11%; margin-top: 1em">Note: You can
set an arbitrary Git repository via the <tt>git://</tt>
schema.</p>

<h2>Building an image using a URL to a tarball&rsquo;ed context
<a name="Building an image using a URL to a tarball&rsquo;ed context"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This will send
the URL itself to the Docker daemon. The daemon will fetch
the tarball archive, decompress it and use its contents as
the build context. The Dockerfile at the root of the archive
and the rest of the archive will get used as the context of
the build. If you pass an <b>&minus;f PATH/Dockerfile</b>
option as well, the system will look for that file inside
the contents of the tarball.</p>

<p style="margin-left:22%; margin-top: 1em">docker build
&minus;f dev/Dockerfile
https://10.10.10.1/docker/context.tar.gz</p>

<p style="margin-left:11%; margin-top: 1em">Note: supported
compression formats are &rsquo;xz&rsquo;,
&rsquo;bzip2&rsquo;, &rsquo;gzip&rsquo; and
&rsquo;identity&rsquo; (no compression).</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">March 2014,
Originally compiled by William Henry (whenry at redhat dot
com) based on docker.com source material and internal work.
June 2014, updated by Sven Dowideit &lang;
SvenDowideit@home.org.au&rang; June 2015, updated by Sally
O&rsquo;Malley &lang; somalley@redhat.com&rang;</p>
<hr>
</body>
</html>
