<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 02:02:25 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>NFS_UTIL</title>

</head>
<body>

<h1 align="center">NFS_UTIL</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CLASSES">CLASSES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">nfstest.nfs_util
- NFS utilities module</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Provides a set
of tools for testing NFS including methods for starting a
packet trace, stopping the packet trace and then open the
packet trace for analysis. It also provides a mechanism to
enable NFS/RPC kernel debug and saving the log messages for
further analysis.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore,
methods for finding specific NFSv4 operations within the
packet trace is also included.</p>

<h2>CLASSES
<a name="CLASSES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>class
NFSUtil(nfstest.host.Host)</b> <br>
NFSUtil object</p>

<p style="margin-left:11%; margin-top: 1em">NFSUtil() -&gt;
New NFSUtil object</p>

<p style="margin-left:11%; margin-top: 1em">Usage: <br>
from nfstest.nfs_util import NFSUtil</p>

<p style="margin-left:11%; margin-top: 1em"># Create object
for local host <br>
x = NFSUtil()</p>

<p style="margin-left:11%; margin-top: 1em"># Start packet
trace <br>
x.trace_start()</p>

<p style="margin-left:11%; margin-top: 1em"># Stop packet
trace <br>
x.trace_stop()</p>

<p style="margin-left:11%; margin-top: 1em"># Open packet
trace <br>
x.trace_open()</p>

<p style="margin-left:11%; margin-top: 1em"># Enable NFS
kernel debug <br>
x.nfs_debug_enable(nfsdebug=&rsquo;all&rsquo;):</p>

<p style="margin-left:11%; margin-top: 1em"># Stop NFS
kernel debug <br>
x.nfs_debug_reset()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Methods
defined here:</b> <br>
--------------------- <b><br>
__del__(self)</b></p>

<p style="margin-left:22%;">Destructor</p>

<p style="margin-left:22%; margin-top: 1em">Gracefully stop
the packet trace and unreference all client objects</p>

<p style="margin-left:11%;"><b>__init__(self,
**kwargs)</b></p>

<p style="margin-left:22%;">Constructor</p>

<p style="margin-left:22%; margin-top: 1em">Initialize
object&rsquo;s private data. <b><br>
rpcdebug:</b></p>

<p style="margin-left:32%;">Set RPC kernel debug flags and
save log messages [default: &rsquo;&rsquo;]</p>

<p style="margin-left:22%;"><b>nfsdebug:</b></p>

<p style="margin-left:32%;">Set NFS kernel debug flags and
save log messages [default: &rsquo;&rsquo;]</p>

<p style="margin-left:22%;"><b>dbgname:</b></p>

<p style="margin-left:32%;">Base name for log messages
files to create [default: &rsquo;dbgfile&rsquo;]</p>

<p style="margin-left:22%;"><b>tracename:</b></p>

<p style="margin-left:32%;">Base name for trace files to
create [default: &rsquo;tracefile&rsquo;]</p>

<p style="margin-left:22%;"><b>trcdelay:</b></p>

<p style="margin-left:32%;">Seconds to delay before
stopping packet trace [default: 0.0]</p>

<p style="margin-left:22%;"><b>notrace:</b></p>

<p style="margin-left:32%;">Debug option so a trace is not
actually started [default: False]</p>

<p style="margin-left:22%;"><b>tcpdump:</b></p>

<p style="margin-left:32%;">Tcpdump command [default:
&rsquo;/usr/sbin/tcpdump&rsquo;]</p>

<p style="margin-left:22%;"><b>messages:</b></p>

<p style="margin-left:32%;">Location of file for system
messages [default: &rsquo;/var/log/messages&rsquo;]</p>

<p style="margin-left:22%;"><b>tmpdir:</b></p>

<p style="margin-left:32%;">Temporary directory where trace
files are created [default: &rsquo;/tmp&rsquo;]</p>

<p style="margin-left:22%;"><b>tbsize:</b></p>

<p style="margin-left:32%;">Capture buffer size in kB
[default: 50000]</p>

<p style="margin-left:11%;"><b>create_host(self, host,
**kwargs)</b></p>

<p style="margin-left:22%;">Create client host object and
set defaults.</p>

<p style="margin-left:11%;"><b>find_exchange_id(self,
**kwargs)</b></p>

<p style="margin-left:22%;">Find the call and its
corresponding reply for the NFSv4 EXCHANGE_ID going to the
server specified by the ipaddr and port. <b><br>
ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address
[default: self.server]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="57%">


<p>Destination port [default: self.port]</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Store the
callback IP/TCP expression in object attribute cb_dst</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply).</p>

<p style="margin-left:11%;"><b>find_getdeviceinfo(self,
deviceid=None)</b></p>

<p style="margin-left:22%;">Find the call and its
corresponding reply for the NFSv4 GETDEVICEINFO going to the
server specified by the ipaddr for self.server and port
given by self.port. <b><br>
deviceid:</b></p>

<p style="margin-left:32%;">Look for an specific deviceid
[default: any deviceid]</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply, dslist).</p>

<p style="margin-left:11%;"><b>find_layoutget(self,
filehandle)</b></p>

<p style="margin-left:22%;">Find the call and its
corresponding reply for the NFSv4 LAYOUTGET of the given
file handle going to the server specified by the ipaddr for
self.server and port given by self.port.</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(layoutget, layoutget_res, loc_body).</p>

<p style="margin-left:11%;"><b>find_layoutrecall(self,
status=0)</b></p>

<p style="margin-left:22%;">Find NFSv4 CB_LAYOUTRECALL call
and return its reply. The reply must also match the given
status.</p>

<p style="margin-left:11%;"><b>find_nfs_op(self, op,
ipaddr, port=None, match=&rsquo;&rsquo;, status=0, <br>
src_ipaddr=None, maxindex=None, call_only=False)</b></p>

<p style="margin-left:22%;">Find the call and its
corresponding reply for the specified NFSv4 operation going
to the server specified by the ipaddr and port. The reply
must also match the given status.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p><b>op:</b></p></td>
<td width="6%"></td>
<td width="33%">


<p>NFS operation to find</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>port:</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Destination port [default: any destination port]</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>match:</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Match string to include [default: &rsquo;&rsquo;]</p></td></tr>
</table>

<p style="margin-left:22%;"><b>status:</b></p>

<p style="margin-left:32%;">Match the status of the
operation [default: 0]</p>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address [default: any
IP address]</p>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>call_only:</b></p>

<p style="margin-left:32%;">Find the call only [default:
False]</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply).</p>

<p style="margin-left:11%;"><b>find_open(self,
**kwargs)</b></p>

<p style="margin-left:22%;">Find the call and its
corresponding reply for the NFSv4 OPEN of the given file
going to the server specified by the ipaddr and port.
<b><br>
filename:</b></p>

<p style="margin-left:32%;">Find open call and reply for
this file [default: None]</p>

<p style="margin-left:22%;"><b>claimfh:</b></p>

<p style="margin-left:32%;">Find open call and reply for
this file handle [default: None]</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address
[default: self.server]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="57%">


<p>Destination port [default: self.port]</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>deleg_type:</b></p>

<p style="margin-left:32%;">Expected delegation type on
reply [default: None]</p>

<p style="margin-left:22%;"><b>deleg_stateid:</b></p>

<p style="margin-left:32%;">Delegation stateid expected on
call in delegate_cur_info [default: None]</p>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address [default: any
IP address]</p>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>anyclaim:</b></p>

<p style="margin-left:32%;">Find open for either regular
open or using delegate_cur_info [default: False]</p>

<p style="margin-left:22%; margin-top: 1em">Must specify
either filename, claimfh or both. Return a tuple:
(filehandle, open_stateid, deleg_stateid).</p>

<p style="margin-left:11%;"><b>get_abs_offset(self, offset,
ds_index=None)</b></p>

<p style="margin-left:22%;">Get real file offset given by
the (read/write) offset on the given data server index,
taking into account the type of layout (dense/sparse), the
stripe_size, first stripe index and the number of
filehandles. The layout information is taken from object
attribute layout.</p>

<p style="margin-left:11%;"><b>get_filehandle(self,
ds_index)</b></p>

<p style="margin-left:22%;">Return filehandle from the
layout list of filehandles.</p>

<p style="margin-left:11%;"><b>nfs_debug_enable(self,
**kwargs)</b></p>

<p style="margin-left:22%;">Enable NFS debug messages.
<b><br>
rpcdebug:</b></p>

<p style="margin-left:32%;">Set RPC kernel debug flags and
save log messages [default: self.rpcdebug]</p>

<p style="margin-left:22%;"><b>nfsdebug:</b></p>

<p style="margin-left:32%;">Set NFS kernel debug flags and
save log messages [default: self.nfsdebug]</p>

<p style="margin-left:22%;"><b>dbgfile:</b></p>

<p style="margin-left:32%;">Name of log messages file to
create, default is a unique name created in the temporary
directory using self.dbgname as the base name.</p>


<p style="margin-left:11%;"><b>nfs_debug_reset(self)</b></p>

<p style="margin-left:22%;">Reset NFS debug messages.</p>

<p style="margin-left:11%;"><b>trace_open(self,
tracefile=None, **kwargs)</b></p>

<p style="margin-left:22%;">Open the trace file given or
the trace file started by trace_start().</p>

<p style="margin-left:22%; margin-top: 1em">All extra
options are passed directly to the packet trace object.</p>

<p style="margin-left:22%; margin-top: 1em">Return the
packet trace object created, the packet trace object is also
stored in the object attribute pktt.</p>

<p style="margin-left:11%;"><b>trace_start(self,
tracefile=None, interface=None, capsize=None, <br>
clients=None)</b></p>

<p style="margin-left:22%;">Start trace on interface given
<b><br>
tracefile:</b></p>

<p style="margin-left:32%;">Name of trace file to create,
default is a unique name created in the temporary directory
using self.tracename as the base name.</p>

<p style="margin-left:22%;"><b>capsize:</b></p>

<p style="margin-left:32%;">Use the -C option of tcpdump to
split the trace files every 1000000*capsize bytes. See
documentation for tcpdump for more information</p>

<p style="margin-left:22%;"><b>clients:</b></p>

<p style="margin-left:32%;">List of Host() objects to
monitor</p>

<p style="margin-left:22%; margin-top: 1em">Return the name
of the trace file created.</p>

<p style="margin-left:11%;"><b>trace_stop(self)</b></p>

<p style="margin-left:22%;">Stop the trace started by
trace_start().</p>

<p style="margin-left:11%;"><b>verify_commit(self, ipaddr,
port, filehandle, init=False)</b></p>

<p style="margin-left:22%;">Verify commits are properly
sent to the server specified by the given ipaddr and port.
<b><br>
ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="56%">


<p>Destination port number of MDS or DS</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find commits for this file
handle</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>init:</b></p></td>
<td width="3%"></td>
<td width="66%">


<p>Initialized test variables [default: False]</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Return the
number of commits sent to the server.</p>

<p style="margin-left:11%;"><b>verify_create_session(self,
ipaddr, port, ds=False, nocreate=False, <br>
ds_index=None, exchid_status=0, cs_status=0)</b></p>

<p style="margin-left:22%;">Verify initial connection to
the metadata server(MDS)/data server(DS). Verify if
EXCHANGE_ID, CREATE_SESSION, RECLAIM_COMPLETE, GETATTR
asking for FATTR4_LEASE_TIME, and GETATTR asking for
FATTR4_FS_LAYOUT_TYPE are all sent or not to the server.
<b><br>
ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Destination port number of MDS or DS</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>ds:</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>True if ipaddr/port defines a DS, otherwise MDS
[default: False]</p></td></tr>
</table>

<p style="margin-left:22%;"><b>nocreate:</b></p>

<p style="margin-left:32%;">True if expecting the client
NOT to send EXCHANGE_ID, CREATE_SESSION, and
RECLAIM_COMPLETE. Otherwise, verify all these operations are
sent by the client [default: False]</p>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">DS index used for displaying
purposes only [default: None]</p>

<p style="margin-left:22%;"><b>exchid_status:</b></p>

<p style="margin-left:32%;">Expected status for EXCHANGE_ID
[default: 0]</p>

<p style="margin-left:22%;"><b>cs_status:</b></p>

<p style="margin-left:32%;">Expected status for
CREATE_SESSION [default: 0]</p>

<p style="margin-left:22%; margin-top: 1em">Return the
sessionid and it is also stored in the object attribute
sessionid.</p>

<p style="margin-left:11%;"><b>verify_io(self, iomode,
stateid, ipaddr=None, port=None, <br>
src_ipaddr=None, filehandle=None, ds_index=None, init=False,
<br>
maxindex=None, pattern=None)</b></p>

<p style="margin-left:22%;">Verify I/O is sent to the
server specified by the ipaddr and port. <b><br>
iomode:</b></p>

<p style="margin-left:32%;">Verify reads (iomode == 1) or
writes (iomode == 2)</p>

<p style="margin-left:22%;"><b>stateid:</b></p>

<p style="margin-left:32%;">Expected stateid to use in all
I/O requests</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS [default: do not match destination]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Destination port number of MDS or DS [default: do not
match destination port]</p></td></tr>
</table>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address of request
[default: do not match source]</p>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find I/O for this file handle.
This option is used when verifying I/O sent to the MDS
[default: use filehandle given by ds_index]</p>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">Data server index. This option
is used when verifying I/O sent to the DS -- filehandle is
taken from x.layout for this index [default: None]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>init:</b></p></td>
<td width="3%"></td>
<td width="66%">


<p>Initialized test variables [default: False]</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>pattern:</b></p>

<p style="margin-left:32%;">Data pattern to compare
[default: default data pattern]</p>

<p style="margin-left:22%; margin-top: 1em">Return the
number of I/O operations sent to the server.</p>

<p style="margin-left:11%;"><b>verify_layoutcommit(self,
filehandle, filesize)</b></p>

<p style="margin-left:22%;">Verify layoutcommit is properly
sent to the server specified by the ipaddr for self.server
and port given by self.port. Verify a GETATTR asking for
file size is sent within the same compound as the
LAYOUTCOMMIT. Verify GETATTR returns correct size for the
file. <b><br>
filehandle:</b></p>

<p style="margin-left:32%;">Find layoutcommit for this file
handle</p>

<p style="margin-left:22%;"><b>filesize:</b></p>

<p style="margin-left:32%;">Expected size of file</p>

<p style="margin-left:11%;"><b>verify_layoutget(self,
filehandle, iomode, riomode=None, status=0, <br>
offset=None, length=None)</b></p>

<p style="margin-left:22%;">Verify the client sends a
LAYOUTGET for the given file handle. <b><br>
filehandle:</b></p>

<p style="margin-left:32%;">Find LAYOUTGET for this file
handle</p>

<p style="margin-left:22%;"><b>iomode:</b></p>

<p style="margin-left:32%;">Expected I/O mode for LAYOUTGET
call</p>

<p style="margin-left:22%;"><b>riomode:</b></p>

<p style="margin-left:32%;">Expected I/O mode for LAYOUTGET
reply if specified, else verify reply I/O mode is equal to
call I/O mode if iomode == 2. If iomode == 1, the reply I/O
mode could be equal to 1 or 2</p>

<p style="margin-left:22%;"><b>status:</b></p>

<p style="margin-left:32%;">Expected status for LAYOUTGET
reply [default: 0]</p>

<p style="margin-left:22%;"><b>offset:</b></p>

<p style="margin-left:32%;">Expected layout range for
LAYOUTGET reply [default: None]</p>

<p style="margin-left:22%;"><b>length:</b></p>

<p style="margin-left:32%;">Expected layout range for
LAYOUTGET reply [default: None]</p>

<p style="margin-left:22%; margin-top: 1em">If both offset
and length are not given, verify LAYOUTGET reply should be a
full layout [0, NFS4_UINT64_MAX]. If only one is provided
the following defaults are used: offset = 0, length =
NFS4_UINT64_MAX.</p>

<p style="margin-left:22%; margin-top: 1em">Layout
information is stored in the object attribute layout.</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(layoutget, layoutget_res, loc_body).</p>

<p style="margin-left:11%;"><b>verify_stripe(self, offset,
size, ds_index)</b></p>

<p style="margin-left:22%;">Verify if read/write is sent to
the correct data server according to stripe size, first
stripe index and the number of filehandles. The layout
information is taken from object attribute layout. <b><br>
offset:</b></p>

<p style="margin-left:32%;">Real file offset</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>size:</b></p></td>
<td width="3%"></td>
<td width="13%">


<p>I/O size</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">Data server index</p>

<p style="margin-left:22%; margin-top: 1em">Return True if
stripe is correctly verified, False otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
methods defined here:</b> <br>
---------------------------- <b><br>
bitmap_str(bitmap, count, bmap, blist)</b></p>

<p style="margin-left:22%;">Return the string
representation of bitmap. <b><br>
bitmap:</b></p>

<p style="margin-left:32%;">Bitmap to convert</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>count:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>Number of occurrences of bitmap</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>bmap:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>Dictionary mapping the bits to strings</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>blist:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>List of all possible bit combinations</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>iomode_str(iomode)</b></p>

<p style="margin-left:22%;">Return a string representation
of iomode. This could be run as an instance or class
method.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>baseobj</b>(1),
<b>nfstest.host</b>(1), <b>packet.pktt</b>(1)</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No known
bugs.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jorge Mora
(mora@netapp.com)</p>
<hr>
</body>
</html>
