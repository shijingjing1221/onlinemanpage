<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 20:54:35 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Vector</title>

</head>
<body>

<h1 align="center">Vector</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#IMPORTANT NOTES">IMPORTANT NOTES</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#DISCLAIMER">DISCLAIMER</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Bit::Vector
&minus; Efficient bit vector, set of integers and &quot;big
int&quot; math library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>OVERLOADED
OPERATORS</small></b> <br>
See <i>Bit::Vector::Overload</i>(3).</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>MORE
STRING IMPORT/EXPORT</small></b> <br>
See <i>Bit::Vector::String</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CLASS
METHODS</small></b></p>

<pre style="margin-left:11%;">  Version
      $version = Bit::Vector&minus;&gt;Version();
  Word_Bits
      $bits = Bit::Vector&minus;&gt;Word_Bits();  #  bits in a machine word
  Long_Bits
      $bits = Bit::Vector&minus;&gt;Long_Bits();  #  bits in an unsigned long
  new
      $vector = Bit::Vector&minus;&gt;new($bits);  #  bit vector constructor
      @veclist = Bit::Vector&minus;&gt;new($bits,$count);
  new_Hex
      $vector = Bit::Vector&minus;&gt;new_Hex($bits,$string);
  new_Bin
      $vector = Bit::Vector&minus;&gt;new_Bin($bits,$string);
  new_Dec
      $vector = Bit::Vector&minus;&gt;new_Dec($bits,$string);
  new_Enum
      $vector = Bit::Vector&minus;&gt;new_Enum($bits,$string);
  Concat_List
      $vector = Bit::Vector&minus;&gt;Concat_List(@vectors);</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>OBJECT
METHODS</small></b></p>

<pre style="margin-left:11%;">  new
      $vec2 = $vec1&minus;&gt;new($bits);  #  alternative call of constructor
      @veclist = $vec&minus;&gt;new($bits,$count);
  Shadow
      $vec2 = $vec1&minus;&gt;Shadow();  #  new vector, same size but empty
  Clone
      $vec2 = $vec1&minus;&gt;Clone();  #  new vector, exact duplicate
  Concat
      $vector = $vec1&minus;&gt;Concat($vec2);
  Concat_List
      $vector = $vec1&minus;&gt;Concat_List($vec2,$vec3,...);
  Size
      $bits = $vector&minus;&gt;Size();
  Resize
      $vector&minus;&gt;Resize($bits);
      $vector&minus;&gt;Resize($vector&minus;&gt;Size()+5);
      $vector&minus;&gt;Resize($vector&minus;&gt;Size()&minus;5);
  Copy
      $vec2&minus;&gt;Copy($vec1);
  Empty
      $vector&minus;&gt;Empty();
  Fill
      $vector&minus;&gt;Fill();
  Flip
      $vector&minus;&gt;Flip();
  Primes
      $vector&minus;&gt;Primes();  #  Sieve of Erathostenes
  Reverse
      $vec2&minus;&gt;Reverse($vec1);
  Interval_Empty
      $vector&minus;&gt;Interval_Empty($min,$max);
  Interval_Fill
      $vector&minus;&gt;Interval_Fill($min,$max);
  Interval_Flip
      $vector&minus;&gt;Interval_Flip($min,$max);
  Interval_Reverse
      $vector&minus;&gt;Interval_Reverse($min,$max);
  Interval_Scan_inc
      if (($min,$max) = $vector&minus;&gt;Interval_Scan_inc($start))
  Interval_Scan_dec
      if (($min,$max) = $vector&minus;&gt;Interval_Scan_dec($start))
  Interval_Copy
      $vec2&minus;&gt;Interval_Copy($vec1,$offset2,$offset1,$length);
  Interval_Substitute
      $vec2&minus;&gt;Interval_Substitute($vec1,$off2,$len2,$off1,$len1);
  is_empty
      if ($vector&minus;&gt;is_empty())
  is_full
      if ($vector&minus;&gt;is_full())
  equal
      if ($vec1&minus;&gt;equal($vec2))
  Lexicompare (unsigned)
      if ($vec1&minus;&gt;Lexicompare($vec2) == 0)
      if ($vec1&minus;&gt;Lexicompare($vec2) != 0)
      if ($vec1&minus;&gt;Lexicompare($vec2) &lt;  0)
      if ($vec1&minus;&gt;Lexicompare($vec2) &lt;= 0)
      if ($vec1&minus;&gt;Lexicompare($vec2) &gt;  0)
      if ($vec1&minus;&gt;Lexicompare($vec2) &gt;= 0)
  Compare (signed)
      if ($vec1&minus;&gt;Compare($vec2) == 0)
      if ($vec1&minus;&gt;Compare($vec2) != 0)
      if ($vec1&minus;&gt;Compare($vec2) &lt;  0)
      if ($vec1&minus;&gt;Compare($vec2) &lt;= 0)
      if ($vec1&minus;&gt;Compare($vec2) &gt;  0)
      if ($vec1&minus;&gt;Compare($vec2) &gt;= 0)
  to_Hex
      $string = $vector&minus;&gt;to_Hex();
  from_Hex
      $vector&minus;&gt;from_Hex($string);
  to_Bin
      $string = $vector&minus;&gt;to_Bin();
  from_Bin
      $vector&minus;&gt;from_Bin($string);
  to_Dec
      $string = $vector&minus;&gt;to_Dec();
  from_Dec
      $vector&minus;&gt;from_Dec($string);
  to_Enum
      $string = $vector&minus;&gt;to_Enum();  #  e.g. &quot;2,3,5&minus;7,11,13&minus;19&quot;
  from_Enum
      $vector&minus;&gt;from_Enum($string);
  Bit_Off
      $vector&minus;&gt;Bit_Off($index);
  Bit_On
      $vector&minus;&gt;Bit_On($index);
  bit_flip
      $bit = $vector&minus;&gt;bit_flip($index);
  bit_test
  contains
      $bit = $vector&minus;&gt;bit_test($index);
      $bit = $vector&minus;&gt;contains($index);
      if ($vector&minus;&gt;bit_test($index))
      if ($vector&minus;&gt;contains($index))
  Bit_Copy
      $vector&minus;&gt;Bit_Copy($index,$bit);
  LSB (least significant bit)
      $vector&minus;&gt;LSB($bit);
  MSB (most significant bit)
      $vector&minus;&gt;MSB($bit);
  lsb (least significant bit)
      $bit = $vector&minus;&gt;lsb();
  msb (most significant bit)
      $bit = $vector&minus;&gt;msb();
  rotate_left
      $carry = $vector&minus;&gt;rotate_left();
  rotate_right
      $carry = $vector&minus;&gt;rotate_right();
  shift_left
      $carry = $vector&minus;&gt;shift_left($carry);
  shift_right
      $carry = $vector&minus;&gt;shift_right($carry);
  Move_Left
      $vector&minus;&gt;Move_Left($bits);  #  shift left &quot;$bits&quot; positions
  Move_Right
      $vector&minus;&gt;Move_Right($bits);  #  shift right &quot;$bits&quot; positions
  Insert
      $vector&minus;&gt;Insert($offset,$bits);
  Delete
      $vector&minus;&gt;Delete($offset,$bits);
  increment
      $carry = $vector&minus;&gt;increment();
  decrement
      $carry = $vector&minus;&gt;decrement();
  inc
      $overflow = $vec2&minus;&gt;inc($vec1);
  dec
      $overflow = $vec2&minus;&gt;dec($vec1);
  add
      $carry = $vec3&minus;&gt;add($vec1,$vec2,$carry);
      ($carry,$overflow) = $vec3&minus;&gt;add($vec1,$vec2,$carry);
  subtract
      $carry = $vec3&minus;&gt;subtract($vec1,$vec2,$carry);
      ($carry,$overflow) = $vec3&minus;&gt;subtract($vec1,$vec2,$carry);
  Neg
  Negate
      $vec2&minus;&gt;Neg($vec1);
      $vec2&minus;&gt;Negate($vec1);
  Abs
  Absolute
      $vec2&minus;&gt;Abs($vec1);
      $vec2&minus;&gt;Absolute($vec1);
  Sign
      if ($vector&minus;&gt;Sign() == 0)
      if ($vector&minus;&gt;Sign() != 0)
      if ($vector&minus;&gt;Sign() &lt;  0)
      if ($vector&minus;&gt;Sign() &lt;= 0)
      if ($vector&minus;&gt;Sign() &gt;  0)
      if ($vector&minus;&gt;Sign() &gt;= 0)
  Multiply
      $vec3&minus;&gt;Multiply($vec1,$vec2);
  Divide
      $quot&minus;&gt;Divide($vec1,$vec2,$rest);
  GCD (Greatest Common Divisor)
      $vecgcd&minus;&gt;GCD($veca,$vecb);
      $vecgcd&minus;&gt;GCD($vecx,$vecy,$veca,$vecb);
  Power
      $vec3&minus;&gt;Power($vec1,$vec2);
  Block_Store
      $vector&minus;&gt;Block_Store($buffer);
  Block_Read
      $buffer = $vector&minus;&gt;Block_Read();
  Word_Size
      $size = $vector&minus;&gt;Word_Size();  #  number of words in &quot;$vector&quot;
  Word_Store
      $vector&minus;&gt;Word_Store($offset,$word);
  Word_Read
      $word = $vector&minus;&gt;Word_Read($offset);
  Word_List_Store
      $vector&minus;&gt;Word_List_Store(@words);
  Word_List_Read
      @words = $vector&minus;&gt;Word_List_Read();
  Word_Insert
      $vector&minus;&gt;Word_Insert($offset,$count);
  Word_Delete
      $vector&minus;&gt;Word_Delete($offset,$count);
  Chunk_Store
      $vector&minus;&gt;Chunk_Store($chunksize,$offset,$chunk);
  Chunk_Read
      $chunk = $vector&minus;&gt;Chunk_Read($chunksize,$offset);
  Chunk_List_Store
      $vector&minus;&gt;Chunk_List_Store($chunksize,@chunks);
  Chunk_List_Read
      @chunks = $vector&minus;&gt;Chunk_List_Read($chunksize);
  Index_List_Remove
      $vector&minus;&gt;Index_List_Remove(@indices);
  Index_List_Store
      $vector&minus;&gt;Index_List_Store(@indices);
  Index_List_Read
      @indices = $vector&minus;&gt;Index_List_Read();
  Or
  Union
      $vec3&minus;&gt;Or($vec1,$vec2);
      $set3&minus;&gt;Union($set1,$set2);
  And
  Intersection
      $vec3&minus;&gt;And($vec1,$vec2);
      $set3&minus;&gt;Intersection($set1,$set2);
  AndNot
  Difference
      $vec3&minus;&gt;AndNot($vec1,$vec2);
      $set3&minus;&gt;Difference($set1,$set2);
  Xor
  ExclusiveOr
      $vec3&minus;&gt;Xor($vec1,$vec2);
      $set3&minus;&gt;ExclusiveOr($set1,$set2);
  Not
  Complement
      $vec2&minus;&gt;Not($vec1);
      $set2&minus;&gt;Complement($set1);
  subset
      if ($set1&minus;&gt;subset($set2))  #  true if $set1 is subset of $set2
  Norm
      $norm = $set&minus;&gt;Norm();
      $norm = $set&minus;&gt;Norm2();
      $norm = $set&minus;&gt;Norm3();
  Min
      $min = $set&minus;&gt;Min();
  Max
      $max = $set&minus;&gt;Max();
  Multiplication
      $matrix3&minus;&gt;Multiplication($rows3,$cols3,
                      $matrix1,$rows1,$cols1,
                      $matrix2,$rows2,$cols2);
  Product
      $matrix3&minus;&gt;Product($rows3,$cols3,
               $matrix1,$rows1,$cols1,
               $matrix2,$rows2,$cols2);
  Closure
      $matrix&minus;&gt;Closure($rows,$cols);
  Transpose
      $matrix2&minus;&gt;Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);</pre>


<h2>IMPORTANT NOTES
<a name="IMPORTANT NOTES"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em">Method naming conventions</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Method names
completely in lower case indicate a boolean return
value.</p>

<p style="margin-left:14%; margin-top: 1em">(Except for the
bit vector constructor method
&quot;<tt>&quot;new()&quot;</tt>&quot;, of course.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Boolean values</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Boolean values
in this module are always a numeric zero
(&quot;<tt>0</tt>&quot;) for &quot;false&quot; and a numeric
one (&quot;<tt>1</tt>&quot;) for &quot;true&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p style="margin-top: 1em">Negative numbers</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">All numeric
input parameters passed to any of the methods in this module
are regarded as being <b><small>UNSIGNED</small></b> (as
opposed to the contents of the bit vectors themselves, which
are usually considered to be <b><small>SIGNED</small></b>
).</p>

<p style="margin-left:14%; margin-top: 1em">As a
consequence, whenever you pass a negative number as an
argument to some method of this module, it will be treated
as a (usually very large) positive number due to its
internal two&rsquo;s complement binary representation,
usually resulting in an &quot;index out of range&quot; error
message and program abortion.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p style="margin-top: 1em">Bit order</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that bit
vectors are stored least order bit and least order word
first internally.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., bit #0 of
any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">(Where word #0
comes first in memory, i.e., it is stored at the least
memory address in the allocated block of memory holding the
given bit vector.)</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that machine words can be stored least order byte first or
last, depending on your system&rsquo;s implementation.</p>

<p style="margin-left:14%; margin-top: 1em">When you are
exporting or importing a whole bit vector at once using the
methods &quot;<tt>&quot;Block_Read()&quot;</tt>&quot; and
&quot;<tt>&quot;Block_Store()&quot;</tt>&quot; (the only
time in this module where this could make any difference),
however, a conversion to and from &quot;least order byte
first&quot; order is automatically supplied.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
what &quot;<tt>&quot;Block_Read()&quot;</tt>&quot; provides
and what &quot;<tt>&quot;Block_Store()&quot;</tt>&quot;
expects is always in &quot;least order byte first&quot;
order, regardless of the order in which words are stored
internally on your machine.</p>

<p style="margin-left:14%; margin-top: 1em">This is to make
sure that what you export on one machine using
&quot;<tt>&quot;Block_Read()&quot;</tt>&quot; can always be
read in correctly with
&quot;<tt>&quot;Block_Store()&quot;</tt>&quot; on a
different machine.</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that whenever bit vectors are converted to and from (binary
or hexadecimal) strings, the <b><small>RIGHTMOST</small></b>
bit is always the <b><small>LEAST SIGNIFICANT</small></b>
one, and the <b><small>LEFTMOST</small></b> bit is always
the <b><small>MOST SIGNIFICANT</small></b> bit.</p>

<p style="margin-left:14%; margin-top: 1em">This is because
in our western culture, numbers are always represented in
this way (least significant to most significant digits go
from right to left).</p>

<p style="margin-left:14%; margin-top: 1em">Of course this
requires an internal reversion of order, which the
corresponding conversion methods perform automatically
(without any additional overhead, it&rsquo;s just a matter
of starting the internal loop at the bottom or the top
end).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em">&quot;Word&quot; related
methods</p> </td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that all
methods whose names begin with
&quot;<tt>&quot;Word_&quot;</tt>&quot; are
<b>MACHINE-DEPENDENT</b>!</p>

<p style="margin-left:14%; margin-top: 1em">They depend on
the size (number of bits) of an &quot;unsigned int&quot; (C
type) on your machine.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, you
should only use these methods if you are
<b><small>ABSOLUTELY CERTAIN</small></b> that portability of
your code is not an issue!</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
can use arbitrarily large chunks (i.e., fragments of bit
vectors) of up to 32 bits <b><small>IN A PORTABLE
WAY</small></b> using the methods whose names begin with
&quot;<tt>&quot;Chunk_&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="17%">


<p style="margin-top: 1em">Chunk sizes</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that legal
chunk sizes for all methods whose names begin with
&quot;<tt>&quot;Chunk_&quot;</tt>&quot; range from
&quot;<tt>1</tt>&quot; to
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits();&quot;</tt>&quot;
bits (&quot;<tt>0</tt>&quot; is <b><small>NOT</small></b>
allowed!).</p>

<p style="margin-left:14%; margin-top: 1em">In order to
make your programs portable, however, you shouldn&rsquo;t
use chunk sizes larger than 32 bits, since this is the
minimum size of an &quot;unsigned long&quot; (C type) on all
systems, as prescribed by <small>ANSI&nbsp;</small> C.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Matching sizes</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">In general, for
methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of
bits), or a fatal &quot;size mismatch&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">Exceptions from
this rule are the methods
&quot;<tt>&quot;Concat()&quot;</tt>&quot;,
&quot;<tt>&quot;Concat_List()&quot;</tt>&quot;,
&quot;<tt>&quot;Copy()&quot;</tt>&quot;,
&quot;<tt>&quot;Interval_Copy()&quot;</tt>&quot; and
&quot;<tt>&quot;Interval_Substitute()&quot;</tt>&quot;,
where no conditions at all are imposed on the size of their
bit vector arguments.</p>

<p style="margin-left:14%; margin-top: 1em">In method
&quot;<tt>&quot;Multiply()&quot;</tt>&quot;, all three bit
vector arguments must in principle obey the rule of matching
sizes, but the bit vector in which the result of the
multiplication is to be stored may be larger than the two
bit vector arguments containing the factors for the
multiplication.</p>

<p style="margin-left:14%; margin-top: 1em">In method
&quot;<tt>&quot;Power()&quot;</tt>&quot;, the bit vector for
the result must be the same size or greater than the base of
the exponentiation term. The exponent can be any size.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p style="margin-top: 1em">Index ranges</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">All indices for
any given bits must lie between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;index out of range&quot; error will
occur.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Object persistence</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Since version
6.5, &quot;Bit::Vector&quot; objects can be serialized and
de-serialized automatically with &quot;Storable&quot;,
out-of-the-box, without requiring any further user action
for this to work.</p>

<p style="margin-left:14%; margin-top: 1em">This is also
true for nested data structures (since version 6.8).</p>

<p style="margin-left:14%; margin-top: 1em">See the
<i>Storable</i>(3) documentation for more details.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>OVERLOADED
OPERATORS</small></b> <br>
See <i>Bit::Vector::Overload</i>(3).</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>MORE
STRING IMPORT/EXPORT</small></b> <br>
See <i>Bit::Vector::String</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CLASS
METHODS</small></b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><tt>&quot;$version =
Bit::Vector&minus;&gt;Version();&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
current version number of this module.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;$bits =
Bit::Vector&minus;&gt;Word_Bits();&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
number of bits of an &quot;unsigned int&quot; (C type) on
your machine.</p>

<p style="margin-left:14%; margin-top: 1em">(An
&quot;unsigned int&quot; is also called a &quot;machine
word&quot;, hence the name of this method.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;$bits =
Bit::Vector&minus;&gt;Long_Bits();&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
number of bits of an &quot;unsigned long&quot; (C type) on
your machine.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;new($bits);&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This is the bit
vector constructor method.</p>

<p style="margin-left:14%; margin-top: 1em">Call this
method to create a new bit vector containing
&quot;<tt>$bits</tt>&quot; bits (with indices ranging from
&quot;<tt>0</tt>&quot; to
&quot;<tt>&quot;$bits&minus;1&quot;</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&minus; in contrast to previous versions &minus; bit vectors
of length zero (i.e., with <tt>&quot;$bits = 0&quot;</tt>)
are permitted now.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns a reference to the newly created bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">A new bit
vector is always initialized so that all bits are cleared
(turned off).</p>

<p style="margin-left:14%; margin-top: 1em">An exception
will be raised if the method is unable to allocate the
necessary memory.</p>

<p style="margin-left:14%; margin-top: 1em">Note that if
you specify a negative number for &quot;<tt>$bits</tt>&quot;
it will be interpreted as a large positive number due to its
internal two&rsquo;s complement binary representation.</p>

<p style="margin-left:14%; margin-top: 1em">In such a case,
the bit vector constructor method will obediently attempt to
create a bit vector of that size, probably resulting in an
exception, as explained above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>&quot;@veclist =
Bit::Vector&minus;&gt;new($bits,$count);&quot;</tt></p> </td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">You can also
create more than one bit vector at a time if you specify the
optional second parameter &quot;<tt>$count</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns a list of &quot;<tt>$count</tt>&quot; bit vectors
which all have the same number of bits
&quot;<tt>$bits</tt>&quot; (and which are all initialized,
i.e., all bits are cleared).</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$count</tt>&quot; is zero, an empty list is
returned.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$bits</tt>&quot; is zero, a list of null-sized bit
vectors is returned.</p>

<p style="margin-left:14%; margin-top: 1em">Note again that
if you specify a negative number for
&quot;<tt>$count</tt>&quot; it will be interpreted as a
large positive number due to its internal two&rsquo;s
complement binary representation.</p>

<p style="margin-left:14%; margin-top: 1em">In such a case,
the bit vector constructor method will obediently attempt to
create that many bit vectors, probably resulting in an
exception (&quot;out of memory&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;new_Hex($bits,$string);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
an alternative constructor which allows you to create a new
bit vector object (with &quot;<tt>$bits</tt>&quot; bits) and
to initialize it all in one go.</p>

<p style="margin-left:14%; margin-top: 1em">The method
internally first calls the bit vector constructor method
&quot;<tt>&quot;new()&quot;</tt>&quot; and then passes the
given string to the method
&quot;<tt>&quot;from_Hex()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">However, this
method is more efficient than performing these two steps
separately: First because in this method, the memory area
occupied by the new bit vector is not initialized to zeros
(which is pointless in this case), and second because it
saves you from the associated overhead of one additional
method invocation.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
will be raised if the necessary memory cannot be allocated
(see the description of the method
&quot;<tt>&quot;new()&quot;</tt>&quot; immediately above for
possible causes) or if the given string cannot be converted
successfully (see the description of the method
&quot;<tt>&quot;from_Hex()&quot;</tt>&quot; further below
for details).</p>

<p style="margin-left:14%; margin-top: 1em">In the latter
case, the memory occupied by the new bit vector is released
first (i.e., &quot;free&quot;d) before the exception is
actually raised.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;new_Bin($bits,$string);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
an alternative constructor which allows you to create a new
bit vector object (with &quot;<tt>$bits</tt>&quot; bits) and
to initialize it all in one go.</p>

<p style="margin-left:14%; margin-top: 1em">The method
internally first calls the bit vector constructor method
&quot;<tt>&quot;new()&quot;</tt>&quot; and then passes the
given string to the method
&quot;<tt>&quot;from_Bin()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">However, this
method is more efficient than performing these two steps
separately: First because in this method, the memory area
occupied by the new bit vector is not initialized to zeros
(which is pointless in this case), and second because it
saves you from the associated overhead of one additional
method invocation.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
will be raised if the necessary memory cannot be allocated
(see the description of the method
&quot;<tt>&quot;new()&quot;</tt>&quot; above for possible
causes) or if the given string cannot be converted
successfully (see the description of the method
&quot;<tt>&quot;from_Bin()&quot;</tt>&quot; further below
for details).</p>

<p style="margin-left:14%; margin-top: 1em">In the latter
case, the memory occupied by the new bit vector is released
first (i.e., &quot;free&quot;d) before the exception is
actually raised.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;new_Dec($bits,$string);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
an alternative constructor which allows you to create a new
bit vector object (with &quot;<tt>$bits</tt>&quot; bits) and
to initialize it all in one go.</p>

<p style="margin-left:14%; margin-top: 1em">The method
internally first calls the bit vector constructor method
&quot;<tt>&quot;new()&quot;</tt>&quot; and then passes the
given string to the method
&quot;<tt>&quot;from_Dec()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">However, this
method is more efficient than performing these two steps
separately: First because in this method,
&quot;<tt>&quot;new()&quot;</tt>&quot; does not initialize
the memory area occupied by the new bit vector with zeros
(which is pointless in this case, because
&quot;<tt>&quot;from_Dec()&quot;</tt>&quot; will do it
anyway), and second because it saves you from the associated
overhead of one additional method invocation.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
will be raised if the necessary memory cannot be allocated
(see the description of the method
&quot;<tt>&quot;new()&quot;</tt>&quot; above for possible
causes) or if the given string cannot be converted
successfully (see the description of the method
&quot;<tt>&quot;from_Dec()&quot;</tt>&quot; further below
for details).</p>

<p style="margin-left:14%; margin-top: 1em">In the latter
case, the memory occupied by the new bit vector is released
first (i.e., &quot;free&quot;d) before the exception is
actually raised.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;new_Enum($bits,$string);&quot;</tt></p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
an alternative constructor which allows you to create a new
bit vector object (with &quot;<tt>$bits</tt>&quot; bits) and
to initialize it all in one go.</p>

<p style="margin-left:14%; margin-top: 1em">The method
internally first calls the bit vector constructor method
&quot;<tt>&quot;new()&quot;</tt>&quot; and then passes the
given string to the method
&quot;<tt>&quot;from_Enum()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">However, this
method is more efficient than performing these two steps
separately: First because in this method,
&quot;<tt>&quot;new()&quot;</tt>&quot; does not initialize
the memory area occupied by the new bit vector with zeros
(which is pointless in this case, because
&quot;<tt>&quot;from_Enum()&quot;</tt>&quot; will do it
anyway), and second because it saves you from the associated
overhead of one additional method invocation.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
will be raised if the necessary memory cannot be allocated
(see the description of the method
&quot;<tt>&quot;new()&quot;</tt>&quot; above for possible
causes) or if the given string cannot be converted
successfully (see the description of the method
&quot;<tt>&quot;from_Enum()&quot;</tt>&quot; further below
for details).</p>

<p style="margin-left:14%; margin-top: 1em">In the latter
case, the memory occupied by the new bit vector is released
first (i.e., &quot;free&quot;d) before the exception is
actually raised.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em"><tt>&quot;$vector =
Bit::Vector&minus;&gt;Concat_List(@vectors);&quot;</tt></p> </td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
creates a new vector containing all bit vectors from the
argument list in concatenated form.</p>

<p style="margin-left:14%; margin-top: 1em">The argument
list may contain any number of arguments (including zero);
the only condition is that all arguments must be bit
vectors.</p>

<p style="margin-left:14%; margin-top: 1em">There is no
condition concerning the length (in number of bits) of these
arguments.</p>

<p style="margin-left:14%; margin-top: 1em">The vectors
from the argument list are not changed in any way.</p>

<p style="margin-left:14%; margin-top: 1em">If the argument
list is empty or if all arguments have length zero, the
resulting bit vector will also have length zero.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
<b><small>RIGHTMOST</small></b> bit vector from the argument
list will become the <b><small>LEAST</small></b> significant
part of the resulting bit vector, and the
<b><small>LEFTMOST</small></b> bit vector from the argument
list will become the <b><small>MOST</small></b> significant
part of the resulting bit vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>OBJECT
METHODS</small></b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>&quot;$vec2 =
$vec1&minus;&gt;new($bits);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;@veclist
= $vec&minus;&gt;new($bits);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This is an
alternative way of calling the bit vector constructor
method.</p>

<p style="margin-left:14%; margin-top: 1em">Vector
&quot;<tt>$vec1</tt>&quot; (or &quot;<tt>$vec</tt>&quot;) is
not affected by this, it just serves as an anchor for the
method invocation mechanism.</p>

<p style="margin-left:14%; margin-top: 1em">In fact
<b><small>ALL</small></b> class methods in this module can
be called this way, even though this is probably considered
to be &quot;politically incorrect&quot; by <small>OO</small>
(&quot;object-orientation&quot;) aficionados. ;&minus;)</p>

<p style="margin-left:14%; margin-top: 1em">So even if you
are too lazy to type
&quot;<tt>&quot;Bit::Vector&minus;&gt;&quot;</tt>&quot;
instead of &quot;<tt>&quot;$vec1&minus;&gt;&quot;</tt>&quot;
(and even though laziness is &minus; allegedly &minus; a
programmer&rsquo;s virtue <tt>&quot;:&minus;)&quot;</tt>),
maybe it is better not to use this feature if you
don&rsquo;t want to get booed at. ;&minus;)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;$vec2 =
$vec1&minus;&gt;Shadow();&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Creates a
<b><small>NEW</small></b> bit vector
&quot;<tt>$vec2</tt>&quot; of the <b><small>SAME
SIZE</small></b> as &quot;<tt>$vec1</tt>&quot; but which is
<b><small>EMPTY</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">Just like a
shadow that has the same shape as the object it originates
from, but is flat and has no volume, i.e., contains
nothing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em"><tt>&quot;$vec2 =
$vec1&minus;&gt;Clone();&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Creates a
<b><small>NEW</small></b> bit vector
&quot;<tt>$vec2</tt>&quot; of the <b><small>SAME
SIZE</small></b> as &quot;<tt>$vec1</tt>&quot; which is an
<b><small>EXACT COPY</small></b> of
&quot;<tt>$vec1</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em"><tt>&quot;$vector =
$vec1&minus;&gt;Concat($vec2);&quot;</tt></p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a new bit vector object which is the result of the
concatenation of the contents of &quot;<tt>$vec1</tt>&quot;
and &quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
contents of &quot;<tt>$vec1</tt>&quot; become the
<b><small>MOST</small></b> significant part of the resulting
bit vector, and &quot;<tt>$vec2</tt>&quot; the
<b><small>LEAST</small></b> significant part.</p>

<p style="margin-left:14%; margin-top: 1em">If both bit
vector arguments have length zero, the resulting bit vector
will also have length zero.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;$vector =
$vec1&minus;&gt;Concat_List($vec2,$vec3,...);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This is an
alternative way of calling this (class) method as an object
method.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns a new bit vector object which is the result of the
concatenation of the contents of <tt>&quot;$vec1 . $vec2 .
$vec3 . ...&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">See the section
&quot;class methods&quot; above for a detailed description
of this method.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
argument list may be empty and that all arguments must be
bit vectors if it isn&rsquo;t.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;$bits =
$vector&minus;&gt;Size();&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
size (number of bits) the given vector was created with (or
&quot;<tt>&quot;Resize()&quot;</tt>&quot;d to).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Resize($bits);&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Changes the
size of the given vector to the specified number of
bits.</p>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to change the size of an existing bit vector,
preserving as many bits from the old vector as will fit into
the new one (i.e., all bits with indices smaller than the
minimum of the sizes of both vectors, old and new).</p>

<p style="margin-left:14%; margin-top: 1em">If the number
of machine words needed to store the new vector is smaller
than or equal to the number of words needed to store the old
vector, the memory allocated for the old vector is reused
for the new one, and only the relevant book-keeping
information is adjusted accordingly.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
even if the number of bits increases, new memory is not
necessarily being allocated (i.e., if the old and the new
number of bits fit into the same number of machine
words).</p>

<p style="margin-left:14%; margin-top: 1em">If the number
of machine words needed to store the new vector is greater
than the number of words needed to store the old vector, new
memory is allocated for the new vector, the old vector is
copied to the new one, the remaining bits in the new vector
are cleared (turned off) and the old vector is deleted,
i.e., the memory that was allocated for it is released.</p>

<p style="margin-left:14%; margin-top: 1em">(An exception
will be raised if the method is unable to allocate the
necessary memory for the new vector.)</p>

<p style="margin-left:14%; margin-top: 1em">As a
consequence, if you decrease the size of a given vector so
that it will use fewer machine words, and increase it again
later so that it will use more words than immediately before
but still less than the original vector, new memory will be
allocated anyway because the information about the size of
the original vector is lost whenever you resize it.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
if you specify a negative number for
&quot;<tt>$bits</tt>&quot; it will be interpreted as a large
positive number due to its internal two&rsquo;s complement
binary representation.</p>

<p style="margin-left:14%; margin-top: 1em">In such a case,
&quot;<i>Resize()</i>&quot; will obediently attempt to
create a bit vector of that size, probably resulting in an
exception, as explained above.</p>

<p style="margin-left:14%; margin-top: 1em">Finally, note
that &minus; in contrast to previous versions &minus;
resizing a bit vector to a size of zero bits (length zero)
is now permitted.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Copy($vec1);&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Copies the
contents of bit vector &quot;<tt>$vec1</tt>&quot; to bit
vector &quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The previous
contents of bit vector &quot;<tt>$vec2</tt>&quot; get
overwritten, i.e., are lost.</p>

<p style="margin-left:14%; margin-top: 1em">Both vectors
must exist beforehand, i.e., this method does not
<b><small>CREATE</small></b> any new bit vector object.</p>

<p style="margin-left:14%; margin-top: 1em">The two vectors
may be of any size.</p>

<p style="margin-left:14%; margin-top: 1em">If the source
bit vector is larger than the target, this method will copy
as much of the least significant bits of the source vector
as will fit into the target vector, thereby discarding any
extraneous most significant bits.</p>


<p style="margin-left:14%; margin-top: 1em"><small>BEWARE</small>
that this causes a brutal cutoff in the middle of your data,
and it will also leave you with an almost unpredictable sign
if subsequently the number in the target vector is going to
be interpreted as a number! (You have been warned!)</p>

<p style="margin-left:14%; margin-top: 1em">If the target
bit vector is larger than the source, this method fills up
the remaining most significant bits in the target bit vector
with either 0&rsquo;s or 1&rsquo;s, depending on the sign (=
the most significant bit) of the source bit vector. This is
also known as &quot;sign extension&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This makes it
possible to copy numbers from a smaller bit vector into a
larger one while preserving the number&rsquo;s absolute
value as well as its sign (due to the two&rsquo;s complement
binary representation of numbers).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="29%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Empty();&quot;</tt></p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Clears all bits
in the given vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Fill();&quot;</tt></p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Sets all bits
in the given vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Flip();&quot;</tt></p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Flips (i.e.,
complements) all bits in the given vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Primes();&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Clears the
given bit vector and sets all bits whose indices are prime
numbers.</p>

<p style="margin-left:14%; margin-top: 1em">This method
uses the algorithm known as the &quot;Sieve of
Erathostenes&quot; internally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Reverse($vec1);&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
copies the given vector &quot;<tt>$vec1</tt>&quot; to the
vector &quot;<tt>$vec2</tt>&quot;, thereby reversing the
order of all bits.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., the least
significant bit of &quot;<tt>$vec1</tt>&quot; becomes the
most significant bit of &quot;<tt>$vec2</tt>&quot;, whereas
the most significant bit of &quot;<tt>$vec1</tt>&quot;
becomes the least significant bit of
&quot;<tt>$vec2</tt>&quot;, and so forth for all bits in
between.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
in-place processing is also possible, i.e.,
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
may be identical.</p>

<p style="margin-left:14%; margin-top: 1em">(Internally,
this is the same as
<tt>&quot;$vec1&minus;&gt;Interval_Reverse(0,$vec1&minus;&gt;Size()&minus;1);&quot;</tt>.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Interval_Empty($min,$max);&quot;</tt></p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Clears all bits
in the interval <tt>&quot;[$min..$max]&quot;</tt> (including
both limits) in the given vector.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$min</tt>&quot;
and &quot;<tt>$max</tt>&quot; may have the same value; this
is the same as clearing a single bit with
&quot;<tt>&quot;Bit_Off()&quot;</tt>&quot; (but less
efficient).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
<tt>&quot;$vector&minus;&gt;Interval_Empty(0,$vector&minus;&gt;Size()&minus;1);&quot;</tt>
is the same as
<tt>&quot;$vector&minus;&gt;Empty();&quot;</tt> (but less
efficient).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Interval_Fill($min,$max);&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Sets all bits
in the interval <tt>&quot;[$min..$max]&quot;</tt> (including
both limits) in the given vector.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$min</tt>&quot;
and &quot;<tt>$max</tt>&quot; may have the same value; this
is the same as setting a single bit with
&quot;<tt>&quot;Bit_On()&quot;</tt>&quot; (but less
efficient).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
<tt>&quot;$vector&minus;&gt;Interval_Fill(0,$vector&minus;&gt;Size()&minus;1);&quot;</tt>
is the same as
<tt>&quot;$vector&minus;&gt;Fill();&quot;</tt> (but less
efficient).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Interval_Flip($min,$max);&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Flips (i.e.,
complements) all bits in the interval
<tt>&quot;[$min..$max]&quot;</tt> (including both limits) in
the given vector.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$min</tt>&quot;
and &quot;<tt>$max</tt>&quot; may have the same value; this
is the same as flipping a single bit with
&quot;<tt>&quot;bit_flip()&quot;</tt>&quot; (but less
efficient).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
<tt>&quot;$vector&minus;&gt;Interval_Flip(0,$vector&minus;&gt;Size()&minus;1);&quot;</tt>
is the same as
<tt>&quot;$vector&minus;&gt;Flip();&quot;</tt> and
<tt>&quot;$vector&minus;&gt;Complement($vector);&quot;</tt>
(but less efficient).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Interval_Reverse($min,$max);&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Reverses the
order of all bits in the interval
<tt>&quot;[$min..$max]&quot;</tt> (including both limits) in
the given vector.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., bits
&quot;<tt>$min</tt>&quot; and &quot;<tt>$max</tt>&quot; swap
places, and so forth for all bits in between.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$min</tt>&quot;
and &quot;<tt>$max</tt>&quot; may have the same value; this
has no effect whatsoever, though.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;if (($min,$max) =
$vector&minus;&gt;Interval_Scan_inc($start))&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
minimum and maximum indices of the next contiguous block of
set bits (i.e., bits in the &quot;on&quot; state).</p>

<p style="margin-left:14%; margin-top: 1em">The search
starts at index &quot;<tt>$start</tt>&quot; (i.e.,
<tt>&quot;$min&quot; &gt;= &quot;$start&quot;</tt>) and
proceeds upwards (i.e., <tt>&quot;$max&quot; &gt;=
&quot;$min&quot;</tt>), thus repeatedly increments the
search pointer &quot;<tt>$start</tt>&quot; (internally).</p>

<p style="margin-left:14%; margin-top: 1em">Note though
that the contents of the variable (or scalar literal value)
&quot;<tt>$start</tt>&quot; is <b><small>NOT</small></b>
altered. I.e., you have to set it to the desired value
yourself prior to each call to
&quot;<tt>&quot;Interval_Scan_inc()&quot;</tt>&quot; (see
also the example given below).</p>

<p style="margin-left:14%; margin-top: 1em">Actually, the
bit vector is not searched bit by bit, but one machine word
at a time, in order to speed up execution (which means that
this method is quite efficient).</p>

<p style="margin-left:14%; margin-top: 1em">An empty list
is returned if no such block can be found.</p>

<p style="margin-left:14%; margin-top: 1em">Note that a
single set bit (surrounded by cleared bits) is a valid block
by this definition. In that case the return values for
&quot;<tt>$min</tt>&quot; and &quot;<tt>$max</tt>&quot; are
the same.</p>

<p style="margin-left:14%; margin-top: 1em">Typical
use:</p>

<pre style="margin-left:14%; margin-top: 1em">    $start = 0;
    while (($start &lt; $vector&minus;&gt;Size()) &amp;&amp;
        (($min,$max) = $vector&minus;&gt;Interval_Scan_inc($start)))
    {
        $start = $max + 2;
        # do something with $min and $max
    }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;if (($min,$max) =
$vector&minus;&gt;Interval_Scan_dec($start))&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
minimum and maximum indices of the next contiguous block of
set bits (i.e., bits in the &quot;on&quot; state).</p>

<p style="margin-left:14%; margin-top: 1em">The search
starts at index &quot;<tt>$start</tt>&quot; (i.e.,
<tt>&quot;$max&quot; &lt;= &quot;$start&quot;</tt>) and
proceeds downwards (i.e., <tt>&quot;$min&quot; &lt;=
&quot;$max&quot;</tt>), thus repeatedly decrements the
search pointer &quot;<tt>$start</tt>&quot; (internally).</p>

<p style="margin-left:14%; margin-top: 1em">Note though
that the contents of the variable (or scalar literal value)
&quot;<tt>$start</tt>&quot; is <b><small>NOT</small></b>
altered. I.e., you have to set it to the desired value
yourself prior to each call to
&quot;<tt>&quot;Interval_Scan_dec()&quot;</tt>&quot; (see
also the example given below).</p>

<p style="margin-left:14%; margin-top: 1em">Actually, the
bit vector is not searched bit by bit, but one machine word
at a time, in order to speed up execution (which means that
this method is quite efficient).</p>

<p style="margin-left:14%; margin-top: 1em">An empty list
is returned if no such block can be found.</p>

<p style="margin-left:14%; margin-top: 1em">Note that a
single set bit (surrounded by cleared bits) is a valid block
by this definition. In that case the return values for
&quot;<tt>$min</tt>&quot; and &quot;<tt>$max</tt>&quot; are
the same.</p>

<p style="margin-left:14%; margin-top: 1em">Typical
use:</p>

<pre style="margin-left:14%; margin-top: 1em">    $start = $vector&minus;&gt;Size() &minus; 1;
    while (($start &gt;= 0) &amp;&amp;
        (($min,$max) = $vector&minus;&gt;Interval_Scan_dec($start)))
    {
        $start = $min &minus; 2;
        # do something with $min and $max
    }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Interval_Copy($vec1,$offset2,$offset1,$length);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to copy a stretch of contiguous bits (starting at
any position &quot;<tt>$offset1</tt>&quot; you choose, with
a length of &quot;<tt>$length</tt>&quot; bits) from a given
&quot;source&quot; bit vector &quot;<tt>$vec1</tt>&quot; to
another position &quot;<tt>$offset2</tt>&quot; in a
&quot;target&quot; bit vector
&quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
two bit vectors &quot;<tt>$vec1</tt>&quot; and
&quot;<tt>$vec2</tt>&quot; do <b><small>NOT</small></b> need
to have the same (matching) size!</p>

<p style="margin-left:14%; margin-top: 1em">Consequently,
any of the two terms &quot;<tt>&quot;$offset1 +
$length&quot;</tt>&quot; and &quot;<tt>&quot;$offset2 +
$length&quot;</tt>&quot; (or both) may exceed the actual
length of its corresponding bit vector
(&quot;<tt>&quot;$vec1&minus;&gt;Size()&quot;</tt>&quot; and
&quot;<tt>&quot;$vec2&minus;&gt;Size()&quot;</tt>&quot;,
respectively).</p>

<p style="margin-left:14%; margin-top: 1em">In such a case,
the &quot;<tt>$length</tt>&quot; parameter is automatically
reduced internally so that both terms above are bounded by
the number of bits of their corresponding bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This may even
result in a length of zero, in which case nothing is copied
at all.</p>

<p style="margin-left:14%; margin-top: 1em">(Of course the
value of the &quot;<tt>$length</tt>&quot; parameter,
supplied by you in the initial method call, may also be zero
right from the start!)</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
&quot;<tt>$offset1</tt>&quot; and
&quot;<tt>$offset2</tt>&quot; must lie within the range
&quot;<tt>0</tt>&quot; and, respectively,
&quot;<tt>&quot;$vec1&minus;&gt;Size()&minus;1&quot;</tt>&quot;
or
&quot;<tt>&quot;$vec2&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that &quot;<tt>$vec1</tt>&quot; and
&quot;<tt>$vec2</tt>&quot; may be identical, i.e., you may
copy a stretch of contiguous bits from one part of a given
bit vector to another part.</p>

<p style="margin-left:14%; margin-top: 1em">The source and
the target interval may even overlap, in which case the
copying is automatically performed in ascending or
descending order (depending on the direction of the copy
&minus; downwards or upwards in the bit vector,
respectively) to handle this situation correctly, i.e., so
that no bits are being overwritten before they have been
copied themselves.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Interval_Substitute($vec1,$off2,$len2,$off1,$len1);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
(roughly) the same for bit vectors (i.e., arrays of
booleans) as what the &quot;splice&quot; function in Perl is
for lists (i.e., arrays of scalars).</p>

<p style="margin-left:14%; margin-top: 1em">(See
&quot;splice&quot; in perlfunc for more details about this
function.)</p>

<p style="margin-left:14%; margin-top: 1em">The method
allows you to substitute a stretch of contiguous bits
(defined by a position (offset) &quot;<tt>$off1</tt>&quot;
and a length of &quot;<tt>$len1</tt>&quot; bits) from a
given &quot;source&quot; bit vector
&quot;<tt>$vec1</tt>&quot; for a different stretch of
contiguous bits (defined by a position (offset)
&quot;<tt>$off2</tt>&quot; and a length of
&quot;<tt>$len2</tt>&quot; bits) in another,
&quot;target&quot; bit vector
&quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
two bit vectors &quot;<tt>$vec1</tt>&quot; and
&quot;<tt>$vec2</tt>&quot; do <b><small>NOT</small></b> need
to have the same (matching) size!</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that &quot;<tt>$off1</tt>&quot; and
&quot;<tt>$off2</tt>&quot; must lie within the range
&quot;<tt>0</tt>&quot; and, respectively,
&quot;<tt>&quot;$vec1&minus;&gt;Size()&quot;</tt>&quot; or
&quot;<tt>&quot;$vec2&minus;&gt;Size()&quot;</tt>&quot;, or
a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">Alert readers
will have noticed that these upper limits are
<b><small>NOT</small></b>
&quot;<tt>&quot;$vec1&minus;&gt;Size()&minus;1&quot;</tt>&quot;
and
&quot;<tt>&quot;$vec2&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
as they would be for any other method in this module, but
that these offsets may actually point to one position
<b><small>PAST THE END</small></b> of the corresponding bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
necessary in order to make it possible to
<b><small>APPEND</small></b> a given stretch of bits to the
target bit vector instead of <b><small>REPLACING</small></b>
something in it.</p>

<p style="margin-left:14%; margin-top: 1em">For reasons of
symmetry and generality, the same applies to the offset in
the source bit vector, even though such an offset (one
position past the end of the bit vector) does not serve any
practical purpose there (but does not cause any harm
either).</p>

<p style="margin-left:14%; margin-top: 1em">(Actually this
saves you from the need of testing for this special case, in
certain circumstances.)</p>

<p style="margin-left:14%; margin-top: 1em">Note that
whenever the term &quot;<tt>&quot;$off1 +
$len1&quot;</tt>&quot; exceeds the size
&quot;<tt>&quot;$vec1&minus;&gt;Size()&quot;</tt>&quot; of
bit vector &quot;<tt>$vec1</tt>&quot; (or if
&quot;<tt>&quot;$off2 + $len2&quot;</tt>&quot; exceeds
&quot;<tt>&quot;$vec2&minus;&gt;Size()&quot;</tt>&quot;),
the corresponding length (&quot;<tt>$len1</tt>&quot; or
&quot;<tt>$len2</tt>&quot;, respectively) is automatically
reduced internally so that &quot;<tt>&quot;$off1 + $len1
&lt;= $vec1&minus;&gt;Size()&quot;</tt>&quot; (and
&quot;<tt>&quot;$off2 + $len2 &lt;=
$vec2&minus;&gt;Size()&quot;</tt>&quot;) holds.</p>

<p style="margin-left:14%; margin-top: 1em">(Note that this
does <b><small>NOT</small></b> alter the intended result,
even though this may seem counter-intuitive at first!)</p>

<p style="margin-left:14%; margin-top: 1em">This may even
result in a length (&quot;<tt>$len1</tt>&quot; or
&quot;<tt>$len2</tt>&quot;) of zero.</p>

<p style="margin-left:14%; margin-top: 1em">A length of
zero for the interval in the <b><small>SOURCE</small></b>
bit vector (&quot;<tt>&quot;$len1 == 0&quot;</tt>&quot;)
means that the indicated stretch of bits in the target bit
vector (starting at position &quot;<tt>$off2</tt>&quot;) is
to be replaced by <b><small>NOTHING</small></b> , i.e., is
to be <b><small>DELETED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">A length of
zero for the interval in the <b><small>TARGET</small></b>
bit vector (&quot;<tt>$len2</tt> == 0&quot;) means that
<b><small>NOTHING</small></b> is replaced, and that the
stretch of bits from the source bit vector is simply
<b><small>INSERTED</small></b> into the target bit vector at
the indicated position (&quot;<tt>$off2</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">If both length
parameters are zero, nothing is done at all.</p>

<p style="margin-left:14%; margin-top: 1em">Note that in
contrast to any other method in this module (especially
&quot;<tt>&quot;Interval_Copy()&quot;</tt>&quot;,
&quot;<tt>&quot;Insert()&quot;</tt>&quot; and
&quot;<tt>&quot;Delete()&quot;</tt>&quot;), this method
<b><small>IMPLICITLY</small></b> and
<b><small>AUTOMATICALLY</small></b> adapts the length of the
resulting bit vector as needed, as given by</p>

<pre style="margin-left:14%; margin-top: 1em">        $size = $vec2&minus;&gt;Size();   #  before
        $size += $len1 &minus; $len2;  #  after</pre>


<p style="margin-left:14%; margin-top: 1em">(The only other
method in this module that changes the size of a bit vector
is the method
&quot;<tt>&quot;Resize()&quot;</tt>&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
replacing a given interval of bits in the target bit vector
with a longer or shorter stretch of bits from the source bit
vector, or simply inserting (&quot;<tt>&quot;$len2 ==
0&quot;</tt>&quot;) a stretch of bits into or deleting
(&quot;<tt>&quot;$len1 == 0&quot;</tt>&quot;) an interval of
bits from the target bit vector will automatically increase
or decrease, respectively, the size of the target bit vector
accordingly.</p>

<p style="margin-left:14%; margin-top: 1em">For the sake of
generality, this may even result in a bit vector with a size
of zero (containing no bits at all).</p>

<p style="margin-left:14%; margin-top: 1em">This is also
the reason why bit vectors of length zero are permitted in
this module in the first place, starting with version
5.0.</p>

<p style="margin-left:14%; margin-top: 1em">Finally, note
that &quot;<tt>$vec1</tt>&quot; and
&quot;<tt>$vec2</tt>&quot; may be identical, i.e., in-place
processing is possible.</p>

<p style="margin-left:14%; margin-top: 1em">(If you think
about that for a while or if you look at the code, you will
see that this is far from trivial!)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;if
($vector&minus;&gt;is_empty())&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Tests whether
the given bit vector is empty, i.e., whether
<b><small>ALL</small></b> of its bits are cleared (in the
&quot;off&quot; state).</p>

<p style="margin-left:14%; margin-top: 1em">In &quot;big
integer&quot; arithmetic, this is equivalent to testing
whether the number stored in the bit vector is zero
(&quot;<tt>0</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Returns
&quot;true&quot; (&quot;<tt>1</tt>&quot;) if the bit vector
is empty and &quot;false&quot; (&quot;<tt>0</tt>&quot;)
otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method also returns &quot;true&quot;
(&quot;<tt>1</tt>&quot;) if the given bit vector has a
length of zero, i.e., if it contains no bits at all.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em"><tt>&quot;if
($vector&minus;&gt;is_full())&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Tests whether
the given bit vector is full, i.e., whether
<b><small>ALL</small></b> of its bits are set (in the
&quot;on&quot; state).</p>

<p style="margin-left:14%; margin-top: 1em">In &quot;big
integer&quot; arithmetic, this is equivalent to testing
whether the number stored in the bit vector is minus one
(&quot;&minus;1&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Returns
&quot;true&quot; (&quot;<tt>1</tt>&quot;) if the bit vector
is full and &quot;false&quot; (&quot;<tt>0</tt>&quot;)
otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
bit vector has a length of zero (i.e., if it contains no
bits at all), this method returns &quot;false&quot;
(&quot;<tt>0</tt>&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;if
($vec1&minus;&gt;equal($vec2))&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Tests the two
given bit vectors for equality.</p>

<p style="margin-left:14%; margin-top: 1em">Returns
&quot;true&quot; (&quot;<tt>1</tt>&quot;) if the two bit
vectors are exact copies of one another and
&quot;false&quot; (&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;$cmp =
$vec1&minus;&gt;Lexicompare($vec2);&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Compares the
two given bit vectors, which are regarded as
<b><small>UNSIGNED</small></b> numbers in binary
representation.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns &quot;<tt>&quot;&minus;1&quot;</tt>&quot; if the
first bit vector is smaller than the second bit vector,
&quot;<tt>0</tt>&quot; if the two bit vectors are exact
copies of one another and &quot;<tt>1</tt>&quot; if the
first bit vector is greater than the second bit vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>&quot;$cmp =
$vec1&minus;&gt;Compare($vec2);&quot;</tt></p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Compares the
two given bit vectors, which are regarded as
<b><small>SIGNED</small></b> numbers in binary
representation.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns &quot;<tt>&quot;&minus;1&quot;</tt>&quot; if the
first bit vector is smaller than the second bit vector,
&quot;<tt>0</tt>&quot; if the two bit vectors are exact
copies of one another and &quot;<tt>1</tt>&quot; if the
first bit vector is greater than the second bit vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$string =
$vector&minus;&gt;to_Hex();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns a
hexadecimal string representing the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
representation is quite compact, in that it only needs at
most twice the number of bytes needed to store the bit
vector itself, internally.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
since a hexadecimal digit is always worth four bits, the
length of the resulting string is always a multiple of four
bits, regardless of the true length (in bits) of the given
bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Finally, note
that the <b><small>LEAST</small></b> significant hexadecimal
digit is located at the <b><small>RIGHT</small></b> end of
the resulting string, and the <b><small>MOST</small></b>
significant digit at the <b><small>LEFT</small></b> end.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;from_Hex($string);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Allows to read
in the contents of a bit vector from a hexadecimal string,
such as returned by the method
&quot;<tt>&quot;to_Hex()&quot;</tt>&quot; (see above).</p>

<p style="margin-left:14%; margin-top: 1em">Remember that
the least significant bits are always to the right of a
hexadecimal string, and the most significant bits to the
left. Therefore, the string is actually read in from right
to left while the bit vector is filled accordingly, 4 bits
at a time, starting with the least significant bits and
going upward to the most significant bits.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string contains less hexadecimal digits than are needed to
completely fill the given bit vector, the remaining (most
significant) bits are all cleared.</p>

<p style="margin-left:14%; margin-top: 1em">This also means
that, even if the given string does not contain enough
digits to completely fill the given bit vector, the previous
contents of the bit vector are erased completely.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.</p>

<p style="margin-left:14%; margin-top: 1em">(In fact they
are ignored completely &minus; they are not even checked for
proper syntax. See also below for more about that.)</p>

<p style="margin-left:14%; margin-top: 1em">This behaviour
is intentional so that you may read in the string
representing one bit vector into another bit vector of
different size, i.e., as much of it as will fit.</p>

<p style="margin-left:14%; margin-top: 1em">If during the
process of reading the given string any character is
encountered which is not a hexadecimal digit, a fatal syntax
error ensues (&quot;input string syntax error&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$string =
$vector&minus;&gt;to_Bin();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns a
binary string representing the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  $vector = Bit::Vector&minus;&gt;new(8);
  $vector&minus;&gt;Primes();
  $string = $vector&minus;&gt;to_Bin();
  print &quot;'$string'\n&quot;;</pre>


<p style="margin-left:14%; margin-top: 1em">This
prints:</p>

<pre style="margin-left:14%; margin-top: 1em">  '10101100'</pre>


<p style="margin-left:14%; margin-top: 1em">(Bits #7, #5,
#3 and #2 are set.)</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
<b><small>LEAST</small></b> significant bit is located at
the <b><small>RIGHT</small></b> end of the resulting string,
and the <b><small>MOST</small></b> significant bit at the
<b><small>LEFT</small></b> end.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;from_Bin($string);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to read in the contents of a bit vector from a
binary string, such as returned by the method
&quot;<tt>&quot;to_Bin()&quot;</tt>&quot; (see above).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method assumes that the <b><small>LEAST</small></b>
significant bit is located at the
<b><small>RIGHT</small></b> end of the binary string, and
the <b><small>MOST</small></b> significant bit at the
<b><small>LEFT</small></b> end. Therefore, the string is
actually read in from right to left while the bit vector is
filled accordingly, one bit at a time, starting with the
least significant bit and going upward to the most
significant bit.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string contains less binary digits (&quot;<tt>0</tt>&quot;
and &quot;<tt>1</tt>&quot;) than are needed to completely
fill the given bit vector, the remaining (most significant)
bits are all cleared.</p>

<p style="margin-left:14%; margin-top: 1em">This also means
that, even if the given string does not contain enough
digits to completely fill the given bit vector, the previous
contents of the bit vector are erased completely.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.</p>

<p style="margin-left:14%; margin-top: 1em">(In fact they
are ignored completely &minus; they are not even checked for
proper syntax. See also below for more about that.)</p>

<p style="margin-left:14%; margin-top: 1em">This behaviour
is intentional so that you may read in the string
representing one bit vector into another bit vector of
different size, i.e., as much of it as will fit.</p>

<p style="margin-left:14%; margin-top: 1em">If during the
process of reading the given string any character is
encountered which is not either &quot;<tt>0</tt>&quot; or
&quot;<tt>1</tt>&quot;, a fatal syntax error ensues
(&quot;input string syntax error&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$string =
$vector&minus;&gt;to_Dec();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a string representing the contents of the given bit
vector converted to decimal (base <tt>10</tt>).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method assumes the given bit vector to be
<b><small>SIGNED</small></b> (and to contain a number in
two&rsquo;s complement binary representation).</p>

<p style="margin-left:14%; margin-top: 1em">Consequently,
whenever the most significant bit of the given bit vector is
set, the number stored in it is regarded as being
<b><small>NEGATIVE</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">The resulting
string can be fed into
&quot;<tt>&quot;from_Dec()&quot;</tt>&quot; (see below) in
order to copy the contents of this bit vector to another one
(or to restore the contents of this one). This is not
advisable, though, since this would be very inefficient
(there are much more efficient methods for storing and
copying bit vectors in this module).</p>

<p style="margin-left:14%; margin-top: 1em">Note that such
conversion from binary to decimal is inherently slow since
the bit vector has to be repeatedly divided by <tt>10</tt>
with remainder until the quotient becomes <tt>0</tt> (each
remainder in turn represents a single decimal digit of the
resulting string).</p>

<p style="margin-left:14%; margin-top: 1em">This is also
true for the implementation of this method in this module,
even though a considerable effort has been made to speed it
up: instead of repeatedly dividing by <tt>10</tt>, the bit
vector is repeatedly divided by the largest power of
<tt>10</tt> that will fit into a machine word. The remainder
is then repeatedly divided by <tt>10</tt> using only machine
word arithmetics, which is much faster than dividing the
whole bit vector (&quot;divide and rule&quot;
principle).</p>

<p style="margin-left:14%; margin-top: 1em">According to my
own measurements, this resulted in an 8&minus;fold speed
increase over the straightforward approach.</p>

<p style="margin-left:14%; margin-top: 1em">Still,
conversion to decimal should be used only where absolutely
necessary.</p>

<p style="margin-left:14%; margin-top: 1em">Keep the
resulting string stored in some variable if you need it
again, instead of converting the bit vector all over
again.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that if
you set the configuration for overloaded operators to
&quot;output=decimal&quot;, this method will be called for
every bit vector enclosed in double quotes!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;from_Dec($string);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to convert a given decimal number, which may be
positive or negative, into two&rsquo;s complement binary
representation, which is then stored in the given bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">The decimal
number should always be provided as a string, to avoid
possible truncation (due to the limited precision of
integers in Perl) or formatting (due to Perl&rsquo;s use of
scientific notation for large numbers), which would lead to
errors.</p>

<p style="margin-left:14%; margin-top: 1em">If the binary
representation of the given decimal number is too big to fit
into the given bit vector (if the given bit vector does not
contain enough bits to hold it), a fatal &quot;numeric
overflow error&quot; occurs.</p>

<p style="margin-left:14%; margin-top: 1em">If the input
string contains other characters than decimal digits
(<tt>&quot;0&minus;9&quot;</tt>) and an optional leading
sign (&quot;<tt>&quot;+&quot;</tt>&quot; or
&quot;<tt>&quot;&minus;&quot;</tt>&quot;), a fatal
&quot;input string syntax error&quot; occurs.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that
large positive numbers which cause the most significant bit
to be set (e.g. &quot;255&quot; in a bit vector with 8 bits)
will be printed as negative numbers when converted back to
decimal using the method &quot;<i>to_Dec()</i>&quot; (e.g.
&quot;&minus;1&quot;, in our example), because numbers with
the most significant bit set are considered to be negative
in two&rsquo;s complement binary representation.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
while it is possible to thusly enter negative numbers as
large positive numbers (e.g. &quot;255&quot; for
&quot;&minus;1&quot; in a bit vector with 8 bits), the
contrary isn&rsquo;t, i.e., you cannot enter
&quot;&minus;255&quot; for &quot;+1&quot;, in our example. A
fatal &quot;numeric overflow error&quot; will occur if you
try to do so.</p>

<p style="margin-left:14%; margin-top: 1em">If possible
program abortion is unwanted or intolerable, use
&quot;<tt>&quot;eval&quot;</tt>&quot;, like this:</p>

<pre style="margin-left:14%; margin-top: 1em">  eval { $vector&minus;&gt;from_Dec(&quot;1152921504606846976&quot;); };
  if ($@)
  {
      # an error occurred
  }</pre>


<p style="margin-left:14%; margin-top: 1em">There are four
possible error messages:</p>

<pre style="margin-left:14%; margin-top: 1em">  if ($@ =~ /item is not a string/)
  if ($@ =~ /input string syntax error/)
  if ($@ =~ /numeric overflow error/)
  if ($@ =~ /unable to allocate memory/)</pre>


<p style="margin-left:14%; margin-top: 1em">Note that the
conversion from decimal to binary is costly in terms of
processing time, since a lot of multiplications have to be
carried out (in principle, each decimal digit must be
multiplied with the binary representation of the power of
<tt>10</tt> corresponding to its position in the decimal
number, i.e., 1, 10, 100, 1000, 10000 and so on).</p>

<p style="margin-left:14%; margin-top: 1em">This is not as
time consuming as the opposite conversion, from binary to
decimal (where successive divisions have to be carried out,
which are even more expensive than multiplications), but
still noticeable.</p>

<p style="margin-left:14%; margin-top: 1em">Again (as in
the case of &quot;<tt>&quot;to_Dec()&quot;</tt>&quot;), the
implementation of this method in this module uses the
principle of &quot;divide and rule&quot; in order to speed
up the conversion, i.e., as many decimal digits as possible
are first accumulated (converted) in a machine word and only
then stored in the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Even so, use
this method only where absolutely necessary if speed is an
important consideration in your application.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that if
you set the configuration for overloaded operators to
&quot;input=decimal&quot;, this method will be called for
every scalar operand you use!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>&quot;$string =
$vector&minus;&gt;to_Enum();&quot;</tt></p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Converts the
given bit vector or set into an enumeration of single
indices and ranges of indices (&quot;.newsrc&quot; style),
representing the bits that are set (&quot;<tt>1</tt>&quot;)
in the bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  $vector = Bit::Vector&minus;&gt;new(20);
  $vector&minus;&gt;Bit_On(2);
  $vector&minus;&gt;Bit_On(3);
  $vector&minus;&gt;Bit_On(11);
  $vector&minus;&gt;Interval_Fill(5,7);
  $vector&minus;&gt;Interval_Fill(13,19);
  print &quot;'&quot;, $vector&minus;&gt;to_Enum(), &quot;'\n&quot;;</pre>


<p style="margin-left:14%; margin-top: 1em">which
prints</p>

<pre style="margin-left:14%; margin-top: 1em">  '2,3,5&minus;7,11,13&minus;19'</pre>


<p style="margin-left:14%; margin-top: 1em">If the given
bit vector is empty, the resulting string will also be
empty.</p>

<p style="margin-left:14%; margin-top: 1em">Note, by the
way, that the above example can also be written a little
handier, perhaps, as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  Bit::Vector&minus;&gt;Configuration(&quot;out=enum&quot;);
  $vector = Bit::Vector&minus;&gt;new(20);
  $vector&minus;&gt;Index_List_Store(2,3,5,6,7,11,13,14,15,16,17,18,19);
  print &quot;'$vector'\n&quot;;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;from_Enum($string);&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
first empties the given bit vector and then tries to set the
bits and ranges of bits specified in the given string.</p>

<p style="margin-left:14%; margin-top: 1em">The string
&quot;<tt>$string</tt>&quot; must only contain unsigned
integers or ranges of integers (two unsigned integers
separated by a dash &quot;&minus;&quot;), separated by
commas (&quot;,&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">All other
characters are disallowed (including white space!) and will
lead to a fatal &quot;input string syntax error&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">In each range,
the first integer (the lower limit of the range) must always
be less than or equal to the second integer (the upper
limit), or a fatal &quot;minimum &gt; maximum index&quot;
error occurs.</p>

<p style="margin-left:14%; margin-top: 1em">All integers
must lie in the permitted range for the given bit vector,
i.e., they must lie between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">If this
condition is not met, a fatal &quot;index out of range&quot;
error occurs.</p>

<p style="margin-left:14%; margin-top: 1em">If possible
program abortion is unwanted or intolerable, use
&quot;<tt>&quot;eval&quot;</tt>&quot;, like this:</p>

<pre style="margin-left:14%; margin-top: 1em">  eval { $vector&minus;&gt;from_Enum(&quot;2,3,5&minus;7,11,13&minus;19&quot;); };
  if ($@)
  {
      # an error occurred
  }</pre>


<p style="margin-left:14%; margin-top: 1em">There are four
possible error messages:</p>

<pre style="margin-left:14%; margin-top: 1em">  if ($@ =~ /item is not a string/)
  if ($@ =~ /input string syntax error/)
  if ($@ =~ /index out of range/)
  if ($@ =~ /minimum &gt; maximum index/)</pre>


<p style="margin-left:14%; margin-top: 1em">Note that the
order of the indices and ranges is irrelevant, i.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">  eval { $vector&minus;&gt;from_Enum(&quot;11,5&minus;7,3,13&minus;19,2&quot;); };</pre>


<p style="margin-left:14%; margin-top: 1em">results in the
same vector as in the example above.</p>

<p style="margin-left:14%; margin-top: 1em">Ranges and
indices may also overlap.</p>

<p style="margin-left:14%; margin-top: 1em">This is because
each (single) index in the string is passed to the method
&quot;<tt>&quot;Bit_On()&quot;</tt>&quot;, internally, and
each range to the method
&quot;<tt>&quot;Interval_Fill()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the resulting bit vector is just the union of all the
indices and ranges specified in the given string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Bit_Off($index);&quot;</tt></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Clears the bit
with index &quot;<tt>$index</tt>&quot; in the given
vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Bit_On($index);&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Sets the bit
with index &quot;<tt>$index</tt>&quot; in the given
vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;bit_flip($index)&quot;</tt></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Flips (i.e.,
complements) the bit with index &quot;<tt>$index</tt>&quot;
in the given vector.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, this
method returns the <b><small>NEW</small></b> state of the
bit in question, i.e., it returns &quot;<tt>0</tt>&quot; if
the bit is cleared or &quot;<tt>1</tt>&quot; if the bit is
set ( <b><small>AFTER</small></b> flipping it).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;if
($vector&minus;&gt;bit_test($index))&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><tt>&quot;if
($vector&minus;&gt;contains($index))&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">Returns the
current state of the bit with index
&quot;<tt>$index</tt>&quot; in the given vector, i.e.,
returns &quot;<tt>0</tt>&quot; if it is cleared (in the
&quot;off&quot; state) or &quot;<tt>1</tt>&quot; if it is
set (in the &quot;on&quot; state).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Bit_Copy($index,$bit);&quot;</tt></p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Sets the bit
with index &quot;<tt>$index</tt>&quot; in the given vector
either to &quot;<tt>0</tt>&quot; or &quot;<tt>1</tt>&quot;
depending on the boolean value
&quot;<tt>$bit</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;LSB($bit);&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Allows you to
set the least significant bit in the given bit vector to the
value given by the boolean parameter
&quot;<tt>$bit</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is a
(faster) shortcut for
&quot;<tt>&quot;$vector&minus;&gt;Bit_Copy(0,$bit);&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;MSB($bit);&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Allows you to
set the most significant bit in the given bit vector to the
value given by the boolean parameter
&quot;<tt>$bit</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is a
(faster) shortcut for
&quot;<tt>&quot;$vector&minus;&gt;Bit_Copy($vector&minus;&gt;Size()&minus;1,$bit);&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;$bit =
$vector&minus;&gt;lsb();&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
least significant bit of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is a
(faster) shortcut for &quot;<tt>&quot;$bit =
$vector&minus;&gt;bit_test(0);&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;$bit =
$vector&minus;&gt;msb();&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
most significant bit of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is a
(faster) shortcut for &quot;<tt>&quot;$bit =
$vector&minus;&gt;bit_test($vector&minus;&gt;Size()&minus;1);&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>&quot;$carry_out =
$vector&minus;&gt;rotate_left();&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><tt>carry MSB
vector: LSB <br>
out: <br>
+&minus;&minus;&minus;+
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
<br>
| | &lt;&minus;&minus;&minus;+&minus;&minus;&minus; | | | |
... | | | | &lt;&minus;&minus;&minus;+ <br>
+&minus;&minus;&minus;+ |
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
| <br>
| | <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+</tt></p>

<p style="margin-left:14%; margin-top: 1em">The least
significant bit ( <small>LSB</small> ) is the bit with index
&quot;<tt>0</tt>&quot;, the most significant bit (
<small>MSB</small> ) is the bit with index
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em"><tt>&quot;$carry_out =
$vector&minus;&gt;rotate_right();&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><tt>MSB vector:
LSB carry <br>
out: <br>

+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
+&minus;&minus;&minus;+ <br>
+&minus;&minus;&minus;&gt; | | | | ... | | | |
&minus;&minus;&minus;+&minus;&minus;&minus;&gt; | | <br>
|
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
| +&minus;&minus;&minus;+ <br>
| | <br>

+&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;+</tt></p>

<p style="margin-left:14%; margin-top: 1em">The least
significant bit ( <small>LSB</small> ) is the bit with index
&quot;<tt>0</tt>&quot;, the most significant bit (
<small>MSB</small> ) is the bit with index
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$carry_out =
$vector&minus;&gt;shift_left($carry_in);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><tt>carry MSB
vector: LSB carry <br>
out: in: <br>
+&minus;&minus;&minus;+
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
+&minus;&minus;&minus;+ <br>
| | &lt;&minus;&minus;&minus; | | | | ... | | | |
&lt;&minus;&minus;&minus; | | <br>
+&minus;&minus;&minus;+
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
+&minus;&minus;&minus;+</tt></p>

<p style="margin-left:14%; margin-top: 1em">The least
significant bit ( <small>LSB</small> ) is the bit with index
&quot;<tt>0</tt>&quot;, the most significant bit (
<small>MSB</small> ) is the bit with index
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em"><tt>&quot;$carry_out =
$vector&minus;&gt;shift_right($carry_in);&quot;</tt></p> </td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><tt>carry MSB
vector: LSB carry <br>
in: out: <br>
+&minus;&minus;&minus;+
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
+&minus;&minus;&minus;+ <br>
| | &minus;&minus;&minus;&gt; | | | | ... | | | |
&minus;&minus;&minus;&gt; | | <br>
+&minus;&minus;&minus;+
+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;
&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+&minus;&minus;&minus;+
+&minus;&minus;&minus;+</tt></p>

<p style="margin-left:14%; margin-top: 1em">The least
significant bit ( <small>LSB</small> ) is the bit with index
&quot;<tt>0</tt>&quot;, the most significant bit (
<small>MSB</small> ) is the bit with index
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Move_Left($bits);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Shifts the
given bit vector left by &quot;<tt>$bits</tt>&quot; bits,
i.e., inserts &quot;<tt>$bits</tt>&quot; new bits at the
lower end (least significant bit) of the bit vector, moving
all other bits up by &quot;<tt>$bits</tt>&quot; places,
thereby losing the &quot;<tt>$bits</tt>&quot; most
significant bits.</p>

<p style="margin-left:14%; margin-top: 1em">The inserted
new bits are all cleared (set to the &quot;off&quot;
state).</p>

<p style="margin-left:14%; margin-top: 1em">This method
does nothing if &quot;<tt>$bits</tt>&quot; is equal to
zero.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that the
whole bit vector is cleared <b><small>WITHOUT
WARNING</small></b> if &quot;<tt>$bits</tt>&quot; is greater
than or equal to the size of the given bit vector!</p>

<p style="margin-left:14%; margin-top: 1em">In fact this
method is equivalent to</p>

<pre style="margin-left:14%; margin-top: 1em">  for ( $i = 0; $i &lt; $bits; $i++ ) { $vector&minus;&gt;shift_left(0); }</pre>


<p style="margin-left:14%; margin-top: 1em">except that it
is much more efficient (for &quot;<tt>$bits</tt>&quot;
greater than or equal to the number of bits in a machine
word on your system) than this straightforward approach.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Move_Right($bits);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Shifts the
given bit vector right by &quot;<tt>$bits</tt>&quot; bits,
i.e., deletes the &quot;<tt>$bits</tt>&quot; least
significant bits of the bit vector, moving all other bits
down by &quot;<tt>$bits</tt>&quot; places, thereby creating
&quot;<tt>$bits</tt>&quot; new bits at the upper end (most
significant bit) of the bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">These new bits
are all cleared (set to the &quot;off&quot; state).</p>

<p style="margin-left:14%; margin-top: 1em">This method
does nothing if &quot;<tt>$bits</tt>&quot; is equal to
zero.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that the
whole bit vector is cleared <b><small>WITHOUT
WARNING</small></b> if &quot;<tt>$bits</tt>&quot; is greater
than or equal to the size of the given bit vector!</p>

<p style="margin-left:14%; margin-top: 1em">In fact this
method is equivalent to</p>

<pre style="margin-left:14%; margin-top: 1em">  for ( $i = 0; $i &lt; $bits; $i++ ) { $vector&minus;&gt;shift_right(0); }</pre>


<p style="margin-left:14%; margin-top: 1em">except that it
is much more efficient (for &quot;<tt>$bits</tt>&quot;
greater than or equal to the number of bits in a machine
word on your system) than this straightforward approach.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Insert($offset,$bits);&quot;</tt></p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
inserts &quot;<tt>$bits</tt>&quot; fresh new bits at
position &quot;<tt>$offset</tt>&quot; in the given bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;<tt>$bits</tt>&quot; most significant bits are lost,
and all bits starting with bit number
&quot;<tt>$offset</tt>&quot; up to and including bit number
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;$bits&minus;1&quot;</tt>&quot;
are moved up by &quot;<tt>$bits</tt>&quot; places.</p>

<p style="margin-left:14%; margin-top: 1em">The now vacant
&quot;<tt>$bits</tt>&quot; bits starting at bit number
&quot;<tt>$offset</tt>&quot; (up to and including bit number
&quot;<tt>&quot;$offset+$bits&minus;1&quot;</tt>&quot;) are
then set to zero (cleared).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method does <b><small>NOT</small></b> increase the size of
the given bit vector, i.e., the bit vector is
<b><small>NOT</small></b> extended at its upper end to
&quot;rescue&quot; the &quot;<tt>$bits</tt>&quot; uppermost
(most significant) bits &minus; instead, these bits are lost
forever.</p>

<p style="margin-left:14%; margin-top: 1em">If you
don&rsquo;t want this to happen, you have to increase the
size of the given bit vector
<b><small>EXPLICITLY</small></b> and
<b><small>BEFORE</small></b> you perform the
&quot;Insert&quot; operation, with a statement such as the
following:</p>

<pre style="margin-left:14%; margin-top: 1em">  $vector&minus;&gt;Resize($vector&minus;&gt;Size() + $bits);</pre>


<p style="margin-left:14%; margin-top: 1em">Or use the
method
&quot;<tt>&quot;Interval_Substitute()&quot;</tt>&quot;
instead of &quot;<tt>&quot;Insert()&quot;</tt>&quot;, which
performs automatic growing and shrinking of its target bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset + $bits&quot;</tt>&quot; exceeds
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
all the bits starting with bit number
&quot;<tt>$offset</tt>&quot; up to bit number
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;
are simply cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Delete($offset,$bits);&quot;</tt></p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
deletes, i.e., removes the bits starting at position
&quot;<tt>$offset</tt>&quot; up to and including bit number
&quot;<tt>&quot;$offset+$bits&minus;1&quot;</tt>&quot; from
the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">The remaining
uppermost bits (starting at position
&quot;<tt>&quot;$offset+$bits&quot;</tt>&quot; up to and
including bit number
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;)
are moved down by &quot;<tt>$bits</tt>&quot; places.</p>

<p style="margin-left:14%; margin-top: 1em">The now vacant
uppermost (most significant) &quot;<tt>$bits</tt>&quot; bits
are then set to zero (cleared).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method does <b><small>NOT</small></b> decrease the size of
the given bit vector, i.e., the bit vector is
<b><small>NOT</small></b> clipped at its upper end to
&quot;get rid of&quot; the vacant &quot;<tt>$bits</tt>&quot;
uppermost bits.</p>

<p style="margin-left:14%; margin-top: 1em">If you
don&rsquo;t want this, i.e., if you want the bit vector to
shrink accordingly, you have to do so
<b><small>EXPLICITLY</small></b> and
<b><small>AFTER</small></b> the &quot;Delete&quot;
operation, with a couple of statements such as these:</p>

<pre style="margin-left:14%; margin-top: 1em">  $size = $vector&minus;&gt;Size();
  if ($bits &gt; $size) { $bits = $size; }
  $vector&minus;&gt;Resize($size &minus; $bits);</pre>


<p style="margin-left:14%; margin-top: 1em">Or use the
method
&quot;<tt>&quot;Interval_Substitute()&quot;</tt>&quot;
instead of &quot;<tt>&quot;Delete()&quot;</tt>&quot;, which
performs automatic growing and shrinking of its target bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset + $bits&quot;</tt>&quot; exceeds
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
all the bits starting with bit number
&quot;<tt>$offset</tt>&quot; up to bit number
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;
are simply cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;$carry =
$vector&minus;&gt;increment();&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
increments the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method regards bit vectors as being unsigned, i.e., the
largest possible positive number is directly followed by the
smallest possible (or greatest possible, speaking in
absolute terms) negative number:</p>

<pre style="margin-left:14%; margin-top: 1em">  before:  2 ^ (b&minus;1) &minus; 1    (= &quot;0111...1111&quot;)
  after:   2 ^ (b&minus;1)        (= &quot;1000...0000&quot;)</pre>


<p style="margin-left:14%; margin-top: 1em">where
&quot;<tt>&quot;b&quot;</tt>&quot; is the number of bits of
the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns &quot;false&quot; (&quot;<tt>0</tt>&quot;) in all
cases except when a carry over occurs (in which case it
returns &quot;true&quot;, i.e., &quot;<tt>1</tt>&quot;),
which happens when the number &quot;1111...1111&quot; is
incremented, which gives &quot;0000...0000&quot; plus a
carry over to the next higher (binary) digit.</p>

<p style="margin-left:14%; margin-top: 1em">This can be
used for the terminating condition of a &quot;while&quot;
loop, for instance, in order to cycle through all possible
values the bit vector can assume.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;$carry =
$vector&minus;&gt;decrement();&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
decrements the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method regards bit vectors as being unsigned, i.e., the
smallest possible (or greatest possible, speaking in
absolute terms) negative number is directly followed by the
largest possible positive number:</p>

<pre style="margin-left:14%; margin-top: 1em">  before:  2 ^ (b&minus;1)        (= &quot;1000...0000&quot;)
  after:   2 ^ (b&minus;1) &minus; 1    (= &quot;0111...1111&quot;)</pre>


<p style="margin-left:14%; margin-top: 1em">where
&quot;<tt>&quot;b&quot;</tt>&quot; is the number of bits of
the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns &quot;false&quot; (&quot;<tt>0</tt>&quot;) in all
cases except when a carry over occurs (in which case it
returns &quot;true&quot;, i.e., &quot;<tt>1</tt>&quot;),
which happens when the number &quot;0000...0000&quot; is
decremented, which gives &quot;1111...1111&quot; minus a
carry over to the next higher (binary) digit.</p>

<p style="margin-left:14%; margin-top: 1em">This can be
used for the terminating condition of a &quot;while&quot;
loop, for instance, in order to cycle through all possible
values the bit vector can assume.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;$overflow =
$vec2&minus;&gt;inc($vec1);&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
copies the contents of bit vector &quot;<tt>$vec1</tt>&quot;
to bit vector &quot;<tt>$vec2</tt>&quot; and increments the
copy (not the original).</p>

<p style="margin-left:14%; margin-top: 1em">If by
incrementing the number its sign becomes invalid, the return
value (&quot;overflow&quot; flag) will be true
(&quot;<tt>1</tt>&quot;), or false (&quot;<tt>0</tt>&quot;)
if not. (See the description of the method
&quot;<i>add()</i>&quot; below for a more in-depth
explanation of what &quot;overflow&quot; means).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
in-place operation is also possible, i.e.,
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
may be identical.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;$overflow =
$vec2&minus;&gt;dec($vec1);&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
copies the contents of bit vector &quot;<tt>$vec1</tt>&quot;
to bit vector &quot;<tt>$vec2</tt>&quot; and decrements the
copy (not the original).</p>

<p style="margin-left:14%; margin-top: 1em">If by
decrementing the number its sign becomes invalid, the return
value (&quot;overflow&quot; flag) will be true
(&quot;<tt>1</tt>&quot;), or false (&quot;<tt>0</tt>&quot;)
if not. (See the description of the method
&quot;<i>subtract()</i>&quot; below for a more in-depth
explanation of what &quot;overflow&quot; means).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
in-place operation is also possible, i.e.,
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
may be identical.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em"><tt>&quot;$carry =
$vec3&minus;&gt;add($vec1,$vec2,$carry);&quot;</tt></p> </td>
<td width="22%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;($carry,$overflow)
= $vec3&minus;&gt;add($vec1,$vec2,$carry);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
adds the two numbers contained in bit vector
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
with carry &quot;<tt>$carry</tt>&quot; and stores the result
in bit vector &quot;<tt>$vec3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., <tt><br>
$vec3</tt> = <tt>$vec1</tt> + <tt>$vec2</tt> +
<tt>$carry</tt></p>

<p style="margin-left:14%; margin-top: 1em">Note that the
&quot;<tt>$carry</tt>&quot; parameter is a boolean value,
i.e., only its least significant bit is taken into account.
(Think of it as though &quot;<tt>&quot;$carry &amp;=
1;&quot;</tt>&quot; was always executed internally.)</p>

<p style="margin-left:14%; margin-top: 1em">In scalar
context, the method returns a boolean value which indicates
if a carry over (to the next higher bit position) has
occured. In list context, the method returns the carry and
the overflow flag (in this order).</p>

<p style="margin-left:14%; margin-top: 1em">The overflow
flag is true (&quot;<tt>1</tt>&quot;) if the sign (i.e., the
most significant bit) of the result is wrong. This can
happen when adding two very large positive numbers or when
adding two (by their absolute value) very large negative
numbers. See also further below.</p>

<p style="margin-left:14%; margin-top: 1em">The carry
in&minus; and output is needed mainly for cascading, i.e.,
to add numbers that are fragmented into several pieces.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  # initialize
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $a[$i] = Bit::Vector&minus;&gt;new($bits);
      $b[$i] = Bit::Vector&minus;&gt;new($bits);
      $c[$i] = Bit::Vector&minus;&gt;new($bits);
  }
  # fill @a and @b
  # $a[  0 ] is low order part,
  # $a[$n&minus;1] is high order part,
  # and same for @b
  # add
  $carry = 0;
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $carry = $c[$i]&minus;&gt;add($a[$i],$b[$i],$carry);
  }</pre>


<p style="margin-left:14%; margin-top: 1em">Note that it
makes no difference to this method whether the numbers in
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
are unsigned or signed (i.e., in two&rsquo;s complement
binary representation).</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that the return value (carry flag) is not meaningful when
the numbers are <b><small>SIGNED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, when
the numbers are signed, a special type of error can occur
which is commonly called an &quot;overflow error&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">An overflow
error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry
over from the next-lower bit position (&quot;
<small>MSB&minus;1&quot;</small> ).</p>

<p style="margin-left:14%; margin-top: 1em">In fact matters
are a bit more complicated than that: the overflow flag is
set to &quot;true&quot; whenever there is a carry over from
bit position <small>MSB&minus;1</small> to the most
significant bit ( <small>MSB</small> ) but no carry over
from the <small>MSB</small> to the output carry flag, or
vice-versa, i.e., when there is no carry over from bit
position <small>MSB&minus;1</small> to the most significant
bit ( <small>MSB</small> ) but a carry over to the output
carry flag.</p>

<p style="margin-left:14%; margin-top: 1em">Thus the
overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most
significant bit position.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em"><tt>&quot;$carry =
$vec3&minus;&gt;subtract($vec1,$vec2,$carry);&quot;</tt></p> </td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;($carry,$overflow)
=
$vec3&minus;&gt;subtract($vec1,$vec2,$carry);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
subtracts the two numbers contained in bit vector
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
with carry &quot;<tt>$carry</tt>&quot; and stores the result
in bit vector &quot;<tt>$vec3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., <tt><br>
$vec3</tt> = <tt>$vec1</tt> &minus; <tt>$vec2</tt> &minus;
<tt>$carry</tt></p>

<p style="margin-left:14%; margin-top: 1em">Note that the
&quot;<tt>$carry</tt>&quot; parameter is a boolean value,
i.e., only its least significant bit is taken into account.
(Think of it as though &quot;<tt>&quot;$carry &amp;=
1;&quot;</tt>&quot; was always executed internally.)</p>

<p style="margin-left:14%; margin-top: 1em">In scalar
context, the method returns a boolean value which indicates
if a carry over (to the next higher bit position) has
occured. In list context, the method returns the carry and
the overflow flag (in this order).</p>

<p style="margin-left:14%; margin-top: 1em">The overflow
flag is true (&quot;<tt>1</tt>&quot;) if the sign (i.e., the
most significant bit) of the result is wrong. This can
happen when subtracting a very large negative number from a
very large positive number or vice-versa. See also further
below.</p>

<p style="margin-left:14%; margin-top: 1em">The carry
in&minus; and output is needed mainly for cascading, i.e.,
to subtract numbers that are fragmented into several
pieces.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  # initialize
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $a[$i] = Bit::Vector&minus;&gt;new($bits);
      $b[$i] = Bit::Vector&minus;&gt;new($bits);
      $c[$i] = Bit::Vector&minus;&gt;new($bits);
  }
  # fill @a and @b
  # $a[  0 ] is low order part,
  # $a[$n&minus;1] is high order part,
  # and same for @b
  # subtract
  $carry = 0;
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $carry = $c[$i]&minus;&gt;subtract($a[$i],$b[$i],$carry);
  }</pre>


<p style="margin-left:14%; margin-top: 1em">Note that it
makes no difference to this method whether the numbers in
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
are unsigned or signed (i.e., in two&rsquo;s complement
binary representation).</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that the return value (carry flag) is not meaningful when
the numbers are <b><small>SIGNED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, when
the numbers are signed, a special type of error can occur
which is commonly called an &quot;overflow error&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">An overflow
error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry
over from the next-lower bit position (&quot;
<small>MSB&minus;1&quot;</small> ).</p>

<p style="margin-left:14%; margin-top: 1em">In fact matters
are a bit more complicated than that: the overflow flag is
set to &quot;true&quot; whenever there is a carry over from
bit position <small>MSB&minus;1</small> to the most
significant bit ( <small>MSB</small> ) but no carry over
from the <small>MSB</small> to the output carry flag, or
vice-versa, i.e., when there is no carry over from bit
position <small>MSB&minus;1</small> to the most significant
bit ( <small>MSB</small> ) but a carry over to the output
carry flag.</p>

<p style="margin-left:14%; margin-top: 1em">Thus the
overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most
significant bit position.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Neg($vec1);&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Negate($vec1);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the two&rsquo;s complement of the number in bit
vector &quot;<tt>$vec1</tt>&quot; and stores the result in
bit vector &quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Calculating the
two&rsquo;s complement of a given number in binary
representation consists of inverting all bits and
incrementing the result by one.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as changing the sign of the given number from
&quot;<tt>&quot;+&quot;</tt>&quot; to
&quot;<tt>&quot;&minus;&quot;</tt>&quot; or vice-versa. In
other words, applying this method twice on a given number
yields the original number again.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
in-place processing is also possible, i.e.,
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
may be identical.</p>

<p style="margin-left:14%; margin-top: 1em">Most
importantly, beware that this method produces a
counter-intuitive result if the number contained in bit
vector &quot;<tt>$vec1</tt>&quot; is <tt>&quot;2 ^
(n&minus;1)&quot;</tt> (i.e., &quot;1000...0000&quot;),
where &quot;<tt>&quot;n&quot;</tt>&quot; is the number of
bits the given bit vector contains: The negated value of
this number is the number itself!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Abs($vec1);&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Absolute($vec1);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">Depending on
the sign (i.e., the most significant bit) of the number in
bit vector &quot;<tt>$vec1</tt>&quot;, the contents of bit
vector &quot;<tt>$vec1</tt>&quot; are copied to bit vector
&quot;<tt>$vec2</tt>&quot; either with the method
&quot;<tt>&quot;Copy()&quot;</tt>&quot; (if the number in
bit vector &quot;<tt>$vec1</tt>&quot; is positive), or with
&quot;<tt>&quot;Negate()&quot;</tt>&quot; (if the number in
bit vector &quot;<tt>$vec1</tt>&quot; is negative).</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
this method calculates the absolute value of the number in
bit vector &quot;<tt>$vec1</tt>&quot; and stores the result
in bit vector &quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
in-place processing is also possible, i.e.,
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
may be identical.</p>

<p style="margin-left:14%; margin-top: 1em">Most
importantly, beware that this method produces a
counter-intuitive result if the number contained in bit
vector &quot;<tt>$vec1</tt>&quot; is <tt>&quot;2 ^
(n&minus;1)&quot;</tt> (i.e., &quot;1000...0000&quot;),
where &quot;<tt>&quot;n&quot;</tt>&quot; is the number of
bits the given bit vector contains: The absolute value of
this number is the number itself, even though this number is
still negative by definition (the most significant bit is
still set)!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;$sign =
$vector&minus;&gt;Sign();&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns &quot;<tt>0</tt>&quot; if all bits in the given bit
vector are cleared, i.e., if the given bit vector contains
the number &quot;<tt>0</tt>&quot;, or if the given bit
vector has a length of zero (contains no bits at all).</p>

<p style="margin-left:14%; margin-top: 1em">If not all bits
are cleared, this method returns
&quot;<tt>&quot;&minus;1&quot;</tt>&quot; if the most
significant bit is set (i.e., if the bit vector contains a
negative number), or &quot;<tt>1</tt>&quot; otherwise (i.e.,
if the bit vector contains a positive number).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;Multiply($vec1,$vec2);&quot;</tt></p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
multiplies the two numbers contained in bit vector
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
and stores the result in bit vector
&quot;<tt>$vec3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method regards its arguments as <b><small>SIGNED</small></b>
.</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit
longer than the largest number you wish to represent, right
from the start, or proceed as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">    $msb1 = $vec1&minus;&gt;msb();
    $msb2 = $vec2&minus;&gt;msb();
    $vec1&minus;&gt;Resize($vec1&minus;&gt;Size()+1);
    $vec2&minus;&gt;Resize($vec2&minus;&gt;Size()+1);
    $vec3&minus;&gt;Resize($vec3&minus;&gt;Size()+1);
    $vec1&minus;&gt;MSB($msb1);
    $vec2&minus;&gt;MSB($msb2);
    $vec3&minus;&gt;Multiply($vec1,$vec2);</pre>


<p style="margin-left:14%; margin-top: 1em">Note also that
all three bit vector arguments must in principle obey the
rule of matching sizes, but that the bit vector
&quot;<tt>$vec3</tt>&quot; may be larger than the two
factors &quot;<tt>$vec1</tt>&quot; and
&quot;<tt>$vec2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">In fact
multiplying two binary numbers with
&quot;<tt>&quot;n&quot;</tt>&quot; bits may yield a result
which is at most &quot;<tt>&quot;2n&quot;</tt>&quot; bits
long.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, it
is usually a good idea to let bit vector
&quot;<tt>$vec3</tt>&quot; have twice the size of bit vector
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;,
unless you are absolutely sure that the result will fit into
a bit vector of the same size as the two factors.</p>

<p style="margin-left:14%; margin-top: 1em">If you are
wrong, a fatal &quot;numeric overflow error&quot; will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">Finally, note
that in-place processing is possible, i.e.,
&quot;<tt>$vec3</tt>&quot; may be identical with
&quot;<tt>$vec1</tt>&quot; or &quot;<tt>$vec2</tt>&quot;, or
both.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">



<p style="margin-top: 1em"><tt>&quot;$quot&minus;&gt;Divide($vec1,$vec2,$rest);&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
divides the two numbers contained in bit vector
&quot;<tt>$vec1</tt>&quot; and &quot;<tt>$vec2</tt>&quot;
and stores the quotient in bit vector
&quot;<tt>$quot</tt>&quot; and the remainder in bit vector
&quot;<tt>$rest</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., <tt><br>
$quot</tt> = <tt>$vec1</tt> / <tt>$vec2</tt>; # div <tt><br>
$rest</tt> = <tt>$vec1</tt> % <tt>$vec2</tt>; # mod</p>

<p style="margin-left:14%; margin-top: 1em">Therefore,
&quot;<tt>$quot</tt>&quot; and &quot;<tt>$rest</tt>&quot;
must be two <b><small>DISTINCT</small></b> bit vectors, or a
fatal &quot;result vector(s) must be distinct&quot; error
will occur.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
a fatal &quot;division by zero error&quot; will occur if
&quot;<tt>$vec2</tt>&quot; is equal to zero.</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that this method regards its arguments as
<b><small>SIGNED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit
longer than the largest number you wish to represent, right
from the start, or proceed as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">    $msb1 = $vec1&minus;&gt;msb();
    $msb2 = $vec2&minus;&gt;msb();
    $vec1&minus;&gt;Resize($vec1&minus;&gt;Size()+1);
    $vec2&minus;&gt;Resize($vec2&minus;&gt;Size()+1);
    $quot&minus;&gt;Resize($quot&minus;&gt;Size()+1);
    $rest&minus;&gt;Resize($rest&minus;&gt;Size()+1);
    $vec1&minus;&gt;MSB($msb1);
    $vec2&minus;&gt;MSB($msb2);
    $quot&minus;&gt;Divide($vec1,$vec2,$rest);</pre>


<p style="margin-left:14%; margin-top: 1em">Finally, note
that in-place processing is possible, i.e.,
&quot;<tt>$quot</tt>&quot; may be identical with
&quot;<tt>$vec1</tt>&quot; or &quot;<tt>$vec2</tt>&quot; or
both, and &quot;<tt>$rest</tt>&quot; may also be identical
with &quot;<tt>$vec1</tt>&quot; or
&quot;<tt>$vec2</tt>&quot; or both, as long as
&quot;<tt>$quot</tt>&quot; and &quot;<tt>$rest</tt>&quot;
are distinct. (!)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">



<p style="margin-top: 1em"><tt>&quot;$vecgcd&minus;&gt;GCD($veca,$vecb);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the &quot;Greatest Common Divisor&quot; of the
two numbers contained in bit vector
&quot;<tt>$veca</tt>&quot; and &quot;<tt>$vecb</tt>&quot;
and stores the result in bit vector
&quot;<tt>$vecgcd</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The method uses
Euklid&rsquo;s algorithm internally:</p>

<pre style="margin-left:14%; margin-top: 1em">    int GCD(int a, int b)
    {
        int t;
        while (b != 0)
        {
            t = a % b; /* = remainder of (a div b) */
            a = b;
            b = t;
        }
        return(a);
    }</pre>


<p style="margin-left:14%; margin-top: 1em">Note that
<tt>&quot;GCD(z,0) == GCD(0,z) == z&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">



<p style="margin-top: 1em"><tt>&quot;$vecgcd&minus;&gt;GCD($vecx,$vecy,$veca,$vecb);&quot;</tt></p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This variant of
the &quot; <small>GCD&quot;</small> method calculates the
&quot;Greatest Common Divisor&quot; of the two numbers
contained in bit vector &quot;<tt>$veca</tt>&quot; and
&quot;<tt>$vecb</tt>&quot; and stores the result in bit
vector &quot;<tt>$vecgcd</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, it
determines the two factors which are necessary in order to
represent the greatest common divisor as a linear
combination of its two arguments, i.e., the two factors
<tt>&quot;x&quot;</tt> and <tt>&quot;y&quot;</tt> so that
<tt>&quot;GCD(a,b) == x * a + y * b&quot;</tt>, and stores
them in bit vector &quot;<tt>$vecx</tt>&quot; and
&quot;<tt>$vecy</tt>&quot;, respectively.</p>

<p style="margin-left:14%; margin-top: 1em">For
example:</p>

<pre style="margin-left:14%; margin-top: 1em">  a = 2322
  b =  654
  GCD( 2322, 654 ) == 6
  x =  20
  y = &minus;71
  20 * 2322 &minus; 71 * 654 == 6</pre>


<p style="margin-left:14%; margin-top: 1em">Please see
http://www.cut&minus;the&minus;knot.org/blue/extension.shtml
for an explanation of how this extension of Euklid&rsquo;s
algorithm works.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;Power($vec1,$vec2);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the exponentiation of base
&quot;<tt>$vec1</tt>&quot; elevated to the
&quot;<tt>$vec2</tt>&quot; power, i.e.,
&quot;<tt>&quot;$vec1 ** $vec2&quot;</tt>&quot;, and stores
the result in bit vector &quot;<tt>$vec3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The method uses
an efficient divide-and-conquer algorithm:</p>

<p style="margin-left:14%; margin-top: 1em">Suppose the
exponent is (decimal) 13, for example. The binary
representation of this exponent is &quot;1101&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This means we
want to calculate</p>

<pre style="margin-left:14%; margin-top: 1em">  $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 *
  $vec1 * $vec1 * $vec1 * $vec1 *
  $vec1</pre>


<p style="margin-left:14%; margin-top: 1em">That is,
&quot;<tt>$vec1</tt>&quot; multiplied with itself 13 times.
The grouping into lines above is no coincidence. The first
line comprises 8 factors, the second contains 4, and the
last line just one. This just happens to be the binary
representation of 13. <tt>&quot;;&minus;)&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">We then
calculate a series of squares (of squares of squares...) of
the base, i.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">  $power[0] = $vec1;
  $power[1] = $vec1 * $vec1;
  $power[2] = $power[1] * $power[1];
  $power[3] = $power[2] * $power[2];
  etc.</pre>


<p style="margin-left:14%; margin-top: 1em">To calculate
the power of our example, we simply initialize our result
with 1 and consecutively multiply it with the items of the
series of powers we just calculated, if the corresponding
bit of the binary representation of the exponent is set:</p>

<pre style="margin-left:14%; margin-top: 1em">  $result = 1;
  $result *= $power[0] if ($vec2 &amp; 1);
  $result *= $power[1] if ($vec2 &amp; 2);
  $result *= $power[2] if ($vec2 &amp; 4);
  $result *= $power[3] if ($vec2 &amp; 8);
  etc.</pre>


<p style="margin-left:14%; margin-top: 1em">The bit vector
&quot;<tt>$vec3</tt>&quot; must be of the same size as the
base &quot;<tt>$vec1</tt>&quot; or greater.
&quot;<tt>$vec3</tt>&quot; and &quot;<tt>$vec1</tt>&quot;
may be the same vector (i.e., in-place calculation as in
&quot;<tt>&quot;$vec1 **= $vec2;&quot;</tt>&quot; is
possible), but &quot;<tt>$vec3</tt>&quot; and
&quot;<tt>$vec2</tt>&quot; must be distinct. Finally, the
exponent &quot;<tt>$vec2</tt>&quot; must be positive. A
fatal error occurs if any of these conditions is not
met.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Block_Store($buffer);&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to load the contents of a given bit vector in one
go.</p>

<p style="margin-left:14%; margin-top: 1em">This is useful
when you store the contents of a bit vector in a file, for
instance (using method
&quot;<tt>&quot;Block_Read()&quot;</tt>&quot;), and when you
want to restore the previously saved bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">For this,
&quot;<tt>$buffer</tt>&quot; <b><small>MUST</small></b> be a
string ( <b><small>NO</small></b> automatic conversion from
numeric to string is provided here as would normally in
Perl!) containing the bit vector in &quot;low order byte
first&quot; order.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string is shorter than what is needed to completely fill the
given bit vector, the remaining (most significant) bytes of
the bit vector are filled with zeros, i.e., the previous
contents of the bit vector are always erased completely.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
string is longer than what is needed to completely fill the
given bit vector, the superfluous bytes are simply
ignored.</p>

<p style="margin-left:14%; margin-top: 1em">See
&quot;sysread&quot; in perlfunc for how to read in the
contents of &quot;<tt>$buffer</tt>&quot; from a file prior
to passing it to this method.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>&quot;$buffer =
$vector&minus;&gt;Block_Read();&quot;</tt></p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to export the contents of a given bit vector in
one block.</p>

<p style="margin-left:14%; margin-top: 1em">This is useful
when you want to save the contents of a bit vector for
later, for instance in a file.</p>

<p style="margin-left:14%; margin-top: 1em">The advantage
of this method is that it allows you to do so in the
compactest possible format, in binary.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns a Perl string which contains an exact copy of the
contents of the given bit vector in &quot;low order byte
first&quot; order.</p>

<p style="margin-left:14%; margin-top: 1em">See
&quot;syswrite&quot; in perlfunc for how to write the data
from this string to a file.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em"><tt>&quot;$size =
$vector&minus;&gt;Word_Size();&quot;</tt></p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Each bit vector
is internally organized as an array of machine words.</p>

<p style="margin-left:14%; margin-top: 1em">The methods
whose names begin with &quot;Word_&quot; allow you to access
this internal array of machine words.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
because the size of a machine word may vary from system to
system, these methods are inherently
<b>MACHINE-DEPENDENT</b>!</p>

<p style="margin-left:14%; margin-top: 1em">Therefore,
<b><small>DO NOT USE</small></b> these methods unless you
are absolutely certain that portability of your code is not
an issue!</p>

<p style="margin-left:14%; margin-top: 1em">You have been
warned!</p>

<p style="margin-left:14%; margin-top: 1em">To be
machine-independent, use the methods whose names begin with
&quot;<tt>&quot;Chunk_&quot;</tt>&quot; instead, with chunk
sizes no greater than 32 bits.</p>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<tt>&quot;Word_Size()&quot;</tt>&quot; returns the
number of machine words that the internal array of words of
the given bit vector contains.</p>

<p style="margin-left:14%; margin-top: 1em">This is similar
in function to the term
&quot;<tt>&quot;scalar(@array)&quot;</tt>&quot; for a Perl
array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Word_Store($offset,$word);&quot;</tt></p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to store a given value &quot;<tt>$word</tt>&quot;
at a given position &quot;<tt>$offset</tt>&quot; in the
internal array of words of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
similar in function to the expression
&quot;<tt>&quot;$array[$offset] = $word;&quot;</tt>&quot;
for a Perl array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>&quot;$word =
$vector&minus;&gt;Word_Read($offset);&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to access the value of a given machine word at
position &quot;<tt>$offset</tt>&quot; in the internal array
of words of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
similar in function to the expression &quot;<tt>&quot;$word
= $array[$offset];&quot;</tt>&quot; for a Perl array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Word_List_Store(@words);&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to store a list of values
&quot;<tt>@words</tt>&quot; in the internal array of machine
words of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Thereby the
<b><small>LEFTMOST</small></b> value in the list
(&quot;<tt>$words[0]</tt>&quot;) is stored in the
<b><small>LEAST</small></b> significant word of the internal
array of words (the one with offset &quot;<tt>0</tt>&quot;),
the next value from the list
(&quot;<tt>$words[1]</tt>&quot;) is stored in the word with
offset &quot;<tt>1</tt>&quot;, and so on, as intuitively
expected.</p>

<p style="margin-left:14%; margin-top: 1em">If the list
&quot;<tt>@words</tt>&quot; contains fewer elements than the
internal array of words of the given bit vector contains
machine words, the remaining (most significant) words are
filled with zeros.</p>

<p style="margin-left:14%; margin-top: 1em">If the list
&quot;<tt>@words</tt>&quot; contains more elements than the
internal array of words of the given bit vector contains
machine words, the superfluous values are simply
ignored.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
comparable in function to the expression
&quot;<tt>&quot;@array = @words;&quot;</tt>&quot; for a Perl
array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p style="margin-top: 1em"><tt>&quot;@words =
$vector&minus;&gt;Word_List_Read();&quot;</tt></p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to retrieve the internal array of machine words
of the given bit vector all at once.</p>

<p style="margin-left:14%; margin-top: 1em">Thereby the
<b><small>LEFTMOST</small></b> value in the returned list
(&quot;<tt>$words[0]</tt>&quot;) is the
<b><small>LEAST</small></b> significant word from the given
bit vector, and the <b><small>RIGHTMOST</small></b> value in
the returned list (&quot;<tt>$words[$#words]</tt>&quot;) is
the <b><small>MOST</small></b> significant word of the given
bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
similar in function to the expression &quot;<tt>&quot;@words
= @array;&quot;</tt>&quot; for a Perl array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Word_Insert($offset,$count);&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
inserts &quot;<tt>$count</tt>&quot; empty new machine words
at position &quot;<tt>$offset</tt>&quot; in the internal
array of words of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;<tt>$count</tt>&quot; most significant words are lost,
and all words starting with word number
&quot;<tt>$offset</tt>&quot; up to and including word number
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;$count&minus;1&quot;</tt>&quot;
are moved up by &quot;<tt>$count</tt>&quot; places.</p>

<p style="margin-left:14%; margin-top: 1em">The now vacant
&quot;<tt>$count</tt>&quot; words starting at word number
&quot;<tt>$offset</tt>&quot; (up to and including word
number
&quot;<tt>&quot;$offset+$count&minus;1&quot;</tt>&quot;) are
then set to zero (cleared).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method does <b><small>NOT</small></b> increase the size of
the given bit vector, i.e., the bit vector is
<b><small>NOT</small></b> extended at its upper end to
&quot;rescue&quot; the &quot;<tt>$count</tt>&quot; uppermost
(most significant) words &minus; instead, these words are
lost forever.</p>

<p style="margin-left:14%; margin-top: 1em">If you
don&rsquo;t want this to happen, you have to increase the
size of the given bit vector
<b><small>EXPLICITLY</small></b> and
<b><small>BEFORE</small></b> you perform the
&quot;Insert&quot; operation, with a statement such as the
following:</p>

<pre style="margin-left:14%; margin-top: 1em">  $vector&minus;&gt;Resize($vector&minus;&gt;Size() + $count * Bit::Vector&minus;&gt;Word_Bits());</pre>


<p style="margin-left:14%; margin-top: 1em">Note also that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset + $count&quot;</tt>&quot; exceeds
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
all the words starting with word number
&quot;<tt>$offset</tt>&quot; up to word number
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;
are simply cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Word_Delete($offset,$count);&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
deletes, i.e., removes the words starting at position
&quot;<tt>$offset</tt>&quot; up to and including word number
&quot;<tt>&quot;$offset+$count&minus;1&quot;</tt>&quot; from
the internal array of machine words of the given bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">The remaining
uppermost words (starting at position
&quot;<tt>&quot;$offset+$count&quot;</tt>&quot; up to and
including word number
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;)
are moved down by &quot;<tt>$count</tt>&quot; places.</p>

<p style="margin-left:14%; margin-top: 1em">The now vacant
uppermost (most significant) &quot;<tt>$count</tt>&quot;
words are then set to zero (cleared).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method does <b><small>NOT</small></b> decrease the size of
the given bit vector, i.e., the bit vector is
<b><small>NOT</small></b> clipped at its upper end to
&quot;get rid of&quot; the vacant
&quot;<tt>$count</tt>&quot; uppermost words.</p>

<p style="margin-left:14%; margin-top: 1em">If you
don&rsquo;t want this, i.e., if you want the bit vector to
shrink accordingly, you have to do so
<b><small>EXPLICITLY</small></b> and
<b><small>AFTER</small></b> the &quot;Delete&quot;
operation, with a couple of statements such as these:</p>

<pre style="margin-left:14%; margin-top: 1em">  $bits = $vector&minus;&gt;Size();
  $count *= Bit::Vector&minus;&gt;Word_Bits();
  if ($count &gt; $bits) { $count = $bits; }
  $vector&minus;&gt;Resize($bits &minus; $count);</pre>


<p style="margin-left:14%; margin-top: 1em">Note also that
&quot;<tt>$offset</tt>&quot; must lie in the permitted range
between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset + $count&quot;</tt>&quot; exceeds
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;,
all the words starting with word number
&quot;<tt>$offset</tt>&quot; up to word number
&quot;<tt>&quot;$vector&minus;&gt;Word_Size()&minus;1&quot;</tt>&quot;
are simply cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="77%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Chunk_Store($chunksize,$offset,$chunk);&quot;</tt></p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to set more than one bit at a time with different
values.</p>

<p style="margin-left:14%; margin-top: 1em">You can access
chunks (i.e., ranges of contiguous bits) between one and at
most
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;
bits wide.</p>

<p style="margin-left:14%; margin-top: 1em">In order to be
portable, though, you should never use chunk sizes larger
than 32 bits.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
&quot;<tt>$chunksize</tt>&quot; does not lie between
&quot;<tt>1</tt>&quot; and
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;,
a fatal &quot;chunk size out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">The method
copies the &quot;<tt>$chunksize</tt>&quot; least significant
bits from the value &quot;<tt>$chunk</tt>&quot; to the given
bit vector, starting at bit position
&quot;<tt>$offset</tt>&quot; and proceeding upwards until
bit number
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">(I.e., bit
number &quot;<tt>0</tt>&quot; of &quot;<tt>$chunk</tt>&quot;
becomes bit number &quot;<tt>$offset</tt>&quot; in the given
bit vector, and bit number
&quot;<tt>&quot;$chunksize&minus;1&quot;</tt>&quot; becomes
bit number
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;
exceeds
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
the corresponding superfluous (most significant) bits from
&quot;<tt>$chunk</tt>&quot; are simply ignored.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>$offset</tt>&quot; itself must lie in the
permitted range between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">This method (as
well as the other &quot;<tt>&quot;Chunk_&quot;</tt>&quot;
methods) is useful, for example, when you are reading in
data in chunks of, say, 8 bits, which you need to access
later, say, using 16 bits at a time (like audio
<small>CD</small> wave files, for instance).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><tt>&quot;$chunk =
$vector&minus;&gt;Chunk_Read($chunksize,$offset);&quot;</tt></p> </td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to read the values of more than one bit at a
time.</p>

<p style="margin-left:14%; margin-top: 1em">You can read
chunks (i.e., ranges of contiguous bits) between one and at
most
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;
bits wide.</p>

<p style="margin-left:14%; margin-top: 1em">In order to be
portable, though, you should never use chunk sizes larger
than 32 bits.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
&quot;<tt>$chunksize</tt>&quot; does not lie between
&quot;<tt>1</tt>&quot; and
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;,
a fatal &quot;chunk size out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns the &quot;<tt>$chunksize</tt>&quot; bits from the
given bit vector starting at bit position
&quot;<tt>$offset</tt>&quot; and proceeding upwards until
bit number
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">(I.e., bit
number &quot;<tt>$offset</tt>&quot; of the given bit vector
becomes bit number &quot;<tt>0</tt>&quot; of the returned
value, and bit number
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;
becomes bit number
&quot;<tt>&quot;$chunksize&minus;1&quot;</tt>&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">If the term
&quot;<tt>&quot;$offset+$chunksize&minus;1&quot;</tt>&quot;
exceeds
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
the non-existent bits are simply not returned.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>$offset</tt>&quot; itself must lie in the
permitted range between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;offset out of range&quot; error will
occur.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Chunk_List_Store($chunksize,@chunks);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to fill the given bit vector with a list of data
packets (&quot;chunks&quot;) of any size
(&quot;<tt>$chunksize</tt>&quot;) you like (within certain
limits).</p>

<p style="margin-left:14%; margin-top: 1em">In fact the
given &quot;<tt>$chunksize</tt>&quot; must lie in the range
between &quot;<tt>1</tt>&quot; and
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;,
or a fatal &quot;chunk size out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">In order to be
portable, though, you should never use chunk sizes larger
than 32 bits.</p>

<p style="margin-left:14%; margin-top: 1em">The given bit
vector is thereby filled in ascending order: The first chunk
from the list (i.e., &quot;<tt>$chunks[0]</tt>&quot;) fills
the &quot;<tt>$chunksize</tt>&quot; least significant bits,
the next chunk from the list
(&quot;<tt>$chunks[1]</tt>&quot;) fills the bits number
&quot;<tt>$chunksize</tt>&quot; to number
&quot;<tt>&quot;2*$chunksize&minus;1&quot;</tt>&quot;, the
third chunk (&quot;<tt>$chunks[2]</tt>&quot;) fills the bits
number &quot;<tt>&quot;2*$chunksize&quot;</tt>&quot;, to
number
&quot;<tt>&quot;3*$chunksize&minus;1&quot;</tt>&quot;, and
so on.</p>

<p style="margin-left:14%; margin-top: 1em">If there a less
chunks in the list than are needed to fill the entire bit
vector, the remaining (most significant) bits are cleared,
i.e., the previous contents of the given bit vector are
always erased completely.</p>

<p style="margin-left:14%; margin-top: 1em">If there are
more chunks in the list than are needed to fill the entire
bit vector, and/or if a chunk extends beyond
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;
(which happens whenever
&quot;<tt>&quot;$vector&minus;&gt;Size()&quot;</tt>&quot; is
not a multiple of &quot;<tt>$chunksize</tt>&quot;), the
superfluous chunks and/or bits are simply ignored.</p>

<p style="margin-left:14%; margin-top: 1em">The method is
useful, for example (and among many other applications), for
the conversion of packet sizes in a data stream.</p>

<p style="margin-left:14%; margin-top: 1em">This method can
also be used to store an octal string in a given bit
vector:</p>

<pre style="margin-left:14%; margin-top: 1em">  $vector&minus;&gt;Chunk_List_Store(3, split(//, reverse $string));</pre>


<p style="margin-left:14%; margin-top: 1em">Note however
that unlike the conversion methods
&quot;<tt>&quot;from_Hex()&quot;</tt>&quot;,
&quot;<tt>&quot;from_Bin()&quot;</tt>&quot;,
&quot;<tt>&quot;from_Dec()&quot;</tt>&quot; and
&quot;<tt>&quot;from_Enum()&quot;</tt>&quot;, this statement
does not include any syntax checking, i.e., it may fail
silently, without warning.</p>

<p style="margin-left:14%; margin-top: 1em">To perform
syntax checking, add the following statements:</p>

<pre style="margin-left:14%; margin-top: 1em">  if ($string =~ /^[0&minus;7]+$/)
  {
      # okay, go ahead with conversion as shown above
  }
  else
  {
      # error, string contains other than octal characters
  }</pre>


<p style="margin-left:14%; margin-top: 1em">Another
application is to store a repetitive pattern in a given bit
vector:</p>

<pre style="margin-left:14%; margin-top: 1em">  $pattern = 0xDEADBEEF;
  $length = 32;            # = length of $pattern in bits
  $size = $vector&minus;&gt;Size();
  $factor = int($size / $length);
  if ($size % $length) { $factor++; }
  $vector&minus;&gt;Chunk_List_Store($length, ($pattern) x $factor);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><tt>&quot;@chunks =
$vector&minus;&gt;Chunk_List_Read($chunksize);&quot;</tt></p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to access the contents of the given bit vector in
form of a list of data packets (&quot;chunks&quot;) of a
size (&quot;<tt>$chunksize</tt>&quot;) of your choosing
(within certain limits).</p>

<p style="margin-left:14%; margin-top: 1em">In fact the
given &quot;<tt>$chunksize</tt>&quot; must lie in the range
between &quot;<tt>1</tt>&quot; and
&quot;<tt>&quot;Bit::Vector&minus;&gt;Long_Bits()&quot;</tt>&quot;,
or a fatal &quot;chunk size out of range&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">In order to be
portable, though, you should never use chunk sizes larger
than 32 bits.</p>

<p style="margin-left:14%; margin-top: 1em">The given bit
vector is thereby read in ascending order: The
&quot;<tt>$chunksize</tt>&quot; least significant bits (bits
number &quot;<tt>0</tt>&quot; to
&quot;<tt>&quot;$chunksize&minus;1&quot;</tt>&quot;) become
the first chunk in the returned list (i.e.,
&quot;<tt>$chunks[0]</tt>&quot;). The bits number
&quot;<tt>$chunksize</tt>&quot; to
&quot;<tt>&quot;2*$chunksize&minus;1&quot;</tt>&quot; become
the next chunk in the list
(&quot;<tt>$chunks[1]</tt>&quot;), and so on.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>&quot;$vector&minus;&gt;Size()&quot;</tt>&quot; is
not a multiple of &quot;<tt>$chunksize</tt>&quot;, the last
chunk in the list will contain fewer bits than
&quot;<tt>$chunksize</tt>&quot;.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that for large bit vectors and/or small values of
&quot;<tt>$chunksize</tt>&quot;, the number of returned list
elements can be extremely large! <b><small>BE
CAREFUL</small> !</b></p>

<p style="margin-left:14%; margin-top: 1em">You could blow
up your application with lack of memory (each list element
is a full-grown Perl scalar, internally, with an associated
memory overhead for its administration!) or at least cause a
noticeable, more or less long-lasting &quot;freeze&quot; of
your application!</p>

<p style="margin-left:14%; margin-top: 1em">Possible
applications:</p>

<p style="margin-left:14%; margin-top: 1em">The method is
especially useful in the conversion of packet sizes in a
data stream.</p>

<p style="margin-left:14%; margin-top: 1em">This method can
also be used to convert a given bit vector to a string of
octal numbers:</p>

<pre style="margin-left:14%; margin-top: 1em">  $string = reverse join('', $vector&minus;&gt;Chunk_List_Read(3));</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Index_List_Remove(@indices);&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to specify a list of indices of bits which should
be turned off in the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">In fact this
method is a shortcut for</p>

<pre style="margin-left:14%; margin-top: 1em">    foreach $index (@indices)
    {
        $vector&minus;&gt;Bit_Off($index);
    }</pre>


<p style="margin-left:14%; margin-top: 1em">In contrast to
all other import methods in this module, this method does
<b><small>NOT</small></b> clear the given bit vector before
processing its list of arguments.</p>

<p style="margin-left:14%; margin-top: 1em">Instead, this
method allows you to accumulate the results of various
consecutive calls.</p>

<p style="margin-left:14%; margin-top: 1em">(The same holds
for the method
&quot;<tt>&quot;Index_List_Store()&quot;</tt>&quot;. As a
consequence, you can &quot;wipe out&quot; what you did using
the method
&quot;<tt>&quot;Index_List_Remove()&quot;</tt>&quot; by
passing the identical argument list to the method
&quot;<tt>&quot;Index_List_Store()&quot;</tt>&quot;.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">



<p style="margin-top: 1em"><tt>&quot;$vector&minus;&gt;Index_List_Store(@indices);&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
allows you to specify a list of indices of bits which should
be turned on in the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">In fact this
method is a shortcut for</p>

<pre style="margin-left:14%; margin-top: 1em">    foreach $index (@indices)
    {
        $vector&minus;&gt;Bit_On($index);
    }</pre>


<p style="margin-left:14%; margin-top: 1em">In contrast to
all other import methods in this module, this method does
<b><small>NOT</small></b> clear the given bit vector before
processing its list of arguments.</p>

<p style="margin-left:14%; margin-top: 1em">Instead, this
method allows you to accumulate the results of various
consecutive calls.</p>

<p style="margin-left:14%; margin-top: 1em">(The same holds
for the method
&quot;<tt>&quot;Index_List_Remove()&quot;</tt>&quot;. As a
consequence, you can &quot;wipe out&quot; what you did using
the method
&quot;<tt>&quot;Index_List_Store()&quot;</tt>&quot; by
passing the identical argument list to the method
&quot;<tt>&quot;Index_List_Remove()&quot;</tt>&quot;.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em"><tt>&quot;@indices =
$vector&minus;&gt;Index_List_Read();&quot;</tt></p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a list of Perl scalars.</p>

<p style="margin-left:14%; margin-top: 1em">The list
contains one scalar for each set bit in the given bit
vector.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that for large bit vectors, this can result in a literally
overwhelming number of list elements! <b><small>BE
CAREFUL</small> !</b> You could run out of memory or slow
down your application considerably!</p>

<p style="margin-left:14%; margin-top: 1em">Each scalar
contains the number of the index corresponding to the bit in
question.</p>

<p style="margin-left:14%; margin-top: 1em">These indices
are always returned in ascending order.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
bit vector is empty (contains only cleared bits) or if it
has a length of zero (if it contains no bits at all), the
method returns an empty list.</p>

<p style="margin-left:14%; margin-top: 1em">This method can
be useful, for instance, to obtain a list of prime
numbers:</p>

<pre style="margin-left:14%; margin-top: 1em">    $limit = 1000; # or whatever
    $vector = Bit::Vector&minus;&gt;new($limit+1);
    $vector&minus;&gt;Primes();
    @primes = $vector&minus;&gt;Index_List_Read();</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;Or($vec1,$vec2);&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$set3&minus;&gt;Union($set1,$set2);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the union of &quot;<tt>$set1</tt>&quot; and
&quot;<tt>$set2</tt>&quot; and stores the result in
&quot;<tt>$set3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is usually
written as &quot;<tt>&quot;$set3 = $set1 u
$set2&quot;</tt>&quot; in set theory (where &quot;u&quot; is
the &quot;cup&quot; operator).</p>

<p style="margin-left:14%; margin-top: 1em">(On systems
where the &quot;cup&quot; character is unavailable this
operator is often denoted by a plus sign &quot;+&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">In-place
calculation is also possible, i.e.,
&quot;<tt>$set3</tt>&quot; may be identical with
&quot;<tt>$set1</tt>&quot; or &quot;<tt>$set2</tt>&quot; or
both.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;And($vec1,$vec2);&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$set3&minus;&gt;Intersection($set1,$set2);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the intersection of &quot;<tt>$set1</tt>&quot;
and &quot;<tt>$set2</tt>&quot; and stores the result in
&quot;<tt>$set3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is usually
written as &quot;<tt>&quot;$set3 = $set1 n
$set2&quot;</tt>&quot; in set theory (where &quot;n&quot; is
the &quot;cap&quot; operator).</p>

<p style="margin-left:14%; margin-top: 1em">(On systems
where the &quot;cap&quot; character is unavailable this
operator is often denoted by an asterisk &quot;*&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">In-place
calculation is also possible, i.e.,
&quot;<tt>$set3</tt>&quot; may be identical with
&quot;<tt>$set1</tt>&quot; or &quot;<tt>$set2</tt>&quot; or
both.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;AndNot($vec1,$vec2);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$set3&minus;&gt;Difference($set1,$set2);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the difference of &quot;<tt>$set1</tt>&quot; less
&quot;<tt>$set2</tt>&quot; and stores the result in
&quot;<tt>$set3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is usually
written as &quot;<tt>&quot;$set3 = $set1 \
$set2&quot;</tt>&quot; in set theory (where &quot;\&quot; is
the &quot;less&quot; operator).</p>

<p style="margin-left:14%; margin-top: 1em">In-place
calculation is also possible, i.e.,
&quot;<tt>$set3</tt>&quot; may be identical with
&quot;<tt>$set1</tt>&quot; or &quot;<tt>$set2</tt>&quot; or
both.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">



<p style="margin-top: 1em"><tt>&quot;$vec3&minus;&gt;Xor($vec1,$vec2);&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$set3&minus;&gt;ExclusiveOr($set1,$set2);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the symmetric difference of
&quot;<tt>$set1</tt>&quot; and &quot;<tt>$set2</tt>&quot;
and stores the result in &quot;<tt>$set3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This can be
written as &quot;<tt>&quot;$set3 = ($set1 u $set2) \ ($set1
n $set2)&quot;</tt>&quot; in set theory (the union of the
two sets less their intersection).</p>

<p style="margin-left:14%; margin-top: 1em">When sets are
implemented as bit vectors then the above formula is
equivalent to the exclusive-or between corresponding bits of
the two bit vectors (hence the name of this method).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method is also much more efficient than evaluating the above
formula explicitly since it uses a built-in machine language
instruction internally.</p>

<p style="margin-left:14%; margin-top: 1em">In-place
calculation is also possible, i.e.,
&quot;<tt>$set3</tt>&quot; may be identical with
&quot;<tt>$set1</tt>&quot; or &quot;<tt>$set2</tt>&quot; or
both.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">



<p style="margin-top: 1em"><tt>&quot;$vec2&minus;&gt;Not($vec1);&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$set2&minus;&gt;Complement($set1);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the complement of &quot;<tt>$set1</tt>&quot; and
stores the result in &quot;<tt>$set2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">In &quot;big
integer&quot; arithmetic, this is equivalent to calculating
the one&rsquo;s complement of the number stored in the bit
vector &quot;<tt>$set1</tt>&quot; in binary
representation.</p>

<p style="margin-left:14%; margin-top: 1em">In-place
calculation is also possible, i.e.,
&quot;<tt>$set2</tt>&quot; may be identical with
&quot;<tt>$set1</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em"><tt>&quot;if
($set1&minus;&gt;subset($set2))&quot;</tt></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns
&quot;true&quot; (&quot;<tt>1</tt>&quot;) if
&quot;<tt>$set1</tt>&quot; is a subset of
&quot;<tt>$set2</tt>&quot; (i.e., completely contained in
&quot;<tt>$set2</tt>&quot;) and &quot;false&quot;
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
any bit which is set (&quot;<tt>1</tt>&quot;) in
&quot;<tt>$set1</tt>&quot; must also be set in
&quot;<tt>$set2</tt>&quot;, but &quot;<tt>$set2</tt>&quot;
may contain set bits which are not set in
&quot;<tt>$set1</tt>&quot;, in order for the condition of
subset relationship to be true between these two sets.</p>

<p style="margin-left:14%; margin-top: 1em">Note that by
definition, if two sets are identical, they are also subsets
(and also supersets) of each other.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$norm =
$set&minus;&gt;Norm();&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
norm (number of bits which are set) of the given vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
equivalent to the number of elements contained in the given
set.</p>

<p style="margin-left:14%; margin-top: 1em">Uses a byte
lookup table for calculating the number of set bits per
byte, and thus needs a time for evaluation (and a number of
loops) linearly proportional to the length of the given bit
vector (in bytes).</p>

<p style="margin-left:14%; margin-top: 1em">This should be
the fastest algorithm on average.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;$norm =
$set&minus;&gt;Norm2();&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
norm (number of bits which are set) of the given vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
equivalent to the number of elements contained in the given
set.</p>

<p style="margin-left:14%; margin-top: 1em">This does the
same as the method &quot;<tt>&quot;Norm()&quot;</tt>&quot;
above, only with a different algorithm:</p>

<p style="margin-left:14%; margin-top: 1em">This method
counts the number of set and cleared bits at the same time
and will stop when either of them has been exhausted, thus
needing at most half as many loops per machine word as the
total number of bits in a machine word &minus; in fact it
will need a number of loops equal to the minimum of the
number of set bits and the number of cleared bits.</p>

<p style="margin-left:14%; margin-top: 1em">This might be a
faster algorithm than of the method
&quot;<tt>&quot;Norm()&quot;</tt>&quot; above on some
systems, depending on the system&rsquo;s architecture and
the compiler and optimisation used, for bit vectors with
sparse set bits and for bit vectors with sparse cleared bits
(i.e., predominantly set bits).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;$norm =
$set&minus;&gt;Norm3();&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
norm (number of bits which are set) of the given vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
equivalent to the number of elements contained in the given
set.</p>

<p style="margin-left:14%; margin-top: 1em">This does the
same as the two methods
&quot;<tt>&quot;Norm()&quot;</tt>&quot; and
&quot;<tt>&quot;Norm2()&quot;</tt>&quot; above, however with
a different algorithm.</p>

<p style="margin-left:14%; margin-top: 1em">In fact this is
the implementation of the method
&quot;<tt>&quot;Norm()&quot;</tt>&quot; used in previous
versions of this module.</p>

<p style="margin-left:14%; margin-top: 1em">The method
needs a number of loops per machine word equal to the number
of set bits in that machine word.</p>

<p style="margin-left:14%; margin-top: 1em">Only for bit
vectors with sparse set bits will this method be fast; it
will depend on a system&rsquo;s architecture and compiler
whether the method will be faster than any of the two
methods above in such cases.</p>

<p style="margin-left:14%; margin-top: 1em">On average
however, this is probably the slowest method of the
three.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$min =
$set&minus;&gt;Min();&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
minimum of the given set, i.e., the minimum of all indices
of all set bits in the given bit vector
&quot;<tt>$set</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">If the set is
empty (no set bits), plus infinity (represented by the
constant &quot; <small>MAX_LONG&quot;</small> on your
system) is returned.</p>

<p style="margin-left:14%; margin-top: 1em">(This constant
is usually 2&nbsp;^&nbsp;(n&minus;1)&nbsp;&minus;&nbsp;1,
where &quot;<tt>&quot;n&quot;</tt>&quot; is the number of
bits of an unsigned long on your machine.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$max =
$set&minus;&gt;Max();&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns the
maximum of the given set, i.e., the maximum of all indices
of all set bits in the given bit vector
&quot;<tt>$set</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">If the set is
empty (no set bits), minus infinity (represented by the
constant &quot; <small>MIN_LONG&quot;</small> on your
system) is returned.</p>

<p style="margin-left:14%; margin-top: 1em">(This constant
is usually
&minus;(2&nbsp;^&nbsp;(n&minus;1)&nbsp;&minus;&nbsp;1) or
&minus;(2&nbsp;^&nbsp;(n&minus;1)), where
&quot;<tt>&quot;n&quot;</tt>&quot; is the number of bits of
an unsigned long on your machine.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">



<p style="margin-top: 1em"><tt>&quot;$m3&minus;&gt;Multiplication($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
multiplies two boolean matrices (stored as bit vectors)
&quot;<tt>$m1</tt>&quot; and &quot;<tt>$m2</tt>&quot; and
stores the result in matrix &quot;<tt>$m3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The method uses
the binary &quot;xor&quot; operation
(&quot;<tt>&quot;^&quot;</tt>&quot;) as the boolean addition
operator (&quot;<tt>&quot;+&quot;</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
raised if the product of the number of rows and columns of
any of the three matrices differs from the actual size of
their underlying bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
also raised if the numbers of rows and columns of the three
matrices do not harmonize in the required manner:</p>

<pre style="margin-left:14%; margin-top: 1em">  rows3 == rows1
  cols3 == cols2
  cols1 == rows2</pre>


<p style="margin-left:14%; margin-top: 1em">This method is
used by the module &quot;Math::MatrixBool&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">See
<i>Math::MatrixBool</i>(3) for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">



<p style="margin-top: 1em"><tt>&quot;$m3&minus;&gt;Product($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
multiplies two boolean matrices (stored as bit vectors)
&quot;<tt>$m1</tt>&quot; and &quot;<tt>$m2</tt>&quot; and
stores the result in matrix &quot;<tt>$m3</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This special
method uses the binary &quot;or&quot; operation
(&quot;<tt>&quot;|&quot;</tt>&quot;) as the boolean addition
operator (&quot;<tt>&quot;+&quot;</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
raised if the product of the number of rows and columns of
any of the three matrices differs from the actual size of
their underlying bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
also raised if the numbers of rows and columns of the three
matrices do not harmonize in the required manner:</p>

<pre style="margin-left:14%; margin-top: 1em">  rows3 == rows1
  cols3 == cols2
  cols1 == rows2</pre>


<p style="margin-left:14%; margin-top: 1em">This method is
used by the module &quot;Math::MatrixBool&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">See
<i>Math::MatrixBool</i>(3) for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">



<p style="margin-top: 1em"><tt>&quot;$matrix&minus;&gt;Closure($rows,$cols);&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the reflexive transitive closure of the given
boolean matrix (stored as a bit vector) using Kleene&rsquo;s
algoritm.</p>

<p style="margin-left:14%; margin-top: 1em">(See
<i>Math::Kleene</i>(3) for a brief introduction into the
theory behind Kleene&rsquo;s algorithm.)</p>

<p style="margin-left:14%; margin-top: 1em">The reflexive
transitive closure answers the question whether a path
exists between any two vertices of a graph whose edges are
given as a matrix:</p>

<p style="margin-left:14%; margin-top: 1em">If a (directed)
edge exists going from vertex &quot;i&quot; to vertex
&quot;j&quot;, then the element in the matrix with
coordinates (i,j) is set to &quot;<tt>1</tt>&quot;
(otherwise it remains set to &quot;<tt>0</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">If the edges
are undirected, the resulting matrix is symmetric, i.e.,
elements (i,j) and (j,i) always contain the same value.</p>

<p style="margin-left:14%; margin-top: 1em">The matrix
representing the edges of the graph only answers the
question whether an <b><small>EDGE</small></b> exists
between any two vertices of the graph or not, whereas the
reflexive transitive closure answers the question whether a
<b><small>PATH</small></b> (a series of adjacent edges)
exists between any two vertices of the graph!</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
contents of the given matrix are modified by this method, so
make a copy of the initial matrix in time if you are going
to need it again later.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
raised if the given matrix is not quadratic, i.e., if the
number of rows and columns of the given matrix is not
identical.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
also raised if the product of the number of rows and columns
of the given matrix differs from the actual size of its
underlying bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
used by the module &quot;Math::MatrixBool&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">See
<i>Math::MatrixBool</i>(3) for details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">



<p style="margin-top: 1em"><tt>&quot;$matrix2&minus;&gt;Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the transpose of a boolean matrix
&quot;<tt>$matrix1</tt>&quot; (stored as a bit vector) and
stores the result in matrix
&quot;<tt>$matrix2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The transpose
of a boolean matrix, representing the edges of a graph, can
be used for finding the strongly connected components of
that graph.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
raised if the product of the number of rows and columns of
any of the two matrices differs from the actual size of its
underlying bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">An exception is
also raised if the following conditions are not met:</p>

<pre style="margin-left:14%; margin-top: 1em">  rows2 == cols1
  cols2 == rows1</pre>


<p style="margin-left:14%; margin-top: 1em">Note that
in-place processing (&quot;<tt>$matrix1</tt>&quot; and
&quot;<tt>$matrix2</tt>&quot; are identical) is only
possible if the matrix is quadratic. Otherwise, a fatal
&quot;matrix is not quadratic&quot; error will occur.</p>

<p style="margin-left:14%; margin-top: 1em">This method is
used by the module &quot;Math::MatrixBool&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">See
<i>Math::MatrixBool</i>(3) for details.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Bit::Vector::Overload</i>(3),
<i>Bit::Vector::String</i>(3), <i>Storable</i>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Set::IntRange</i>(3),
<i>Math::MatrixBool</i>(3), <i>Math::MatrixReal</i>(3),
<i>DFA::Kleene</i>(3), <i>Math::Kleene</i>(3),
<i>Graph::Kruskal</i>(3).</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This man page
documents &quot;Bit::Vector&quot; version 7.3.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>


<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1995 &minus; 2013 by Steffen Beyer. All rights reserved.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e., under the terms
of the &quot;Artistic License&quot; or the &quot;
<small>GNU</small> General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The C library
at the core of this Perl module can additionally be
redistributed and/or modified under the terms of the &quot;
<small>GNU</small> Library General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the files &quot;Artistic.txt&quot;, &quot;
<small>GNU_GPL</small> .txt&quot; and &quot;
<small>GNU_LGPL</small> .txt&quot; in this distribution for
details!</p>

<h2>DISCLAIMER
<a name="DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">See the &quot;
<small>GNU</small> General Public License&quot; for more
details.</p>
<hr>
</body>
</html>
