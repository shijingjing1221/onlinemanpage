<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:00:57 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>NOTIFY</title>

</head>
<body>

<h1 align="center">NOTIFY</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PARAMETERS">PARAMETERS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#COMPATIBILITY">COMPATIBILITY</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">NOTIFY &minus;
generate a notification</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">NOTIFY
<i>channel</i> [ , <i>payload</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>NOTIFY</b> command sends a notification event together
with an optional &ldquo;payload&rdquo; string to each client
application that has previously executed <b>LISTEN</b>
<i>channel</i> for the specified channel name in the current
database.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTIFY</b>
provides a simple interprocess communication mechanism for a
collection of processes accessing the same PostgreSQL
database. A payload string can be sent along with the
notification, and higher&minus;level mechanisms for passing
structured data can be built by using tables in the database
to pass additional data from notifier to listener(s).</p>

<p style="margin-left:11%; margin-top: 1em">The information
passed to the client for a notification event includes the
notification channel name, the notifying session's server
process PID, and the payload string, which is an empty
string if it has not been specified.</p>

<p style="margin-left:11%; margin-top: 1em">It is up to the
database designer to define the channel names that will be
used in a given database and what each one means. Commonly,
the channel name is the same as the name of some table in
the database, and the notify event essentially means,
&ldquo;I changed this table, take a look at it to see what's
new&rdquo;. But no such association is enforced by the
<b>NOTIFY</b> and <b>LISTEN</b> commands. For example, a
database designer could use several different channel names
to signal different sorts of changes to a single table.
Alternatively, the payload string could be used to
differentiate various cases.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>NOTIFY</b> is used to signal the occurrence of changes to
a particular table, a useful programming technique is to put
the <b>NOTIFY</b> in a rule that is triggered by table
updates. In this way, notification happens automatically
when the table is changed, and the application programmer
cannot accidentally forget to do it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTIFY</b>
interacts with SQL transactions in some important ways.
Firstly, if a <b>NOTIFY</b> is executed inside a
transaction, the notify events are not delivered until and
unless the transaction is committed. This is appropriate,
since if the transaction is aborted, all the commands within
it have had no effect, including <b>NOTIFY</b>. But it can
be disconcerting if one is expecting the notification events
to be delivered immediately. Secondly, if a listening
session receives a notification signal while it is within a
transaction, the notification event will not be delivered to
its connected client until just after the transaction is
completed (either committed or aborted). Again, the
reasoning is that if a notification were delivered within a
transaction that was later aborted, one would want the
notification to be undone somehow &mdash; but the server
cannot &ldquo;take back&rdquo; a notification once it has
sent it to the client. So notification events are only
delivered between transactions. The upshot of this is that
applications using <b>NOTIFY</b> for real&minus;time
signaling should try to keep their transactions short.</p>

<p style="margin-left:11%; margin-top: 1em">If the same
channel name is signaled multiple times from the same
transaction with identical payload strings, the database
server can decide to deliver a single notification only. On
the other hand, notifications with distinct payload strings
will always be delivered as distinct notifications.
Similarly, notifications from different transactions will
never get folded into one notification. Except for dropping
later instances of duplicate notifications, <b>NOTIFY</b>
guarantees that notifications from the same transaction get
delivered in the order they were sent. It is also guaranteed
that messages from different transactions are delivered in
the order in which the transactions committed.</p>

<p style="margin-left:11%; margin-top: 1em">It is common
for a client that executes <b>NOTIFY</b> to be listening on
the same notification channel itself. In that case it will
get back a notification event, just like all the other
listening sessions. Depending on the application logic, this
could result in useless work, for example, reading a
database table to find the same updates that that session
just wrote out. It is possible to avoid such extra work by
noticing whether the notifying session's server process PID
(supplied in the notification event message) is the same as
one's own session's PID (available from libpq). When they
are the same, the notification event is one's own work
bouncing back, and can be ignored.</p>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>channel</i></p>

<p style="margin-left:17%;">Name of the notification
channel to be signaled (any identifier).</p>


<p style="margin-left:11%; margin-top: 1em"><i>payload</i></p>

<p style="margin-left:17%;">The &ldquo;payload&rdquo;
string to be communicated along with the notification. This
must be specified as a simple string literal. In the default
configuration it must be shorter than 8000 bytes. (If binary
data or large amounts of information need to be
communicated, it's best to put it in a database table and
send the key of the record.)</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There is a
queue that holds notifications that have been sent but not
yet processed by all listening sessions. If this queue
becomes full, transactions calling <b>NOTIFY</b> will fail
at commit. The queue is quite large (8GB in a standard
installation) and should be sufficiently sized for almost
every use case. However, no cleanup can take place if a
session executes <b>LISTEN</b> and then enters a transaction
for a very long time. Once the queue is half full you will
see warnings in the log file pointing you to the session
that is preventing cleanup. In this case you should make
sure that this session ends its current transaction so that
cleanup can proceed.</p>

<p style="margin-left:11%; margin-top: 1em">A transaction
that has executed <b>NOTIFY</b> cannot be prepared for
two&minus;phase commit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pg_notify</b>
<br>
To send a notification you can also use the function
<b>pg_notify</b>(text, text). The function takes the channel
name as the first argument and the payload as the second.
The function is much easier to use than the <b>NOTIFY</b>
command if you need to work with non&minus;constant channel
names and payloads.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Configure and
execute a listen/notify sequence from psql:</p>

<p style="margin-left:17%; margin-top: 1em">LISTEN virtual;
<br>
NOTIFY virtual; <br>
Asynchronous notification &quot;virtual&quot; received from
server process with PID 8448. <br>
NOTIFY virtual, 'This is the payload'; <br>
Asynchronous notification &quot;virtual&quot; with payload
&quot;This is the payload&quot; received from server process
with PID 8448.</p>

<p style="margin-left:17%; margin-top: 1em">LISTEN foo;
<br>
SELECT pg_notify('fo' || 'o', 'pay' || 'load'); <br>
Asynchronous notification &quot;foo&quot; with payload
&quot;payload&quot; received from server process with PID
14728.</p>

<h2>COMPATIBILITY
<a name="COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There is no
<b>NOTIFY</b> statement in the SQL standard.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>LISTEN</b>(7),
<b>UNLISTEN</b>(7)</p>
<hr>
</body>
</html>
