<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 20:47:19 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug::_Safe_iterator_base</title>

</head>
<body>

<h1 align="center">__gnu_debug::_Safe_iterator_base</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Member Data Documentation">Member Data Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_debug::_Safe_iterator_base
&minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherited by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence
&gt;</b>, <b>__gnu_debug::_Safe_local_iterator_base</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Base_iterator, map
&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">void <b>_M_attach</b>
(<b>_Safe_sequence_base</b> *__seq, bool __constant) <br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq, bool __constant) throw () <br>
bool <b>_M_attached_to</b> (const <b>_Safe_sequence_base</b>
*__seq) const <br>
bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b>
&amp;__x) const throw () <br>
void <b>_M_detach</b> () <br>
void <b>_M_detach_single</b> () throw () <br>
void <b>_M_invalidate</b> () <br>
void <b>_M_reset</b> () throw () <br>
bool <b>_M_singular</b> () const throw () <br>
void <b>_M_unlink</b> () throw ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator_base</b> *
<b>_M_next <br>
_Safe_iterator_base</b> * <b>_M_prior <br>
_Safe_sequence_base</b> * <b>_M_sequence</b> <br>
unsigned int <b>_M_version</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator_base</b> ()
<b><br>
_Safe_iterator_base</b> (const <b>_Safe_sequence_base</b>
*__seq, bool __constant) <b><br>
_Safe_iterator_base</b> (const <b>_Safe_iterator_base</b>
&amp;__x, bool __constant) <b><br>
_Safe_iterator_base</b> (const <b>_Safe_iterator_base</b>
&amp;) <br>
__gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> () throw ()
<b><br>
_Safe_iterator_base</b> &amp; <b>operator=</b> (const
<b>_Safe_iterator_base</b> &amp;)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Basic
functionality for a <i>safe</i> iterator.</p>

<p style="margin-left:11%; margin-top: 1em">The
_Safe_iterator_base base class implements the functionality
of a safe iterator that is not specific to a particular
iterator type. It contains a pointer back to the sequence it
references along with iterator version information and
pointers to form a doubly-linked list of iterators
referenced by the container.</p>

<p style="margin-left:11%; margin-top: 1em">This class must
not perform any operations that can throw an exception, or
the exception guarantees of derived iterators will be
broken.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 50 of file safe_base.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base
()</b> <tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Initializes the iterator and makes it singular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 76 of file safe_base.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base
(const _Safe_sequence_base *__seq, bool__constant)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Initialize the iterator to reference the sequence pointed to
by <tt>__seq</tt>. <tt>__constant</tt> is true when we are
initializing a constant iterator, and false if it is a
mutable iterator. Note that <tt>__seq</tt> may be NULL, in
which case the iterator will be singular. Otherwise, the
iterator will reference <tt>__seq</tt> and be
nonsingular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 87 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
_M_attach().</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base
(const _Safe_iterator_base &amp;__x, bool__constant)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Initializes the iterator to reference the same sequence that
<tt>__x</tt> does. <tt>__constant</tt> is true if this is a
constant iterator, and false if it is mutable.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 94 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
_M_attach(), and _M_sequence.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_attach
(_Safe_sequence_base *__seq, bool__constant)</b> <br>
Attaches this iterator to the given sequence, detaching it
from whatever sequence it was attached to originally. If the
new sequence is the NULL pointer, the iterator is left
unattached.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_attach(), __gnu_debug::_Safe_iterator&lt;
_Base_iterator, map &gt;::_M_attach(), and
_Safe_iterator_base().</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_attach_single
(_Safe_sequence_base *__seq, bool__constant)</b> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_attach_single(), and
__gnu_debug::_Safe_iterator&lt; _Base_iterator, map
&gt;::_M_attach_single().</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_attached_to (const
_Safe_sequence_base *__seq) const</b> <tt>[inline]</tt> <br>
Determines if we are attached to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 129 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
_M_sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_can_compare (const
_Safe_iterator_base &amp;__x) const</b> <br>
Can we compare this iterator to the given iterator
<tt>__x</tt>? Returns true if both iterators are nonsingular
and reference the same sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_detach ()</b> <br>
Detach the iterator for whatever sequence it is attached to,
if any.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_detach_single ()</b>
<br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if().</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_cxx::__mutex&amp;
__gnu_debug::_Safe_iterator_base::_M_get_mutex ()</b>
<tt>[protected]</tt> <br>
For use in _Safe_iterator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_invalidate ()</b>
<tt>[inline]</tt> <br>
Invalidate the iterator, making it singular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 142 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
_M_version.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_reset ()</b> <br>
Reset all member variables</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_singular () const</b>
<br>
Is this iterator singular?</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::__check_singular(),
__gnu_debug::__check_singular_aux(),
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_dereferenceable(), __gnu_debug::_Safe_iterator&lt;
_Base_iterator, map &gt;::_M_dereferenceable(),
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_incrementable(), __gnu_debug::_Safe_iterator&lt;
_Base_iterator, map &gt;::_M_incrementable(),
__gnu_debug::_Safe_iterator&lt; _Base_iterator, map
&gt;::_Safe_iterator(), and
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_Safe_local_iterator().</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_unlink ()</b>
<tt>[inline]</tt> <br>
Unlink itself</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 151 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">References
_M_next, and _M_prior.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_next</b> <br>
Pointer to the next iterator in the sequence&rsquo;s list of
iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 72 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if(), and _M_unlink().</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_prior</b> <br>
Pointer to the previous iterator in the sequence&rsquo;s
list of iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 68 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if(), and _M_unlink().</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_sequence_base*
__gnu_debug::_Safe_iterator_base::_M_sequence</b> <br>
The sequence this iterator references; may be NULL to
indicate a singular iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 55 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
_M_attached_to(), __gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if(), _Safe_iterator_base(), and
__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base().</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned int
__gnu_debug::_Safe_iterator_base::_M_version</b> <br>
The version number of this iterator. The sentinel value 0 is
used to indicate an invalidated iterator (i.e., one that is
singular because of an operation on the container). This
version number must equal the version number in the sequence
referenced by _M_sequence for the iterator to be
non-singular.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 64 of file safe_base.h.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
_M_invalidate().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
