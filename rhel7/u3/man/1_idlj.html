<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:42:18 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>idlj</title>

</head>
<body>

<h1 align="center">idlj</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#RESTRICTIONS">RESTRICTIONS</a><br>
<a href="#KNOWN&nbsp;PROBLEMS">KNOWN&nbsp;PROBLEMS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">idlj &minus;
Generates Java bindings for a specified Interface Definition
Language (IDL) file.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>idlj</b> [
<i>options</i> ] <i>idlfile <br>
options</i></p>

<p style="margin-left:22%;">The command-line options. See
Options. Options can appear in any order, but must precede
the <b>idlfile</b>.</p>

<p style="margin-left:11%;"><i>idlfile</i></p>

<p style="margin-left:22%;">The name of a file that
contains Interface Definition Language (IDL)
definitions.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The IDL-to-Java
Compiler generates the Java bindings for a specified IDL
file. For binding details, see Java IDL: IDL to Java
Language Mapping at
http://docs.oracle.com/javase/8/docs/technotes/guides/idl/mapping/jidlMapping.html</p>

<p style="margin-left:11%; margin-top: 1em">Some earlier
releases of the IDL-to-Java compiler were named
<b>idltojava</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EMIT&nbsp;CLIENT&nbsp;AND&nbsp;SERVER&nbsp;BINDINGS</b>
<br>
The following <b>idlj</b> command generates an IDL file
named <b>My.idl</b> with client-side bindings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">The previous
syntax is equivalent to the following:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;fclient My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">The next
example generates the server-side bindings, and includes the
client-side bindings plus the skeleton, all of which are POA
(Inheritance Model).</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlg
&minus;fserver My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">If you want to
generate both client and server-side bindings, then use one
of the following (equivalent) commands:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;fclient &minus;fserver My.idl <br>
idlj &minus;fall My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">There are two
possible server-side models: the Portal Servant Inheritance
Model and the Tie Model. See Tie Delegation Model.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Portable
Servant Inheritance Model</b>. The default server-side model
is the Portable Servant Inheritance Model. Given an
interface <b>My</b> defined in <b>My.idl</b>, the file
<b>MyPOA.java</b> is generated. You must provide the
implementation for the <b>My</b> interface, and the
<b>My</b> interface must inherit from the <b>MyPOA</b>
class. <b>MyPOA.java</b> is a stream-based skeleton that
extends the <b>org.omg.PortableServer.Servant</b> class at
http://docs.oracle.com/javase/8/docs/api/org/omg/PortableServer/Servant.html
The <b>My</b> interface implements the <b>callHandler</b>
interface and the operations interface associated with the
IDL interface the skeleton implements.The
<b>PortableServer</b> module for the Portable Object Adapter
(POA) defines the native <b>Servant</b> type. See Portable
Object Adapter (POA) at
http://docs.oracle.com/javase/8/docs/technotes/guides/idl/POA.html
In the Java programming language, the <b>Servant</b> type is
mapped to the Java <b>org.omg.PortableServer.Servant</b>
class. It serves as the base class for all POA servant
implementations and provides a number of methods that can be
called by the application programmer, and methods that are
called by the POA and that can be overridden by the user to
control aspects of servant behavior.Another option for the
Inheritance Model is to use the <b>-oldImplBase</b> flag to
generate server-side bindings that are compatible with
releases of the Java programming language before Java SE
1.4. The -<b>oldImplBase</b> flag is nonstandard, and these
APIs are deprecated. You would use this flag only for
compatibility with existing servers written in Java SE 1.3.
In that case, you would need to modify an existing make file
to add the <b>-oldImplBase</b> flag to the <b>idlj</b>
compiler. Otherwise POA-based server-side mappings are
generated. To generate server-side bindings that are
backward compatible, do the following:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;fclient &minus;fserver &minus;oldImplBase My.idl <br>
idlj &minus;fall &minus;oldImplBase My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">Given an
interface <b>My</b> defined in <b>My.idl</b>, the file
<b>_MyImplBase.java</b> is generated. You must provide the
implementation for the <b>My</b> interface, and the
<b>My</b> interface must inherit from the <b>_MyImplBase</b>
class.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tie
Delegation Model</b>. The other server-side model is called
the Tie Model. This is a delegation model. Because it is not
possible to generate ties and skeletons at the same time,
they must be generated separately. The following commands
generate the bindings for the Tie Model:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;fall My.idl <br>
idlj &minus;fallTIE My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">For the
<b>My</b> interface, the second command generates
<b>MyPOATie.java</b>. The constructor to the <b>MyPOATie</b>
class takes a delegate. In this example, using the default
POA model, the constructor also needs a POA. You must
provide the implementation for the delegate, but it does not
have to inherit from any other class, only the interface
<b>MyOperations</b>. To use it with the ORB, you must wrap
your implementation within the <b>MyPOATie</b> class, for
example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>ORB orb =
ORB.init(args, System.getProperties()); <br>
// Get reference to rootpoa &amp; activate the POAManager
<br>
POA rootpoa =
(POA)orb.resolve_initial_references(&quot;RootPOA&quot;);
<br>
rootpoa.the_POAManager().activate(); <br>
// create servant and register it with the ORB <br>
MyServant myDelegate = new MyServant(); <br>
myDelegate.setORB(orb); <br>
// create a tie, with servant being the delegate. <br>
MyPOATie tie = new MyPOATie(myDelegate, rootpoa); <br>
// obtain the objectRef for the tie <br>
My ref = tie._this(orb);</b></p>

<p style="margin-left:11%; margin-top: 1em">You might want
to use the Tie model instead of the typical Inheritance
model when your implementation must inherit from some other
implementation. Java allows any number of interface
inheritance, but there is only one slot for class
inheritance. If you use the inheritance model, then that
slot is used up. With the Tie Model, that slot is freed up
for your own use. The drawback is that it introduces a level
of indirection: one extra method call occurs when a method
is called.</p>

<p style="margin-left:11%; margin-top: 1em">For server-side
generation, Tie model bindings that are compatible with
versions of the IDL to Java language mapping in versions
earlier than Java SE 1.4.</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;oldImplBase &minus;fall My.idl <br>
idlj &minus;oldImplBase &minus;fallTIE My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">For the
<b>My</b> interface, the this generates <b>My_Tie.java</b>.
The constructor to the <b>My_Tie</b> class takes an
<b>impl</b> object. You must provide the implementation for
<b>impl</b>, but it does not have to inherit from any other
class, only the interface <b>HelloOperations</b>. But to use
it with the ORB, you must wrap your implementation within
<b>My_Tie</b>, for example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>ORB orb =
ORB.init(args, System.getProperties()); <br>
// create servant and register it with the ORB <br>
MyServant myDelegate = new MyServant(); <br>
myDelegate.setORB(orb); <br>
// create a tie, with servant being the delegate. <br>
MyPOATie tie = new MyPOATie(myDelegate); <br>
// obtain the objectRef for the tie <br>
My ref = tie._this(orb);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SPECIFY&nbsp;ALTERNATE&nbsp;LOCATIONS&nbsp;FOR&nbsp;EMITTED&nbsp;FILES</b>
<br>
If you want to direct the emitted files to a directory other
than the current directory, then call the compiler this way:
<b>idlj -td /altdir My.idl</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For the
<b>My</b> interface, the bindings are emitted to
<b>/altdir/My.java</b>, etc., instead of
<b>./My.java</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SPECIFY&nbsp;ALTERNATE&nbsp;LOCATIONS&nbsp;FOR&nbsp;INCLUDE&nbsp;FILES</b>
<br>
If the <b>My.idl</b> file includes another <b>idl</b> file,
<b>MyOther.idl</b>, then the compiler assumes that the
<b>MyOther.idl</b> file resides in the local directory. If
it resides in <b>/includes</b>, for example, then you call
the compiler with the following command:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;i /includes My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">If
<b>My.idl</b> also included <b>Another.idl</b> that resided
in <b>/moreIncludes</b>, for example, then you call the
compiler with the following command:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;i /includes &minus;i /moreIncludes My.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">Because this
form of <b>include</b> can become long, another way to
indicate to the compiler where to search for included files
is provided. This technique is similar to the idea of an
environment variable. Create a file named idl.config in a
directory that is listed in your <b>CLASSPATH</b> variable.
Inside of <b>idl.config</b>, provide a line with the
following form:</p>


<p style="margin-left:11%; margin-top: 1em"><b>includes=/includes;/moreIncludes</b></p>

<p style="margin-left:11%; margin-top: 1em">The compiler
will find this file and read in the includes list. Note that
in this example the separator character between the two
directories is a semicolon (;). This separator character is
platform dependent. On the Windows platform, use a
semicolon, on the Unix platform, use a colon, and so on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EMIT&nbsp;BINDINGS&nbsp;FOR&nbsp;INCLUDE&nbsp;FILES</b>
<br>
By default, only those interfaces, structures, and so on,
that are defined in the <b>idl</b> file on the command line
have Java bindings generated for them. The types defined in
included files are not generated. For example, assume the
following two <b>idl</b> files:</p>

<p style="margin-left:11%; margin-top: 1em"><b>My.idl file:
<br>
#include &lt;MyOther.idl&gt; <br>
interface My <br>
{ <br>
}; <br>
MyOther.idl file: <br>
interface MyOther <br>
{ <br>
};</b></p>

<p style="margin-left:11%; margin-top: 1em">There is a
caveat to the default rule. Any <b>#include</b> statements
that appear at the global scope are treated as described.
These <b>#include</b> statements can be thought of as import
statements. The <b>#include</b> statements that appear
within an enclosed scope are treated as true <b>#include</b>
statements, which means that the code within the included
file is treated as though it appeared in the original file
and, therefore, Java bindings are emitted for it. Here is an
example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>My.idl file:
<br>
#include &lt;MyOther.idl&gt; <br>
interface My <br>
{ <br>
#include &lt;Embedded.idl&gt; <br>
}; <br>
MyOther.idl file: <br>
interface MyOther <br>
{ <br>
}; <br>
Embedded.idl <br>
enum E {one, two, three};</b></p>

<p style="margin-left:11%; margin-top: 1em">Run<b>idlj
My.idl</b>to generate the following list of Java files.
Notice that <b>MyOther.java</b> is not generated because it
is defined in an import-like <b>#include</b>. But
<b>E.java</b> was generated because it was defined in a true
<b>#include</b>. Notice that because the <b>Embedded.idl</b>
file is included within the scope of the interface
<b>My</b>, it appears within the scope of <b>My</b> (in
<b>MyPackage</b>). If the <b>-emitAll</b> flag had been
used, then all types in all included files would have been
emitted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>./MyHolder.java
<br>
./MyHelper.java <br>
./_MyStub.java <br>
./MyPackage <br>
./MyPackage/EHolder.java <br>
./MyPackage/EHelper.java <br>
./MyPackage/E.java <br>
./My.java</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>INSERT&nbsp;PACKAGE&nbsp;PREFIXES</b>
<br>
Suppose that you work for a company named ABC that has
constructed the following IDL file:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Widgets.idl
file: <br>
module Widgets <br>
{ <br>
interface W1 {...}; <br>
interface W2 {...}; <br>
};</b></p>

<p style="margin-left:11%; margin-top: 1em">If you run this
file through the IDL-to-Java compiler, then the Java
bindings for W1 and W2 are placed within the <b>Widgets</b>
package. There is an industry convention that states that a
company&rsquo;s packages should reside within a package
named <b>com.&lt;company name&gt;</b>. To follow this
convention, the package name should be
<b>com.abc.Widgets</b>. To place this package prefix onto
the Widgets module, execute the following:</p>

<p style="margin-left:11%; margin-top: 1em"><b>idlj
&minus;pkgPrefix Widgets com.abc Widgets.idl</b></p>

<p style="margin-left:11%; margin-top: 1em">If you have an
IDL file that includes Widgets.idl, then the
<b>-pkgPrefix</b> flag must appear in that command also. If
it does not, then your IDL file will be looking for a
<b>Widgets</b> package rather than a <b>com.abc.Widgets</b>
package.</p>

<p style="margin-left:11%; margin-top: 1em">If you have a
number of these packages that require prefixes, then it
might be easier to place them into the idl.config file
described previously. Each package prefix line should be of
the form: <b>PkgPrefix.&lt;type&gt;=&lt;prefix&gt;</b>. The
line for the previous example would be
<b>PkgPrefix.Widgets=com.abc</b>. This option does not
affect the Repository ID.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DEFINE&nbsp;SYMBOLS&nbsp;BEFORE&nbsp;COMPILATION</b>
<br>
You might need to define a symbol for compilation that is
not defined within the IDL file, perhaps to include
debugging code in the bindings. The command <b>idlj -d MYDEF
My.idl</b>is equivalent to putting the line <b>#define
MYDEF</b> inside My.idl.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PRESERVE&nbsp;PREEXISTING&nbsp;BINDINGS</b>
<br>
If the Java binding files already exist, then the
<b>-keep</b> flag keeps the compiler from overwriting them.
The default is to generate all files without considering
that they already exist. If you have customized those files
(which you should not do unless you are very comfortable
with their contents), then the <b>-keep</b> option is very
useful. The command <b>idlj -keep My.idl</b> emits all
client-side bindings that do not already exist.</p>


<p style="margin-left:11%; margin-top: 1em"><b>VIEW&nbsp;COMPILATION&nbsp;PROGRESS</b>
<br>
The IDL-to-Java compiler generates status messages as it
progresses through its phases of execution. Use the
<b>-v</b> option to activate the verbose mode: <b>idlj -v
My.idl</b>.</p>

<p style="margin-left:11%; margin-top: 1em">By default the
compiler does not operate in verbose mode</p>


<p style="margin-left:11%; margin-top: 1em"><b>DISPLAY&nbsp;VERSION&nbsp;INFORMATION</b>
<br>
To display the build version of the IDL-to-Java compiler,
specify the <b>-version</b> option on the command-line:
<b>idlj -version</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Version
information also appears within the bindings generated by
the compiler. Any additional options appearing on the
command-line are ignored.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">-d
<i>symbol</i></p>

<p style="margin-left:22%;">This is equivalent to the
following line in an IDL file:</p>

<p style="margin-left:22%; margin-top: 1em"><b>#define</b>
<i>symbol</i></p>

<p style="margin-left:11%;">-demitAll</p>

<p style="margin-left:22%;">Emit all types, including those
found in <b>#include</b> files.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>-fside</p></td>
<td width="2%"></td>
<td width="78%">


<p>Defines what bindings to emit. The <b>side</b> parameter
can be <b>client</b>, <b>server</b>, <b>serverTIE</b>,
<b>all</b>, or <b>allTIE</b>. The <b>-fserverTIE</b> and
<b>-fallTIE</b> options cause delegate model skeletons to be
emitted. Defaults to <b>-fclient</b> when the flag is not
specified.</p> </td></tr>
</table>

<p style="margin-left:11%;">-i <i>include-path</i></p>

<p style="margin-left:22%;">By default, the current
directory is scanned for included files. This option adds
another directory.</p>

<p style="margin-left:11%;">-i <i>keep</i></p>

<p style="margin-left:22%;">If a file to be generated
already exists, then do not overwrite it. By default it is
overwritten.</p>

<p style="margin-left:11%;">-noWarn</p>

<p style="margin-left:22%;">Suppress warning messages.</p>

<p style="margin-left:11%;">-oldImplBase</p>

<p style="margin-left:22%;">Generates skeletons compatible
with pre-1.4 JDK ORBs. By default, the POA Inheritance Model
server-side bindings are generated. This option provides
backward-compatibility with earlier releases of the Java
programming language by generating server-side bindings that
are <b>ImplBase</b> Inheritance Model classes.</p>

<p style="margin-left:11%;">-pkgPrefix
<i>typeprefix</i></p>

<p style="margin-left:22%;">Wherever <b>type</b> is
encountered at file scope, prefix the generated Java package
name with <b>prefix</b> for all files generated for that
type. The type is the simple name of either a top-level
module, or an IDL type defined outside of any module.</p>

<p style="margin-left:11%;">-pkgTranslate
<i>typepackage</i></p>

<p style="margin-left:22%;">Whenever the module name type
is encountered in an identifier, replace it in the
identifier with package for all files in the generated Java
package. Note that <b>pkgPrefix</b> changes are made first.
The type value is the simple name of either a top-level
module, or an IDL type defined outside of any module and
must match the full package name exactly.</p>

<p style="margin-left:22%; margin-top: 1em">If more than
one translation matches an identifier, then the longest
match is chosen as shown in the following example:</p>


<p style="margin-left:22%; margin-top: 1em"><i>Command</i>:</p>


<p style="margin-left:22%; margin-top: 1em"><b>pkgTranslate
type pkg &minus;pkgTranslate type2.baz pkg2.fizz</b></p>

<p style="margin-left:22%; margin-top: 1em"><i>Resulting
Translation</i>:</p>

<p style="margin-left:22%; margin-top: 1em"><b>type =&gt;
pkg <br>
type.ext =&gt; pkg.ext <br>
type.baz =&gt; pkg2.fizz <br>
type2.baz.pkg =&gt; pkg2.fizz.pkg</b></p>

<p style="margin-left:22%; margin-top: 1em">The following
package names <b>org</b>, <b>org</b>.o<b>mg</b>, or any
subpackages of <b>org.omg</b> cannot be translated. Any
attempt to translate these packages results in uncompilable
code, and the use of these packages as the first argument
after <b>-pkgTranslate</b> is treated as an error.</p>

<p style="margin-left:11%;">-skeletonName
<i>xxx%yyy</i></p>

<p style="margin-left:22%;">Use <b>xxx%yyy</b> as the
pattern for naming the skeleton. The defaults are:
<b>%POA</b> for the <b>POA</b> base class (<b>-fserver</b>
or <b>-fall</b>), and <b>_%ImplBase</b> for the
<b>oldImplBase</b> class (-<b>oldImplBase</b>) and
(<b>-fserver</b> or <b>-fall</b>)).</p>

<p style="margin-left:11%;">-td <i>dir</i></p>

<p style="margin-left:22%;">Use <i>dir</i> for the output
directory instead of the current directory.</p>

<p style="margin-left:11%;">-tieName <i>xxx%yyy</i></p>

<p style="margin-left:22%;">Use <b>xxx%yyy</b> according to
the pattern. The defaults are: <b>%POA</b> for the
<b>POA</b> base class (<b>-fserverTie or -fallTie</b>), and
<b>_%Tie</b> for the <b>oldImplBase</b> tie class
(-<b>oldImplBase</b>) and (<b>-fserverTie</b> or
<b>-fallTie</b>))</p>

<p style="margin-left:11%;">-nowarn, -verbose</p>

<p style="margin-left:22%;">Displays release information
and terminates.</p>

<p style="margin-left:11%;">-version</p>

<p style="margin-left:22%;">Displays release information
and terminates.</p>

<h2>RESTRICTIONS
<a name="RESTRICTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Escaped
identifiers in the global scope cannot have the same
spelling as IDL primitive types, <b>Object</b>, or
<b>ValueBase</b>. This is because the symbol table is
preloaded with these identifiers. Allowing them to be
redefined would overwrite their original definitions.
Possible permanent restriction.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fixed</b> IDL type is not supported.</p>

<h2>KNOWN&nbsp;PROBLEMS
<a name="KNOWN&nbsp;PROBLEMS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No import is
generated for global identifiers. If you call an unexported
local <b>impl</b> object, then you do get an exception, but
it seems to be due to a <b>NullPointerException</b> in the
<b>ServerDelegate</b> DSI code.</p>
<hr>
</body>
</html>
