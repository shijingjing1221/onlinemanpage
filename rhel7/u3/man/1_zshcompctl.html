<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 23:18:18 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ZSHCOMPCTL</title>

</head>
<body>

<h1 align="center">ZSHCOMPCTL</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#COMMAND FLAGS">COMMAND FLAGS</a><br>
<a href="#OPTION FLAGS">OPTION FLAGS</a><br>
<a href="#ALTERNATIVE COMPLETION">ALTERNATIVE COMPLETION</a><br>
<a href="#EXTENDED COMPLETION">EXTENDED COMPLETION</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">zshcompctl
&minus; zsh programmable completion</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This version of
zsh has two ways of performing completion of words on the
command line. New users of the shell may prefer to use the
newer and more powerful system based on shell functions;
this is described in <i>zshcompsys</i>(1), and the basic
shell mechanisms which support it are described in
<i>zshcompwid</i>(1). This manual entry describes the older
<b>compctl</b> command. <b><br>
compctl</b> [ <b>&minus;CDT</b> ] <i>options</i> [
<i>command</i> ... ] <b><br>
compctl</b> [ <b>&minus;CDT</b> ] <i>options</i> [
<b>&minus;x</b> <i>pattern options</i> <b>&minus;</b> ...
<b>&minus;&minus;</b> ] [ <b>+</b> <i>options</i> [ <b><br>
&minus;x</b> ... <b>&minus;&minus;</b> ] ... [<b>+</b>] ] [
<i>command</i> ... ] <b><br>
compctl &minus;M</b> <i>match&minus;specs</i> ... <b><br>
compctl &minus;L</b> [ <b>&minus;CDTM</b> ] [ <i>command</i>
... ] <b><br>
compctl +</b> <i>command</i> ...</p>

<p style="margin-left:11%; margin-top: 1em">Control the
editor&rsquo;s completion behavior according to the supplied
set of <i>options</i>. Various editing commands, notably
<b>expand&minus;or&minus;complete&minus;word</b>, usually
bound to tab, will attempt to complete a word typed by the
user, while others, notably
<b>delete&minus;char&minus;or&minus;list</b>, usually bound
to ^D in EMACS editing mode, list the possibilities;
<b>compctl</b> controls what those possibilities are. They
may for example be filenames (the most common case, and
hence the default), shell variables, or words from a
user&minus;specified list.</p>

<h2>COMMAND FLAGS
<a name="COMMAND FLAGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Completion of
the arguments of a command may be different for each command
or may use the default. The behavior when completing the
command word itself may also be separately specified. These
correspond to the following flags and arguments, all of
which (except for <b>&minus;L</b>) may be combined with any
combination of the <i>options</i> described subsequently in
the section &lsquo;Option Flags&rsquo;: <i><br>
command</i> ...</p>

<p style="margin-left:22%;">controls completion for the
named commands, which must be listed last on the command
line. If completion is attempted for a command with a
pathname containing slashes and no completion definition is
found, the search is retried with the last pathname
component. If the command starts with a <b>=</b>, completion
is tried with the pathname of the command.</p>

<p style="margin-left:22%; margin-top: 1em">Any of the
<i>command</i> strings may be patterns of the form normally
used for filename generation. These should be quoted to
protect them from immediate expansion; for example the
command string <b>&rsquo;foo*&rsquo;</b> arranges for
completion of the words of any command beginning with
<b>foo</b>. When completion is attempted, all pattern
completions are tried in the reverse order of their
definition until one matches. By default, completion then
proceeds as normal, i.e. the shell will try to generate more
matches for the specific command on the command line; this
can be overridden by including <b>&minus;tn</b> in the flags
for the pattern completion.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
aliases are expanded before the command name is determined
unless the <b>COMPLETE_ALIASES</b> option is set. Commands
may not be combined with the <b>&minus;C</b>,
<b>&minus;D</b> or <b>&minus;T</b> flags.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;C</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>controls completion when the command word itself is
being completed. If no <b>compctl &minus;C</b> command has
been issued, the names of any executable command (whether in
the path or specific to the shell, such as aliases or
functions) are completed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;D</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>controls default completion behavior for the arguments
of commands not assigned any special behavior. If no
<b>compctl &minus;D</b> command has been issued, filenames
are completed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;T</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>supplies completion flags to be used before any other
processing is done, even before processing for
<b>compctl</b>s defined for specific commands. This is
especially useful when combined with extended completion
(the <b>&minus;x</b> flag, see the section &lsquo;Extended
Completion&rsquo; below). Using this flag you can define
default behavior which will apply to all commands without
exception, or you can alter the standard behavior for all
commands. For example, if your access to the user database
is too slow and/or it contains too many users (so that
completion after &lsquo;<b>~</b>&rsquo; is too slow to be
usable), you can use</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;T &minus;x &rsquo;s[~] C[0,[^/]#]&rsquo; &minus;k
friends &minus;S/ &minus;tn</b></p>

<p style="margin-left:22%; margin-top: 1em">to complete the
strings in the array <b>friends</b> after a
&lsquo;<b>~</b>&rsquo;. The <b>C[...]</b> argument is
necessary so that this form of ~&minus;completion is not
tried after the directory name is finished.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;L</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">lists the existing completion
behavior in a manner suitable for putting into a
start&minus;up script; the existing behavior is not changed.
Any combination of the above forms, or the <b>&minus;M</b>
flag (which must follow the <b>&minus;L</b> flag), may be
specified, otherwise all defined completions are listed. Any
other flags supplied are ignored.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>no argument</i></p>

<p style="margin-left:22%;">If no argument is given,
<b>compctl</b> lists all defined completions in an
abbreviated form; with a list of <i>options</i>, all
completions with those flags set (not counting extended
completion) are listed.</p>

<p style="margin-left:11%; margin-top: 1em">If the <b>+</b>
flag is alone and followed immediately by the <i>command</i>
list, the completion behavior for all the commands in the
list is reset to the default. In other words, completion
will subsequently use the options specified by the
<b>&minus;D</b> flag.</p>

<p style="margin-left:11%; margin-top: 1em">The form with
<b>&minus;M</b> as the first and only option defines global
matching specifications (see zshcompwid). The match
specifications given will be used for every completion
attempt (only when using <b>compctl</b>, not with the new
completion system) and are tried in the order in which they
are defined until one generates at least one match.
E.g.:</p>

<p style="margin-left:22%; margin-top: 1em"><b>compctl
&minus;M &rsquo;&rsquo;
&rsquo;m:{a&minus;zA&minus;Z}={A&minus;Za&minus;z}&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">This will first
try completion without any global match specifications (the
empty string) and, if that generates no matches, will try
case insensitive completion.</p>

<h2>OPTION FLAGS
<a name="OPTION FLAGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">[
<b>&minus;fcFBdeaRGovNAIOPZEnbjrzu/12</b> ] <br>
[ <b>&minus;k</b> <i>array</i> ] [ <b>&minus;g</b>
<i>globstring</i> ] [ <b>&minus;s</b> <i>subststring</i> ]
<br>
[ <b>&minus;K</b> <i>function</i> ] <br>
[ <b>&minus;Q</b> ] [ <b>&minus;P</b> <i>prefix</i> ] [
<b>&minus;S</b> <i>suffix</i> ] <br>
[ <b>&minus;W</b> <i>file&minus;prefix</i> ] [
<b>&minus;H</b> <i>num pattern</i> ] <br>
[ <b>&minus;q</b> ] [ <b>&minus;X</b> <i>explanation</i> ] [
<b>&minus;Y</b> <i>explanation</i> ] <br>
[ <b>&minus;y</b> <i>func&minus;or&minus;var</i> ] [
<b>&minus;l</b> <i>cmd</i> ] [ <b>&minus;h</b> <i>cmd</i> ]
[ <b>&minus;U</b> ] <br>
[ <b>&minus;t</b> <i>continue</i> ] [ <b>&minus;J</b>
<i>name</i> ] [ <b>&minus;V</b> <i>name</i> ] <br>
[ <b>&minus;M</b> <i>match&minus;spec</i> ]</p>

<p style="margin-left:11%; margin-top: 1em">The remaining
<i>options</i> specify the type of command arguments to look
for during completion. Any combination of these flags may be
specified; the result is a sorted list of all the
possibilities. The options are as follows.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Simple
Flags</b> <br>
These produce completion lists made up by the shell
itself:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;f</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Filenames and file system paths.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;/</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Just file system paths.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;c</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Command names, including aliases, shell functions,
builtins and reserved words.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;F</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Function names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;B</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of builtin commands.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;m</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of external commands.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;w</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Reserved words.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;a</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Alias names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;R</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of regular (non&minus;global) aliases.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;G</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of global aliases.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;d</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>This can be combined with <b>&minus;F</b>,
<b>&minus;B</b>, <b>&minus;w</b>, <b>&minus;a</b>,
<b>&minus;R</b> and <b>&minus;G</b> to get names of disabled
functions, builtins, reserved words or aliases.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;e</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>This option (to show enabled commands) is in effect by
default, but may be combined with <b>&minus;d</b>;
<b>&minus;de</b> in combination with <b>&minus;F</b>,
<b>&minus;B</b>, <b>&minus;w</b>, <b>&minus;a</b>,
<b>&minus;R</b> and <b>&minus;G</b> will complete names of
functions, builtins, reserved words or aliases whether or
not they are disabled.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;o</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of shell options (see <i>zshoptions</i>(1)).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of any variable defined in the shell.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;N</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of scalar (non&minus;array) parameters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;A</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Array names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;I</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of integer variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;O</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of read&minus;only variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;p</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of parameters used by the shell (including special
parameters).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;Z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of shell special parameters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;E</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of environment variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Named directories.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;b</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Key binding names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;j</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Job names: the first word of the job leader&rsquo;s
command line. This is useful with the <b>kill</b>
builtin.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;r</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of running jobs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;z</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Names of suspended jobs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;u</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>User names.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Flags with
Arguments</b> <br>
These have user supplied arguments to determine how the list
of completions is to be made up: <b><br>
&minus;k</b> <i>array</i></p>

<p style="margin-left:22%;">Names taken from the elements
of <b>$</b><i>array</i> (note that the
&lsquo;<b>$</b>&rsquo; does not appear on the command line).
Alternatively, the argument <i>array</i> itself may be a set
of space&minus; or comma&minus;separated values in
parentheses, in which any delimiter may be escaped with a
backslash; in this case the argument should be quoted. For
example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;k &quot;(cputime filesize datasize stacksize</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p><b>coredumpsize resident descriptors)&quot;
limit</b></p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;g</b>
<i>globstring</i></p>

<p style="margin-left:22%;">The <i>globstring</i> is
expanded using filename globbing; it should be quoted to
protect it from immediate expansion. The resulting filenames
are taken as the possible completions. Use
&lsquo;<b>*(/)</b>&rsquo; instead of &lsquo;<b>*/</b>&rsquo;
for directories. The <b>fignore</b> special parameter is not
applied to the resulting files. More than one pattern may be
given separated by blanks. (Note that brace expansion is
<i>not</i> part of globbing. Use the syntax
&lsquo;<b>(either|or)</b>&rsquo; to match alternatives.)</p>

<p style="margin-left:11%;"><b>&minus;s</b>
<i>subststring</i></p>

<p style="margin-left:22%;">The <i>subststring</i> is split
into words and these words are than expanded using all shell
expansion mechanisms (see <i>zshexpn</i>(1)). The resulting
words are taken as possible completions. The <b>fignore</b>
special parameter is not applied to the resulting files.
Note that <b>&minus;g</b> is faster for filenames.</p>

<p style="margin-left:11%;"><b>&minus;K</b>
<i>function</i></p>

<p style="margin-left:22%;">Call the given function to get
the completions. Unless the name starts with an underscore,
the function is passed two arguments: the prefix and the
suffix of the word on which completion is to be attempted,
in other words those characters before the cursor position,
and those from the cursor position onwards. The whole
command line can be accessed with the <b>&minus;c</b> and
<b>&minus;l</b> flags of the <b>read</b> builtin. The
function should set the variable <b>reply</b> to an array
containing the completions (one completion per element);
note that <b>reply</b> should not be made local to the
function. From such a function the command line can be
accessed with the <b>&minus;c</b> and <b>&minus;l</b> flags
to the <b>read</b> builtin. For example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>function
whoson { reply=(&lsquo;users&lsquo;); } <br>
compctl &minus;K whoson talk</b></p>

<p style="margin-left:22%; margin-top: 1em">completes only
logged&minus;on users after &lsquo;<b>talk</b>&rsquo;. Note
that &lsquo;<b>whoson</b>&rsquo; must return an array, so
&lsquo;<b>reply=&lsquo;users&lsquo;</b>&rsquo; would be
incorrect.</p>

<p style="margin-left:11%;"><b>&minus;H</b> <i>num
pattern</i></p>

<p style="margin-left:22%;">The possible completions are
taken from the last <i>num</i> history lines. Only words
matching <i>pattern</i> are taken. If <i>num</i> is zero or
negative the whole history is searched and if <i>pattern</i>
is the empty string all words are taken (as with
&lsquo;<b>*</b>&rsquo;). A typical use is</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;D &minus;f + &minus;H 0 &rsquo;&rsquo;</b></p>

<p style="margin-left:22%; margin-top: 1em">which forces
completion to look back in the history list for a word if no
filename matches.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Control
Flags</b> <br>
These do not directly specify types of name to be completed,
but manipulate the options that do:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;Q</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>This instructs the shell not to quote any metacharacters
in the possible completions. Normally the results of a
completion are inserted into the command line with any
metacharacters quoted so that they are interpreted as normal
characters. This is appropriate for filenames and ordinary
strings. However, for special effects, such as inserting a
backquoted expression from a completion array
(<b>&minus;k</b>) so that the expression will not be
evaluated until the complete line is executed, this option
must be used.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;P</b>
<i>prefix</i></p>

<p style="margin-left:22%;">The <i>prefix</i> is inserted
just before the completed string; any initial part already
typed will be completed and the whole <i>prefix</i> ignored
for completion purposes. For example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;j &minus;P &quot;%&quot; kill</b></p>

<p style="margin-left:22%; margin-top: 1em">inserts a
&lsquo;%&rsquo; after the kill command and then completes
job names.</p>

<p style="margin-left:11%;"><b>&minus;S</b>
<i>suffix</i></p>

<p style="margin-left:22%;">When a completion is found the
<i>suffix</i> is inserted after the completed string. In the
case of menu completion the suffix is inserted immediately,
but it is still possible to cycle through the list of
completions by repeatedly hitting the same key.</p>

<p style="margin-left:11%;"><b>&minus;W</b>
<i>file&minus;prefix</i></p>

<p style="margin-left:22%;">With directory
<i>file&minus;prefix</i>: for command, file, directory and
globbing completion (options <b>&minus;c</b>,
<b>&minus;f</b>, <b>&minus;/</b>, <b>&minus;g</b>), the file
prefix is implicitly added in front of the completion. For
example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;/ &minus;W ~/Mail maildirs</b></p>

<p style="margin-left:22%; margin-top: 1em">completes any
subdirectories to any depth beneath the directory
<b>~/Mail</b>, although that prefix does not appear on the
command line. The <i>file&minus;prefix</i> may also be of
the form accepted by the <b>&minus;k</b> flag, i.e. the name
of an array or a literal list in parenthesis. In this case
all the directories in the list will be searched for
possible completions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;q</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If used with a suffix as specified by the
<b>&minus;S</b> option, this causes the suffix to be removed
if the next character typed is a blank or does not insert
anything or if the suffix consists of only one character and
the next character typed is the same character; this the
same rule used for the <b>AUTO_REMOVE_SLASH</b> option. The
option is most useful for list separators (comma, colon,
etc.).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;l</b> <i>cmd</i></p></td>
<td width="2%"></td>
<td width="78%">


<p>This option restricts the range of command line words
that are considered to be arguments. If combined with one of
the extended completion patterns
&lsquo;<b>p[</b>...<b>]</b>&rsquo;,
&lsquo;<b>r[</b>...<b>]</b>&rsquo;, or
&lsquo;<b>R[</b>...<b>]</b>&rsquo; (see the section
&lsquo;Extended Completion&rsquo; below) the range is
restricted to the range of arguments specified in the
brackets. Completion is then performed as if these had been
given as arguments to the <i>cmd</i> supplied with the
option. If the <i>cmd</i> string is empty the first word in
the range is instead taken as the command name, and command
name completion performed on the first word in the range.
For example,</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;x &rsquo;r[&minus;exec,;]&rsquo; &minus;l
&rsquo;&rsquo; &minus;&minus; find</b></p>

<p style="margin-left:22%; margin-top: 1em">completes
arguments between &lsquo;<b>&minus;exec</b>&rsquo; and the
following &lsquo;<b>;</b>&rsquo; (or the end of the command
line if there is no such string) as if they were a separate
command line.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&minus;h</b> <i>cmd</i></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Normally zsh completes quoted
strings as a whole. With this option, completion can be done
separately on different parts of such strings. It works like
the <b>&minus;l</b> option but makes the completion code
work on the parts of the current word that are separated by
spaces. These parts are completed as if they were arguments
to the given <i>cmd</i>. If <i>cmd</i> is the empty string,
the first part is completed as a command name, as with
<b>&minus;l</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;U</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Use the whole list of possible completions, whether or
not they actually match the word on the command line. The
word typed so far will be deleted. This is most useful with
a function (given by the <b>&minus;K</b> option) which can
examine the word components passed to it (or via the
<b>read</b> builtin&rsquo;s <b>&minus;c</b> and
<b>&minus;l</b> flags) and use its own criteria to decide
what matches. If there is no completion, the original word
is retained. Since the produced possible completions seldom
have interesting common prefixes and suffixes, menu
completion is started immediately if <b>AUTO_MENU</b> is set
and this flag is used.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;y</b>
<i>func&minus;or&minus;var</i></p>

<p style="margin-left:22%;">The list provided by
<i>func&minus;or&minus;var</i> is displayed instead of the
list of completions whenever a listing is required; the
actual completions to be inserted are not affected. It can
be provided in two ways. Firstly, if
<i>func&minus;or&minus;var</i> begins with a <b>$</b> it
defines a variable, or if it begins with a left parenthesis
a literal array, which contains the list. A variable may
have been set by a call to a function using the
<b>&minus;K</b> option. Otherwise it contains the name of a
function which will be executed to create the list. The
function will be passed as an argument list all matching
completions, including prefixes and suffixes expanded in
full, and should set the array <b>reply</b> to the result.
In both cases, the display list will only be retrieved after
a complete list of matches has been created.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
returned list does not have to correspond, even in length,
to the original set of matches, and may be passed as a
scalar instead of an array. No special formatting of
characters is performed on the output in this case; in
particular, newlines are printed literally and if they
appear output in columns is suppressed.</p>

<p style="margin-left:11%;"><b>&minus;X</b>
<i>explanation</i></p>

<p style="margin-left:22%;">Print <i>explanation</i> when
trying completion on the current set of options. A
&lsquo;<b>%n</b>&rsquo; in this string is replaced by the
number of matches that were added for this explanation
string. The explanation only appears if completion was tried
and there was no unique match, or when listing completions.
Explanation strings will be listed together with the matches
of the group specified together with the <b>&minus;X</b>
option (using the <b>&minus;J</b> or <b>&minus;V</b>
option). If the same explanation string is given to multiple
<b>&minus;X</b> options, the string appears only once (for
each group) and the number of matches shown for the
&lsquo;<b>%n</b>&rsquo; is the total number of all matches
for each of these uses. In any case, the explanation string
will only be shown if there was at least one match added for
the explanation string.</p>

<p style="margin-left:22%; margin-top: 1em">The sequences
<b>%B</b>, <b>%b</b>, <b>%S</b>, <b>%s</b>, <b>%U</b>, and
<b>%u</b> specify output attributes (bold, standout, and
underline), <b>%F</b>, <b>%f</b>, <b>%K</b>, <b>%k</b>
specify foreground and background colours, and
<b>%{...%}</b> can be used to include literal escape
sequences as in prompts.</p>

<p style="margin-left:11%;"><b>&minus;Y</b>
<i>explanation</i></p>

<p style="margin-left:22%;">Identical to <b>&minus;X</b>,
except that the <i>explanation</i> first undergoes expansion
following the usual rules for strings in double quotes. The
expansion will be carried out after any functions are called
for the <b>&minus;K</b> or <b>&minus;y</b> options, allowing
them to set variables.</p>

<p style="margin-left:11%;"><b>&minus;t</b>
<i>continue</i></p>

<p style="margin-left:22%;">The
<i>continue</i>&minus;string contains a character that
specifies which set of completion flags should be used next.
It is useful:</p>

<p style="margin-left:22%; margin-top: 1em">(i) With
<b>&minus;T</b>, or when trying a list of pattern
completions, when <b>compctl</b> would usually continue with
ordinary processing after finding matches; this can be
suppressed with &lsquo;<b>&minus;tn</b>&rsquo;.</p>

<p style="margin-left:22%; margin-top: 1em">(ii) With a
list of alternatives separated by <b>+</b>, when
<b>compctl</b> would normally stop when one of the
alternatives generates matches. It can be forced to consider
the next set of completions by adding
&lsquo;<b>&minus;t+</b>&rsquo; to the flags of the
alternative before the &lsquo;<b>+</b>&rsquo;.</p>

<p style="margin-left:22%; margin-top: 1em">(iii) In an
extended completion list (see below), when <b>compctl</b>
would normally continue until a set of conditions succeeded,
then use only the immediately following flags. With
&lsquo;<b>&minus;t&minus;</b>&rsquo;, <b>compctl</b> will
continue trying extended completions after the next
&lsquo;<b>&minus;</b>&rsquo;; with
&lsquo;<b>&minus;tx</b>&rsquo; it will attempt completion
with the default flags, in other words those before the
&lsquo;<b>&minus;x</b>&rsquo;.</p>

<p style="margin-left:11%;"><b>&minus;J</b> <i>name</i></p>

<p style="margin-left:22%;">This gives the name of the
group the matches should be placed in. Groups are listed and
sorted separately; likewise, menu completion will offer the
matches in the groups in the order in which the groups were
defined. If no group name is explicitly given, the matches
are stored in a group named <i>default</i>. The first time a
group name is encountered, a group with that name is
created. After that all matches with the same group name are
stored in that group.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
useful with non&minus;exclusive alternative completions. For
example, in</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;f &minus;J files &minus;t+ + &minus;v &minus;J
variables foo</b></p>

<p style="margin-left:22%; margin-top: 1em">both files and
variables are possible completions, as the <b>&minus;t+</b>
forces both sets of alternatives before and after the
<b>+</b> to be considered at once. Because of the
<b>&minus;J</b> options, however, all files are listed
before all variables.</p>

<p style="margin-left:11%;"><b>&minus;V</b> <i>name</i></p>

<p style="margin-left:22%;">Like <b>&minus;J</b>, but
matches within the group will not be sorted in listings nor
in menu completion. These unsorted groups are in a different
name space from the sorted ones, so groups defined as
<b>&minus;J files</b> and <b>&minus;V files</b> are
distinct.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;1</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>If given together with the <b>&minus;V</b> option, makes
only consecutive duplicates in the group be removed. Note
that groups with and without this flag are in different name
spaces.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;2</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>If given together with the <b>&minus;J</b> or
<b>&minus;V</b> option, makes all duplicates be kept. Again,
groups with and without this flag are in different name
spaces.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;M</b>
<i>match&minus;spec</i></p>

<p style="margin-left:22%;">This defines additional
matching control specifications that should be used only
when testing words for the list of flags this flag appears
in. The format of the <i>match&minus;spec</i> string is
described in zshcompwid.</p>

<h2>ALTERNATIVE COMPLETION
<a name="ALTERNATIVE COMPLETION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>compctl</b>
[ <b>&minus;CDT</b> ] <i>options</i> <b>+</b> <i>options</i>
[ <b>+</b> ... ] [ <b>+</b> ] <i>command</i> ...</p>

<p style="margin-left:11%; margin-top: 1em">The form with
&lsquo;<b>+</b>&rsquo; specifies alternative options.
Completion is tried with the options before the first
&lsquo;<b>+</b>&rsquo;. If this produces no matches
completion is tried with the flags after the
&lsquo;<b>+</b>&rsquo; and so on. If there are no flags
after the last &lsquo;<b>+</b>&rsquo; and a match has not
been found up to that point, default completion is tried. If
the list of flags contains a <b>&minus;t</b> with a <b>+</b>
character, the next list of flags is used even if the
current list produced matches.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
options are available that restrict completion to some part
of the command line; this is referred to as &lsquo;extended
completion&rsquo;.</p>

<h2>EXTENDED COMPLETION
<a name="EXTENDED COMPLETION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>compctl</b>
[ <b>&minus;CDT</b> ] <i>options</i> <b>&minus;x</b>
<i>pattern options</i> <b>&minus;</b> ...
<b>&minus;&minus;</b> <br>
[ <i>command</i> ... ] <b><br>
compctl</b> [ <b>&minus;CDT</b> ] <i>options</i> [
<b>&minus;x</b> <i>pattern options</i> <b>&minus;</b> ...
<b>&minus;&minus;</b> ] <br>
[ <b>+</b> <i>options</i> [ <b>&minus;x</b> ...
<b>&minus;&minus;</b> ] ... [<b>+</b>] ] [ <i>command</i>
... ]</p>

<p style="margin-left:11%; margin-top: 1em">The form with
&lsquo;<b>&minus;x</b>&rsquo; specifies extended completion
for the commands given; as shown, it may be combined with
alternative completion using &lsquo;<b>+</b>&rsquo;. Each
<i>pattern</i> is examined in turn; when a match is found,
the corresponding <i>options</i>, as described in the
section &lsquo;Option Flags&rsquo; above, are used to
generate possible completions. If no <i>pattern</i> matches,
the <i>options</i> given before the <b>&minus;x</b> are
used.</p>

<p style="margin-left:11%; margin-top: 1em">Note that each
pattern should be supplied as a single argument and should
be quoted to prevent expansion of metacharacters by the
shell.</p>

<p style="margin-left:11%; margin-top: 1em">A
<i>pattern</i> is built of sub&minus;patterns separated by
commas; it matches if at least one of these
sub&minus;patterns matches (they are &lsquo;or&rsquo;ed).
These sub&minus;patterns are in turn composed of other
sub&minus;patterns separated by white spaces which match if
all of the sub&minus;patterns match (they are
&lsquo;and&rsquo;ed). An element of the sub&minus;patterns
is of the form
&lsquo;<i>c</i><b>[</b>...<b>][</b>...<b>]</b>&rsquo;, where
the pairs of brackets may be repeated as often as necessary,
and matches if any of the sets of brackets match (an
&lsquo;or&rsquo;). The example below makes this clearer.</p>

<p style="margin-left:11%; margin-top: 1em">The elements
may be any of the following: <b><br>
s[</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the current word on
the command line starts with one of the strings given in
brackets. The <i>string</i> is not removed and is not part
of the completion.</p>


<p style="margin-left:11%;"><b>S[</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Like
<b>s[</b><i>string</i><b>]</b> except that the <i>string</i>
is part of the completion.</p>


<p style="margin-left:11%;"><b>p[</b><i>from</i><b>,</b><i>to</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the number of the
current word is between one of the <i>from</i> and <i>to</i>
pairs inclusive. The comma and <i>to</i> are optional;
<i>to</i> defaults to the same value as <i>from</i>. The
numbers may be negative: <b>&minus;</b><i>n</i> refers to
the <i>n</i>&rsquo;th last word on the line.</p>


<p style="margin-left:11%;"><b>c[</b><i>offset</i><b>,</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the <i>string</i>
matches the word offset by <i>offset</i> from the current
word position. Usually <i>offset</i> will be negative.</p>


<p style="margin-left:11%;"><b>C[</b><i>offset</i><b>,</b><i>pattern</i><b>]</b>...</p>

<p style="margin-left:22%;">Like <b>c</b> but using pattern
matching instead.</p>


<p style="margin-left:11%;"><b>w[</b><i>index</i><b>,</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the word in position
<i>index</i> is equal to the corresponding <i>string</i>.
Note that the word count is made after any alias
expansion.</p>


<p style="margin-left:11%;"><b>W[</b><i>index</i><b>,</b><i>pattern</i><b>]</b>...</p>

<p style="margin-left:22%;">Like <b>w</b> but using pattern
matching instead.</p>


<p style="margin-left:11%;"><b>n[</b><i>index</i><b>,</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the current word
contains <i>string</i>. Anything up to and including the
<i>index</i>th occurrence of this string will not be
considered part of the completion, but the rest will.
<i>index</i> may be negative to count from the end: in most
cases, <i>index</i> will be 1 or &minus;1. For example,</p>

<p style="margin-left:32%; margin-top: 1em"><b>compctl
&minus;s &rsquo;&lsquo;users&lsquo;&rsquo; &minus;x
&rsquo;n[1,@]&rsquo; &minus;k hosts &minus;&minus;
talk</b></p>

<p style="margin-left:22%; margin-top: 1em">will usually
complete usernames, but if you insert an <b>@</b> after the
name, names from the array <i>hosts</i> (assumed to contain
hostnames, though you must make the array yourself) will be
completed. Other commands such as <b>rcp</b> can be handled
similarly.</p>


<p style="margin-left:11%;"><b>N[</b><i>index</i><b>,</b><i>string</i><b>]</b>...</p>

<p style="margin-left:22%;">Like <b>n</b> except that the
string will be taken as a character class. Anything up to
and including the <i>index</i>th occurrence of any of the
characters in <i>string</i> will not be considered part of
the completion.</p>


<p style="margin-left:11%;"><b>m[</b><i>min</i><b>,</b><i>max</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the total number of
words lies between <i>min</i> and <i>max</i> inclusive.</p>


<p style="margin-left:11%;"><b>r[</b><i>str1</i><b>,</b><i>str2</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches if the cursor is after
a word with prefix <i>str1</i>. If there is also a word with
prefix <i>str2</i> on the command line after the one matched
by <i>str1</i> it matches only if the cursor is before this
word. If the comma and <i>str2</i> are omitted, it matches
if the cursor is after a word with prefix <i>str1</i>.</p>


<p style="margin-left:11%;"><b>R[</b><i>str1</i><b>,</b><i>str2</i><b>]</b>...</p>

<p style="margin-left:22%;">Like <b>r</b> but using pattern
matching instead.</p>


<p style="margin-left:11%;"><b>q[</b><i>str</i><b>]</b>...</p>

<p style="margin-left:22%;">Matches the word currently
being completed is in single quotes and the <i>str</i>
begins with the letter &lsquo;s&rsquo;, or if completion is
done in double quotes and <i>str</i> starts with the letter
&lsquo;d&rsquo;, or if completion is done in backticks and
<i>str</i> starts with a &lsquo;b&rsquo;.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:22%; margin-top: 1em"><b>compctl
&minus;u &minus;x &rsquo;s[+]
c[&minus;1,&minus;f],s[&minus;f+]&rsquo; \ <br>
&minus;g &rsquo;~/Mail/*(:t)&rsquo; &minus;
&rsquo;s[&minus;f],c[&minus;1,&minus;f]&rsquo; &minus;f
&minus;&minus; mail</b></p>

<p style="margin-left:11%; margin-top: 1em">This is to be
interpreted as follows:</p>

<p style="margin-left:11%; margin-top: 1em">If the current
command is <b>mail</b>, then</p>

<p style="margin-left:22%; margin-top: 1em">if ((the
current word begins with <b>+</b> and the previous word is
<b>&minus;f</b>) <br>
or (the current word begins with <b>&minus;f+</b>)), then
complete the <br>
non&minus;directory part (the &lsquo;<b>:t</b>&rsquo; glob
modifier) of files in the directory <b><br>
~/Mail</b>; else</p>

<p style="margin-left:22%; margin-top: 1em">if the current
word begins with <b>&minus;f</b> or the previous word was
<b>&minus;f</b>, then <br>
complete any file; else</p>

<p style="margin-left:22%; margin-top: 1em">complete user
names.</p>
<hr>
</body>
</html>
