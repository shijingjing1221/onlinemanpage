<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 20:57:32 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CDEFTUTORIAL</title>

</head>
<body>

<h1 align="center">CDEFTUTORIAL</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#What are CDEFs?">What are CDEFs?</a><br>
<a href="#Syntax">Syntax</a><br>
<a href="#RPN-expressions">RPN-expressions</a><br>
<a href="#Converting your wishes to RPN">Converting your wishes to RPN</a><br>
<a href="#Some special numbers">Some special numbers</a><br>
<a href="#Some examples">Some examples</a><br>
<a href="#The examples from the RRD graph manual page">The examples from the RRD graph manual page</a><br>
<a href="#Out of ideas for now">Out of ideas for now</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">cdeftutorial
&minus; Alex van den Bogaerdt&rsquo;s CDEF tutorial</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Intention of
this document: to provide some examples of the commonly used
parts of RRDtool&rsquo;s <small>CDEF</small> language.</p>

<p style="margin-left:11%; margin-top: 1em">If you think
some important feature is not explained properly, and if
adding it to this document would benefit most users, please
do ask me to add it. I will then try to provide an answer in
the next release of this tutorial. No feedback equals no
changes! Additions to this document are also welcome. --
Alex van den Bogaerdt &lt;alex@vandenbogaerdt.nl&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why this
tutorial?</b> <br>
One of the powerful parts of RRDtool is its ability to do
all sorts of calculations on the data retrieved from its
databases. However, RRDtool&rsquo;s many options and syntax
make it difficult for the average user to understand. The
manuals are good at explaining what these options do;
however they do not (and should not) explain in detail why
they are useful. As with my RRDtool tutorial: if you want a
simple document in simple language you should read this
tutorial. If you are happy with the official documentation,
you may find this document too simple or even boring. If you
do choose to read this tutorial, I also expect you to have
read and fully understand my other tutorial.</p>

<p style="margin-left:11%; margin-top: 1em"><b>More
reading</b> <br>
If you have difficulties with the way I try to explain it
please read Steve Rader&rsquo;s rpntutorial. It may help you
understand how this all works.</p>

<h2>What are CDEFs?
<a name="What are CDEFs?"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When retrieving
data from an <small>RRD</small> , you are using a &quot;
<small>DEF</small> &quot; to work with that data. Think of
it as a variable that changes over time (where time is the
x&minus;axis). The value of this variable is what is found
in the database at that particular time and you can&rsquo;t
do any modifications on it. This is what CDEFs are for: they
takes values from DEFs and perform calculations on them.</p>

<h2>Syntax
<a name="Syntax"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">   DEF:var_name_1=some.rrd:ds_name:CF
   CDEF:var_name_2=RPN_expression</pre>


<p style="margin-left:11%; margin-top: 1em">You first
define &quot;var_name_1&quot; to be data collected from data
source &quot;ds_name&quot; found in <small>RRD</small>
&quot;some.rrd&quot; with consolidation function &quot;
<small>CF</small> &quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Assume the
ifInOctets <small>SNMP</small> counter is saved in mrtg.rrd
as the <small>DS</small> &quot;in&quot;. Then the following
<small>DEF</small> defines a variable for the average of
that data source:</p>

<pre style="margin-left:11%; margin-top: 1em">   DEF:inbytes=mrtg.rrd:in:AVERAGE</pre>


<p style="margin-left:11%; margin-top: 1em">Say you want to
display bits per second (instead of bytes per second as
stored in the database.) You have to define a calculation
(hence &quot; <small>CDEF</small> &quot;) on variable
&quot;inbytes&quot; and use that variable (inbits) instead
of the original:</p>

<pre style="margin-left:11%; margin-top: 1em">   CDEF:inbits=inbytes,8,*</pre>


<p style="margin-left:11%; margin-top: 1em">This tells
RRDtool to multiply inbytes by eight to get inbits.
I&rsquo;ll explain later how this works. In the graphing or
printing functions, you can now use inbits where you would
use inbytes otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
variable name used in the <small>CDEF</small> (inbits) must
not be the same as the variable named in the
<small>DEF</small> (inbytes)!</p>

<h2>RPN-expressions
<a name="RPN-expressions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>RPN</small>
is short-hand for Reverse Polish Notation. It works as
follows. You put the variables or numbers on a stack. You
also put operations (things-to-do) on the stack and this
stack is then processed. The result will be placed on the
stack. At the end, there should be exactly one number left:
the outcome of the series of operations. If there is not
exactly one number left, RRDtool will complain loudly.</p>

<p style="margin-left:11%; margin-top: 1em">Above
multiplication by eight will look like:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Start with an empty stack</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Put the content of variable inbytes on the stack</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Put the number eight on the stack</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Put the operation multiply on the stack</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Process the stack</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Retrieve the value from the stack and put it in variable
inbits</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">We will now do
an example with real numbers. Suppose the variable inbytes
would have value 10, the stack would be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="12%">


<p style="margin-top: 1em">||</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="12%">


<p>|10|</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="12%">


<p>|10|8|</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="12%">


<p>|10|8|*|</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="12%">


<p>|80|</p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="12%">


<p>||</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Processing the
stack (step 5) will retrieve one value from the stack (from
the right at step 4). This is the operation multiply and
this takes two values off the stack as input. The result is
put back on the stack (the value 80 in this case). For
multiplication the order doesn&rsquo;t matter, but for other
operations like subtraction and division it does. Generally
speaking you have the following order:</p>

<pre style="margin-left:11%; margin-top: 1em">   y = A &minus; B  &minus;&minus;&gt;  y=minus(A,B)  &minus;&minus;&gt;  CDEF:y=A,B,&minus;</pre>


<p style="margin-left:11%; margin-top: 1em">This is not
very intuitive (at least most people don&rsquo;t think so).
For the function f(A,B) you reverse the position of
&quot;f&quot;, but you do not reverse the order of the
variables.</p>

<h2>Converting your wishes to RPN
<a name="Converting your wishes to RPN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">First, get a
clear picture of what you want to do. Break down the problem
in smaller portions until they cannot be split anymore. Then
it is rather simple to convert your ideas into
<small>RPN</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Suppose you
have several RRDs and would like to add up some counters in
them. These could be, for instance, the counters for every
<small>WAN</small> link you are monitoring.</p>

<p style="margin-left:11%; margin-top: 1em">You have:</p>

<pre style="margin-left:11%; margin-top: 1em">   router1.rrd with link1in link2in
   router2.rrd with link1in link2in
   router3.rrd with link1in link2in</pre>


<p style="margin-left:11%; margin-top: 1em">Suppose you
would like to add up all these counters, except for link2in
inside router2.rrd. You need to do:</p>

<p style="margin-left:11%; margin-top: 1em">(in this
example, &quot;router1.rrd:link1in&quot; means the
<small>DS</small> link1in inside the <small>RRD</small>
router1.rrd)</p>

<pre style="margin-left:11%; margin-top: 1em">   router1.rrd:link1in
   router1.rrd:link2in
   router2.rrd:link1in
   router3.rrd:link1in
   router3.rrd:link2in
   &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;   +
   (outcome of the sum)</pre>


<p style="margin-left:11%; margin-top: 1em">As a
mathematical function, this could be written:</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;add(router1.rrd:link1in
, router1.rrd:link2in , router2.rrd:link1in ,
router3.rrd:link1in , router3.rrd:link2.in)&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">With RRDtool
and <small>RPN</small> , first, define the inputs:</p>

<pre style="margin-left:11%; margin-top: 1em">   DEF:a=router1.rrd:link1in:AVERAGE
   DEF:b=router1.rrd:link2in:AVERAGE
   DEF:c=router2.rrd:link1in:AVERAGE
   DEF:d=router3.rrd:link1in:AVERAGE
   DEF:e=router3.rrd:link2in:AVERAGE</pre>


<p style="margin-left:11%; margin-top: 1em">Now, the
mathematical function becomes:
<tt>&quot;add(a,b,c,d,e)&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">In
<small>RPN</small> , there&rsquo;s no operator that sums
more than two values so you need to do several additions.
You add a and b, add c to the result, add d to the result
and add e to the result.</p>

<pre style="margin-left:11%; margin-top: 1em">   push a:         a     stack contains the value of a
   push b and add: b,+   stack contains the result of a+b
   push c and add: c,+   stack contains the result of a+b+c
   push d and add: d,+   stack contains the result of a+b+c+d
   push e and add: e,+   stack contains the result of a+b+c+d+e</pre>


<p style="margin-left:11%; margin-top: 1em">What was
calculated here would be written down as:</p>

<pre style="margin-left:11%; margin-top: 1em">   ( ( ( (a+b) + c) + d) + e) &gt;</pre>


<p style="margin-left:11%; margin-top: 1em">This is in
<small>RPN:</small>
<tt>&quot;CDEF:result=a,b,+,c,+,d,+,e,+&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">This is correct
but it can be made more clear to humans. It does not matter
if you add a to b and then add c to the result or first add
b to c and then add a to the result. This makes it possible
to rewrite the <small>RPN</small> into
<tt>&quot;CDEF:result=a,b,c,d,e,+,+,+,+&quot;</tt> which is
evaluated differently:</p>

<pre style="margin-left:11%; margin-top: 1em">   push value of variable a on the stack: a
   push value of variable b on the stack: a b
   push value of variable c on the stack: a b c
   push value of variable d on the stack: a b c d
   push value of variable e on the stack: a b c d e
   push operator + on the stack:          a b c d e +
   and process it:                        a b c P   (where P == d+e)
   push operator + on the stack:          a b c P +
   and process it:                        a b Q     (where Q == c+P)
   push operator + on the stack:          a b Q +
   and process it:                        a R       (where R == b+Q)
   push operator + on the stack:          a R +
   and process it:                        S         (where S == a+R)</pre>


<p style="margin-left:11%; margin-top: 1em">As you can see
the <small>RPN</small> expression
<tt>&quot;a,b,c,d,e,+,+,+,+,+&quot;</tt> will evaluate in
<tt>&quot;((((d+e)+c)+b)+a)&quot;</tt> and it has the same
outcome as <tt>&quot;a,b,+,c,+,d,+,e,+&quot;</tt>. This is
called the commutative law of addition, but you may forget
this right away, as long as you remember what it means.</p>

<p style="margin-left:11%; margin-top: 1em">Now look at an
expression that contains a multiplication:</p>

<p style="margin-left:11%; margin-top: 1em">First in normal
math: <tt>&quot;let result = a+b*c&quot;</tt>. In this case
you can&rsquo;t choose the order yourself, you have to start
with the multiplication and then add a to it. You may alter
the position of b and c, you must not alter the position of
a and b.</p>

<p style="margin-left:11%; margin-top: 1em">You have to
take this in consideration when converting this expression
into <small>RPN</small> . Read it as: &quot;Add the outcome
of b*c to a&quot; and then it is easy to write the
<small>RPN</small> expression:
<tt>&quot;result=a,b,c,*,+&quot;</tt> Another expression
that would return the same:
<tt>&quot;result=b,c,*,a,+&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">In normal math,
you may encounter something like &quot;a*(b+c)&quot; and
this can also be converted into <small>RPN</small> . The
parenthesis just tell you to first add b and c, and then
multiply a with the result. Again, now it is easy to write
it in <small>RPN:</small>
<tt>&quot;result=a,b,c,+,*&quot;</tt>. Note that this is
very similar to one of the expressions in the previous
paragraph, only the multiplication and the addition changed
places.</p>

<p style="margin-left:11%; margin-top: 1em">When you have
problems with <small>RPN</small> or when RRDtool is
complaining, it&rsquo;s usually a good thing to write down
the stack on a piece of paper and see what happens. Have the
manual ready and pretend to be RRDtool. Just do all the math
by hand to see what happens, I&rsquo;m sure this will solve
most, if not all, problems you encounter.</p>

<h2>Some special numbers
<a name="Some special numbers"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>The unknown
value</b> <br>
Sometimes collecting your data will fail. This can be very
common, especially when querying over busy links. RRDtool
can be configured to allow for one (or even more) unknown
value(s) and calculate the missing update. You can, for
instance, query your device every minute. This is creating
one so called <small>PDP</small> or primary data point per
minute. If you defined your <small>RRD</small> to contain an
<small>RRA</small> that stores 5&minus;minute values, you
need five of those PDPs to create one <small>CDP</small>
(consolidated data point). These PDPs can become unknown in
two cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">The updates are too far apart.
This is tuned using the &quot;heartbeat&quot; setting.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The update was set to unknown on purpose by inserting no
value (using the template option) or by using &quot;U&quot;
as the value to insert.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">When a
<small>CDP</small> is calculated, another mechanism
determines if this <small>CDP</small> is valid or not. If
there are too many PDPs unknown, the <small>CDP</small> is
unknown as well. This is determined by the xff factor.
Please note that one unknown counter update can result in
two unknown PDPs! If you only allow for one unknown
<small>PDP</small> per <small>CDP</small> , this makes the
<small>CDP</small> go unknown!</p>

<p style="margin-left:11%; margin-top: 1em">Suppose the
counter increments with one per second and you retrieve it
every minute:</p>

<pre style="margin-left:11%; margin-top: 1em">   counter value    resulting rate
   10'000
   10'060            1; (10'060&minus;10'000)/60 == 1
   10'120            1; (10'120&minus;10'060)/60 == 1
   unknown           unknown; you don't know the last value
   10'240            unknown; you don't know the previous value
   10'300            1; (10'300&minus;10'240)/60 == 1</pre>


<p style="margin-left:11%; margin-top: 1em">If the
<small>CDP</small> was to be calculated from the last five
updates, it would get two unknown PDPs and three known PDPs.
If xff would have been set to 0.5 which by the way is a
commonly used factor, the <small>CDP</small> would have a
known value of 1. If xff would have been set to 0.2 then the
resulting <small>CDP</small> would be unknown.</p>

<p style="margin-left:11%; margin-top: 1em">You have to
decide the proper values for heartbeat, number of PDPs per
<small>CDP</small> and the xff factor. As you can see from
the previous text they define the behavior of your
<small>RRA</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>Working with
unknown data in your database</b> <br>
As you have read in the previous chapter, entries in an
<small>RRA</small> can be set to the unknown value. If you
do calculations with this type of value, the result has to
be unknown too. This means that an expression such as
<tt>&quot;result=a,b,+&quot;</tt> will be unknown if either
a or b is unknown. It would be wrong to just ignore the
unknown value and return the value of the other parameter.
By doing so, you would assume &quot;unknown&quot; means
&quot;zero&quot; and this is not true.</p>

<p style="margin-left:11%; margin-top: 1em">There has been
a case where somebody was collecting data for over a year. A
new piece of equipment was installed, a new
<small>RRD</small> was created and the scripts were changed
to add a counter from the old database and a counter from
the new database. The result was disappointing, a large part
of the statistics seemed to have vanished mysteriously ...
They of course didn&rsquo;t, values from the old database
(known values) were added to values from the new database
(unknown values) and the result was unknown.</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
it is fairly reasonable to use a <small>CDEF</small> that
alters unknown data into zero. The counters of the device
were unknown (after all, it wasn&rsquo;t installed yet!) but
you know that the data rate through the device had to be
zero (because of the same reason: it was not installed).</p>

<p style="margin-left:11%; margin-top: 1em">There are some
examples below that make this change.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Infinity</b>
<br>
Infinite data is another form of a special number. It cannot
be graphed because by definition you would never reach the
infinite value. You can think of positive and negative
infinity depending on the position relative to zero.</p>

<p style="margin-left:11%; margin-top: 1em">RRDtool is
capable of representing (&minus;not&minus; graphing!)
infinity by stopping at its current maximum (for positive
infinity) or minimum (for negative infinity) without knowing
this maximum (minimum).</p>

<p style="margin-left:11%; margin-top: 1em">Infinity in
RRDtool is mostly used to draw an <small>AREA</small>
without knowing its vertical dimensions. You can think of it
as drawing an <small>AREA</small> with an infinite height
and displaying only the part that is visible in the current
graph. This is probably a good way to approximate infinity
and it sure allows for some neat tricks. See below for
examples.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Working with
unknown data and infinity</b> <br>
Sometimes you would like to discard unknown data and pretend
it is zero (or any other value for that matter) and
sometimes you would like to pretend that known data is
unknown (to discard known-to-be-wrong data). This is why
CDEFs have support for unknown data. There are also examples
available that show unknown data by using infinity.</p>

<h2>Some examples
<a name="Some examples"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Example:
using a recently created <small>RRD</small></b> <br>
You are keeping statistics on your router for over a year
now. Recently you installed an extra router and you would
like to show the combined throughput for these two
devices.</p>

<p style="margin-left:11%; margin-top: 1em">If you just add
up the counters from router.rrd and router2.rrd, you will
add known data (from router.rrd) to unknown data (from
router2.rrd) for the bigger part of your stats. You could
solve this in a few ways:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">While creating the new database,
fill it with zeros from the start to now. You have to make
the database start at or before the least recent time in the
other database.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Alternatively, you could use <small>CDEF</small> and
alter unknown data to zero.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Both methods
have their pros and cons. The first method is troublesome
and if you want to do that you have to figure it out
yourself. It is not possible to create a database filled
with zeros, you have to put them in manually. Implementing
the second method is described next:</p>

<p style="margin-left:11%; margin-top: 1em">What we want
is: &quot;if the value is unknown, replace it with
zero&quot;. This could be written in pseudo-code as: if
(value is unknown) then (zero) else (value). When reading
the rrdgraph manual you notice the &quot; <small>UN</small>
&quot; function that returns zero or one. You also notice
the &quot; <small>IF</small> &quot; function that takes zero
or one as input.</p>

<p style="margin-left:11%; margin-top: 1em">First look at
the &quot; <small>IF</small> &quot; function. It takes three
values from the stack, the first value is the decision
point, the second value is returned to the stack if the
evaluation is &quot;true&quot; and if not, the third value
is returned to the stack. We want the &quot;
<small>UN</small> &quot; function to decide what happens so
we combine those two functions in one <small>CDEF</small>
.</p>

<p style="margin-left:11%; margin-top: 1em">Lets write down
the two possible paths for the &quot; <small>IF</small>
&quot; function:</p>

<pre style="margin-left:11%; margin-top: 1em">   if true  return a
   if false return b</pre>


<p style="margin-left:11%; margin-top: 1em">In
<small>RPN:</small> <tt>&quot;result=x,a,b,IF&quot;</tt>
where &quot;x&quot; is either true or false.</p>

<p style="margin-left:11%; margin-top: 1em">Now we have to
fill in &quot;x&quot;, this should be the &quot;(value is
unknown)&quot; part and this is in <small>RPN:</small>
<tt>&quot;result=value,UN&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">We now combine
them: <tt>&quot;result=value,UN,a,b,IF&quot;</tt> and when
we fill in the appropriate things for &quot;a&quot; and
&quot;b&quot; we&rsquo;re finished:</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;CDEF:result=value,UN,0,value,IF&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">You may want to
read Steve Rader&rsquo;s <small>RPN</small> guide if you
have difficulties with the way I explained this last
example.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
check this <small>RPN</small> expression, just mimic RRDtool
behavior:</p>

<pre style="margin-left:11%; margin-top: 1em">   For any known value, the expression evaluates as follows:
   CDEF:result=value,UN,0,value,IF  (value,UN) is not true so it becomes 0
   CDEF:result=0,0,value,IF         &quot;IF&quot; will return the 3rd value
   CDEF:result=value                The known value is returned
   For the unknown value, this happens:
   CDEF:result=value,UN,0,value,IF  (value,UN) is true so it becomes 1
   CDEF:result=1,0,value,IF         &quot;IF&quot; sees 1 and returns the 2nd value
   CDEF:result=0                    Zero is returned</pre>


<p style="margin-left:11%; margin-top: 1em">Of course, if
you would like to see another value instead of zero, you can
use that other value.</p>

<p style="margin-left:11%; margin-top: 1em">Eventually,
when all unknown data is removed from the <small>RRD</small>
, you may want to remove this rule so that unknown data is
properly displayed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example:
better handling of unknown data, by using time</b> <br>
The above example has one drawback. If you do log unknown
data in your database after installing your new equipment,
it will also be translated into zero and therefore you
won&rsquo;t see that there was a problem. This is not good
and what you really want to do is:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If there is unknown data, look
at the time that this sample was taken.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the unknown value is before time xxx, make it
zero.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If it is after time xxx, leave it as unknown data.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This is doable:
you can compare the time that the sample was taken to some
known time. Assuming you started to monitor your device on
Friday September 17, 1999, 00:35:57 <small>MET DST</small> .
Translate this time in seconds since 1970&minus;01&minus;01
and it becomes 937&rsquo;521&rsquo;357. If you process
unknown values that were received after this time, you want
to leave them unknown and if they were &quot;received&quot;
before this time, you want to translate them into zero (so
you can effectively ignore them while adding them to your
other routers counters).</p>

<p style="margin-left:11%; margin-top: 1em">Translating
Friday September 17, 1999, 00:35:57 <small>MET DST</small>
into 937&rsquo;521&rsquo;357 can be done by, for instance,
using gnu date:</p>

<pre style="margin-left:11%; margin-top: 1em">   date &minus;d &quot;19990917 00:35:57&quot; +%s</pre>


<p style="margin-left:11%; margin-top: 1em">You could also
dump the database and see where the data starts to be known.
There are several other ways of doing this, just pick
one.</p>

<p style="margin-left:11%; margin-top: 1em">Now we have to
create the magic that allows us to process unknown values
different depending on the time that the sample was taken.
This is a three step process:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the timestamp of the value is
after 937&rsquo;521&rsquo;357, leave it as is.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the value is a known value, leave it as is.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Change the unknown value into zero.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Lets look at
part one:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (true) return the original value</pre>


<p style="margin-left:11%; margin-top: 1em">We rewrite
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    if (true) return &quot;a&quot;
    if (false) return &quot;b&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">We need to
calculate true or false from step 1. There is a function
available that returns the timestamp for the current sample.
It is called, how surprisingly, &quot; <small>TIME</small>
&quot;. This time has to be compared to a constant number,
we need &quot; <small>GT</small> &quot;. The output of
&quot; <small>GT</small> &quot; is true or false and this is
good input to &quot; <small>IF</small> &quot;. We want
&quot;if (time &gt; 937521357) then (return a) else (return
b)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This process
was already described thoroughly in the previous chapter so
lets do it quick:</p>

<pre style="margin-left:11%; margin-top: 1em">   if (x) then a else b
      where x represents &quot;time&gt;937521357&quot;
      where a represents the original value
      where b represents the outcome of the previous example
   time&gt;937521357       &minus;&minus;&gt; TIME,937521357,GT
   if (x) then a else b &minus;&minus;&gt; x,a,b,IF
   substitute x         &minus;&minus;&gt; TIME,937521357,GT,a,b,IF
   substitute a         &minus;&minus;&gt; TIME,937521357,GT,value,b,IF
   substitute b         &minus;&minus;&gt; TIME,937521357,GT,value,value,UN,0,value,IF,IF</pre>


<p style="margin-left:11%; margin-top: 1em">We end up with:
<tt>&quot;CDEF:result=TIME,937521357,GT,value,value,UN,0,value,IF,IF&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">This looks very
complex, however, as you can see, it was not too hard to
come up with.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example:
Pretending weird data isn&rsquo;t there</b> <br>
Suppose you have a problem that shows up as huge spikes in
your graph. You know this happens and why, so you decide to
work around the problem. Perhaps you&rsquo;re using your
network to do a backup at night and by doing so you get
almost 10mb/s while the rest of your network activity does
not produce numbers higher than 100kb/s.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the number exceeds 100kb/s it
is wrong and you want it masked out by changing it into
unknown.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>You don&rsquo;t want the graph to show more than
100kb/s.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Pseudo code: if
(number &gt; 100) then unknown else number or Pseudo code:
if (number &gt; 100) then 100 else number.</p>

<p style="margin-left:11%; margin-top: 1em">The second
&quot;problem&quot; may also be solved by using the rigid
option of RRDtool graph, however this has not the same
result. In this example you can end up with a graph that
does autoscaling. Also, if you use the numbers to display
maxima they will be set to 100kb/s.</p>

<p style="margin-left:11%; margin-top: 1em">We use &quot;
<small>IF</small> &quot; and &quot; <small>GT</small> &quot;
again. &quot;if (x) then (y) else (z)&quot; is written down
as &quot;CDEF:result=x,y,z,IF&quot;; now fill in x, y and z.
For x you fill in &quot;number greater than 100kb/s&quot;
becoming &quot;number,100000,GT&quot; (kilo is 1&rsquo;000
and b/s is what we measure!). The &quot;z&quot; part is
&quot;number&quot; in both cases and the &quot;y&quot; part
is either &quot; <small>UNKN</small> &quot; for unknown or
&quot;100000&quot; for 100kb/s.</p>

<p style="margin-left:11%; margin-top: 1em">The two
<small>CDEF</small> expressions would be:</p>

<pre style="margin-left:11%; margin-top: 1em">    CDEF:result=number,100000,GT,UNKN,number,IF
    CDEF:result=number,100000,GT,100000,number,IF</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Example:
working on a certain time span</b> <br>
If you want a graph that spans a few weeks, but would only
want to see some routers&rsquo; data for one week, you need
to &quot;hide&quot; the rest of the time frame. Don&rsquo;t
ask me when this would be useful, it&rsquo;s just here for
the example :)</p>

<p style="margin-left:11%; margin-top: 1em">We need to
compare the time stamp to a begin date and an end date.
Comparing isn&rsquo;t difficult:</p>

<pre style="margin-left:11%; margin-top: 1em">        TIME,begintime,GE
        TIME,endtime,LE</pre>


<p style="margin-left:11%; margin-top: 1em">These two parts
of the <small>CDEF</small> produce either 0 for false or 1
for true. We can now check if they are both 0 (or 1) using a
few <small>IF</small> statements but, as Wataru Satoh
pointed out, we can use the &quot;*&quot; or &quot;+&quot;
functions as logical <small>AND</small> and logical
<small>OR</small> .</p>

<p style="margin-left:11%; margin-top: 1em">For
&quot;*&quot;, the result will be zero (false) if either one
of the two operators is zero. For &quot;+&quot;, the result
will only be false (0) when two false (0) operators will be
added. Warning: *any* number not equal to 0 will be
considered &quot;true&quot;. This means that, for instance,
&quot;&minus;1,1,+&quot; (which should be &quot;true or
true&quot;) will become <small>FALSE</small> ... In other
words, use &quot;+&quot; only if you know for sure that you
have positive numbers (or zero) only.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
compile the complete <small>CDEF:</small></p>

<pre style="margin-left:11%; margin-top: 1em">        DEF:ds0=router1.rrd:AVERAGE
        CDEF:ds0modified=TIME,begintime,GT,TIME,endtime,LE,*,ds0,UNKN,IF</pre>


<p style="margin-left:11%; margin-top: 1em">This will
return the value of ds0 if both comparisons return true. You
could also do it the other way around:</p>

<pre style="margin-left:11%; margin-top: 1em">        DEF:ds0=router1.rrd:AVERAGE
        CDEF:ds0modified=TIME,begintime,LT,TIME,endtime,GT,+,UNKN,ds0,IF</pre>


<p style="margin-left:11%; margin-top: 1em">This will
return an <small>UNKNOWN</small> if either comparison
returns true.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example: You
suspect to have problems and want to see unknown data.</b>
<br>
Suppose you add up the number of active users on several
terminal servers. If one of them doesn&rsquo;t give an
answer (or an incorrect one) you get &quot;NaN&quot; in the
database (&quot;Not a Number&quot;) and NaN is evaluated as
Unknown.</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
you would like to be alerted to it and the sum of the
remaining values is of no value to you.</p>

<p style="margin-left:11%; margin-top: 1em">It would be
something like:</p>

<pre style="margin-left:11%; margin-top: 1em">    DEF:users1=location1.rrd:onlineTS1:LAST
    DEF:users2=location1.rrd:onlineTS2:LAST
    DEF:users3=location2.rrd:onlineTS1:LAST
    DEF:users4=location2.rrd:onlineTS2:LAST
    CDEF:allusers=users1,users2,users3,users4,+,+,+</pre>


<p style="margin-left:11%; margin-top: 1em">If you now plot
allusers, unknown data in one of users1..users4 will show up
as a gap in your graph. You want to modify this to show a
bright red line, not a gap.</p>

<p style="margin-left:11%; margin-top: 1em">Define an extra
<small>CDEF</small> that is unknown if all is okay and is
infinite if there is an unknown value:</p>

<pre style="margin-left:11%; margin-top: 1em">    CDEF:wrongdata=allusers,UN,INF,UNKN,IF</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;allusers,UN&quot;
will evaluate to either true or false, it is the (x) part of
the &quot; <small>IF</small> &quot; function and it checks
if allusers is unknown. The (y) part of the &quot;
<small>IF</small> &quot; function is set to &quot;
<small>INF</small> &quot; (which means infinity) and the (z)
part of the function returns &quot; <small>UNKN</small>
&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The logic is:
if (allusers == unknown) then return <small>INF</small> else
return <small>UNKN</small> .</p>

<p style="margin-left:11%; margin-top: 1em">You can now use
<small>AREA</small> to display this &quot;wrongdata&quot; in
bright red. If it is unknown (because allusers is known)
then the red <small>AREA</small> won&rsquo;t show up. If the
value is <small>INF</small> (because allusers is unknown)
then the red <small>AREA</small> will be filled in on the
graph at that particular time.</p>

<pre style="margin-left:11%; margin-top: 1em">   AREA:allusers#0000FF:combined user count
   AREA:wrongdata#FF0000:unknown data</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Same example
useful with STACKed data:</b> <br>
If you use stack in the previous example (as I would do)
then you don&rsquo;t add up the values. Therefore, there is
no relationship between the four values and you don&rsquo;t
get a single value to test. Suppose users3 would be unknown
at one point in time: users1 is plotted, users2 is stacked
on top of users1, users3 is unknown and therefore nothing
happens, users4 is stacked on top of users2. Add the extra
CDEFs anyway and use them to overlay the &quot;normal&quot;
graph:</p>

<pre style="margin-left:11%; margin-top: 1em">   DEF:users1=location1.rrd:onlineTS1:LAST
   DEF:users2=location1.rrd:onlineTS2:LAST
   DEF:users3=location2.rrd:onlineTS1:LAST
   DEF:users4=location2.rrd:onlineTS2:LAST
   CDEF:allusers=users1,users2,users3,users4,+,+,+
   CDEF:wrongdata=allusers,UN,INF,UNKN,IF
   AREA:users1#0000FF:users at ts1
   STACK:users2#00FF00:users at ts2
   STACK:users3#00FFFF:users at ts3
   STACK:users4#FFFF00:users at ts4
   AREA:wrongdata#FF0000:unknown data</pre>


<p style="margin-left:11%; margin-top: 1em">If there is
unknown data in one of users1..users4, the
&quot;wrongdata&quot; <small>AREA</small> will be drawn and
because it starts at the X&minus;axis and has infinite
height it will effectively overwrite the STACKed parts.</p>

<p style="margin-left:11%; margin-top: 1em">You could
combine the two <small>CDEF</small> lines into one (we
don&rsquo;t use &quot;allusers&quot;) if you like. But there
are good reasons for writing two <small>CDEFS:</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">It improves the readability of
the script.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>It can be used inside <small>GPRINT</small> to display
the total number of users.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If you choose
to combine them, you can substitute the &quot;allusers&quot;
in the second <small>CDEF</small> with the part after the
equal sign from the first line:</p>

<pre style="margin-left:11%; margin-top: 1em">   CDEF:wrongdata=users1,users2,users3,users4,+,+,+,UN,INF,UNKN,IF</pre>


<p style="margin-left:11%; margin-top: 1em">If you do so,
you won&rsquo;t be able to use these next GPRINTs:</p>

<pre style="margin-left:11%; margin-top: 1em">   COMMENT:&quot;Total number of users seen&quot;
   GPRINT:allusers:MAX:&quot;Maximum: %6.0lf&quot;
   GPRINT:allusers:MIN:&quot;Minimum: %6.0lf&quot;
   GPRINT:allusers:AVERAGE:&quot;Average: %6.0lf&quot;
   GPRINT:allusers:LAST:&quot;Current: %6.0lf\n&quot;</pre>


<h2>The examples from the RRD graph manual page
<a name="The examples from the RRD graph manual page"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Degrees
Celsius vs. Degrees Fahrenheit</b> <br>
To convert Celsius into Fahrenheit use the formula
F=9/5*C+32</p>

<pre style="margin-left:11%; margin-top: 1em">   rrdtool graph demo.png &minus;&minus;title=&quot;Demo Graph&quot; \
      DEF:cel=demo.rrd:exhaust:AVERAGE \
      CDEF:far=9,5,/,cel,*,32,+ \
      LINE2:cel#00a000:&quot;D. Celsius&quot; \
      LINE2:far#ff0000:&quot;D. Fahrenheit\c&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">This example
gets the <small>DS</small> called &quot;exhaust&quot; from
database &quot;demo.rrd&quot; and puts the values in
variable &quot;cel&quot;. The <small>CDEF</small> used is
evaluated as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">   CDEF:far=9,5,/,cel,*,32,+
   1. push 9, push 5
   2. push function &quot;divide&quot; and process it
      the stack now contains 9/5
   3. push variable &quot;cel&quot;
   4. push function &quot;multiply&quot; and process it
      the stack now contains 9/5*cel
   5. push 32
   6. push function &quot;plus&quot; and process it
      the stack contains now the temperature in Fahrenheit</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Changing
unknown into zero</b></p>

<pre style="margin-left:11%;">   rrdtool graph demo.png &minus;&minus;title=&quot;Demo Graph&quot; \
      DEF:idat1=interface1.rrd:ds0:AVERAGE \
      DEF:idat2=interface2.rrd:ds0:AVERAGE \
      DEF:odat1=interface1.rrd:ds1:AVERAGE \
      DEF:odat2=interface2.rrd:ds1:AVERAGE \
      CDEF:agginput=idat1,UN,0,idat1,IF,idat2,UN,0,idat2,IF,+,8,* \
      CDEF:aggoutput=odat1,UN,0,odat1,IF,odat2,UN,0,odat2,IF,+,8,* \
      AREA:agginput#00cc00:Input Aggregate \
      LINE1:aggoutput#0000FF:Output Aggregate</pre>


<p style="margin-left:11%; margin-top: 1em">These two CDEFs
are built from several functions. It helps to split them
when viewing what they do. Starting with the first
<small>CDEF</small> we would get:</p>

<pre style="margin-left:11%; margin-top: 1em"> idat1,UN &minus;&minus;&gt; a
 0        &minus;&minus;&gt; b
 idat1    &minus;&minus;&gt; c
 if (a) then (b) else (c)</pre>


<p style="margin-left:11%; margin-top: 1em">The result is
therefore &quot;0&quot; if it is true that &quot;idat1&quot;
equals &quot; <small>UN</small> &quot;. If not, the original
value of &quot;idat1&quot; is put back on the stack. Lets
call this answer &quot;d&quot;. The process is repeated for
the next five items on the stack, it is done the same and
will return answer &quot;h&quot;. The resulting stack is
therefore &quot;d,h&quot;. The expression has been
simplified to &quot;d,h,+,8,*&quot; and it will now be easy
to see that we add &quot;d&quot; and &quot;h&quot;, and
multiply the result with eight.</p>

<p style="margin-left:11%; margin-top: 1em">The end result
is that we have added &quot;idat1&quot; and
&quot;idat2&quot; and in the process we effectively ignored
unknown values. The result is multiplied by eight, most
likely to convert bytes/s to bits/s.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Infinity
demo</b></p>

<pre style="margin-left:11%;">   rrdtool graph example.png &minus;&minus;title=&quot;INF demo&quot; \
      DEF:val1=some.rrd:ds0:AVERAGE \
      DEF:val2=some.rrd:ds1:AVERAGE \
      DEF:val3=some.rrd:ds2:AVERAGE \
      DEF:val4=other.rrd:ds0:AVERAGE \
      CDEF:background=val4,POP,TIME,7200,%,3600,LE,INF,UNKN,IF \
      CDEF:wipeout=val1,val2,val3,val4,+,+,+,UN,INF,UNKN,IF \
      AREA:background#F0F0F0 \
      AREA:val1#0000FF:Value1 \
      STACK:val2#00C000:Value2 \
      STACK:val3#FFFF00:Value3 \
      STACK:val4#FFC000:Value4 \
      AREA:whipeout#FF0000:Unknown</pre>


<p style="margin-left:11%; margin-top: 1em">This demo
demonstrates two ways to use infinity. It is a bit tricky to
see what happens in the &quot;background&quot;
<small>CDEF</small> .</p>

<pre style="margin-left:11%; margin-top: 1em">   &quot;val4,POP,TIME,7200,%,3600,LE,INF,UNKN,IF&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">This
<small>RPN</small> takes the value of &quot;val4&quot; as
input and then immediately removes it from the stack using
&quot; <small>POP</small> &quot;. The stack is now empty but
as a side effect we now know the time that this sample was
taken. This time is put on the stack by the &quot;
<small>TIME</small> &quot; function.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;
<small>TIME</small> ,7200,%&quot; takes the modulo of time
and 7&rsquo;200 (which is two hours). The resulting value on
the stack will be a number in the range from 0 to 7199.</p>

<p style="margin-left:11%; margin-top: 1em">For people who
don&rsquo;t know the modulo function: it is the remainder
after an integer division. If you divide 16 by 3, the answer
would be 5 and the remainder would be 1. So,
&quot;16,3,%&quot; returns 1.</p>

<p style="margin-left:11%; margin-top: 1em">We have the
result of &quot; <small>TIME</small> ,7200,%&quot; on the
stack, lets call this &quot;a&quot;. The start of the
<small>RPN</small> has become &quot;a,3600,LE&quot; and this
checks if &quot;a&quot; is less or equal than
&quot;3600&quot;. It is true half of the time. We now have
to process the rest of the <small>RPN</small> and this is
only a simple &quot; <small>IF</small> &quot; function that
returns either &quot; <small>INF</small> &quot; or &quot;
<small>UNKN</small> &quot; depending on the time. This is
returned to variable &quot;background&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The second
<small>CDEF</small> has been discussed earlier in this
document so we won&rsquo;t do that here.</p>

<p style="margin-left:11%; margin-top: 1em">Now you can
draw the different layers. Start with the background that is
either unknown (nothing to see) or infinite (the whole
positive part of the graph gets filled).</p>

<p style="margin-left:11%; margin-top: 1em">Next you draw
the data on top of this background, it will overlay the
background. Suppose one of val1..val4 would be unknown, in
that case you end up with only three bars stacked on top of
each other. You don&rsquo;t want to see this because the
data is only valid when all four variables are valid. This
is why you use the second <small>CDEF</small> , it will
overlay the data with an <small>AREA</small> so the data
cannot be seen anymore.</p>

<p style="margin-left:11%; margin-top: 1em">If your data
can also have negative values you also need to overwrite the
other half of your graph. This can be done in a relatively
simple way: what you need is the &quot;wipeout&quot;
variable and place a negative sign before it:
&quot;CDEF:wipeout2=wipeout,&minus;1,*&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Filtering
data</b> <br>
You may do some complex data filtering:</p>

<pre style="margin-left:11%; margin-top: 1em">  MEDIAN FILTER: filters shot noise
    DEF:var=database.rrd:traffic:AVERAGE
    CDEF:prev1=PREV(var)
    CDEF:prev2=PREV(prev1)
    CDEF:prev3=PREV(prev2)
    CDEF:median=prev1,prev2,prev3,+,+,3,/
    LINE3:median#000077:filtered
    LINE1:prev2#007700:'raw data'
  DERIVATE:
    DEF:var=database.rrd:traffic:AVERAGE
    CDEF:prev1=PREV(var)
    CDEF:time=var,POP,TIME
    CDEF:prevtime=PREV(time)
    CDEF:derivate=var,prev1,&minus;,time,prevtime,&minus;,/
    LINE3:derivate#000077:derivate
    LINE1:var#007700:'raw data'</pre>


<h2>Out of ideas for now
<a name="Out of ideas for now"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
was created from questions asked by either myself or by
other people on the RRDtool mailing list. Please let me know
if you find errors in it or if you have trouble
understanding it. If you think there should be an addition,
mail me: &lt;alex@vandenbogaerdt.nl&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Remember: <b>No
feedback equals no changes!</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The RRDtool
manpages</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Alex van den
Bogaerdt &lt;alex@vandenbogaerdt.nl&gt;</p>
<hr>
</body>
</html>
