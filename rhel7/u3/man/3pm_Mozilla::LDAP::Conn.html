<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:56:59 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Conn</title>

</head>
<body>

<h1 align="center">Conn</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#ABSTRACT">ABSTRACT</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SOME PERLDAP/OO BASICS">SOME PERLDAP/OO BASICS</a><br>
<a href="#CREATING A NEW OBJECT INSTANCE">CREATING A NEW OBJECT INSTANCE</a><br>
<a href="#PERFORMING LDAP SEARCHES">PERFORMING LDAP SEARCHES</a><br>
<a href="#PERFORMING ASYNCHRONOUS SEARCHES">PERFORMING ASYNCHRONOUS SEARCHES</a><br>
<a href="#MODIFYING AND CREATING NEW LDAP ENTRIES">MODIFYING AND CREATING NEW LDAP ENTRIES</a><br>
<a href="#OBJECT CLASS METHODS">OBJECT CLASS METHODS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#INSTALLATION">INSTALLATION</a><br>
<a href="#AVAILABILITY">AVAILABILITY</a><br>
<a href="#CREDITS">CREDITS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Mozilla::LDAP::Conn &minus; Object Oriented API for the LDAP SDK.</pre>


<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use Mozilla::LDAP::Conn;
  use Mozilla::LDAP::Utils;</pre>


<h2>ABSTRACT
<a name="ABSTRACT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
the main <small>API</small> for using our Perl Object
Oriented <small>LDAP</small> module. Even though it&rsquo;s
certainly possible, and sometimes even necessary, to call
the native <small>LDAP C SDK</small> functions, we strongly
recommend you use these object classes.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s not
required to use our Mozilla::LDAP::Utils.pm package, but
it&rsquo;s convenient and good for portability if you use as
much as you can from that package as well. This implies
using the LdapConf package as well, even though you usually
don&rsquo;t need to use it directly.</p>

<p style="margin-left:11%; margin-top: 1em">You should read
this document in combination with the Mozilla::LDAP::Entry
document. Both modules depend on each other heavily.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">First, this is
not ment to be a crash course in how <small>LDAP</small>
works, if you have no experience with <small>LDAP, I</small>
suggest you read some of the literature that&rsquo;s
available out there. The <small>LDAP</small> Deployment Book
from Netscape, or the <small>LDAP C SDK</small>
documentation are good starting points.</p>

<p style="margin-left:11%; margin-top: 1em">This object
class basically tracks and manages the <small>LDAP</small>
connection, it&rsquo;s current status, and the current
search operation (if any). Every time you call the
<b>search</b> method of an object instance, you&rsquo;ll
reset it&rsquo;s internal state. It depends heavily on the
::Entry class, which are used to retrieve, modify and update
a single entry.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>search</b> and <b>nextEntry</b> methods returns
Mozilla::LDAP::Entry objects, or an appropriately subclass
of it. You also have to instantiate (and modify) a new
::Entry object when you want to add new entries to an
<small>LDAP</small> server. Alternatively, the <i>add()</i>
method will also take a hash array as argument, to make it
easy to create new <small>LDAP</small> entries.</p>

<p style="margin-left:11%; margin-top: 1em">To assure that
changes to an entry are updated properly, we strongly
recommend you use the native methods of the ::Entry object
class. Even though you can modify certain elements directly,
it could cause changes not to be committed to the
<small>LDAP</small> server. If there&rsquo;s something
missing from the <small>API,</small> please let us know, or
even fix it yourself.</p>

<h2>SOME PERLDAP/OO BASICS
<a name="SOME PERLDAP/OO BASICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An entry
consist of a <small>DN,</small> and a hash array of pointers
to attribute values. Each attribute value (except the
<small>DN</small> ) is an array, but you have to remember
the hash array in the entry stores pointers to the array,
not the array. So, to access the first <small>CN</small>
value of an entry, you&rsquo;d do</p>

<pre style="margin-left:11%; margin-top: 1em">    $cn = $entry&minus;&gt;{cn}[0];</pre>


<p style="margin-left:11%; margin-top: 1em">To set the
<small>CN</small> attribute to a completely new array of
values, you&rsquo;d do</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry&minus;&gt;{cn} = [ &quot;Leif Hedstrom&quot;, &quot;The Swede&quot; ];</pre>


<p style="margin-left:11%; margin-top: 1em">As long as you
remember this, and try to use native Mozilla::LDAP::Entry
methods, this package will take care of most the work. Once
you master this, working with <small>LDAP</small> in Perl is
surprisingly easy.</p>

<p style="margin-left:11%; margin-top: 1em">We already
mentioned <small>DN,</small> which stands for Distinguished
Name. Every entry on an <small>LDAP</small> server must have
a <small>DN,</small> and it&rsquo;s always guaranteed to be
unique within your database. Some typical DNs are</p>

<pre style="margin-left:11%; margin-top: 1em">    uid=leif,ou=people,o=netscape.com
    cn=gene&minus;staff,ou=mailGroup,o=netscape.com
    dc=data,dc=netscape,dc=com</pre>


<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
also a term called <small>RDN,</small> which stands for
Relative Distinguished Name. In the above examples,
<tt>&quot;uid=leif&quot;</tt>,
<tt>&quot;cn=gene&minus;staff&quot;</tt> and
<tt>&quot;dc=data&quot;</tt> are all RDNs. One particular
property for a <small>RDN</small> is that they must be
unique within it&rsquo;s sub-tree. Hence, there can only be
one user with <tt>&quot;uid=leif&quot;</tt> within the
<tt>&quot;ou=people&quot;</tt> tree, there can never be a
name conflict.</p>

<h2>CREATING A NEW OBJECT INSTANCE
<a name="CREATING A NEW OBJECT INSTANCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Before you can
do anything with PerLDAP, you&rsquo;ll need to instantiate
at least one Mozilla::LDAP::Conn object, and connect it to
an <small>LDAP</small> server. As you probably guessed
already, this is done with the <b>new</b> method:</p>

<pre style="margin-left:11%; margin-top: 1em">    $conn = Mozilla::LDAP::Conn&minus;&gt;new(&quot;ldap&quot;, &quot;389&quot;, $bind, $pswd, $cert, $ver);
    die &quot;Couldn't connect to LDAP server ldap&quot; unless  $conn;</pre>


<p style="margin-left:11%; margin-top: 1em">The arguments
are: Host name, port number, and optionally a bind-DN,
it&rsquo;s password, and a certificate. A recent addition is
the <small>LDAP</small> protocol version, which is by
default <small>LDAP</small> v3. If there is no bind-DN, the
connection will be bound as the anonymous user. If the
certificate file is specified, the connection will be over
<small>SSL,</small> and you should then probably connect to
port 636. You have to check that the object was created
properly, and take proper actions if you couldn&rsquo;t get
a connection.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
one convenient alternative call method to this function.
Instead of providing each individual argument, you can
provide one hash array (actually, a pointer to a hash). For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    %ld = Mozilla::LDAP::Utils::ldapArgs();
    $conn = Mozilla::LDAP::Conn&minus;&gt;new(\%ld);</pre>


<p style="margin-left:11%; margin-top: 1em">The components
of the hash are:</p>

<pre style="margin-left:11%; margin-top: 1em">    $ld&minus;&gt;{&quot;host&quot;}
    $ld&minus;&gt;{&quot;port&quot;}
    $ld&minus;&gt;{&quot;base&quot;}
    $ld&minus;&gt;{&quot;bind&quot;}
    $ld&minus;&gt;{&quot;pswd&quot;}
    $ld&minus;&gt;{&quot;cert&quot;}
    $ld&minus;&gt;{&quot;vers&quot;}</pre>


<p style="margin-left:11%; margin-top: 1em">and (not used
in the <b>new</b> method)</p>

<pre style="margin-left:11%; margin-top: 1em">    $ld&minus;&gt;{&quot;scope&quot;}</pre>


<p style="margin-left:11%; margin-top: 1em">New for PerLDAP
v1.5 and later are the following:</p>

<pre style="margin-left:11%; margin-top: 1em">    $ld&minus;&gt;{&quot;nspr&quot;}
    $ld&minus;&gt;{&quot;timeout&quot;}
    $ld&minus;&gt;{&quot;callback&quot;}
    $ld&minus;&gt;{&quot;entryclass&quot;}</pre>


<p style="margin-left:11%; margin-top: 1em">The <b>nspr</b>
flag (1/0) indicates that we wish to use the
<small>NSPR</small> layer for the <small>LDAP</small>
connection. This obviously only works if PerLDAP has been
compiled with <small>NSPR</small> support and libraries. The
default is for <small>NSPR</small> to be disabled.</p>

<p style="margin-left:11%; margin-top: 1em">For an
<small>NSPR</small> enabled connection, you can also provide
an optional timeout parameter, which will be used during the
lifetime of the connection. This includes the initial setup
and connection to the <small>LDAP</small> server. You can
change this parameter later using the
<b><i>setNSPRTimeout()</i></b> method.</p>

<p style="margin-left:11%; margin-top: 1em">During the bind
process, you can provide a callback function to be called
when the asynchronus bind has completed. The callback should
take two arguments, a reference to the ::Conn object
(&quot;self&quot;) and a result structure as returned by the
call to <b><i>ldap_result()</i></b>.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, you
can optionally specify what class the different methods
should use when instantiating <b>Entry</b> result objects.
The default is Mozilla::LDAP::Entry.</p>

<p style="margin-left:11%; margin-top: 1em">Once a
connection is established, the package will take care of the
rest. If for some reason the connection is lost, the object
should reconnect on it&rsquo;s own, automatically. [Note:
This doesn&rsquo;t work now... ]. You can use the
Mozilla::LDAP:Conn object for any number of operations, but
since everything is currently done synchronously, you can
only have one operation active at any single time. You can
of course have multiple Mozilla::LDAP::Conn instanced active
at the same time.</p>

<h2>PERFORMING LDAP SEARCHES
<a name="PERFORMING LDAP SEARCHES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">We assume that
you are familiar with the <small>LDAP</small> filter syntax
already, all searches performed by this object class uses
these filters. You should also be familiar with
<small>LDAP</small> URLs, and <small>LDAP</small> object
classes. There are some of the few things you actually must
know about <small>LDAP.</small> Perhaps the simples filter
is</p>

<pre style="margin-left:11%; margin-top: 1em">    (uid=leif)</pre>


<p style="margin-left:11%; margin-top: 1em">This matches
all entries with the <small>UID</small> set to
&quot;leif&quot;. Normally that would only match one entry,
but there is no guarantee for that. To find everyone with
the name &quot;leif&quot;, you&rsquo;d instead do</p>

<pre style="margin-left:11%; margin-top: 1em">    (cn=*leif*)</pre>


<p style="margin-left:11%; margin-top: 1em">A more
complicated search involves logic operators. To find all
mail groups owned by &quot;leif&quot; (or actually his
<small>DN</small> ), you could do</p>

<pre style="margin-left:11%; margin-top: 1em">    (&amp;(objectclass=mailGroup)(owner=uid=leif,ou=people,o=netscape))</pre>


<p style="margin-left:11%; margin-top: 1em">The
<i>owner</i> attribute is what&rsquo;s called a
<small>DN</small> attribute, so to match on it we have to
specify the entire <small>DN</small> in the filter above. We
could of course also do a sub string &quot;wild card&quot;
match, but it&rsquo;s less efficient, and requires indexes
to perform reasonably well.</p>

<p style="margin-left:11%; margin-top: 1em">Ok, now we are
prepared to actually do a real search on the
<small>LDAP</small> server:</p>

<pre style="margin-left:11%; margin-top: 1em">    $base = &quot;o=netscape.com&quot;;
    $conn = Mozilla::LDAP::Conn&minus;&gt;new(&quot;ldap&quot;, &quot;389&quot;, &quot;&quot;, &quot;&quot;); die &quot;No LDAP
    connection&quot; unless $conn;
    $entry = $conn&minus;&gt;search($base, &quot;subtree&quot;, &quot;(uid=leif)&quot;);
    if (! $entry)
      { # handle this event, no entries found, dude!
      }
    else
      {
        while ($entry)
          {
            $entry&minus;&gt;printLDIF();
            $entry = $conn&minus;&gt;nextEntry();
          }
      }</pre>


<p style="margin-left:11%; margin-top: 1em">This is in fact
a poor mans implementation of the <i>ldapsearch</i> command
line utility. The <b>search</b> method returns an
Mozilla::LDAP::Entry object (or derived subclass), which
holds the first entry from the search, if any. To get the
second and subsequent entries you call the <b>entry</b>
method, until there are no more entries. The
<b>printLDIF</b> method is a convenient function, requesting
the entry to print itself on <small>STDOUT,</small> in
<small>LDIF</small> format.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
to the <b>search</b> methods are the <i><small>LDAP</small>
Base-DN</i>, the <i>scope</i> of the search
(&quot;base&quot;, &quot;one&quot; or &quot;sub&quot;), and
the actual <small>LDAP</small> <i>filter</i>. The entry
return contains the <small>DN,</small> and all attribute
values. To access a specific attribute value, you just have
to use the hash array:</p>

<pre style="margin-left:11%; margin-top: 1em">    $cn = $entry&minus;&gt;{cn}[0];</pre>


<p style="margin-left:11%; margin-top: 1em">Since many
<small>LDAP</small> attributes can have more than one value,
value of the hash array is another array (or actually a
pointer to an array). In many cases you can just assume the
value is in the first slot (indexed by [0]), but for some
attributes you have to support multiple values. To find out
how many values a specific attribute has, you&rsquo;d call
the <b>size</b> method:</p>

<pre style="margin-left:11%; margin-top: 1em">    $numVals = $entry&minus;&gt;size(&quot;objectclass&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">One caveat:
Many <small>LDAP</small> attributes are case insensitive,
but the methods in the Mozilla::LDAP::Entry package are not
aware of this. Hence, if you compare values with case
sensitivity, you can experience weird behavior. If you know
an attribute is <small>CIS</small> (Case Insensitive), make
sure you do case insensitive string comparisons.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately
some methods in this package can&rsquo;t do this, and by
default will do case sensitive comparisons. We are working
on this, and in a future release some of the methods will
handle this more gracefully. As an extension (for
<small>LDAP</small> v3.0) we could also use schema discovery
for handling this even better.</p>

<p style="margin-left:11%; margin-top: 1em">There is an
alternative search method, to use <small>LDAP</small> URLs
instead of a filter string. This can be used to easily parse
and process URLs, which is a compact way of storing a
&quot;link&quot; to some specific <small>LDAP</small>
information. To process such a search, you use the
<b>searchURL</b> method:</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry&minus;&gt;searchURL(&quot;ldap:///o=netscape.com??sub?(uid=leif)&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">As it turns
out, the <b>search</b> method also supports <small>LDAP
URL</small> searches. If the search filter looks like a
proper <small>URL,</small> we will actually do an
<small>URL</small> search instead. This is for backward
compatibility, and for ease of use.</p>

<p style="margin-left:11%; margin-top: 1em">To achieve
better performance and use less memory, you can limit your
search to only retrieve certain attributes. With the
<small>LDAP</small> URLs you specify this as an optional
parameter, and with the <b>search</b> method you add two
more options, like</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry = $conn&minus;&gt;search($base, &quot;sub&quot;, $filter, 0, (&quot;mail&quot;, &quot;cn&quot;));</pre>


<p style="margin-left:11%; margin-top: 1em">The last
argument specifies an array of attributes to retrieve, the
fewer the attributes, the faster the search will be. The
second to last argument is a boolean value indicating if we
should retrieve only the attribute names (and no values). In
most cases you want this to be <small>FALSE,</small> to
retrieve both the attribute names, and all their values. To
do this with the <b>searchURL</b> method, add a second
argument, which should be 0 or 1.</p>

<h2>PERFORMING ASYNCHRONOUS SEARCHES
<a name="PERFORMING ASYNCHRONOUS SEARCHES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Conn also
supports an async_search method that takes the same
arguments as the search method but returns an instance of
SearchIter instead of Entry. As its name implies, the
SearchIter is used to iterate through the search results.
The nextEntry method works just like the nextEntry method of
Conn. The abandon method should be called if search result
processing is aborted before the last result is received, to
allow the client and server to release resources.
Example:</p>

<pre style="margin-left:11%; margin-top: 1em">        $iter = $conn&minus;&gt;async_search($base, $scope, $filter, ...);
    if ($rc = $iter&minus;&gt;getResultCode()) {
            # process error condition
        } else {
            while (my $entry = $iter&minus;&gt;nextEntry) {
                        # process entry
            if (some abort condition) {
                $iter&minus;&gt;abandon;
                last;
            }
        }
    }</pre>


<h2>MODIFYING AND CREATING NEW LDAP ENTRIES
<a name="MODIFYING AND CREATING NEW LDAP ENTRIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Once you have
an <small>LDAP</small> entry, either from a search, or
created directly to get a new empty object, you are ready to
modify it. If you are creating a new entry, the first thing
to set it it&rsquo;s <small>DN,</small> like</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry = $conn&minus;&gt;newEntry();
    $entry&minus;&gt;setDN(&quot;uid=leif,ou=people,o=netscape.com&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">alternatively
you can still use the <b>new</b> method on the Entry class,
like</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry = Mozilla::LDAP::Entry&minus;&gt;new();</pre>


<p style="margin-left:11%; margin-top: 1em">You should not
do this for an existing <small>LDAP</small> entry, changing
the <small>RDN</small> (or <small>DN</small> ) for such an
entry must be done with <b>modifyRDN</b>. To populate (or
modify) some other attributes, we can do</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry&minus;&gt;{objectclass} = [ &quot;top&quot;, &quot;person&quot;, &quot;inetOrgPerson&quot; ];
    $entry&minus;&gt;{cn} = [ &quot;Leif Hedstrom&quot; ];
    $entry&minus;&gt;{mail} = [ &quot;leif@netscape.com&quot; ];</pre>


<p style="margin-left:11%; margin-top: 1em">Once you are
done modifying your <small>LDAP</small> entry, call the
<b>update</b> method from the Mozilla::LDAP::Conn object
instance:</p>

<pre style="margin-left:11%; margin-top: 1em">    $conn&minus;&gt;update($entry);</pre>


<p style="margin-left:11%; margin-top: 1em">Or, if you are
creating an entirely new <small>LDAP</small> entry, you must
call the <b>add</b> method:</p>

<pre style="margin-left:11%; margin-top: 1em">    $conn&minus;&gt;add($entry);</pre>


<p style="margin-left:11%; margin-top: 1em">If all comes to
worse, and you have to remove an entry again from the
<small>LDAP</small> server, just call the <b>delete</b>
method, like</p>

<pre style="margin-left:11%; margin-top: 1em">    $conn&minus;&gt;delete($entry&minus;&gt;getDN());</pre>


<p style="margin-left:11%; margin-top: 1em">You can&rsquo;t
use native Perl functions like <i>push()</i> and
<i>splice()</i> on attribute values, since they won&rsquo;t
update the ::Entry instance state properly. Instead use one
of the methods provided by the Mozilla::LDAP::Entry object
class, for instance</p>

<pre style="margin-left:11%; margin-top: 1em">    $entry&minus;&gt;addValue(&quot;cn&quot;, &quot;The Swede&quot;);
    $entry&minus;&gt;removeValue(&quot;mailAlternateAddress&quot;, &quot;leif@mcom.com&quot;);
    $entry&minus;&gt;remove(&quot;seeAlso&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">These methods
return a <small>TRUE</small> or <small>FALSE</small> value,
depending on the outcome of the operation. If there was no
value to remove, or a value already exists, we return
<small>FALSE,</small> otherwise <small>TRUE.</small> To
check if an attribute has a certain value, use the
<b>hasValue</b> method, like</p>

<pre style="margin-left:11%; margin-top: 1em">    if ($entry&minus;&gt;hasValue(&quot;mail&quot;, &quot;leif@netscape.com&quot;)) {
        # Do something
    }</pre>


<p style="margin-left:11%; margin-top: 1em">There is a
similar method, <b>matchValue</b>, which takes a regular
expression to match against, instead of the entire string.
For more information this and other methods in the Entry
class, see below.</p>

<h2>OBJECT CLASS METHODS
<a name="OBJECT CLASS METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">We have already
described the fundamentals of this class earlier. This is a
summary of all available methods which you can use. Be
careful not to use any undocumented features or heaviour,
since the internals in this module is likely to change.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Searching
and updating entries</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>add</b></p></td>
<td width="11%"></td>
<td width="69%">


<p>Add a new entry to the <small>LDAP</small> server. Make
sure you use the <b>new</b> method for the
Mozilla::LDAP::Entry object, to create a proper entry.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>browse</b></p></td>
<td width="11%"></td>
<td width="69%">


<p>Searches for an <small>LDAP</small> entry, but sets some
default values to begin with, such as scope=BASE,
filter=(objectclass=*) and so on. Much like <b>search</b>
except for these defaults. Requires a <small>DN</small>
value as an argument. An optional second argument is an
array of which attributes to return from the entry. Note
that this does not support the &quot;attributesOnly&quot;
flag.</p> </td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $secondEntry = $conn&minus;&gt;browse($entry&minus;&gt;getDN());</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>close</b></p></td>
<td width="9%"></td>
<td width="69%">


<p style="margin-top: 1em">Close the <small>LDAP</small>
connection, and clean up the object. If you don&rsquo;t call
this directly, the destructor for the object instance will
do the job for you.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>compare</b></p></td>
<td width="9%"></td>
<td width="69%">


<p>Compares an attribute and value to a given
<small>DN</small> without first doing a search. Requires
three arguments: a <small>DN,</small> the attribute name,
and the value of the attribute. Returns <small>TRUE</small>
if the attribute/value compared ok.</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    print &quot;not&quot; unless $conn&minus;&gt;compare($entry&minus;&gt;getDN(), &quot;cn&quot;, &quot;Big Swede&quot;);
    print &quot;ok&quot;;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>delete</b></p></td>
<td width="11%"></td>
<td width="69%">


<p style="margin-top: 1em">This will delete the current
entry, or possibly an entry as specified with the optional
argument. You can use this function to delete any entry you
like, by passing it an explicit <small>DN.</small> If you
don&rsquo;t pass it this argument, <b>delete</b> defaults to
delete the current entry, from the last call to
<b>search</b> or <b>entry</b>. I&rsquo;d recommend doing a
delete with the explicit <small>DN,</small> like</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $conn&minus;&gt;delete($entry&minus;&gt;getDN());</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>modifyRDN</b></p></td>
<td width="6%"></td>
<td width="69%">


<p style="margin-top: 1em">This will rename the specified
<small>LDAP</small> entry, by modifying it&rsquo;s
<small>RDN.</small> For example, assuming you have a
<small>DN</small> of</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    uid=leif, ou=people, dc=netscape, dc=com</pre>


<p style="margin-left:31%; margin-top: 1em">and you wish to
rename to</p>

<pre style="margin-left:31%; margin-top: 1em">    uid=fiel, ou=people, dc=netscape, dc=com</pre>


<p style="margin-left:31%; margin-top: 1em">you&rsquo;d do
something like</p>

<pre style="margin-left:31%; margin-top: 1em">    $rdn = &quot;uid=fiel&quot;;
    $conn&minus;&gt;modifyRDN($rdn, $entry&minus;&gt;getDN());</pre>


<p style="margin-left:31%; margin-top: 1em">Note that this
can only be done on the <small>RDN,</small> you could not
change say <tt>&quot;ou=people&quot;</tt> to be
<tt>&quot;ou=hackers&quot;</tt> in the example above. To do
that, you have to add a new entry (a copy of the old one),
and then remove the old entry.</p>

<p style="margin-left:31%; margin-top: 1em">The last
argument is a boolean (0 or 1), which indicates if the old
<small>RDN</small> value should be removed from the entry.
The default is <small>TRUE</small> (&quot;1&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>new</b></p></td>
<td width="16%"></td>
<td width="69%">


<p style="margin-top: 1em">This creates and initialized a
new <small>LDAP</small> connection and object. The required
arguments are host name, port number, bind <small>DN</small>
and the bind password. An optional argument is a certificate
(public key), which causes the <small>LDAP</small>
connection to be established over an <small>SSL</small>
channel. Currently we do not support Client Authentication,
so you still have to use the simple authentication method
(i.e. with a password).</p></td></tr>
</table>

<p style="margin-left:31%; margin-top: 1em">A typical usage
could be something like</p>

<pre style="margin-left:31%; margin-top: 1em">    %ld = Mozilla::LDAP::Utils::ldapArgs();
    $conn = Mozilla::LDAP::Conn&minus;&gt;new(\%ld);</pre>


<p style="margin-left:31%; margin-top: 1em">Also, remember
that if you use <small>SSL,</small> the port is (usually)
636.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>newEntry</b></p></td>
<td width="8%"></td>
<td width="69%">


<p style="margin-top: 1em">This will create an empty
Mozilla::LDAP::Entry object, which is properly tied into the
appropriate objectclass. Use this method instead of manually
creating new Entry objects, or at least make sure that you
use the &quot;tie&quot; function when creating the entry.
This function takes no arguments, and returns a pointer to
an ::Entry object. For instance</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $entry = $conn&minus;&gt;newEntry();</pre>


<p style="margin-left:31%; margin-top: 1em">or</p>

<pre style="margin-left:31%; margin-top: 1em">    $entry = Mozilla::LDAP::Conn&minus;&gt;newEntry();</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em"><b>nextEntry</b></p></td>
<td width="6%"></td>
<td width="69%">


<p style="margin-top: 1em">This method will return the next
entry from the search result, and can therefore only be
called after a succesful search has been initiated. If there
are no more entries to retrieve, it returns nothing (empty
string).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>search</b></p></td>
<td width="6%"></td>
<td width="69%">


<p>The <b>search</b> method is the main entry point into
this module. It requires at least three arguments: The Base
<small>DN,</small> the scope, and the search strings. Two
more optional arguments can be given, the first specifies if
only attribute names should be returned (
<small>TRUE</small> or <small>FALSE</small> ). The second
argument is a list (array) of attributes to return.</p></td></tr>
</table>

<p style="margin-left:31%; margin-top: 1em">The last option
is very important for performance. If you are only
interested in say the &quot;mail&quot; and
&quot;mailHost&quot; attributes, specifying this in the
search will signficantly reduce the search time. An example
of an efficient search is</p>

<pre style="margin-left:31%; margin-top: 1em">    @attr = (&quot;cn&quot;, &quot;uid&quot;, &quot;mail&quot;);
    $filter = &quot;(uid=*)&quot;;
    $entry = $conn&minus;&gt;search($base, $scope, $filter, 0, @attr);
    while ($entry) {
        # do something
        $entry = $conn&minus;&gt;nextEntry();
    }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>searchURL</b></p></td>
<td width="5%"></td>
<td width="69%">


<p style="margin-top: 1em">This is almost identical to
<b>search</b>, except this function takes only two
arguments, an <small>LDAP URL</small> and an optional flag
to specify if we only want the attribute names to be
returned (and no values). This function isn&rsquo;t very
useful, since the <b>search</b> method will actually honor
properly formed <small>LDAP URL</small> &rsquo;s, and use it
if appropriate.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p><b>simpleAuth</b></p></td>
<td width="5%"></td>
<td width="69%">


<p>This method will rebind the <small>LDAP</small>
connection using new credentials (i.e. a new user-DN and
password). To rebind &quot;anonymously&quot;, just
don&rsquo;t pass a <small>DN</small> and password, and it
will default to binding as the unprivleged user. For
example:</p> </td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $user = &quot;leif&quot;;
    $password = &quot;secret&quot;;
    $conn = Mozilla::LDAP::Conn&minus;&gt;new($host, $port);     # Anonymous bind
    die &quot;Could't connect to LDAP server $host&quot; unless $conn;
    $entry = $conn&minus;&gt;search($base, $scope, &quot;(uid=$user)&quot;, 0, (uid));
    exit (&minus;1) unless $entry;
    $ret = $conn&minus;&gt;simpleAuth($entry&minus;&gt;getDN(), $password);
    exit (&minus;1) unless $ret;
    $ret = $conn&minus;&gt;simpleAuth();         # Bind as anon again.</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>update</b></p></td>
<td width="11%"></td>
<td width="69%">


<p style="margin-top: 1em">After modifying an Ldap::Entry
entry (see below), use the <b>update</b> method to commit
changes to the <small>LDAP</small> server. Only attributes
that has been changed will be updated, assuming you have
used the appropriate methods in the Entry object. For
instance, do not use <b>push</b> or <b>splice</b> to modify
an entry, the <b>update</b> will not recognize such
changes.</p> </td></tr>
</table>

<p style="margin-left:31%; margin-top: 1em">To change the
<small>CN</small> value for an entry, you could do</p>

<pre style="margin-left:31%; margin-top: 1em">    $entry&minus;&gt;{cn} = [&quot;Leif Hedstrom&quot;];
    $conn&minus;&gt;update($entry);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Other
methods</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>getErrorCode</b></p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">Return the error code (numeric)
from the last <small>LDAP API</small> function call.
Remember that this can only be called <i>after</i> the
successful creation of a new :Conn object instance. A
typical usage could be</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    if (! $opt_n) {
        $conn&minus;&gt;modifyRDN($rdn, $entry&minus;&gt;getDN());
        $conn&minus;&gt;printError() if $conn&minus;&gt;getErrorCode();
    }</pre>


<p style="margin-left:31%; margin-top: 1em">Which will
report any error message as generated by the call to
<b>modifyRDN</b>. Some <small>LDAP</small> functions return
extra error information, which can be retrieved like:</p>

<pre style="margin-left:31%; margin-top: 1em">   $err = getErrorCode(\$matched, \$string);</pre>


<p style="margin-left:31%; margin-top: 1em">$matched will
then contain the portion of the matched <small>DN</small>
(if applicable to the error code), and <tt>$string</tt> will
contain any additional error string returned by the
<small>LDAP</small> server.</p>

<p style="margin-left:11%;"><b>getErrorString</b></p>

<p style="margin-left:31%;">Very much like
<b>getErrorCode</b>, but return a string with a human
readable error message. This can then be used to print a
good error message on the console.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>getLD</b></p></td>
<td width="11%"></td>
<td width="69%">


<p>Return the (internal) LDAP* connection handle, which you
can use (carefully) to call the native <small>LDAP
API</small> functions. You shouldn&rsquo;t have to use this
in most cases, unless of course our <small>OO</small> layer
is seriously flawed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>getRes</b></p></td>
<td width="11%"></td>
<td width="69%">


<p>Just like <b>getLD</b>, except it returns the internal
<small>LDAP</small> return message structure. Again, use
this very carefully, and be aware that this might break in
future releases of PerLDAP. These two methods can be used to
call some useful <small>API</small> functions, like</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $cld = $conn&minus;&gt;getLD();
    $res = $conn&minus;&gt;getRes();
    $count = Mozilla::LDAP::API::ldap_count_entries($cld, $res);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>isURL</b></p></td>
<td width="5%"></td>
<td width="69%">


<p style="margin-top: 1em">Returns <small>TRUE</small> or
<small>FALSE</small> if the given argument is a properly
formed <small>URL.</small></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p><b>printError</b></p></td>
<td width="5%"></td>
<td width="69%">


<p>Print the last error message on standard output.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>setRebindProc</b></p>

<p style="margin-left:31%;">Tell the <small>LDAP
SDK</small> to call the provided Perl function when it has
to follow referrals. The Perl function should return an
array of three elements, the new Bind <small>DN,</small>
password and authentication method. A typical usage is</p>

<pre style="margin-left:31%; margin-top: 1em">    sub rebindProc {
        return (&quot;uid=ldapadmin&quot;, &quot;secret&quot;, LDAP_AUTH_SIMPLE);
    }
    $ld&minus;&gt;setRebindProc(\&amp;rebindProc);</pre>



<p style="margin-left:11%;"><b>setDefaultRebindProc</b></p>

<p style="margin-left:31%;">This is very much like the
previous function, except instead of specifying the function
to use, you give it the <small>DN,</small> password and Auth
method. Then we&rsquo;ll use a default rebind procedure
(internal in C) to handle the rebind credentials. This was a
solution for the Windows/NT problem/bugs we have with rebind
procedures written in Perl.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p><b>setVersion</b></p></td>
<td width="5%"></td>
<td width="69%">


<p>Change the <small>LDAP</small> protocol version on the
already initialized connection. The default is
<small>LDAP</small> v3 (new for PerLDAP v1.5!), but you can
downgrade the connection to <small>LDAP</small> v2 if
necessary using this function. Example:</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">    $conn&minus;&gt;setVersion(2);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>getVersion</b></p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">Return the protocol version
currently in used by the connection.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>setSizelimit</b></p></td>
<td width="2%"></td>
<td width="69%">


<p>Set the sizelimit on a connection, to limit the maximum
number of entries that we want to retrieve. For example:</p></td></tr>
</table>

<pre style="margin-left:31%; margin-top: 1em">   $conn&minus;&gt;setSizelimit(10);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>getSizelimit</b></p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">Get the current sizelimit on a
connection (if any).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>setOption</b></p></td>
<td width="2%"></td>
<td width="69%">


<p>Set an (integer) <small>LDAP</small> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>getOption</b></p></td>
<td width="2%"></td>
<td width="69%">


<p>Get an (integer) <small>LDAP</small> option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p><b>installNSPR</b></p></td>
<td width="2%"></td>
<td width="69%">


<p>Install <small>NSPR I/O,</small> threading, and
<small>DNS</small> functions so they will be used by
&rsquo;ld&rsquo;.</p> </td></tr>
</table>

<p style="margin-left:31%; margin-top: 1em">Pass a non-zero
value for the &rsquo;shared&rsquo; parameter if you plan to
use this <small>LDAP</small> * handle from more than one
thread. This is highly unlikely since PerLDAP is
asynchronous.</p>

<p style="margin-left:11%;"><b>setNSPRTimeout</b></p>

<p style="margin-left:31%;">Set the <small>TCP</small>
timeout value, in millisecond, for the <small>NSPR</small>
enabled connection. It&rsquo;s an error to call this before
calling <i>installNSPR()</i>, unless you created the new
connection object with the <b>nspr</b> option.</p>

<p style="margin-left:31%; margin-top: 1em">This method can
also be invoked as a class method, and it will then apply to
all new connections created. Like</p>

<pre style="margin-left:31%; margin-top: 1em">    Mozilla::LDAP::Conn&minus;&gt;installNSPR(1);
    Mozilla::LDAP::Conn&minus;&gt;setNSPRTimeout(1000);</pre>


<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
plenty of examples to look at, in the examples directory. We
are adding more examples every day (almost).</p>

<h2>INSTALLATION
<a name="INSTALLATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Installing this
package is part of the Makefile supplied in the package. See
the installation procedures which are part of this
package.</p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package
can be retrieved from a number of places, including:</p>

<pre style="margin-left:11%; margin-top: 1em">    http://www.mozilla.org/directory/
    Your local CPAN server</pre>


<h2>CREDITS
<a name="CREDITS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most of this
code was developed by Leif Hedstrom, Netscape Communications
Corporation.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None. :)</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Mozilla::LDAP::Entry,
LDAP::Mozilla:Utils LDAP::Mozilla:API and of course
Perl.</p>
<hr>
</body>
</html>
