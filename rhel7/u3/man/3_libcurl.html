<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:51:22 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>libcurl</title>

</head>
<body>

<h1 align="center">libcurl</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#LINKING WITH LIBCURL">LINKING WITH LIBCURL</a><br>
<a href="#LIBCURL SYMBOL NAMES">LIBCURL SYMBOL NAMES</a><br>
<a href="#PORTABILITY">PORTABILITY</a><br>
<a href="#THREADS">THREADS</a><br>
<a href="#PERSISTENT CONNECTIONS">PERSISTENT CONNECTIONS</a><br>
<a href="#GLOBAL CONSTANTS">GLOBAL CONSTANTS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libcurl &minus;
client-side URL transfers</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is a short
overview on how to use libcurl in your C programs. There are
specific man pages for each function mentioned in here.
There are also the <i>libcurl-easy(3)</i> man page, the
<i>libcurl-multi(3)</i> man page, the
<i>libcurl-share(3)</i> man page and the
<i>libcurl-tutorial(3)</i> man page for in-depth
understanding on how to program with libcurl.</p>

<p style="margin-left:11%; margin-top: 1em">There are more
than thirty custom bindings available that bring libcurl
access to your favourite language. Look elsewhere for
documentation on those.</p>

<p style="margin-left:11%; margin-top: 1em">libcurl has a
global constant environment that you must set up and
maintain while using libcurl. This essentially means you
call <i>curl_global_init(3)</i> at the start of your program
and <i>curl_global_cleanup(3)</i> at the end. See GLOBAL
CONSTANTS below for details.</p>

<p style="margin-left:11%; margin-top: 1em">To transfer
files, you always set up an &quot;easy handle&quot; using
<i>curl_easy_init(3)</i>, but when you want the file(s)
transferred you have the option of using the
&quot;easy&quot; interface, or the &quot;multi&quot;
interface.</p>

<p style="margin-left:11%; margin-top: 1em">The easy
interface is a synchronous interface with which you call
<i>curl_easy_perform(3)</i> and let it perform the transfer.
When it is completed, the function returns and you can
continue. More details are found in the
<i>libcurl-easy(3)</i> man page.</p>

<p style="margin-left:11%; margin-top: 1em">The multi
interface on the other hand is an asynchronous interface,
that you call and that performs only a little piece of the
transfer on each invoke. It is perfect if you want to do
things while the transfer is in progress, or similar. The
multi interface allows you to select() on libcurl action,
and even to easily download multiple files simultaneously
using a single thread. See further details in the
<i>libcurl-multi(3)</i> man page.</p>

<p style="margin-left:11%; margin-top: 1em">You can have
multiple easy handles share certain data, even if they are
used in different threads. This magic is setup using the
share interface, as described in the <i>libcurl-share(3)</i>
man page.</p>

<p style="margin-left:11%; margin-top: 1em">There is also a
series of other helpful functions to use, including
these:</p>

<p style="margin-left:22%;">curl_version_info()</p>

<p style="margin-left:32%;">gets detailed libcurl (and
other used libraries) version info</p>

<p style="margin-left:22%;">curl_getdate()</p>

<p style="margin-left:32%;">converts a date string to
time_t</p>

<p style="margin-left:22%;">curl_easy_getinfo()</p>

<p style="margin-left:32%;">get information about a
performed transfer</p>

<p style="margin-left:22%;">curl_formadd()</p>

<p style="margin-left:32%;">helps building an HTTP form
POST</p>

<p style="margin-left:22%;">curl_formfree()</p>

<p style="margin-left:32%;">free a list built with
<i>curl_formadd(3)</i></p>

<p style="margin-left:22%;">curl_slist_append()</p>

<p style="margin-left:32%;">builds a linked list</p>

<p style="margin-left:22%;">curl_slist_free_all()</p>

<p style="margin-left:32%;">frees a whole curl_slist</p>

<h2>LINKING WITH LIBCURL
<a name="LINKING WITH LIBCURL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On unix-like
machines, there&rsquo;s a tool named curl-config that gets
installed with the rest of the curl stuff when &rsquo;make
install&rsquo; is performed.</p>

<p style="margin-left:11%; margin-top: 1em">curl-config is
added to make it easier for applications to link with
libcurl and developers to learn about libcurl and how to use
it.</p>

<p style="margin-left:11%; margin-top: 1em">Run
&rsquo;curl-config --libs&rsquo; to get the (additional)
linker options you need to link with the particular version
of libcurl you&rsquo;ve installed. See the
<i>curl-config(1)</i> man page for further details.</p>

<p style="margin-left:11%; margin-top: 1em">Unix-like
operating system that ship libcurl as part of their
distributions often don&rsquo;t provide the curl-config
tool, but simply install the library and headers in the
common path for this purpose.</p>

<h2>LIBCURL SYMBOL NAMES
<a name="LIBCURL SYMBOL NAMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All public
functions in the libcurl interface are prefixed with
&rsquo;curl_&rsquo; (with a lowercase c). You can find other
functions in the library source code, but other prefixes
indicate that the functions are private and may change
without further notice in the next release.</p>

<p style="margin-left:11%; margin-top: 1em">Only use
documented functions and functionality!</p>

<h2>PORTABILITY
<a name="PORTABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libcurl works
<b>exactly</b> the same, on any of the platforms it compiles
and builds on.</p>

<h2>THREADS
<a name="THREADS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Never ever call
curl-functions simultaneously using the same handle from
several threads. libcurl is thread-safe and can be used in
any number of threads, but you must use separate curl
handles if you want to use libcurl in more than one thread
simultaneously.</p>

<p style="margin-left:11%; margin-top: 1em">The global
environment functions are not thread-safe. See GLOBAL
CONSTANTS below for details.</p>

<h2>PERSISTENT CONNECTIONS
<a name="PERSISTENT CONNECTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Persistent
connections means that libcurl can re-use the same
connection for several transfers, if the conditions are
right.</p>

<p style="margin-left:11%; margin-top: 1em">libcurl will
<b>always</b> attempt to use persistent connections.
Whenever you use <i>curl_easy_perform(3)</i> or
<i>curl_multi_perform(3)</i>, libcurl will attempt to use an
existing connection to do the transfer, and if none exists
it&rsquo;ll open a new one that will be subject for re-use
on a possible following call to <i>curl_easy_perform(3)</i>
or <i>curl_multi_perform(3)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To allow
libcurl to take full advantage of persistent connections,
you should do as many of your file transfers as possible
using the same curl handle. When you call
<i>curl_easy_cleanup(3)</i>, all the possibly open
connections held by libcurl will be closed and
forgotten.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
options set with <i>curl_easy_setopt(3)</i> will be used on
every repeated <i>curl_easy_perform(3)</i> call.</p>

<h2>GLOBAL CONSTANTS
<a name="GLOBAL CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a
variety of constants that libcurl uses, mainly through its
internal use of other libraries, which are too complicated
for the library loader to set up. Therefore, a program must
call a library function after the program is loaded and
running to finish setting up the library code. For example,
when libcurl is built for SSL capability via the GNU TLS
library, there is an elaborate tree inside that library that
describes the SSL protocol.</p>


<p style="margin-left:11%; margin-top: 1em"><i>curl_global_init()</i>
is the function that you must call. This may allocate
resources (e.g. the memory for the GNU TLS tree mentioned
above), so the companion function
<i>curl_global_cleanup()</i> releases them.</p>

<p style="margin-left:11%; margin-top: 1em">The basic rule
for constructing a program that uses libcurl is this: Call
<i>curl_global_init()</i>, with a <i>CURL_GLOBAL_ALL</i>
argument, immediately after the program starts, while it is
still only one thread and before it uses libcurl at all.
Call <i>curl_global_cleanup()</i> immediately before the
program exits, when the program is again only one thread and
after its last use of libcurl.</p>

<p style="margin-left:11%; margin-top: 1em">You can call
both of these multiple times, as long as all calls meet
these requirements and the number of calls to each is the
same.</p>

<p style="margin-left:11%; margin-top: 1em">It isn&rsquo;t
actually required that the functions be called at the
beginning and end of the program -- that&rsquo;s just
usually the easiest way to do it. It <i>is</i> required that
the functions be called when no other thread in the program
is running.</p>

<p style="margin-left:11%; margin-top: 1em">These global
constant functions are <i>not thread safe</i>, so you must
not call them when any other thread in the program is
running. It isn&rsquo;t good enough that no other thread is
using libcurl at the time, because these functions
internally call similar functions of other libraries, and
those functions are similarly thread-unsafe. You can&rsquo;t
generally know what these libraries are, or whether other
threads are using them.</p>

<p style="margin-left:11%; margin-top: 1em">The global
constant situation merits special consideration when the
code you are writing to use libcurl is not the main program,
but rather a modular piece of a program, e.g. another
library. As a module, your code doesn&rsquo;t know about
other parts of the program -- it doesn&rsquo;t know whether
they use libcurl or not. And its code doesn&rsquo;t
necessarily run at the start and end of the whole
program.</p>

<p style="margin-left:11%; margin-top: 1em">A module like
this must have global constant functions of its own, just
like <i>curl_global_init()</i> and
<i>curl_global_cleanup()</i>. The module thus has control at
the beginning and end of the program and has a place to call
the libcurl functions. Note that if multiple modules in the
program use libcurl, they all will separately call the
libcurl functions, and that&rsquo;s OK because only the
first <i>curl_global_init()</i> and the last
<i>curl_global_cleanup()</i> in a program change anything.
(libcurl uses a reference count in static memory).</p>

<p style="margin-left:11%; margin-top: 1em">In a C++
module, it is common to deal with the global constant
situation by defining a special class that represents the
global constant environment of the module. A program always
has exactly one object of the class, in static storage. That
way, the program automatically calls the constructor of the
object as the program starts up and the destructor as it
terminates. As the author of this libcurl-using module, you
can make the constructor call <i>curl_global_init()</i> and
the destructor call <i>curl_global_cleanup()</i> and satisfy
libcurl&rsquo;s requirements without your user having to
think about it.</p>


<p style="margin-left:11%; margin-top: 1em"><i>curl_global_init()</i>
has an argument that tells what particular parts of the
global constant environment to set up. In order to
successfully use any value except <i>CURL_GLOBAL_ALL</i>
(which says to set up the whole thing), you must have
specific knowledge of internal workings of libcurl and all
other parts of the program of which it is part.</p>

<p style="margin-left:11%; margin-top: 1em">A special part
of the global constant environment is the identity of the
memory allocator. <i>curl_global_init()</i> selects the
system default memory allocator, but you can use
<i>curl_global_init_mem()</i> to supply one of your own.
However, there is no way to use
<i>curl_global_init_mem()</i> in a modular program -- all
modules in the program that might use libcurl would have to
agree on one allocator.</p>

<p style="margin-left:11%; margin-top: 1em">There is a
failsafe in libcurl that makes it usable in simple
situations without you having to worry about the global
constant environment at all: <i>curl_easy_init()</i> sets up
the environment itself if it hasn&rsquo;t been done yet. The
resources it acquires to do so get released by the operating
system automatically when the program exits.</p>

<p style="margin-left:11%; margin-top: 1em">This failsafe
feature exists mainly for backward compatibility because
there was a time when the global functions didn&rsquo;t
exist. Because it is sufficient only in the simplest of
programs, it is not recommended for any program to rely on
it.</p>
<hr>
</body>
</html>
