<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 20:47:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_cxx::__rc_string_base&lt; _CharT, _Traits, _Alloc &gt;</title>

</head>
<body>

<h1 align="center">__gnu_cxx::__rc_string_base&lt; _CharT, _Traits, _Alloc &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_cxx::__rc_string_base&lt;
_CharT, _Traits, _Alloc &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
__gnu_cxx::__vstring_utility&lt; _CharT, _Traits, _Alloc
&gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef <br>
_Util_Base::_CharT_alloc_type <b>_CharT_alloc_type</b>&quot;
<br>
typedef __vstring_utility <br>
&lt; _CharT, _Traits, _Alloc &gt; <b>_Util_Base</b>&quot;
<br>
typedef _Alloc <b>allocator_type</b> <br>
typedef <br>
_CharT_alloc_type::size_type <b>size_type</b>&quot; <br>
typedef _Traits <b>traits_type</b> <br>
typedef _Traits::char_type <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>__rc_string_base</b> (const
_Alloc &amp;__a) <b><br>
__rc_string_base</b> (const <b>__rc_string_base</b>
&amp;__rcs) <b><br>
__rc_string_base</b> (<b>__rc_string_base</b>
&amp;&amp;__rcs) <b><br>
__rc_string_base</b> (size_type __n, _CharT __c, const
_Alloc &amp;__a) <br>
template&lt;typename _InputIterator &gt;
<b>__rc_string_base</b> (_InputIterator __beg,
_InputIterator __end, const _Alloc &amp;__a) <br>
void <b>_M_assign</b> (const <b>__rc_string_base</b>
&amp;__rcs) <br>
size_type <b>_M_capacity</b> () const <br>
void <b>_M_clear</b> () <br>
bool <b>_M_compare</b> (const <b>__rc_string_base</b> &amp;)
const <br>
template&lt;&gt; bool <b>_M_compare</b> (const
<b>__rc_string_base</b> &amp;__rcs) const <br>
template&lt;&gt; bool <b>_M_compare</b> (const
<b>__rc_string_base</b> &amp;__rcs) const <br>
_CharT * <b>_M_data</b> () const <br>
void <b>_M_erase</b> (size_type __pos, size_type __n) <br>
allocator_type &amp; <b>_M_get_allocator</b> () <br>
const allocator_type &amp; <b>_M_get_allocator</b> () const
<br>
bool <b>_M_is_shared</b> () const <br>
void <b>_M_leak</b> () <br>
size_type <b>_M_length</b> () const <br>
size_type <b>_M_max_size</b> () const <br>
void <b>_M_mutate</b> (size_type __pos, size_type __len1,
const _CharT *__s, size_type __len2) <br>
void <b>_M_reserve</b> (size_type __res) <br>
void <b>_M_set_leaked</b> () <br>
void <b>_M_set_length</b> (size_type __n) <br>
void <b>_M_swap</b> (<b>__rc_string_base</b> &amp;__rcs)
<br>
template&lt;typename _InIterator &gt; _CharT *
<b>_S_construct</b> (_InIterator __beg, _InIterator __end,
const _Alloc &amp;__a, <b>std::forward_iterator_tag</b>)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">typedef <br>
__gnu_cxx::__normal_iterator <br>
&lt; const_pointer, <b><br>
__gnu_cxx::__versa_string</b> <br>
&lt; _CharT, _Traits, _Alloc, <b><br>
__rc_string_base</b> &gt; &gt;
<b>__const_rc_iterator</b>&quot; <br>
typedef <br>
__gnu_cxx::__normal_iterator <br>
&lt; const_pointer, <b><br>
__gnu_cxx::__versa_string</b> <br>
&lt; _CharT, _Traits, _Alloc, <br>
__sso_string_base &gt; &gt;
<b>__const_sso_iterator</b>&quot; <br>
typedef <br>
__gnu_cxx::__normal_iterator <br>
&lt; pointer, <b><br>
__gnu_cxx::__versa_string</b> <br>
&lt; _CharT, _Traits, _Alloc, <b><br>
__rc_string_base</b> &gt; &gt; <b>__rc_iterator</b>&quot;
<br>
typedef <br>
__gnu_cxx::__normal_iterator <br>
&lt; pointer, <b><br>
__gnu_cxx::__versa_string</b> <br>
&lt; _CharT, _Traits, _Alloc, <br>
__sso_string_base &gt; &gt; <b>__sso_iterator</b>&quot; <br>
typedef <br>
_CharT_alloc_type::const_pointer <b>const_pointer</b>&quot;
<br>
typedef <br>
_CharT_alloc_type::difference_type
<b>difference_type</b>&quot; <br>
typedef _CharT_alloc_type::pointer <b>pointer</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static void <b>_S_assign</b>
(_CharT *__d, size_type __n, _CharT __c) <br>
static int <b>_S_compare</b> (size_type __n1, size_type
__n2) <br>
static void <b>_S_copy</b> (_CharT *__d, const _CharT *__s,
size_type __n) <br>
template&lt;typename _Iterator &gt; static void
<b>_S_copy_chars</b> (_CharT *__p, _Iterator __k1, _Iterator
__k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p,
__sso_iterator __k1, __sso_iterator __k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p,
__const_sso_iterator __k1, __const_sso_iterator __k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p, __rc_iterator
__k1, __rc_iterator __k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p,
__const_rc_iterator __k1, __const_rc_iterator __k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p, _CharT *__k1,
_CharT *__k2) <br>
static void <b>_S_copy_chars</b> (_CharT *__p, const _CharT
*__k1, const _CharT *__k2) <br>
static void <b>_S_move</b> (_CharT *__d, const _CharT *__s,
size_type __n)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT, typename _Traits, typename _Alloc&gt;class
__gnu_cxx::__rc_string_base&lt; _CharT, _Traits, _Alloc
&gt;</b> <br>
Documentation? What&rsquo;s that? Nathan Myers
ncm@cantrip.org.</p>

<p style="margin-left:11%; margin-top: 1em">A string looks
like this:</p>

<p style="margin-left:11%; margin-top: 1em">* [_Rep] <br>
* _M_length <br>
* [__rc_string_base&lt;char_type&gt;] _M_capacity <br>
* _M_dataplus _M_refcount <br>
* _M_p ----------------&gt; unnamed array of char_type <br>
*</p>

<p style="margin-left:11%; margin-top: 1em">Where the _M_p
points to the first character in the string, and you cast it
to a pointer-to-_Rep and subtract 1 to get a pointer to the
header.</p>

<p style="margin-left:11%; margin-top: 1em">This approach
has the enormous advantage that a string object requires
only one allocation. All the ugliness is confined within a
single pair of inline functions, which each compile to a
single <i>add</i> instruction: _Rep::_M_refdata(), and
__rc_string_base::_M_rep(); and the allocation function
which gets a block of raw bytes and with room enough and
constructs a _Rep object at the front.</p>

<p style="margin-left:11%; margin-top: 1em">The reason you
want _M_data pointing to the character array and not the
_Rep is so that the debugger can see the string contents.
(Probably we should add a non-inline member to get the _Rep
for the debugger to use, so users can check the actual
string length.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
_Rep object is a POD so that you can have a static <i>empty
string</i> _Rep object already <i>constructed</i> before
static constructors have run. The reference-count encoding
is chosen so that a 0 indicates one reference, so you never
try to destroy the empty-string _Rep object.</p>

<p style="margin-left:11%; margin-top: 1em">All but the
last paragraph is considered pretty conventional for a C++
string implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 82 of file rc_string_base.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
