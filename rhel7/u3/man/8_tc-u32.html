<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:41:06 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Universal 32bit classifier in tc</title>

</head>
<body>

<h1 align="center">Universal 32bit classifier in tc</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#VALUES">VALUES</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#SELECTORS">SELECTORS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">u32 &minus;
universal 32bit traffic control filter</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:23%; margin-top: 1em"><b>tc
filter</b> ... [ <b>handle</b> <i>HANDLE</i> ] <b>u32</b>
<i>OPTION_LIST</i> [ <b>offset</b> <i>OFFSET</i> ] [
<b>hashkey</b> <i>HASHKEY</i> ] [ <b>classid</b>
<i>CLASSID</i> ] [ <b>divisor</b> <i>uint_value</i> ] [
<b>order</b> <i>u32_value</i> ] [ <b>ht</b> <i>HANDLE</i> ]
[ <b>sample</b> <i>SELECTOR</i> [ <b>divisor</b>
<i>uint_value</i> ] ] [ <b>link</b> <i>HANDLE</i> ] [
<b>indev</b> <i>ifname</i> ] [ <b>help</b> ]</p>

<p style="margin-left:23%; margin-top: 1em"><i>HANDLE</i>
:= {
<i>u12_hex_htid</i><b>:</b>[<i>u8_hex_hash</i><b>:</b>[<i>u12_hex_nodeid</i>]
| <b>0x</b><i>u32_hex_value</i> }</p>


<p style="margin-left:23%; margin-top: 1em"><i>OPTION_LIST</i>
:= [ <i>OPTION_LIST</i> ] <i>OPTION</i></p>

<p style="margin-left:23%; margin-top: 1em"><i>HASHKEY</i>
:= [ <b>mask</b> <i>u32_hex_value</i> ] [ <b>at</b>
<i>4*int_value</i> ]</p>

<p style="margin-left:23%; margin-top: 1em"><i>CLASSID</i>
:= { <b>root</b> | <b>none</b> |
[<i>u16_major</i>]<b>:</b><i>u16_minor</i> |
<i>u32_hex_value</i> }</p>

<p style="margin-left:23%; margin-top: 1em"><i>OFFSET</i>
:= [ <b>plus</b> <i>int_value</i> ] [ <b>at</b>
<i>2*int_value</i> ] [ <b>mask</b> <i>u16_hex_value</i> ] [
<b>shift</b> <i>int_value</i> ] [ <b>eat</b> ]</p>

<p style="margin-left:23%; margin-top: 1em"><i>OPTION</i>
:= { <b>match</b> <i>SELECTOR</i> | <b>action</b>
<i>ACTION</i> }</p>


<p style="margin-left:23%; margin-top: 1em"><i>SELECTOR</i>
:= { <b>u32</b> <i>VAL_MASK_32</i> | <b>u16</b>
<i>VAL_MASK_16</i> | <b>u8</b> <i>VAL_MASK_8</i> | <b>ip</b>
<i>IP</i> | <b>ip6</b> <i>IP6</i> | { <b>tcp</b> |
<b>udp</b> } <i>TCPUDP</i> | <b>icmp</b> <i>ICMP</i> |
<b>mark</b> <i>VAL_MASK_32</i> | <b>ether</b> <i>ETHER</i>
}</p>

<p style="margin-left:23%; margin-top: 1em"><i>IP</i> := {
{ <b>src</b> | <b>dst</b> } { <b>default</b> | <b>any</b> |
<b>all</b> | <i>ip_address</i> [ <b>/</b> { <i>prefixlen</i>
| <i>netmask</i> } ] } <i>AT</i> | { <b>dsfield</b> |
<b>ihl</b> | <b>protocol</b> | <b>precedence</b> |
<b>icmp_type</b> | <b>icmp_code</b> } <i>VAL_MASK_8</i> | {
<b>sport</b> | <b>dport</b> } <i>VAL_MASK_16</i> |
<b>nofrag</b> | <b>firstfrag</b> | <b>df</b> | <b>mf</b>
}</p>

<p style="margin-left:23%; margin-top: 1em"><i>IP6</i> := {
{ <b>src</b> | <b>dst</b> } { <b>default</b> | <b>any</b> |
<b>all</b> | <i>ip6_address</i> [/<i>prefixlen</i> ] }
<i>AT</i> | <b>priority</b> <i>VAL_MASK_8</i> | {
<b>protocol</b> | <b>icmp_type</b> | <b>icmp_code</b> }
<i>VAL_MASK_8</i> | <b>flowlabel</b> <i>VAL_MASK_32</i> | {
<b>sport</b> | <b>dport</b> } <i>VAL_MASK_16</i> }</p>

<p style="margin-left:23%; margin-top: 1em"><i>TCPUDP</i>
:= { <b>src</b> | <b>dst</b> } <i>VAL_MASK_16</i></p>

<p style="margin-left:23%; margin-top: 1em"><i>ICMP</i> :=
{ <b>type</b> <i>VAL_MASK_8</i> | <b>code</b>
<i>VAL_MASK_8</i> }</p>

<p style="margin-left:23%; margin-top: 1em"><i>ETHER</i> :=
{ <b>src</b> | <b>dst</b> } <i>ether_address AT</i></p>


<p style="margin-left:23%; margin-top: 1em"><i>VAL_MASK_32</i>
:= <i>u32_value u32_hex_mask</i> [ <i>AT</i> ]</p>


<p style="margin-left:23%; margin-top: 1em"><i>VAL_MASK_16</i>
:= <i>u16_value u16_hex_mask</i> [ <i>AT</i> ]</p>


<p style="margin-left:23%; margin-top: 1em"><i>VAL_MASK_8</i>
:= <i>u8_value u8_hex_mask</i> [ <i>AT</i> ]</p>

<p style="margin-left:23%; margin-top: 1em"><i>AT</i> := [
<b>at</b> [ <b>nexthdr+</b> ] <i>int_value</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
Universal/Ugly 32bit filter allows to match arbitrary
bitfields in the packet. Due to breaking everything down to
values, masks and offsets, It is equally powerful and hard
to use. Luckily many abstracting directives are present
which allow defining rules on a higher level and therefore
free the user from having to fiddle with bits and masks in
many cases.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
general modes of invocation: The first mode creates a new
filter to delegate packets to different destinations. Apart
from the obvious ones, namely classifying the packet by
specifying a <i>CLASSID</i> or calling an <b>action</b>, one
may <b>link</b> one filter to another one (or even a list of
them), effectively organizing filters into a tree-like
hierarchy.</p>

<p style="margin-left:11%; margin-top: 1em">Typically
filter delegation is done by means of a hash table, which
leads to the second mode of invocation: it merely serves to
set up these hash tables. Filters can select a hash table
and provide a key selector from which a hash is to be
computed and used as key to lookup the table&rsquo;s bucket
which contains filters for further processing. This is
useful if a high number of filters is in use, as the
overhead of performing the hash operation and table lookup
becomes negligible in that case. Using hashtables with
<b>u32</b> basically involves the following pattern:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(1)</p></td>
<td width="2%"></td>
<td width="83%">


<p>Creating a new hash table, specifying it&rsquo;s size
using the <b>divisor</b> parameter and ideally a handle by
which the table can be identified. If the latter is not
given, the kernel chooses one on it&rsquo;s own, which has
to be guessed later.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(2)</p></td>
<td width="2%"></td>
<td width="83%">


<p>Creating filters which link to the created table in
<i>(1)</i> using the <b>link</b> parameter and defining the
packet data which the kernel will use to calculate the
<b>hashkey</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>(3)</p></td>
<td width="2%"></td>
<td width="83%">


<p>Adding filters to buckets in the hash table from
<i>(1)</i>. In order to avoid having to know how exactly the
kernel creates the hash key, there is the <b>sample</b>
parameter, which gives sample data to hash and thereby
define the table bucket the filter should be added to.</p></td></tr>
</table>

<p style="margin-top: 1em">In fact, even if not explicitly
requested <b>u32</b> creates a hash table for every
<b>priority</b> a filter is being added with. The
table&rsquo;s size is 1 though, so it is in fact merely a
linked list.</p>

<h2>VALUES
<a name="VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Options and
selectors require values to be specified in a specific
format, which is often non-intuitive. Therefore the
terminals in <i>SYNOPSIS</i> have been given descriptive
names to indicate the required format and/or maximum allowed
numeric value: Prefixes <i>u32</i>, <i>u16</i> and <i>u8</i>
indicate four, two and single byte unsigned values. E.g.
<i>u16</i> indicates a two byte-sized value in range between
0 and 65535 (0xFFFF) inclusive. A prefix of <i>int</i>
indicates a four byte signed value. A middle part of
<i>_hex_</i> indicates that the value is parsed in
hexadecimal format. Otherwise, the value&rsquo;s base is
automatically detected, i.e. values prefixed with <i>0x</i>
are considered hexadecimal, a leading <i>0</i> indicates
octal format and decimal format otherwise. There are some
values with special formatting as well: <i>ip_address</i>
and <i>netmask</i> are in dotted-quad formatting as usual
for IPv4 addresses. An <i>ip6_address</i> is specified in
common, colon-separated hexadecimal format. Finally,
<i>prefixlen</i> is an unsigned, decimal integer value in
range from 0 to the address width in bits (32 for IPv4 and
128 for IPv6).</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes
values need to be dividable by a certain number. In that
case a name of the form <i>N*val</i> was chosen, indicating
that <i>val</i> must be dividable by <i>N</i>. Or the other
way around: the resulting value must be a multiple of
<i>N</i>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>U32</b>
recognizes the following options: <b><br>
handle</b> <i>HANDLE</i></p>

<p style="margin-left:22%;">The handle is used to reference
a filter and therefore must be unique. It consists of a hash
table identifier <b>htid</b> and optional <b>hash</b> (which
identifies the hash table&rsquo;s bucket) and <b>nodeid</b>.
All these values are parsed as unsigned, hexadecimal numbers
with length 12bits ( <b>htid</b> and <b>nodeid</b>) or 8bits
( <b>hash</b>). Alternatively one may specify a single,
32bit long hex number which contains the three fields bits
in concatenated form. Other than the fields themselves, it
has to be prefixed by <b>0x</b>.</p>

<p style="margin-left:11%;"><b>offset</b> <i>OFFSET</i></p>

<p style="margin-left:22%;">Set an offset which defines
where matches of subsequent filters are applied to.
Therefore this option is useful only when combined with
<b>link</b> or a combination of <b>ht</b> and <b>sample</b>.
The offset may be given explicitly by using the <b>plus</b>
keyword, or extracted from the packet data with <b>at</b>.
It is possible to mangle the latter using <b>mask</b> and/or
<b>shift</b> keywords. By default, this offset is recorded
but not implicitly applied. It is used only to substitute
the <b>nexthdr+</b> statement. Using the keyword <b>eat</b>
though inverses this behaviour: the offset is applied
always, and <b>nexthdr+</b> will fall back to zero.</p>

<p style="margin-left:11%;"><b>hashkey</b>
<i>HASHKEY</i></p>

<p style="margin-left:22%;">Spefify what packet data to use
to calculate a hash key for bucket lookup. The kernel
adjusts the value according to the hash table&rsquo;s size.
For this to work, the option <b>link</b> must be given.</p>

<p style="margin-left:11%;"><b>classid</b>
<i>CLASSID</i></p>

<p style="margin-left:22%;">Classify matching packets into
the given <i>CLASSID</i>, which consists of either 16bit
<b>major</b> and <b>minor</b> numbers or a single 32bit
value combining both.</p>

<p style="margin-left:11%;"><b>divisor</b>
<i>u32_value</i></p>

<p style="margin-left:22%;">Specify a modulo value. Used
when creating hash tables to define their size or for
declaring a <b>sample</b> to calculate hash table keys from.
Must be a power of two with exponent not exceeding
eight.</p>

<p style="margin-left:11%;"><b>order</b>
<i>u32_value</i></p>

<p style="margin-left:22%;">A value to order filters by,
ascending. Conflicts with <b>handle</b> which serves the
same purpose.</p>

<p style="margin-left:11%;"><b>sample</b>
<i>SELECTOR</i></p>

<p style="margin-left:22%;">Used together with <b>ht</b> to
specify which bucket to add this filter to. This allows one
to avoid having to know how exactly the kernel calculates
hashes. The additional <b>divisor</b> defaults to 256, so
must be given for hash tables of different size.</p>

<p style="margin-left:11%;"><b>link</b> <i>HANDLE</i></p>

<p style="margin-left:22%;">Delegate matching packets to
filters in a hash table. <i>HANDLE</i> is used to only
specify the hash table, so only <b>htid</b> may be given,
<b>hash</b> and <b>nodeid</b> have to be omitted. By
default, bucket number 0 will be used and can be overridden
by the <b>hashkey</b> option.</p>

<p style="margin-left:11%;"><b>indev</b> <i>ifname</i></p>

<p style="margin-left:22%;">Filter on the incoming
interface of the packet. Obviously works only for forwarded
traffic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>help</b></p></td>
<td width="5%"></td>
<td width="72%">


<p>Print a brief help text about possible options.</p></td>
<td width="6%">
</td></tr>
</table>

<h2>SELECTORS
<a name="SELECTORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Basically the
only real selector is <b>u32 .</b> All others merely provide
a higher level syntax and are internally translated into
<b>u32 . <br>
u32</b> <i>VAL_MASK_32</i> <b><br>
u16</b> <i>VAL_MASK_16</i> <b><br>
u8</b> <i>VAL_MASK_8</i></p>

<p style="margin-left:22%;">Match packet data to a given
value. The selector name defines the sample length to
extract (32bits for <b>u32</b>, 16bits for <b>u16</b> and
8bits for <b>u8</b>). Before comparing, the sample is binary
AND&rsquo;ed with the given mask. This way uninteresting
bits can be cleared before comparison. The position of the
sample is defined by the offset specified in <i>AT</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>ip</b> <i>IP</i></p></td>
<td width="82%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ip6</b> <i>IP6</i></p>

<p style="margin-left:22%;">Assume packet starts with an
IPv4 ( <b>ip</b>) or IPv6 ( <b>ip6</b>) header.
<i>IP</i>/<i>IP6</i> then allows to match various header
fields: <b><br>
src</b> <i>ADDR</i> <b><br>
dst</b> <i>ADDR</i></p>

<p style="margin-left:32%;">Compare Source or Destination
Address fields against the value of <i>ADDR</i>. The
reserved words <b>default</b>, <b>any</b> and <b>all</b>
effectively match any address. Otherwise an IP address of
the particular protocol is expected, optionally suffixed by
a prefix length to match whole subnets. In case of IPv4 a
netmask may also be given.</p>

<p style="margin-left:22%;"><b>dsfield</b>
<i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">IPv4 only. Match the packet
header&rsquo;s DSCP/ECN field. Synonyms to this are
<b>tos</b> and <b>precedence</b>.</p>

<p style="margin-left:22%;"><b>ihl</b>
<i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">IPv4 only. Match the Internet
Header Length field. Note that the value&rsquo;s unit is
32bits, so to match a packet with 24byte header length
<i>u8_value</i> has to be 6.</p>

<p style="margin-left:22%;"><b>protocol</b>
<i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">Match the Protocol (IPv4) or
Next Header (IPv6) field value, e.g. 6 for TCP.</p>

<p style="margin-left:22%;"><b>icmp_type</b>
<i>VAL_MASK_8</i> <b><br>
icmp_code</b> <i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">Assume a next-header protocol
of icmp or ipv6-icmp and match Type or Code field values.
This is dangerous, as the code assumes minimal header size
for IPv4 and lack of extension headers for IPv6.</p>

<p style="margin-left:22%;"><b>sport</b> <i>VAL_MASK_16</i>
<b><br>
dport</b> <i>VAL_MASK_16</i></p>

<p style="margin-left:32%;">Match layer four source or
destination ports. This is dangerous as well, as it assumes
a suitable layer four protocol is present (which has Source
and Destination Port fields right at the start of the header
and 16bit in size). Also minimal header size for IPv4 and
lack of IPv6 extension headers is assumed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>nofrag</b></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>firstfrag</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>df</b></p></td>
<td width="7%"></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p><b>mf</b></p></td>
<td width="7%"></td>
<td width="68%">


<p>IPv4 only, check certain flags and fragment offset
values. Match if the packet is not a fragment
(<b>nofrag</b>), the first fragment (<b>firstfrag</b>), if
Don&rsquo;t Fragment (<b>df</b>) or More Fragments
(<b>mf</b>) bits are set.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>priority</b>
<i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">IPv6 only. Match the
header&rsquo;s Traffic Class field, which has the same
purpose and semantics of IPv4&rsquo;s ToS field since RFC
3168: upper six bits are DSCP, the lower two ECN.</p>

<p style="margin-left:22%;"><b>flowlabel</b>
<i>VAL_MASK_32</i></p>

<p style="margin-left:32%;">IPv6 only. Match the Flow Label
field&rsquo;s value. Note that Flow Label itself is only
20bytes long, which are the least significant ones here. The
remaining upper 12bytes match Version and Traffic Class
fields.</p>

<p style="margin-left:11%;"><b>tcp</b> <i>TCPUDP</i>
<b><br>
udp</b> <i>TCPUDP</i></p>

<p style="margin-left:22%;">Match fields of next header of
protocol TCP or UDP. The possible values for <i>TCPDUP</i>
are: <b><br>
src</b> <i>VAL_MASK_16</i></p>

<p style="margin-left:32%;">Match on Source Port field
value.</p>

<p style="margin-left:22%;"><b>dst</b>
<i>VALMASK_16</i></p>

<p style="margin-left:32%;">Match on Destination Port field
value.</p>

<p style="margin-left:11%;"><b>icmp</b> <i>ICMP</i></p>

<p style="margin-left:22%;">Match fields of next header of
protocol ICMP. The possible values for <i>ICMP</i> are:
<b><br>
type</b> <i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">Match on ICMP Type field.</p>

<p style="margin-left:22%;"><b>code</b>
<i>VAL_MASK_8</i></p>

<p style="margin-left:32%;">Match on ICMP Code field.</p>

<p style="margin-left:11%;"><b>mark</b>
<i>VAL_MASK_32</i></p>

<p style="margin-left:22%;">Match on netfilter fwmark
value.</p>

<p style="margin-left:11%;"><b>ether</b> <i>ETHER</i></p>

<p style="margin-left:22%;">Match on ethernet header
fields. Possible values for <i>ETHER</i> are: <b><br>
src</b> <i>ether_address AT</i> <b><br>
dst</b> <i>ether_address AT</i></p>

<p style="margin-left:32%;">Match on source or destination
ethernet address. This is dangerous: It assumes an ethernet
header is present at the start of the packet. This will
probably lead to unexpected things if used with layer three
interfaces like e.g. tun or ppp.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<pre style="margin-left:22%; margin-top: 1em">tc filter add dev eth0 parent 999:0 prio 99 protocol ip u32 \
        match ip src 192.168.8.0/24 classid 1:1</pre>


<p style="margin-left:11%; margin-top: 1em">This attaches a
filter to the qdisc identified by <b>999:0.</b> It&rsquo;s
priority is <b>99</b>, which affects in which order multiple
filters attached to the same <b>parent</b> are consulted
(the lower the earlier). The filter handles packets of
<b>protocol</b> type <b>ip</b>, and <b>match</b>es if the IP
header&rsquo;s source address is within the
<b>192.168.8.0/24</b> subnet. Matching packets are
classified into class <b>1.1</b>. The effect of this command
might be surprising at first glance:</p>

<pre style="margin-left:22%; margin-top: 1em">filter parent 1: protocol ip pref 99 u32
filter parent 1: protocol ip pref 99 u32 \
        fh 800: ht divisor 1
filter parent 1: protocol ip pref 99 u32 \
        fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 \
        match c0a80800/ffffff00 at 12</pre>


<p style="margin-left:11%; margin-top: 1em">So parent
<b>1:</b> is assigned a new <b>u32</b> filter, which
contains a hash table of size 1 (as the <b>divisor</b>
indicates). The table ID is <b>800</b>. The third line then
shows the actual filter which was added above: it sits in
table <b>800</b> and bucket <b>0</b>, classifies packets
into class ID <b>1:1</b> and matches the upper three bytes
of the four byte value at offset <b>12</b> to be
<b>0xc0a808</b>, which is 192, 168 and 8.</p>

<p style="margin-left:11%; margin-top: 1em">Now for
something more complicated, namely creating a custom hash
table:</p>

<pre style="margin-left:22%; margin-top: 1em">tc filter add dev eth0 prio 99 handle 1: u32 divisor 256</pre>


<p style="margin-left:11%; margin-top: 1em">This creates a
table of size 256 with handle <b>1:</b> in priority
<b>99</b>. The effect is as follows:</p>

<pre style="margin-left:22%; margin-top: 1em">filter parent 1: protocol all pref 99 u32
filter parent 1: protocol all pref 99 u32 fh 1: ht divisor 256
filter parent 1: protocol all pref 99 u32 fh 800: ht divisor 1</pre>


<p style="margin-left:11%; margin-top: 1em">So along with
the requested hash table (handle <b>1:</b>), the kernel has
created his own table of size 1 to hold other filters of the
same priority.</p>

<p style="margin-left:11%; margin-top: 1em">The next step
is to create a filter which links to the created hash
table:</p>

<pre style="margin-left:22%; margin-top: 1em">tc filter add dev eth0 parent 1: prio 1 u32 \
        link 1: hashkey mask 0x0000ff00 at 12 \
        match ip src 192.168.0.0/16</pre>


<p style="margin-left:11%; margin-top: 1em">The filter is
given a lower priority than the hash table itself so
<b>u32</b> consults it before manually traversing the hash
table. The options <b>link</b> and <b>hashkey</b> determine
which table and bucket to redirect to. In this case the hash
key should be constructed out of the second byte at offset
12, which corresponds to an IP packet&rsquo;s third byte of
the source address field. Along with the <b>match</b>
statement, this effectively maps all class C networks below
192.168.0.0/16 to different buckets of the hash table.</p>

<p style="margin-left:11%; margin-top: 1em">Filters for
certain subnets can be created like so:</p>

<pre style="margin-left:22%; margin-top: 1em">tc filter add dev eth0 parent 1: prio 99 u32 \
        ht 1: sample u32 0x00000800 0x0000ff00 at 12 \
        match ip src 192.168.8.0/24 classid 1:1</pre>


<p style="margin-left:11%; margin-top: 1em">The bucket is
defined using the <b>sample</b> option: In this case, the
second byte at offset 12 must be 0x08, exactly. In this
case, the resulting bucket ID is obviously 8, but as soon as
<b>sample</b> selects an amount of data which could exceed
the <b>divisor</b>, one would have to know the
kernel-internal algorithm to deduce the destination bucket.
This filter&rsquo;s <b>match</b> statement is redundant in
this case, as the entropy for the hash key does not exceed
the table size and therefore no collisions can occur.
Otherwise it&rsquo;s necessary to prevent matching unwanted
packets.</p>

<p style="margin-left:11%; margin-top: 1em">Matching upper
layer fields is problematic since IPv4 header length is
variable and IPv6 supports extension headers which affect
upper layer header offset. To overcome this, there is the
possibility to specify <b>nexthdr+</b> when giving an
offset, and to make things easier there are the <b>tcp</b>
and <b>udp</b> matches which use <b>nexthdr+</b> implicitly.
This offset has to be calculated in beforehand though, and
the only way to achieve that is by doing it in a separate
filter which then links to the filter which wants to use it.
Here is an example of doing so:</p>

<pre style="margin-left:22%; margin-top: 1em">tc filter add dev eth0 parent 1:0 protocol ip handle 1: \
        u32 divisor 1
tc filter add dev eth0 parent 1:0 protocol ip \
        u32 ht 1: \
        match tcp src 22 FFFF \
        classid 1:2
tc filter add dev eth0 parent 1:0 protocol ip \
        u32 ht 800: \
        match ip protocol 6 FF \
        match ip firstfrag \
        offset at 0 mask 0f00 shift 6 \
        link 1:</pre>


<p style="margin-left:11%; margin-top: 1em">This is what is
being done: In the first call, a single element sized hash
table is created so there is a place to hold the linked to
filter and a known handle (<b>1:</b>) to reference to it.
The second call then adds the actual filter, which pushes
packets with TCP source port 22 into class <b>1:2</b>. Using
<b>ht</b>, it is moved into the hash table created by the
first call. The third call then does the actual magic: It
matches IPv4 packets with next layer protocol 6 (TCP), only
if it&rsquo;s the first fragment (usually TCP sets DF bit,
but if it doesn&rsquo;t and the packet is fragmented, only
the first one contains the TCP header), and then sets the
offset based on the IP header&rsquo;s IHL field
(right-shifting by 6 eliminates the offset of the field and
at the same time converts the value into byte unit).
Finally, using <b>link</b>, the hash table from first call
is referenced which holds the filter from second call.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>tc</b>(8),
<b><br>
cls_u32.txt</b> at
<b>http://linux-tc-notes.sourceforge.net/</b></p>
<hr>
</body>
</html>
