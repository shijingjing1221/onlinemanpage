<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:08:41 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Date::Calendar::Year</title>

</head>
<body>

<h1 align="center">Date::Calendar::Year</h1>

<a href="#NAME">NAME</a><br>
<a href="#MOTTO">MOTTO</a><br>
<a href="#PREFACE">PREFACE</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#INTERFACE">INTERFACE</a><br>
<a href="#IMPLEMENTATION">IMPLEMENTATION</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#KNOWN BUGS">KNOWN BUGS</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#DISCLAIMER">DISCLAIMER</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Date::Calendar::Year
&minus; Implements embedded &quot;year&quot; objects for
Date::Calendar</p>

<h2>MOTTO
<a name="MOTTO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There is more
than one way to do it &minus; this is just one of them!</p>

<h2>PREFACE
<a name="PREFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that
Date::Calendar::Year (and Date::Calendar) can only deal with
years lying within the range [1583..2299].</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use Date::Calendar::Year qw( check_year empty_period );
  use Date::Calendar::Year qw( :all ); # same as above
  check_year(YEAR|DATE); # dies if year &lt; 1583 or year &gt; 2299
  empty_period();        # warns about empty interval if $^W is set
  $index = $year&minus;&gt;date2index(YEAR,MONTH,DAY|DATE);
  $date  = $year&minus;&gt;index2date(INDEX);
  use Date::Calendar::Profiles qw( $Profiles );
  $year_2000_US_FL = Date::Calendar::Year&minus;&gt;new( 2000, $Profiles&minus;&gt;{'US&minus;FL'} [,LANG[,WEEKEND]] );
  $year_2001_DE_NW = Date::Calendar::Year&minus;&gt;new( 2001, $Profiles&minus;&gt;{'DE&minus;NW'} [,LANG[,WEEKEND]] );
  $year = Date::Calendar::Year&minus;&gt;new( 2001, {} );
  $year&minus;&gt;init( 2002, $Profiles&minus;&gt;{'DE&minus;SN'} [,LANG[,WEEKEND]] );
  $vector = $year&minus;&gt;vec_full(); # vector of full holidays
  $vector = $year&minus;&gt;vec_half(); # vector of half holidays
  $vector = $year&minus;&gt;vec_work(); # NOT a vector of workdays but a workspace!
  $size   = $year&minus;&gt;val_days(); # number of days in that year, size of vectors
  $base   = $year&minus;&gt;val_base(); # number of days for [year,1,1] since [1,1,1]
  $number = $year&minus;&gt;val_year(); # the year's number itself
  $number = $year&minus;&gt;year();     # alias for val_year()
  @names    = $year&minus;&gt;labels(YEAR,MONTH,DAY|DATE);
  @holidays = $year&minus;&gt;labels();
  $holidays = $year&minus;&gt;labels();
  @dates    = $year&minus;&gt;search(PATTERN);
  $dates    = $year&minus;&gt;search(PATTERN);
  $hashref  = $year&minus;&gt;tags(YEAR,MONTH,DAY|DATE);
  $hashref  = $year&minus;&gt;tags(INDEX);
  $days     = $year&minus;&gt;delta_workdays(YEAR,MONTH1,DAY1|DATE1
                                   ,YEAR,MONTH2,DAY2|DATE2
                                   ,FLAG1,FLAG2);
  ($date,$rest,$sign) = $year&minus;&gt;add_delta_workdays(YEAR,MONTH,DAY|DATE
                                                 ,DELTA,SIGN);
  $flag     = $year&minus;&gt;is_full(YEAR,MONTH,DAY|DATE);
  $flag     = $year&minus;&gt;is_half(YEAR,MONTH,DAY|DATE);
  $flag     = $year&minus;&gt;is_work(YEAR,MONTH,DAY|DATE);</pre>


<h2>INTERFACE
<a name="INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that
whenever a year number, a date, a time or a combined date
and time are expected as input parameters by one of the
methods of this class, you can always pass a
Date::Calc[::Object] date object or an array reference (of
an array of appropriate length) instead!</p>

<p style="margin-left:11%; margin-top: 1em">See
<i>Date::Calc::Object</i>(3) for more details.</p>

<p style="margin-left:11%; margin-top: 1em">So instead of
calling a given method like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $object&minus;&gt;method1( $year,$month,$day );
  $object&minus;&gt;method2( $year1,$month1,$day1, $year2,$month2,$day2 );
  $object&minus;&gt;method3( $year1, $year2, $year3 );</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
call it like so:</p>

<pre style="margin-left:11%; margin-top: 1em">  $object&minus;&gt;method1( $date );
  $object&minus;&gt;method1( [1964,1,3] );
  $object&minus;&gt;method2( $year1,$month1,$day1, $date2 );
  $object&minus;&gt;method2( $date1, $year2,$month2,$day2 );
  $object&minus;&gt;method2( $date1, $date2 );
  $object&minus;&gt;method2( $year1,$month1,$day1, [2001,3,17] );
  $object&minus;&gt;method2( [1964,1,3], $year2,$month2,$day2 );
  $object&minus;&gt;method2( [1964,1,3], [2001,3,17] );
  $object&minus;&gt;method2( $date1, [2001,3,17] );
  $object&minus;&gt;method2( [1964,1,3], $date2 );
  $object&minus;&gt;method3( $year1, $date2, [2001,3,17] );</pre>


<p style="margin-left:11%; margin-top: 1em">And similarly
if a time or a combined date and time are expected.</p>

<p style="margin-left:11%; margin-top: 1em">If you
substitute an expected year number by an anonymous array
(this is the recommended way of writing date constants, for
increased readability of your programs), it must contain
three values, nevertheless (otherwise the use of an
anonymous array would be pointless).</p>

<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t
confuse year numbers and their substitutes (a date object or
an array reference) with Date::Calendar::Year objects, which
are a totally different thing!</p>

<p style="margin-left:11%; margin-top: 1em">But
incidentally <tt>&quot;:&minus;)&quot;</tt>, you may also
pass a Date::Calendar::Year object whenever a year number is
expected. However, and perhaps against your expectations at
times, only the year number from that object will be used,
not the year object itself (the year object in question
might be using the wrong profile!).</p>

<p style="margin-left:11%; margin-top: 1em">Moreover,
whenever a method of this class returns a date, it does so
by returning a Date::Calc[::Object] date object.</p>

<h2>IMPLEMENTATION
<a name="IMPLEMENTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Each
Date::Calendar::Year object consists mainly of three bit
vectors, plus some administrative attributes, all stored in
a (blessed) hash.</p>

<p style="margin-left:11%; margin-top: 1em">All three bit
vectors contain as many bits as there are days in the
corresponding year, i.e., either 365 or 366.</p>

<p style="margin-left:11%; margin-top: 1em">The first bit
vector, called &quot; <small>FULL&quot;,</small> contains
set bits for Saturdays, Sundays and all &quot;full&quot;
legal holidays (i.e., days off, on which you usually do not
work).</p>

<p style="margin-left:11%; margin-top: 1em">The second bit
vector, called &quot; <small>HALF&quot;,</small> contains
set bits for all &quot;half&quot; holidays, i.e., holidays
where you get only half a day off from work.</p>

<p style="margin-left:11%; margin-top: 1em">The third and
last bit vector, called &quot; <small>WORK&quot;,</small> is
used as a workspace, in which various calculations are
performed throughout this module.</p>

<p style="margin-left:11%; margin-top: 1em">Its name does
<b><small>NOT</small></b> come from &quot;working days&quot;
(as you might think), but from &quot;workspace&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">It only so
happens that it is used to calculate the working days
sometimes, at some places in this module.</p>

<p style="margin-left:11%; margin-top: 1em">But you are
free to use it yourself, for whatever calculation you would
like to carry out yourself.</p>

<p style="margin-left:11%; margin-top: 1em">The two other
bit vectors, &quot; <small>FULL&quot;</small> and &quot;
<small>HALF&quot;,</small> should never be changed, unless
you know <b><small>EXACTLY</small></b> what you&rsquo;re
doing!</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Functions</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><tt>&quot;check_year(YEAR);&quot;</tt></p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
checks that the given year lies in the permitted range
[1583..2299]. It returns nothing in case of success, and
throws an exception (&quot;given year out of range
[1583..2299]&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="26%">



<p style="margin-top: 1em"><tt>&quot;empty_period();&quot;</tt></p> </td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
issues a warning (from the perspective of the caller of a
Date::* module) that the given range of dates is empty
(&quot;dates interval is empty&quot;), provided that
warnings are enabled (i.e., &quot;<tt>$^W</tt>&quot; is
true).</p>

<p style="margin-left:14%; margin-top: 1em">This function
is currently used by the method
&quot;<i>delta_workdays()</i>&quot; in this class, and by
its equivalent from the Date::Calendar module.</p>

<p style="margin-left:14%; margin-top: 1em">It is called
whenever the range of dates of which the difference in
working days is to be calculated is empty. This can happen
for instance if you specify two adjacent dates both of which
are not to be included in the difference.</p>

<p style="margin-left:11%; margin-top: 1em">Methods</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="77%">


<p style="margin-top: 1em"><tt>&quot;$index =
$year&minus;&gt;date2index(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
converts a given date into the number of the day in that
year (this is sometimes also referred to as the
&quot;julian&quot; date), i.e., a number between 0 (for
January 1st) and the number of days in the given year minus
one, i.e., 364 or 365 (for December 31st).</p>

<p style="margin-left:14%; margin-top: 1em">You may need
this in order to access the bit vectors returned by the
methods &quot;<i>vec_full()</i>&quot;,
&quot;<i>vec_half()</i>&quot; and
&quot;<i>vec_work()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that there
are shorthand methods in this module called
&quot;<i>is_full()</i>&quot;, &quot;<i>is_half()</i>&quot;
and &quot;<i>is_work()</i>&quot;, which serve to test
individual bits of the three bit vectors which are a part of
each Date::Calendar::Year object.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
(&quot;given year != object&rsquo;s year&quot;) is thrown if
the year associated with the year object itself and the year
from the given date do not match.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
(&quot;invalid date&quot;) is also thrown if the given
arguments do not constitute a valid date, or (&quot;given
year out of range [1583..2299]&quot;) if the given year lies
outside of the permitted range.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p style="margin-top: 1em"><tt>&quot;$date =
$year&minus;&gt;index2date(INDEX);&quot;</tt></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
converts an index (or &quot;julian date&quot;) for the given
year back into a date.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
(&quot;invalid index&quot;) is thrown if the given index is
outside of the permitted range for the given year, i.e.,
<tt>&quot;[0..364]&quot;</tt> or
<tt>&quot;[0..365]&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
method returns a Date::Calc <b><small>OBJECT</small></b>
!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em"><tt>&quot;$year_2000_US_FL =
Date::Calendar::Year&minus;&gt;new( 2000,
$Profiles&minus;&gt;{'US&minus;FL'} [,LANG[,WEEKEND]]
);&quot;</tt></p> </td>
<td width="6%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$year_2001_DE_NW
= Date::Calendar::Year&minus;&gt;new( 2001,
$Profiles&minus;&gt;{'DE&minus;NW'} [,LANG[,WEEKEND]]
);&quot;</tt></p>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$year
= Date::Calendar::Year&minus;&gt;new( 2001, {}
);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This is the
constructor method. Call it to create a new
Date::Calendar::Year object.</p>

<p style="margin-left:14%; margin-top: 1em">The first
argument must be a year number in the range
[1583..2299].</p>

<p style="margin-left:14%; margin-top: 1em">The second
argument must be the reference of a hash, which usually
contains names of holidays and commemorative days as keys
and strings containing the date or formula for each holiday
as values.</p>

<p style="margin-left:14%; margin-top: 1em">Reading this
hash and initializing the object&rsquo;s internal data is
performed by an extra method, called
&quot;<i>init()</i>&quot;, which is called internally by the
constructor method, and which is described immediately
below, after this method.</p>

<p style="margin-left:14%; margin-top: 1em">In case you
want to call the &quot;<i>init()</i>&quot; method yourself,
explicitly, after creating the object, you can pass an empty
profile (e.g., just an empty anonymous hash) to the
&quot;<i>new()</i>&quot; method, in order to create an empty
object, and also to improve performance.</p>

<p style="margin-left:14%; margin-top: 1em">The third
argument is optional, and must consist of the valid name or
number of a language as provided by the <i>Date::Calc</i>(3)
module, if given.</p>

<p style="margin-left:14%; margin-top: 1em">This argument
determines which language shall be used when reading the
profile, since the profile may contain names of months and
weekdays in its formulas in that language.</p>

<p style="margin-left:14%; margin-top: 1em">The default is
English if no value or no valid value is specified (and if
the global default has not been changed with
&quot;<i>Language()</i>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">After the third
argument, a list of day numbers which will constitute the
&quot;weekend&quot; can optionally be specified, where
1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday,
6=Saturday and 7=Sunday.</p>

<p style="margin-left:14%; margin-top: 1em">If no values
are given, 6 and 7 (Saturday and Sunday) are automatically
taken as default.</p>

<p style="margin-left:14%; margin-top: 1em">If values
outside of the range <tt>1..7</tt> are given, they will be
ignored.</p>

<p style="margin-left:14%; margin-top: 1em">This can be
used to switch off this feature and to have no regularly
recurring holidays at all when for instance a zero is
given.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;$year&minus;&gt;init(
2002, $Profiles&minus;&gt;{'DE&minus;SN'} [,LANG[,WEEKEND]]
);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method is
called by the &quot;<i>new()</i>&quot; constructor method,
internally, and has the same arguments as the latter.</p>

<p style="margin-left:14%; margin-top: 1em">See immediately
above for a description of these arguments.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
can also call this method explicitly yourself, if needed,
and you can of course subclass the Date::Calendar::Year
class and override the &quot;<i>init()</i>&quot; method with
a method of your own.</p>

<p style="margin-left:14%; margin-top: 1em">The holiday
scheme or &quot;profile&quot; (i.e., the reference of a hash
passed as the second argument to this method) must obey the
following semantics and syntax:</p>

<p style="margin-left:14%; margin-top: 1em">The keys are
the names of the holiday or commemorative day in question.
Keys must be unique (but see further below).</p>

<p style="margin-left:14%; margin-top: 1em">The difference
between a holiday and a commemorative day is that you
(usually) get a day off on a holiday, whereas on a purely
commemorative day, you don&rsquo;t.</p>

<p style="margin-left:14%; margin-top: 1em">A commemorative
day is just a date with a name, nothing more.</p>

<p style="margin-left:14%; margin-top: 1em">The values
belonging to these keys can either be the code reference of
a callback function (see <i>Date::Calendar::Profiles</i>(3)
for more details and examples), or a string.</p>

<p style="margin-left:14%; margin-top: 1em">All other
values cause a fatal error with program abortion.</p>

<p style="margin-left:14%; margin-top: 1em">The strings can
specify three types of dates:</p>

<pre style="margin-left:14%; margin-top: 1em">  &minus;  fixed dates
     (like New Year, or first of January),
  &minus;  dates relative to Easter Sunday
     (like Ascension = Easter Sunday + 39 days), and
  &minus;  the 1st, 2nd, 3rd, 4th or last
     of a given day of week in a given month
     (like &quot;the 4th Thursday of November&quot;, or Thanksgiving).</pre>


<p style="margin-left:14%; margin-top: 1em">All other types
of dates must be specified via callback functions.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
&quot;last&quot; of a given day of week is written as the
&quot;5th&quot;, because the last is always either the 5th
or the 4th of the given day of week. So the
&quot;<i>init()</i>&quot; module first calculates the 5th of
the requested day of week, and if that doesn&rsquo;t exist,
takes the 4th instead.</p>

<p style="margin-left:14%; margin-top: 1em">There are also
two modifier characters which may prefix the string with the
date formula, &quot;#&quot; and &quot;:&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The character
&quot;#&quot; (mnemonic: it&rsquo;s only a comment) signals
that the date in question is a purely commemorative day,
i.e., it will not enter into any date calculations, but can
be queried with the &quot;<i>labels()</i>&quot; and
&quot;<i>search()</i>&quot; methods, and appears when
printing a calendar, for instance.</p>

<p style="margin-left:14%; margin-top: 1em">The character
&quot;:&quot; (mnemonic: divided into two halfs) specifies
that the date in question is only a &quot;half&quot;
holiday, i.e., you only get half a day off instead of a full
day. Some companies have this sort of thing.
<tt>&quot;:&minus;)&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">The exact
syntax for the date formula strings is the following (by
example):</p>

<pre style="margin-left:14%; margin-top: 1em"> &minus;  Fixed dates:
    &quot;Christmas&quot;  =&gt;  &quot;24.12&quot;,   # European format (day, month)
    &quot;Christmas&quot;  =&gt;  &quot;24.12.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24Dec.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24&minus;12&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24&minus;12&minus;&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24&minus;Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24&minus;Dec&minus;&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;12/25&quot;,   # American format (month, day)
    &quot;Christmas&quot;  =&gt;  &quot;Dec25&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;Dec/25&quot;,
 &minus;  Dates relative to Easter Sunday:
    &quot;Ladies' Carnival&quot;  =&gt;  &quot;&minus;52&quot;,
    &quot;Carnival Monday&quot;   =&gt;  &quot;&minus;48&quot;,
    &quot;Mardi Gras&quot;        =&gt;  &quot;&minus;47&quot;,
    &quot;Ash Wednesday&quot;     =&gt;  &quot;&minus;46&quot;,
    &quot;Palm Sunday&quot;       =&gt;   &quot;&minus;7&quot;,
    &quot;Maundy Thursday&quot;   =&gt;   &quot;&minus;3&quot;,
    &quot;Good Friday&quot;       =&gt;   &quot;&minus;2&quot;,
    &quot;Easter Sunday&quot;     =&gt;   &quot;+0&quot;,
    &quot;Easter Monday&quot;     =&gt;   &quot;+1&quot;,
    &quot;Ascension&quot;         =&gt;  &quot;+39&quot;,
    &quot;Whitsunday&quot;        =&gt;  &quot;+49&quot;,
    &quot;Whitmonday&quot;        =&gt;  &quot;+50&quot;,
    &quot;Corpus Christi&quot;    =&gt;  &quot;+60&quot;,
 &minus;  The 1st, 2nd, 3rd, 4th or last day of week:
    &quot;Thanksgiving&quot;      =&gt;  &quot;4Thu11&quot;,
    &quot;Thanksgiving&quot;      =&gt;  &quot;4/Thu/Nov&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/10&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/10&quot;,
    &quot;Memorial Day&quot;      =&gt;  &quot;5/Mon/May&quot;, # LAST Monday of May</pre>


<p style="margin-left:14%; margin-top: 1em">Remember that
each of these date formula strings may also be prefixed with
either &quot;#&quot; or &quot;:&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">    &quot;Christmas&quot;         =&gt;  &quot;:24.12.&quot;, # only half a day off
    &quot;Valentine's Day&quot;   =&gt;  &quot;#Feb/14&quot;, # not an official holiday</pre>


<p style="margin-left:14%; margin-top: 1em">Note that the
name of the month or day of week may have any length you
like, it just must specify the intended month or day of week
unambiguously. So &quot;D&quot;, &quot;De&quot;,
&quot;Dec&quot;, &quot;Dece&quot;, &quot;Decem&quot;,
&quot;Decemb&quot;, &quot;Decembe&quot; and
&quot;December&quot; would all be valid, for example. Note
also that case is ignored.</p>

<p style="margin-left:14%; margin-top: 1em">When specifying
day and month numbers, or offsets relative to Easter Sunday,
leading zeros are permitted (for nicely indented formatting,
for instance) but ignored.</p>

<p style="margin-left:14%; margin-top: 1em">Leading zeros
are not permitted in front of the ordinal number [1..5] or
the number of the day of week [1..7] when specifying the nth
day of week in a month.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that if keys are not unique in the source code, later
entries will overwrite previous ones! I.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">    ...
    &quot;My special holiday&quot; =&gt; &quot;01&minus;11&quot;,
    &quot;My special holiday&quot; =&gt; &quot;02&minus;11&quot;,
    ...</pre>


<p style="margin-left:14%; margin-top: 1em">will
<b><small>NOT</small></b> set two holidays of the same name,
one on November first, the other on November second, but
only one, on November second!</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, in
order to use sets of defaults and to be able to override
some of them, you must <b><small>FIRST</small></b> include
any hash containing the default definitions, and
<b><small>THEN</small></b> write down your own definitions
(see also the Date::Calendar::Profiles module for examples
of this!), like this:</p>

<pre style="margin-left:14%; margin-top: 1em">    $defaults =
    {
        &quot;Holiday #1&quot; =&gt; &quot;01&minus;01&quot;,
        &quot;Holiday #2&quot; =&gt; &quot;02&minus;02&quot;,
        &quot;Holiday #3&quot; =&gt; &quot;03&minus;03&quot;
    };
    $variant1 =
    {
        %$defaults,
        &quot;Holiday #2&quot; =&gt; &quot;09&minus;02&quot;,
        &quot;Holiday #4&quot; =&gt; &quot;04&minus;04&quot;
    };</pre>


<p style="margin-left:14%; margin-top: 1em">This is because
of the way hashes work in Perl.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;<i>init()</i>&quot; method proceeds as follows:</p>

<p style="margin-left:14%; margin-top: 1em">First it checks
whether the given year number lies in the range
[1583..2299]. A fatal error occurs if not.</p>

<p style="margin-left:14%; margin-top: 1em">Then it
determines the number of days in the requested year, and
stores it in the given Date::Calendar::Year object.</p>

<p style="margin-left:14%; margin-top: 1em">It then calls
the <i>Bit::Vector</i>(3) module to allocate three bit
vectors with a number of bits equal to the number of days in
the requested year, and stores the three object references
(of the bit vectors) in the Date::Calendar::Year object.</p>

<p style="margin-left:14%; margin-top: 1em">(See also the
description of the three methods
&quot;<i>vec_full()</i>&quot;, &quot;<i>vec_half()</i>&quot;
and &quot;<i>vec_full()</i>&quot; immediately below.)</p>

<p style="margin-left:14%; margin-top: 1em">It then sets
the bits which correspond to Saturdays and Sundays (or
optionally to the days whose numbers have been specified as
the &quot;weekend&quot;) in the &quot;full holidays&quot;
bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">At last, it
iterates over the keys of the given holiday scheme (of the
hash referred to by the hash reference passed to the
&quot;<i>init()</i>&quot; method as the second argument),
evaluates the formula (or calls the given callback
function), and sets the corresponding bit in the
&quot;full&quot; or &quot;half&quot; holidays bit vector if
the calculated date is valid.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal error
occurs if the date formula cannot be parsed or if the date
returned by a formula or callback function is invalid (e.g.
30&minus;Feb&minus;2001 or the like) or lies outside the
given year (e.g. Easter+365).</p>

<p style="margin-left:14%; margin-top: 1em">Finally, the
&quot;<i>init()</i>&quot; method makes sure that days marked
as &quot;full&quot; holidays do not appear as
&quot;half&quot; holidays as well.</p>

<p style="margin-left:14%; margin-top: 1em">Then the
&quot;<i>init()</i>&quot; method returns.</p>

<p style="margin-left:14%; margin-top: 1em">Note that when
deciphering the date formulas, the &quot;<i>init()</i>&quot;
method uses the functions
&quot;<i>Decode_Day_of_Week()</i>&quot; and
&quot;<i>Decode_Month()</i>&quot; from the
<i>Date::Calc</i>(3) module, which are
language-dependent.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore the
&quot;<i>init()</i>&quot; method allows you to pass it an
optional third argument, which must consist of the valid
name or number of a language as provided by the
<i>Date::Calc</i>(3) module.</p>

<p style="margin-left:14%; margin-top: 1em">For the time of
scanning the given holiday scheme, the
&quot;<i>init()</i>&quot; method will use the language that
has been specified, or the global setting from
&quot;<i>Language()</i>&quot; if no or an invalid language
parameter is given.</p>

<p style="margin-left:14%; margin-top: 1em">The default is
English if none is specified and if the global setting has
not been modified.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
you can provide the names of months and days of week in your
holiday profile in any of the languages supported by the
<i>Date::Calc</i>(3) module, provided you give the
&quot;<i>init()</i>&quot; method a clue (the third
parameter) which language to expect.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$vector =
$year&minus;&gt;vec_full();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a reference to the bit vector in the given year
object which contains all &quot;full&quot; holidays.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that you should <b><small>NEVER</small></b> change the
contents of this bit vector unless you know
<b><small>EXACTLY</small></b> what you&rsquo;re doing!</p>

<p style="margin-left:14%; margin-top: 1em">You should
usually only read from this bit vector, or use it as an
operand in bit vector operations &minus; but never as an
lvalue.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$vector =
$year&minus;&gt;vec_half();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a reference to the bit vector in the given year
object which contains all &quot;half&quot; holidays.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that you should <b><small>NEVER</small></b> change the
contents of this bit vector unless you know
<b><small>EXACTLY</small></b> what you&rsquo;re doing!</p>

<p style="margin-left:14%; margin-top: 1em">You should
usually only read from this bit vector, or use it as an
operand in bit vector operations &minus; but never as an
lvalue.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$vector =
$year&minus;&gt;vec_work();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns a reference to the &quot;workspace&quot; bit vector
in the given year object.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
cannot rely on the contents of this bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">You have to set
it up yourself before performing any calculations with
it.</p>

<p style="margin-left:14%; margin-top: 1em">Currently the
contents of this bit vector are modified by the two methods
&quot;<i>delta_workdays()</i>&quot; and
&quot;<i>add_delta_workdays()</i>&quot;, in ways which are
hard to predict (depending on the calculations being
performed).</p>

<p style="margin-left:14%; margin-top: 1em">The size of
this bit vector can be determined through either
&quot;<tt>&quot;$days =
$vector&minus;&gt;Size();&quot;</tt>&quot; or
&quot;<tt>&quot;$days =
$year&minus;&gt;val_days();&quot;</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>&quot;$size =
$year&minus;&gt;val_days();&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns the number of days in the given year object, i.e.,
either 365 or 366. This is also the size (number of bits) of
the three bit vectors contained in the given year
object.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>&quot;$base =
$year&minus;&gt;val_base();&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns the value of the expression
&quot;<tt>&quot;Date_to_Days($year&minus;&gt;val_year(),1,1)&quot;</tt>&quot;,
or in other words, the number of days between January 1st of
the year 1 and January 1st of the given year, plus one.</p>

<p style="margin-left:14%; margin-top: 1em">This value is
used internally by the method
&quot;<i>date2index()</i>&quot; in order to calculate the
&quot;julian&quot; date or day of the year for a given
date.</p>

<p style="margin-left:14%; margin-top: 1em">The expression
above is computed only once in method
&quot;<i>init()</i>&quot; and then stored in one of the year
object&rsquo;s attributes, of which this method just returns
the value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;$number =
$year&minus;&gt;val_year();&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$number
= $year&minus;&gt;year();&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">These two
methods are identical, the latter being a shortcut of the
former.</p>

<p style="margin-left:14%; margin-top: 1em">They return the
number of the year for which a calendar has been stored in
the given year object.</p>

<p style="margin-left:14%; margin-top: 1em">The method name
&quot;<i>val_year()</i>&quot; is used here in order to be
consistent with the other attribute accessor methods of this
class, and the method &quot;<i>year()</i>&quot; is necessary
in order to be able to pass Date::Calendar::Year objects as
parameters instead of a year number in the methods of the
Date::Calendar and Date::Calendar::Year modules.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;@names =
$year&minus;&gt;labels(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;@holidays
= $year&minus;&gt;labels();&quot;</tt></p>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$holidays
= $year&minus;&gt;labels();&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">If any
arguments are given, they are supposed to represent a date.
In that case, a list of all labels (= names of holidays)
associated with that date are returned. The first item
returned is always the name of the day of week for that
date.</p>

<p style="margin-left:14%; margin-top: 1em">If no arguments
are given, the list of all available labels in the given
year is returned. This list does <b><small>NOT</small></b>
include any names of the days of week (which would be
pointless in this case).</p>

<p style="margin-left:14%; margin-top: 1em">In list
context, the resulting list itself is returned. In scalar
context, the number of items in the resulting list is
returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>&quot;@dates =
$year&minus;&gt;search(PATTERN);&quot;</tt></p> </td>
<td width="34%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$dates
= $year&minus;&gt;search(PATTERN);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
searches through all the labels of the given year and
returns a list of date objects with all dates whose labels
match the given pattern.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
is a simple, case-insensitive substring search,
<b><small>NOT</small></b> a full-fledged regular expression
search!</p>

<p style="margin-left:14%; margin-top: 1em">The result is
guaranteed to be sorted chronologically.</p>

<p style="margin-left:14%; margin-top: 1em">In scalar
context, only the number of items in the resulting list is
returned, instead of the resulting list itself (as in list
context).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em"><tt>&quot;$hashref =
$year&minus;&gt;tags(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$hashref
= $year&minus;&gt;tags(INDEX);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
returns a hash reference for the given calendar and date (or
index). The hash it refers to is a copy of the calendar
profile&rsquo;s internal hash which contains the names for
the given date as keys and 0, 1, 2, or 3 as their
corresponding values meaning the following:</p>

<pre style="margin-left:14%; margin-top: 1em">    0    =&gt;    commemorative day
    1    =&gt;    &quot;half&quot; holiday
    2    =&gt;    &quot;full&quot; holiday
    3    =&gt;    both a &quot;half&quot; and a &quot;full&quot; holiday</pre>


<p style="margin-left:14%; margin-top: 1em">The value
&quot;3&quot; should only occur if a date has been redefined
by the underlying profile using the same key (i.e., the same
name) but with a different type of holiday.</p>

<p style="margin-left:14%; margin-top: 1em">The index must
be a number such as returned by the method
&quot;<i>date2index()</i>&quot;; it can be used here instead
of a date or a date object in order to speed up processing
(= no need to calculate it internally).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;$days =
$year&minus;&gt;delta_workdays(YEAR,MONTH1,DAY1,
YEAR,MONTH2,DAY2, FLAG1,FLAG2);&quot;</tt></p></td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;$days
=
$year&minus;&gt;delta_workdays(DATE1,DATE2,FLAG1,FLAG2);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method
calculates the number of work days (i.e., the number of
days, but excluding all holidays) between two dates.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
this method is equivalent to the
&quot;<i>Delta_Days()</i>&quot; function of the Date::Calc
module, except that it disregards holidays in its
counting.</p>

<p style="margin-left:14%; margin-top: 1em">The two flags
indicate whether the start and end dates should be included
in the counting (that is, of course, only in case they
aren&rsquo;t holidays), or not.</p>

<p style="margin-left:14%; margin-top: 1em">It is common,
for example, that you want to know how many work days are
left between the current date and a given deadline.</p>

<p style="margin-left:14%; margin-top: 1em">Typically, you
will want to count the current date but not the
deadline&rsquo;s date. So you would specify &quot;true&quot;
(&quot;1&quot;) for <small>FLAG1</small> and
&quot;false&quot; (&quot;0&quot;) for <small>FLAG2</small>
in order to achieve that.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
a value of &quot;true&quot; means &quot;including this
date&quot;, a value of &quot;false&quot; means
&quot;excluding this date&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">As with the
&quot;<i>Delta_Days()</i>&quot; function from the Date::Calc
module, the dates have to be given in chronological order to
yield a positive result. If the dates are reversed, the
result will be negative.</p>

<p style="margin-left:14%; margin-top: 1em">The parameter
<small>FLAG1</small> is associated with the first given
date, the parameter <small>FLAG2</small> with the second
given date (regardless of whether the dates are in
chronological order or not).</p>

<p style="margin-left:14%; margin-top: 1em">An exception
(&quot;given year != object&rsquo;s year&quot;) is thrown if
the year number of either of the two given dates does not
match the year number associated with the given year
object.</p>

<p style="margin-left:14%; margin-top: 1em">An exception
(&quot;invalid date&quot;) is also raised if either of the
two date arguments does not constitute a valid date.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($date,$rest,$sign) =
$year&minus;&gt;add_delta_workdays(YEAR,MONTH,DAY, DELTA,
SIGN);&quot;</tt></p> </td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><tt>&quot;($date,$rest,$sign)
=
$year&minus;&gt;add_delta_workdays(DATE,DELTA,SIGN);&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">This method is
the equivalent of the &quot;<i>Add_Delta_Days()</i>&quot;
function from the Date::Calc module, except that it adds
work days and skips holidays.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
you can add or subtract a number of work days &quot;
<small>DELTA&quot;</small> to/from a given date and get a
new date as the result (as a Date::Calc object).</p>

<p style="margin-left:14%; margin-top: 1em">You add days
(i.e., you go forward in time) with a positive offset &quot;
<small>DELTA&quot;,</small> and you subtract days (i.e., you
go backwards in time) with a negative offset.</p>

<p style="margin-left:14%; margin-top: 1em">Note that an
exception (&quot;invalid date&quot;) is raised if the given
date argument (the &quot;start&quot; date) does not
constitute a valid date.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that
this method is limited to date calculations within a single
year (in contrast to the method with the same name from the
Date::Calendar module).</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, the
method does not only return a date (object), but also a
&quot;rest&quot; and a &quot;sign&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;rest&quot; indicates how many days are still left from
your original <small>DELTA</small> after going in the
desired direction and reaching a year boundary.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;sign&quot; indicates in which direction (future or
past) one needs to go in order to &quot;eat up&quot; the
&quot;rest&quot; (by subtracting a day from the
&quot;rest&quot; for each work day passed), or to adjust the
resulting date (in order to skip any holidays directly after
a year boundary), if at all.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;sign&quot; is &minus;1 for going backwards in time, +1
for going forward, and 0 if the result doesn&rsquo;t need
any more fixing (for instance because the result lies in the
same year as the starting date).</p>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<i>add_delta_workdays()</i>&quot; from the
Date::Calendar module uses the &quot;rest&quot; and
&quot;sign&quot; return values from this method in order to
perform calculations which may cross year boundaries.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, it
is not recommended to use this method here directly, as it
is rather clumsy to use, but to use the method with the same
name from the Date::Calendar module instead, which does the
same but is much easier to use and moreover allows
calculations which cross an arbitrary number of year
boundaries.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that this method may currently return unexpected (i.e.,
contradicting the above documentation) or plain wrong
results when going back in time (this is a bug!).</p>

<p style="margin-left:14%; margin-top: 1em">However, it
works correctly and as documented above when going forward
in time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$flag =
$year&minus;&gt;is_full(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns &quot;true&quot; (&quot;1&quot;) if the bit
corresponding to the given date is set in the bit vector
representing &quot;full&quot; holidays, and
&quot;false&quot; (&quot;0&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., the
method returns &quot;true&quot; if the given date is a
(full) holiday (according to the calendar profile associated
with the given year object).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$flag =
$year&minus;&gt;is_half(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns &quot;true&quot; (&quot;1&quot;) if the bit
corresponding to the given date is set in the bit vector
representing &quot;half&quot; holidays, and
&quot;false&quot; (&quot;0&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., the
method returns &quot;true&quot; if the given date is a half
holiday (according to the calendar profile associated with
the given year object).</p>

<p style="margin-left:14%; margin-top: 1em">Note that if a
date is a &quot;full&quot; holiday, the &quot;half&quot; bit
is never set, even if you try to do so in your calendar
profile, on purpose or by accident.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$flag =
$year&minus;&gt;is_work(YEAR,MONTH,DAY|DATE);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
returns &quot;true&quot; (&quot;1&quot;) if the bit
corresponding to the given date is set in the bit vector
used to perform all sorts of calculations, and
&quot;false&quot; (&quot;0&quot;) otherwise.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that the &quot;work&quot; in this method&rsquo;s name does
<b><small>NOT</small></b> come from &quot;work
days&quot;!</p>

<p style="margin-left:14%; margin-top: 1em">It comes from
the fact that the corresponding bit vector can be used for
any &quot;work&quot; that you need to do. In other words,
it&rsquo;s a &quot;work space&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, this
bit vector might contain about everything you could imagine
&minus; including a bit pattern which marks all &quot;work
days&quot; with set bits, if it so happens!</p>

<p style="margin-left:14%; margin-top: 1em">But you better
don&rsquo;t rely on it, unless you put the bit pattern there
yourself in the first place.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
can get a reference to this bit vector (in order to fill it
with any bit pattern you like) using the method
&quot;<i>vec_work()</i>&quot;, described further above in
this document.</p>

<p style="margin-left:14%; margin-top: 1em">The number of
bits in this bit vector is the same as the number of days in
the given year &quot;<tt>$year</tt>&quot;, which you can
retrieve through either &quot;<tt>&quot;$days =
$year&minus;&gt;vec_work&minus;&gt;Size();&quot;</tt>&quot;
or &quot;<tt>&quot;$days =
$year&minus;&gt;val_days();&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">See also
<i>Bit::Vector</i>(3) for more details.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Bit::Vector</i>(3),
<i>Date::Calendar</i>(3),
<i>Date::Calendar::Profiles</i>(3),
<i>Date::Calc::Object</i>(3), <i>Date::Calc</i>(3),
<i>Date::Calc::Util</i>(3).</p>

<h2>KNOWN BUGS
<a name="KNOWN BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The method
&quot;<i>add_delta_workdays()</i>&quot; is known to produce
results which are sometimes off by one working day when a
negative offset is used. As a workaround, try to add one
working day first and then subtract one working day more
than initially intended. See also the file
&quot;examples/bug.pl&quot; for how to do this.</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This man page
documents &quot;Date::Calendar::Year&quot; version 6.3.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>


<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2000 &minus; 2009 by Steffen Beyer. All rights reserved.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
free software; you can use, modify and redistribute it under
the same terms as Perl itself, i.e., at your option, under
the terms either of the &quot;Artistic License&quot; or the
&quot; <small>GNU</small> General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The C library
at the core of the module &quot;Date::Calc::XS&quot; can, at
your discretion, also be used, modified and redistributed
under the terms of the &quot; <small>GNU</small> Library
General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the files &quot;Artistic.txt&quot;, &quot;
<small>GNU_GPL</small> .txt&quot; and &quot;
<small>GNU_LGPL</small> .txt&quot; in the
&quot;license&quot; subdirectory of this distribution for
any details!</p>

<h2>DISCLAIMER
<a name="DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">See the &quot;
<small>GNU</small> General Public License&quot; for more
details.</p>
<hr>
</body>
</html>
