<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:04:10 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Params::Validate</title>

</head>
<body>

<h1 align="center">Params::Validate</h1>

<a href="#NAME">NAME</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PARAMETER VALIDATION">PARAMETER VALIDATION</a><br>
<a href="#USAGE NOTES">USAGE NOTES</a><br>
<a href="#&quot;GLOBAL&quot; OPTIONS">&quot;GLOBAL&quot; OPTIONS</a><br>
<a href="#PER-INVOCATION OPTIONS">PER-INVOCATION OPTIONS</a><br>
<a href="#DISABLING VALIDATION">DISABLING VALIDATION</a><br>
<a href="#LIMITATIONS">LIMITATIONS</a><br>
<a href="#SUPPORT">SUPPORT</a><br>
<a href="#DONATIONS">DONATIONS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Params::Validate
&minus; Validate method/function parameters</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">version
1.08</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Params::Validate qw(:all);
    # takes named params (hash or hashref)
    sub foo {
        validate(
            @_, {
                foo =&gt; 1,    # mandatory
                bar =&gt; 0,    # optional
            }
        );
    }
    # takes positional params
    sub bar {
        # first two are mandatory, third is optional
        validate_pos( @_, 1, 1, 0 );
    }
    sub foo2 {
        validate(
            @_, {
                foo =&gt;
                    # specify a type
                    { type =&gt; ARRAYREF },
                bar =&gt;
                    # specify an interface
                    { can =&gt; [ 'print', 'flush', 'frobnicate' ] },
                baz =&gt; {
                    type      =&gt; SCALAR,     # a scalar ...
                                             # ... that is a plain integer ...
                    regex     =&gt; qr/^\d+$/,
                    callbacks =&gt; {           # ... and smaller than 90
                        'less than 90' =&gt; sub { shift() &lt; 90 },
                    },
                }
            }
        );
    }
    sub with_defaults {
        my %p = validate(
            @_, {
                # required
                foo =&gt; 1,
                # $p{bar} will be 99 if bar is not given.  bar is now
                # optional.
                bar =&gt; { default =&gt; 99 }
            }
        );
    }
    sub pos_with_defaults {
        my @p = validate_pos( @_, 1, { default =&gt; 99 } );
    }
    sub sets_options_on_call {
        my %p = validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR, default =&gt; 2 } },
            normalize_keys =&gt; sub { $_[0] =~ s/^&minus;//; lc $_[0] },
        );
    }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
Params::Validate module allows you to validate method or
function call parameters to an arbitrary level of
specificity. At the simplest level, it is capable of
validating the required parameters were given and that no
unspecified additional parameters were passed in.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
capable of determining that a parameter is of a specific
type, that it is an object of a certain class hierarchy,
that it possesses certain methods, or applying validation
callbacks to arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EXPORT</small></b>
<br>
The module always exports the
<tt>&quot;validate()&quot;</tt> and
<tt>&quot;validate_pos()&quot;</tt> functions.</p>

<p style="margin-left:11%; margin-top: 1em">It also has an
additional function available for export,
<tt>&quot;validate_with&quot;</tt>, which can be used to
validate any type of parameters, and set various options on
a per-invocation basis.</p>

<p style="margin-left:11%; margin-top: 1em">In addition, it
can export the following constants, which are used as part
of the type checking. These are <tt>&quot;SCALAR&quot;</tt>,
<tt>&quot;ARRAYREF&quot;</tt>, <tt>&quot;HASHREF&quot;</tt>,
<tt>&quot;CODEREF&quot;</tt>, <tt>&quot;GLOB&quot;</tt>,
<tt>&quot;GLOBREF&quot;</tt>, and
<tt>&quot;SCALARREF&quot;</tt>, <tt>&quot;UNDEF&quot;</tt>,
<tt>&quot;OBJECT&quot;</tt>, <tt>&quot;BOOLEAN&quot;</tt>,
and <tt>&quot;HANDLE&quot;</tt>. These are explained in the
section on Type Validation.</p>

<p style="margin-left:11%; margin-top: 1em">The constants
are available via the export tag
<tt>&quot;:types&quot;</tt>. There is also an
<tt>&quot;:all&quot;</tt> tag which includes all of the
constants as well as the
<tt>&quot;validation_options()&quot;</tt> function.</p>

<h2>PARAMETER VALIDATION
<a name="PARAMETER VALIDATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The validation
mechanisms provided by this module can handle both named or
positional parameters. For the most part, the same features
are available for each. The biggest difference is the way
that the validation specification is given to the relevant
subroutine. The other difference is in the error messages
produced when validation checks fail.</p>

<p style="margin-left:11%; margin-top: 1em">When handling
named parameters, the module will accept either a hash or a
hash reference.</p>

<p style="margin-left:11%; margin-top: 1em">Subroutines
expecting named parameters should call the
<tt>&quot;validate()&quot;</tt> subroutine like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            parameter1 =&gt; validation spec,
            parameter2 =&gt; validation spec,
            ...
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">Subroutines
expecting positional parameters should call the
<tt>&quot;validate_pos()&quot;</tt> subroutine like
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos( @_, { validation spec }, { validation spec } );</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Mandatory/Optional
Parameters</b> <br>
If you just want to specify that some parameters are
mandatory and others are optional, this can be done very
simply.</p>

<p style="margin-left:11%; margin-top: 1em">For a
subroutine expecting named parameters, you would do
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate( @_, { foo =&gt; 1, bar =&gt; 1, baz =&gt; 0 } );</pre>


<p style="margin-left:11%; margin-top: 1em">This says that
the &quot;foo&quot; and &quot;bar&quot; parameters are
mandatory and that the &quot;baz&quot; parameter is
optional. The presence of any other parameters will cause an
error.</p>

<p style="margin-left:11%; margin-top: 1em">For a
subroutine expecting positional parameters, you would do
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos( @_, 1, 1, 0, 0 );</pre>


<p style="margin-left:11%; margin-top: 1em">This says that
you expect at least 2 and no more than 4 parameters. If you
have a subroutine that has a minimum number of parameters
but can take any maximum number, you can do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos( @_, 1, 1, (0) x (@_ &minus; 2) );</pre>


<p style="margin-left:11%; margin-top: 1em">This will
always be valid as long as at least two parameters are
given. A similar construct could be used for the more
complex validation parameters described further on.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos( @_, 1, 1, 0, 1, 1 );</pre>


<p style="margin-left:11%; margin-top: 1em">makes
absolutely no sense, so don&rsquo;t do it. Any zeros must
come at the end of the validation specification.</p>

<p style="margin-left:11%; margin-top: 1em">In addition, if
you specify that a parameter can have a default, then it is
considered optional.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Type
Validation</b> <br>
This module supports the following simple types, which can
be exported as constants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p><small>SCALAR</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A scalar which
is not a reference, such as <tt>10</tt> or <tt>'hello'</tt>.
A parameter that is undefined is <b>not</b> treated as a
scalar. If you want to allow undefined values, you will have
to specify <tt>&quot;SCALAR | UNDEF&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p style="margin-top: 1em"><small>ARRAYREF</small></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An array
reference such as <tt>&quot;[1, 2, 3]&quot;</tt> or
<tt>&quot;\@foo&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>HASHREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A hash
reference such as <tt>&quot;{ a =&gt; 1, b =&gt; 2
}&quot;</tt> or <tt>&quot;\%bar&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>CODEREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A subroutine
reference such as <tt>&quot;\&amp;foo_sub&quot;</tt> or
<tt>&quot;sub { print &quot;hello&quot; }&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>GLOB</small></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This one is a
bit tricky. A glob would be something like <tt>*FOO</tt>,
but not <tt>&quot;\*FOO&quot;</tt>, which is a glob
reference. It should be noted that this trick:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $fh = do { local *FH; };</pre>


<p style="margin-left:17%; margin-top: 1em">makes
<tt>$fh</tt> a glob, not a glob reference. On the other
hand, the return value from
<tt>&quot;Symbol::gensym&quot;</tt> is a glob reference.
Either can be used as a file or directory handle.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>GLOBREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A glob
reference such as <tt>&quot;\*FOO&quot;</tt>. See the
<small>GLOB</small> entry above for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em"><small>SCALARREF</small></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A reference to
a scalar such as <tt>&quot;\$x&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><small>UNDEF</small></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An undefined
value</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><small>OBJECT</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A blessed
reference.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>BOOLEAN</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is a
special option, and is just a shortcut for <tt>&quot;UNDEF |
SCALAR&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><small>HANDLE</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option is
also special, and is just a shortcut for <tt>&quot;GLOB |
GLOBREF&quot;</tt>. However, it seems likely that most
people interested in either globs or glob references are
likely to really be interested in whether the parameter in
question could be a valid file or directory handle.</p>

<p style="margin-left:11%; margin-top: 1em">To specify that
a parameter must be of a given type when using named
parameters, do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; HASHREF }
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">If a parameter
can be of more than one type, just use the bitwise or
(<tt>&quot;|&quot;</tt>) operator to combine them.</p>

<pre style="margin-left:11%; margin-top: 1em">    validate( @_, { foo =&gt; { type =&gt; GLOB | GLOBREF } );</pre>


<p style="margin-left:11%; margin-top: 1em">For positional
parameters, this can be specified as follows:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos( @_, { type =&gt; SCALAR | ARRAYREF }, { type =&gt; CODEREF } );</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Interface
Validation</b> <br>
To specify that a parameter is expected to have a certain
set of methods, we can do the following:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            foo =&gt;
                # just has to be able to &minus;&gt;bar
                { can =&gt; 'bar' }
        }
    );
 ... or ...
    validate(
        @_, {
            foo =&gt;
                # must be able to &minus;&gt;bar and &minus;&gt;print
                { can =&gt; [qw( bar print )] }
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Class
Validation</b> <br>
A word of warning. When constructing your external
interfaces, it is probably better to specify what methods
you expect an object to have rather than what class it
should be of (or a child of). This will make your
<small>API</small> much more flexible.</p>

<p style="margin-left:11%; margin-top: 1em">With that said,
if you want to validate that an incoming parameter belongs
to a class (or child class) or classes, do:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_,
        { foo =&gt; { isa =&gt; 'My::Frobnicator' } }
    );
 ... or ...
    validate(
        @_,
        # must be both, not either!
        { foo =&gt; { isa =&gt; [qw( My::Frobnicator IO::Handle )] } }
    );</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Regex
Validation</b> <br>
If you want to specify that a given parameter must match a
specific regular expression, this can be done with
&quot;regex&quot; spec key. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_,
        { foo =&gt; { regex =&gt; qr/^\d+$/ } }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">The value of
the &quot;regex&quot; key may be either a string or a
pre-compiled regex created via <tt>&quot;qr&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If the value
being checked against a regex is undefined, the regex is
explicitly checked against the empty string (&rsquo;&rsquo;)
instead, in order to avoid &quot;Use of uninitialized
value&quot; warnings.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;Regexp::Common&quot;</tt> module on
<small>CPAN</small> is an excellent source of regular
expressions suitable for validating input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Callback
Validation</b> <br>
If none of the above are enough, it is possible to pass in
one or more callbacks to validate the parameter. The
callback will be given the <b>value</b> of the parameter as
its first argument. Its second argument will be all the
parameters, as a reference to either a hash or array.
Callbacks are specified as hash reference. The key is an id
for the callback (used in error messages) and the value is a
subroutine reference, such as:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'smaller than a breadbox' =&gt; sub { shift() &lt; $breadbox },
                    'green or blue' =&gt;
                        sub { $_[0] eq 'green' || $_[0] eq 'blue' }
                }
            }
        );
    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'bigger than baz' =&gt; sub { $_[0] &gt; $_[1]&minus;&gt;{baz} }
                }
            }
        }
    );</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Untainting</b>
<br>
If you want values untainted, set the &quot;untaint&quot;
key in a spec hashref to a true value, like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    my %p = validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR, untaint =&gt; 1 },
            bar =&gt; { type =&gt; ARRAYREF }
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">This will
untaint the &quot;foo&quot; parameter if the parameters are
valid.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
untainting is only done if <i>all parameters</i> are valid.
Also, only the return values are untainted, not the original
values passed into the validation function.</p>

<p style="margin-left:11%; margin-top: 1em">Asking for
untainting of a reference value will not do anything, as
<tt>&quot;Params::Validate&quot;</tt> will only attempt to
untaint the reference itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Mandatory/Optional
Revisited</b> <br>
If you want to specify something such as type or interface,
plus the fact that a parameter can be optional, do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; ARRAYREF, optional =&gt; 1 }
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">or this for
positional parameters:</p>

<pre style="margin-left:11%; margin-top: 1em">    validate_pos(
        @_,
        { type =&gt; SCALAR },
        { type =&gt; ARRAYREF, optional =&gt; 1 }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">By default,
parameters are assumed to be mandatory unless specified as
optional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Dependencies</b>
<br>
It also possible to specify that a given optional parameter
depends on the presence of one or more other optional
parameters.</p>

<pre style="margin-left:11%; margin-top: 1em">    validate(
        @_, {
            cc_number =&gt; {
                type     =&gt; SCALAR,
                optional =&gt; 1,
                depends  =&gt; [ 'cc_expiration', 'cc_holder_name' ],
            },
            cc_expiration  { type =&gt; SCALAR, optional =&gt; 1 },
            cc_holder_name { type =&gt; SCALAR, optional =&gt; 1 },
        }
    );</pre>


<p style="margin-left:11%; margin-top: 1em">In this case,
&quot;cc_number&quot;, &quot;cc_expiration&quot;, and
&quot;cc_holder_name&quot; are all optional. However, if
&quot;cc_number&quot; is provided, then
&quot;cc_expiration&quot; and &quot;cc_holder_name&quot;
must be provided as well.</p>

<p style="margin-left:11%; margin-top: 1em">This allows you
to group together sets of parameters that all must be
provided together.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;validate_pos()&quot;</tt> version of dependencies
is slightly different, in that you can only depend on one
other parameter. Also, if for example, the second parameter
2 depends on the fourth parameter, then it implies a
dependency on the third parameter as well. This is because
if the fourth parameter is required, then the user must also
provide a third parameter so that there can be four
parameters in total.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;Params::Validate&quot;</tt>
will die if you try to depend on a parameter not declared as
part of your parameter specification.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Specifying
defaults</b> <br>
If the <tt>&quot;validate()&quot;</tt> or
<tt>&quot;validate_pos()&quot;</tt> functions are called in
a list context, they will return a hash or containing the
original parameters plus defaults as indicated by the
validation spec.</p>

<p style="margin-left:11%; margin-top: 1em">If the function
is not called in a list context, providing a default in the
validation spec still indicates that the parameter is
optional.</p>

<p style="margin-left:11%; margin-top: 1em">The hash or
array returned from the function will always be a copy of
the original parameters, in order to leave <tt>@_</tt>
untouched for the calling function.</p>

<p style="margin-left:11%; margin-top: 1em">Simple examples
of defaults would be:</p>

<pre style="margin-left:11%; margin-top: 1em">    my %p = validate( @_, { foo =&gt; 1, bar =&gt; { default =&gt; 99 } } );
    my @p = validate_pos( @_, 1, { default =&gt; 99 } );</pre>


<p style="margin-left:11%; margin-top: 1em">In scalar
context, a hash reference or array reference will be
returned, as appropriate.</p>

<h2>USAGE NOTES
<a name="USAGE NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Validation
failure</b> <br>
By default, when validation fails
<tt>&quot;Params::Validate&quot;</tt> calls
<tt>&quot;Carp::confess()&quot;</tt>. This can be overridden
by setting the <tt>&quot;on_fail&quot;</tt> option, which is
described in the &quot; <small>GLOBAL&quot; OPTIONS</small>
section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Method
calls</b> <br>
When using this module to validate the parameters passed to
a method call, you will probably want to remove the
class/object from the parameter list <b>before</b> calling
<tt>&quot;validate()&quot;</tt> or
<tt>&quot;validate_pos()&quot;</tt>. If your method expects
named parameters, then this is necessary for the
<tt>&quot;validate()&quot;</tt> function to actually work,
otherwise <tt>@_</tt> will not be usable as a hash, because
it will first have your object (or class) <b>followed</b> by
a set of keys and values.</p>

<p style="margin-left:11%; margin-top: 1em">Thus the
idiomatic usage of <tt>&quot;validate()&quot;</tt> in a
method call will look something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">    sub method {
        my $self = shift;
        my %params = validate(
            @_, {
                foo =&gt; 1,
                bar =&gt; { type =&gt; ARRAYREF },
            }
        );
    }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Speeding Up
Validation</b> <br>
In most cases, the validation spec will remain the same for
each call to a subroutine. In that case, you can speed up
validation by defining the validation spec just once, rather
than on each call to the subroutine:</p>

<pre style="margin-left:11%; margin-top: 1em">    my %spec = ( ... );
    sub foo {
        my %params = validate( @_, \%spec );
    }</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
use the <tt>&quot;state&quot;</tt> feature to do this:</p>

<pre style="margin-left:11%; margin-top: 1em">    use feature 'state';
    sub foo {
        state $spec = { ... };
        my %params = validate( @_, $spec );
    }</pre>


<h2>&quot;GLOBAL&quot; OPTIONS
<a name="&quot;GLOBAL&quot; OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Because the
<small>API</small> for the <tt>&quot;validate()&quot;</tt>
and <tt>&quot;validate_pos()&quot;</tt> functions does not
make it possible to specify any options other than the
validation spec, it is possible to set some options as
pseudo&minus;&rsquo;globals&rsquo;. These allow you to
specify such things as whether or not the validation of
named parameters should be case sensitive, for one
example.</p>

<p style="margin-left:11%; margin-top: 1em">These options
are called pseudo&minus;&rsquo;globals&rsquo; because these
settings are <b>only applied to calls originating from the
package that set the options</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
if I am in package <tt>&quot;Foo&quot;</tt> and I call
<tt>&quot;validation_options()&quot;</tt>, those options are
only in effect when I call <tt>&quot;validate()&quot;</tt>
from package <tt>&quot;Foo&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">While this is
quite different from how most other modules operate, I feel
that this is necessary in able to make it possible for one
module/application to use Params::Validate while still using
other modules that also use Params::Validate, perhaps with
different options set.</p>

<p style="margin-left:11%; margin-top: 1em">The downside to
this is that if you are writing an app with a standard
calling style for all functions, and your app has ten
modules, <b>each module must include a call to
&quot;validation_options()&quot;</b>. You could of course
write a module that all your modules use which uses various
trickery to do this when imported.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">


<p style="margin-top: 1em">normalize_keys =&gt;
<tt>$callback</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option is
only relevant when dealing with named parameters.</p>

<p style="margin-left:17%; margin-top: 1em">This callback
will be used to transform the hash keys of both the
parameters and the parameter spec when
<tt>&quot;validate()&quot;</tt> or
<tt>&quot;validate_with()&quot;</tt> are called.</p>

<p style="margin-left:17%; margin-top: 1em">Any alterations
made by this callback will be reflected in the parameter
hash that is returned by the validation function. For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">    sub foo {
        return validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR } },
            normalize_keys =&gt;
                sub { my $k = shift; $k =~ s/^&minus;//; return uc $k },
        );
    }
    %p = foo( foo =&gt; 20 );
    # $p{FOO} is now 20
    %p = foo( &minus;fOo =&gt; 50 );
    # $p{FOO} is now 50</pre>


<p style="margin-left:17%; margin-top: 1em">The callback
must return a defined value.</p>

<p style="margin-left:17%; margin-top: 1em">If a callback
is given then the deprecated &quot;ignore_case&quot; and
&quot;strip_leading&quot; options are ignored.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">allow_extra =&gt;
<tt>$boolean</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If true, then
the validation routine will allow extra parameters not named
in the validation specification. In the case of positional
parameters, this allows an unlimited number of maximum
parameters (though a minimum may still be set). Defaults to
false.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="31%">


<p style="margin-top: 1em">on_fail =&gt;
<tt>$callback</tt></p> </td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If given, this
callback will be called whenever a validation check fails.
It will be called with a single parameter, which will be a
string describing the failure. This is useful if you wish to
have this module throw exceptions as objects rather than as
strings, for example.</p>

<p style="margin-left:17%; margin-top: 1em">This callback
is expected to <tt>&quot;die()&quot;</tt> internally. If it
does not, the validation will proceed onwards, with
unpredictable results.</p>

<p style="margin-left:17%; margin-top: 1em">The default is
to simply use the Carp module&rsquo;s
<tt>&quot;confess()&quot;</tt> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="32%">


<p style="margin-top: 1em">stack_skip =&gt;
<tt>$number</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This tells
Params::Validate how many stack frames to skip when finding
a subroutine name to use in error messages. By default, it
looks one frame back, at the immediate caller to
<tt>&quot;validate()&quot;</tt> or
<tt>&quot;validate_pos()&quot;</tt>. If this option is set,
then the given number of frames are skipped instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">ignore_case =&gt;
<tt>$boolean</tt></p> </td>
<td width="48%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>DEPRECATED</small></p>

<p style="margin-left:17%; margin-top: 1em">This is only
relevant when dealing with named parameters. If it is true,
then the validation code will ignore the case of parameter
names. Defaults to false.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">strip_leading =&gt;
<tt>$characters</tt></p> </td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>DEPRECATED</small></p>

<p style="margin-left:17%; margin-top: 1em">This too is
only relevant when dealing with named parameters. If this is
given then any parameters starting with these characters
will be considered equivalent to parameters without them
entirely. For example, if this is specified as
&rsquo;&minus;&rsquo;, then <tt>&quot;&minus;foo&quot;</tt>
and <tt>&quot;foo&quot;</tt> would be considered
identical.</p>

<h2>PER-INVOCATION OPTIONS
<a name="PER-INVOCATION OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;validate_with()&quot;</tt> function can be used to
set the options listed above on a per-invocation basis. For
example:</p>

<pre style="margin-left:11%; margin-top: 1em">    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
    );</pre>


<p style="margin-left:11%; margin-top: 1em">In addition to
the options listed above, it is also possible to set the
option &quot;called&quot;, which should be a string. This
string will be used in any error messages caused by a
failure to meet the validation spec.</p>

<p style="margin-left:11%; margin-top: 1em">This subroutine
will validate named parameters as a hash if the
&quot;spec&quot; parameter is a hash reference. If it is an
array reference, the parameters are assumed to be
positional.</p>

<pre style="margin-left:11%; margin-top: 1em">    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );
    my @p = validate_with(
        params =&gt; \@_,
        spec   =&gt; [
            { type    =&gt; SCALAR },
            { default =&gt; 10 }
        ],
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );</pre>


<h2>DISABLING VALIDATION
<a name="DISABLING VALIDATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the
environment variable <tt>&quot;PERL_NO_VALIDATION&quot;</tt>
is set to something true, then validation is turned off.
This may be useful if you only want to use this module
during development but don&rsquo;t want the speed hit during
production.</p>

<p style="margin-left:11%; margin-top: 1em">The only error
that will be caught will be when an odd number of parameters
are passed into a function/method that expects a hash.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
selectively turn validation on and off at runtime, you can
directly set the <tt>$Params::Validate::NO_VALIDATION</tt>
global variable. It is <b>strongly</b> recommended that you
<b>localize</b> any changes to this variable, because other
modules you are using may expect validation to be on when
they execute. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">    {
        local $Params::Validate::NO_VALIDATION = 1;
        # no error
        foo( bar =&gt; 2 );
    }
    # error
    foo( bar =&gt; 2 );
    sub foo {
        my %p = validate( @_, { foo =&gt; 1 } );
        ...;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">But if you want
to shoot yourself in the foot and just turn it off, go
ahead!</p>

<h2>LIMITATIONS
<a name="LIMITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Right now there
is no way (short of a callback) to specify that something
must be of one of a list of classes, or that it must possess
one of a list of methods. If this is desired, it can be
added in the future.</p>

<p style="margin-left:11%; margin-top: 1em">Ideally, there
would be only one validation function. If someone figures
out how to do this, please let me know.</p>

<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please submit
bugs and patches to the <small>CPAN RT</small> system at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params%3A%3AValidate
or via email at
bug&minus;params&minus;validate@rt.cpan.org.</p>

<p style="margin-left:11%; margin-top: 1em">Support
questions can be sent to Dave at autarch@urth.org.</p>

<h2>DONATIONS
<a name="DONATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;d
like to thank me for the work I&rsquo;ve done on this
module, please consider making a &quot;donation&quot; to me
via PayPal. I spend a lot of free time creating free
software, and would appreciate any support you&rsquo;d care
to offer.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that <b>I am not suggesting that you must do this</b> in
order for me to continue working on this particular
software. I will continue to do so, inasmuch as I have in
the past, for as long as it interests me.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, a
donation made in this way will probably not make me work on
this software much more, unless I get so many donations that
I can consider working on free software full time, which
seems unlikely at best.</p>

<p style="margin-left:11%; margin-top: 1em">To donate, log
into PayPal and send money to autarch@urth.org or use the
button on this page:
&lt;http://www.urth.org/~autarch/fs&minus;donation.html&gt;</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Dave Rolsky,
&lt;autarch@urth.org&gt; and Ilya Martynov
&lt;ilya@martynov.org&gt;</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
is Copyright (c) 2013 by Dave Rolsky and Ilya Martynov.</p>

<p style="margin-left:11%; margin-top: 1em">This is free
software, licensed under:</p>

<pre style="margin-left:11%; margin-top: 1em">  The Artistic License 2.0 (GPL Compatible)</pre>
<hr>
</body>
</html>
