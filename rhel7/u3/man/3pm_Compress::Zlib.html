<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:03:42 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Compress::Zlib</title>

</head>
<body>

<h1 align="center">Compress::Zlib</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#GZIP INTERFACE">GZIP INTERFACE</a><br>
<a href="#COMPRESS/UNCOMPRESS">COMPRESS/UNCOMPRESS</a><br>
<a href="#Deflate Interface">Deflate Interface</a><br>
<a href="#Inflate Interface">Inflate Interface</a><br>
<a href="#CHECKSUM FUNCTIONS">CHECKSUM FUNCTIONS</a><br>
<a href="#Misc">Misc</a><br>
<a href="#CONSTANTS">CONSTANTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#MODIFICATION HISTORY">MODIFICATION HISTORY</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Compress::Zlib
&minus; Interface to zlib compression library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">    use Compress::Zlib ;
    ($d, $status) = deflateInit( [OPT] ) ;
    $status = $d&minus;&gt;deflate($input, $output) ;
    $status = $d&minus;&gt;flush([$flush_type]) ;
    $d&minus;&gt;deflateParams(OPTS) ;
    $d&minus;&gt;deflateTune(OPTS) ;
    $d&minus;&gt;dict_adler() ;
    $d&minus;&gt;crc32() ;
    $d&minus;&gt;adler32() ;
    $d&minus;&gt;total_in() ;
    $d&minus;&gt;total_out() ;
    $d&minus;&gt;msg() ;
    $d&minus;&gt;get_Strategy();
    $d&minus;&gt;get_Level();
    $d&minus;&gt;get_BufSize();
    ($i, $status) = inflateInit( [OPT] ) ;
    $status = $i&minus;&gt;inflate($input, $output [, $eof]) ;
    $status = $i&minus;&gt;inflateSync($input) ;
    $i&minus;&gt;dict_adler() ;
    $d&minus;&gt;crc32() ;
    $d&minus;&gt;adler32() ;
    $i&minus;&gt;total_in() ;
    $i&minus;&gt;total_out() ;
    $i&minus;&gt;msg() ;
    $d&minus;&gt;get_BufSize();
    $dest = compress($source) ;
    $dest = uncompress($source) ;
    $gz = gzopen($filename or filehandle, $mode) ;
    $bytesread = $gz&minus;&gt;gzread($buffer [,$size]) ;
    $bytesread = $gz&minus;&gt;gzreadline($line) ;
    $byteswritten = $gz&minus;&gt;gzwrite($buffer) ;
    $status = $gz&minus;&gt;gzflush($flush) ;
    $offset = $gz&minus;&gt;gztell() ;
    $status = $gz&minus;&gt;gzseek($offset, $whence) ;
    $status = $gz&minus;&gt;gzclose() ;
    $status = $gz&minus;&gt;gzeof() ;
    $status = $gz&minus;&gt;gzsetparams($level, $strategy) ;
    $errstring = $gz&minus;&gt;gzerror() ;
    $gzerrno
    $dest = Compress::Zlib::memGzip($buffer) ;
    $dest = Compress::Zlib::memGunzip($buffer) ;
    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;
    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)
    my $version = Compress::Raw::Zlib::zlib_version();</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>Compress::Zlib</i> module provides a Perl interface to
the <i>zlib</i> compression library (see &quot;
<small>AUTHOR&quot;</small> for details about where to get
<i>zlib</i>).</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;Compress::Zlib&quot;</tt> module can be split into
two general areas of functionality, namely a simple
read/write interface to <i>gzip</i> files and a low-level
in-memory compression/decompression interface.</p>

<p style="margin-left:11%; margin-top: 1em">Each of these
areas will be discussed in the following sections.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Notes for
users of Compress::Zlib version 1</b> <br>
The main change in <tt>&quot;Compress::Zlib&quot;</tt>
version 2.x is that it does not now interface directly to
the zlib library. Instead it uses the
<tt>&quot;IO::Compress::Gzip&quot;</tt> and
<tt>&quot;IO::Uncompress::Gunzip&quot;</tt> modules for
reading/writing gzip files, and the
<tt>&quot;Compress::Raw::Zlib&quot;</tt> module for some
low-level zlib access.</p>

<p style="margin-left:11%; margin-top: 1em">The interface
provided by version 2 of this module should be 100% backward
compatible with version 1. If you find a difference in the
expected behaviour please contact the author (See &quot;
<small>AUTHOR&quot;</small> ). See &quot; <small>GZIP
INTERFACE&quot;</small></p>

<p style="margin-left:11%; margin-top: 1em">With the
creation of the <tt>&quot;IO::Compress&quot;</tt> and
<tt>&quot;IO::Uncompress&quot;</tt> modules no new features
are planned for <tt>&quot;Compress::Zlib&quot;</tt> &minus;
the new modules do everything that
<tt>&quot;Compress::Zlib&quot;</tt> does and then some.
Development on <tt>&quot;Compress::Zlib&quot;</tt> will be
limited to bug fixes only.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
writing new code, your first port of call should be one of
the new <tt>&quot;IO::Compress&quot;</tt> or
<tt>&quot;IO::Uncompress&quot;</tt> modules.</p>

<h2>GZIP INTERFACE
<a name="GZIP INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A number of
functions are supplied in <i>zlib</i> for reading and
writing <i>gzip</i> files that conform to <small>RFC
1952.</small> This module provides an interface to most of
them.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
previously used <tt>&quot;Compress::Zlib&quot;</tt> 1.x, the
following enhancements/changes have been made to the
<tt>&quot;gzopen&quot;</tt> interface:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>If you want to open either <small>STDIN</small> or
<small>STDOUT</small> with <tt>&quot;gzopen&quot;</tt>, you
can now optionally use the special filename
&quot;<tt>&quot;&minus;&quot;</tt>&quot; as a synonym for
<tt>&quot;\*STDIN&quot;</tt> and
<tt>&quot;\*STDOUT&quot;</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>In <tt>&quot;Compress::Zlib&quot;</tt> version 1.x,
<tt>&quot;gzopen&quot;</tt> used the zlib library to open
the underlying file. This made things especially tricky when
a Perl filehandle was passed to <tt>&quot;gzopen&quot;</tt>.
Behind the scenes the numeric C file descriptor had to be
extracted from the Perl filehandle and this passed to the
zlib library.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Apart from
being non-portable to some operating systems, this made it
difficult to use <tt>&quot;gzopen&quot;</tt> in situations
where you wanted to extract/create a gzip data stream that
is embedded in a larger file, without having to resort to
opening and closing the file multiple times.</p>

<p style="margin-left:18%; margin-top: 1em">It also made it
impossible to pass a perl filehandle that wasn&rsquo;t
associated with a real filesystem file, like, say, an
<tt>&quot;IO::String&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">In
<tt>&quot;Compress::Zlib&quot;</tt> version 2.x, the
<tt>&quot;gzopen&quot;</tt> interface has been completely
rewritten to use the IO::Compress::Gzip for writing gzip
files and IO::Uncompress::Gunzip for reading gzip files.
None of the limitations mentioned above apply.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Addition of
<tt>&quot;gzseek&quot;</tt> to provide a restricted
<tt>&quot;seek&quot;</tt> interface.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Added <tt>&quot;gztell&quot;</tt>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A more complete
and flexible interface for reading/writing gzip
files/buffers is included with the module
<tt>&quot;IO&minus;Compress&minus;Zlib&quot;</tt>. See
IO::Compress::Gzip and IO::Uncompress::Gunzip for more
details. <b><br>
$gz = gzopen($filename,</b> <b><i>$mode</i></b><b>) <br>
$gz = gzopen($filehandle,</b>
<b><i>$mode</i></b><b>)</b></p>

<p style="margin-left:18%;">This function opens either the
<i>gzip</i> file <tt>$filename</tt> for reading or writing
or attaches to the opened filehandle, <tt>$filehandle</tt>.
It returns an object on success and
<tt>&quot;undef&quot;</tt> on failure.</p>

<p style="margin-left:18%; margin-top: 1em">When writing a
gzip file this interface will <i>always</i> create the
smallest possible gzip header (exactly 10 bytes). If you
want greater control over what gets stored in the gzip
header (like the original filename or a comment) use
IO::Compress::Gzip instead. Similarly if you want to read
the contents of the gzip header use
IO::Uncompress::Gunzip.</p>

<p style="margin-left:18%; margin-top: 1em">The second
parameter, <tt>$mode</tt>, is used to specify whether the
file is opened for reading or writing and to optionally
specify a compression level and compression strategy when
writing. The format of the <tt>$mode</tt> parameter is
similar to the mode parameter to the &rsquo;C&rsquo;
function <tt>&quot;fopen&quot;</tt>, so &quot;rb&quot; is
used to open for reading, &quot;wb&quot; for writing and
&quot;ab&quot; for appending (writing at the end of the
file).</p>

<p style="margin-left:18%; margin-top: 1em">To specify a
compression level when writing, append a digit between 0 and
9 to the mode string -- 0 means no compression and 9 means
maximum compression. If no compression level is specified
Z_DEFAULT_COMPRESSION is used.</p>

<p style="margin-left:18%; margin-top: 1em">To specify the
compression strategy when writing, append &rsquo;f&rsquo;
for filtered data, &rsquo;h&rsquo; for Huffman only
compression, or &rsquo;R&rsquo; for run-length encoding. If
no strategy is specified Z_DEFAULT_STRATEGY is used.</p>

<p style="margin-left:18%; margin-top: 1em">So, for
example, &quot;wb9&quot; means open for writing with the
maximum compression using the default strategy and
&quot;wb4R&quot; means open for writing with compression
level 4 and run-length encoding.</p>

<p style="margin-left:18%; margin-top: 1em">Refer to the
<i>zlib</i> documentation for the exact format of the
<tt>$mode</tt> parameter.</p>

<p style="margin-left:11%;"><b>$bytesread =</b>
<b><i>$gz</i></b><b>&minus;&gt;gzread($buffer [, $size])
;</b></p>

<p style="margin-left:18%;">Reads <tt>$size</tt> bytes from
the compressed file into <tt>$buffer</tt>. If <tt>$size</tt>
is not specified, it will default to 4096. If the scalar
<tt>$buffer</tt> is not large enough, it will be extended
automatically.</p>

<p style="margin-left:18%; margin-top: 1em">Returns the
number of bytes actually read. On <small>EOF</small> it
returns 0 and in the case of an error, &minus;1.</p>

<p style="margin-left:11%;"><b>$bytesread =</b>
<b><i>$gz</i></b><b>&minus;&gt;gzreadline($line) ;</b></p>

<p style="margin-left:18%;">Reads the next line from the
compressed file into <tt>$line</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">Returns the
number of bytes actually read. On <small>EOF</small> it
returns 0 and in the case of an error, &minus;1.</p>

<p style="margin-left:18%; margin-top: 1em">It is legal to
intermix calls to <tt>&quot;gzread&quot;</tt> and
<tt>&quot;gzreadline&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">To maintain
backward compatibility with version 1.x of this module
<tt>&quot;gzreadline&quot;</tt> ignores the <tt>$/</tt>
variable &minus; it <i>always</i> uses the string
<tt>&quot;\n&quot;</tt> as the line delimiter.</p>

<p style="margin-left:18%; margin-top: 1em">If you want to
read a gzip file a line at a time and have it respect the
<tt>$/</tt> variable (or <tt>$INPUT_RECORD_SEPARATOR</tt>,
or <tt>$RS</tt> when <tt>&quot;English&quot;</tt> is in use)
see IO::Uncompress::Gunzip.</p>

<p style="margin-left:11%;"><b>$byteswritten =</b>
<b><i>$gz</i></b><b>&minus;&gt;gzwrite($buffer) ;</b></p>

<p style="margin-left:18%;">Writes the contents of
<tt>$buffer</tt> to the compressed file. Returns the number
of bytes actually written, or 0 on error.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$gz</i></b><b>&minus;&gt;gzflush($flush_type)
;</b></p>

<p style="margin-left:18%;">Flushes all pending output into
the compressed file.</p>

<p style="margin-left:18%; margin-top: 1em">This method
takes an optional parameter, <tt>$flush_type</tt>, that
controls how the flushing will be carried out. By default
the <tt>$flush_type</tt> used is
<tt>&quot;Z_FINISH&quot;</tt>. Other valid values for
<tt>$flush_type</tt> are <tt>&quot;Z_NO_FLUSH&quot;</tt>,
<tt>&quot;Z_SYNC_FLUSH&quot;</tt>,
<tt>&quot;Z_FULL_FLUSH&quot;</tt> and
<tt>&quot;Z_BLOCK&quot;</tt>. It is strongly recommended
that you only set the <tt>&quot;flush_type&quot;</tt>
parameter if you fully understand the implications of what
it does &minus; overuse of <tt>&quot;flush&quot;</tt> can
seriously degrade the level of compression achieved. See the
<tt>&quot;zlib&quot;</tt> documentation for details.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success.</p>

<p style="margin-left:11%;"><b>$offset =</b>
<b><i>$gz</i></b><b>&minus;&gt;</b><b><i>gztell()</i></b>
<b>;</b></p>

<p style="margin-left:18%;">Returns the uncompressed file
offset.</p>

<p style="margin-left:11%;"><b>$status =</b>
<b><i>$gz</i></b><b>&minus;&gt;gzseek($offset, $whence)
;</b></p>

<p style="margin-left:18%;">Provides a sub-set of the
<tt>&quot;seek&quot;</tt> functionality, with the
restriction that it is only legal to seek forward in the
compressed file. It is a fatal error to attempt to seek
backward.</p>

<p style="margin-left:18%; margin-top: 1em">When opened for
writing, empty parts of the file will have
<small>NULL</small> (0x00) bytes written to them.</p>

<p style="margin-left:18%; margin-top: 1em">The
<tt>$whence</tt> parameter should be one of <small>SEEK_SET,
SEEK_CUR</small> or <small>SEEK_END.</small></p>

<p style="margin-left:18%; margin-top: 1em">Returns 1 on
success, 0 on failure.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzclose</b></p>

<p style="margin-left:18%;">Closes the compressed file. Any
pending data is flushed to the file before it is closed.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzsetparams($level,</b>
<b><i>$strategy</i></b></p>

<p style="margin-left:18%;">Change settings for the deflate
stream <tt>$gz</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged.</p>

<p style="margin-left:18%; margin-top: 1em">Note: This
method is only available if you are running zlib 1.0.6 or
better. <b><br>
$level</b></p>

<p style="margin-left:26%;">Defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:18%;"><b>$strategy</b></p>

<p style="margin-left:26%;">Defines the strategy used to
tune the compression. The valid values are
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzerror</b></p>

<p style="margin-left:18%;">Returns the <i>zlib</i> error
message or number for the last operation associated with
<tt>$gz</tt>. The return value will be the <i>zlib</i> error
number when used in a numeric context and the <i>zlib</i>
error message when used in a string context. The <i>zlib</i>
error number constants, shown below, are available for
use.</p>

<pre style="margin-left:18%; margin-top: 1em">    Z_OK
    Z_STREAM_END
    Z_ERRNO
    Z_STREAM_ERROR
    Z_DATA_ERROR
    Z_MEM_ERROR
    Z_BUF_ERROR</pre>


<p style="margin-left:11%;"><b>$gzerrno</b></p>

<p style="margin-left:18%;">The <tt>$gzerrno</tt> scalar
holds the error code associated with the most recent
<i>gzip</i> routine. Note that unlike
<tt>&quot;gzerror()&quot;</tt>, the error is <i>not</i>
associated with a particular file.</p>

<p style="margin-left:18%; margin-top: 1em">As with
<tt>&quot;gzerror()&quot;</tt> it returns an error number in
numeric context and an error message in string context.
Unlike <tt>&quot;gzerror()&quot;</tt> though, the error
message will correspond to the <i>zlib</i> message when the
error is associated with <i>zlib</i> itself, or the
<small>UNIX</small> error message when it is not (i.e.
<i>zlib</i> returned <tt>&quot;Z_ERRORNO&quot;</tt>).</p>

<p style="margin-left:18%; margin-top: 1em">As there is an
overlap between the error numbers used by <i>zlib</i> and
<small>UNIX,</small> <tt>$gzerrno</tt> should only be used
to check for the presence of <i>an</i> error in numeric
context. Use <tt>&quot;gzerror()&quot;</tt> to check for
specific <i>zlib</i> errors. The <i>gzcat</i> example below
shows how the variable can be used safely.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Examples</b>
<br>
Here is an example script which uses the interface. It
implements a <i>gzcat</i> function.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Zlib ;
    # use stdin if no files supplied
    @ARGV = '&minus;' unless @ARGV ;
    foreach my $file (@ARGV) {
        my $buffer ;
        my $gz = gzopen($file, &quot;rb&quot;)
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;
        print $buffer while $gz&minus;&gt;gzread($buffer) &gt; 0 ;
        die &quot;Error reading from $file: $gzerrno&quot; . ($gzerrno+0) . &quot;\n&quot;
            if $gzerrno != Z_STREAM_END ;
        $gz&minus;&gt;gzclose() ;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">Below is a
script which makes use of <tt>&quot;gzreadline&quot;</tt>.
It implements a very simple <i>grep</i> like script.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Zlib ;
    die &quot;Usage: gzgrep pattern [file...]\n&quot;
        unless @ARGV &gt;= 1;
    my $pattern = shift ;
    # use stdin if no files supplied
    @ARGV = '&minus;' unless @ARGV ;
    foreach my $file (@ARGV) {
        my $gz = gzopen($file, &quot;rb&quot;)
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;
        while ($gz&minus;&gt;gzreadline($_) &gt; 0) {
            print if /$pattern/ ;
        }
        die &quot;Error reading from $file: $gzerrno\n&quot;
            if $gzerrno != Z_STREAM_END ;
        $gz&minus;&gt;gzclose() ;
    }</pre>


<p style="margin-left:11%; margin-top: 1em">This script,
<i>gzstream</i>, does the opposite of the <i>gzcat</i>
script above. It reads from standard input and writes a gzip
data stream to standard output.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Zlib ;
    binmode STDOUT;  # gzopen only sets it on the fd
    my $gz = gzopen(\*STDOUT, &quot;wb&quot;)
          or die &quot;Cannot open stdout: $gzerrno\n&quot; ;
    while (&lt;&gt;) {
        $gz&minus;&gt;gzwrite($_)
          or die &quot;error writing: $gzerrno\n&quot; ;
    }
    $gz&minus;&gt;gzclose ;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Compress::Zlib::memGzip</b>
<br>
This function is used to create an in-memory gzip file with
the minimum possible gzip header (exactly 10 bytes).</p>

<pre style="margin-left:11%; margin-top: 1em">    $dest = Compress::Zlib::memGzip($buffer)
        or die &quot;Cannot compress: $gzerrno\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">If successful,
it returns the in-memory gzip file. Otherwise it returns
<tt>&quot;undef&quot;</tt> and the <tt>$gzerrno</tt>
variable will store the zlib error code.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$buffer</tt> parameter can either be a scalar or a
scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">See
IO::Compress::Gzip for an alternative way to carry out
in-memory gzip compression.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Compress::Zlib::memGunzip</b>
<br>
This function is used to uncompress an in-memory gzip
file.</p>

<pre style="margin-left:11%; margin-top: 1em">    $dest = Compress::Zlib::memGunzip($buffer)
        or die &quot;Cannot uncompress: $gzerrno\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">If successful,
it returns the uncompressed gzip file. Otherwise it returns
<tt>&quot;undef&quot;</tt> and the <tt>$gzerrno</tt>
variable will store the zlib error code.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$buffer</tt> parameter can either be a scalar or a
scalar reference. The contents of the <tt>$buffer</tt>
parameter are destroyed after calling this function.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>$buffer</tt> consists of multiple concatenated gzip data
streams only the first will be uncompressed. Use
<tt>&quot;gunzip&quot;</tt> with the
<tt>&quot;MultiStream&quot;</tt> option in the
<tt>&quot;IO::Uncompress::Gunzip&quot;</tt> module if you
need to deal with concatenated data streams.</p>

<p style="margin-left:11%; margin-top: 1em">See
IO::Uncompress::Gunzip for an alternative way to carry out
in-memory gzip uncompression.</p>

<h2>COMPRESS/UNCOMPRESS
<a name="COMPRESS/UNCOMPRESS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two functions
are provided to perform in-memory compression/uncompression
of <small>RFC 1950</small> data streams. They are called
<tt>&quot;compress&quot;</tt> and
<tt>&quot;uncompress&quot;</tt>. <b><br>
$dest = compress($source [,</b> <b><i>$level</i></b><b>] )
;</b></p>

<p style="margin-left:18%;">Compresses <tt>$source</tt>. If
successful it returns the compressed data. Otherwise it
returns <i>undef</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The source
buffer, <tt>$source</tt>, can either be a scalar or a scalar
reference.</p>

<p style="margin-left:18%; margin-top: 1em">The
<tt>$level</tt> parameter defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>. If
<tt>$level</tt> is not specified
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt> will be used.</p>

<p style="margin-left:11%;"><b>$dest = uncompress($source)
;</b></p>

<p style="margin-left:18%;">Uncompresses <tt>$source</tt>.
If successful it returns the uncompressed data. Otherwise it
returns <i>undef</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The source
buffer can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">Please note:
the two functions defined above are <i>not</i> compatible
with the Unix commands of the same name.</p>

<p style="margin-left:11%; margin-top: 1em">See IO::Deflate
and IO::Inflate included with this distribution for an
alternative interface for reading/writing <small>RFC
1950</small> files/buffers.</p>

<h2>Deflate Interface
<a name="Deflate Interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines an interface that allows in-memory compression using
the <i>deflate</i> interface provided by zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface available:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($d,
$status) = deflateInit( [ <small>OPT</small> ] )</b> <br>
Initialises a deflation stream.</p>

<p style="margin-left:11%; margin-top: 1em">It combines the
features of the <i>zlib</i> functions
<tt>&quot;deflateInit&quot;</tt>,
<tt>&quot;deflateInit2&quot;</tt> and
<tt>&quot;deflateSetDictionary&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
it will return the initialised deflation stream, <tt>$d</tt>
and <tt>$status</tt> of <tt>&quot;Z_OK&quot;</tt> in a list
context. In scalar context it returns the deflation stream,
<tt>$d</tt>, only.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, the returned deflation stream (<tt>$d</tt>) will
be <i>undef</i> and <tt>$status</tt> will hold the exact
<i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
<tt>&quot;&minus;Name=&gt;value&quot;</tt> pairs. This
allows individual options to be tailored without having to
specify them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>

<p style="margin-left:11%; margin-top: 1em">The function
takes one optional parameter, a reference to a hash. The
contents of the hash allow the deflation interface to be
tailored.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of the valid options: <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
Z_DEFAULT_COMPRESSION.</p>

<p style="margin-left:11%;"><b>&minus;Method</b></p>

<p style="margin-left:18%;">Defines the compression method.
The only valid value at present (and the default) is
Z_DEFLATED.</p>

<p style="margin-left:11%;"><b>&minus;WindowBits</b></p>

<p style="margin-left:18%;">To create an <small>RFC
1950</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to a positive number.</p>

<p style="margin-left:18%; margin-top: 1em">To create an
<small>RFC 1951</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;&minus;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">For a full
definition of the meaning and valid values for
<tt>&quot;WindowBits&quot;</tt> refer to the <i>zlib</i>
documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_WBITS.</small></p>

<p style="margin-left:11%;"><b>&minus;MemLevel</b></p>

<p style="margin-left:18%;">For a definition of the meaning
and valid values for <tt>&quot;MemLevel&quot;</tt> refer to
the <i>zlib</i> documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_MEM_LEVEL.</small></p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
Z_DEFAULT_STRATEGY.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">When a dictionary is specified
<i>Compress::Zlib</i> will automatically call
<tt>&quot;deflateSetDictionary&quot;</tt> directly after
calling <tt>&quot;deflateInit&quot;</tt>. The Adler32 value
for the dictionary can be obtained by calling the method
<tt>&quot;$d&minus;&quot;</tt><i>dict_adler()</i>&gt;.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
no dictionary.</p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
deflation buffer. If the buffer has to be reallocated to
increase the size, it will grow in increments of
<tt>&quot;Bufsize&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
4096.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using the <tt>&quot;deflateInit&quot;</tt>
optional parameter list to override the default buffer size
and compression level. All other options will take their
default values.</p>

<pre style="margin-left:11%; margin-top: 1em">    deflateInit( &minus;Bufsize =&gt; 300,
                 &minus;Level =&gt; Z_BEST_SPEED  ) ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $d&minus;&gt;deflate($buffer)</b> <br>
Deflates the contents of <tt>$buffer</tt>. The buffer can
either be a scalar or a scalar reference. When finished,
<tt>$buffer</tt> will be completely processed (assuming
there were no errors). If the deflation was successful it
returns the deflated output, <tt>$out</tt>, and a status
value, <tt>$status</tt>, of <tt>&quot;Z_OK&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">On error,
<tt>$out</tt> will be <i>undef</i> and <tt>$status</tt> will
contain the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context <tt>&quot;deflate&quot;</tt> will return
<tt>$out</tt> only.</p>

<p style="margin-left:11%; margin-top: 1em">As with the
<i>deflate</i> function in <i>zlib</i>, it is not
necessarily the case that any output will be produced by
this method. So don&rsquo;t rely on the fact that
<tt>$out</tt> is empty for an error test.</p>

<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $d&minus;&gt;</b><b><i>flush()</i></b> <b>=head2
($out, $status) = $d&minus;&gt;flush($flush_type)</b> <br>
Typically used to finish the deflation. Any pending output
will be returned via <tt>$out</tt>. <tt>$status</tt> will
have a value <tt>&quot;Z_OK&quot;</tt> if successful.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context <tt>&quot;flush&quot;</tt> will return <tt>$out</tt>
only.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using
<tt>&quot;Z_FINISH&quot;</tt>) or when you want to create a
<i>full flush point</i> (using
<tt>&quot;Z_FULL_FLUSH&quot;</tt>).</p>

<p style="margin-left:11%; margin-top: 1em">By default the
<tt>&quot;flush_type&quot;</tt> used is
<tt>&quot;Z_FINISH&quot;</tt>. Other valid values for
<tt>&quot;flush_type&quot;</tt> are
<tt>&quot;Z_NO_FLUSH&quot;</tt>,
<tt>&quot;Z_PARTIAL_FLUSH&quot;</tt>,
<tt>&quot;Z_SYNC_FLUSH&quot;</tt> and
<tt>&quot;Z_FULL_FLUSH&quot;</tt>. It is strongly
recommended that you only set the
<tt>&quot;flush_type&quot;</tt> parameter if you fully
understand the implications of what it does. See the
<tt>&quot;zlib&quot;</tt> documentation for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;deflateParams([ <small>OPT</small> ])</b> <br>
Change settings for the deflate stream <tt>$d</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged. <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9,
<tt>&quot;Z_NO_COMPRESSION&quot;</tt>,
<tt>&quot;Z_BEST_SPEED&quot;</tt>,
<tt>&quot;Z_BEST_COMPRESSION&quot;</tt>, and
<tt>&quot;Z_DEFAULT_COMPRESSION&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
<tt>&quot;Z_DEFAULT_STRATEGY&quot;</tt>,
<tt>&quot;Z_FILTERED&quot;</tt> and
<tt>&quot;Z_HUFFMAN_ONLY&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>dict_adler()</i></b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>msg()</i></b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>total_in()</i></b>
<br>
Returns the total number of bytes uncompressed bytes input
to deflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;</b><b><i>total_out()</i></b>
<br>
Returns the total number of compressed bytes output from
deflate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Here is a trivial example of using
<tt>&quot;deflate&quot;</tt>. It simply reads standard
input, deflates it and writes it to standard output.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Zlib ;
    binmode STDIN;
    binmode STDOUT;
    my $x = deflateInit()
       or die &quot;Cannot create a deflation stream\n&quot; ;
    my ($output, $status) ;
    while (&lt;&gt;)
    {
        ($output, $status) = $x&minus;&gt;deflate($_) ;
        $status == Z_OK
            or die &quot;deflation failed\n&quot; ;
        print $output ;
    }
    ($output, $status) = $x&minus;&gt;flush() ;
    $status == Z_OK
        or die &quot;deflation failed\n&quot; ;
    print $output ;</pre>


<h2>Inflate Interface
<a name="Inflate Interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines the interface available that allows in-memory
uncompression using the <i>deflate</i> interface provided by
zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($i,
$status) =</b> <b><i>inflateInit()</i></b> <br>
Initialises an inflation stream.</p>

<p style="margin-left:11%; margin-top: 1em">In a list
context it returns the inflation stream, <tt>$i</tt>, and
the <i>zlib</i> status code in <tt>$status</tt>. In a scalar
context it returns the inflation stream only.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
<tt>$i</tt> will hold the inflation stream and
<tt>$status</tt> will be <tt>&quot;Z_OK&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, <tt>$i</tt> will be <i>undef</i> and
<tt>$status</tt> will hold the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
<tt>&quot;&minus;Name=&gt;value&quot;</tt> pairs. This
allows individual options to be tailored without having to
specify them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>

<p style="margin-left:11%; margin-top: 1em">The function
takes one optional parameter, a reference to a hash. The
contents of the hash allow the deflation interface to be
tailored.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of the valid options: <b><br>
&minus;WindowBits</b></p>

<p style="margin-left:18%;">To uncompress an <small>RFC
1950</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to a positive number.</p>

<p style="margin-left:18%; margin-top: 1em">To uncompress
an <small>RFC 1951</small> data stream, set
<tt>&quot;WindowBits&quot;</tt> to
<tt>&quot;&minus;MAX_WBITS&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">For a full
definition of the meaning and valid values for
<tt>&quot;WindowBits&quot;</tt> refer to the <i>zlib</i>
documentation for <i>inflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_WBITS.</small></p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
inflation buffer. If the buffer has to be reallocated to
increase the size, it will grow in increments of
<tt>&quot;Bufsize&quot;</tt>.</p>

<p style="margin-left:18%; margin-top: 1em">Default is
4096.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">The default is no
dictionary.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using the <tt>&quot;inflateInit&quot;</tt>
optional parameter to override the default buffer size.</p>

<pre style="margin-left:11%; margin-top: 1em">    inflateInit( &minus;Bufsize =&gt; 300 ) ;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $i&minus;&gt;inflate($buffer)</b> <br>
Inflates the complete contents of <tt>$buffer</tt>. The
buffer can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
<tt>&quot;Z_OK&quot;</tt> if successful and
<tt>&quot;Z_STREAM_END&quot;</tt> if the end of the
compressed data has been successfully reached. If not
successful, <tt>$out</tt> will be <i>undef</i> and
<tt>$status</tt> will hold the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>$buffer</tt> parameter is modified by
<tt>&quot;inflate&quot;</tt>. On completion it will contain
what remains of the input buffer after inflation. This means
that <tt>$buffer</tt> will be an empty string when the
return status is <tt>&quot;Z_OK&quot;</tt>. When the return
status is <tt>&quot;Z_STREAM_END&quot;</tt> the
<tt>$buffer</tt> parameter will contains what (if anything)
was stored in the input buffer after the deflated data
stream.</p>

<p style="margin-left:11%; margin-top: 1em">This feature is
useful when processing a file format that encapsulates a
compressed data stream (e.g. gzip, zip).</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$i&minus;&gt;inflateSync($buffer)</b> <br>
Scans <tt>$buffer</tt> until it reaches either a <i>full
flush point</i> or the end of the buffer.</p>

<p style="margin-left:11%; margin-top: 1em">If a <i>full
flush point</i> is found, <tt>&quot;Z_OK&quot;</tt> is
returned and <tt>$buffer</tt> will be have all data up to
the flush point removed. This can then be passed to the
<tt>&quot;deflate&quot;</tt> method.</p>

<p style="margin-left:11%; margin-top: 1em">Any other
return code means that a flush point was not found. If more
data is available, <tt>&quot;inflateSync&quot;</tt> can be
called repeatedly with more compressed data until the flush
point is found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>dict_adler()</i></b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>msg()</i></b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>total_in()</i></b>
<br>
Returns the total number of bytes compressed bytes input to
inflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;</b><b><i>total_out()</i></b>
<br>
Returns the total number of uncompressed bytes output from
inflate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Here is an example of using
<tt>&quot;inflate&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">    use strict ;
    use warnings ;
    use Compress::Zlib ;
    my $x = inflateInit()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        ($output, $status) = $x&minus;&gt;inflate(\$input) ;
        print $output
            if $status == Z_OK or $status == Z_STREAM_END ;
        last if $status != Z_OK ;
    }
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;</pre>


<h2>CHECKSUM FUNCTIONS
<a name="CHECKSUM FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two functions
are provided by <i>zlib</i> to calculate checksums. For the
Perl interface, the order of the two parameters in both
functions has been reversed. This allows both running
checksums and one off calculations to be done.</p>

<pre style="margin-left:11%; margin-top: 1em">    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;</pre>


<p style="margin-left:11%; margin-top: 1em">The buffer
parameters can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<tt>$crc</tt> parameters is <tt>&quot;undef&quot;</tt>, the
crc value will be reset.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.</p>

<pre style="margin-left:11%; margin-top: 1em">    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)</pre>


<p style="margin-left:11%; margin-top: 1em">These functions
allow checksums to be merged.</p>

<h2>Misc
<a name="Misc"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>my $version
=</b> <i>Compress::Zlib::zlib_version()</i><b>;</b> <br>
Returns the version of the zlib library.</p>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the
<i>zlib</i> constants are automatically imported when you
make use of <i>Compress::Zlib</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">IO::Compress::Gzip,
IO::Uncompress::Gunzip, IO::Compress::Deflate,
IO::Uncompress::Inflate, IO::Compress::RawDeflate,
IO::Uncompress::RawInflate, IO::Compress::Bzip2,
IO::Uncompress::Bunzip2, IO::Compress::Lzma,
IO::Uncompress::UnLzma, IO::Compress::Xz,
IO::Uncompress::UnXz, IO::Compress::Lzop,
IO::Uncompress::UnLzop, IO::Compress::Lzf,
IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate,
IO::Uncompress::AnyUncompress</p>


<p style="margin-left:11%; margin-top: 1em">IO::Compress::FAQ</p>


<p style="margin-left:11%; margin-top: 1em">File::GlobMapper,
Archive::Zip, Archive::Tar, IO::Zlib</p>

<p style="margin-left:11%; margin-top: 1em">For <small>RFC
1950, 1951</small> and 1952 see
<i>http://www.faqs.org/rfcs/rfc1950.html</i>,
<i>http://www.faqs.org/rfcs/rfc1951.html</i> and
<i>http://www.faqs.org/rfcs/rfc1952.html</i></p>

<p style="margin-left:11%; margin-top: 1em">The <i>zlib</i>
compression library was written by Jean-loup Gailly
<i>gzip@prep.ai.mit.edu</i> and Mark Adler
<i>madler@alumni.caltech.edu</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for the <i>zlib</i> compression library is
<i>http://www.zlib.org</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for gzip is <i>http://www.gzip.org</i>.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module was
written by Paul Marquess, <i>pmqs@cpan.org</i>.</p>

<h2>MODIFICATION HISTORY
<a name="MODIFICATION HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See the Changes
file.</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1995&minus;2013 Paul Marquess. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
