<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:43:59 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IO::ScalarArray</title>

</head>
<body>

<h1 align="center">IO::ScalarArray</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PUBLIC INTERFACE">PUBLIC INTERFACE</a><br>
<a href="#WARNINGS">WARNINGS</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">IO::ScalarArray
&minus; IO:: interface for reading/writing an array of
scalars</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perform I/O on
strings, using the basic <small>OO</small> interface...</p>

<pre style="margin-left:11%; margin-top: 1em">    use IO::ScalarArray;
    @data = (&quot;My mes&quot;, &quot;sage:\n&quot;);
    ### Open a handle on an array, and append to it:
    $AH = new IO::ScalarArray \@data;
    $AH&minus;&gt;print(&quot;Hello&quot;);
    $AH&minus;&gt;print(&quot;, world!\nBye now!\n&quot;);
    print &quot;The array is now: &quot;, @data, &quot;\n&quot;;
    ### Open a handle on an array, read it line&minus;by&minus;line, then close it:
    $AH = new IO::ScalarArray \@data;
    while (defined($_ = $AH&minus;&gt;getline)) {
        print &quot;Got line: $_&quot;;
    }
    $AH&minus;&gt;close;
    ### Open a handle on an array, and slurp in all the lines:
    $AH = new IO::ScalarArray \@data;
    print &quot;All lines:\n&quot;, $AH&minus;&gt;getlines;
    ### Get the current position (either of two ways):
    $pos = $AH&minus;&gt;getpos;
    $offset = $AH&minus;&gt;tell;
    ### Set the current position (either of two ways):
    $AH&minus;&gt;setpos($pos);
    $AH&minus;&gt;seek($offset, 0);
    ### Open an anonymous temporary array:
    $AH = new IO::ScalarArray;
    $AH&minus;&gt;print(&quot;Hi there!&quot;);
    print &quot;I printed: &quot;, @{$AH&minus;&gt;aref}, &quot;\n&quot;;      ### get at value</pre>


<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t
like <small>OO</small> for your I/O? No problem. Thanks to
the magic of an invisible <i>tie()</i>, the following now
works out of the box, just as it does with IO::Handle:</p>

<pre style="margin-left:11%; margin-top: 1em">    use IO::ScalarArray;
    @data = (&quot;My mes&quot;, &quot;sage:\n&quot;);
    ### Open a handle on an array, and append to it:
    $AH = new IO::ScalarArray \@data;
    print $AH &quot;Hello&quot;;
    print $AH &quot;, world!\nBye now!\n&quot;;
    print &quot;The array is now: &quot;, @data, &quot;\n&quot;;
    ### Open a handle on a string, read it line&minus;by&minus;line, then close it:
    $AH = new IO::ScalarArray \@data;
    while (&lt;$AH&gt;) {
        print &quot;Got line: $_&quot;;
    }
    close $AH;
    ### Open a handle on a string, and slurp in all the lines:
    $AH = new IO::ScalarArray \@data;
    print &quot;All lines:\n&quot;, &lt;$AH&gt;;
    ### Get the current position (WARNING: requires 5.6):
    $offset = tell $AH;
    ### Set the current position (WARNING: requires 5.6):
    seek $AH, $offset, 0;
    ### Open an anonymous temporary scalar:
    $AH = new IO::ScalarArray;
    print $AH &quot;Hi there!&quot;;
    print &quot;I printed: &quot;, @{$AH&minus;&gt;aref}, &quot;\n&quot;;      ### get at value</pre>


<p style="margin-left:11%; margin-top: 1em">And for you
folks with 1.x code out there: the old <i>tie()</i> style
still works, though this is <i>unnecessary and
deprecated</i>:</p>

<pre style="margin-left:11%; margin-top: 1em">    use IO::ScalarArray;
    ### Writing to a scalar...
    my @a;
    tie *OUT, 'IO::ScalarArray', \@a;
    print OUT &quot;line 1\nline 2\n&quot;, &quot;line 3\n&quot;;
    print &quot;Array is now: &quot;, @a, &quot;\n&quot;
    ### Reading and writing an anonymous scalar...
    tie *OUT, 'IO::ScalarArray';
    print OUT &quot;line 1\nline 2\n&quot;, &quot;line 3\n&quot;;
    tied(OUT)&minus;&gt;seek(0,0);
    while (&lt;OUT&gt;) {
        print &quot;Got line: &quot;, $_;
    }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This class is
part of the IO::Stringy distribution; see IO::Stringy for
change log and general information.</p>

<p style="margin-left:11%; margin-top: 1em">The
IO::ScalarArray class implements objects which behave just
like IO::Handle (or FileHandle) objects, except that you may
use them to write to (or read from) arrays of scalars.
Logically, an array of scalars defines an in-core
&quot;file&quot; whose contents are the concatenation of the
scalars in the array. The handles created by this class are
automatically tiehandle&rsquo;d (though please see &quot;
<small>WARNINGS&quot;</small> for information relevant to
your Perl version).</p>

<p style="margin-left:11%; margin-top: 1em">For writing
large amounts of data with individual <i>print()</i>
statements, this class is likely to be more efficient than
IO::Scalar.</p>

<p style="margin-left:11%; margin-top: 1em">Basically,
this:</p>

<pre style="margin-left:11%; margin-top: 1em">    my @a;
    $AH = new IO::ScalarArray \@a;
    $AH&minus;&gt;print(&quot;Hel&quot;, &quot;lo, &quot;);         ### OO style
    $AH&minus;&gt;print(&quot;world!\n&quot;);            ### ditto</pre>


<p style="margin-left:11%; margin-top: 1em">Or this:</p>

<pre style="margin-left:11%; margin-top: 1em">    my @a;
    $AH = new IO::ScalarArray \@a;
    print $AH &quot;Hel&quot;, &quot;lo, &quot;;           ### non&minus;OO style
    print $AH &quot;world!\n&quot;;              ### ditto</pre>


<p style="margin-left:11%; margin-top: 1em">Causes
<tt>@a</tt> to be set to the following array of 3
strings:</p>

<pre style="margin-left:11%; margin-top: 1em">    ( &quot;Hel&quot; ,
      &quot;lo, &quot; ,
      &quot;world!\n&quot; )</pre>


<p style="margin-left:11%; margin-top: 1em">See IO::Scalar
and compare with this class.</p>

<h2>PUBLIC INTERFACE
<a name="PUBLIC INTERFACE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Construction</b>
<br>
new [ <small>ARGS...</small> ]</p>

<p style="margin-left:17%;"><i>Class method.</i> Return a
new, unattached array handle. If any arguments are given,
they&rsquo;re sent to <i>open()</i>.</p>

<p style="margin-left:11%;">open [ <small>ARRAYREF</small>
]</p>

<p style="margin-left:17%;"><i>Instance method.</i> Open
the array handle on a new array, pointed to by
<small>ARRAYREF.</small> If no <small>ARRAYREF</small> is
given, a &quot;private&quot; array is created to hold the
file data.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
self object on success, undefined on error.</p>

<p style="margin-left:11%;">opened</p>

<p style="margin-left:17%;"><i>Instance method.</i> Is the
array handle opened on something?</p>

<p style="margin-left:11%;">close</p>

<p style="margin-left:17%;"><i>Instance method.</i>
Disassociate the array handle from its underlying array.
Done automatically on destroy.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Input and
output</b> <br>
flush</p>

<p style="margin-left:17%;"><i>Instance method.</i> No-op,
provided for <small>OO</small> compatibility.</p>

<p style="margin-left:11%;">getc</p>

<p style="margin-left:17%;"><i>Instance method.</i> Return
the next character, or undef if none remain. This does a
<i>read</i>(1), which is somewhat costly.</p>

<p style="margin-left:11%;">getline</p>

<p style="margin-left:17%;"><i>Instance method.</i> Return
the next line, or undef on end of data. Can safely be called
in an array context. Currently, lines are delimited by
&quot;\n&quot;.</p>

<p style="margin-left:11%;">getlines</p>

<p style="margin-left:17%;"><i>Instance method.</i> Get all
remaining lines. It will <i>croak()</i> if accidentally
called in a scalar context.</p>

<p style="margin-left:11%;">print
<small>ARGS...</small></p>

<p style="margin-left:17%;"><i>Instance method.</i> Print
<small>ARGS</small> to the underlying array.</p>

<p style="margin-left:17%; margin-top: 1em">Currently, this
always causes a &quot;seek to the end of the array&quot; and
generates a new array entry. This may change in the
future.</p>

<p style="margin-left:11%;">read <small>BUF,
NBYTES,</small> [ <small>OFFSET</small> ];</p>

<p style="margin-left:17%;"><i>Instance method.</i> Read
some bytes from the array. Returns the number of bytes
actually read, 0 on end-of-file, undef on error.</p>

<p style="margin-left:11%;">write <small>BUF,
NBYTES,</small> [ <small>OFFSET</small> ];</p>

<p style="margin-left:17%;"><i>Instance method.</i> Write
some bytes into the array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Seeking/telling
and other attributes</b> <br>
autoflush</p>

<p style="margin-left:17%;"><i>Instance method.</i> No-op,
provided for <small>OO</small> compatibility.</p>

<p style="margin-left:11%;">binmode</p>

<p style="margin-left:17%;"><i>Instance method.</i> No-op,
provided for <small>OO</small> compatibility.</p>

<p style="margin-left:11%;">clearerr</p>

<p style="margin-left:17%;"><i>Instance method.</i> Clear
the error and <small>EOF</small> flags. A no-op.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>eof</p></td>
<td width="2%"></td>
<td width="61%">


<p><i>Instance method.</i> Are we at end of file?</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%;">seek
<small>POS,WHENCE</small></p>

<p style="margin-left:17%;"><i>Instance method.</i> Seek to
a given position in the stream. Only a <small>WHENCE</small>
of 0 ( <small>SEEK_SET</small> ) is supported.</p>

<p style="margin-left:11%;">tell</p>

<p style="margin-left:17%;"><i>Instance method.</i> Return
the current position in the stream, as a numeric offset.</p>

<p style="margin-left:11%;">setpos <small>POS</small></p>

<p style="margin-left:17%;"><i>Instance method.</i> Seek to
a given position in the array, using the opaque
<i>getpos()</i> value. Don&rsquo;t expect this to be a
number.</p>

<p style="margin-left:11%;">getpos</p>

<p style="margin-left:17%;"><i>Instance method.</i> Return
the current position in the array, as an opaque value.
Don&rsquo;t expect this to be a number.</p>

<p style="margin-left:11%;">aref</p>

<p style="margin-left:17%;"><i>Instance method.</i> Return
a reference to the underlying array.</p>

<h2>WARNINGS
<a name="WARNINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
<small>TIEHANDLE</small> spec was incomplete prior to
5.005_57; it was missing support for
<tt>&quot;seek()&quot;</tt>, <tt>&quot;tell()&quot;</tt>,
and <tt>&quot;eof()&quot;</tt>. Attempting to use these
functions with an IO::ScalarArray will not work prior to
5.005_57. IO::ScalarArray will not have the relevant methods
invoked; and even worse, this kind of bug can lie dormant
for a while. If you turn warnings on (via <tt>$^W</tt> or
<tt>&quot;perl &minus;w&quot;</tt>), and you see something
like this...</p>

<pre style="margin-left:11%; margin-top: 1em">    attempt to seek on unopened filehandle</pre>


<p style="margin-left:11%; margin-top: 1em">...then you are
probably trying to use one of these functions on an
IO::ScalarArray with an old Perl. The remedy is to simply
use the <small>OO</small> version; e.g.:</p>

<pre style="margin-left:11%; margin-top: 1em">    $AH&minus;&gt;seek(0,0);    ### GOOD: will work on any 5.005
    seek($AH,0,0);     ### WARNING: will only work on 5.005_57 and beyond</pre>


<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>$Id:</tt>
ScalarArray.pm,v 1.7 2005/02/10 21:21:53 dfs Exp $</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Primary
Maintainer</b> <br>
David F. Skoll (<i>dfs@roaringpenguin.com</i>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Principal
author</b> <br>
Eryq (<i>eryq@zeegee.com</i>). President, ZeeGee Software
Inc (<i>http://www.zeegee.com</i>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
contributors</b> <br>
Thanks to the following individuals for their invaluable
contributions (if I&rsquo;ve forgotten or misspelled your
name, please email me!):</p>

<p style="margin-left:11%; margin-top: 1em"><i>Andy
Glew,</i> for suggesting <tt>&quot;getc()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Brandon
Browning,</i> for suggesting
<tt>&quot;opened()&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Eric L.
Brine,</i> for his offset-using <i>read()</i> and
<i>write()</i> implementations.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Doug
Wilson,</i> for the IO::Handle inheritance and automatic
tie-ing.</p>
<hr>
</body>
</html>
