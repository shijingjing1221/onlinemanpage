<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 23:08:46 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XML::LibXML::Node</title>

</head>
<body>

<h1 align="center">XML::LibXML::Node</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::LibXML::Node
&minus; Abstract Base Class of XML::LibXML Nodes</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use XML::LibXML;
  $name = $node&minus;&gt;nodeName;
  $node&minus;&gt;setNodeName( $newName );
  $bool = $node&minus;&gt;isSameNode( $other_node );
  $bool = $node&minus;&gt;isEqual( $other_node );
  $content = $node&minus;&gt;nodeValue;
  $content = $node&minus;&gt;textContent;
  $type = $node&minus;&gt;nodeType;
  $node&minus;&gt;unbindNode();
  $childnode = $node&minus;&gt;removeChild( $childnode );
  $oldnode = $node&minus;&gt;replaceChild( $newNode, $oldNode );
  $node&minus;&gt;replaceNode($newNode);
  $childnode = $node&minus;&gt;appendChild( $childnode );
  $childnode = $node&minus;&gt;addChild( $childnode );
  $node = $parent&minus;&gt;addNewChild( $nsURI, $name );
  $node&minus;&gt;addSibling($newNode);
  $newnode =$node&minus;&gt;cloneNode( $deep );
  $parentnode = $node&minus;&gt;parentNode;
  $nextnode = $node&minus;&gt;nextSibling();
  $nextnode = $node&minus;&gt;nextNonBlankSibling();
  $prevnode = $node&minus;&gt;previousSibling();
  $prevnode = $node&minus;&gt;previousNonBlankSibling();
  $boolean = $node&minus;&gt;hasChildNodes();
  $childnode = $node&minus;&gt;firstChild;
  $childnode = $node&minus;&gt;lastChild;
  $documentnode = $node&minus;&gt;ownerDocument;
  $node = $node&minus;&gt;getOwner;
  $node&minus;&gt;setOwnerDocument( $doc );
  $node&minus;&gt;insertBefore( $newNode, $refNode );
  $node&minus;&gt;insertAfter( $newNode, $refNode );
  @nodes = $node&minus;&gt;findnodes( $xpath_expression );
  $result = $node&minus;&gt;find( $xpath );
  print $node&minus;&gt;findvalue( $xpath );
  $bool = $node&minus;&gt;exists( $xpath_expression );
  @childnodes = $node&minus;&gt;childNodes();
  @childnodes = $node&minus;&gt;nonBlankChildNodes();
  $xmlstring = $node&minus;&gt;toString($format,$docencoding);
  $c14nstring = $node&minus;&gt;toStringC14N();
  $c14nstring = $node&minus;&gt;toStringC14N($with_comments, $xpath_expression , $xpath_context);
  $ec14nstring = $node&minus;&gt;toStringEC14N();
  $ec14nstring = $node&minus;&gt;toStringEC14N($with_comments, $xpath_expression, $inclusive_prefix_list);
  $ec14nstring = $node&minus;&gt;toStringEC14N($with_comments, $xpath_expression, $xpath_context, $inclusive_prefix_list);
  $str = $doc&minus;&gt;serialize($format);
  $localname = $node&minus;&gt;localname;
  $nameprefix = $node&minus;&gt;prefix;
  $uri = $node&minus;&gt;namespaceURI();
  $boolean = $node&minus;&gt;hasAttributes();
  @attributelist = $node&minus;&gt;attributes();
  $URI = $node&minus;&gt;lookupNamespaceURI( $prefix );
  $prefix = $node&minus;&gt;lookupNamespacePrefix( $URI );
  $node&minus;&gt;normalize;
  @nslist = $node&minus;&gt;getNamespaces;
  $node&minus;&gt;removeChildNodes();
  $strURI = $node&minus;&gt;baseURI();
  $node&minus;&gt;setBaseURI($strURI);
  $node&minus;&gt;nodePath();
  $lineno = $node&minus;&gt;line_number();</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::LibXML::Node
defines functions that are common to all Node Types. A
LibXML::Node should never be created standalone, but as an
instance of a high level class such as LibXML::Element or
LibXML::Text. The class itself should provide only common
functionality. In XML::LibXML each node is part either of a
document or a document-fragment. Because of this there is no
node without a parent. This may causes confusion with
&quot;unbound&quot; nodes.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many functions
listed here are extensively documented in the
<small>DOM</small> Level 3 specification
(&lt;http://www.w3.org/TR/DOM&minus;Level&minus;3&minus;Core/&gt;).
Please refer to the specification for extensive
documentation. <br>
nodeName</p>

<pre style="margin-left:17%;">  $name = $node&minus;&gt;nodeName;</pre>


<p style="margin-left:17%; margin-top: 1em">Returns the
node&rsquo;s name. This function is aware of namespaces and
returns the full name of the current node
(<tt>&quot;prefix:localname&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Since 1.62 this
function also returns the correct <small>DOM</small> names
for node types with constant names, namely: #text,
#cdata&minus;section, #comment, #document,
#document&minus;fragment.</p>

<p style="margin-left:11%;">setNodeName</p>

<pre style="margin-left:17%;">  $node&minus;&gt;setNodeName( $newName );</pre>


<p style="margin-left:17%; margin-top: 1em">In very limited
situations, it is useful to change a nodes name. In the
<small>DOM</small> specification this should throw an error.
This Function is aware of namespaces.</p>

<p style="margin-left:11%;">isSameNode</p>

<pre style="margin-left:17%;">  $bool = $node&minus;&gt;isSameNode( $other_node );</pre>


<p style="margin-left:17%; margin-top: 1em">returns
<small>TRUE \fIs0(1) if the given nodes refer to the same
node structure, otherwise <small>FALSE \fIs0(0) is
returned.</small></small></p>


<p style="margin-left:11%;"><small><small>isEqual</small></small></p>


<pre style="margin-left:17%;">  $bool = $node&minus;&gt;isEqual( $other_node );</pre>



<p style="margin-left:17%; margin-top: 1em"><small>deprecated
version of <i>isSameNode()</i>.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i><small>NOTE</small></i>
isEqual will change behaviour to follow the
<small>DOM</small> specification</small></p>

<p style="margin-left:11%;"><small>nodeValue</small></p>

<pre style="margin-left:17%;">  $content = $node&minus;&gt;nodeValue;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>If the
node has any content (such as stored in a <tt>&quot;text
node&quot;</tt>) it can get requested through this
function.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i><small>NOTE:</small></i>
Element Nodes have no content per definition. To get the
text value of an Element use <i>textContent()</i>
instead!</small></p>

<p style="margin-left:11%;"><small>textContent</small></p>

<pre style="margin-left:17%;">  $content = $node&minus;&gt;textContent;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>this
function returns the content of all text nodes in the
descendants of the given node as specified in
<small>DOM.</small></small></p>

<p style="margin-left:11%;"><small>nodeType</small></p>

<pre style="margin-left:17%;">  $type = $node&minus;&gt;nodeType;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Return a
numeric value representing the node type of this node. The
module XML::LibXML by default exports constants for the node
types (see the <small>EXPORT</small> section in the
XML::LibXML manual page).</small></p>

<p style="margin-left:11%;"><small>unbindNode</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;unbindNode();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Unbinds
the Node from its siblings and Parent, but not from the
Document it belongs to. If the node is not inserted into the
<small>DOM</small> afterwards, it will be lost after the
program terminates. From a low level view, the unbound node
is stripped from the context it is and inserted into a
(hidden) document-fragment.</small></p>

<p style="margin-left:11%;"><small>removeChild</small></p>

<pre style="margin-left:17%;">  $childnode = $node&minus;&gt;removeChild( $childnode );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
will unbind the Child Node from its parent <tt>$node</tt>.
The function returns the unbound node. If
<tt>&quot;oldNode&quot;</tt> is not a child of the given
Node the function will fail.</small></p>


<p style="margin-left:11%;"><small>replaceChild</small></p>


<pre style="margin-left:17%;">  $oldnode = $node&minus;&gt;replaceChild( $newNode, $oldNode );</pre>



<p style="margin-left:17%; margin-top: 1em"><small>Replaces
the <tt>$oldNode</tt> with the <tt>$newNode</tt>. The
<tt>$oldNode</tt> will be unbound from the Node. This
function differs from the <small>DOM L2</small>
specification, in the case, if the new node is not part of
the document, the node will be imported first.</small></p>

<p style="margin-left:11%;"><small>replaceNode</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;replaceNode($newNode);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function is very similar to <i>replaceChild()</i>, but it
replaces the node itself rather than a childnode. This is
useful if a node found by any XPath function, should be
replaced.</small></p>

<p style="margin-left:11%;"><small>appendChild</small></p>

<pre style="margin-left:17%;">  $childnode = $node&minus;&gt;appendChild( $childnode );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>The
function will add the <tt>$childnode</tt> to the end of
<tt>$node</tt>&rsquo;s children. The function should fail,
if the new childnode is already a child of <tt>$node</tt>.
This function differs from the <small>DOM L2</small>
specification, in the case, if the new node is not part of
the document, the node will be imported first.</small></p>

<p style="margin-left:11%;"><small>addChild</small></p>

<pre style="margin-left:17%;">  $childnode = $node&minus;&gt;addChild( $childnode );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>As an
alternative to <i>appendChild()</i> one can use the
<i>addChild()</i> function. This function is a bit faster,
because it avoids all <small>DOM</small> conformity checks.
Therefore this function is quite useful if one builds
<small>XML</small> documents in memory where the order and
ownership (<tt>&quot;ownerDocument&quot;</tt>) is
assured.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i>addChild()</i>
uses libxml2&rsquo;s own <i>xmlAddChild()</i> function. Thus
it has to be used with extra care: If a text node is added
to a node and the node itself or its last childnode is as
well a text node, the node to add will be merged with the
one already available. The current node will be removed from
memory after this action. Because perl is not aware of this
action, the perl instance is still available. XML::LibXML
will catch the loss of a node and refuse to run any function
called on that node.</small></p>

<pre style="margin-left:17%; margin-top: 1em">  my $t1 = $doc&minus;&gt;createTextNode( &quot;foo&quot; );
   my $t2 = $doc&minus;&gt;createTextNode( &quot;bar&quot; );
   $t1&minus;&gt;addChild( $t2 );       # is OK
   my $val = $t2&minus;&gt;nodeValue(); # will fail, script dies</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Also
<i>addChild()</i> will not check if the added node belongs
to the same document as the node it will be added to. This
could lead to inconsistent documents and in more worse cases
even to memory violations, if one does not keep track of
this issue.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small>Although
this sounds like a lot of trouble, <i>addChild()</i> is
useful if a document is built from a stream, such as happens
sometimes in <small>SAX</small> handlers or
filters.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>If you
are not sure about the source of your nodes, you better stay
with <i>appendChild()</i>, because this function is more
user friendly in the sense of being more error
tolerant.</small></p>

<p style="margin-left:11%;"><small>addNewChild</small></p>

<pre style="margin-left:17%;">  $node = $parent&minus;&gt;addNewChild( $nsURI, $name );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Similar
to <tt>&quot;addChild()&quot;</tt>, this function uses low
level libxml2 functionality to provide faster interface for
<small>DOM</small> building. <i>addNewChild()</i> uses
<tt>&quot;xmlNewChild()&quot;</tt> to create a new node on a
given parent element.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i>addNewChild()</i>
has two parameters <tt>$nsURI</tt> and <tt>$name</tt>, where
<tt>$nsURI</tt> is an (optional) namespace
<small>URI.</small> <tt>$name</tt> is the fully qualified
element name; <i>addNewChild()</i> will determine the
correct prefix if necessary.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
function returns the newly created node.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>This
function is very useful for <small>DOM</small> building,
where a created node can be directly associated with its
parent. <i><small>NOTE</small></i> this function is not part
of the <small>DOM</small> specification and its use will
limit your code to XML::LibXML.</small></p>

<p style="margin-left:11%;"><small>addSibling</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;addSibling($newNode);</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>addSibling()</i>
allows adding an additional node to the end of a nodelist,
defined by the given node.</small></p>

<p style="margin-left:11%;"><small>cloneNode</small></p>

<pre style="margin-left:17%;">  $newnode =$node&minus;&gt;cloneNode( $deep );</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>cloneNode</i>
creates a copy of <tt>$node</tt>. When <tt>$deep</tt> is set
to 1 (true) the function will copy all child nodes as well.
If <tt>$deep</tt> is 0 only the current node will be copied.
Note that in case of element, attributes are copied even if
<tt>$deep</tt> is 0.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>Note
that the behavior of this function for <tt>$deep</tt>=0 has
changed in 1.62 in order to be consistent with the
<small>DOM</small> spec (in older versions attributes and
namespace information was not copied for
elements).</small></p>

<p style="margin-left:11%;"><small>parentNode</small></p>

<pre style="margin-left:17%;">  $parentnode = $node&minus;&gt;parentNode;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
simply the Parent Node of the current node.</small></p>

<p style="margin-left:11%;"><small>nextSibling</small></p>

<pre style="margin-left:17%;">  $nextnode = $node&minus;&gt;nextSibling();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
the next sibling if any .</small></p>


<p style="margin-left:11%;"><small>nextNonBlankSibling</small></p>


<pre style="margin-left:17%;">  $nextnode = $node&minus;&gt;nextNonBlankSibling();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
the next non-blank sibling if any (a node is blank if it is
a Text or <small>CDATA</small> node consisting of whitespace
only). This method is not defined by
<small>DOM.</small></small></p>


<p style="margin-left:11%;"><small>previousSibling</small></p>


<pre style="margin-left:17%;">  $prevnode = $node&minus;&gt;previousSibling();</pre>



<p style="margin-left:17%; margin-top: 1em"><small>Analogous
to <i>getNextSibling</i> the function returns the previous
sibling if any.</small></p>


<p style="margin-left:11%;"><small>previousNonBlankSibling</small></p>


<pre style="margin-left:17%;">  $prevnode = $node&minus;&gt;previousNonBlankSibling();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
the previous non-blank sibling if any (a node is blank if it
is a Text or <small>CDATA</small> node consisting of
whitespace only). This method is not defined by
<small>DOM.</small></small></p>


<p style="margin-left:11%;"><small>hasChildNodes</small></p>


<pre style="margin-left:17%;">  $boolean = $node&minus;&gt;hasChildNodes();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>If the
current node has child nodes this function returns
<small>TRUE \fIs0(1), otherwise it returns
<small>FALSE</small> (0, not undef).</small></small></p>


<p style="margin-left:11%;"><small><small>firstChild</small></small></p>


<pre style="margin-left:17%;">  $childnode = $node&minus;&gt;firstChild;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>If a
node has child nodes this function will return the first
node in the child list.</small></p>

<p style="margin-left:11%;"><small>lastChild</small></p>

<pre style="margin-left:17%;">  $childnode = $node&minus;&gt;lastChild;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>If the
<tt>$node</tt> has child nodes this function returns the
last child node.</small></p>


<p style="margin-left:11%;"><small>ownerDocument</small></p>


<pre style="margin-left:17%;">  $documentnode = $node&minus;&gt;ownerDocument;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Through
this function it is always possible to access the document
the current node is bound to.</small></p>

<p style="margin-left:11%;"><small>getOwner</small></p>

<pre style="margin-left:17%;">  $node = $node&minus;&gt;getOwner;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function returns the node the current node is associated
with. In most cases this will be a document node or a
document fragment node.</small></p>


<p style="margin-left:11%;"><small>setOwnerDocument</small></p>


<pre style="margin-left:17%;">  $node&minus;&gt;setOwnerDocument( $doc );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function binds a node to another <small>DOM.</small> This
method unbinds the node first, if it is already bound to
another document.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>This
function is the opposite calling of
XML::LibXML::Document&rsquo;s <i>adoptNode()</i> function.
Because of this it has the same limitations with Entity
References as <i>adoptNode()</i>.</small></p>


<p style="margin-left:11%;"><small>insertBefore</small></p>


<pre style="margin-left:17%;">  $node&minus;&gt;insertBefore( $newNode, $refNode );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>The
method inserts <tt>$newNode</tt> before <tt>$refNode</tt>.
If <tt>$refNode</tt> is undefined, the newNode will be set
as the new last child of the parent node. This function
differs from the <small>DOM L2</small> specification, in the
case, if the new node is not part of the document, the node
will be imported first, automatically.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><tt>$refNode</tt>
has to be passed to the function even if it is
undefined:</small></p>

<pre style="margin-left:17%; margin-top: 1em">  $node&minus;&gt;insertBefore( $newNode, undef ); # the same as $node&minus;&gt;appendChild( $newNode );
   $node&minus;&gt;insertBefore( $newNode ); # wrong</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Note,
that the reference node has to be a direct child of the node
the function is called on. Also, <tt>$newChild</tt> is not
allowed to be an ancestor of the new parent
node.</small></p>

<p style="margin-left:11%;"><small>insertAfter</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;insertAfter( $newNode, $refNode );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>The
method inserts <tt>$newNode</tt> after <tt>$refNode</tt>. If
<tt>$refNode</tt> is undefined, the newNode will be set as
the new last child of the parent node.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>Note,
that <tt>$refNode</tt> has to be passed explicitly even if
it is undef.</small></p>

<p style="margin-left:11%;"><small>findnodes</small></p>

<pre style="margin-left:17%;">  @nodes = $node&minus;&gt;findnodes( $xpath_expression );</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>findnodes</i>
evaluates the xpath expression (XPath 1.0) on the current
node and returns the resulting node set as an array. In
scalar context, returns an XML::LibXML::NodeList
object.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
xpath expression can be passed either as a string or or as a
XML::LibXML::XPathExpression object.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i><small>NOTE
ON NAMESPACES AND XPATH</small></i> :</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>A common
mistake about XPath is to assume that node tests consisting
of an element name with no prefix match elements in the
default namespace. This assumption is wrong &minus; by XPath
specification, such node tests can only match elements that
are in no (i.e. null) namespace.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>So, for
example, one cannot match the root element of an
<small>XHTML</small> document with
<tt>&quot;$node&minus;&gt;find('/html')&quot;</tt> since
<tt>'/html'</tt> would only match if the root element
<tt>&quot;&lt;html&gt;&quot;</tt> had no namespace, but all
<small>XHTML</small> elements belong to the namespace
http://www.w3.org/1999/xhtml. (Note that
<tt>&quot;xmlns=&quot;...&quot;&quot;</tt> namespace
declarations can also be specified in a <small>DTD,</small>
which makes the situation even worse, since the
<small>XML</small> document looks as if there was no default
namespace).</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>There
are several possible ways to deal with namespaces in
XPath:</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p><small>&bull;</small></p></td>
<td width="5%"></td>
<td width="77%">


<p><small>The recommended way is to use the
XML::LibXML::XPathContext module to define an explicit
context for XPath evaluation, in which a document
independent prefix-to-namespace mapping can be defined. For
example:</small></p> </td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">  my $xpc = XML::LibXML::XPathContext&minus;&gt;new;
  $xpc&minus;&gt;registerNs('x', 'http://www.w3.org/1999/xhtml');
  $xpc&minus;&gt;find('/x:html',$node);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em"><small>&bull;</small></p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em"><small>Another possibility is to
use prefixes declared in the queried document (if known). If
the document declares a prefix for the namespace in question
(and the context node is in the scope of the declaration),
<tt>&quot;XML::LibXML&quot;</tt> allows you to use the
prefix in the XPath expression, e.g.:</small></p></td></tr>
</table>

<pre style="margin-left:23%; margin-top: 1em">  $node&minus;&gt;find('/x:html');</pre>


<p style="margin-left:17%; margin-top: 1em"><small>See also
XML::LibXML::XPathContext&minus;&gt;findnodes.</small></p>

<p style="margin-left:11%;"><small>find</small></p>

<pre style="margin-left:17%;">  $result = $node&minus;&gt;find( $xpath );</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>find</i>
evaluates the XPath 1.0 expression using the current node as
the context of the expression, and returns the result
depending on what type of result the XPath expression had.
For example, the XPath &quot;1 * 3 + 52&quot; results in a
XML::LibXML::Number object being returned. Other expressions
might return an XML::LibXML::Boolean object, or an
XML::LibXML::Literal object (a string). Each of those
objects uses Perl&rsquo;s overload feature to &quot;do the
right thing&quot; in different contexts.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
xpath expression can be passed either as a string or or as a
XML::LibXML::XPathExpression object.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>See also
XML::LibXML::XPathContext&minus;&gt;find.</small></p>

<p style="margin-left:11%;"><small>findvalue</small></p>

<pre style="margin-left:17%;">  print $node&minus;&gt;findvalue( $xpath );</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>findvalue</i>
is exactly equivalent to:</small></p>

<pre style="margin-left:17%; margin-top: 1em">  $node&minus;&gt;find( $xpath )&minus;&gt;to_literal;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>That is,
it returns the literal value of the results. This enables
you to ensure that you get a string back from your search,
allowing certain shortcuts. This could be used as the
equivalent of <small>XSLT</small> &rsquo;s
&lt;xsl:value&minus;of
select=&quot;some_xpath&quot;/&gt;.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>See also
XML::LibXML::XPathContext&minus;&gt;findvalue.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
xpath expression can be passed either as a string or or as a
XML::LibXML::XPathExpression object.</small></p>

<p style="margin-left:11%;"><small>exists</small></p>

<pre style="margin-left:17%;">  $bool = $node&minus;&gt;exists( $xpath_expression );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
method behaves like <i>findnodes</i>, except that it only
returns a boolean value (1 if the expression matches a node,
0 otherwise) and may be faster than <i>findnodes</i>,
because the XPath evaluation may stop early on the first
match (this is true for libxml2 &gt;= 2.6.27).</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>For
XPath expressions that do not return node-set, the method
returns true if the returned value is a non-zero number or a
non-empty string.</small></p>

<p style="margin-left:11%;"><small>childNodes</small></p>

<pre style="margin-left:17%;">  @childnodes = $node&minus;&gt;childNodes();</pre>



<p style="margin-left:17%; margin-top: 1em"><small><i>childNodes</i>
implements a more intuitive interface to the childnodes of
the current node. It enables you to pass all children
directly to a <tt>&quot;map&quot;</tt> or
<tt>&quot;grep&quot;</tt>. If this function is called in
scalar context, a XML::LibXML::NodeList object will be
returned.</small></p>


<p style="margin-left:11%;"><small>nonBlankChildNodes</small></p>


<pre style="margin-left:17%;">  @childnodes = $node&minus;&gt;nonBlankChildNodes();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This is
like <i>childNodes</i>, but returns only non-blank nodes
(where a node is blank if it is a Text or
<small>CDATA</small> node consisting of whitespace only).
This method is not defined by
<small>DOM.</small></small></p>

<p style="margin-left:11%;"><small>toString</small></p>

<pre style="margin-left:17%;">  $xmlstring = $node&minus;&gt;toString($format,$docencoding);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
method is similar to the method
<tt>&quot;toString&quot;</tt> of a XML::LibXML::Document but
for a single node. It returns a string consisting of
<small>XML</small> serialization of the given node and all
its descendants. Unlike
<tt>&quot;XML::LibXML::Document::toString&quot;</tt>, in
this case the resulting string is by default a character
string ( <small>UTF&minus;8</small> encoded with
<small>UTF8</small> flag on). An optional flag
<tt>$format</tt> controls indentation, as in
<tt>&quot;XML::LibXML::Document::toString&quot;</tt>. If the
second optional <tt>$docencoding</tt> flag is true, the
result will be a byte string in the document encoding (see
<tt>&quot;XML::LibXML::Document::actualEncoding&quot;</tt>).</small></p>


<p style="margin-left:11%;"><small>toStringC14N</small></p>


<pre style="margin-left:17%;">  $c14nstring = $node&minus;&gt;toStringC14N();
  $c14nstring = $node&minus;&gt;toStringC14N($with_comments, $xpath_expression , $xpath_context);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>The
function is similar to <i>toString()</i>. Instead of simply
serializing the document tree, it transforms it as it is
specified in the <small>XML&minus;C14N</small> Specification
(see &lt;http://www.w3.org/TR/xml&minus;c14n&gt;). Such
transformation is known as canonization.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>If
<tt>$with_comments</tt> is 0 or not defined, the
result-document will not contain any comments that exist in
the original document. To include comments into the
canonized document, <tt>$with_comments</tt> has to be set to
1.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
parameter <tt>$xpath_expression</tt> defines the nodeset of
nodes that should be visible in the resulting document. This
can be used to filter out some nodes. One has to note, that
only the nodes that are part of the nodeset, will be
included into the result-document. Their child-nodes will
not exist in the resulting document, unless they are part of
the nodeset defined by the xpath expression.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>If
<tt>$xpath_expression</tt> is omitted or empty,
<i>toStringC14N()</i> will include all nodes in the given
sub-tree, using the following XPath expressions: with
comments</small></p>

<pre style="margin-left:17%; margin-top: 1em">  (. | .//node() | .//@* | .//namespace::*)</pre>


<p style="margin-left:17%; margin-top: 1em"><small>and
without comments</small></p>

<pre style="margin-left:17%; margin-top: 1em">  (. | .//node() | .//@* | .//namespace::*)[not(self::comment())]</pre>


<p style="margin-left:17%; margin-top: 1em"><small>An
optional parameter <tt>$xpath_context</tt> can be used to
pass an XML::LibXML::XPathContext object defining the
context for evaluation of <tt>$xpath_expression</tt>. This
is useful for mapping namespace prefixes used in the XPath
expression to namespace URIs. Note, however, that
<tt>$node</tt> will be used as the context node for the
evaluation, not the context node of
<tt>$xpath_context</tt>!</small></p>


<p style="margin-left:11%;"><small>toStringEC14N</small></p>


<pre style="margin-left:17%;">  $ec14nstring = $node&minus;&gt;toStringEC14N();
  $ec14nstring = $node&minus;&gt;toStringEC14N($with_comments, $xpath_expression, $inclusive_prefix_list);
  $ec14nstring = $node&minus;&gt;toStringEC14N($with_comments, $xpath_expression, $xpath_context, $inclusive_prefix_list);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>The
function is similar to <i>toStringC14N()</i> but follows the
<small>XML&minus;EXC&minus;C14N</small> Specification (see
&lt;http://www.w3.org/TR/xml&minus;exc&minus;c14n&gt;) for
exclusive canonization of <small>XML.</small></small></p>

<p style="margin-left:17%; margin-top: 1em"><small>The
arguments <tt>$with_comments</tt>,
<tt>$xpath_expression</tt>, <tt>$xpath_context</tt> are as
in <i>toStringC14N()</i>. An <small>ARRAY</small> reference
can be passed as the last argument
<tt>$inclusive_prefix_list</tt>, listing namespace prefixes
that are to be handled in the manner described by the
Canonical <small>XML</small> Recommendation (i.e. preserved
in the output even if the namespace is not used). C.f. the
spec for details.</small></p>

<p style="margin-left:11%;"><small>serialize</small></p>

<pre style="margin-left:17%;">  $str = $doc&minus;&gt;serialize($format);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>An alias
for <i>toString()</i>. This function was name added to be
more consistent with libxml2.</small></p>


<p style="margin-left:11%;"><small>serialize_c14n</small></p>

<p style="margin-left:17%;"><small>An alias for
<i>toStringC14N()</i>.</small></p>


<p style="margin-left:11%;"><small>serialize_exc_c14n</small></p>

<p style="margin-left:17%;"><small>An alias for
<i>toStringEC14N()</i>.</small></p>

<p style="margin-left:11%;"><small>localname</small></p>

<pre style="margin-left:17%;">  $localname = $node&minus;&gt;localname;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
the local name of a tag. This is the part behind the
colon.</small></p>

<p style="margin-left:11%;"><small>prefix</small></p>

<pre style="margin-left:17%;">  $nameprefix = $node&minus;&gt;prefix;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Returns
the prefix of a tag. This is the part before the
colon.</small></p>


<p style="margin-left:11%;"><small>namespaceURI</small></p>


<pre style="margin-left:17%;">  $uri = $node&minus;&gt;namespaceURI();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>returns
the <small>URI</small> of the current namespace.</small></p>


<p style="margin-left:11%;"><small>hasAttributes</small></p>


<pre style="margin-left:17%;">  $boolean = $node&minus;&gt;hasAttributes();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>returns
1 ( <small>TRUE</small> ) if the current node has any
attributes set, otherwise 0 ( <small>FALSE</small> ) is
returned.</small></p>

<p style="margin-left:11%;"><small>attributes</small></p>

<pre style="margin-left:17%;">  @attributelist = $node&minus;&gt;attributes();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function returns all attributes and namespace declarations
assigned to the given node.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>Because
XML::LibXML does not implement namespace declarations and
attributes the same way, it is required to test what kind of
node is handled while accessing the functions
result.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>If this
function is called in array context the attribute nodes are
returned as an array. In scalar context, the function will
return a XML::LibXML::NamedNodeMap object.</small></p>


<p style="margin-left:11%;"><small>lookupNamespaceURI</small></p>


<pre style="margin-left:17%;">  $URI = $node&minus;&gt;lookupNamespaceURI( $prefix );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Find a
namespace <small>URI</small> by its prefix starting at the
current node.</small></p>


<p style="margin-left:11%;"><small>lookupNamespacePrefix</small></p>


<pre style="margin-left:17%;">  $prefix = $node&minus;&gt;lookupNamespacePrefix( $URI );</pre>


<p style="margin-left:17%; margin-top: 1em"><small>Find a
namespace prefix by its <small>URI</small> starting at the
current node.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><i><small>NOTE</small></i>
Only the namespace URIs are meant to be unique. The prefix
is only document related. Also the document might have more
than a single prefix defined for a namespace.</small></p>

<p style="margin-left:11%;"><small>normalize</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;normalize;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function normalizes adjacent text nodes. This function is
not as strict as libxml2&rsquo;s <i>xmlTextMerge()</i>
function, since it will not free a node that is still
referenced by the perl layer.</small></p>


<p style="margin-left:11%;"><small>getNamespaces</small></p>


<pre style="margin-left:17%;">  @nslist = $node&minus;&gt;getNamespaces;</pre>


<p style="margin-left:17%; margin-top: 1em"><small>If a
node has any namespaces defined, this function will return
these namespaces. Note, that this will not return all
namespaces that are in scope, but only the ones declared
explicitly for that node.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small>Although
getNamespaces is available for all nodes, it only makes
sense if used with element nodes.</small></p>


<p style="margin-left:11%;"><small>removeChildNodes</small></p>


<pre style="margin-left:17%;">  $node&minus;&gt;removeChildNodes();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function is not specified for any <small>DOM</small> level:
It removes all childnodes from a node in a single step.
Other than the libxml2 function itself (xmlFreeNodeList),
this function will not immediately remove the nodes from the
memory. This saves one from getting memory violations, if
there are nodes still referred to from the Perl
level.</small></p>

<p style="margin-left:11%;"><small>baseURI ()</small></p>

<pre style="margin-left:17%;">  $strURI = $node&minus;&gt;baseURI();</pre>



<p style="margin-left:17%; margin-top: 1em"><small>Searches
for the base <small>URL</small> of the node. The method
should work on both <small>XML</small> and
<small>HTML</small> documents even if base mechanisms for
these are completely different. It returns the base as
defined in <small>RFC 2396</small> sections &quot;5.1.1.
Base <small>URI</small> within Document Content&quot; and
&quot;5.1.2. Base <small>URI</small> from the Encapsulating
Entity&quot;. However it does not return the document base
(5.1.3), use method <tt>&quot;URI&quot;</tt> of
<tt>&quot;XML::LibXML::Document&quot;</tt> for
this.</small></p>

<p style="margin-left:11%;"><small>setBaseURI
($strURI)</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;setBaseURI($strURI);</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
method only does something useful for an element node in an
<small>XML</small> document. It sets the xml:base attribute
on the node to <tt>$strURI</tt>, which effectively sets the
base <small>URI</small> of the node to the same
value.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>Note:
For <small>HTML</small> documents this behaves as if the
document was <small>XML</small> which may not be desired,
since it does not effectively set the base
<small>URI</small> of the node. See <small>RFC 2396</small>
appendix D for an example of how base <small>URI</small> can
be specified in <small>HTML.</small></small></p>

<p style="margin-left:11%;"><small>nodePath</small></p>

<pre style="margin-left:17%;">  $node&minus;&gt;nodePath();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function is not specified for any <small>DOM</small> level:
It returns a canonical structure based XPath for a given
node.</small></p>

<p style="margin-left:11%;"><small>line_number</small></p>

<pre style="margin-left:17%;">  $lineno = $node&minus;&gt;line_number();</pre>


<p style="margin-left:17%; margin-top: 1em"><small>This
function returns the line number where the tag was found
during parsing. If a node is added to the document the line
number is 0. Problems may occur, if a node from one document
is passed to another one.</small></p>


<p style="margin-left:17%; margin-top: 1em"><small><small>IMPORTANT:</small>
Due to limitations in the libxml2 library line numbers
greater than 65535 will be returned as 65535. Please see
&lt;http://bugzilla.gnome.org/show_bug.cgi?id=325533&gt; for
more details.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>Note:
<i>line_number()</i> is special to XML::LibXML and not part
of the <small>DOM</small> specification.</small></p>

<p style="margin-left:17%; margin-top: 1em"><small>If the
line_numbers flag of the parser was not activated before
parsing, <i>line_number()</i> will always return
0.</small></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><small>Matt
Sergeant, Christian Glahn, Petr Pajas</small></p>

<h2>VERSION
<a name="VERSION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>2.0018</small></p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>2001&minus;2007,
AxKit.com Ltd.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small>2002&minus;2006,
Christian Glahn.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small>2006&minus;2009,
Petr Pajas.</small></p>
<hr>
</body>
</html>
