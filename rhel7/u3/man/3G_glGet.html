<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:30:56 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GLGET</title>

</head>
<body>

<h1 align="center">GLGET</h1>

<a href="#NAME">NAME</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#PARAMETERS">PARAMETERS</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br>
<a href="#PARAMETERS">PARAMETERS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">glGet &minus;
return the value or values of a selected parameter</p>

<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="81%">


<p style="margin-top: 1em"><b>void
glGetBooleanv(GLenum&nbsp;</b><i>pname</i><b>,
GLboolean&nbsp;*&nbsp;</b><i>params</i><b>);</b></p> </td>
<td width="8%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="78%"></td>
<td width="11%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="78%">


<p><b>void glGetDoublev(GLenum&nbsp;</b><i>pname</i><b>,
GLdouble&nbsp;*&nbsp;</b><i>params</i><b>);</b></p> </td>
<td width="11%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="75%"></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="75%">


<p><b>void glGetFloatv(GLenum&nbsp;</b><i>pname</i><b>,
GLfloat&nbsp;*&nbsp;</b><i>params</i><b>);</b></p> </td>
<td width="14%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="75%"></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="75%">


<p><b>void glGetIntegerv(GLenum&nbsp;</b><i>pname</i><b>,
GLint&nbsp;*&nbsp;</b><i>params</i><b>);</b></p> </td>
<td width="14%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="81%"></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="81%">


<p><b>void glGetInteger64v(GLenum&nbsp;</b><i>pname</i><b>,
GLint64&nbsp;*&nbsp;</b><i>params</i><b>);</b></p> </td>
<td width="8%">
</td></tr>
</table>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><i>pname</i></b></p>

<p style="margin-left:17%;">Specifies the parameter value
to be returned. The symbolic constants in the list below are
accepted.</p>


<p style="margin-left:11%; margin-top: 1em"><i>params</i></p>

<p style="margin-left:17%;">Returns the value or values of
the specified parameter.</p>

<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>void
glGetBooleani_v(GLenum&nbsp;</b><i>pname</i><b>,
GLuint&nbsp;</b><i>index</i><b>,
GLboolean&nbsp;*&nbsp;</b><i>data</i><b>);</b></p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>void glGetIntegeri_v(GLenum&nbsp;</b><i>pname</i><b>,
GLuint&nbsp;</b><i>index</i><b>,
GLint&nbsp;*&nbsp;</b><i>data</i><b>);</b></p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>void glGetFloati_v(GLenum&nbsp;</b><i>pname</i><b>,
GLuint&nbsp;</b><i>index</i><b>,
GLfloat&nbsp;*&nbsp;</b><i>data</i><b>);</b></p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>void glGetDoublei_v(GLenum&nbsp;</b><i>pname</i><b>,
GLuint&nbsp;</b><i>index</i><b>,
GLdouble&nbsp;*&nbsp;</b><i>data</i><b>);</b></p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<td width="11%"></td>
<td width="89%">


<p><b>void
glGetInteger64i_v(GLenum&nbsp;</b><i>pname</i><b>,
GLuint&nbsp;</b><i>index</i><b>,
GLint64&nbsp;*&nbsp;</b><i>data</i><b>);</b></p> </td></tr>
</table>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><i>pname</i></b></p>

<p style="margin-left:17%;">Specifies the parameter value
to be returned. The symbolic constants in the list below are
accepted.</p>


<p style="margin-left:11%; margin-top: 1em"><i>index</i></p>

<p style="margin-left:17%;">Specifies the index of the
particular element being queried.</p>


<p style="margin-left:11%; margin-top: 1em"><i>data</i></p>

<p style="margin-left:17%;">Returns the value or values of
the specified parameter.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These four
commands return values for simple state variables in GL.
<i>pname</i> is a symbolic constant indicating the state
variable to be returned, and <i>params</i> is a pointer to
an array of the indicated type in which to place the
returned data.</p>

<p style="margin-left:11%; margin-top: 1em">Type conversion
is performed if <i>params</i> has a different type than the
state variable value being requested. If
<b>glGetBooleanv</b> is called, a floating&minus;point (or
integer) value is converted to <b>GL_FALSE</b> if and only
if it is 0.0 (or 0). Otherwise, it is converted to
<b>GL_TRUE</b>. If <b>glGetIntegerv</b> is called, boolean
values are returned as <b>GL_TRUE</b> or <b>GL_FALSE</b>,
and most floating&minus;point values are rounded to the
nearest integer value. Floating&minus;point colors and
normals, however, are returned with a linear mapping that
maps 1.0 to the most positive representable integer value
and &minus;1.0 to the most negative representable integer
value. If <b>glGetFloatv</b> or <b>glGetDoublev</b> is
called, boolean values are returned as <b>GL_TRUE</b> or
<b>GL_FALSE</b>, and integer values are converted to
floating&minus;point values.</p>

<p style="margin-left:11%; margin-top: 1em">The following
symbolic constants are accepted by <i>pname</i>:</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_ACTIVE_TEXTURE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value indicating the active multitexture
unit. The initial value is <b>GL_TEXTURE0</b>. See
<b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_ALIASED_LINE_WIDTH_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a pair of values indicating the range of widths
supported for aliased lines. See <b>glLineWidth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_ARRAY_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the target <b>GL_ARRAY_BUFFER</b>. If no
buffer object is bound to this target, 0 is returned. The
initial value is 0. See <b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether blending
is enabled. The initial value is <b>GL_FALSE</b>. See
<b>glBlendFunc</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_COLOR</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns four values, the red, green, blue, and alpha values
which are the components of the blend color. See
<b>glBlendColor</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_DST_ALPHA</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the symbolic constant identifying the
alpha destination blend function. The initial value is
<b>GL_ZERO</b>. See <b>glBlendFunc</b>() and
<b>glBlendFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_DST_RGB</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the symbolic constant identifying the RGB
destination blend function. The initial value is
<b>GL_ZERO</b>. See <b>glBlendFunc</b>() and
<b>glBlendFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_EQUATION_RGB</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating whether
the RGB blend equation is <b>GL_FUNC_ADD</b>,
<b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
<b>GL_MIN</b> or <b>GL_MAX</b>. See
<b>glBlendEquationSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_EQUATION_ALPHA</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating whether
the Alpha blend equation is <b>GL_FUNC_ADD</b>,
<b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>,
<b>GL_MIN</b> or <b>GL_MAX</b>. See
<b>glBlendEquationSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_SRC_ALPHA</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the symbolic constant identifying the
alpha source blend function. The initial value is
<b>GL_ONE</b>. See <b>glBlendFunc</b>() and
<b>glBlendFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_BLEND_SRC_RGB</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the symbolic constant identifying the RGB
source blend function. The initial value is <b>GL_ONE</b>.
See <b>glBlendFunc</b>() and
<b>glBlendFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_COLOR_CLEAR_VALUE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns four values: the red, green, blue, and alpha values
used to clear the color buffers. Integer values, if
requested, are linearly mapped from the internal
floating&minus;point representation such that 1.0 returns
the most positive representable integer value, and
&minus;1.0 returns the most negative representable integer
value. The initial value is (0, 0, 0, 0). See
<b>glClearColor</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_COLOR_LOGIC_OP</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether a
fragment's RGBA color values are merged into the framebuffer
using a logical operation. The initial value is
<b>GL_FALSE</b>. See <b>glLogicOp</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_COLOR_WRITEMASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns four boolean values: the red, green, blue, and alpha
write enables for the color buffers. The initial value is
(<b>GL_TRUE</b>, <b>GL_TRUE</b>, <b>GL_TRUE</b>,
<b>GL_TRUE</b>). See <b>glColorMask</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_COMPRESSED_TEXTURE_FORMATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a list of symbolic constants of length
<b>GL_NUM_COMPRESSED_TEXTURE_FORMATS</b> indicating which
compressed texture formats are available. See
<b>glCompressedTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a compute shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum total number of active shader
storage blocks that may be accessed by all active
shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_UNIFORM_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform blocks per
compute shader. The value must be at least 14. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum supported texture image units
that can be used to access texture maps from the compute
shader. The value may be at least 16. See
<b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of individual
floating&minus;point, integer, or boolean values that can be
held in uniform variable storage for a compute shader. The
value must be at least 1024. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to compute shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic counter
buffers that may be accessed by a compute shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of words for compute shader
uniform variables in all uniform blocks (including default).
The value must be at least 1. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of invocations in a single
local work group (i.e., the product of the three dimensions)
that may be dispatched to a compute shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_WORK_GROUP_COUNT</b></p>

<p style="margin-left:17%; margin-top: 1em">Accepted by the
indexed versions of <b>glGet</b>. <i>params</i> the maximum
number of work groups that may be dispatched to a compute
shader. Indices 0, 1, and 2 correspond to the X, Y and Z
dimensions, respectively.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_WORK_GROUP_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em">Accepted by the
indexed versions of <b>glGet</b>. <i>params</i> the maximum
size of a work groups that may be used during compilation of
a compute shader. Indices 0, 1, and 2 correspond to the X, Y
and Z dimensions, respectively.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DISPATCH_INDIRECT_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the target
<b>GL_DISPATCH_INDIRECT_BUFFER</b>. If no buffer object is
bound to this target, 0 is returned. The initial value is 0.
See <b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_DEBUG_GROUP_STACK_DEPTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum depth of the debug
message group stack.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEBUG_GROUP_STACK_DEPTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the current depth of the debug
message group stack.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_CONTEXT_FLAGS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the flags with which the context was
created (such as debugging functionality).</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_CULL_FACE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether polygon
culling is enabled. The initial value is <b>GL_FALSE</b>.
See <b>glCullFace</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_CURRENT_PROGRAM</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the name of the program object that is
currently active, or 0 if no program object is active. See
<b>glUseProgram</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEPTH_CLEAR_VALUE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the value that is used to clear the depth
buffer. Integer values, if requested, are linearly mapped
from the internal floating&minus;point representation such
that 1.0 returns the most positive representable integer
value, and &minus;1.0 returns the most negative
representable integer value. The initial value is 1. See
<b>glClearDepth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEPTH_FUNC</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the symbolic constant that indicates the
depth comparison function. The initial value is
<b>GL_LESS</b>. See <b>glDepthFunc</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEPTH_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns two values: the near and far mapping limits for the
depth buffer. Integer values, if requested, are linearly
mapped from the internal floating&minus;point representation
such that 1.0 returns the most positive representable
integer value, and &minus;1.0 returns the most negative
representable integer value. The initial value is (0, 1).
See <b>glDepthRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEPTH_TEST</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether depth
testing of fragments is enabled. The initial value is
<b>GL_FALSE</b>. See <b>glDepthFunc</b>() and
<b>glDepthRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DEPTH_WRITEMASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating if the depth
buffer is enabled for writing. The initial value is
<b>GL_TRUE</b>. See <b>glDepthMask</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DITHER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether dithering
of fragment colors and indices is enabled. The initial value
is <b>GL_TRUE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DOUBLEBUFFER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether double
buffering is supported.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DRAW_BUFFER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating which
buffers are being drawn to. See <b>glDrawBuffer</b>(). The
initial value is <b>GL_BACK</b> if there are back buffers,
otherwise it is <b>GL_FRONT</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DRAW_BUFFER</b><i>i</i></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating which
buffers are being drawn to by the corresponding output
color. See <b>glDrawBuffers</b>(). The initial value of
<b>GL_DRAW_BUFFER0</b> is <b>GL_BACK</b> if there are back
buffers, otherwise it is <b>GL_FRONT</b>. The initial values
of draw buffers for all other output colors is
<b>GL_NONE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_DRAW_FRAMEBUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the name of the framebuffer object
currently bound to the <b>GL_DRAW_FRAMEBUFFER</b> target. If
the default framebuffer is bound, this value will be zero.
The initial value is zero. See
<b>glBindFramebuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_READ_FRAMEBUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the name of the framebuffer object
currently bound to the <b>GL_READ_FRAMEBUFFER</b> target. If
the default framebuffer is bound, this value will be zero.
The initial value is zero. See
<b>glBindFramebuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_ELEMENT_ARRAY_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the target
<b>GL_ELEMENT_ARRAY_BUFFER</b>. If no buffer object is bound
to this target, 0 is returned. The initial value is 0. See
<b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating the mode
of the derivative accuracy hint for fragment shaders. The
initial value is <b>GL_DONT_CARE</b>. See
<b>glHint</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_IMPLEMENTATION_COLOR_READ_FORMAT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single GLenum value indicating the
implementation's preferred pixel data format. See
<b>glReadPixels</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_IMPLEMENTATION_COLOR_READ_TYPE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single GLenum value indicating the
implementation's preferred pixel data type. See
<b>glReadPixels</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LINE_SMOOTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether
antialiasing of lines is enabled. The initial value is
<b>GL_FALSE</b>. See <b>glLineWidth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LINE_SMOOTH_HINT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating the mode
of the line antialiasing hint. The initial value is
<b>GL_DONT_CARE</b>. See <b>glHint</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LINE_WIDTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the line width as specified with
<b>glLineWidth</b>(). The initial value is 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LAYER_PROVOKING_VERTEX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the implementation dependent specifc
vertex of a primitive that is used to select the rendering
layer. If the value returned is equivalent to
<b>GL_PROVOKING_VERTEX</b>, then the vertex selection
follows the convention specified by
<b>glProvokingVertex</b>(). If the value returned is
equivalent to <b>GL_FIRST_VERTEX_CONVENTION</b>, then the
selection is always taken from the first vertex in the
primitive. If the value returned is equivalent to
<b>GL_LAST_VERTEX_CONVENTION</b>, then the selection is
always taken from the last vertex in the primitive. If the
value returned is equivalent to <b>GL_UNDEFINED_VERTEX</b>,
then the selection is not guaranteed to be taken from any
specific vertex in the primitive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LINE_WIDTH_GRANULARITY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the width difference between adjacent
supported widths for antialiased lines. See
<b>glLineWidth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LINE_WIDTH_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns two values: the smallest and largest supported
widths for antialiased lines. See <b>glLineWidth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_LOGIC_OP_MODE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating the
selected logic operation mode. The initial value is
<b>GL_COPY</b>. See <b>glLogicOp</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAJOR_VERSION</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the major version number of the OpenGL
API supported by the current context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_3D_TEXTURE_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a rough estimate of the largest 3D
texture that the GL can handle. The value must be at least
64. Use <b>GL_PROXY_TEXTURE_3D</b> to determine if a texture
is too large. See <b>glTexImage3D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_ARRAY_TEXTURE_LAYERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value indicates the maximum number of
layers allowed in an array texture, and must be at least
256. See <b>glTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_CLIP_DISTANCES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of
application&minus;defined clipping distances. The value must
be at least 8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COLOR_TEXTURE_SAMPLES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of samples in a color
multisample texture.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to all active shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of words for fragment shader
uniform variables in all uniform blocks (including default).
The value must be at least 1. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of words for geometry shader
uniform variables in all uniform blocks (including default).
The value must be at least 1. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum supported texture image units
that can be used to access texture maps from the vertex
shader and the fragment processor combined. If both the
vertex shader and the fragment processing stage access the
same texture image unit, then that counts as using two
texture image units against this limit. The value must be at
least 48. See <b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_UNIFORM_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform blocks per
program. The value must be at least 36. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of words for vertex shader
uniform variables in all uniform blocks (including default).
The value must be at least 1. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_CUBE_MAP_TEXTURE_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value gives a rough estimate of the
largest cube&minus;map texture that the GL can handle. The
value must be at least 1024. Use
<b>GL_PROXY_TEXTURE_CUBE_MAP</b> to determine if a texture
is too large. See <b>glTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_DEPTH_TEXTURE_SAMPLES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of samples in a
multisample depth or depth&minus;stencil texture.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_DRAW_BUFFERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of simultaneous
outputs that may be written in a fragment shader. The value
must be at least 8. See <b>glDrawBuffers</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_DUALSOURCE_DRAW_BUFFERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active draw buffers
when using dual&minus;source blending. The value must be at
least 1. See <b>glBlendFunc</b>() and
<b>glBlendFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_ELEMENTS_INDICES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the recommended maximum number of vertex
array indices. See <b>glDrawRangeElements</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_ELEMENTS_VERTICES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the recommended maximum number of vertex
array vertices. See <b>glDrawRangeElements</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to fragment shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a fragment
shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_INPUT_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of components of the
inputs read by the fragment shader, which must be at least
128.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of individual
floating&minus;point, integer, or boolean values that can be
held in uniform variable storage for a fragment shader. The
value must be at least 1024. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_UNIFORM_VECTORS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of individual
4&minus;vectors of floating&minus;point, integer, or boolean
values that can be held in uniform variable storage for a
fragment shader. The value is equal to the value of
<b>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</b> divided by 4 and
must be at least 256. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAGMENT_UNIFORM_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform blocks per
fragment shader. The value must be at least 12. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAMEBUFFER_WIDTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum width for a framebuffer that
has no attachments, which must be at least 16384. See
<b>glFramebufferParameter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAMEBUFFER_HEIGHT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum height for a framebuffer that
has no attachments, which must be at least 16384. See
<b>glFramebufferParameter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAMEBUFFER_LAYERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of layers for a
framebuffer that has no attachments, which must be at least
2048. See <b>glFramebufferParameter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAMEBUFFER_SAMPLES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum samples in a framebuffer that
has no attachments, which must be at least 4. See
<b>glFramebufferParameter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to geometry shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a geometry
shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_INPUT_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of components of
inputs read by a geometry shader, which must be at least
64.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_OUTPUT_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of components of
outputs written by a geometry shader, which must be at least
128.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum supported texture image units
that can be used to access texture maps from the geometry
shader. The value must be at least 16. See
<b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_UNIFORM_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform blocks per
geometry shader. The value must be at least 12. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_GEOMETRY_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of individual
floating&minus;point, integer, or boolean values that can be
held in uniform variable storage for a geometry shader. The
value must be at least 1024. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_INTEGER_SAMPLES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of samples supported
in integer format multisample buffers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MIN_MAP_BUFFER_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the minimum alignment in basic machine
units of pointers returned from<b>glMapBuffer</b>() and
<b>glMapBufferRange</b>(). This value must be a power of two
and must be at least 64.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_LABEL_LENGTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum length of a label that may be
assigned to an object. See <b>glObjectLabel</b>() and
<b>glObjectPtrLabel</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_PROGRAM_TEXEL_OFFSET</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum texel offset allowed in a
texture lookup, which must be at least 7.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MIN_PROGRAM_TEXEL_OFFSET</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the minimum texel offset allowed in a
texture lookup, which must be at most &minus;8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_RECTANGLE_TEXTURE_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value gives a rough estimate of the
largest rectangular texture that the GL can handle. The
value must be at least 1024. Use
<b>GL_PROXY_RECTANGLE_TEXTURE</b> to determine if a texture
is too large. See <b>glTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_RENDERBUFFER_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value indicates the maximum supported
size for renderbuffers. See
<b>glFramebufferRenderbuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_SAMPLE_MASK_WORDS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of sample mask
words.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_SERVER_WAIT_TIMEOUT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum <b>glWaitSync</b>() timeout
interval.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of shader storage
buffer binding points on the context, which must be at least
8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to tessellation control shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to tessellation evaluation shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a tessellation
control shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a tessellation
evaluation shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TEXTURE_BUFFER_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value gives the maximum number of
texels allowed in the texel array of a texture buffer
object. Value must be at least 65536.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TEXTURE_IMAGE_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum supported texture image units
that can be used to access texture maps from the fragment
shader. The value must be at least 16. See
<b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TEXTURE_LOD_BIAS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum, absolute value of the
texture level&minus;of&minus;detail bias. The value must be
at least 2.0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_TEXTURE_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. The value gives a rough estimate of the
largest texture that the GL can handle. The value must be at
least 1024. Use a proxy texture target such as
<b>GL_PROXY_TEXTURE_1D</b> or <b>GL_PROXY_TEXTURE_2D</b> to
determine if a texture is too large. See
<b>glTexImage1D</b>() and <b>glTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_UNIFORM_BUFFER_BINDINGS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform buffer
binding points on the context, which must be at least
36.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_UNIFORM_BLOCK_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum size in basic machine units
of a uniform block, which must be at least 16384.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_UNIFORM_LOCATIONS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of explicitly
assignable uniform locations, which must be at least
1024.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VARYING_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number components for varying
variables, which must be at least 60.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VARYING_VECTORS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number 4&minus;vectors for varying
variables, which is equal to the value of
<b>GL_MAX_VARYING_COMPONENTS</b> and must be at least
15.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VARYING_FLOATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of interpolators
available for processing varying variables used by vertex
and fragment shaders. This value represents the number of
individual floating&minus;point values that can be
interpolated; varying variables declared as vectors,
matrices, and arrays will all consume multiple
interpolators. The value must be at least 32.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_ATOMIC_COUNTERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum number of atomic
counters available to vertex shaders.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_ATTRIBS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of 4&minus;component
generic vertex attributes accessible to a vertex shader. The
value must be at least 16. See <b>glVertexAttrib</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of active shader
storage blocks that may be accessed by a vertex shader.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum supported texture image units
that can be used to access texture maps from the vertex
shader. The value may be at least 16. See
<b>glActiveTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_UNIFORM_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of individual
floating&minus;point, integer, or boolean values that can be
held in uniform variable storage for a vertex shader. The
value must be at least 1024. See <b>glUniform</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_UNIFORM_VECTORS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of 4&minus;vectors
that may be held in uniform variable storage for the vertex
shader. The value of <b>GL_MAX_VERTEX_UNIFORM_VECTORS</b> is
equal to the value of
<b>GL_MAX_VERTEX_UNIFORM_COMPONENTS</b> and must be at least
256.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_OUTPUT_COMPONENTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of components of
output written by a vertex shader, which must be at least
64.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_UNIFORM_BLOCKS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of uniform blocks per
vertex shader. The value must be at least 12. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VIEWPORT_DIMS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns two values: the maximum supported width and height
of the viewport. These must be at least as large as the
visible dimensions of the display being rendered to. See
<b>glViewport</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VIEWPORTS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the maximum number of simultaneous
viewports that are supported. The value must be at least 16.
See <b>glViewportIndexed</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MINOR_VERSION</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the minor version number of the OpenGL
API supported by the current context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_NUM_COMPRESSED_TEXTURE_FORMATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single integer value indicating the number of
available compressed texture formats. The minimum value is
4. See <b>glCompressedTexImage2D</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_NUM_EXTENSIONS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of extensions supported by the
GL implementation for the current context. See
<b>glGetString</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_NUM_PROGRAM_BINARY_FORMATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of program binary formats
supported by the implementation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_NUM_SHADER_BINARY_FORMATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of binary shader formats
supported by the implementation. If this value is greater
than zero, then the implementation supports loading binary
shaders. If it is zero, then the loading of binary shaders
by the implementation is not supported.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the byte alignment used for writing pixel
data to memory. The initial value is 4. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_IMAGE_HEIGHT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the image height used for writing pixel
data to memory. The initial value is 0. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_LSB_FIRST</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether
single&minus;bit pixels being written to memory are written
first to the least significant bit of each unsigned byte.
The initial value is <b>GL_FALSE</b>. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_ROW_LENGTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the row length used for writing pixel
data to memory. The initial value is 0. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_SKIP_IMAGES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of pixel images skipped before
the first pixel is written into memory. The initial value is
0. See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_SKIP_PIXELS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of pixel locations skipped
before the first pixel is written into memory. The initial
value is 0. See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_SKIP_ROWS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of rows of pixel locations
skipped before the first pixel is written into memory. The
initial value is 0. See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PACK_SWAP_BYTES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether the bytes
of two&minus;byte and four&minus;byte pixel indices and
components are swapped before being written to memory. The
initial value is <b>GL_FALSE</b>. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PIXEL_PACK_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the target <b>GL_PIXEL_PACK_BUFFER</b>.
If no buffer object is bound to this target, 0 is returned.
The initial value is 0. See <b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PIXEL_UNPACK_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the target <b>GL_PIXEL_UNPACK_BUFFER</b>.
If no buffer object is bound to this target, 0 is returned.
The initial value is 0. See <b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POINT_FADE_THRESHOLD_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the point size threshold for determining
the point size. See <b>glPointParameter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PRIMITIVE_RESTART_INDEX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the current primitive restart index. The
initial value is 0. See
<b>glPrimitiveRestartIndex</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PROGRAM_BINARY_FORMATS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
an array of <b>GL_NUM_PROGRAM_BINARY_FORMATS</b> values,
indicating the proram binary formats supported by the
implementation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PROGRAM_PIPELINE_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i> a
single value, the name of the currently bound program
pipeline object, or zero if no program pipeline object is
bound. See <b>glBindProgramPipeline</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_PROVOKING_VERTEX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the currently selected provoking vertex
convention. The initial value is
<b>GL_LAST_VERTEX_CONVENTION</b>. See
<b>glProvokingVertex</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POINT_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the point size as specified by
<b>glPointSize</b>(). The initial value is 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POINT_SIZE_GRANULARITY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the size difference between adjacent
supported sizes for antialiased points. See
<b>glPointSize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POINT_SIZE_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns two values: the smallest and largest supported sizes
for antialiased points. The smallest size must be at most 1,
and the largest size must be at least 1. See
<b>glPointSize</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_OFFSET_FACTOR</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the scaling factor used to determine the
variable offset that is added to the depth value of each
fragment generated when a polygon is rasterized. The initial
value is 0. See <b>glPolygonOffset</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_OFFSET_UNITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value. This value is multiplied by an
implementation&minus;specific value and then added to the
depth value of each fragment generated when a polygon is
rasterized. The initial value is 0. See
<b>glPolygonOffset</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_OFFSET_FILL</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether polygon
offset is enabled for polygons in fill mode. The initial
value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_OFFSET_LINE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether polygon
offset is enabled for polygons in line mode. The initial
value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_OFFSET_POINT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether polygon
offset is enabled for polygons in point mode. The initial
value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_SMOOTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether
antialiasing of polygons is enabled. The initial value is
<b>GL_FALSE</b>. See <b>glPolygonMode</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_POLYGON_SMOOTH_HINT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating the mode
of the polygon antialiasing hint. The initial value is
<b>GL_DONT_CARE</b>. See <b>glHint</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_READ_BUFFER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating which
color buffer is selected for reading. The initial value is
<b>GL_BACK</b> if there is a back buffer, otherwise it is
<b>GL_FRONT</b>. See <b>glReadPixels</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_RENDERBUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the renderbuffer object
currently bound to the target <b>GL_RENDERBUFFER</b>. If no
renderbuffer object is bound to this target, 0 is returned.
The initial value is 0. See <b>glBindRenderbuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SAMPLE_BUFFERS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single integer value indicating the number of
sample buffers associated with the framebuffer. See
<b>glSampleCoverage</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SAMPLE_COVERAGE_VALUE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single positive floating&minus;point value
indicating the current sample coverage value. See
<b>glSampleCoverage</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SAMPLE_COVERAGE_INVERT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating if the temporary
coverage value should be inverted. See
<b>glSampleCoverage</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SAMPLER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the sampler object
currently bound to the active texture unit. The initial
value is 0. See <b>glBindSampler</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SAMPLES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single integer value indicating the coverage mask
size. See <b>glSampleCoverage</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SCISSOR_BOX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns four values: the x and y window coordinates of the
scissor box, followed by its width and height. Initially the
x and y window coordinates are both 0 and the width and
height are set to the size of the window. See
<b>glScissor</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SCISSOR_TEST</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether scissoring
is enabled. The initial value is <b>GL_FALSE</b>. See
<b>glScissor</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SHADER_COMPILER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether an online
shader compiler is present in the implementation. All
desktop OpenGL implementations must support online shader
compilations, and therefore the value of
<b>GL_SHADER_COMPILER</b> will always be <b>GL_TRUE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SHADER_STORAGE_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
non&minus;indexed variants of <b>glGet</b> (such as
<b>glGetIntegerv</b>), <i>params</i> returns a single value,
the name of the buffer object currently bound to the target
<b>GL_SHADER_STORAGE_BUFFER</b>. If no buffer object is
bound to this target, 0 is returned. When used with indexed
variants of <b>glGet</b> (such as <b>glGetIntegeri_v</b>),
<i>params</i> returns a single value, the name of the buffer
object bound to the indexed shader storage buffer binding
points. The initial value is 0 for all targets. See
<b>glBindBuffer</b>(), <b>glBindBufferBase</b>(), and
<b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the minimum required alignment for
shader storage buffer sizes and offset. The initial value is
1. See <b>glShaderStorateBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SHADER_STORAGE_BUFFER_START</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the start offset of the binding range for each
indexed shader storage buffer binding. The initial value is
0 for all bindings. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SHADER_STORAGE_BUFFER_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the size of the binding range for each indexed shader
storage buffer binding. The initial value is 0 for all
bindings. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SMOOTH_LINE_WIDTH_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a pair of values indicating the range of widths
supported for smooth (antialiased) lines. See
<b>glLineWidth</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SMOOTH_LINE_WIDTH_GRANULARITY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value indicating the level of quantization
applied to smooth line width parameters.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_FAIL</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken for back&minus;facing polygons when the
stencil test fails. The initial value is <b>GL_KEEP</b>. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_FUNC</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
function is used for back&minus;facing polygons to compare
the stencil reference value with the stencil buffer value.
The initial value is <b>GL_ALWAYS</b>. See
<b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_PASS_DEPTH_FAIL</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken for back&minus;facing polygons when the
stencil test passes, but the depth test fails. The initial
value is <b>GL_KEEP</b>. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_PASS_DEPTH_PASS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken for back&minus;facing polygons when the
stencil test passes and the depth test passes. The initial
value is <b>GL_KEEP</b>. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_REF</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the reference value that is compared with
the contents of the stencil buffer for back&minus;facing
polygons. The initial value is 0. See
<b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_VALUE_MASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the mask that is used for
back&minus;facing polygons to mask both the stencil
reference value and the stencil buffer value before they are
compared. The initial value is all 1's. See
<b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_BACK_WRITEMASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the mask that controls writing of the
stencil bitplanes for back&minus;facing polygons. The
initial value is all 1's. See
<b>glStencilMaskSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_CLEAR_VALUE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the index to which the stencil bitplanes
are cleared. The initial value is 0. See
<b>glClearStencil</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_FAIL</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken when the stencil test fails. The initial
value is <b>GL_KEEP</b>. See <b>glStencilOp</b>(). This
stencil state only affects non&minus;polygons and
front&minus;facing polygons. Back&minus;facing polygons use
separate stencil state. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_FUNC</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
function is used to compare the stencil reference value with
the stencil buffer value. The initial value is
<b>GL_ALWAYS</b>. See <b>glStencilFunc</b>(). This stencil
state only affects non&minus;polygons and front&minus;facing
polygons. Back&minus;facing polygons use separate stencil
state. See <b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_PASS_DEPTH_FAIL</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken when the stencil test passes, but the depth
test fails. The initial value is <b>GL_KEEP</b>. See
<b>glStencilOp</b>(). This stencil state only affects
non&minus;polygons and front&minus;facing polygons.
Back&minus;facing polygons use separate stencil state. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_PASS_DEPTH_PASS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, a symbolic constant indicating what
action is taken when the stencil test passes and the depth
test passes. The initial value is <b>GL_KEEP</b>. See
<b>glStencilOp</b>(). This stencil state only affects
non&minus;polygons and front&minus;facing polygons.
Back&minus;facing polygons use separate stencil state. See
<b>glStencilOpSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_REF</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the reference value that is compared with
the contents of the stencil buffer. The initial value is 0.
See <b>glStencilFunc</b>(). This stencil state only affects
non&minus;polygons and front&minus;facing polygons.
Back&minus;facing polygons use separate stencil state. See
<b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_TEST</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether stencil
testing of fragments is enabled. The initial value is
<b>GL_FALSE</b>. See <b>glStencilFunc</b>() and
<b>glStencilOp</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_VALUE_MASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the mask that is used to mask both the
stencil reference value and the stencil buffer value before
they are compared. The initial value is all 1's. See
<b>glStencilFunc</b>(). This stencil state only affects
non&minus;polygons and front&minus;facing polygons.
Back&minus;facing polygons use separate stencil state. See
<b>glStencilFuncSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STENCIL_WRITEMASK</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the mask that controls writing of the
stencil bitplanes. The initial value is all 1's. See
<b>glStencilMask</b>(). This stencil state only affects
non&minus;polygons and front&minus;facing polygons.
Back&minus;facing polygons use separate stencil state. See
<b>glStencilMaskSeparate</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_STEREO</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether stereo
buffers (left and right) are supported.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_SUBPIXEL_BITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, an estimate of the number of bits of
subpixel resolution that are used to position rasterized
geometry in window coordinates. The value must be at least
4.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_1D</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_1D</b>. The initial value
is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_1D_ARRAY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_1D_ARRAY</b>. The initial
value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_2D</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_2D</b>. The initial value
is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_2D_ARRAY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_2D_ARRAY</b>. The initial
value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_2D_MULTISAMPLE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_2D_MULTISAMPLE</b>. The
initial value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>.
The initial value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_3D</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_3D</b>. The initial value
is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_BUFFER</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_BUFFER</b>. The initial
value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_CUBE_MAP</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_CUBE_MAP</b>. The initial
value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BINDING_RECTANGLE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the texture currently
bound to the target <b>GL_TEXTURE_RECTANGLE</b>. The initial
value is 0. See <b>glBindTexture</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_COMPRESSION_HINT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value indicating the mode of the texture
compression hint. The initial value is
<b>GL_DONT_CARE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the name of the buffer object
currently bound to the <b>GL_TEXTURE_BUFFER</b> buffer
binding point. The initial value is 0. See
<b>glBindBuffer</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the minimum required alignment for
texture buffer sizes and offset. The initial value is 1. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TIMESTAMP</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the 64&minus;bit value of the
current GL time. See <b>glQueryCounter</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TRANSFORM_FEEDBACK_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
non&minus;indexed variants of <b>glGet</b> (such as
<b>glGetIntegerv</b>), <i>params</i> returns a single value,
the name of the buffer object currently bound to the target
<b>GL_TRANSFORM_FEEDBACK_BUFFER</b>. If no buffer object is
bound to this target, 0 is returned. When used with indexed
variants of <b>glGet</b> (such as <b>glGetIntegeri_v</b>),
<i>params</i> returns a single value, the name of the buffer
object bound to the indexed transform feedback attribute
stream. The initial value is 0 for all targets. See
<b>glBindBuffer</b>(), <b>glBindBufferBase</b>(), and
<b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TRANSFORM_FEEDBACK_BUFFER_START</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the start offset of the binding range for each
transform feedback attribute stream. The initial value is 0
for all streams. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TRANSFORM_FEEDBACK_BUFFER_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the size of the binding range for each transform
feedback attribute stream. The initial value is 0 for all
streams. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNIFORM_BUFFER_BINDING</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
non&minus;indexed variants of <b>glGet</b> (such as
<b>glGetIntegerv</b>), <i>params</i> returns a single value,
the name of the buffer object currently bound to the target
<b>GL_UNIFORM_BUFFER</b>. If no buffer object is bound to
this target, 0 is returned. When used with indexed variants
of <b>glGet</b> (such as <b>glGetIntegeri_v</b>),
<i>params</i> returns a single value, the name of the buffer
object bound to the indexed uniform buffer binding point.
The initial value is 0 for all targets. See
<b>glBindBuffer</b>(), <b>glBindBufferBase</b>(), and
<b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the minimum required alignment for
uniform buffer sizes and offset. The initial value is 1. See
<b>glUniformBlockBinding</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNIFORM_BUFFER_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the size of the binding range for each indexed
uniform buffer binding. The initial value is 0 for all
bindings. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNIFORM_BUFFER_START</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
indexed variants of <b>glGet</b> (such as
<b>glGetInteger64i_v</b>), <i>params</i> returns a single
value, the start offset of the binding range for each
indexed uniform buffer binding. The initial value is 0 for
all bindings. See <b>glBindBufferRange</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_ALIGNMENT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the byte alignment used for reading pixel
data from memory. The initial value is 4. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_IMAGE_HEIGHT</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the image height used for reading pixel
data from memory. The initial is 0. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_LSB_FIRST</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether
single&minus;bit pixels being read from memory are read
first from the least significant bit of each unsigned byte.
The initial value is <b>GL_FALSE</b>. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_ROW_LENGTH</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the row length used for reading pixel
data from memory. The initial value is 0. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_SKIP_IMAGES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of pixel images skipped before
the first pixel is read from memory. The initial value is 0.
See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_SKIP_PIXELS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of pixel locations skipped
before the first pixel is read from memory. The initial
value is 0. See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_SKIP_ROWS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the number of rows of pixel locations
skipped before the first pixel is read from memory. The
initial value is 0. See <b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_UNPACK_SWAP_BYTES</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether the bytes
of two&minus;byte and four&minus;byte pixel indices and
components are swapped after being read from memory. The
initial value is <b>GL_FALSE</b>. See
<b>glPixelStore</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VERTEX_PROGRAM_POINT_SIZE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single boolean value indicating whether vertex
program point size mode is enabled. If enabled, and a vertex
shader is active, then the point size is taken from the
shader built&minus;in gl_PointSize. If disabled, and a
vertex shader is active, then the point size is taken from
the point state as specified by <b>glPointSize</b>(). The
initial value is <b>GL_FALSE</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VERTEX_BINDING_DIVISOR</b></p>

<p style="margin-left:17%; margin-top: 1em">Accepted by the
indexed forms. <i>params</i> returns a single integer value
representing the instance step divisor of the first element
in the bound buffer's data store for vertex attribute bound
to <i>index</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VERTEX_BINDING_OFFSET</b></p>

<p style="margin-left:17%; margin-top: 1em">Accepted by the
indexed forms. <i>params</i> returns a single integer value
representing the byte offset of the first element in the
bound buffer's data store for vertex attribute bound to
<i>index</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VERTEX_BINDING_STRIDE</b></p>

<p style="margin-left:17%; margin-top: 1em">Accepted by the
indexed forms. <i>params</i> returns a single integer value
representing the byte offset between the start of each
element in the bound buffer's data store for vertex
attribute bound to <i>index</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single integer value containing the maximum offset
that may be added to a vertex binding offset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_ATTRIB_BINDINGS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single integer value containing the maximum number
of vertex buffers that may be bound.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VIEWPORT</b></p>

<p style="margin-left:17%; margin-top: 1em">When used with
non&minus;indexed variants of <b>glGet</b> (such as
<b>glGetIntegerv</b>), <i>params</i> returns four values:
the x and y window coordinates of the viewport, followed by
its width and height. Initially the x and y window
coordinates are both set to 0, and the width and height are
set to the width and height of the window into which the GL
will do its rendering. See <b>glViewport</b>(). When used
with indexed variants of <b>glGet</b> (such as
<b>glGetIntegeri_v</b>), <i>params</i> returns four values:
the x and y window coordinates of the indexed viewport,
followed by its width and height. Initially the x and y
window coordinates are both set to 0, and the width and
height are set to the width and height of the window into
which the GL will do its rendering. See
<b>glViewportIndexedf</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VIEWPORT_BOUNDS_RANGE</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns two values, the minimum and maximum viewport bounds
range. The minimum range should be at least [&minus;32768,
32767].</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VIEWPORT_INDEX_PROVOKING_VERTEX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns one value, the implementation dependent specifc
vertex of a primitive that is used to select the viewport
index. If the value returned is equivalent to
<b>GL_PROVOKING_VERTEX</b>, then the vertex selection
follows the convention specified by
<b>glProvokingVertex</b>(). If the value returned is
equivalent to <b>GL_FIRST_VERTEX_CONVENTION</b>, then the
selection is always taken from the first vertex in the
primitive. If the value returned is equivalent to
<b>GL_LAST_VERTEX_CONVENTION</b>, then the selection is
always taken from the last vertex in the primitive. If the
value returned is equivalent to <b>GL_UNDEFINED_VERTEX</b>,
then the selection is not guaranteed to be taken from any
specific vertex in the primitive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VIEWPORT_SUBPIXEL_BITS</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the number of bits of
sub&minus;pixel precision which the GL uses to interpret the
floating point viewport bounds. The minimum value is 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_ELEMENT_INDEX</b></p>

<p style="margin-left:17%; margin-top: 1em"><i>params</i>
returns a single value, the maximum index that may be
specified during the transfer of generic vertex attributes
to the GL.</p>

<p style="margin-left:11%; margin-top: 1em">Many of the
boolean parameters can also be queried more easily using
<b>glIsEnabled</b>().</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
parameters return the associated value for the active
texture unit: <b>GL_TEXTURE_1D</b>,
<b>GL_TEXTURE_BINDING_1D</b>, <b>GL_TEXTURE_2D</b>,
<b>GL_TEXTURE_BINDING_2D</b>, <b>GL_TEXTURE_3D</b> and
<b>GL_TEXTURE_BINDING_3D</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VIEWPORTS</b>,
<b>GL_VIEWPORT_SUBPIXEL_BITS</b>,
<b>GL_VIEWPORT_BOUNDS_RANGE</b>,
<b>GL_LAYER_PROVOKING_VERTEX</b>, and
<b>GL_VIEWPORT_INDEX_PROVOKING_VERTEX</b> are available only
if the GL version is 4.1 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_ATOMIC_COUNTERS</b>,
<b>GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS</b>,
<b>GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS</b>,
<b>GL_MAX_GEOMETRY_ATOMIC_COUNTERS</b>,
<b>GL_MAX_FRAMGENT_ATOMIC_COUNTERS</b>, and
<b>GL_MIN_MAP_BUFFER_ALIGNMENT</b> are accepted by
<i>pname</i> only if the GL version is 4.2 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_ELEMENT_INDEX</b>
is accepted by <i>pname</i> only if the GL version is 4.3 or
greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_COMPUTE_UNIFORM_BLOCKS</b>,
<b>GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS</b>,
<b>GL_MAX_COMPUTE_UNIFORM_COMPONENTS</b>,
<b>GL_MAX_COMPUTE_ATOMIC_COUNTERS</b>,
<b>GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS</b>,
<b>GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS</b>,
<b>GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS</b>,
<b>GL_MAX_COMPUTE_WORK_GROUP_COUNT</b>, and
<b>GL_MAX_COMPUTE_WORK_GROUP_SIZE</b> and
<b>GL_DISPATCH_INDIRECT_BUFFER_BINDING</b> are available
only if the GL version is 4.3 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_DEBUG_GROUP_STACK_DEPTH</b>,
<b>GL_DEBUG_GROUP_STACK_DEPTH</b> and
<b>GL_MAX_LABEL_LENGTH</b> are accepted only if the GL
version is 4.3 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_UNIFORM_LOCATIONS</b>
is accepted only if the GL version is 4.3 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_FRAMEBUFFER_WIDTH</b>,
<b>GL_MAX_FRAMEBUFFER_HEIGHT</b>,
<b>GL_MAX_FRAMEBUFFER_LAYERS</b>, and
<b>GL_MAX_FRAMEBUFFER_SAMPLES</b> are available only if the
GL version is 4.3 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS</b>,
<b>GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS</b>,
<b>GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS</b>,
<b>GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS</b>,
<b>GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS</b>, and
<b>GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS</b> are available
only if the GL version is 4.3 or higher.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT</b>
is available only if the GL version is 4.3 or greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_VERTEX_BINDING_DIVISOR</b>,
<b>GL_VERTEX_BINDING_OFFSET</b>,
<b>GL_VERTEX_BINDING_STRIDE</b>,
<b>GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET</b> and
<b>GL_MAX_VERTEX_ATTRIB_BINDINGS</b> are available only if
the GL version is 4.3 or greater.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>pname</i> is not an accepted value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated on any of <b>glGetBooleani_v</b>,
<b>glGetIntegeri_v</b>, or <b>glGetInteger64i_v</b> if
<i>index</i> is outside of the valid range for the indexed
state <i>target</i>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>glGetActiveUniform</b>(),
<b>glGetAttachedShaders</b>(), <b>glGetAttribLocation</b>(),
<b>glGetBufferParameter</b>(), <b>glGetBufferPointerv</b>(),
<b>glGetBufferSubData</b>(),
<b>glGetCompressedTexImage</b>(), <b>glGetError</b>(),
<b>glGetProgram</b>(), <b>glGetProgramInfoLog</b>(),
<b>glGetQueryiv</b>(), <b>glGetQueryObject</b>(),
<b>glGetShader</b>(), <b>glGetShaderInfoLog</b>(),
<b>glGetShaderSource</b>(), <b>glGetString</b>(),
<b>glGetTexImage</b>(), <b>glGetTexLevelParameter</b>(),
<b>glGetTexParameter</b>(), <b>glGetUniform</b>(),
<b>glGetUniformLocation</b>(), <b>glGetVertexAttrib</b>(),
<b>glGetVertexAttribPointerv</b>(), <b>glIsEnabled</b>()</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
&copy; 1991&minus;2006 Silicon Graphics, Inc. Copyright
&copy; 2010&minus;2011 Khronos Group. This document is
licensed under the SGI Free Software B License. For details,
see
<b><font color="#0000FF">http://oss.sgi.com/projects/FreeB/</font></b><font color="#000000">.</font></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>opengl.org</b></font></p>
<hr>
</body>
</html>
