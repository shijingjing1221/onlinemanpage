<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:06:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERF&minus;RECORD</title>

</head>
<body>

<h1 align="center">PERF&minus;RECORD</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perf-record
&minus; Run a command and record its profile into
perf.data</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>perf
record</i> [&minus;e &lt;EVENT&gt; |
&minus;&minus;event=EVENT] [&minus;l] [&minus;a]
&lt;command&gt; <i><br>
perf record</i> [&minus;e &lt;EVENT&gt; |
&minus;&minus;event=EVENT] [&minus;l] [&minus;a] &mdash;
&lt;command&gt; [&lt;options&gt;]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This command
runs a command and gathers a performance counter profile
from it, into perf.data &minus; without displaying
anything.</p>

<p style="margin-left:11%; margin-top: 1em">This file can
then be inspected later on, using <i>perf report</i>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&lt;command&gt;...</p>

<p style="margin-left:17%;">Any command you can specify in
a shell.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;e,
&minus;&minus;event=</p>

<p style="margin-left:17%;">Select the PMU event. Selection
can be:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a
symbolic event name (use <i>perf list</i> to list all
events)</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a raw
PMU event (eventsel+umask) in the form of rNNN where NNN is
a hexadecimal event descriptor.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a
symbolically formed PMU event like
<i>pmu/param1=0x3,param2/</i> where <i>param1</i>,
<i>param2</i>, etc are defined as formats for the PMU in
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/*.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a
symbolically formed event like
<i>pmu/config=M,config1=N,config3=K/</i></p>

<p style="margin-left:29%; margin-top: 1em">where M, N, K
are numbers (in decimal, hex, octal format). Acceptable <br>
values for each of 'config', 'config1' and 'config2' are
defined by <br>
corresponding entries in
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/* <br>
param1 and param2 are defined as formats for the PMU in:
<br>
/sys/bus/event_sources/devices/&lt;pmu&gt;/format/*</p>

<p style="margin-left:29%; margin-top: 1em">There are also
some params which are not defined in
.../&lt;pmu&gt;/format/*. <br>
These params can be used to overload default config values
per event. <br>
Here is a list of the params. <br>
&minus; 'period': Set event sampling period <br>
&minus; 'freq': Set event sampling frequency <br>
&minus; 'time': Disable/enable time stamping. Acceptable
values are 1 for <br>
enabling time stamping. 0 for disabling time stamping. <br>
The default is 1. <br>
&minus; 'call&minus;graph': Disable/enable callgraph.
Acceptable str are &quot;fp&quot; for <br>
FP mode, &quot;dwarf&quot; for DWARF mode, &quot;lbr&quot;
for LBR mode and <br>
&quot;no&quot; for disable callgraph. <br>
&minus; 'stack&minus;size': user stack size for dwarf mode
<br>
Note: If user explicitly sets options which conflict with
the params, <br>
the value set by the params will be overridden.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a
hardware breakpoint event in the form of
<i>\mem:addr[/len][:access]</i> where addr is the address in
memory you want to break in. Access is the memory access
type (read, write, execute) it can be passed as follows:
<i>\mem:addr[:[r][w][x]]</i>. len is the range, number of
bytes from specified addr, which the breakpoint will cover.
If you want to profile read&minus;write accesses in 0x1000,
just set <i>mem:0x1000:rw</i>. If you want to profile write
accesses in [0x1000~1008), just set
<i>mem:0x1000/8:w</i>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; a group
of events surrounded by a pair of brace
(&quot;{event1,event2,...}&quot;). Each event is separated
by commas and the group should be quoted to prevent the
shell interpretation. You also need to use
&minus;&minus;group on &quot;perf report&quot; to view group
events together.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;filter=&lt;filter&gt;</p>

<p style="margin-left:17%;">Event filter. This option
should follow a event selector (&minus;e) which selects
tracepoint event(s). Multiple <i>&minus;&minus;filter</i>
options are combined using <i>&amp;&amp;</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;exclude&minus;perf</p>

<p style="margin-left:17%;">Don&rsquo;t record events
issued by perf itself. This option should follow a event
selector (&minus;e) which selects tracepoint event(s). It
adds a filter expression <i>common_pid != $PERFPID</i> to
filters. If other <i>&minus;&minus;filter</i> exists, the
new filter expression will be combined with them by
<i>&amp;&amp;</i>.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;a,
&minus;&minus;all&minus;cpus</p>

<p style="margin-left:17%;">System&minus;wide collection
from all CPUs.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;p,
&minus;&minus;pid=</p>

<p style="margin-left:17%;">Record events on existing
process ID (comma separated list).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;t,
&minus;&minus;tid=</p>

<p style="margin-left:17%;">Record events on existing
thread ID (comma separated list). This option also disables
inheritance by default. Enable it by adding
&minus;&minus;inherit.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;u,
&minus;&minus;uid=</p>

<p style="margin-left:17%;">Record events in threads owned
by uid. Name or number.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;r,
&minus;&minus;realtime=</p>

<p style="margin-left:17%;">Collect data with this RT
SCHED_FIFO priority.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;no&minus;buffering</p>

<p style="margin-left:17%;">Collect data without
buffering.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;c,
&minus;&minus;count=</p>

<p style="margin-left:17%;">Event period to sample.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;o,
&minus;&minus;output=</p>

<p style="margin-left:17%;">Output file name.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;i,
&minus;&minus;no&minus;inherit</p>

<p style="margin-left:17%;">Child tasks do not inherit
counters.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;F,
&minus;&minus;freq=</p>

<p style="margin-left:17%;">Profile at this frequency.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;m,
&minus;&minus;mmap&minus;pages=</p>

<p style="margin-left:17%;">Number of mmap data pages (must
be a power of two) or size specification with appended unit
character &minus; B/K/M/G. The size is rounded up to have
nearest pages power of two value. Also, by adding a comma,
the number of mmap pages for AUX area tracing can be
specified.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;group</p>

<p style="margin-left:17%;">Put all events in a single
event group. This precedes the &minus;&minus;event option
and remains only for backward compatibility. See
&minus;&minus;event.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;g</p>

<p style="margin-left:17%;">Enables call&minus;graph (stack
chain/backtrace) recording.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;call&minus;graph</p>

<p style="margin-left:17%;">Setup and enable
call&minus;graph (stack chain/backtrace) recording, implies
&minus;g. Default is &quot;fp&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">Allows
specifying &quot;fp&quot; (frame pointer) or
&quot;dwarf&quot; <br>
(DWARF's CFI &minus; Call Frame Information) or
&quot;lbr&quot; <br>
(Hardware Last Branch Record facility) as the method to
collect <br>
the information used to show the call graphs.</p>

<p style="margin-left:23%; margin-top: 1em">In some
systems, where binaries are build with gcc <br>
&minus;&minus;fomit&minus;frame&minus;pointer, using the
&quot;fp&quot; method will produce bogus <br>
call graphs, using &quot;dwarf&quot;, if available (perf
tools linked to <br>
the libunwind or libdw library) should be used instead. <br>
Using the &quot;lbr&quot; method doesn't require any
compiler options. It <br>
will produce call graphs from the hardware LBR registers.
The <br>
main limition is that it is only available on new Intel <br>
platforms, such as Haswell. It can only get user call chain.
It <br>
doesn't work with branch stack sampling at the same
time.</p>

<p style="margin-left:23%; margin-top: 1em">When
&quot;dwarf&quot; recording is used, perf also records
(user) stack dump <br>
when sampled. Default size of the stack dump is 8192
(bytes). <br>
User can change the size by passing the size after comma
like <br>
&quot;&minus;&minus;call&minus;graph dwarf,4096&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;q,
&minus;&minus;quiet</p>

<p style="margin-left:17%;">Don&rsquo;t print any message,
useful for scripting.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;v,
&minus;&minus;verbose</p>

<p style="margin-left:17%;">Be more verbose (show counter
open errors, etc).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;s,
&minus;&minus;stat</p>

<p style="margin-left:17%;">Record per&minus;thread event
counts. Use it with <i>perf report &minus;T</i> to see the
values.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;d,
&minus;&minus;data</p>

<p style="margin-left:17%;">Record the sample
addresses.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;T,
&minus;&minus;timestamp</p>

<p style="margin-left:17%;">Record the sample timestamps.
Use it with <i>perf report &minus;D</i> to see the
timestamps, for instance.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;P,
&minus;&minus;period</p>

<p style="margin-left:17%;">Record the sample period.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;n,
&minus;&minus;no&minus;samples</p>

<p style="margin-left:17%;">Don&rsquo;t sample.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;R,
&minus;&minus;raw&minus;samples</p>

<p style="margin-left:17%;">Collect raw sample records from
all opened counters (default for tracepoint counters).</p>

<p style="margin-left:11%; margin-top: 1em">&minus;C,
&minus;&minus;cpu</p>

<p style="margin-left:17%;">Collect samples only on the
list of CPUs provided. Multiple CPUs can be provided as a
comma&minus;separated list with no space: 0,1. Ranges of
CPUs are specified with &minus;: 0&minus;2. In
per&minus;thread mode with inheritance mode on (default),
samples are captured only when the thread executes on the
designated CPUs. Default is to monitor all CPUs.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;B,
&minus;&minus;no&minus;buildid</p>

<p style="margin-left:17%;">Do not save the build ids of
binaries in the perf.data files. This skips post processing
after recording, which sometimes makes the final step in the
recording process to take a long time, as it needs to
process all events looking for mmap records. The downside is
that it can misresolve symbols if the workload binaries used
when recording get locally rebuilt or upgraded, because the
only key available in this case is the pathname. You can
also set the &quot;record.build&minus;id&quot; config
variable to 'skip to have this behaviour permanently.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;N,
&minus;&minus;no&minus;buildid&minus;cache</p>

<p style="margin-left:17%;">Do not update the buildid
cache. This saves some overhead in situations where the
information in the perf.data file (which includes buildids)
is sufficient. You can also set the
&quot;record.build&minus;id&quot; config variable to
<i>no&minus;cache</i> to have the same effect.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;G
name,..., &minus;&minus;cgroup name,...</p>

<p style="margin-left:17%;">monitor only in the container
(cgroup) called &quot;name&quot;. This option is available
only in per&minus;cpu mode. The cgroup filesystem must be
mounted. All threads belonging to container &quot;name&quot;
are monitored when they run on the monitored CPUs. Multiple
cgroups can be provided. Each cgroup is applied to the
corresponding event, i.e., first cgroup to first event,
second cgroup to second event and so on. It is possible to
provide an empty cgroup (monitor all the time) using, e.g.,
&minus;G foo,,bar. Cgroups must have corresponding events,
i.e., they always refer to events defined earlier on the
command line.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;b,
&minus;&minus;branch&minus;any</p>

<p style="margin-left:17%;">Enable taken branch stack
sampling. Any type of taken branch may be sampled. This is a
shortcut for &minus;&minus;branch&minus;filter any. See
&minus;&minus;branch&minus;filter for more infos.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;j,
&minus;&minus;branch&minus;filter</p>

<p style="margin-left:17%;">Enable taken branch stack
sampling. Each sample captures a series of consecutive taken
branches. The number of branches captured with each sample
depends on the underlying hardware, the type of branches of
interest, and the executed code. It is possible to select
the types of branches captured by enabling filters. The
following filters are defined:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; any: any
type of branches</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
any_call: any function call or system call</p>

<p style="margin-left:23%; margin-top: 1em">&bull; any_ret:
any function return or system call return</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
ind_call: any indirect branch</p>

<p style="margin-left:23%; margin-top: 1em">&bull; call:
direct calls, including far (to/from kernel) calls</p>

<p style="margin-left:23%; margin-top: 1em">&bull; u: only
when the branch target is at the user level</p>

<p style="margin-left:23%; margin-top: 1em">&bull; k: only
when the branch target is in the kernel</p>

<p style="margin-left:23%; margin-top: 1em">&bull; hv: only
when the target is at the hypervisor level</p>

<p style="margin-left:23%; margin-top: 1em">&bull; in_tx:
only when the target is in a hardware transaction</p>

<p style="margin-left:23%; margin-top: 1em">&bull; no_tx:
only when the target is not in a hardware transaction</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
abort_tx: only when the target is a hardware transaction
abort</p>

<p style="margin-left:23%; margin-top: 1em">&bull; cond:
conditional branches</p>

<p style="margin-left:17%; margin-top: 1em">The option
requires at least one branch type among any, any_call,
any_ret, ind_call, cond. The privilege levels may be
omitted, in which case, the privilege levels of the
associated event are applied to the branch filter. Both
kernel (k) and hypervisor (hv) privilege levels are subject
to permissions. When sampling on multiple events, branch
stack sampling is enabled for all the sampling events. The
sampled branch type is the same for all events. The various
filters must be specified as a comma separated list:
&minus;&minus;branch&minus;filter any_ret,u,k Note that this
feature may not be available on all processors.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;weight</p>

<p style="margin-left:17%;">Enable weightened sampling. An
additional weight is recorded per sample and can be
displayed with the weight and local_weight sort keys. This
currently works for TSX abort events and some memory events
in precise mode on modern Intel CPUs.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;transaction</p>

<p style="margin-left:17%;">Record transaction flags for
transaction related events.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;per&minus;thread</p>

<p style="margin-left:17%;">Use per&minus;thread mmaps. By
default per&minus;cpu mmaps are created. This option
overrides that and uses per&minus;thread mmaps. A
side&minus;effect of that is that inheritance is
automatically disabled. &minus;&minus;per&minus;thread is
ignored with a warning if combined with &minus;a or &minus;C
options.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;D,
&minus;&minus;delay=</p>

<p style="margin-left:17%;">After starting the program,
wait msecs before measuring. This is useful to filter out
the startup phase of the program, which is often very
different.</p>

<p style="margin-left:11%; margin-top: 1em">&minus;I,
&minus;&minus;intr&minus;regs</p>

<p style="margin-left:17%;">Capture machine state
(registers) at interrupt, i.e., on counter overflows for
each sample. List of captured registers depends on the
architecture. This option is off by default. It is possible
to select the registers to sample using their symbolic
names, e.g. on x86, ax, si. To list the available registers
use &minus;&minus;intr&minus;regs=\?. To name registers,
pass a comma separated list such as
&minus;&minus;intr&minus;regs=ax,bx. The list of register is
architecture dependent.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;running&minus;time</p>

<p style="margin-left:17%;">Record running and enabled time
for read events (:S)</p>

<p style="margin-left:11%; margin-top: 1em">&minus;S,
&minus;&minus;snapshot</p>

<p style="margin-left:17%;">Select AUX area tracing
Snapshot Mode. This option is valid only with an AUX area
tracing event. Optionally the number of bytes to capture per
snapshot can be specified. In Snapshot Mode, trace data is
captured only when signal SIGUSR2 is received.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;proc&minus;map&minus;timeout</p>

<p style="margin-left:17%;">When processing
pre&minus;existing threads /proc/XXX/mmap, it may take a
long time, because the file may be huge. A time out is
needed in such cases. This option sets the time out limit.
The default value is 500 ms.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;switch&minus;events</p>

<p style="margin-left:17%;">Record context switch events
i.e. events of type PERF_RECORD_SWITCH or
PERF_RECORD_SWITCH_CPU_WIDE.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;buildid&minus;all</p>

<p style="margin-left:17%;">Record build&minus;id of all
DSOs regardless whether it&rsquo;s actually hit or not.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;all&minus;kernel</p>

<p style="margin-left:17%;">Configure all used events to
run in kernel space.</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;all&minus;user</p>

<p style="margin-left:17%;">Configure all used events to
run in user space.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>perf-stat</b>(1),
<b>perf-list</b>(1)</p>
<hr>
</body>
</html>
