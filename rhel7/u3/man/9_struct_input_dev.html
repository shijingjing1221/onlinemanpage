<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:38:17 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>STRUCT INPUT_DEV</title>

</head>
<body>

<h1 align="center">STRUCT INPUT_DEV</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#MEMBERS">MEMBERS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">struct_input_dev
&minus; represents an input device</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">struct
input_dev { <br>
const char * name; <br>
const char * phys; <br>
const char * uniq; <br>
struct input_id id; <br>
unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; <br>
unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; <br>
unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; <br>
unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; <br>
unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; <br>
unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; <br>
unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; <br>
unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; <br>
unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; <br>
unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; <br>
unsigned int hint_events_per_packet; <br>
unsigned int keycodemax; <br>
unsigned int keycodesize; <br>
void * keycode; <br>
int (* setkeycode) (struct input_dev *dev,const struct
input_keymap_entry *ke,unsigned int *old_keycode); <br>
int (* getkeycode) (struct input_dev *dev,struct
input_keymap_entry *ke); <br>
struct ff_device * ff; <br>
unsigned int repeat_key; <br>
struct timer_list timer; <br>
int rep[REP_CNT]; <br>
struct input_mt * mt; <br>
struct input_absinfo * absinfo; <br>
unsigned long key[BITS_TO_LONGS(KEY_CNT)]; <br>
unsigned long led[BITS_TO_LONGS(LED_CNT)]; <br>
unsigned long snd[BITS_TO_LONGS(SND_CNT)]; <br>
unsigned long sw[BITS_TO_LONGS(SW_CNT)]; <br>
int (* open) (struct input_dev *dev); <br>
void (* close) (struct input_dev *dev); <br>
int (* flush) (struct input_dev *dev, struct file *file);
<br>
int (* event) (struct input_dev *dev, unsigned int type,
unsigned int code, int value); <br>
struct input_handle __rcu * grab; <br>
spinlock_t event_lock; <br>
struct mutex mutex; <br>
unsigned int users; <br>
bool going_away; <br>
struct device dev; <br>
struct list_head h_list; <br>
struct list_head node; <br>
unsigned int num_vals; <br>
unsigned int max_vals; <br>
struct input_value * vals; <br>
bool devres_managed; <br>
};</p>

<h2>MEMBERS
<a name="MEMBERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">name</p>

<p style="margin-left:17%;">name of the device</p>

<p style="margin-left:11%; margin-top: 1em">phys</p>

<p style="margin-left:17%;">physical path to the device in
the system hierarchy</p>

<p style="margin-left:11%; margin-top: 1em">uniq</p>

<p style="margin-left:17%;">unique identification code for
the device (if device has it)</p>

<p style="margin-left:11%; margin-top: 1em">id</p>

<p style="margin-left:17%;">id of the device (struct
input_id)</p>


<p style="margin-left:11%; margin-top: 1em">propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]</p>

<p style="margin-left:17%;">bitmap of device properties and
quirks</p>


<p style="margin-left:11%; margin-top: 1em">evbit[BITS_TO_LONGS(EV_CNT)]</p>

<p style="margin-left:17%;">bitmap of types of events
supported by the device (EV_KEY, EV_REL, etc.)</p>


<p style="margin-left:11%; margin-top: 1em">keybit[BITS_TO_LONGS(KEY_CNT)]</p>

<p style="margin-left:17%;">bitmap of keys/buttons this
device has</p>


<p style="margin-left:11%; margin-top: 1em">relbit[BITS_TO_LONGS(REL_CNT)]</p>

<p style="margin-left:17%;">bitmap of relative axes for the
device</p>


<p style="margin-left:11%; margin-top: 1em">absbit[BITS_TO_LONGS(ABS_CNT)]</p>

<p style="margin-left:17%;">bitmap of absolute axes for the
device</p>


<p style="margin-left:11%; margin-top: 1em">mscbit[BITS_TO_LONGS(MSC_CNT)]</p>

<p style="margin-left:17%;">bitmap of miscellaneous events
supported by the device</p>


<p style="margin-left:11%; margin-top: 1em">ledbit[BITS_TO_LONGS(LED_CNT)]</p>

<p style="margin-left:17%;">bitmap of leds present on the
device</p>


<p style="margin-left:11%; margin-top: 1em">sndbit[BITS_TO_LONGS(SND_CNT)]</p>

<p style="margin-left:17%;">bitmap of sound effects
supported by the device</p>


<p style="margin-left:11%; margin-top: 1em">ffbit[BITS_TO_LONGS(FF_CNT)]</p>

<p style="margin-left:17%;">bitmap of force feedback
effects supported by the device</p>


<p style="margin-left:11%; margin-top: 1em">swbit[BITS_TO_LONGS(SW_CNT)]</p>

<p style="margin-left:17%;">bitmap of switches present on
the device</p>


<p style="margin-left:11%; margin-top: 1em">hint_events_per_packet</p>

<p style="margin-left:17%;">average number of events
generated by the device in a packet (between
EV_SYN/SYN_REPORT events). Used by event handlers to
estimate size of the buffer needed to hold events.</p>

<p style="margin-left:11%; margin-top: 1em">keycodemax</p>

<p style="margin-left:17%;">size of keycode table</p>


<p style="margin-left:11%; margin-top: 1em">keycodesize</p>

<p style="margin-left:17%;">size of elements in keycode
table</p>

<p style="margin-left:11%; margin-top: 1em">keycode</p>

<p style="margin-left:17%;">map of scancodes to keycodes
for this device</p>

<p style="margin-left:11%; margin-top: 1em">setkeycode</p>

<p style="margin-left:17%;">optional method to alter
current keymap, used to implement sparse keymaps. If not
supplied default mechanism will be used. The method is being
called while holding event_lock and thus must not sleep</p>

<p style="margin-left:11%; margin-top: 1em">getkeycode</p>

<p style="margin-left:17%;">optional legacy method to
retrieve current keymap.</p>

<p style="margin-left:11%; margin-top: 1em">ff</p>

<p style="margin-left:17%;">force feedback structure
associated with the device if device supports force feedback
effects</p>

<p style="margin-left:11%; margin-top: 1em">repeat_key</p>

<p style="margin-left:17%;">stores key code of the last key
pressed; used to implement software autorepeat</p>

<p style="margin-left:11%; margin-top: 1em">timer</p>

<p style="margin-left:17%;">timer for software
autorepeat</p>


<p style="margin-left:11%; margin-top: 1em">rep[REP_CNT]</p>

<p style="margin-left:17%;">current values for autorepeat
parameters (delay, rate)</p>

<p style="margin-left:11%; margin-top: 1em">mt</p>

<p style="margin-left:17%;">pointer to multitouch state</p>

<p style="margin-left:11%; margin-top: 1em">absinfo</p>

<p style="margin-left:17%;">array of struct input_absinfo
elements holding information about absolute axes (current
value, min, max, flat, fuzz, resolution)</p>


<p style="margin-left:11%; margin-top: 1em">key[BITS_TO_LONGS(KEY_CNT)]</p>

<p style="margin-left:17%;">reflects current state of
device's keys/buttons</p>


<p style="margin-left:11%; margin-top: 1em">led[BITS_TO_LONGS(LED_CNT)]</p>

<p style="margin-left:17%;">reflects current state of
device's LEDs</p>


<p style="margin-left:11%; margin-top: 1em">snd[BITS_TO_LONGS(SND_CNT)]</p>

<p style="margin-left:17%;">reflects current state of sound
effects</p>


<p style="margin-left:11%; margin-top: 1em">sw[BITS_TO_LONGS(SW_CNT)]</p>

<p style="margin-left:17%;">reflects current state of
device's switches</p>

<p style="margin-left:11%; margin-top: 1em">open</p>

<p style="margin-left:17%;">this method is called when the
very first user calls <b>input_open_device</b>. The driver
must prepare the device to start generating events (start
polling thread, request an IRQ, submit URB, etc.)</p>

<p style="margin-left:11%; margin-top: 1em">close</p>

<p style="margin-left:17%;">this method is called when the
very last user calls <b>input_close_device</b>.</p>

<p style="margin-left:11%; margin-top: 1em">flush</p>

<p style="margin-left:17%;">purges the device. Most
commonly used to get rid of force feedback effects loaded
into the device when disconnecting from it</p>

<p style="margin-left:11%; margin-top: 1em">event</p>

<p style="margin-left:17%;">event handler for events sent
_to_ the device, like EV_LED or EV_SND. The device is
expected to carry out the requested action (turn on a LED,
play sound, etc.) The call is protected by <i>event_lock</i>
and must not sleep</p>

<p style="margin-left:11%; margin-top: 1em">grab</p>

<p style="margin-left:17%;">input handle that currently has
the device grabbed (via EVIOCGRAB ioctl). When a handle
grabs a device it becomes sole recipient for all input
events coming from the device</p>

<p style="margin-left:11%; margin-top: 1em">event_lock</p>

<p style="margin-left:17%;">this spinlock is is taken when
input core receives and processes a new event for the device
(in <b>input_event</b>). Code that accesses and/or modifies
parameters of a device (such as keymap or absmin, absmax,
absfuzz, etc.) after device has been registered with input
core must take this lock.</p>

<p style="margin-left:11%; margin-top: 1em">mutex</p>

<p style="margin-left:17%;">serializes calls to
<b>open</b>, <b>close</b> and <b>flush</b> methods</p>

<p style="margin-left:11%; margin-top: 1em">users</p>

<p style="margin-left:17%;">stores number of users (input
handlers) that opened this device. It is used by
<b>input_open_device</b> and <b>input_close_device</b> to
make sure that dev&minus;&gt;<b>open</b> is only called when
the first user opens device and dev&minus;&gt;<b>close</b>
is called when the very last user closes the device</p>

<p style="margin-left:11%; margin-top: 1em">going_away</p>

<p style="margin-left:17%;">marks devices that are in a
middle of unregistering and causes input_open_device*() fail
with &minus;ENODEV.</p>

<p style="margin-left:11%; margin-top: 1em">dev</p>

<p style="margin-left:17%;">driver model's view of this
device</p>

<p style="margin-left:11%; margin-top: 1em">h_list</p>

<p style="margin-left:17%;">list of input handles
associated with the device. When accessing the list
dev&minus;&gt;mutex must be held</p>

<p style="margin-left:11%; margin-top: 1em">node</p>

<p style="margin-left:17%;">used to place the device onto
input_dev_list</p>

<p style="margin-left:11%; margin-top: 1em">num_vals</p>

<p style="margin-left:17%;">number of values queued in the
current frame</p>

<p style="margin-left:11%; margin-top: 1em">max_vals</p>

<p style="margin-left:17%;">maximum number of values queued
in a frame</p>

<p style="margin-left:11%; margin-top: 1em">vals</p>

<p style="margin-left:17%;">array of values queued in the
current frame</p>


<p style="margin-left:11%; margin-top: 1em">devres_managed</p>

<p style="margin-left:17%;">indicates that devices is
managed with devres framework and needs not be explicitly
unregistered or freed.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<hr>
</body>
</html>
