<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:40:33 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Parser</title>

</head>
<body>

<h1 align="center">Parser</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#VERSION 2 COMPATIBILITY">VERSION 2 COMPATIBILITY</a><br>
<a href="#SUBCLASSING">SUBCLASSING</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">HTML::Parser
&minus; HTML parser class</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> use HTML::Parser ();
 # Create parser object
 $p = HTML::Parser&minus;&gt;new( api_version =&gt; 3,
                         start_h =&gt; [\&amp;start, &quot;tagname, attr&quot;],
                         end_h   =&gt; [\&amp;end,   &quot;tagname&quot;],
                         marked_sections =&gt; 1,
                       );
 # Parse document text chunk by chunk
 $p&minus;&gt;parse($chunk1);
 $p&minus;&gt;parse($chunk2);
 #...
 $p&minus;&gt;eof;                 # signal end of document
 # Parse directly from file
 $p&minus;&gt;parse_file(&quot;foo.html&quot;);
 # or
 open(my $fh, &quot;&lt;:utf8&quot;, &quot;foo.html&quot;) || die;
 $p&minus;&gt;parse_file($fh);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Objects of the
<tt>&quot;HTML::Parser&quot;</tt> class will recognize
markup and separate it from plain text (alias data content)
in <small>HTML</small> documents. As different kinds of
markup and text are recognized, the corresponding event
handlers are invoked.</p>


<p style="margin-left:11%; margin-top: 1em"><tt>&quot;HTML::Parser&quot;</tt>
is not a generic <small>SGML</small> parser. We have tried
to make it able to deal with the <small>HTML</small> that is
actually &quot;out there&quot;, and it normally parses as
closely as possible to the way the popular web browsers do
it instead of strictly following one of the many
<small>HTML</small> specifications from W3C. Where there is
disagreement, there is often an option that you can enable
to get the official behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">The document to
be parsed may be supplied in arbitrary chunks. This makes
on-the-fly parsing as documents are received from the
network possible.</p>

<p style="margin-left:11%; margin-top: 1em">If event driven
parsing does not feel right for your application, you might
want to use <tt>&quot;HTML::PullParser&quot;</tt>. This is
an <tt>&quot;HTML::Parser&quot;</tt> subclass that allows a
more conventional program structure.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
method is used to construct a new
<tt>&quot;HTML::Parser&quot;</tt> object: <br>
$p = HTML::Parser&minus;&gt;new( %options_and_handlers )</p>

<p style="margin-left:17%;">This class method creates a new
<tt>&quot;HTML::Parser&quot;</tt> object and returns it.
Key/value argument pairs may be provided to assign event
handlers or initialize parser options. The handlers and
parser options can also be set or modified later by the
method calls described below.</p>

<p style="margin-left:17%; margin-top: 1em">If a top level
key is in the form &quot;&lt;event&gt;_h&quot; (e.g.,
&quot;text_h&quot;) then it assigns a handler to that event,
otherwise it initializes a parser option. The event handler
specification value must be an array reference. Multiple
handlers may also be assigned with the &rsquo;handlers =&gt;
[%handlers]&rsquo; option. See examples below.</p>

<p style="margin-left:17%; margin-top: 1em">If <i>new()</i>
is called without any arguments, it will create a parser
that uses callback methods compatible with version 2 of
<tt>&quot;HTML::Parser&quot;</tt>. See the section on
&quot;version 2 compatibility&quot; below for details.</p>

<p style="margin-left:17%; margin-top: 1em">The special
constructor option &rsquo;api_version =&gt; 2&rsquo; can be
used to initialize version 2 callbacks while still setting
other options and handlers. The &rsquo;api_version =&gt;
3&rsquo; option can be used if you don&rsquo;t want to set
any options and don&rsquo;t want to fall back to v2
compatible mode.</p>

<p style="margin-left:17%; margin-top: 1em">Examples:</p>

<pre style="margin-left:17%; margin-top: 1em"> $p = HTML::Parser&minus;&gt;new(api_version =&gt; 3,
                        text_h =&gt; [ sub {...}, &quot;dtext&quot; ]);</pre>


<p style="margin-left:17%; margin-top: 1em">This creates a
new parser object with a text event handler subroutine that
receives the original text with general entities
decoded.</p>

<pre style="margin-left:17%; margin-top: 1em"> $p = HTML::Parser&minus;&gt;new(api_version =&gt; 3,
                        start_h =&gt; [ 'my_start', &quot;self,tokens&quot; ]);</pre>


<p style="margin-left:17%; margin-top: 1em">This creates a
new parser object with a start event handler method that
receives the <tt>$p</tt> and the tokens array.</p>

<pre style="margin-left:17%; margin-top: 1em"> $p = HTML::Parser&minus;&gt;new(api_version =&gt; 3,
                        handlers =&gt; { text =&gt; [\@array, &quot;event,text&quot;],
                                      comment =&gt; [\@array, &quot;event,text&quot;],
                                    });</pre>


<p style="margin-left:17%; margin-top: 1em">This creates a
new parser object that stores the event type and the
original text in <tt>@array</tt> for text and comment
events.</p>

<p style="margin-left:11%; margin-top: 1em">The following
methods feed the <small>HTML</small> document to the
<tt>&quot;HTML::Parser&quot;</tt> object: <br>
$p&minus;&gt;parse( $string )</p>

<p style="margin-left:17%;">Parse <tt>$string</tt> as the
next chunk of the <small>HTML</small> document. Handlers
invoked should not attempt to modify the <tt>$string</tt>
in-place until <tt>$p</tt>&minus;&gt;parse returns.</p>

<p style="margin-left:17%; margin-top: 1em">If an invoked
event handler aborts parsing by calling
<tt>$p</tt>&minus;&gt;eof, then
<tt>$p</tt>&minus;&gt;<i>parse()</i> will return a
<small>FALSE</small> value. Otherwise the return value is a
reference to the parser object ($p).</p>

<p style="margin-left:11%;">$p&minus;&gt;parse( $code_ref
)</p>

<p style="margin-left:17%;">If a code reference is passed
as the argument to be parsed, then the chunks to be parsed
are obtained by invoking this function repeatedly. Parsing
continues until the function returns an empty (or undefined)
result. When this happens <tt>$p</tt>&minus;&gt;eof is
automatically signaled.</p>

<p style="margin-left:17%; margin-top: 1em">Parsing will
also abort if one of the event handlers calls
<tt>$p</tt>&minus;&gt;eof.</p>

<p style="margin-left:17%; margin-top: 1em">The effect of
this is the same as:</p>

<pre style="margin-left:17%; margin-top: 1em"> while (1) {
    my $chunk = &amp;$code_ref();
    if (!defined($chunk) || !length($chunk)) {
        $p&minus;&gt;eof;
        return $p;
    }
    $p&minus;&gt;parse($chunk) || return undef;
 }</pre>


<p style="margin-left:17%; margin-top: 1em">But it is more
efficient as this loop runs internally in <small>XS</small>
code.</p>

<p style="margin-left:11%;">$p&minus;&gt;parse_file( $file
)</p>

<p style="margin-left:17%;">Parse text directly from a
file. The <tt>$file</tt> argument can be a filename, an open
file handle, or a reference to an open file handle.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$file</tt> contains a filename and the file can&rsquo;t
be opened, then the method returns an undefined value and $!
tells why it failed. Otherwise the return value is a
reference to the parser object.</p>

<p style="margin-left:17%; margin-top: 1em">If a file
handle is passed as the <tt>$file</tt> argument, then the
file will normally be read until <small>EOF,</small> but not
closed.</p>

<p style="margin-left:17%; margin-top: 1em">If an invoked
event handler aborts parsing by calling
<tt>$p</tt>&minus;&gt;eof, then
<tt>$p</tt>&minus;&gt;<i>parse_file()</i> may not have read
the entire file.</p>

<p style="margin-left:17%; margin-top: 1em">On systems with
multi-byte line terminators, the values passed for the
offset and length argspecs may be too low if
<i>parse_file()</i> is called on a file handle that is not
in binary mode.</p>

<p style="margin-left:17%; margin-top: 1em">If a filename
is passed in, then <i>parse_file()</i> will open the file in
binary mode.</p>

<p style="margin-left:11%;">$p&minus;&gt;eof</p>

<p style="margin-left:17%;">Signals the end of the
<small>HTML</small> document. Calling the
<tt>$p</tt>&minus;&gt;eof method outside a handler callback
will flush any remaining buffered text (which triggers the
<tt>&quot;text&quot;</tt> event if there is any remaining
text).</p>

<p style="margin-left:17%; margin-top: 1em">Calling
<tt>$p</tt>&minus;&gt;eof inside a handler will terminate
parsing at that point and cause <tt>$p</tt>&minus;&gt;parse
to return a <small>FALSE</small> value. This also terminates
parsing by <tt>$p</tt>&minus;&gt;<i>parse_file()</i>.</p>

<p style="margin-left:17%; margin-top: 1em">After
<tt>$p</tt>&minus;&gt;eof has been called, the
<i>parse()</i> and <i>parse_file()</i> methods can be
invoked to feed new documents with the parser object.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value from <i>eof()</i> is a reference to the parser
object.</p>

<p style="margin-left:11%; margin-top: 1em">Most parser
options are controlled by boolean attributes. Each boolean
attribute is enabled by calling the corresponding method
with a <small>TRUE</small> argument and disabled with a
<small>FALSE</small> argument. The attribute value is left
unchanged if no argument is given. The return value from
each method is the old attribute value.</p>

<p style="margin-left:11%; margin-top: 1em">Methods that
can be used to get and/or set parser options are: <br>
$p&minus;&gt;attr_encoded <br>
$p&minus;&gt;attr_encoded( $bool )</p>

<p style="margin-left:17%;">By default, the
<tt>&quot;attr&quot;</tt> and <tt>@attr</tt> argspecs will
have general entities for attribute values decoded. Enabling
this attribute leaves entities alone.</p>

<p style="margin-left:11%;">$p&minus;&gt;backquote <br>
$p&minus;&gt;backquote( $bool )</p>

<p style="margin-left:17%;">By default, only &rsquo; and
&quot; are recognized as quote characters around attribute
values. <small>MSIE</small> also recognizes backquotes for
some reason. Enabling this attribute provides compatibility
with this behaviour.</p>


<p style="margin-left:11%;">$p&minus;&gt;boolean_attribute_value(
$val )</p>

<p style="margin-left:17%;">This method sets the value
reported for boolean attributes inside <small>HTML</small>
start tags. By default, the name of the attribute is also
used as its value. This affects the values reported for
<tt>&quot;tokens&quot;</tt> and <tt>&quot;attr&quot;</tt>
argspecs.</p>

<p style="margin-left:11%;">$p&minus;&gt;case_sensitive
<br>
$p&minus;&gt;case_sensitive( $bool )</p>

<p style="margin-left:17%;">By default, tagnames and
attribute names are down-cased. Enabling this attribute
leaves them as found in the <small>HTML</small> source
document.</p>

<p style="margin-left:11%;">$p&minus;&gt;closing_plaintext
<br>
$p&minus;&gt;closing_plaintext( $bool )</p>

<p style="margin-left:17%;">By default,
&quot;plaintext&quot; element can never be closed.
Everything up to the end of the document is parsed in
<small>CDATA</small> mode. This historical behaviour is what
at least <small>MSIE</small> does. Enabling this attribute
makes closing &quot;&lt;/plaintext&gt;&quot; tag effective
and the parsing process will resume after seeing this tag.
This emulates early gecko-based browsers.</p>


<p style="margin-left:11%;">$p&minus;&gt;empty_element_tags
<br>
$p&minus;&gt;empty_element_tags( $bool )</p>

<p style="margin-left:17%;">By default, empty element tags
are not recognized as such and the &quot;/&quot; before
&quot;&gt;&quot; is just treated like a normal name
character (unless <tt>&quot;strict_names&quot;</tt> is
enabled). Enabling this attribute make
<tt>&quot;HTML::Parser&quot;</tt> recognize these tags.</p>

<p style="margin-left:17%; margin-top: 1em">Empty element
tags look like start tags, but end with the character
sequence &quot;/&gt;&quot; instead of &quot;&gt;&quot;. When
recognized by <tt>&quot;HTML::Parser&quot;</tt> they cause
an artificial end event in addition to the start event. The
<tt>&quot;text&quot;</tt> for the artificial end event will
be empty and the <tt>&quot;tokenpos&quot;</tt> array will be
undefined even though the the token array will have one
element containing the tag name.</p>

<p style="margin-left:11%;">$p&minus;&gt;marked_sections
<br>
$p&minus;&gt;marked_sections( $bool )</p>

<p style="margin-left:17%;">By default, section markings
like &lt;![CDATA[...]]&gt; are treated like ordinary text.
When this attribute is enabled section markings are
honoured.</p>

<p style="margin-left:17%; margin-top: 1em">There are
currently no events associated with the marked section
markup, but the text can be returned as
<tt>&quot;skipped_text&quot;</tt>.</p>

<p style="margin-left:11%;">$p&minus;&gt;strict_comment
<br>
$p&minus;&gt;strict_comment( $bool )</p>

<p style="margin-left:17%;">By default, comments are
terminated by the first occurrence of
&quot;&minus;&minus;&gt;&quot;. This is the behaviour of
most popular browsers (like Mozilla, Opera and
<small>MSIE</small> ), but it is not correct according to
the official <small>HTML</small> standard. Officially, you
need an even number of &quot;&minus;&minus;&quot; tokens
before the closing &quot;&gt;&quot; is recognized and there
may not be anything but whitespace between an even and an
odd &quot;&minus;&minus;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The official
behaviour is enabled by enabling this attribute.</p>

<p style="margin-left:17%; margin-top: 1em">Enabling of
&rsquo;strict_comment&rsquo; also disables recognizing these
forms as comments:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;/ comment&gt;
  &lt;! comment&gt;</pre>


<p style="margin-left:11%;">$p&minus;&gt;strict_end <br>
$p&minus;&gt;strict_end( $bool )</p>

<p style="margin-left:17%;">By default, attributes and
other junk are allowed to be present on end tags in a manner
that emulates <small>MSIE</small> &rsquo;s behaviour.</p>

<p style="margin-left:17%; margin-top: 1em">The official
behaviour is enabled with this attribute. If enabled, only
whitespace is allowed between the tagname and the final
&quot;&gt;&quot;.</p>

<p style="margin-left:11%;">$p&minus;&gt;strict_names <br>
$p&minus;&gt;strict_names( $bool )</p>

<p style="margin-left:17%;">By default, almost anything is
allowed in tag and attribute names. This is the behaviour of
most popular browsers and allows us to parse some broken
tags with invalid attribute values like:</p>

<pre style="margin-left:17%; margin-top: 1em">   &lt;IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">By default,
&quot; <small>LIST</small> ]&quot; is parsed as a boolean
attribute, not as part of the <small>ALT</small> value as
was clearly intended. This is also what Mozilla sees.</p>

<p style="margin-left:17%; margin-top: 1em">The official
behaviour is enabled by enabling this attribute. If enabled,
it will cause the tag above to be reported as text since
&quot; <small>LIST</small> ]&quot; is not a legal attribute
name.</p>

<p style="margin-left:11%;">$p&minus;&gt;unbroken_text <br>
$p&minus;&gt;unbroken_text( $bool )</p>

<p style="margin-left:17%;">By default, blocks of text are
given to the text handler as soon as possible (but the
parser takes care always to break text at a boundary between
whitespace and non-whitespace so single words and entities
can always be decoded safely). This might create breaks that
make it hard to do transformations on the text. When this
attribute is enabled, blocks of text are always reported in
one piece. This will delay the text event until the
following (non-text) event has been recognized by the
parser.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
<tt>&quot;offset&quot;</tt> argspec will give you the offset
of the first segment of text and <tt>&quot;length&quot;</tt>
is the combined length of the segments. Since there might be
ignored tags in between, these numbers can&rsquo;t be used
to directly index in the original document file.</p>

<p style="margin-left:11%;">$p&minus;&gt;utf8_mode <br>
$p&minus;&gt;utf8_mode( $bool )</p>

<p style="margin-left:17%;">Enable this option when parsing
raw undecoded <small>UTF&minus;8.</small> This tells the
parser that the entities expanded for strings reported by
<tt>&quot;attr&quot;</tt>, <tt>@attr</tt> and
<tt>&quot;dtext&quot;</tt> should be expanded as decoded
<small>UTF&minus;8</small> so they end up compatible with
the surrounding text.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;utf8_mode&quot;</tt> is enabled then it is an
error to pass strings containing characters with code above
255 to the <i>parse()</i> method, and the <i>parse()</i>
method will croak if you try.</p>

<p style="margin-left:17%; margin-top: 1em">Example: The
Unicode character &quot;\x{2665}&quot; is
&quot;\xE2\x99\xA5&quot; when <small>UTF&minus;8</small>
encoded. The character can also be represented by the entity
&quot;&amp;hearts;&quot; or &quot;&amp;#x2665&quot;. If we
feed the parser:</p>

<pre style="margin-left:17%; margin-top: 1em">  $p&minus;&gt;parse(&quot;\xE2\x99\xA5&amp;hearts;&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">then
<tt>&quot;dtext&quot;</tt> will be reported as
&quot;\xE2\x99\xA5\x{2665}&quot; without
<tt>&quot;utf8_mode&quot;</tt> enabled, but as
&quot;\xE2\x99\xA5\xE2\x99\xA5&quot; when enabled. The later
string is what you want.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
only available with perl&minus;5.8 or better.</p>

<p style="margin-left:11%;">$p&minus;&gt;xml_mode <br>
$p&minus;&gt;xml_mode( $bool )</p>

<p style="margin-left:17%;">Enabling this attribute changes
the parser to allow some <small>XML</small> constructs. This
enables the behaviour controlled by individually by the
<tt>&quot;case_sensitive&quot;</tt>,
<tt>&quot;empty_element_tags&quot;</tt>,
<tt>&quot;strict_names&quot;</tt> and
<tt>&quot;xml_pic&quot;</tt> attributes and also suppresses
special treatment of elements that are parsed as
<small>CDATA</small> for <small>HTML.</small></p>

<p style="margin-left:11%;">$p&minus;&gt;xml_pic <br>
$p&minus;&gt;xml_pic( $bool )</p>

<p style="margin-left:17%;">By default, <i>processing
instructions</i> are terminated by &quot;&gt;&quot;. When
this attribute is enabled, processing instructions are
terminated by &quot;?&gt;&quot; instead.</p>

<p style="margin-left:11%; margin-top: 1em">As markup and
text is recognized, handlers are invoked. The following
method is used to set up handlers for different events: <br>
$p&minus;&gt;handler( event =&gt; \&amp;subroutine, $argspec
) <br>
$p&minus;&gt;handler( event =&gt; $method_name, $argspec )
<br>
$p&minus;&gt;handler( event =&gt; \@accum, $argspec ) <br>
$p&minus;&gt;handler( event =&gt; &quot;&quot; ); <br>
$p&minus;&gt;handler( event =&gt; undef ); <br>
$p&minus;&gt;handler( event );</p>

<p style="margin-left:17%;">This method assigns a
subroutine, method, or array to handle an event.</p>

<p style="margin-left:17%; margin-top: 1em">Event is one of
<tt>&quot;text&quot;</tt>, <tt>&quot;start&quot;</tt>,
<tt>&quot;end&quot;</tt>, <tt>&quot;declaration&quot;</tt>,
<tt>&quot;comment&quot;</tt>, <tt>&quot;process&quot;</tt>,
<tt>&quot;start_document&quot;</tt>,
<tt>&quot;end_document&quot;</tt> or
<tt>&quot;default&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;\&amp;subroutine&quot;</tt> is a reference to a
subroutine which is called to handle the event.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$method_name</tt> is the name of a method of <tt>$p</tt>
which is called to handle the event.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>@accum</tt> is an array that will hold the event
information as sub-arrays.</p>

<p style="margin-left:17%; margin-top: 1em">If the second
argument is &quot;&quot;, the event is ignored. If it is
undef, the default handler is invoked for the event.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$argspec</tt> is a string that describes the information
to be reported for the event. Any requested information that
does not apply to a specific event is passed as
<tt>&quot;undef&quot;</tt>. If argspec is omitted, then it
is left unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value from <tt>$p</tt>&minus;&gt;handler is the old callback
routine or a reference to the accumulator array.</p>

<p style="margin-left:17%; margin-top: 1em">Any return
values from handler callback routines/methods are always
ignored. A handler callback can request parsing to be
aborted by invoking the <tt>$p</tt>&minus;&gt;eof method. A
handler callback is not allowed to invoke the
<tt>$p</tt>&minus;&gt;<i>parse()</i> or
<tt>$p</tt>&minus;&gt;<i>parse_file()</i> method. An
exception will be raised if it tries.</p>

<p style="margin-left:17%; margin-top: 1em">Examples:</p>

<pre style="margin-left:17%; margin-top: 1em">    $p&minus;&gt;handler(start =&gt;  &quot;start&quot;, 'self, attr, attrseq, text' );</pre>


<p style="margin-left:17%; margin-top: 1em">This causes the
&quot;start&quot; method of object <tt>$p</tt> to be called
for &rsquo;start&rsquo; events. The callback signature is
<tt>$p</tt>&minus;&gt;start(\%attr, \@attr_seq,
<tt>$text</tt>).</p>

<pre style="margin-left:17%; margin-top: 1em">    $p&minus;&gt;handler(start =&gt;  \&amp;start, 'attr, attrseq, text' );</pre>


<p style="margin-left:17%; margin-top: 1em">This causes
subroutine <i>start()</i> to be called for
&rsquo;start&rsquo; events. The callback signature is
start(\%attr, \@attr_seq, <tt>$text</tt>).</p>

<pre style="margin-left:17%; margin-top: 1em">    $p&minus;&gt;handler(start =&gt;  \@accum, '&quot;S&quot;, attr, attrseq, text' );</pre>


<p style="margin-left:17%; margin-top: 1em">This causes
&rsquo;start&rsquo; event information to be saved in
<tt>@accum</tt>. The array elements will be
[&rsquo;S&rsquo;, \%attr, \@attr_seq, <tt>$text</tt>].</p>

<pre style="margin-left:17%; margin-top: 1em">   $p&minus;&gt;handler(start =&gt; &quot;&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">This causes
&rsquo;start&rsquo; events to be ignored. It also suppresses
invocations of any default handler for start events. It is
in most cases equivalent to
<tt>$p</tt>&minus;&gt;handler(start =&gt; sub {}), but is
more efficient. It is different from the empty-sub-handler
in that <tt>&quot;skipped_text&quot;</tt> is not reset by
it.</p>

<pre style="margin-left:17%; margin-top: 1em">   $p&minus;&gt;handler(start =&gt; undef);</pre>


<p style="margin-left:17%; margin-top: 1em">This causes no
handler to be associated with start events. If there is a
default handler it will be invoked.</p>

<p style="margin-left:11%; margin-top: 1em">Filters based
on tags can be set up to limit the number of events
reported. The main bottleneck during parsing is often the
huge number of callbacks made from the parser. Applying
filters can improve performance significantly.</p>

<p style="margin-left:11%; margin-top: 1em">The following
methods control filters: <br>
$p&minus;&gt;ignore_elements( @tags )</p>

<p style="margin-left:17%;">Both the
<tt>&quot;start&quot;</tt> event and the
<tt>&quot;end&quot;</tt> event as well as any events that
would be reported in between are suppressed. The ignored
elements can contain nested occurrences of itself.
Example:</p>

<pre style="margin-left:17%; margin-top: 1em">   $p&minus;&gt;ignore_elements(qw(script style));</pre>


<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;script&quot;</tt> and <tt>&quot;style&quot;</tt>
tags will always nest properly since their content is parsed
in <small>CDATA</small> mode. For most other tags
<tt>&quot;ignore_elements&quot;</tt> must be used with
caution since <small>HTML</small> is often not <i>well
formed</i>.</p>

<p style="margin-left:11%;">$p&minus;&gt;ignore_tags( @tags
)</p>

<p style="margin-left:17%;">Any <tt>&quot;start&quot;</tt>
and <tt>&quot;end&quot;</tt> events involving any of the
tags given are suppressed. To reset the filter (i.e.
don&rsquo;t suppress any <tt>&quot;start&quot;</tt> and
<tt>&quot;end&quot;</tt> events), call
<tt>&quot;ignore_tags&quot;</tt> without an argument.</p>

<p style="margin-left:11%;">$p&minus;&gt;report_tags( @tags
)</p>

<p style="margin-left:17%;">Any <tt>&quot;start&quot;</tt>
and <tt>&quot;end&quot;</tt> events involving any of the
tags <i>not</i> given are suppressed. To reset the filter
(i.e. report all <tt>&quot;start&quot;</tt> and
<tt>&quot;end&quot;</tt> events), call
<tt>&quot;report_tags&quot;</tt> without an argument.</p>

<p style="margin-left:11%; margin-top: 1em">Internally, the
system has two filter lists, one for
<tt>&quot;report_tags&quot;</tt> and one for
<tt>&quot;ignore_tags&quot;</tt>, and both filters are
applied. This effectively gives
<tt>&quot;ignore_tags&quot;</tt> precedence over
<tt>&quot;report_tags&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">   $p&minus;&gt;ignore_tags(qw(style));
   $p&minus;&gt;report_tags(qw(script style));</pre>


<p style="margin-left:11%; margin-top: 1em">results in only
<tt>&quot;script&quot;</tt> events being reported.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Argspec</b>
<br>
Argspec is a string containing a comma-separated list that
describes the information reported by the event. The
following argspec identifier names can be used: <br>
&quot;attr&quot;</p>

<p style="margin-left:17%;">Attr causes a reference to a
hash of attribute name/value pairs to be passed.</p>

<p style="margin-left:17%; margin-top: 1em">Boolean
attributes&rsquo; values are either the value set by
<tt>$p</tt>&minus;&gt;boolean_attribute_value, or the
attribute name if no value has been set by
<tt>$p</tt>&minus;&gt;boolean_attribute_value.</p>

<p style="margin-left:17%; margin-top: 1em">This passes
undef except for <tt>&quot;start&quot;</tt> events.</p>

<p style="margin-left:17%; margin-top: 1em">Unless
<tt>&quot;xml_mode&quot;</tt> or
<tt>&quot;case_sensitive&quot;</tt> is enabled, the
attribute names are forced to lower case.</p>

<p style="margin-left:17%; margin-top: 1em">General
entities are decoded in the attribute values and one layer
of matching quotes enclosing the attribute values is
removed.</p>

<p style="margin-left:17%; margin-top: 1em">The Unicode
character set is assumed for entity decoding.</p>

<p style="margin-left:11%;">@attr</p>

<p style="margin-left:17%;">Basically the same as
<tt>&quot;attr&quot;</tt>, but keys and values are passed as
individual arguments and the original sequence of the
attributes is kept. The parameters passed will be the same
as the <tt>@attr</tt> calculated here:</p>

<pre style="margin-left:17%; margin-top: 1em">   @attr = map { $_ =&gt; $attr&minus;&gt;{$_} } @$attrseq;</pre>


<p style="margin-left:17%; margin-top: 1em">assuming
<tt>$attr</tt> and <tt>$attrseq</tt> here are the hash and
array passed as the result of <tt>&quot;attr&quot;</tt> and
<tt>&quot;attrseq&quot;</tt> argspecs.</p>

<p style="margin-left:17%; margin-top: 1em">This passes no
values for events besides <tt>&quot;start&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;attrseq&quot;</p>

<p style="margin-left:17%;">Attrseq causes a reference to
an array of attribute names to be passed. This can be useful
if you want to walk the <tt>&quot;attr&quot;</tt> hash in
the original sequence.</p>

<p style="margin-left:17%; margin-top: 1em">This passes
undef except for <tt>&quot;start&quot;</tt> events.</p>

<p style="margin-left:17%; margin-top: 1em">Unless
<tt>&quot;xml_mode&quot;</tt> or
<tt>&quot;case_sensitive&quot;</tt> is enabled, the
attribute names are forced to lower case.</p>

<p style="margin-left:11%;">&quot;column&quot;</p>

<p style="margin-left:17%;">Column causes the column number
of the start of the event to be passed. The first column on
a line is 0.</p>

<p style="margin-left:11%;">&quot;dtext&quot;</p>

<p style="margin-left:17%;">Dtext causes the decoded text
to be passed. General entities are automatically decoded
unless the event was inside a <small>CDATA</small> section
or was between literal start and end tags
(<tt>&quot;script&quot;</tt>, <tt>&quot;style&quot;</tt>,
<tt>&quot;xmp&quot;</tt>, <tt>&quot;iframe&quot;</tt>,
<tt>&quot;title&quot;</tt>, <tt>&quot;textarea&quot;</tt>
and <tt>&quot;plaintext&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">The Unicode
character set is assumed for entity decoding. With Perl
version 5.6 or earlier only the Latin&minus;1 range is
supported, and entities for characters outside the range
0..255 are left unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">This passes
undef except for <tt>&quot;text&quot;</tt> events.</p>

<p style="margin-left:11%;">&quot;event&quot;</p>

<p style="margin-left:17%;">Event causes the event name to
be passed.</p>

<p style="margin-left:17%; margin-top: 1em">The event name
is one of <tt>&quot;text&quot;</tt>,
<tt>&quot;start&quot;</tt>, <tt>&quot;end&quot;</tt>,
<tt>&quot;declaration&quot;</tt>,
<tt>&quot;comment&quot;</tt>, <tt>&quot;process&quot;</tt>,
<tt>&quot;start_document&quot;</tt> or
<tt>&quot;end_document&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;is_cdata&quot;</p>

<p style="margin-left:17%;">Is_cdata causes a
<small>TRUE</small> value to be passed if the event is
inside a <small>CDATA</small> section or between literal
start and end tags (<tt>&quot;script&quot;</tt>,
<tt>&quot;style&quot;</tt>, <tt>&quot;xmp&quot;</tt>,
<tt>&quot;iframe&quot;</tt>, <tt>&quot;title&quot;</tt>,
<tt>&quot;textarea&quot;</tt> and
<tt>&quot;plaintext&quot;</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">if the flag is
<small>FALSE</small> for a text event, then you should
normally either use <tt>&quot;dtext&quot;</tt> or decode the
entities yourself before the text is processed further.</p>

<p style="margin-left:11%;">&quot;length&quot;</p>

<p style="margin-left:17%;">Length causes the number of
bytes of the source text of the event to be passed.</p>

<p style="margin-left:11%;">&quot;line&quot;</p>

<p style="margin-left:17%;">Line causes the line number of
the start of the event to be passed. The first line in the
document is 1. Line counting doesn&rsquo;t start until at
least one handler requests this value to be reported.</p>

<p style="margin-left:11%;">&quot;offset&quot;</p>

<p style="margin-left:17%;">Offset causes the byte position
in the <small>HTML</small> document of the start of the
event to be passed. The first byte in the document has
offset 0.</p>

<p style="margin-left:11%;">&quot;offset_end&quot;</p>

<p style="margin-left:17%;">Offset_end causes the byte
position in the <small>HTML</small> document of the end of
the event to be passed. This is the same as
<tt>&quot;offset&quot;</tt> +
<tt>&quot;length&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;self&quot;</p>

<p style="margin-left:17%;">Self causes the current object
to be passed to the handler. If the handler is a method,
this must be the first element in the argspec.</p>

<p style="margin-left:17%; margin-top: 1em">An alternative
to passing self as an argspec is to register closures that
capture <tt>$self</tt> by themselves as handlers.
Unfortunately this creates circular references which prevent
the HTML::Parser object from being garbage collected. Using
the <tt>&quot;self&quot;</tt> argspec avoids this
problem.</p>

<p style="margin-left:11%;">&quot;skipped_text&quot;</p>

<p style="margin-left:17%;">Skipped_text returns the
concatenated text of all the events that have been skipped
since the last time an event was reported. Events might be
skipped because no handler is registered for them or because
some filter applies. Skipped text also includes marked
section markup, since there are no events that can catch
it.</p>

<p style="margin-left:17%; margin-top: 1em">If an
<tt>&quot;&quot;</tt>&minus;handler is registered for an
event, then the text for this event is not included in
<tt>&quot;skipped_text&quot;</tt>. Skipped text both before
and after the <tt>&quot;&quot;</tt>&minus;event is included
in the next reported <tt>&quot;skipped_text&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;tag&quot;</p>

<p style="margin-left:17%;">Same as
<tt>&quot;tagname&quot;</tt>, but prefixed with
&quot;/&quot; if it belongs to an <tt>&quot;end&quot;</tt>
event and &quot;!&quot; for a declaration. The
<tt>&quot;tag&quot;</tt> does not have any prefix for
<tt>&quot;start&quot;</tt> events, and is in this case
identical to <tt>&quot;tagname&quot;</tt>.</p>

<p style="margin-left:11%;">&quot;tagname&quot;</p>

<p style="margin-left:17%;">This is the element name (or
<i>generic identifier</i> in <small>SGML</small> jargon) for
start and end tags. Since <small>HTML</small> is case
insensitive, this name is forced to lower case to ease
string matching.</p>

<p style="margin-left:17%; margin-top: 1em">Since
<small>XML</small> is case sensitive, the tagname case is
not changed when <tt>&quot;xml_mode&quot;</tt> is enabled.
The same happens if the <tt>&quot;case_sensitive&quot;</tt>
attribute is set.</p>

<p style="margin-left:17%; margin-top: 1em">The declaration
type of declaration elements is also passed as a tagname,
even if that is a bit strange. In fact, in the current
implementation tagname is identical to
<tt>&quot;token0&quot;</tt> except that the name may be
forced to lower case.</p>

<p style="margin-left:11%;">&quot;token0&quot;</p>

<p style="margin-left:17%;">Token0 causes the original text
of the first token string to be passed. This should always
be the same as <tt>$tokens</tt>&minus;&gt;[0].</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;declaration&quot;</tt> events, this is the
declaration type.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;start&quot;</tt> and <tt>&quot;end&quot;</tt>
events, this is the tag name.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;process&quot;</tt> and non-strict
<tt>&quot;comment&quot;</tt> events, this is everything
inside the tag.</p>

<p style="margin-left:17%; margin-top: 1em">This passes
undef if there are no tokens in the event.</p>

<p style="margin-left:11%;">&quot;tokenpos&quot;</p>

<p style="margin-left:17%;">Tokenpos causes a reference to
an array of token positions to be passed. For each string
that appears in <tt>&quot;tokens&quot;</tt>, this array
contains two numbers. The first number is the offset of the
start of the token in the original <tt>&quot;text&quot;</tt>
and the second number is the length of the token.</p>

<p style="margin-left:17%; margin-top: 1em">Boolean
attributes in a <tt>&quot;start&quot;</tt> event will have
(0,0) for the attribute value offset and length.</p>

<p style="margin-left:17%; margin-top: 1em">This passes
undef if there are no tokens in the event (e.g.,
<tt>&quot;text&quot;</tt>) and for artificial
<tt>&quot;end&quot;</tt> events triggered by empty element
tags.</p>

<p style="margin-left:17%; margin-top: 1em">If you are
using these offsets and lengths to modify
<tt>&quot;text&quot;</tt>, you should either work from right
to left, or be very careful to calculate the changes to the
offsets.</p>

<p style="margin-left:11%;">&quot;tokens&quot;</p>

<p style="margin-left:17%;">Tokens causes a reference to an
array of token strings to be passed. The strings are exactly
as they were found in the original text, no decoding or case
changes are applied.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;declaration&quot;</tt> events, the array contains
each word, comment, and delimited string starting with the
declaration type.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;comment&quot;</tt> events, this contains each
sub-comment. If <tt>$p</tt>&minus;&gt;strict_comments is
disabled, there will be only one sub-comment.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;start&quot;</tt> events, this contains the
original tag name followed by the attribute name/value
pairs. The values of boolean attributes will be either the
value set by <tt>$p</tt>&minus;&gt;boolean_attribute_value,
or the attribute name if no value has been set by
<tt>$p</tt>&minus;&gt;boolean_attribute_value.</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;end&quot;</tt> events, this contains the original
tag name (always one token).</p>

<p style="margin-left:17%; margin-top: 1em">For
<tt>&quot;process&quot;</tt> events, this contains the
process instructions (always one token).</p>

<p style="margin-left:17%; margin-top: 1em">This passes
<tt>&quot;undef&quot;</tt> for <tt>&quot;text&quot;</tt>
events.</p>

<p style="margin-left:11%;">&quot;text&quot;</p>

<p style="margin-left:17%;">Text causes the source text
(including markup element delimiters) to be passed.</p>

<p style="margin-left:11%;">&quot;undef&quot;</p>

<p style="margin-left:17%;">Pass an undefined value. Useful
as padding where the same handler routine is registered for
multiple events.</p>

<p style="margin-left:11%;">'...'</p>

<p style="margin-left:17%;">A literal string of 0 to 255
characters enclosed in single (&rsquo;) or double (&quot;)
quotes is passed as entered.</p>

<p style="margin-left:11%; margin-top: 1em">The whole
argspec string can be wrapped up in <tt>'@{...}'</tt> to
signal that the resulting event array should be flattened.
This only makes a difference if an array reference is used
as the handler target. Consider this example:</p>

<pre style="margin-left:11%; margin-top: 1em">   $p&minus;&gt;handler(text =&gt; [], 'text');
   $p&minus;&gt;handler(text =&gt; [], '@{text}']);</pre>


<p style="margin-left:11%; margin-top: 1em">With two text
events; <tt>&quot;foo&quot;</tt>, <tt>&quot;bar&quot;</tt>;
then the first example will end up with [[&quot;foo&quot;],
[&quot;bar&quot;]] and the second with [&quot;foo&quot;,
&quot;bar&quot;] in the handler target array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Events</b>
<br>
Handlers for the following events can be registered: <br>
&quot;comment&quot;</p>

<p style="margin-left:17%;">This event is triggered when a
markup comment is recognized.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;!&minus;&minus; This is a comment &minus;&minus; &minus;&minus; So is this &minus;&minus;&gt;</pre>


<p style="margin-left:11%;">&quot;declaration&quot;</p>

<p style="margin-left:17%;">This event is triggered when a
<i>markup declaration</i> is recognized.</p>

<p style="margin-left:17%; margin-top: 1em">For typical
<small>HTML</small> documents, the only declaration you are
likely to find is &lt;!DOCTYPE ...&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;!DOCTYPE HTML PUBLIC &quot;&minus;//W3C//DTD HTML 4.01//EN&quot;
      &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">DTDs inside
&lt;!DOCTYPE ...&gt; will confuse HTML::Parser.</p>

<p style="margin-left:11%;">&quot;default&quot;</p>

<p style="margin-left:17%;">This event is triggered for
events that do not have a specific handler. You can set up a
handler for this event to catch stuff you did not want to
catch explicitly.</p>

<p style="margin-left:11%;">&quot;end&quot;</p>

<p style="margin-left:17%;">This event is triggered when an
end tag is recognized.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;/A&gt;</pre>


<p style="margin-left:11%;">&quot;end_document&quot;</p>

<p style="margin-left:17%;">This event is triggered when
<tt>$p</tt>&minus;&gt;eof is called and after any remaining
text is flushed. There is no document text associated with
this event.</p>

<p style="margin-left:11%;">&quot;process&quot;</p>

<p style="margin-left:17%;">This event is triggered when a
processing instructions markup is recognized.</p>

<p style="margin-left:17%; margin-top: 1em">The format and
content of processing instructions are system and
application dependent.</p>

<p style="margin-left:17%; margin-top: 1em">Examples:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;? HTML processing instructions &gt;
  &lt;? XML processing instructions ?&gt;</pre>


<p style="margin-left:11%;">&quot;start&quot;</p>

<p style="margin-left:17%;">This event is triggered when a
start tag is recognized.</p>

<p style="margin-left:17%; margin-top: 1em">Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;A HREF=&quot;http://www.perl.com/&quot;&gt;</pre>


<p style="margin-left:11%;">&quot;start_document&quot;</p>

<p style="margin-left:17%;">This event is triggered before
any other events for a new document. A handler for it can be
used to initialize stuff. There is no document text
associated with this event.</p>

<p style="margin-left:11%;">&quot;text&quot;</p>

<p style="margin-left:17%;">This event is triggered when
plain text (characters) is recognized. The text may contain
multiple lines. A sequence of text may be broken between
several text events unless
<tt>$p</tt>&minus;&gt;unbroken_text is enabled.</p>

<p style="margin-left:17%; margin-top: 1em">The parser will
make sure that it does not break a word or a sequence of
whitespace between two text events.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode</b>
<tt><br>
&quot;HTML::Parser&quot;</tt> can parse Unicode strings when
running under perl&minus;5.8 or better. If Unicode is passed
to <tt>$p</tt>&minus;&gt;<i>parse()</i> then chunks of
Unicode will be reported to the handlers. The offset and
length argspecs will also report their position in terms of
characters.</p>

<p style="margin-left:11%; margin-top: 1em">It is safe to
parse raw undecoded <small>UTF&minus;8</small> if you either
avoid decoding entities and make sure to not use
<i>argspecs</i> that do, or enable the
<tt>&quot;utf8_mode&quot;</tt> for the parser. Parsing of
undecoded <small>UTF&minus;8</small> might be useful when
parsing from a file where you need the reported offsets and
lengths to match the byte offsets in the file.</p>

<p style="margin-left:11%; margin-top: 1em">If a filename
is passed to <tt>$p</tt>&minus;&gt;<i>parse_file()</i> then
the file will be read in binary mode. This will be fine if
the file contains only <small>ASCII</small> or Latin&minus;1
characters. If the file contains <small>UTF&minus;8</small>
encoded text then care must be taken when decoding entities
as described in the previous paragraph, but better is to
open the file with the <small>UTF&minus;8</small> layer so
that it is decoded properly:</p>

<pre style="margin-left:11%; margin-top: 1em">   open(my $fh, &quot;&lt;:utf8&quot;, &quot;index.html&quot;) || die &quot;...: $!&quot;;
   $p&minus;&gt;parse_file($fh);</pre>


<p style="margin-left:11%; margin-top: 1em">If the file
contains text encoded in a charset besides
<small>ASCII,</small> Latin&minus;1 or
<small>UTF&minus;8</small> then decoding will always be
needed.</p>

<h2>VERSION 2 COMPATIBILITY
<a name="VERSION 2 COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When an
<tt>&quot;HTML::Parser&quot;</tt> object is constructed with
no arguments, a set of handlers is automatically provided
that is compatible with the old HTML::Parser version 2
callback methods.</p>

<p style="margin-left:11%; margin-top: 1em">This is
equivalent to the following method calls:</p>

<pre style="margin-left:11%; margin-top: 1em">   $p&minus;&gt;handler(start   =&gt; &quot;start&quot;,   &quot;self, tagname, attr, attrseq, text&quot;);
   $p&minus;&gt;handler(end     =&gt; &quot;end&quot;,     &quot;self, tagname, text&quot;);
   $p&minus;&gt;handler(text    =&gt; &quot;text&quot;,    &quot;self, text, is_cdata&quot;);
   $p&minus;&gt;handler(process =&gt; &quot;process&quot;, &quot;self, token0, text&quot;);
   $p&minus;&gt;handler(comment =&gt;
             sub {
                 my($self, $tokens) = @_;
                 for (@$tokens) {$self&minus;&gt;comment($_);}},
             &quot;self, tokens&quot;);
   $p&minus;&gt;handler(declaration =&gt;
             sub {
                 my $self = shift;
                 $self&minus;&gt;declaration(substr($_[0], 2, &minus;1));},
             &quot;self, text&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">Setting up
these handlers can also be requested with the
&quot;api_version =&gt; 2&quot; constructor option.</p>

<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;HTML::Parser&quot;</tt> class is subclassable.
Parser objects are plain hashes and
<tt>&quot;HTML::Parser&quot;</tt> reserves only hash keys
that start with &quot;_hparser&quot;. The parser state can
be set up by invoking the <i>init()</i> method, which takes
the same arguments as <i>new()</i>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The first
simple example shows how you might strip out comments from
an <small>HTML</small> document. We achieve this by setting
up a comment handler that does nothing and a default handler
that will print out anything else:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTML::Parser;
  HTML::Parser&minus;&gt;new(default_h =&gt; [sub { print shift }, 'text'],
                    comment_h =&gt; [&quot;&quot;],
                   )&minus;&gt;parse_file(shift || die) || die $!;</pre>


<p style="margin-left:11%; margin-top: 1em">An alternative
implementation is:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTML::Parser;
  HTML::Parser&minus;&gt;new(end_document_h =&gt; [sub { print shift },
                                       'skipped_text'],
                    comment_h      =&gt; [&quot;&quot;],
                   )&minus;&gt;parse_file(shift || die) || die $!;</pre>


<p style="margin-left:11%; margin-top: 1em">This will in
most cases be much more efficient since only a single
callback will be made.</p>

<p style="margin-left:11%; margin-top: 1em">The next
example prints out the text that is inside the &lt;title&gt;
element of an <small>HTML</small> document. Here we start by
setting up a start handler. When it sees the title start tag
it enables a text handler that prints any text found and an
end handler that will terminate parsing as soon as the title
end tag is seen:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTML::Parser ();
  sub start_handler
  {
    return if shift ne &quot;title&quot;;
    my $self = shift;
    $self&minus;&gt;handler(text =&gt; sub { print shift }, &quot;dtext&quot;);
    $self&minus;&gt;handler(end  =&gt; sub { shift&minus;&gt;eof if shift eq &quot;title&quot;; },
                           &quot;tagname,self&quot;);
  }
  my $p = HTML::Parser&minus;&gt;new(api_version =&gt; 3);
  $p&minus;&gt;handler( start =&gt; \&amp;start_handler, &quot;tagname,self&quot;);
  $p&minus;&gt;parse_file(shift || die) || die $!;
  print &quot;\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">More examples
are found in the <i>eg/</i> directory of the
<tt>&quot;HTML&minus;Parser&quot;</tt> distribution: the
program <tt>&quot;hrefsub&quot;</tt> shows how you can edit
all links found in a document; the program
<tt>&quot;htextsub&quot;</tt> shows how to edit the text
only; the program <tt>&quot;hstrip&quot;</tt> shows how you
can strip out certain tags/elements and/or attributes; and
the program <tt>&quot;htext&quot;</tt> show how to obtain
the plain text, but not any script/style content.</p>

<p style="margin-left:11%; margin-top: 1em">You can browse
the <i>eg/</i> directory online from the <i>[Browse]</i>
link on the http://search.cpan.org/~gaas/HTML&minus;Parser/
page.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&lt;style&gt; and &lt;script&gt; sections do not end with
the first &quot;&lt;/&quot;, but need the complete
corresponding end tag. The standard behaviour is not really
practical.</p>

<p style="margin-left:11%; margin-top: 1em">When the
<i>strict_comment</i> option is enabled, we still recognize
comments where there is something other than whitespace
between even and odd &quot;&minus;&minus;&quot; markers.</p>

<p style="margin-left:11%; margin-top: 1em">Once
<tt>$p</tt>&minus;&gt;boolean_attribute_value has been set,
there is no way to restore the default behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">There is
currently no way to get both quote characters into the same
literal argspec.</p>

<p style="margin-left:11%; margin-top: 1em">Empty tags,
e.g. &quot;&lt;&gt;&quot; and &quot;&lt;/&gt;&quot;, are not
recognized. <small>SGML</small> allows them to repeat the
previous start tag or close the previous start tag
respectively.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NET</small>
tags, e.g. &quot;code/.../&quot; are not recognized. This is
<small>SGML</small> shorthand for
&quot;&lt;code&gt;...&lt;/code&gt;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Unclosed start
or end tags, e.g.
&quot;&lt;tt&lt;b&gt;...&lt;/b&lt;/tt&gt;&quot; are not
recognized.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
messages may be produced by HTML::Parser. The notation in
this listing is the same as used in perldiag: <br>
Not a reference to a hash</p>

<p style="margin-left:17%;">(F) The object blessed into or
subclassed from HTML::Parser is not a hash as required by
the HTML::Parser methods.</p>

<p style="margin-left:11%;">Bad signature in parser state
object at %p</p>

<p style="margin-left:17%;">(F) The _hparser_xs_state
element does not refer to a valid state structure. Something
must have changed the internal value stored in this hash
element, or the memory has been overwritten.</p>

<p style="margin-left:11%;">_hparser_xs_state element is
not a reference</p>

<p style="margin-left:17%;">(F) The _hparser_xs_state
element has been destroyed.</p>

<p style="margin-left:11%;">Can&rsquo;t find
&rsquo;_hparser_xs_state&rsquo; element in HTML::Parser
hash</p>

<p style="margin-left:17%;">(F) The _hparser_xs_state
element is missing from the parser hash. It was either
deleted, or not created when the object was created.</p>

<p style="margin-left:11%;"><small>API</small> version %s
not supported by HTML::Parser %s</p>

<p style="margin-left:17%;">(F) The constructor option
&rsquo;api_version&rsquo; with an argument greater than or
equal to 4 is reserved for future extensions.</p>

<p style="margin-left:11%;">Bad constructor option
&rsquo;%s&rsquo;</p>

<p style="margin-left:17%;">(F) An unknown constructor
option key was passed to the <i>new()</i> or <i>init()</i>
methods.</p>

<p style="margin-left:11%;">Parse loop not allowed</p>

<p style="margin-left:17%;">(F) A handler invoked the
<i>parse()</i> or <i>parse_file()</i> method. This is not
permitted.</p>

<p style="margin-left:11%;">marked sections not
supported</p>

<p style="margin-left:17%;">(F) The
<tt>$p</tt>&minus;&gt;<i>marked_sections()</i> method was
invoked in a HTML::Parser module that was compiled without
support for marked sections.</p>

<p style="margin-left:11%;">Unknown boolean attribute
(%d)</p>

<p style="margin-left:17%;">(F) Something is wrong with the
internal logic that set up aliases for boolean
attributes.</p>

<p style="margin-left:11%;">Only code or array references
allowed as handler</p>

<p style="margin-left:17%;">(F) The second argument for
<tt>$p</tt>&minus;&gt;handler must be either a subroutine
reference, then name of a subroutine or method, or a
reference to an array.</p>

<p style="margin-left:11%;">No handler for %s events</p>

<p style="margin-left:17%;">(F) The first argument to
<tt>$p</tt>&minus;&gt;handler must be a valid event name;
i.e. one of &quot;start&quot;, &quot;end&quot;,
&quot;text&quot;, &quot;process&quot;,
&quot;declaration&quot; or &quot;comment&quot;.</p>

<p style="margin-left:11%;">Unrecognized identifier %s in
argspec</p>

<p style="margin-left:17%;">(F) The identifier is not a
known argspec name. Use one of the names mentioned in the
argspec section above.</p>

<p style="margin-left:11%;">Literal string is longer than
255 chars in argspec</p>

<p style="margin-left:17%;">(F) The current implementation
limits the length of literals in an argspec to 255
characters. Make the literal shorter.</p>

<p style="margin-left:11%;">Backslash reserved for literal
string in argspec</p>

<p style="margin-left:17%;">(F) The backslash character
&quot;\&quot; is not allowed in argspec literals. It is
reserved to permit quoting inside a literal in a later
version.</p>

<p style="margin-left:11%;">Unterminated literal string in
argspec</p>

<p style="margin-left:17%;">(F) The terminating quote
character for a literal was not found.</p>

<p style="margin-left:11%;">Bad argspec (%s)</p>

<p style="margin-left:17%;">(F) Only identifier names,
literals, spaces and commas are allowed in argspecs.</p>

<p style="margin-left:11%;">Missing comma separator in
argspec</p>

<p style="margin-left:17%;">(F) Identifiers in an argspec
must be separated with &quot;,&quot;.</p>

<p style="margin-left:11%;">Parsing of undecoded
<small>UTF&minus;8</small> will give garbage when decoding
entities</p>

<p style="margin-left:17%;">(W) The first chunk parsed
appears to contain undecoded <small>UTF&minus;8</small> and
one or more argspecs that decode entities are used for the
callback handlers.</p>

<p style="margin-left:17%; margin-top: 1em">The result of
decoding will be a mix of encoded and decoded characters for
any entities that expand to characters with code above 127.
This is not a good thing.</p>

<p style="margin-left:17%; margin-top: 1em">The recommened
solution is to apply <i>Encode::decode_utf8()</i> on the
data before feeding it to the
<tt>$p</tt>&minus;&gt;<i>parse()</i>. For
<tt>$p</tt>&minus;&gt;<i>parse_file()</i> pass a file that
has been opened in &quot;:utf8&quot; mode.</p>

<p style="margin-left:17%; margin-top: 1em">The alternative
solution is to enable the <tt>&quot;utf8_mode&quot;</tt> and
not decode before passing strings to
<tt>$p</tt>&minus;&gt;<i>parse()</i>. The parser can process
raw undecoded <small>UTF&minus;8</small> sanely if the
<tt>&quot;utf8_mode&quot;</tt> is enabled, or if the
&quot;attr&quot;, &quot;@attr&quot; or &quot;dtext&quot;
argspecs are avoided.</p>

<p style="margin-left:11%;">Parsing string decoded with
wrong endianness</p>

<p style="margin-left:17%;">(W) The first character in the
document is U+FFFE. This is not a legal Unicode character
but a byte swapped <small>BOM.</small> The result of parsing
will likely be garbage.</p>

<p style="margin-left:11%;">Parsing of undecoded
<small>UTF&minus;32</small></p>

<p style="margin-left:17%;">(W) The parser found the
Unicode <small>UTF&minus;32 BOM</small> signature at the
start of the document. The result of parsing will likely be
garbage.</p>

<p style="margin-left:11%;">Parsing of undecoded
<small>UTF&minus;16</small></p>

<p style="margin-left:17%;">(W) The parser found the
Unicode <small>UTF&minus;16 BOM</small> signature at the
start of the document. The result of parsing will likely be
garbage.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">HTML::Entities,
HTML::PullParser, HTML::TokeParser, HTML::HeadParser,
HTML::LinkExtor, HTML::Form</p>


<p style="margin-left:11%; margin-top: 1em">HTML::TreeBuilder
(part of the <i>HTML-Tree</i> distribution)</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://www.w3.org/TR/html4/&gt;</p>

<p style="margin-left:11%; margin-top: 1em">More
information about marked sections and processing
instructions may be found at
&lt;http://www.is&minus;thought.co.uk/book/sgml&minus;8.htm&gt;.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> Copyright 1996&minus;2008 Gisle Aas. All rights reserved.
 Copyright 1999&minus;2000 Michael A. Chase.  All rights reserved.</pre>


<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
