<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:43:57 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IO::HTML</title>

</head>
<body>

<h1 align="center">IO::HTML</h1>

<a href="#NAME">NAME</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SUBROUTINES">SUBROUTINES</a><br>
<a href="#EXPORTS">EXPORTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#CONFIGURATION AND ENVIRONMENT">CONFIGURATION AND ENVIRONMENT</a><br>
<a href="#DEPENDENCIES">DEPENDENCIES</a><br>
<a href="#INCOMPATIBILITIES">INCOMPATIBILITIES</a><br>
<a href="#BUGS AND LIMITATIONS">BUGS AND LIMITATIONS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br>
<a href="#DISCLAIMER OF WARRANTY">DISCLAIMER OF WARRANTY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">IO::HTML
&minus; Open an HTML file with automatic charset
detection</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
describes version 1.00 of <small>IO::HTML,</small> released
February 23, 2013.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use IO::HTML;                 # exports html_file by default
  use HTML::TreeBuilder;
  my $tree = HTML::TreeBuilder&minus;&gt;new_from_file(
               html_file('foo.html')
             );
  # Alternative interface:
  open(my $in, '&lt;:raw', 'bar.html');
  my $encoding = IO::HTML::sniff_encoding($in, 'bar.html');</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>IO::HTML</small>
provides an easy way to open a file containing
<small>HTML</small> while automatically determining its
encoding. It uses the <small>HTML5</small> encoding sniffing
algorithm specified in section 8.2.2.1 of the draft
standard.</p>

<p style="margin-left:11%; margin-top: 1em">The algorithm
as implemented here is:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the file begins with a byte order mark indicating
<small>UTF&minus;16LE, UTF&minus;16BE,</small> or
<small>UTF&minus;8,</small> then that is the encoding.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the first 1024 bytes of the file contain a
<tt>&quot;&lt;meta&gt;&quot;</tt> tag that indicates the
charset, and Encode recognizes the specified charset name,
then that is the encoding. (This portion of the algorithm is
implemented by <tt>&quot;find_charset_in&quot;</tt>.)</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;&lt;meta&gt;&quot;</tt> tag can be in one of two
formats:</p>

<pre style="margin-left:17%; margin-top: 1em">  &lt;meta charset=&quot;...&quot;&gt;
  &lt;meta http&minus;equiv=&quot;Content&minus;Type&quot; content=&quot;...charset=...&quot;&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">The search is
case-insensitive, and the order of attributes within the tag
is irrelevant. Any additional attributes of the tag are
ignored. The first matching tag with a recognized encoding
ends the search.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the first 1024 bytes of the
file are valid <small>UTF&minus;8</small> (with at least 1
non-ASCII character), then the encoding is
<small>UTF&minus;8.</small></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If all else fails, use the default character encoding.
The <small>HTML5</small> standard suggests the default
encoding should be locale dependent, but currently it is
always <tt>&quot;cp1252&quot;</tt> unless you set
<tt>$IO::HTML::default_encoding</tt> to a different value.
Note: <tt>&quot;sniff_encoding&quot;</tt> does not apply
this step; only <tt>&quot;html_file&quot;</tt> does
that.</p> </td></tr>
</table>

<h2>SUBROUTINES
<a name="SUBROUTINES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>html_file</b></p>


<pre style="margin-left:11%;">  $filehandle = html_file($filename, \%options);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
(exported by default) is the primary entry point. It opens
the file specified by <tt>$filename</tt> for reading, uses
<tt>&quot;sniff_encoding&quot;</tt> to find a suitable
encoding layer, and applies it. It also applies the
<tt>&quot;:crlf&quot;</tt> layer. If the file begins with a
<small>BOM,</small> the filehandle is positioned just after
the <small>BOM.</small></p>

<p style="margin-left:11%; margin-top: 1em">The optional
second argument is a hashref containing options. The
possible keys are described under
<tt>&quot;find_charset_in&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>&quot;sniff_encoding&quot;</tt> is unable to determine
the encoding, it defaults to
<tt>$IO::HTML::default_encoding</tt>, which is set to
<tt>&quot;cp1252&quot;</tt> (a.k.a. Windows&minus;1252) by
default. According to the standard, the default should be
locale dependent, but that is not currently implemented.</p>

<p style="margin-left:11%; margin-top: 1em">It dies if the
file cannot be opened.</p>


<p style="margin-left:11%; margin-top: 1em"><b>html_file_and_encoding</b></p>


<pre style="margin-left:11%;">  ($filehandle, $encoding, $bom)
    = html_file_and_encoding($filename, \%options);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
(exported only by request) is just like
<tt>&quot;html_file&quot;</tt>, but returns more
information. In addition to the filehandle, it returns the
name of the encoding used, and a flag indicating whether a
byte order mark was found (if <tt>$bom</tt> is true, the
file began with a <small>BOM</small> ). This may be useful
if you want to write the file out again (especially in
conjunction with the <tt>&quot;html_outfile&quot;</tt>
function).</p>

<p style="margin-left:11%; margin-top: 1em">The optional
second argument is a hashref containing options. The
possible keys are described under
<tt>&quot;find_charset_in&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">It dies if the
file cannot be opened. The result of calling it in scalar
context is undefined.</p>


<p style="margin-left:11%; margin-top: 1em"><b>html_outfile</b></p>


<pre style="margin-left:11%;">  $filehandle = html_outfile($filename, $encoding, $bom);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
(exported only by request) opens <tt>$filename</tt> for
output using <tt>$encoding</tt>, and writes a
<small>BOM</small> to it if <tt>$bom</tt> is true. If
<tt>$encoding</tt> is <tt>&quot;undef&quot;</tt>, it
defaults to <tt>$IO::HTML::default_encoding</tt>.
<tt>$encoding</tt> may be either an encoding name or an
Encode::Encoding object.</p>

<p style="margin-left:11%; margin-top: 1em">It dies if the
file cannot be opened.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sniff_encoding</b></p>


<pre style="margin-left:11%;">  ($encoding, $bom) = sniff_encoding($filehandle, $filename, \%options);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
(exported only by request) runs the <small>HTML5</small>
encoding sniffing algorithm on <tt>$filehandle</tt> (which
must be seekable, and should have been opened in
<tt>&quot;:raw&quot;</tt> mode). <tt>$filename</tt> is used
only for error messages (if there&rsquo;s a problem using
the filehandle), and defaults to &quot;file&quot; if
omitted. The optional third argument is a hashref containing
options. The possible keys are described under
<tt>&quot;find_charset_in&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">It returns
Perl&rsquo;s canonical name for the encoding, which is not
necessarily the same as the <small>MIME</small> or
<small>IANA</small> charset name. It returns
<tt>&quot;undef&quot;</tt> if the encoding cannot be
determined. <tt>$bom</tt> is true if the file began with a
byte order mark. In scalar context, it returns only
<tt>$encoding</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The
filehandle&rsquo;s position is restored to its original
position (normally the beginning of the file) unless
<tt>$bom</tt> is true. In that case, the position is
immediately after the <small>BOM.</small></p>

<p style="margin-left:11%; margin-top: 1em">Tip: If you
want to run <tt>&quot;sniff_encoding&quot;</tt> on a file
you&rsquo;ve already loaded into a string, open an in-memory
file on the string, and pass that handle:</p>

<pre style="margin-left:11%; margin-top: 1em">  ($encoding, $bom) = do {
    open(my $fh, '&lt;', \$string);  sniff_encoding($fh)
  };</pre>


<p style="margin-left:11%; margin-top: 1em">(This only
makes sense if <tt>$string</tt> contains bytes, not
characters.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_charset_in</b></p>


<pre style="margin-left:11%;">  $encoding = find_charset_in($string_containing_HTML, \%options);</pre>


<p style="margin-left:11%; margin-top: 1em">This function
(exported only by request) looks for charset information in
a <tt>&quot;&lt;meta&gt;&quot;</tt> tag in a possibly
incomplete <small>HTML</small> document using the &quot;two
step&quot; algorithm specified by <small>HTML5.</small> It
does not look for a <small>BOM.</small> Only the first 1024
bytes of the string are checked.</p>

<p style="margin-left:11%; margin-top: 1em">It returns
Perl&rsquo;s canonical name for the encoding, which is not
necessarily the same as the <small>MIME</small> or
<small>IANA</small> charset name. It returns
<tt>&quot;undef&quot;</tt> if no charset is specified or if
the specified charset is not recognized by the Encode
module.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
second argument is a hashref containing options. The
following keys are recognized: <br>
&quot;encoding&quot;</p>

<p style="margin-left:17%;">If true, return the
Encode::Encoding object instead of its name. Defaults to
false.</p>

<p style="margin-left:11%;">&quot;need_pragma&quot;</p>

<p style="margin-left:17%;">If true (the default), follow
the <small>HTML5</small> spec and examine the
<tt>&quot;content&quot;</tt> attribute only of
<tt>&quot;&lt;meta
http&minus;equiv=&quot;Content&minus;Type&quot;&quot;</tt>.
If set to 0, relax the <small>HTML5</small> spec, and look
for &quot;charset=&quot; in the <tt>&quot;content&quot;</tt>
attribute of <i>every</i> meta tag.</p>

<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">By default,
only <tt>&quot;html_file&quot;</tt> is exported. Other
functions may be exported on request.</p>

<p style="margin-left:11%; margin-top: 1em">For people who
prefer not to export functions, all functions beginning with
<tt>&quot;html_&quot;</tt> have an alias without that prefix
(e.g. you can call <tt>&quot;IO::HTML::file(...)&quot;</tt>
instead of <tt>&quot;IO::HTML::html_file(...)&quot;</tt>.
These aliases are not exportable.</p>

<p style="margin-left:11%; margin-top: 1em">The following
export tags are available: <br>
&quot;:all&quot;</p>

<p style="margin-left:17%;">All exportable functions.</p>

<p style="margin-left:11%;">&quot;:rw&quot;</p>


<p style="margin-left:17%;"><tt>&quot;html_file&quot;</tt>,
<tt>&quot;html_file_and_encoding&quot;</tt>,
<tt>&quot;html_outfile&quot;</tt>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>HTML5</small> specification, section 8.2.2.1
Determining the character encoding:
&lt;http://www.w3.org/TR/html5/parsing.html#determining&minus;the&minus;character&minus;encoding&gt;</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&quot;Could not
read %s: %s&quot;</p>

<p style="margin-left:17%;">The specified file could not be
read from for the reason specified by <tt>$!</tt>.</p>

<p style="margin-left:11%;">&quot;Could not seek %s:
%s&quot;</p>

<p style="margin-left:17%;">The specified file could not be
rewound for the reason specified by <tt>$!</tt>.</p>

<p style="margin-left:11%;">&quot;Failed to open %s:
%s&quot;</p>

<p style="margin-left:17%;">The specified file could not be
opened for reading for the reason specified by
<tt>$!</tt>.</p>

<p style="margin-left:11%;">&quot;No default encoding
specified&quot;</p>

<p style="margin-left:17%;">The
<tt>&quot;sniff_encoding&quot;</tt> algorithm didn&rsquo;t
find an encoding to use, and you set
<tt>$IO::HTML::default_encoding</tt> to
<tt>&quot;undef&quot;</tt>.</p>

<h2>CONFIGURATION AND ENVIRONMENT
<a name="CONFIGURATION AND ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>IO::HTML</small>
requires no configuration files or environment
variables.</p>

<h2>DEPENDENCIES
<a name="DEPENDENCIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>IO::HTML</small>
has no non-core dependencies for Perl 5.8.7+. With earlier
versions of Perl 5.8, you need to upgrade Encode to at least
version 2.10, and you may need to upgrade Exporter to at
least version 5.57.</p>

<h2>INCOMPATIBILITIES
<a name="INCOMPATIBILITIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None
reported.</p>

<h2>BUGS AND LIMITATIONS
<a name="BUGS AND LIMITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No bugs have
been reported.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Christopher J.
Madsen
<tt>&quot;&lt;perl&nbsp;AT&nbsp;cjmweb.net&gt;&quot;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Please report
any bugs or feature requests to
<tt>&quot;&lt;bug&minus;IO&minus;HTML&nbsp;AT&nbsp;rt.cpan.org&gt;&quot;</tt>
or through the web interface at
&lt;http://rt.cpan.org/Public/Bug/Report.html?Queue=IO&minus;HTML&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">You can follow
or contribute to IO-HTML&rsquo;s development at
&lt;http://github.com/madsen/io&minus;html&gt;.</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
is copyright (c) 2013 by Christopher J. Madsen.</p>

<p style="margin-left:11%; margin-top: 1em">This is free
software; you can redistribute it and/or modify it under the
same terms as the Perl 5 programming language system
itself.</p>

<h2>DISCLAIMER OF WARRANTY
<a name="DISCLAIMER OF WARRANTY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><small>BECAUSE
THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY
APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE
&quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE
PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR, OR CORRECTION.</small></p>

<p style="margin-left:11%; margin-top: 1em"><small>IN NO
EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO
MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY
THE ABOVE LICENSE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING
ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE
SOFTWARE</small> ( <small>INCLUDING BUT NOT LIMITED TO LOSS
OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE
SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE</small> ),
<small>EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED
OF THE POSSIBILITY OF SUCH DAMAGES.</small></p>
<hr>
</body>
</html>
