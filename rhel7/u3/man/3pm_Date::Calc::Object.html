<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:08:40 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Date::Calc::Object</title>

</head>
<body>

<h1 align="center">Date::Calc::Object</h1>

<a href="#NAME">NAME</a><br>
<a href="#MOTTO">MOTTO</a><br>
<a href="#PREFACE">PREFACE</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#DISCLAIMER">DISCLAIMER</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Date::Calc::Object
&minus; Object&minus;oriented add&minus;on for Date::Calc
with overloaded operators</p>

<h2>MOTTO
<a name="MOTTO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Make frequent
things easy and infrequent or hard things possible</p>

<h2>PREFACE
<a name="PREFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that you
do <b><small>NOT</small></b> need to &quot;<tt>&quot;use
Date::Calc qw(...);&quot;</tt>&quot; in addition to this
module.</p>

<p style="margin-left:11%; margin-top: 1em">Simply</p>

<pre style="margin-left:11%; margin-top: 1em">  use Date::Calc::Object qw(...);</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>INSTEAD
OF</small></b></p>

<pre style="margin-left:11%; margin-top: 1em">  use Date::Calc qw(...);</pre>


<p style="margin-left:11%; margin-top: 1em">with the same
&quot;<tt>&quot;qw(...)&quot;</tt>&quot; as you would with
the &quot;Date::Calc&quot; module, and then forget about
&quot;Date::Calc::Object&quot; altogether.</p>

<p style="margin-left:11%; margin-top: 1em">The rest of
your existing code doesn&rsquo;t change at all.</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
in order to create a new date object, you do not need to
use</p>

<pre style="margin-left:11%; margin-top: 1em">  $date_object = Date::Calc::Object&minus;&gt;new(...);</pre>


<p style="margin-left:11%; margin-top: 1em">(but you may),
and should use</p>

<pre style="margin-left:11%; margin-top: 1em">  $date_object = Date::Calc&minus;&gt;new(...);</pre>


<p style="margin-left:11%; margin-top: 1em">instead (saves
you some typing and is a trifle faster).</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Export
tags</b></p>

<pre style="margin-left:11%;">  :all  &minus;  all functions from Date::Calc
  :aux  &minus;  auxiliary functions shift_*
  :ALL  &minus;  both :all and :aux</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Functions</b>
<br>
See <i>Date::Calc</i>(3) for a list of available
functions.</p>

<pre style="margin-left:11%; margin-top: 1em">  $year                          = shift_year(\@_);
  ($year,$mm,$dd)                = shift_date(\@_);
  ($hrs,$min,$sec)               = shift_time(\@_);
  ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Methods</b></p>


<pre style="margin-left:11%;">  $old = Date::Calc&minus;&gt;accurate_mode([FLAG]);
  $old = Date::Calc&minus;&gt;normalized_mode([FLAG]);
  $old = Date::Calc&minus;&gt;number_format([NUMBER|CODEREF]);
  $old = Date::Calc&minus;&gt;delta_format([NUMBER|CODEREF]);  # global default
  $old = Date::Calc&minus;&gt;date_format([NUMBER|CODEREF]);   # global default
  $old = Date::Calc&minus;&gt;language([LANGUAGE]);            # global default &minus; DEPRECATED
  $old = $date&minus;&gt;accurate_mode([FLAG]);           # is global nevertheless!
  $old = $date&minus;&gt;normalized_mode([FLAG]);         # is global nevertheless!
  $old = $date&minus;&gt;number_format([NUMBER|CODEREF]); # is global nevertheless!
  $old = $date&minus;&gt;delta_format([NUMBER|CODEREF]);  # individual override
  $old = $date&minus;&gt;date_format([NUMBER|CODEREF]);   # individual override
  $old = $date&minus;&gt;language([LANGUAGE]);            # individual override
  $flag = $date&minus;&gt;is_delta();
  $flag = $date&minus;&gt;is_date();
  $flag = $date&minus;&gt;is_short(); # i.e., has no time part
  $flag = $date&minus;&gt;is_long();  # i.e., has time part
  $flag = $date&minus;&gt;is_valid();
  $date = Date::Calc&minus;&gt;new([TYPE]);
  $date = Date::Calc&minus;&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $date = Date::Calc&minus;&gt;new($arrayref);
  $newdate = $somedate&minus;&gt;new([TYPE]);
  $newdate = $somedate&minus;&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $newdate = $somedate&minus;&gt;new($arrayref);
  $datecopy = $date&minus;&gt;clone();
  $targetdate&minus;&gt;copy($sourcedate);
  $targetdate&minus;&gt;copy($arrayref);
  $targetdate&minus;&gt;copy(@list);
  ($year,$month,$day) = $date&minus;&gt;date([TYPE]);
  ($year,$month,$day) = $date&minus;&gt;date([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  ($year,$month,$day) = $date&minus;&gt;date($arrayref);
  ([$hrs,$min,$sec])  = $date&minus;&gt;time([TYPE]);
  ($hrs,$min,$sec)    = $date&minus;&gt;time([TYPE,]HRS,MIN,SEC);
  ([$hrs,$min,$sec])  = $date&minus;&gt;time($arrayref);
  ($year,$month,$day,$hrs,$min,$sec) =
      $date&minus;&gt;datetime([TYPE]);
  ($year,$month,$day,$hrs,$min,$sec) =
      $date&minus;&gt;datetime([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $date  = Date::Calc&minus;&gt;today([FLAG]);
  $date  = Date::Calc&minus;&gt;now([FLAG]); # shorthand for &minus;&minus;+
  $date  = Date::Calc&minus;&gt;today_and_now([FLAG]); # &lt;&minus;&minus;&minus;&minus;&minus;+
  $date  = Date::Calc&minus;&gt;gmtime([time]);    # UTC/GMT
  $date  = Date::Calc&minus;&gt;localtime([time]); # local time
  $delta = Date::Calc&minus;&gt;tzoffset([time]);
  $date  = Date::Calc&minus;&gt;time2date([time]); # UTC/GMT
  $date&minus;&gt;today([FLAG]);         # updates the date part only
  $date&minus;&gt;now([FLAG]);           # updates the time part only
  $date&minus;&gt;today_and_now([FLAG]); # updates both date and time
  $date&minus;&gt;gmtime([time]);        # updates both date and time (UTC/GMT)
  $date&minus;&gt;localtime([time]);     # updates both date and time (local time)
  $delta&minus;&gt;tzoffset([time]);     # updates both date and time
  $date&minus;&gt;time2date([time]);     # updates both date and time (UTC/GMT)
  $time = Date::Calc&minus;&gt;mktime();    # same as &quot;$time = CORE::time();&quot;
  $time = Date::Calc&minus;&gt;date2time(); # same as &quot;$time = CORE::time();&quot;
  $time = $date&minus;&gt;mktime();      # converts into Unix time (local time)
  $time = $date&minus;&gt;date2time();   # converts into Unix time (UTC/GMT)
  $year    = $date&minus;&gt;year([YEAR]);
  $month   = $date&minus;&gt;month([MONTH]);
  $day     = $date&minus;&gt;day([DAY]);
  $hours   = $date&minus;&gt;hours([HRS]);
  $minutes = $date&minus;&gt;minutes([MIN]);
  $seconds = $date&minus;&gt;seconds([SEC]);
  $number = $date&minus;&gt;number([NUMBER|CODEREF]);
  $string = $date&minus;&gt;string([NUMBER|CODEREF][,LANGUAGE]);
  $delta&minus;&gt;normalize(); # renormalizes a delta vector</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Overloaded
Operators</b></p>

<pre style="margin-left:11%;">  #####################################################
  # Scalar operands are always converted into a delta #
  # vector with that many days, i.e., [1,0,0,SCALAR]  #
  #####################################################</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Comparison
Operators:</b></p>

<pre style="margin-left:11%;">  if ($date1 &lt;  $date2) { # compares date part only
  if ($date1 &lt;= $date2) { # compares date part only
  if ($date1 &gt;  $date2) { # compares date part only
  if ($date1 &gt;= $date2) { # compares date part only
  if ($date1 == $date2) { # compares date part only
  if ($date1 != $date2) { # compares date part only
  $comp = $date1 &lt;=&gt; $date2; # compares date part only
  if ($date1 lt $date2) { # compares both date and time
  if ($date1 le $date2) { # compares both date and time
  if ($date1 gt $date2) { # compares both date and time
  if ($date1 ge $date2) { # compares both date and time
  if ($date1 eq $date2) { # compares both date and time
  if ($date1 ne $date2) { # compares both date and time
  $comp = $date1 cmp $date2; # compares both date and time</pre>


<p style="margin-left:11%; margin-top: 1em">Note that you
can of course also compare two deltas, but not a date and a
delta!</p>

<pre style="margin-left:11%; margin-top: 1em">  ##################################################
  # Default TYPE for array refs in comparisons is: #
  # Same as other operand                          #
  ##################################################
  if ([2000,4,1] == $date) {
  if ($today &gt; [2000,4,1]) {
  if ($now ge [2000,3,26,2,0,0]) {
  if ($delta == [18,0,0]) {
  if ($delta == &minus;1) {</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Plus:</b></p>


<pre style="margin-left:11%;">  $date2 = $date1 + $delta;
  $date2 = $delta + $date1;
  $date += $delta;
  $this = $date++;
  $next = ++$date;
  $delta3 = $delta1 + $delta2;
  $delta1 += $delta2;
  $delta += $date; # beware of implicit type change!
  $delta++;
  ++$delta;
  #####################################################
  # Default TYPE for array refs in '+' operations is: #
  # Opposite of other operand                         #
  #####################################################
  $date2 = [2000,3,26] + $delta;
  $date2 = $date1 + [+1,0,0];
  $date2 = [0,0,&minus;1] + $date1;
  $date2 = $date1 + 1;
  $date += [0,0,+1];
  $date += 2;
  $delta3 = [1,+1,0,&minus;1] + $delta2;
  $delta3 = $delta1 + [1,0,0,+1];
  $delta3 = $delta1 + 1;
  $delta += [1,0,+1,0];
  $delta += [2000,3,26]; # beware of implicit type change!
  $delta += 7;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Unary
Minus:</b></p>

<pre style="margin-left:11%;">  $delta2 = &minus;$delta1;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Minus:</b></p>


<pre style="margin-left:11%;">  $delta = $date2 &minus; $date1;
  $date2 = $date1 &minus; $delta;
  $date &minus;= $delta;
  $date2 &minus;= $date1; # beware of implicit type change!
  $this = $date&minus;&minus;;
  $prev = &minus;&minus;$date;
  $delta3 = $delta2 &minus; $delta1;
  $delta2 &minus;= $delta1;
  $delta&minus;&minus;;
  &minus;&minus;$delta;
  #####################################################
  # Default TYPE for array refs in '&minus;' operations is: #
  # Always a date                                     #
  #####################################################
  $delta = $today &minus; [2000,3,26];
  $delta = [2000,4,1] &minus; $date;
  $date2 = [2000,3,26] &minus; $delta;
  $date2 = $date1 &minus; [1,0,0,+7];
  $date2 = $date1 &minus; 7;
  $date &minus;= [1,0,0,+1]; # better add [0,0,&minus;1] instead!
  $date2 &minus;= [2000,3,26]; # beware of implicit type change!
  $date2 &minus;= 1;
  $delta3 = [1,0,+1,0] &minus; $delta1;
  $delta3 = $delta2 &minus; [1,0,0,&minus;1];
  $delta &minus;= [1,0,0,+1];
  $delta &minus;= 7;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous
Operators:</b></p>

<pre style="margin-left:11%;">  $string = &quot;$date&quot;;
  $string = &quot;$delta&quot;;
  print &quot;$date\n&quot;;
  print &quot;$delta\n&quot;;
  if ($date) { # date is valid
  if ($delta) { # delta is valid
  $days = abs($date);
  $diff = abs($delta); # can be negative!
  $diff = abs(abs($delta)); # always positive</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>FLAG</small></p></td>
<td width="80%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">&quot;
<small>FLAG&quot;</small> is either 0 (for
&quot;false&quot;) or 1 (for &quot;true&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">In the case of
&quot;<tt>&quot;accurate_mode()&quot;</tt>&quot; and
&quot;<tt>&quot;normalized_mode()&quot;</tt>&quot;, this
switches the corresponding mode on and off (see further
below for an explanation of what these are).</p>

<p style="margin-left:14%; margin-top: 1em">In the case of
&quot;<tt>&quot;today()&quot;</tt>&quot;,
&quot;<tt>&quot;now()&quot;</tt>&quot; and
&quot;<tt>&quot;today_and_now()&quot;</tt>&quot;, a
&quot;true&quot; value indicates &quot;
<small>GMT&quot;</small> (Greenwich Mean Time), as opposed
to local time, which is the default.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p style="margin-top: 1em"><small>NUMBER</small></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">&quot;
<small>NUMBER&quot;</small> is a number between 0 and 2 (for
&quot;<i>number_format()</i>&quot; and
&quot;<i>number()</i>&quot;) or between 0 and 4 (for
&quot;<i>delta_format()</i>&quot;,
&quot;<i>date_format()</i>&quot; and
&quot;<i>string()</i>&quot;), indicating which of the
three/five predefined formats, respectively, should be used
for converting a date into numeric representation (needed
for comparing dates, for instance) or string
representation.</p>

<p style="margin-left:14%; margin-top: 1em">Format #0 is
the default at startup and the simplest of all (and should
be fastest to calculate, too).</p>

<p style="margin-left:14%; margin-top: 1em">The string
representation of dates in format #0 also has the advantage
of being sortable in chronological order (and of complying
with <small>ISO&nbsp;</small> 8601).</p>

<p style="margin-left:14%; margin-top: 1em">(The numeric
formats are (trivially) always sortable in chronological
order of course.)</p>

<p style="margin-left:14%; margin-top: 1em">The other
formats are (mostly) increasingly more sophisticated (in
terms of esthetics and computation time) with increasing
number (except for format #4):</p>

<pre style="margin-left:14%; margin-top: 1em">  Delta number formats (short):
      0    13603
      1    13603
      2    13603
  Delta string formats (short):
      0    '+0+0+13603'
      1    '+0 +0 +13603'
      2    '+0Y +0M +13603D'
      3    '+0 Y +0 M +13603 D'
      4    '(0,0,13603)'
  Date number formats (short):
      0    20010401
      1    730576
      2    730576
  Date string formats (short):
      0    '20010401'
      1    '01&minus;Apr&minus;2001'
      2    'Sun 1&minus;Apr&minus;2001'
      3    'Sunday, April 1st 2001'
      4    '[2001,4,1]'
  Delta number formats (long):
      0    13603.012959
      1    13603.012959
      2    13603.0624884259
  Delta string formats (long):
      0    '+0+0+13603+1+29+59'
      1    '+0 +0 +13603 +1 +29 +59'
      2    '+0Y +0M +13603D +1h +29m +59s'
      3    '+0 Y +0 M +13603 D +1 h +29 m +59 s'
      4    '(0,0,13603,1,29,59)'
  Date number formats (long):
      0    20010401.082959
      1    730576.082959
      2    730576.354155093
  Date string formats (long):
      0    '20010401082959'
      1    '01&minus;Apr&minus;2001 08:29:59'
      2    'Sun 1&minus;Apr&minus;2001 08:29:59'
      3    'Sunday, April 1st 2001 08:29:59'
      4    '[2001,4,1,8,29,59]'</pre>


<p style="margin-left:14%; margin-top: 1em">If a number
outside of the permitted range is specified, or if the value
is not a code reference (see also the next section below for
more details), the default format #0 is used instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>CODEREF</small></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">&quot;
<small>CODEREF&quot;</small> is the reference of a
subroutine which can be passed to the methods
&quot;<i>number_format()</i>&quot;,
&quot;<i>delta_format()</i>&quot; and
&quot;<i>date_format()</i>&quot; in order to install a
callback function which will be called subsequently whenever
a date (or delta) object needs to be (implicitly) converted
into a number or string.</p>

<p style="margin-left:14%; margin-top: 1em">This happens
for instance when you compare two date objects, or when you
put a date object reference in a string between double
quotes.</p>

<p style="margin-left:14%; margin-top: 1em">Such a &quot;
<small>CODEREF&quot;</small> can also be passed to the
methods &quot;<i>number()</i>&quot; and
&quot;<i>string()</i>&quot; for explicitly converting a date
object as desired.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="12%">


<p style="margin-top: 1em"><small>LANGUAGE</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">&quot;
<small>LANGUAGE&quot;</small> is either a number in the
range <tt>&quot;[1..Languages()]&quot;</tt>, or one of the
strings
&quot;<tt>&quot;Language_to_Text(1..Languages())&quot;</tt>&quot;
(see also <i>Date::Calc</i>(3)).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>TYPE</small></p></td>
<td width="80%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">&quot;
<small>TYPE&quot;</small> is 0 for a regular date and 1 for
a delta vector (a list of year, month, day and optionally
hours, minutes and seconds offsets).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="11%">


<p style="margin-top: 1em">Storage</p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em">&quot;Date::Calc&quot;
objects are implemented as two nested arrays.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;blessed&quot; array (whose reference is the object
reference you receive when calling the
&quot;<i>new()</i>&quot; method) contains an anonymous array
at position zero and the object&rsquo;s data in its
remaining fields.</p>

<p style="margin-left:14%; margin-top: 1em">The embedded
anonymous array is used for storing the object&rsquo;s
attributes (flags).</p>

<p style="margin-left:14%; margin-top: 1em">Dates and delta
vectors always comprise either 3 or 6 data values: Year,
month, day plus (optionally) hours, minutes and seconds.</p>

<p style="margin-left:14%; margin-top: 1em">These values
are stored in the &quot;blessed&quot; array at positions
1..3 or 1..6, respectively.</p>

<p style="margin-left:14%; margin-top: 1em">An object
without the time values is therefore called
&quot;short&quot;, and an object having time values is
called &quot;long&quot; throughout this manual.</p>

<p style="margin-left:14%; margin-top: 1em">Hint: Whenever
possible, if you do not need the time values, omit them,
i.e., always use the &quot;short&quot; form of the object if
possible, this will speed up calculations a little (the
short form uses different (faster) functions for all
calculations internally).</p>

<p style="margin-left:14%; margin-top: 1em">The embedded
anonymous array contains various flags:</p>

<p style="margin-left:14%; margin-top: 1em">At position
zero, it contains the &quot; <small>TYPE&quot;</small>
indicator which determines whether the object is a date or a
delta vector.</p>

<p style="margin-left:14%; margin-top: 1em">At position 1,
the object stores the &quot; <small>NUMBER&quot;</small> of
one of the delta vector formats, or the reference of a
callback function which converts the contents of the object
into string representation if it&rsquo;s a delta vector, or
&quot;undef&quot; if the global settings apply.</p>

<p style="margin-left:14%; margin-top: 1em">At position 2,
the object stores the &quot; <small>NUMBER&quot;</small> of
one of the date formats, or the reference of a callback
function which converts the contents of the object into
string representation if it&rsquo;s a date, or
&quot;undef&quot; if the global settings apply.</p>

<p style="margin-left:14%; margin-top: 1em">At position 3,
the object stores the &quot; <small>LANGUAGE&quot;</small>
to be used for all conversions into strings (where
applicable), or &quot;undef&quot; if the global language
setting applies.</p>

<p style="margin-left:14%; margin-top: 1em">Note that your
callback functions (see the section &quot;Callback
Functions&quot; further below for more details) should not
pay attention to this value at position 3, because they get
a parameter which tells them which language to use (this is
necessary in order to allow temporary overrides).</p>

<p style="margin-left:14%; margin-top: 1em">If your
callback handlers use the &quot;*_to_Text*&quot; functions
(or any other language-dependent function) from the
&quot;Date::Calc&quot; module, your handlers should pass on
this language parameter to these functions (and not the
value from position 3).</p>

<p style="margin-left:14%; margin-top: 1em">Be reminded
though that you should <b><small>NEVER</small></b> access
the object&rsquo;s internal data directly, i.e., through
their positional numbers, but <b><small>ALWAYS</small></b>
through their respective accessor methods, e.g.:</p>

<pre style="margin-left:14%; margin-top: 1em">        year()
        month()
        day()
        hours()
        minutes()
        seconds()
        date()
        time()
        datetime()
        is_delta()
        is_date()
        is_short()
        is_long()
        delta_format()
        date_format()
        language()</pre>


<p style="margin-left:14%; margin-top: 1em">And although
position 4 and onward in the embedded anonymous array is
currently unused, it might not stay so in future releases of
this module.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, in
case you need more attributes in a subclass of the
&quot;Date::Calc[::Object]&quot; class, I suggest using
values starting at positions a bit further up, e.g. 6, 8 or
10.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p style="margin-top: 1em">Invalid Dates</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Only
&quot;<i>new()</i>&quot; allows to create objects containing
possibly invalid dates (needed for reading in and evaluating
user input, for example).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="8%">


<p style="margin-top: 1em">Usage</p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The methods</p>

<pre style="margin-left:14%; margin-top: 1em">        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()
        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()</pre>


<p style="margin-left:14%; margin-top: 1em">are used for
reading as well as for setting attributes. They simply
return the values in question if they are called without
parameters.</p>

<p style="margin-left:14%; margin-top: 1em">The methods</p>

<pre style="margin-left:14%; margin-top: 1em">        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()</pre>


<p style="margin-left:14%; margin-top: 1em">always return
the previous value if a new value is set. This allows you to
change these values temporarily and to restore their old
value afterwards more easily (but you can also override the
&quot;format&quot; and &quot;language&quot; settings
directly when calling the &quot;<i>number()</i>&quot; or
&quot;<i>string()</i>&quot; method).</p>

<p style="margin-left:14%; margin-top: 1em">The methods</p>

<pre style="margin-left:14%; margin-top: 1em">        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()</pre>


<p style="margin-left:14%; margin-top: 1em">always return
the new values when the corresponding values have been
changed.</p>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<i>date()</i>&quot; <small>NEVER</small> returns the
time values (hours, minutes, seconds) even if they have just
been set using this method (which the method optionally
allows). Otherwise it would be very hard to predict the
exact number of values it returns, which might lead to
errors (wrong number of parameters) elsewhere in your
program.</p>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<i>datetime()</i>&quot; <small>ALWAYS</small> returns
the time values (hours, minutes, seconds) even if the object
in question lacks a time part. In that case, zeros are
returned for hours, minutes and seconds instead (but the
stored time part is left unchanged, whether it exists or
not).</p>

<p style="margin-left:14%; margin-top: 1em">If you do not
provide values for hours, minutes and seconds when using the
method &quot;<i>date()</i>&quot; to set the values for year,
month and day, the time part will not be changed (whether it
exists or not).</p>

<p style="margin-left:14%; margin-top: 1em">If you do not
provide values for hours, minutes and seconds when using the
method &quot;<i>datetime()</i>&quot; to set the values for
year, month and day, the time part will be filled with zeros
(the time part will be created if necessary).</p>

<p style="margin-left:14%; margin-top: 1em">If the object
is short, i.e., if it does not have any time values, the
method &quot;<i>time()</i>&quot; returns an empty list.</p>

<p style="margin-left:14%; margin-top: 1em">If the object
is short and the methods &quot;<i>hours()</i>&quot;,
&quot;<i>minutes()</i>&quot; or &quot;<i>seconds()</i>&quot;
are used to set any of these time values, the object is
automatically promoted to the &quot;long&quot; form, and the
other two time values are filled with zeros.</p>

<p style="margin-left:14%; margin-top: 1em">The following
methods can also return &quot;undef&quot; under certain
circumstances:</p>

<pre style="margin-left:14%; margin-top: 1em">        delta_format()
        date_format()
        language()
        is_delta()
        is_date()
        is_short()
        is_long()
        is_valid()
        hours()
        minutes()
        seconds()
        number()
        string()</pre>


<p style="margin-left:14%; margin-top: 1em">The methods
&quot;<i>delta_format()</i>&quot;,
&quot;<i>date_format()</i>&quot; and
&quot;<i>language()</i>&quot; return &quot;undef&quot; when
they are called as object methods and no individual override
has been defined for the object in question.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;is_*()&quot; predicate methods return
&quot;undef&quot; if the object in question does not have
the expected internal structure. This can happen for
instance when you create an empty object with
&quot;<i>new()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">When called
without parameters, the methods &quot;<i>hours()</i>&quot;,
&quot;<i>minutes()</i>&quot; and
&quot;<i>seconds()</i>&quot; return &quot;undef&quot; if the
object in question does not have a time part.</p>

<p style="margin-left:14%; margin-top: 1em">The methods
&quot;<i>number()</i>&quot; and &quot;<i>string()</i>&quot;
return &quot;undef&quot; if the object in question is not
valid (i.e., if &quot;<i>is_valid()</i>&quot; returns
&quot;undef&quot; or false).</p>

<p style="margin-left:14%; margin-top: 1em">And finally,
the methods</p>

<pre style="margin-left:14%; margin-top: 1em">        copy()
        today()
        now()
        today_and_now()
        gmtime()
        localtime()
        tzoffset()
        time2date()
        normalize()</pre>


<p style="margin-left:14%; margin-top: 1em">return the
object reference of the (target) object in question for
convenience.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p style="margin-top: 1em">Import/Export</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that you
can import and export Unix &quot;time&quot; values using the
methods &quot;<i>gmtime()</i>&quot;,
&quot;<i>localtime()</i>&quot;, &quot;<i>mktime()</i>&quot;,
&quot;<i>date2time()</i>&quot; and
&quot;<i>time2date()</i>&quot;, both as local time or as
<small>UTC/GMT.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em">Accurate Mode and Normalized
Mode</p> </td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<i>accurate_mode()</i>&quot; controls the internal
flag which determines which of two fundamental modes of
operation is used.</p>

<p style="margin-left:14%; margin-top: 1em">When set to
true (the default at startup), delta vectors are calculated
to give the exact difference in days between two dates. The
&quot;year&quot; and &quot;month&quot; entries in the
resulting delta vector are always zero in that case.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;accurate mode&quot; is switched off (when the
corresponding flag is set to false), delta vectors are
calculated with year and month differences.</p>

<p style="margin-left:14%; margin-top: 1em">E.g., the
difference between <tt>&quot;[1999,12,6]&quot;</tt> and
<tt>&quot;[2000,6,24]&quot;</tt> is <tt>&quot;[+0 +0
+201]&quot;</tt> (plus 201 days) in accurate mode and
<tt>&quot;[+1 &minus;6 +18]&quot;</tt> (plus one year, minus
6 months, plus 18 days) when accurate mode is switched off,
and is <tt>&quot;[+0 +6 +18]&quot;</tt> (plus 6 months, plus
18 days) if additionally, &quot;normalized mode&quot; is
switched on.</p>

<p style="margin-left:14%; margin-top: 1em">The delta
vector is calculated by simply taking the difference in
years, the difference in months and the difference in days
(if &quot;accurate mode&quot; is switched off and if
&quot;normalized mode&quot; has not been switched on). This
is called &quot;one-by-one&quot; semantics or
&quot;year-month-day mode&quot;; &quot; <small>YMD</small>
mode&quot; for short.</p>

<p style="margin-left:14%; margin-top: 1em">When
&quot;normalized mode&quot; is switched on (while
&quot;accurate mode&quot; is switched off), the delta vector
is calculated in a more complex way involving the functions
&quot;<tt>&quot;Add_Delta_YM()&quot;</tt>&quot; (for
&quot;truncation&quot;) and
&quot;<tt>&quot;Delta_Days()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, the
result is normalized, i.e., the return values are guaranteed
to all have the same sign (or to be zero), and to all be
&quot;minimal&quot;, i.e., not to exceed the ranges
<tt>&quot;[&minus;11..+11]&quot;</tt> for months,
<tt>&quot;[&minus;30..+30]&quot;</tt> for days,
<tt>&quot;[&minus;23..+23]&quot;</tt> for hours and
<tt>&quot;[&minus;59..+59]&quot;</tt> for minutes and
seconds.</p>

<p style="margin-left:14%; margin-top: 1em">The rule is to
add these result values to a date in a left-to-right order,
and to truncate invalid intermediate dates, such as e.g.
<tt>&quot;[2009,2,29]&quot;</tt>, to the last valid day of
that same month, e.g. <tt>&quot;[2009,2,28]&quot;</tt>. This
is called &quot;left-to-right with truncation&quot;
semantics or &quot;normalized mode&quot;; &quot;N_YMD
mode&quot; for short.</p>

<p style="margin-left:14%; margin-top: 1em">The method
&quot;<i>normalized_mode()</i>&quot; controls the internal
flag which determines whether &quot; <small>YMD</small>
mode&quot; is used (the default at startup, for reasons of
backward compatibility) or &quot;N_YMD mode&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that also
for reasons of backward compatibility, this flag only has
effect when &quot;accurate mode&quot; is switched off.</p>

<p style="margin-left:14%; margin-top: 1em">Both flags can
be set and reset independently from each other, however.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, at
startup, you can for instance switch &quot;normalized
mode&quot; on, without having any immediate effect, and
switch off &quot;accurate mode&quot; later, which instantly
also causes &quot;normalized mode&quot; to spring into
effect.</p>

<p style="margin-left:14%; margin-top: 1em">Because years
and months have varying lengths in terms of days, the &quot;
<small>YMD&quot;</small> and &quot;N_YMD&quot; modes are
less accurate than &quot;accurate mode&quot;, because these
modes depend on the context of the two dates of which the
delta vector is the difference. Added to a different date, a
delta vector calculated in &quot; <small>YMD</small>
mode&quot; or &quot;N_YMD mode&quot; may yield a different
offset in terms of days, i.e., the final result may
sometimes vary seemingly unpredictably (or in other
situations may give you the expected result, at the expense
of actually representing a varying difference in days,
determined exclusively by context).</p>

<p style="margin-left:14%; margin-top: 1em">Beware also
that &minus; for the same reason &minus; the absolute value
(&quot;<tt>&quot;abs()&quot;</tt>&quot;) of a delta vector
returns a fictitious number of days if the delta vector
contains non-zero values for &quot;year&quot; and/or
&quot;month&quot; (see also the next section &quot;Absolute
Value&quot; below for more details).</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<p style="margin-left:14%; margin-top: 1em">The difference
between <tt>&quot;[2000,1,1]&quot;</tt> and
<tt>&quot;[2000,3,1]&quot;</tt> is <tt>&quot;[+0 +0
+60]&quot;</tt> in &quot;accurate mode&quot; and
<tt>&quot;[+0 +2 +0]&quot;</tt> in &quot; <small>YMD</small>
mode&quot; (in this &quot;benign&quot; example, the result
is the same in &quot; <small>YMD</small> mode&quot; and in
&quot;N_YMD mode&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">When added to
the date <tt>&quot;[2000,4,1]&quot;</tt>, the
&quot;accurate&quot; delta vector yields the date
<tt>&quot;[2000,5,31]&quot;</tt>, whereas the &quot;
<small>YMD</small> mode&quot; delta vector yields the date
<tt>&quot;[2000,6,1]&quot;</tt> (which is actually a
difference of 61 days).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, when
added to the date <tt>&quot;[1999,1,1]&quot;</tt>, the
&quot;accurate&quot; delta vector yields the date
<tt>&quot;[1999,3,2]&quot;</tt>, whereas the
&quot;inaccurate&quot; &quot; <small>YMD</small> Mode&quot;
delta vector yields the date <tt>&quot;[1999,3,1]&quot;</tt>
(which is actually a difference of 59 days).</p>

<p style="margin-left:14%; margin-top: 1em">Depending on
what you want, either mode may suit you better.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Absolute Value</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>&quot;abs($date)&quot;</tt>&quot; and
&quot;<tt>&quot;abs($delta)&quot;</tt>&quot; are just
shorthands for
&quot;<tt>&quot;$date&minus;&gt;number()&quot;</tt>&quot;
and
&quot;<tt>&quot;$delta&minus;&gt;number()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The operator
&quot;<tt>&quot;abs()&quot;</tt>&quot;, when applied to a
date or delta vector, returns the corresponding number of
days (see below for an exception to this), with the time
part (if available) represented by a fraction after the
decimal point.</p>

<p style="margin-left:14%; margin-top: 1em">In the case of
dates, the absolute value (to the left of the decimal point)
is the number of days since the 1st of January 1&nbsp;A.D.
(by extrapolating the Gregorian calendar back beyond its
&quot;natural&quot; limit of 1582 A.D.) <b><small>PLUS
ONE</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">(I.e., the
absolute value of the 1st of January 1 A.D. is 1.)</p>

<p style="margin-left:14%; margin-top: 1em">Exception:</p>

<p style="margin-left:14%; margin-top: 1em">If the &quot;
<small>NUMBER&quot;</small> or
&quot;<i>number_format()</i>&quot; is set to 0 (the default
setting), the absolute value of a date to the left of the
decimal point is &quot;yyyymmdd&quot;, i.e., the number in
which the uppermost four digits correspond to the year, the
next lower two digits to the month and the lowermost two
digits to the day.</p>

<p style="margin-left:14%; margin-top: 1em">In the case of
delta vectors, the absolute value (to the left of the
decimal point) is simply the difference in days (but see
also below).</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
absolute value of a delta vector can be negative!</p>

<p style="margin-left:14%; margin-top: 1em">If you want a
positive value in all cases, apply the
&quot;<tt>&quot;abs()&quot;</tt>&quot; operator again, i.e.,
&quot;<tt>&quot;$posdiff =
abs(abs($delta));&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">If the delta
vector contains non-zero values for &quot;year&quot; and/or
&quot;month&quot; (see also the discussion of &quot;Accurate
Mode&quot; in the section above), an exact representation in
days cannot be calculated, because years and months do not
have fixed equivalents in days.</p>

<p style="margin-left:14%; margin-top: 1em">If nevertheless
you attempt to calculate the absolute value of such a delta
vector, a fictitious value is returned, which is calculated
by simply multiplying the year difference with 12, adding
the month difference, multiplying this sum with 31 and
finally adding the day difference.</p>

<p style="margin-left:14%; margin-top: 1em">Beware that
because of this, the absolute values of delta vectors are
not necessarily contiguous.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, since
there is more than one way to express the difference between
two dates, comparisons of delta vectors may not always yield
the expected result.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<p style="margin-left:14%; margin-top: 1em">The difference
between the two dates <tt>&quot;[2000,4,30]&quot;</tt> and
<tt>&quot;[2001,5,1]&quot;</tt> can be expressed as
<tt>&quot;[+1 +1 &minus;29]&quot;</tt>, or as <tt>&quot;[+1
+0 +1]&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">The first delta
vector has an absolute value of 374, whereas the latter
delta vector has an absolute value of only 373 (while the
true difference in days between the two dates is 366).</p>

<p style="margin-left:14%; margin-top: 1em">If the date or
delta vector has a time part, the time is returned as a
fraction of a full day after the decimal point as
follows:</p>

<p style="margin-left:14%; margin-top: 1em">If the &quot;
<small>NUMBER&quot;</small> or
&quot;<i>number_format()</i>&quot; is set to 0 (the default
setting) or 1, this fraction is simply &quot;.hhmmss&quot;,
i.e., the two digits after the decimal point represent the
hours, the next two digits the minutes and the last two
digits the seconds.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
cannot simply add and subtract these values to yield
meaningful dates or deltas again, you can only use them for
comparisons (equal, not equal, less than, greater than,
etc.). If you want to add/subtract, read on:</p>

<p style="margin-left:14%; margin-top: 1em">Only when the
&quot; <small>NUMBER&quot;</small> or
&quot;<i>number_format()</i>&quot; is set to 2, this
fraction will be the equivalent number of seconds (i.e.,
<tt>&quot;(((hours * 60) + minutes) * 60) +
seconds&quot;</tt>) divided by the number of seconds in a
full day (i.e., <tt>&quot;24*60*60 = 86400&quot;</tt>), or
<tt>&quot;0/86400&quot;</tt>, <tt>&quot;1/86400&quot;</tt>,
... , <tt>&quot;86399/86400&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
the (mathematically correct) fraction of a day.</p>

<p style="margin-left:14%; margin-top: 1em">You can safely
perform arithmetics with these values as far as the internal
precision of your vendor&rsquo;s implementation of the C
run-time library (on which Perl depends) will permit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em">Renormalizing Delta Vectors</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">When adding or
subtracting delta vectors to/from one another, the addition
or subtraction takes place component by component.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  [+0 +0 +0 +3 +29 +50] + [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +3 +29 +50] &minus; [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 &minus;26 +45]</pre>


<p style="margin-left:14%; margin-top: 1em">This may result
in time values outside the usual ranges
(<tt>&quot;[&minus;23..+23]&quot;</tt> for hours and
<tt>&quot;[&minus;59..+59]&quot;</tt> for minutes and
seconds).</p>

<p style="margin-left:14%; margin-top: 1em">Note that even
though the delta value for days will often become quite
large, it is impossible to renormalize this value because
there is no constant conversion factor from days to months
(should it be 28, 29, 30 or 31?).</p>

<p style="margin-left:14%; margin-top: 1em">If accurate
mode (see further above for what that is) is switched off,
delta vectors can also contain non-zero values for years and
months. If you add or subtract these, the value for months
can lie outside the range
<tt>&quot;[&minus;11..11]&quot;</tt>, which isn&rsquo;t
wrong, but may seem funny.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, the
&quot;<i>normalize()</i>&quot; method will also renormalize
the &quot;months&quot; value, if and only if accurate mode
has been switched off. (!)</p>

<p style="margin-left:14%; margin-top: 1em">(Hence, switch
accurate mode <b><small>ON</small></b> temporarily if you
<b><small>DON</small> &rsquo;T</b> want the renormalization
of the &quot;months&quot; value to happen.)</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
force the time values from the example above back into their
proper ranges, use the &quot;<i>normalize()</i>&quot; method
as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  print &quot;[$delta]\n&quot;;
  $delta&minus;&gt;normalize();
  print &quot;[$delta]\n&quot;;</pre>


<p style="margin-left:14%; margin-top: 1em">This will
print</p>

<pre style="margin-left:14%; margin-top: 1em">  [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +4 +24 +55]</pre>


<p style="margin-left:14%; margin-top: 1em">for the first
and</p>

<pre style="margin-left:14%; margin-top: 1em">  [+0 +0 +0 +3 &minus;26 +45]
  [+0 +0 +0 +2 +34 +45]</pre>


<p style="margin-left:14%; margin-top: 1em">for the second
delta vector from the example further above.</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
values for days, hours, minutes and seconds are guaranteed
to have the same sign after the renormalization.</p>

<p style="margin-left:14%; margin-top: 1em">Under
&quot;normal&quot; circumstances, i.e., when accurate mode
is on (the default), this method only has an effect on the
time part of the delta vector.</p>

<p style="margin-left:14%; margin-top: 1em">If the delta
vector in question does not have a time part, nothing
happens.</p>

<p style="margin-left:14%; margin-top: 1em">If accurate
mode is off, the &quot;months&quot; value is also
normalized, i.e., if it lies outside of the range
<tt>&quot;[&minus;11..11]&quot;</tt>, integer multiples of
12 are added to the &quot;years&quot; value and subtracted
from the &quot;months&quot; value. Moreover, the
&quot;months&quot; value is guaranteed to have the same sign
as the values for days, hours, minutes and seconds, unless
the &quot;months&quot; value is zero or the values for days,
hours, minutes and seconds are all zero.</p>

<p style="margin-left:14%; margin-top: 1em">If the object
in question is a date and if warnings are enabled, the
message &quot;normalizing a date is a no-op&quot; will be
printed to <small>STDERR.</small></p>

<p style="margin-left:14%; margin-top: 1em">If the object
in question is not a valid &quot;Date::Calc&quot; object,
nothing happens.</p>

<p style="margin-left:14%; margin-top: 1em">The method
returns its object&rsquo;s reference, which allows chaining
of method calls, as in the following example:</p>

<pre style="margin-left:14%; margin-top: 1em">  @time = $delta&minus;&gt;normalize()&minus;&gt;time();</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Callback Functions</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that you
are not restricted to the built-in formats (numbered from 0
to 2 for &quot;<i>number_format()</i>&quot; and
&quot;<i>number()</i>&quot; and from 0 to 4 for
&quot;<i>delta_format()</i>&quot;,
&quot;<i>date_format()</i>&quot; and
&quot;<i>string()</i>&quot;) for converting a date or delta
object into a number or string.</p>

<p style="margin-left:14%; margin-top: 1em">You can also
provide your own function(s) for doing so, in order to suit
your own taste or needs, by passing a subroutine reference
to the appropriate method, i.e.,
&quot;<i>number_format()</i>&quot;,
&quot;<i>number()</i>&quot;,
&quot;<i>delta_format()</i>&quot;,
&quot;<i>date_format()</i>&quot; and
&quot;<i>string()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">You can pass a
handler to only one or more of these methods, or to all of
them, as you like. You can use different callback functions,
or the same for all.</p>

<p style="margin-left:14%; margin-top: 1em">In order to
facilitate the latter, and in order to make the decoding of
the various cases easier for you, the callback function
receives a uniquely identifying function code as its second
parameter:</p>

<pre style="margin-left:14%; margin-top: 1em">  0  =  TO_NUMBER | IS_DATE  | IS_SHORT  (number[_format])
  1  =  TO_NUMBER | IS_DATE  | IS_LONG   (number[_format])
  2  =  TO_NUMBER | IS_DELTA | IS_SHORT  (number[_format])
  3  =  TO_NUMBER | IS_DELTA | IS_LONG   (number[_format])
  4  =  TO_STRING | IS_DATE  | IS_SHORT  (string|date_format)
  5  =  TO_STRING | IS_DATE  | IS_LONG   (string|date_format)
  6  =  TO_STRING | IS_DELTA | IS_SHORT  (string|delta_format)
  7  =  TO_STRING | IS_DELTA | IS_LONG   (string|delta_format)</pre>


<p style="margin-left:14%; margin-top: 1em">The first
parameter of the callback function is of course the
reference of the object in question itself (therefore, the
callback function can actually be an object method &minus;
but not a class method, for obvious reasons).</p>

<p style="margin-left:14%; margin-top: 1em">The third
parameter is the number of the language (in the range
<tt>&quot;[1..Languages()]&quot;</tt>) which you should
always pass along when using any of the following functions
from the &quot;Date::Calc&quot; module in your handler:</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<i>Decode_Month()</i>&quot;,
&quot;<i>Decode_Day_of_Week()</i>&quot;,
&quot;<i>Compressed_to_Text()</i>&quot;,
&quot;<i>Date_to_Text()</i>&quot;,
&quot;<i>Date_to_Text_Long()</i>&quot;,
&quot;<i>Calendar()</i>&quot;,
&quot;<i>Month_to_Text()</i>&quot;,
&quot;<i>Day_of_Week_to_Text()</i>&quot;,
&quot;<i>Day_of_Week_Abbreviation()</i>&quot;,
&quot;<i>Decode_Date_EU()</i>&quot;,
&quot;<i>Decode_Date_US()</i>&quot;,
&quot;<i>Decode_Date_EU2()</i>&quot;,
&quot;<i>Decode_Date_US2()</i>&quot;,
&quot;<i>Parse_Date()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The callback
handler should return the resulting number or string, as
requested.</p>


<p style="margin-left:14%; margin-top: 1em"><small>BEWARE</small>
that you should <small>NEVER</small> rely upon any knowledge
of the object&rsquo;s internal structure, as this may be
subject to change!</p>


<p style="margin-left:14%; margin-top: 1em"><small>ALWAYS</small>
use the test and access methods provided by this module!</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  sub handler
  {
      my($self,$code,$lang) = @_;
      if    ($code == 0) # TO_NUMBER | IS_DATE  | IS_SHORT
      {
          return Date_to_Days( $self&minus;&gt;date() );
      }
      elsif ($code == 1) # TO_NUMBER | IS_DATE  | IS_LONG
      {
          return Date_to_Days( $self&minus;&gt;date() ) +
                           ( ( $self&minus;&gt;hours() * 60 +
                               $self&minus;&gt;minutes() ) * 60 +
                               $self&minus;&gt;seconds() ) / 86400;
      }
      elsif ($code == 2) # TO_NUMBER | IS_DELTA | IS_SHORT
      {
          return ( $self&minus;&gt;year() * 12 +
                   $self&minus;&gt;month() ) * 31 +
                   $self&minus;&gt;day();
      }
      elsif ($code == 3) # TO_NUMBER | IS_DELTA | IS_LONG
      {
          return ( $self&minus;&gt;year() * 12 +
                   $self&minus;&gt;month() ) * 31 +
                   $self&minus;&gt;day() +
               ( ( $self&minus;&gt;hours() * 60 +
                   $self&minus;&gt;minutes() ) * 60 +
                   $self&minus;&gt;seconds() ) / 86400;
      }
      elsif ($code == 4) # TO_STRING | IS_DATE  | IS_SHORT
      {
          return join( &quot;/&quot;, $self&minus;&gt;date() );
      }
      elsif ($code == 5) # TO_STRING | IS_DATE  | IS_LONG
      {
          return join( &quot;/&quot;, $self&minus;&gt;date() ) . &quot; &quot; .
                 join( &quot;:&quot;, $self&minus;&gt;time() );
      }
      elsif ($code == 6) # TO_STRING | IS_DELTA | IS_SHORT
      {
          return join( &quot;|&quot;, $self&minus;&gt;date() );
      }
      elsif ($code == 7) # TO_STRING | IS_DELTA | IS_LONG
      {
          return join( &quot;|&quot;, $self&minus;&gt;datetime() );
      }
      else
      {
          die &quot;internal error&quot;;
      }
  }
  Date::Calc&minus;&gt;number_format(\&amp;handler);
  Date::Calc&minus;&gt;delta_format(\&amp;handler);
  Date::Calc&minus;&gt;date_format(\&amp;handler);</pre>


<p style="margin-left:14%; margin-top: 1em">This sets our
handler to take care of all automatic conversions, such as
needed when comparing dates or when interpolating a string
in double quotes which contains a date object.</p>

<p style="margin-left:14%; margin-top: 1em">To deactivate a
handler, simply pass a valid format number to the method in
question, e.g.:</p>

<pre style="margin-left:14%; margin-top: 1em">  Date::Calc&minus;&gt;number_format(0);
  Date::Calc&minus;&gt;delta_format(2);
  Date::Calc&minus;&gt;date_format(3);</pre>


<p style="margin-left:14%; margin-top: 1em">When calling
the &quot;<i>number()</i>&quot; or
&quot;<i>string()</i>&quot; method explicitly, you can pass
a different format number (than the global setting), like
this:</p>

<pre style="margin-left:14%; margin-top: 1em">  $number = $date&minus;&gt;number(2);
  $string = $date&minus;&gt;string(1);</pre>


<p style="margin-left:14%; margin-top: 1em">You can also
pass a handler&rsquo;s reference, like so:</p>

<pre style="margin-left:14%; margin-top: 1em">  $number = $date&minus;&gt;number(\&amp;handler);
  $string = $date&minus;&gt;string(\&amp;handler);</pre>


<p style="margin-left:14%; margin-top: 1em">This overrides
the global setting and the individual object&rsquo;s local
setting for the duration of the call of
&quot;<i>number()</i>&quot; or &quot;<i>string()</i>&quot;
(but doesn&rsquo;t change the global or local settings
themselves).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, you
can also define individual overrides for the date and the
delta vector formats (but not the number format) for
individual objects, e.g.:</p>

<pre style="margin-left:14%; margin-top: 1em">  $date&minus;&gt;delta_format(1);
  $date&minus;&gt;date_format(2);
  $date&minus;&gt;delta_format(\&amp;handler);
  $date&minus;&gt;date_format(\&amp;handler);</pre>


<p style="margin-left:14%; margin-top: 1em">In order to
deactivate an individual handler for an object, and/or in
order to deactivate any override altogether (so that the
global settings apply again), you have to pass
&quot;undef&quot; explicitly to the method in question:</p>

<pre style="margin-left:14%; margin-top: 1em">  $date&minus;&gt;delta_format(undef);
  $date&minus;&gt;date_format(undef);</pre>


<p style="margin-left:14%; margin-top: 1em">You can also
define a language for individual objects (see the next
section immediately below for more details).</p>

<p style="margin-left:14%; margin-top: 1em">If such an
individual language override has been set, it will be passed
to your callback handlers as the third parameter (in the
case of &quot;string&quot; conversions, but not in the case
of &quot;number&quot; conversions).</p>

<p style="margin-left:14%; margin-top: 1em">Otherwise, the
global settings as defined by
<tt>&quot;Language($lang);&quot;</tt> or
<tt>&quot;Date::Calc&minus;&quot;</tt>language($lang);&gt;
will be passed to your handler.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p style="margin-top: 1em">Languages</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that this
module is completely transparent to the setting of a
language in &quot;Date::Calc&quot;. This means that you can
choose a language in &quot;Date::Calc&quot; (with the
&quot;<i>Language()</i>&quot; function) and all dates
subsequently printed by this module will automatically be in
that language &minus; provided that you use the built-in
formats of this module, or that you pass the third parameter
of the callback funtion to the funtions of the
&quot;Date::Calc&quot; module which accept it.</p>

<p style="margin-left:14%; margin-top: 1em">However, this
global language setting can be overridden for individual
date (or delta) objects by using the
<b><small>OBJECT</small></b> method</p>

<pre style="margin-left:14%; margin-top: 1em">    $oldlang = $date&minus;&gt;language($newlang);</pre>


<p style="margin-left:14%; margin-top: 1em">(The global
setting is not altered by this in any way.)</p>

<p style="margin-left:14%; margin-top: 1em">In order to
deactivate such an individual language setting (so that the
global setting applies again), simply pass the value
&quot;undef&quot; explicitly to the
&quot;<i>language()</i>&quot; object method:</p>

<pre style="margin-left:14%; margin-top: 1em">  $date&minus;&gt;language(undef);</pre>


<p style="margin-left:14%; margin-top: 1em">The
<b><small>CLASS</small></b> method</p>

<pre style="margin-left:14%; margin-top: 1em">    $oldlang = Date::Calc&minus;&gt;language($newlang);</pre>


<p style="margin-left:14%; margin-top: 1em">is just a
convenient wrapper around the &quot;<i>Language()</i>&quot;
function, which allows you to enter language numbers (as
returned by the &quot;<i>Decode_Language()</i>&quot;
function) or strings (as returned by the
&quot;<i>Language_to_Text()</i>&quot; function), whatever
you prefer.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;<i>language()</i>&quot; method (both class and object)
always returns the <b><small>NAME</small></b> (one of
&quot;<tt>&quot;Language_to_Text(1..Languages())&quot;</tt>&quot;)
of the current setting (and never its number).</p>


<p style="margin-left:14%; margin-top: 1em"><small>BEWARE</small>
that in order to avoid possible conflicts between threads or
modules running concurrently, you should
<small>NEVER</small> use the global function
<tt>&quot;Language($lang);&quot;</tt> or the class method
<tt>&quot;Date::Calc&minus;&quot;</tt>language($lang);&gt;
in this module!</p>

<p style="margin-left:14%; margin-top: 1em">The class
method is retained only for backward compatibility and for
convenience in stand-alone applications when it is
guaranteed that no such conflicts can arise.</p>

<p style="margin-left:14%; margin-top: 1em">But you should
probably avoid to use global settings anyway, because it may
be especially troublesome to fix your code later when
suddenly the need arises to use your code with threads or
when your code needs to use other modules which also use
&quot;Date::Calc&quot; (with different settings!).</p>

<p style="margin-left:14%; margin-top: 1em">By exclusively
using local settings, you are making your code invulnerable
against other, concurrent modules also using
&quot;Date::Calc&quot; which still use global settings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Exported Functions</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The
&quot;Date::Calc::Object&quot; package imports
&quot;:all&quot; functions exported by the
&quot;Date::Calc&quot; module and re-exports them, for
conveniency.</p>

<p style="margin-left:14%; margin-top: 1em">This allows you
to write</p>

<pre style="margin-left:14%; margin-top: 1em">  use Date::Calc::Object qw(...);</pre>


<p style="margin-left:14%; margin-top: 1em">instead of</p>

<pre style="margin-left:14%; margin-top: 1em">  use Date::Calc qw(...);</pre>


<p style="margin-left:14%; margin-top: 1em">but with
exactly the same semantics. The difference is that the
object-oriented frontend is loaded additionally in the first
case.</p>

<p style="margin-left:14%; margin-top: 1em">As with
&quot;Date::Calc&quot; you can use the &quot;:all&quot; tag
to import all of &quot;Date::Calc&quot;&rsquo;s
functions:</p>

<pre style="margin-left:14%; margin-top: 1em">  use Date::Calc::Object qw(:all);</pre>


<p style="margin-left:14%; margin-top: 1em">In addition to
the functions exported by &quot;Date::Calc&quot;, the
&quot;Date::Calc::Object&quot; package offers some utility
functions of its own for export:</p>

<pre style="margin-left:14%; margin-top: 1em">    $year                          = shift_year(\@_);
    ($year,$mm,$dd)                = shift_date(\@_);
    ($hrs,$min,$sec)               = shift_time(\@_);
    ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);</pre>


<p style="margin-left:14%; margin-top: 1em">These functions
enable your subroutines or methods to accept a
&quot;Date::Calc&quot; (or subclass) date object, an
(anonymous) array or a list (containing the necessary
values) as parameters <b><small>INTERCHANGEABLY</small></b>
.</p>

<p style="margin-left:14%; margin-top: 1em">You can import
all of these auxiliary functions by using an
&quot;:aux&quot; tag:</p>

<pre style="margin-left:14%; margin-top: 1em">  use Date::Calc::Object qw(:aux);</pre>


<p style="margin-left:14%; margin-top: 1em">If you want to
import both all of the &quot;Date::Calc&quot; functions as
well as all these auxiliary functions, use the
&quot;:ALL&quot; tag:</p>

<pre style="margin-left:14%; margin-top: 1em">  use Date::Calc::Object qw(:ALL);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="17%">


<p style="margin-top: 1em">Subclassing</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">In case you
want to subclass &quot;Date::Calc&quot; objects and to add
new attributes of your own, it is recommended that you
proceed as follows (the following will be considered as a
part of the module&rsquo;s &quot;contract of use&quot;
&minus; which might be subject to change in the future,
however):</p>

<p style="margin-left:14%; margin-top: 1em">Define a
constant for the index of each attribute you want to add,
currently starting no lower than &quot;4&quot;, at the top
of your subclass:</p>

<pre style="margin-left:14%; margin-top: 1em">    use constant ATTRIB1 =&gt; 4;
    use constant ATTRIB2 =&gt; 5;
    use constant ATTRIB3 =&gt; 6;
    ...</pre>


<p style="margin-left:14%; margin-top: 1em">It is
recommended that you use constants (which are easy to
change), because I someday might want to require the element
with index &quot;4&quot; for a new attribute of my own...
<tt>&quot;:&minus;)&quot;</tt></p>

<p style="margin-left:14%; margin-top: 1em">Then access
your attributes like so (e.g. after calling
&quot;<tt>&quot;$self =
SUPER&minus;&gt;new();&quot;</tt>&quot; in your constructor
method):</p>

<pre style="margin-left:14%; margin-top: 1em">    $self&minus;&gt;[0][ATTRIB1] = 'value1';
    $self&minus;&gt;[0][ATTRIB2] = 'value2';
    $self&minus;&gt;[0][ATTRIB3] = 'value3';
    ...</pre>


<p style="margin-left:14%; margin-top: 1em">Beware that if
you put anything other than numbers or strings into your
attributes, the methods &quot;<i>clone()</i>&quot; and
&quot;<i>copy()</i>&quot; might not work as expected
anymore!</p>

<p style="margin-left:14%; margin-top: 1em">Especially if
your attributes contain references to other data structures,
only the references will be copied, but not the data
structures themselves.</p>

<p style="margin-left:14%; margin-top: 1em">This may not be
what you want.</p>

<p style="margin-left:14%; margin-top: 1em">(You will have
to override these two methods and write some of your own if
not.)</p>

<p style="margin-left:14%; margin-top: 1em">In order for
the overloaded operators and the &quot;shift_*()&quot;
auxiliary functions from the &quot;Date::Calc::Object&quot;
package to work properly (the latter of which are heavily
used in the &quot;Date::Calendar[::Year]&quot; modules, for
instance), the package name of your subclass (= the one your
objects will be blessed into) is
<b><small>REQUIRED</small></b> to contain a
&quot;::&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
should <b><small>ONLY</small></b> subclass
&quot;Date::Calc&quot;, <b><small>NEVER</small></b>
&quot;Date::Calc::Object&quot;, since subclassing the latter
is less efficient (because &quot;Date::Calc::Object&quot; is
just an empty class which inherits from
&quot;Date::Calc&quot; &minus; subclassing
&quot;Date::Calc::Object&quot; would thus just introduce an
additional name space layer to search during Perl&rsquo;s
runtime method binding process).</p>

<p style="margin-left:14%; margin-top: 1em">If you give
your subclass a package name below/inside the
&quot;Date::&quot; namespace, you will also benefit from the
fact that all error messages produced by the
&quot;Date::Calc[::Object]&quot; module (and also the
&quot;Date::Calendar[::Year]&quot; modules, by the way) will
appear to have originated from the place outside of all
&quot;<tt>&quot;/^Date::/&quot;</tt>&quot; modules
(including yours) where one of the &quot;Date::&quot;
modules was first called &minus; i.e., all errors are always
blamed on the user, no matter how deeply nested inside the
&quot;Date::&quot; modules they occur, and do not usually
refer to places inside any of the &quot;Date::&quot; modules
(this assumes that there are no bugs in the
&quot;Date::&quot; modules, and that all errors are always
the user&rsquo;s fault <tt>&quot;:&minus;)&quot;</tt>).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, your
module&rsquo;s own error messages will behave in the same
way if you &quot;<tt>&quot;use Carp::Clan
qw(^Date::);&quot;</tt>&quot; at the top of your module and
if you produce all error messages using
&quot;<i>carp()</i>&quot; and &quot;<i>croak()</i>&quot;
(instead of &quot;<i>warn()</i>&quot; and
&quot;<i>die()</i>&quot;, respectively).</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1)</p></td>
<td width="4%"></td>
<td width="37%">

<pre style="margin-top: 1em">  # Switch to summer time:</td>
<td width="45%">
</td></tr>
</table></pre>

<p style="margin-left:15%;">$now =
Date::Calc&minus;&gt;now(); <br>
if (($now ge [2000,3,26,2,0,0]) and <br>
($now lt [2000,3,26,3,0,0])) <br>
{ <br>
$now += [0,0,0,1,0,0]; <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2)</p></td>
<td width="4%"></td>
<td width="50%">

<pre style="margin-top: 1em">  use Date::Calc::Object qw(:all);</td>
<td width="32%">
</td></tr>
</table></pre>


<p style="margin-left:15%;">Date::Calc&minus;&gt;date_format(3);
<br>
$date = 0; <br>
while (!$date) <br>
{ <br>
print &quot;Please enter the date of your birthday
(day&minus;month&minus;year): &quot;; <br>
$date = Date::Calc&minus;&gt;new( Decode_Date_EU(
scalar(&lt;STDIN&gt;) ) ); <br>
if ($date) <br>
{ <br>
$resp = 0; <br>
while ($resp !~ /^\s*[YyNn]/) <br>
{ <br>
print &quot;Your birthday is: $date\n&quot;; <br>
print &quot;Is that correct? (yes/no) &quot;; <br>
$resp = &lt;STDIN&gt;; <br>
} <br>
$date = 0 unless ($resp =~ /^\s*[Yy]/) <br>
} <br>
else <br>
{ <br>
print &quot;Unable to parse your birthday. Please try
again.\n&quot;; <br>
} <br>
} <br>
if ($date + [18,0,0] &lt;= [Today()]) <br>
{ print &quot;Ok, you are over 18.\n&quot;; } <br>
else <br>
{ print &quot;Sorry, you are under 18!\n&quot;; }</p>

<p style="margin-left:11%; margin-top: 1em">For more
examples, see the &quot;examples&quot; subdirectory in this
distribution, and their descriptions in the file &quot;
<small>EXAMPLES</small> .txt&quot;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Date::Calc</i>(3),
<i>Date::Calc::Util</i>(3), <i>Date::Calendar</i>(3),
<i>Date::Calendar::Year</i>(3),
<i>Date::Calendar::Profiles</i>(3).</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This man page
documents &quot;Date::Calc::Object&quot; version 6.3.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>


<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2000 &minus; 2009 by Steffen Beyer. All rights reserved.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
free software; you can use, modify and redistribute it under
the same terms as Perl itself, i.e., at your option, under
the terms either of the &quot;Artistic License&quot; or the
&quot; <small>GNU</small> General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The C library
at the core of the module &quot;Date::Calc::XS&quot; can, at
your discretion, also be used, modified and redistributed
under the terms of the &quot; <small>GNU</small> Library
General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the files &quot;Artistic.txt&quot;, &quot;
<small>GNU_GPL</small> .txt&quot; and &quot;
<small>GNU_LGPL</small> .txt&quot; in the
&quot;license&quot; subdirectory of this distribution for
any details!</p>

<h2>DISCLAIMER
<a name="DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">See the &quot;
<small>GNU</small> General Public License&quot; for more
details.</p>
<hr>
</body>
</html>
