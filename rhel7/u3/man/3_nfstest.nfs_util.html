<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:00:24 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>NFS_UTIL</title>

</head>
<body>

<h1 align="center">NFS_UTIL</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CLASSES">CLASSES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">nfstest.nfs_util
- NFS utilities module</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Provides a set
of tools for testing NFS including methods for starting a
packet trace, stopping the packet trace and then open the
packet trace for analysis. It also provides a mechanism to
enable NFS/RPC kernel debug and saving the log messages for
further analysis.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore,
methods for finding specific NFSv4 operations within the
packet trace are also included.</p>

<h2>CLASSES
<a name="CLASSES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>class
NFSUtil(nfstest.host.Host)</b> <br>
NFSUtil object</p>

<p style="margin-left:11%; margin-top: 1em">NFSUtil() -&gt;
New NFSUtil object</p>

<p style="margin-left:11%; margin-top: 1em">Usage: <br>
from nfstest.nfs_util import NFSUtil</p>

<p style="margin-left:11%; margin-top: 1em"># Create object
for local host <br>
x = NFSUtil()</p>

<p style="margin-left:11%; margin-top: 1em"># Start packet
trace <br>
x.trace_start()</p>

<p style="margin-left:11%; margin-top: 1em"># Stop packet
trace <br>
x.trace_stop()</p>

<p style="margin-left:11%; margin-top: 1em"># Open packet
trace <br>
x.trace_open()</p>

<p style="margin-left:11%; margin-top: 1em"># Enable NFS
kernel debug <br>
x.nfs_debug_enable(nfsdebug=&rsquo;all&rsquo;):</p>

<p style="margin-left:11%; margin-top: 1em"># Stop NFS
kernel debug <br>
x.nfs_debug_reset()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Methods
defined here:</b> <br>
---------------------</p>


<p style="margin-left:11%; margin-top: 1em"><b>__del__(self)</b>
<br>
Destructor</p>

<p style="margin-left:11%; margin-top: 1em">Gracefully stop
the packet trace and unreference all client <br>
objects</p>


<p style="margin-left:11%; margin-top: 1em"><b>__init__(self,
**kwargs)</b> <br>
Constructor</p>

<p style="margin-left:11%; margin-top: 1em">Initialize
object&rsquo;s private data.</p>

<p style="margin-left:22%;"><b>rpcdebug:</b></p>

<p style="margin-left:32%;">Set RPC kernel debug flags and
save log messages [default: &rsquo;&rsquo;]</p>

<p style="margin-left:22%;"><b>nfsdebug:</b></p>

<p style="margin-left:32%;">Set NFS kernel debug flags and
save log messages [default: &rsquo;&rsquo;]</p>

<p style="margin-left:22%;"><b>dbgname:</b></p>

<p style="margin-left:32%;">Base name for log messages
files to create [default: &rsquo;dbgfile&rsquo;]</p>

<p style="margin-left:22%;"><b>tracename:</b></p>

<p style="margin-left:32%;">Base name for trace files to
create [default: &rsquo;tracefile&rsquo;]</p>

<p style="margin-left:22%;"><b>trcdelay:</b></p>

<p style="margin-left:32%;">Seconds to delay before
stopping packet trace [default: 0.0]</p>

<p style="margin-left:22%;"><b>notrace:</b></p>

<p style="margin-left:32%;">Debug option so a trace is not
actually started [default: False]</p>

<p style="margin-left:22%;"><b>tcpdump:</b></p>

<p style="margin-left:32%;">Tcpdump command [default:
&rsquo;/usr/sbin/tcpdump&rsquo;]</p>

<p style="margin-left:22%;"><b>messages:</b></p>

<p style="margin-left:32%;">Location of file for system
messages [default: &rsquo;/var/log/messages&rsquo;]</p>

<p style="margin-left:22%;"><b>tmpdir:</b></p>

<p style="margin-left:32%;">Temporary directory where trace
files are created [default: &rsquo;/tmp&rsquo;]</p>

<p style="margin-left:22%;"><b>tbsize:</b></p>

<p style="margin-left:32%;">Capture buffer size in kB
[default: 50000]</p>


<p style="margin-left:11%; margin-top: 1em"><b>create_host(self,
host, **kwargs)</b> <br>
Create client host object and set defaults.</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_exchange_id(self,
**kwargs)</b> <br>
Find the call and its corresponding reply for the NFSv4
EXCHANGE_ID <br>
going to the server specified by the ipaddr and port.</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address
[default: self.server]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="57%">


<p>Destination port [default: self.port]</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Store the
callback IP/TCP expression in object attribute cb_dst</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply).</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_getdeviceinfo(self,
deviceid=None)</b> <br>
Find the call and its corresponding reply for the NFSv4
GETDEVICEINFO <br>
going to the server specified by the ipaddr for self.server
and port <br>
given by self.port.</p>

<p style="margin-left:22%;"><b>deviceid:</b></p>

<p style="margin-left:32%;">Look for an specific deviceid
[default: any deviceid]</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply, dslist).</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_layoutget(self,
filehandle)</b> <br>
Find the call and its corresponding reply for the NFSv4
LAYOUTGET <br>
of the given file handle going to the server specified by
the <br>
ipaddr for self.server and port given by self.port.</p>

<p style="margin-left:11%; margin-top: 1em">Return a tuple:
(layoutget, layoutget_res, loc_body).</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_layoutrecall(self,
status=0)</b> <br>
Find NFSv4 CB_LAYOUTRECALL call and return its reply. <br>
The reply must also match the given status.</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_nfs_op(self,
op, ipaddr, port=None, match=&rsquo;&rsquo;, status=0,
src_ipaddr=None, maxindex=None, call_only=False)</b> <br>
Find the call and its corresponding reply for the specified
NFSv4 <br>
operation going to the server specified by the ipaddr and
port. <br>
The reply must also match the given status.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p><b>op:</b></p></td>
<td width="6%"></td>
<td width="33%">


<p>NFS operation to find</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>port:</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Destination port [default: any destination port]</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>match:</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Match string to include [default: &rsquo;&rsquo;]</p></td></tr>
</table>

<p style="margin-left:22%;"><b>status:</b></p>

<p style="margin-left:32%;">Match the status of the
operation [default: 0]</p>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address [default: any
IP address]</p>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>call_only:</b></p>

<p style="margin-left:32%;">Find the call only [default:
False]</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(pktcall, pktreply).</p>


<p style="margin-left:11%; margin-top: 1em"><b>find_open(self,
**kwargs)</b> <br>
Find the call and its corresponding reply for the NFSv4 OPEN
of the <br>
given file going to the server specified by the ipaddr and
port.</p>

<p style="margin-left:22%;"><b>filename:</b></p>

<p style="margin-left:32%;">Find open call and reply for
this file [default: None]</p>

<p style="margin-left:22%;"><b>claimfh:</b></p>

<p style="margin-left:32%;">Find open call and reply for
this file handle using CLAIM_FH <br>
[default: None]</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address
[default: self.server]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="57%">


<p>Destination port [default: self.port]</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>deleg_type:</b></p>

<p style="margin-left:32%;">Expected delegation type on
reply [default: None]</p>

<p style="margin-left:22%;"><b>deleg_stateid:</b></p>

<p style="margin-left:32%;">Delegation stateid expected on
call in delegate_cur_info [default: None]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p><b>fh:</b></p></td>
<td width="6%"></td>
<td width="68%">


<p>Find open call and reply for this file handle when
using</p> </td></tr>
</table>

<p style="margin-left:32%;">deleg_stateid [default:
None]</p>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address [default: any
IP address]</p>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>anyclaim:</b></p>

<p style="margin-left:32%;">Find open for either regular
open or using delegate_cur_info [default: False]</p>

<p style="margin-left:22%; margin-top: 1em">Must specify
either filename, claimfh or both. <br>
Return a tuple: (filehandle, open_stateid,
deleg_stateid).</p>


<p style="margin-left:11%; margin-top: 1em"><b>get_abs_offset(self,
offset, ds_index=None)</b> <br>
Get real file offset given by the (read/write) offset on the
given <br>
data server index, taking into account the type of layout
<br>
(dense/sparse), the stripe_size, first stripe index and the
number <br>
of filehandles. The layout information is taken from object
<br>
attribute layout.</p>


<p style="margin-left:11%; margin-top: 1em"><b>get_filehandle(self,
ds_index)</b> <br>
Return filehandle from the layout list of filehandles.</p>


<p style="margin-left:11%; margin-top: 1em"><b>get_freebytes(self,
dir=None)</b> <br>
Get the number of bytes available in the given directory.
<br>
It takes into account the effective user running the test.
<br>
The root user is allowed to use all the available disk space
<br>
on the device, on the other hand a regular user is allowed a
<br>
little bit less.</p>


<p style="margin-left:11%; margin-top: 1em"><b>get_stateid(self,
filename)</b> <br>
Search the packet trace for the file name given to get the
OPEN <br>
so all related state ids can be searched. A couple of object
<br>
attributes are defined, one is the correct state id that
should <br>
be used by I/O operations. The second is a dictionary table
<br>
which maps the state id to a string identifying if the state
<br>
id is an open, lock or delegation state id.</p>


<p style="margin-left:11%; margin-top: 1em"><b>nfs_debug_enable(self,
**kwargs)</b> <br>
Enable NFS debug messages.</p>

<p style="margin-left:22%;"><b>rpcdebug:</b></p>

<p style="margin-left:32%;">Set RPC kernel debug flags and
save log messages [default: self.rpcdebug]</p>

<p style="margin-left:22%;"><b>nfsdebug:</b></p>

<p style="margin-left:32%;">Set NFS kernel debug flags and
save log messages [default: self.nfsdebug]</p>

<p style="margin-left:22%;"><b>dbgfile:</b></p>

<p style="margin-left:32%;">Name of log messages file to
create, default is a unique name <br>
created in the temporary directory using self.dbgname as the
<br>
base name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>nfs_debug_reset(self)</b>
<br>
Reset NFS debug messages.</p>


<p style="margin-left:11%; margin-top: 1em"><b>stid_str(self,
stateid)</b> <br>
Display the state id in CRC16 format</p>


<p style="margin-left:11%; margin-top: 1em"><b>trace_open(self,
tracefile=None, **kwargs)</b> <br>
Open the trace file given or the trace file started by
trace_start().</p>

<p style="margin-left:11%; margin-top: 1em">All extra
options are passed directly to the packet trace object.</p>

<p style="margin-left:11%; margin-top: 1em">Return the
packet trace object created, the packet trace object <br>
is also stored in the object attribute pktt.</p>


<p style="margin-left:11%; margin-top: 1em"><b>trace_start(self,
tracefile=None, interface=None, capsize=None,
clients=None)</b> <br>
Start trace on interface given</p>

<p style="margin-left:22%;"><b>tracefile:</b></p>

<p style="margin-left:32%;">Name of trace file to create,
default is a unique name <br>
created in the temporary directory using self.tracename as
the <br>
base name.</p>

<p style="margin-left:22%;"><b>capsize:</b></p>

<p style="margin-left:32%;">Use the -C option of tcpdump to
split the trace files every <br>
1000000*capsize bytes. See documentation for tcpdump for
more <br>
information</p>

<p style="margin-left:22%;"><b>clients:</b></p>

<p style="margin-left:32%;">List of Host() objects to
monitor</p>

<p style="margin-left:22%; margin-top: 1em">Return the name
of the trace file created.</p>


<p style="margin-left:11%; margin-top: 1em"><b>trace_stop(self)</b>
<br>
Stop the trace started by trace_start().</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_commit(self,
ipaddr, port, filehandle, init=False)</b> <br>
Verify commits are properly sent to the server specified by
the <br>
given ipaddr and port.</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="56%">


<p>Destination port number of MDS or DS</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find commits for this file
handle</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>init:</b></p></td>
<td width="3%"></td>
<td width="66%">


<p>Initialized test variables [default: False]</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Return the
number of commits sent to the server.</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_create_session(self,
ipaddr, port, ds=False, nocreate=False, ds_index=None,
exchid_status=0, cs_status=0)</b> <br>
Verify initial connection to the metadata server(MDS)/data
server(DS). <br>
Verify if EXCHANGE_ID, CREATE_SESSION, RECLAIM_COMPLETE,
<br>
GETATTR asking for FATTR4_LEASE_TIME, and GETATTR asking for
<br>
FATTR4_FS_LAYOUT_TYPES are all sent or not to the
server.</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Destination port number of MDS or DS</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>ds:</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>True if ipaddr/port defines a DS, otherwise MDS
[default: False]</p></td></tr>
</table>

<p style="margin-left:22%;"><b>nocreate:</b></p>

<p style="margin-left:32%;">True if expecting the client
NOT to send EXCHANGE_ID, <br>
CREATE_SESSION, and RECLAIM_COMPLETE. Otherwise, verify all
<br>
these operations are sent by the client [default: False]</p>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">DS index used for displaying
purposes only [default: None]</p>

<p style="margin-left:22%;"><b>exchid_status:</b></p>

<p style="margin-left:32%;">Expected status for EXCHANGE_ID
[default: 0]</p>

<p style="margin-left:22%;"><b>cs_status:</b></p>

<p style="margin-left:32%;">Expected status for
CREATE_SESSION [default: 0]</p>

<p style="margin-left:22%; margin-top: 1em">Return the
sessionid and it is also stored in the object <br>
attribute sessionid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_io(self,
iomode, stateid, ipaddr=None, port=None, src_ipaddr=None,
filehandle=None, ds_index=None, init=False, maxindex=None,
pattern=None)</b> <br>
Verify I/O is sent to the server specified by the ipaddr and
port.</p>

<p style="margin-left:22%;"><b>iomode:</b></p>

<p style="margin-left:32%;">Verify reads (iomode == 1) or
writes (iomode == 2)</p>

<p style="margin-left:22%;"><b>stateid:</b></p>

<p style="margin-left:32%;">Expected stateid to use in all
I/O requests</p>

<p style="margin-left:22%;"><b>ipaddr:</b></p>

<p style="margin-left:32%;">Destination IP address of MDS
or DS <br>
[default: do not match destination]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>port:</b></p></td>
<td width="3%"></td>
<td width="56%">


<p>Destination port number of MDS or DS</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:32%;">[default: do not match
destination port]</p>

<p style="margin-left:22%;"><b>src_ipaddr:</b></p>

<p style="margin-left:32%;">Source IP address of request
<br>
[default: do not match source]</p>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find I/O for this file handle.
This option is used when <br>
verifying I/O sent to the MDS <br>
[default: use filehandle given by ds_index]</p>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">Data server index. This option
is used when verifying I/O sent <br>
to the DS -- filehandle is taken from x.layout for this
index <br>
[default: None]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>init:</b></p></td>
<td width="3%"></td>
<td width="66%">


<p>Initialized test variables [default: False]</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>maxindex:</b></p>

<p style="margin-left:32%;">The match fails if packet index
hits this limit [default: no limit]</p>

<p style="margin-left:22%;"><b>pattern:</b></p>

<p style="margin-left:32%;">Data pattern to compare
[default: default data pattern]</p>

<p style="margin-left:22%; margin-top: 1em">Return the
number of I/O operations sent to the server.</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_layoutcommit(self,
filehandle, filesize)</b> <br>
Verify layoutcommit is properly sent to the server specified
by <br>
the ipaddr for self.server and port given by self.port. <br>
Verify a GETATTR asking for file size is sent within the
same <br>
compound as the LAYOUTCOMMIT. <br>
Verify GETATTR returns correct size for the file.</p>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find layoutcommit for this file
handle</p>

<p style="margin-left:22%;"><b>filesize:</b></p>

<p style="margin-left:32%;">Expected size of file</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_layoutget(self,
filehandle, iomode, riomode=None, status=0, offset=None,
length=None)</b> <br>
Verify the client sends a LAYOUTGET for the given file
handle.</p>

<p style="margin-left:22%;"><b>filehandle:</b></p>

<p style="margin-left:32%;">Find LAYOUTGET for this file
handle</p>

<p style="margin-left:22%;"><b>iomode:</b></p>

<p style="margin-left:32%;">Expected I/O mode for LAYOUTGET
call</p>

<p style="margin-left:22%;"><b>riomode:</b></p>

<p style="margin-left:32%;">Expected I/O mode for LAYOUTGET
reply if specified, else verify <br>
reply I/O mode is equal to call I/O mode if iomode == 2.
<br>
If iomode == 1, the reply I/O mode could be equal to 1 or
2</p>

<p style="margin-left:22%;"><b>status:</b></p>

<p style="margin-left:32%;">Expected status for LAYOUTGET
reply [default: 0]</p>

<p style="margin-left:22%;"><b>offset:</b></p>

<p style="margin-left:32%;">Expected layout range for
LAYOUTGET reply [default: None]</p>

<p style="margin-left:22%;"><b>length:</b></p>

<p style="margin-left:32%;">Expected layout range for
LAYOUTGET reply [default: None]</p>

<p style="margin-left:22%; margin-top: 1em">If both offset
and length are not given, verify LAYOUTGET reply <br>
should be a full layout [0, NFS4_UINT64_MAX]. If only one is
<br>
provided the following defaults are used: offset = 0, <br>
length = NFS4_UINT64_MAX.</p>

<p style="margin-left:22%; margin-top: 1em">Layout
information is stored in the object attribute layout.</p>

<p style="margin-left:22%; margin-top: 1em">Return a tuple:
(layoutget, layoutget_res, loc_body).</p>


<p style="margin-left:11%; margin-top: 1em"><b>verify_stripe(self,
offset, size, ds_index)</b> <br>
Verify if read/write is sent to the correct data server
according <br>
to stripe size, first stripe index and the number of
filehandles. <br>
The layout information is taken from object attribute
layout.</p>

<p style="margin-left:22%;"><b>offset:</b></p>

<p style="margin-left:32%;">Real file offset</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>size:</b></p></td>
<td width="3%"></td>
<td width="13%">


<p>I/O size</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>ds_index:</b></p>

<p style="margin-left:32%;">Data server index</p>

<p style="margin-left:22%; margin-top: 1em">Return True if
stripe is correctly verified, False otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
methods defined here:</b> <br>
----------------------------</p>


<p style="margin-left:11%; margin-top: 1em"><b>bitmap_str(bitmap,
count, bmap, blist)</b> <br>
Return the string representation of bitmap.</p>

<p style="margin-left:22%;"><b>bitmap:</b></p>

<p style="margin-left:32%;">Bitmap to convert</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>count:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>Number of occurrences of bitmap</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>bmap:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>Dictionary mapping the bits to strings</p></td>
<td width="9%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>blist:</b></p></td>
<td width="1%"></td>
<td width="59%">


<p>List of all possible bit combinations</p></td>
<td width="9%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>iomode_str(iomode)</b>
<br>
Return a string representation of iomode. <br>
This could be run as an instance or class method.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>baseobj(3),
nfstest.host(3), packet.nfs.nfs4_const(3),
packet.pktt(3)</b></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No known
bugs.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jorge Mora
(mora@netapp.com)</p>
<hr>
</body>
</html>
