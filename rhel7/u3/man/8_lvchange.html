<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:54:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LVCHANGE</title>

</head>
<body>

<h1 align="center">LVCHANGE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#Examples">Examples</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvchange
&mdash; change attributes of a logical volume</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>lvchange</b>
[<b>&minus;a</b>|<b>&minus;&minus;activate</b>
[<b>a</b>][<b>e</b>|<b>s</b>|<b>l</b>]{<b>y</b>|<b>n</b>}]
[<b>&minus;&minus;activationmode</b>
{<b>complete</b>|<b>degraded</b>|<b>partial</b>}]
[<b>&minus;&minus;addtag</b> <i>Tag</i>]
[<b>&minus;K</b>|<b>&minus;&minus;ignoreactivationskip</b>]
[<b>&minus;k</b>|<b>&minus;&minus;setactivationskip</b>
{<b>y</b>|<b>n</b>}] [<b>&minus;&minus;alloc</b>
<i>AllocationPolicy</i>]
[<b>&minus;A</b>|<b>&minus;&minus;autobackup</b>
{<b>y</b>|<b>n</b>}] [<b>&minus;&minus;rebuild</b>
<i>PhysicalVolume</i>] [<b>&minus;&minus;cachemode</b>
{<b>passthrough</b>|<b>writeback</b>|<b>writethrough</b>}]
[<b>&minus;&minus;cachepolicy</b> <i>Policy</i>]
[<b>&minus;&minus;cachesettings</b>
<i>Key</i><b>=</b><i>Value</i>]
[<b>&minus;&minus;commandprofile</b> <i>ProfileName</i>]
[<b>&minus;C</b>|<b>&minus;&minus;contiguous</b>
{<b>y</b>|<b>n</b>}]
[<b>&minus;d</b>|<b>&minus;&minus;debug</b>]
[<b>&minus;&minus;deltag</b> <i>Tag</i>]
[<b>&minus;&minus;detachprofile</b>]
[<b>&minus;&minus;discards</b>
{<b>ignore</b>|<b>nopassdown</b>|<b>passdown</b>}]
[<b>&minus;&minus;errorwhenfull</b> {<b>y</b>|<b>n</b>}]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;&minus;ignorelockingfailure</b>]
[<b>&minus;&minus;ignoremonitoring</b>]
[<b>&minus;&minus;ignoreskippedcluster</b>]
[<b>&minus;&minus;metadataprofile</b> <i>ProfileName</i>]
[<b>&minus;&minus;monitor</b> {<b>y</b>|<b>n</b>}]
[<b>&minus;&minus;noudevsync</b>]
[<b>&minus;P</b>|<b>&minus;&minus;partial</b>]
[<b>&minus;p</b>|<b>&minus;&minus;permission</b>
{<b>r</b>|<b>rw</b>}]
[<b>&minus;M</b>|<b>&minus;&minus;persistent</b>
{<b>y</b>|<b>n</b>} [<b>&minus;&minus;major</b>
<i>Major</i>] [<b>&minus;&minus;minor</b> <i>Minor</i>]]
[<b>&minus;&minus;poll</b> {<b>y</b>|<b>n</b>}]
[<b>&minus;&minus;</b>[<b>raid</b>]<b>maxrecoveryrate</b>
<i>Rate</i>]
[<b>&minus;&minus;</b>[<b>raid</b>]<b>minrecoveryrate</b>
<i>Rate</i>]
[<b>&minus;&minus;</b>[<b>raid</b>]<b>syncaction</b>
{<b>check</b>|<b>repair</b>}]
[<b>&minus;&minus;</b>[<b>raid</b>]<b>writebehind</b>
<i>IOCount</i>]
[<b>&minus;&minus;</b>[<b>raid</b>]<b>writemostly</b>
<i>PhysicalVolume</i>[<b>:</b>{<b>y</b>|<b>n</b>|<b>t</b>}]]
[<b>&minus;r</b>|<b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<b>auto</b>|<b>none</b>}]
[<b>&minus;&minus;refresh</b>]
[<b>&minus;&minus;reportformat</b>
{<b>basic</b>|<b>json</b>}] [<b>&minus;&minus;resync</b>]
[<b>&minus;S</b>|<b>&minus;&minus;select</b>
<i>Selection</i>] [<b>&minus;&minus;sysinit</b>]
[<b>&minus;t</b>|<b>&minus;&minus;test</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;Z</b>|<b>&minus;&minus;zero</b>
{<b>y</b>|<b>n</b>}] [<i>LogicalVolumePath</i>...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvchange allows
you to change the attributes of a logical volume including
making them known to the kernel ready for use.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>lvm</b>(8) for common options.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="44%">



<p style="margin-top: 1em"><b>&minus;a</b>|<b>&minus;&minus;activate</b>
[<b>a</b>][<b>e</b>|<b>s</b>|<b>l</b>]{<b>y</b>|<b>n</b>}</p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:22%;">Controls the availability of
the logical volumes for use. Communicates with the kernel
device-mapper driver via libdevmapper to activate
(<b>&minus;ay</b>) or deactivate (<b>&minus;an</b>) the
logical volumes. <br>
Activation of a logical volume creates a symbolic link
<i>/dev/VolumeGroupName/LogicalVolumeName</i> pointing to
the device node. This link is removed on deactivation. All
software and scripts should access the device through this
symbolic link and present this as the name of the device.
The location and name of the underlying device node may
depend on the distribution and configuration (e.g. udev) and
might change from release to release. <br>
If autoactivation option is used (<b>&minus;aay</b>), the
logical volume is activated only if it matches an item in
the <b>activation/auto_activation_volume_list</b> set in
<b>lvm.conf</b>(5). If this list is not set, then all
volumes are considered for activation. The <b>&minus;aay</b>
option should be also used during system boot so it&rsquo;s
possible to select which volumes to activate using the
<b>activation/auto_activation_volume_list</b> setting. <br>
In a clustered VG, clvmd is used for activation, and the
following options are possible:</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;aey</b>, clvmd activates the LV in exclusive mode
(with an exclusive lock), allowing a single node to activate
the LV.</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;asy</b>, clvmd activates the LV in shared mode
(with a shared lock), allowing multiple nodes to activate
the LV concurrently. If the LV type prohibits shared access,
such as an LV with a snapshot, the &rsquo;<b>s</b>&rsquo;
option is ignored and an exclusive lock is used.</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;ay</b> (no mode specified), clvmd activates the LV
in shared mode if the LV type allows concurrent access, such
as a linear LV. Otherwise, clvmd activates the LV in
exclusive mode.</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;aey</b>, <b>&minus;asy</b>, and <b>&minus;ay</b>,
clvmd attempts to activate the LV on all nodes. If exclusive
mode is used, then only one of the nodes will be
successful.</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;an</b>, clvmd attempts to deactivate the LV on all
nodes.</p>

<p style="margin-left:22%; margin-top: 1em">With
<b>&minus;aly</b>, clvmd activates the LV only on the local
node, and <b>&minus;aln</b> deactivates only on the local
node. If the LV type allows concurrent access, then shared
mode is used, otherwise exclusive.</p>

<p style="margin-left:22%; margin-top: 1em">LVs with
snapshots are always activated exclusively because they can
only be used on one node at once.</p>

<p style="margin-left:22%; margin-top: 1em">For local VGs
<b>&minus;ay</b>, <b>&minus;aey</b>, and <b>&minus;asy</b>
are all equivalent.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="67%">



<p style="margin-top: 1em"><b>&minus;&minus;activationmode</b>
{<b>complete</b>|<b>degraded</b>|<b>partial</b>}</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:22%;">The activation mode determines
whether logical volumes are allowed to activate when there
are physical volumes missing (e.g. due to a device failure).
<b>complete</b> is the most restrictive; allowing only those
logical volumes to be activated that are not affected by the
missing PVs. <b>degraded</b> allows RAID logical volumes to
be activated even if they have PVs missing. (Note that the
&quot;<i>mirror</i>&quot; segment type is not considered a
RAID logical volume. The &quot;<i>raid1</i>&quot; segment
type should be used instead.) Finally, <b>partial</b> allows
any logical volume to be activated even if portions are
missing due to a missing or failed PV. This last option
should only be used when performing recovery or repair
operations. <b>degraded</b> is the default mode. To change
it, modify <b>activation_mode</b> in <b>lvm.conf</b>(5).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">



<p style="margin-top: 1em"><b>&minus;K</b>|<b>&minus;&minus;ignoreactivationskip</b></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:22%;">Ignore the flag to skip Logical
Volumes during activation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="43%">



<p style="margin-top: 1em"><b>&minus;k</b>|<b>&minus;&minus;setactivationskip</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:22%;">Controls whether Logical
Volumes are persistently flagged to be skipped during
activation. By default, thin snapshot volumes are flagged
for activation skip. To activate such volumes, an extra
<b>&minus;&minus;ignoreactivationskip</b> option must be
used. The flag is not applied during deactivation. To see
whether the flag is attached, use <b>lvs</b>(8) command
where the state of the flag is reported within
<b>lv_attr</b> bits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="74%">


<p style="margin-top: 1em"><b>&minus;&minus;cachemode</b>
{<b>passthrough</b>|<b>writeback</b>|<b>writethrough</b>}</p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifying a cache mode
determines when the writes to a cache LV are considered
complete. When <b>writeback</b> is specified, a write is
considered complete as soon as it is stored in the cache
pool LV. If <b>writethough</b> is specified, a write is
considered complete only when it has been stored in the
cache pool LV and on the origin LV. While
<b>writethrough</b> may be slower for writes, it is more
resilient if something should happen to a device associated
with the cache pool LV. With <b>passthrough</b> mode, all
reads are served from origin LV (all reads miss the cache)
and all writes are forwarded to the origin LV; additionally,
write hits cause cache block invalidates. See
<b>lvmcache(7)</b> for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="72%">



<p style="margin-top: 1em"><b>&minus;&minus;cachepolicy</b>
<i>Policy</i>, <b>&minus;&minus;cachesettings</b>
<i>Key</i><b>=</b><i>Value</i></p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:22%;">Only applicable to cached LVs;
see also <b>lvmcache(7)</b>. Sets the cache policy and its
associated tunable settings. In most use-cases, default
values should be adequate.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">



<p style="margin-top: 1em"><b>&minus;C</b>|<b>&minus;&minus;contiguous</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:22%;">Tries to set or reset the
contiguous allocation policy for logical volumes. It&rsquo;s
only possible to change a non-contiguous logical
volume&rsquo;s allocation policy to contiguous, if all of
the allocated physical extents are already contiguous.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">



<p style="margin-top: 1em"><b>&minus;&minus;detachprofile</b></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:22%;">Detach any metadata
configuration profiles attached to given Logical Volumes.
See <b>lvm.conf</b>(5) for more information about metadata
profiles.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em"><b>&minus;&minus;discards</b>
{<b>ignore</b>|<b>nopassdown</b>|<b>passdown</b>}</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:22%;">Set this to <b>ignore</b> to
ignore any discards received by a thin pool Logical Volume.
Set to <b>nopassdown</b> to process such discards within the
thin pool itself and allow the no-longer-needed extents to
be overwritten by new data. Set to <b>passdown</b> (the
default) to process them both within the thin pool itself
and to pass them down the underlying device.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">



<p style="margin-top: 1em"><b>&minus;&minus;errorwhenfull</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets thin pool behavior when
data space is exhaused. See <b>lvcreate</b>(8) for
information.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="27%">



<p style="margin-top: 1em"><b>&minus;&minus;ignoremonitoring</b></p> </td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:22%;">Make no attempt to interact
with dmeventd unless <b>&minus;&minus;monitor</b> is
specified. Do not use this if dmeventd is already monitoring
a device.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>&minus;&minus;major</b>
<i>Major</i></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the major number. This
option is supported only on older systems (kernel version
2.4) and is ignored on modern Linux systems where major
numbers are dynamically assigned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>&minus;&minus;minor</b>
<i>Minor</i></p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:22%;">Set the minor number.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="44%">



<p style="margin-top: 1em"><b>&minus;&minus;metadataprofile</b>
<i>ProfileName</i></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:22%;">Uses and attaches
<i>ProfileName</i> configuration profile to the logical
volume metadata. Whenever the logical volume is processed
next time, the profile is automatically applied. If the
volume group has another profile attached, the logical
volume profile is preferred. See <b>lvm.conf</b>(5) for more
information about metadata profiles.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">


<p style="margin-top: 1em"><b>&minus;&minus;monitor</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:22%;">Start or stop monitoring a
mirrored or snapshot logical volume with dmeventd, if it is
installed. If a device used by a monitored mirror reports an
I/O error, the failure is handled according to
<b>mirror_image_fault_policy</b> and
<b>mirror_log_fault_policy</b> set in
<b>lvm.conf</b>(5).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">



<p style="margin-top: 1em"><b>&minus;&minus;noudevsync</b></p> </td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:22%;">Disable udev synchronisation.
The process will not wait for notification from udev. It
will continue irrespective of any possible udev processing
in the background. You should only use this if udev is not
running or has rules that ignore the devices LVM2
creates.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">



<p style="margin-top: 1em"><b>&minus;p</b>|<b>&minus;&minus;permission</b>
{<b>r</b>|<b>rw</b>}</p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:22%;">Change access permission to
read-only or read/write.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">



<p style="margin-top: 1em"><b>&minus;M</b>|<b>&minus;&minus;persistent</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:22%;">Set to <b>y</b> to make the
minor number specified persistent. Change of persistent
numbers is not supported for pool volumes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em"><b>&minus;&minus;poll</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:22%;">Without polling a logical
volume&rsquo;s backgrounded transformation process will
never complete. If there is an incomplete pvmove or
lvconvert (for example, on rebooting after a crash), use
<b>&minus;&minus;poll y</b> to restart the process from its
last checkpoint. However, it may not be appropriate to
immediately poll a logical volume when it is activated, use
<b>&minus;&minus;poll n</b> to defer and then
<b>&minus;&minus;poll y</b> to restart the process.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>rebuild</b>
<i>PhysicalVolume</i></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:22%;">Option can be repeated multiple
times. Selects PhysicalVolume(s) to be rebuild in a RaidLV.
Use this option instead of <b>&minus;&minus;resync</b> or
<b>&minus;&minus;</b>[<b>raid</b>]<b>syncaction repair</b>
in case the PVs with corrupted data are known and their data
should be reconstructed rather than reconstructing default
(rotating) data. <br>
E.g. in a raid1 mirror, the master leg on /dev/sda may hold
corrupt data due to a known transient disk error, thus
<b><br>
lvchange --rebuild /dev/sda LV</b> <br>
will request the master leg to be rebuild rather than
rebuilding all other legs from the master. On a raid5 with
rotating data and parity <b><br>
lvchange --rebuild /dev/sda LV</b> <br>
will rebuild all data and parity blocks in the stripe on
/dev/sda.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="75%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>maxrecoveryrate</b>
<i>Rate</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]</p> </td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the maximum recovery rate
for a RAID logical volume. <i>Rate</i> is specified as an
amount per second for each device in the array. If no suffix
is given, then KiB/sec/device is assumed. Setting the
recovery rate to <b>0</b> means it will be unbounded.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="75%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>minrecoveryrate</b>
<i>Rate</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]</p> </td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the minimum recovery rate
for a RAID logical volume. <i>Rate</i> is specified as an
amount per second for each device in the array. If no suffix
is given, then KiB/sec/device is assumed. Setting the
recovery rate to <b>0</b> means it will be unbounded.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="51%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>syncaction</b>
{<b>check</b>|<b>repair</b>}</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:22%;">This argument is used to
initiate various RAID synchronization operations. The
<b>check</b> and <b>repair</b> options provide a way to
check the integrity of a RAID logical volume (often referred
to as &quot;scrubbing&quot;). These options cause the RAID
logical volume to read all of the data and parity blocks in
the array and check for any discrepancies (e.g. mismatches
between mirrors or incorrect parity values). If <b>check</b>
is used, the discrepancies will be counted but not repaired.
If <b>repair</b> is used, the discrepancies will be
corrected as they are encountered. The <b>lvs</b>(8) command
can be used to show the number of discrepancies found or
repaired.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>writebehind</b>
<i>IOCount</i></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:22%;">Specify the maximum number of
outstanding writes that are allowed to devices in a RAID1
logical volume that are marked as write-mostly. Once this
value is exceeded, writes become synchronous (i.e. all
writes to the constituent devices must complete before the
array signals the write has completed). Setting the value to
zero clears the preference and allows the system to choose
the value arbitrarily.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="67%">



<p style="margin-top: 1em"><b>&minus;&minus;</b>[<b>raid</b>]<b>writemostly</b>
<i>PhysicalVolume</i>[<b>:</b>{<b>y</b>|<b>n</b>|<b>t</b>}]</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:22%;">Mark a device in a RAID1
logical volume as write-mostly. All reads to these drives
will be avoided unless absolutely necessary. This keeps the
number of I/Os to the drive to a minimum. The default
behavior is to set the write-mostly attribute for the
specified physical volume in the logical volume. It is
possible to also remove the write-mostly flag by appending a
&quot;<b>:n</b>&quot; to the physical volume or to toggle
the value by specifying &quot;<b>:t</b>&quot;. The
<b>&minus;&minus;writemostly</b> argument can be specified
more than one time in a single command; making it possible
to toggle the write-mostly attributes for all the physical
volumes in a logical volume at once.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">



<p style="margin-top: 1em"><b>&minus;r</b>|<b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<b>auto</b>|<b>none</b>}</p> </td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:22%;">Set read ahead sector count of
this logical volume. For volume groups with metadata in lvm1
format, this must be a value between 2 and 120 sectors. The
default value is &quot;<b>auto</b>&quot; which allows the
kernel to choose a suitable value automatically.
&quot;<b>none</b>&quot; is equivalent to specifying
zero.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">



<p style="margin-top: 1em"><b>&minus;&minus;refresh</b></p> </td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:22%;">If the logical volume is
active, reload its metadata. This is not necessary in normal
operation, but may be useful if something has gone wrong or
if you&rsquo;re doing clustering manually without a
clustered lock manager.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>&minus;&minus;resync</b></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:22%;">Forces the complete
resynchronization of a mirror. In normal circumstances you
should not need this option because synchronization happens
automatically. Data is read from the primary mirror device
and copied to the others, so this can take a considerable
amount of time - and during this time you are without a
complete redundant copy of your data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">



<p style="margin-top: 1em"><b>&minus;&minus;sysinit</b></p> </td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:22%;">Indicates that
<b>lvchange</b>(8) is being invoked from early system
initialisation scripts (e.g. rc.sysinit or an initrd),
before writeable filesystems are available. As such, some
functionality needs to be disabled and this option acts as a
shortcut which selects an appropriate set of options.
Currently this is equivalent to using
<b>&minus;&minus;ignorelockingfailure</b>,
<b>&minus;&minus;ignoremonitoring</b>, <b>&minus;&minus;poll
n</b> and setting
<b>LVM_SUPPRESS_LOCKING_FAILURE_MESSAGES</b> environment
variable.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>&minus;&minus;sysinit</b> is used in conjunction with
<b>lvmetad</b>(8) enabled and running, autoactivation is
preferred over manual activation via direct lvchange call.
Logical volumes are autoactivated according to
<b>auto_activation_volume_list</b> set in
<b>lvm.conf</b>(5).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">



<p style="margin-top: 1em"><b>&minus;Z</b>|<b>&minus;&minus;zero</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:22%;">Set zeroing mode for thin pool.
Note: already provisioned blocks from pool in non-zero mode
are not cleared in unwritten parts when setting zero to
<b>y</b>.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>LVM_SUPPRESS_LOCKING_FAILURE_MESSAGES</b></p>

<p style="margin-left:22%;">Suppress locking failure
messages.</p>

<h2>Examples
<a name="Examples"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Changes the
permission on volume lvol1 in volume group vg00 to be
read-only:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvchange
&minus;pr vg00/lvol1</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>lvm</b>(8),
<b>lvmetad</b>(8), <b>lvs</b>(8), <b>lvcreate</b>(8),
<b>vgchange</b>(8), <b>lvmcache</b>(7), <b>lvmthin</b>(7),
<b>lvm.conf</b>(5)</p>
<hr>
</body>
</html>
