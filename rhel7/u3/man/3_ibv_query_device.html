<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:42:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IBV_QUERY_DEVICE</title>

</head>
<body>

<h1 align="center">IBV_QUERY_DEVICE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">ibv_query_device
&minus; query an RDMA device&rsquo;s attributes</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;infiniband/verbs.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ibv_query_device(struct ibv_context</b> <i>*context</i><b>,
<br>
struct ibv_device_attr</b> <i>*device_attr</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ibv_query_device()</b>
returns the attributes of the device with context
<i>context</i>. The argument <i>device_attr</i> is a pointer
to an ibv_device_attr struct, as defined in
&lt;infiniband/verbs.h&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">struct
ibv_device_attr {</p>

<p style="margin-left:23%;">char fw_ver[64]; /* FW version
*/ <br>
uint64_t node_guid; /* Node GUID (in network byte order) */
<br>
uint64_t sys_image_guid; /* System image GUID (in network
byte order) */ <br>
uint64_t max_mr_size; /* Largest contiguous block that can
be registered */ <br>
uint64_t page_size_cap; /* Supported memory shift sizes */
<br>
uint32_t vendor_id; /* Vendor ID, per IEEE */ <br>
uint32_t vendor_part_id; /* Vendor supplied part ID */ <br>
uint32_t hw_ver; /* Hardware version */ <br>
int max_qp; /* Maximum number of supported QPs */ <br>
int max_qp_wr; /* Maximum number of outstanding WR on any
work queue */ <br>
int device_cap_flags; /* HCA capabilities mask */ <br>
int max_sge; /* Maximum number of s/g per WR for non-RD QPs
*/ <br>
int max_sge_rd; /* Maximum number of s/g per WR for RD QPs
*/ <br>
int max_cq; /* Maximum number of supported CQs */ <br>
int max_cqe; /* Maximum number of CQE capacity per CQ */
<br>
int max_mr; /* Maximum number of supported MRs */ <br>
int max_pd; /* Maximum number of supported PDs */ <br>
int max_qp_rd_atom; /* Maximum number of RDMA Read &amp;
Atomic operations that can be outstanding per QP */ <br>
int max_ee_rd_atom; /* Maximum number of RDMA Read &amp;
Atomic operations that can be outstanding per EEC */ <br>
int max_res_rd_atom; /* Maximum number of resources used for
RDMA Read &amp; Atomic operations by this HCA as the Target
*/ <br>
int max_qp_init_rd_atom; /* Maximum depth per QP for
initiation of RDMA Read &amp; Atomic operations */ <br>
int max_ee_init_rd_atom; /* Maximum depth per EEC for
initiation of RDMA Read &amp; Atomic operations */ <br>
enum ibv_atomic_cap atomic_cap; /* Atomic operations support
level */ <br>
int max_ee; /* Maximum number of supported EE contexts */
<br>
int max_rdd; /* Maximum number of supported RD domains */
<br>
int max_mw; /* Maximum number of supported MWs */ <br>
int max_raw_ipv6_qp; /* Maximum number of supported raw IPv6
datagram QPs */ <br>
int max_raw_ethy_qp; /* Maximum number of supported
Ethertype datagram QPs */ <br>
int max_mcast_grp; /* Maximum number of supported multicast
groups */ <br>
int max_mcast_qp_attach; /* Maximum number of QPs per
multicast group which can be attached */ <br>
int max_total_mcast_qp_attach;/* Maximum number of QPs which
can be attached to multicast groups */ <br>
int max_ah; /* Maximum number of supported address handles
*/ <br>
int max_fmr; /* Maximum number of supported FMRs */ <br>
int max_map_per_fmr; /* Maximum number of (re)maps per FMR
before an unmap operation in required */ <br>
int max_srq; /* Maximum number of supported SRQs */ <br>
int max_srq_wr; /* Maximum number of WRs per SRQ */ <br>
int max_srq_sge; /* Maximum number of s/g per SRQ */ <br>
uint16_t max_pkeys; /* Maximum number of partitions */ <br>
uint8_t local_ca_ack_delay; /* Local CA ack delay */ <br>
uint8_t phys_port_cnt; /* Number of physical ports */</p>

<p style="margin-left:11%;">};</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ibv_query_device()</b>
returns 0 on success, or the value of errno on failure
(which indicates the failure reason).</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The maximum
values returned by this function are the upper limits of
supported resources by the device. However, it may not be
possible to use these maximum values, since the actual
number of any resource that can be created may be limited by
the machine configuration, the amount of host memory, user
permissions, and the amount of resources already in use by
other users/processes.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ibv_open_device</b>(3),
<b>ibv_query_port</b>(3), <b>ibv_query_pkey</b>(3),
<b>ibv_query_gid</b>(3)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Dotan Barak
&lt;dotanba@gmail.com&gt;</p>
<hr>
</body>
</html>
