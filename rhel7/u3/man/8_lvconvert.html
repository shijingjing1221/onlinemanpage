<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:54:00 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LVCONVERT</title>

</head>
<body>

<h1 align="center">LVCONVERT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#COMMANDS">COMMANDS</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#Examples">Examples</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvconvert
&mdash; change LV type and other utilities</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>lvconvert</b>
[<i>OPTION</i>]...
<i>VolumeGroup</i>/<i>LogicalVolume</i></p>

<p style="margin-left:11%; margin-top: 1em">OPTIONS:
<b><br>
&minus;b</b>, <b>&minus;&minus;background <br>
&minus;&minus;cachepolicy</b> <i>Policy</i> <b><br>
&minus;&minus;cachepool</b>
<i>CachePoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
<b><br>
&minus;&minus;cachesettings</b>
<i>Key</i><b>=</b><i>Value</i> <b><br>
&minus;c</b>, <b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]
<b><br>
&minus;&minus;corelog <br>
&minus;&minus;discards</b>
{<b>ignore</b>|<b>nopassdown</b>|<b>passdown</b>} <b><br>
&minus;i</b>, <b>&minus;&minus;interval</b> <i>Seconds</i>
<b><br>
&minus;&minus;merge <br>
&minus;&minus;mirrorlog</b>
{<b>disk</b>|<b>core</b>|<b>mirrored</b>} <b><br>
&minus;m</b>, <b>&minus;&minus;mirrors</b> <i>Number</i>
<b><br>
&minus;n</b>, <b>&minus;&minus;name</b> <i>Name</i> <b><br>
&minus;&minus;noudevsync <br>
&minus;&minus;originname</b>
<i>NewExternalOriginVolumeName</i> <b><br>
&minus;&minus;poolmetadata</b>
<i>PoolMetadataLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
<b><br>
&minus;&minus;poolmetadatasize</b>
<i>PoolMetadataSize</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]
<b><br>
&minus;&minus;poolmetadataspare</b> {<b>y</b>|<b>n</b>}
<b><br>
&minus;r</b>, <b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<b>auto</b>|<b>none</b>} <b><br>
&minus;R</b>, <b>&minus;&minus;regionsize</b>
<i>MirrorLogRegionSize</i> <b><br>
&minus;&minus;repair <br>
&minus;&minus;replace</b> <i>PhysicalVolume</i> <b><br>
&minus;&minus;splitcache <br>
&minus;&minus;splitmirrors</b> <i>Number</i> <b><br>
&minus;&minus;splitsnapshot <br>
&minus;&minus;stripes</b> <i>Number</i> <b><br>
&minus;I</b>, <b>&minus;&minus;stripesize</b>
<i>StripeSize</i> <b><br>
&minus;&minus;type striped <br>
&minus;&minus;type snapshot</b> |
<b>&minus;&minus;snapshot</b> | <b>&minus;s <br>
&minus;&minus;type mirror <br>
&minus;&minus;type raid* <br>
&minus;&minus;type thin</b> | <b>&minus;&minus;thin</b> |
<b>&minus;T <br>
&minus;&minus;type cache</b> | <b>&minus;&minus;cache</b> |
<b>&minus;H <br>
&minus;&minus;type thin&minus;pool <br>
&minus;&minus;type cache&minus;pool <br>
&minus;&minus;thinpool</b>
<i>ThinPoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
<b><br>
&minus;&minus;trackchanges <br>
&minus;&minus;uncache <br>
&minus;Z</b>, <b>&minus;&minus;zero</b>
{<b>y</b>|<b>n</b>}</p>

<p style="margin-left:11%; margin-top: 1em">Common options:
<b><br>
&minus;A</b>, <b>&minus;&minus;alloc</b>
<i>AllocationPolicy</i> <b><br>
&minus;f</b>, <b>&minus;&minus;force <br>
&minus;&minus;commandprofile</b> <i>ProfileName</i> <b><br>
&minus;h</b>, <b>&minus;?</b>, <b>&minus;&minus;help <br>
&minus;v</b>, <b>&minus;&minus;verbose <br>
&minus;y</b>, <b>&minus;&minus;yes <br>
&minus;&minus;version</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvconvert
changes the LV type and includes various LV utilities.</p>

<p style="margin-left:11%; margin-top: 1em">To display the
current LV type, run the command:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvs &minus;o
name,segtype</b> <i>VG</i>/<i>LV</i></p>

<p style="margin-left:11%; margin-top: 1em">To change the
LV type, run the command:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type</b> <i>NewType VG</i>/<i>LV</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>LV types</b>
<br>
The LV type is also called the &quot;segment type&quot; or
&quot;segtype&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">LVs with the
following types can be modified by lvconvert: <b>striped,
snapshot, mirror, raid*, thin, cache, thin&minus;pool,
cache&minus;pool.</b></p>

<p style="margin-left:11%; margin-top: 1em">The specific
operations available on each LV type are listed below.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>linear</b> type is equivalent to the <b>striped</b> type
when one stripe exists. In that case, the types can
sometimes be used interchangably.</p>

<p style="margin-left:11%; margin-top: 1em">In most cases,
the <b>mirror</b> type is deprecated and the <b>raid1</b>
type should be used. They are both implementations of
mirroring.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>raid*</b> type refers to one of many raid levels, e.g.
<b>raid1, raid5.</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>LV
layers</b> <br>
In some cases, an LV is a single device mapper (dm) layer
above physical devices. In other cases, hidden LVs (dm
devices) are layered between the visible LV and physical
devices. LVs in the middle layers are sometimes called sub
LVs.</p>

<p style="margin-left:11%; margin-top: 1em">Changing the LV
type will often change the composition of sub LVs.</p>

<p style="margin-left:11%; margin-top: 1em">Sub LVs can be
displayed with the command <b>lvs -a.</b></p>

<p style="margin-left:11%; margin-top: 1em">A command run
on a visible LV sometimes operates on a sub LV rather than
the specified LV. These cases are noted below.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes a sub
LV must be specified directly on the command line, but this
is a non-standard form. These cases may change in the future
to avoid the direct use of hidden LVs.</p>

<h2>COMMANDS
<a name="COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Operations
on a StripedLV with type striped or linear:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge</b> VG/StripedLV <br>
&bull; Merge StripedLV into an LV when it is a previously
split mirror. <br>
&bull; Options &minus;&minus;background,
&minus;&minus;interval. <br>
&bull; See corresponding operation --splitmirrors.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type snapshot</b> VG/StripedLV VG/SnapshotLV
<br>
&bull; Recombine StripedLV with SnapshotLV which was
previously split. <br>
&bull; Options &minus;&minus;chunksize, &minus;&minus;zero.
<br>
&bull; See corresponding operation --splitsnapshot.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type thin</b> VG/StripedLV <br>
&bull; Convert StripedLV to type thin with an external
origin. <br>
&bull; StripedLV becomes a read&minus;only external origin
LV with a new name. <br>
&bull; Requires &minus;&minus;thinpool to specify the thin
pool to use. <br>
&bull; Options &minus;&minus;originname.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache</b> VG/StripedLV <br>
&bull; Convert StripedLV to type cache. <br>
&bull; Requires &minus;&minus;cachepool to specify the cache
pool to use. <br>
&bull; Options &minus;&minus;cachepolicy,
&minus;&minus;cachesettings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type thin&minus;pool</b> VG/StripedLV <br>
&bull; Convert StripedLV to type thin&minus;pool. <br>
&bull; The StripedLV is used for thin pool data. <br>
&bull; Options &minus;&minus;chunksize,
&minus;&minus;discards,
&minus;&minus;poolmetadata{size,spare}, <br>
&minus;&minus;readahead, &minus;&minus;zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache&minus;pool</b> VG/StripedLV <br>
&bull; Convert StripedLV to type cache&minus;pool. <br>
&bull; Options &minus;&minus;chunksize,
&minus;&minus;poolmetadata{size,spare}.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type mirror</b> VG/StripedLV <br>
&bull; Convert StripedLV to type mirror. <br>
&bull; Requires &minus;&minus;mirrors to specify the number
of mirrors to use. <br>
&bull; Options &minus;&minus;mirrorlog,
&minus;&minus;regionsize.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type raid*</b> VG/StripedLV <br>
&bull; Convert StripedLV to type raid*. <br>
&bull; Required options depend on the raid level.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on RaidLV with type raid*:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;mirrors</b> Number VG/RaidLV <br>
&bull; Change the number of images in raid1 RaidLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors</b> Number VG/RaidLV <br>
&bull; Split images from raid1 RaidLV and use them to create
a new LV. <br>
&bull; Requires &minus;&minus;name for the new LV, or the
use of &minus;&minus;trackchanges.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge</b> VG/RaidLV <br>
&bull; Merge RaidLV into an LV when it is a previously split
mirror. <br>
&bull; Options &minus;&minus;background,
&minus;&minus;interval. <br>
&bull; See corresponding operation --splitmirrors.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;repair</b> VG/RaidLV <br>
&bull; Replace failed PVs in RaidLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;replace</b> PV VG/RaidLV <br>
&bull; Replace specific PV(s) in a raid* LV with another PV.
<br>
&bull; The new PV(s) to use can be optionally specified
after the LV. <br>
&bull; Repeat to replace multiple: &minus;&minus;replace PV1
&minus;&minus;replace PV2 ...</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type snapshot</b> VG/RaidLV VG/SnapshotLV <br>
&bull; Combine RaidLV with SnapshotLV that was previously
split. <br>
&bull; Options &minus;&minus;chunksize, &minus;&minus;zero.
<br>
&bull; See corresponding operation
&minus;&minus;splitsnapshot.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type thin</b> VG/RaidLV <br>
&bull; Convert RaidLV to type thin with an external origin.
<br>
&bull; RaidLV becomes a read&minus;only external origin LV
with a new name. <br>
&bull; Requires &minus;&minus;thinpool to specify the thin
pool to use. <br>
&bull; Options &minus;&minus;originname.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache</b> VG/RaidLV <br>
&bull; Convert RaidLV to type cache. <br>
&bull; Requires &minus;&minus;cachepool to specify the cache
pool to use. <br>
&bull; Options &minus;&minus;cachepolicy,
&minus;&minus;cachesettings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type thin&minus;pool</b> VG/RaidLV <br>
&bull; Convert RaidLV to type thin&minus;pool. <br>
&bull; The RaidLV is used for thin pool data. <br>
&bull; Options &minus;&minus;chunksize,
&minus;&minus;discards,
&minus;&minus;poolmetadata{size,spare}, <br>
&minus;&minus;readahead, &minus;&minus;zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache&minus;pool</b> VG/RaidLV <br>
&bull; Convert RaidLV to type cache&minus;pool. <br>
&bull; Options &minus;&minus;chunksize,
&minus;&minus;poolmetadata{size,spare}.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type raid*</b> VG/RaidLV <br>
&bull; Convert RaidLV to use a different raid level. <br>
&bull; Required options depend on the raid level.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type mirror</b> VG/RaidLV <br>
&bull; Convert RaidLV to type mirror.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type striped</b> VG/RaidLV <br>
&bull; Convert RaidLV to type striped.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type linear</b> VG/RaidLV <br>
&bull; Convert RaidLV to type linear.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on MirrorLV with type mirror:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;mirrors</b> Number VG/MirrorLV <br>
&bull; Change the number of images in MirrorLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors</b> Number VG/MirrorLV <br>
&bull; Split images from MirrorLV and use them to create a
new LV. <br>
&bull; Requires &minus;&minus;name for the new LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;mirrorlog</b> LogType VG/MirrorLV <br>
&bull; Change the type of log used by MirrorLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;repair</b> VG/MirrorLV <br>
&bull; Replace failed PVs in MirrorLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type linear</b> VG/MirrorLV <br>
&bull; Convert MirrorLV to type linear.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type raid*</b> VG/MirrorLV <br>
&bull; Convert MirrorLV to type raid*. <br>
&bull; Required options depend on the raid level.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on CachePoolLV with type cache&minus;pool:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitcache</b> VG/CachePoolLV <br>
&bull; Split the cache LV from CachePoolLV. <br>
&bull; Equivalent to --splitcache on CacheLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on CacheLV with type cache:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitcache</b> VG/CacheLV <br>
&bull; Split and keep the cache pool from CacheLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;uncache</b> VG/CacheLV <br>
&bull; Split and remove the cache pool from CacheLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors</b> Number VG/CacheLV <br>
&bull; Split images from the mirrored origin of CacheLV to
create a new LV. <br>
&bull; Operates on mirror or raid1 sub LV. <br>
&bull; Requires &minus;&minus;name for the new LV, or the
use of &minus;&minus;trackchanges.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type thin&minus;pool</b> VG/CacheLV <br>
&bull; Convert CacheLV to type thin-pool. <br>
&bull; The CacheLV is used for thin pool data. <br>
&bull; Options &minus;&minus;chunksize,
&minus;&minus;discards,
&minus;&minus;poolmetadata{size,spare}, <br>
&minus;&minus;readahead, &minus;&minus;zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on ThinPoolLV with type thin&minus;pool:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitcache</b> VG/ThinPoolLV <br>
&bull; Split and keep the cache pool from the data portion
of ThinPoolLV. <br>
&bull; Operates on the data sub LV of the thin pool LV. <br>
&bull; The data sub LV of the thin pool must be a cache
LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;uncache</b> VG/ThinPoolLV <br>
&bull; Split and remove the cache pool from the data portion
of ThinPoolLV. <br>
&bull; Operates on the data sub LV of the thin pool LV. <br>
&bull; The data sub LV of the thin pool must be a cache
LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache</b> VG/ThinPoolLV <br>
&bull; Convert the data portion of ThinPoolLV to type cache.
<br>
&bull; Requires &minus;&minus;cachepool to specify the cache
pool to use. <br>
&bull; Operates on the data sub LV of the thin pool LV. <br>
&bull; Options &minus;&minus;cachepolicy,
&minus;&minus;cachesettings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;repair</b> VG/ThinPoolLV <br>
&bull; Repair ThinPoolLV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on ThinLV with type thin:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge</b> VG/ThinLV <br>
&bull; Merge ThinLV into its origin LV. <br>
&bull; ThinLV must have been created as a snapshot of
another thin LV. <br>
&bull; Options &minus;&minus;background,
&minus;&minus;interval.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operations
on SnapshotLV with type snapshot:</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitsnapshot</b> VG/SnapshotLV <br>
&bull; Separate COW snapshot SnapshotLV from its origin
LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge</b> VG/SnapshotLV <br>
&bull; Merge COW snapshot SnapshotLV into its origin. <br>
&bull; Options &minus;&minus;background,
&minus;&minus;interval.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>lvm</b>(8) for common options.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>&minus;b</b>,
<b>&minus;&minus;background</b></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:22%;">If the operation requires
polling, this option causes the command to return before the
operation is complete, and polling is done in the
background.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">



<p style="margin-top: 1em"><b>&minus;&minus;cachepolicy</b>
<i>Policy</i></p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the cache policy for
a cache LV. Also see <b>lvmcache</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="69%">


<p style="margin-top: 1em"><b>&minus;&minus;cachepool</b>
<i>CachePoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p> </td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the cache pool to use
when converting an LV to a cache LV. If
CachePoolLogicalVolume is not yet a cache pool, the command
will attempt to convert it into a cache pool prior to the
cache LV conversion. Also see <b>lvmcache</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">



<p style="margin-top: 1em"><b>&minus;&minus;cachesettings</b>
<i>Key</i><b>=</b><i>Value</i></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies tunable values for a
cache LV. (The default values should usually be adequate.)
The special string value <b>default</b> switches settings
back to their default kernel values and removes them from
the list of settings stored in LVM metadata. Also see
<b>lvmcache</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>&minus;c</b>,
<b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]</p> </td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:22%;">Sets the chunk size for a
snapshot, cache pool or thin pool. The default unit is in
kilobytes.</p>

<p style="margin-left:22%; margin-top: 1em">For snapshots,
the value must be a power of 2 between 4KiB and 512KiB and
the default value is 4.</p>

<p style="margin-left:22%; margin-top: 1em">For a cache
pool the value must be between 32KiB and 1GiB and the
default value is 64.</p>

<p style="margin-left:22%; margin-top: 1em">For a thin pool
the value must be between 64KiB and 1GiB and the default
value starts with 64 and scales up to fit the pool metadata
size within 128MiB, if the pool metadata size is not
specified. The value must be a multiple of 64KiB. (Early
kernel support until thin target version 1.4 required the
value to be a power of 2. Discards were not supported for
non-power of 2 values until thin target version 1.5.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">



<p style="margin-top: 1em"><b>&minus;&minus;corelog</b></p> </td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies or changes the log
type for a mirror LV. It is an alias for
<b>&minus;&minus;mirrorlog core</b>. (This option does not
apply to the <b>raid1</b> LV type.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em"><b>&minus;&minus;discards</b>
{<b>ignore</b>|<b>nopassdown</b>|<b>passdown</b>}</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies if discards will be
processed by the thin layer in the kernel and passed down to
the Physical Volume. This applies only to thin pools. The
default is <b>passdown</b>. Also see <b>lvmthin</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>&minus;H</b>,
<b>&minus;&minus;cache</b></p> </td>
<td width="72%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Alias for <b>&minus;&minus;type cache.</b></p><td width="60%"></td>
<td width="40%">


<p>See COMMANDS description for</p></td></tr>
</table>

<p style="margin-left:22%;"><b>lvconvert &minus;&minus;type
cache.</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>&minus;i</b>,
<b>&minus;&minus;interval</b> <i>Seconds</i></p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:22%;">Report progress as a percentage
at regular intervals.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>&minus;&minus;merge</b></p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:22%;">Merges a snapshot that was
split from an origin LV using
<b>&minus;&minus;splitsnapshot</b>, back into the origin
LV.</p>

<p style="margin-left:22%; margin-top: 1em">Merges a raid1
image that was split from a raid1 LV using
<b>&minus;&minus;splitsnapshot</b> and
<b>&minus;&minus;trackchanges</b>, back into the original
raid1 LV.</p>

<p style="margin-left:22%; margin-top: 1em">To check if the
kernel supports the snapshot merge feature, look for
&quot;snapshot&minus;merge&quot; in the output of <b>dmsetup
targets</b>.</p>

<p style="margin-left:22%; margin-top: 1em">When merging a
snapshot, if both the origin and snapshot LVs are not open,
the merge will start immediately. Otherwise, the merge will
start the first time either the origin or snapshot LV are
activated and both are closed. Merging a snapshot into an
origin that cannot be closed, for example a root filesystem,
is deferred until the next time the origin volume is
activated. When merging starts, the resulting LV will have
the origin&rsquo;s name, minor number and UUID. While the
merge is in progress, reads or writes to the origin appear
as being directed to the snapshot being merged. When the
merge finishes, the merged snapshot is removed. Multiple
snapshots may be specified on the command line or a @tag may
be used to specify multiple snapshots be merged to their
respective origin.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="49%">


<p style="margin-top: 1em"><b>&minus;&minus;mirrorlog</b>
{<b>disk</b>|<b>core</b>|<b>mirrored</b>}</p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies or changes the log
type for a mirror LV. The default is <b>disk</b>, which is
persistent and requires a small amount of storage space,
usually on a separate device from the data being mirrored.
<b>Core</b> may be useful for short-lived mirrors. It means
the mirror is regenerated by copying the data from the first
device again every time the device is activated - e.g.
possibly after every reboot. Using <b>mirrored</b> will
create a persistent log that is itself mirrored. (This
option does not apply to the <b>raid1</b> LV type.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p style="margin-top: 1em"><b>&minus;m</b>,
<b>&minus;&minus;mirrors</b> <i>Number</i></p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the number mirror
images in addition to the original LV image, e.g.
<b>&minus;&minus;mirrors 1</b> means two copies of the data,
the original and one mirror image.</p>

<p style="margin-left:22%; margin-top: 1em">The current
maximum is 9 providing 10 raid1 images.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
required when converting an LV to a <b>raid1</b> or
<b>mirror</b> LV.</p>

<p style="margin-left:22%; margin-top: 1em">This option can
be used alone to change the number of mirror images in an
existing <b>raid1</b> or <b>mirror</b> LV.</p>

<p style="margin-left:22%; margin-top: 1em">The special
case <b>&minus;&minus;mirrors 0</b> has been used
historically to indicate a linear LV with no mirror
images.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">


<p style="margin-top: 1em"><b>&minus;n</b>,
<b>&minus;&minus;name</b> <i>Name</i></p></td>
<td width="66%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Specifies the name to use when the command is creating a
new LV, e.g. <b>&minus;&minus;splitmirrors.</b></p><td width="11%"></td>
<td width="18%"></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">



<p style="margin-top: 1em"><b>&minus;&minus;noudevsync</b></p> </td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:22%;">Disables udev synchronisation.
The process will not wait for notification from udev. It
will continue irrespective of any possible udev processing
in the background. You should only use this if udev is not
running or has rules that ignore the devices LVM
creates.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="61%">


<p style="margin-top: 1em"><b>&minus;&minus;originname</b>
<i>NewExternalOriginVolumeName</i></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the name to use for
the external origin LV when converting an LV to a thin LV.
The LV being converted becomes a read&minus;only external
origin with this name. <br>
Without this option, the default name of
&quot;lvol&lt;n&gt;&quot; will be generated where &lt;n&gt;
is the LVM internal number of the LV.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="78%">



<p style="margin-top: 1em"><b>&minus;&minus;poolmetadata</b>
<i>PoolMetadataLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the LV to use for
thin pool metadata when converting an LV to a thin pool LV.
<br>
Specifies the LV to use for cache pool metadata when
converting an LV to a cache pool LV. <br>
The size should be between 2MiB and 16GiB. <br>
(This option can also be used when a thin pool or cache pool
are created as an auxiliary operation within a different
command.) Also see <b>lvmthin</b>(7), and
<b>lvmcache</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="86%">



<p style="margin-top: 1em"><b>&minus;&minus;poolmetadatasize</b>
<i>PoolMetadataSize</i>[<b>b</b>|<b>B</b>|<b>s</b>|<b>S</b>|<b>k</b>|<b>K</b>|<b>m</b>|<b>M</b>|<b>g</b>|<b>G</b>]</p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the size of a cache
pool metadata LV or a thin pool metadata LV. This is used if
a command creates a pool metadata LV automatically as part
of the operation. This option is not used when an existing
LV is specified as the pool metadata LV, i.e.
<b>&minus;&minus;poolmetadata</b>. The default unit is
megabytes. Also see <b>lvmthin</b>(7), and
<b>lvmcache</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="38%">



<p style="margin-top: 1em"><b>&minus;&minus;poolmetadataspare</b>
{<b>y</b>|<b>n</b>}</p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies if a spare pool
metadata LV should be created. A spare pool metadata LV will
be used for pool repair. Only one spare pool metadata LV is
maintained within a VG, with the size of the largest
existing pool metadata LV. The default is <b>y</b>es.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="67%">


<p style="margin-top: 1em"><b>&minus;r</b>,
<b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<b>auto</b>|<b>none</b>}</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the read ahead sector
count of a thin pool metadata LV. The default value is
<b>auto</b> which allows the kernel to choose a suitable
value automatically. <b>None</b> is equivalent to specifying
zero.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="55%">


<p style="margin-top: 1em"><b>&minus;R</b>,
<b>&minus;&minus;regionsize</b>
<i>MirrorLogRegionSize</i></p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:22%;">A mirror LV is divided into
regions of this size (in MB), and the mirror log uses this
granularity to track which regions are in sync. (This option
does not apply to the <b>raid1</b> LV type.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>&minus;&minus;repair</b></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:22%;">Replaces failed PVs in a raid1
or mirror LV with other PVs available in the VG. By default,
the original number of mirror images will be restored if
possible. Specify <b>&minus;y</b> on the command line to
skip the prompts. Use <b>&minus;f</b> if you do not want any
replacement. You may use
<b>&minus;&minus;use&minus;policies</b> to use the device
replacement policy specified in <b>lvm.conf</b>(5), see
<b>activation/mirror_log_fault_policy</b> or
<b>activation/mirror_device_fault_policy</b>.</p>

<p style="margin-left:22%; margin-top: 1em">When used with
a thin pool LV, this option automates the use of the
<b>thin_repair</b>(8) tool on the thin pool. This repairs a
very limitted number of problems. Only inactive thin pools
can be repaired. There is no validation of metadata between
kernel and LVM. This requires further manual work. After
successfull repair the old unmodified metadata are still
available in &quot;&lt;pool&gt;_meta&lt;n&gt;&quot; LV. Also
see <b>lvmthin</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="37%">


<p style="margin-top: 1em"><b>&minus;&minus;replace</b>
<i>PhysicalVolume</i></p> </td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:22%;">Remove the specified device
<i>PhysicalVolume</i> and replace it with one that is
available in the VG, or from a specific list of PVs
specified on the command line following the LV name. This
option may be repeated multiple times depending on the
RaidLV type.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">


<p style="margin-top: 1em"><b>&minus;s</b>,
<b>&minus;&minus;snapshot</b></p> </td>
<td width="68%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Alias for <b>&minus;&minus;type snapshot.</b></p><td width="65%"></td>
<td width="35%">


<p>See COMMANDS description for</p></td></tr>
</table>

<p style="margin-left:22%;"><b>lvconvert &minus;&minus;type
snapshot.</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>&minus;&minus;split</b></p></td>
<td width="78%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Separates <i>SplitableLogicalVolume</i>. This option
tries to detect the necessary split operation from its
arguments. Avoid using this option and use one of the
following instead: <b>&minus;&minus;splitcache,
&minus;&minus;splitmirrors,
&minus;&minus;splitsnapshot.</b></p> <td width="11%"></td>
<td width="18%"></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">



<p style="margin-top: 1em"><b>&minus;&minus;splitcache</b></p> </td>
<td width="71%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Separates a cache pool from a cache LV, and keeps the
unused cache pool LV. Before the separation, the cache is
flushed. See similar option
<b>&minus;&minus;uncache.</b></p> <td width="11%"></td>
<td width="32%"></td>
<td width="26%"></td>
<td width="31%">


<p>Also see <b>lvmcache</b>(7).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">



<p style="margin-top: 1em"><b>&minus;&minus;splitmirrors</b>
<i>Number</i></p> </td>
<td width="26%"></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:22%;">Splits the specified number of
images from a <b>raid1</b> or <b>mirror</b> LV and uses them
to create a new LV.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>If <b>&minus;&minus;trackchanges</b> is also specified,
changes to the raid1 LV are tracked while the split LV
remains detached. <b>lvconvert &minus;&minus;merge</b></p><td width="22%"></td>
<td width="78%">


<p style="margin-top: 1em">can be used to recombine the
split images with the original raid1 LV.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">A name can be
specified for the new LV with <b>&minus;&minus;name</b> (a
name is required without
<b>&minus;&minus;trackchanges</b>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">



<p style="margin-top: 1em"><b>&minus;&minus;splitsnapshot</b></p> </td>
<td width="66%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Separates a COW snapshot from its origin LV. The LV that
is split off contains the chunks that differ from the origin
LV along with metadata describing them. This LV can be wiped
and then destroyed with lvremove. See corresponding
operation <b>lvconvert &minus;&minus;type snapshot.</b></p><td width="11%"></td>
<td width="24%"></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>&minus;&minus;stripes</b>
<i>Number</i></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the number of stripes
in a striped LV. This is the number of physical volumes
(devices) that a striped LV is spread across. Data that
appears sequential in the LV is spread across multiple
devices in units of the stripe size (see
<b>&minus;&minus;stripesize</b>). This does not apply to
existing allocated space, only newly allocated space can be
striped.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="41%">


<p style="margin-top: 1em"><b>&minus;I</b>,
<b>&minus;&minus;stripesize</b> <i>StripeSize</i></p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the stripe size in
kilobytes for a striped LV. The stripe size is the number of
kilobytes written to each stripe, i.e. to one device, before
writing to the next stripe/device. StripeSize must be a
power of 2 and cannot exceed the VG physical extent (PE)
size.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="27%">


<p style="margin-top: 1em"><b>&minus;&minus;type</b>
<i>SegmentType</i></p> </td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:22%;">Converts an LV from one segment
type to another. See COMMANDS section for a description of
converting between each type.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="66%">


<p style="margin-top: 1em"><b>&minus;&minus;thinpool</b>
<i>ThinPoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p> </td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:22%;">Specifies the thin pool to use
when converting an LV to a thin LV. If ThinPoolLogicalVolume
is not yet a thin pool, the command will attempt to convert
it to a thin pool prior to the thin LV conversion. Also see
<b>lvmthin</b>(7).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="21%">



<p style="margin-top: 1em"><b>&minus;&minus;trackchanges</b></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:22%;">Can be used with
<b>&minus;&minus;splitmirrors</b> on a raid1 LV. This causes
changes to the original raid1 LV to be tracked while the
split images remain detached. This allows the
read&minus;only detached image(s) to be merged efficiently
back into the raid1 LV later. Only the regions with changed
data are resynchronized during merge. (This option only
applies to the <b>raid1</b> LV type.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p style="margin-top: 1em"><b>&minus;T</b>,
<b>&minus;&minus;thin</b></p> </td>
<td width="74%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Alias for <b>&minus;&minus;type thin.</b></p><td width="58%"></td>
<td width="42%">


<p>See COMMANDS description for</p></td></tr>
</table>

<p style="margin-left:22%;"><b>lvconvert &minus;&minus;type
thin.</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">



<p style="margin-top: 1em"><b>&minus;&minus;uncache</b></p> </td>
<td width="75%">
</td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Separates a cache pool from a cache LV, and removes the
unused cache pool LV. Before the separation, the cache is
flushed. See similar option
<b>&minus;&minus;splitcache.</b></p> <td width="11%"></td>
<td width="24%"></td>
<td width="39%"></td>
<td width="26%">


<p>Also see <b>lvmcache</b>(7).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="24%">


<p style="margin-top: 1em"><b>&minus;Z</b>,
<b>&minus;&minus;zero</b> {<b>y</b>|<b>n</b>}</p></td>
<td width="39%"></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:22%;">For snapshots, this controls
zeroing of the first 4KiB of data in the snapshot. If the LV
is read&minus;only, the snapshot will not be zeroed.</p>

<p style="margin-left:22%; margin-top: 1em">For thin pools,
this controls zeroing of provisioned blocks. Provisioning of
large zeroed chunks negatively impacts performance. Also see
<b>lvmthin</b>(7).</p>

<h2>Examples
<a name="Examples"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Convert a
linear LV to a two-way mirror LV: <b><br>
lvconvert &minus;&minus;type mirror &minus;&minus;mirrors 1
vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
linear LV to a two-way RAID1 LV: <b><br>
lvconvert &minus;&minus;type raid1 &minus;&minus;mirrors 1
vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
mirror LV to use an in&minus;memory log: <b><br>
lvconvert &minus;&minus;mirrorlog core vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
mirror LV to use a disk log: <b><br>
lvconvert &minus;&minus;mirrorlog disk vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
mirror or raid1 LV to a linear LV: <b><br>
lvconvert --type linear vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
mirror LV to a raid1 LV with the same number of images:
<b><br>
lvconvert &minus;&minus;type raid1 vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
linear LV to a two-way mirror LV, allocating new extents
from specific PV ranges: <b><br>
lvconvert &minus;&minus;mirrors 1 vg/lvol1
/dev/sda:0&minus;15 /dev/sdb:0&minus;15</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert a
mirror LV to a linear LV, freeing physical extents from a
specific PV: <b><br>
lvconvert &minus;&minus;type linear vg/lvol1
/dev/sda</b></p>

<p style="margin-left:11%; margin-top: 1em">Split one image
from a mirror or raid1 LV, making it a new LV: <b><br>
lvconvert &minus;&minus;splitmirrors 1 &minus;&minus;name
lv_split vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Split one image
from a raid1 LV, and track changes made to the raid1 LV
while the split image remains detached: <b><br>
lvconvert &minus;&minus;splitmirrors 1
&minus;&minus;trackchanges vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Merge an image
(that was previously created with &minus;&minus;splitmirrors
and &minus;&minus;trackchanges) back into the original raid1
LV: <b><br>
lvconvert &minus;&minus;merge vg/lvol1_rimage_1</b></p>

<p style="margin-left:11%; margin-top: 1em">Replace PV
/dev/sdb1 with PV /dev/sdf1 in a raid1/4/5/6/10 LV: <b><br>
lvconvert &minus;&minus;replace /dev/sdb1 vg/lvol1
/dev/sdf1</b></p>

<p style="margin-left:11%; margin-top: 1em">Replace 3 PVs
/dev/sd[b-d]1 with PVs /dev/sd[f-h]1 in a raid1 LV: <b><br>
lvconvert &minus;&minus;replace /dev/sdb1
&minus;&minus;replace /dev/sdc1 &minus;&minus;replace
/dev/sdd1</b></p>

<p style="margin-left:22%;"><b>vg/lvol1
/dev/sd[fgh]1</b></p>

<p style="margin-left:11%; margin-top: 1em">Replace the
maximum of 2 PVs /dev/sd[bc]1 with PVs /dev/sd[gh]1 in a
raid6 LV: <b><br>
lvconvert &minus;&minus;replace /dev/sdb1
&minus;&minus;replace /dev/sdc1 vg/lvol1
/dev/sd[gh]1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an LV
into a thin LV in the specified thin pool. The existing LV
is used as an external read&minus;only origin for the new
thin LV. <b><br>
lvconvert &minus;&minus;type thin &minus;&minus;thinpool
vg/tpool1 vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an LV
into a thin LV in the specified thin pool. The existing LV
is used as an external read&minus;only origin for the new
thin LV, and is renamed &quot;external&quot;: <b><br>
lvconvert &minus;&minus;type thin &minus;&minus;thinpool
vg/tpool1</b></p>

<p style="margin-left:22%;"><b>&minus;&minus;originname
external vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an LV
to a cache pool LV using another specified LV for cache pool
metadata: <b><br>
lvconvert &minus;&minus;type cache-pool
&minus;&minus;poolmetadata vg/poolmeta1 vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an LV
to a cache LV using the specified cache pool and chunk size:
<b><br>
lvconvert &minus;&minus;type cache &minus;&minus;cachepool
vg/cpool1 &minus;c 128 vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Detach and keep
the cache pool from a cache LV: <b><br>
lvconvert &minus;&minus;splitcache vg/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Detach and
remove the cache pool from a cache LV: <b><br>
lvconvert &minus;&minus;uncache vg/lvol1</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>lvm</b>(8),
<b>lvm.conf</b>(5), <b>lvmcache</b>(7), <b>lvmthin</b>(7),
<b>lvdisplay</b>(8), <b>lvextend</b>(8), <b>lvreduce</b>(8),
<b>lvremove</b>(8), <b>lvrename</b>(8), <b>lvscan</b>(8),
<b>vgcreate</b>(8), <b>cache_dump</b>(8),
<b>cache_repair</b>(8), <b>cache_restore</b>(8),
<b>thin_dump</b>(8), <b>thin_repair</b>(8),
<b>thin_restore</b>(8)</p>
<hr>
</body>
</html>
