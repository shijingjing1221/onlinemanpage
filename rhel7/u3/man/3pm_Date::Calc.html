<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 21:08:39 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Date::Calc</title>

</head>
<body>

<h1 align="center">Date::Calc</h1>

<a href="#NAME">NAME</a><br>
<a href="#MOTTO">MOTTO</a><br>
<a href="#PREFACE">PREFACE</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#IMPORTANT NOTES">IMPORTANT NOTES</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RECIPES">RECIPES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#BEWARE">BEWARE</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#DISCLAIMER">DISCLAIMER</a><br>
<a href="#POD ERRORS">POD ERRORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Date::Calc
&minus; Gregorian calendar date calculations</p>

<h2>MOTTO
<a name="MOTTO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Keep it small,
fast and simple</p>

<h2>PREFACE
<a name="PREFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package
consists of a C library and a Perl module (which uses the C
library, internally) for all kinds of date calculations
based on the Gregorian calendar (the one used in all western
countries today), thereby complying with all relevant norms
and standards: <small>ISO/R&nbsp;</small> 2015&minus;1971,
<small>DIN&nbsp;</small> 1355 and, to some extent,
<small>ISO&nbsp;</small> 8601 (where applicable).</p>

<p style="margin-left:11%; margin-top: 1em">(See also
http://www.engelschall.com/u/sb/download/Date&minus;Calc/DIN1355/
for a scan of part of the &quot; <small>DIN&nbsp;</small>
1355&quot; document (in German)).</p>

<p style="margin-left:11%; margin-top: 1em">The module of
course handles year numbers of 2000 and above correctly
(&quot;Year 2000&quot; or &quot;Y2K&quot; compliance) --
actually all year numbers from 1 to the largest positive
integer representable on your system (which is at least
32767) can be dealt with.</p>

<p style="margin-left:11%; margin-top: 1em">This is not
true, however, for the import/export functions in this
package which are an interface to the internal
<small>POSIX</small> date and time functions of your system,
which can only cover dates in the following ranges:</p>

<pre style="margin-left:11%; margin-top: 1em"> 01&minus;Jan&minus;1970 00:00:00 GMT .. 19&minus;Jan&minus;2038 03:14:07 GMT [Unix etc.]
 01&minus;Jan&minus;1904 00:00:00 LT  .. 06&minus;Feb&minus;2040 06:28:15 LT  [MacOS Classic]
 (LT = local time)</pre>


<p style="margin-left:11%; margin-top: 1em">Note that this
package projects the Gregorian calendar back until the year
1&nbsp;A.D. -- even though the Gregorian calendar was only
adopted in 1582, mostly by the Catholic European countries,
in obedience to the corresponding decree of Pope
Gregory&nbsp; <small>XIII</small> in that year.</p>

<p style="margin-left:11%; margin-top: 1em">Some (mainly
protestant) countries continued to use the Julian calendar
(used until then) until as late as the beginning of the 20th
century.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, note
that this package is not intended to do everything you could
ever imagine automagically for you; it is rather intended to
serve as a toolbox (in the best of <small>UNIX</small>
spirit and traditions) which should, however, always get you
where you want to go.</p>

<p style="margin-left:11%; margin-top: 1em">See the section
&quot; <small>RECIPES&quot;</small> at the bottom of this
document for solutions to common problems!</p>

<p style="margin-left:11%; margin-top: 1em">If nevertheless
you can&rsquo;t figure out how to solve a particular
problem, please let me know! (See e&minus;mail address at
the end of this document.)</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use Date::Calc qw(
      Days_in_Year
      Days_in_Month
      Weeks_in_Year
      leap_year
      check_date
      check_time
      check_business_date
      Day_of_Year
      Date_to_Days
      Day_of_Week
      Week_Number
      Week_of_Year
      Monday_of_Week
      Nth_Weekday_of_Month_Year
      Standard_to_Business
      Business_to_Standard
      Delta_Days
      Delta_DHMS
      Delta_YMD
      Delta_YMDHMS
      N_Delta_YMD
      N_Delta_YMDHMS
      Normalize_DHMS
      Add_Delta_Days
      Add_Delta_DHMS
      Add_Delta_YM
      Add_Delta_YMD
      Add_Delta_YMDHMS
      Add_N_Delta_YMD
      Add_N_Delta_YMDHMS
      System_Clock
      Today
      Now
      Today_and_Now
      This_Year
      Gmtime
      Localtime
      Mktime
      Timezone
      Date_to_Time
      Time_to_Date
      Easter_Sunday
      Decode_Month
      Decode_Day_of_Week
      Decode_Language
      Decode_Date_EU
      Decode_Date_US
      Fixed_Window
      Moving_Window
      Compress
      Uncompress
      check_compressed
      Compressed_to_Text
      Date_to_Text
      Date_to_Text_Long
      English_Ordinal
      Calendar
      Month_to_Text
      Day_of_Week_to_Text
      Day_of_Week_Abbreviation
      Language_to_Text
      Language
      Languages
      Decode_Date_EU2
      Decode_Date_US2
      Parse_Date
      ISO_LC
      ISO_UC
  );
  use Date::Calc qw(:all);
  Days_in_Year
      $days = Days_in_Year($year,$month);
  Days_in_Month
      $days = Days_in_Month($year,$month);
  Weeks_in_Year
      $weeks = Weeks_in_Year($year);
  leap_year
      if (leap_year($year))
  check_date
      if (check_date($year,$month,$day))
  check_time
      if (check_time($hour,$min,$sec))
  check_business_date
      if (check_business_date($year,$week,$dow))
  Day_of_Year
      $doy = Day_of_Year($year,$month,$day);
  Date_to_Days
      $days = Date_to_Days($year,$month,$day);
  Day_of_Week
      $dow = Day_of_Week($year,$month,$day);
  Week_Number
      $week = Week_Number($year,$month,$day);          # DEPRECATED
  Week_of_Year
      ($week,$year) = Week_of_Year($year,$month,$day); # RECOMMENDED
      $week = Week_of_Year($year,$month,$day);         # DANGEROUS
  Monday_of_Week
      ($year,$month,$day) = Monday_of_Week($week,$year);
  Nth_Weekday_of_Month_Year
      if (($year,$month,$day) =
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))
  Standard_to_Business
      ($year,$week,$dow) =
      Standard_to_Business($year,$month,$day);
  Business_to_Standard
      ($year,$month,$day) =
      Business_to_Standard($year,$week,$dow);
  Delta_Days
      $Dd = Delta_Days($year1,$month1,$day1,
                       $year2,$month2,$day2);
  Delta_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                 $year2,$month2,$day2, $hour2,$min2,$sec2);
  Delta_YMD
      ($Dy,$Dm,$Dd) =
      Delta_YMD($year1,$month1,$day1,
                $year2,$month2,$day2);
  Delta_YMDHMS
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) =
      Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                   $year2,$month2,$day2, $hour2,$min2,$sec2);
  N_Delta_YMD
      ($Dy,$Dm,$Dd) =
      N_Delta_YMD($year1,$month1,$day1,
                  $year2,$month2,$day2);
  N_Delta_YMDHMS
      ($D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss) =
      N_Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                     $year2,$month2,$day2, $hour2,$min2,$sec2);
  Normalize_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Normalize_DHMS($Dd,$Dh,$Dm,$Ds);
  Add_Delta_Days
      ($year,$month,$day) =
      Add_Delta_Days($year,$month,$day,
                     $Dd);
  Add_Delta_DHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
                     $Dd,$Dh,$Dm,$Ds);
  Add_Delta_YM
      ($year,$month,$day) =
      Add_Delta_YM($year,$month,$day,
                   $Dy,$Dm);
  Add_Delta_YMD
      ($year,$month,$day) =
      Add_Delta_YMD($year,$month,$day,
                    $Dy,$Dm,$Dd);
  Add_Delta_YMDHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
                       $D_y,$D_m,$D_d, $Dh,$Dm,$Ds);
  Add_N_Delta_YMD
      ($year,$month,$day) =
      Add_N_Delta_YMD($year,$month,$day,
                      $Dy,$Dm,$Dd);
  Add_N_Delta_YMDHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_N_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
                         $D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss);
  System_Clock
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      System_Clock([$gmt]);
  Today
      ($year,$month,$day) = Today([$gmt]);
  Now
      ($hour,$min,$sec) = Now([$gmt]);
  Today_and_Now
      ($year,$month,$day, $hour,$min,$sec) = Today_and_Now([$gmt]);
  This_Year
      $year = This_Year([$gmt]);
  Gmtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Gmtime([time]);
  Localtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Localtime([time]);
  Mktime
      $time = Mktime($year,$month,$day, $hour,$min,$sec);
  Timezone
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) = Timezone([time]);
  Date_to_Time
      $time = Date_to_Time($year,$month,$day, $hour,$min,$sec);
  Time_to_Date
      ($year,$month,$day, $hour,$min,$sec) = Time_to_Date([time]);
  Easter_Sunday
      ($year,$month,$day) = Easter_Sunday($year);
  Decode_Month
      if ($month = Decode_Month($string[,$lang]))
  Decode_Day_of_Week
      if ($dow = Decode_Day_of_Week($string[,$lang]))
  Decode_Language
      if ($lang = Decode_Language($string))
  Decode_Date_EU
      if (($year,$month,$day) = Decode_Date_EU($string[,$lang]))
  Decode_Date_US
      if (($year,$month,$day) = Decode_Date_US($string[,$lang]))
  Fixed_Window
      $year = Fixed_Window($yy);
  Moving_Window
      $year = Moving_Window($yy);
  Compress
      $date = Compress($year,$month,$day);
  Uncompress
      if (($century,$year,$month,$day) = Uncompress($date))
  check_compressed
      if (check_compressed($date))
  Compressed_to_Text
      $string = Compressed_to_Text($date[,$lang]);
  Date_to_Text
      $string = Date_to_Text($year,$month,$day[,$lang]);
  Date_to_Text_Long
      $string = Date_to_Text_Long($year,$month,$day[,$lang]);
  English_Ordinal
      $string = English_Ordinal($number);
  Calendar
      $string = Calendar($year,$month[,$orthodox[,$lang]]);
  Month_to_Text
      $string = Month_to_Text($month[,$lang]);
  Day_of_Week_to_Text
      $string = Day_of_Week_to_Text($dow[,$lang]);
  Day_of_Week_Abbreviation
      $string = Day_of_Week_Abbreviation($dow[,$lang]);
  Language_to_Text
      $string = Language_to_Text($lang);
  Language
      $lang = Language();
      Language($lang);               # DEPRECATED
      $oldlang = Language($newlang); # DEPRECATED
  Languages
      $max_lang = Languages();
  Decode_Date_EU2
      if (($year,$month,$day) = Decode_Date_EU2($string[,$lang]))
  Decode_Date_US2
      if (($year,$month,$day) = Decode_Date_US2($string[,$lang]))
  Parse_Date
      if (($year,$month,$day) = Parse_Date($string[,$lang]))
  ISO_LC
      $lower = ISO_LC($string);
  ISO_UC
      $upper = ISO_UC($string);
  Version
      $string = Date::Calc::Version();</pre>


<h2>IMPORTANT NOTES
<a name="IMPORTANT NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">(See the
section &quot; <small>RECIPES&quot;</small> at the bottom of
this document for solutions to common problems!)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p>&quot;Year 2000&quot; (&quot;Y2K&quot;) compliance</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The upper limit
for any year number in this module is only given by the size
of the largest positive integer that can be represented in a
variable of the C type &quot;int&quot; on your system, which
is at least 32767, according to the <small>ANSI C</small>
standard (exceptions see below).</p>

<p style="margin-left:14%; margin-top: 1em">In order to
simplify calculations, this module projects the gregorian
calendar back until the year 1&nbsp;A.D. -- i.e., back
<b><small>BEYOND</small></b> the year 1582 when this
calendar was first decreed by the Catholic Pope
Gregory&nbsp; <small>XIII</small> !</p>

<p style="margin-left:14%; margin-top: 1em">Therefore,
<b><small>BE SURE TO ALWAYS SPECIFY &quot;1998&quot; WHEN
YOU MEAN &quot;1998&quot;</small></b> , for instance, and
<b><small>DO NOT WRITE &quot;98&quot; INSTEAD</small></b> ,
because this will in fact perform a calculation based on the
year &quot;98&quot; A.D. and <b><small>NOT</small></b>
&quot;1998&quot;!</p>

<p style="margin-left:14%; margin-top: 1em">An exception
from this rule are the functions which contain the word
&quot;compress&quot; in their names (which can only handle
years between 1970 and 2069 and also accept the
abbreviations &quot;00&quot; to &quot;99&quot;), and the
functions whose names begin with &quot;Decode_Date_&quot;
(which translate year numbers below 100 using a technique
known as &quot;moving window&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
convert a two-digit year number into a full-fledged,
four-digit (at least for some years to come
<tt>&quot;;&minus;)&quot;</tt>) year number, use the two
functions &quot;<i>Fixed_Window()</i>&quot; and
&quot;<i>Moving_Window()</i>&quot; (see their description
further below).</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
the following import/export functions (which are interfaces
to the <small>POSIX</small> functions
&quot;<i>time()</i>&quot;, &quot;<i>gmtime()</i>&quot;,
&quot;<i>localtime()</i>&quot; and
&quot;<i>mktime()</i>&quot; or (the last two) substitutes
for the <small>BSD</small> function
&quot;<i>timegm()</i>&quot; and the <small>POSIX</small>
function &quot;<i>gmtime()</i>&quot;) have a very limited
range of representable dates (in contrast to all other
functions in this package, which cover virtually any date
including and after January&nbsp;1st&nbsp;1&nbsp;A.D.):</p>

<pre style="margin-left:14%; margin-top: 1em">              System_Clock()
              Today()
              Now()
              Today_and_Now()
              This_Year()
              Gmtime()
              Localtime()
              Mktime()
              Timezone()
              Date_to_Time()
              Time_to_Date()</pre>


<p style="margin-left:14%; margin-top: 1em">These functions
can only deal with dates in the range from
01&minus;Jan&minus;1970&nbsp;00:00:00&nbsp;
<small>GMT</small> to
19&minus;Jan&minus;2038&nbsp;03:14:07&nbsp;
<small>GMT</small> (the latter limit is only authoritative
on 32&nbsp;bit systems, however, and can (in principle,
through a few code changes) be extended somewhat
<tt>&quot;:&minus;)&quot;</tt> on 64&nbsp;bit systems).</p>

<p style="margin-left:14%; margin-top: 1em">On MacOS
Classic, the valid range of dates is between (both included)
01&minus;Jan&minus;1904&nbsp;00:00:00 (local time) to
06&minus;Feb&minus;2040&nbsp;06:28:15 (local time).</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that the function &quot;<i>Easter_Sunday()</i>&quot; can
only be used for years in the range 1583 to 2299.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p style="margin-top: 1em"><small>POSIX</small>
functions</p> </td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that the
following functions</p>

<pre style="margin-left:14%; margin-top: 1em">              Gmtime()
              Localtime()
              Mktime()
              Timezone()</pre>


<p style="margin-left:14%; margin-top: 1em">are actually
wrappers around or based upon the corresponding
<small>POSIX</small> functions &quot;<i>time()</i>&quot;,
&quot;<i>gmtime()</i>&quot;, &quot;<i>localtime()</i>&quot;
and &quot;<i>mktime()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">As such, they
depend on local settings of the underlying machine such as
e.g. the system clock, the time zone and the locale.</p>

<p style="margin-left:14%; margin-top: 1em">Their results
can therefore sometimes be unexpected or
counter-intuitive.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, no
support can be provided for these functions.</p>

<p style="margin-left:14%; margin-top: 1em">They are
supplied &quot;as is&quot;, purely for the sake of
interoperability.</p>

<p style="margin-left:14%; margin-top: 1em">Use at your own
risk. (You have been warned!)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="17%">


<p style="margin-top: 1em">First index</p></td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b><small>ALL</small></b>
ranges in this module start with &quot;<tt>1</tt>&quot;,
<b><small>NOT</small></b> &quot;<tt>0</tt>&quot;!</p>

<p style="margin-left:14%; margin-top: 1em">I.e., the day
of month, day of week, day of year, month of year, week of
year, first valid year number and language
<b><small>ALL</small></b> start counting at one,
<b><small>NOT</small></b> zero!</p>

<p style="margin-left:14%; margin-top: 1em">The only
exception is the function
&quot;<tt>&quot;Week_Number()&quot;</tt>&quot;, which may in
fact return &quot;<tt>0</tt>&quot; when the given date
actually lies in the last week of the
<b><small>PREVIOUS</small></b> year, and of course the
numbers for hours (<tt>0..23</tt>), minutes (<tt>0..59</tt>)
and seconds (<tt>0..59</tt>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em">Function naming conventions</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Function names
completely in lower case indicate a boolean return
value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Boolean values</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Boolean values
returned from functions in this module are always a numeric
zero (&quot;<tt>0</tt>&quot;) for &quot;false&quot; and a
numeric one (&quot;<tt>1</tt>&quot;) for
&quot;true&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em">Exception handling</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The functions
in this module will usually die with a corresponding error
message if their input parameters, intermediate results or
output values are out of range.</p>

<p style="margin-left:14%; margin-top: 1em">The following
functions handle errors differently:</p>

<pre style="margin-left:14%; margin-top: 1em">  &minus;  check_date()
  &minus;  check_time()
  &minus;  check_business_date()
  &minus;  check_compressed()</pre>


<p style="margin-left:14%; margin-top: 1em">(which return a
&quot;false&quot; return value when the given input does not
represent a valid date or time),</p>

<pre style="margin-left:14%; margin-top: 1em">  &minus;  Nth_Weekday_of_Month_Year()</pre>


<p style="margin-left:14%; margin-top: 1em">(which returns
an empty list if the requested 5th day of week does not
exist),</p>

<pre style="margin-left:14%; margin-top: 1em">  &minus;  Decode_Month()
  &minus;  Decode_Day_of_Week()
  &minus;  Decode_Language()
  &minus;  Fixed_Window()
  &minus;  Moving_Window()
  &minus;  Compress()</pre>


<p style="margin-left:14%; margin-top: 1em">(which return
&quot;<tt>0</tt>&quot; upon failure or invalid input),
and</p>

<pre style="margin-left:14%; margin-top: 1em">  &minus;  Decode_Date_EU()
  &minus;  Decode_Date_US()
  &minus;  Decode_Date_EU2()
  &minus;  Decode_Date_US2()
  &minus;  Parse_Date()
  &minus;  Uncompress()</pre>


<p style="margin-left:14%; margin-top: 1em">(which return
an empty list upon failure or invalid input).</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
can always catch an exception thrown by any of the functions
in this module and handle it yourself by enclosing the
function call in an &quot;<tt>&quot;eval&quot;</tt>&quot;
with curly brackets and checking the special variable
&quot;<tt>$@</tt>&quot; (see &quot;eval&quot; in
<i>perlfunc</i>(1) for details).</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;use Date::Calc qw(
Days_in_Year Days_in_Month ... );&quot;</tt></p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><tt>&quot;use Date::Calc qw(:all);&quot;</tt></p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">You can either
specify the functions you want to import explicitly by
enumerating them between the parentheses of the
&quot;<tt>&quot;qw()&quot;</tt>&quot; operator, or you can
use the &quot;<tt>&quot;:all&quot;</tt>&quot; tag instead to
import <b><small>ALL</small></b> available functions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p style="margin-top: 1em"><tt>&quot;$days =
Days_in_Year($year,$month);&quot;</tt></p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the sum of the number of days in the months starting
with January up to and including &quot;<tt>$month</tt>&quot;
in the given year &quot;<tt>$year</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,
&quot;<tt>&quot;Days_in_Year(1998,1)&quot;</tt>&quot;
returns &quot;<tt>31</tt>&quot;,
&quot;<tt>&quot;Days_in_Year(1998,2)&quot;</tt>&quot;
returns &quot;<tt>59</tt>&quot;,
&quot;<tt>&quot;Days_in_Year(1998,3)&quot;</tt>&quot;
returns &quot;<tt>90</tt>&quot;, and so on.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>&quot;Days_in_Year($year,12)&quot;</tt>&quot;
returns the number of days in the given year
&quot;<tt>$year</tt>&quot;, i.e., either
&quot;<tt>365</tt>&quot; or &quot;<tt>366</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>&quot;$days =
Days_in_Month($year,$month);&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the number of days in the given month
&quot;<tt>$month</tt>&quot; of the given year
&quot;<tt>$year</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The year must
always be supplied, even though it is only needed when the
month is February, in order to determine whether it is a
leap year or not.</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,
&quot;<tt>&quot;Days_in_Month(1998,1)&quot;</tt>&quot;
returns &quot;<tt>31</tt>&quot;,
&quot;<tt>&quot;Days_in_Month(1998,2)&quot;</tt>&quot;
returns &quot;<tt>28</tt>&quot;,
&quot;<tt>&quot;Days_in_Month(2000,2)&quot;</tt>&quot;
returns &quot;<tt>29</tt>&quot;,
&quot;<tt>&quot;Days_in_Month(1998,3)&quot;</tt>&quot;
returns &quot;<tt>31</tt>&quot;, and so on.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><tt>&quot;$weeks =
Weeks_in_Year($year);&quot;</tt></p> </td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the number of weeks in the given year
&quot;<tt>$year</tt>&quot;, i.e., either
&quot;<tt>52</tt>&quot; or &quot;<tt>53</tt>&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;if
(leap_year($year))&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns &quot;true&quot; (&quot;<tt>1</tt>&quot;) if the
given year &quot;<tt>$year</tt>&quot; is a leap year and
&quot;false&quot; (&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><tt>&quot;if
(check_date($year,$month,$day))&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns &quot;true&quot; (&quot;<tt>1</tt>&quot;) if the
given three numerical values &quot;<tt>$year</tt>&quot;,
&quot;<tt>$month</tt>&quot; and &quot;<tt>$day</tt>&quot;
constitute a valid date, and &quot;false&quot;
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>&quot;if
(check_time($hour,$min,$sec))&quot;</tt></p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns &quot;true&quot; (&quot;<tt>1</tt>&quot;) if the
given three numerical values &quot;<tt>$hour</tt>&quot;,
&quot;<tt>$min</tt>&quot; and &quot;<tt>$sec</tt>&quot;
constitute a valid time (<tt>&quot;0 &lt;= $hour &lt;
24&quot;</tt>, <tt>&quot;0 &lt;= $min &lt; 60&quot;</tt> and
<tt>&quot;0 &lt;= $sec &lt; 60&quot;</tt>), and
&quot;false&quot; (&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>&quot;if
(check_business_date($year,$week,$dow))&quot;</tt></p> </td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns &quot;true&quot; (&quot;<tt>1</tt>&quot;) if the
given three numerical values &quot;<tt>$year</tt>&quot;,
&quot;<tt>$week</tt>&quot; and &quot;<tt>$dow</tt>&quot;
constitute a valid date in business format, and
&quot;false&quot; (&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em"><b>Beware</b>
that this function does <b><small>NOT</small></b> compute
whether a given date is a business day (i.e., Monday to
Friday)!</p>

<p style="margin-left:14%; margin-top: 1em">To do so, use
&quot;<tt>&quot;(Day_of_Week($year,$month,$day) &lt;
6)&quot;</tt>&quot; instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em"><tt>&quot;$doy =
Day_of_Year($year,$month,$day);&quot;</tt></p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the (relative) number of the day of the given date
in the given year.</p>

<p style="margin-left:14%; margin-top: 1em">E.g.,
&quot;<tt>&quot;Day_of_Year($year,1,1)&quot;</tt>&quot;
returns &quot;<tt>1</tt>&quot;,
&quot;<tt>&quot;Day_of_Year($year,2,1)&quot;</tt>&quot;
returns &quot;<tt>32</tt>&quot;, and
&quot;<tt>&quot;Day_of_Year($year,12,31)&quot;</tt>&quot;
returns either &quot;<tt>365</tt>&quot; or
&quot;<tt>366</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The day of year
is sometimes also referred to as the Julian day (or date),
although it has nothing to do with the Julian calendar, the
calendar which was used before the Gregorian calendar.</p>

<p style="margin-left:14%; margin-top: 1em">In order to
convert the number returned by this function back into a
date, use the function
&quot;<tt>&quot;Add_Delta_Days()&quot;</tt>&quot; (described
further below), as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  $doy = Day_of_Year($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days($year,1,1, $doy &minus; 1);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em"><tt>&quot;$days =
Date_to_Days($year,$month,$day);&quot;</tt></p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the (absolute) number of the day of the given date,
where counting starts at the 1st of January of the year
1&nbsp;A.D.</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,
&quot;<tt>&quot;Date_to_Days(1,1,1)&quot;</tt>&quot; returns
&quot;<tt>1</tt>&quot;,
&quot;<tt>&quot;Date_to_Days(1,12,31)&quot;</tt>&quot;
returns &quot;<tt>365</tt>&quot;,
&quot;<tt>&quot;Date_to_Days(2,1,1)&quot;</tt>&quot; returns
&quot;<tt>366</tt>&quot;,
&quot;<tt>&quot;Date_to_Days(1998,5,1)&quot;</tt>&quot;
returns &quot;<tt>729510</tt>&quot;, and so on.</p>

<p style="margin-left:14%; margin-top: 1em">This is
sometimes also referred to (not quite correctly) as the
Julian date (or day). This may cause confusion, because also
the number of the day in a year (from 1 to 365 or 366) is
frequently called the &quot;Julian day&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">More confusing
still, this has nothing to do with the Julian calendar,
which was used <b><small>BEFORE</small></b> the Gregorian
calendar.</p>

<p style="margin-left:14%; margin-top: 1em">The Julian
calendar was named after famous Julius Caesar, who had
instituted it in Roman times. The Julian calendar is less
precise than the Gregorian calendar because it has too many
leap years compared to the true mean length of a year (but
the Gregorian calendar also still has one day too much every
5000 years). Anyway, the Julian calendar was better than
what existed before, because rulers had often changed the
calendar used until then in arbitrary ways, in order to
lengthen their own reign, for instance.</p>

<p style="margin-left:14%; margin-top: 1em">In order to
convert the number returned by this function back into a
date, use the function
&quot;<tt>&quot;Add_Delta_Days()&quot;</tt>&quot; (described
further below), as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  $days = Date_to_Days($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days(1,1,1, $days &minus; 1);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em"><tt>&quot;$dow =
Day_of_Week($year,$month,$day);&quot;</tt></p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the number of the day of week of the given date.</p>

<p style="margin-left:14%; margin-top: 1em">The function
returns &quot;<tt>1</tt>&quot; for Monday,
&quot;<tt>2</tt>&quot; for Tuesday and so on until
&quot;<tt>7</tt>&quot; for Sunday.</p>

<p style="margin-left:14%; margin-top: 1em">Note that in
the Hebrew calendar (on which the Christian calendar is
based), the week starts with Sunday and ends with the
Sabbath or Saturday (where according to the Genesis (as
described in the Bible) the Lord rested from creating the
world).</p>

<p style="margin-left:14%; margin-top: 1em">In medieval
times, Catholic Popes have decreed the Sunday to be the
official day of rest, in order to dissociate the Christian
from the Hebrew belief.</p>

<p style="margin-left:14%; margin-top: 1em">It appears that
this actually happened with the Emperor Constantin, who
converted to Christianity but still worshipped the Sun god
and therefore moved the Christian sabbath to the day of the
Sun.</p>

<p style="margin-left:14%; margin-top: 1em">Nowadays, the
Sunday <b><small>AND</small></b> the Saturday are commonly
considered (and used as) days of rest, usually referred to
as the &quot;week-end&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Consistent with
this practice, current norms and standards (such as
<small>ISO/R&nbsp;</small> 2015&minus;1971,
<small>DIN&nbsp;</small> 1355 and <small>ISO&nbsp;</small>
8601) define the Monday as the first day of the week.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em"><tt>&quot;$week =
Week_Number($year,$month,$day);&quot;</tt></p> </td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the number of the week the given date lies in.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
date lies in the <b><small>LAST</small></b> week of the
<b><small>PREVIOUS</small></b> year, &quot;<tt>0</tt>&quot;
is returned.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
date lies in the <b><small>FIRST</small></b> week of the
<b><small>NEXT</small></b> year,
&quot;<tt>&quot;Weeks_in_Year($year) + 1&quot;</tt>&quot; is
returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="77%">


<p style="margin-top: 1em"><tt>&quot;($week,$year) =
Week_of_Year($year,$month,$day);&quot;</tt></p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the number of the week the given date lies in, as
well as the year that week belongs to.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., if the
given date lies in the <b><small>LAST</small></b> week of
the <b><small>PREVIOUS</small></b> year,
&quot;<tt>&quot;(Weeks_in_Year($year&minus;1),
$year&minus;1)&quot;</tt>&quot; is returned.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
date lies in the <b><small>FIRST</small></b> week of the
<b><small>NEXT</small></b> year, &quot;<tt>&quot;(1,
$year+1)&quot;</tt>&quot; is returned.</p>

<p style="margin-left:14%; margin-top: 1em">Otherwise,
&quot;<tt>&quot;(Week_Number($year,$month,$day),
$year)&quot;</tt>&quot; is returned.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em"><tt>&quot;$week =
Week_of_Year($year,$month,$day);&quot;</tt></p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">In scalar
context, this function returns just the week number. This
allows you to write &quot;<tt>&quot;$week =
Week_of_Year($year,$month,$day);&quot;</tt>&quot; instead of
&quot;<tt>&quot;($week) =
Week_of_Year($year,$month,$day);&quot;</tt>&quot; (note the
parentheses around &quot;<tt>$week</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">If the given
date lies in the <b><small>LAST</small></b> week of the
<b><small>PREVIOUS</small></b> year,
&quot;<tt>&quot;Weeks_in_Year($year&minus;1)&quot;</tt>&quot;
is returned.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
date lies in the <b><small>FIRST</small></b> week of the
<b><small>NEXT</small></b> year, &quot;<tt>1</tt>&quot; is
returned.</p>

<p style="margin-left:14%; margin-top: 1em">Otherwise the
return value is identical with that of
&quot;<tt>&quot;Week_Number($year,$month,$day)&quot;</tt>&quot;.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that using this function in scalar context is a
<b><small>DANGEROUS</small></b> feature, because without
knowing which year the week belongs to, you might
inadvertently assume the wrong one!</p>

<p style="margin-left:14%; margin-top: 1em">If for instance
you are iterating through an interval of dates, you might
assume that the week always belongs to the same year as the
given date, which unfortunately is
<b><small>WRONG</small></b> in some cases!</p>

<p style="margin-left:14%; margin-top: 1em">In many years,
the 31st of December for instance belongs to week number one
of the <b><small>FOLLOWING</small></b> year. Assuming that
the year is the same as your date (31st of December, in this
example), sends you back to the first week of the
<b><small>CURRENT</small></b> year &minus; the Monday of
which, by the way, in case of bad luck, might actually lie
in the year <b><small>BEFORE</small></b> the current
year!</p>

<p style="margin-left:14%; margin-top: 1em">This actually
happens in 2002, for example.</p>

<p style="margin-left:14%; margin-top: 1em">So you always
need to provide the correct corresponding year number by
other means, keeping track of it yourself.</p>

<p style="margin-left:14%; margin-top: 1em">In case you do
not understand this, never mind, but then simply
<b><small>DO NOT USE</small></b> this function in scalar
context!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Monday_of_Week($week,$year);&quot;</tt></p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the date of the first day of the given week, i.e.,
the Monday.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$year</tt>&quot;
must be greater than or equal to &quot;<tt>1</tt>&quot;, and
&quot;<tt>$week</tt>&quot; must lie in the range
&quot;<tt>1</tt>&quot; to
&quot;<tt>&quot;Weeks_in_Year($year)&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
can write &quot;<tt>&quot;($year,$month,$day) =
Monday_of_Week(Week_of_Year($year,$month,$day));&quot;</tt>&quot;
in order to calculate the date of the Monday of the same
week as the given date.</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
calculate any other day of week in the same week as a given
date, use</p>

<pre style="margin-left:14%; margin-top: 1em">  @date = Add_Delta_Days(Monday_of_Week(Week_of_Year(@date)),$offset);</pre>


<p style="margin-left:14%; margin-top: 1em">where
<tt>&quot;$offset = 1&quot;</tt> for Tuesday, <tt>2</tt> for
Wednesday etc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Nth_Weekday_of_Month_Year($year,$month,$dow,$n))&quot;</tt></p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
calculates the date of the &quot;<tt>$n</tt>&quot;th day of
week &quot;<tt>$dow</tt>&quot; in the given month
&quot;<tt>$month</tt>&quot; and year
&quot;<tt>$year</tt>&quot;; such as, for example, the 3rd
Thursday of a given month and year.</p>

<p style="margin-left:14%; margin-top: 1em">This can be
used to send a notification mail to the members of a group
which meets regularly on every 3rd Thursday of a month, for
instance.</p>

<p style="margin-left:14%; margin-top: 1em">(See the
section &quot; <small>RECIPES&quot;</small> near the end of
this document for a code snippet to actually do so.)</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$year</tt>&quot;
must be greater than or equal to &quot;<tt>1</tt>&quot;,
&quot;<tt>$month</tt>&quot; must lie in the range
&quot;<tt>1</tt>&quot; to &quot;<tt>12</tt>&quot;,
&quot;<tt>$dow</tt>&quot; must lie in the range
&quot;<tt>1</tt>&quot; to &quot;<tt>7</tt>&quot; and
&quot;<tt>$n</tt>&quot; must lie in the range
&quot;<tt>1</tt>&quot; to &quot;<tt>5</tt>&quot;, or a fatal
error (with appropriate error message) occurs.</p>

<p style="margin-left:14%; margin-top: 1em">The function
returns an empty list when the 5th of a given day of week
does not exist in the given month and year.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$week,$dow) =
Standard_to_Business($year,$month,$day);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
converts a given date from standard notation (year, month,
day (of month)) to business notation (year, week, day of
week).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Business_to_Standard($year,$week,$dow);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
converts a given date from business notation (year, week,
day of week) to standard notation (year, month, day (of
month)).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;$Dd =
Delta_Days($year1,$month1,$day1,
$year2,$month2,$day2);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the difference in days between the two given
dates.</p>

<p style="margin-left:14%; margin-top: 1em">The result is
positive if the two dates are in chronological order, i.e.,
if date #1 comes chronologically
<b><small>BEFORE</small></b> date #2, and negative if the
order of the two dates is reversed.</p>

<p style="margin-left:14%; margin-top: 1em">The result is
zero if the two dates are identical.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($Dd,$Dh,$Dm,$Ds) =
Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
$year2,$month2,$day2, $hour2,$min2,$sec2);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the difference in days, hours, minutes and seconds
between the two given dates with times.</p>

<p style="margin-left:14%; margin-top: 1em">All four return
values will be positive if the two dates are in
chronological order, i.e., if date #1 comes chronologically
<b><small>BEFORE</small></b> date #2, and negative (in all
four return values!) if the order of the two dates is
reversed.</p>

<p style="margin-left:14%; margin-top: 1em">This is so that
the two functions
&quot;<tt>&quot;Delta_DHMS()&quot;</tt>&quot; and
&quot;<tt>&quot;Add_Delta_DHMS()&quot;</tt>&quot;
(description see further below) are complementary, i.e.,
mutually inverse:</p>

<pre style="margin-left:14%; margin-top: 1em">  Add_Delta_DHMS(@date1,@time1, Delta_DHMS(@date1,@time1, @date2,@time2))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>&quot;(@date2,@time2)&quot;</tt>&quot; again,
whereas</p>

<pre style="margin-left:14%; margin-top: 1em">  Add_Delta_DHMS(@date2,@time2,
      map(&minus;$_, Delta_DHMS(@date1,@time1, @date2,@time2)))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>&quot;(@date1,@time1)&quot;</tt>&quot;, and</p>

<pre style="margin-left:14%; margin-top: 1em">  Delta_DHMS(@date1,@time1, Add_Delta_DHMS(@date1,@time1, @delta))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>@delta</tt>&quot; again.</p>

<p style="margin-left:14%; margin-top: 1em">The result is
zero (in all four return values) if the two dates and times
are identical.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p style="margin-top: 1em"><tt>&quot;($Dy,$Dm,$Dd) =
Delta_YMD($year1,$month1,$day1,
$year2,$month2,$day2);&quot;</tt></p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the vector</p>

<pre style="margin-left:14%; margin-top: 1em">    ( $year2 &minus; $year1, $month2 &minus; $month1, $day2 &minus; $day1 )</pre>


<p style="margin-left:14%; margin-top: 1em">This is called
the &quot;one-by-one&quot; semantics.</p>

<p style="margin-left:14%; margin-top: 1em">Adding the
result of this function to the first date always yields the
second date again, and adding the negative result (where the
signs of all elements of the result vector have been
flipped) to the second date gives the first date. See also
the description of the function
&quot;<i>Add_Delta_YMD()</i>&quot; further below.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  (6,2,&minus;30) == Delta_YMD(1996,1,31, 2002,3,1]);
  [1996,1,31] + ( 6, 2,&minus;30) = [2002,3, 1]
  [2002,3, 1] + (&minus;6,&minus;2, 30) = [1996,1,31]</pre>


<p style="margin-left:14%; margin-top: 1em">An error occurs
if any of the two given dates is invalid.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($D_y,$D_m,$D_d,
$Dh,$Dm,$Ds) = Delta_YMDHMS($year1,$month1,$day1,
$hour1,$min1,$sec1, $year2,$month2,$day2,
$hour2,$min2,$sec2);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is based on the function &quot;<i>Delta_YMD()</i>&quot;
above but additionally calculates the time difference. When
a carry over from the time difference occurs, the value of
&quot;<tt>$D_d</tt>&quot; is adjusted accordingly, thus
giving the correct total date/time difference.</p>

<p style="margin-left:14%; margin-top: 1em">Arguments are
expected to be in chronological order to yield a (usually)
positive result.</p>

<p style="margin-left:14%; margin-top: 1em">In any case,
adding the result of this function to the first date/time
value (<tt>&quot;$year1,$month1,$day1,&quot;
&quot;$hour1,$min1,$sec1&quot;</tt>) always gives the second
date/time value (<tt>&quot;$year2,$month2,$day2,&quot;
&quot;$hour2,$min2,$sec2&quot;</tt>) again, and adding the
negative result (with the signs of all elements of the
result vector flipped) to the second date/time value gives
the first date/time value.</p>

<p style="margin-left:14%; margin-top: 1em">See the
function &quot;<i>Add_Delta_YMDHMS()</i>&quot; further below
for adding a date/time value and a date/time difference.</p>

<p style="margin-left:14%; margin-top: 1em">An error occurs
if any of the given two date/time values is invalid.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="77%">


<p style="margin-top: 1em"><tt>&quot;($Dy,$Dm,$Dd) =
N_Delta_YMD($year1,$month1,$day1,
$year2,$month2,$day2);&quot;</tt></p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the difference between the two given dates in a more
intuitive way (as far as possible &minus; more on that see a
bit further below) than the function
&quot;<i>Delta_YMD()</i>&quot; described above.</p>

<p style="margin-left:14%; margin-top: 1em">The
&quot;N&quot; which precedes its name is meant to signify
&quot;new&quot; or &quot;normalized&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This function
is loosely based on recipe #17 b) (see the section &quot;
<small>RECIPES&quot;</small> below near the end of this
document).</p>

<p style="margin-left:14%; margin-top: 1em">However, the
code of recipe #17 b) actually does not treat positive and
negative values symmetrically and consistently.</p>

<p style="margin-left:14%; margin-top: 1em">This new
routine does.</p>

<p style="margin-left:14%; margin-top: 1em">The return
values of this function are guaranteed to all have the same
sign (or to be zero). This is why this function is called
&quot;normalized&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, the
results are guaranteed to be &quot;minimal&quot;, in the
sense that <tt>&quot;|$Dm| &lt; 12&quot;</tt> and
<tt>&quot;|$Dd| &lt; 31&quot;</tt> (which is equivalent to
<tt>$Dm</tt> lying in the range
<tt>&quot;[&minus;11..+11]&quot;</tt> and <tt>$Dd</tt> lying
in the range <tt>&quot;[&minus;30..+30]&quot;</tt>).</p>

<p style="margin-left:14%; margin-top: 1em">When the
results are applied (i.e., added) to the first given date in
a left-to-right order, the second given date is guaranteed
to be obtained, provided that intermediary results are
truncated, as done by the function
&quot;<i>Add_Delta_YM()</i>&quot; (see further below), i.e.,
that invalid intermediate dates such as e.g. [2009,2,31]
will automatically be transformed into [2009,2,28] (and not
&quot;wrapped&quot; into the next month, e.g. to
[2009,3,3]).</p>

<p style="margin-left:14%; margin-top: 1em">This is called
the &quot;left-to-right with truncation&quot; semantics.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
reversing the order of the given dates and reversing the
sign of each of the result values will not always add
up.</p>

<p style="margin-left:14%; margin-top: 1em">Consider the
dates [2008,2,29] and [2009,2,1]: their difference is
(0,11,3) ([2008,2,29] plus 11 months is [2009,1,29], which
plus 3 days is [2009,2,1]), but the difference between
[2009,2,1] and [2008,2,29] is (0,&minus;11,&minus;1), and
not (0,&minus;11,&minus;3) ([2009,2,1] minus 11 months is
[2008,3,1], which minus one day is [2008,2,29]).</p>

<p style="margin-left:14%; margin-top: 1em">Another
example: The difference between [1996,2,29] and [1997,2,28]
is (1,0,0) (observe the truncation of the invalid date
[1997,2,29] to [1997,2,28] here!), whereas the difference
between [1997,2,28] and [1996,2,29] is
(0,&minus;11,&minus;28) ([1997,2,28] minus 11 months is
[1996,3,28], which minus 28 days is not [1996,3,0] but of
course [1996,2,29]).</p>


<p style="margin-left:14%; margin-top: 1em">&quot;Benign&quot;
examples such as for instance the difference between
[1964,1,3] and [2009,9,10] are completely symmetrical: The
difference in this example is (45,8,7), whereas the
difference between [2009,9,10] and [1964,1,3] is
(&minus;45,&minus;8,&minus;7), as would normally be
expected. In this example, the result is also the same as
the one returned by &quot;<i>Delta_YMD()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">All these
counter-intuitive effects are due to the fact that months
(and due to leap years, also years) do not correspond to a
fixed number of days, so the semantics of &quot;plus one
month&quot; or &quot;plus one year&quot; are in fact
undefined.</p>

<p style="margin-left:14%; margin-top: 1em">The present
function is an attempt to provide a definition which is
intuitive most of the time, and at least consistent the rest
of the time.</p>

<p style="margin-left:14%; margin-top: 1em">Other
definitions are of course possible, but most often lead to
contradictions (e.g., the results and the given first date
do not add up to the second given date).</p>

<p style="margin-left:14%; margin-top: 1em">See the file
&quot;datecalc.pl&quot; in the &quot;examples&quot;
subdirectory of this distribution for a way to play around
with this function, or go to
http://www.engelschall.com/u/sb/datecalc/ for the online
version.</p>

<p style="margin-left:14%; margin-top: 1em">An error occurs
if any of the two given dates is invalid, or if any
intermediate result leads to an invalid date (this does not
apply to truncation, however, as explained above).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($D_y,$D_m,$D_d,
$Dhh,$Dmm,$Dss) = N_Delta_YMDHMS($year1,$month1,$day1,
$hour1,$min1,$sec1, $year2,$month2,$day2,
$hour2,$min2,$sec2);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
essentially does the same as the function
&quot;<i>N_Delta_YMD()</i>&quot; described immediately
above, except that also the difference in hours, minutes and
seconds is taken into account.</p>

<p style="margin-left:14%; margin-top: 1em">This function
is loosely based on recipe #17 a) (see the section &quot;
<small>RECIPES&quot;</small> below near the end of this
document).</p>

<p style="margin-left:14%; margin-top: 1em">However, the
code of recipe #17 a) actually does not treat positive and
negative values symmetrically and consistently.</p>

<p style="margin-left:14%; margin-top: 1em">This new
routine does.</p>

<p style="margin-left:14%; margin-top: 1em">The return
values of this function (including the time differences) are
guaranteed to all have the same sign (or to be zero). This
is the reason for the &quot;N&quot; that precedes the name
of this function, which is intended to mean
&quot;normalized&quot; (or &quot;new&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, the
results are guaranteed to be &quot;minimal&quot;, in the
sense that <tt>&quot;|$D_m| &lt; 12&quot;</tt>,
<tt>&quot;|$D_d| &lt; 31&quot;</tt>, <tt>&quot;|$Dhh| &lt;
24&quot;</tt>, <tt>&quot;|$Dmm| &lt; 60&quot;</tt> and
<tt>&quot;|$Dss| &lt; 60&quot;</tt> (which is equivalent to
<tt>$D_m</tt> lying in the range
<tt>&quot;[&minus;11..+11]&quot;</tt>, <tt>$D_d</tt> lying
in the range <tt>&quot;[&minus;30..+30]&quot;</tt>,
<tt>$Dhh</tt> lying in the range
<tt>&quot;[&minus;23..+23]&quot;</tt>, and <tt>$Dmm</tt> and
<tt>$Dss</tt> both lying in the range
<tt>&quot;[&minus;59..+59]&quot;</tt>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;($Dd,$Dh,$Dm,$Ds) =
Normalize_DHMS($Dd,$Dh,$Dm,$Ds);&quot;</tt></p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
takes four arbitrary values for days, hours, minutes and
seconds (which may have different signs) and renormalizes
them so that the values for hours, minutes and seconds will
lie in the ranges <tt>&quot;[&minus;23..23]&quot;</tt>,
<tt>&quot;[&minus;59..59]&quot;</tt> and
<tt>&quot;[&minus;59..59]&quot;</tt>, respectively, and so
that all four values have the same sign (or are zero).</p>

<p style="margin-left:14%; margin-top: 1em">The given
values are left untouched, i.e., unchanged.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Add_Delta_Days($year,$month,$day, $Dd);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
has two principal uses:</p>

<p style="margin-left:14%; margin-top: 1em">First, it can
be used to calculate a new date, given an initial date and
an offset (which may be positive or negative) in days, in
order to answer questions like &quot;today plus 90 days --
which date gives that?&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">(In order to
add a weeks offset, simply multiply the weeks offset with
&quot;<tt>7</tt>&quot; and use that as your days
offset.)</p>

<p style="margin-left:14%; margin-top: 1em">Second, it can
be used to convert the canonical representation of a date,
i.e., the number of that day (where counting starts at the
1st of January in 1&nbsp;A.D.), back into a date given as
year, month and day.</p>

<p style="margin-left:14%; margin-top: 1em">Because
counting starts at &quot;<tt>1</tt>&quot;, you will actually
have to subtract &quot;<tt>1</tt>&quot; from the canonical
date in order to get back the original date:</p>

<pre style="margin-left:14%; margin-top: 1em">  $canonical = Date_to_Days($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days(1,1,1, $canonical &minus; 1);</pre>


<p style="margin-left:14%; margin-top: 1em">Moreover, this
function is the inverse of the function
&quot;<tt>&quot;Delta_Days()&quot;</tt>&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  Add_Delta_Days(@date1, Delta_Days(@date1, @date2))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>@date2</tt>&quot; again, whereas</p>

<pre style="margin-left:14%; margin-top: 1em">  Add_Delta_Days(@date2, &minus;Delta_Days(@date1, @date2))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>@date1</tt>&quot;, and</p>

<pre style="margin-left:14%; margin-top: 1em">  Delta_Days(@date1, Add_Delta_Days(@date1, $delta))</pre>


<p style="margin-left:14%; margin-top: 1em">yields
&quot;<tt>$delta</tt>&quot; again.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec) = Add_Delta_DHMS($year,$month,$day,
$hour,$min,$sec, $Dd,$Dh,$Dm,$Ds);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
serves to add a days, hours, minutes and seconds offset to a
given date and time, in order to answer questions like
&quot;today and now plus 7 days but minus 5 hours and then
plus 30 minutes, what date and time gives that?&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  ($y,$m,$d,$H,$M,$S) = Add_Delta_DHMS(Today_and_Now(), +7,&minus;5,+30,0);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Add_Delta_YM($year,$month,$day, $Dy,$Dm);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
can be used to add a year and/or month offset to a given
date.</p>

<p style="margin-left:14%; margin-top: 1em">In contrast to
the function described immediately below
(&quot;<tt>&quot;Add_Delta_YMD()&quot;</tt>&quot;), this
function does no &quot;wrapping&quot; into the next month if
the day happens to lie outside the valid range for the
resulting year and month (after adding the year and month
offsets). Instead, it simply truncates the day to the last
possible day of the resulting month.</p>

<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<p style="margin-left:14%; margin-top: 1em">Adding an
offset of 0 years, 1 month to the date [1999,1,31] would
result in the (invalid) date [1999,2,31]. The function
replaces this result by the (valid) date [1999,2,28].</p>

<p style="margin-left:14%; margin-top: 1em">Adding an
offset of 1 year, 1 month to the same date [1999,1,31] as
above would result in the (still invalid) date [2000,2,31].
The function replaces this result by the valid date
[2000,2,29] (because 2000 is a leap year).</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
year and month offsets can be negative, and that they can
have different signs.</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
additionally add a days offset, use the function
&quot;<tt>&quot;Add_Delta_Days()&quot;</tt>&quot; before or
after calling
&quot;<tt>&quot;Add_Delta_YM()&quot;</tt>&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  @date2 = Add_Delta_Days( Add_Delta_YM(@date1, $Dy,$Dm), $Dd );
  @date2 = Add_Delta_YM( Add_Delta_Days(@date1, $Dd), $Dy,$Dm );</pre>


<p style="margin-left:14%; margin-top: 1em">Note that your
result may depend on the order in which you call these two
functions!</p>

<p style="margin-left:14%; margin-top: 1em">Consider the
date [1999,2,28] and the offsets 0 years, 1 month and 1
day:</p>

<p style="margin-left:14%; margin-top: 1em">[1999,2,28]
plus one month is [1999,3,28], plus one day is [1999,3,29].
[1999,2,28] plus one day is [1999,3,1], plus one month is
[1999,4,1].</p>

<p style="margin-left:14%; margin-top: 1em">(Which is also
the reason why the
&quot;<tt>&quot;Add_Delta_YM()&quot;</tt>&quot; function
does not allow to add a days offset, because this would
actually require <small>TWO</small> functions: One for
adding the days offset <small>BEFORE</small> and one for
adding it <small>AFTER</small> applying the year/month
offsets.)</p>

<p style="margin-left:14%; margin-top: 1em">An error occurs
if the initial date is not valid.</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;<tt>&quot;Add_Delta_YM( Add_Delta_YM(@date, $Dy,$Dm),
&minus;$Dy,&minus;$Dm );&quot;</tt>&quot; will not, in
general, return the original date &quot;<tt>@date</tt>&quot;
(consider the examples given above!).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Add_Delta_YMD($year,$month,$day,
$Dy,$Dm,$Dd);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
serves to add a years, months and days offset to a given
date.</p>

<p style="margin-left:14%; margin-top: 1em">(In order to
add a weeks offset, simply multiply the weeks offset with
&quot;<tt>7</tt>&quot; and add this number to your days
offset.)</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
three offsets for years, months and days are applied
independently from each other. This also allows them to have
different signs.</p>

<p style="margin-left:14%; margin-top: 1em">The years and
months offsets are applied first, and the days offset is
applied last.</p>

<p style="margin-left:14%; margin-top: 1em">If the
resulting date happens to fall on a day after the end of the
resulting month, like the 32nd of April or the 30th of
February, then the date is simply counted forward into the
next month (possibly also into the next year) by the number
of excessive days (e.g., the 32nd of April will become the
2nd of May).</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that this behaviour differs from that of previous versions
of this module! In previous versions, the day was simply
truncated to the maximum number of days in the resulting
month.</p>

<p style="margin-left:14%; margin-top: 1em">If you want the
previous behaviour, use the new function
&quot;<tt>&quot;Add_Delta_YM()&quot;</tt>&quot; (described
immediately above) plus the function
&quot;<tt>&quot;Add_Delta_Days()&quot;</tt>&quot;
instead.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
also that because a year and a month offset is not
equivalent to a fixed number of days, the transformation
performed by this function is <b><small>NOT ALWAYS
REVERSIBLE</small></b> !</p>

<p style="margin-left:14%; margin-top: 1em">This is in
contrast to the functions
&quot;<tt>&quot;Add_Delta_Days()&quot;</tt>&quot; and
&quot;<tt>&quot;Add_Delta_DHMS()&quot;</tt>&quot;, which are
fully and truly reversible (with the help of the functions
&quot;<tt>&quot;Delta_Days()&quot;</tt>&quot; and
&quot;<tt>&quot;Delta_DHMS()&quot;</tt>&quot;, for
instance).</p>

<p style="margin-left:14%; margin-top: 1em">Note that for
this same reason,</p>

<pre style="margin-left:14%; margin-top: 1em">  @date = Add_Delta_YMD(
          Add_Delta_YMD(@date, $Dy,$Dm,$Dd), &minus;$Dy,&minus;$Dm,&minus;$Dd);</pre>


<p style="margin-left:14%; margin-top: 1em">will in general
<b><small>NOT</small></b> return the initial date
&quot;<tt>@date</tt>&quot;, even though</p>

<pre style="margin-left:14%; margin-top: 1em">  @date2 = Add_Delta_YMD( @date1, Delta_YMD(@date1, @date2) );</pre>


<p style="margin-left:14%; margin-top: 1em">will always
return the second date &quot;<tt>@date2</tt>&quot;, and</p>

<pre style="margin-left:14%; margin-top: 1em">  @date1 = Add_Delta_YMD( @date2, map(&minus;$_, Delta_YMD(@date1, @date2)) );</pre>


<p style="margin-left:14%; margin-top: 1em">which is the
same as</p>

<pre style="margin-left:14%; margin-top: 1em">  @date1 = Add_Delta_YMD( @date2, Delta_YMD(@date2, @date1) );</pre>


<p style="margin-left:14%; margin-top: 1em">will always
return the first date &quot;<tt>@date1</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<pre style="margin-left:14%; margin-top: 1em">  [1996,1,31] + ( 6, 1,&minus;2) = [2002,3,1]
  [2002,3, 1] + (&minus;6,&minus;1, 2) = [1996,2,3] # EXPECTED: [1996,1,31]
  (6,2,&minus;30) == Delta_YMD(1996,1,31, 2002,3,1);
  [1996,1,31] + ( 6, 2,&minus;30) = [2002,3, 1]
  [2002,3, 1] + (&minus;6,&minus;2, 30) = [1996,1,31] # OK
  (6,1,&minus;2) == Delta_YMD(1996,2,3, 2002,3,1);
  [1996,2,3] + ( 6, 1,&minus;2) = [2002,3,1]
  [2002,3,1] + (&minus;6,&minus;1, 2) = [1996,2,3] # OK</pre>


<p style="margin-left:14%; margin-top: 1em">Note that this
is <b><small>NOT</small></b> a program bug but
<b><small>NECESSARILY</small></b> so, because of the
variable lengths of years and months, and hence because of
the ambiguity of the difference between two dates in terms
of years, months and days, i.e., the fact that the
difference between two dates can be expressed in more than
one way:</p>

<pre style="margin-left:14%; margin-top: 1em">  [1996,1,31] + (6,1, &minus;2) = [2002,3,1]
  [1996,1,31] + (6,2,&minus;30) = [2002,3,1]</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec) = Add_Delta_YMDHMS($year,$month,$day,
$hour,$min,$sec, $D_y,$D_m,$D_d,
$Dh,$Dm,$Ds);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Same as the
function above, except that a time offset may be given in
addition to the year, month and day offset.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Add_N_Delta_YMD($year,$month,$day,
$Dy,$Dm,$Dd);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is actually a shortcut for applying the function
&quot;<i>Add_Delta_YM()</i>&quot; first, followed by the
function &quot;<i>Add_Delta_Days()</i>&quot;, i.e., this
function does exactly the same as</p>

<pre style="margin-left:14%; margin-top: 1em"> ($year,$month,$day) = Add_Delta_Days( Add_Delta_YM($year,$month,$day,$Dy,$Dm), $Dd );</pre>


<p style="margin-left:14%; margin-top: 1em">Beware that, if
necessary, the function &quot;<i>Add_Delta_YM()</i>&quot;
truncates the resulting day of the month to the largest
allowable value for that month, i.e., the (invalid) result
[2009,2,31] is automatically transformed into
[2009,2,28].</p>

<p style="margin-left:14%; margin-top: 1em">For more
details on this truncation, see the description of the
function &quot;<i>Add_Delta_YM()</i>&quot; further
above.</p>

<p style="margin-left:14%; margin-top: 1em">This function
is meant to be complementary with the function
&quot;<i>N_Delta_YMD()</i>&quot; described further
above.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
it is guaranteed that the result returned by</p>

<pre style="margin-left:14%; margin-top: 1em">  Add_N_Delta_YMD( @date1, N_Delta_YMD(@date1, @date2) );</pre>


<p style="margin-left:14%; margin-top: 1em">is always
identical with the given date
&quot;<tt>@date2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that unlike with function
&quot;<i>Add_Delta_YMD()</i>&quot;, the reverse is not true
here, i.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">  ($Dy,$Dm,$Dd) = N_Delta_YMD(@date1,@date2);
  @date = Add_N_Delta_YMD(@date2, &minus;$Dy,&minus;$Dm,&minus;$Dd);</pre>


<p style="margin-left:14%; margin-top: 1em">will
<b><small>NOT</small></b> always return the initial date
&quot;<tt>@date1</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  (0,11,3) == N_Delta_YMD(2008,2,29, 2009,2,1);
  [2008,2,29] + (0, 11, 3) = [2009,2, 1]
  [2009,2, 1] + (0,&minus;11,&minus;3) = [2008,2,27] # EXPECTED: [2008,2,29]</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec) = Add_N_Delta_YMDHMS($year,$month,$day,
$hour,$min,$sec, $D_y,$D_m,$D_d,
$Dhh,$Dmm,$Dss);&quot;</tt></p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
essentially does the same as the function
&quot;<i>Add_N_Delta_YMD()</i>&quot; described immediately
above, except that also the difference in hours, minutes and
seconds is taken into account.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec, $doy,$dow,$dst) =
System_Clock([$gmt]);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">If your
operating system supports the corresponding system calls
(&quot;<tt>&quot;time()&quot;</tt>&quot; and
&quot;<tt>&quot;localtime()&quot;</tt>&quot; or
&quot;<tt>&quot;gmtime()&quot;</tt>&quot;), this function
will return the information provided by your system clock,
i.e., the current date and time, the number of the day of
year, the number of the day of week and a flag signaling
whether daylight savings time is currently in effect or
not.</p>

<p style="margin-left:14%; margin-top: 1em">The ranges of
values returned (and their meanings) are as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59    (0..61 on some systems)
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  &minus;1..1</pre>



<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$doy</tt>&quot;
is the day of year, sometimes also referred to as the
&quot;julian date&quot;, which starts at
&quot;<tt>1</tt>&quot; and goes up to the number of days in
that year.</p>

<p style="margin-left:14%; margin-top: 1em">The day of week
(&quot;<tt>$dow</tt>&quot;) will be &quot;<tt>1</tt>&quot;
for Monday, &quot;<tt>2</tt>&quot; for Tuesday and so on
until &quot;<tt>7</tt>&quot; for Sunday.</p>

<p style="margin-left:14%; margin-top: 1em">The daylight
savings time flag (&quot;<tt>$dst</tt>&quot;) will be
&quot;<tt>&quot;&minus;1&quot;</tt>&quot; if this
information is not available on your system,
&quot;<tt>0</tt>&quot; for no daylight savings time (i.e.,
winter time) and &quot;<tt>1</tt>&quot; when daylight
savings time is in effect.</p>

<p style="margin-left:14%; margin-top: 1em">If your
operating system does not provide the necessary system
calls, calling this function will result in a fatal
&quot;not available on this system&quot; error message.</p>

<p style="margin-left:14%; margin-top: 1em">If you want to
handle this exception yourself, use
&quot;<tt>&quot;eval&quot;</tt>&quot; as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  eval { ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
    System_Clock(); };
  if ($@)
  {
      # Handle missing system clock
      # (For instance, ask user to enter this information manually)
  }</pre>


<p style="margin-left:14%; margin-top: 1em">Note that
curlies (&quot;{&quot; and &quot;}&quot;) are used here to
delimit the statement to be &quot;eval&quot;ed (which is the
way to catch exceptions in Perl), and not quotes (which is a
way to evaluate Perl expressions at runtime).</p>

<p style="margin-left:14%; margin-top: 1em">If the optional
(boolean) input parameter &quot;<tt>$gmt</tt>&quot; is
given, a &quot;true&quot; value (&quot;<tt>1</tt>&quot;)
will cause &quot;<tt>&quot;gmtime()&quot;</tt>&quot; to be
used instead of
&quot;<tt>&quot;localtime()&quot;</tt>&quot;, internally,
thus returning Greenwich Mean Time ( <small>GMT,</small> or
<small>UTC</small> ) instead of local time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Today([$gmt]);&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a subset of the values returned by the function
&quot;<tt>&quot;System_Clock()&quot;</tt>&quot; (see above
for details), namely the current year, month and day.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;not available on this system&quot; error message will
appear if the corresponding system calls are not supported
by your current operating system.</p>

<p style="margin-left:14%; margin-top: 1em">If the optional
(boolean) input parameter &quot;<tt>$gmt</tt>&quot; is
given, a &quot;true&quot; value (&quot;<tt>1</tt>&quot;)
will cause &quot;<tt>&quot;gmtime()&quot;</tt>&quot; to be
used instead of
&quot;<tt>&quot;localtime()&quot;</tt>&quot;, internally,
thus returning Greenwich Mean Time ( <small>GMT,</small> or
<small>UTC</small> ) instead of local time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>&quot;($hour,$min,$sec) =
Now([$gmt]);&quot;</tt></p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a subset of the values returned by the function
&quot;<tt>&quot;System_Clock()&quot;</tt>&quot; (see above
for details), namely the current time (hours, minutes and
full seconds).</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;not available on this system&quot; error message will
appear if the corresponding system calls are not supported
by your current operating system.</p>

<p style="margin-left:14%; margin-top: 1em">If the optional
(boolean) input parameter &quot;<tt>$gmt</tt>&quot; is
given, a &quot;true&quot; value (&quot;<tt>1</tt>&quot;)
will cause &quot;<tt>&quot;gmtime()&quot;</tt>&quot; to be
used instead of
&quot;<tt>&quot;localtime()&quot;</tt>&quot;, internally,
thus returning Greenwich Mean Time ( <small>GMT,</small> or
<small>UTC</small> ) instead of local time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec) = Today_and_Now([$gmt]);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a subset of the values returned by the function
&quot;<tt>&quot;System_Clock()&quot;</tt>&quot; (see above
for details), namely the current date (year, month, day) and
time (hours, minutes and full seconds).</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;not available on this system&quot; error message will
appear if the corresponding system calls are not supported
by your current operating system.</p>

<p style="margin-left:14%; margin-top: 1em">If the optional
(boolean) input parameter &quot;<tt>$gmt</tt>&quot; is
given, a &quot;true&quot; value (&quot;<tt>1</tt>&quot;)
will cause &quot;<tt>&quot;gmtime()&quot;</tt>&quot; to be
used instead of
&quot;<tt>&quot;localtime()&quot;</tt>&quot;, internally,
thus returning Greenwich Mean Time ( <small>GMT,</small> or
<small>UTC</small> ) instead of local time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>&quot;$year =
This_Year([$gmt]);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the current year, according to local time.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;not available on this system&quot; error message will
appear if the corresponding system calls are not supported
by your current operating system.</p>

<p style="margin-left:14%; margin-top: 1em">If the optional
(boolean) input parameter &quot;<tt>$gmt</tt>&quot; is
given, a &quot;true&quot; value (&quot;<tt>1</tt>&quot;)
will cause &quot;<tt>&quot;gmtime()&quot;</tt>&quot; to be
used instead of
&quot;<tt>&quot;localtime()&quot;</tt>&quot;, internally,
thus returning Greenwich Mean Time ( <small>GMT,</small> or
<small>UTC</small> ) instead of local time. However, this
will only make a difference within a few hours around New
Year (unless you are on a Pacific island, where this can be
almost 24 hours).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec, $doy,$dow,$dst) =
Gmtime([time]);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This is
Date::Calc&rsquo;s equivalent of Perl&rsquo;s built-in
&quot;<i>gmtime()</i>&quot; function. See also
&quot;gmtime&quot; in <i>perlfunc</i>(1).</p>

<p style="margin-left:14%; margin-top: 1em">With the
optional argument &quot;time&quot; (i.e., seconds since the
epoch), this function will return the corresponding values
for that particular time (instead of the current time when
this parameter is omitted).</p>

<p style="margin-left:14%; margin-top: 1em">The ranges of
values returned (and their meanings) are as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  &minus;1..1</pre>



<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$doy</tt>&quot;
is the day of year, sometimes also referred to as the
&quot;julian date&quot;, which starts at
&quot;<tt>1</tt>&quot; and goes up to the number of days in
that year.</p>

<p style="margin-left:14%; margin-top: 1em">The day of week
(&quot;<tt>$dow</tt>&quot;) will be &quot;<tt>1</tt>&quot;
for Monday, &quot;<tt>2</tt>&quot; for Tuesday and so on
until &quot;<tt>7</tt>&quot; for Sunday.</p>

<p style="margin-left:14%; margin-top: 1em">The daylight
savings time flag (&quot;<tt>$dst</tt>&quot;) will be
&quot;<tt>&quot;&minus;1&quot;</tt>&quot; if this
information is not available on your system,
&quot;<tt>0</tt>&quot; for no daylight savings time (i.e.,
winter time) and &quot;<tt>1</tt>&quot; when daylight
savings time is in effect.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;time out of range&quot; error will occur if the given
time value is out of range
<tt>&quot;[0..(~0&gt;&gt;1)]&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">If the time
value is omitted, the &quot;<i>time()</i>&quot; function is
called instead, internally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec, $doy,$dow,$dst) =
Localtime([time]);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This is
Date::Calc&rsquo;s equivalent of Perl&rsquo;s built-in
&quot;<i>localtime()</i>&quot; function. See also
&quot;localtime&quot; in <i>perlfunc</i>(1).</p>

<p style="margin-left:14%; margin-top: 1em">The ranges of
values returned (and their meanings) are as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  &minus;1..1</pre>



<p style="margin-left:14%; margin-top: 1em">&quot;<tt>$doy</tt>&quot;
is the day of year, sometimes also referred to as the
&quot;julian date&quot;, which starts at
&quot;<tt>1</tt>&quot; and goes up to the number of days in
that year.</p>

<p style="margin-left:14%; margin-top: 1em">The day of week
(&quot;<tt>$dow</tt>&quot;) will be &quot;<tt>1</tt>&quot;
for Monday, &quot;<tt>2</tt>&quot; for Tuesday and so on
until &quot;<tt>7</tt>&quot; for Sunday.</p>

<p style="margin-left:14%; margin-top: 1em">The daylight
savings time flag (&quot;<tt>$dst</tt>&quot;) will be
&quot;<tt>&quot;&minus;1&quot;</tt>&quot; if this
information is not available on your system,
&quot;<tt>0</tt>&quot; for no daylight savings time (i.e.,
winter time) and &quot;<tt>1</tt>&quot; when daylight
savings time is in effect.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;time out of range&quot; error will occur if the given
time value is out of range
<tt>&quot;[0..(~0&gt;&gt;1)]&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">If the time
value is omitted, the &quot;<i>time()</i>&quot; function is
called instead, internally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="81%">


<p style="margin-top: 1em"><tt>&quot;$time =
Mktime($year,$month,$day, $hour,$min,$sec);&quot;</tt></p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
converts a date into a time value, i.e., into the number of
seconds since whatever moment in time your system considers
to be the &quot;epoch&quot;. On Unix and most other systems
this is the number of seconds since January 1st 1970 at
midnight ( <small>GMT</small> ). On MacOS Classic this is
the number of seconds since January 1st 1904 at midnight
(local time).</p>

<p style="margin-left:14%; margin-top: 1em">The function is
similar to the &quot;<i>POSIX::mktime()</i>&quot; function
(see &quot;mktime&quot; in <i><small>POSIX</small></i> (1)
for more details), but in contrast to the latter, it expects
dates in the usual ranges used throughout this module: The
year 2001 stays year 2001, and months are numbered from 1 to
12.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;date out of range&quot; error will occur if the given
date cannot be expressed in terms of seconds since the epoch
(this happens for instance when the date lies before the
epoch, or if it is later than
19&minus;Jan&minus;2038&nbsp;03:14:07&nbsp;
<small>GMT</small> on 32&nbsp;bit Unix systems, or later
than 06&minus;Feb&minus;2040&nbsp;06:28:15 (local time) on a
Macintosh with MacOS Classic).</p>

<p style="margin-left:14%; margin-top: 1em">Just like the
&quot;<i>POSIX::mktime()</i>&quot; function, this function
uses the &quot;<i>mktime()</i>&quot; system call,
internally.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the given date and time is considered to be in local time,
and that the value returned by this function will depend on
your machine&rsquo;s local settings such as the time zone,
whether daylight savings time is (or was, at the time) in
effect, and the system clock itself.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that &quot;<i>mktime()</i>&quot; does not always return the
same time value as fed into &quot;<i>localtime()</i>&quot;,
when you feed the output of &quot;<i>localtime()</i>&quot;
back into &quot;<i>mktime()</i>&quot;, on some systems!</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,
&quot;<tt>&quot;Mktime((Localtime($time))[0..5])&quot;</tt>&quot;
will not always return the same value as given in
&quot;<tt>$time</tt>&quot;!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($D_y,$D_m,$D_d,
$Dh,$Dm,$Ds, $dst) = Timezone([time]);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the difference between
&quot;<tt>&quot;localtime(time)&quot;</tt>&quot; and
&quot;<tt>&quot;gmtime(time)&quot;</tt>&quot;, which is the
timezone offset in effect for the current location and the
given &quot;<tt>&quot;time&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This offset is
positive if you are located to the east of Greenwich, and is
usually negative (except during daylight savings time, in
some locations) if you are located to the west of
Greenwich.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
offset is influenced by all of the relevant system settings
and parameters on your machine; such as locales, environment
variables (e.g. &quot;<tt>&quot;TZ&quot;</tt>&quot;) and the
system clock itself. See the relevant documentation on your
system for more details.</p>

<p style="margin-left:14%; margin-top: 1em">If the
&quot;<tt>&quot;time&quot;</tt>&quot; is omitted, the
&quot;<tt>&quot;time()&quot;</tt>&quot; function will be
called automatically, internally (similar to the built-in
functions &quot;<tt>&quot;localtime()&quot;</tt>&quot; and
&quot;<tt>&quot;gmtime()&quot;</tt>&quot; in Perl).</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;time out of range&quot; error will occur if the given
time value is out of range
<tt>&quot;[0..(~0&gt;&gt;1)]&quot;</tt>.</p>

<p style="margin-left:14%; margin-top: 1em">The last item
of the returned list is a flag which indicates whether
daylight savings time is currently in effect. This flag is
negative (&minus;1) if this information is not available on
your system. It is zero (0) when daylight savings time is
off, and positive (+1) when daylight savings time is on.</p>

<p style="margin-left:14%; margin-top: 1em">Thus you can
check very quickly whether daylight savings time is
currently in effect by evaluating this function in scalar
context (in scalar context, Perl returns the last item of a
list):</p>

<pre style="margin-left:14%; margin-top: 1em">  if (scalar Timezone &gt; 0) { # yes, daylight savings time</pre>


<p style="margin-left:14%; margin-top: 1em">However, a
slightly more efficient way would be this:</p>

<pre style="margin-left:14%; margin-top: 1em">  if (scalar System_Clock &gt; 0) { # yes, daylight savings time</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;$time =
Date_to_Time($year,$month,$day,
$hour,$min,$sec);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is a replacement for the <small>BSD</small> function
&quot;<i>timegm()</i>&quot; (which is not available on all
Unix systems), which converts a given date and time into a
time value, i.e., into the number of seconds since whatever
moment in time your system considers to be the
&quot;epoch&quot;. On Unix and most other systems this is
the number of seconds since January 1st 1970 at midnight (
<small>GMT</small> ). On MacOS Classic this is the number of
seconds since January 1st 1904 at midnight (local time).</p>

<p style="margin-left:14%; margin-top: 1em">Under Unix, the
date and time are considered to be in <small>UTC</small>
(&quot;Universal Time Coordinated&quot;, and so is the
resulting time value.</p>


<p style="margin-left:14%; margin-top: 1em"><small>UTC</small>
is almost the same as <small>GMT</small> (or &quot;Greenwich
Mean Time&quot;), except that <small>UTC</small> has leap
seconds (in order to account for small variations in the
rotation of the earth, for instance), whereas
<small>GMT</small> does not.</p>

<p style="margin-left:14%; margin-top: 1em">Under MacOS
Classic, however, both input and output are considered to be
in local time.</p>

<p style="margin-left:14%; margin-top: 1em">The ranges of
year and month follow the same rules as throughout the rest
of this module (and not the contorted rules of its Unix
equivalent), i.e., the year &quot;2001&quot; stays
&quot;2001&quot; and the month ranges from 1 to 12.</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;date out of range&quot; error will occur if the given
date cannot be expressed in terms of seconds since the epoch
(this happens for instance when the date lies before the
epoch, or if it is later than
19&minus;Jan&minus;2038&nbsp;03:14:07&nbsp;
<small>GMT</small> on 32&nbsp;bit Unix systems, or later
than 06&minus;Feb&minus;2040&nbsp;06:28:15 (local time) on a
Macintosh with MacOS Classic).</p>

<p style="margin-left:14%; margin-top: 1em">This function
should be very fast, because it is implemented in a very
straightforward manner and doesn&rsquo;t use any internal
system calls.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, the
functions &quot;<i>Date_to_Time()</i>&quot; and
&quot;<i>Time_to_Date()</i>&quot; are guaranteed to be
complementary, i.e., that
&quot;<tt>&quot;Date_to_Time(Time_to_Date($time))&quot;</tt>&quot;
and
&quot;<tt>&quot;Time_to_Date(Date_to_Time($year,$month,$day,
$hour,$min,$sec))&quot;</tt>&quot; will always return the
initial values.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day,
$hour,$min,$sec) = Time_to_Date([time]);&quot;</tt></p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is an alternative to the <small>POSIX</small>
&quot;<i>gmtime()</i>&quot; function (and its built-in Perl
equivalent), which converts a given time value into the
corresponding date and time. The given time value must be
the number of seconds since whatever moment in time your
system considers to be the &quot;epoch&quot;. On Unix and
most other systems this is the number of seconds since
January 1st 1970 at midnight ( <small>GMT</small> ). On
MacOS Classic this is the number of seconds since January
1st 1904 at midnight (local time).</p>

<p style="margin-left:14%; margin-top: 1em">Under Unix, the
given time value is considered to be in <small>UTC</small>
(&quot;Universal Time Coordinated&quot;, and so is the
resulting date and time.</p>


<p style="margin-left:14%; margin-top: 1em"><small>UTC</small>
is almost the same as <small>GMT</small> (or &quot;Greenwich
Mean Time&quot;), except that <small>UTC</small> has leap
seconds (in order to account for small variations in the
rotation of the earth, for instance), whereas
<small>GMT</small> does not.</p>

<p style="margin-left:14%; margin-top: 1em">Under MacOS
Classic, however, both input and output are considered to be
in local time.</p>

<p style="margin-left:14%; margin-top: 1em">If the input
value &quot;<tt>&quot;time&quot;</tt>&quot; is omitted, the
&quot;<tt>&quot;time()&quot;</tt>&quot; function will be
called automatically, internally (similar to the built-in
functions &quot;<tt>&quot;localtime()&quot;</tt>&quot; and
&quot;<tt>&quot;gmtime()&quot;</tt>&quot; in Perl).</p>

<p style="margin-left:14%; margin-top: 1em">A fatal
&quot;time out of range&quot; error will occur if the given
time value is negative.</p>

<p style="margin-left:14%; margin-top: 1em">This function
should be very fast, because it is implemented in a very
straightforward manner and doesn&rsquo;t use any internal
system calls (except for &quot;<i>time()</i>&quot;, if the
input value is omitted).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, the
functions &quot;<i>Date_to_Time()</i>&quot; and
&quot;<i>Time_to_Date()</i>&quot; are guaranteed to be
complementary, i.e., that
&quot;<tt>&quot;Date_to_Time(Time_to_Date($time))&quot;</tt>&quot;
and
&quot;<tt>&quot;Time_to_Date(Date_to_Time($year,$month,$day,
$hour,$min,$sec))&quot;</tt>&quot; will always return the
initial values.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em"><tt>&quot;($year,$month,$day) =
Easter_Sunday($year);&quot;</tt></p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
calculates the date of Easter Sunday for all years in the
range from 1583 to 2299 (all other year numbers will result
in a fatal &quot;year out of range&quot; error message)
using the method known as the &quot;Gaussian Rule&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Some related
christian feast days which depend on the date of Easter
Sunday:</p>

<pre style="margin-left:14%; margin-top: 1em">  Carnival Monday / Rosenmontag / Veille du Mardi Gras   =  &minus;48 days
  Mardi Gras / Karnevalsdienstag / Mardi Gras            =  &minus;47 days
  Ash Wednesday / Aschermittwoch / Mercredi des Cendres  =  &minus;46 days
  Palm Sunday / Palmsonntag / Dimanche des Rameaux       =   &minus;7 days
  Easter Friday / Karfreitag / Vendredi Saint            =   &minus;2 days
  Easter Saturday / Ostersamstag / Samedi de Paques      =   &minus;1 day
  Easter Monday / Ostermontag / Lundi de Paques          =   +1 day
  Ascension of Christ / Christi Himmelfahrt / Ascension  =  +39 days
  Whitsunday / Pfingstsonntag / Dimanche de Pentecote    =  +49 days
  Whitmonday / Pfingstmontag / Lundi de Pentecote        =  +50 days
  Feast of Corpus Christi / Fronleichnam / Fete&minus;Dieu     =  +60 days</pre>


<p style="margin-left:14%; margin-top: 1em">Use the offsets
shown above to calculate the date of the corresponding feast
day as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  ($year,$month,$day) = Add_Delta_Days(Easter_Sunday($year), $offset));</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em"><tt>&quot;if ($month =
Decode_Month($string[,$lang]))&quot;</tt></p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
takes a string as its argument, which should contain the
name of a month in the given or currently selected language
(see further below for details about the multi-language
support of this package), or any uniquely identifying
abbreviation of a month&rsquo;s name (i.e., the first few
letters), and returns the corresponding number (1..12) upon
a successful match, or &quot;<tt>0</tt>&quot; otherwise
(therefore, the return value can also be used as the
conditional expression in an &quot;if&quot; statement).</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
input string may not contain any other characters which do
not pertain to the month&rsquo;s name, especially no leading
or trailing whitespace.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
matching is performed in a case-insensitive manner (this may
depend on the &quot;locale&quot; setting on your current
system, though!)</p>

<p style="margin-left:14%; margin-top: 1em">With
&quot;1&quot; (&quot;English&quot;) as the given language,
the following examples will all return the value
&quot;<tt>9</tt>&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  $month = Decode_Month(&quot;s&quot;,1);
  $month = Decode_Month(&quot;Sep&quot;,1);
  $month = Decode_Month(&quot;septemb&quot;,1);
  $month = Decode_Month(&quot;September&quot;,1);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><tt>&quot;if ($dow =
Decode_Day_of_Week($string[,$lang]))&quot;</tt></p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
takes a string as its argument, which should contain the
name of a day of week in the given or currently selected
language (see further below for details about the
multi-language support of this package), or any uniquely
identifying abbreviation of the name of a day of week (i.e.,
the first few letters), and returns the corresponding number
(1..7) upon a successful match, or &quot;<tt>0</tt>&quot;
otherwise (therefore, the return value can also be used as
the conditional expression in an &quot;if&quot;
statement).</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
input string may not contain any other characters which do
not pertain to the name of the day of week, especially no
leading or trailing whitespace.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
matching is performed in a case-insensitive manner (this may
depend on the &quot;locale&quot; setting on your current
system, though!)</p>

<p style="margin-left:14%; margin-top: 1em">With
&quot;1&quot; (&quot;English&quot;) as the given language,
the following examples will all return the value
&quot;<tt>3</tt>&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  $dow = Decode_Day_of_Week(&quot;w&quot;,1);
  $dow = Decode_Day_of_Week(&quot;Wed&quot;,1);
  $dow = Decode_Day_of_Week(&quot;wednes&quot;,1);
  $dow = Decode_Day_of_Week(&quot;Wednesday&quot;,1);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em"><tt>&quot;if ($lang =
Decode_Language($string))&quot;</tt></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
takes a string as its argument, which should contain the
name of one of the languages supported by this package (
<b><small>IN THIS VERY LANGUAGE ITSELF</small></b> ), or any
uniquely identifying abbreviation of the name of a language
(i.e., the first few letters), and returns its corresponding
internal number (1..14 in the original distribution) upon a
successful match, or &quot;<tt>0</tt>&quot; otherwise
(therefore, the return value can also be used as the
conditional expression in an &quot;if&quot; statement).</p>

<p style="margin-left:14%; margin-top: 1em">Note that the
input string may not contain any other characters which do
not pertain to the name of a language, especially no leading
or trailing whitespace.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
matching is performed in a case-insensitive manner (this may
depend on the &quot;locale&quot; setting on your current
system, though!)</p>

<p style="margin-left:14%; margin-top: 1em">The original
distribution supports the following fourteen languages:</p>

<pre style="margin-left:14%; margin-top: 1em">            English                    ==&gt;    1    (default)
            Francais    (French)       ==&gt;    2
            Deutsch     (German)       ==&gt;    3
            Espan~ol     (Spanish)      ==&gt;    4
            Portugues   (Portuguese)   ==&gt;    5
            Nederlands  (Dutch)        ==&gt;    6
            Italiano    (Italian)      ==&gt;    7
            Norsk       (Norwegian)    ==&gt;    8
            Svenska     (Swedish)      ==&gt;    9
            Dansk       (Danish)       ==&gt;   10
            suomi       (Finnish)      ==&gt;   11
            Magyar      (Hungarian)    ==&gt;   12
            polski      (Polish)       ==&gt;   13
            Romaneste   (Romanian)     ==&gt;   14</pre>


<p style="margin-left:14%; margin-top: 1em">See the section
&quot;How to install additional languages&quot; in the file
&quot; <small>INSTALL</small> .txt&quot; in this
distribution for how to add more languages to this
package.</p>

<p style="margin-left:14%; margin-top: 1em">In the original
distribution (no other languages installed), the following
examples will all return the value
&quot;<tt>3</tt>&quot;:</p>

<pre style="margin-left:14%; margin-top: 1em">  $lang = Decode_Language(&quot;d&quot;);
  $lang = Decode_Language(&quot;de&quot;);
  $lang = Decode_Language(&quot;Deutsch&quot;);</pre>


<p style="margin-left:14%; margin-top: 1em">Note that you
may not be able to enter the special international
characters in some of the languages&rsquo; names over the
keyboard directly on some systems.</p>

<p style="margin-left:14%; margin-top: 1em">This should
never be a problem, though; just enter an abbreviation of
the name of the language consisting of the first few letters
up to the character before the first special international
character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Decode_Date_EU($string[,$lang]))&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
scans a given string and tries to parse any date which might
be embedded in it.</p>

<p style="margin-left:14%; margin-top: 1em">The function
returns an empty list if it can&rsquo;t successfully extract
a valid date from its input string, or else it returns the
date found.</p>

<p style="margin-left:14%; margin-top: 1em">The function
accepts almost any format, as long as the date is given in
the european order (hence its name) day-month-year.</p>

<p style="margin-left:14%; margin-top: 1em">Thereby, zero
or more <b>NON-NUMERIC</b> characters may
<b><small>PRECEDE</small></b> the day and
<b><small>FOLLOW</small></b> the year.</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, zero
or more <b>NON-ALPHANUMERIC</b> characters are permitted
<b><small>BETWEEN</small></b> these three items (i.e.,
between day and month and between month and year).</p>

<p style="margin-left:14%; margin-top: 1em">The month may
be given either numerically (i.e., a number from
&quot;<tt>1</tt>&quot; to &quot;<tt>12</tt>&quot;), or
alphanumerically, i.e., as the name of the month in the
given or currently selected language, or any uniquely
identifying abbreviation thereof.</p>

<p style="margin-left:14%; margin-top: 1em">(See further
below for details about the multi-language support of this
package!)</p>

<p style="margin-left:14%; margin-top: 1em">If the year is
given as one or two digits only (i.e., if the year is less
than 100), it is mapped to a &quot;window&quot; of +/&minus;
50 years around the current year, as described by the
&quot;<i>Moving_Window()</i>&quot; function (see further
below).</p>

<p style="margin-left:14%; margin-top: 1em">If the day,
month and year are all given numerically but
<b><small>WITHOUT</small></b> any delimiting characters
between them, this string of digits will be mapped to the
day, month and year as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">                Length:        Mapping:
                  3              dmy
                  4              dmyy
                  5              dmmyy
                  6              ddmmyy
                  7              dmmyyyy
                  8              ddmmyyyy</pre>


<p style="margin-left:14%; margin-top: 1em">(Where
&quot;d&quot; stands for &quot;day&quot;, &quot;m&quot;
stands for &quot;month&quot; and &quot;y&quot; stands for
&quot;year&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">All other
strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.</p>

<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<pre style="margin-left:14%; margin-top: 1em">  &quot;3.1.64&quot;
  &quot;3 1 64&quot;
  &quot;03.01.64&quot;
  &quot;03/01/64&quot;
  &quot;3. Jan 1964&quot;
  &quot;Birthday: 3. Jan '64 in Backnang/Germany&quot;
  &quot;03&minus;Jan&minus;64&quot;
  &quot;3.Jan1964&quot;
  &quot;3Jan64&quot;
  &quot;030164&quot;
  &quot;3ja64&quot;
  &quot;3164&quot;</pre>


<p style="margin-left:14%; margin-top: 1em">Experiment!
(See the corresponding example applications in the
&quot;examples&quot; subdirectory of this distribution in
order to do so.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Decode_Date_US($string[,$lang]))&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
scans a given string and tries to parse any date which might
be embedded in it.</p>

<p style="margin-left:14%; margin-top: 1em">The function
returns an empty list if it can&rsquo;t successfully extract
a valid date from its input string, or else it returns the
date found.</p>

<p style="margin-left:14%; margin-top: 1em">The function
accepts almost any format, as long as the date is given in
the U.S. american order (hence its name) month-day-year.</p>

<p style="margin-left:14%; margin-top: 1em">Thereby, zero
or more <b>NON-ALPHANUMERIC</b> characters may
<b><small>PRECEDE</small></b> and
<b><small>FOLLOW</small></b> the month (i.e., precede the
month and separate it from the day which follows
behind).</p>

<p style="margin-left:14%; margin-top: 1em">Moreover, zero
or more <b>NON-NUMERIC</b> characters are permitted
<b><small>BETWEEN</small></b> the day and the year, as well
as <b><small>AFTER</small></b> the year.</p>

<p style="margin-left:14%; margin-top: 1em">The month may
be given either numerically (i.e., a number from
&quot;<tt>1</tt>&quot; to &quot;<tt>12</tt>&quot;), or
alphanumerically, i.e., as the name of the month in the
given or currently selected language, or any uniquely
identifying abbreviation thereof.</p>

<p style="margin-left:14%; margin-top: 1em">(See further
below for details about the multi-language support of this
package!)</p>

<p style="margin-left:14%; margin-top: 1em">If the year is
given as one or two digits only (i.e., if the year is less
than 100), it is mapped to a &quot;window&quot; of +/&minus;
50 years around the current year, as described by the
&quot;<i>Moving_Window()</i>&quot; function (see further
below).</p>

<p style="margin-left:14%; margin-top: 1em">If the month,
day and year are all given numerically but
<b><small>WITHOUT</small></b> any delimiting characters
between them, this string of digits will be mapped to the
month, day and year as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">                Length:        Mapping:
                  3              mdy
                  4              mdyy
                  5              mddyy
                  6              mmddyy
                  7              mddyyyy
                  8              mmddyyyy</pre>


<p style="margin-left:14%; margin-top: 1em">(Where
&quot;m&quot; stands for &quot;month&quot;, &quot;d&quot;
stands for &quot;day&quot; and &quot;y&quot; stands for
&quot;year&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">All other
strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.</p>

<p style="margin-left:14%; margin-top: 1em">If only the day
and the year form a contiguous string of digits, they will
be mapped as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">                Length:        Mapping:
                  2              dy
                  3              dyy
                  4              ddyy
                  5              dyyyy
                  6              ddyyyy</pre>


<p style="margin-left:14%; margin-top: 1em">(Where
&quot;d&quot; stands for &quot;day&quot; and &quot;y&quot;
stands for &quot;year&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<pre style="margin-left:14%; margin-top: 1em">  &quot;1 3 64&quot;
  &quot;01/03/64&quot;
  &quot;Jan 3 '64&quot;
  &quot;Jan 3 1964&quot;
  &quot;===&gt; January 3rd 1964 (birthday)&quot;
  &quot;Jan31964&quot;
  &quot;Jan364&quot;
  &quot;ja364&quot;
  &quot;1364&quot;</pre>


<p style="margin-left:14%; margin-top: 1em">Experiment!
(See the corresponding example applications in the
&quot;examples&quot; subdirectory of this distribution in
order to do so.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><tt>&quot;$year =
Fixed_Window($yy);&quot;</tt></p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
applies a &quot;fixed window&quot; strategy to two-digit
year numbers in order to convert them into four-digit year
numbers.</p>

<p style="margin-left:14%; margin-top: 1em">All other year
numbers are passed through unchanged, except for negative
year numbers, which cause the function to return zero
(&quot;<tt>0</tt>&quot;) instead.</p>

<p style="margin-left:14%; margin-top: 1em">Two-digit year
numbers &quot;<tt>&quot;yy&quot;</tt>&quot; below 70 are
converted to &quot;<tt>&quot;20yy&quot;</tt>&quot;, whereas
year numbers equal to or greater than 70 (but less than 100)
are converted to &quot;<tt>&quot;19yy&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">In the original
distribution of this package, the base century is set to
&quot;1900&quot; and the base year to &quot;70&quot; (which
is a standard on <small>UNIX</small> systems), but these
constants (also called the &quot;epoch&quot;) can actually
be chosen at will (in the files &quot;DateCalc.c&quot; and
&quot;DateCalc.h&quot;) at compile time of this module.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">


<p style="margin-top: 1em"><tt>&quot;$year =
Moving_Window($yy);&quot;</tt></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
applies a &quot;moving window&quot; strategy to two-digit
year numbers in order to convert them into four-digit year
numbers, provided the necessary system calls (system clock)
are available. Otherwise the function falls back to the
&quot;fixed window&quot; strategy described in the function
above.</p>

<p style="margin-left:14%; margin-top: 1em">All other year
numbers are passed through unchanged, except for negative
year numbers, which cause the function to return zero
(&quot;<tt>0</tt>&quot;) instead.</p>

<p style="margin-left:14%; margin-top: 1em">Two-digit year
numbers are mapped according to a &quot;window&quot; of 50
years in both directions (past and future) around the
current year.</p>

<p style="margin-left:14%; margin-top: 1em">That is,
two-digit year numbers are first mapped to the same century
as the current year. If the resulting year is smaller than
the current year minus 50, then one more century is added to
the result. If the resulting year is equal to or greater
than the current year plus 50, then a century is subtracted
from the result.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>&quot;$date =
Compress($year,$month,$day);&quot;</tt></p> </td>
<td width="28%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><small>WARNING:</small>
This function is legacy code, its use is deprecated!</p>

<p style="margin-left:14%; margin-top: 1em">This function
encodes a date in 16 bits, which is the value being
returned.</p>

<p style="margin-left:14%; margin-top: 1em">The encoding
scheme is as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">            Bit number:    FEDCBA9 8765 43210
            Contents:      yyyyyyy mmmm ddddd</pre>


<p style="margin-left:14%; margin-top: 1em">(Where the
&quot;yyyyyyy&quot; contain the number of the year,
&quot;mmmm&quot; the number of the month and
&quot;ddddd&quot; the number of the day.)</p>

<p style="margin-left:14%; margin-top: 1em">The function
returns &quot;<tt>0</tt>&quot; if the given input values do
not represent a valid date. Therefore, the return value of
this function can also be used as the conditional expression
in an &quot;if&quot; statement, in order to check whether
the given input values constitute a valid date).</p>

<p style="margin-left:14%; margin-top: 1em">Through this
special encoding scheme, it is possible to
<b><small>COMPARE</small></b> compressed dates for equality
and order (less than/greater than)
<b><small>WITHOUT</small></b> any previous
<b><small>DECODING</small></b> !</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that contiguous dates do <b><small>NOT</small></b>
necessarily have contiguous compressed representations!</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,
incrementing the compressed representation of a date
<b><small>MAY OR MAY NOT</small></b> yield a valid new
date!</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
this function can only handle dates within one century.</p>

<p style="margin-left:14%; margin-top: 1em">This century
can be chosen at will (at compile time of this module) by
defining a base century and year (also called the
&quot;epoch&quot;). In the original distribution of this
package, the base century is set to &quot;1900&quot; and the
base year to &quot;70&quot; (which is standard on
<small>UNIX</small> systems).</p>

<p style="margin-left:14%; margin-top: 1em">This allows
this function to handle dates from &quot;1970&quot; up to
&quot;2069&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
year is equal to, say, &quot;95&quot;, this package will
automatically assume that you really meant &quot;1995&quot;
instead. However, if you specify a year number which is
<b><small>SMALLER</small></b> than 70, like &quot;64&quot;,
for instance, this package will assume that you really meant
&quot;2064&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">You are not
confined to two-digit (abbreviated) year numbers,
though.</p>

<p style="margin-left:14%; margin-top: 1em">The function
also accepts &quot;full-length&quot; year numbers, provided
that they lie in the supported range (i.e., from
&quot;1970&quot; to &quot;2069&quot;, in the original
configuration of this package).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
function is maintained mainly for backward compatibility,
and that its use is not recommended.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;if
(($century,$year,$month,$day) =
Uncompress($date))&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><small>WARNING:</small>
This function is legacy code, its use is deprecated!</p>

<p style="margin-left:14%; margin-top: 1em">This function
decodes dates that were encoded previously using the
function &quot;<tt>&quot;Compress()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">It returns the
century, year, month and day of the date encoded in
&quot;<tt>$date</tt>&quot; if &quot;<tt>$date</tt>&quot;
represents a valid date, or an empty list otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">The year
returned in &quot;<tt>$year</tt>&quot; is actually a
two-digit year number (i.e., the year number taken modulo
100), and only the expression &quot;<tt>&quot;$century +
$year&quot;</tt>&quot; yields the &quot;full-length&quot;
year number (for example, <tt>&quot;1900 + 95 =
1995&quot;</tt>).</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
function is maintained mainly for backward compatibility,
and that its use is not recommended.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><tt>&quot;if
(check_compressed($date))&quot;</tt></p> </td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><small>WARNING:</small>
This function is legacy code, its use is deprecated!</p>

<p style="margin-left:14%; margin-top: 1em">This function
returns &quot;true&quot; (&quot;<tt>1</tt>&quot;) if the
given input value constitutes a valid compressed date, and
&quot;false&quot; (&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
function is maintained mainly for backward compatibility,
and that its use is not recommended.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$string =
Compressed_to_Text($date[,$lang]);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><small>WARNING:</small>
This function is legacy code, its use is deprecated!</p>

<p style="margin-left:14%; margin-top: 1em">This function
returns a string of fixed length (always 9 characters long)
containing a textual representation of the compressed date
encoded in &quot;<tt>$date</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This string has
the form &quot;dd-Mmm-yy&quot;, where &quot;dd&quot; is the
two-digit number of the day, &quot;Mmm&quot; are the first
three letters of the name of the month in the given or
currently selected language (see further below for details
about the multi-language support of this package), and
&quot;yy&quot; is the two-digit year number (i.e., the year
number taken modulo 100).</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$date</tt>&quot; does not represent a valid date,
the string &quot;??&minus;???&minus;??&quot; is returned
instead.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
function is maintained mainly for backward compatibility,
and that its use is not recommended.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em"><tt>&quot;$string =
Date_to_Text($year,$month,$day[,$lang]);&quot;</tt></p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a string containing a textual representation of the
given date of the form &quot;www dd-Mmm-yyyy&quot;, where
&quot;www&quot; are the first three letters of the name of
the day of week in the given or currently selected language,
or a special abbreviation, if special abbreviations have
been defined for the given or currently selected language
(see further below for details about the multi-language
support of this package), &quot;dd&quot; is the day (one or
two digits), &quot;Mmm&quot; are the first three letters of
the name of the month in the given or currently selected
language, and &quot;yyyy&quot; is the number of the year in
full length.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
input values do not constitute a valid date, a fatal
&quot;not a valid date&quot; error occurs.</p>

<p style="margin-left:14%; margin-top: 1em">(See the
section &quot; <small>RECIPES&quot;</small> near the end of
this document for a code snippet for how to print dates in
any format you like.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;$string =
Date_to_Text_Long($year,$month,$day[,$lang]);&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a string containing a textual representation of the
given date roughly of the form &quot;Wwwwww, dd Mmmmmm
yyyy&quot;, where &quot;Wwwwww&quot; is the name of the day
of week in the given or currently selected language (see
further below for details about the multi-language support
of this package), &quot;dd&quot; is the day (one or two
digits), &quot;Mmmmmm&quot; is the name of the month in the
given or currently selected language, and &quot;yyyy&quot;
is the number of the year in full length.</p>

<p style="margin-left:14%; margin-top: 1em">The exact
format of the output string depends on the given or
currently selected language. In the original distribution of
this package, these formats are defined as follows:</p>

<pre style="margin-left:14%; margin-top: 1em">  1  English    :  &quot;Wwwwww, Mmmmmm ddth yyyy&quot;
  2  French     :  &quot;Wwwwww dd mmmmmm yyyy&quot;
  3  German     :  &quot;Wwwwww, den dd. Mmmmmm yyyy&quot;
  4  Spanish    :  &quot;Wwwwww, dd de mmmmmm de yyyy&quot;
  5  Portuguese :  &quot;Wwwwww, dia dd de mmmmmm de yyyy&quot;
  6  Dutch      :  &quot;Wwwwww, dd mmmmmm yyyy&quot;
  7  Italian    :  &quot;Wwwwww, dd Mmmmmm yyyy&quot;
  8  Norwegian  :  &quot;wwwwww, dd. mmmmmm yyyy&quot;
  9  Swedish    :  &quot;wwwwww, dd mmmmmm yyyy&quot;
 10  Danish     :  &quot;wwwwww, dd. mmmmmm yyyy&quot;
 11  Finnish    :  &quot;wwwwww, dd. mmmmmmta yyyy&quot;
 12  Hungarian  :  &quot;dd. Mmmmmm yyyy., wwwwww&quot;
 13  Polish     :  &quot;Wwwwww, dd Mmmmmm yyyy&quot;
 14  Romanian   :  &quot;Wwwwww dd Mmmmmm yyyy&quot;</pre>


<p style="margin-left:14%; margin-top: 1em">(You can change
these formats in the file &quot;DateCalc.c&quot; before
building this module in order to suit your personal
preferences.)</p>

<p style="margin-left:14%; margin-top: 1em">If the given
input values do not constitute a valid date, a fatal
&quot;not a valid date&quot; error occurs.</p>

<p style="margin-left:14%; margin-top: 1em">In order to
capitalize the day of week at the beginning of the string in
Norwegian, use
&quot;<tt>&quot;ucfirst(Date_to_Text_Long($year,$month,$day,8));&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">(See the
section &quot; <small>RECIPES&quot;</small> near the end of
this document for an example on how to print dates in any
format you like.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p style="margin-top: 1em"><tt>&quot;$string =
English_Ordinal($number);&quot;</tt></p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a string containing the (english) abbreviation of
the ordinal number for the given (cardinal) number
&quot;<tt>$number</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">I.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">    0  =&gt;  '0th'    10  =&gt;  '10th'    20  =&gt;  '20th'
    1  =&gt;  '1st'    11  =&gt;  '11th'    21  =&gt;  '21st'
    2  =&gt;  '2nd'    12  =&gt;  '12th'    22  =&gt;  '22nd'
    3  =&gt;  '3rd'    13  =&gt;  '13th'    23  =&gt;  '23rd'
    4  =&gt;  '4th'    14  =&gt;  '14th'    24  =&gt;  '24th'
    5  =&gt;  '5th'    15  =&gt;  '15th'    25  =&gt;  '25th'
    6  =&gt;  '6th'    16  =&gt;  '16th'    26  =&gt;  '26th'
    7  =&gt;  '7th'    17  =&gt;  '17th'    27  =&gt;  '27th'
    8  =&gt;  '8th'    18  =&gt;  '18th'    28  =&gt;  '28th'
    9  =&gt;  '9th'    19  =&gt;  '19th'    29  =&gt;  '29th'</pre>


<p style="margin-left:14%; margin-top: 1em">etc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;$string =
Calendar($year,$month[,$orthodox[,$lang]]);&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a calendar of the given month in the given year
(somewhat similar to the <small>UNIX &quot;</small>
<tt>&quot;cal&quot;</tt>&quot; command), in the given or
currently selected language (see further below for details
about the multi-language support of this package).</p>

<p style="margin-left:14%; margin-top: 1em">Example:</p>

<pre style="margin-left:14%; margin-top: 1em">  print Calendar(1998,5);</pre>


<p style="margin-left:14%; margin-top: 1em">This will
print:</p>

<pre style="margin-left:14%; margin-top: 1em">           May 1998
  Mon Tue Wed Thu Fri Sat Sun
                    1   2   3
    4   5   6   7   8   9  10
   11  12  13  14  15  16  17
   18  19  20  21  22  23  24
   25  26  27  28  29  30  31</pre>


<p style="margin-left:14%; margin-top: 1em">If the optional
boolean parameter &quot;<tt>$orthodox</tt>&quot; is given
and true, the calendar starts on Sunday instead of
Monday.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em"><tt>&quot;$string =
Month_to_Text($month[,$lang]);&quot;</tt></p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the name of the given month in the given or
currently selected language (see further below for details
about the multi-language support of this package).</p>

<p style="margin-left:14%; margin-top: 1em">If the given
month lies outside of the valid range from
&quot;<tt>1</tt>&quot; to &quot;<tt>12</tt>&quot;, a fatal
&quot;month out of range&quot; error will occur.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>&quot;$string =
Day_of_Week_to_Text($dow[,$lang]);&quot;</tt></p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the name of the given day of week in the given or
currently selected language (see further below for details
about the multi-language support of this package).</p>

<p style="margin-left:14%; margin-top: 1em">If the given
day of week lies outside of the valid range from
&quot;<tt>1</tt>&quot; to &quot;<tt>7</tt>&quot;, a fatal
&quot;day of week out of range&quot; error will occur.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><tt>&quot;$string =
Day_of_Week_Abbreviation($dow[,$lang]);&quot;</tt></p> </td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the special abbreviation of the name of the given
day of week, <b><small>IF</small></b> such special
abbreviations have been defined for the given or currently
selected language (see further below for details about the
multi-language support of this package).</p>

<p style="margin-left:14%; margin-top: 1em">(In the
original distribution of this package, this was only true
for Portuguese. Starting with version 5.1, abbreviations for
Polish have also been introduced. Starting with version 5.7,
the abbreviations for Portuguese have been disabled. So
Polish is currently the only language to define such special
abbreviations.)</p>

<p style="margin-left:14%; margin-top: 1em">If not, the
first three letters of the name of the day of week in the
given or currently selected language are returned
instead.</p>

<p style="margin-left:14%; margin-top: 1em">If the given
day of week lies outside of the valid range from
&quot;<tt>1</tt>&quot; to &quot;<tt>7</tt>&quot;, a fatal
&quot;day of week out of range&quot; error will occur.</p>

<p style="margin-left:14%; margin-top: 1em">Currently, this
table of special abbreviations is only used by the functions
&quot;<tt>&quot;Date_to_Text()&quot;</tt>&quot; and
&quot;<tt>&quot;Calendar()&quot;</tt>&quot;, internally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><tt>&quot;$string =
Language_to_Text($lang);&quot;</tt></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the name of any language supported by this package
when the internal number representing that language is given
as input.</p>

<p style="margin-left:14%; margin-top: 1em">The original
distribution supports the following fourteen languages:</p>

<pre style="margin-left:14%; margin-top: 1em">            1   ==&gt;   English                     (default)
            2   ==&gt;   Francais    (French)
            3   ==&gt;   Deutsch     (German)
            4   ==&gt;   Espan~ol     (Spanish)
            5   ==&gt;   Portugues   (Portuguese)
            6   ==&gt;   Nederlands  (Dutch)
            7   ==&gt;   Italiano    (Italian)
            8   ==&gt;   Norsk       (Norwegian)
            9   ==&gt;   Svenska     (Swedish)
           10   ==&gt;   Dansk       (Danish)
           11   ==&gt;   suomi       (Finnish)
           12   ==&gt;   Magyar      (Hungarian)
           13   ==&gt;   polski      (Polish)
           14   ==&gt;   Romaneste   (Romanian)</pre>


<p style="margin-left:14%; margin-top: 1em">See the section
&quot;How to install additional languages&quot; in the file
&quot; <small>INSTALL</small> .txt&quot; in this
distribution for how to add more languages to this
package.</p>

<p style="margin-left:14%; margin-top: 1em">See the
description of the function
&quot;<tt>&quot;Languages()&quot;</tt>&quot; further below
to determine how many languages are actually available in a
given installation of this package.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em"><tt>&quot;$lang =
Language();&quot;</tt></p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><tt>&quot;Language($lang); # DEPRECATED&quot;</tt></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><tt>&quot;$oldlang = Language($newlang); #
DEPRECATED&quot;</tt></p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
can be used to determine which language is currently
selected, and to change the selected language (this latter
use is deprecated, because this global setting may cause
conflicts between threads or modules running
concurrently).</p>

<p style="margin-left:14%; margin-top: 1em">Thereby, each
language has a unique internal number.</p>

<p style="margin-left:14%; margin-top: 1em">The original
distribution contains the following fourteen languages:</p>

<pre style="margin-left:14%; margin-top: 1em">            1   ==&gt;   English                     (default)
            2   ==&gt;   Francais    (French)
            3   ==&gt;   Deutsch     (German)
            4   ==&gt;   Espan~ol     (Spanish)
            5   ==&gt;   Portugues   (Portuguese)
            6   ==&gt;   Nederlands  (Dutch)
            7   ==&gt;   Italiano    (Italian)
            8   ==&gt;   Norsk       (Norwegian)
            9   ==&gt;   Svenska     (Swedish)
           10   ==&gt;   Dansk       (Danish)
           11   ==&gt;   suomi       (Finnish)
           12   ==&gt;   Magyar      (Hungarian)
           13   ==&gt;   polski      (Polish)
           14   ==&gt;   Romaneste   (Romanian)</pre>


<p style="margin-left:14%; margin-top: 1em">See the section
&quot;How to install additional languages&quot; in the file
&quot; <small>INSTALL</small> .txt&quot; in this
distribution for how to add more languages to this
package.</p>

<p style="margin-left:14%; margin-top: 1em">See the
description of the function
&quot;<tt>&quot;Languages()&quot;</tt>&quot; further below
to determine how many languages are actually available in a
given installation of this package.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that in order for your programs to be portable, you should
<b><small>NEVER</small></b> actually use the internal number
of a language in this package
<b><small>EXPLICITLY</small></b> , because the same number
could mean different languages on different systems,
depending on what languages have been added to any given
installation of this package.</p>

<p style="margin-left:14%; margin-top: 1em">Therefore, you
should always use a statement such as</p>

<pre style="margin-left:14%; margin-top: 1em">  Language(Decode_Language(&quot;Name_of_Language&quot;)); # DEPRECATED</pre>


<p style="margin-left:14%; margin-top: 1em">or</p>

<pre style="margin-left:14%; margin-top: 1em">  DateCalc_Function(@parameters,Decode_Language(&quot;Name_of_Language&quot;)); # RECOMMENDED</pre>


<p style="margin-left:14%; margin-top: 1em">to select the
desired language, and</p>

<pre style="margin-left:14%; margin-top: 1em">  $language = Language_to_Text(Language());</pre>


<p style="margin-left:14%; margin-top: 1em">or</p>

<pre style="margin-left:14%; margin-top: 1em">  $old_language = Language_to_Text(Language(&quot;Name_of_new_Language&quot;)); # DEPRECATED</pre>


<p style="margin-left:14%; margin-top: 1em">to determine
the (previously) selected language.</p>

<p style="margin-left:14%; margin-top: 1em">If the so
chosen language is not available in the current
installation, this will result in an appropriate error
message, instead of silently using the wrong (a random)
language (which just happens to have the same internal
number in the other installation).</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that when using the function
&quot;<tt>&quot;Language()&quot;</tt>&quot;, the selected
language is a global setting, shared by all threads or
modules you might be running concurrently, thus possibly
causing conflicts between them.</p>

<p style="margin-left:14%; margin-top: 1em">In order to
avoid these conflicts, you should
<b><small>NEVER</small></b> use the function
&quot;<tt>&quot;Language()&quot;</tt>&quot;, but should
<b><small>ALWAYS</small></b> pass a language number (as
returned by the function
&quot;<tt>&quot;Decode_Language()&quot;</tt>&quot;) to the
functions which are language-dependent, which are:</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<i>Decode_Month()</i>&quot;,
&quot;<i>Decode_Day_of_Week()</i>&quot;,
&quot;<i>Compressed_to_Text()</i>&quot;,
&quot;<i>Date_to_Text()</i>&quot;,
&quot;<i>Date_to_Text_Long()</i>&quot;,
&quot;<i>Calendar()</i>&quot;,
&quot;<i>Month_to_Text()</i>&quot;,
&quot;<i>Day_of_Week_to_Text()</i>&quot;,
&quot;<i>Day_of_Week_Abbreviation()</i>&quot;,
&quot;<i>Decode_Date_EU()</i>&quot;,
&quot;<i>Decode_Date_US()</i>&quot;,
&quot;<i>Decode_Date_EU2()</i>&quot;,
&quot;<i>Decode_Date_US2()</i>&quot;,
&quot;<i>Parse_Date()</i>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">Note that when
you pass an invalid number, such as e.g. zero, or no
language parameter at all, these functions will revert to
their behaviour in the versions of this module prior to 6.0,
which means that the global setting (as set by
&quot;<tt>&quot;Language()&quot;</tt>&quot;) becomes active
again (only in case of an invalid or missing language
parameter!).</p>

<p style="margin-left:14%; margin-top: 1em">In the C
library &quot;DateCalc.c&quot;, where omitting a parameter
is not an option, passing a zero for the language is
therefore the recommended way to guarantee backward
compatibility.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><tt>&quot;$max_lang =
Languages();&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns the (maximum) number of languages which are
currently available in your installation of this
package.</p>

<p style="margin-left:14%; margin-top: 1em">(This may vary
from installation to installation.)</p>

<p style="margin-left:14%; margin-top: 1em">See the section
&quot;How to install additional languages&quot; in the file
&quot; <small>INSTALL</small> .txt&quot; in this
distribution for how to add more languages to this
package.</p>

<p style="margin-left:14%; margin-top: 1em">In the original
distribution of this package there are fourteen built-in
languages, therefore the value returned by this function
will be &quot;<tt>14</tt>&quot; if no other languages have
been added to your particular installation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Decode_Date_EU2($string[,$lang))&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is the Perl equivalent of the function
&quot;<tt>&quot;Decode_Date_EU()&quot;</tt>&quot;
(implemented in C), included here merely as an example to
demonstrate how easy it is to write your own routine in Perl
(using regular expressions) adapted to your own special
needs, should the necessity arise, and intended primarily as
a basis for your own development.</p>

<p style="margin-left:14%; margin-top: 1em">In one
particular case this Perl version is actually slightly more
permissive than its C equivalent, as far as the class of
permitted intervening (i.e., delimiting) characters is
concerned.</p>

<p style="margin-left:14%; margin-top: 1em">(Can you tell
the subtle, almost insignificant difference by looking at
the code? Or by experimenting? Hint: Try the string
&quot;a3b1c64d&quot; with both functions.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Decode_Date_US2($string[,$lang))&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is the Perl equivalent of the function
&quot;<tt>&quot;Decode_Date_US()&quot;</tt>&quot;
(implemented in C), included here merely as an example to
demonstrate how easy it is to write your own routine in Perl
(using regular expressions) adapted to your own special
needs, should the necessity arise, and intended primarily as
a basis for your own development.</p>

<p style="margin-left:14%; margin-top: 1em">In one
particular case this Perl version is actually slightly more
permissive than its C equivalent.</p>

<p style="margin-left:14%; margin-top: 1em">(Hint: This is
the same difference as with the
&quot;<tt>&quot;Decode_Date_EU()&quot;</tt>&quot; and
&quot;<tt>&quot;Decode_Date_EU2()&quot;</tt>&quot; pair of
functions.)</p>

<p style="margin-left:14%; margin-top: 1em">In a different
case, the C version is a little bit more permissive than its
Perl equivalent.</p>

<p style="margin-left:14%; margin-top: 1em">(Can you tell
the difference by looking at the code? Or by experimenting?
Hint: Try the string &quot;(1/364)&quot; with both
functions.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><tt>&quot;if
(($year,$month,$day) =
Parse_Date($string[,$lang))&quot;</tt></p> </td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
is useful for parsing dates as returned by the <small>UNIX
&quot;</small> <tt>&quot;date&quot;</tt>&quot; command or as
found in the headers of e&minus;mail (in order to determine
the date at which some e&minus;mail has been sent or
received, for instance).</p>

<p style="margin-left:14%; margin-top: 1em">Example #1:</p>

<pre style="margin-left:14%; margin-top: 1em">  ($year,$month,$day) = Parse_Date(`/bin/date`);</pre>


<p style="margin-left:14%; margin-top: 1em">Example #2:</p>

<pre style="margin-left:14%; margin-top: 1em">  while (&lt;MAIL&gt;)
  {
      if (/^From \S/)
      {
          ($year,$month,$day) = Parse_Date($_);
          ...
      }
      ...
  }</pre>


<p style="margin-left:14%; margin-top: 1em">The function
returns an empty list if it can&rsquo;t extract a valid date
from the input string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em"><tt>&quot;$lower =
ISO_LC($string);&quot;</tt></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns a copy
of the given string where all letters of the
ISO&minus;Latin&minus;1 character set have been replaced by
their lower case equivalents.</p>

<p style="margin-left:14%; margin-top: 1em">Similar to
Perl&rsquo;s built-in function
&quot;<tt>&quot;lc()&quot;</tt>&quot; (see &quot;lc&quot; in
<i>perlfunc</i>(1)) but for the whole
ISO&minus;Latin&minus;1 character set, not just plain
<small>ASCII.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em"><tt>&quot;$upper =
ISO_UC($string);&quot;</tt></p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Returns a copy
of the given string where all letters of the
ISO&minus;Latin&minus;1 character set have been replaced by
their upper case equivalents.</p>

<p style="margin-left:14%; margin-top: 1em">Similar to
Perl&rsquo;s built-in function
&quot;<tt>&quot;uc()&quot;</tt>&quot; (see &quot;uc&quot; in
<i>perlfunc</i>(1)) but for the whole
ISO&minus;Latin&minus;1 character set, not just plain
<small>ASCII.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><tt>&quot;$string =
Date::Calc::Version();&quot;</tt></p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This function
returns a string with the (numeric) version number of the
C&nbsp;library (&quot;DateCalc.c&quot;) at the core of this
package (which is also (automatically) the version number of
the &quot;Calc.xs&quot; file).</p>

<p style="margin-left:14%; margin-top: 1em">Note that under
all normal circumstances, this version number should be
identical with the one found in the Perl variable
&quot;<tt>$Date::Calc::VERSION</tt>&quot; (the version
number of the &quot;Calc.pm&quot; file).</p>

<p style="margin-left:14%; margin-top: 1em">Since this
function is not exported, you always have to qualify it
explicitly, i.e.,
&quot;<tt>&quot;Date::Calc::Version()&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This is to
avoid possible name space conflicts with version functions
from other modules.</p>

<h2>RECIPES
<a name="RECIPES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1)</p></td>
<td width="3%"></td>
<td width="41%">


<p style="margin-top: 1em">How do I compare two dates?</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Solution
#1:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Date_to_Days );
  if (Date_to_Days($year1,$month1,$day1)  &lt;
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &lt;=
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &gt;
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &gt;=
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  ==
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  !=
      Date_to_Days($year2,$month2,$day2))
  $cmp = (Date_to_Days($year1,$month1,$day1)  &lt;=&gt;
          Date_to_Days($year2,$month2,$day2));</pre>


<p style="margin-left:17%; margin-top: 1em">Solution
#2:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Delta_Days );
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &gt; 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &gt;= 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &lt; 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &lt;= 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) == 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) != 0)</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I check whether a given
date lies within a certain range of dates?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Date_to_Days );
  $lower = Date_to_Days($year1,$month1,$day1);
  $upper = Date_to_Days($year2,$month2,$day2);
  $date = Date_to_Days($year,$month,$day);
  if (($date &gt;= $lower) &amp;&amp; ($date &lt;= $upper))
  {
      # ok
  }
  else
  {
      # not ok
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I compare two dates with
times? How do I check whether two dates and times lie more
or less than a given time interval apart?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Solution
#1:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Add_Delta_DHMS Date_to_Days );
  @date1 = (2002,8,31,23,59,1);
  @date2 = (2002,9,1,11,30,59); # ==&gt; less than 12 hours
  #@date1 = (2002,8,31,22,59,1);
  #@date2 = (2002,9,1,11,30,59); # ==&gt; more than 12 hours
  # Omit the next line if you just want to compare the two dates
  # (and change @date3 and @d3 to @date1 and @d1, respectively):
  @date3 = Add_Delta_DHMS(@date1, 0,12,0,0); # ==&gt; is the difference within 12 hours?
  @d2 = ( Date_to_Days(@date2[0..2]), ($date2[3]*60+$date2[4])*60+$date2[5] );
  @d3 = ( Date_to_Days(@date3[0..2]), ($date3[3]*60+$date3[4])*60+$date3[5] );
  @diff = ( $d2[0]&minus;$d3[0], $d2[1]&minus;$d3[1] );
  if ($diff[0] &gt; 0 and $diff[1] &lt; 0) { $diff[0]&minus;&minus;; $diff[1] += 86400; }
  if ($diff[0] &lt; 0 and $diff[1] &gt; 0) { $diff[0]++; $diff[1] &minus;= 86400; }
  if (($diff[0] || $diff[1]) &gt;= 0) { print &quot;More than 12 hours.\n&quot;; }
  else                             { print &quot;Less than 12 hours.\n&quot;; }</pre>


<p style="margin-left:17%; margin-top: 1em">Solution
#2:</p>

<p style="margin-left:17%; margin-top: 1em">This solution
is only feasible if your dates are guaranteed to lie within
the range given by your system&rsquo;s epoch and overflow
date and time!</p>

<pre style="margin-left:17%; margin-top: 1em">     Unix:    1&minus;Jan&minus;1970 00:00:00  to  19&minus;Jan&minus;2038 03:14:07
     MacOS:   1&minus;Jan&minus;1904 00:00:00  to   6&minus;Feb&minus;2040 06:28:15
  use Date::Calc qw( Date_to_Time );
  @date1 = (2002,8,31,23,59,1);
  @date2 = (2002,9,1,11,30,59); # ==&gt; less than 12 hours
  #@date1 = (2002,8,31,22,59,1);
  #@date2 = (2002,9,1,11,30,59); # ==&gt; more than 12 hours
  $d1 = Date_to_Time(@date1);
  $d2 = Date_to_Time(@date2);
  if ($d1 &lt;= $d2) { print &quot;The two dates are in chronological order.\n&quot;; }
  else            { print &quot;The two dates are in reversed order.\n&quot;; }
  if ($d1 + 12*60*60 &lt;= $d2) { print &quot;More than 12 hours.\n&quot;; }
  else                       { print &quot;Less than 12 hours.\n&quot;; }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4)</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">How do I verify whether someone
has a certain age?</p></td>
<td width="6%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Decode_Date_EU Today leap_year Delta_Days );
  $date = &lt;STDIN&gt;; # get birthday
  ($year1,$month1,$day1) = Decode_Date_EU($date);
  ($year2,$month2,$day2) = Today();
  if (($day1 == 29) &amp;&amp; ($month1 == 2) &amp;&amp; !leap_year($year2))
      { $day1&minus;&minus;; }
  if ( (($year2 &minus; $year1) &gt;  18) ||
     ( (($year2 &minus; $year1) == 18) &amp;&amp;
     (Delta_Days($year2,$month1,$day1, $year2,$month2,$day2) &gt;= 0) ) )
  {
      print &quot;Ok &minus; you are over 18.\n&quot;;
  }
  else
  {
      print &quot;Sorry &minus; you aren't 18 yet!\n&quot;;
  }
  Or, alternatively (substituting the last &quot;if&quot; statement above):
  if (($year1+18 &lt;=&gt; $year2 || $month1 &lt;=&gt; $month2 || $day1 &lt;=&gt; $day2) &lt;= 0)
      { print &quot;Ok &minus; you are over 18.\n&quot;; }
  else
      { print &quot;Sorry &minus; you aren't 18 yet!\n&quot;; }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">5)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I calculate the number of
the week of month the current date lies in?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">            April 1998
    Mon Tue Wed Thu Fri Sat Sun
              1   2   3   4   5  =  week #1
      6   7   8   9  10  11  12  =  week #2
     13  14  15  16  17  18  19  =  week #3
     20  21  22  23  24  25  26  =  week #4
     27  28  29  30              =  week #5</pre>


<p style="margin-left:17%; margin-top: 1em">Solution:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Day_of_Week );
  ($year,$month,$day) = Today();
  $week = int(($day + Day_of_Week($year,$month,1) &minus; 2) / 7) + 1;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">6)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I calculate whether a
given date is the 1st, 2nd, 3rd, 4th or 5th of that day of
week in the given month?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">           October 2000
    Mon Tue Wed Thu Fri Sat Sun
                              1
      2   3   4   5   6   7   8
      9  10  11  12  13  14  15
     16  17  18  19  20  21  22
     23  24  25  26  27  28  29
     30  31</pre>


<p style="margin-left:17%; margin-top: 1em">Is Sunday, the
15th of October 2000, the 1st, 2nd, 3rd, 4th or 5th Sunday
of that month?</p>

<p style="margin-left:17%; margin-top: 1em">Solution:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Day_of_Week Delta_Days
                     Nth_Weekday_of_Month_Year
                     Date_to_Text_Long English_Ordinal
                     Day_of_Week_to_Text Month_to_Text );
  ($year,$month,$day) = (2000,10,15);
  $dow = Day_of_Week($year,$month,$day);
  $n = int( Delta_Days(
            Nth_Weekday_of_Month_Year($year,$month,$dow,1),
            $year,$month,$day)
            / 7) + 1;
  printf(&quot;%s is the %s %s in %s %d.\n&quot;,
      Date_to_Text_Long($year,$month,$day),
      English_Ordinal($n),
      Day_of_Week_to_Text($dow),
      Month_to_Text($month),
      $year);</pre>


<p style="margin-left:17%; margin-top: 1em">This
prints:</p>

<pre style="margin-left:17%; margin-top: 1em">  Sunday, October 15th 2000 is the 3rd Sunday in October 2000.</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">7)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I calculate the date of
the Wednesday of the same week as the current date?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Solution
#1:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Day_of_Week Add_Delta_Days );
  $searching_dow = 3; # 3 = Wednesday
  @today = Today();
  $current_dow = Day_of_Week(@today);
  @date = Add_Delta_Days(@today, $searching_dow &minus; $current_dow);</pre>


<p style="margin-left:17%; margin-top: 1em">Solution
#2:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Add_Delta_Days
                     Monday_of_Week Week_of_Year );
  $searching_dow = 3; # 3 = Wednesday
  @today = Today();
  @date = Add_Delta_Days( Monday_of_Week( Week_of_Year(@today) ),
                          $searching_dow &minus; 1 );</pre>


<p style="margin-left:17%; margin-top: 1em">Solution
#3:</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Standard_to_Business Today
                     Business_to_Standard );
  @business = Standard_to_Business(Today());
  $business[2] = 3; # 3 = Wednesday
  @date = Business_to_Standard(@business);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">8)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I add a week offset to a
business date (including across year boundaries)?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Business_to_Standard Add_Delta_Days
                     Standard_to_Business );
  @temp = Business_to_Standard($year,$week,$dow);
  @temp = Add_Delta_Days(@temp, $week_offset * 7);
  ($year,$week,$dow) = Standard_to_Business(@temp);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">9)</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I calculate the last and
the next Saturday for any given date?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Day_of_Week Add_Delta_Days
                     Day_of_Week_to_Text Date_to_Text );
  $searching_dow = 6; # 6 = Saturday
  @today = Today();
  $current_dow = Day_of_Week(@today);
  if ($searching_dow == $current_dow)
  {
      @prev = Add_Delta_Days(@today,&minus;7);
      @next = Add_Delta_Days(@today,+7);
  }
  else
  {
      if ($searching_dow &gt; $current_dow)
      {
          @next = Add_Delta_Days(@today,
                    $searching_dow &minus; $current_dow);
          @prev = Add_Delta_Days(@next,&minus;7);
      }
      else
      {
          @prev = Add_Delta_Days(@today,
                    $searching_dow &minus; $current_dow);
          @next = Add_Delta_Days(@prev,+7);
      }
  }
  $dow = Day_of_Week_to_Text($searching_dow);
  print &quot;Today is:      &quot;, ' ' x length($dow),
                               Date_to_Text(@today), &quot;\n&quot;;
  print &quot;Last $dow was:     &quot;, Date_to_Text(@prev),  &quot;\n&quot;;
  print &quot;Next $dow will be: &quot;, Date_to_Text(@next),  &quot;\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">This will print
something like:</p>

<pre style="margin-left:17%; margin-top: 1em">  Today is:              Sun 12&minus;Apr&minus;1998
  Last Saturday was:     Sat 11&minus;Apr&minus;1998
  Next Saturday will be: Sat 18&minus;Apr&minus;1998</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">10)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I calculate the last
business day (payday!) of a month?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Solution #1
(holidays <b><small>NOT</small></b> taken into account):</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Days_in_Month Day_of_Week Add_Delta_Days );
  $day = Days_in_Month($year,$month);
  $dow = Day_of_Week($year,$month,$day);
  if ($dow &gt; 5)
  {
      ($year,$month,$day) =
          Add_Delta_Days($year,$month,$day, 5&minus;$dow);
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Solution #2
(holidays taken into account):</p>

<p style="margin-left:17%; margin-top: 1em">This solution
expects a multi-dimensional array
&quot;<tt>@holiday</tt>&quot;, which contains all holidays,
as follows: &quot;<tt>&quot;$holiday[$year][$month][$day] =
1;&quot;</tt>&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">(See the
description of the function
&quot;<tt>&quot;Easter_Sunday()&quot;</tt>&quot; further
above for how to calculate the moving (variable) christian
feast days!)</p>

<p style="margin-left:17%; margin-top: 1em">Days which are
not holidays remain undefined or should have a value of zero
in this array.</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Days_in_Month Add_Delta_Days Day_of_Week );
  $day = Days_in_Month($year,$month);
  while (1)
  {
      while ($holiday[$year][$month][$day])
      {
          ($year,$month,$day) =
              Add_Delta_Days($year,$month,$day, &minus;1);
      }
      $dow = Day_of_Week($year,$month,$day);
      if ($dow &gt; 5)
      {
          ($year,$month,$day) =
              Add_Delta_Days($year,$month,$day, 5&minus;$dow);
      }
      else { last; }
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Solution #3
(holidays taken into account, more comfortable, but requires
<i>Date::Calendar</i>(3) and
<i>Date::Calc::Object</i>(3)):</p>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc::Object qw( Today Add_Delta_YM Date_to_Text_Long );
  use Date::Calendar::Profiles qw($Profiles);
  use Date::Calendar;
  $calendar = Date::Calendar&minus;&gt;new( $Profiles&minus;&gt;{'DE&minus;BW'} );
  @today = Today();
  @nextmonth = Add_Delta_YM(@today[0,1],1, 0,1);
  $workaround = $calendar&minus;&gt;add_delta_workdays(@nextmonth,+1);
  $payday     = $calendar&minus;&gt;add_delta_workdays($workaround,&minus;2);
  print &quot;Pay day = &quot;, Date_to_Text_Long($payday&minus;&gt;date()), &quot;\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">The
&quot;workaround&quot; is necessary due to a bug in the
method &quot;<i>add_delta_workdays()</i>&quot; when adding a
negative number of workdays.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">11)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How do I convert a
<small>MS</small> Visual Basic &quot;
<small>DATETIME&quot;</small> value into its date and time
constituents?</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Add_Delta_DHMS Date_to_Text );
  $datetime = &quot;35883.121653&quot;;
  ($Dd,$Dh,$Dm,$Ds) = ($datetime =~ /^(\d+)\.(\d\d)(\d\d)(\d\d)$/);
  ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS(1900,1,1, 0,0,0, $Dd,$Dh,$Dm,$Ds);
  printf(&quot;The given date is %s %02d:%02d:%02d\n&quot;,
      Date_to_Text($year,$month,$day), $hour, $min, $sec);</pre>


<p style="margin-left:17%; margin-top: 1em">This
prints:</p>

<pre style="margin-left:17%; margin-top: 1em">  The given date is Tue 31&minus;Mar&minus;1998 12:16:53</pre>


<p style="margin-left:17%; margin-top: 1em">Since I do not
have or use Visual Basic, I can&rsquo;t guarantee that the
number format assumed here is really the one used by Visual
Basic &minus; but you get the general idea.
<tt>&quot;:&minus;)&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">Moreover,
consider the following:</p>

<p style="margin-left:17%; margin-top: 1em">Morten Sickel
&lt;Morten.Sickel@nrpa.no&gt; wrote:</p>

<p style="margin-left:17%; margin-top: 1em">I discovered a
bug in Excel (2000): Excel thinks that 1900 was a leap year.
Users should use 31&minus;Dec&minus;1899 as the date to add
an Excel date value to in order to get the correct date.</p>

<p style="margin-left:17%; margin-top: 1em">I found out on
the web that this bug originated in Lotus 123, which made
29&minus;Feb&minus;1900 an &quot;industrial standard&quot;.
<small>MS</small> chose to keep the bug in order to be
compatible with Lotus 123. But they have not mentioned
anything about it in the help files.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">12)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I send a reminder to
members of a group on the day before a meeting which occurs
every first Friday of a month?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Date_to_Days Add_Delta_YMD
                     Nth_Weekday_of_Month_Year );
  ($year,$month,$day) = Today();
  $tomorrow = Date_to_Days($year,$month,$day) + 1;
  $dow = 5; # 5 = Friday
  $n   = 1; # 1 = First of that day of week
  $meeting_this_month = Date_to_Days(
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
  ($year,$month,$day) = Add_Delta_YMD($year,$month,$day, 0,1,0);
  $meeting_next_month = Date_to_Days(
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
  if (($tomorrow == $meeting_this_month) ||
      ($tomorrow == $meeting_next_month))
  {
      # Send reminder e&minus;mail!
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">13)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I print a date in a
different format than provided by the functions
&quot;<tt>&quot;Date_to_Text()&quot;</tt>&quot;,
&quot;<tt>&quot;Date_to_Text_Long()&quot;</tt>&quot; or
&quot;<tt>&quot;Compressed_to_Text()&quot;</tt>&quot;?</p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Today Day_of_Week_to_Text
                     Day_of_Week Month_to_Text
                     English_Ordinal );
  ($year,$month,$day) = Today();</pre>


<p style="margin-left:17%; margin-top: 1em">For example
with leading zeros for the day:
&quot;Fri&nbsp;03&minus;Jan&minus;1964&quot;</p>

<pre style="margin-left:17%; margin-top: 1em">  printf(&quot;%.3s %02d&minus;%.3s&minus;%d\n&quot;,
      Day_of_Week_to_Text(Day_of_Week($year,$month,$day)),
      $day,
      Month_to_Text($month),
      $year);</pre>


<p style="margin-left:17%; margin-top: 1em">For example in
U.S. american format:
&quot;April&nbsp;12th,&nbsp;1998&quot;</p>

<pre style="margin-left:17%; margin-top: 1em">  $string = sprintf(&quot;%s %s, %d&quot;,
                Month_to_Text($month),
                English_Ordinal($day),
                $year);</pre>


<p style="margin-left:17%; margin-top: 1em">For example in
one of the possible formats as specified by
<small>ISO&nbsp;</small> 8601:</p>

<pre style="margin-left:17%; margin-top: 1em">  @date = ($year,$month,$day,$hour,$min,$sec);
  $date = sprintf(&quot;%d&minus;%02d&minus;%02d %02d:%02d:%02d&quot;, @date);</pre>


<p style="margin-left:17%; margin-top: 1em">(See also
&quot;printf&quot; in <i>perlfunc</i>(1) and/or
&quot;sprintf&quot; in <i>perlfunc</i>(1)!)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">14)</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em">How can I iterate through a
range of dates?</p></td>
<td width="17%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Delta_Days Add_Delta_Days );
  @start = (1999,5,27);
  @stop  = (1999,6,1);
  $j = Delta_Days(@start,@stop);
  for ( $i = 0; $i &lt;= $j; $i++ )
  {
      @date = Add_Delta_Days(@start,$i);
      printf(&quot;%4d/%02d/%02d\n&quot;, @date);
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Note that the
loop can be improved; see also the recipe below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">15)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I create a (Perl) list
of dates in a certain range?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  use Date::Calc qw( Delta_Days Add_Delta_Days Date_to_Text );
  sub date_range
  {
      my(@date) = (@_)[0,1,2];
      my(@list);
      my($i);
      $i = Delta_Days(@_);
      while ($i&minus;&minus; &gt;= 0)
      {
          push( @list, [ @date ] );
          @date = Add_Delta_Days(@date, 1) if ($i &gt;= 0);
      }
      return(@list);
  }
  @range = &amp;date_range(1999,11,3, 1999,12,24); # in chronological order
  foreach $date (@range)
  {
      print Date_to_Text(@{$date}), &quot;\n&quot;;
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Note that you
probably shouldn&rsquo;t use this one, because it is much
more efficient to iterate through all the dates (as shown in
the recipe immediately above) than to construct such an
array and then to loop through it. Also, it is much more
space-efficient not to create this array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">16)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I calculate the
difference in days between dates, but without counting
Saturdays and Sundays?</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  sub Delta_Business_Days
  {
      my(@date1) = (@_)[0,1,2];
      my(@date2) = (@_)[3,4,5];
      my($minus,$result,$dow1,$dow2,$diff,$temp);
      $minus  = 0;
      $result = Delta_Days(@date1,@date2);
      if ($result != 0)
      {
          if ($result &lt; 0)
          {
              $minus = 1;
              $result = &minus;$result;
              $dow1 = Day_of_Week(@date2);
              $dow2 = Day_of_Week(@date1);
          }
          else
          {
              $dow1 = Day_of_Week(@date1);
              $dow2 = Day_of_Week(@date2);
          }
          $diff = $dow2 &minus; $dow1;
          $temp = $result;
          if ($diff != 0)
          {
              if ($diff &lt; 0)
              {
                  $diff += 7;
              }
              $temp &minus;= $diff;
              $dow1 += $diff;
              if ($dow1 &gt; 6)
              {
                  $result&minus;&minus;;
                  if ($dow1 &gt; 7)
                  {
                      $result&minus;&minus;;
                  }
              }
          }
          if ($temp != 0)
          {
              $temp /= 7;
              $result &minus;= ($temp &lt;&lt; 1);
          }
      }
      if ($minus) { return &minus;$result; }
      else        { return  $result; }
  }</pre>


<p style="margin-left:17%; margin-top: 1em">This solution
is probably of little practical value, however, because it
doesn&rsquo;t take legal holidays into account.</p>

<p style="margin-left:17%; margin-top: 1em">See
<i>Date::Calendar</i>(3) for how to do that.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">17)</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">How can I &quot;normalize&quot;
the output of the &quot;<i>Delta_YMDHMS()</i>&quot; (or
&quot;<i>Delta_YMD()</i>&quot;) function so that it contains
only positive values?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">I.e., how can I
show a difference in date (and time) in a more
human-readable form, for example in order to show how much
time until (or since) the expiration of something (e.g. an
account, a domain, a credit card, etc.) is left (has
passed)?</p>

<p style="margin-left:17%; margin-top: 1em">Correct
solution: Use the functions
&quot;<i>N_Delta_YMDHMS()</i>&quot; and
&quot;<i>N_Delta_YMD()</i>&quot; instead!</p>

<p style="margin-left:17%; margin-top: 1em">The following
gives a rudimentary sketch of a (much inferior) solution,
which is maintained here only for historical reasons of this
module:</p>

<p style="margin-left:17%; margin-top: 1em">a)
<i>Delta_YMDHMS()</i>:</p>

<pre style="margin-left:17%; margin-top: 1em">  #!perl
  use strict;
  use Date::Calc qw(Today_and_Now Delta_YMDHMS Add_Delta_YMDHMS Delta_DHMS Date_to_Text);
  my $today = [Today_and_Now()];
  my $target = [2005,1,1,0,0,0];
  my $sign = &quot;until&quot;;
  my $delta = Normalize_Delta_YMDHMS($today,$target);
  if ($delta&minus;&gt;[0] &lt; 0)
  {
      $sign = &quot;since&quot;;
      $delta = Normalize_Delta_YMDHMS($target,$today);
  }
  printf(&quot;Today is %s %02d:%02d:%02d\n&quot;, Date_to_Text(@{$today}[0..2]), @{$today}[3..5]);
  printf
  (
      &quot;%d year%s, %d month%s, %d day%s, %d hour%s, %d minute%s, %d second%s %s %s %02d:%02d:%02d\n&quot;,
      $delta&minus;&gt;[0], (($delta&minus;&gt;[0]==1)?'':'s'),
      $delta&minus;&gt;[1], (($delta&minus;&gt;[1]==1)?'':'s'),
      $delta&minus;&gt;[2], (($delta&minus;&gt;[2]==1)?'':'s'),
      $delta&minus;&gt;[3], (($delta&minus;&gt;[3]==1)?'':'s'),
      $delta&minus;&gt;[4], (($delta&minus;&gt;[4]==1)?'':'s'),
      $delta&minus;&gt;[5], (($delta&minus;&gt;[5]==1)?'':'s'),
      $sign,
      Date_to_Text(@{$target}[0..2]),
      @{$target}[3..5]
  );
  sub Normalize_Delta_YMDHMS
  {
      my($date1,$date2) = @_;
      my(@delta);
      @delta = Delta_YMDHMS(@$date1,@$date2);
      while ($delta[1] &lt; 0 or
             $delta[2] &lt; 0 or
             $delta[3] &lt; 0 or
             $delta[4] &lt; 0 or
             $delta[5] &lt; 0)
      {
          if ($delta[1] &lt; 0) { $delta[0]&minus;&minus;; $delta[1] += 12; }
          if ($delta[2] &lt; 0)
          {
              $delta[1]&minus;&minus;;
              @delta[2..5] = (0,0,0,0);
              @delta[2..5] = Delta_DHMS(Add_Delta_YMDHMS(@$date1,@delta),@$date2);
          }
          if ($delta[3] &lt; 0) { $delta[2]&minus;&minus;; $delta[3] += 24; }
          if ($delta[4] &lt; 0) { $delta[3]&minus;&minus;; $delta[4] += 60; }
          if ($delta[5] &lt; 0) { $delta[4]&minus;&minus;; $delta[5] += 60; }
      }
      return \@delta;
  }</pre>


<p style="margin-left:17%; margin-top: 1em">b)
<i>Delta_YMD()</i>:</p>

<pre style="margin-left:17%; margin-top: 1em">  #!perl
  use strict;
  use Date::Calc qw(Today Delta_YMD Add_Delta_YM Delta_Days Date_to_Text);
  my($sign,$delta);
  my $today = [Today()];
  my $target = [2005,1,1];
  if (Delta_Days(@$today,@$target) &lt; 0)
  {
      $sign = &quot;since&quot;;
      $delta = Normalize_Delta_YMD($target,$today);
  }
  else
  {
      $sign = &quot;until&quot;;
      $delta = Normalize_Delta_YMD($today,$target);
  }
  print &quot;Today is &quot;, Date_to_Text(@$today), &quot;\n&quot;;
  printf
  (
      &quot;%d year%s, %d month%s, %d day%s %s %s\n&quot;,
      $delta&minus;&gt;[0], (($delta&minus;&gt;[0]==1)?'':'s'),
      $delta&minus;&gt;[1], (($delta&minus;&gt;[1]==1)?'':'s'),
      $delta&minus;&gt;[2], (($delta&minus;&gt;[2]==1)?'':'s'),
      $sign,
      Date_to_Text(@$target)
  );
  sub Normalize_Delta_YMD
  {
      my($date1,$date2) = @_;
      my(@delta);
      @delta = Delta_YMD(@$date1,@$date2);
      while ($delta[1] &lt; 0 or $delta[2] &lt; 0)
      {
          if ($delta[1] &lt; 0) { $delta[0]&minus;&minus;; $delta[1] += 12; }
          if ($delta[2] &lt; 0)
          {
              $delta[1]&minus;&minus;;
              $delta[2] = Delta_Days(Add_Delta_YM(@$date1,@delta[0,1]),@$date2);
          }
      }
      return \@delta;
  }</pre>


<p style="margin-left:17%; margin-top: 1em">Note that for
normalizing just a time vector, you can use the built-in
function &quot;<i>Normalize_DHMS()</i>&quot;. However, this
will yield either all positive <b><small>OR</small></b> all
negative values, <b><small>NOT</small></b> all positive
values as above.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Date::Calc::Util</i>(3),
<i>Date::Calc::Object</i>(3), <i>Date::Calendar</i>(3),
<i>Date::Calendar::Year</i>(3),
<i>Date::Calendar::Profiles</i>(3).</p>

<pre style="margin-left:11%; margin-top: 1em">  &quot;The Calendar FAQ&quot;:
  http://www.tondering.dk/claus/calendar.html
  by Claus Tondering &lt;claus@tondering.dk&gt;</pre>


<h2>BEWARE
<a name="BEWARE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When you are
using the (deprecated) function
&quot;<i>Language()</i>&quot;, the language setting is
stored in a global variable.</p>

<p style="margin-left:11%; margin-top: 1em">This may cause
conflicts between threads or modules running
concurrently.</p>

<p style="margin-left:11%; margin-top: 1em">Therefore, in
order to avoid such conflicts, <small>NEVER</small> use the
function &quot;<i>Language()</i>&quot;, but
<small>ALWAYS</small> pass a language parameter to the
functions which are language-dependent.</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This man page
documents &quot;Date::Calc&quot; version 6.3.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>


<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1995 &minus; 2009 by Steffen Beyer. All rights reserved.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
free software; you can use, modify and redistribute it under
the same terms as Perl itself, i.e., at your option, under
the terms either of the &quot;Artistic License&quot; or the
&quot; <small>GNU</small> General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The C library
at the core of the module &quot;Date::Calc::XS&quot; can, at
your discretion, also be used, modified and redistributed
under the terms of the &quot; <small>GNU</small> Library
General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the files &quot;Artistic.txt&quot;, &quot;
<small>GNU_GPL</small> .txt&quot; and &quot;
<small>GNU_LGPL</small> .txt&quot; in the
&quot;license&quot; subdirectory of this distribution for
any details!</p>

<h2>DISCLAIMER
<a name="DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">See the &quot;
<small>GNU</small> General Public License&quot; for more
details.</p>

<h2>POD ERRORS
<a name="POD ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Hey! <b>The
above document had some coding errors, which are explained
below:</b> <br>
Around line 1761:</p>

<p style="margin-left:17%;">Non-ASCII character seen before
=encoding in &rsquo;Francais&rsquo;. Assuming
<small>ISO8859&minus;1</small></p>
<hr>
</body>
</html>
