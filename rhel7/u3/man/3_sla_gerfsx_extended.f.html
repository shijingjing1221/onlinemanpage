<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:27:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>sla_gerfsx_extended.f</title>

</head>
<body>

<h1 align="center">sla_gerfsx_extended.f</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Function/Subroutine Documentation">Function/Subroutine Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">sla_gerfsx_extended.f
&minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Functions/Subroutines</b></p>

<p style="margin-left:17%;">subroutine
<b>sla_gerfsx_extended</b> (PREC_TYPE, TRANS_TYPE, N, NRHS,
A, LDA, AF, LDAF, IPIV, COLEQU, C, B, LDB, Y, LDY, BERR_OUT,
N_NORMS, ERRS_N, ERRS_C, RES, AYB, DY, Y_TAIL, RCOND,
ITHRESH, RTHRESH, DZ_UB, IGNORE_CWISE, INFO) <b><br>
SLA_GERFSX_EXTENDED</b> <i>improves the computed solution to
a system of linear equations for general matrices by
performing extra-precise iterative refinement and provides
error bounds and backward error estimates for the
solution.</i></p>

<h2>Function/Subroutine Documentation
<a name="Function/Subroutine Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>subroutine
sla_gerfsx_extended (integerPREC_TYPE, integerTRANS_TYPE,
integerN, integerNRHS, real, dimension( lda, * )A,
integerLDA, real, dimension( ldaf, * )AF, integerLDAF,
integer, dimension( * )IPIV, logicalCOLEQU, real, dimension(
* )C, real, dimension( ldb, * )B, integerLDB, real,
dimension( ldy, * )Y, integerLDY, real, dimension( *
)BERR_OUT, integerN_NORMS, real, dimension( nrhs, * )ERRS_N,
real, dimension( nrhs, * )ERRS_C, real, dimension( * )RES,
real, dimension( * )AYB, real, dimension( * )DY, real,
dimension( * )Y_TAIL, realRCOND, integerITHRESH,
realRTHRESH, realDZ_UB, logicalIGNORE_CWISE, integerINFO)
<br>
SLA_GERFSX_EXTENDED</b></i> improves the computed solution
to a system of linear equations for general matrices by
performing extra-precise iterative refinement and provides
error bounds and backward error estimates for the
solution.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Purpose:</b></p>


<p style="margin-left:17%; margin-top: 1em">SLA_GERFSX_EXTENDED
improves the computed solution to a system of <br>
linear equations by performing extra-precise iterative
refinement <br>
and provides error bounds and backward error estimates for
the solution. <br>
This subroutine is called by SGERFSX to perform iterative
refinement. <br>
In addition to normwise error bound, the code provides
maximum <br>
componentwise error bound if possible. See comments for
ERRS_N <br>
and ERRS_C for details of the error bounds. Note that this
<br>
subroutine is only resonsible for setting the second fields
of <br>
ERRS_N and ERRS_C.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>PREC_TYPE</i></p>

<p style="margin-left:17%; margin-top: 1em">PREC_TYPE is
INTEGER <br>
Specifies the intermediate precision to be used in
refinement. <br>
The value is defined by ILAPREC(P) where P is a CHARACTER
and <br>
P = &rsquo;S&rsquo;: Single <br>
= &rsquo;D&rsquo;: Double <br>
= &rsquo;I&rsquo;: Indigenous <br>
= &rsquo;X&rsquo;, &rsquo;E&rsquo;: Extra</p>


<p style="margin-left:17%; margin-top: 1em"><i>TRANS_TYPE</i></p>

<p style="margin-left:17%; margin-top: 1em">TRANS_TYPE is
INTEGER <br>
Specifies the transposition operation on A. <br>
The value is defined by ILATRANS(T) where T is a CHARACTER
and <br>
T = &rsquo;N&rsquo;: No transpose <br>
= &rsquo;T&rsquo;: Transpose <br>
= &rsquo;C&rsquo;: Conjugate transpose</p>

<p style="margin-left:17%; margin-top: 1em"><i>N</i></p>

<p style="margin-left:17%; margin-top: 1em">N is INTEGER
<br>
The number of linear equations, i.e., the order of the <br>
matrix A. N &gt;= 0.</p>


<p style="margin-left:17%; margin-top: 1em"><i>NRHS</i></p>

<p style="margin-left:17%; margin-top: 1em">NRHS is INTEGER
<br>
The number of right-hand-sides, i.e., the number of columns
of the <br>
matrix B.</p>

<p style="margin-left:17%; margin-top: 1em"><i>A</i></p>

<p style="margin-left:17%; margin-top: 1em">A is REAL
array, dimension (LDA,N) <br>
On entry, the N-by-N matrix A.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDA</i></p>

<p style="margin-left:17%; margin-top: 1em">LDA is INTEGER
<br>
The leading dimension of the array A. LDA &gt;=
max(1,N).</p>

<p style="margin-left:17%; margin-top: 1em"><i>AF</i></p>

<p style="margin-left:17%; margin-top: 1em">AF is REAL
array, dimension (LDAF,N) <br>
The factors L and U from the factorization <br>
A = P*L*U as computed by SGETRF.</p>


<p style="margin-left:17%; margin-top: 1em"><i>LDAF</i></p>

<p style="margin-left:17%; margin-top: 1em">LDAF is INTEGER
<br>
The leading dimension of the array AF. LDAF &gt;=
max(1,N).</p>


<p style="margin-left:17%; margin-top: 1em"><i>IPIV</i></p>

<p style="margin-left:17%; margin-top: 1em">IPIV is INTEGER
array, dimension (N) <br>
The pivot indices from the factorization A = P*L*U <br>
as computed by SGETRF; row i of the matrix was interchanged
<br>
with row IPIV(i).</p>


<p style="margin-left:17%; margin-top: 1em"><i>COLEQU</i></p>

<p style="margin-left:17%; margin-top: 1em">COLEQU is
LOGICAL <br>
If .TRUE. then column equilibration was done to A before
calling <br>
this routine. This is needed to compute the solution and
error <br>
bounds correctly.</p>

<p style="margin-left:17%; margin-top: 1em"><i>C</i></p>

<p style="margin-left:17%; margin-top: 1em">C is REAL
array, dimension (N) <br>
The column scale factors for A. If COLEQU = .FALSE., C <br>
is not accessed. If C is input, each element of C should be
a power <br>
of the radix to ensure a reliable solution and error
estimates. <br>
Scaling by powers of the radix does not cause rounding
errors unless <br>
the result underflows or overflows. Rounding errors during
scaling <br>
lead to refining with a matrix that is not equivalent to the
<br>
input matrix, producing error estimates that may not be <br>
reliable.</p>

<p style="margin-left:17%; margin-top: 1em"><i>B</i></p>

<p style="margin-left:17%; margin-top: 1em">B is REAL
array, dimension (LDB,NRHS) <br>
The right-hand-side matrix B.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDB</i></p>

<p style="margin-left:17%; margin-top: 1em">LDB is INTEGER
<br>
The leading dimension of the array B. LDB &gt;=
max(1,N).</p>

<p style="margin-left:17%; margin-top: 1em"><i>Y</i></p>

<p style="margin-left:17%; margin-top: 1em">Y is REAL
array, dimension (LDY,NRHS) <br>
On entry, the solution matrix X, as computed by SGETRS. <br>
On exit, the improved solution matrix Y.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDY</i></p>

<p style="margin-left:17%; margin-top: 1em">LDY is INTEGER
<br>
The leading dimension of the array Y. LDY &gt;=
max(1,N).</p>


<p style="margin-left:17%; margin-top: 1em"><i>BERR_OUT</i></p>

<p style="margin-left:17%; margin-top: 1em">BERR_OUT is
REAL array, dimension (NRHS) <br>
On exit, BERR_OUT(j) contains the componentwise relative
backward <br>
error for right-hand-side j from the formula <br>
max(i) ( abs(RES(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i)
) <br>
where abs(Z) is the componentwise absolute value of the
matrix <br>
or vector Z. This is computed by SLA_LIN_BERR.</p>


<p style="margin-left:17%; margin-top: 1em"><i>N_NORMS</i></p>

<p style="margin-left:17%; margin-top: 1em">N_NORMS is
INTEGER <br>
Determines which error bounds to return (see ERRS_N <br>
and ERRS_C). <br>
If N_NORMS &gt;= 1 return normwise error bounds. <br>
If N_NORMS &gt;= 2 return componentwise error bounds.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ERRS_N</i></p>

<p style="margin-left:17%; margin-top: 1em">ERRS_N is REAL
array, dimension (NRHS, N_ERR_BNDS) <br>
For each right-hand side, this array contains information
about <br>
various error bounds and condition numbers corresponding to
the <br>
normwise relative error, which is defined as follows:</p>

<p style="margin-left:17%; margin-top: 1em">Normwise
relative error in the ith solution vector: <br>
max_j (abs(XTRUE(j,i) - X(j,i))) <br>
------------------------------ <br>
max_j abs(X(j,i))</p>

<p style="margin-left:17%; margin-top: 1em">The array is
indexed by the type of error information as described <br>
below. There currently are up to three pieces of information
<br>
returned.</p>

<p style="margin-left:17%; margin-top: 1em">The first index
in ERRS_N(i,:) corresponds to the ith <br>
right-hand side.</p>

<p style="margin-left:17%; margin-top: 1em">The second
index in ERRS_N(:,err) contains the following <br>
three fields: <br>
err = 1 &quot;Trust/don&rsquo;t trust&quot; boolean. Trust
the answer if the <br>
reciprocal condition number is less than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;).</p>

<p style="margin-left:17%; margin-top: 1em">err = 2
&quot;Guaranteed&quot; error bound: The estimated forward
error, <br>
almost certainly within a factor of 10 of the true error
<br>
so long as the next entry is greater than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;). This error bound
should only <br>
be trusted if the previous boolean is true.</p>

<p style="margin-left:17%; margin-top: 1em">err = 3
Reciprocal condition number: Estimated normwise <br>
reciprocal condition number. Compared with the threshold
<br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;) to determine if the
error <br>
estimate is &quot;guaranteed&quot;. These reciprocal
condition <br>
numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
<br>
appropriately scaled matrix Z. <br>
Let Z = S*A, where S scales each row by a power of the <br>
radix so all absolute row sums of Z are approximately 1.</p>

<p style="margin-left:17%; margin-top: 1em">This subroutine
is only responsible for setting the second field <br>
above. <br>
See Lapack Working Note 165 for further details and extra
<br>
cautions.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ERRS_C</i></p>

<p style="margin-left:17%; margin-top: 1em">ERRS_C is REAL
array, dimension (NRHS, N_ERR_BNDS) <br>
For each right-hand side, this array contains information
about <br>
various error bounds and condition numbers corresponding to
the <br>
componentwise relative error, which is defined as
follows:</p>

<p style="margin-left:17%; margin-top: 1em">Componentwise
relative error in the ith solution vector: <br>
abs(XTRUE(j,i) - X(j,i)) <br>
max_j ---------------------- <br>
abs(X(j,i))</p>

<p style="margin-left:17%; margin-top: 1em">The array is
indexed by the right-hand side i (on which the <br>
componentwise relative error depends), and the type of error
<br>
information as described below. There currently are up to
three <br>
pieces of information returned for each right-hand side. If
<br>
componentwise accuracy is not requested (PARAMS(3) = 0.0),
then <br>
ERRS_C is not accessed. If N_ERR_BNDS .LT. 3, then at most
<br>
the first (:,N_ERR_BNDS) entries are returned.</p>

<p style="margin-left:17%; margin-top: 1em">The first index
in ERRS_C(i,:) corresponds to the ith <br>
right-hand side.</p>

<p style="margin-left:17%; margin-top: 1em">The second
index in ERRS_C(:,err) contains the following <br>
three fields: <br>
err = 1 &quot;Trust/don&rsquo;t trust&quot; boolean. Trust
the answer if the <br>
reciprocal condition number is less than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;).</p>

<p style="margin-left:17%; margin-top: 1em">err = 2
&quot;Guaranteed&quot; error bound: The estimated forward
error, <br>
almost certainly within a factor of 10 of the true error
<br>
so long as the next entry is greater than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;). This error bound
should only <br>
be trusted if the previous boolean is true.</p>

<p style="margin-left:17%; margin-top: 1em">err = 3
Reciprocal condition number: Estimated componentwise <br>
reciprocal condition number. Compared with the threshold
<br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;) to determine if the
error <br>
estimate is &quot;guaranteed&quot;. These reciprocal
condition <br>
numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
<br>
appropriately scaled matrix Z. <br>
Let Z = S*(A*diag(x)), where x is the solution for the <br>
current right-hand side and S scales each row of <br>
A*diag(x) by a power of the radix so all absolute row <br>
sums of Z are approximately 1.</p>

<p style="margin-left:17%; margin-top: 1em">This subroutine
is only responsible for setting the second field <br>
above. <br>
See Lapack Working Note 165 for further details and extra
<br>
cautions.</p>

<p style="margin-left:17%; margin-top: 1em"><i>RES</i></p>

<p style="margin-left:17%; margin-top: 1em">RES is REAL
array, dimension (N) <br>
Workspace to hold the intermediate residual.</p>

<p style="margin-left:17%; margin-top: 1em"><i>AYB</i></p>

<p style="margin-left:17%; margin-top: 1em">AYB is REAL
array, dimension (N) <br>
Workspace. This can be the same workspace passed for
Y_TAIL.</p>

<p style="margin-left:17%; margin-top: 1em"><i>DY</i></p>

<p style="margin-left:17%; margin-top: 1em">DY is REAL
array, dimension (N) <br>
Workspace to hold the intermediate solution.</p>


<p style="margin-left:17%; margin-top: 1em"><i>Y_TAIL</i></p>

<p style="margin-left:17%; margin-top: 1em">Y_TAIL is REAL
array, dimension (N) <br>
Workspace to hold the trailing bits of the intermediate
solution.</p>


<p style="margin-left:17%; margin-top: 1em"><i>RCOND</i></p>

<p style="margin-left:17%; margin-top: 1em">RCOND is REAL
<br>
Reciprocal scaled condition number. This is an estimate of
the <br>
reciprocal Skeel condition number of the matrix A after <br>
equilibration (if done). If this is less than the machine
<br>
precision (in particular, if it is zero), the matrix is
singular <br>
to working precision. Note that the error may still be small
even <br>
if this number is very small and the matrix appears ill-
<br>
conditioned.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ITHRESH</i></p>

<p style="margin-left:17%; margin-top: 1em">ITHRESH is
INTEGER <br>
The maximum number of residual computations allowed for <br>
refinement. The default is 10. For &rsquo;aggressive&rsquo;
set to 100 to <br>
permit convergence using approximate factorizations or <br>
factorizations other than LU. If the factorization uses a
<br>
technique other than Gaussian elimination, the guarantees in
<br>
ERRS_N and ERRS_C may no longer be trustworthy.</p>


<p style="margin-left:17%; margin-top: 1em"><i>RTHRESH</i></p>

<p style="margin-left:17%; margin-top: 1em">RTHRESH is REAL
<br>
Determines when to stop refinement if the error estimate
stops <br>
decreasing. Refinement will stop when the next solution no
longer <br>
satisfies norm(dx_{i+1}) &lt; RTHRESH * norm(dx_i) where
norm(Z) is <br>
the infinity norm of Z. RTHRESH satisfies 0 &lt; RTHRESH
&lt;= 1. The <br>
default value is 0.5. For &rsquo;aggressive&rsquo; set to
0.9 to permit <br>
convergence on extremely ill-conditioned matrices. See LAWN
165 <br>
for more details.</p>


<p style="margin-left:17%; margin-top: 1em"><i>DZ_UB</i></p>

<p style="margin-left:17%; margin-top: 1em">DZ_UB is REAL
<br>
Determines when to start considering componentwise
convergence. <br>
Componentwise convergence is only considered after each
component <br>
of the solution Y is stable, which we definte as the
relative <br>
change in each component being less than DZ_UB. The default
value <br>
is 0.25, requiring the first bit to be stable. See LAWN 165
for <br>
more details.</p>


<p style="margin-left:17%; margin-top: 1em"><i>IGNORE_CWISE</i></p>

<p style="margin-left:17%; margin-top: 1em">IGNORE_CWISE is
LOGICAL <br>
If .TRUE. then ignore componentwise convergence. Default
value <br>
is .FALSE..</p>


<p style="margin-left:17%; margin-top: 1em"><i>INFO</i></p>

<p style="margin-left:17%; margin-top: 1em">INFO is INTEGER
<br>
= 0: Successful exit. <br>
&lt; 0: if INFO = -i, the ith argument to SGETRS had an
illegal <br>
value</p>


<p style="margin-left:11%; margin-top: 1em"><b>Author:</b></p>

<p style="margin-left:17%;">Univ. of Tennessee</p>

<p style="margin-left:17%; margin-top: 1em">Univ. of
California Berkeley</p>

<p style="margin-left:17%; margin-top: 1em">Univ. of
Colorado Denver</p>

<p style="margin-left:17%; margin-top: 1em">NAG Ltd.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Date:</b></p>

<p style="margin-left:17%;">September 2012</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 393 of file sla_gerfsx_extended.f.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for LAPACK from the source
code.</p>
<hr>
</body>
</html>
