<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Fri Nov 11 22:51:01 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>virt-v2v</title>

</head>
<body>

<h1 align="center">virt-v2v</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INPUT AND OUTPUT MODES">INPUT AND OUTPUT MODES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#XEN PARAVIRTUALIZED GUESTS">XEN PARAVIRTUALIZED GUESTS</a><br>
<a href="#ENABLING VIRTIO">ENABLING VIRTIO</a><br>
<a href="#RHEL 4">RHEL 4</a><br>
<a href="#WINDOWS">WINDOWS</a><br>
<a href="#UEFI">UEFI</a><br>
<a href="#NETWORKS AND BRIDGES">NETWORKS AND BRIDGES</a><br>
<a href="#INPUT FROM VMWARE VCENTER SERVER">INPUT FROM VMWARE VCENTER SERVER</a><br>
<a href="#INPUT FROM VMWARE OVA">INPUT FROM VMWARE OVA</a><br>
<a href="#INPUT FROM VMWARE ESXi HYPERVISOR">INPUT FROM VMWARE ESXi HYPERVISOR</a><br>
<a href="#INPUT FROM RHEL 5 XEN">INPUT FROM RHEL 5 XEN</a><br>
<a href="#OUTPUT TO LIBVIRT">OUTPUT TO LIBVIRT</a><br>
<a href="#OUTPUT TO RHEV">OUTPUT TO RHEV</a><br>
<a href="#OUTPUT TO GLANCE">OUTPUT TO GLANCE</a><br>
<a href="#RESOURCE REQUIREMENTS">RESOURCE REQUIREMENTS</a><br>
<a href="#POST-CONVERSION TASKS">POST-CONVERSION TASKS</a><br>
<a href="#FREE SPACE FOR CONVERSION">FREE SPACE FOR CONVERSION</a><br>
<a href="#RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT">RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT</a><br>
<a href="#DEBUGGING RHEV-M IMPORT FAILURES">DEBUGGING RHEV-M IMPORT FAILURES</a><br>
<a href="#MINIMAL XML FOR &minus;i libvirtxml OPTION">MINIMAL XML FOR &minus;i libvirtxml OPTION</a><br>
<a href="#MACHINE READABLE OUTPUT">MACHINE READABLE OUTPUT</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#OTHER TOOLS">OTHER TOOLS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">virt&minus;v2v
&minus; Convert a guest to use KVM</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest
 virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
   &minus;o rhev &minus;os rhev.nfs:/export_domain &minus;&minus;network rhevm
 virt&minus;v2v &minus;i libvirtxml guest&minus;domain.xml &minus;o local &minus;os /var/tmp
 virt&minus;v2v &minus;i disk disk.img &minus;o local &minus;os /var/tmp
 virt&minus;v2v &minus;i disk disk.img &minus;o glance</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
converts guests from a foreign hypervisor to run on
<small>KVM.</small> It can read Linux and Windows guests
running on VMware, Xen, Hyper-V and some other hypervisors,
and convert them to <small>KVM</small> managed by libvirt,
OpenStack, oVirt, Red Hat Enterprise Virtualisation (
<small>RHEV</small> ) or several other targets.</p>

<p style="margin-left:11%; margin-top: 1em">There is also a
companion front-end called <i>virt&minus;p2v</i>(1) which
comes as an <small>ISO, CD</small> or <small>PXE</small>
image that can be booted on physical machines to virtualize
those machines (physical to virtual, or p2v).</p>

<p style="margin-left:11%; margin-top: 1em">This manual
page documents the rewritten virt&minus;v2v included in
libguestfs &ge; 1.28.</p>

<h2>INPUT AND OUTPUT MODES
<a name="INPUT AND OUTPUT MODES"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">                          &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;  &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o null
 &minus;i disk &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;    &#9474;            &#9474; &#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o local
 &minus;i ova  &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9492;&#9472;&#9472;&#9654; &#9474; virt&minus;v2v   &#9474; &#9472;&#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o qemu
                   &#9492;&#9472;&#9472;&#9472;&#9472;&#9654; &#9474; conversion &#9474; &#9472;&#9472;&#9472;&#9496;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
 VMware&#9472;&#9654;&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;   &#9474; server     &#9474; &#9472;&#9472;&#9472;&#9472;&#9654; &minus;o libvirt &#9474;&#9472;&#9654; KVM
 Xen &#9472;&#9472;&#9472;&#9654;&#9474; &minus;i libvirt &#9472;&#9472;&#9654; &#9474;            &#9474;     &#9474;  (default) &#9474;
 ... &#9472;&#9472;&#9472;&#9654;&#9474;  (default) &#9474;   &#9474;            &#9474; &#9472;&#9472;&#9488; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;
         &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;   &#9474;            &#9474; &#9472;&#9488;&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o glance
 &minus;i libvirtxml &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &#9474;            &#9474; &#9488;&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o rhev
                          &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; &minus;o vdsm</pre>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
has a number of possible input and output modes, selected
using the <i>&minus;i</i> and <i>&minus;o</i> options. Only
one input and output mode can be selected for each run of
virt&minus;v2v.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
disk</i> is used for reading from local disk images (mainly
for testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
libvirt</i> is used for reading from any libvirt source.
Since libvirt can connect to many different hypervisors, it
is used for reading guests from VMware, <small>RHEL
5</small> Xen and more. The <i>&minus;ic</i> option selects
the precise libvirt source.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
libvirtxml</i> is used to read from libvirt
<small>XML</small> files. This is the method used by
<i>virt&minus;p2v</i>(1) behind the scenes.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;i
ova</i> is used for reading from a VMware ova source
file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
glance</i> is used for writing to OpenStack Glance.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
libvirt</i> is used for writing to any libvirt target.
Libvirt can connect to local or remote <small>KVM</small>
hypervisors. The <i>&minus;oc</i> option selects the precise
libvirt target.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
local</i> is used to write to a local disk image with a
local libvirt configuration file (mainly for testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
qemu</i> writes to a local disk image with a shell script
for booting the guest directly in qemu (mainly for
testing).</p>

<p style="margin-left:11%; margin-top: 1em"><i>&minus;o
rhev</i> is used to write to a RHEV-M / oVirt target.
<i>&minus;o vdsm</i> is only used when virt&minus;v2v runs
under <small>VDSM</small> control.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Convert from
VMware vCenter server to local libvirt</b> <br>
You have a VMware vCenter server called
<tt>&quot;vcenter.example.com&quot;</tt>, a datacenter
called <tt>&quot;Datacenter&quot;</tt>, and an ESXi
hypervisor called <tt>&quot;esxi&quot;</tt>. You want to
convert a guest called <tt>&quot;vmware_guest&quot;</tt> to
run locally under libvirt.</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest</pre>


<p style="margin-left:11%; margin-top: 1em">In this case
you will most likely have to run virt&minus;v2v as
<tt>&quot;root&quot;</tt>, since it needs to talk to the
system libvirt daemon and copy the guest disks to
<i>/var/lib/libvirt/images</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information see &quot; <small>INPUT FROM VMWARE VCENTER
SERVER&quot;</small> below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert from
VMware to RHEV&minus;M/oVirt</b> <br>
This is the same as the previous example, except you want to
send the guest to a RHEV-M Export Storage Domain which is
located remotely (over <small>NFS</small> ) at
<tt>&quot;rhev.nfs:/export_domain&quot;</tt>. If you are
unclear about the location of the Export Storage Domain you
should check the settings on your RHEV-M management console.
Guest network interface(s) are connected to the target
network called <tt>&quot;rhevm&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
   &minus;o rhev &minus;os rhev.nfs:/export_domain &minus;&minus;network rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">In this case
the host running virt&minus;v2v acts as a <b>conversion
server</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that after
conversion, the guest will appear in the RHEV-M Export
Storage Domain, from where you will need to import it using
the RHEV-M user interface. (See &quot; <small>OUTPUT TO
RHEV&quot;</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert disk
image to OpenStack glance</b> <br>
Given a disk image from another hypervisor that you want to
convert to run on OpenStack (only KVM-based OpenStack is
supported), you can do:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i disk disk.img &minus;o glance</pre>


<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>OUTPUT TO GLANCE&quot;</small> below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert disk
image to disk image</b> <br>
Given a disk image from another hypervisor that you want to
convert to run on <small>KVM,</small> you have two options.
The simplest way is to try:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i disk disk.img &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
virt&minus;v2v guesses everything about the input
<i>disk.img</i> and (in this case) writes the converted
result to <i>/var/tmp</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A more complex
method is to write some libvirt <small>XML</small>
describing the input guest (if you can get the source
hypervisor to provide you with libvirt <small>XML,</small>
then so much the better). You can then do:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v &minus;i libvirtxml guest&minus;domain.xml &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">Since
<i>guest&minus;domain.xml</i> contains the path(s) to the
guest disk image(s) you do not need to specify the name of
the disk image on the command line.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Display help.</p>

<p style="margin-left:11%;"><b>&minus;b</b> ... <b><br>
&minus;&minus;bridge</b> ...</p>

<p style="margin-left:17%;">See
<i>&minus;&minus;network</i> below.</p>

<p style="margin-left:11%;"><b>&minus;&minus;colors <br>
&minus;&minus;colours</b></p>

<p style="margin-left:17%;">Use <small>ANSI</small> colour
sequences to colourize messages. This is the default when
the output is a tty. If the output of the program is
redirected to a file, <small>ANSI</small> colour sequences
are disabled unless you use this option.</p>


<p style="margin-left:11%;"><b>&minus;&minus;compressed</b></p>

<p style="margin-left:17%;">Write a compressed output file.
This is only allowed if the output format is qcow2 (see
<i>&minus;of</i> below), and is equivalent to the
<i>&minus;c</i> option of <i>qemu&minus;img</i>(1).</p>


<p style="margin-left:11%;"><b>&minus;&minus;debug&minus;gc</b></p>

<p style="margin-left:17%;">Debug garbage collection and
memory allocation. This is only useful when debugging memory
problems in virt&minus;v2v or the OCaml libguestfs
bindings.</p>


<p style="margin-left:11%;"><b>&minus;&minus;debug&minus;overlays</b></p>

<p style="margin-left:17%;">Save the overlay file(s)
created during conversion. This option is only used for
debugging virt&minus;v2v and may be removed in a future
version.</p>

<p style="margin-left:11%;"><b>&minus;i disk</b></p>

<p style="margin-left:17%;">Set the input method to
<i>disk</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you can read a virtual machine disk image with no metadata.
virt&minus;v2v tries to guess the best default metadata.
This is usually adequate but you can get finer control (eg.
of memory and vCPUs) by using <i>&minus;i libvirtxml</i>
instead. Only guests that use a single disk can be imported
this way.</p>

<p style="margin-left:11%;"><b>&minus;i libvirt</b></p>

<p style="margin-left:17%;">Set the input method to
<i>libvirt</i>. This is the default.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you have to specify a libvirt guest name or
<small>UUID</small> on the command line. You may also
specify a libvirt connection <small>URI</small> (see
<i>&minus;ic</i>).</p>

<p style="margin-left:11%;"><b>&minus;i libvirtxml</b></p>

<p style="margin-left:17%;">Set the input method to
<i>libvirtxml</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you have to pass a libvirt <small>XML</small> file on the
command line. This file is read in order to get metadata
about the source guest (such as its name, amount of memory),
and also to locate the input disks. See &quot;
<small>MINIMAL XML FOR</small> &minus;i libvirtxml
<small>OPTION&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;i local</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;i
disk</i>.</p>

<p style="margin-left:11%;"><b>&minus;i ova</b></p>

<p style="margin-left:17%;">Set the input method to
<i>ova</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode
you can read a VMware ova file. Virt&minus;v2v will read the
ova manifest file and check the vmdk volumes for validity
(checksums) as well as analyzing the ovf file, and then
convert the guest. See &quot; <small>INPUT FROM VMWARE
OVA&quot;</small> below</p>

<p style="margin-left:11%;"><b>&minus;ic</b> libvirtURI</p>

<p style="margin-left:17%;">Specify a libvirt connection
<small>URI</small> to use when reading the guest. This is
only used when <i>&minus;i&nbsp;libvirt</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Only local
libvirt connections, VMware vCenter connections, or
<small>RHEL 5</small> Xen remote connections can be used.
Other remote libvirt connections will not work in
general.</p>

<p style="margin-left:17%; margin-top: 1em">See also &quot;
<small>INPUT FROM VMWARE VCENTER SERVER&quot;</small> ,
&quot; <small>INPUT FROM RHEL 5 XEN&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;if</b> format</p>

<p style="margin-left:17%;">For <i>&minus;i disk</i> only,
this specifies the format of the input disk image. For other
input methods you should specify the input format in the
metadata.</p>


<p style="margin-left:11%;"><b>&minus;&minus;machine&minus;readable</b></p>

<p style="margin-left:17%;">This option is used to make the
output more machine friendly when being parsed by other
programs. See &quot; <small>MACHINE READABLE
OUTPUT&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;n</b> in:out <b><br>
&minus;n</b> out <b><br>
&minus;&minus;network</b> in:out <b><br>
&minus;&minus;network</b> out <b><br>
&minus;b</b> in:out <b><br>
&minus;b</b> out <b><br>
&minus;&minus;bridge</b> in:out <b><br>
&minus;&minus;bridge</b> out</p>

<p style="margin-left:17%;">Map network (or bridge) called
<tt>&quot;in&quot;</tt> to network (or bridge) called
<tt>&quot;out&quot;</tt>. If no <tt>&quot;in:&quot;</tt>
prefix is given, all other networks (or bridges) are mapped
to <tt>&quot;out&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>NETWORKS AND BRIDGES&quot;</small> below.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;copy</b></p>

<p style="margin-left:17%;">Don&rsquo;t copy the disks.
Instead, conversion is performed (and thrown away), and
metadata is written, but no disks are created. See also
discussion of <i>&minus;o&nbsp;null</i> below.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
in two cases: Either you want to test if conversion is
likely to succeed, without the long copying process. Or you
are only interested in looking at the metadata.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
not compatible with <i>&minus;o libvirt</i> since it would
create a faulty guest (one with no disks).</p>

<p style="margin-left:17%; margin-top: 1em">This option is
not compatible with <i>&minus;o glance</i> for technical
reasons.</p>

<p style="margin-left:11%;"><b>&minus;&minus;no&minus;trim
all <br>
&minus;&minus;no&minus;trim</b> mp[,mp...]</p>

<p style="margin-left:17%;">By default virt&minus;v2v runs
<i>fstrim</i>(8) to reduce the amount of data that needs to
be copied. This is known to break some buggy bootloaders
causing boot failures after conversion (see for example
https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27).</p>

<p style="margin-left:17%; margin-top: 1em">You can use
<i>&minus;&minus;no&minus;trim all</i> to disable all
trimming. Note this will greatly increase the amount of data
that has to be copied and can make virt&minus;v2v run much
more slowly.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
disable trimming on selected filesystems only (specified by
a comma-separated list of their mount point(s) in the
guest). Typically you would use
<i>&minus;&minus;no&minus;trim /boot</i> to work around the
grub bug mentioned above.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
disable trimming on partitions using the libguestfs naming
scheme for devices, eg: <i>&minus;&minus;no&minus;trim
/dev/sdb2</i> means do not trim the second partition on the
second block device. Use <i>virt&minus;filesystems</i>(1) to
list filesystem names in a guest.</p>

<p style="margin-left:11%;"><b>&minus;o disk</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;o
local</i>.</p>

<p style="margin-left:11%;"><b>&minus;o glance</b></p>

<p style="margin-left:17%;">Set the output method to
OpenStack Glance. In this mode the converted guest is
uploaded to Glance. See &quot; <small>OUTPUT TO
GLANCE&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;o libvirt</b></p>

<p style="margin-left:17%;">Set the output method to
<i>libvirt</i>. This is the default.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode,
the converted guest is created as a libvirt guest. You may
also specify a libvirt connection <small>URI</small> (see
<i>&minus;oc</i>).</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>OUTPUT TO LIBVIRT&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;o local</b></p>

<p style="margin-left:17%;">Set the output method to
<i>local</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In this mode,
the converted guest is written to a local directory
specified by <i>&minus;os /dir</i> (the directory must
exist). The converted guest&rsquo;s disks are written
as:</p>

<pre style="margin-left:17%; margin-top: 1em"> /dir/name&minus;sda
 /dir/name&minus;sdb
 [etc]</pre>


<p style="margin-left:17%; margin-top: 1em">and a libvirt
<small>XML</small> file is created containing guest
metadata:</p>

<pre style="margin-left:17%; margin-top: 1em"> /dir/name.xml</pre>


<p style="margin-left:17%; margin-top: 1em">where
<tt>&quot;name&quot;</tt> is the guest name.</p>

<p style="margin-left:11%;"><b>&minus;o null</b></p>

<p style="margin-left:17%;">Set the output method to
<i>null</i>.</p>

<p style="margin-left:17%; margin-top: 1em">The guest is
converted and copied (unless you also specify
<i>&minus;&minus;no&minus;copy</i>), but the results are
thrown away and no metadata is written.</p>

<p style="margin-left:11%;"><b>&minus;o ovirt</b></p>

<p style="margin-left:17%;">This is the same as <i>&minus;o
rhev</i>.</p>

<p style="margin-left:11%;"><b>&minus;o qemu</b></p>

<p style="margin-left:17%;">Set the output method to
<i>qemu</i>.</p>

<p style="margin-left:17%; margin-top: 1em">This is similar
to <i>&minus;o local</i>, except that a shell script is
written which you can use to boot the guest in qemu. The
converted disks and shell script are written to the
directory specified by <i>&minus;os</i>.</p>

<p style="margin-left:11%;"><b>&minus;o rhev</b></p>

<p style="margin-left:17%;">Set the output method to
<i>rhev</i>.</p>

<p style="margin-left:17%; margin-top: 1em">The converted
guest is written to a <small>RHEV</small> Export Storage
Domain. The <i>&minus;os</i> parameter must also be used to
specify the location of the Export Storage Domain. Note this
does not actually import the guest into <small>RHEV.</small>
You have to do that manually later using the
<small>UI.</small></p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>OUTPUT TO RHEV&quot;</small> below.</p>

<p style="margin-left:11%;"><b>&minus;o vdsm</b></p>

<p style="margin-left:17%;">Set the output method to
<i>vdsm</i>.</p>

<p style="margin-left:17%; margin-top: 1em">This mode is
similar to <i>&minus;o rhev</i>, but the full path to the
data domain must be given:
<i>/rhev/data&minus;center/&lt;data&minus;center&minus;uuid&gt;/&lt;data&minus;domain&minus;uuid&gt;</i>.
This mode is only used when virt&minus;v2v runs under
<small>VDSM</small> control.</p>

<p style="margin-left:11%;"><b>&minus;oa sparse <br>
&minus;oa preallocated</b></p>

<p style="margin-left:17%;">Set the output file allocation
mode. The default is <tt>&quot;sparse&quot;</tt>.</p>

<p style="margin-left:11%;"><b>&minus;oc</b> libvirtURI</p>

<p style="margin-left:17%;">Specify a libvirt connection to
use when writing the converted guest. This is only used when
<i>&minus;o&nbsp;libvirt</i>. See &quot; <small>OUTPUT TO
LIBVIRT&quot;</small> below.</p>

<p style="margin-left:17%; margin-top: 1em">Only local
libvirt connections can be used. Remote libvirt connections
will not work.</p>

<p style="margin-left:11%;"><b>&minus;of</b> format</p>

<p style="margin-left:17%;">When converting the guest,
convert the disks to the given format.</p>

<p style="margin-left:17%; margin-top: 1em">If not
specified, then the input format is used.</p>

<p style="margin-left:11%;"><b>&minus;on</b> name</p>

<p style="margin-left:17%;">Rename the guest when
converting it. If this option is not used then the output
name is the same as the input name.</p>

<p style="margin-left:11%;"><b>&minus;os</b> storage</p>

<p style="margin-left:17%;">The location of the storage for
the converted guest.</p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
libvirt</i>, this is a libvirt directory pool (see
<tt>&quot;virsh&nbsp;pool&minus;list&quot;</tt>) or pool
<small>UUID.</small></p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
local</i> and <i>&minus;o qemu</i>, this is a directory
name. The directory must exist.</p>

<p style="margin-left:17%; margin-top: 1em">For <i>&minus;o
rhev</i>, this can be an <small>NFS</small> path of the
Export Storage Domain of the form
<tt>&quot;&lt;host&gt;:&lt;path&gt;&quot;</tt>, eg:</p>

<pre style="margin-left:17%; margin-top: 1em"> rhev&minus;storage.example.com:/rhev/export</pre>


<p style="margin-left:17%; margin-top: 1em">The
<small>NFS</small> export must be mountable and writable by
the user and host running virt&minus;v2v, since the
virt&minus;v2v program has to actually mount it when it
runs. So you probably have to run virt&minus;v2v as
<tt>&quot;root&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em"><b>Or:</b> You
can mount the Export Storage Domain yourself, and point
<i>&minus;os</i> to the mountpoint. Note that virt&minus;v2v
will still need to write to this remote directory, so
virt&minus;v2v will still need to run as
<tt>&quot;root&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">You will get an
error if virt&minus;v2v is unable to mount/write to the
Export Storage Domain.</p>


<p style="margin-left:11%;"><b>&minus;&minus;password&minus;file</b>
file</p>

<p style="margin-left:17%;">Instead of asking for
password(s) interactively, pass the password through a file.
Note the file should contain the whole password, <b>without
any trailing newline</b>, and for security the file should
have mode <tt>0600</tt> so that others cannot read it.</p>


<p style="margin-left:11%;"><b>&minus;&minus;print&minus;source</b></p>

<p style="margin-left:17%;">Print information about the
source guest and stop. This option is useful when you are
setting up network and bridge maps. See &quot;
<small>NETWORKS AND BRIDGES&quot;</small> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;q</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;quiet</b></p>

<p style="margin-left:17%;">This disables progress bars and
other unnecessary output.</p>

<p style="margin-left:11%;"><b>&minus;&minus;root ask <br>
&minus;&minus;root single <br>
&minus;&minus;root first <br>
&minus;&minus;root</b> /dev/sdX <b><br>
&minus;&minus;root</b> /dev/VG/LV</p>

<p style="margin-left:17%;">Choose the root filesystem to
be converted.</p>

<p style="margin-left:17%; margin-top: 1em">In the case
where the virtual machine is dual-boot or multi-boot, or
where the <small>VM</small> has other filesystems that look
like operating systems, this option can be used to select
the root filesystem (a.k.a. <tt>&quot;C:&quot;</tt> drive or
<i>/</i>) of the operating system that is to be converted.
The Windows Recovery Console, certain attached
<small>DVD</small> drives, and bugs in libguestfs inspection
heuristics, can make a guest look like a multi-boot
operating system.</p>

<p style="margin-left:17%; margin-top: 1em">The default in
virt&minus;v2v &le; 0.7.1 was
<i>&minus;&minus;root&nbsp;single</i>, which causes
virt&minus;v2v to die if a multi-boot operating system is
found.</p>

<p style="margin-left:17%; margin-top: 1em">Since
virt&minus;v2v &ge; 0.7.2 the default is now
<i>&minus;&minus;root&nbsp;ask</i>: If the <small>VM</small>
is found to be multi-boot, then virt&minus;v2v will stop and
list the possible root filesystems and ask the user which to
use. This requires that virt&minus;v2v is run
interactively.</p>


<p style="margin-left:17%; margin-top: 1em"><i>&minus;&minus;root&nbsp;first</i>
means to choose the first root device in the case of a
multi-boot operating system. Since this is a heuristic, it
may sometimes choose the wrong one.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
name a specific root device, eg.
<i>&minus;&minus;root&nbsp;/dev/sda2</i> would mean to use
the second partition on the first hard drive. If the named
root device does not exist or was not detected as a root
device, then virt&minus;v2v will fail.</p>

<p style="margin-left:17%; margin-top: 1em">Note that there
is a bug in grub which prevents it from successfully booting
a multiboot system if VirtIO is enabled. Grub is only able
to boot an operating system from the first VirtIO disk.
Specifically, <i>/boot</i> must be on the first VirtIO disk,
and it cannot chainload an <small>OS</small> which is not in
the first VirtIO disk.</p>


<p style="margin-left:11%;"><b>&minus;&minus;vdsm&minus;image&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;vol&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;vm&minus;uuid</b>
<small>UUID</small> <b><br>
&minus;&minus;vdsm&minus;ovf&minus;output</b></p>

<p style="margin-left:17%;">Normally the
<small>RHEV</small> output mode chooses random UUIDs for the
target guest. However <small>VDSM</small> needs to control
the UUIDs and passes these parameters when virt&minus;v2v
runs under <small>VDSM</small> control. The parameters
control:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the image directory of each guest disk
(<i>&minus;&minus;vdsm&minus;image&minus;uuid</i>) (this
option is passed once for each guest disk)</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>UUIDs for each guest disk
(<i>&minus;&minus;vdsm&minus;vol&minus;uuid</i>) (this
option is passed once for each guest disk)</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the <small>OVF</small> file name
(<i>&minus;&minus;vdsm&minus;vm&minus;uuid</i>).</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>the <small>OVF</small> output directory (default current
directory)
(<i>&minus;&minus;vdsm&minus;ovf&minus;output</i>).</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The format of
UUIDs is:
<tt>&quot;12345678&minus;1234&minus;1234&minus;1234&minus;123456789abc&quot;</tt>
(each hex digit can be <tt>&quot;0&minus;9&quot;</tt> or
<tt>&quot;a&minus;f&quot;</tt>), conforming to
<small>OSF&nbsp;DCE&nbsp;1.1.</small></p>

<p style="margin-left:17%; margin-top: 1em">These options
can only be used with <i>&minus;o vdsm</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;v</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Enable verbose messages for
debugging.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;V</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:17%;">Display version number and
exit.</p>

<p style="margin-left:11%;"><b>&minus;&minus;vmtype desktop
<br>
&minus;&minus;vmtype server</b></p>

<p style="margin-left:17%;">For the <i>&minus;o rhev</i> or
<i>&minus;o vdsm</i> targets only, specify the type of
guest. You can set this to <tt>&quot;desktop&quot;</tt> or
<tt>&quot;server&quot;</tt>. If the option is not given,
then a suitable default is chosen based on the detected
guest operating system.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;x</b></p></td>
<td width="3%"></td>
<td width="60%">


<p>Enable tracing of libguestfs <small>API</small>
calls.</p> </td>
<td width="23%">
</td></tr>
</table>

<h2>XEN PARAVIRTUALIZED GUESTS
<a name="XEN PARAVIRTUALIZED GUESTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Older versions
of virt&minus;v2v could turn a Xen paravirtualized (
<small>PV</small> ) guest into a <small>KVM</small> guest by
installing a new kernel. This version of virt&minus;v2v does
<i>not</i> attempt to install any new kernels. Instead it
will give you an error if there are <i>only</i> Xen
<small>PV</small> kernels available.</p>

<p style="margin-left:11%; margin-top: 1em">Therefore
before conversion you should check that a regular kernel is
installed. For some older Linux distributions, this means
installing a kernel from the table below:</p>

<pre style="margin-left:11%; margin-top: 1em"> RHEL 3         (Does not apply, as there was no Xen PV kernel)
 RHEL 4         i686 with &gt; 10GB of RAM: install 'kernel&minus;hugemem'
                i686 SMP: install 'kernel&minus;smp'
                other i686: install 'kernel'
                x86&minus;64 SMP with &gt; 8 CPUs: install 'kernel&minus;largesmp'
                x86&minus;64 SMP: install 'kernel&minus;smp'
                other x86&minus;64: install 'kernel'
 RHEL 5         i686: install 'kernel&minus;PAE'
                x86&minus;64: install 'kernel'
 SLES 10        i586 with &gt; 10GB of RAM: install 'kernel&minus;bigsmp'
                i586 SMP: install 'kernel&minus;smp'
                other i586: install 'kernel&minus;default'
                x86&minus;64 SMP: install 'kernel&minus;smp'
                other x86&minus;64: install 'kernel&minus;default'
 SLES 11+       i586: install 'kernel&minus;pae'
                x86&minus;64: install 'kernel&minus;default'
 Windows        (Does not apply, as there is no Xen PV Windows kernel)</pre>


<h2>ENABLING VIRTIO
<a name="ENABLING VIRTIO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;Virtio&quot;
is the name for a set of drivers which make disk (block
device), network and other guest operations work much faster
on <small>KVM.</small></p>

<p style="margin-left:11%; margin-top: 1em">Older versions
of virt&minus;v2v could install these drivers for certain
Linux guests. This version of virt&minus;v2v does <i>not</i>
attempt to install new Linux kernels or drivers, but will
warn you if they are not installed already.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
enable virtio, and hence improve performance of the guest
after conversion, you should ensure that the <b>minimum</b>
versions of packages are installed <i>before</i> conversion,
by consulting the table below.</p>

<pre style="margin-left:11%; margin-top: 1em"> RHEL 3         No virtio drivers are available
 RHEL 4         kernel &gt;= 2.5.9&minus;89.EL
                lvm2 &gt;= 2.02.42&minus;5.el4
                device&minus;mapper &gt;= 1.02.28&minus;2.el4
                selinux&minus;policy&minus;targeted &gt;= 1.17.30&minus;2.152.el4
                policycoreutils &gt;= 1.18.1&minus;4.13
 RHEL 5         kernel &gt;= 2.6.18&minus;128.el5
                lvm2 &gt;= 2.02.40&minus;6.el5
                selinux&minus;policy&minus;targeted &gt;= 2.4.6&minus;203.el5
 RHEL 6+        All versions support virtio
 Fedora         All versions support virtio
 SLES 11+       All versions support virtio
 SLES 10        kernel &gt;= 2.6.16.60&minus;0.85.1
 OpenSUSE 11+   All versions support virtio
 OpenSUSE 10    kernel &gt;= 2.6.25.5&minus;1.1
 Windows        Drivers are installed from the directory pointed to by
                &quot;VIRTIO_WIN&quot; environment variable
                (/usr/share/virtio&minus;win by default) if present</pre>


<h2>RHEL 4
<a name="RHEL 4"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>SELinux
relabel appears to hang forever</b> <br>
In <small>RHEL</small> &le; 4.7 there was a bug which causes
SELinux relabelling to appear to hang forever at:</p>

<pre style="margin-left:11%; margin-top: 1em"> *** Warning &minus;&minus; SELinux relabel is required. ***
 *** Disabling security enforcement.         ***
 *** Relabeling could take a very long time, ***
 *** depending on file system size.          ***</pre>


<p style="margin-left:11%; margin-top: 1em">In reality it
is waiting for you to press a key (but there is no visual
indication of this). You can either hit the
<tt>&quot;[Return]&quot;</tt> key, at which point the guest
will finish relabelling and reboot, or you can install
policycoreutils &ge; 1.18.1&minus;4.13 before starting the
v2v conversion. See also
https://bugzilla.redhat.com/show_bug.cgi?id=244636</p>

<h2>WINDOWS
<a name="WINDOWS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Windows &ge;
8 Fast Startup is incompatible with virt&minus;v2v</b> <br>
Guests which use the Windows &ge; 8 &quot;Fast Startup&quot;
feature (or guests which are hibernated) cannot be converted
with virt&minus;v2v. You will see an error:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v: error: unable to mount the disk image for writing. This has
 probably happened because Windows Hibernation or Fast Restart is being
 used in this guest. You have to disable this (in the guest) in order
 to use virt&minus;v2v.</pre>


<p style="margin-left:11%; margin-top: 1em">As the message
says, you need to boot the guest and disable the &quot;Fast
Startup&quot; feature (Control Panel &rarr; Power Options
&rarr; Choose what the power buttons do &rarr; Change
settings that are currently unavailable &rarr; Turn on fast
startup), and shut down the guest, and then you will be able
to convert it.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information, see: &quot; <small>WINDOWS HIBERNATION AND
WINDOWS 8 FAST STARTUP&quot;</small> in
<i>guestfs</i>(3).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Boot
failure: 0x0000007B</b> <br>
This boot failure is caused by Windows being unable to find
or load the right disk driver (eg. <i>viostor.sys</i>). If
you experience this error, here are some things to
check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">First ensure that the guest
boots on the source hypervisor before conversion.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Check you have the Windows virtio drivers available in
<i>/usr/share/virtio&minus;win</i>, and that virt&minus;v2v
did not print any warning about not being able to install
virtio drivers.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">On
Red&nbsp;Hat&nbsp;Enterprise&nbsp;Linux&nbsp;7, you will
need to install the signed drivers available in the
<tt>&quot;virtio&minus;win&quot;</tt> package. If you do not
have access to the signed drivers, then you will probably
need to disable driver signing in the boot menus.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Check that you are presenting a
virtio-blk interface (<b>not</b> virtio-scsi and <b>not</b>
ide) to the guest. On the qemu/KVM command line you should
see something similar to this:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ... &minus;drive file=windows&minus;sda,if=virtio ...</pre>


<p style="margin-left:17%; margin-top: 1em">In libvirt
<small>XML,</small> you should see:</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;target dev='vda' bus='virtio'/&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Check that Windows Group Policy
does not prevent the driver from being installed or used.
Try deleting Windows Group Policy before conversion.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Check there is no anti-virus or other software which
implements Group Policy-like prohibitions on installing or
using new drivers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Enable boot debugging and check the <i>viostor.sys</i>
driver is being loaded.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>OpenStack
and Windows reactivation</b> <br>
OpenStack does not offer stable device / <small>PCI</small>
addresses to guests. Every time it creates or starts a
guest, it regenerates the libvirt <small>XML</small> for
that guest from scratch. The libvirt <small>XML</small> will
have no &lt;address&gt; fields. Libvirt will then assign
addresses to devices, in a predictable manner. Addresses may
change if any of the following are true:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A new disk or network device has
been added or removed from the guest.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The version of OpenStack or (possibly) libvirt has
changed.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Because Windows
does not like &quot;hardware&quot; changes of this kind, it
may trigger Windows reactivation.</p>

<p style="margin-left:11%; margin-top: 1em">This can also
prevent booting with a 7B error [see previous section] if
the guest has group policy containing <tt>&quot;Device
Installation Restrictions&quot;</tt>.</p>

<h2>UEFI
<a name="UEFI"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">VMware allows
you to present <small>UEFI</small> firmware to guests
(instead of the ordinary <small>PC BIOS</small> ).
Virt&minus;v2v can convert these guests, but requires that
<small>UEFI</small> is supported by the target
hypervisor.</p>

<p style="margin-left:11%; margin-top: 1em">Currently
<small>KVM</small> supports <small>OVMF,</small> an open
source <small>UEFI</small> firmware, and can run these
guests.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<small>OVMF</small> support was only recently added to
<small>KVM</small> (in 2014/2015), not all target
environments support <small>UEFI</small> guests yet:
<small><br>
UEFI</small> on libvirt, qemu</p>

<p style="margin-left:17%;">Supported. Virt&minus;v2v will
generate the correct libvirt <small>XML</small> (metadata)
automatically, but note that the same version of
<small>OVMF</small> must be installed on the conversion host
as is installed on the target hypervisor, else you will have
to adjust paths in the metadata.</p>

<p style="margin-left:17%; margin-top: 1em">On
<small>RHEL</small> &ge; 7.3, only qemu-kvm-rhev (not
qemu-kvm) is supported.</p>

<p style="margin-left:11%;"><small>UEFI</small> on
OpenStack</p>

<p style="margin-left:17%;">Not supported.</p>

<p style="margin-left:11%;"><small>UEFI</small> on
<small>RHEV</small></p>

<p style="margin-left:17%;">Not supported.</p>

<h2>NETWORKS AND BRIDGES
<a name="NETWORKS AND BRIDGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Guests are
usually connected to one or more networks, and when
converted to the target hypervisor you usually want to
reconnect those networks at the destination. The options
<i>&minus;&minus;network</i> and <i>&minus;&minus;bridge</i>
allow you to do that.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
unsure of what networks and bridges are in use on the source
hypervisor, then you can examine the source metadata
(libvirt <small>XML,</small> vCenter information, etc.). Or
you can run virt&minus;v2v with the
<i>&minus;&minus;print&minus;source</i> option which causes
virt&minus;v2v to print out the information it has about the
guest on the source and then exit.</p>

<p style="margin-left:11%; margin-top: 1em">In the
<i>&minus;&minus;print&minus;source</i> output you will see
a section showing the guest&rsquo;s Network Interface Cards
(NICs):</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v [&minus;i ...] &minus;&minus;print&minus;source name
 [...]
 NICs:
     Network &quot;default&quot; mac: 52:54:00:d0:cf:0e</pre>


<p style="margin-left:11%; margin-top: 1em">This is typical
of a libvirt guest: It has a single network interface
connected to a network called
<tt>&quot;default&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To map a
specific network to a target network, for example
<tt>&quot;default&quot;</tt> on the source to
<tt>&quot;rhevm&quot;</tt> on the target, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v [...] &minus;&minus;network default:rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">To map every
network to a target network, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v [...] &minus;&minus;network rhevm</pre>


<p style="margin-left:11%; margin-top: 1em">Bridges are
handled in the same way, but you have to use the
<i>&minus;&minus;bridge</i> option instead. For example:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v [&minus;i ...] &minus;&minus;print&minus;source name
 [...]
 NICs:
     Bridge &quot;br0&quot;
 $ virt&minus;v2v [...] &minus;&minus;bridge br0:targetbr</pre>


<h2>INPUT FROM VMWARE VCENTER SERVER
<a name="INPUT FROM VMWARE VCENTER SERVER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import guests from VMware vCenter Server.</p>

<p style="margin-left:11%; margin-top: 1em">vCenter &ge;
5.0 is required. If you don&rsquo;t have vCenter, using
<small>OVA</small> is recommended instead (see &quot;
<small>INPUT FROM VMWARE OVA&quot;</small> below), or if
that is not possible then see &quot; <small>INPUT FROM
VMWARE</small> ESXi <small>HYPERVISOR&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
uses libvirt for access to vCenter, and therefore the input
mode should be <i>&minus;i libvirt</i>. As this is the
default, you don&rsquo;t need to specify it on the command
line.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:
REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</small></b> <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then the converted guest will complain on every boot. The
tools cannot be removed after conversion because the
uninstaller checks if it is running on VMware and refuses to
start (which is also the reason that virt&minus;v2v cannot
remove them).</p>

<p style="margin-left:11%; margin-top: 1em">This is not
necessary for Linux guests, as virt&minus;v2v is able to
remove VMware tools.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:
URI</small></b> <br>
The libvirt <small>URI</small> of a vCenter server looks
something like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> vpx://user@server/Datacenter/esxi</pre>


<p style="margin-left:11%; margin-top: 1em">where: <br>
&quot;user@&quot;</p>

<p style="margin-left:17%;">is the (optional, but
recommended) user to connect as.</p>

<p style="margin-left:17%; margin-top: 1em">If the username
contains a backslash (eg. <tt>&quot;DOMAIN\USER&quot;</tt>)
then you will need to URI-escape that character using
<tt>%5c</tt>: <tt>&quot;DOMAIN%5cUSER&quot;</tt> (5c is the
hexadecimal <small>ASCII</small> code for backslash.) Other
punctuation may also have to be escaped.</p>

<p style="margin-left:11%;">&quot;server&quot;</p>

<p style="margin-left:17%;">is the vCenter Server
(<i>not</i> hypervisor).</p>

<p style="margin-left:11%;">&quot;Datacenter&quot;</p>

<p style="margin-left:17%;">is the name of the
datacenter.</p>

<p style="margin-left:17%; margin-top: 1em">If the name
contains a space, replace it with the URI-escape code
<tt>%20</tt>.</p>

<p style="margin-left:11%;">&quot;esxi&quot;</p>

<p style="margin-left:17%;">is the name of the ESXi
hypervisor running the guest.</p>

<p style="margin-left:11%; margin-top: 1em">If the VMware
deployment is using folders, then these may need to be added
to the <small>URI,</small> eg:</p>

<pre style="margin-left:11%; margin-top: 1em"> vpx://user@server/Folder/Datacenter/esxi</pre>


<p style="margin-left:11%; margin-top: 1em">For full
details of libvirt URIs, see:
http://libvirt.org/drvesx.html</p>

<p style="margin-left:11%; margin-top: 1em">Typical errors
from libvirt / virsh when the <small>URI</small> is wrong
include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find datacenter specified in [...]</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find compute resource specified in [...]</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Path [...] does not specify a compute resource</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Path [...] does not specify a host system</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Could not find host system specified in [...]</p></td>
<td width="6%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:
TEST LIBVIRT CONNECTION TO VCENTER</small></b> <br>
Use the <i>virsh</i>(1) command to list the guests on the
vCenter Server like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi' list &minus;&minus;all
 Enter root's password for vcenter.example.com: ***
  Id    Name                           State
 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  &minus;     Fedora 20                      shut off
  &minus;     Windows 2003                   shut off</pre>


<p style="margin-left:11%; margin-top: 1em">If you get an
error &quot;Peer certificate cannot be authenticated with
given <small>CA</small> certificates&quot; or similar, then
you can either import the vCenter host&rsquo;s certificate,
or bypass signature verification by adding the
<tt>&quot;?no_verify=1&quot;</tt> flag:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' list &minus;&minus;all</pre>


<p style="margin-left:11%; margin-top: 1em">You should also
try dumping the metadata from any guest on your server, like
this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c 'vpx://root@vcenter.example.com/Datacenter/esxi' dumpxml &quot;Windows 2003&quot;
 &lt;domain type='vmware'&gt;
   &lt;name&gt;Windows 2003&lt;/name&gt;
   [...]
 &lt;/domain&gt;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>If the above
commands do not work, then virt&minus;v2v is not going to
work either</b>. Fix your libvirt configuration and/or your
VMware vCenter Server before continuing.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:
IMPORTING A GUEST</small></b> <br>
To import a particular guest from vCenter Server, do:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;ic 'vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1' \
   &quot;Windows 2003&quot; \
   &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;Windows 2003&quot;</tt> is the name of the guest
(which must be shut down).</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
may be asked for the vCenter password <i>twice</i>. This
happens once because libvirt needs it, and a second time
because virt&minus;v2v itself connects directly to the
server. Use <i>&minus;&minus;password&minus;file</i> to
supply a password via a file.</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the output flags are set to write the converted guest to a
temporary directory as this is just an example, but you can
also write to libvirt or any other supported target.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:</small>
NON-ADMINISTRATOR <small>ROLE</small></b> <br>
Instead of using the vCenter Administrator role, you can
create a custom non-administrator role to perform the
conversion. You will however need to give it a minimum set
of permissions as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="57%">


<p style="margin-top: 1em">Create a custom role in
vCenter.</p> </td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="57%">


<p>Enable (check) the following objects:</p></td>
<td width="26%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> Datastore:
  &minus; Browse datastore
  &minus; Low level file operations
 Sessions:
  &minus; Validate session
 Virtual Machine:
   Provisioning:
     &minus; Allow disk access
     &minus; Allow read&minus;only disk access
     &minus; Guest Operating system management by VIX API</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>VCENTER:
FIREWALL AND PROXY SETTINGS</small></b> <i><br>
vCenter: Ports</i></p>

<p style="margin-left:11%; margin-top: 1em">If there is a
firewall between the virt&minus;v2v conversion server and
the vCenter server, then you will need to open port 443
(https) and port 5480.</p>

<p style="margin-left:11%; margin-top: 1em">Port 443 is
used to copy the guest disk image(s). Port 5480 is used to
query vCenter for guest metadata.</p>

<p style="margin-left:11%; margin-top: 1em">These port
numbers are only the defaults. It is possible to reconfigure
vCenter to use other port numbers. In that case you would
need to specify those ports in the
<tt>&quot;vpx://&quot;</tt> <small>URI.</small> See &quot;
<small>VCENTER: URI&quot;</small> above.</p>

<p style="margin-left:11%; margin-top: 1em">These ports
only apply to virt&minus;v2v conversions. You may have to
open other ports for other vCenter functionality, for
example the web user interface. VMware documents the
required ports for vCenter in their online
documentation.</p>

<pre style="margin-left:11%; margin-top: 1em"> &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;   port 443 &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;        &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
 &#9474; virt&minus;v2v   &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; vCenter    &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; ESXi       &#9474;
 &#9474; conversion &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9654; server     &#9474;        &#9474; hypervisor &#9474;
 &#9474; server     &#9474;  port 5480 &#9474;            &#9474;        &#9474;   &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;  &#9474;
 &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;            &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;        &#9474;   &#9474;guest&#9474;  &#9474;
                                                 &#9492;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9496;</pre>


<p style="margin-left:11%; margin-top: 1em">(In the diagram
above the arrows show the direction in which the
<small>TCP</small> connection is initiated, <i>not</i>
necessarily the direction of data transfer.)</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
itself does not connect directly to the ESXi hypervisor
containing the guest. However vCenter connects to the
hypervisor and forwards the information, so if you have a
firewall between vCenter and its hypervisors you may need to
open additional ports (consult VMware documentation).</p>

<p style="margin-left:11%; margin-top: 1em"><i>vCenter:
Proxy settings</i></p>

<p style="margin-left:11%; margin-top: 1em">To copy the
disks, virt&minus;v2v uses <i>libcurl</i>(3). The Curl
library obeys the proxy environment variables, in particular
<tt>&quot;https_proxy&quot;</tt>,
<tt>&quot;all_proxy&quot;</tt> and
<tt>&quot;no_proxy&quot;</tt>
(<tt>&quot;HTTPS_PROXY&quot;</tt>,
<tt>&quot;ALL_PROXY&quot;</tt> and
<tt>&quot;NO_PROXY&quot;</tt> can also be used, but the
lowercase named environment variables take precedence).</p>

<p style="margin-left:11%; margin-top: 1em">If these
environment variables are set then copying may happen via
the proxy, and so a different set of ports may need to be
opened in the firewall.</p>

<p style="margin-left:11%; margin-top: 1em">The port 5480
connection never uses a proxy.</p>

<h2>INPUT FROM VMWARE OVA
<a name="INPUT FROM VMWARE OVA"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import guests from VMware&rsquo;s
<small>OVA</small> (Open Virtualization Appliance) files.
Only OVAs exported from VMware vSphere will work.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</small></b> <br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then the converted guest will complain on every boot. The
tools cannot be removed after conversion because the
uninstaller checks if it is running on VMware and refuses to
start (which is also the reason that virt&minus;v2v cannot
remove them).</p>

<p style="margin-left:11%; margin-top: 1em">This is not
necessary for Linux guests, as virt&minus;v2v is able to
remove VMware tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
CREATE OVA</small></b> <br>
To create an <small>OVA</small> in vSphere, use the
&quot;Export <small>OVF</small> Template&quot; option (from
the <small>VM</small> context menu, or from the File menu).
Either &quot;Folder of files&quot; ( <small>OVF</small> ) or
&quot;Single file&quot; ( <small>OVA</small> ) will work,
but <small>OVA</small> is probably easier to deal with.
<small>OVA</small> files are really just uncompressed tar
files, so you can use commands like <tt>&quot;tar tf
VM.ova&quot;</tt> to view their contents.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Create
<small>OVA</small> with ovftool</i></p>

<p style="margin-left:11%; margin-top: 1em">You can also
use VMware&rsquo;s proprietary
<tt>&quot;ovftool&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em"> ovftool &minus;&minus;noSSLVerify \
   vi://USER:PASSWORD@esxi.example.com/VM \
   VM.ova</pre>


<p style="margin-left:11%; margin-top: 1em">To connect to
vCenter:</p>

<pre style="margin-left:11%; margin-top: 1em"> ovftool  &minus;&minus;noSSLVerify \
   vi://USER:PASSWORD@vcenter.example.com/DATACENTER&minus;NAME/vm/VM \
   VM.ova</pre>


<p style="margin-left:11%; margin-top: 1em">For Active
Directory-aware authentication, you have to express the
<tt>&quot;@&quot;</tt> character in the form of its ascii
hex-code (<tt>%5c</tt>):</p>

<pre style="margin-left:11%; margin-top: 1em"> vi://DOMAIN%5cUSER:PASSWORD@...</pre>


<p style="margin-left:11%; margin-top: 1em"><b><small>OVA:
IMPORTING A GUEST</small></b> <br>
To import an <small>OVA</small> file called
<i><small>VM</small> .ova</i>, do;</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;i ova VM.ova &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">If you exported
the guest as a &quot;Folder of files&quot;, <i>or</i> if you
unpacked the <small>OVA</small> tarball yourself, then you
can point virt&minus;v2v at the directory containing the
files:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;i ova /path/to/files &minus;o local &minus;os /var/tmp</pre>


<h2>INPUT FROM VMWARE ESXi HYPERVISOR
<a name="INPUT FROM VMWARE ESXi HYPERVISOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
cannot access an ESXi hypervisor directly. You should use
the <small>OVA</small> method above (see &quot; <small>INPUT
FROM VMWARE OVA&quot;</small> ) if possible, as it is much
faster and requires much less disk space than the method
described in this section.</p>

<p style="margin-left:11%; margin-top: 1em">You can use the
<i>virt&minus;v2v&minus;copy&minus;to&minus;local</i>(1)
tool to copy the guest off the hypervisor into a local file,
and then convert it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</small></b>
<br>
For Windows guests, you should remove VMware tools before
conversion. Although this is not strictly necessary, and the
guest will still be able to run, if you don&rsquo;t do this
then the converted guest will complain on every boot. The
tools cannot be removed after conversion because the
uninstaller checks if it is running on VMware and refuses to
start (which is also the reason that virt&minus;v2v cannot
remove them).</p>

<p style="margin-left:11%; margin-top: 1em">This is not
necessary for Linux guests, as virt&minus;v2v is able to
remove VMware tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>URI</small></b> <br>
The libvirt <small>URI</small> for VMware ESXi hypervisors
will look something like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> esx://root@esxi.example.com?no_verify=1</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;?no_verify=1&quot;</tt> parameter disables
<small>TLS</small> certificate checking.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>TEST LIBVIRT CONNECTION TO</small> ESXi
<small>HYPERVISOR</small></b> <br>
Use the <i>virsh</i>(1) command to test the
<small>URI</small> and list the remote guests available:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c esx://root@esxi.example.com?no_verify=1 list &minus;&minus;all
 Enter root's password for esxi.example.com: ***
  Id    Name                           State
 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  &minus;     guest                          shut off</pre>


<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>COPY THE GUEST TO THE LOCAL MACHINE</small></b> <br>
Using the libvirt <small>URI</small> as the <i>&minus;ic</i>
option, copy one of the guests to the local machine:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v&minus;copy&minus;to&minus;local &minus;ic esx://root@esxi.example.com?no_verify=1 guest</pre>


<p style="margin-left:11%; margin-top: 1em">This creates
<i>guest.xml</i>, <i>guest&minus;disk1</i>, ...</p>

<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>DO THE VIRT&minus;V2V CONVERSION</small></b> <br>
Perform the conversion of the guest using
virt&minus;v2v:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;i libvirtxml guest.xml &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em"><b>ESXi:
<small>CLEAN UP</small></b> <br>
Remove the <i>guest.xml</i> and <i>guest&minus;disk*</i>
files.</p>

<h2>INPUT FROM RHEL 5 XEN
<a name="INPUT FROM RHEL 5 XEN"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
is able to import Xen guests from <small>RHEL 5</small> Xen
hosts.</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
uses libvirt for access to the remote Xen host, and
therefore the input mode should be <i>&minus;i libvirt</i>.
As this is the default, you don&rsquo;t need to specify it
on the command line.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
SET UP</small> SSH-AGENT <small>ACCESS TO XEN
HOST</small></b> <br>
Currently you must enable passwordless <small>SSH</small>
access to the remote Xen host from the virt&minus;v2v
conversion server.</p>

<p style="margin-left:11%; margin-top: 1em">You must also
use ssh-agent, and add your ssh public key to
<i>/root/.ssh/authorized_keys</i> (on the Xen host).</p>

<p style="margin-left:11%; margin-top: 1em">After doing
this, you should check that passwordless access works from
the virt&minus;v2v server to the Xen host. For example:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ ssh root@xen.example.com
 [ logs straight into the shell, no password is requested ]</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
password-interactive and Kerberos access are <b>not</b>
supported. You <b>have</b> to set up ssh access using
ssh-agent and authorized_keys.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
TEST LIBVIRT CONNECTION TO REMOTE XEN HOST</small></b> <br>
Use the <i>virsh</i>(1) command to list the guests on the
remote Xen host:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c xen+ssh://root@xen.example.com list &minus;&minus;all
  Id    Name                           State
 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  0     Domain&minus;0                       running
  &minus;     rhel49&minus;x86_64&minus;pv               shut off</pre>


<p style="margin-left:11%; margin-top: 1em">You should also
try dumping the metadata from any guest on your server, like
this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virsh &minus;c xen+ssh://root@xen.example.com dumpxml rhel49&minus;x86_64&minus;pv
 &lt;domain type='xen'&gt;
   &lt;name&gt;rhel49&minus;x86_64&minus;pv&lt;/name&gt;
   [...]
 &lt;/domain&gt;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>If the above
commands do not work, then virt&minus;v2v is not going to
work either</b>. Fix your libvirt configuration or the
remote server before continuing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>If the guest
disks are located on a host block device</b>, then the
conversion will fail. See &quot; <small>XEN OR SSH
CONVERSIONS FROM BLOCK DEVICES&quot;</small> below for a
workaround.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN:
IMPORTING A GUEST</small></b> <br>
To import a particular guest from a Xen server, do:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;ic 'xen+ssh://root@xen.example.com' \
   rhel49&minus;x86_64&minus;pv \
   &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;rhel49&minus;x86_64&minus;pv&quot;</tt> is the
name of the guest (which must be shut down).</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the output flags are set to write the converted guest to a
temporary directory as this is just an example, but you can
also write to libvirt or any other supported target.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>XEN
OR SSH CONVERSIONS FROM BLOCK DEVICES</small></b> <br>
Currently virt&minus;v2v cannot directly access a Xen guest
(or any guest located remotely over ssh) if that
guest&rsquo;s disks are located on host block devices.</p>

<p style="margin-left:11%; margin-top: 1em">To tell if a
Xen guest uses host block devices, look at the guest
<small>XML.</small> You will see:</p>

<pre style="margin-left:11%; margin-top: 1em">  &lt;disk type='block' device='disk'&gt;
    ...
    &lt;source dev='/dev/VG/guest'/&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">where
<tt>&quot;type='block'&quot;</tt>, <tt>&quot;source
dev=&quot;</tt> and <tt>&quot;/dev/...&quot;</tt> are all
indications that the disk is located on a host block
device.</p>

<p style="margin-left:11%; margin-top: 1em">This happens
because the qemu ssh block driver that we use to access
remote disks uses the ssh sftp protocol, and this protocol
cannot correctly detect the size of host block devices.</p>

<p style="margin-left:11%; margin-top: 1em">The workaround
is to copy the guest over to the conversion server, using
the separate
<i>virt&minus;v2v&minus;copy&minus;to&minus;local</i>(1)
tool, followed by running virt&minus;v2v. You will need
sufficient space on the conversion server to store a full
copy of the guest.</p>

<pre style="margin-left:11%; margin-top: 1em"> virt&minus;v2v&minus;copy&minus;to&minus;local &minus;ic xen+ssh://root@xen.example.com guest
 virt&minus;v2v &minus;i libvirtxml guest.xml &minus;o local &minus;os /var/tmp
 rm guest.xml guest&minus;disk*</pre>


<h2>OUTPUT TO LIBVIRT
<a name="OUTPUT TO LIBVIRT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>&minus;o
libvirt</i> option lets you upload the converted guest to a
libvirt-managed host. There are several limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You can only use a local libvirt
connection [see below for how to workaround this].</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <i>&minus;os pool</i> option must specify a
directory pool, not anything more exotic such as iSCSI [but
see below].</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You can only upload to a <small>KVM</small>
hypervisor.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>To output to
a remote libvirt instance and/or a non-directory storage
pool</b> you have to use the following workaround:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Use virt&minus;v2v in
<i>&minus;o local</i> mode to convert the guest disks and
metadata into a local temporary directory:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virt&minus;v2v [...] &minus;o local &minus;os /var/tmp</pre>


<p style="margin-left:17%; margin-top: 1em">This creates
two (or more) files in <i>/var/tmp</i> called:</p>

<pre style="margin-left:17%; margin-top: 1em"> /var/tmp/NAME.xml     # the libvirt XML (metadata)
 /var/tmp/NAME&minus;sda     # the guest's first disk</pre>


<p style="margin-left:17%; margin-top: 1em">(for
<tt>&quot;NAME&quot;</tt> substitute the guest&rsquo;s
name).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Upload the converted disk(s)
into the storage pool called <tt>&quot;POOL&quot;</tt>:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> size=$(stat &minus;c%s /var/tmp/NAME&minus;sda)
 virsh vol&minus;create&minus;as POOL NAME&minus;sda $size &minus;&minus;format raw
 virsh vol&minus;upload &minus;&minus;pool POOL NAME&minus;sda /var/tmp/NAME&minus;sda</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Edit <i>/var/tmp/NAME.xml</i> to
change <i>/var/tmp/NAME&minus;sda</i> to the pool name. In
other words, locate the following bit of
<small>XML:</small></p> </td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> &lt;disk type='file' device='disk'&gt;
   &lt;driver name='qemu' type='raw' cache='none' /&gt;
   &lt;source file='/var/tmp/NAME&minus;sda' /&gt;
   &lt;target dev='hda' bus='ide' /&gt;
 &lt;/disk&gt;</pre>


<p style="margin-left:17%; margin-top: 1em">and change two
things: The <tt>&quot;type='file'&quot;</tt> attribute must
be changed to <tt>&quot;type='volume'&quot;</tt>, and the
<tt>&quot;&lt;source&gt;&quot;</tt> element must be changed
to include <tt>&quot;pool&quot;</tt> and
<tt>&quot;volume&quot;</tt> attributes:</p>

<pre style="margin-left:17%; margin-top: 1em"> &lt;disk type='volume' device='disk'&gt;
   ...
   &lt;source pool='POOL' volume='NAME&minus;sda' /&gt;
   ...
 &lt;/disk&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="3%"></td>
<td width="52%">


<p style="margin-top: 1em">Define the final guest in
libvirt:</p> </td>
<td width="31%">
</td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> virsh define /var/tmp/NAME.xml</pre>


<h2>OUTPUT TO RHEV
<a name="OUTPUT TO RHEV"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
only applies to the <i>&minus;o rhev</i> output mode. If you
use virt&minus;v2v from the RHEV-M user interface, then
behind the scenes the import is managed by
<small>VDSM</small> using the <i>&minus;o vdsm</i> output
mode (which end users should not try to use directly).</p>

<p style="margin-left:11%; margin-top: 1em">You have to
specify <i>&minus;o rhev</i> and an <i>&minus;os</i> option
that points to the RHEV-M Export Storage Domain. You can
either specify the <small>NFS</small> server and mountpoint,
eg.
<tt>&quot;&minus;os&nbsp;rhev&minus;storage:/rhev/export&quot;</tt>,
or you can mount that first and point to the directory where
it is mounted, eg.
<tt>&quot;&minus;os&nbsp;/tmp/mnt&quot;</tt>. Be careful not
to point to the Data Storage Domain by accident as that will
not work.</p>

<p style="margin-left:11%; margin-top: 1em">On successful
completion virt&minus;v2v will have written the new guest to
the Export Storage Domain, but it will not yet be ready to
run. It must be imported into <small>RHEV</small> using the
<small>UI</small> before it can be used.</p>

<p style="margin-left:11%; margin-top: 1em">In
<small>RHEV</small> &ge; 2.2 this is done from the Storage
tab. Select the export domain the guest was written to. A
pane will appear underneath the storage domain list
displaying several tabs, one of which is &quot;
<small>VM</small> Import&quot;. The converted guest will be
listed here. Select the appropriate guest an click
&quot;Import&quot;. See the <small>RHEV</small>
documentation for additional details.</p>

<p style="margin-left:11%; margin-top: 1em">If you export
several guests, then you can import them all at the same
time through the <small>UI.</small></p>

<h2>OUTPUT TO GLANCE
<a name="OUTPUT TO GLANCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To output to
OpenStack Glance, use the <i>&minus;o glance</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">This runs the
<i>glance</i>(1) <small>CLI</small> program which must be
installed on the virt&minus;v2v conversion host. For
authentication to work, you will need to set
<tt>&quot;OS_*&quot;</tt> environment variables. In most
cases you can do this by sourcing a file called something
like <i>keystonerc_admin</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
adds metadata for the guest to Glance, describing such
things as the guest operating system and what drivers it
requires. The command <tt>&quot;glance
image&minus;show&quot;</tt> will display the metadata as
&quot;Property&quot; fields such as
<tt>&quot;os_type&quot;</tt> and
<tt>&quot;hw_disk_bus&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Glance and
sparseness</b> <br>
Glance image upload doesn&rsquo;t appear to correctly handle
sparseness. For this reason, using qcow2 will be faster and
use less space on the Glance server. Use the virt&minus;v2v
<i>&minus;of&nbsp;qcow2</i> option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Glance and
multiple disks</b> <br>
If the guest has a single disk, then the name of the disk in
Glance will be the name of the guest. You can control this
using the <i>&minus;on</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">Glance
doesn&rsquo;t have a concept of associating multiple disks
with a single guest, and Nova doesn&rsquo;t allow you to
boot a guest from multiple Glance disks either. If the guest
has multiple disks, then the first (assumed to be the system
disk) will have the name of the guest, and the second and
subsequent data disks will be called
<tt>&quot;</tt><i>guestname</i><tt>&minus;disk2&quot;</tt>,
<tt>&quot;</tt><i>guestname</i><tt>&minus;disk3&quot;</tt>
etc. It may be best to leave the system disk in Glance, and
import the data disks to Cinder (see next section).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Importing
disks into Cinder</b> <br>
Since most virt&minus;v2v guests are &quot;pets&quot;,
Glance is perhaps not the best place to store them. There is
no way for virt&minus;v2v to upload directly to Cinder
(https://bugzilla.redhat.com/1155229). There are two ways to
upload to Cinder:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Import the image to Glance first
(ie. <i>&minus;o glance</i>) and then copy it to Cinder:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> cinder create &minus;&minus;image&minus;id &lt;GLANCE&minus;IMAGE&minus;UUID&gt; &lt;SIZE&gt;</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Create (through some other
means) a new volume / <small>LUN</small> in your Cinder
backing store. Migrate the guest to this volume (using
<i>&minus;o local</i>). Then ask Cinder to take over
management of the volume using:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> cinder manage &lt;VOLUMEREF&gt;</pre>


<h2>RESOURCE REQUIREMENTS
<a name="RESOURCE REQUIREMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Network</b>
<br>
The most important resource for virt&minus;v2v appears to be
network bandwidth. Virt&minus;v2v should be able to copy
guest data at gigabit ethernet speeds or greater.</p>

<p style="margin-left:11%; margin-top: 1em">Ensure that the
network connections between servers (conversion server,
<small>NFS</small> server, vCenter, Xen) are as fast and as
low latency as possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Disk
space</b> <br>
Virt&minus;v2v places potentially large temporary files in
<tt>$TMPDIR</tt> (which is <i>/var/tmp</i> if you
don&rsquo;t set it). Using tmpfs is a bad idea.</p>

<p style="margin-left:11%; margin-top: 1em">For each guest
disk, an overlay is stored temporarily. This stores the
changes made during conversion, and is used as a cache. The
overlays are not particularly large &minus; tens or low
hundreds of megabytes per disk is typical. In addition to
the overlay(s), input and output methods may use disk space,
as outlined in the table below. <i><br>
&minus;i ova</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the uncompressed source disks in
<tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%;"><i>&minus;o glance</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the output disks in <tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%;"><i>&minus;o local <br>
&minus;o qemu</i></p>

<p style="margin-left:17%;">You must ensure there is
sufficient space in the output directory for the converted
guest.</p>

<p style="margin-left:11%;"><i>&minus;o null</i></p>

<p style="margin-left:17%;">This temporarily places a full
copy of the output disks in <tt>$TMPDIR</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Minimum free space check in the host&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>VMware
vCenter resources</b> <br>
Copying from VMware vCenter is currently quite slow, but we
believe this to be an issue with VMware. Ensuring the VMware
ESXi hypervisor and vCenter are running on fast hardware
with plenty of memory should alleviate this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compute
power and <small>RAM</small></b> <br>
Virt&minus;v2v is not especially compute or
<small>RAM</small> intensive. If you are running many
parallel conversions, then you may consider allocating one
<small>CPU</small> core and between 512 <small>MB</small>
and 1 <small>GB</small> of <small>RAM</small> per running
instance.</p>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
can be run in a virtual machine.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Trimming</b>
<br>
Virt&minus;v2v attempts to optimize the speed of conversion
by ignoring guest filesystem data which is not used. This
would include unused filesystem blocks, blocks containing
zeroes, and deleted files.</p>

<p style="margin-left:11%; margin-top: 1em">To do this,
virt&minus;v2v issues a non-destructive <i>fstrim</i>(8)
operation. As this happens to an overlay placed over the
guest data, it does <b>not</b> affect the source in any
way.</p>

<p style="margin-left:11%; margin-top: 1em">If this fstrim
operation fails, you will see a warning, but virt&minus;v2v
will continue anyway. It may run more slowly (in some cases
much more slowly), because it is copying the unused parts of
the disk.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately
support for fstrim is not universal, and it also depends on
specific details of the filesystem, partition alignment, and
backing storage. As an example, <small>NTFS</small>
filesystems cannot be fstrimmed if they occupy a partition
which is not aligned to the underlying storage. That was the
default on Windows before Vista. As another example,
<small>VFAT</small> filesystems (used by <small>UEFI</small>
guests) cannot be trimmed at all.</p>

<p style="margin-left:11%; margin-top: 1em">fstrim support
in the Linux kernel is improving gradually, so over time
some of these restrictions will be lifted and virt&minus;v2v
will work faster.</p>

<h2>POST-CONVERSION TASKS
<a name="POST-CONVERSION TASKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Guest
network configuration</b> <br>
Virt&minus;v2v cannot currently reconfigure a guest&rsquo;s
network configuration. If the converted guest is not
connected to the same subnet as the source, its network
configuration may have to be updated. See also
<i>virt&minus;customize</i>(1).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Converting a
Windows guest</b> <br>
When converting a Windows guests, the conversion process is
split into two stages:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="29%">


<p>Offline conversion.</p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="29%">


<p>First boot.</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The guest will
be bootable after the offline conversion stage, but will not
yet have all necessary drivers installed to work correctly.
These will be installed automatically the first time the
guest boots.</p>

<p style="margin-left:11%; margin-top: 1em"><b>N.B.</b>
Take care not to interrupt the automatic driver installation
process when logging in to the guest for the first time, as
this may prevent the guest from subsequently booting
correctly.</p>

<h2>FREE SPACE FOR CONVERSION
<a name="FREE SPACE FOR CONVERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Free space
in the guest</b> <br>
Virt&minus;v2v checks there is sufficient free space in the
guest filesystem to perform the conversion. Currently it
checks: <br>
Linux root filesystem or Windows &quot;C:&quot; drive</p>

<p style="margin-left:17%;">Minimum free space: 20
<small>MB</small></p>

<p style="margin-left:11%;">Linux <i>/boot</i></p>

<p style="margin-left:17%;">Minimum free space: 50
<small>MB</small></p>

<p style="margin-left:17%; margin-top: 1em">This is because
we need to build a new initramfs for some Enterprise Linux
conversions.</p>

<p style="margin-left:11%;">Any other mountable
filesystem</p>

<p style="margin-left:17%;">Minimum free space: 10
<small>MB</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Minimum free
space check in the host</b> <br>
You must have sufficient free space in the host directory
used to store temporary overlays (except in
<i>&minus;&minus;in&minus;place</i> mode). To find out which
directory this is, use:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ df &minus;h &quot;`guestfish get&minus;cachedir`&quot;
 Filesystem        Size  Used Avail Use% Mounted on
 /dev/mapper/root   50G   40G  6.8G  86% /</pre>


<p style="margin-left:11%; margin-top: 1em">and look under
the <tt>&quot;Avail&quot;</tt> column. Virt&minus;v2v will
refuse to do the conversion at all unless at least 1GB is
available there.</p>

<p style="margin-left:11%; margin-top: 1em">See also &quot;
<small>RESOURCE REQUIREMENTS&quot;</small> above.</p>

<h2>RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT
<a name="RUNNING VIRT&minus;V2V AS ROOT OR NON-ROOT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Nothing in
virt&minus;v2v inherently needs root access, and it will run
just fine as a non-root user. However, certain external
features may require either root or a special user: <br>
Mounting the Export Storage Domain</p>

<p style="margin-left:17%;">When using <i>&minus;o rhev
&minus;os server:/esd</i> virt&minus;v2v has to have
sufficient privileges to <small>NFS</small> mount the Export
Storage Domain from <tt>&quot;server&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">You can avoid
needing root here by mounting it yourself before running
virt&minus;v2v, and passing <i>&minus;os /mountpoint</i>
instead, but first of all read the next section&nbsp;...</p>

<p style="margin-left:11%;">Writing to the Export Storage
Domain as 36:36</p>

<p style="margin-left:17%;">RHEV-M cannot read files and
directories from the Export Storage Domain unless they have
<small>UID:GID 36:36.</small> You will see <small>VM</small>
import problems if the <small>UID:GID</small> is not
correct.</p>

<p style="margin-left:17%; margin-top: 1em">When you run
virt&minus;v2v <i>&minus;o rhev</i> as root, virt&minus;v2v
attempts to create files and directories with the correct
ownership. If you run virt&minus;v2v as non-root, it will
probably still work, but you will need to manually change
ownership after virt&minus;v2v has finished.</p>

<p style="margin-left:11%;">Writing to libvirt</p>

<p style="margin-left:17%;">When using <i>&minus;o
libvirt</i>, you may need to run virt&minus;v2v as root so
that it can write to the libvirt system instance (ie.
<tt>&quot;qemu:///system&quot;</tt>) and to the default
location for disk images (usually
<i>/var/lib/libvirt/images</i>).</p>

<p style="margin-left:17%; margin-top: 1em">You can avoid
this by setting up libvirt connection authentication, see
http://libvirt.org/auth.html. Alternatively, use
<i>&minus;oc qemu:///session</i>, which will write to your
per-user libvirt instance.</p>

<p style="margin-left:11%;">Writing to Glance</p>

<p style="margin-left:17%;">This does <i>not</i> need root
(in fact it probably won&rsquo;t work), but may require
either a special user and/or for you to source a script that
sets authentication environment variables. Consult the
Glance documentation.</p>

<h2>DEBUGGING RHEV-M IMPORT FAILURES
<a name="DEBUGGING RHEV-M IMPORT FAILURES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When you export
to the RHEV-M Export Storage Domain, and then import that
guest through the RHEV-M <small>UI,</small> you may
encounter an import failure. Diagnosing these failures is
infuriatingly difficult as the <small>UI</small> generally
hides the true reason for the failure.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
log files of interest. The first is stored on the RHEV-M
server itself, and is called
<i>/var/log/ovirt&minus;engine/engine.log</i></p>

<p style="margin-left:11%; margin-top: 1em">The second
file, which is the most useful, is found on the
<small>SPM</small> host ( <small>SPM</small> stands for
&quot;Storage Pool Manager&quot;). This is a
<small>RHEV</small> node that is elected to do all metadata
modifications in the data center, such as image or snapshot
creation. You can find out which host is the current
<small>SPM</small> from the &quot;Hosts&quot; tab &quot;Spm
Status&quot; column. Once you have located the
<small>SPM,</small> log into it and grab the file
<i>/var/log/vdsm/vdsm.log</i> which will contain detailed
error messages from low-level commands.</p>

<h2>MINIMAL XML FOR &minus;i libvirtxml OPTION
<a name="MINIMAL XML FOR &minus;i libvirtxml OPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When using the
<i>&minus;i libvirtxml</i> option, you have to supply some
libvirt <small>XML.</small> Writing this from scratch is
hard, so the template below is helpful.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note this
should only be used for testing and/or where you know what
you&rsquo;re doing!</b> If you have libvirt metadata for the
guest, always use that instead.</p>

<pre style="margin-left:11%; margin-top: 1em"> &lt;domain type='kvm'&gt;
   &lt;name&gt;NAME&lt;/name&gt;
   &lt;memory&gt;1048576&lt;/memory&gt;
   &lt;vcpu&gt;2&lt;/vcpu&gt;
   &lt;os&gt;
     &lt;type&gt;hvm&lt;/type&gt;
     &lt;boot dev='hd'/&gt;
   &lt;/os&gt;
   &lt;features&gt;
     &lt;acpi/&gt;
     &lt;apic/&gt;
     &lt;pae/&gt;
   &lt;/features&gt;
   &lt;devices&gt;
     &lt;disk type='file' device='disk'&gt;
       &lt;driver name='qemu' type='raw'/&gt;
       &lt;source file='/path/to/disk/image'/&gt;
       &lt;target dev='hda' bus='ide'/&gt;
     &lt;/disk&gt;
     &lt;interface type='network'&gt;
       &lt;mac address='52:54:00:01:02:03'/&gt;
       &lt;source network='default'/&gt;
       &lt;model type='rtl8139'/&gt;
     &lt;/interface&gt;
   &lt;/devices&gt;
 &lt;/domain&gt;</pre>


<h2>MACHINE READABLE OUTPUT
<a name="MACHINE READABLE OUTPUT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>&minus;&minus;machine&minus;readable</i> option can be
used to make the output more machine friendly, which is
useful when calling virt&minus;v2v from other programs, GUIs
etc.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to use this option.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly use the
option on its own to query the capabilities of the
virt&minus;v2v binary. Typical output looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em"> $ virt&minus;v2v &minus;&minus;machine&minus;readable
 virt&minus;v2v
 libguestfs&minus;rewrite
 input:disk
 [...]
 output:local
 [...]
 convert:enterprise&minus;linux
 convert:windows</pre>


<p style="margin-left:11%; margin-top: 1em">A list of
features is printed, one per line, and the program exits
with status 0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;input:&quot;</tt> and <tt>&quot;output:&quot;</tt>
features refer to <i>&minus;i</i> and <i>&minus;o</i> (input
and output mode) options supported by this binary. The
<tt>&quot;convert:&quot;</tt> features refer to guest types
that this binary knows how to convert.</p>

<p style="margin-left:11%; margin-top: 1em">Secondly use
the option in conjunction with other options to make the
regular program output more machine friendly.</p>

<p style="margin-left:11%; margin-top: 1em">At the moment
this means:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Progress bar messages can be parsed from stdout by
looking for this regular expression:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em"> ^[0&minus;9]+/[0&minus;9]+$</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">The calling program should treat
messages sent to stdout (except for progress bar messages)
as status messages. They can be logged and/or displayed to
the user.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The calling program should treat messages sent to stderr
as error messages. In addition, virt&minus;v2v exits with a
non-zero status code if there was a fatal error.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Virt&minus;v2v
&le; 0.9.1 did not support the
<i>&minus;&minus;machine&minus;readable</i> option at all.
The option was added when virt&minus;v2v was rewritten in
2014.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/share/virtio&minus;win</i></p>

<p style="margin-left:17%;">(Optional)</p>

<p style="margin-left:17%; margin-top: 1em">If this
directory is present, then virtio drivers for Windows guests
will be found from this directory and installed in the guest
during conversion.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;TMPDIR&quot;</p>

<p style="margin-left:17%;">Location of the temporary
directory used for the potentially large temporary overlay
file.</p>

<p style="margin-left:17%; margin-top: 1em">See the
&quot;Disk space&quot; section above.</p>


<p style="margin-left:11%;">&quot;VIRT_TOOLS_DATA_DIR&quot;</p>

<p style="margin-left:17%;">This can point to the directory
containing data files used for Windows conversion.</p>

<p style="margin-left:17%; margin-top: 1em">Normally you do
not need to set this. If not set, a compiled-in default will
be used (something like
<i>/usr/share/virt&minus;tools</i>).</p>

<p style="margin-left:17%; margin-top: 1em">This directory
may contain the following files: <i><br>
rhsrvany.exe</i></p>

<p style="margin-left:23%;">(Required when doing
conversions of Windows guests)</p>

<p style="margin-left:23%; margin-top: 1em">This is the
RHSrvAny Windows binary, used to install a
&quot;firstboot&quot; script in the guest during conversion
of Windows guests.</p>

<p style="margin-left:23%; margin-top: 1em">See also:
<tt>&quot;https://github.com/rwmjones/rhsrvany&quot;</tt></p>

<p style="margin-left:17%;"><i>rhev&minus;apt.exe</i></p>

<p style="margin-left:23%;">(Optional)</p>

<p style="margin-left:23%; margin-top: 1em">The
<small>RHEV</small> Application Provisioning Tool (
<small>RHEV APT</small> ). If this file is present, then
<small>RHEV APT</small> will be installed in the Windows
guest during conversion. This tool is a guest agent which
ensures that the virtio drivers remain up to date when the
guest is running on Red Hat Enterprise Virtualization (
<small>RHEV</small> ).</p>

<p style="margin-left:23%; margin-top: 1em">This file comes
from Red Hat Enterprise Virtualization ( <small>RHEV</small>
), and is not distributed with virt&minus;v2v.</p>

<p style="margin-left:11%;">&quot;VIRTIO_WIN&quot;</p>

<p style="margin-left:17%;">This is where VirtIO drivers
for Windows are searched for
(<i>/usr/share/virtio&minus;win</i> if unset). It can be a
directory <i>or</i> point to <i>virtio&minus;win.iso</i> (
<small>CD ROM</small> image containing drivers).</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>ENABLING VIRTIO&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em">For other
environment variables, see &quot; <small>ENVIRONMENT
VARIABLES&quot;</small> in <i>guestfs</i>(3).</p>

<h2>OTHER TOOLS
<a name="OTHER TOOLS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>virt&minus;v2v&minus;copy&minus;to&minus;local</i>(1)</p>

<p style="margin-left:17%;">There are some special cases
where virt&minus;v2v cannot directly access the remote
hypervisor. In that case you have to use
<i>virt&minus;v2v&minus;copy&minus;to&minus;local</i>(1) to
make a local copy of the guest first, followed by running
<tt>&quot;virt&minus;v2v &minus;i libvirtxml&quot;</tt> to
perform the conversion.</p>


<p style="margin-left:11%;"><i>engine&minus;image&minus;uploader</i>(8)</p>

<p style="margin-left:17%;">Variously called
<tt>&quot;engine&minus;image&minus;uploader&quot;</tt>,
<tt>&quot;ovirt&minus;image&minus;uploader&quot;</tt> or
<tt>&quot;rhevm&minus;image&minus;uploader&quot;</tt>, this
tool allows you to copy a guest from one oVirt or
<small>RHEV</small> Export Storage Domain to another. It
only permits importing a guest that was previously exported
from another oVirt/RHEV instance.</p>


<p style="margin-left:11%;">import&minus;to&minus;ovirt.pl</p>

<p style="margin-left:17%;">This script can be used to
import guests that already run on <small>KVM</small> to
oVirt or <small>RHEV.</small> For more information, see this
blog posting by the author of virt&minus;v2v:</p>


<p style="margin-left:17%; margin-top: 1em">https://rwmj.wordpress.com/2015/09/18/importing&minus;kvm&minus;guests&minus;to&minus;ovirt&minus;or&minus;rhev/#content</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>virt&minus;p2v</i>(1),
<i>virt&minus;customize</i>(1), <i>virt&minus;df</i>(1),
<i>virt&minus;filesystems</i>(1),
<i>virt&minus;sparsify</i>(1), <i>virt&minus;sysprep</i>(1),
<i>guestfs</i>(3), <i>guestfish</i>(1),
<i>qemu&minus;img</i>(1), <i>fstrim</i>(8),
<i>virt&minus;v2v&minus;copy&minus;to&minus;local</i>(1),
<i>virt&minus;v2v&minus;test&minus;harness</i>(1),
<i>engine&minus;image&minus;uploader</i>(8),
import&minus;to&minus;ovirt.pl, http://libguestfs.org/.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Richard W.M.
Jones http://people.redhat.com/~rjones/</p>

<p style="margin-left:11%; margin-top: 1em">Matthew
Booth</p>

<p style="margin-left:11%; margin-top: 1em">Mike
Latimer</p>

<p style="margin-left:11%; margin-top: 1em">Pino
Toscano</p>

<p style="margin-left:11%; margin-top: 1em">Shahar
Havivi</p>

<p style="margin-left:11%; margin-top: 1em">Tingting
Zheng</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2009&minus;2016 Red Hat Inc.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of the <small>GNU</small> General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later
version.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the
<small>GNU</small> General Public License for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the <small>GNU</small> General Public
License along with this program; if not, write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, <small>MA 02110&minus;1301 USA.</small></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To get a list
of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">To report a new
bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</p>

<p style="margin-left:11%; margin-top: 1em">When reporting
a bug, please supply:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The version of libguestfs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Where you got libguestfs (eg. which Linux distro,
compiled from source, etc)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Describe the bug accurately and give a way to reproduce
it.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Run <i>libguestfs&minus;test&minus;tool</i>(1) and paste
the <b>complete, unedited</b> output into the bug
report.</p> </td></tr>
 </table>
<hr>
</body>
</html>
