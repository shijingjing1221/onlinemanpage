<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:01:14 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>jarsigner</title>

</head>
<body>

<h1 align="center">jarsigner</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ERRORS&nbsp;AND&nbsp;WARNINGS">ERRORS&nbsp;AND&nbsp;WARNINGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#JDK&nbsp;1.1&nbsp;COMPATIBILITY">JDK&nbsp;1.1&nbsp;COMPATIBILITY</a><br>
<a href="#SEE&nbsp;ALSO">SEE&nbsp;ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jarsigner
&minus; Signs and verifies Java Archive (JAR) files.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>jarsigner</b>
[ <i>options</i> ] <i>jar&minus;file alias</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;verify</b> [ <i>options</i> ] <i>jar&minus;file</i>
[<i>alias ...</i>] <i><br>
options</i></p>

<p style="margin-left:22%;">The command-line options. See
Options.</p>

<p style="margin-left:11%;">-verify</p>

<p style="margin-left:22%;">The <b>-verify</b> option can
take zero or more keystore alias names after the JAR file
name. When the <b>-verify</b> option is specified, the
<b>jarsigner</b> command checks that the certificate used to
verify each signed entry in the JAR file matches one of the
keystore aliases. The aliases are defined in the keystore
specified by <b>-keystore</b> or the default keystore.</p>

<p style="margin-left:22%; margin-top: 1em">If you also
specified the <b>-strict</b> option, and the
<b>jarsigner</b> command detected severe warnings, the
message, &quot;jar verified, with signer errors&quot; is
displayed.</p>

<p style="margin-left:11%;"><i>jar-file</i></p>

<p style="margin-left:22%;">The JAR file to be signed.</p>

<p style="margin-left:22%; margin-top: 1em">If you also
specified the <b>-strict</b> option, and the
<b>jarsigner</b> command detected severe warnings, the
message, &quot;jar signed, with signer errors&quot; is
displayed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>alias</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>The aliases are defined in the keystore specified by
<b>-keystore</b> or the default keystore.</p></td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> tool has two purposes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">To sign Java Archive (JAR)
files.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>To verify the signatures and integrity of signed JAR
files.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The JAR feature
enables the packaging of class files, images, sounds, and
other digital data in a single file for faster and easier
distribution. A tool named <b>jar</b> enables developers to
produce JAR files. (Technically, any zip file can also be
considered a JAR file, although when created by the
<b>jar</b> command or processed by the <b>jarsigner</b>
command, JAR files also contain a
<b>META-INF/MANIFEST.MF</b> file.)</p>

<p style="margin-left:11%; margin-top: 1em">A digital
signature is a string of bits that is computed from some
data (the data being signed) and the private key of an
entity (a person, company, and so on). Similar to a
handwritten signature, a digital signature has many useful
characteristics:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Its authenticity can be verified
by a computation that uses the public key corresponding to
the private key used to generate the signature.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>It cannot be forged, assuming the private key is kept
secret.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>It is a function of the data signed and thus cannot be
claimed to be the signature for other data as well.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The signed data cannot be changed. If the data is
changed, then the signature cannot be verified as
authentic.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">To generate an
entity&rsquo;s signature for a file, the entity must first
have a public/private key pair associated with it and one or
more certificates that authenticate its public key. A
certificate is a digitally signed statement from one entity
that says that the public key of another entity has a
particular value.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> command uses key and certificate
information from a keystore to generate digital signatures
for JAR files. A keystore is a database of private keys and
their associated X.509 certificate chains that authenticate
the corresponding public keys. The <b>keytool</b> command is
used to create and administer keystores.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> command uses an entity&rsquo;s private key
to generate a signature. The signed JAR file contains, among
other things, a copy of the certificate from the keystore
for the public key corresponding to the private key used to
sign the file. The <b>jarsigner</b> command can verify the
digital signature of the signed JAR file using the
certificate inside it (in its signature block file).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> command can generate signatures that
include a time stamp that lets a systems or deployer
(including Java Plug-in) to check whether the JAR file was
signed while the signing certificate was still valid. In
addition, APIs allow applications to obtain the timestamp
information.</p>

<p style="margin-left:11%; margin-top: 1em">At this time,
the <b>jarsigner</b> command can only sign JAR files created
by the <b>jar</b> command or zip files. JAR files are the
same as zip files, except they also have a
<b>META-INF/MANIFEST.MF</b> file. A
<b>META-INF/MANIFEST.MF</b> file is created when the
<b>jarsigner</b> command signs a zip file.</p>

<p style="margin-left:11%; margin-top: 1em">The default
<b>jarsigner</b> command behavior is to sign a JAR or zip
file. Use the <b>-verify</b> option to verify a signed JAR
file.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> command also attempts to validate the
signer&rsquo;s certificate after signing or verifying. If
there is a validation error or any other problem, the
command generates warning messages. If you specify the
<b>-strict</b> option, then the command treats severe
warnings as errors. See Errors and Warnings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>KEYSTORE&nbsp;ALIASES</b>
<br>
All keystore entities are accessed with unique aliases.</p>

<p style="margin-left:11%; margin-top: 1em">When you use
the <b>jarsigner</b> command to sign a JAR file, you must
specify the alias for the keystore entry that contains the
private key needed to generate the signature. For example,
the following command signs the JAR file named
<b>MyJARFile.jar</b> with the private key associated with
the alias <b>duke</b> in the keystore named <b>mystore</b>
in the <b>working</b> directory. Because no output file is
specified, it overwrites <b>MyJARFile.jar</b> with the
signed JAR file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;storepass
&lt;keystore password&gt; <br>
&minus;keypass &lt;private key password&gt; MyJARFile.jar
duke</b></p>

<p style="margin-left:11%; margin-top: 1em">Keystores are
protected with a password, so the store password must be
specified. You are prompted for it when you do not specify
it on the command line. Similarly, private keys are
protected in a keystore with a password, so the private
key&rsquo;s password must be specified, and you are prompted
for the password when you do not specify it on the command
line and it is not the same as the store password.</p>


<p style="margin-left:11%; margin-top: 1em"><b>KEYSTORE&nbsp;LOCATION</b>
<br>
The <b>jarsigner</b> command has a <b>-keystore</b> option
for specifying the URL of the keystore to be used. The
keystore is by default stored in a file named
<b>.keystore</b> in the user&rsquo;s home directory, as
determined by the <b>user.home</b> system property.</p>

<p style="margin-left:11%; margin-top: 1em">On Oracle
Solaris systems, <b>user.home</b> defaults to the
user&rsquo;s home directory.</p>

<p style="margin-left:11%; margin-top: 1em">The input
stream from the <b>-keystore</b> option is passed to the
<b>KeyStore.load</b> method. If <b>NONE</b> is specified as
the URL, then a null stream is passed to the
<b>KeyStore.load</b> method. <b>NONE</b> should be specified
when the <b>KeyStore</b> class is not file based, for
example, when it resides on a hardware token device.</p>


<p style="margin-left:11%; margin-top: 1em"><b>KEYSTORE&nbsp;IMPLEMENTATION</b>
<br>
The <b>KeyStore</b> class provided in the
<b>java.security</b> package supplies a number of
well-defined interfaces to access and modify the information
in a keystore. You can have multiple different concrete
implementations, where each implementation is for a
particular type of keystore.</p>

<p style="margin-left:11%; margin-top: 1em">Currently,
there are two command-line tools that use keystore
implementations (<b>keytool</b> and <b>jarsigner</b>), and a
GUI-based tool named Policy Tool. Because the
<b>KeyStore</b> class is publicly available, JDK users can
write additional security applications that use it.</p>

<p style="margin-left:11%; margin-top: 1em">There is a
built-in default implementation provided by Oracle that
implements the keystore as a file, that uses a proprietary
keystore type (format) named JKS. The built-in
implementation protects each private key with its individual
password and protects the integrity of the entire keystore
with a (possibly different) password.</p>

<p style="margin-left:11%; margin-top: 1em">Keystore
implementations are provider-based, which means the
application interfaces supplied by the <b>KeyStore</b> class
are implemented in terms of a Service Provider Interface
(SPI). There is a corresponding abstract <b>KeystoreSpi</b>
class, also in the <b>java.security package</b>, that
defines the Service Provider Interface methods that
providers must implement. The term provider refers to a
package or a set of packages that supply a concrete
implementation of a subset of services that can be accessed
by the Java Security API. To provide a keystore
implementation, clients must implement a provider and supply
a <b>KeystoreSpi</b> subclass implementation, as described
in How to Implement a Provider in the Java Cryptography
Architecture at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html</p>

<p style="margin-left:11%; margin-top: 1em">Applications
can choose different types of keystore implementations from
different providers, with the <b>getInstance</b> factory
method in the <b>KeyStore</b> class. A keystore type defines
the storage and data format of the keystore information and
the algorithms used to protect private keys in the keystore
and the integrity of the keystore itself. Keystore
implementations of different types are not compatible.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> and <b>policytool</b> commands can read
file-based keystores from any location that can be specified
using a URL. In addition, these commands can read
non-file-based keystores such as those provided by MSCAPI on
Windows and PKCS11 on all platforms.</p>

<p style="margin-left:11%; margin-top: 1em">For the
<b>jarsigner</b> and <b>keytool</b> commands, you can
specify a keystore type at the command line with the
<b>-storetype</b> option. For Policy Tool, you can specify a
keystore type with the <i>Edit</i> command in the
<i>KeyStore</i> menu.</p>

<p style="margin-left:11%; margin-top: 1em">If you do not
explicitly specify a keystore type, then the tools choose a
keystore implementation based on the value of the
<b>keystore.type</b> property specified in the security
properties file. The security properties file is called
<b>java.security</b>, and it resides in the JDK security
properties directory, <b>java.home/lib/security</b>, where
<b>java.home</b> is the runtime environment&rsquo;s
directory. The <b>jre</b> directory in the JDK or the
top-level directory of the Java Runtime Environment
(JRE).</p>

<p style="margin-left:11%; margin-top: 1em">Each tool gets
the <b>keystore.type</b> value and then examines all the
installed providers until it finds one that implements
keystores of that type. It then uses the keystore
implementation from that provider.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>KeyStore</b> class defines a static method named
<b>getDefaultType</b> that lets applications and applets
retrieve the value of the <b>keystore.type</b> property. The
following line of code creates an instance of the default
keystore type as specified in the <b>keystore.type
property</b>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>KeyStore
keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</b></p>

<p style="margin-left:11%; margin-top: 1em">The default
keystore type is <b>jks</b> (the proprietary type of the
keystore implementation provided by Oracle). This is
specified by the following line in the security properties
file:</p>


<p style="margin-left:11%; margin-top: 1em"><b>keystore.type=jks</b></p>

<p style="margin-left:11%; margin-top: 1em">Case does not
matter in keystore type designations. For example,
<b>JKS</b> is the same as <b>jks</b>.</p>

<p style="margin-left:11%; margin-top: 1em">To have the
tools use a keystore implementation other than the default,
change that line to specify a different keystore type. For
example, if you have a provider package that supplies a
keystore implementation for a keystore type called
<b>pkcs12</b>, then change the line to the following:</p>


<p style="margin-left:11%; margin-top: 1em"><b>keystore.type=pkcs12</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i> If
you use the PKCS 11 provider package, then see
&quot;KeyTool&quot; and &quot;JarSigner&quot; in Java PKCS
#11 Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/p11guide.html</p>


<p style="margin-left:11%; margin-top: 1em"><b>SUPPORTED&nbsp;ALGORITHMS</b>
<br>
By default, the <b>jarsigner</b> command signs a JAR file
using one of the following algorithms:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Digital Signature Algorithm
(DSA) with the SHA1 digest algorithm</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>RSA algorithm with the SHA256 digest algorithm</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Elliptic Curve (EC) cryptography algorithm with the
SHA256 with Elliptic Curve Digital Signature Algorithm
(ECDSA).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the
signer&rsquo;s public and private keys are DSA keys, then
<b>jarsigner</b> signs the JAR file with the
<b>SHA1withDSA</b> algorithm. If the signer&rsquo;s keys are
RSA keys, then <b>jarsigner</b> attempts to sign the JAR
file with the <b>SHA256withRSA</b> algorithm. If the
signer&rsquo;s keys are EC keys, then <b>jarsigner</b> signs
the JAR file with the <b>SHA256withECDSA</b> algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">These default
signature algorithms can be overridden using the
<b>-sigalg</b> option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>THE&nbsp;SIGNED&nbsp;JAR&nbsp;FILE</b>
<br>
When the <b>jarsigner</b> command is used to sign a JAR
file, the output signed JAR file is exactly the same as the
input JAR file, except that it has two additional files
placed in the META-INF directory:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">A signature file with an
<b>.SF</b> extension</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>A signature block file with a <b>.DSA</b>, <b>.RSA</b>,
or <b>.EC</b> extension</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The base file
names for these two files come from the value of the
<b>-sigFile</b> option. For example, when the option is
<b>-sigFile MKSIGN</b>, the files are named <b>MKSIGN.SF</b>
and <b>MKSIGN.DSA</b></p>

<p style="margin-left:11%; margin-top: 1em">If no
<b>-sigfile</b> option appears on the command line, then the
base file name for the <b>.SF</b> and <b>.DSA</b> files is
the first 8 characters of the alias name specified on the
command line, all converted to uppercase. If the alias name
has fewer than 8 characters, then the full alias name is
used. If the alias name contains any characters that are not
allowed in a signature file name, then each such character
is converted to an underscore (_) character in forming the
file name. Valid characters include letters, digits,
underscores, and hyphens.</p>

<p style="margin-left:11%; margin-top: 1em">Signature
File</p>

<p style="margin-left:11%; margin-top: 1em">A signature
file (<b>.SF</b> file) looks similar to the manifest file
that is always included in a JAR file when the
<b>jarsigner</b> command is used to sign the file. For each
source file included in the JAR file, the <b>.SF</b> file
has three lines, such as in the manifest file, that list the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em">File name</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>Name of the digest algorithm (SHA)</p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p>SHA digest value</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the manifest
file, the SHA digest value for each source file is the
digest (hash) of the binary data in the source file. In the
<b>.SF</b> file, the digest value for a specified source
file is the hash of the three lines in the manifest file for
the source file.</p>

<p style="margin-left:11%; margin-top: 1em">The signature
file, by default, includes a header with a hash of the whole
manifest file. The header also contains a hash of the
manifest header. The presence of the header enables
verification optimization. See JAR File Verification.</p>

<p style="margin-left:11%; margin-top: 1em">Signature Block
File</p>

<p style="margin-left:11%; margin-top: 1em">The <b>.SF</b>
file is signed and the signature is placed in the signature
block file. This file also contains, encoded inside it, the
certificate or certificate chain from the keystore that
authenticates the public key corresponding to the private
key used for signing. The file has the extension
<b>.DSA</b>, <b>.RSA</b>, or <b>.EC</b>, depending on the
digest algorithm used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SIGNATURE&nbsp;TIME&nbsp;STAMP</b>
<br>
The <b>jarsigner</b> command can generate and store a
signature time stamp when signing a JAR file. In addition,
<b>jarsigner</b> supports alternative signing mechanisms.
This behavior is optional and is controlled by the user at
the time of signing through these options. See Options.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;tsa</b>
<i>url</i> <b><br>
&minus;tsacert</b> <i>alias</i> <b><br>
&minus;altsigner</b> <i>class</i> <b><br>
&minus;altsignerpath</b> <i>classpathlist</i> <b><br>
&minus;tsapolicyid</b> <i>policyid</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>JAR&nbsp;FILE&nbsp;VERIFICATION</b>
<br>
A successful JAR file verification occurs when the
signatures are valid, and none of the files that were in the
JAR file when the signatures were generated have changed
since then. JAR file verification involves the following
steps:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="57%">


<p style="margin-top: 1em">Verify the signature of the
<b>.SF</b> file.</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The
verification ensures that the signature stored in each
signature block (<b>.DSA</b>) file was generated using the
private key corresponding to the public key whose
certificate (or certificate chain) also appears in the
<b>.DSA</b> file. It also ensures that the signature is a
valid signature of the corresponding signature (<b>.SF</b>)
file, and thus the <b>.SF</b> file was not tampered
with.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Verify the digest listed in each
entry in the <b>.SF</b> file with each corresponding section
in the manifest.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The <b>.SF</b>
file by default includes a header that contains a hash of
the entire manifest file. When the header is present, the
verification can check to see whether or not the hash in the
header matches the hash of the manifest file. If there is a
match, then verification proceeds to the next step.</p>

<p style="margin-left:17%; margin-top: 1em">If there is no
match, then a less optimized verification is required to
ensure that the hash in each source file information section
in the <b>.SF</b> file equals the hash of its corresponding
section in the manifest file. See Signature File.</p>

<p style="margin-left:17%; margin-top: 1em">One reason the
hash of the manifest file that is stored in the <b>.SF</b>
file header might not equal the hash of the current manifest
file is that one or more files were added to the JAR file
(with the <b>jar</b> tool) after the signature and
<b>.SF</b> file were generated. When the <b>jar</b> tool is
used to add files, the manifest file is changed by adding
sections to it for the new files, but the <b>.SF</b> file is
not changed. A verification is still considered successful
when none of the files that were in the JAR file when the
signature was generated have been changed since then. This
happens when the hashes in the non-header sections of the
<b>.SF</b> file equal the hashes of the corresponding
sections in the manifest file.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Read each file in the JAR file
that has an entry in the <b>.SF</b> file. While reading,
compute the file&rsquo;s digest and compare the result with
the digest for this file in the manifest section. The
digests should be the same or verification fails.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If any serious
verification failures occur during the verification process,
then the process is stopped and a security exception is
thrown. The <b>jarsigner</b> command catches and displays
the exception.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i>
You should read any addition warnings (or errors if you
specified the <b>-strict</b> option), as well as the content
of the certificate (by specifying the <b>-verbose</b> and
<b>-certs</b> options) to determine if the signature can be
trusted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MULTIPLE&nbsp;SIGNATURES&nbsp;FOR&nbsp;A&nbsp;JAR&nbsp;FILE</b>
<br>
A JAR file can be signed by multiple people by running the
<b>jarsigner</b> command on the file multiple times and
specifying the alias for a different person each time, as
follows:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
myBundle.jar susan <br>
jarsigner myBundle.jar kevin</b></p>

<p style="margin-left:11%; margin-top: 1em">When a JAR file
is signed multiple times, there are multiple <b>.SF</b> and
<b>.DSA</b> files in the resulting JAR file, one pair for
each signature. In the previous example, the output JAR file
includes files with the following names:</p>

<p style="margin-left:11%; margin-top: 1em"><b>SUSAN.SF
<br>
SUSAN.DSA <br>
KEVIN.SF <br>
KEVIN.DSA</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i> It
is also possible for a JAR file to have mixed signatures,
some generated by the JDK 1.1 by the <b>javakey</b> command
and others by <b>jarsigner</b>. The <b>jarsigner</b> command
can be used to sign JAR files that are already signed with
the <b>javakey</b> command.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
sections describe the various <b>jarsigner</b> options. Be
aware of the following standards:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">All option names are preceded by
a minus sign (-).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The options can be provided in any order.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Items that are in italics or underlined (option values)
represent the actual values that must be supplied.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <b>-storepass</b>, <b>-keypass</b>, <b>-sigfile</b>,
<b>-sigalg</b>, <b>-digestalg</b>, <b>-signedjar</b>, and
TSA-related options are only relevant when signing a JAR
file; they are not relevant when verifying a signed JAR
file. The <b>-keystore</b> option is relevant for signing
and verifying a JAR file. In addition, aliases are specified
when signing and verifying a JAR file.</p></td></tr>
</table>

<p style="margin-left:11%;">-keystore <i>url</i></p>

<p style="margin-left:14%;">Specifies the URL that tells
the keystore location. This defaults to the file
<b>.keystore</b> in the user&rsquo;s home directory, as
determined by the <b>user.home</b> system property.</p>

<p style="margin-left:14%; margin-top: 1em">A keystore is
required when signing. You must explicitly specify a
keystore when the default keystore does not exist or if you
want to use one other than the default.</p>

<p style="margin-left:14%; margin-top: 1em">A keystore is
not required when verifying, but if one is specified or the
default exists and the <b>-verbose</b> option was also
specified, then additional information is output regarding
whether or not any of the certificates used to verify the
JAR file are contained in that keystore.</p>

<p style="margin-left:14%; margin-top: 1em">The
<b>-keystore</b> argument can be a file name and path
specification rather than a URL, in which case it is treated
the same as a file: URL, for example, the following are
equivalent:</p>


<p style="margin-left:14%; margin-top: 1em"><b>&minus;keystore</b>
<i>filePathAndName</i> <b><br>
&minus;keystore file:</b><i>filePathAndName</i></p>

<p style="margin-left:14%; margin-top: 1em">If the Sun PKCS
#11 provider was configured in the <b>java.security</b>
security properties file (located in the JRE&rsquo;s
<b>$JAVA_HOME/lib/security directory</b>), then the
<b>keytool</b> and <b>jarsigner</b> tools can operate on the
PKCS #11 token by specifying these options:</p>


<p style="margin-left:14%; margin-top: 1em"><b>&minus;keystore
NONE <br>
&minus;storetype PKCS11</b></p>

<p style="margin-left:14%; margin-top: 1em">For example,
the following command lists the contents of the configured
PKCS#11 token:</p>

<p style="margin-left:14%; margin-top: 1em"><b>keytool
&minus;keystore NONE &minus;storetype PKCS11
&minus;list</b></p>

<p style="margin-left:11%;">-storetype <i>storetype</i></p>

<p style="margin-left:14%;">Specifies the type of keystore
to be instantiated. The default keystore type is the one
that is specified as the value of the <b>keystore.type</b>
property in the security properties file, which is returned
by the static <b>getDefaultType</b> method in
<b>java.security.KeyStore</b>.</p>

<p style="margin-left:14%; margin-top: 1em">The PIN for a
PCKS #11 token can also be specified with the
<b>-storepass</b> option. If none is specified, then the
<b>keytool</b> and <b>jarsigner</b> commands prompt for the
token PIN. If the token has a protected authentication path
(such as a dedicated PIN-pad or a biometric reader), then
the <b>-protected</b> option must be specified and no
password options can be specified.</p>

<p style="margin-left:11%;">-storepass[:env | :file]
<i>argument</i></p>

<p style="margin-left:14%;">Specifies the password that is
required to access the keystore. This is only needed when
signing (not verifying) a JAR file. In that case, if a
<b>-storepass</b> option is not provided at the command
line, then the user is prompted for the password.</p>

<p style="margin-left:14%; margin-top: 1em">If the modifier
<b>env</b> or <b>file</b> is not specified, then the
password has the value <i>argument</i>. Otherwise, the
password is retrieved as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>env</b>: Retrieve the password from the environment
variable named <b>argument</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>file</b>: Retrieve the password from the file named
<b>argument</b>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i>
The password should not be specified on the command line or
in a script unless it is for testing purposes, or you are on
a secure system. <br>
-keypass [:env | :file] <i>argument</i></p>

<p style="margin-left:14%;">Specifies the password used to
protect the private key of the keystore entry addressed by
the alias specified on the command line. The password is
required when using <b>jarsigner</b> to sign a JAR file. If
no password is provided on the command line, and the
required password is different from the store password, then
the user is prompted for it.</p>

<p style="margin-left:14%; margin-top: 1em">If the modifier
<b>env</b> or <b>file</b> is not specified, then the
password has the value <b>argument</b>. Otherwise, the
password is retrieved as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>env</b>: Retrieve the password from the environment
variable named <b>argument</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>file</b>: Retrieve the password from the file named
<b>argument</b>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i>
The password should not be specified on the command line or
in a script unless it is for testing purposes, or you are on
a secure system. <br>
-sigfile <i>file</i></p>

<p style="margin-left:14%;">Specifies the base file name to
be used for the generated <b>.SF</b> and <b>.DSA</b> files.
For example, if file is <b>DUKESIGN</b>, then the generated
<b>.SF</b> and <b>.DSA</b> files are named
<b>DUKESIGN.SF</b> and <b>DUKESIGN.DSA</b>, and placed in
the <b>META-INF</b> directory of the signed JAR file.</p>

<p style="margin-left:14%; margin-top: 1em">The characters
in the file must come from the set <b>a-zA-Z0-9_-</b>. Only
letters, numbers, underscore, and hyphen characters are
allowed. All lowercase characters are converted to uppercase
for the <b>.SF</b> and <b>.DSA</b> file names.</p>

<p style="margin-left:14%; margin-top: 1em">If no
<b>-sigfile</b> option appears on the command line, then the
base file name for the <b>.SF</b> and <b>.DSA</b> files is
the first 8 characters of the alias name specified on the
command line, all converted to upper case. If the alias name
has fewer than 8 characters, then the full alias name is
used. If the alias name contains any characters that are not
valid in a signature file name, then each such character is
converted to an underscore (_) character to form the file
name.</p>

<p style="margin-left:11%;">-sigalg <i>algorithm</i></p>

<p style="margin-left:14%;">Specifies the name of the
signature algorithm to use to sign the JAR file.</p>

<p style="margin-left:14%; margin-top: 1em">For a list of
standard signature algorithm names, see &quot;Appendix A:
Standard Names&quot; in the Java Cryptography Architecture
(JCA) Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</p>

<p style="margin-left:14%; margin-top: 1em">This algorithm
must be compatible with the private key used to sign the JAR
file. If this option is not specified, then
<b>SHA1withDSA</b>, <b>SHA256withRSA</b>, or
<b>SHA256withECDSA</b> are used depending on the type of
private key. There must either be a statically installed
provider supplying an implementation of the specified
algorithm or the user must specify one with the
<b>-providerClass</b> option; otherwise, the command will
not succeed.</p>

<p style="margin-left:11%;">-digestalg <i>algorithm</i></p>

<p style="margin-left:14%;">Specifies the name of the
message digest algorithm to use when digesting the entries
of a JAR file.</p>

<p style="margin-left:14%; margin-top: 1em">For a list of
standard message digest algorithm names, see &quot;Appendix
A: Standard Names&quot; in the Java Cryptography
Architecture (JCA) Reference Guide at
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</p>

<p style="margin-left:14%; margin-top: 1em">If this option
is not specified, then <b>SHA256</b> is used. There must
either be a statically installed provider supplying an
implementation of the specified algorithm or the user must
specify one with the <b>-providerClass</b> option;
otherwise, the command will not succeed.</p>

<p style="margin-left:11%;">-certs</p>

<p style="margin-left:14%;">If the <b>-certs</b> option
appears on the command line with the <b>-verify</b> and
<b>-verbose</b> options, then the output includes
certificate information for each signer of the JAR file.
This information includes the name of the type of
certificate (stored in the <b>.DSA</b> file) that certifies
the signer&rsquo;s public key, and if the certificate is an
X.509 certificate (an instance of the
<b>java.security.cert.X509Certificate</b>), then the
distinguished name of the signer.</p>

<p style="margin-left:14%; margin-top: 1em">The keystore is
also examined. If no keystore value is specified on the
command line, then the default keystore file (if any) is
checked. If the public key certificate for a signer matches
an entry in the keystore, then the alias name for the
keystore entry for that signer is displayed in parentheses.
If the signer comes from a JDK 1.1 identity database instead
of from a keystore, then the alias name displays in brackets
instead of parentheses.</p>

<p style="margin-left:11%;">-certchain <i>file</i></p>

<p style="margin-left:14%;">Specifies the certificate chain
to be used when the certificate chain associated with the
private key of the keystore entry that is addressed by the
alias specified on the command line is not complete. This
can happen when the keystore is located on a hardware token
where there is not enough capacity to hold a complete
certificate chain. The file can be a sequence of
concatenated X.509 certificates, or a single PKCS#7
formatted data block, either in binary encoding format or in
printable encoding format (also known as Base64 encoding) as
defined by the Internet RFC 1421 standard. See the section
Internet RFC 1421 Certificate Encoding Standard in
<b>keytool</b> and http://tools.ietf.org/html/rfc1421.</p>

<p style="margin-left:11%;">-verbose</p>

<p style="margin-left:14%;">When the <b>-verbose</b> option
appears on the command line, it indicates verbose mode,
which causes <b>jarsigner</b> to output extra information
about the progress of the JAR signing or verification.</p>

<p style="margin-left:11%;">-internalsf</p>

<p style="margin-left:14%;">In the past, the <b>.DSA</b>
(signature block) file generated when a JAR file was signed
included a complete encoded copy of the <b>.SF</b> file
(signature file) also generated. This behavior has been
changed. To reduce the overall size of the output JAR file,
the <b>.DSA</b> file by default does not contain a copy of
the <b>.SF</b> file anymore. If <b>-internalsf</b> appears
on the command line, then the old behavior is utilized. This
option is useful for testing. In practice, do not use the
<b>-internalsf</b> option because it incurs higher
overhead.</p>

<p style="margin-left:11%;">-sectionsonly</p>

<p style="margin-left:14%;">If the <b>-sectionsonly</b>
option appears on the command line, then the <b>.SF</b> file
(signature file) generated when a JAR file is signed does
not include a header that contains a hash of the whole
manifest file. It contains only the information and hashes
related to each individual source file included in the JAR
file. See Signature File.</p>

<p style="margin-left:14%; margin-top: 1em">By default,
this header is added, as an optimization. When the header is
present, whenever the JAR file is verified, the verification
can first check to see whether the hash in the header
matches the hash of the whole manifest file. When there is a
match, verification proceeds to the next step. When there is
no match, it is necessary to do a less optimized
verification that the hash in each source file information
section in the <b>.SF</b> file equals the hash of its
corresponding section in the manifest file. See JAR File
Verification.</p>

<p style="margin-left:14%; margin-top: 1em">The
<b>-sectionsonly</b> option is primarily used for testing.
It should not be used other than for testing because using
it incurs higher overhead.</p>

<p style="margin-left:11%;">-protected</p>

<p style="margin-left:14%;">Values can be either
<b>true</b> or <b>false</b>. Specify <b>true</b> when a
password must be specified through a protected
authentication path such as a dedicated PIN reader.</p>

<p style="margin-left:11%;">-providerClass
<i>provider-class-name</i></p>

<p style="margin-left:14%;">Used to specify the name of
cryptographic service provider&rsquo;s master class file
when the service provider is not listed in the
<b>java.security</b> security properties file.</p>

<p style="margin-left:14%; margin-top: 1em">Used with the
<b>-providerArg ConfigFilePath</b> option, the
<b>keytool</b> and <b>jarsigner</b> tools install the
provider dynamically and use <i>ConfigFilePath</i> for the
path to the token configuration file. The following example
shows a command to list a <b>PKCS #11</b> keystore when the
Oracle PKCS #11 provider was not configured in the security
properties file.</p>

<p style="margin-left:14%; margin-top: 1em"><b>jarsigner
&minus;keystore NONE &minus;storetype PKCS11 \ <br>
&minus;providerClass sun.security.pkcs11.SunPKCS11 \ <br>
&minus;providerArg /mydir1/mydir2/token.config \ <br>
&minus;list</b></p>

<p style="margin-left:11%;">-providerName
<i>providerName</i></p>

<p style="margin-left:14%;">If more than one provider was
configured in the <b>java.security</b> security properties
file, then you can use the <b>-providerName</b> option to
target a specific provider instance. The argument to this
option is the name of the provider.</p>

<p style="margin-left:14%; margin-top: 1em">For the Oracle
PKCS #11 provider, <i>providerName</i> is of the form
<b>SunPKCS11-</b><i>TokenName</i>, where <i>TokenName</i> is
the name suffix that the provider instance has been
configured with, as detailed in the configuration attributes
table. For example, the following command lists the contents
of the <b>PKCS #11</b> keystore provider instance with name
suffix <b>SmartCard</b>:</p>

<p style="margin-left:14%; margin-top: 1em"><b>jarsigner
&minus;keystore NONE &minus;storetype PKCS11 \ <br>
&minus;providerName SunPKCS11&minus;SmartCard \ <br>
&minus;list</b></p>

<p style="margin-left:11%;">-J<i>javaoption</i></p>

<p style="margin-left:14%;">Passes through the specified
<i>javaoption</i> string directly to the Java interpreter.
The <b>jarsigner</b> command is a wrapper around the
interpreter. This option should not contain any spaces. It
is useful for adjusting the execution environment or memory
usage. For a list of possible interpreter options, type
<b>java -h</b> or <b>java -X</b> at the command line.</p>

<p style="margin-left:11%;">-tsa <i>url</i></p>

<p style="margin-left:14%;">If <b>-tsa
http://example.tsa.url</b> appears on the command line when
signing a JAR file then a time stamp is generated for the
signature. The URL, <b>http://example.tsa.url</b>,
identifies the location of the Time Stamping Authority (TSA)
and overrides any URL found with the <b>-tsacert</b> option.
The <b>-tsa</b> option does not require the TSA public key
certificate to be present in the keystore.</p>

<p style="margin-left:14%; margin-top: 1em">To generate the
time stamp, <b>jarsigner</b> communicates with the TSA with
the Time-Stamp Protocol (TSP) defined in RFC 3161. When
successful, the time stamp token returned by the TSA is
stored with the signature in the signature block file.</p>

<p style="margin-left:11%;">-tsacert <i>alias</i></p>

<p style="margin-left:14%;">When <b>-tsacert alias</b>
appears on the command line when signing a JAR file, a time
stamp is generated for the signature. The alias identifies
the TSA public key certificate in the keystore that is in
effect. The entry&rsquo;s certificate is examined for a
Subject Information Access extension that contains a URL
identifying the location of the TSA.</p>

<p style="margin-left:14%; margin-top: 1em">The TSA public
key certificate must be present in the keystore when using
the <b>-tsacert</b> option.</p>

<p style="margin-left:11%;">-tsapolicyid
<i>policyid</i></p>

<p style="margin-left:14%;">Specifies the object identifier
(OID) that identifies the policy ID to be sent to the TSA
server. If this option is not specified, no policy ID is
sent and the TSA server will choose a default policy ID.</p>

<p style="margin-left:14%; margin-top: 1em">Object
identifiers are defined by X.696, which is an ITU
Telecommunication Standardization Sector (ITU-T) standard.
These identifiers are typically period-separated sets of
non-negative digits like <b>1.2.3.4</b>, for example.</p>

<p style="margin-left:11%;">-altsigner <i>class</i></p>

<p style="margin-left:14%;">This option specifies an
alternative signing mechanism. The fully qualified class
name identifies a class file that extends the
<b>com.sun.jarsigner.ContentSigner</b> abstract class. The
path to this class file is defined by the
<b>-altsignerpath</b> option. If the <b>-altsigner</b>
option is used, then the <b>jarsigner</b> command uses the
signing mechanism provided by the specified class.
Otherwise, the <b>jarsigner</b> command uses its default
signing mechanism.</p>

<p style="margin-left:14%; margin-top: 1em">For example, to
use the signing mechanism provided by a class named
<b>com.sun.sun.jarsigner.AuthSigner</b>, use the jarsigner
option <b>-altsigner com.sun.jarsigner.AuthSigner</b>.</p>

<p style="margin-left:11%;">-altsignerpath
<i>classpathlist</i></p>

<p style="margin-left:14%;">Specifies the path to the class
file and any JAR file it depends on. The class file name is
specified with the <b>-altsigner</b> option. If the class
file is in a JAR file, then this option specifies the path
to that JAR file.</p>

<p style="margin-left:14%; margin-top: 1em">An absolute
path or a path relative to the current directory can be
specified. If <i>classpathlist</i> contains multiple paths
or JAR files, then they should be separated with a colon (:)
on Oracle Solaris and a semicolon (;) on Windows. This
option is not necessary when the class is already in the
search path.</p>

<p style="margin-left:14%; margin-top: 1em">The following
example shows how to specify the path to a JAR file that
contains the class file. The JAR file name is included.</p>


<p style="margin-left:14%; margin-top: 1em"><b>&minus;altsignerpath
/home/user/lib/authsigner.jar</b></p>

<p style="margin-left:14%; margin-top: 1em">The following
example shows how to specify the path to the JAR file that
contains the class file. The JAR file name is omitted.</p>


<p style="margin-left:14%; margin-top: 1em"><b>&minus;altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</b></p>

<p style="margin-left:11%;">-strict</p>

<p style="margin-left:14%;">During the signing or verifying
process, the command may issue warning messages. If you
specify this option, the exit code of the tool reflects the
severe warning messages that this command found. See Errors
and Warnings.</p>

<p style="margin-left:11%;">-verbose <i>suboptions</i></p>

<p style="margin-left:14%;">For the verifying process, the
<b>-verbose</b> option takes suboptions to determine how
much information is shown. If the <b>-certs</b> option is
also specified, then the default mode (or suboption
<b>all</b>) displays each entry as it is being processed,
and after that, the certificate information for each signer
of the JAR file. If the <b>-certs</b> and the
<b>-verbose:grouped</b> suboptions are specified, then
entries with the same signer info are grouped and displayed
together with their certificate information. If
<b>-certs</b> and the <b>-verbose:summary</b> suboptions are
specified, then entries with the same signer information are
grouped and displayed together with their certificate
information. Details about each entry are summarized and
displayed as <i>one entry (and more)</i>. See Examples.</p>

<h2>ERRORS&nbsp;AND&nbsp;WARNINGS
<a name="ERRORS&nbsp;AND&nbsp;WARNINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">During the
signing or verifying process, the <b>jarsigner</b> command
may issue various errors or warnings.</p>

<p style="margin-left:11%; margin-top: 1em">If there is a
failure, the <b>jarsigner</b> command exits with code 1. If
there is no failure, but there are one or more severe
warnings, the <b>jarsigner</b> command exits with code 0
when the <b>-strict</b> option is <i>not</i> specified, or
exits with the OR-value of the warning codes when the
<b>-strict</b> is specified. If there is only informational
warnings or no warning at all, the command always exits with
code 0.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
a certificate used to sign an entry is expired and has a
KeyUsage extension that does not allow it to sign a file,
the <b>jarsigner</b> command exits with code 12 (=4+8) when
the <b>-strict</b> option is specified.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i>
Exit codes are reused because only the values from 0 to 255
are legal on Unix-based operating systems.</p>

<p style="margin-left:11%; margin-top: 1em">The following
sections describes the names, codes, and descriptions of the
errors and warnings that the <b>jarsigner</b> command can
issue.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FAILURE</b>
<br>
Reasons why the <b>jarsigner</b> command fails include (but
are not limited to) a command line parsing error, the
inability to find a keypair to sign the JAR file, or the
verification of a signed JAR fails. <br>
failure</p>

<p style="margin-left:22%;">Code 1. The signing or
verifying fails.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SEVERE&nbsp;WARNINGS</b>
<i><br>
Note:</i> Severe warnings are reported as errors if you
specify the <b>-strict</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">Reasons why the
<b>jarsigner</b> command issues a severe warning include the
certificate used to sign the JAR file has an error or the
signed JAR file has other problems. <br>
hasExpiredCert</p>

<p style="margin-left:22%;">Code 4. This jar contains
entries whose signer certificate has expired.</p>

<p style="margin-left:11%;">notYetValidCert</p>

<p style="margin-left:22%;">Code 4. This jar contains
entries whose signer certificate is not yet valid.</p>

<p style="margin-left:11%;">chainNotValidated</p>

<p style="margin-left:22%;">Code 4. This jar contains
entries whose certificate chain cannot be correctly
validated.</p>

<p style="margin-left:11%;">badKeyUsage</p>

<p style="margin-left:22%;">Code 8. This jar contains
entries whose signer certificate&rsquo;s KeyUsage extension
doesn&rsquo;t allow code signing.</p>

<p style="margin-left:11%;">badExtendedKeyUsage</p>

<p style="margin-left:22%;">Code 8. This jar contains
entries whose signer certificate&rsquo;s ExtendedKeyUsage
extension doesn&rsquo;t allow code signing.</p>

<p style="margin-left:11%;">badNetscapeCertType</p>

<p style="margin-left:22%;">Code 8. This jar contains
entries whose signer certificate&rsquo;s NetscapeCertType
extension doesn&rsquo;t allow code signing.</p>

<p style="margin-left:11%;">hasUnsignedEntry</p>

<p style="margin-left:22%;">Code 16. This jar contains
unsigned entries which have not been integrity-checked.</p>

<p style="margin-left:11%;">notSignedByAlias</p>

<p style="margin-left:22%;">Code 32. This jar contains
signed entries which are not signed by the specified
alias(es).</p>

<p style="margin-left:11%;">aliasNotInStore</p>

<p style="margin-left:22%;">Code 32. This jar contains
signed entries that are not signed by alias in this
keystore.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INFORMATIONAL&nbsp;WARNINGS</b>
<br>
Informational warnings include those that are not errors but
regarded as bad practice. They do not have a code. <br>
hasExpiringCert</p>

<p style="margin-left:22%;">This jar contains entries whose
signer certificate will expire within six months.</p>

<p style="margin-left:11%;">noTimestamp</p>

<p style="margin-left:22%;">This jar contains signatures
that does not include a timestamp. Without a timestamp,
users may not be able to validate this JAR file after the
signer certificate&rsquo;s expiration date
(<b>YYYY-MM-DD</b>) or after any future revocation date.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SIGN&nbsp;A&nbsp;JAR&nbsp;FILE</b>
<br>
Use the following command to sign bundle.jar with the
private key of a user whose keystore alias is <b>jane</b> in
a keystore named <b>mystore</b> in the <b>working</b>
directory and name the signed JAR file
<b>sbundle.jar</b>:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore <br>
&minus;storepass &lt;keystore password&gt; <br>
&minus;keypass &lt;private key password&gt; <br>
&minus;signedjar sbundle.jar bundle.jar jane</b></p>

<p style="margin-left:11%; margin-top: 1em">There is no
<b>-sigfile</b> specified in the previous command so the
generated <b>.SF</b> and <b>.DSA</b> files to be placed in
the signed JAR file have default names based on the alias
name. They are named <b>JANE.SF</b> and <b>JANE.DSA</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
be prompted for the store password and the private key
password, then you could shorten the previous command to the
following:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore <br>
&minus;signedjar sbundle.jar bundle.jar jane</b></p>

<p style="margin-left:11%; margin-top: 1em">If the keystore
is the default keystore (.keystore in your home directory),
then you do not need to specify a keystore, as follows:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;signedjar sbundle.jar bundle.jar jane</b></p>

<p style="margin-left:11%; margin-top: 1em">If you want the
signed JAR file to overwrite the input JAR file
(bundle.jar), then you do not need to specify a
<b>-signedjar</b> option, as follows:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
bundle.jar jane</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>VERIFY&nbsp;A&nbsp;SIGNED&nbsp;JAR&nbsp;FILE</b>
<br>
To verify a signed JAR file to ensure that the signature is
valid and the JAR file was not been tampered with, use a
command such as the following:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;verify sbundle.jar</b></p>

<p style="margin-left:11%; margin-top: 1em">When the
verification is successful, <b>jar verified</b> is
displayed. Otherwise, an error message is displayed. You can
get more information when you use the <b>-verbose</b>
option. A sample use of <b>jarsigner</b> with
the<b>-verbose</b> option follows:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;verify &minus;verbose sbundle.jar <br>
198 Fri Sep 26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF
<br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 AclEx.class <br>
smk 849 Fri Sep 26 16:12:46 PDT 1997 test.class <br>
s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore <br>
jar verified.</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>VERIFICATION&nbsp;WITH&nbsp;CERTIFICATE&nbsp;INFORMATION</b>
<br>
If you specify the <b>-certs</b> option with the
<b>-verify</b> and <b>-verbose</b> options, then the output
includes certificate information for each signer of the JAR
file. The information includes the certificate type, the
signer distinguished name information (when it is an X.509
certificate), and in parentheses, the keystore alias for the
signer when the public key certificate in the JAR file
matches the one in a keystore entry, for example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;verify
&minus;verbose &minus;certs myTest.jar <br>
198 Fri Sep 26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF
<br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
208 Fri Sep 26 16:23:30 PDT 1997 META&minus;INF/JAVATEST.SF
<br>
1087 Fri Sep 26 16:23:30 PDT 1997
META&minus;INF/JAVATEST.DSA <br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 Tst.class <br>
X.509, CN=Test Group, OU=Java Software, O=Oracle, L=CUP,
S=CA, C=US (javatest) <br>
X.509, CN=Jane Smith, OU=Java Software, O=Oracle, L=cup,
S=ca, C=us (jane) <br>
s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore <br>
jar verified.</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
certificate for a signer is not an X.509 certificate, then
there is no distinguished name information. In that case,
just the certificate type and the alias are shown. For
example, if the certificate is a PGP certificate, and the
alias is <b>bob</b>, then you would get: <b>PGP,
(bob)</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>VERIFICATION&nbsp;THAT&nbsp;INCLUDES&nbsp;IDENTITY&nbsp;DATABASE&nbsp;SIGNERS</b>
<br>
If a JAR file was signed with the JDK 1.1 <b>javakey</b>
tool, and the signer is an alias in an identity database,
then the verification output includes an <b>i</b>. If the
JAR file was signed by both an alias in an identity database
and an alias in a keystore, then both <b>k</b> and <b>i</b>
appear.</p>

<p style="margin-left:11%; margin-top: 1em">When the
<b>-certs</b> option is used, any identity database aliases
are shown in brackets rather than the parentheses used for
keystore aliases, for example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;verify
&minus;verbose &minus;certs writeFile.jar <br>
198 Fri Sep 26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF
<br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
199 Fri Sep 27 12:22:30 PDT 1997 META&minus;INF/DUKE.SF <br>
1013 Fri Sep 27 12:22:30 PDT 1997 META&minus;INF/DUKE.DSA
<br>
smki 2752 Fri Sep 26 16:12:30 PDT 1997 writeFile.html <br>
X.509, CN=Jane Smith, OU=Java Software, O=Oracle, L=cup,
S=ca, C=us (jane) <br>
X.509, CN=Duke, OU=Java Software, O=Oracle, L=cup, S=ca,
C=us [duke] <br>
s = signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore <br>
i = at least one certificate was found in identity scope
<br>
jar verified.</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Note:</i>
The alias <b>duke</b> is in brackets to denote that it is an
identity database alias, and not a keystore alias.</p>

<h2>JDK&nbsp;1.1&nbsp;COMPATIBILITY
<a name="JDK&nbsp;1.1&nbsp;COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>keytool</b> and <b>jarsigner</b> tools replace the
<b>javakey</b> tool in JDK 1.1. These new tools provide more
features than <b>javakey</b>, including the ability to
protect the keystore and private keys with passwords, and
the ability to verify signatures in addition to generating
them.</p>

<p style="margin-left:11%; margin-top: 1em">The new
keystore architecture replaces the identity database that
<b>javakey</b> created and managed. There is no backward
compatibility between the keystore format and the database
format used by <b>javakey</b> in JDK 1.1. However, be aware
of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>It is possible to import the information from an
identity database into a keystore through the <b>keytool
-identitydb</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <b>jarsigner</b> command can sign JAR files that
were signed with the <b>javakey</b> command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The <b>jarsigner</b> command can verify JAR files signed
with <b>javakey</b>. The <b>jarsigner</b> command recognizes
and can work with signer aliases that are from a JDK 1.1
identity database rather than a JDK keystore.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>UNSIGNED&nbsp;JARS</b>
<br>
Unsigned JARs have the default privileges that are granted
to all code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SIGNED&nbsp;JARS</b>
<br>
Signed JARs have the privilege configurations based on their
JDK 1.1.<i>n</i> identity and policy file status as
described. Only trusted identities can be imported into the
JDK keystore.</p>

<p style="margin-left:11%; margin-top: 1em">Default
Privileges Granted to All Code</p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>No</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>No</i> <br>
Policy file grants privileges to identity/alias:
<i>No</i></p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>No</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>Yes</i> <br>
Policy file grants privileges to identity/alias:
<i>No</i></p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: Yes/Untrusted <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>No</i> <br>
Policy file grants privileges to identity/alias: <i>No</i>
<br>
See 3 in Notes Regarding Privileges of Signed JARs.</p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: Yes/Untrusted <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>No</i> <br>
Policy file grants privileges to identity/alias: <i>Yes</i>
<br>
See 1 and 3 in Notes Regarding Privileges of Signed
JARs.</p>

<p style="margin-left:11%; margin-top: 1em">Default
Privileges and Policy File Privileges Granted</p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>No</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>Yes</i> <br>
Policy file grants privileges to identity/alias:
<i>Yes</i></p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>Yes/Trusted</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>Yes</i> <br>
Policy file grants privileges to identity/alias: <i>Yes</i>
<br>
See 2 in Notes Regarding Privileges of Signed JARs.</p>

<p style="margin-left:11%; margin-top: 1em">All Privileges
Granted</p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>Yes/Trusted</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>No</i> <br>
Policy file grants privileges to identity/alias:
<i>No</i></p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>Yes/Trusted</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>Yes</i> <br>
Policy file grants privileges to identity/alias: <i>No</i>
<br>
See 1 in Notes Regarding Privileges of Signed JARs.</p>

<p style="margin-left:11%; margin-top: 1em">Identity in 1.1
database: <i>Yes/Trusted</i> <br>
Trusted identity imported into Java keystore from 1.1.
database: <i>No</i> <br>
Policy file grants privileges to identity/alias: <i>Yes</i>
<br>
See 1 in Notes Regarding Privileges of Signed JARs.</p>

<p style="margin-left:11%; margin-top: 1em">Notes Regarding
Privileges of Signed JARs</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If an identity or alias is
mentioned in the policy file, then it must be imported into
the keystore for the policy file to have any effect on
privileges granted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>The policy file/keystore combination has precedence over
a trusted identity in the identity database.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Untrusted identities are ignored in the Java
platform.</p> </td></tr>
</table>

<h2>SEE&nbsp;ALSO
<a name="SEE&nbsp;ALSO"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>jar</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><b>keytool</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Trail: Security Features in Java SE at
http://docs.oracle.com/javase/tutorial/security/index.html</p> </td></tr>
 </table>
<hr>
</body>
</html>
