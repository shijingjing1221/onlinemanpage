<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:04:03 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>User manual for old pbm functions</title>

</head>
<body>

<h1 align="center">User manual for old pbm functions</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libpbm -
libnetpbm functions to read and write PBM image files</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;netpbm/pbm.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>bit
**pbm_allocarray(int</b> <i>cols</i><b>, int</b>
<i>rows</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>bit
*pbm_allocrow(int</b> <i>cols</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_freearray(bit
**</b><i>bits</i><b>, int</b> <i>rows</i><b>);</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_freerow(bit
*</b><i>bitrow</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_readpbminit(FILE *</b> <i>fp</i><b>, int
*</b><i>colsP</i><b>, int *</b><i>rowsP</i><b>, int
*</b><i>formatP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_readpbmrow(FILE *</b> <i>fp</i><b>, bit
*</b><i>bitrow</i><b>, int</b> <i>cols</i><b>, int</b>
<i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_readpbmrow_packed(FILE *</b> <i>fp</i><b>, unsigned char
* const</b> <i>packed_bits</i><b>, const int</b>
<i>cols</i><b>, const int</b> <i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void bit**
pbm_readpbm(FILE *</b> <i>fp</i><b>, int
*</b><i>colsP</i><b>, int *</b><i>rowsP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_writepbminit(FILE *</b> <i>fp</i><b>, int</b>
<i>cols</i><b>, int</b> <i>rows</i><b>, int</b>
<i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_writepbmrow(FILE *</b> <i>fp</i><b>, bit
*</b><i>bitrow</i><b>, int</b> <i>cols</i><b>, int</b>
<i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_writepbmrow_packed(FILE *</b> <i>fp</i><b>, unsigned
char * const</b> <i>packed_bits</i><b>, const int</b>
<i>cols</i><b>, const int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_writepbm(FILE *</b> <i>fp</i><b>, bit
**</b><i>bits</i><b>, int</b> <i>cols</i><b>, int</b>
<i>rows</i><b>, int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
pbm_packed_bytes(</b><i>cols</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_nextimage( FILE *</b><i>file</i><b>, int * const</b>
<i>eofP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
pbm_check( FILE *</b> <i>file</i><b>, const enum
pm_check_type</b> <i>check_type</i><b>, const int</b>
<i>format</i><b>, const int</b> <i>cols</i><b>, const
int</b> <i>rows</i><b>, enum pm_check_code * const</b>
<i>retval</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These library
functions are part of <b>Netpbm</b>(1)</p>

<p style="margin-left:11%; margin-top: 1em"><b>TYPES AND
CONSTANTS <br>
typedef ... bit;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PBM_WHITE ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PBM_BLACK ...</b></p>

<p style="margin-left:11%; margin-top: 1em">Each <b>bit</b>
should contain only the values of <b>PBM_WHITE</b> or
<b>PBM_BLACK</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PBM_FORMAT ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
RPBM_FORMAT ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PBM_TYPE PBM_FORMAT</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PBM_FORMAT_TYPE(</b><i>f</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em">These are for
distinguishing different file formats and types.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INITIALIZATION
<br>
pbm_init()</b> is obsolete (at least since Netpbm 9.25
(March 2002)). Use
<a href="libpm.html#initialization"><b>pm_proginit()</b></a>
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_init()</b>
is identical to <b>pm_proginit</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MEMORY
MANAGEMENT <br>
pbm_allocarray()</b> allocates an array of bits.
<b>pbm_allocrow()</b> allocates a row of the given number of
bits. <b>pbm_freearray()</b> frees the array allocated with
<b>pbm_allocarray()</b> containing the given number of rows.
<b>pbm_freerow()</b> frees a row of bits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>READING PBM
IMAGE FILES <br>
pbm_readpbminit()</b> reads the header from a PBM image in a
PBM file, filling in the rows, cols and format variables.
<b>pbm_readpbmrow()</b> reads a row of bits into the
<i>bitrow</i> array. Format and cols were filled in by
<b>pbm_readpbminit()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_readpbmrow_packed()</b>
is like <b>pbm_readpbmrow()</b> except instead of returning
a <b>bits</b> array, it returns an array <i>packed_bits</i>
of bytes with the pixels of the image row packed into them.
The pixels are in order from left to right across the row
and from the beginning of the array to the end. Within a
byte, the bits are in order from the most significant bit to
the least significant bit. If the number of pixels in the
row is not a multiple of 8, the last byte returned is padded
on the least significant bit side with undefined bits. White
is represented by a <b>PBM_WHITE</b> bit; black by
<b>PBM_BLACK</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_readpbm()</b>
reads an entire bitmap file into memory, returning the
allocated array and filling in the rows and cols variables.
This function combines <b>pbm_readpbminit()</b>,
<b>pbm_allocarray()</b> and <b>pbm_readpbmrow()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_readpbminit()</b>
and <b>pbm_readpbm</b> abort the program with a message to
Standard Error if the PBM image header is not syntactically
valid, including if it contains a number too large to be
processed using the system&rsquo;s normal data structures
(to wit, a number that won&rsquo;t fit in a C
&rsquo;int&rsquo;).</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readppminit()</b>
and <b>ppm_readppm</b> abort the program with a message to
Standard Error if the PPM image header is not syntactically
valid, including if it contains a number too large to be
processed using the system&rsquo;s normal data structures
(to wit, a number that won&rsquo;t fit in a C
&rsquo;int&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em"><b>WRITING PBM
IMAGE FILES <br>
pbm_writepbminit()</b> writes the header for a PBM image in
a PBM file. <i>forceplain</i> is a boolean value specifying
that a plain format (text) file to be written, as opposed to
a raw format (binary) one. <b>pbm_writepbmrow()</b> writes a
row to a PBM file. <b>pbm_writepbmrow_packed()</b> is the
same as <b>pbm_writepbmrow()</b> except that you supply the
row to write as an array of bytes packed with bits instead
of as a <b>bits</b> array. The format of <i>packed_bits</i>
is the same as that returned by <b>pbm_readpbmrow()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_writepbm()</b>
writes the header and all data for a PBM image to a PBM
file. This function combines <b>pbm_writepbminit()</b> and
<b>pbm_writepbmrow()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MISCELLANEOUS
<br>
pbm_nextimage()</b> positions a PBM input file to the next
image in it (so that a subsequent <b>pbm_readpbminit()</b>
reads its header).</p>

<p style="margin-left:11%; margin-top: 1em">Immediately
before a call to <b>pbm_nextimage()</b>, the file must be
positioned either at its beginning (i.e. nothing has been
read from the file yet) or just after an image (i.e. as left
by a <b>pbm_readpbmrow()</b> of the last row in the
image).</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
the raw PNM and PAM format, the next image always starts
immediately after the previous image, so all
<b>pbm_nextimage()</b> really does is test whether there is
a next image or the file is positioned at end-of-file. In
plain PNM, though, there may be white space between
images.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>pbm_nextimage()</b> successfully positions to the next
image, it returns <b>*</b><i>eofP</i> false (0). If there is
no next image in the file, it returns <b>*</b><i>eofP</i>
true . If it can&rsquo;t position or determine the file
status due to a file error, it
<a href="liberror.html#error">throws an error</a> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>pbm_check()</b>
checks for the common file integrity error where the file is
the wrong size to contain all the image data.
<b>pbm_check()</b> assumes the file is positioned after an
image header (as if <b>pbm_readpbminit()</b> was the last
operation on the file). It checks the file size to see if
the number of bytes left in the file are the number required
to contain the image raster. If the file is too short,
<b>pbm_check()</b> causes the program t
<a href="liberror.html#error">throws an error</a> .
Otherwise, it returns one of the following values
(enumerations of the <b>enum pm_check_code</b> type) as
<b>*</b><i>retval</i>: <b><br>
PM_CHECK_OK</b></p>

<p style="margin-left:22%;">The file&rsquo;s size is
exactly what is required to hold the image raster.</p>


<p style="margin-left:11%;"><b>PM_CHECK_UNKNOWN_TYPE</b></p>

<p style="margin-left:22%;"><i>format</i> is not a format
whose size <b>pbm_check()</b> can anticipate. The only
format with which <b>pbm_check()</b> can deal is raw PBM
format.</p>

<p style="margin-left:11%;"><b>PM_CHECK_TOO_LONG</b></p>

<p style="margin-left:22%;">The file is longer than it
needs to be to contain the image raster. The extra data
might be another image.</p>


<p style="margin-left:11%;"><b>PM_CHECK_UNCHECKABLE</b></p>

<p style="margin-left:22%;">The file is not a kind that has
a predictable size, so there is no simple way for
<b>pbm_check()</b> to know if it is the right size. Only a
regular file has predictable size. A pipe is a common
example of a file that does not.</p>


<p style="margin-left:11%; margin-top: 1em"><i>check_type</i>
must have the value <b>PM_CHECK_BASIC</b> (an enumerated
value of the <b>pm_check_type</b> enumerated type).
Otherwise, the effect of <b>pbm_check()</b> is
unpredictable. This argument exists for future backward
compatible expansion of the function of
<b>pbm_check()</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>libpgm</b>(1)
, <b>libppm</b>(1) , <b>libpnm</b>(1) , <b>pbm</b>(1)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
1989, 1991 by Tony Hansen and Jef Poskanzer.</p>
<hr>
</body>
</html>
