<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:32:23 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Bit::Vector::Overload</title>

</head>
<body>

<h1 align="center">Bit::Vector::Overload</h1>

<a href="#NAME">NAME</a><br>
<a href="#USAGE">USAGE</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#IMPORTANT NOTES">IMPORTANT NOTES</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#LICENSE">LICENSE</a><br>
<a href="#DISCLAIMER">DISCLAIMER</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Bit::Vector::Overload
&minus; Overloaded operators add&minus;on for
Bit::Vector</p>

<h2>USAGE
<a name="USAGE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that you
do not need to &quot;<tt>&quot;use
Bit::Vector;&quot;</tt>&quot; in addition to this
module.</p>

<p style="margin-left:11%; margin-top: 1em">Simply
&quot;<tt>&quot;use Bit::Vector::Overload;&quot;</tt>&quot;
<b><small>INSTEAD</small></b> of &quot;<tt>&quot;use
Bit::Vector;&quot;</tt>&quot;. You can still use all the
methods from the &quot;Bit::Vector&quot; module in addition
to the overloaded operators and methods provided here after
that.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Configuration
      $config = Bit::Vector&minus;&gt;Configuration();
      Bit::Vector&minus;&gt;Configuration($config);
      $oldconfig = Bit::Vector&minus;&gt;Configuration($newconfig);
  String Conversion
      $string = &quot;$vector&quot;;             #  depending on configuration
      print &quot;\$vector = '$vector'\n&quot;;
  Emptyness
      if ($vector)  #  if not empty (non&minus;zero)
      if (! $vector)  #  if empty (zero)
      unless ($vector)  #  if empty (zero)
  Complement (one's complement)
      $vector2 = ~$vector1;
      $vector = ~$vector;
  Negation (two's complement)
      $vector2 = &minus;$vector1;
      $vector = &minus;$vector;
  Norm
      $norm = abs($vector);  #  depending on configuration
  Absolute
      $vector2 = abs($vector1);  #  depending on configuration
  Concatenation
      $vector3 = $vector1 . $vector2;
      $vector1 .= $vector2;
      $vector1 = $vector2 . $vector1;
      $vector2 = $vector1 . $scalar;  #  depending on configuration
      $vector2 = $scalar . $vector1;
      $vector .= $scalar;
  Duplication
      $vector2 = $vector1 x $factor;
      $vector x= $factor;
  Shift Left
      $vector2 = $vector1 &lt;&lt; $bits;
      $vector &lt;&lt;= $bits;
  Shift Right
      $vector2 = $vector1 &gt;&gt; $bits;
      $vector &gt;&gt;= $bits;
  Union
      $vector3 = $vector1 | $vector2;
      $vector1 |= $vector2;
      $vector2 = $vector1 | $scalar;
      $vector |= $scalar;
      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;
  Intersection
      $vector3 = $vector1 &amp; $vector2;
      $vector1 &amp;= $vector2;
      $vector2 = $vector1 &amp; $scalar;
      $vector &amp;= $scalar;
      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;
  ExclusiveOr
      $vector3 = $vector1 ^ $vector2;
      $vector1 ^= $vector2;
      $vector2 = $vector1 ^ $scalar;
      $vector ^= $scalar;
  Set Difference
      $vector3 = $vector1 &minus; $vector2;  #  depending on configuration
      $vector1 &minus;= $vector2;
      $vector1 = $vector2 &minus; $vector1;
      $vector2 = $vector1 &minus; $scalar;
      $vector2 = $scalar &minus; $vector1;
      $vector &minus;= $scalar;
  Addition
      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;
  Subtraction
      $vector3 = $vector1 &minus; $vector2;  #  depending on configuration
      $vector1 &minus;= $vector2;
      $vector1 = $vector2 &minus; $vector1;
      $vector2 = $vector1 &minus; $scalar;
      $vector2 = $scalar &minus; $vector1;
      $vector &minus;= $scalar;
  Multiplication
      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;
  Division
      $vector3 = $vector1 / $vector2;
      $vector1 /= $vector2;
      $vector1 = $vector2 / $vector1;
      $vector2 = $vector1 / $scalar;
      $vector2 = $scalar / $vector1;
      $vector /= $scalar;
  Modulo
      $vector3 = $vector1 % $vector2;
      $vector1 %= $vector2;
      $vector1 = $vector2 % $vector1;
      $vector2 = $vector1 % $scalar;
      $vector2 = $scalar % $vector1;
      $vector %= $scalar;
  Exponentiation
      $vector3 = $vector1 ** $vector2;
      $vector1 **= $vector2;
      $vector2 = $vector1 ** $scalar;
      $vector2 = $scalar ** $vector1;
      $vector **= $scalar;
  Increment
      ++$vector;
      $vector++;
  Decrement
      &minus;&minus;$vector;
      $vector&minus;&minus;;
  Lexical Comparison (unsigned)
      $cmp = $vector1 cmp $vector2;
      if ($vector1 lt $vector2)
      if ($vector1 le $vector2)
      if ($vector1 gt $vector2)
      if ($vector1 ge $vector2)
      $cmp = $vector cmp $scalar;
      if ($vector lt $scalar)
      if ($vector le $scalar)
      if ($vector gt $scalar)
      if ($vector ge $scalar)
  Comparison (signed)
      $cmp = $vector1 &lt;=&gt; $vector2;
      if ($vector1 &lt; $vector2)  #  depending on configuration
      if ($vector1 &lt;= $vector2)
      if ($vector1 &gt; $vector2)
      if ($vector1 &gt;= $vector2)
      $cmp = $vector &lt;=&gt; $scalar;
      if ($vector &lt; $scalar)  #  depending on configuration
      if ($vector &lt;= $scalar)
      if ($vector &gt; $scalar)
      if ($vector &gt;= $scalar)
  Equality
      if ($vector1 eq $vector2)
      if ($vector1 ne $vector2)
      if ($vector eq $scalar)
      if ($vector ne $scalar)
      if ($vector1 == $vector2)
      if ($vector1 != $vector2)
      if ($vector == $scalar)
      if ($vector != $scalar)
  Subset Relationship
      if ($vector1 &lt;= $vector2)  #  depending on configuration
  True Subset Relationship
      if ($vector1 &lt; $vector2)  #  depending on configuration
  Superset Relationship
      if ($vector1 &gt;= $vector2)  #  depending on configuration
  True Superset Relationship
      if ($vector1 &gt; $vector2)  #  depending on configuration</pre>


<h2>IMPORTANT NOTES
<a name="IMPORTANT NOTES"></a>
</h2>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Boolean values</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Boolean values
in this module are always a numeric zero
(&quot;<tt>0</tt>&quot;) for &quot;false&quot; and a numeric
one (&quot;<tt>1</tt>&quot;) for &quot;true&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p style="margin-top: 1em">Negative numbers</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Numeric factors
(as needed for the
&quot;<tt>&quot;&lt;&lt;&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&gt;&quot;</tt>&quot; and
&quot;<tt>&quot;x&quot;</tt>&quot; operators) and bit
numbers are always regarded as being
<b><small>UNSIGNED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">As a
consequence, whenever you pass a negative number for such a
factor or bit number, it will be treated as a (usually very
large) positive number due to its internal two&rsquo;s
complement binary representation, usually resulting in
malfunctions or an &quot;index out of range&quot; error
message and program abortion.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
does not apply to &quot;big integer&quot; decimal numbers,
which are (usually) passed as strings, and which may of
course be negative (see also the section &quot;Big
integers&quot; a little further below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em">Overloaded operators
configuration</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that the
behaviour of certain overloaded operators can be changed in
various ways by means of the
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; method (for
more details, see the description of this method further
below).</p>

<p style="margin-left:14%; margin-top: 1em">For instance,
scalars (i.e., numbers and strings) provided as operands to
overloaded operators are automatically converted to bit
vectors, internally.</p>

<p style="margin-left:14%; margin-top: 1em">These scalars
are thereby automatically assumed to be indices or to be in
hexadecimal, binary, decimal or enumeration format,
depending on the configuration.</p>

<p style="margin-left:14%; margin-top: 1em">Similarly, when
converting bit vectors to strings using double quotes
(&quot;&quot;), the output format will also depend on the
previously chosen configuration.</p>

<p style="margin-left:14%; margin-top: 1em">Finally, some
overloaded operators may have different semantics depending
on the proper configuration; for instance, the operator
&quot;+&quot; can be the &quot;union&quot; operator from set
theory or the arithmetic &quot;add&quot; operator.</p>

<p style="margin-left:14%; margin-top: 1em">In all cases
(input, output and operator semantics), the defaults have
been chosen in such a way so that the behaviour of the
module is backward compatible with previous versions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">&quot;Big integers&quot;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">As long as
&quot;big integers&quot; (for &quot;big integer&quot;
arithmetic) are small enough so that Perl doesn&rsquo;t need
scientific notation (exponents) to be able to represent them
internally, you can provide these &quot;big integer&quot;
constants to the overloaded operators of this module (or to
the method &quot;<tt>&quot;from_Dec()&quot;</tt>&quot;) in
numeric form (i.e., either as a numeric constant or
expression or as a Perl variable containing a numeric
value).</p>

<p style="margin-left:14%; margin-top: 1em">Note that you
will get an error message (resulting in program abortion) if
your &quot;big integer&quot; numbers exceed that limit.</p>

<p style="margin-left:14%; margin-top: 1em">Because this
limit is machine-dependent and not obvious to find out, it
is strongly recommended that you enclose
<b><small>ALL</small></b> your &quot;big integer&quot;
constants in your programs in (double or single) quotes.</p>

<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<pre style="margin-left:14%; margin-top: 1em">    $vector /= 10;  #  ok because number is small
    $vector /= &minus;10;  #  ok for same reason
    $vector /= &quot;10&quot;;  #  always correct
    $vector += &quot;1152921504606846976&quot;;  #  quotes probably required here</pre>


<p style="margin-left:14%; margin-top: 1em">All examples
assume</p>

<pre style="margin-left:14%; margin-top: 1em">    Bit::Vector&minus;&gt;Configuration(&quot;input=decimal&quot;);</pre>


<p style="margin-left:14%; margin-top: 1em">having been set
beforehand.</p>

<p style="margin-left:14%; margin-top: 1em">Note also that
this module does not support scientific notation (exponents)
for &quot;big integer&quot; decimal numbers because you can
always make the bit vector large enough for the whole number
to fit without loss of precision (as it would occur if
scientific notation were used).</p>

<p style="margin-left:14%; margin-top: 1em">Finally, note
that the only characters allowed in &quot;big integer&quot;
constant strings are the digits <tt>0..9</tt> and an
optional leading sign (&quot;<tt>&quot;+&quot;</tt>&quot; or
&quot;<tt>&quot;&minus;&quot;</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">All other
characters produce a syntax error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em">Valid operands for overloaded
operators</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">All overloaded
operators expect at least one bit vector operand, in order
for the operator to &quot;know&quot; that not the usual
operation is to be carried out, but rather the overloaded
variant.</p>

<p style="margin-left:14%; margin-top: 1em">This is
especially true for all unary operators:</p>

<pre style="margin-left:14%; margin-top: 1em">                    &quot;$vector&quot;
                    if ($vector)
                    if (!$vector)
                    ~$vector
                    &minus;$vector
                    abs($vector)
                    ++$vector
                    $vector++
                    &minus;&minus;$vector
                    $vector&minus;&minus;</pre>


<p style="margin-left:14%; margin-top: 1em">For obvious
reasons the left operand (the &quot;lvalue&quot;) of all
assignment operators is also required to be a bit
vector:</p>

<pre style="margin-left:14%; margin-top: 1em">                        .=
                        x=
                        &lt;&lt;=
                        &gt;&gt;=
                        |=
                        &amp;=
                        ^=
                        +=
                        &minus;=
                        *=
                        /=
                        %=
                       **=</pre>


<p style="margin-left:14%; margin-top: 1em">In the case of
three special operators, namely
&quot;<tt>&quot;&lt;&lt;&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&gt;&quot;</tt>&quot; and
&quot;<tt>&quot;x&quot;</tt>&quot;, as well as their related
assignment variants,
&quot;<tt>&quot;&lt;&lt;=&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&gt;=&quot;</tt>&quot; and
&quot;<tt>&quot;x=&quot;</tt>&quot;, the left operand is
<b><small>ALWAYS</small></b> a bit vector and the right
operand is <b><small>ALWAYS</small></b> a number (which is
the factor indicating how many times the operator is to be
applied).</p>

<p style="margin-left:14%; margin-top: 1em">In all truly
binary operators, i.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">                        .
                        |
                        &amp;
                        ^
                        +
                        &minus;
                        *
                        /
                        %
                       **
                    &lt;=&gt;   cmp
                     ==    eq
                     !=    ne
                     &lt;     lt
                     &lt;=    le
                     &gt;     gt
                     &gt;=    ge</pre>


<p style="margin-left:14%; margin-top: 1em">one of either
operands may be replaced by a Perl scalar, i.e., a number or
a string, either as a Perl constant, a Perl expression or a
Perl variable yielding a number or a string.</p>

<p style="margin-left:14%; margin-top: 1em">The same
applies to the right side operand (the &quot;rvalue&quot;)
of the remaining assignment operators, i.e.,</p>

<pre style="margin-left:14%; margin-top: 1em">                        .=
                        |=
                        &amp;=
                        ^=
                        +=
                        &minus;=
                        *=
                        /=
                        %=
                       **=</pre>


<p style="margin-left:14%; margin-top: 1em">Note that this
Perl scalar should be of the correct type, i.e., numeric or
string, for the chosen configuration, because otherwise a
warning message will occur if your program runs under the
&quot;<tt>&quot;&minus;w&quot;</tt>&quot; switch of
Perl.</p>

<p style="margin-left:14%; margin-top: 1em">The acceptable
scalar types for each possible configuration are the
following:</p>

<pre style="margin-left:14%; margin-top: 1em">    input = bit indices    (default)  :    numeric
    input = hexadecimal               :    string
    input = binary                    :    string
    input = decimal                   :    string     (in general)
    input = decimal                   :    numeric    (if small enough)
    input = enumeration               :    string</pre>


<p style="margin-left:14%; margin-top: 1em"><small>NOTE
ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT VECTORS
OF THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER
OPERAND.</small></p>

<p style="margin-left:14%; margin-top: 1em">The only
exception from this rule is the concatenation operator
(&quot;<tt>&quot;.&quot;</tt>&quot;) and its assignment
variant (&quot;<tt>&quot;.=&quot;</tt>&quot;):</p>

<p style="margin-left:14%; margin-top: 1em">If one of the
two operands of the concatenation operator
(&quot;<tt>&quot;.&quot;</tt>&quot;) is not a bit vector
object but a Perl scalar, the contents of the remaining bit
vector operand are converted into a string (the format of
which depends on the configuration set with the
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; method),
which is then concatenated in the proper order (i.e., as
indicated by the order of the two operands) with the Perl
scalar (in other words, a string is returned in such a case
instead of a bit vector object!).</p>

<p style="margin-left:14%; margin-top: 1em">If the right
side operand (the &quot;rvalue&quot;) of the assignment
variant (&quot;<tt>&quot;.=&quot;</tt>&quot;) of the
concatenation operator is a Perl scalar, it is converted
internally to a bit vector of the same size as the left side
operand provided that the configuration states that scalars
are to be regarded as indices, decimal strings or
enumerations.</p>

<p style="margin-left:14%; margin-top: 1em">If the
configuration states that scalars are to be regarded as
hexadecimal or boolean strings, however, these strings are
converted to bit vectors of a size matching the length of
the input string, i.e., four times the length for
hexadecimal strings (because each hexadecimal digit is worth
4 bits) and once the length for binary strings.</p>

<p style="margin-left:14%; margin-top: 1em">If a decimal
number (&quot;big integer&quot;) is too large to be stored
in a bit vector of the given size, a &quot;numeric overflow
error&quot; occurs.</p>

<p style="margin-left:14%; margin-top: 1em">If a bit index
is out of range for the given bit vector, an &quot;index out
of range&quot; error occurs.</p>

<p style="margin-left:14%; margin-top: 1em">If a scalar
operand cannot be converted successfully due to invalid
syntax, a fatal &quot;input string syntax error&quot; is
issued.</p>

<p style="margin-left:14%; margin-top: 1em">If the two
operands of the operator
&quot;<tt>&quot;&lt;&lt;&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&gt;&quot;</tt>&quot; or
&quot;<tt>&quot;x&quot;</tt>&quot; are reversed, a fatal
&quot;reversed operands error&quot; occurs.</p>

<p style="margin-left:14%; margin-top: 1em">If an operand
is neither a bit vector nor a scalar, then a fatal
&quot;illegal operand type error&quot; occurs.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p style="margin-top: 1em">Bit order</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Note that bit
vectors are stored least order bit and least order word
first internally.</p>

<p style="margin-left:14%; margin-top: 1em">I.e., bit #0 of
any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">(Where word #0
comes first in memory, i.e., it is stored at the least
memory address in the allocated block of memory holding the
given bit vector.)</p>

<p style="margin-left:14%; margin-top: 1em">Note however
that machine words can be stored least order byte first or
last, depending on your system&rsquo;s implementation.</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that whenever bit vectors are converted to and from (binary
or hexadecimal) strings, the <b><small>RIGHTMOST</small></b>
bit is always the <b><small>LEAST SIGNIFICANT</small></b>
one, and the <b><small>LEFTMOST</small></b> bit is always
the <b><small>MOST SIGNIFICANT</small></b> bit.</p>

<p style="margin-left:14%; margin-top: 1em">This is because
in our western culture, numbers are always represented in
this way (least significant to most significant digits go
from right to left).</p>

<p style="margin-left:14%; margin-top: 1em">Of course this
requires an internal reversion of order, which the
corresponding conversion methods perform automatically
(without any additional overhead, it&rsquo;s just a matter
of starting the internal loop at the bottom or the top
end).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em">Matching sizes</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">In general, for
methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of
bits), or a fatal &quot;size mismatch&quot; error will
occur.</p>

<p style="margin-left:14%; margin-top: 1em">Exceptions from
this rule are the methods
&quot;<tt>&quot;Concat()&quot;</tt>&quot;,
&quot;<tt>&quot;Concat_List()&quot;</tt>&quot;,
&quot;<tt>&quot;Copy()&quot;</tt>&quot;,
&quot;<tt>&quot;Interval_Copy()&quot;</tt>&quot; and
&quot;<tt>&quot;Interval_Substitute()&quot;</tt>&quot;,
where no conditions at all are imposed on the size of their
bit vector arguments.</p>

<p style="margin-left:14%; margin-top: 1em">In method
&quot;<tt>&quot;Multiply()&quot;</tt>&quot;, all three bit
vector arguments must in principle obey the rule of matching
sizes, but the bit vector in which the result of the
multiplication is to be stored may be larger than the two
bit vector arguments containing the factors for the
multiplication.</p>

<p style="margin-left:14%; margin-top: 1em">In method
&quot;<tt>&quot;Power()&quot;</tt>&quot;, the bit vector for
the result must be the same size or greater than the base of
the exponentiation term. The exponent can be any size.</p>

<p style="margin-left:14%; margin-top: 1em">The same
applies to the corresponding overloaded operators.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p style="margin-top: 1em">Index ranges</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">All indices for
any given bits must lie between &quot;<tt>0</tt>&quot; and
&quot;<tt>&quot;$vector&minus;&gt;Size()&minus;1&quot;</tt>&quot;,
or a fatal &quot;index out of range&quot; error will
occur.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;$config =
Bit::Vector&minus;&gt;Configuration();&quot;</tt></p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">



<p><tt>&quot;Bit::Vector&minus;&gt;Configuration($config);&quot;</tt></p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><tt>&quot;$oldconfig =
Bit::Vector&minus;&gt;Configuration($newconfig);&quot;</tt></p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This method
serves to alter the semantics (i.e., behaviour) of certain
overloaded operators (which are all implemented in Perl, by
the way).</p>

<p style="margin-left:14%; margin-top: 1em">It does not
have any effect whatsoever on anything else. In particular,
it does not affect the methods implemented in C.</p>

<p style="margin-left:14%; margin-top: 1em">The method
accepts an (optional) string as input in which certain
keywords are expected, which influence some or almost all of
the overloaded operators in several possible ways.</p>

<p style="margin-left:14%; margin-top: 1em">The method
always returns a string (which you do not need to take care
of, i.e., to store, in case you aren&rsquo;t interested in
keeping it) which is a complete representation of the
current configuration (i.e., <b><small>BEFORE</small></b>
any modifications are applied) and which can be fed back to
this method later in order to restore the previous
configuration.</p>

<p style="margin-left:14%; margin-top: 1em">There are three
aspects of the way certain overloaded operators behave which
can be controlled with this method:</p>

<pre style="margin-left:14%; margin-top: 1em">  +  the way scalar operands (replacing one of the two
     bit vector object operands) are automatically
     converted internally into a bit vector object of
     their own,
  +  the operation certain overloaded operators perform,
     i.e., an operation with sets or an arithmetic
     operation,
  +  the format to which bit vectors are converted
     automatically when they are enclosed in double
     quotes.</pre>


<p style="margin-left:14%; margin-top: 1em">The input
string may contain any number of assignments, each of which
controls one of these three aspects.</p>

<p style="margin-left:14%; margin-top: 1em">Each assignment
has the form
&quot;<tt>&quot;&lt;which&gt;=&lt;value&gt;&quot;</tt>&quot;.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>&quot;&lt;which&gt;&quot;</tt>&quot;
and &quot;<tt>&quot;&lt;value&gt;&quot;</tt>&quot; thereby
consist of letters
(<tt>&quot;[a&minus;zA&minus;Z]&quot;</tt>) and white
space.</p>

<p style="margin-left:14%; margin-top: 1em">Multiple
assignments have to be separated by one or more comma
(&quot;,&quot;), semi-colon (&quot;;&quot;), colon
(&quot;:&quot;), vertical bar (&quot;|&quot;), slash
(&quot;/&quot;), newline (&quot;\n&quot;), ampersand
(&quot;&amp;&quot;), plus (&quot;+&quot;) or dash
(&quot;&minus;&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Empty lines or
statements (only white space) are allowed but will be
ignored.</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>&quot;&lt;which&gt;&quot;</tt>&quot;
has to contain one or more keywords from one of three
groups, each group representing one of the three aspects
that the &quot;<tt>&quot;Configuration()&quot;</tt>&quot;
method controls:</p>

<pre style="margin-left:14%; margin-top: 1em">  +  &quot;^scalar&quot;, &quot;^input&quot;, &quot;^in$&quot;
  +  &quot;^operator&quot;, &quot;^semantic&quot;, &quot;^ops$&quot;
  +  &quot;^string&quot;, &quot;^output&quot;, &quot;^out$&quot;</pre>


<p style="margin-left:14%; margin-top: 1em">The character
&quot;^&quot; thereby denotes the beginning of a word, and
&quot;$&quot; denotes the end. Case is ignored (!).</p>

<p style="margin-left:14%; margin-top: 1em">Using these
keywords, you can build any phrase you like to select one of
the three aspects (see also examples given below).</p>

<p style="margin-left:14%; margin-top: 1em">The only
condition is that no other keyword from any of the other two
groups may match &minus; otherwise a syntax error will occur
(i.e., ambiguities are forbidden). A syntax error also
occurs if none of the keywords matches.</p>

<p style="margin-left:14%; margin-top: 1em">This same
principle applies to
&quot;<tt>&quot;&lt;value&gt;&quot;</tt>&quot;:</p>

<p style="margin-left:14%; margin-top: 1em">Depending on
which aspect you specified for
&quot;<tt>&quot;&lt;which&gt;&quot;</tt>&quot;, there are
different groups of keywords that determine the value the
selected aspect will be set to:</p>

<pre style="margin-left:14%; margin-top: 1em">  +  &quot;&lt;which&gt;&quot; = &quot;^scalar&quot;, &quot;^input&quot;, &quot;^in$&quot;:
       &quot;&lt;value&gt;&quot; =
       *  &quot;^bit$&quot;, &quot;^index&quot;, &quot;^indice&quot;
       *  &quot;^hex&quot;
       *  &quot;^bin&quot;
       *  &quot;^dec&quot;
       *  &quot;^enum&quot;
  +  &quot;&lt;which&gt;&quot; = &quot;^operator&quot;, &quot;^semantic&quot;, &quot;^ops$&quot;:
       &quot;&lt;value&gt;&quot; =
       *  &quot;^set$&quot;
       *  &quot;^arithmetic&quot;
  +  &quot;&lt;which&gt;&quot; = &quot;^string&quot;, &quot;^output&quot;, &quot;^out$&quot;:
       &quot;&lt;value&gt;&quot; =
       *  &quot;^hex&quot;
       *  &quot;^bin&quot;
       *  &quot;^dec&quot;
       *  &quot;^enum&quot;</pre>


<p style="margin-left:14%; margin-top: 1em">Examples:</p>

<pre style="margin-left:14%; margin-top: 1em">  &quot;Any scalar input I provide should be considered to be = a bit index&quot;
  &quot;I want to have operator semantics suitable for = arithmetics&quot;
  &quot;Any bit vector in double quotes is to be output as = an enumeration&quot;</pre>



<p style="margin-left:14%; margin-top: 1em"><b><small>SCALAR
INPUT:</small></b></p>

<p style="margin-left:14%; margin-top: 1em">In the case of
scalar input, &quot;<tt>&quot;^bit$&quot;</tt>&quot;,
&quot;<tt>&quot;^index&quot;</tt>&quot;, or
&quot;<tt>&quot;^indice&quot;</tt>&quot; all cause scalar
input to be considered to represent a bit index, i.e.,
&quot;<tt>&quot;$vector ^= 5;&quot;</tt>&quot; will flip bit
#5 in the given bit vector (this is essentially the same as
&quot;<tt>&quot;$vector&minus;&gt;bit_flip(5);&quot;</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">Note that
&quot;bit indices&quot; is the default setting for
&quot;scalar input&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">The keyword
&quot;<tt>&quot;^hex&quot;</tt>&quot; will cause scalar
input to be considered as being in hexadecimal, i.e.,
&quot;<tt>&quot;$vector ^= 5;&quot;</tt>&quot; will flip bit
#0 and bit #2 (because hexadecimal &quot;<tt>5</tt>&quot; is
binary &quot;<tt>0101</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">(Note though
that hexadecimal input should always be enclosed in quotes,
otherwise it will be interpreted as a decimal number by
Perl! The example relies on the fact that hexadecimal
<tt>&quot;0&minus;9&quot;</tt> and decimal
<tt>&quot;0&minus;9&quot;</tt> are the same.)</p>

<p style="margin-left:14%; margin-top: 1em">The keyword
&quot;<tt>&quot;^bin&quot;</tt>&quot; will cause scalar
input to be considered as being in binary format. All
characters except &quot;<tt>0</tt>&quot; and
&quot;<tt>1</tt>&quot; are forbidden in this case (i.e.,
produce a syntax error).</p>


<p style="margin-left:14%; margin-top: 1em">&quot;<tt>&quot;$vector
^= '0101';&quot;</tt>&quot;, for instance, will flip bit #0
and bit #2.</p>

<p style="margin-left:14%; margin-top: 1em">The keyword
&quot;<tt>&quot;^dec&quot;</tt>&quot; causes scalar input to
be considered as integers in decimal format, i.e.,
&quot;<tt>&quot;$vector ^= 5;&quot;</tt>&quot; will flip bit
#0 and bit #2 (because decimal &quot;<tt>5</tt>&quot; is
binary &quot;<tt>0101</tt>&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">(Note though
that all decimal input should be enclosed in quotes, because
for large numbers, Perl will use scientific notation
internally for representing them, which produces a syntax
error because scientific notation is neither supported by
this module nor needed.)</p>

<p style="margin-left:14%; margin-top: 1em">Finally, the
keyword &quot;<tt>&quot;^enum&quot;</tt>&quot; causes scalar
input to be considered as being a list
(&quot;enumeration&quot;) of indices and ranges of
(contiguous) indices, i.e., &quot;<tt>&quot;$vector |=
'2,3,5,7&minus;13,17&minus;23';&quot;</tt>&quot; will cause
bits #2, #3, #5, #7 through #13 and #17 through #23 to be
set.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>OPERATOR
SEMANTICS:</small></b></p>

<p style="margin-left:14%; margin-top: 1em">Several
overloaded operators can have two distinct functions
depending on this setting.</p>

<p style="margin-left:14%; margin-top: 1em">The affected
operators are: &quot;<tt>&quot;+&quot;</tt>&quot;,
&quot;<tt>&quot;&minus;&quot;</tt>&quot;,
&quot;<tt>&quot;*&quot;</tt>&quot;,
&quot;<tt>&quot;&lt;&quot;</tt>&quot;,
&quot;<tt>&quot;&lt;=&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&quot;</tt>&quot; and
&quot;<tt>&quot;&gt;=&quot;</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">With the
default setting, &quot;set operations&quot;, these operators
perform:</p>

<pre style="margin-left:14%; margin-top: 1em">  +       set union                           ( set1  u   set2 )
  &minus;       set difference                      ( set1  \   set2 )
  *       set intersection                    ( set1  n   set2 )
  &lt;       true subset relationship            ( set1  &lt;   set2 )
  &lt;=      subset relationship                 ( set1  &lt;=  set2 )
  &gt;       true superset relationship          ( set1  &gt;   set2 )
  &gt;=      superset relationship               ( set1  &gt;=  set2 )</pre>


<p style="margin-left:14%; margin-top: 1em">With the
alternative setting, &quot;arithmetic operations&quot;,
these operators perform:</p>

<pre style="margin-left:14%; margin-top: 1em">  +       addition                            ( num1  +   num2 )
  &minus;       subtraction                         ( num1  &minus;   num2 )
  *       multiplication                      ( num1  *   num2 )
  &lt;       &quot;less than&quot; comparison              ( num1  &lt;   num2 )
  &lt;=      &quot;less than or equal&quot; comparison     ( num1  &lt;=  num2 )
  &gt;       &quot;greater than&quot; comparison           ( num1  &gt;   num2 )
  &gt;=      &quot;greater than or equal&quot; comparison  ( num1  &gt;=  num2 )</pre>


<p style="margin-left:14%; margin-top: 1em">Note that these
latter comparison operators
(&quot;<tt>&quot;&lt;&quot;</tt>&quot;,
&quot;<tt>&quot;&lt;=&quot;</tt>&quot;,
&quot;<tt>&quot;&gt;&quot;</tt>&quot; and
&quot;<tt>&quot;&gt;=&quot;</tt>&quot;) regard their
operands as being <b><small>SIGNED</small></b> .</p>

<p style="margin-left:14%; margin-top: 1em">To perform
comparisons with <b><small>UNSIGNED</small></b> operands,
use the operators &quot;<tt>&quot;lt&quot;</tt>&quot;,
&quot;<tt>&quot;le&quot;</tt>&quot;,
&quot;<tt>&quot;gt&quot;</tt>&quot; and
&quot;<tt>&quot;ge&quot;</tt>&quot; instead (in contrast to
the operators above, these operators are
<b><small>NOT</small></b> affected by the &quot;operator
semantics&quot; setting).</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>STRING
OUTPUT:</small></b></p>

<p style="margin-left:14%; margin-top: 1em">There are four
methods which convert the contents of a given bit vector
into a string: &quot;<tt>&quot;to_Hex()&quot;</tt>&quot;,
&quot;<tt>&quot;to_Bin()&quot;</tt>&quot;,
&quot;<tt>&quot;to_Dec()&quot;</tt>&quot; and
&quot;<tt>&quot;to_Enum()&quot;</tt>&quot; (not counting
&quot;<tt>&quot;Block_Read()&quot;</tt>&quot;, since this
method does not return a human-readable string).</p>

<p style="margin-left:14%; margin-top: 1em">(For conversion
to octal, see the description of the method
&quot;<tt>&quot;Chunk_List_Read()&quot;</tt>&quot;.)</p>

<p style="margin-left:14%; margin-top: 1em">Therefore,
there are four possible formats into which a bit vector can
be converted when it is enclosed in double quotes, for
example:</p>

<pre style="margin-left:14%; margin-top: 1em">  print &quot;\$vector = '$vector'\n&quot;;
  $string = &quot;$vector&quot;;</pre>


<p style="margin-left:14%; margin-top: 1em">Hence you can
set &quot;string output&quot; to four different values: To
&quot;hex&quot; for hexadecimal format (which is the
default), to &quot;bin&quot; for binary format, to
&quot;dec&quot; for conversion to decimal numbers and to
&quot;enum&quot; for conversion to enumerations
(&quot;.newsrc&quot; style sets).</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>BEWARE</small></b>
that the conversion to decimal numbers is inherently slow;
it can easily take up several seconds for a single large bit
vector!</p>

<p style="margin-left:14%; margin-top: 1em">Therefore you
should store the decimal strings returned to you rather than
converting a given bit vector again.</p>


<p style="margin-left:14%; margin-top: 1em"><b><small>EXAMPLES:</small></b></p>

<p style="margin-left:14%; margin-top: 1em">The default
setting as returned by the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; is:</p>

<pre style="margin-left:14%; margin-top: 1em">        Scalar Input       = Bit Index
        Operator Semantics = Set Operators
        String Output      = Hexadecimal</pre>


<p style="margin-left:14%; margin-top: 1em">Performing a
statement such as:</p>

<pre style="margin-left:14%; margin-top: 1em">  Bit::Vector&minus;&gt;Configuration(&quot;in=bin,ops=arithmetic,out=bin&quot;);
  print Bit::Vector&minus;&gt;Configuration(), &quot;\n&quot;;</pre>


<p style="margin-left:14%; margin-top: 1em">yields the
following output:</p>

<pre style="margin-left:14%; margin-top: 1em">        Scalar Input       = Binary
        Operator Semantics = Arithmetic Operators
        String Output      = Binary</pre>


<p style="margin-left:14%; margin-top: 1em">Note that you
can always feed this output back into the
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; method to
restore that setting later.</p>

<p style="margin-left:14%; margin-top: 1em">This also means
that you can enter the same given setting with almost any
degree of verbosity you like (as long as the required
keywords appear and no ambiguities arise).</p>

<p style="margin-left:14%; margin-top: 1em">Note further
that any aspect you do not specify is not changed, i.e., the
statement</p>

<pre style="margin-left:14%; margin-top: 1em">  Bit::Vector&minus;&gt;Configuration(&quot;operators = arithmetic&quot;);</pre>


<p style="margin-left:14%; margin-top: 1em">leaves all
other aspects unchanged.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;$vector&quot;</tt></p> </td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Remember that
variables enclosed in double quotes are always interpolated
in Perl.</p>

<p style="margin-left:14%; margin-top: 1em">Whenever a Perl
variable containing the reference of a
&quot;Bit::Vector&quot; object is enclosed in double quotes
(either alone or together with other text and/or variables),
the contents of the corresponding bit vector are converted
into a printable string.</p>

<p style="margin-left:14%; margin-top: 1em">Since there are
several conversion methods available in this module (see the
description of the methods
&quot;<tt>&quot;to_Hex()&quot;</tt>&quot;,
&quot;<tt>&quot;to_Bin()&quot;</tt>&quot;,
&quot;<tt>&quot;to_Dec()&quot;</tt>&quot; and
&quot;<tt>&quot;to_Enum()&quot;</tt>&quot;), it is of course
desirable to be able to choose which of these methods should
be applied in this case.</p>

<p style="margin-left:14%; margin-top: 1em">This can
actually be done by changing the configuration of this
module using the method
&quot;<tt>&quot;Configure()&quot;</tt>&quot; (see the
previous chapter, immediately above).</p>

<p style="margin-left:14%; margin-top: 1em">The default is
conversion to hexadecimal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em"><tt>&quot;if
($vector)&quot;</tt></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">It is possible
to use a Perl variable containing the reference of a
&quot;Bit::Vector&quot; object as a boolean expression.</p>

<p style="margin-left:14%; margin-top: 1em">The condition
above is true if the corresponding bit vector contains at
least one set bit, and it is false if
<b><small>ALL</small></b> bits of the corresponding bit
vector are cleared.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p style="margin-top: 1em"><tt>&quot;if
(!$vector)&quot;</tt></p> </td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Since it is
possible to use a Perl variable containing the reference of
a &quot;Bit::Vector&quot; object as a boolean expression,
you can of course also negate this boolean expression.</p>

<p style="margin-left:14%; margin-top: 1em">The condition
above is true if <b><small>ALL</small></b> bits of the
corresponding bit vector are cleared, and it is false if the
corresponding bit vector contains at least one set bit.</p>

<p style="margin-left:14%; margin-top: 1em">Note that this
is <b><small>NOT</small></b> the same as using the method
&quot;<tt>&quot;is_full()&quot;</tt>&quot;, which returns
true if <b><small>ALL</small></b> bits of the corresponding
bit vector are <b><small>SET</small></b> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;~$vector&quot;</tt></p> </td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the one&rsquo;s
complement of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
equivalent to inverting all bits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">



<p style="margin-top: 1em"><tt>&quot;&minus;$vector&quot;</tt>
(unary minus)</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the two&rsquo;s
complement of the given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">This is
equivalent to inverting all bits and incrementing the result
by one.</p>

<p style="margin-left:14%; margin-top: 1em">(This is the
same as changing the sign of a number in two&rsquo;s
complement binary representation.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="21%">



<p style="margin-top: 1em"><tt>&quot;abs($vector)&quot;</tt></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns the number of set bits in
the given bit vector (this is the same as calculating the
number of elements which are contained in the given set)
&minus; which is the default behaviour, or it returns a new
bit vector object which contains the absolute value of the
number stored in the given bit vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 .
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
usually returns a new bit vector object which is the result
of the concatenation of the two bit vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">The left
operand becomes the most significant, and the right operand
becomes the least significant part of the new bit vector
object.</p>

<p style="margin-left:14%; margin-top: 1em">If one of the
two operands is not a bit vector object but a Perl scalar,
however, the contents of the remaining bit vector operand
are converted into a string (the format of which depends on
the configuration set with the
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; method),
which is then concatenated in the proper order (i.e., as
indicated by the order of the two operands) with the Perl
scalar.</p>

<p style="margin-left:14%; margin-top: 1em">In other words,
a string is returned in such a case instead of a bit vector
object!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p style="margin-top: 1em"><tt>&quot;$vector x
$factor&quot;</tt></p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the concatenation
of as many copies of the given bit vector operand (the left
operand) as the factor (the right operand) specifies.</p>

<p style="margin-left:14%; margin-top: 1em">If the factor
is zero, a bit vector object with a length of zero bits is
returned.</p>

<p style="margin-left:14%; margin-top: 1em">If the factor
is one, just a new copy of the given bit vector is
returned.</p>

<p style="margin-left:14%; margin-top: 1em">Note that a
fatal &quot;reversed operands error&quot; occurs if the two
operands are swapped.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><tt>&quot;$vector &lt;&lt;
$bits&quot;</tt></p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted left
(towards the most significant bit) by as many places as the
right operand, &quot;<tt>$bits</tt>&quot;, specifies.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the &quot;<tt>$bits</tt>&quot; most significant bits are
lost, all other bits move up by &quot;<tt>$bits</tt>&quot;
positions, and the &quot;<tt>$bits</tt>&quot; least
significant bits that have been left unoccupied by this
shift are all set to zero.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$bits</tt>&quot; is greater than the number of
bits of the given bit vector, this term returns an empty bit
vector (i.e., with all bits cleared) of the same size as the
given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that a
fatal &quot;reversed operands error&quot; occurs if the two
operands are swapped.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><tt>&quot;$vector &gt;&gt;
$bits&quot;</tt></p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted right
(towards the least significant bit) by as many places as the
right operand, &quot;<tt>$bits</tt>&quot;, specifies.</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the &quot;<tt>$bits</tt>&quot; least significant bits are
lost, all other bits move down by &quot;<tt>$bits</tt>&quot;
positions, and the &quot;<tt>$bits</tt>&quot; most
significant bits that have been left unoccupied by this
shift are all set to zero.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$bits</tt>&quot; is greater than the number of
bits of the given bit vector, this term returns an empty bit
vector (i.e., with all bits cleared) of the same size as the
given bit vector.</p>

<p style="margin-left:14%; margin-top: 1em">Note that a
fatal &quot;reversed operands error&quot; occurs if the two
operands are swapped.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 |
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the result of a
bitwise <small>OR</small> operation between the two bit
vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the union of two sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 &amp;
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the result of a
bitwise <small>AND</small> operation between the two bit
vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the intersection of two sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 ^
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object which is the result of a
bitwise <small>XOR</small> (exclusive-or) operation between
the two bit vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the symmetric difference of two
sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 +
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns a new bit vector object
which is the result of a bitwise <small>OR</small> operation
between the two bit vector operands (this is the same as
calculating the union of two sets) &minus; which is the
default behaviour, or it returns a new bit vector object
which contains the sum of the two numbers stored in the two
bit vector operands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 &minus;
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns a new bit vector object
which is the set difference of the two sets represented in
the two bit vector operands &minus; which is the default
behaviour, or it returns a new bit vector object which
contains the difference of the two numbers stored in the two
bit vector operands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 *
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns a new bit vector object
which is the result of a bitwise <small>AND</small>
operation between the two bit vector operands (this is the
same as calculating the intersection of two sets) &minus;
which is the default behaviour, or it returns a new bit
vector object which contains the product of the two numbers
stored in the two bit vector operands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 /
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object containing the result of the
division of the two numbers stored in the two bit vector
operands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector1 %
$vector2&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object containing the remainder of
the division of the two numbers stored in the two bit vector
operands.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em"><tt>&quot;$vector1 **
$vector2&quot;</tt></p> </td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns a new bit vector object containing the result of the
exponentiation of the left bit vector elevated to the right
bit vector&rsquo;s power.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 .=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
&quot;appends&quot; the right bit vector operand (the
&quot;rvalue&quot;) to the left one (the
&quot;lvalue&quot;).</p>

<p style="margin-left:14%; margin-top: 1em">The former
contents of the left operand become the most significant
part of the resulting bit vector, and the right operand
becomes the least significant part.</p>

<p style="margin-left:14%; margin-top: 1em">Since bit
vectors are stored in &quot;least order bit first&quot;
order, this actually requires the left operand to be shifted
&quot;up&quot; by the length of the right operand, which is
then copied to the now freed least significant part of the
left operand.</p>

<p style="margin-left:14%; margin-top: 1em">If the right
operand is a Perl scalar, it is first converted to a bit
vector of the same size as the left operand, provided that
the configuration states that scalars are to be regarded as
indices, decimal strings or enumerations.</p>

<p style="margin-left:14%; margin-top: 1em">If the
configuration states that scalars are to be regarded as
hexadecimal or boolean strings, however, these strings are
converted to bit vectors of a size matching the length of
the input string, i.e., four times the length for
hexadecimal strings (because each hexadecimal digit is worth
4 bits) and once the length for binary strings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><tt>&quot;$vector x=
$factor;&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
replaces the given bit vector by a concatenation of as many
copies of the original contents of the given bit vector as
the factor (the right operand) specifies.</p>

<p style="margin-left:14%; margin-top: 1em">If the factor
is zero, the given bit vector is resized to a length of zero
bits.</p>

<p style="margin-left:14%; margin-top: 1em">If the factor
is one, the given bit vector is not changed at all.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">


<p style="margin-top: 1em"><tt>&quot;$vector &lt;&lt;=
$bits;&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
moves the contents of the given bit vector left by
&quot;<tt>$bits</tt>&quot; positions (towards the most
significant bit).</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the &quot;<tt>$bits</tt>&quot; most significant bits are
lost, all other bits move up by &quot;<tt>$bits</tt>&quot;
positions, and the &quot;<tt>$bits</tt>&quot; least
significant bits that have been left unoccupied by this
shift are all set to zero.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$bits</tt>&quot; is greater than the number of
bits of the given bit vector, the given bit vector is erased
completely (i.e., all bits are cleared).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="31%">


<p style="margin-top: 1em"><tt>&quot;$vector &gt;&gt;=
$bits;&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
moves the contents of the given bit vector right by
&quot;<tt>$bits</tt>&quot; positions (towards the least
significant bit).</p>

<p style="margin-left:14%; margin-top: 1em">This means that
the &quot;<tt>$bits</tt>&quot; least significant bits are
lost, all other bits move down by &quot;<tt>$bits</tt>&quot;
positions, and the &quot;<tt>$bits</tt>&quot; most
significant bits that have been left unoccupied by this
shift are all set to zero.</p>

<p style="margin-left:14%; margin-top: 1em">If
&quot;<tt>$bits</tt>&quot; is greater than the number of
bits of the given bit vector, the given bit vector is erased
completely (i.e., all bits are cleared).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 |=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
performs a bitwise <small>OR</small> operation between the
two bit vector operands and stores the result in the left
operand.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the union of two sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 &amp;=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
performs a bitwise <small>AND</small> operation between the
two bit vector operands and stores the result in the left
operand.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the intersection of two sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 ^=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
performs a bitwise <small>XOR</small> (exclusive-or)
operation between the two bit vector operands and stores the
result in the left operand.</p>

<p style="margin-left:14%; margin-top: 1em">This is the
same as calculating the symmetric difference of two
sets.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 +=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this statement either performs a bitwise
<small>OR</small> operation between the two bit vector
operands (this is the same as calculating the union of two
sets) &minus; which is the default behaviour, or it
calculates the sum of the two numbers stored in the two bit
vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">The result of
this operation is stored in the left operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 &minus;=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this statement either calculates the set
difference of the two sets represented in the two bit vector
operands &minus; which is the default behaviour, or it
calculates the difference of the two numbers stored in the
two bit vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">The result of
this operation is stored in the left operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 *=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this statement either performs a bitwise
<small>AND</small> operation between the two bit vector
operands (this is the same as calculating the intersection
of two sets) &minus; which is the default behaviour, or it
calculates the product of the two numbers stored in the two
bit vector operands.</p>

<p style="margin-left:14%; margin-top: 1em">The result of
this operation is stored in the left operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 /=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
puts the result of the division of the two numbers stored in
the two bit vector operands into the left operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;$vector1 %=
$vector2;&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
puts the remainder of the division of the two numbers stored
in the two bit vector operands into the left operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;$vector1 **=
$vector2;&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This statement
puts the result of the exponentiation of the left operand
elevated to the right operand&rsquo;s power into the left
operand.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;++$vector&quot;</tt>,
<tt>&quot;$vector++&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This operator
performs pre&minus; and post-incrementation of the given bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">The value
returned by this term is a reference of the given bit vector
object (after or before the incrementation,
respectively).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">



<p style="margin-top: 1em"><tt>&quot;&minus;&minus;$vector&quot;</tt>,
<tt>&quot;$vector&minus;&minus;&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This operator
performs pre&minus; and post-decrementation of the given bit
vector.</p>

<p style="margin-left:14%; margin-top: 1em">The value
returned by this term is a reference of the given bit vector
object (after or before the decrementation,
respectively).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em"><tt>&quot;($vector1 cmp
$vector2)&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns &quot;<tt>&quot;&minus;1&quot;</tt>&quot; if
&quot;<tt>$vector1</tt>&quot; is less than
&quot;<tt>$vector2</tt>&quot;, &quot;<tt>0</tt>&quot; if
&quot;<tt>$vector1</tt>&quot; and
&quot;<tt>$vector2</tt>&quot; are the same, and
&quot;<tt>1</tt>&quot; if &quot;<tt>$vector1</tt>&quot; is
greater than &quot;<tt>$vector2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>UNSIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 eq
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if the contents of the
two bit vector operands are the same and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 ne
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if the two bit vector
operands differ and false (&quot;<tt>0</tt>&quot;)
otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 lt
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if
&quot;<tt>$vector1</tt>&quot; is less than
&quot;<tt>$vector2</tt>&quot;, and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>UNSIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 le
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if
&quot;<tt>$vector1</tt>&quot; is less than or equal to
&quot;<tt>$vector2</tt>&quot;, and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>UNSIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 gt
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if
&quot;<tt>$vector1</tt>&quot; is greater than
&quot;<tt>$vector2</tt>&quot;, and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>UNSIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 ge
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if
&quot;<tt>$vector1</tt>&quot; is greater than or equal to
&quot;<tt>$vector2</tt>&quot;, and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>UNSIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="38%">


<p style="margin-top: 1em"><tt>&quot;($vector1 &lt;=&gt;
$vector2)&quot;</tt></p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns &quot;<tt>&quot;&minus;1&quot;</tt>&quot; if
&quot;<tt>$vector1</tt>&quot; is less than
&quot;<tt>$vector2</tt>&quot;, &quot;<tt>0</tt>&quot; if
&quot;<tt>$vector1</tt>&quot; and
&quot;<tt>$vector2</tt>&quot; are the same, and
&quot;<tt>1</tt>&quot; if &quot;<tt>$vector1</tt>&quot; is
greater than &quot;<tt>$vector2</tt>&quot;.</p>

<p style="margin-left:14%; margin-top: 1em">This comparison
assumes <b><small>SIGNED</small></b> bit vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 ==
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if the contents of the
two bit vector operands are the same and false
(&quot;<tt>0</tt>&quot;) otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 !=
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">This term
returns true (&quot;<tt>1</tt>&quot;) if the two bit vector
operands differ and false (&quot;<tt>0</tt>&quot;)
otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;($vector1 &lt;
$vector2)&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
a true subset of &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise) &minus; which is the
default behaviour, or it returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
less than &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise).</p>

<p style="margin-left:14%; margin-top: 1em">The latter
comparison assumes <b><small>SIGNED</small></b> bit
vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 &lt;=
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
a subset of &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise) &minus; which is the
default behaviour, or it returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
less than or equal to &quot;<tt>$vector2</tt>&quot; (and
false (&quot;<tt>0</tt>&quot;) otherwise).</p>

<p style="margin-left:14%; margin-top: 1em">The latter
comparison assumes <b><small>SIGNED</small></b> bit
vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><tt>&quot;($vector1 &gt;
$vector2)&quot;</tt></p> </td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
a true superset of &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise) &minus; which is the
default behaviour, or it returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
greater than &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise).</p>

<p style="margin-left:14%; margin-top: 1em">The latter
comparison assumes <b><small>SIGNED</small></b> bit
vectors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><tt>&quot;($vector1 &gt;=
$vector2)&quot;</tt></p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Depending on
the configuration (see the description of the method
&quot;<tt>&quot;Configuration()&quot;</tt>&quot; for more
details), this term either returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
a superset of &quot;<tt>$vector2</tt>&quot; (and false
(&quot;<tt>0</tt>&quot;) otherwise) &minus; which is the
default behaviour, or it returns true
(&quot;<tt>1</tt>&quot;) if &quot;<tt>$vector1</tt>&quot; is
greater than or equal to &quot;<tt>$vector2</tt>&quot; (and
false (&quot;<tt>0</tt>&quot;) otherwise).</p>

<p style="margin-left:14%; margin-top: 1em">The latter
comparison assumes <b><small>SIGNED</small></b> bit
vectors.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>Bit::Vector</i>(3),
<i>Bit::Vector::String</i>(3).</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This man page
documents &quot;Bit::Vector::Overload&quot; version 7.3.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>


<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
2000 &minus; 2013 by Steffen Beyer. All rights reserved.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e., under the terms
of the &quot;Artistic License&quot; or the &quot;
<small>GNU</small> General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The C library
at the core of this Perl module can additionally be
redistributed and/or modified under the terms of the &quot;
<small>GNU</small> Library General Public License&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Please refer to
the files &quot;Artistic.txt&quot;, &quot;
<small>GNU_GPL</small> .txt&quot; and &quot;
<small>GNU_LGPL</small> .txt&quot; in this distribution for
details!</p>

<h2>DISCLAIMER
<a name="DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">See the &quot;
<small>GNU</small> General Public License&quot; for more
details.</p>
<hr>
</body>
</html>
