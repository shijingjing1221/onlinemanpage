<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:01:14 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>jarsigner</title>

</head>
<body>

<h1 align="center">jarsigner</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jarsigner
&minus; JAR Signing and Verification Tool</p>

<p style="margin-left:15%; margin-top: 1em">Generates
signatures for Java ARchive (JAR) files, and verifies the
signatures of signed JAR files.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>jarsigner</b>
[ options ] jar&minus;file alias <b><br>
jarsigner</b> &minus;verify [ options ] jar&minus;file</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>jarsigner</b> tool is used for two purposes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>1.</p></td>
<td width="2%"></td>
<td width="80%">


<p>to sign Java ARchive (JAR) files, and</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="80%">


<p>to verify the signatures and integrity of signed JAR
files.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The JAR feature
enables the packaging of class files, images, sounds, and
other digital data in a single file for faster and easier
distribution. A tool named <b>jar</b> enables developers to
produce JAR files. (Technically, any zip file can also be
considered a JAR file, although when created by <b>jar</b>
or processed by <b>jarsigner</b>, JAR files also contain a
META&minus;INF/MANIFEST.MF file.)</p>

<p style="margin-left:11%; margin-top: 1em">A <i>digital
signature</i> is a string of bits that is computed from some
data (the data being &quot;signed&quot;) and the private key
of an entity (a person, company, etc.). Like a handwritten
signature, a digital signature has many useful
characteristics:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">Its authenticity can be
verified, via a computation that uses the public key
corresponding to the private key used to generate the
signature.</p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>It cannot be forged, assuming the private key is kept
secret.</p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>It is a function of the data signed and thus can&rsquo;t
be claimed to be the signature for other data as well.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>The signed data cannot be changed; if it is, the
signature will no longer verify as being authentic.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In order for an
entity&rsquo;s signature to be generated for a file, the
entity must first have a public/private key pair associated
with it, and also one or more certificates authenticating
its public key. A <i>certificate</i> is a digitally signed
statement from one entity, saying that the public key of
some other entity has a particular value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>jarsigner</b>
uses key and certificate information from a <i>keystore</i>
to generate digital signatures for JAR files. A keystore is
a database of private keys and their associated X.509
certificate chains authenticating the corresponding public
keys. The <b>keytool</b> utility is used to create and
administer keystores.</p>


<p style="margin-left:11%; margin-top: 1em"><b>jarsigner</b>
uses an entity&rsquo;s private key to generate a signature.
The signed JAR file contains, among other things, a copy of
the certificate from the keystore for the public key
corresponding to the private key used to sign the file.
<b>jarsigner</b> can verify the digital signature of the
signed JAR file using the certificate inside it (in its
signature block file).</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
J2SE 5.0, <b>jarsigner</b> can generate signatures that
include a timestamp, thus enabling systems/deployer
(including Java Plug&minus;in) to check whether the JAR file
was signed while the signing certificate was still valid. In
addition, APIs were added in J2SE 5.0 to allow applications
to obtain the timestamp information.</p>

<p style="margin-left:11%; margin-top: 1em">At this time,
<b>jarsigner</b> can only sign JAR files created by the SDK
<b>jar</b> tool or zip files. (JAR files are the same as zip
files, except they also have a META&minus;INF/MANIFEST.MF
file. Such a file will automatically be created when
<b>jarsigner</b> signs a zip file.)</p>

<p style="margin-left:11%; margin-top: 1em">The default
<b>jarsigner</b> behavior is to <i>sign</i> a JAR (or zip)
file. Use the <i>&minus;verify</i> option to instead have it
<i>verify</i> a signed JAR file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Compatibility
with JDK 1.1</b></p>

<p style="margin-left:15%;">The <b>keytool</b> and
<b>jarsigner</b> tools completely replace the <b>javakey</b>
tool provided in JDK 1.1. These new tools provide more
features than <b>javakey</b>, including the ability to
protect the keystore and private keys with passwords, and
the ability to verify signatures in addition to generating
them.</p>

<p style="margin-left:15%; margin-top: 1em">The new
keystore architecture replaces the identity database that
<b>javakey</b> created and managed. There is no backwards
compatibility between the keystore format and the database
format used by <b>javakey</b> in 1.1. However,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">It is possible to import the
information from an identity database into a keystore, via
the <b>keytool</b> <i>&minus;identitydb</i> command.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p><b>jarsigner</b> can sign JAR files also previously
signed using <b>javakey</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p><b>jarsigner</b> can verify JAR files signed using
<b>javakey</b>. Thus, it recognizes and can work with signer
aliases that are from a JDK 1.1 identity database rather
than a Java 2 SDK keystore.</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">The following
table explains how JAR files that were signed in JDK 1.1.x
are treated in the Java 2 platform.</p>

<p style="margin-left:15%; margin-top: 1em">Notes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">If an identity/alias is
mentioned in the policy file, it must be imported into the
keystore for the policy file to have any effect on
privileges granted.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p>2.</p></td>
<td width="2%"></td>
<td width="75%">


<p>The policy file/keystore combination has precedence over
a trusted identity in the identity database.</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p>3.</p></td>
<td width="2%"></td>
<td width="75%">


<p>Untrusted identities are ignored in the Java 2
platform.</p> </td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p>4.</p></td>
<td width="2%"></td>
<td width="75%">


<p>Only trusted identities can be imported into Java 2 SDK
keystores.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Keystore
Aliases</b></p>

<p style="margin-left:15%;">All keystore entities are
accessed via unique <i>aliases</i>.</p>

<p style="margin-left:15%; margin-top: 1em">When using
<b>jarsigner</b> to sign a JAR file, you must specify the
alias for the keystore entry containing the private key
needed to generate the signature. For example, the following
will sign the JAR file named &quot;MyJARFile.jar&quot;,
using the private key associated with the alias
&quot;duke&quot; in the keystore named &quot;mystore&quot;
in the &quot;working&quot; directory. Since no output file
is specified, it overwrites MyJARFile.jar with the signed
JAR file.</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;storepass myspass
<br>
&minus;keypass dukekeypasswd MyJARFile.jar duke</b></p>

<p style="margin-left:15%; margin-top: 1em">Keystores are
protected with a password, so the store password (in this
case &quot;myspass&quot;) must be specified. You will be
prompted for it if you don&rsquo;t specify it on the command
line. Similarly, private keys are protected in a keystore
with a password, so the private key&rsquo;s password (in
this case &quot;dukekeypasswd&quot;) must be specified, and
you will be prompted for it if you don&rsquo;t specify it on
the command line and it isn&rsquo;t the same as the store
password.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Keystore
Location</b></p>

<p style="margin-left:15%;"><b>jarsigner</b> has a
<i>&minus;keystore</i> option for specifying the URL of the
keystore to be used. The keystore is by default stored in a
file named <i>.keystore</i> in the user&rsquo;s home
directory, as determined by the <i>user.home</i> system
property. On Solaris systems <i>user.home</i> defaults to
the user&rsquo;s home directory.</p>

<p style="margin-left:15%; margin-top: 1em">Note that the
input stream from the <i>&minus;keystore</i> option is
passed to the <i>KeyStore.load</i> method. If <i>NONE</i> is
specified as the URL, then a null stream is passed to the
<i>KeyStore.load</i> method. <i>NONE</i> should be specified
if the <i>KeyStore</i> is not file&minus;based, for example,
if it resides on a hardware token device.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Keystore
Implementation</b></p>

<p style="margin-left:15%;">The <i>KeyStore</i> class
provided in the <i>java.security</i> package supplies
well&minus;defined interfaces to access and modify the
information in a keystore. It is possible for there to be
multiple different concrete implementations, where each
implementation is that for a particular <i>type</i> of
keystore.</p>

<p style="margin-left:15%; margin-top: 1em">Currently,
there are two command&minus;line tools that make use of
keystore implementations (<b>keytool</b> and
<b>jarsigner</b>), and also a GUI&minus;based tool named
<b>Policy Tool</b>. Since <i>KeyStore</i> is publicly
available, Java 2 SDK users can write additional security
applications that use it.</p>

<p style="margin-left:15%; margin-top: 1em">There is a
built&minus;in default implementation, provided by Sun
Microsystems. It implements the keystore as a file,
utilizing a proprietary keystore type (format) named
&quot;JKS&quot;. It protects each private key with its
individual password, and also protects the integrity of the
entire keystore with a (possibly different) password.</p>

<p style="margin-left:15%; margin-top: 1em">Keystore
implementations are provider&minus;based. More specifically,
the application interfaces supplied by <i>KeyStore</i> are
implemented in terms of a &quot;Service Provider
Interface&quot; (SPI). That is, there is a corresponding
abstract <i>KeystoreSpi</i> class, also in the
<i>java.security</i> package, which defines the Service
Provider Interface methods that &quot;providers&quot; must
implement. (The term &quot;provider&quot; refers to a
package or a set of packages that supply a concrete
implementation of a subset of services that can be accessed
by the Java Security API.) Thus, to provide a keystore
implementation, clients must implement a provider and supply
a KeystoreSpi subclass implementation, as described in
<i>How to Implement a Provider for the Java Cryptography
Architecture</i> @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/HowToImplAProvider.html.</p>

<p style="margin-left:15%; margin-top: 1em">Applications
can choose different <i>types</i> of keystore
implementations from different providers, using the
&quot;getInstance&quot; factory method supplied in the
<i>KeyStore</i> class. A keystore type defines the storage
and data format of the keystore information, and the
algorithms used to protect private keys in the keystore and
the integrity of the keystore itself. Keystore
implementations of different types are not compatible.</p>

<p style="margin-left:15%; margin-top: 1em"><b>keytool</b>
works on any file&minus;based keystore implementation. (It
treats the keytore location that is passed to it at the
command line as a filename and converts it to a
FileInputStream, from which it loads the keystore
information.) The <b>jarsigner</b> and <b>policytool</b>
tools, on the other hand, can read a keystore from any
location that can be specified using a URL.</p>

<p style="margin-left:15%; margin-top: 1em">For
<b>jarsigner</b> and <b>keytool</b>, you can specify a
keystore type at the command line, via the
<i>&minus;storetype</i> option. For <b>Policy Tool</b>, you
can specify a keystore type via the &quot;Change
Keystore&quot; command in the Edit menu.</p>

<p style="margin-left:15%; margin-top: 1em">If you
don&rsquo;t explicitly specify a keystore type, the tools
choose a keystore implementation based simply on the value
of the <i>keystore.type</i> property specified in the
security properties file. The security properties file is
called <i>java.security</i>, and it resides in the SDK
security properties directory,
<i>java.home</i>/lib/security, where <i>java.home</i> is the
runtime environment&rsquo;s directory (the <i>jre</i>
directory in the SDK or the top&minus;level directory of the
Java 2 Runtime Environment).</p>

<p style="margin-left:15%; margin-top: 1em">Each tool gets
the <i>keystore.type</i> value and then examines all the
currently&minus;installed providers until it finds one that
implements keystores of that type. It then uses the keystore
implementation from that provider.</p>

<p style="margin-left:15%; margin-top: 1em">The
<i>KeyStore</i> class defines a static method named
<i>getDefaultType</i> that lets applications and applets
retrieve the value of the <i>keystore.type</i> property. The
following line of code creates an instance of the default
keystore type (as specified in the <i>keystore.type</i>
property):</p>

<p style="margin-left:15%; margin-top: 1em"><b>KeyStore
keyStore =
KeyStore.getInstance(KeyStore.getDefaultType());</b></p>

<p style="margin-left:15%; margin-top: 1em">The default
keystore type is &quot;jks&quot; (the proprietary type of
the keystore implementation provided by Sun). This is
specified by the following line in the security properties
file:</p>


<p style="margin-left:15%; margin-top: 1em"><b>keystore.type=jks</b></p>

<p style="margin-left:15%; margin-top: 1em">Note: Case
doesn&rsquo;t matter in keystore type designations. For
example, &quot;JKS&quot; would be considered the same as
&quot;jks&quot;.</p>

<p style="margin-left:15%; margin-top: 1em">To have the
tools utilize a keystore implementation other than the
default, change that line to specify a different keystore
type. For example, if you have a provider package that
supplies a keystore implementation for a keystore type
called &quot;pkcs12&quot;, change the line to</p>


<p style="margin-left:15%; margin-top: 1em"><b>keystore.type=pkcs12</b></p>

<p style="margin-left:15%; margin-top: 1em">Note that if
you us the PKCS#11 provider package, you should refer to the
<i>KeyTool and JarSigner</i> @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html#keytooljarsigner
section of the Java PKCS#11 Reference Guide for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Supported
Algorithms</b></p>

<p style="margin-left:15%;">By default, <b>jarsigner</b>
signs a JAR file using either</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">DSA (Digital Signature
Algorithm) with the SHA&minus;1 digest algorithm, or</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>the RSA algorithm with the MD5 digest algorithm.</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">That is, if the
signer&rsquo;s public and private keys are DSA keys,
<b>jarsigner</b> will sign the JAR file using the
&quot;SHA1withDSA&quot; algorithm. If the signer&rsquo;s
keys are RSA keys, <b>jarsigner</b> will attempt to sign the
JAR file using the &quot;MD5withRSA&quot; algorithm.</p>

<p style="margin-left:15%; margin-top: 1em">These default
signature algorithms can be overridden using the
<i>&minus;sigalg</i> option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Signed
JAR File</b></p>

<p style="margin-left:15%;">When <b>jarsigner</b> is used
to sign a JAR file, the output signed JAR file is exactly
the same as the input JAR file, except that it has two
additional files placed in the META&minus;INF directory:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="71%">


<p style="margin-top: 1em">a signature file, with a .SF
extension, and</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="71%">


<p>a signature block file, with a .DSA extension.</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">The base file
names for these two files come from the value of the
<i>&minus;sigFile</i> option. For example, if the option
appears as</p>


<p style="margin-left:15%; margin-top: 1em"><b>&minus;sigFile
MKSIGN</b></p>

<p style="margin-left:15%; margin-top: 1em">the files are
named &quot;MKSIGN.SF&quot; and &quot;MKSIGN.DSA&quot;.</p>

<p style="margin-left:15%; margin-top: 1em">If no
<i>&minus;sigfile</i> option appears on the command line,
the base file name for the .SF and .DSA files will be the
first 8 characters of the alias name specified on the
command line, all converted to upper case. If the alias name
has fewer than 8 characters, the full alias name is used. If
the alias name contains any characters that are not allowed
in a signature file name, each such character is converted
to an underscore (&quot;_&quot;) character in forming the
file name. Legal characters include letters, digits,
underscores, and hyphens.</p>

<p style="margin-left:15%; margin-top: 1em"><b>The
Signature (.SF) File</b></p>

<p style="margin-left:20%; margin-top: 1em">A signature
file (the .SF file) looks similar to the manifest file that
is always included in a JAR file when <b>jarsigner</b> is
used to sign the file. That is, for each source file
included in the JAR file, the .SF file has three lines, just
as in the manifest file, listing the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="1%">


<p style="margin-top: 1em">o</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">the file name,</p></td></tr>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="1%">


<p>o</p></td>
<td width="2%"></td>
<td width="72%">


<p>the name of the digest algorithm used (SHA), and</p></td></tr>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="1%">


<p>o</p></td>
<td width="2%"></td>
<td width="72%">


<p>a SHA digest value.</p></td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">In the manifest
file, the SHA digest value for each source file is the
digest (hash) of the binary data in the source file. In the
.SF file, on the other hand, the digest value for a given
source file is the hash of the three lines in the manifest
file for the source file.</p>

<p style="margin-left:20%; margin-top: 1em">The signature
file also, by default, includes a header containing a hash
of the whole manifest file. The presence of the header
enables verification optimization, as described in JAR File
Verification.</p>

<p style="margin-left:15%; margin-top: 1em"><b>The
Signature Block (.DSA) File</b></p>

<p style="margin-left:20%; margin-top: 1em">The .SF file is
signed and the signature is placed in the .DSA file. The
.DSA file also contains, encoded inside it, the certificate
or certificate chain from the keystore which authenticates
the public key corresponding to the private key used for
signing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signature
Timestamp</b></p>

<p style="margin-left:15%;">As of the J2SE 5.0 release, the
<i>jarsigner</i> tool can now generate and store a signature
timestamp when signing a JAR file. In addition,
<i>jarsigner</i> supports alternative signing mechanisms.
This behavior is optional and is controlled by the user at
the time of signing through these options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="43%">


<p style="margin-top: 1em"><i>&minus;tsa url</i></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="43%">


<p><i>&minus;tsacert alias</i></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="43%">


<p><i>&minus;altsigner class</i></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="43%">


<p><i>&minus;altsignerpath classpathlist</i></p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">Each of these
options is detailed in the Options section below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JAR File
Verification</b></p>

<p style="margin-left:15%;">A successful JAR file
verification occurs if the signature(s) are valid, and none
of the files that were in the JAR file when the signatures
were generated have been changed since then. JAR file
verification involves the following steps:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="67%">


<p style="margin-top: 1em">Verify the signature of the .SF
file itself.</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">That is, the
verification ensures that the signature stored in each
signature block (.DSA) file was in fact generated using the
private key corresponding to the public key whose
certificate (or certificate chain) also appears in the .DSA
file. It also ensures that the signature is a valid
signature of the corresponding signature (.SF) file, and
thus the .SF file has not been tampered with.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">Verify the digest listed in each
entry in the .SF file with each corresponding section in the
manifest.</p> </td></tr>
</table>

<p style="margin-left:20%; margin-top: 1em">The .SF file by
default includes a header containing a hash of the entire
manifest file. When the header is present, then the
verification can check to see whether or not the hash in the
header indeed matches the hash of the manifest file. If that
is the case, verification proceeds to the next step.</p>

<p style="margin-left:20%; margin-top: 1em">If that is not
the case, a less optimized verification is required to
ensure that the hash in each source file information section
in the .SF file equals the hash of its corresponding section
in the manifest file (see The Signature (.SF) File).</p>

<p style="margin-left:20%; margin-top: 1em">One reason the
hash of the manifest file that is stored in the .SF file
header may not equal the hash of the current manifest file
would be because one or more files were added to the JAR
file (using the <i>jar</i> tool) after the signature (and
thus the .SF file) was generated. When the <i>jar</i> tool
is used to add files, the manifest file is changed (sections
are added to it for the new files), but the .SF file is not.
A verification is still considered successful if none of the
files that were in the JAR file when the signature was
generated have been changed since then, which is the case if
the hashes in the non&minus;header sections of the .SF file
equal the hashes of the corresponding sections in the
manifest file.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">Read each file in the JAR file
that has an entry in the .SF file. While reading, compute
the file&rsquo;s digest, and then compare the result with
the digest for this file in the manifest section. The
digests should be the same, or verification fails.</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">If any serious
verification failures occur during the verification process,
the process is stopped and a security exception is thrown.
It is caught and displayed by <b>jarsigner</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Multiple
Signatures for a JAR File</b></p>

<p style="margin-left:15%;">A JAR file can be signed by
multiple people simply by running the <b>jarsigner</b> tool
on the file multiple times, specifying the alias for a
different person each time, as in:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
myBundle.jar susan <br>
jarsigner myBundle.jar kevin</b></p>

<p style="margin-left:15%; margin-top: 1em">When a JAR file
is signed multiple times, there are multiple .SF and .DSA
files in the resulting JAR file, one pair for each
signature. Thus, in the example above, the output JAR file
includes files with the following names:</p>

<p style="margin-left:15%; margin-top: 1em"><b>SUSAN.SF
<br>
SUSAN.DSA <br>
KEVIN.SF <br>
KEVIN.DSA</b></p>

<p style="margin-left:15%; margin-top: 1em">Note: It is
also possible for a JAR file to have mixed signatures, some
generated by the JDK 1.1 <b>javakey</b> tool and others by
<b>jarsigner</b>. That is, <b>jarsigner</b> can be used to
sign JAR files already previously signed using
<b>javakey</b>.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The various
<b>jarsigner</b> options are listed and described below.
Note:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">All option names are preceded by
a minus sign (&minus;).</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>The options may be provided in any order.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>Items in italics (option values) represent the actual
values that must be supplied.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>The <i>&minus;keystore</i>, <i>&minus;storepass</i>,
<i>&minus;keypass</i>, <i>&minus;sigfile</i>,
<i>&minus;sigalg</i>, <i>&minus;digestalg</i>, and
<i>&minus;signedjar</i> options are only relevant when
signing a JAR file, not when verifying a signed JAR file.
Similarly, an alias is only specified on the command line
when signing a JAR file.</p></td></tr>
</table>

<p style="margin-left:15%;">&minus;keystore url</p>

<p style="margin-left:20%;">Specifies the URL that tells
the keystore location. This defaults to the file
<i>.keystore</i> in the user&rsquo;s home directory, as
determined by the &quot;user.home&quot; system property.</p>

<p style="margin-left:15%; margin-top: 1em">A keystore is
required when signing, so you must explicitly specify one if
the default keystore does not exist (or you want to use one
other than the default).</p>

<p style="margin-left:15%; margin-top: 1em">A keystore is
<i>not</i> required when verifying, but if one is specified,
or the default exists, and the <i>&minus;verbose</i> option
was also specified, additional information is output
regarding whether or not any of the certificates used to
verify the JAR file are contained in that keystore.</p>

<p style="margin-left:15%; margin-top: 1em">Note: the
<i>&minus;keystore</i> argument can actually be a file name
(and path) specification rather than a URL, in which case it
will be treated the same as a &quot;file:&quot; URL. That
is, <b><br>
&minus;keystore</b> <b><i>filePathAndName</i></b> <br>
is treated as equivalent to <b><br>
&minus;keystore file:</b><b><i>filePathAndName</i></b> <br>
If the Sun PKCS#11 provider has been configured in the
<i>java.security</i> security properties file (located in
the JRE&rsquo;s <i>$JAVA_HOME/lib/security</i> directory),
then keytool and jarsigner can operate on the PKCS#11 token
by specifying these options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="26%">


<p><i>&minus;keystore NONE</i></p></td>
<td width="51%">
</td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="26%">


<p><i>&minus;storetype PKCS11</i></p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:15%;">For example, this command lists
the contents of the configured PKCS#11 token:</p>

<p style="margin-left:20%; margin-top: 1em"><b>jarsigner
&minus;keystore NONE &minus;storetype PKCS11
&minus;list</b></p>

<p style="margin-left:15%;">&minus;storetype storetype</p>

<p style="margin-left:20%;">Specifies the type of keystore
to be instantiated. The default keystore type is the one
that is specified as the value of the
&quot;keystore.type&quot; property in the security
properties file, which is returned by the static
<i>getDefaultType</i> method in
<i>java.security.KeyStore</i>.</p>

<p style="margin-left:15%; margin-top: 1em">The PIN for a
PCKS#11 token can also be specified using the
<i>&minus;storepass</i> option. If none has been specified,
keytool and jarsigner will prompt for the token PIN. If the
token has a protected authentication path (such as a
dedicated PIN&minus;pad or a biometric reader), then the
<i>&minus;protected</i> option must be specified and no
password options can be specified. <br>
&minus;storepass password</p>

<p style="margin-left:20%;">Specifies the password which is
required to access the keystore. This is only needed when
signing (not verifying) a JAR file. In that case, if a
<i>&minus;storepass</i> option is not provided at the
command line, the user is prompted for the password.</p>

<p style="margin-left:15%; margin-top: 1em">Note: The
password shouldn&rsquo;t be specified on the command line or
in a script unless it is for testing purposes, or you are on
a secure system. Also, when typing in a password at the
password prompt, the password is echoed (displayed exactly
as typed), so be careful not to type it in front of anyone.
<br>
&minus;keypass password</p>

<p style="margin-left:20%;">Specifies the password used to
protect the private key of the keystore entry addressed by
the alias specified on the command line. The password is
required when using <b>jarsigner</b> to sign a JAR file. If
no password is provided on the command line, and the
required password is different from the store password, the
user is prompted for it.</p>

<p style="margin-left:15%; margin-top: 1em">Note: The
password shouldn&rsquo;t be specified on the command line or
in a script unless it is for testing purposes, or you are on
a secure system. Also, when typing in a password at the
password prompt, the password is echoed (displayed exactly
as typed), so be careful not to type it in front of anyone.
<br>
&minus;sigfile file</p>

<p style="margin-left:20%;">Specifies the base file name to
be used for the generated .SF and .DSA files. For example,
if <i>file</i> is &quot;DUKESIGN&quot;, the generated .SF
and .DSA files will be named &quot;DUKESIGN.SF&quot; and
&quot;DUKESIGN.DSA&quot;, and will be placed in the
&quot;META&minus;INF&quot; directory of the signed JAR
file.</p>

<p style="margin-left:15%; margin-top: 1em">The characters
in <i>file</i> must come from the set
&quot;a&minus;zA&minus;Z0&minus;9_&minus;&quot;. That is,
only letters, numbers, underscore, and hyphen characters are
allowed. Note: All lowercase characters will be converted to
uppercase for the .SF and .DSA file names.</p>

<p style="margin-left:15%; margin-top: 1em">If no
<i>&minus;sigfile</i> option appears on the command line,
the base file name for the .SF and .DSA files will be the
first 8 characters of the alias name specified on the
command line, all converted to upper case. If the alias name
has fewer than 8 characters, the full alias name is used. If
the alias name contains any characters that are not legal in
a signature file name, each such character is converted to
an underscore (&quot;_&quot;) character in forming the file
name. <br>
&minus;sigalg algorithm</p>

<p style="margin-left:20%; margin-top: 1em">Specifies the
name of the signature algorithm to use to sign the JAR
file.</p>

<p style="margin-left:20%; margin-top: 1em">See <i>Appendix
A</i> @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#appa
of the Java Cryptography Architecture for a list of standard
signature algorithm names. This algorithm must be compatible
with the private key used to sign the JAR file. If this
option is not specified, SHA1withDSA or MD5withRSA will be
used depending on the type of private key. There must either
be a statically installed provider supplying an
implementation of the specified algorithm or the user must
specify one with the <i>&minus;providerClass</i> option,
otherwise the command will not succeed.</p>

<p style="margin-left:15%;">&minus;digestalg algorithm</p>

<p style="margin-left:20%;">Specifies the name of the
message digest algorithm to use when digesting the entries
of a jar file.</p>

<p style="margin-left:20%; margin-top: 1em">See <i>Appendix
A</i> @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#appa
of the Java Cryptography Architecture for a list of standard
message digest algorithm names. If this option is not
specified, SHA&minus;1 will be used. There must either be a
statically installed provider supplying an implementation of
the specified algorithm or the user must specify one with
the <i>&minus;providerClass</i> option, otherwise the
command will not succeed.</p>

<p style="margin-left:15%;">&minus;signedjar file</p>

<p style="margin-left:20%;">Specifies the name to be used
for the signed JAR file.</p>

<p style="margin-left:15%; margin-top: 1em">If no name is
specified on the command line, the name used is the same as
the input JAR file name (the name of the JAR file to be
signed); in other words, that file is overwritten with the
signed JAR file. <br>
&minus;verify</p>

<p style="margin-left:20%;">If this appears on the command
line, the specified JAR file will be verified, not signed.
If the verification is successful, &quot;jar verified&quot;
will be displayed. If you try to verify an unsigned JAR
file, or a JAR file signed with an unsupported algorithm
(e.g., RSA when you don&rsquo;t have an RSA provider
installed), the following is displayed: &quot;jar is
unsigned. (signatures missing or not parsable)&quot;</p>

<p style="margin-left:15%; margin-top: 1em">It is possible
to verify JAR files signed using either <b>jarsigner</b> or
the JDK 1.1 <b>javakey</b> tool, or both.</p>

<p style="margin-left:15%; margin-top: 1em">For further
information on verification, see JAR File Verification. <br>
&minus;certs</p>

<p style="margin-left:20%;">If this appears on the command
line, along with the <i>&minus;verify</i> and
<i>&minus;verbose</i> options, the output includes
certificate information for each signer of the JAR file.
This information includes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>the name of the type of certificate (stored in the .DSA
file) that certifies the signer&rsquo;s public key</p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>if the certificate is an X.509 certificate (more
specifically, an instance of
<i>java.security.cert.X509Certificate</i>): the
distinguished name of the signer</p></td></tr>
</table>

<p style="margin-left:15%; margin-top: 1em">The keystore is
also examined. If no keystore value is specified on the
command line, the default keystore file (if any) will be
checked. If the public key certificate for a signer matches
an entry in the keystore, then the following information
will also be displayed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">in parentheses, the alias name
for the keystore entry for that signer. If the signer
actually comes from a JDK 1.1 identity database instead of
from a keystore, the alias name will appear in brackets
instead of parentheses.</p></td></tr>
</table>

<p style="margin-left:15%;">&minus;verbose</p>

<p style="margin-left:20%;">If this appears on the command
line, it indicates &quot;verbose&quot; mode, which causes
<b>jarsigner</b> to output extra information as to the
progress of the JAR signing or verification.</p>

<p style="margin-left:15%;">&minus;internalsf</p>

<p style="margin-left:20%;">In the past, the .DSA
(signature block) file generated when a JAR file was signed
used to include a complete encoded copy of the .SF file
(signature file) also generated. This behavior has been
changed. To reduce the overall size of the output JAR file,
the .DSA file by default doesn&rsquo;t contain a copy of the
.SF file anymore. But if <i>&minus;internalsf</i> appears on
the command line, the old behavior is utilized. <b>This
option is mainly useful for testing; in practice, it should
not be used, since doing so eliminates a useful
optimization.</b></p>

<p style="margin-left:15%;">&minus;sectionsonly</p>

<p style="margin-left:20%;">If this appears on the command
line, the .SF file (signature file) generated when a JAR
file is signed does <i>not</i> include a header containing a
hash of the whole manifest file. It just contains
information and hashes related to each individual source
file included in the JAR file, as described in The Signature
(.SF) File .</p>

<p style="margin-left:15%; margin-top: 1em">By default,
this header is added, as an optimization. When the header is
present, then whenever the JAR file is verified, the
verification can first check to see whether or not the hash
in the header indeed matches the hash of the whole manifest
file. If so, verification proceeds to the next step. If not,
it is necessary to do a less optimized verification that the
hash in each source file information section in the .SF file
equals the hash of its corresponding section in the manifest
file.</p>

<p style="margin-left:15%; margin-top: 1em">For further
information, see JAR File Verification.</p>

<p style="margin-left:15%; margin-top: 1em"><b>This option
is mainly useful for testing; in practice, it should not be
used, since doing so eliminates a useful optimization.</b>
<br>
&minus;protected</p>

<p style="margin-left:20%;">Either <i>true</i> or
<i>false</i>. This value should be specified as <i>true</i>
if a password must be given via a protected authentication
path such as a dedicated PIN reader.</p>

<p style="margin-left:15%;">&minus;provider
provider&minus;class&minus;name</p>

<p style="margin-left:20%;">Used to specify the name of
cryptographic service provider&rsquo;s master class file
when the service provider is not listed in the security
properties file, <i>java.security</i>.</p>

<p style="margin-left:15%; margin-top: 1em">Used in
conjunction with the <i>&minus;providerArg
ConfigFilePath</i> option, keytool and jarsigner will
install the provider dynamically (where
<i>ConfigFilePath</i> is the path to the token configuration
file). Here&rsquo;s an example of a command to list a
PKCS#11 keystore when the Sun PKCS#11 provider has not been
configured in the security properties file.</p>

<p style="margin-left:20%; margin-top: 1em"><b>jarsigner
&minus;keystore NONE &minus;storetype PKCS11 \ <br>
&minus;providerClass sun.security.pkcs11.SunPKCS11 \ <br>
&minus;providerArg /foo/bar/token.config \ <br>
&minus;list</b></p>

<p style="margin-left:15%;">&minus;providerName
providerName</p>

<p style="margin-left:20%;">If more than one provider has
been configured in the <i>java.security</i> security
properties file, you can use the <i>&minus;providerName</i>
option to target a specific provider instance. The argument
to this option is the name of the provider.</p>

<p style="margin-left:15%; margin-top: 1em">For the Sun
PKCS#11 provider, <i>providerName</i> is of the form
<i>SunPKCS11&minus;TokenName</i>, where <i>TokenName</i> is
the name suffix that the provider instance has been
configured with, as detailed in the <i>configuration
attributes table</i> @ <br>

http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html#KeyToolJarSigner#ATTRS.
For example, the following command lists the contents of the
PKCS#11 keystore provider instance with name suffix
<i>SmartCard</i>:</p>

<p style="margin-left:20%; margin-top: 1em"><b>jarsigner
&minus;keystore NONE &minus;storetype PKCS11 \ <br>
&minus;providerName SunPKCS11&minus;SmartCard \ <br>
&minus;list</b></p>

<p style="margin-left:15%;">&minus;Jjavaoption</p>

<p style="margin-left:20%;">Passes through the specified
<i>javaoption</i> string directly to the Java interpreter.
(<b>jarsigner</b> is actually a &quot;wrapper&quot; around
the interpreter.) This option should not contain any spaces.
It is useful for adjusting the execution environment or
memory usage. For a list of possible interpreter options,
type <i>java &minus;h</i> or <i>java &minus;X</i> at the
command line.</p>

<p style="margin-left:15%;">&minus;tsa url</p>

<p style="margin-left:20%;">If <i>&quot;&minus;tsa
http://example.tsa.url&quot;</i> appears on the command line
when signing a JAR file then a timestamp is generated for
the signature. The URL, <i>http://example.tsa.url</i>,
identifies the location of the Time Stamping Authority
(TSA). It overrides any URL found via the
<i>&minus;tsacert</i> option. The <i>&minus;tsa</i> option
does not require the TSA&rsquo;s public key certificate to
be present in the keystore.</p>

<p style="margin-left:15%; margin-top: 1em">To generate the
timestamp, <i>jarsigner</i> communicates with the TSA using
the Time&minus;Stamp Protocol (TSP) defined in <i>RFC
3161</i> @ <br>
http://www.ietf.org/rfc/rfc3161.txt. If successful, the
timestamp token returned by the TSA is stored along with the
signature in the signature block file. <br>
&minus;tsacert alias</p>

<p style="margin-left:20%;">If <i>&quot;&minus;tsacert
alias&quot;</i> appears on the command line when signing a
JAR file then a timestamp is generated for the signature.
The <i>alias</i> identifies the TSA&rsquo;s public key
certificate in the keystore that is currently in effect. The
entry&rsquo;s certificate is examined for a Subject
Information Access extension that contains a URL identifying
the location of the TSA.</p>

<p style="margin-left:15%; margin-top: 1em">The TSA&rsquo;s
public key certificate must be present in the keystore when
using <i>&minus;tsacert</i>. <br>
&minus;altsigner class</p>

<p style="margin-left:20%;">Specifies that an alternative
signing mechanism be used. The fully&minus;qualified class
name identifies a class file that extends the
<i>com.sun.jarsigner.ContentSigner abstract class</i>. The
path to this class file is defined by the
<i>&minus;altsignerpath</i> option. If the
<i>&minus;altsigner</i> option is used, <i>jarsigner</i>
uses the signing mechanism provided by the specified class.
Otherwise, <i>jarsigner</i> uses its default signing
mechanism.</p>

<p style="margin-left:15%; margin-top: 1em">For example, to
use the signing mechanism provided by a class named
<i>com.sun.sun.jarsigner.AuthSigner</i>, use the
<i>jarsigner</i> option <i>&quot;&minus;altsigner
com.sun.jarsigner.AuthSigner&quot;</i> <br>
&minus;altsignerpath classpathlist</p>

<p style="margin-left:20%;">Specifies the path to the class
file (the class file name is specified with the
<i>&minus;altsigner</i> option described above) and any JAR
files it depends on. If the class file is in a JAR file,
then this specifies the path to that JAR file, as shown in
the example below.</p>

<p style="margin-left:15%; margin-top: 1em">An absolute
path or a path relative to the current directory may be
specified. If <i>classpathlist</i> contains multiple paths
or JAR files, they should be separated with a colon
(<i>:</i>) on Solaris and a semi&minus;colon (<i>;</i>) on
Windows. This option is not necessary if the class is
already in the search path.</p>

<p style="margin-left:15%; margin-top: 1em">Example of
specifying the path to a jar file that contains the class
file:</p>


<p style="margin-left:20%; margin-top: 1em"><i>&minus;altsignerpath
/home/user/lib/authsigner.jar</i></p>

<p style="margin-left:15%; margin-top: 1em">Note that the
JAR file name is included.</p>

<p style="margin-left:15%; margin-top: 1em">Example of
specifying the path to the jar file that contains the class
file:</p>


<p style="margin-left:20%; margin-top: 1em"><i>&minus;altsignerpath
/home/user/classes/com/sun/tools/jarsigner/</i></p>

<p style="margin-left:15%; margin-top: 1em">Note that the
JAR file name is omitted.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Signing a
JAR File</b></p>

<p style="margin-left:15%;">Suppose you have a JAR file
named &quot;bundle.jar&quot; and you&rsquo;d like to sign it
using the private key of the user whose keystore alias is
&quot;jane&quot; in the keystore named &quot;mystore&quot;
in the &quot;working&quot; directory. Suppose the keystore
password is &quot;myspass&quot; and the password for
<i>jane</i>&rsquo;s private key is &quot;j638klm&quot;. You
can use the following to sign the JAR file and name the
signed JAR file &quot;sbundle.jar&quot;:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;storepass myspass
<br>
&minus;keypass j638klm &minus;signedjar sbundle.jar
bundle.jar jane</b></p>

<p style="margin-left:15%; margin-top: 1em">Note that there
is no <i>&minus;sigfile</i> specified in the command above,
so the generated .SF and .DSA files to be placed in the
signed JAR file will have default names based on the alias
name. That is, they will be named <i>JANE.SF</i> and
<i>JANE.DSA</i>.</p>

<p style="margin-left:15%; margin-top: 1em">If you want to
be prompted for the store password and the private key
password, you could shorten the above command to</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore <br>
&minus;signedjar sbundle.jar bundle.jar jane</b></p>

<p style="margin-left:15%; margin-top: 1em">If the keystore
to be used is the default keystore (the one named
&quot;.keystore&quot; in your home directory), you
don&rsquo;t need to specify a keystore, as in:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;signedjar sbundle.jar bundle.jar jane</b></p>

<p style="margin-left:15%; margin-top: 1em">Finally, if you
want the signed JAR file to simply overwrite the input JAR
file (<i>bundle.jar</i>), you don&rsquo;t need to specify a
<i>&minus;signedjar</i> option:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
bundle.jar jane</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Verifying a
Signed JAR File</b></p>

<p style="margin-left:15%;">To verify a signed JAR file,
that is, to verify that the signature is valid and the JAR
file has not been tampered with, use a command such as the
following:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;verify sbundle.jar</b></p>

<p style="margin-left:15%; margin-top: 1em">If the
verification is successful,</p>

<p style="margin-left:15%; margin-top: 1em"><b>jar
verified.</b></p>

<p style="margin-left:15%; margin-top: 1em">is displayed.
Otherwise, an error message appears.</p>

<p style="margin-left:15%; margin-top: 1em">You can get
more information if you use the <i>&minus;verbose</i>
option. A sample use of <b>jarsigner</b> with the
<i>&minus;verbose</i> option is shown below, along with
sample output:</p>

<p style="margin-left:15%; margin-top: 1em"><b>jarsigner
&minus;verify &minus;verbose sbundle.jar</b></p>

<p style="margin-left:15%; margin-top: 1em"><b>198 Fri Sep
26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 AclEx.class <br>
smk 849 Fri Sep 26 16:12:46 PDT 1997 test.class</b></p>

<p style="margin-left:15%; margin-top: 1em"><b>s =
signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore</b></p>

<p style="margin-left:15%; margin-top: 1em"><b>jar
verified.</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Verification
with Certificate Information</b> <br>
If you specify the <i>&minus;certs</i> option when
verifying, along with the <i>&minus;verify</i> and
<i>&minus;verbose</i> options, the output includes
certificate information for each signer of the JAR file,
including the certificate type, the signer distinguished
name information (iff it&rsquo;s an X.509 certificate), and,
in parentheses, the keystore alias for the signer if the
public key certificate in the JAR file matches that in a
keystore entry. For example,</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;verify
&minus;verbose &minus;certs myTest.jar</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>198 Fri Sep
26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
208 Fri Sep 26 16:23:30 PDT 1997 META&minus;INF/JAVATEST.SF
<br>
1087 Fri Sep 26 16:23:30 PDT 1997
META&minus;INF/JAVATEST.DSA <br>
smk 2752 Fri Sep 26 16:12:30 PDT 1997 Tst.class</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>X.509,
CN=Test Group, OU=Java Software, O=Sun Microsystems, L=CUP,
S=CA, C=US (javatest) <br>
X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup, S=ca,
C=us (jane)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>s =
signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>jar
verified.</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
certificate for a signer is not an X.509 certificate, there
is no distinguished name information. In that case, just the
certificate type and the alias are shown. For example, if
the certificate is a PGP certificate, and the alias is
&quot;bob&quot;, you&rsquo;d get</p>

<p style="margin-left:11%; margin-top: 1em"><b>PGP,
(bob)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Verification
of a JAR File that Includes Identity Database Signers</b>
<br>
If a JAR file has been signed using the JDK 1.1
<b>javakey</b> tool, and thus the signer is an alias in an
identity database, the verification output includes an
&quot;i&quot; symbol. If the JAR file has been signed by
both an alias in an identity database and an alias in a
keystore, both &quot;k&quot; and &quot;i&quot; appear.</p>

<p style="margin-left:11%; margin-top: 1em">When the
<i>&minus;certs</i> option is used, any identity database
aliases are shown in square brackets rather than the
parentheses used for keystore aliases. For example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>jarsigner
&minus;keystore /working/mystore &minus;verify
&minus;verbose &minus;certs writeFile.jar</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>198 Fri Sep
26 16:14:06 PDT 1997 META&minus;INF/MANIFEST.MF <br>
199 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.SF <br>
1013 Fri Sep 26 16:22:10 PDT 1997 META&minus;INF/JANE.DSA
<br>
199 Fri Sep 27 12:22:30 PDT 1997 META&minus;INF/DUKE.SF <br>
1013 Fri Sep 27 12:22:30 PDT 1997 META&minus;INF/DUKE.DSA
<br>
smki 2752 Fri Sep 26 16:12:30 PDT 1997
writeFile.html</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>X.509,
CN=Jane Smith, OU=Java Software, O=Sun, L=cup, S=ca, C=us
(jane) <br>
X.509, CN=Duke, OU=Java Software, O=Sun, L=cup, S=ca, C=us
[duke]</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>s =
signature was verified <br>
m = entry is listed in manifest <br>
k = at least one certificate was found in keystore <br>
i = at least one certificate was found in identity
scope</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>jar
verified.</b></p>

<p style="margin-left:11%; margin-top: 1em">Note that the
alias &quot;duke&quot; is in brackets to denote that it is
an identity database alias, not a keystore alias.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="40%">


<p style="margin-top: 1em">jar tool documentation</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="40%">


<p>keytool tool documentation</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="40%">


<p>the <b><i>Security</i></b> @</p></td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:18%;">http://java.sun.com/docs/books/tutorial/security1.2/index.html
trail of the <b><i>Java Tutorial</i></b> @ <br>
http://java.sun.com/docs/books/tutorial/trailmap.html for
examples of the use of the <b>jarsigner</b> tool</p>
<hr>
</body>
</html>
