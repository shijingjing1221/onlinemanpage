<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:27:20 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</title>

</head>
<body>

<h1 align="center">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Member Typedef Documentation">Member Typedef Documentation</a><br>
<a href="#Constructor &amp; Destructor Documentation">Constructor &amp; Destructor Documentation</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
std::__allow_copy_cons&lt; bool &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:23%; margin-top: 1em">typedef
_Hashtable::key_type <b>key_type</b> <br>
typedef _Hashtable::value_type <b>value_type</b> <br>
typedef _Hashtable::mapped_type <b>mapped_type</b> <br>
typedef _Hashtable::hasher <b>hasher</b> <br>
typedef _Hashtable::key_equal <b>key_equal</b> <br>
typedef _Hashtable::allocator_type <b>allocator_type</b></p>

<p style="margin-left:23%; margin-top: 1em">typedef
allocator_type::pointer <b>pointer</b> <br>
typedef <br>
allocator_type::const_pointer <b>const_pointer</b>&quot;
<br>
typedef allocator_type::reference <b>reference</b> <br>
typedef <br>
allocator_type::const_reference <b>const_reference</b>&quot;
<br>
typedef _Hashtable::iterator <b>iterator</b> <br>
typedef _Hashtable::const_iterator <b>const_iterator</b>
<br>
typedef _Hashtable::local_iterator <b>local_iterator</b>
<br>
typedef <br>
_Hashtable::const_local_iterator
<b>const_local_iterator</b>&quot; <br>
typedef _Hashtable::size_type <b>size_type</b> <br>
typedef _Hashtable::difference_type
<b>difference_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>unordered_map</b>
(<b>size_type</b> __n=10, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <br>
template&lt;typename _InputIterator &gt;
<b>unordered_map</b> (_InputIterator __f, _InputIterator
__l, <b>size_type</b> __n=0, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <b><br>
unordered_map</b> (const <b>unordered_map</b> &amp;)=default
<b><br>
unordered_map</b> (<b>unordered_map</b> &amp;&amp;)=default
<b><br>
unordered_map</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n=0, const
<b>hasher</b> &amp;__hf=<b>hasher</b>(), const
<b>key_equal</b> &amp;__eql=<b>key_equal</b>(), const
<b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
<b><br>
iterator begin</b> () noexcept <b><br>
local_iterator begin</b> (<b>size_type</b> __n) <b><br>
size_type bucket</b> (const <b>key_type</b> &amp;__key)
const <b><br>
size_type bucket_count</b> () const noexcept <b><br>
size_type bucket_size</b> (<b>size_type</b> __n) const <br>
void <b>clear</b> () noexcept <b><br>
size_type count</b> (const <b>key_type</b> &amp;__x) const
<br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>emplace</b> (_Args
&amp;&amp;...__args) <br>
template&lt;typename... _Args&gt; <b>iterator
emplace_hint</b> (<b>const_iterator</b> __pos, _Args
&amp;&amp;...__args) <br>
bool <b>empty</b> () const noexcept <b><br>
iterator end</b> () noexcept <b><br>
local_iterator end</b> (<b>size_type</b> __n) <b><br>
size_type erase</b> (const <b>key_type</b> &amp;__x) <b><br>
iterator erase</b> (<b>const_iterator</b> __first,
<b>const_iterator</b> __last) <b><br>
allocator_type get_allocator</b> () const noexcept <b><br>
hasher hash_function</b> () const <br>
template&lt;typename _InputIterator &gt; void <b>insert</b>
(_InputIterator __first, _InputIterator __last) <br>
void <b>insert</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l) <b><br>
key_equal key_eq</b> () const <br>
float <b>load_factor</b> () const noexcept <b><br>
size_type max_bucket_count</b> () const noexcept <br>
float <b>max_load_factor</b> () const noexcept <br>
void <b>max_load_factor</b> (float __z) <b><br>
size_type max_size</b> () const noexcept <b><br>
unordered_map</b> &amp; <b>operator=</b> (const
<b>unordered_map</b> &amp;)=default <b><br>
unordered_map</b> &amp; <b>operator=</b>
(<b>unordered_map</b> &amp;&amp;)=default <b><br>
unordered_map</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; <b>value_type</b> &gt; __l)
<br>
void <b>rehash</b> (<b>size_type</b> __n) <br>
void <b>reserve</b> (<b>size_type</b> __n) <b><br>
size_type size</b> () const noexcept <br>
void <b>swap</b> (<b>unordered_map</b> &amp;__x)</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_iterator
begin</b> () const noexcept <b><br>
const_iterator cbegin</b> () const noexcept</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_iterator
end</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>insert</b> (const
<b>value_type</b> &amp;__x)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">


<p>template&lt;typename _Pair , typename = typename
std::enable_if&lt;std::is_constructible&lt;value_type,</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">


<p>_Pair&amp;&amp;&gt;::value&gt;::type&gt;
<b>std::pair</b>&lt; <b>iterator</b>, bool &gt;
<b>insert</b> (_Pair &amp;&amp;__x)</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
insert</b> (<b>const_iterator</b> __hint, const
<b>value_type</b> &amp;__x)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">


<p>template&lt;typename _Pair , typename = typename
std::enable_if&lt;std::is_constructible&lt;value_type,</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="92%">


<p>_Pair&amp;&amp;&gt;::value&gt;::type&gt; <b>iterator
insert</b> (<b>const_iterator</b> __hint, _Pair
&amp;&amp;__x)</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
erase</b> (<b>const_iterator</b> __position) <b><br>
iterator erase</b> (<b>iterator</b> __it)</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
find</b> (const <b>key_type</b> &amp;__x) <b><br>
const_iterator find</b> (const <b>key_type</b> &amp;__x)
const</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b>
(const <b>key_type</b> &amp;__x) <b><br>
std::pair</b>&lt; <b>const_iterator</b>, <b><br>
const_iterator</b> &gt; <b>equal_range</b> (const
<b>key_type</b> &amp;__x) const &quot;</p>


<p style="margin-left:23%; margin-top: 1em"><b>mapped_type</b>
&amp; <b>operator[]</b> (const <b>key_type</b> &amp;__k)
<b><br>
mapped_type</b> &amp; <b>operator[]</b> (<b>key_type</b>
&amp;&amp;__k)</p>


<p style="margin-left:23%; margin-top: 1em"><b>mapped_type</b>
&amp; <b>at</b> (const <b>key_type</b> &amp;__k) <br>
const <b>mapped_type</b> &amp; <b>at</b> (const
<b>key_type</b> &amp;__k) const</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_local_iterator
begin</b> (<b>size_type</b> __n) const <b><br>
const_local_iterator cbegin</b> (<b>size_type</b> __n)
const</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_local_iterator
end</b> (<b>size_type</b> __n) const <b><br>
const_local_iterator cend</b> (<b>size_type</b> __n)
const</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Key1 ,
typename _Tp1 , typename _Hash1 , typename _Pred1 , typename
_Alloc1 &gt; bool <b>operator==</b> (const
<b>unordered_map</b>&lt; _Key1, _Tp1, _Hash1, _Pred1,
_Alloc1 &gt; &amp;, const <b>unordered_map</b>&lt; _Key1,
_Tp1, _Hash1, _Pred1, _Alloc1 &gt; &amp;)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;
&gt;&gt;class std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;</b> <br>
A standard container composed of unique keys (containing at
most one of each key value) that associates values of
another type with the keys.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters:</b></p>

<p style="margin-left:17%;"><i>_Key</i> Type of key
objects. <i><br>
_Tp</i> Type of mapped objects. <i><br>
_Hash</i> Hashing function object type, defaults to
hash&lt;_Value&gt;. <i><br>
_Pred</i> Predicate function object type, defaults to
equal_to&lt;_Value&gt;. <i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Key&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, and <tt>unordered
associative container</tt></p>

<p style="margin-left:11%; margin-top: 1em">The resulting
value type of the container is std::pair&lt;const _Key,
_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Base is
_Hashtable, dispatched at compile time via template alias
__umap_hashtable.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 97 of file unordered_map.h.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::allocator_type std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::allocator_type</b>
<br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 111 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::const_iterator std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::const_iterator</b>
<br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 121 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::const_local_iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::const_local_iterator</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 123 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef allocator_type::const_pointer std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::const_pointer</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 117 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef allocator_type::const_reference
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::const_reference</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 119 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::difference_type std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::difference_type</b>
<br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 125 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::hasher std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::hasher</b> <br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 109 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::iterator std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::iterator</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 120 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::key_equal std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::key_equal</b> <br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 110 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::key_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::key_type</b> <br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 106 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::local_iterator std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::local_iterator</b>
<br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 122 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::mapped_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::mapped_type</b> <br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 108 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef allocator_type::pointer std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::pointer</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 116 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef allocator_type::reference std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::reference</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 118 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::size_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::size_type</b> <br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 124 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
typedef _Hashtable::value_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::value_type</b> <br>
Public typedefs.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 107 of file unordered_map.h.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (size_type__n =</b> <tt>10</tt><b>,
const hasher &amp;__hf = hasher</b><tt>()</tt><b>, const
key_equal &amp;__eql = key_equal</b><tt>()</tt><b>, const
allocator_type &amp;__a =
allocator_type</b><tt>()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Default constructor creates no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> Initial number of
buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 138 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (_InputIterator__f, _InputIterator__l,
size_type__n =</b> <tt>0</tt><b>, const hasher &amp;__hf =
hasher</b><tt>()</tt><b>, const key_equal &amp;__eql =
key_equal</b><tt>()</tt><b>, const allocator_type &amp;__a =
allocator_type</b><tt>()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds an unordered_map from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_map consisting of copies of the elements from
[__first,__last). This is linear in N (where N is
distance(__first,__last)).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 159 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (const unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt; &amp;)</b> <tt>[default]</tt> <br>
Copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt> <br>
Move constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (initializer_list&lt; value_type
&gt;__l, size_type__n =</b> <tt>0</tt><b>, const hasher
&amp;__hf = hasher</b><tt>()</tt><b>, const key_equal
&amp;__eql = key_equal</b><tt>()</tt><b>, const
allocator_type &amp;__a =
allocator_type</b><tt>()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds an unordered_map from an initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_map consisting of copies of the elements in the
list. This is linear in N (where N is
<i>__l.size()</i>).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 184 of file unordered_map.h.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
mapped_type&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::at (const key_type &amp;__k)</b>
<tt>[inline]</tt> <br>
Access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A reference to the data whose
key is equal to <i>__k</i>, if such a data is present in the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If no
such data is present.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 612 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const mapped_type&amp; std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::at (const key_type &amp;__k)
const</b> <tt>[inline]</tt> <br>
Access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A reference to the data whose
key is equal to <i>__k</i>, if such a data is present in the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions:</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If no
such data is present.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 616 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::begin ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 248 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::begin () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 257 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
local_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::begin (size_type__n)</b>
<tt>[inline]</tt> <br>
Returns a read/write iterator pointing to the first bucket
element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read/write local
iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 657 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::begin (size_type__n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 668 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::bucket_count () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of buckets of the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 624 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::cbegin () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 261 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::cbegin (size_type__n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 672 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::cend () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 283 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::cend (size_type__n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 698 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::clear ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Erases all elements in an unordered_map. Note that this
function only erases the elements, and that if the elements
themselves are pointers, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 497 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::count (const key_type &amp;__x) const</b>
<tt>[inline]</tt> <br>
Finds the number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to count.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for unordered_multimap; for unordered_map
the result will either be 0 (not present) or 1
(present).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 560 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; std::pair&lt;iterator,
bool&gt; std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::emplace (_Args &amp;&amp;...__args)</b>
<tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__args</i> Arguments used to
generate a new pair instance (see std::piecewise_contruct
for passing arguments to each part of the pair
constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 310 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::emplace_hint (const_iterator__pos, _Args
&amp;&amp;...__args)</b> <tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__pos</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__args</i> Arguments used to generate a new pair instance
(see std::piecewise_contruct for passing arguments to each
part of the pair constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of the std::pair built from <i>__args</i>
(may or may not be that std::pair).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
emplace() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 340 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
bool std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::empty () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns true if the unordered_map is empty.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 228 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::end ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 270 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::end () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 279 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
local_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::end (size_type__n)</b> <tt>[inline]</tt>
<br>
Returns a read/write iterator pointing to one past the last
bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read/write local
iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 683 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::end (size_type__n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 694 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt;iterator, iterator&gt; std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const
key_type &amp;__x)</b> <tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 573 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt;const_iterator, const_iterator&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::equal_range (const key_type &amp;__x) const</b>
<tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 577 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const_iterator__position)</b>
<tt>[inline]</tt> <br>
Erases an element from an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_map. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 447 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (iterator__it)</b> <tt>[inline]</tt> <br>
Erases an element from an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_map. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 452 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const key_type &amp;__x)</b>
<tt>[inline]</tt> <br>
Erases elements according to the provided key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of element to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The number of elements
erased.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases all the elements located by the given key from an
unordered_map. For an unordered_map the result of this
function can only be 0 (not present) or 1 (present). Note
that this function only erases the element, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 469 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const_iterator__first,
const_iterator__last)</b> <tt>[inline]</tt> <br>
Erases a [__first,__last) range of elements from an
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be erased. <i><br>
__last</i> Iterator pointing to the end of the range to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">The iterator <i>__last</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases a sequence of elements from an unordered_map. Note
that this function only erases the elements, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 487 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::find (const key_type &amp;__x)</b>
<tt>[inline]</tt> <br>
Tries to locate an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 542 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::find (const key_type &amp;__x) const</b>
<tt>[inline]</tt> <br>
Tries to locate an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 546 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
allocator_type std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::get_allocator () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the allocator object with which the unordered_map
was constructed.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 221 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
hasher std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::hash_function () const</b> <tt>[inline]</tt>
<br>
Returns the hash functor object with which the unordered_map
was constructed.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 518 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt;iterator, bool&gt; std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::insert (const value_type
&amp;__x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 362 of file unordered_map.h.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>template&lt;class _Key, class _Tp, class _Hash =
hash&lt;_Key&gt;, class _Pred = std::equal_to&lt;_Key&gt;,
class _Alloc = std::allocator&lt;std::pair&lt;const _Key,
_Tp&gt; &gt;&gt; template&lt;typename _Pair , typename =
typename
std::enable_if&lt;std::is_constructible&lt;value_type,</b></p> </td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>_Pair&amp;&amp;&gt;::value&gt;::type&gt;
std::pair&lt;iterator, bool&gt; std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::insert (_Pair
&amp;&amp;__x)</b> <tt>[inline]</tt></p></td></tr>
</table>

<p style="margin-left:11%;">Attempts to insert a std::pair
into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 369 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::insert (const_iterator__hint, const value_type
&amp;__x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 396 of file unordered_map.h.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>template&lt;class _Key, class _Tp, class _Hash =
hash&lt;_Key&gt;, class _Pred = std::equal_to&lt;_Key&gt;,
class _Alloc = std::allocator&lt;std::pair&lt;const _Key,
_Tp&gt; &gt;&gt; template&lt;typename _Pair , typename =
typename
std::enable_if&lt;std::is_constructible&lt;value_type,</b></p> </td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>_Pair&amp;&amp;&gt;::value&gt;::type&gt; iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (const_iterator__hint, _Pair &amp;&amp;__x)</b>
<tt>[inline]</tt></p> </td></tr>
</table>

<p style="margin-left:11%;">Attempts to insert a std::pair
into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 403 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (_InputIterator__first,
_InputIterator__last)</b> <tt>[inline]</tt> <br>
A template function that attempts to insert a range of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be inserted. <i><br>
__last</i> Iterator pointing to the end of the range.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 418 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (initializer_list&lt; value_type &gt;__l)</b>
<tt>[inline]</tt> <br>
Attempts to insert a list of elements into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> A
std::initializer_list&lt;value_type&gt; of elements to be
inserted.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 429 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
key_equal std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::key_eq () const</b> <tt>[inline]</tt> <br>
Returns the key comparison object with which the
unordered_map was constructed.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 524 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
float std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::load_factor () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the average number of elements per bucket.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 706 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::max_bucket_count () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the maximum number of buckets of the
unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 629 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
float std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::max_load_factor () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a positive number that the unordered_map tries to
keep the load factor less than or equal to.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 712 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::max_load_factor (float__z)</b> <tt>[inline]</tt> <br>
Change the unordered_map maximum load factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__z</i> The new maximum load
factor.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 720 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::max_size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the maximum size of the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 238 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
unordered_map&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (const unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;)</b> <tt>[default]</tt>
<br>
Copy assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
unordered_map&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt>
<br>
Move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
unordered_map&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (initializer_list&lt;
value_type &gt;__l)</b> <tt>[inline]</tt> <br>
Unordered_map list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills an unordered_map with copies of the elements in the
initializer list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the unordered_map and that the
resulting unordered_map&rsquo;s size is the same as the
number of elements assigned. Old data may be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 212 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
mapped_type&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator[] (const key_type &amp;__k)</b>
<tt>[inline]</tt> <br>
Subscript ( [] ) access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A reference to the data of the
(key,data) pair.</p>

<p style="margin-left:11%; margin-top: 1em">Allows for easy
lookup with the subscript ( [] )operator. Returns data
associated with the key specified in subscript. If the key
does not exist, a pair with that key is created using
default values, which is then returned.</p>

<p style="margin-left:11%; margin-top: 1em">Lookup requires
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 595 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
mapped_type&amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator[] (key_type &amp;&amp;__k)</b>
<tt>[inline]</tt> <br>
Subscript ( [] ) access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">A reference to the data of the
(key,data) pair.</p>

<p style="margin-left:11%; margin-top: 1em">Allows for easy
lookup with the subscript ( [] )operator. Returns data
associated with the key specified in subscript. If the key
does not exist, a pair with that key is created using
default values, which is then returned.</p>

<p style="margin-left:11%; margin-top: 1em">Lookup requires
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 599 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::rehash (size_type__n)</b> <tt>[inline]</tt> <br>
May rehash the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> The new number of
buckets.</p>

<p style="margin-left:11%; margin-top: 1em">Rehash will
occur only if the new number of buckets respect the
unordered_map maximum load factor.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 731 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::reserve (size_type__n)</b> <tt>[inline]</tt> <br>
Prepare the unordered_map for a specified number of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
required.</p>

<p style="margin-left:11%; margin-top: 1em">Same as
rehash(ceil(n / max_load_factor())).</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 742 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the size of the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 233 of file unordered_map.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;class
_Key, class _Tp, class _Hash = hash&lt;_Key&gt;, class _Pred
= std::equal_to&lt;_Key&gt;, class _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::swap (unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x)</b> <tt>[inline]</tt> <br>
Swaps data with another unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__x</i> An unordered_map of
the same element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two unordered_map in constant time.
Note that the global std::swap() function is specialized
such that std::swap(m1,m2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 510 of file unordered_map.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
