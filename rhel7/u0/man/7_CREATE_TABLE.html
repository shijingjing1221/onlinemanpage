<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:37:27 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CREATE TABLE</title>

</head>
<body>

<h1 align="center">CREATE TABLE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PARAMETERS">PARAMETERS</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#COMPATIBILITY">COMPATIBILITY</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">CREATE_TABLE
&minus; define a new table</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">CREATE [ [
GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [
IF NOT EXISTS ] <i>table_name</i> ( [ <br>
{ <i>column_name data_type</i> [ COLLATE <i>collation</i> ]
[ <i>column_constraint</i> [ ... ] ] <br>
| <i>table_constraint</i> <br>
| LIKE <i>source_table</i> [ <i>like_option</i> ... ] } <br>
[, ... ] <br>
] ) <br>
[ INHERITS ( <i>parent_table</i> [, ... ] ) ] <br>
[ WITH ( <i>storage_parameter</i> [= <i>value</i>] [, ... ]
) | WITH OIDS | WITHOUT OIDS ] <br>
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ] <br>
[ TABLESPACE <i>tablespace_name</i> ]</p>

<p style="margin-left:11%; margin-top: 1em">CREATE [ [
GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [
IF NOT EXISTS ] <i>table_name</i> <br>
OF <i>type_name</i> [ ( <br>
{ <i>column_name</i> WITH OPTIONS [ <i>column_constraint</i>
[ ... ] ] <br>
| <i>table_constraint</i> } <br>
[, ... ] <br>
) ] <br>
[ WITH ( <i>storage_parameter</i> [= <i>value</i>] [, ... ]
) | WITH OIDS | WITHOUT OIDS ] <br>
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ] <br>
[ TABLESPACE <i>tablespace_name</i> ]</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>column_constraint</i> is:</p>

<p style="margin-left:11%; margin-top: 1em">[ CONSTRAINT
<i>constraint_name</i> ] <br>
{ NOT NULL | <br>
NULL | <br>
CHECK ( <i>expression</i> ) [ NO INHERIT ] | <br>
DEFAULT <i>default_expr</i> | <br>
UNIQUE <i>index_parameters</i> | <br>
PRIMARY KEY <i>index_parameters</i> | <br>
REFERENCES <i>reftable</i> [ ( <i>refcolumn</i> ) ] [ MATCH
FULL | MATCH PARTIAL | MATCH SIMPLE ] <br>
[ ON DELETE <i>action</i> ] [ ON UPDATE <i>action</i> ] }
<br>
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED |
INITIALLY IMMEDIATE ]</p>

<p style="margin-left:11%; margin-top: 1em">and
<i>table_constraint</i> is:</p>

<p style="margin-left:11%; margin-top: 1em">[ CONSTRAINT
<i>constraint_name</i> ] <br>
{ CHECK ( <i>expression</i> ) [ NO INHERIT ] | <br>
UNIQUE ( <i>column_name</i> [, ... ] )
<i>index_parameters</i> | <br>
PRIMARY KEY ( <i>column_name</i> [, ... ] )
<i>index_parameters</i> | <br>
EXCLUDE [ USING <i>index_method</i> ] (
<i>exclude_element</i> WITH <i>operator</i> [, ... ] )
<i>index_parameters</i> [ WHERE ( <i>predicate</i> ) ] |
<br>
FOREIGN KEY ( <i>column_name</i> [, ... ] ) REFERENCES
<i>reftable</i> [ ( <i>refcolumn</i> [, ... ] ) ] <br>
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE
<i>action</i> ] [ ON UPDATE <i>action</i> ] } <br>
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED |
INITIALLY IMMEDIATE ]</p>

<p style="margin-left:11%; margin-top: 1em">and
<i>like_option</i> is:</p>

<p style="margin-left:11%; margin-top: 1em">{ INCLUDING |
EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE |
COMMENTS | ALL }</p>


<p style="margin-left:11%; margin-top: 1em"><i>index_parameters</i>
in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:</p>

<p style="margin-left:11%; margin-top: 1em">[ WITH (
<i>storage_parameter</i> [= <i>value</i>] [, ... ] ) ] <br>
[ USING INDEX TABLESPACE <i>tablespace_name</i> ]</p>


<p style="margin-left:11%; margin-top: 1em"><i>exclude_element</i>
in an EXCLUDE constraint is:</p>

<p style="margin-left:11%; margin-top: 1em">{
<i>column_name</i> | ( <i>expression</i> ) } [
<i>opclass</i> ] [ ASC | DESC ] [ NULLS { FIRST | LAST }
]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>CREATE
TABLE</b> will create a new, initially empty table in the
current database. The table will be owned by the user
issuing the command.</p>

<p style="margin-left:11%; margin-top: 1em">If a schema
name is given (for example, CREATE TABLE myschema.mytable
...) then the table is created in the specified schema.
Otherwise it is created in the current schema. Temporary
tables exist in a special schema, so a schema name cannot be
given when creating a temporary table. The name of the table
must be distinct from the name of any other table, sequence,
index, view, or foreign table in the same schema.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CREATE
TABLE</b> also automatically creates a data type that
represents the composite type corresponding to one row of
the table. Therefore, tables cannot have the same name as
any existing data type in the same schema.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
constraint clauses specify constraints (tests) that new or
updated rows must satisfy for an insert or update operation
to succeed. A constraint is an SQL object that helps define
the set of valid values in the table in various ways.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to define constraints: table constraints and column
constraints. A column constraint is defined as part of a
column definition. A table constraint definition is not tied
to a particular column, and it can encompass more than one
column. Every column constraint can also be written as a
table constraint; a column constraint is only a notational
convenience for use when the constraint only affects one
column.</p>

<p style="margin-left:11%; margin-top: 1em">To be able to
create a table, you must have USAGE privilege on all column
types or the type in the OF clause, respectively.</p>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">TEMPORARY or
TEMP</p>

<p style="margin-left:17%;">If specified, the table is
created as a temporary table. Temporary tables are
automatically dropped at the end of a session, or optionally
at the end of the current transaction (see ON COMMIT below).
Existing permanent tables with the same name are not visible
to the current session while the temporary table exists,
unless they are referenced with schema&minus;qualified
names. Any indexes created on a temporary table are
automatically temporary as well.</p>

<p style="margin-left:17%; margin-top: 1em">The autovacuum
daemon cannot access and therefore cannot vacuum or analyze
temporary tables. For this reason, appropriate vacuum and
analyze operations should be performed via session SQL
commands. For example, if a temporary table is going to be
used in complex queries, it is wise to run <b>ANALYZE</b> on
the temporary table after it is populated.</p>

<p style="margin-left:17%; margin-top: 1em">Optionally,
GLOBAL or LOCAL can be written before TEMPORARY or TEMP.
This presently makes no difference in PostgreSQL and is
deprecated; see COMPATIBILITY.</p>

<p style="margin-left:11%; margin-top: 1em">UNLOGGED</p>

<p style="margin-left:17%;">If specified, the table is
created as an unlogged table. Data written to unlogged
tables is not written to the write&minus;ahead log (see
Chapter 29, Reliability and the Write-Ahead Log, in the
documentation), which makes them considerably faster than
ordinary tables. However, they are not crash&minus;safe: an
unlogged table is automatically truncated after a crash or
unclean shutdown. The contents of an unlogged table are also
not replicated to standby servers. Any indexes created on an
unlogged table are automatically unlogged as well; however,
unlogged GiST indexes are currently not supported and cannot
be created on an unlogged table.</p>

<p style="margin-left:11%; margin-top: 1em">IF NOT
EXISTS</p>

<p style="margin-left:17%;">Do not throw an error if a
relation with the same name already exists. A notice is
issued in this case. Note that there is no guarantee that
the existing relation is anything like the one that would
have been created.</p>


<p style="margin-left:11%; margin-top: 1em"><i>table_name</i></p>

<p style="margin-left:17%;">The name (optionally
schema&minus;qualified) of the table to be created.</p>

<p style="margin-left:11%; margin-top: 1em">OF
<i>type_name</i></p>

<p style="margin-left:17%;">Creates a typed table, which
takes its structure from the specified composite type (name
optionally schema&minus;qualified). A typed table is tied to
its type; for example the table will be dropped if the type
is dropped (with DROP TYPE ... CASCADE).</p>

<p style="margin-left:17%; margin-top: 1em">When a typed
table is created, then the data types of the columns are
determined by the underlying composite type and are not
specified by the CREATE TABLE command. But the CREATE TABLE
command can add defaults and constraints to the table and
can specify storage parameters.</p>


<p style="margin-left:11%; margin-top: 1em"><i>column_name</i></p>

<p style="margin-left:17%;">The name of a column to be
created in the new table.</p>


<p style="margin-left:11%; margin-top: 1em"><i>data_type</i></p>

<p style="margin-left:17%;">The data type of the column.
This can include array specifiers. For more information on
the data types supported by PostgreSQL, refer to Chapter 8,
Data Types, in the documentation.</p>

<p style="margin-left:11%; margin-top: 1em">COLLATE
<i>collation</i></p>

<p style="margin-left:17%;">The COLLATE clause assigns a
collation to the column (which must be of a collatable data
type). If not specified, the column data type's default
collation is used.</p>

<p style="margin-left:11%; margin-top: 1em">INHERITS (
<i>parent_table</i> [, ... ] )</p>

<p style="margin-left:17%;">The optional INHERITS clause
specifies a list of tables from which the new table
automatically inherits all columns.</p>

<p style="margin-left:17%; margin-top: 1em">Use of INHERITS
creates a persistent relationship between the new child
table and its parent table(s). Schema modifications to the
parent(s) normally propagate to children as well, and by
default the data of the child table is included in scans of
the parent(s).</p>

<p style="margin-left:17%; margin-top: 1em">If the same
column name exists in more than one parent table, an error
is reported unless the data types of the columns match in
each of the parent tables. If there is no conflict, then the
duplicate columns are merged to form a single column in the
new table. If the column name list of the new table contains
a column name that is also inherited, the data type must
likewise match the inherited column(s), and the column
definitions are merged into one. If the new table explicitly
specifies a default value for the column, this default
overrides any defaults from inherited declarations of the
column. Otherwise, any parents that specify default values
for the column must all specify the same default, or an
error will be reported.</p>

<p style="margin-left:17%; margin-top: 1em">CHECK
constraints are merged in essentially the same way as
columns: if multiple parent tables and/or the new table
definition contain identically&minus;named CHECK
constraints, these constraints must all have the same check
expression, or an error will be reported. Constraints having
the same name and expression will be merged into one copy. A
constraint marked NO INHERIT in a parent will not be
considered. Notice that an unnamed CHECK constraint in the
new table will never be merged, since a unique name will
always be chosen for it.</p>

<p style="margin-left:17%; margin-top: 1em">Column STORAGE
settings are also copied from parent tables.</p>

<p style="margin-left:11%; margin-top: 1em">LIKE
<i>source_table</i> [ <i>like_option</i> ... ]</p>

<p style="margin-left:17%;">The LIKE clause specifies a
table from which the new table automatically copies all
column names, their data types, and their not&minus;null
constraints.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike
INHERITS, the new table and original table are completely
decoupled after creation is complete. Changes to the
original table will not be applied to the new table, and it
is not possible to include data of the new table in scans of
the original table.</p>

<p style="margin-left:17%; margin-top: 1em">Default
expressions for the copied column definitions will only be
copied if INCLUDING DEFAULTS is specified. The default
behavior is to exclude default expressions, resulting in the
copied columns in the new table having null defaults.</p>

<p style="margin-left:17%; margin-top: 1em">Not&minus;null
constraints are always copied to the new table. CHECK
constraints will only be copied if INCLUDING CONSTRAINTS is
specified; other types of constraints will never be copied.
Also, no distinction is made between column constraints and
table constraints &mdash; when constraints are requested,
all check constraints are copied.</p>

<p style="margin-left:17%; margin-top: 1em">Any indexes on
the original table will not be created on the new table,
unless the INCLUDING INDEXES clause is specified.</p>

<p style="margin-left:17%; margin-top: 1em">STORAGE
settings for the copied column definitions will only be
copied if INCLUDING STORAGE is specified. The default
behavior is to exclude STORAGE settings, resulting in the
copied columns in the new table having type&minus;specific
default settings. For more on STORAGE settings, see Section
56.2, &ldquo;TOAST&rdquo;, in the documentation.</p>

<p style="margin-left:17%; margin-top: 1em">Comments for
the copied columns, constraints, and indexes will only be
copied if INCLUDING COMMENTS is specified. The default
behavior is to exclude comments, resulting in the copied
columns and constraints in the new table having no
comments.</p>

<p style="margin-left:17%; margin-top: 1em">INCLUDING ALL
is an abbreviated form of INCLUDING DEFAULTS INCLUDING
CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING
COMMENTS.</p>

<p style="margin-left:17%; margin-top: 1em">Note also that
unlike INHERITS, columns and constraints copied by LIKE are
not merged with similarly named columns and constraints. If
the same name is specified explicitly or in another LIKE
clause, an error is signalled.</p>

<p style="margin-left:17%; margin-top: 1em">The LIKE clause
can also be used to copy columns from views, foreign tables,
or composite types. Inapplicable options (e.g., INCLUDING
INDEXES from a view) are ignored.</p>

<p style="margin-left:11%; margin-top: 1em">CONSTRAINT
<i>constraint_name</i></p>

<p style="margin-left:17%;">An optional name for a column
or table constraint. If the constraint is violated, the
constraint name is present in error messages, so constraint
names like col must be positive can be used to communicate
helpful constraint information to client applications.
(Double&minus;quotes are needed to specify constraint names
that contain spaces.) If a constraint name is not specified,
the system generates a name.</p>

<p style="margin-left:11%; margin-top: 1em">NOT NULL</p>

<p style="margin-left:17%;">The column is not allowed to
contain null values.</p>

<p style="margin-left:11%; margin-top: 1em">NULL</p>

<p style="margin-left:17%;">The column is allowed to
contain null values. This is the default.</p>

<p style="margin-left:17%; margin-top: 1em">This clause is
only provided for compatibility with non&minus;standard SQL
databases. Its use is discouraged in new applications.</p>

<p style="margin-left:11%; margin-top: 1em">CHECK (
<i>expression</i> ) [ NO INHERIT ]</p>

<p style="margin-left:17%;">The CHECK clause specifies an
expression producing a Boolean result which new or updated
rows must satisfy for an insert or update operation to
succeed. Expressions evaluating to TRUE or UNKNOWN succeed.
Should any row of an insert or update operation produce a
FALSE result an error exception is raised and the insert or
update does not alter the database. A check constraint
specified as a column constraint should reference that
column's value only, while an expression appearing in a
table constraint can reference multiple columns.</p>

<p style="margin-left:17%; margin-top: 1em">Currently,
CHECK expressions cannot contain subqueries nor refer to
variables other than columns of the current row.</p>

<p style="margin-left:17%; margin-top: 1em">A constraint
marked with NO INHERIT will not propagate to child
tables.</p>

<p style="margin-left:11%; margin-top: 1em">DEFAULT
<i>default_expr</i></p>

<p style="margin-left:17%;">The DEFAULT clause assigns a
default data value for the column whose column definition it
appears within. The value is any variable&minus;free
expression (subqueries and cross&minus;references to other
columns in the current table are not allowed). The data type
of the default expression must match the data type of the
column.</p>

<p style="margin-left:17%; margin-top: 1em">The default
expression will be used in any insert operation that does
not specify a value for the column. If there is no default
for a column, then the default is null.</p>

<p style="margin-left:11%; margin-top: 1em">UNIQUE (column
constraint), UNIQUE ( <i>column_name</i> [, ... ] ) (table
constraint)</p>

<p style="margin-left:17%;">The UNIQUE constraint specifies
that a group of one or more columns of a table can contain
only unique values. The behavior of the unique table
constraint is the same as that for column constraints, with
the additional capability to span multiple columns.</p>

<p style="margin-left:17%; margin-top: 1em">For the purpose
of a unique constraint, null values are not considered
equal.</p>

<p style="margin-left:17%; margin-top: 1em">Each unique
table constraint must name a set of columns that is
different from the set of columns named by any other unique
or primary key constraint defined for the table. (Otherwise
it would just be the same constraint listed twice.)</p>

<p style="margin-left:11%; margin-top: 1em">PRIMARY KEY
(column constraint), PRIMARY KEY ( <i>column_name</i> [, ...
] ) (table constraint)</p>

<p style="margin-left:17%;">The primary key constraint
specifies that a column or columns of a table can contain
only unique (non&minus;duplicate), nonnull values.
Technically, PRIMARY KEY is merely a combination of UNIQUE
and NOT NULL, but identifying a set of columns as primary
key also provides metadata about the design of the schema,
as a primary key implies that other tables can rely on this
set of columns as a unique identifier for rows.</p>

<p style="margin-left:17%; margin-top: 1em">Only one
primary key can be specified for a table, whether as a
column constraint or a table constraint.</p>

<p style="margin-left:17%; margin-top: 1em">The primary key
constraint should name a set of columns that is different
from other sets of columns named by any unique constraint
defined for the same table.</p>

<p style="margin-left:11%; margin-top: 1em">EXCLUDE [ USING
<i>index_method</i> ] ( <i>exclude_element</i> WITH
<i>operator</i> [, ... ] ) <i>index_parameters</i> [ WHERE (
<i>predicate</i> ) ]</p>

<p style="margin-left:17%;">The EXCLUDE clause defines an
exclusion constraint, which guarantees that if any two rows
are compared on the specified column(s) or expression(s)
using the specified operator(s), not all of these
comparisons will return TRUE. If all of the specified
operators test for equality, this is equivalent to a UNIQUE
constraint, although an ordinary unique constraint will be
faster. However, exclusion constraints can specify
constraints that are more general than simple equality. For
example, you can specify a constraint that no two rows in
the table contain overlapping circles (see Section 8.8,
&ldquo;Geometric Types&rdquo;, in the documentation) by
using the &amp;&amp; operator.</p>

<p style="margin-left:17%; margin-top: 1em">Exclusion
constraints are implemented using an index, so each
specified operator must be associated with an appropriate
operator class (see Section 11.9, &ldquo;Operator Classes
and Operator Families&rdquo;, in the documentation) for the
index access method <i>index_method</i>. The operators are
required to be commutative. Each <i>exclude_element</i> can
optionally specify an operator class and/or ordering
options; these are described fully under CREATE INDEX
(<b>CREATE_INDEX</b>(7)).</p>

<p style="margin-left:17%; margin-top: 1em">The access
method must support amgettuple (see Chapter 52, Index Access
Method Interface Definition, in the documentation); at
present this means GIN cannot be used. Although it's
allowed, there is little point in using B&minus;tree or hash
indexes with an exclusion constraint, because this does
nothing that an ordinary unique constraint doesn't do
better. So in practice the access method will always be GiST
or SP&minus;GiST.</p>

<p style="margin-left:17%; margin-top: 1em">The
<i>predicate</i> allows you to specify an exclusion
constraint on a subset of the table; internally this creates
a partial index. Note that parentheses are required around
the predicate.</p>

<p style="margin-left:11%; margin-top: 1em">REFERENCES
<i>reftable</i> [ ( <i>refcolumn</i> ) ] [ MATCH
<i>matchtype</i> ] [ ON DELETE <i>action</i> ] [ ON UPDATE
<i>action</i> ] (column constraint), FOREIGN KEY (
<i>column_name</i> [, ... ] ) REFERENCES <i>reftable</i> [ (
<i>refcolumn</i> [, ... ] ) ] [ MATCH <i>matchtype</i> ] [
ON DELETE <i>action</i> ] [ ON UPDATE <i>action</i> ] (table
constraint)</p>

<p style="margin-left:17%;">These clauses specify a foreign
key constraint, which requires that a group of one or more
columns of the new table must only contain values that match
values in the referenced column(s) of some row of the
referenced table. If <i>refcolumn</i> is omitted, the
primary key of the <i>reftable</i> is used. The referenced
columns must be the columns of a non&minus;deferrable unique
or primary key constraint in the referenced table. Note that
foreign key constraints cannot be defined between temporary
tables and permanent tables.</p>

<p style="margin-left:17%; margin-top: 1em">A value
inserted into the referencing column(s) is matched against
the values of the referenced table and referenced columns
using the given match type. There are three match types:
MATCH FULL, MATCH PARTIAL, and MATCH SIMPLE, which is also
the default. MATCH FULL will not allow one column of a
multicolumn foreign key to be null unless all foreign key
columns are null. MATCH SIMPLE allows some foreign key
columns to be null while other parts of the foreign key are
not null. MATCH PARTIAL is not yet implemented.</p>

<p style="margin-left:17%; margin-top: 1em">In addition,
when the data in the referenced columns is changed, certain
actions are performed on the data in this table's columns.
The ON DELETE clause specifies the action to perform when a
referenced row in the referenced table is being deleted.
Likewise, the ON UPDATE clause specifies the action to
perform when a referenced column in the referenced table is
being updated to a new value. If the row is updated, but the
referenced column is not actually changed, no action is
done. Referential actions other than the NO ACTION check
cannot be deferred, even if the constraint is declared
deferrable. There are the following possible actions for
each clause:</p>

<p style="margin-left:17%; margin-top: 1em">NO ACTION</p>

<p style="margin-left:23%;">Produce an error indicating
that the deletion or update would create a foreign key
constraint violation. If the constraint is deferred, this
error will be produced at constraint check time if there
still exist any referencing rows. This is the default
action.</p>

<p style="margin-left:17%; margin-top: 1em">RESTRICT</p>

<p style="margin-left:23%;">Produce an error indicating
that the deletion or update would create a foreign key
constraint violation. This is the same as NO ACTION except
that the check is not deferrable.</p>

<p style="margin-left:17%; margin-top: 1em">CASCADE</p>

<p style="margin-left:23%;">Delete any rows referencing the
deleted row, or update the value of the referencing column
to the new value of the referenced column, respectively.</p>

<p style="margin-left:17%; margin-top: 1em">SET NULL</p>

<p style="margin-left:23%;">Set the referencing column(s)
to null.</p>

<p style="margin-left:17%; margin-top: 1em">SET DEFAULT</p>

<p style="margin-left:23%;">Set the referencing column(s)
to their default values.</p>

<p style="margin-left:17%; margin-top: 1em">If the
referenced column(s) are changed frequently, it might be
wise to add an index to the foreign key column so that
referential actions associated with the foreign key column
can be performed more efficiently.</p>

<p style="margin-left:11%; margin-top: 1em">DEFERRABLE, NOT
DEFERRABLE</p>

<p style="margin-left:17%;">This controls whether the
constraint can be deferred. A constraint that is not
deferrable will be checked immediately after every command.
Checking of constraints that are deferrable can be postponed
until the end of the transaction (using the SET CONSTRAINTS
(<b>SET_CONSTRAINTS</b>(7)) command). NOT DEFERRABLE is the
default. Currently, only UNIQUE, PRIMARY KEY, EXCLUDE, and
REFERENCES (foreign key) constraints accept this clause. NOT
NULL and CHECK constraints are not deferrable.</p>

<p style="margin-left:11%; margin-top: 1em">INITIALLY
IMMEDIATE, INITIALLY DEFERRED</p>

<p style="margin-left:17%;">If a constraint is deferrable,
this clause specifies the default time to check the
constraint. If the constraint is INITIALLY IMMEDIATE, it is
checked after each statement. This is the default. If the
constraint is INITIALLY DEFERRED, it is checked only at the
end of the transaction. The constraint check time can be
altered with the SET CONSTRAINTS (<b>SET_CONSTRAINTS</b>(7))
command.</p>

<p style="margin-left:11%; margin-top: 1em">WITH (
<i>storage_parameter</i> [= <i>value</i>] [, ... ] )</p>

<p style="margin-left:17%;">This clause specifies optional
storage parameters for a table or index; see Storage
Parameters for more information. The WITH clause for a table
can also include OIDS=TRUE (or just OIDS) to specify that
rows of the new table should have OIDs (object identifiers)
assigned to them, or OIDS=FALSE to specify that the rows
should not have OIDs. If OIDS is not specified, the default
setting depends upon the default_with_oids configuration
parameter. (If the new table inherits from any tables that
have OIDs, then OIDS=TRUE is forced even if the command says
OIDS=FALSE.)</p>

<p style="margin-left:17%; margin-top: 1em">If OIDS=FALSE
is specified or implied, the new table does not store OIDs
and no OID will be assigned for a row inserted into it. This
is generally considered worthwhile, since it will reduce OID
consumption and thereby postpone the wraparound of the
32&minus;bit OID counter. Once the counter wraps around,
OIDs can no longer be assumed to be unique, which makes them
considerably less useful. In addition, excluding OIDs from a
table reduces the space required to store the table on disk
by 4 bytes per row (on most machines), slightly improving
performance.</p>

<p style="margin-left:17%; margin-top: 1em">To remove OIDs
from a table after it has been created, use ALTER TABLE
(<b>ALTER_TABLE</b>(7)).</p>

<p style="margin-left:11%; margin-top: 1em">WITH OIDS,
WITHOUT OIDS</p>

<p style="margin-left:17%;">These are obsolescent syntaxes
equivalent to WITH (OIDS) and WITH (OIDS=FALSE),
respectively. If you wish to give both an OIDS setting and
storage parameters, you must use the WITH ( ... ) syntax;
see above.</p>

<p style="margin-left:11%; margin-top: 1em">ON COMMIT</p>

<p style="margin-left:17%;">The behavior of temporary
tables at the end of a transaction block can be controlled
using ON COMMIT. The three options are:</p>

<p style="margin-left:17%; margin-top: 1em">PRESERVE
ROWS</p>

<p style="margin-left:23%;">No special action is taken at
the ends of transactions. This is the default behavior.</p>

<p style="margin-left:17%; margin-top: 1em">DELETE ROWS</p>

<p style="margin-left:23%;">All rows in the temporary table
will be deleted at the end of each transaction block.
Essentially, an automatic <b>TRUNCATE</b>(7) is done at each
commit.</p>

<p style="margin-left:17%; margin-top: 1em">DROP</p>

<p style="margin-left:23%;">The temporary table will be
dropped at the end of the current transaction block.</p>

<p style="margin-left:11%; margin-top: 1em">TABLESPACE
<i>tablespace_name</i></p>

<p style="margin-left:17%;">The <i>tablespace_name</i> is
the name of the tablespace in which the new table is to be
created. If not specified, default_tablespace is consulted,
or temp_tablespaces if the table is temporary.</p>

<p style="margin-left:11%; margin-top: 1em">USING INDEX
TABLESPACE <i>tablespace_name</i></p>

<p style="margin-left:17%;">This clause allows selection of
the tablespace in which the index associated with a UNIQUE,
PRIMARY KEY, or EXCLUDE constraint will be created. If not
specified, default_tablespace is consulted, or
temp_tablespaces if the table is temporary.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Storage
Parameters</b> <br>
The WITH clause can specify storage parameters for tables,
and for indexes associated with a UNIQUE, PRIMARY KEY, or
EXCLUDE constraint. Storage parameters for indexes are
documented in CREATE INDEX (<b>CREATE_INDEX</b>(7)). The
storage parameters currently available for tables are listed
below. For each parameter, unless noted, there is an
additional parameter with the same name prefixed with
toast., which can be used to control the behavior of the
table's secondary TOAST table, if any (see Section 56.2,
&ldquo;TOAST&rdquo;, in the documentation for more
information about TOAST). Note that the TOAST table inherits
the autovacuum_* values from its parent table, if there are
no toast.autovacuum_* settings set.</p>

<p style="margin-left:11%; margin-top: 1em">fillfactor
(integer)</p>

<p style="margin-left:17%;">The fillfactor for a table is a
percentage between 10 and 100. 100 (complete packing) is the
default. When a smaller fillfactor is specified,
<b>INSERT</b> operations pack table pages only to the
indicated percentage; the remaining space on each page is
reserved for updating rows on that page. This gives
<b>UPDATE</b> a chance to place the updated copy of a row on
the same page as the original, which is more efficient than
placing it on a different page. For a table whose entries
are never updated, complete packing is the best choice, but
in heavily updated tables smaller fillfactors are
appropriate. This parameter cannot be set for TOAST
tables.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_enabled,
toast.autovacuum_enabled (boolean)</p>

<p style="margin-left:17%;">Enables or disables the
autovacuum daemon on a particular table. If true, the
autovacuum daemon will initiate a <b>VACUUM</b> operation on
a particular table when the number of updated or deleted
tuples exceeds autovacuum_vacuum_threshold plus
autovacuum_vacuum_scale_factor times the number of live
tuples currently estimated to be in the relation. Similarly,
it will initiate an <b>ANALYZE</b> operation when the number
of inserted, updated or deleted tuples exceeds
autovacuum_analyze_threshold plus
autovacuum_analyze_scale_factor times the number of live
tuples currently estimated to be in the relation. If false,
this table will not be autovacuumed, except to prevent
transaction Id wraparound. See Section 23.1.5,
&ldquo;Preventing Transaction ID Wraparound Failures&rdquo;,
in the documentation for more about wraparound prevention.
Observe that this variable inherits its value from the
autovacuum setting.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_vacuum_threshold,
toast.autovacuum_vacuum_threshold (integer)</p>

<p style="margin-left:17%;">Minimum number of updated or
deleted tuples before initiate a <b>VACUUM</b> operation on
a particular table.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_vacuum_scale_factor,
toast.autovacuum_vacuum_scale_factor (float4)</p>

<p style="margin-left:17%;">Multiplier for reltuples to add
to autovacuum_vacuum_threshold.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_analyze_threshold
(integer)</p>

<p style="margin-left:17%;">Minimum number of inserted,
updated, or deleted tuples before initiate an <b>ANALYZE</b>
operation on a particular table.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_analyze_scale_factor
(float4)</p>

<p style="margin-left:17%;">Multiplier for reltuples to add
to autovacuum_analyze_threshold.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_vacuum_cost_delay,
toast.autovacuum_vacuum_cost_delay (integer)</p>

<p style="margin-left:17%;">Custom
autovacuum_vacuum_cost_delay parameter.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_vacuum_cost_limit,
toast.autovacuum_vacuum_cost_limit (integer)</p>

<p style="margin-left:17%;">Custom
autovacuum_vacuum_cost_limit parameter.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_freeze_min_age,
toast.autovacuum_freeze_min_age (integer)</p>

<p style="margin-left:17%;">Custom vacuum_freeze_min_age
parameter. Note that autovacuum will ignore attempts to set
a per&minus;table autovacuum_freeze_min_age larger than the
half system&minus;wide autovacuum_freeze_max_age
setting.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_freeze_max_age,
toast.autovacuum_freeze_max_age (integer)</p>

<p style="margin-left:17%;">Custom
autovacuum_freeze_max_age parameter. Note that autovacuum
will ignore attempts to set a per&minus;table
autovacuum_freeze_max_age larger than the system&minus;wide
setting (it can only be set smaller). Note that while you
can set autovacuum_freeze_max_age very small, or even zero,
this is usually unwise since it will force frequent
vacuuming.</p>


<p style="margin-left:11%; margin-top: 1em">autovacuum_freeze_table_age,
toast.autovacuum_freeze_table_age (integer)</p>

<p style="margin-left:17%;">Custom vacuum_freeze_table_age
parameter.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Using OIDs in
new applications is not recommended: where possible, using a
SERIAL or other sequence generator as the table's primary
key is preferred. However, if your application does make use
of OIDs to identify specific rows of a table, it is
recommended to create a unique constraint on the oid column
of that table, to ensure that OIDs in the table will indeed
uniquely identify rows even after counter wraparound. Avoid
assuming that OIDs are unique across tables; if you need a
database&minus;wide unique identifier, use the combination
of tableoid and row OID for the purpose.</p>


<p style="margin-left:17%; margin-top: 1em"><b><big>Tip</big></b>
<br>
The use of OIDS=FALSE is not recommended for tables with no
primary key, since without either an OID or a unique data
key, it is difficult to identify specific rows.</p>

<p style="margin-left:11%; margin-top: 1em">PostgreSQL
automatically creates an index for each unique constraint
and primary key constraint to enforce uniqueness. Thus, it
is not necessary to create an index explicitly for primary
key columns. (See CREATE INDEX (<b>CREATE_INDEX</b>(7)) for
more information.)</p>

<p style="margin-left:11%; margin-top: 1em">Unique
constraints and primary keys are not inherited in the
current implementation. This makes the combination of
inheritance and unique constraints rather dysfunctional.</p>

<p style="margin-left:11%; margin-top: 1em">A table cannot
have more than 1600 columns. (In practice, the effective
limit is usually lower because of tuple&minus;length
constraints.)</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Create table
films and table distributors:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
films ( <br>
code char(5) CONSTRAINT firstkey PRIMARY KEY, <br>
title varchar(40) NOT NULL, <br>
did integer NOT NULL, <br>
date_prod date, <br>
kind varchar(10), <br>
len interval hour to minute <br>
);</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer PRIMARY KEY DEFAULT nextval('serial'), <br>
name varchar(40) NOT NULL CHECK (name &lt;&gt; '') <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Create a table
with a 2&minus;dimensional array:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
array_int ( <br>
vector int[][] <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a unique
table constraint for the table films. Unique table
constraints can be defined on one or more columns of the
table:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
films ( <br>
code char(5), <br>
title varchar(40), <br>
did integer, <br>
date_prod date, <br>
kind varchar(10), <br>
len interval hour to minute, <br>
CONSTRAINT production UNIQUE(date_prod) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a check
column constraint:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer CHECK (did &gt; 100), <br>
name varchar(40) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a check
table constraint:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer, <br>
name varchar(40) <br>
CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
<br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a
primary key table constraint for the table films:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
films ( <br>
code char(5), <br>
title varchar(40), <br>
did integer, <br>
date_prod date, <br>
kind varchar(10), <br>
len interval hour to minute, <br>
CONSTRAINT code_title PRIMARY KEY(code,title) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a
primary key constraint for table distributors. The following
two examples are equivalent, the first using the table
constraint syntax, the second the column constraint
syntax:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer, <br>
name varchar(40), <br>
PRIMARY KEY(did) <br>
);</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer PRIMARY KEY, <br>
name varchar(40) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Assign a
literal constant default value for the column name, arrange
for the default value of column did to be generated by
selecting the next value of a sequence object, and make the
default value of modtime be the time at which the row is
inserted:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
name varchar(40) DEFAULT 'Luso Films', <br>
did integer DEFAULT nextval('distributors_serial'), <br>
modtime timestamp DEFAULT current_timestamp <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define two NOT
NULL column constraints on the table distributors, one of
which is explicitly given a name:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer CONSTRAINT no_null NOT NULL, <br>
name varchar(40) NOT NULL <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Define a unique
constraint for the name column:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer, <br>
name varchar(40) UNIQUE <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">The same,
specified as a table constraint:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer, <br>
name varchar(40), <br>
UNIQUE(name) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Create the same
table, specifying 70% fill factor for both the table and its
unique index:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
distributors ( <br>
did integer, <br>
name varchar(40), <br>
UNIQUE(name) WITH (fillfactor=70) <br>
) <br>
WITH (fillfactor=70);</p>

<p style="margin-left:11%; margin-top: 1em">Create table
circles with an exclusion constraint that prevents any two
circles from overlapping:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
circles ( <br>
c circle, <br>
EXCLUDE USING gist (c WITH &amp;&amp;) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Create table
cinemas in tablespace diskvol1:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
cinemas ( <br>
id serial, <br>
name text, <br>
location text <br>
) TABLESPACE diskvol1;</p>

<p style="margin-left:11%; margin-top: 1em">Create a
composite type and a typed table:</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TYPE
employee_type AS (name text, salary numeric);</p>

<p style="margin-left:17%; margin-top: 1em">CREATE TABLE
employees OF employee_type ( <br>
PRIMARY KEY (name), <br>
salary WITH OPTIONS DEFAULT 1000 <br>
);</p>

<h2>COMPATIBILITY
<a name="COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <b>CREATE
TABLE</b> command conforms to the SQL standard, with
exceptions listed below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Temporary
Tables</b> <br>
Although the syntax of CREATE TEMPORARY TABLE resembles that
of the SQL standard, the effect is not the same. In the
standard, temporary tables are defined just once and
automatically exist (starting with empty contents) in every
session that needs them. PostgreSQL instead requires each
session to issue its own CREATE TEMPORARY TABLE command for
each temporary table to be used. This allows different
sessions to use the same temporary table name for different
purposes, whereas the standard's approach constrains all
instances of a given temporary table name to have the same
table structure.</p>

<p style="margin-left:11%; margin-top: 1em">The standard's
definition of the behavior of temporary tables is widely
ignored. PostgreSQL's behavior on this point is similar to
that of several other SQL databases.</p>

<p style="margin-left:11%; margin-top: 1em">The SQL
standard also distinguishes between global and local
temporary tables, where a local temporary table has a
separate set of contents for each SQL module within each
session, though its definition is still shared across
sessions. Since PostgreSQL does not support SQL modules,
this distinction is not relevant in PostgreSQL.</p>

<p style="margin-left:11%; margin-top: 1em">For
compatibility's sake, PostgreSQL will accept the GLOBAL and
LOCAL keywords in a temporary table declaration, but they
currently have no effect. Use of these keywords is
discouraged, since future versions of PostgreSQL might adopt
a more standard&minus;compliant interpretation of their
meaning.</p>

<p style="margin-left:11%; margin-top: 1em">The ON COMMIT
clause for temporary tables also resembles the SQL standard,
but has some differences. If the ON COMMIT clause is
omitted, SQL specifies that the default behavior is ON
COMMIT DELETE ROWS. However, the default behavior in
PostgreSQL is ON COMMIT PRESERVE ROWS. The ON COMMIT DROP
option does not exist in SQL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Non&minus;deferred
Uniqueness Constraints</b> <br>
When a UNIQUE or PRIMARY KEY constraint is not deferrable,
PostgreSQL checks for uniqueness immediately whenever a row
is inserted or modified. The SQL standard says that
uniqueness should be enforced only at the end of the
statement; this makes a difference when, for example, a
single command updates multiple key values. To obtain
standard&minus;compliant behavior, declare the constraint as
DEFERRABLE but not deferred (i.e., INITIALLY IMMEDIATE). Be
aware that this can be significantly slower than immediate
uniqueness checking.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Column Check
Constraints</b> <br>
The SQL standard says that CHECK column constraints can only
refer to the column they apply to; only CHECK table
constraints can refer to multiple columns. PostgreSQL does
not enforce this restriction; it treats column and table
check constraints alike.</p>

<p style="margin-left:11%; margin-top: 1em"><b>EXCLUDE
Constraint</b> <br>
The EXCLUDE constraint type is a PostgreSQL extension.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NULL
&ldquo;Constraint&rdquo;</b> <br>
The NULL &ldquo;constraint&rdquo; (actually a
non&minus;constraint) is a PostgreSQL extension to the SQL
standard that is included for compatibility with some other
database systems (and for symmetry with the NOT NULL
constraint). Since it is the default for any column, its
presence is simply noise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Inheritance</b>
<br>
Multiple inheritance via the INHERITS clause is a PostgreSQL
language extension. SQL:1999 and later define single
inheritance using a different syntax and different
semantics. SQL:1999&minus;style inheritance is not yet
supported by PostgreSQL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Zero&minus;column
Tables</b> <br>
PostgreSQL allows a table of no columns to be created (for
example, CREATE TABLE foo();). This is an extension from the
SQL standard, which does not allow zero&minus;column tables.
Zero&minus;column tables are not in themselves very useful,
but disallowing them creates odd special cases for <b>ALTER
TABLE DROP COLUMN</b>, so it seems cleaner to ignore this
spec restriction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>WITH
Clause</b> <br>
The WITH clause is a PostgreSQL extension; neither storage
parameters nor OIDs are in the standard.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Tablespaces</b>
<br>
The PostgreSQL concept of tablespaces is not part of the
standard. Hence, the clauses TABLESPACE and USING INDEX
TABLESPACE are extensions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Typed
Tables</b> <br>
Typed tables implement a subset of the SQL standard.
According to the standard, a typed table has columns
corresponding to the underlying composite type as well as
one other column that is the &ldquo;self&minus;referencing
column&rdquo;. PostgreSQL does not support these
self&minus;referencing columns explicitly, but the same
effect can be had using the OID feature.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ALTER TABLE
(<b>ALTER_TABLE</b>(7)), DROP TABLE (<b>DROP_TABLE</b>(7)),
CREATE TABLESPACE (<b>CREATE_TABLESPACE</b>(7)), CREATE TYPE
(<b>CREATE_TYPE</b>(7))</p>
<hr>
</body>
</html>
