<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:05:27 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LVM</title>

</head>
<body>

<h1 align="center">LVM</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#BUILT-IN COMMANDS">BUILT-IN COMMANDS</a><br>
<a href="#COMMANDS">COMMANDS</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#VALID NAMES">VALID NAMES</a><br>
<a href="#ALLOCATION">ALLOCATION</a><br>
<a href="#LOGICAL VOLUME TYPES">LOGICAL VOLUME TYPES</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvm &minus;
LVM2 tools</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>lvm</b>
[command | file]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvm provides
the command-line tools for LVM2. A separate manual page
describes each command in detail.</p>

<p style="margin-left:11%; margin-top: 1em">If <b>lvm</b>
is invoked with no arguments it presents a readline prompt
(assuming it was compiled with readline support). LVM
commands may be entered interactively at this prompt with
readline facilities including history and command name and
option completion. Refer to <b>readline</b>(3) for
details.</p>

<p style="margin-left:11%; margin-top: 1em">If <b>lvm</b>
is invoked with argv[0] set to the name of a specific LVM
command (for example by using a hard or soft link) it acts
as that command.</p>

<p style="margin-left:11%; margin-top: 1em">On invocation,
<b>lvm</b> requires that only the standard file descriptors
stdin, stdout and stderr are available. If others are found,
they get closed and messages are issued warning about the
leak. This warning can be suppressed by setting the
environment variable <b>LVM_SUPPRESS_FD_WARNINGS</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Where commands
take VG or LV names as arguments, the full path name is
optional. An LV called &quot;lvol0&quot; in a VG called
&quot;vg0&quot; can be specified as &quot;vg0/lvol0&quot;.
Where a list of VGs is required but is left empty, a list of
all VGs will be substituted. Where a list of LVs is required
but a VG is given, a list of all the LVs in that VG will be
substituted. So <b>lvdisplay vg0</b> will display all the
LVs in &quot;vg0&quot;. Tags can also be used - see
<b>&minus;&minus;addtag</b> below.</p>

<p style="margin-left:11%; margin-top: 1em">One advantage
of using the built-in shell is that configuration
information gets cached internally between commands.</p>

<p style="margin-left:11%; margin-top: 1em">A file
containing a simple script with one command per line can
also be given on the command line. The script can also be
executed directly if the first line is #! followed by the
absolute path of <b>lvm</b>.</p>

<h2>BUILT-IN COMMANDS
<a name="BUILT-IN COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
commands are built into lvm without links normally being
created in the filesystem for them. <b><br>
dumpconfig</b> &mdash; Display the configuration information
after</p>

<p style="margin-left:22%;">loading <b>lvm.conf</b>(5) and
any other configuration files.</p>

<p style="margin-left:11%;"><b>devtypes</b> &mdash; Display
the recognised built-in block device types. <b><br>
formats</b> &mdash; Display recognised metadata formats.
<b><br>
help</b> &mdash; Display the help text. <b><br>
pvdata</b> &mdash; Not implemented in LVM2. <b><br>
segtypes</b> &mdash; Display recognised Logical Volume
segment types. <b><br>
tags</b> &mdash; Display any tags defined on this host.
<b><br>
version</b> &mdash; Display version information.</p>

<h2>COMMANDS
<a name="COMMANDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
commands implement the core LVM functionality. <b><br>
pvchange</b> &mdash; Change attributes of a Physical Volume.
<b><br>
pvck</b> &mdash; Check Physical Volume metadata. <b><br>
pvcreate</b> &mdash; Initialize a disk or partition for use
by LVM. <b><br>
pvdisplay</b> &mdash; Display attributes of a Physical
Volume. <b><br>
pvmove</b> &mdash; Move Physical Extents. <b><br>
pvremove</b> &mdash; Remove a Physical Volume. <b><br>
pvresize</b> &mdash; Resize a disk or partition in use by
LVM2. <b><br>
pvs</b> &mdash; Report information about Physical Volumes.
<b><br>
pvscan</b> &mdash; Scan all disks for Physical Volumes.
<b><br>
vgcfgbackup</b> &mdash; Backup Volume Group descriptor area.
<b><br>
vgcfgrestore</b> &mdash; Restore Volume Group descriptor
area. <b><br>
vgchange</b> &mdash; Change attributes of a Volume Group.
<b><br>
vgck</b> &mdash; Check Volume Group metadata. <b><br>
vgconvert</b> &mdash; Convert Volume Group metadata format.
<b><br>
vgcreate</b> &mdash; Create a Volume Group. <b><br>
vgdisplay</b> &mdash; Display attributes of Volume Groups.
<b><br>
vgexport</b> &mdash; Make volume Groups unknown to the
system. <b><br>
vgextend</b> &mdash; Add Physical Volumes to a Volume Group.
<b><br>
vgimport</b> &mdash; Make exported Volume Groups known to
the system. <b><br>
vgimportclone</b> &mdash; Import and rename duplicated
Volume Group (e.g. a <br>
hardware snapshot). <b><br>
vgmerge</b> &mdash; Merge two Volume Groups. <b><br>
vgmknodes</b> &mdash; Recreate Volume Group directory and
Logical Volume special <br>
files <b><br>
vgreduce</b> &mdash; Reduce a Volume Group by removing one
or more</p>

<p style="margin-left:22%;">Physical Volumes.</p>

<p style="margin-left:11%;"><b>vgremove</b> &mdash; Remove
a Volume Group. <b><br>
vgrename</b> &mdash; Rename a Volume Group. <b><br>
vgs</b> &mdash; Report information about Volume Groups.
<b><br>
vgscan</b> &mdash; Scan all disks for Volume Groups and
rebuild caches. <b><br>
vgsplit</b> &mdash; Split a Volume Group into two, moving
any logical</p>

<p style="margin-left:22%;">volumes from one Volume Group
to another by moving entire Physical Volumes.</p>

<p style="margin-left:11%;"><b>lvchange</b> &mdash; Change
attributes of a Logical Volume. <b><br>
lvconvert</b> &mdash; Convert a Logical Volume from linear
to mirror or snapshot. <b><br>
lvcreate</b> &mdash; Create a Logical Volume in an existing
Volume Group. <b><br>
lvdisplay</b> &mdash; Display attributes of a Logical
Volume. <b><br>
lvextend</b> &mdash; Extend the size of a Logical Volume.
<b><br>
lvmchange</b> &mdash; Change attributes of the Logical
Volume Manager. <b><br>
lvmdiskscan</b> &mdash; Scan for all devices visible to
LVM2. <b><br>
lvmdump</b> &mdash; Create lvm2 information dumps for
diagnostic purposes. <b><br>
lvreduce</b> &mdash; Reduce the size of a Logical Volume.
<b><br>
lvremove</b> &mdash; Remove a Logical Volume. <b><br>
lvrename</b> &mdash; Rename a Logical Volume. <b><br>
lvresize</b> &mdash; Resize a Logical Volume. <b><br>
lvs</b> &mdash; Report information about Logical Volumes.
<b><br>
lvscan</b> &mdash; Scan (all disks) for Logical Volumes.
<br>
The following commands are not implemented in LVM2 but might
be in the <br>
future: lvmsadc, lvmsar, pvdata.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
options are available for many of the commands. They are
implemented generically and documented here rather than
repeated on individual manual pages. <b><br>
&minus;h</b>, <b>&minus;?</b>, <b>&minus;&minus;help</b></p>

<p style="margin-left:22%;">Display the help text.</p>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:22%;">Display version
information.</p>

<p style="margin-left:11%;"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:22%;">Set verbose level. Repeat from
1 to 3 times to increase the detail of messages sent to
stdout and stderr. Overrides config file setting.</p>

<p style="margin-left:11%;"><b>&minus;d</b>,
<b>&minus;&minus;debug</b></p>

<p style="margin-left:22%;">Set debug level. Repeat from 1
to 6 times to increase the detail of messages sent to the
log file and/or syslog (if configured). Overrides config
file setting.</p>

<p style="margin-left:11%;"><b>&minus;q</b>,
<b>&minus;&minus;quiet</b></p>

<p style="margin-left:22%;">Suppress output and log
messages. Overrides <b>&minus;d</b> and <b>&minus;v</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;yes</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Don&rsquo;t prompt for confirmation interactively but
instead always assume the answer is &rsquo;yes&rsquo;. Take
great care if you use this!</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;t</b>,
<b>&minus;&minus;test</b></p>

<p style="margin-left:22%;">Run in test mode. Commands will
not update metadata. This is implemented by disabling all
metadata writing but nevertheless returning success to the
calling function. This may lead to unusual error messages in
multi-stage operations if a tool relies on reading back
metadata it believes has changed but hasn&rsquo;t.</p>


<p style="margin-left:11%;"><b>&minus;&minus;driverloaded</b>
{<i>y</i>|<i>n</i>}</p>

<p style="margin-left:22%;">Whether or not the
device-mapper kernel driver is loaded. If you set this to
<i>n</i>, no attempt will be made to contact the driver.</p>

<p style="margin-left:11%;"><b>&minus;A</b>,
<b>&minus;&minus;autobackup</b> {<i>y</i>|<i>n</i>}</p>

<p style="margin-left:22%;">Whether or not to metadata
should be backed up automatically after a change. You are
strongly advised not to disable this! See
<b>vgcfgbackup</b>(8).</p>

<p style="margin-left:11%;"><b>&minus;P</b>,
<b>&minus;&minus;partial</b></p>

<p style="margin-left:22%;">When set, the tools will do
their best to provide access to Volume Groups that are only
partially available (one or more Physical Volumes belonging
to the Volume Group are missing from the system). Where part
of a logical volume is missing, <b>/dev/ioerror</b> will be
substituted, and you could use <b>dmsetup</b>(8) to set this
up to return I/O errors when accessed, or create it as a
large block device of nulls. Metadata may not be changed
with this option. To insert a replacement Physical Volume of
the same or large size use <b>pvcreate &minus;u</b> to set
the uuid to match the original followed by
<b>vgcfgrestore</b>(8).</p>

<p style="margin-left:11%;"><b>&minus;M</b>,
<b>&minus;&minus;metadatatype</b> <i>Type</i></p>

<p style="margin-left:22%;">Specifies which type of on-disk
metadata to use, such as <i>lvm1</i> or <i>lvm2</i>, which
can be abbreviated to <i>1</i> or <i>2</i> respectively. The
default (<i>lvm2</i>) can be changed by setting
<b>format</b> in the <b>global</b> section of the config
file.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ignorelockingfailure</b></p>

<p style="margin-left:22%;">This lets you proceed with
read-only metadata operations such as <b>lvchange
&minus;ay</b> and <b>vgchange &minus;ay</b> even if the
locking module fails. One use for this is in a system init
script if the lock directory is mounted read-only when the
script runs.</p>


<p style="margin-left:11%;"><b>&minus;&minus;ignoreskippedcluster</b></p>

<p style="margin-left:22%;">Use to avoid exiting with an
non-zero status code if the command is run without clustered
locking and some clustered Volume Groups have to be skipped
over.</p>

<p style="margin-left:11%;"><b>&minus;&minus;addtag</b>
<i>Tag</i></p>

<p style="margin-left:22%;">Add the tag <i>Tag</i> to a PV,
VG or LV. Supply this argument multiple times to add more
than one tag at once. A tag is a word that can be used to
group LVM2 objects of the same type together. Tags can be
given on the command line in place of PV, VG or LV
arguments. Tags should be prefixed with @ to avoid
ambiguity. Each tag is expanded by replacing it with all
objects possessing that tag which are of the type expected
by its position on the command line. PVs can only possess
tags while they are part of a Volume Group: PV tags are
discarded if the PV is removed from the VG. As an example,
you could tag some LVs as <b>database</b> and others as
<b>userdata</b> and then activate the database ones with
<b>lvchange &minus;ay @database</b>. Objects can possess
multiple tags simultaneously. Only the new LVM2 metadata
format supports tagging: objects using the LVM1 metadata
format cannot be tagged because the on-disk format does not
support it. Characters allowed in tags are: <b>A-Z a-z 0-9 _
+ . -</b> and as of version 2.02.78 the following characters
are also accepted: <b>/ = ! : # &amp;</b></p>

<p style="margin-left:11%;"><b>&minus;&minus;deltag</b>
<i>Tag</i></p>

<p style="margin-left:22%;">Delete the tag <i>Tag</i> from
a PV, VG or LV, if it&rsquo;s present. Supply this argument
multiple times to remove more than one tag at once.</p>


<p style="margin-left:11%;"><b>&minus;&minus;alloc&nbsp;</b>{<i>anywhere</i>|<i>contiguous</i>|<i>cling</i>|<i>inherit</i>|<i>normal</i>}</p>

<p style="margin-left:22%;">Selects the allocation policy
when a command needs to allocate Physical Extents from the
Volume Group. Each Volume Group and Logical Volume has an
allocation policy defined. The default for a Volume Group is
<i>normal</i> which applies common-sense rules such as not
placing parallel stripes on the same Physical Volume. The
default for a Logical Volume is <i>inherit</i> which applies
the same policy as for the Volume Group. These policies can
be changed using <b>lvchange</b>(8) and <b>vgchange</b>(8)
or overridden on the command line of any command that
performs allocation. The <i>contiguous</i> policy requires
that new Physical Extents be placed adjacent to existing
Physical Extents. The <i>cling</i> policy places new
Physical Extents on the same Physical Volume as existing
Physical Extents in the same stripe of the Logical Volume.
If there are sufficient free Physical Extents to satisfy an
allocation request but <i>normal</i> doesn&rsquo;t use them,
<i>anywhere</i> will - even if that reduces performance by
placing two stripes on the same Physical Volume.</p>


<p style="margin-left:11%;"><b>&minus;&minus;profile&nbsp;</b>ProfileName</p>

<p style="margin-left:22%;">Selects the configuration
profile to use when processing an LVM command. In addition
to that, when creating a Volume Group or a Logical Volume,
it causes the ProfileName to be stored in metadata for each
Volume Group or Logical Volume. If the profile is stored in
metadata, it is automatically applied next time the Volume
Group or the Logical Volume is processed and the use of
--profile is not necessary when running LVM commands
further. See also <b>lvm.conf</b>(5) for more information
about <b>profile config</b> and the way it fits with other
LVM configuration methods.</p>


<p style="margin-left:11%;"><b>&minus;&minus;config&nbsp;</b>ConfigurationString</p>

<p style="margin-left:22%;">Uses the ConfigurationString as
direct string representation of the configuration to
override the existing configuration. The ConfigurationString
is of exactly the same format as used in any LVM
configuration file. See <b>lvm.conf</b>(5) for more
information about <b>direct config override on command
line</b> and the way it fits with other LVM configuration
methods.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>HOME</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Directory containing
<i>.lvm_history</i> if the internal readline shell is
invoked.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>LVM_SYSTEM_DIR</b></p>

<p style="margin-left:22%;">Directory containing
<b>lvm.conf</b>(5) and other LVM system files. Defaults to
&quot;/etc/lvm&quot;.</p>


<p style="margin-left:11%;"><b>LVM_SUPPRESS_FD_WARNINGS</b></p>

<p style="margin-left:22%;">Suppress warnings about openned
file descriptors, when lvm command is executed.</p>

<p style="margin-left:11%;"><b>LVM_VG_NAME</b></p>

<p style="margin-left:22%;">The Volume Group name that is
assumed for any reference to a Logical Volume that
doesn&rsquo;t specify a path. Not set by default.</p>

<p style="margin-left:11%;"><b>LVM_LVMETAD_PIDFILE</b></p>

<p style="margin-left:22%;">Path for the lvmetad pid
file.</p>

<p style="margin-left:11%;"><b>LVM_LVMETAD_SOCKET</b></p>

<p style="margin-left:22%;">Path for the lvmetad socket
file.</p>

<h2>VALID NAMES
<a name="VALID NAMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
characters are valid for VG and LV names: <b>a-z A-Z 0-9 + _
. -</b></p>

<p style="margin-left:11%; margin-top: 1em">VG and LV names
cannot begin with a hyphen. There are also various reserved
names that are used internally by lvm that can not be used
as LV or VG names. A VG cannot be called anything that
exists in /dev/ at the time of creation, nor can it be
called &rsquo;.&rsquo; or &rsquo;..&rsquo;. A LV cannot be
called &rsquo;.&rsquo; &rsquo;..&rsquo;
&rsquo;snapshot&rsquo; or &rsquo;pvmove&rsquo;. The LV name
may also not contain the strings &rsquo;_mlog&rsquo;,
&rsquo;_mimage&rsquo;, &rsquo;_rimage&rsquo;,
&rsquo;_tdata&rsquo;, &rsquo;_tmeta&rsquo;.</p>

<h2>ALLOCATION
<a name="ALLOCATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When an
operation needs to allocate Physical Extents for one or more
Logical Volumes, the tools proceed as follows:</p>

<p style="margin-left:11%; margin-top: 1em">First of all,
they generate the complete set of unallocated Physical
Extents in the Volume Group. If any ranges of Physical
Extents are supplied at the end of the command line, only
unallocated Physical Extents within those ranges on the
specified Physical Volumes are considered.</p>

<p style="margin-left:11%; margin-top: 1em">Then they try
each allocation policy in turn, starting with the strictest
policy (<i>contiguous</i>) and ending with the allocation
policy specified using <b>&minus;&minus;alloc</b> or set as
the default for the particular Logical Volume or Volume
Group concerned. For each policy, working from the
lowest-numbered Logical Extent of the empty Logical Volume
space that needs to be filled, they allocate as much space
as possible according to the restrictions imposed by the
policy. If more space is needed, they move on to the next
policy.</p>

<p style="margin-left:11%; margin-top: 1em">The
restrictions are as follows:</p>


<p style="margin-left:11%; margin-top: 1em"><i>Contiguous</i>
requires that the physical location of any Logical Extent
that is not the first Logical Extent of a Logical Volume is
adjacent to the physical location of the Logical Extent
immediately preceding it.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Cling</i>
requires that the Physical Volume used for any Logical
Extent to be added to an existing Logical Volume is already
in use by at least one Logical Extent earlier in that
Logical Volume. If the configuration parameter
allocation/cling_tag_list is defined, then two Physical
Volumes are considered to match if any of the listed tags is
present on both Physical Volumes. This allows groups of
Physical Volumes with similar properties (such as their
physical location) to be tagged and treated as equivalent
for allocation purposes.</p>

<p style="margin-left:11%; margin-top: 1em">When a Logical
Volume is striped or mirrored, the above restrictions are
applied independently to each stripe or mirror image (leg)
that needs space.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Normal</i>
will not choose a Physical Extent that shares the same
Physical Volume as a Logical Extent already allocated to a
parallel Logical Volume (i.e. a different stripe or mirror
image/leg) at the same offset within that parallel Logical
Volume.</p>

<p style="margin-left:11%; margin-top: 1em">When allocating
a mirror log at the same time as Logical Volumes to hold the
mirror data, Normal will first try to select different
Physical Volumes for the log and the data. If that&rsquo;s
not possible and the
allocation/mirror_logs_require_separate_pvs configuration
parameter is set to 0, it will then allow the log to share
Physical Volume(s) with part of the data.</p>

<p style="margin-left:11%; margin-top: 1em">When allocating
thin pool metadata, similar considerations to those of a
mirror log in the last paragraph apply based on the value of
the allocation/thin_pool_metadata_require_separate_pvs
configuration parameter.</p>

<p style="margin-left:11%; margin-top: 1em">If you rely
upon any layout behaviour beyond that documented here, be
aware that it might change in future versions of the
code.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
you supply on the command line two empty Physical Volumes
that have an identical number of free Physical Extents
available for allocation, the current code considers using
each of them in the order they are listed, but there is no
guarantee that future releases will maintain that property.
If it is important to obtain a specific layout for a
particular Logical Volume, then you should build it up
through a sequence of <b>lvcreate</b>(8) and
<b>lvconvert</b>(8) steps such that the restrictions
described above applied to each step leave the tools no
discretion over the layout.</p>

<p style="margin-left:11%; margin-top: 1em">To view the way
the allocation process currently works in any specific case,
read the debug logging output, for example by adding
<b>&minus;vvvv</b> to a command.</p>

<h2>LOGICAL VOLUME TYPES
<a name="LOGICAL VOLUME TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some logical
volume types are simple to create and can be done with a
single <b>lvcreate</b>(8) command. The linear and striped
logical volume types are an example of this. Other logical
volume types may require more than one command to create.
The cache and thin provisioning types are examples of
this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache</b>
<br>
The <i>cache</i> logical volume type uses a small and fast
LV to improve the performance of a large and slow LV. It
does this by storing the frequently used blocks on the
faster LV. LVM refers to the small fast LV as a <b>cache
pool LV</b>. The large slow LV is called the <b>origin
LV</b>. Due to requirements from dm-cache (the kernel
driver), LVM further splits the cache pool LV into two
devices - the <b>cache data LV</b> and <b>cache metadata
LV</b>. The cache data LV is where copies of data blocks are
kept from the origin LV to increase speed. The cache
metadata LV holds the accounting information that specifies
where data blocks are stored (e.g. on the origin LV or on
the cache data LV). Users should be familiar with these LVs
if they wish to create the best and most robust cached
logical volumes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache
Terms</b> <br>
origin LV OriginLV large slow LV <br>
cache data LV CacheDataLV small fast LV for cache pool data
<br>
cache metadata LV CacheMetaLV small fast LV for cache pool
metadata <br>
cache pool LV CachePoolLV CacheDataLV + CacheMetaLV <br>
cache LV CacheLV OriginLV + CachePoolLV</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache
Steps</b> <br>
The steps to create a logical volume of <i>cache</i> type
are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>0.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Create an LV or identify an existing LV to be the origin
LV.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Create the cache data LV. The size of this LV is the
size of the cache and will be reported as the size of the
cache pool LV.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Create the cache metadata LV. The size of this LV should
be 1000 times smaller than the cache data LV with a minimum
size of 8MiB.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Create the cache pool LV by combining the cache data LV
(from step 1) and cache metadata LV (from step 2). When
performing this step, behavioral characteristics of the
cache pool LV can be set. The name of the cache pool LV
takes the name of the cache data LV and the cache data LV
and cache metadata LV are renamed to CachePoolLV_cdata and
CachePoolLV_cmeta.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Create a cache LV by linking the cache pool LV to the
origin LV. The user accessible cache LV takes the name of
the origin LV, while the origin LV becomes a hidden LV with
the name OriginLV_corig. Users can perform this step while
the origin LV is in use.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The steps above
represent the best way to create a cache LV. They provide
the most options and have the ability to create the most
robust logical volumes. The examples below illustrate how
these steps might be used in practice.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache
Commands</b> <br>
0. create OriginLV <br>
lvcreate -L LargeSize -n OriginLV VG SlowPVs</p>

<p style="margin-left:11%; margin-top: 1em">1. create
CacheDataLV <br>
lvcreate -L CacheSize -n CacheDataLV VG FastPVs</p>

<p style="margin-left:11%; margin-top: 1em">2. create
CacheMetaLV <br>
lvcreate -L MetaSize -n CacheMetaLV VG FastPVs</p>

<p style="margin-left:11%; margin-top: 1em">3. create
CachePoolLV <br>
lvconvert --type cache-pool --poolmetadata VG/CacheMetaLV
VG/CacheDataLV <br>
CachePoolLV takes the name of CacheDataLV. <br>
CacheDataLV is renamed CachePoolLV_cdata and becomes hidden.
<br>
CacheMetaLV is renamed CachePoolLV_cmeta and becomes
hidden.</p>

<p style="margin-left:11%; margin-top: 1em">4. create
CacheLV <br>
lvconvert --type cache --cachepool VG/CachePoolLV
VG/OriginLV <br>
CacheLV takes the name of OriginLV. <br>
OriginLV is renamed OriginLV_corig and becomes hidden.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cache
Examples <br>
Example 1:</b> Creating a simple cache LV.</p>

<p style="margin-left:11%; margin-top: 1em">0. Create the
origin LV <br>
# lvcreate -L 10G -n lvx vg /dev/slow_dev</p>

<p style="margin-left:11%; margin-top: 1em">1. Create a
cache data LV <br>
# lvcreate -L 1G -n lvx_cache vg /dev/fast_dev</p>

<p style="margin-left:11%; margin-top: 1em">2. Create a
cache metadata LV (~1/1000th size of CacheDataLV or 8MiB)
<br>
# lvcreate -L 8M -n lvx_cache_meta vg /dev/fast_dev</p>

<p style="margin-left:11%; margin-top: 1em">3. Create a
cache pool LV, combining cache data LV and cache metadata LV
<br>
# lvconvert --type cache-pool --poolmetadata
vg/lvx_cache_meta \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>vg/lvx_cache</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">4. Create a
cached LV by combining the cache pool LV and origin LV <br>
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
2:</b> Creating a cache LV with a fault tolerant cache pool
LV.</p>

<p style="margin-left:11%; margin-top: 1em">Users who are
concerned about the possibility of failures in their fast
devices that could lead to data loss might consider making
their cache pool sub-LVs redundant. Example 2 illustrates
how to do that. Note that only steps 1 &amp; 2 change.</p>

<p style="margin-left:11%; margin-top: 1em">0. Create an
origin LV we wish to cache <br>
# lvcreate -L 10G -n lvx vg /dev/slow_devs</p>

<p style="margin-left:11%; margin-top: 1em">1. Create a
2-way RAID1 cache data LV <br>
# lvcreate --type raid1 -m 1 -L 1G -n lvx_cache vg \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/dev/fast1 /dev/fast2</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">2. Create a
2-way RAID1 cache metadata LV <br>
# lvcreate --type raid1 -m 1 -L 8M -n lvx_cache_meta vg
\</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/dev/fast1 /dev/fast2</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">3. Create a
cache pool LV combining cache data LV and cache metadata LV
<br>
# lvconvert --type cache-pool --poolmetadata
vg/lvx_cache_meta \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>vg/lvx_cache</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">4. Create a
cached LV by combining the cache pool LV and origin LV <br>
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
3:</b> Creating a simple cache LV with <i>writethough</i>
caching.</p>

<p style="margin-left:11%; margin-top: 1em">Some users wish
to ensure that any data written will be stored both in the
cache pool LV and on the origin LV. The loss of a device
associated with the cache pool LV in this case would not
mean the loss of any data. When combining the cache data LV
and the cache metadata LV to form the cache pool LV,
properties of the cache can be specified - in this case,
<i>writethrough</i> vs. <i>writeback</i>. Note that only
step 3 is affected in this case.</p>

<p style="margin-left:11%; margin-top: 1em">0. Create an
origin LV we wish to cache (yours may already exist) <br>
# lvcreate -L 10G -n lvx vg /dev/slow</p>

<p style="margin-left:11%; margin-top: 1em">1. Create a
cache data LV <br>
# lvcreate -L 1G -n lvx_cache vg /dev/fast</p>

<p style="margin-left:11%; margin-top: 1em">2. Create a
cache metadata LV <br>
# lvcreate -L 8M -n lvx_cache_meta vg /dev/fast</p>

<p style="margin-left:11%; margin-top: 1em">3. Create a
cache pool LV specifying cache mode &quot;writethrough&quot;
<br>
# lvconvert --type cache-pool --poolmetadata
vg/lvx_cache_meta \</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>--cachemode writethrough vg/lvx_cache</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">4. Create a
cache LV by combining the cache pool LV and origin LV <br>
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx</p>

<p style="margin-left:11%; margin-top: 1em"><b>Removing
Cache Logical Volumes</b> <br>
If you wish to remove all logical volumes associated with a
cache LV, you must remove both top-level, user-visible
devices. The cache metadata LV and cache data LV cannot be
removed directly. If only the cache pool LV is specfied for
removal, any cached blocks not yet on the origin LV will be
flush, the cache pool LV will be removed, and the now
un-cached origin LV will remain. If the user specifies a
cache LV for removal, then the origin LV is removed and only
the cache pool LV will remain. The cache pool LV can then be
used to create another cache LV with a different origin LV
if desired.</p>

<p style="margin-left:11%; margin-top: 1em">When users
intend to remove all logical volumes associated with a cache
LV, it is generally better to start with the origin LV and
then remove the cache pool LV. If the operations are
performed in the reverse order, the user will have to wait
for the contents of the cache pool LV to be flushed before
the origin LV is removed. This could take some time.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All tools
return a status code of zero on success or non-zero on
failure.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/etc/lvm/lvm.conf
<br>
$HOME/.lvm_history</i></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>lvm.conf</b></i>(5),
<b>clvmd</b>(8), <b>lvchange</b>(8), <b>lvcreate</b>(8),
<b>lvdisplay</b>(8), <b>lvextend</b>(8),
<b>lvmchange</b>(8), <b>lvmdiskscan</b>(8),
<b>lvreduce</b>(8), <b>lvremove</b>(8), <b>lvrename</b>(8),
<b>lvresize</b>(8), <b>lvs</b>(8), <b>lvscan</b>(8),
<b>pvchange</b>(8), <b>pvck</b>(8), <b>pvcreate</b>(8),
<b>pvdisplay</b>(8), <b>pvmove</b>(8), <b>pvremove</b>(8),
<b>pvs</b>(8), <b>pvscan</b>(8), <b>vgcfgbackup</b>(8),
<b>vgchange</b>(8), <b>vgck</b>(8), <b>vgconvert</b>(8),
<b>vgcreate</b>(8), <b>vgdisplay</b>(8), <b>vgextend</b>(8),
<b>vgimport</b>(8), <b>vgimportclone</b>(8),
<b>vgmerge</b>(8), <b>vgmknodes</b>(8), <b>vgreduce</b>(8),
<b>vgremove</b>(8), <b>vgrename</b>(8), <b>vgs</b>(8),
<b>vgscan</b>(8), <b>vgsplit</b>(8), <b>readline</b>(3)</p>
<hr>
</body>
</html>
