<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:05:33 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>lwptut</title>

</head>
<body>

<h1 align="center">lwptut</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lwptut
&minus;&minus; An LWP Tutorial</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>LWP</small>
(short for &quot;Library for <small>WWW</small> in
Perl&quot;) is a very popular group of Perl modules for
accessing data on the Web. Like most Perl
module-distributions, each of <small>LWP</small> &rsquo;s
component modules comes with documentation that is a
complete reference to its interface. However, there are so
many modules in <small>LWP</small> that it&rsquo;s hard to
know where to start looking for information on how to do
even the simplest most common things.</p>

<p style="margin-left:11%; margin-top: 1em">Really
introducing you to using <small>LWP</small> would require a
whole book -- a book that just happens to exist, called
<i>Perl &amp; <small>LWP</small></i> . But this article
should give you a taste of how you can go about some common
tasks with <small>LWP.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Getting
documents with LWP::Simple</b> <br>
If you just want to get what&rsquo;s at a particular
<small>URL,</small> the simplest way to do it is
LWP::Simple&rsquo;s functions.</p>

<p style="margin-left:11%; margin-top: 1em">In a Perl
program, you can call its <tt>&quot;get($url)&quot;</tt>
function. It will try getting that <small>URL</small>
&rsquo;s content. If it works, then it&rsquo;ll return the
content; but if there&rsquo;s some error, it&rsquo;ll return
undef.</p>

<pre style="margin-left:11%; margin-top: 1em">  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
    # Just an example: the URL for the most recent /Fresh Air/ show
  use LWP::Simple;
  my $content = get $url;
  die &quot;Couldn't get $url&quot; unless defined $content;
  # Then go do things with $content, like this:
  if($content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The handiest
variant on <tt>&quot;get&quot;</tt> is
<tt>&quot;getprint&quot;</tt>, which is useful in Perl
one-liners. If it can get the page whose <small>URL</small>
you provide, it sends it to <small>STDOUT</small> ;
otherwise it complains to <small>STDERR.</small></p>

<pre style="margin-left:11%; margin-top: 1em">  % perl &minus;MLWP::Simple &minus;e &quot;getprint 'http://www.cpan.org/RECENT'&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">That is the
<small>URL</small> of a plain text file that lists new files
in <small>CPAN</small> in the past two weeks. You can easily
make it part of a tidy little shell command, like this one
that mails you the list of new <tt>&quot;Acme::&quot;</tt>
modules:</p>

<pre style="margin-left:11%; margin-top: 1em">  % perl &minus;MLWP::Simple &minus;e &quot;getprint 'http://www.cpan.org/RECENT'&quot;  \
     | grep &quot;/by&minus;module/Acme&quot; | mail &minus;s &quot;New Acme modules! Joy!&quot; $USER</pre>


<p style="margin-left:11%; margin-top: 1em">There are other
useful functions in LWP::Simple, including one function for
running a <small>HEAD</small> request on a
<small>URL</small> (useful for checking links, or getting
the last-revised time of a <small>URL</small> ), and two
functions for saving/mirroring a <small>URL</small> to a
local file. See the LWP::Simple documentation for the full
details, or chapter 2 of <i>Perl &amp;
<small>LWP</small></i> for more examples.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Basics
of the <small>LWP</small> Class Model</b> <br>
LWP::Simple&rsquo;s functions are handy for simple cases,
but its functions don&rsquo;t support cookies or
authorization, don&rsquo;t support setting header lines in
the <small>HTTP</small> request, generally don&rsquo;t
support reading header lines in the <small>HTTP</small>
response (notably the full <small>HTTP</small> error
message, in case of an error). To get at all those features,
you&rsquo;ll have to use the full <small>LWP</small> class
model.</p>

<p style="margin-left:11%; margin-top: 1em">While
<small>LWP</small> consists of dozens of classes, the main
two that you have to understand are LWP::UserAgent and
HTTP::Response. LWP::UserAgent is a class for &quot;virtual
browsers&quot; which you use for performing requests, and
HTTP::Response is a class for the responses (or error
messages) that you get back from those requests.</p>

<p style="margin-left:11%; margin-top: 1em">The basic idiom
is <tt>&quot;$response =
$browser&minus;&gt;get($url)&quot;</tt>, or more fully
illustrated:</p>

<pre style="margin-left:11%; margin-top: 1em">  # Early in your program:
  use LWP 5.64; # Loads all important LWP classes, and makes
                #  sure your version is reasonably recent.
  my $browser = LWP::UserAgent&minus;&gt;new;
  ...
  # Then later, whenever you need to make a get request:
  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
  my $response = $browser&minus;&gt;get( $url );
  die &quot;Can't get $url &minus;&minus; &quot;, $response&minus;&gt;status_line
   unless $response&minus;&gt;is_success;
  die &quot;Hey, I was expecting HTML, not &quot;, $response&minus;&gt;content_type
   unless $response&minus;&gt;content_type eq 'text/html';
     # or whatever content&minus;type you're equipped to deal with
  # Otherwise, process the content somehow:
  if($response&minus;&gt;decoded_content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">There are two
objects involved: <tt>$browser</tt>, which holds an object
of class LWP::UserAgent, and then the <tt>$response</tt>
object, which is of class HTTP::Response. You really need
only one browser object per program; but every time you make
a request, you get back a new HTTP::Response object, which
will have some interesting attributes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A status code indicating success or failure (which you
can test with
<tt>&quot;$response&minus;&gt;is_success&quot;</tt>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>An <small>HTTP</small> status line that is hopefully
informative if there&rsquo;s failure (which you can see with
<tt>&quot;$response&minus;&gt;status_line&quot;</tt>,
returning something like &quot;404 Not Found&quot;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A <small>MIME</small> content-type like
&quot;text/html&quot;, &quot;image/gif&quot;,
&quot;application/xml&quot;, etc., which you can see with
<tt>&quot;$response&minus;&gt;content_type&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The actual content of the response, in
<tt>&quot;$response&minus;&gt;decoded_content&quot;</tt>. If
the response is <small>HTML,</small> that&rsquo;s where the
<small>HTML</small> source will be; if it&rsquo;s a
<small>GIF,</small> then
<tt>&quot;$response&minus;&gt;decoded_content&quot;</tt>
will be the binary <small>GIF</small> data.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>And dozens of other convenient and more specific methods
that are documented in the docs for HTTP::Response, and its
superclasses HTTP::Message and HTTP::Headers.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Adding Other
<small>HTTP</small> Request Headers</b> <br>
The most commonly used syntax for requests is
<tt>&quot;$response =
$browser&minus;&gt;get($url)&quot;</tt>, but in truth, you
can add extra <small>HTTP</small> header lines to the
request by adding a list of key-value pairs after the
<small>URL,</small> like so:</p>

<pre style="margin-left:11%; margin-top: 1em">  $response = $browser&minus;&gt;get( $url, $key1, $value1, $key2, $value2, ... );</pre>


<p style="margin-left:11%; margin-top: 1em">For example,
here&rsquo;s how to send some more Netscape-like headers, in
case you&rsquo;re dealing with a site that would otherwise
reject your request:</p>

<pre style="margin-left:11%; margin-top: 1em">  my @ns_headers = (
   'User&minus;Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x&minus;xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept&minus;Charset' =&gt; 'iso&minus;8859&minus;1,*,utf&minus;8',
   'Accept&minus;Language' =&gt; 'en&minus;US',
  );
  ...
  $response = $browser&minus;&gt;get($url, @ns_headers);</pre>


<p style="margin-left:11%; margin-top: 1em">If you
weren&rsquo;t reusing that array, you could just go ahead
and do this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $response = $browser&minus;&gt;get($url,
   'User&minus;Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x&minus;xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept&minus;Charset' =&gt; 'iso&minus;8859&minus;1,*,utf&minus;8',
   'Accept&minus;Language' =&gt; 'en&minus;US',
  );</pre>


<p style="margin-left:11%; margin-top: 1em">If you were
only ever changing the &rsquo;User&minus;Agent&rsquo; line,
you could just change the <tt>$browser</tt> object&rsquo;s
default line from &quot;libwww&minus;perl/5.65&quot; (or the
like) to whatever you like, using the LWP::UserAgent
<tt>&quot;agent&quot;</tt> method:</p>

<pre style="margin-left:11%; margin-top: 1em">   $browser&minus;&gt;agent('Mozilla/4.76 [en] (Win98; U)');</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Enabling
Cookies</b> <br>
A default LWP::UserAgent object acts like a browser with its
cookies support turned off. There are various ways of
turning it on, by setting its
<tt>&quot;cookie_jar&quot;</tt> attribute. A &quot;cookie
jar&quot; is an object representing a little database of all
the <small>HTTP</small> cookies that a browser can know
about. It can correspond to a file on disk (the way Netscape
uses its <i>cookies.txt</i> file), or it can be just an
in-memory object that starts out empty, and whose collection
of cookies will disappear once the program is finished
running.</p>

<p style="margin-left:11%; margin-top: 1em">To give a
browser an in-memory empty cookie jar, you set its
<tt>&quot;cookie_jar&quot;</tt> attribute like so:</p>

<pre style="margin-left:11%; margin-top: 1em">  $browser&minus;&gt;cookie_jar({});</pre>


<p style="margin-left:11%; margin-top: 1em">To give it a
copy that will be read from a file on disk, and will be
saved to it when the program is finished running, set the
<tt>&quot;cookie_jar&quot;</tt> attribute like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTTP::Cookies;
  $browser&minus;&gt;cookie_jar( HTTP::Cookies&minus;&gt;new(
    'file' =&gt; '/some/where/cookies.lwp',
        # where to read/write cookies
    'autosave' =&gt; 1,
        # save it to disk when done
  ));</pre>


<p style="margin-left:11%; margin-top: 1em">That file will
be an LWP-specific format. If you want to be access the
cookies in your Netscape cookies file, you can use the
HTTP::Cookies::Netscape class:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTTP::Cookies;
    # yes, loads HTTP::Cookies::Netscape too
  $browser&minus;&gt;cookie_jar( HTTP::Cookies::Netscape&minus;&gt;new(
    'file' =&gt; 'c:/Program Files/Netscape/Users/DIR&minus;NAME&minus;HERE/cookies.txt',
        # where to read cookies
  ));</pre>


<p style="margin-left:11%; margin-top: 1em">You could add
an <tt>&quot;'autosave' =&gt; 1&quot;</tt> line as further
above, but at time of writing, it&rsquo;s uncertain whether
Netscape might discard some of the cookies you could be
writing back to disk.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Posting Form
Data</b> <br>
Many <small>HTML</small> forms send data to their server
using an <small>HTTP POST</small> request, which you can
send with this syntax:</p>

<pre style="margin-left:11%; margin-top: 1em"> $response = $browser&minus;&gt;post( $url,
   [
     formkey1 =&gt; value1,
     formkey2 =&gt; value2,
     ...
   ],
 );</pre>


<p style="margin-left:11%; margin-top: 1em">Or if you need
to send <small>HTTP</small> headers:</p>

<pre style="margin-left:11%; margin-top: 1em"> $response = $browser&minus;&gt;post( $url,
   [
     formkey1 =&gt; value1,
     formkey2 =&gt; value2,
     ...
   ],
   headerkey1 =&gt; value1,
   headerkey2 =&gt; value2,
 );</pre>


<p style="margin-left:11%; margin-top: 1em">For example,
the following program makes a search request to AltaVista
(by sending some form data via an <small>HTTP POST</small>
request), and extracts from the <small>HTML</small> the
report of the number of matches:</p>

<pre style="margin-left:11%; margin-top: 1em">  use strict;
  use warnings;
  use LWP 5.64;
  my $browser = LWP::UserAgent&minus;&gt;new;
  my $word = 'tarragon';
  my $url = 'http://search.yahoo.com/yhs/search';
  my $response = $browser&minus;&gt;post( $url,
    [ 'q' =&gt; $word,  # the Altavista query string
      'fr' =&gt; 'altavista', 'pg' =&gt; 'q', 'avkw' =&gt; 'tgz', 'kl' =&gt; 'XX',
    ]
  );
  die &quot;$url error: &quot;, $response&minus;&gt;status_line
   unless $response&minus;&gt;is_success;
  die &quot;Weird content type at $url &minus;&minus; &quot;, $response&minus;&gt;content_type
   unless $response&minus;&gt;content_is_html;
  if( $response&minus;&gt;decoded_content =~ m{([0&minus;9,]+)(?:&lt;.*?&gt;)? results for} ) {
    # The substring will be like &quot;996,000&lt;/strong&gt; results for&quot;
    print &quot;$word: $1\n&quot;;
  }
  else {
    print &quot;Couldn't find the match&minus;string in the response\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Sending
<small>GET</small> Form Data</b> <br>
Some <small>HTML</small> forms convey their form data not by
sending the data in an <small>HTTP POST</small> request, but
by making a normal <small>GET</small> request with the data
stuck on the end of the <small>URL.</small> For example, if
you went to <tt>&quot;www.imdb.com&quot;</tt> and ran a
search on &quot;Blade Runner&quot;, the <small>URL</small>
you&rsquo;d see in your browser window would be:</p>

<pre style="margin-left:11%; margin-top: 1em">  http://www.imdb.com/find?s=all&amp;q=Blade+Runner</pre>


<p style="margin-left:11%; margin-top: 1em">To run the same
search with <small>LWP,</small> you&rsquo;d use this idiom,
which involves the <small>URI</small> class:</p>

<pre style="margin-left:11%; margin-top: 1em">  use URI;
  my $url = URI&minus;&gt;new( 'http://www.imdb.com/find' );
    # makes an object representing the URL
  $url&minus;&gt;query_form(  # And here the form data pairs:
    'q' =&gt; 'Blade Runner',
    's' =&gt; 'all',
  );
  my $response = $browser&minus;&gt;get($url);</pre>


<p style="margin-left:11%; margin-top: 1em">See chapter 5
of <i>Perl &amp; <small>LWP</small></i> for a longer
discussion of <small>HTML</small> forms and of form data,
and chapters 6 through 9 for a longer discussion of
extracting data from <small>HTML.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>Absolutizing
URLs</b> <br>
The <small>URI</small> class that we just mentioned above
provides all sorts of methods for accessing and modifying
parts of URLs (such as asking sort of <small>URL</small> it
is with <tt>&quot;$url&minus;&gt;scheme&quot;</tt>, and
asking what host it refers to with
<tt>&quot;$url&minus;&gt;host&quot;</tt>, and so on, as
described in the docs for the <small>URI</small> class.
However, the methods of most immediate interest are the
<tt>&quot;query_form&quot;</tt> method seen above, and now
the <tt>&quot;new_abs&quot;</tt> method for taking a
probably-relative <small>URL</small> string (like
&quot;../foo.html&quot;) and getting back an absolute
<small>URL</small> (like
&quot;http://www.perl.com/stuff/foo.html&quot;), as shown
here:</p>

<pre style="margin-left:11%; margin-top: 1em">  use URI;
  $abs = URI&minus;&gt;new_abs($maybe_relative, $base);</pre>


<p style="margin-left:11%; margin-top: 1em">For example,
consider this program that matches URLs in the
<small>HTML</small> list of new modules in
<small>CPAN:</small></p>

<pre style="margin-left:11%; margin-top: 1em">  use strict;
  use warnings;
  use LWP;
  my $browser = LWP::UserAgent&minus;&gt;new;
  my $url = 'http://www.cpan.org/RECENT.html';
  my $response = $browser&minus;&gt;get($url);
  die &quot;Can't get $url &minus;&minus; &quot;, $response&minus;&gt;status_line
   unless $response&minus;&gt;is_success;
  my $html = $response&minus;&gt;decoded_content;
  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print &quot;$1\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">When run, it
emits output that starts out something like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  MIRRORING.FROM
  RECENT
  RECENT.html
  authors/00whois.html
  authors/01mailrc.txt.gz
  authors/id/A/AA/AASSAD/CHECKSUMS
  ...</pre>


<p style="margin-left:11%; margin-top: 1em">However, if you
actually want to have those be absolute URLs, you can use
the <small>URI</small> module&rsquo;s
<tt>&quot;new_abs&quot;</tt> method, by changing the
<tt>&quot;while&quot;</tt> loop to this:</p>

<pre style="margin-left:11%; margin-top: 1em">  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print URI&minus;&gt;new_abs( $1, $response&minus;&gt;base ) ,&quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">(The
<tt>&quot;$response&minus;&gt;base&quot;</tt> method from
HTTP::Message is for returning what <small>URL</small>
should be used for resolving relative URLs -- it&rsquo;s
usually just the same as the <small>URL</small> that you
requested.)</p>

<p style="margin-left:11%; margin-top: 1em">That program
then emits nicely absolute URLs:</p>

<pre style="margin-left:11%; margin-top: 1em">  http://www.cpan.org/MIRRORING.FROM
  http://www.cpan.org/RECENT
  http://www.cpan.org/RECENT.html
  http://www.cpan.org/authors/00whois.html
  http://www.cpan.org/authors/01mailrc.txt.gz
  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
  ...</pre>


<p style="margin-left:11%; margin-top: 1em">See chapter 4
of <i>Perl &amp; <small>LWP</small></i> for a longer
discussion of <small>URI</small> objects.</p>

<p style="margin-left:11%; margin-top: 1em">Of course,
using a regexp to match hrefs is a bit simplistic, and for
more robust programs, you&rsquo;ll probably want to use an
HTML-parsing module like HTML::LinkExtor or HTML::TokeParser
or even maybe HTML::TreeBuilder.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
Browser Attributes</b> <br>
LWP::UserAgent objects have many attributes for controlling
how they work. Here are a few notable ones:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">



<p style="margin-top: 1em"><tt>&quot;$browser&minus;&gt;timeout(15);&quot;</tt></p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This sets this
browser object to give up on requests that don&rsquo;t
answer within 15 seconds.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="81%">



<p style="margin-top: 1em"><tt>&quot;$browser&minus;&gt;protocols_allowed(
[ 'http', 'gopher'] );&quot;</tt></p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This sets this
browser object to not speak any protocols other than
<small>HTTP</small> and gopher. If it tries accessing any
other kind of <small>URL</small> (like an &quot;ftp:&quot;
or &quot;mailto:&quot; or &quot;news:&quot;
<small>URL</small> ), then it won&rsquo;t actually try
connecting, but instead will immediately return an error
code 500, with a message like &quot;Access to
&rsquo;ftp&rsquo; URIs has been disabled&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><tt>&quot;use LWP::ConnCache;
$browser&minus;&gt;conn_cache(LWP::ConnCache&minus;&gt;new());&quot;</tt></p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This tells the
browser object to try using the <small>HTTP/1.1</small>
&quot;Keep-Alive&quot; feature, which speeds up requests by
reusing the same socket connection for multiple requests to
the same server.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">



<p style="margin-top: 1em"><tt>&quot;$browser&minus;&gt;agent(
'SomeName/1.23 (more info here maybe)' )&quot;</tt></p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This changes
how the browser object will identify itself in the default
&quot;User-Agent&quot; line is its <small>HTTP</small>
requests. By default, it&rsquo;ll send
&quot;libwww&minus;perl/<i>versionnumber</i>&quot;, like
&quot;libwww&minus;perl/5.65&quot;. You can change that to
something more descriptive like this:</p>

<pre style="margin-left:17%; margin-top: 1em">  $browser&minus;&gt;agent( 'SomeName/3.14 (contact@robotplexus.int)' );</pre>


<p style="margin-left:17%; margin-top: 1em">Or if need be,
you can go in disguise, like this:</p>

<pre style="margin-left:17%; margin-top: 1em">  $browser&minus;&gt;agent( 'Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)' );</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p style="margin-top: 1em"><tt>&quot;push @{
$ua&minus;&gt;requests_redirectable },
'POST';&quot;</tt></p> </td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This tells this
browser to obey redirection responses to <small>POST</small>
requests (like most modern interactive browsers), even
though the <small>HTTP RFC</small> says that should not
normally be done.</p>

<p style="margin-left:11%; margin-top: 1em">For more
options and information, see the full documentation for
LWP::UserAgent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing
Polite Robots</b> <br>
If you want to make sure that your LWP-based program
respects <i>robots.txt</i> files and doesn&rsquo;t make too
many requests too fast, you can use the LWP::RobotUA class
instead of the LWP::UserAgent class.</p>

<p style="margin-left:11%; margin-top: 1em">LWP::RobotUA
class is just like LWP::UserAgent, and you can use it like
so:</p>

<pre style="margin-left:11%; margin-top: 1em">  use LWP::RobotUA;
  my $browser = LWP::RobotUA&minus;&gt;new('YourSuperBot/1.34', 'you@yoursite.com');
    # Your bot's name and your email address
  my $response = $browser&minus;&gt;get($url);</pre>


<p style="margin-left:11%; margin-top: 1em">But
HTTP::RobotUA adds these features:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If the <i>robots.txt</i> on
<tt>$url</tt>&rsquo;s server forbids you from accessing
<tt>$url</tt>, then the <tt>$browser</tt> object (assuming
it&rsquo;s of class LWP::RobotUA) won&rsquo;t actually
request it, but instead will give you back (in
<tt>$response</tt>) a 403 error with a message
&quot;Forbidden by robots.txt&quot;. That is, if you have
this line:</p></td></tr>
</table>

<pre style="margin-left:17%; margin-top: 1em">  die &quot;$url &minus;&minus; &quot;, $response&minus;&gt;status_line, &quot;\nAborted&quot;
   unless $response&minus;&gt;is_success;</pre>


<p style="margin-left:17%; margin-top: 1em">then the
program would die with an error message like this:</p>

<pre style="margin-left:17%; margin-top: 1em">  http://whatever.site.int/pith/x.html &minus;&minus; 403 Forbidden by robots.txt
  Aborted at whateverprogram.pl line 1234</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If this <tt>$browser</tt> object
sees that the last time it talked to <tt>$url</tt>&rsquo;s
server was too recently, then it will pause (via
<tt>&quot;sleep&quot;</tt>) to avoid making too many
requests too often. How long it will pause for, is by
default one minute -- but you can control it with the
<tt>&quot;$browser&minus;&gt;delay(</tt> <i>minutes</i>
<tt>)&quot;</tt> attribute.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
this code:</p>

<pre style="margin-left:17%; margin-top: 1em">  $browser&minus;&gt;delay( 7/60 );</pre>


<p style="margin-left:17%; margin-top: 1em">...means that
this browser will pause when it needs to avoid talking to
any given server more than once every 7 seconds.</p>

<p style="margin-left:11%; margin-top: 1em">For more
options and information, see the full documentation for
LWP::RobotUA.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
Proxies</b> <br>
In some cases, you will want to (or will have to) use
proxies for accessing certain sites and/or using certain
protocols. This is most commonly the case when your
<small>LWP</small> program is running (or could be running)
on a machine that is behind a firewall.</p>

<p style="margin-left:11%; margin-top: 1em">To make a
browser object use proxies that are defined in the usual
environment variables (<tt>&quot;HTTP_PROXY&quot;</tt>,
etc.), just call the <tt>&quot;env_proxy&quot;</tt> on a
user-agent object before you go making any requests on it.
Specifically:</p>

<pre style="margin-left:11%; margin-top: 1em">  use LWP::UserAgent;
  my $browser = LWP::UserAgent&minus;&gt;new;
  # And before you go making any requests:
  $browser&minus;&gt;env_proxy;</pre>


<p style="margin-left:11%; margin-top: 1em">For more
information on proxy parameters, see the LWP::UserAgent
documentation, specifically the <tt>&quot;proxy&quot;</tt>,
<tt>&quot;env_proxy&quot;</tt>, and
<tt>&quot;no_proxy&quot;</tt> methods.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>HTTP</small>
Authentication</b> <br>
Many web sites restrict access to documents by using &quot;
<small>HTTP</small> Authentication&quot;. This isn&rsquo;t
just any form of &quot;enter your password&quot;
restriction, but is a specific mechanism where the
<small>HTTP</small> server sends the browser an
<small>HTTP</small> code that says &quot;That document is
part of a protected &rsquo;realm&rsquo;, and you can access
it only if you re-request it and add some special
authorization headers to your request&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the Unicode.org admins stop email-harvesting bots from
harvesting the contents of their mailing list archives, by
protecting them with <small>HTTP</small> Authentication, and
then publicly stating the username and password (at
<tt>&quot;http://www.unicode.org/mail&minus;arch/&quot;</tt>)
-- namely username &quot;unicode-ml&quot; and password
&quot;unicode&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
consider this <small>URL,</small> which is part of the
protected area of the web site:</p>

<pre style="margin-left:11%; margin-top: 1em">  http://www.unicode.org/mail&minus;arch/unicode&minus;ml/y2002&minus;m08/0067.html</pre>


<p style="margin-left:11%; margin-top: 1em">If you access
that with a browser, you&rsquo;ll get a prompt like
&quot;Enter username and password for
&rsquo;Unicode&minus;MailList&minus;Archives&rsquo; at
server &rsquo;www.unicode.org&rsquo;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In
<small>LWP,</small> if you just request that
<small>URL,</small> like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  use LWP;
  my $browser = LWP::UserAgent&minus;&gt;new;
  my $url =
   'http://www.unicode.org/mail&minus;arch/unicode&minus;ml/y2002&minus;m08/0067.html';
  my $response = $browser&minus;&gt;get($url);
  die &quot;Error: &quot;, $response&minus;&gt;header('WWW&minus;Authenticate') || 'Error accessing',
    #  ('WWW&minus;Authenticate' is the realm&minus;name)
    &quot;\n &quot;, $response&minus;&gt;status_line, &quot;\n at $url\n Aborting&quot;
   unless $response&minus;&gt;is_success;</pre>


<p style="margin-left:11%; margin-top: 1em">Then
you&rsquo;ll get this error:</p>

<pre style="margin-left:11%; margin-top: 1em">  Error: Basic realm=&quot;Unicode&minus;MailList&minus;Archives&quot;
   401 Authorization Required
   at http://www.unicode.org/mail&minus;arch/unicode&minus;ml/y2002&minus;m08/0067.html
   Aborting at auth1.pl line 9.  [or wherever]</pre>


<p style="margin-left:11%; margin-top: 1em">...because the
<tt>$browser</tt> doesn&rsquo;t know any the username and
password for that realm
(&quot;Unicode-MailList-Archives&quot;) at that host
(&quot;www.unicode.org&quot;). The simplest way to let the
browser know about this is to use the
<tt>&quot;credentials&quot;</tt> method to let it know about
a username and password that it can try using for that realm
at that host. The syntax is:</p>

<pre style="margin-left:11%; margin-top: 1em">  $browser&minus;&gt;credentials(
    'servername:portnumber',
    'realm&minus;name',
   'username' =&gt; 'password'
  );</pre>


<p style="margin-left:11%; margin-top: 1em">In most cases,
the port number is 80, the default <small>TCP/IP</small>
port for <small>HTTP</small> ; and you usually call the
<tt>&quot;credentials&quot;</tt> method before you make any
requests. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $browser&minus;&gt;credentials(
    'reports.mybazouki.com:80',
    'web_server_usage_reports',
    'plinky' =&gt; 'banjo123'
  );</pre>


<p style="margin-left:11%; margin-top: 1em">So if we add
the following to the program above, right after the
<tt>&quot;$browser =
LWP::UserAgent&minus;&gt;new;&quot;</tt> line...</p>

<pre style="margin-left:11%; margin-top: 1em">  $browser&minus;&gt;credentials(  # add this to our $browser 's &quot;key ring&quot;
    'www.unicode.org:80',
    'Unicode&minus;MailList&minus;Archives',
    'unicode&minus;ml' =&gt; 'unicode'
  );</pre>


<p style="margin-left:11%; margin-top: 1em">...then when we
run it, the request succeeds, instead of causing the
<tt>&quot;die&quot;</tt> to be called.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Accessing
<small>HTTPS</small> URLs</b> <br>
When you access an <small>HTTPS URL,</small> it&rsquo;ll
work for you just like an <small>HTTP URL</small> would --
if your <small>LWP</small> installation has
<small>HTTPS</small> support (via an appropriate Secure
Sockets Layer library). For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  use LWP;
  my $url = 'https://www.paypal.com/';   # Yes, HTTPS!
  my $browser = LWP::UserAgent&minus;&gt;new;
  my $response = $browser&minus;&gt;get($url);
  die &quot;Error at $url\n &quot;, $response&minus;&gt;status_line, &quot;\n Aborting&quot;
   unless $response&minus;&gt;is_success;
  print &quot;Whee, it worked!  I got that &quot;,
   $response&minus;&gt;content_type, &quot; document!\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">If your
<small>LWP</small> installation doesn&rsquo;t have
<small>HTTPS</small> support set up, then the response will
be unsuccessful, and you&rsquo;ll get this error
message:</p>

<pre style="margin-left:11%; margin-top: 1em">  Error at https://www.paypal.com/
   501 Protocol scheme 'https' is not supported
   Aborting at paypal.pl line 7.   [or whatever program and line]</pre>


<p style="margin-left:11%; margin-top: 1em">If your
<small>LWP</small> installation <i>does</i> have
<small>HTTPS</small> support installed, then the response
should be successful, and you should be able to consult
<tt>$response</tt> just like with any normal
<small>HTTP</small> response.</p>

<p style="margin-left:11%; margin-top: 1em">For information
about installing <small>HTTPS</small> support for your
<small>LWP</small> installation, see the helpful
<i><small>README.SSL</small></i> file that comes in the
libwww-perl distribution.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Getting
Large Documents</b> <br>
When you&rsquo;re requesting a large (or at least
potentially large) document, a problem with the normal way
of using the request methods (like <tt>&quot;$response =
$browser&minus;&gt;get($url)&quot;</tt>) is that the
response object in memory will have to hold the whole
document -- <i>in memory</i>. If the response is a thirty
megabyte file, this is likely to be quite an imposition on
this process&rsquo;s memory usage.</p>

<p style="margin-left:11%; margin-top: 1em">A notable
alternative is to have <small>LWP</small> save the content
to a file on disk, instead of saving it up in memory. This
is the syntax to use:</p>

<pre style="margin-left:11%; margin-top: 1em">  $response = $ua&minus;&gt;get($url,
                         ':content_file' =&gt; $filespec,
                      );</pre>


<p style="margin-left:11%; margin-top: 1em">For
example,</p>

<pre style="margin-left:11%; margin-top: 1em">  $response = $ua&minus;&gt;get('http://search.cpan.org/',
                         ':content_file' =&gt; '/tmp/sco.html'
                      );</pre>


<p style="margin-left:11%; margin-top: 1em">When you use
this <tt>&quot;:content_file&quot;</tt> option, the
<tt>$response</tt> will have all the normal header lines,
but <tt>&quot;$response&minus;&gt;content&quot;</tt> will be
empty.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
&quot;:content_file&quot; option isn&rsquo;t supported under
older versions of <small>LWP,</small> so you should consider
adding <tt>&quot;use LWP 5.66;&quot;</tt> to check the
<small>LWP</small> version, if you think your program might
run on systems with older versions.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
be compatible with older <small>LWP</small> versions, then
use this syntax, which does the same thing:</p>

<pre style="margin-left:11%; margin-top: 1em">  use HTTP::Request::Common;
  $response = $ua&minus;&gt;request( GET($url), $filespec );</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Remember, this
article is just the most rudimentary introduction to
<small>LWP</small> -- to learn more about <small>LWP</small>
and LWP-related tasks, you really must read from the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">LWP::Simple -- simple functions
for getting/heading/mirroring URLs</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><small>LWP</small> -- overview of the libwww-perl
modules</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>LWP::UserAgent -- the class for objects that represent
&quot;virtual browsers&quot;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>HTTP::Response -- the class for objects that represent
the response to a <small>LWP</small> response, as in
<tt>&quot;$response =
$browser&minus;&gt;get(...)&quot;</tt></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>HTTP::Message and HTTP::Headers -- classes that provide
more methods to HTTP::Response.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><small>URI</small> -- class for objects that represent
absolute or relative URLs</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>URI::Escape -- functions for URL-escaping and
URL-unescaping strings (like turning &quot;this &amp;
that&quot; to and from &quot;this%20%26%20that&quot;).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>HTML::Entities -- functions for HTML-escaping and
HTML-unescaping strings (like turning &quot;C. &amp; E.
Brontee&quot; to and from &quot;C. &amp;amp; E.
Bront&amp;euml;&quot;)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>HTML::TokeParser and HTML::TreeBuilder -- classes for
parsing <small>HTML</small></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>HTML::LinkExtor -- class for finding links in
<small>HTML</small> documents</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The book <i>Perl &amp; <small>LWP</small></i> by Sean M.
Burke. O&rsquo;Reilly &amp; Associates, 2002. <small>ISBN:
0&minus;596&minus;00178&minus;9,</small>
&lt;http://oreilly.com/catalog/perllwp/&gt;. The whole book
is also available free online:
&lt;http://lwp.interglacial.com&gt;.</p> </td></tr>
</table>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright 2002,
Sean M. Burke. You can redistribute this document and/or
modify it, but only under the same terms as Perl itself.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sean M. Burke
<tt>&quot;sburke@cpan.org&quot;</tt></p>
<hr>
</body>
</html>
