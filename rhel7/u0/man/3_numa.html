<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:09:25 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>NUMA</title>

</head>
<body>

<h1 align="center">NUMA</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#Compatibility with libnuma version 1">Compatibility with libnuma version 1</a><br>
<a href="#THREAD SAFETY">THREAD SAFETY</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">numa &minus;
NUMA policy library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;numa.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>cc ...
&minus;lnuma</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_available(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_max_possible_node(void); <br>
int numa_num_possible_nodes();</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_max_node(void); <br>
int numa_num_configured_nodes(); <br>
struct bitmask *numa_get_mems_allowed(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_num_configured_cpus(void); <br>
struct bitmask *numa_all_nodes_ptr; <br>
struct bitmask *numa_no_nodes_ptr; <br>
struct bitmask *numa_all_cpus_ptr;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_num_task_cpus(); <br>
int numa_num_task_nodes();</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_parse_bitmap(char *</b><i>line</i> <b>, struct bitmask
*</b><i>mask</i><b>); <br>
struct bitmask *numa_parse_nodestring(const char
*</b><i>string</i><b>); <br>
struct bitmask *numa_parse_nodestring_all(const char
*</b><i>string</i><b>); <br>
struct bitmask *numa_parse_cpustring(const char
*</b><i>string</i><b>); <br>
struct bitmask *numa_parse_cpustring_all(const char
*</b><i>string</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>long
numa_node_size(int</b> <i>node</i><b>, long
*</b><i>freep</i><b>); <br>
long long numa_node_size64(int</b> <i>node</i><b>, long long
*</b><i>freep</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_preferred(void); <br>
void numa_set_preferred(int</b> <i>node</i><b>); <br>
int numa_get_interleave_node(void); <br>
struct bitmask *numa_get_interleave_mask(void); <br>
void numa_set_interleave_mask(struct bitmask
*</b><i>nodemask</i><b>); <br>
void numa_interleave_memory(void *</b><i>start</i><b>,
size_t</b> <i>size</i><b>, struct bitmask
*</b><i>nodemask</i><b>); <br>
void numa_bind(struct bitmask *</b><i>nodemask</i><b>); <br>
void numa_set_localalloc(void); <br>
void numa_set_membind(struct bitmask
*</b><i>nodemask</i><b>); <br>
struct bitmask *numa_get_membind(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*numa_alloc_onnode(size_t</b> <i>size</i><b>, int</b>
<i>node</i><b>); <br>
void *numa_alloc_local(size_t</b> <i>size</i><b>); <br>
void *numa_alloc_interleaved(size_t</b> <i>size</i><b>);
<br>
void *numa_alloc_interleaved_subset(size_t</b>
<i>size</i><b>, struct bitmask *</b><i>nodemask</i><b>);
void *numa_alloc(size_t</b> <i>size</i><b>); <br>
void *numa_realloc(void *</b><i>old_addr</i><b>, size_t</b>
<i>old_size</i><b>, size_t</b> <i>new_size</i><b>); <br>
void numa_free(void *</b><i>start</i><b>, size_t</b>
<i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_run_on_node(int</b> <i>node</i><b>); <br>
int numa_run_on_node_mask(struct bitmask
*</b><i>nodemask</i><b>); <br>
int numa_run_on_node_mask_all(struct bitmask
*</b><i>nodemask</i><b>); <br>
struct bitmask *numa_get_run_node_mask(void);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
numa_tonode_memory(void *</b><i>start</i><b>, size_t</b>
<i>size</i><b>, int</b> <i>node</i><b>); <br>
void numa_tonodemask_memory(void *</b><i>start</i><b>,
size_t</b> <i>size</i><b>, struct bitmask
*</b><i>nodemask</i><b>); <br>
void numa_setlocal_memory(void *</b><i>start</i><b>,
size_t</b> <i>size</i><b>); <br>
void numa_police_memory(void *</b><i>start</i><b>,
size_t</b> <i>size</i><b>); <br>
void numa_set_bind_policy(int</b> <i>strict</i><b>); <br>
void numa_set_strict(int</b> <i>strict</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_distance(int</b> <i>node1</i><b>, int</b>
<i>node2</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_sched_getaffinity(pid_t</b> <i>pid</i><b>, struct
bitmask *</b><i>mask</i><b>); <br>
int numa_sched_setaffinity(pid_t</b> <i>pid</i><b>, struct
bitmask *</b><i>mask</i><b>); <br>
int numa_node_to_cpus(int</b> <i>node</i><b>, struct bitmask
*</b><i>mask</i><b>); <br>
int numa_node_of_cpu(int</b> <i>cpu</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>struct
bitmask *numa_allocate_cpumask();</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
numa_free_cpumask(); <br>
struct bitmask *numa_allocate_nodemask();</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
numa_free_nodemask(); <br>
struct bitmask *numa_bitmask_alloc(unsigned int</b>
<i>n</i><b>); <br>
struct bitmask *numa_bitmask_clearall(struct bitmask
*</b><i>bmp</i><b>); <br>
struct bitmask *numa_bitmask_clearbit(struct bitmask
*</b><i>bmp</i><b>, unsigned int</b> <i>n</i><b>); <br>
int numa_bitmask_equal(const struct bitmask
*</b><i>bmp1</i><b>, const struct bitmask
*</b><i>bmp2</i><b>); <br>
void numa_bitmask_free(struct bitmask *</b><i>bmp</i><b>);
<br>
int numa_bitmask_isbitset(const struct bitmask
*</b><i>bmp</i><b>, unsigned int</b> <i>n</i><b>); <br>
unsigned int numa_bitmask_nbytes(struct bitmask
*</b><i>bmp</i><b>); <br>
struct bitmask *numa_bitmask_setall(struct bitmask
*</b><i>bmp</i><b>); <br>
struct bitmask *numa_bitmask_setbit(struct bitmask
*</b><i>bmp</i><b>, unsigned int</b> <i>n</i><b>); <br>
void copy_bitmask_to_nodemask(struct bitmask
*</b><i>bmp</i><b>, nodemask_t *</b><i>nodemask</i><b>) <br>
void copy_nodemask_to_bitmask(nodemask_t
*</b><i>nodemask</i><b>, struct bitmask *</b><i>bmp</i><b>)
<br>
void copy_bitmask_to_bitmask(struct bitmask
*</b><i>bmpfrom</i><b>, struct bitmask *</b><i>bmpto</i><b>)
<br>
unsigned int numa_bitmask_weight(const struct bitmask *bmp
)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
numa_move_pages(int</b> <i>pid</i><b>, unsigned long</b>
<i>count</i><b>, void **</b><i>pages</i><b>, const int
*</b><i>nodes</i><b>, int *</b><i>status</i><b>, int</b>
<i>flags</i><b>); <br>
int numa_migrate_pages(int</b> <i>pid</i><b>, struct bitmask
*</b><i>fromnodes</i><b>, struct bitmask
*</b><i>tonodes</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
numa_error(char *</b><i>where</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>extern
int</b> <i>numa_exit_on_error</i><b>; <br>
extern int</b> <i>numa_exit_on_warn</i><b>; <br>
void numa_warn(int</b> <i>number</i><b>, char
*</b><i>where</i><b>, ...);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>libnuma</i> library offers a simple programming interface
to the NUMA (Non Uniform Memory Access) policy supported by
the Linux kernel. On a NUMA architecture some memory areas
have different latency or bandwidth than others.</p>

<p style="margin-left:11%; margin-top: 1em">Available
policies are page interleaving (i.e., allocate in a
round-robin fashion from all, or a subset, of the nodes on
the system), preferred node allocation (i.e., preferably
allocate on a particular node), local allocation (i.e.,
allocate on the node on which the task is currently
executing), or allocation only on specific nodes (i.e.,
allocate on some subset of the available nodes). It is also
possible to bind tasks to specific nodes.</p>

<p style="margin-left:11%; margin-top: 1em">Numa memory
allocation policy may be specified as a per-task attribute,
that is inherited by children tasks and processes, or as an
attribute of a range of process virtual address space. Numa
memory policies specified for a range of virtual address
space are shared by all tasks in the process. Further more,
memory policies specified for a range of a shared memory
attached using <i>shmat(2)</i> or <i>mmap(2)</i> from
shmfs/hugetlbfs are shared by all processes that attach to
that region. Memory policies for shared disk backed file
mappings are currently ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The default
memory allocation policy for tasks and all memory range is
local allocation. This assumes that no ancestor has
installed a non-default policy.</p>

<p style="margin-left:11%; margin-top: 1em">For setting a
specific policy globally for all memory allocations in a
process and its children it is easiest to start it with the
<b>numactl</b>(8) utility. For more finegrained policy
inside an application this library can be used.</p>

<p style="margin-left:11%; margin-top: 1em">All numa memory
allocation policy only takes effect when a page is actually
faulted into the address space of a process by accessing it.
The <b>numa_alloc_*</b> functions take care of this
automatically.</p>

<p style="margin-left:11%; margin-top: 1em">A <i>node</i>
is defined as an area where all memory has the same speed as
seen from a particular CPU. A node can contain multiple
CPUs. Caches are ignored for this definition.</p>

<p style="margin-left:11%; margin-top: 1em">Most functions
in this library are only concerned about numa nodes and
their memory. The exceptions to this are:
<i>numa_node_to_cpus</i>(), <i>numa_node_of_cpu</i>(),
<i>numa_bind</i>(), <i>numa_run_on_node</i>(),
<i>numa_run_on_node_mask</i>(),
<i>numa_run_on_node_mask_all</i>(), and
<i>numa_get_run_node_mask</i>(). These functions deal with
the CPUs associated with numa nodes. See the descriptions
below for more information.</p>

<p style="margin-left:11%; margin-top: 1em">Some of these
functions accept or return a pointer to struct bitmask. A
struct bitmask controls a bit map of arbitrary length
containing a bit representation of nodes. The predefined
variable <i>numa_all_nodes_ptr</i> points to a bit mask that
has all available nodes set; <i>numa_no_nodes_ptr</i> points
to the empty set.</p>

<p style="margin-left:11%; margin-top: 1em">Before any
other calls in this library can be used
<b>numa_available</b>() must be called. If it returns
&minus;1, all other functions in this library are
undefined.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_max_possible_node()</b>
returns the number of the highest possible node in a system.
In other words, the size of a kernel type nodemask_t (in
bits) minus 1. This number can be gotten by calling
<b>numa_num_possible_nodes()</b> and subtracting 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_num_possible_nodes()</b>
returns the size of kernel&rsquo;s node mask (kernel type
nodemask_t). In other words, large enough to represent the
maximum number of nodes that the kernel can handle. This
will match the kernel&rsquo;s MAX_NUMNODES value. This count
is derived from /proc/self/status, field Mems_allowed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_max_node</b>()
returns the highest node number available on the current
system. (See the node numbers in /sys/devices/system/node/
). Also see <b>numa_num_configured_nodes().</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_num_configured_nodes()</b>
returns the number of memory nodes in the system. This count
includes any nodes that are currently disabled. This count
is derived from the node numbers in
/sys/devices/system/node. (Depends on the kernel being
configured with /sys (CONFIG_SYSFS)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_get_mems_allowed()</b>
returns the mask of nodes from which the process is allowed
to allocate memory in it&rsquo;s current cpuset context. Any
nodes that are not included in the returned bitmask will be
ignored in any of the following libnuma memory policy
calls.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_num_configured_cpus()</b>
returns the number of cpus in the system. This count
includes any cpus that are currently disabled. This count is
derived from the cpu numbers in /sys/devices/system/cpu. If
the kernel is configured without /sys (CONFIG_SYSFS=n) then
it falls back to using the number of online cpus.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_all_nodes_ptr</b>
points to a bitmask that is allocated by the library with
bits representing all nodes on which the calling task may
allocate memory. This set may be up to all nodes on the
system, or up to the nodes in the current cpuset. The
bitmask is allocated by a call to
<b>numa_allocate_nodemask()</b> using size
<b>numa_max_possible_node().</b> The set of nodes to record
is derived from /proc/self/status, field
&quot;Mems_allowed&quot;. The user should not alter this
bitmask.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_no_nodes_ptr</b>
points to a bitmask that is allocated by the library and
left all zeroes. The bitmask is allocated by a call to
<b>numa_allocate_nodemask()</b> using size
<b>numa_max_possible_node().</b> The user should not alter
this bitmask.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_all_cpus_ptr</b>
points to a bitmask that is allocated by the library with
bits representing all cpus on which the calling task may
execute. This set may be up to all cpus on the system, or up
to the cpus in the current cpuset. The bitmask is allocated
by a call to <b>numa_allocate_cpumask()</b> using size
<b>numa_num_possible_cpus().</b> The set of cpus to record
is derived from /proc/self/status, field
&quot;Cpus_allowed&quot;. The user should not alter this
bitmask.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_num_task_cpus()</b>
returns the number of cpus that the calling task is allowed
to use. This count is derived from the map
/proc/self/status, field &quot;Cpus_allowed&quot;. Also see
the bitmask <b>numa_all_cpus_ptr.</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_num_task_nodes()</b>
returns the number of nodes on which the calling task is
allowed to allocate memory. This count is derived from the
map /proc/self/status, field &quot;Mems_allowed&quot;. Also
see the bitmask <b>numa_all_nodes_ptr.</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_parse_bitmap()</b>
parses <i>line</i> , which is a character string such as
found in /sys/devices/system/node/nodeN/cpumap into a
bitmask structure. The string contains the hexadecimal
representation of a bit map. The bitmask may be allocated
with <b>numa_allocate_cpumask().</b> Returns 0 on success.
Returns -1 on failure. This function is probably of little
use to a user application, but it is used by <i>libnuma</i>
internally.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_parse_nodestring()</b>
parses a character string list of nodes into a bit mask. The
bit mask is allocated by <b>numa_allocate_nodemask().</b>
The string is a comma-separated list of node numbers or node
ranges. A leading ! can be used to indicate &quot;not&quot;
this list (in other words, all nodes except this list), and
a leading + can be used to indicate that the node numbers in
the list are relative to the task&rsquo;s cpuset. The string
can be &quot;all&quot; to specify all (
<b>numa_num_task_nodes()</b> ) nodes. Node numbers are
limited by the number in the system. See
<b>numa_max_node()</b> and
<b>numa_num_configured_nodes().</b> <br>
Examples: 1-5,7,10 !4-5 +0-3 <br>
If the string is of 0 length, bitmask
<b>numa_no_nodes_ptr</b> is returned. Returns 0 if the
string is invalid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_parse_nodestring_all()</b>
is similar to <b>numa_parse_nodestring</b> , but can parse
all possible nodes, not only current nodeset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_parse_cpustring()</b>
parses a character string list of cpus into a bit mask. The
bit mask is allocated by <b>numa_allocate_cpumask().</b> The
string is a comma-separated list of cpu numbers or cpu
ranges. A leading ! can be used to indicate &quot;not&quot;
this list (in other words, all cpus except this list), and a
leading + can be used to indicate that the cpu numbers in
the list are relative to the task&rsquo;s cpuset. The string
can be &quot;all&quot; to specify all (
<b>numa_num_task_cpus()</b> ) cpus. Cpu numbers are limited
by the number in the system. See <b>numa_num_task_cpus()</b>
and <b>numa_num_configured_cpus().</b> <br>
Examples: 1-5,7,10 !4-5 +0-3 <br>
Returns 0 if the string is invalid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_parse_cpustring_all()</b>
is similar to <b>numa_parse_cpustring</b> , but can parse
all possible cpus, not only current cpuset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_node_size</b>()
returns the memory size of a node. If the argument
<i>freep</i> is not NULL, it used to return the amount of
free memory on the node. On error it returns &minus;1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_node_size64</b>()
works the same as <b>numa_node_size</b>() except that it
returns values as <i>long long</i> instead of <i>long</i>.
This is useful on 32-bit architectures with large nodes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_preferred</b>()
returns the preferred node of the current task. This is the
node on which the kernel preferably allocates memory, unless
some other policy overrides this.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_preferred</b>()
sets the preferred node for the current task to <i>node</i>.
The system will attempt to allocate memory from the
preferred node, but will fall back to other nodes if no
memory is available on the the preferred node. Passing a
<i>node</i> of &minus;1 argument specifies local allocation
and is equivalent to calling
<b>numa_set_localalloc</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_get_interleave_mask</b>()
returns the current interleave mask if the task&rsquo;s
memory allocation policy is page interleaved. Otherwise,
this function returns an empty mask.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_interleave_mask</b>()
sets the memory interleave mask for the current task to
<i>nodemask</i>. All new memory allocations are page
interleaved over all nodes in the interleave mask.
Interleaving can be turned off again by passing an empty
mask (<i>numa_no_nodes</i>). The page interleaving only
occurs on the actual page fault that puts a new page into
the current address space. It is also only a hint: the
kernel will fall back to other nodes if no memory is
available on the interleave target.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_interleave_memory</b>()
interleaves <i>size</i> bytes of memory page by page from
<i>start</i> on nodes specified in <i>nodemask</i>. The
<i>size</i> argument will be rounded up to a multiple of the
system page size. If <i>nodemask</i> contains nodes that are
externally denied to this process, this call will fail. This
is a lower level function to interleave allocated but not
yet faulted in memory. Not yet faulted in means the memory
is allocated using <b>mmap</b>(2) or <b>shmat</b>(2), but
has not been accessed by the current process yet. The memory
is page interleaved to all nodes specified in
<i>nodemask</i>. Normally <b>numa_alloc_interleaved</b>()
should be used for private memory instead, but this function
is useful to handle shared memory areas. To be useful the
memory area should be several megabytes at least (or tens of
megabytes of hugetlbfs mappings) If the
<b>numa_set_strict</b>() flag is true then the operation
will cause a numa_error if there were already pages in the
mapping that do not follow the policy.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bind</b>()
binds the current task and its children to the nodes
specified in <i>nodemask</i>. They will only run on the CPUs
of the specified nodes and only be able to allocate memory
from them. This function is equivalent to calling
<i>numa_run_on_node_mask(nodemask)</i> followed by
<i>numa_set_membind(nodemask)</i>. If tasks should be bound
to individual CPUs inside nodes consider using
<i>numa_node_to_cpus</i> and the <i>sched_setaffinity(2)</i>
syscall.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_localalloc</b>()
sets the memory allocation policy for the calling task to
local allocation. In this mode, the preferred node for
memory allocation is effectively the node where the task is
executing at the time of a page allocation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_membind</b>()
sets the memory allocation mask. The task will only allocate
memory from the nodes set in <i>nodemask</i>. Passing an
empty <i>nodemask</i> or a <i>nodemask</i> that contains
nodes other than those in the mask returned by
<i>numa_get_mems_allowed</i>() will result in an error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_get_membind</b>()
returns the mask of nodes from which memory can currently be
allocated. If the returned mask is equal to
<i>numa_all_nodes</i>, then memory allocation is allowed
from all nodes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_alloc_onnode</b>()
allocates memory on a specific node. The <i>size</i>
argument will be rounded up to a multiple of the system page
size. if the specified <i>node</i> is externally denied to
this process, this call will fail. This function is
relatively slow compared to the <i>malloc</i>(3), family of
functions. The memory must be freed with <b>numa_free</b>().
On errors NULL is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_alloc_local</b>()
allocates <i>size</i> bytes of memory on the local node. The
<i>size</i> argument will be rounded up to a multiple of the
system page size. This function is relatively slow compared
to the <i>malloc</i>(3) family of functions. The memory must
be freed with <b>numa_free</b>(). On errors NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_alloc_interleaved</b>()
allocates <i>size</i> bytes of memory page interleaved on
all nodes. This function is relatively slow and should only
be used for large areas consisting of multiple pages. The
interleaving works at page level and will only show an
effect when the area is large. The allocated memory must be
freed with <b>numa_free</b>(). On error, NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_alloc_interleaved_subset</b>()
attempts to allocate <i>size</i> bytes of memory page
interleaved on all nodes. The <i>size</i> argument will be
rounded up to a multiple of the system page size. The nodes
on which a process is allowed to allocate memory may be
constrained externally. If this is the case, this function
may fail. This function is relatively slow compare to
<i>malloc</i>(3), family of functions and should only be
used for large areas consisting of multiple pages. The
interleaving works at page level and will only show an
effect when the area is large. The allocated memory must be
freed with <b>numa_free</b>(). On error, NULL is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_alloc</b>()
allocates <i>size</i> bytes of memory with the current NUMA
policy. The <i>size</i> argument will be rounded up to a
multiple of the system page size. This function is
relatively slow compare to the <i>malloc</i>(3) family of
functions. The memory must be freed with <b>numa_free</b>().
On errors NULL is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_realloc</b>()
changes the size of the memory area pointed to by
<i>old_addr</i> from <i>old_size</i> to <i>new_size.</i> The
memory area pointed to by <i>old_addr</i> must have been
allocated with one of the <b>numa_alloc*</b> functions. The
<i>new_size</i> will be rounded up to a multiple of the
system page size. The contents of the memory area will be
unchanged to the minimum of the old and new sizes; newly
allocated memory will be uninitialized. The memory policy
(and node bindings) associated with the original memory area
will be preserved in the resized area. For example, if the
initial area was allocated with a call to
<b>numa_alloc_onnode(),</b> then the new pages (if the area
is enlarged) will be allocated on the same node. However, if
no memory policy was set for the original area, then
<b>numa_realloc</b>() cannot guarantee that the new pages
will be allocated on the same node. On success, the address
of the resized area is returned (which might be different
from that of the initial area), otherwise NULL is returned
and <i>errno</i> is set to indicate the error. The pointer
returned by <b>numa_realloc</b>() is suitable for passing to
<b>numa_free</b>().</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_free</b>()
frees <i>size</i> bytes of memory starting at <i>start</i>,
allocated by the <b>numa_alloc_*</b> functions above. The
<i>size</i> argument will be rounded up to a multiple of the
system page size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_run_on_node</b>()
runs the current task and its children on a specific node.
They will not migrate to CPUs of other nodes until the node
affinity is reset with a new call to
<b>numa_run_on_node_mask</b>(). Passing &minus;1 permits the
kernel to schedule on all nodes again. On success, 0 is
returned; on error &minus;1 is returned, and <i>errno</i> is
set to indicate the error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_run_on_node_mask</b>()
runs the current task and its children only on nodes
specified in <i>nodemask</i>. They will not migrate to CPUs
of other nodes until the node affinity is reset with a new
call to <b>numa_run_on_node_mask</b>() or
<b>numa_run_on_node</b>(). Passing <i>numa_all_nodes</i>
permits the kernel to schedule on all nodes again. On
success, 0 is returned; on error &minus;1 is returned, and
<i>errno</i> is set to indicate the error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_run_on_node_mask_all</b>()
runs the current task and its children only on nodes
specified in <i>nodemask</i> like
<i>numa_run_on_node_mask</i> but without any cpuset
awareness.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_get_run_node_mask</b>()
returns a mask of CPUs on which the current task is allowed
to run.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_tonode_memory</b>()
put memory on a specific node. The constraints described for
<b>numa_interleave_memory</b>() apply here too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_tonodemask_memory</b>()
put memory on a specific set of nodes. The constraints
described for <b>numa_interleave_memory</b>() apply here
too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_setlocal_memory</b>()
locates memory on the current node. The constraints
described for <b>numa_interleave_memory</b>() apply here
too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_police_memory</b>()
locates memory with the current NUMA policy. The constraints
described for <b>numa_interleave_memory</b>() apply here
too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_distance</b>()
reports the distance in the machine topology between two
nodes. The factors are a multiple of 10. It returns 0 when
the distance cannot be determined. A node has distance 10 to
itself. Reporting the distance requires a Linux kernel
version of <i>2.6.10</i> or newer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_bind_policy</b>()
specifies whether calls that bind memory to a specific node
should use the preferred policy or a strict policy. The
preferred policy allows the kernel to allocate memory on
other nodes when there isn&rsquo;t enough free on the target
node. strict will fail the allocation in that case. Setting
the argument to specifies strict, 0 preferred. Note that
specifying more than one node non strict may only use the
first node in some kernel versions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_set_strict</b>()
sets a flag that says whether the functions allocating on
specific nodes should use use a strict policy. Strict means
the allocation will fail if the memory cannot be allocated
on the target node. Default operation is to fall back to
other nodes. This doesn&rsquo;t apply to interleave and
default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_get_interleave_node()</b>
is used by <i>libnuma</i> internally. It is probably not
useful for user applications. It uses the MPOL_F_NODE flag
of the get_mempolicy system call, which is not intended for
application use (its operation may change or be removed
altogether in future kernel versions). See
get_mempolicy(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_pagesize()</b>
returns the number of bytes in page. This function is simply
a fast alternative to repeated calls to the getpagesize
system call. See getpagesize(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_sched_getaffinity()</b>
retrieves a bitmask of the cpus on which a task may run. The
task is specified by <i>pid.</i> Returns the return value of
the sched_getaffinity system call. See sched_getaffinity(2).
The bitmask must be at least the size of the kernel&rsquo;s
cpu mask structure. Use <b>numa_allocate_cpumask()</b> to
allocate it. Test the bits in the mask by calling
<b>numa_bitmask_isbitset().</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_sched_setaffinity()</b>
sets a task&rsquo;s allowed cpu&rsquo;s to those cpu&rsquo;s
specified in <i>mask.</i> The task is specified by
<i>pid.</i> Returns the return value of the
sched_setaffinity system call. See sched_setaffinity(2). You
may allocate the bitmask with
<b>numa_allocate_cpumask().</b> Or the bitmask may be
smaller than the kernel&rsquo;s cpu mask structure. For
example, call <b>numa_bitmask_alloc()</b> using a maximum
number of cpus from <b>numa_num_configured_cpus().</b> Set
the bits in the mask by calling
<b>numa_bitmask_setbit().</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_node_to_cpus</b>()
converts a node number to a bitmask of CPUs. The user must
pass a bitmask structure with a mask buffer long enough to
represent all possible cpu&rsquo;s. Use
numa_allocate_cpumask() to create it. If the bitmask is not
long enough <i>errno</i> will be set to <i>ERANGE</i> and
&minus;1 returned. On success 0 is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_node_of_cpu</b>()
returns the node that a cpu belongs to. If the user supplies
an invalid cpu <i>errno</i> will be set to <i>EINVAL</i> and
&minus;1 will be returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_allocate_cpumask</b>
() returns a bitmask of a size equal to the kernel&rsquo;s
cpu mask (kernel type cpumask_t). In other words, large
enough to represent NR_CPUS cpus. This number of cpus can be
gotten by calling <b>numa_num_possible_cpus().</b> The
bitmask is zero-filled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_free_cpumask</b>
frees a cpumask previously allocate by
<i>numa_allocate_cpumask.</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_allocate_nodemask()</b>
returns a bitmask of a size equal to the kernel&rsquo;s node
mask (kernel type nodemask_t). In other words, large enough
to represent MAX_NUMNODES nodes. This number of nodes can be
gotten by calling <b>numa_num_possible_nodes().</b> The
bitmask is zero-filled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_free_nodemask()</b>
frees a nodemask previous allocated by
<i>numa_allocate_nodemask().</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_alloc()</b>
allocates a bitmask structure and its associated bit mask.
The memory allocated for the bit mask contains enough words
(type unsigned long) to contain <i>n</i> bits. The bit mask
is zero-filled. The bitmask structure points to the bit mask
and contains the <i>n</i> value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_clearall()</b>
sets all bits in the bit mask to 0. The bitmask structure
points to the bit mask and contains its size ( <i>bmp</i>
-&gt;size). The value of <i>bmp</i> is always returned. Note
that <b>numa_bitmask_alloc()</b> creates a zero-filled bit
mask.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_clearbit()</b>
sets a specified bit in a bit mask to 0. Nothing is done if
the <i>n</i> value is greater than the size of the bitmask
(and no error is returned). The value of <i>bmp</i> is
always returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_equal()</b>
returns 1 if two bitmasks are equal. It returns 0 if they
are not equal. If the bitmask structures control bit masks
of different sizes, the &quot;missing&quot; trailing bits of
the smaller bit mask are considered to be 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_free()</b>
deallocates the memory of both the bitmask structure pointed
to by <i>bmp</i> and the bit mask. It is an error to attempt
to free this bitmask twice.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_isbitset()</b>
returns the value of a specified bit in a bit mask. If the
<i>n</i> value is greater than the size of the bit map, 0 is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_nbytes()</b>
returns the size (in bytes) of the bit mask controlled by
<i>bmp.</i> The bit masks are always full words (type
unsigned long), and the returned size is the actual size of
all those words.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_setall()</b>
sets all bits in the bit mask to 1. The bitmask structure
points to the bit mask and contains its size ( <i>bmp</i>
-&gt;size). The value of <i>bmp</i> is always returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_setbit()</b>
sets a specified bit in a bit mask to 1. Nothing is done if
<i>n</i> is greater than the size of the bitmask (and no
error is returned). The value of <i>bmp</i> is always
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>copy_bitmask_to_nodemask()</b>
copies the body (the bit map itself) of the bitmask
structure pointed to by <i>bmp</i> to the nodemask_t
structure pointed to by the <i>nodemask</i> pointer. If the
two areas differ in size, the copy is truncated to the size
of the receiving field or zero-filled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>copy_nodemask_to_bitmask()</b>
copies the nodemask_t structure pointed to by the
<i>nodemask</i> pointer to the body (the bit map itself) of
the bitmask structure pointed to by the <i>bmp</i> pointer.
If the two areas differ in size, the copy is truncated to
the size of the receiving field or zero-filled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>copy_bitmask_to_bitmask()</b>
copies the body (the bit map itself) of the bitmask
structure pointed to by the <i>bmpfrom</i> pointer to the
body of the bitmask structure pointed to by the <i>bmpto</i>
pointer. If the two areas differ in size, the copy is
truncated to the size of the receiving field or
zero-filled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_bitmask_weight()</b>
returns a count of the bits that are set in the body of the
bitmask pointed to by the <i>bmp</i> argument.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_move_pages()</b>
moves a list of pages in the address space of the currently
executing or current process. It simply uses the move_pages
system call. <i><br>
pid</i> - ID of task. If not valid, use the current task.
<i><br>
count</i> - Number of pages. <i><br>
pages</i> - List of pages to move. <i><br>
nodes</i> - List of nodes to which pages can be moved.
<i><br>
status</i> - Field to which status is to be returned.
<i><br>
flags</i> - MPOL_MF_MOVE or MPOL_MF_MOVE_ALL <br>
See move_pages(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_migrate_pages()</b>
simply uses the migrate_pages system call to cause the pages
of the calling task, or a specified task, to be migated from
one set of nodes to another. See migrate_pages(2). The bit
masks representing the nodes should be allocated with
<b>numa_allocate_nodemask()</b> , or with
<b>numa_bitmask_alloc()</b> using an <i>n</i> value returned
from <b>numa_num_possible_nodes().</b> A task&rsquo;s
current node set can be gotten by calling
<b>numa_get_membind().</b> Bits in the <i>tonodes</i> mask
can be set by calls to <b>numa_bitmask_setbit().</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_error</b>()
is a <i>libnuma</i> internal function that can be overridden
by the user program. This function is called with a <i>char
*</i> argument when a <i>libnuma</i> function fails.
Overriding the library internal definition makes it possible
to specify a different error handling strategy when a
<i>libnuma</i> function fails. It does not affect
<b>numa_available</b>(). The <b>numa_error</b>() function
defined in <i>libnuma</i> prints an error on <i>stderr</i>
and terminates the program if <i>numa_exit_on_error</i> is
set to a non-zero value. The default value of
<i>numa_exit_on_error</i> is zero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>numa_warn</b>()
is a <i>libnuma</i> internal function that can be also
overridden by the user program. It is called to warn the
user when a <i>libnuma</i> function encounters a non-fatal
error. The default implementation prints a warning to
<i>stderr</i>. The first argument is a unique number
identifying each warning. After that there is a
<b>printf</b>(3)-style format string and a variable number
of arguments. <i>numa_warn</i> exits the program when
<i>numa_exit_on_warn</i> is set to a non-zero value. The
default value of <i>numa_exit_on_warn</i> is zero.</p>

<h2>Compatibility with libnuma version 1
<a name="Compatibility with libnuma version 1"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Binaries that
were compiled for libnuma version 1 need not be re-compiled
to run with libnuma version 2. <br>
Source codes written for libnuma version 1 may be
re-compiled without change with version 2 installed. To do
so, in the code&rsquo;s Makefile add this option to CFLAGS:
-DNUMA_VERSION1_COMPATIBILITY</p>

<h2>THREAD SAFETY
<a name="THREAD SAFETY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>numa_set_bind_policy</i>
and <i>numa_exit_on_error</i> are process global. The other
calls are thread safe.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright 2002,
2004, 2007, 2008 Andi Kleen, SuSE Labs. <i>libnuma</i> is
under the GNU Lesser General Public License, v2.1.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>get_mempolicy</b>(2),
<b>set_mempolicy</b>(2), <b>getpagesize</b>(2),
<b>mbind</b>(2), <b>mmap</b>(2), <b>shmat</b>(2),
<b>numactl</b>(8), <b>sched_getaffinity</b>(2)
<b>sched_setaffinity</b>(2) <b>move_pages</b>(2)
<b>migrate_pages</b>(2)</p>
<hr>
</body>
</html>
