<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:24:36 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SPI_PREPARE</title>

</head>
<body>

<h1 align="center">SPI_PREPARE</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ARGUMENTS">ARGUMENTS</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#NOTES">NOTES</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SPI_prepare
&minus; prepare a statement, without executing it yet</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">SPIPlanPtr
SPI_prepare(const char * <i>command</i>, int <i>nargs</i>,
Oid * <i>argtypes</i>)</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SPI_prepare</b>
creates and returns a prepared statement for the specified
command, but doesn't execute the command. The prepared
statement can later be executed repeatedly using
<b>SPI_execute_plan</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When the same
or a similar command is to be executed repeatedly, it is
generally advantageous to perform parse analysis only once,
and might furthermore be advantageous to re&minus;use an
execution plan for the command. <b>SPI_prepare</b> converts
a command string into a prepared statement that encapsulates
the results of parse analysis. The prepared statement also
provides a place for caching an execution plan if it is
found that generating a custom plan for each execution is
not helpful.</p>

<p style="margin-left:11%; margin-top: 1em">A prepared
command can be generalized by writing parameters ($1, $2,
etc.) in place of what would be constants in a normal
command. The actual values of the parameters are then
specified when <b>SPI_execute_plan</b> is called. This
allows the prepared command to be used over a wider range of
situations than would be possible without parameters.</p>

<p style="margin-left:11%; margin-top: 1em">The statement
returned by <b>SPI_prepare</b> can be used only in the
current invocation of the procedure, since <b>SPI_finish</b>
frees memory allocated for such a statement. But the
statement can be saved for longer using the functions
<b>SPI_keepplan</b> or <b>SPI_saveplan</b>.</p>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">const char *
<i>command</i></p>

<p style="margin-left:17%;">command string</p>

<p style="margin-left:11%; margin-top: 1em">int
<i>nargs</i></p>

<p style="margin-left:17%;">number of input parameters ($1,
$2, etc.)</p>

<p style="margin-left:11%; margin-top: 1em">Oid *
<i>argtypes</i></p>

<p style="margin-left:17%;">pointer to an array containing
the OIDs of the data types of the parameters</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SPI_prepare</b>
returns a non&minus;null pointer to an SPIPlan, which is an
opaque struct representing a prepared statement. On error,
NULL will be returned, and <i>SPI_result</i> will be set to
one of the same error codes used by <b>SPI_execute</b>,
except that it is set to SPI_ERROR_ARGUMENT if
<i>command</i> is NULL, or if <i>nargs</i> is less than 0,
or if <i>nargs</i> is greater than 0 and <i>argtypes</i> is
NULL.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If no
parameters are defined, a generic plan will be created at
the first use of <b>SPI_execute_plan</b>, and used for all
subsequent executions as well. If there are parameters, the
first few uses of <b>SPI_execute_plan</b> will generate
custom plans that are specific to the supplied parameter
values. After enough uses of the same prepared statement,
<b>SPI_execute_plan</b> will build a generic plan, and if
that is not too much more expensive than the custom plans,
it will start using the generic plan instead of
re&minus;planning each time. If this default behavior is
unsuitable, you can alter it by passing the
CURSOR_OPT_GENERIC_PLAN or CURSOR_OPT_CUSTOM_PLAN flag to
<b>SPI_prepare_cursor</b>, to force use of generic or custom
plans respectively.</p>

<p style="margin-left:11%; margin-top: 1em">This function
should only be called from a connected procedure.</p>

<p style="margin-left:11%; margin-top: 1em">SPIPlanPtr is
declared as a pointer to an opaque struct type in spi.h. It
is unwise to try to access its contents directly, as that
makes your code much more likely to break in future
revisions of PostgreSQL.</p>

<p style="margin-left:11%; margin-top: 1em">The name
SPIPlanPtr is somewhat historical, since the data structure
no longer necessarily contains an execution plan.</p>
<hr>
</body>
</html>
