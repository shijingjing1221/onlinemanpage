<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:08:41 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IP</title>

</head>
<body>

<h1 align="center">IP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#INSTALLATION">INSTALLATION</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXPORT_OK">EXPORT_OK</a><br>
<a href="#NOTES / BUGS ... FEATURES">NOTES / BUGS ... FEATURES</a><br>
<a href="#HISTORY">HISTORY</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#WARRANTY">WARRANTY</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">NetAddr::IP
&minus; Manages IPv4 and IPv6 addresses and subnets</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP qw(
        Compact
        Coalesce
        Zeros
        Ones
        V4mask
        V4net
        netlimit
        :aton           DEPRECATED
        :lower
        :upper
        :old_storable
        :old_nth
        :rfc3021
  );
  NOTE: NetAddr::IP::Util has a full complement of network address
        utilities to convert back and forth between binary and text.
        inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa
        ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx,
        inet_n2ad, inetanyto6, ipv6to4</pre>


<p style="margin-left:11%; margin-top: 1em">See
NetAddr::IP::Util</p>

<pre style="margin-left:11%; margin-top: 1em">  my $ip = new NetAddr::IP '127.0.0.1';
         or if you prefer
  my $ip = NetAddr::IP&minus;&gt;new('127.0.0.1);
        or from a packed IPv4 address
  my $ip = new_from_aton NetAddr::IP (inet_aton('127.0.0.1'));
        or from an octal filtered IPv4 address
  my $ip = new_no NetAddr::IP '127.012.0.0';
  print &quot;The address is &quot;, $ip&minus;&gt;addr, &quot; with mask &quot;, $ip&minus;&gt;mask, &quot;\n&quot; ;
  if ($ip&minus;&gt;within(new NetAddr::IP &quot;127.0.0.0&quot;, &quot;255.0.0.0&quot;)) {
      print &quot;Is a loopback address\n&quot;;
  }
                                # This prints 127.0.0.1/32
  print &quot;You can also say $ip...\n&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">* The following
four functions return ipV6 representations of:</p>

<pre style="margin-left:11%; margin-top: 1em">  ::                                       = Zeros();
  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
  ::FFFF:FFFF                              = V4net();</pre>


<p style="margin-left:11%; margin-top: 1em">######
<small>DEPRECATED,</small> will be remove in version 5
############</p>

<pre style="margin-left:11%; margin-top: 1em">  * To accept addresses in the format as returned by
  inet_aton, invoke the module as:
  use NetAddr::IP qw(:aton);</pre>


<p style="margin-left:11%; margin-top: 1em">######
<small>USE</small> new_from_aton instead
##########################</p>

<p style="margin-left:11%; margin-top: 1em">* To enable
usage of legacy data files containing NetAddr::IP objects
stored using the Storable module.</p>

<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP qw(:old_storable);</pre>


<p style="margin-left:11%; margin-top: 1em">* To compact
many smaller subnets (see:
<tt>&quot;$me&minus;&gt;compact($addr1,$addr2,...)&quot;</tt></p>


<p style="margin-left:11%; margin-top: 1em"><tt>@compacted_object_list
= Compact(@object_list)</tt></p>

<p style="margin-left:11%; margin-top: 1em">* Return a
reference to list of <tt>&quot;NetAddr::IP&quot;</tt>
subnets of <tt>$masklen</tt> mask length, when
<tt>$number</tt> or more addresses from
<tt>@list_of_subnets</tt> are found to be contained in said
subnet.</p>

<pre style="margin-left:11%; margin-top: 1em">  $arrayref = Coalesce($masklen, $number, @list_of_subnets)</pre>


<p style="margin-left:11%; margin-top: 1em">* By default
<b>NetAddr::IP</b> functions and methods return string IPv6
addresses in uppercase. To change that to lowercase:</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
the <small>AUGUST 2010 RFC5952</small> states:</p>

<pre style="margin-left:11%; margin-top: 1em">    4.3. Lowercase
      The characters &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, and &quot;f&quot; in an IPv6
      address MUST be represented in lowercase.</pre>


<p style="margin-left:11%; margin-top: 1em">It is
recommended that all <small>NEW</small> applications using
NetAddr::IP be invoked as shown on the next line.</p>

<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP qw(:lower);</pre>


<p style="margin-left:11%; margin-top: 1em">* To ensure the
current IPv6 string case behavior even if the default
changes:</p>

<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP qw(:upper);</pre>


<p style="margin-left:11%; margin-top: 1em">* To set a
limit on the size of <b>nets</b> processed or returned by
NetAddr::IP.</p>

<p style="margin-left:11%; margin-top: 1em">Set the maximum
number of nets beyond which NetAddr::IP will return an error
as a power of 2 (default 16 or 65536 nets). Each 2**16
consumes approximately 4 megs of memory. A 2**20 consumes 64
megs of memory, A 2**24 consumes 1 gigabyte of memory.</p>

<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP qw(netlimit);
  netlimit 20;</pre>


<p style="margin-left:11%; margin-top: 1em">The maximum
<b>netlimit</b> allowed is 2**24. Attempts to set limits
below the default of 16 or above the maximum of 24 are
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">Returns true on
success, otherwise <tt>&quot;undef&quot;</tt>.</p>

<h2>INSTALLATION
<a name="INSTALLATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Un-tar the
distribution in an appropriate directory and type:</p>

<pre style="margin-left:11%; margin-top: 1em">        perl Makefile.PL
        make
        make test
        make install</pre>



<p style="margin-left:11%; margin-top: 1em"><b>NetAddr::IP</b>
depends on <b>NetAddr::IP::Util</b> which installs by
default with its primary functions compiled using
Perl&rsquo;s <small>XS</small> extensions to build a C
library. If you do not have a C complier available or would
like the slower Pure Perl version for some other reason,
then type:</p>

<pre style="margin-left:11%; margin-top: 1em">        perl Makefile.PL &minus;noxs
        make
        make test
        make install</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module
provides an object-oriented abstraction on top of
<small>IP</small> addresses or <small>IP</small> subnets
that allows for easy manipulations. Version 4.xx of
NetAddr::IP will work with older versions of Perl and is
compatible with Math::BigInt.</p>

<p style="margin-left:11%; margin-top: 1em">The internal
representation of all <small>IP</small> objects is in 128
bit IPv6 notation. IPv4 and IPv6 objects may be freely
mixed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Overloaded
Operators</b> <br>
Many operators have been overloaded, as described below:
<b><br>
Assignment (&quot;=&quot;)</b></p>

<p style="margin-left:17%;">Has been optimized to copy one
NetAddr::IP object to another very quickly.</p>


<p style="margin-left:11%;"><b>&quot;&minus;&gt;copy()&quot;</b></p>

<p style="margin-left:17%;">The <b>assignment
(&quot;=&quot;)</b> operation is only put in to operation
when the copied object is further mutated by another
overloaded operation. See overload <b><small>SPECIAL SYMBOLS
FOR</small> &quot;use overload&quot;</b> for details.</p>


<p style="margin-left:17%; margin-top: 1em"><b>&quot;&minus;&gt;copy()&quot;</b>
actually creates a new object when called.</p>

<p style="margin-left:11%;"><b>Stringification</b></p>

<p style="margin-left:17%;">An object can be used just as a
string. For instance, the following code</p>

<pre style="margin-left:17%; margin-top: 1em">        my $ip = new NetAddr::IP '192.168.1.123';
        print &quot;$ip\n&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">Will print the
string 192.168.1.123/32.</p>

<p style="margin-left:11%;"><b>Equality</b></p>

<p style="margin-left:17%;">You can test for equality with
either <tt>&quot;eq&quot;</tt> or <tt>&quot;==&quot;</tt>.
<tt>&quot;eq&quot;</tt> allows comparison with arbitrary
strings as well as NetAddr::IP objects. The following
example:</p>

<pre style="margin-left:17%; margin-top: 1em">    if (NetAddr::IP&minus;&gt;new('127.0.0.1','255.0.0.0') eq '127.0.0.1/8')
       { print &quot;Yes\n&quot;; }</pre>


<p style="margin-left:17%; margin-top: 1em">will print out
&quot;Yes&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Comparison with
<tt>&quot;==&quot;</tt> requires both operands to be
NetAddr::IP objects.</p>

<p style="margin-left:17%; margin-top: 1em">In both cases,
a true value is returned if the <small>CIDR</small>
representation of the operands is equal.</p>

<p style="margin-left:11%;"><b>Comparison via &gt;, &lt;,
&gt;=, &lt;=, &lt;=&gt; and &quot;cmp&quot;</b></p>

<p style="margin-left:17%;">Internally, all network objects
are represented in 128 bit format. The numeric
representation of the network is compared through the
corresponding operation. Comparisons are tried first on the
address portion of the object and if that is equal then the
<small>NUMERIC</small> cidr portion of the masks are
compared. This leads to the counterintuitive result that</p>

<pre style="margin-left:17%; margin-top: 1em">        /24 &gt; /16</pre>


<p style="margin-left:17%; margin-top: 1em">Comparison
should not be done on netaddr objects with different
<small>CIDR</small> as this may produce indeterminate
&minus; unexpected results, rather the determination of
which netblock is larger or smaller should be done by
comparing</p>

<pre style="margin-left:17%; margin-top: 1em">        $ip1&minus;&gt;masklen &lt;=&gt; $ip2&minus;&gt;masklen</pre>


<p style="margin-left:11%;"><b>Addition of a constant
(&quot;+&quot;)</b></p>

<p style="margin-left:17%;">Add a 32 bit signed constant to
the address part of a NetAddr object. This operation changes
the address part to point so many hosts above the current
objects start address. For instance, this code:</p>

<pre style="margin-left:17%; margin-top: 1em">    print NetAddr::IP&minus;&gt;new('127.0.0.1/8') + 5;</pre>


<p style="margin-left:17%; margin-top: 1em">will output
127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:</p>

<pre style="margin-left:17%; margin-top: 1em">    print NetAddr::IP&minus;&gt;new('10.0.0.1/24') + 255;
    outputs 10.0.0.0/24.</pre>


<p style="margin-left:17%; margin-top: 1em">Returns the the
unchanged object when the constant is missing or out of
range.</p>

<pre style="margin-left:17%; margin-top: 1em">    2147483647 &lt;= constant &gt;= &minus;2147483648</pre>


<p style="margin-left:11%;"><b>Subtraction of a constant
(&quot;&minus;&quot;)</b></p>

<p style="margin-left:17%;">The complement of the addition
of a constant.</p>

<p style="margin-left:11%;"><b>Difference
(&quot;&minus;&quot;)</b></p>

<p style="margin-left:17%;">Returns the difference between
the address parts of two NetAddr::IP objects address parts
as a 32 bit signed number.</p>

<p style="margin-left:17%; margin-top: 1em">Returns
<b>undef</b> if the difference is out of range.</p>

<p style="margin-left:17%; margin-top: 1em">(See range
restrictions on Addition above)</p>

<p style="margin-left:11%;"><b>Auto-increment</b></p>

<p style="margin-left:17%;">Auto-incrementing a NetAddr::IP
object causes the address part to be adjusted to the next
host address within the subnet. It will wrap at the
broadcast address and start again from the network
address.</p>

<p style="margin-left:11%;"><b>Auto-decrement</b></p>

<p style="margin-left:17%;">Auto-decrementing a NetAddr::IP
object performs exactly the opposite of auto-incrementing
it, as you would expect.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Serializing
and Deserializing</b> <br>
This module defines hooks to collaborate with Storable for
serializing <tt>&quot;NetAddr::IP&quot;</tt> objects,
through compact and human readable strings. You can revert
to the old format by invoking this module as</p>

<pre style="margin-left:11%; margin-top: 1em">  use NetAddr::IP ':old_storable';</pre>


<p style="margin-left:11%; margin-top: 1em">You must do
this if you have legacy data files containing NetAddr::IP
objects stored using the Storable module.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Methods</b>
<br>
&quot;&minus;&gt;new([$addr, [ $mask|IPv6 ]])&quot; <br>
&quot;&minus;&gt;new6([$addr, [ $mask]])&quot; <br>
&quot;&minus;&gt;new_no([$addr, [ $mask]])&quot; <br>
&quot;&minus;&gt;new_from_aton($netaddr)&quot; <br>
new_cis and new_cis6 are <small>DEPRECATED</small> <br>
&quot;&minus;&gt;new_cis(&quot;$addr $mask)&quot; <br>
&quot;&minus;&gt;new_cis6(&quot;$addr $mask)&quot;</p>

<p style="margin-left:17%;">The first two methods create a
new address with the supplied address in <tt>$addr</tt> and
an optional netmask <tt>$mask</tt>, which can be omitted to
get a /32 or /128 netmask for IPv4 / IPv6 addresses
respectively.</p>

<p style="margin-left:17%; margin-top: 1em">The third
method <tt>&quot;new_no&quot;</tt> is exclusively for IPv4
addresses and filters improperly formatted dot quad strings
for leading 0&rsquo;s that would normally be interpreted as
octal format by NetAddr per the specifications for
inet_aton.</p>


<p style="margin-left:17%; margin-top: 1em"><b>new_from_aton</b>
takes a packed IPv4 address and assumes a /32 mask. This
function replaces the <small>DEPRECATED</small> :aton
functionality which is fundamentally broken.</p>

<p style="margin-left:17%; margin-top: 1em">The last two
methods <b>new_cis</b> and <b>new_cis6</b> differ from
<b>new</b> and <b>new6</b> only in that they except the
common Cisco address notation for address/mask pairs with a
<b>space</b> as a separator instead of a slash (/)</p>

<p style="margin-left:17%; margin-top: 1em">These methods
are <small>DEPRECATED</small> because the functionality is
now included in the other &quot;new&quot; methods</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  &minus;&gt;new_cis('1.2.3.0 24')
        or
        &minus;&gt;new_cis6('::1.2.3.0 120')</pre>



<p style="margin-left:17%; margin-top: 1em">&quot;&minus;&gt;new6&quot;
and <tt>&quot;&minus;&gt;new_cis6&quot;</tt> mark the
address as being in ipV6 address space even if the format
would suggest otherwise.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  &minus;&gt;new6('1.2.3.4') will result in ::102:304
  addresses submitted to &minus;&gt;new in ipV6 notation will
  remain in that notation permanently. i.e.
        &minus;&gt;new('::1.2.3.4') will result in ::102:304
  whereas new('1.2.3.4') would print out as 1.2.3.4
  See &quot;STRINGIFICATION&quot; below.</pre>


<p style="margin-left:17%; margin-top: 1em">$addr can be
almost anything that can be resolved to an <small>IP</small>
address in all the notations I have seen over time. It can
optionally contain the mask in <small>CIDR</small>
notation.</p>

<p style="margin-left:17%; margin-top: 1em"><b>prefix</b>
notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.</p>

<p style="margin-left:17%; margin-top: 1em">Addresses in
the same format returned by <tt>&quot;inet_aton&quot;</tt>
or <tt>&quot;gethostbyname&quot;</tt> can also be
understood, although no mask can be specified for them. The
default is to not attempt to recognize this format, as it
seems to be seldom used.</p>

<p style="margin-left:17%; margin-top: 1em">To accept
addresses in that format, invoke the module as in</p>

<pre style="margin-left:17%; margin-top: 1em">  use NetAddr::IP ':aton'</pre>


<p style="margin-left:17%; margin-top: 1em">If called with
no arguments, &rsquo;default&rsquo; is assumed.</p>

<p style="margin-left:17%; margin-top: 1em">If called with
an empty string as the argument, returns
&rsquo;undef&rsquo;</p>

<p style="margin-left:17%; margin-top: 1em"><tt>$addr</tt>
can be any of the following and possibly more...</p>

<pre style="margin-left:17%; margin-top: 1em">  n.n
  n.n/mm
  n.n.n
  n.n.n/mm
  n.n.n.n
  n.n.n.n/mm            32 bit cidr notation
  n.n.n.n/m.m.m.m
  loopback, localhost, broadcast, any, default
  x.x.x.x/host
  0xABCDEF, 0b111111000101011110, (a bcd number)
  a netaddr as returned by 'inet_aton'</pre>


<p style="margin-left:17%; margin-top: 1em">Any
<small>RFC1884</small> notation</p>

<pre style="margin-left:17%; margin-top: 1em">  ::n.n.n.n
  ::n.n.n.n/mmm         128 bit cidr notation
  ::n.n.n.n/::m.m.m.m
  ::x:x
  ::x:x/mmm
  x:x:x:x:x:x:x:x
  x:x:x:x:x:x:x:x/mmm
  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
  loopback, localhost, unspecified, any, default
  ::x:x/host
  0xABCDEF, 0b111111000101011110 within the limits
  of perl's number resolution
  123456789012  a 'big' bcd number (bigger than perl likes)
  and Math::BigInt</pre>


<p style="margin-left:17%; margin-top: 1em">If called with
no arguments, &rsquo;default&rsquo; is assumed.</p>

<p style="margin-left:17%; margin-top: 1em">If called with
an empty string as the argument, returns
&rsquo;undef&rsquo;</p>


<p style="margin-left:11%;">&quot;&minus;&gt;broadcast()&quot;</p>

<p style="margin-left:17%;">Returns a new object referring
to the broadcast address of a given subnet. The broadcast
address has all ones in all the bit positions where the
netmask has zero bits. This is normally used to address all
the hosts in a given subnet.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;network()&quot;</p>

<p style="margin-left:17%;">Returns a new object referring
to the network address of a given subnet. A network address
has all zero bits where the bits of the netmask are zero.
Normally this is used to refer to a subnet.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;addr()&quot;</p>

<p style="margin-left:17%;">Returns a scalar with the
address part of the object as an IPv4 or IPv6 text string as
appropriate. This is useful for printing or for passing the
address part of the NetAddr::IP object to other components
that expect an <small>IP</small> address. If the object is
an ipV6 address or was created using &minus;&gt;new6($ip) it
will be reported in ipV6 hex format otherwise it will be
reported in dot quad format only if it resides in ipV4
address space.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;mask()&quot;</p>

<p style="margin-left:17%;">Returns a scalar with the mask
as an IPv4 or IPv6 text string as described above.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;masklen()&quot;</p>

<p style="margin-left:17%;">Returns a scalar the number of
one bits in the mask.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;bits()&quot;</p>

<p style="margin-left:17%;">Returns the width of the
address in bits. Normally 32 for v4 and 128 for v6.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;version()&quot;</p>

<p style="margin-left:17%;">Returns the version of the
address or subnet. Currently this can be either 4 or 6.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;cidr()&quot;</p>

<p style="margin-left:17%;">Returns a scalar with the
address and mask in <small>CIDR</small> notation. A
NetAddr::IP object <i>stringifies</i> to the result of this
function. (see comments about &minus;&gt;<i>new6()</i> and
&minus;&gt;<i>addr()</i> for output formats)</p>


<p style="margin-left:11%;">&quot;&minus;&gt;aton()&quot;</p>

<p style="margin-left:17%;">Returns the address part of the
NetAddr::IP object in the same format as the
<tt>&quot;inet_aton()&quot;</tt> or
<tt>&quot;ipv6_aton&quot;</tt> function respectively. If the
object was created using &minus;&gt;new6($ip), the address
returned will always be in ipV6 format, even for addresses
in ipV4 address space.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;range()&quot;</p>

<p style="margin-left:17%;">Returns a scalar with the base
address and the broadcast address separated by a dash and
spaces. This is called range notation.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;prefix()&quot;</p>

<p style="margin-left:17%;">Returns a scalar with the
address and mask in ipV4 prefix representation. This is
useful for some programs, which expect its input to be in
this format. This method will include the broadcast address
in the encoding.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;nprefix()&quot;</p>

<p style="margin-left:17%;">Just as
<tt>&quot;&minus;&gt;prefix()&quot;</tt>, but does not
include the broadcast address.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;numeric()&quot;</p>

<p style="margin-left:17%;">When called in a scalar
context, will return a numeric representation of the address
part of the <small>IP</small> address. When called in an
array contest, it returns a list of two elements. The first
element is as described, the second element is the numeric
representation of the netmask.</p>

<p style="margin-left:17%; margin-top: 1em">This method is
essential for serializing the representation of a
subnet.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;bigint()&quot;</p>

<p style="margin-left:17%;">When called in scalar context,
will return a Math::BigInt representation of the address
part of the <small>IP</small> address. When called in an
array context, it returns a list of two elements, The first
element is as described, the second element is the
Math::BigInt representation of the netmask.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;wildcard()&quot;</p>

<p style="margin-left:17%;">When called in a scalar
context, returns the wildcard bits corresponding to the
mask, in dotted-quad or ipV6 format as applicable.</p>

<p style="margin-left:17%; margin-top: 1em">When called in
an array context, returns a two-element array. The first
element, is the address part. The second element, is the
wildcard translation of the mask.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;short()&quot;</p>

<p style="margin-left:17%;">Returns the address part in a
short or compact notation.</p>

<pre style="margin-left:17%; margin-top: 1em">  (ie, 127.0.0.1 becomes 127.1).</pre>


<p style="margin-left:17%; margin-top: 1em">Works with
both, V4 and V6.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;full()&quot;</p>

<p style="margin-left:17%;">Returns the address part in
<small>FULL</small> notation for ipV4 and ipV6
respectively.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e. for ipV4
    0000:0000:0000:0000:0000:0000:127.0.0.1
       for ipV6
    0000:0000:0000:0000:0000:0000:0000:0000</pre>


<p style="margin-left:17%; margin-top: 1em">To force ipV4
addresses into full ipV6 format use:</p>


<p style="margin-left:11%;">&quot;&minus;&gt;full6()&quot;</p>

<p style="margin-left:17%;">Returns the address part in
<small>FULL</small> ipV6 notation</p>


<p style="margin-left:11%;">&quot;$me&minus;&gt;contains($other)&quot;</p>

<p style="margin-left:17%;">Returns true when <tt>$me</tt>
completely contains <tt>$other</tt>. False is returned
otherwise and <tt>&quot;undef&quot;</tt> is returned if
<tt>$me</tt> and <tt>$other</tt> are not both
<tt>&quot;NetAddr::IP&quot;</tt> objects.</p>


<p style="margin-left:11%;">&quot;$me&minus;&gt;within($other)&quot;</p>

<p style="margin-left:17%;">The complement of
<tt>&quot;&minus;&gt;contains()&quot;</tt>. Returns true
when <tt>$me</tt> is completely contained within
<tt>$other</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>$me</tt> and <tt>$other</tt> must be
<tt>&quot;NetAddr::IP&quot;</tt> objects.</p>


<p style="margin-left:11%;">C&minus;&gt;<i>is_rfc1918()</i>&gt;</p>

<p style="margin-left:17%;">Returns true when <tt>$me</tt>
is an <small>RFC 1918</small> address.</p>

<pre style="margin-left:17%; margin-top: 1em">  10.0.0.0      &minus;   10.255.255.255  (10/8 prefix)
  172.16.0.0    &minus;   172.31.255.255  (172.16/12 prefix)
  192.168.0.0   &minus;   192.168.255.255 (192.168/16 prefix)</pre>



<p style="margin-left:11%;">&quot;&minus;&gt;splitref($bits,[optional
$bits1,$bits2,...])&quot;</p>

<p style="margin-left:17%;">Returns a reference to a list
of objects, representing subnets of
<tt>&quot;bits&quot;</tt> mask produced by splitting the
original object, which is left unchanged. Note that
<tt>$bits</tt> must be longer than the original mask in
order for it to be splittable.</p>


<p style="margin-left:17%; margin-top: 1em"><small>ERROR</small>
conditions:</p>

<pre style="margin-left:17%; margin-top: 1em">  &minus;&gt;splitref will DIE with the message 'netlimit exceeded'
    if the number of return objects exceeds 'netlimit'.
    See function 'netlimit' above (default 2**16 or 65536 nets).
  &minus;&gt;splitref returns undef when C&lt;bits&gt; or the (bits list)
    will not fit within the original object.
  &minus;&gt;splitref returns undef if a supplied ipV4, ipV6, or NetAddr
    mask in inappropriately formatted,</pre>


<p style="margin-left:17%; margin-top: 1em"><b>bits</b> may
be a <small>CIDR</small> mask, a dot quad or ipV6 string or
a NetAddr::IP object. If <tt>&quot;bits&quot;</tt> is
missing, the object is split for into all available
addresses within the ipV4 or ipV6 object ( auto-mask of
<small>CIDR 32, 128</small> respectively ).</p>

<p style="margin-left:17%; margin-top: 1em">With optional
additional <tt>&quot;bits&quot;</tt> list, the original
object is split into parts sized based on the list.
<small>NOTE:</small> a short list will replicate the last
item. If the last item is too large to for what remains of
the object after splitting off the first parts of the list,
a &quot;best fits&quot; list of remaining objects will be
returned based on an increasing sort of the
<small>CIDR</small> values of the <tt>&quot;bits&quot;</tt>
list.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  my $ip = new NetAddr::IP('192.168.0.0/24');
        my $objptr = $ip&minus;&gt;split(28, 29, 28, 29, 26);
   has split plan 28 29 28 29 26 26 26 28
   and returns this list of objects
        192.168.0.0/28
        192.168.0.16/29
        192.168.0.24/28
        192.168.0.40/29
        192.168.0.48/26
        192.168.0.112/26
        192.168.0.176/26
        192.168.0.240/28</pre>



<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
that /26 replicates twice beyond the original request and
/28 fills the remaining return object requirement.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;rsplitref($bits,[optional
$bits1,$bits2,...])&quot;</p>


<p style="margin-left:17%;"><tt>&quot;&minus;&gt;rsplitref&quot;</tt>
is the same as <tt>&quot;&minus;&gt;splitref&quot;</tt>
above except that the split plan is applied to the original
object in reverse order.</p>

<pre style="margin-left:17%; margin-top: 1em">  i.e.  my $ip = new NetAddr::IP('192.168.0.0/24');
        my @objects = $ip&minus;&gt;split(28, 29, 28, 29, 26);
   has split plan 28 26 26 26 29 28 29 28
   and returns this list of objects
        192.168.0.0/28
        192.168.0.16/26
        192.168.0.80/26
        192.168.0.144/26
        192.168.0.208/29
        192.168.0.216/28
        192.168.0.232/29
        192.168.0.240/28</pre>



<p style="margin-left:11%;">&quot;&minus;&gt;split($bits,[optional
$bits1,$bits2,...])&quot;</p>

<p style="margin-left:17%;">Similar to
<tt>&quot;&minus;&gt;splitref&quot;</tt> above but returns
the list rather than a list reference. You may not want to
use this if a large number of objects is expected.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;rsplit($bits,[optional
$bits1,$bits2,...])&quot;</p>

<p style="margin-left:17%;">Similar to
<tt>&quot;&minus;&gt;rsplitref&quot;</tt> above but returns
the list rather than a list reference. You may not want to
use this if a large number of objects is expected.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;hostenum()&quot;</p>

<p style="margin-left:17%;">Returns the list of hosts
within a subnet.</p>


<p style="margin-left:17%; margin-top: 1em"><small>ERROR</small>
conditions:</p>

<pre style="margin-left:17%; margin-top: 1em">  &minus;&gt;hostenum will DIE with the message 'netlimit exceeded'
    if the number of return objects exceeds 'netlimit'.
    See function 'netlimit' above (default 2**16 or 65536 nets).</pre>



<p style="margin-left:11%;">&quot;&minus;&gt;hostenumref()&quot;</p>

<p style="margin-left:17%;">Faster version of
<tt>&quot;&minus;&gt;hostenum()&quot;</tt>, returning a
reference to a list.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
hostenum and hostenumref report zero (0) useable hosts in a
/31 network. This is the behavior expected prior to
<small>RFC 3021.</small> To report 2 useable hosts for use
in point-to-point networks, use <b>:rfc3021</b> tag.</p>

<pre style="margin-left:17%; margin-top: 1em">        use NetAddr::IP qw(:rfc3021);</pre>


<p style="margin-left:17%; margin-top: 1em">This will cause
hostenum and hostenumref to return two (2) useable hosts in
a /31 network.</p>


<p style="margin-left:11%;">&quot;$me&minus;&gt;compact($addr1,
$addr2, ...)&quot; <br>
&quot;@compacted_object_list =
Compact(@object_list)&quot;</p>

<p style="margin-left:17%;">Given a list of objects
(including <tt>$me</tt>), this method will compact all the
addresses and subnets into the largest (ie, least specific)
subnets possible that contain exactly all of the given
objects.</p>

<p style="margin-left:17%; margin-top: 1em">Note that in
versions prior to 3.02, if fed with the same
<small>IP</small> subnets multiple times, these subnets
would be returned. From 3.02 on, a more &quot;correct&quot;
approach has been adopted and only one address would be
returned.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>$me</tt> and all <tt>$addr</tt>&rsquo;s must be
<tt>&quot;NetAddr::IP&quot;</tt> objects.</p>


<p style="margin-left:11%;">&quot;$me&minus;&gt;compactref(\@list)&quot;
<br>
&quot;$compacted_object_list = Compact(\@list)&quot;</p>

<p style="margin-left:17%;">As usual, a faster version of
<tt>&quot;&minus;&gt;compact()&quot;</tt> that returns a
reference to a list. Note that this method takes a reference
to a list instead.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<tt>$me</tt> must be a <tt>&quot;NetAddr::IP&quot;</tt>
object.</p>


<p style="margin-left:11%;">&quot;$me&minus;&gt;coalesce($masklen,
$number, @list_of_subnets)&quot; <br>
&quot;$arrayref =
Coalesce($masklen,$number,@list_of_subnets)&quot;</p>

<p style="margin-left:17%;">Will return a reference to list
of <tt>&quot;NetAddr::IP&quot;</tt> subnets of
<tt>$masklen</tt> mask length, when <tt>$number</tt> or more
addresses from <tt>@list_of_subnets</tt> are found to be
contained in said subnet.</p>

<p style="margin-left:17%; margin-top: 1em">Subnets from
<tt>@list_of_subnets</tt> with a mask shorter than
<tt>$masklen</tt> are passed &quot;as is&quot; to the return
list.</p>

<p style="margin-left:17%; margin-top: 1em">Subnets from
<tt>@list_of_subnets</tt> with a mask longer than
<tt>$masklen</tt> will be counted (actually, the number of
<small>IP</small> addresses is counted) towards
<tt>$number</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Called as a
method, the array will include <tt>$me</tt>.</p>


<p style="margin-left:17%; margin-top: 1em"><small>WARNING:</small>
the list of subnet must be the same type. i.e ipV4 or
ipV6</p>


<p style="margin-left:11%;">&quot;&minus;&gt;first()&quot;</p>

<p style="margin-left:17%;">Returns a new object
representing the first usable <small>IP</small> address
within the subnet (ie, the first host address).</p>


<p style="margin-left:11%;">&quot;&minus;&gt;last()&quot;</p>

<p style="margin-left:17%;">Returns a new object
representing the last usable <small>IP</small> address
within the subnet (ie, one less than the broadcast
address).</p>


<p style="margin-left:11%;">&quot;&minus;&gt;nth($index)&quot;</p>

<p style="margin-left:17%;">Returns a new object
representing the <i>n</i>&minus;th usable <small>IP</small>
address within the subnet (ie, the <i>n</i>&minus;th host
address). If no address is available (for example, when the
network is too small for <tt>$index</tt> hosts),
<tt>&quot;undef&quot;</tt> is returned.</p>

<p style="margin-left:17%; margin-top: 1em">Version 4.00 of
NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
<tt>&quot;&minus;&gt;nth($index)&quot;</tt> and
<tt>&quot;&minus;&gt;num()&quot;</tt> exactly as the
documentation states. Previous versions behaved slightly
differently and not in a consistent manner. See the
<small>README</small> file for details.</p>

<p style="margin-left:17%; margin-top: 1em">To use the old
behavior for <tt>&quot;&minus;&gt;nth($index)&quot;</tt> and
<tt>&quot;&minus;&gt;num()&quot;</tt>:</p>

<pre style="margin-left:17%; margin-top: 1em">  use NetAddr::IP::Lite qw(:old_nth);
  old behavior:
  NetAddr::IP&minus;&gt;new('10/32')&minus;&gt;nth(0) == undef
  NetAddr::IP&minus;&gt;new('10/32')&minus;&gt;nth(1) == undef
  NetAddr::IP&minus;&gt;new('10/31')&minus;&gt;nth(0) == undef
  NetAddr::IP&minus;&gt;new('10/31')&minus;&gt;nth(1) == 10.0.0.1/31
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(0) == undef
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(1) == 10.0.0.1/30
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(2) == 10.0.0.2/30
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(3) == 10.0.0.3/30</pre>


<p style="margin-left:17%; margin-top: 1em">Note that in
each case, the broadcast address is represented in the
output set and that the &rsquo;zero&rsquo;th index is alway
undef except for a point-to-point /31 or /127 network where
there are exactly two addresses in the network.</p>

<pre style="margin-left:17%; margin-top: 1em">  new behavior:
  NetAddr::IP&minus;&gt;new('10/32')&minus;&gt;nth(0)  == 10.0.0.0/32
  NetAddr::IP&minus;&gt;new('10.1/32'&minus;&gt;nth(0) == 10.0.0.1/32
  NetAddr::IP&minus;&gt;new('10/31')&minus;&gt;nth(0)  == 10.0.0.0/32
  NetAddr::IP&minus;&gt;new('10/31')&minus;&gt;nth(1)  == 10.0.0.1/32
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(0) == 10.0.0.1/30
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(1) == 10.0.0.2/30
  NetAddr::IP&minus;&gt;new('10/30')&minus;&gt;nth(2) == undef</pre>


<p style="margin-left:17%; margin-top: 1em">Note that a /32
net always has 1 usable address while a /31 has exactly two
usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the
network address except for a /31 or /127 when it return the
network address.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;num()&quot;</p>

<p style="margin-left:17%;">As of version 4.42 of
NetAddr::IP and version 1.27 of NetAddr::IP::Lite a /31 and
/127 with return a net <b>num</b> value of 2 instead of 0
(zero) for point-to-point networks.</p>

<p style="margin-left:17%; margin-top: 1em">Version 4.00 of
NetAddr::IP and version 1.00 of NetAddr::IP::Lite return the
number of usable <small>IP</small> addresses within the
subnet, not counting the broadcast or network address.</p>

<p style="margin-left:17%; margin-top: 1em">Previous
versions worked only for ipV4 addresses, returned a maximum
span of 2**32 and returned the number of <small>IP</small>
addresses not counting the broadcast address. <br>
(one greater than the new behavior)</p>

<p style="margin-left:17%; margin-top: 1em">To use the old
behavior for <tt>&quot;&minus;&gt;nth($index)&quot;</tt> and
<tt>&quot;&minus;&gt;num()&quot;</tt>:</p>

<pre style="margin-left:17%; margin-top: 1em">  use NetAddr::IP::Lite qw(:old_nth);</pre>



<p style="margin-left:17%; margin-top: 1em"><small>WARNING:</small></p>

<p style="margin-left:17%; margin-top: 1em">NetAddr::IP
will calculate and return a numeric string for network
ranges as large as 2**128. These values are
<small>TEXT</small> strings and perl can treat them as
integers for numeric calculations.</p>

<p style="margin-left:17%; margin-top: 1em">Perl on 32 bit
platforms only handles integer numbers up to 2**32 and on 64
bit platforms to 2**64.</p>

<p style="margin-left:17%; margin-top: 1em">If you wish to
manipulate numeric strings returned by NetAddr::IP that are
larger than 2**32 or 2**64, respectively, you must load
additional modules such as Math::BigInt, bignum or some
similar package to do the integer math.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;re()&quot;</p>

<p style="margin-left:17%;">Returns a Perl regular
expression that will match an <small>IP</small> address
within the given subnet. Defaults to ipV4 notation. Will
return an ipV6 regex if the address in not in ipV4
space.</p>


<p style="margin-left:11%;">&quot;&minus;&gt;re6()&quot;</p>

<p style="margin-left:17%;">Returns a Perl regular
expression that will match an <small>IP</small> address
within the given subnet. Always returns an ipV6 regex.</p>

<h2>EXPORT_OK
<a name="EXPORT_OK"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">        Compact
        Coalesce
        Zeros
        Ones
        V4mask
        V4net
        netlimit</pre>


<h2>NOTES / BUGS ... FEATURES
<a name="NOTES / BUGS ... FEATURES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">NetAddr::IP
only runs in Pure Perl mode on Windows boxes because I
don&rsquo;t have the resources or know how to get the
&quot;configure&quot; stuff working in the Windows
environment. Volunteers <small>WELCOME</small> to port the
&quot;C&quot; portion of this module to Windows.</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:17%; margin-top: 1em">See the Changes
file</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Luis E. Mun~oz
&lt;luismunoz@cpan.org&gt;, Michael Robinton
&lt;michael@bizsystems.com&gt;</p>

<h2>WARRANTY
<a name="WARRANTY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
comes with the same warranty as Perl itself (ie, none), so
by using it you accept any and all the liability.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
is (c) Luis E. Mun~oz, 1999 &minus; 2007, and (c) Michael
Robinton, 2006 &minus; 2012.</p>

<p style="margin-left:11%; margin-top: 1em">All rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of either:</p>

<pre style="margin-left:11%; margin-top: 1em">  a) the GNU General Public License as published by the Free
  Software Foundation; either version 2, or (at your option) any
  later version, or
  b) the &quot;Artistic License&quot; which comes with this distribution.</pre>


<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See either
the <small>GNU</small> General Public License or the
Artistic License for more details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the Artistic License with this
distribution, in the file named &quot;Artistic&quot;. If
not, I&rsquo;ll be glad to provide one.</p>

<p style="margin-left:11%; margin-top: 1em">You should also
have received a copy of the <small>GNU</small> General
Public License along with this program in the file named
&quot;Copying&quot;. If not, write to the</p>

<pre style="margin-left:11%; margin-top: 1em">        Free Software Foundation, Inc.
        51 Franklin Street, Fifth Floor
        Boston, MA 02110&minus;1301 USA.</pre>


<p style="margin-left:11%; margin-top: 1em">or visit their
web page on the internet at:</p>

<pre style="margin-left:11%; margin-top: 1em">        http://www.gnu.org/copyleft/gpl.html.</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  perl(1) L&lt;NetAddr::IP::Lite&gt;, L&lt;NetAddr::IP::Util&gt;,
L&lt;NetAddr::IP::InetBase&gt;</pre>
<hr>
</body>
</html>
