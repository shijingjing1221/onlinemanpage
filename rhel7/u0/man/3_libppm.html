<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:04:08 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>User manual for old ppm functions</title>

</head>
<body>

<h1 align="center">User manual for old ppm functions</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHOR">AUTHOR</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libppm -
functions for PPM programs</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;netpbm/ppm.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_init(int *</b> <i>argcP</i><b>, <br>
char *</b> <i>argv</i><b>[]);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixel **
ppm_allocarray(</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int</b>
<i>cols</i><b>,int</b> <i>rows</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixel *
ppm_allocrow(int</b> <i>cols</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_freearray(pixel **</b> <i>pixels</i><b>, <br>
int</b> <i>rows</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_freerow(pixel *</b> <i>pixelrow</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_readppminit(FILE *</b> <i>fp</i><b>, <br>
int *</b> <i>colsP</i><b>, <br>
int *</b> <i>rowsP</i><b>,</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixval *</b>
<i>maxvalP</i><b>,int *</b> <i>formatP</i> <b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_readppmrow(FILE *</b><i>fp</i><b>, <br>
pixel *</b> <i>pixelrow</i><b>, <br>
int</b> <i>cols</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>format</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixel **
ppm_readppm(FILE *</b> <i>fp</i><b>, <br>
int *</b> <i>colsP</i><b>, <br>
int *</b> <i>rowsP</i><b>, <br>
pixvalP *</b> <i>maxvalP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_writeppminit(FILE *</b> <i>fp</i><b>, <br>
int</b> <i>cols</i><b>, <br>
int</b> <i>rows</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_writeppmrow(FILE *</b> <i>fp</i><b>, <br>
pixel *</b> <i>pixelrow</i><b>, <br>
int</b> <i>cols</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_writeppm(FILE *</b> <i>fp</i><b>, <br>
pixel **</b> <i>pixels</i><b>, <br>
int</b> <i>cols</i><b>, <br>
int</b> <i>rows</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_writeppm(FILE *</b> <i>fp</i><b>, <br>
pixel **</b> <i>pixels</i><b>, <br>
int</b> <i>cols</i><b>, <br>
int</b> <i>rows</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>forceplain</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_nextimage(FILE *</b> <i>file</i><b>, <br>
int * const</b> <i>eofP</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_check(FILE *</b> <i>file</i><b>, <br>
const enum pm_check_type</b> <i>check_type</i><b>, <br>
const int</b> <i>format</i><b>, <br>
const int</b> <i>cols</i><b>, <br>
const int</b> <i>rows</i><b>, <br>
const int</b> <i>maxval</i><b>, enum pm_check_code *
const</b> <i>retval</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef ...
pixel;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef ...
pixval;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PPM_MAXMAXVAL ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PPM_OVERALLMAXVAL ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PPM_FORMAT ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
RPPM_FORMAT ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PPM_TYPE PPM_FORMAT</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
PPM_FORMAT_TYPE(</b><i>format</i><b>) ...</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixval
PPM_GETR(pixel</b> <i>p</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixval
PPM_GETG(pixel</b> <i>p</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixval
PPM_GETB(pixel</b> <i>p</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
PPM_ASSIGN(pixel</b> <i>p</i><b>, <br>
pixval</b> <i>red</i><b>, <br>
pixval</b> <i>grn</i><b>, <br>
pixval</b> <i>blu</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
PPM_EQUAL(pixel</b> <i>p</i><b>, <br>
pixel</b> <i>q</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
PPM_ISGRAY(pixel</b> <i>p</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void <br>
PPM_DEPTH(pixel</b> <i>newp</i><b>, <br>
pixel</b> <i>p</i><b>, <br>
pixval</b> <i>oldmaxval</i><b>, <br>
pixval</b> <i>newmaxval</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>pixel
ppm_parsecolor(char *</b> <i>colorname</i><b>, <br>
pixval</b> <i>maxval</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>char *
ppm_colorname(pixel *</b> <i>colorP</i><b>, <br>
pixval</b> <i>maxval</i><b>, <br>
int</b> <i>hexok</i><b>)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_readcolornamefile( <br>
const char *</b><i>fileName</i>, <b><br>
int</b> <i>mustOpen</i>, <b><br>
colorhash_table *</b> <i>chtP</i>, <b><br>
const char ***</b> <i>colornamesP</i> <b><br>
)</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These library
functions are part of <b>Netpbm</b>(1)</p>

<p style="margin-left:11%; margin-top: 1em"><b>TYPES AND
CONSTANTS</b> <br>
Each <b>pixel</b> contains three <b>pixval</b>s, each of
which should contain only the values between <b>0</b> and
<b>PPM_MAXMAXVAL</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MANIPULATING
PIXELS</b> <br>
The macros <b>PPM_GETR</b>, <b>PPM_GETG</b>, and
<b>PPM_GETB</b> retrieve the red, green, or blue sample,
respectively, from the given pixel.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PPM_ASSIGN</b> macro assigns the given values to the red,
green, and blue samples of the given pixel.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PPM_EQUAL</b> macro tests two pixels for equality.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PPM_ISGRAY</b> macro tests a pixel for being gray. It
returns true if and only if the color of pixel <i>p</i> is
black, white, or gray.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PPM_DEPTH</b> macro scales the colors of pixel <i>p</i>
according the old and new maxvals and assigns the new values
to <i>newp</i>. It is intended to make writing ppmtowhatever
easier.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PPM_LUMIN</b>, <b>PPM_CHROM_R</b>, and <b>PPM_CHROM_B</b>
macros determine the luminance, red chrominance, and blue
chrominance, respectively, of the pixel <i>p</i>. The scale
of all these values is the same as the scale of the input
samples (i.e. 0 to maxval for luminance, -maxval/2 to
maxval/2 for chrominance).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
macros do it by floating point multiplication. If you are
computing these values over an entire image, it may be
significantly faster to do it with multiplication tables
instead. Compute all the possible products once up front,
then for each pixel, just look up the products in the
tables.</p>


<p style="margin-left:11%; margin-top: 1em"><b>INITIALIZATION
<br>
ppm_init()</b> is obsolete (at least since Netpbm 9.25
(March 2002)). Use
<a href="libpm.html#initialization"><b>pm_proginit()</b></a>
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_init()</b>
is identical to <b>pm_proginit</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MEMORY
MANAGEMENT <br>
ppm_allocarray()</b> allocates an array of pixels.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_allocrow()</b>
allocates a row of the given number of pixels.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_freearray()</b>
frees the array allocated with <b>ppm_allocarray()</b>
containing the given number of rows.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_freerow()</b>
frees a row of pixelss allocated with
<b>ppm_allocrow()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>READING
FILES</b> <br>
If a function in this section is called on a PBM or PGM
format file, it translates the PBM or PGM file into a PPM
file on the fly and functions as if it were called on the
equivalent PPM file. The <i>format</i> value returned by
<b>ppm_readppminit()</b> is, however, not translated. It
represents the actual format of the PBM or PGM file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readppminit()</b>
reads the header of a PPM file, returning all the
information from the header and leaving the file positioned
just after the header.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readppmrow()</b>
reads a row of pixels into the <i>pixelrow</i> array.
<i>format</i>, <i>cols</i>, and <i>maxval</i> are the values
returned by <b>ppm_readppminit()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readppm()</b>
reads an entire PPM image into memory, returning the
allocated array as its return value and returning the
information from the header as <i>rows</i>, <i>cols</i>, and
<i>maxval</i>. This function combines
<b>ppm_readppminit()</b>, <b>ppm_allocarray()</b>, and
<b>ppm_readppmrow()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>WRITING
FILES <br>
ppm_writeppminit()</b> writes the header for a PPM file and
leaves it positioned just after the header.</p>


<p style="margin-left:11%; margin-top: 1em"><i>forceplain</i>
is a logical value that tells <b>ppm_writeppminit()</b> to
write a header for a plain PPM format file, as opposed to a
raw PPM format file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_writeppmrow()</b>
writes the row <i>pixelrow</i> to a PPM file. For meaningful
results, <i>cols</i>, <i>maxval</i>, and <i>forceplain</i>
must be the same as was used with
<b>ppm_writeppminit()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_writeppm()</b>
write the header and all data for a PPM image. This function
combines <b>ppm_writeppminit()</b> and
<b>ppm_writeppmrow()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MISCELLANEOUS
<br>
ppm_nextimage()</b> positions a PPM input file to the next
image in it (so that a subsequent <b>ppm_readppminit()</b>
reads its header).</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_nextimage()</b>
is analogous to <b>pbm_nextimage()</b>, but works on PPM,
PGM, and PBM files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_check()</b>
checks for the common file integrity error where the file is
the wrong size to contain all the image data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_check()</b>
is analogous to <b>pbm_check()</b>, but works on PPM, PGM,
and PBM files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>COLOR <br>
Luminance, Chrominance (YcbCr)</b></p>

<pre style="margin-left:11%; margin-top: 1em">    float PPM_LUMIN(pixel p);
    float PPM_CHROM_B(pixel p);
    float PPM_CHROM_R(pixel p);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>PPM_LUMIN</b>
takes a <b>pixel</b> as an argument and returns the
luminance of that pixel, with the same maxval as the pixel
(e.g. if the pixel&rsquo;s maxval is 255, a <b>PPM_LUMIN</b>
value of 255 means fully luminant).</p>


<p style="margin-left:11%; margin-top: 1em"><b>PPM_CHROM_B</b>
and <b>PPM_CHROM_R</b> are similar, for the red and blue
chrominance values.</p>

<pre style="margin-left:11%; margin-top: 1em">    pixel
    ppm_color_from_ycbcr(unsigned int y,
                         int          cb,
                         int          cr);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>ppm_color_from_ycbcr()</b>
converts in the other direction. Given luminance and
chrominance, it returns a pixel value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Hue,
Saturation, Value (HSV)</b></p>
<pre style="margin-left:11%; margin-top: 1em">    struct hsv {
        double h;  /* hue (degrees)  0..360 */
        double s;  /* saturation (0-1) */
        double v;  /* value (0-1) */
    };
    pixel
    ppm_color_from_hsv(struct hsv const hsv,
                       pixval     const maxval);

    struct hsv
    ppm_hsv_from_color(pixel  const color,
                       pixval const maxval);</pre>


<p style="margin-left:11%; margin-top: 1em">These convert a
color between from <b>pixel</b> (RGB) form and HSV.</p>

<pre style="margin-left:11%; margin-top: 1em">    pixval
    ppm_saturation(pixel  const p,
                   pixval const maxval);</pre>


<p style="margin-left:11%; margin-top: 1em">This gives you
the saturation of a color, as a pixval. (e.g. if the
saturation of <i>p</i> is 50% and <i>maxval</i> is 100,
<b>ppm_saturation()</b> returns 50).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Berlin-Kay
Color</b></p>

<p style="margin-left:11%; margin-top: 1em">Brent Berlin
and Paul Kay in 1969 did a study which identified a set of
11 basic colors people universally recognize. They are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>black</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>gray</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>white</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>red</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>orange</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>yellow</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>green</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>blue</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>violet</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>purple</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="9%">


<p>brown</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<b>bk_color</b> type represents a color from this set:</p>

<pre style="margin-left:11%; margin-top: 1em">    typedef enum {
        BKCOLOR_BLACK = 0,
        BKCOLOR_GRAY,
        BKCOLOR_WHITE,
        BKCOLOR_RED,
        BKCOLOR_ORANGE,
        BKCOLOR_YELLOW,
        BKCOLOR_GREEN,
        BKCOLOR_BLUE,
        BKCOLOR_VIOLET,
        BKCOLOR_PURPLE,
        BKCOLOR_BROWN
    } bk_color;</pre>


<p style="margin-left:11%; margin-top: 1em">You can use
this as an index of an array, in which case you might also
want macro <b>BKCOLOR_COUNT</b>, which is the number of
colors in the set (11).</p>

<p style="margin-left:11%; margin-top: 1em">To translate
between the <b>bk_color</b> type and the English names of
the colors, use <b>ppm_bk_color_from_name()</b> and
<b>ppm_name_from_bk_color()</b>:</p>
<pre style="margin-left:11%; margin-top: 1em">    bk_color
    ppm_bk_color_from_name(const char * name);


    const char *
    ppm_name_from_bk_color(bk_color bkColor);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>ppm_bk_color_from_color()</b>
tells you to which Berlin-Kay color a certain color is
closest, by way of a fuzzy color matching algorithm:</p>

<pre style="margin-left:11%; margin-top: 1em">    bk_color
    ppm_bk_color_from_color(pixel  color,
                            pixval maxval);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>maxval</i>
is the maxval on which <i>color</i> is based.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_color_from_bk_color()</b>
converts the opposite way: given a Berlin-Kay color, it
gives the color, in <b>pixel</b> form, that best represents
it.</p>

<pre style="margin-left:11%; margin-top: 1em">    pixel
    ppm_color_from_bk_color(bk_color bkColor,
                            pixval   maxval);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>maxval</i>
is the maxval on which the returned color is based.</p>

<p style="margin-left:11%; margin-top: 1em">All of the
facilities in this section were new in Netpbm 10.34 (June
2006).</p>

<p style="margin-left:11%; margin-top: 1em"><b>COLOR NAMES
<br>
System Color Dictionary</b></p>

<p style="margin-left:11%; margin-top: 1em">Netpbm uses the
system&rsquo;s X11 color dictionary (usually in
<b>/usr/lib/X11/rgb.txt</b>). This is the same file the X
Window System typically uses to associate colors with their
names.</p>

<p style="margin-left:11%; margin-top: 1em">The color
dictionary that Netpbm uses is in the file whose name is the
value of the <b>RGBDEF</b> environment variable. If
<b>RGBDEF</b> is not set, Netpbm defaults to the first
existing file from this list:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="10%"></td>
<td width="40%">


<p style="margin-top: 1em"><b>/usr/lib/X11/rgb.txt</b></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="40%">


<p><b>/usr/openwinlib/rgb.txt</b></p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="40%">


<p><b>/usr/X11R6/lib/X11/rgb.txt</b></p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">You can see the
color names from a typical X11 color dictionary, which is
probably very close to what is on your system, along with
the colors,
<a href="http://www.swiss.ai.mit.edu/~jaffer/Color/x11.pdf">here</a>
. <b>This</b> website (1) <br>
shows a bunch of other versions you could use.</p>

<p style="margin-left:11%; margin-top: 1em">Netpbm is
packaged with a color dictionary. A standard Netpbm
installation installs this file as &quot;misc/rgb.txt&quot;
in the Netpbm directory. This color dictionary has colors
from everywhere the Netpbm maintainer could find them, and
is a superset of XFree 86&rsquo;s color dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_parsecolor</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_parsecolor()</b>
interprets a color specification and returns a pixel of the
color that it indicates. The color specification is ASCII
text, in one of these formats:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">a name, as defined in the
<a href="#rgb.txt">system color dictionary</a> .</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>An X11-style hexadecimal specifier:
<tt>rgb:</tt><i>r</i><tt>/</tt><i>g</i><tt>/</tt><i>b, where
r, g, and b are each 1- to 4-digit hexadecimal numbers. For
each, the maxval is the maximum number that can be
represented in the number of hexadecimal digits given.
Example:</i> <tt>rgb:01/ff/8000</tt> <i>specifies 1/255 red
intensity, maximum green intensity, and about half blue
intensity.</i></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><i>&bull;</i></p></td>
<td width="10%"></td>
<td width="78%">


<p>An X11-style decimal specifier:
<tt>rgbi:</tt><i>r</i><tt>/</tt><i>g</i><tt>/</tt><i>b,
where r, g, and b are floating point numbers from 0 to
1.</i></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><i>&bull;</i></p></td>
<td width="10%"></td>
<td width="78%">


<p>an old-X11-style hexadecimal triple: <tt>#rgb</tt>,
<tt>#rrggbb</tt>, <tt>#rrrgggbbb</tt>, or
<tt>#rrrrggggbbbb</tt>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="10%"></td>
<td width="78%">


<p>A triplet of decimal floating point numbers from 0.0 to
1.0, representing red, green, and blue intensities
respectively, separated by commas. E.g.
<tt>1.0,0.5,.25</tt>. This is for backwards compatibility;
it was in use before MIT came up with the similar and
preferred rgbi style).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the color
specification does not conform to any of these formats,
including the case that it is a name, but is not in the
system color dictionary, <b>ppm_parsecolor()
throws</b>an<b>error</b>(1)</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_colorname</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_colorname()</b>
returns a string that describes the color of the given
pixel. If a <a href="#rgb.txt">system color dictionary</a>
is available and the color appears in it,
<b>ppm_colorname()</b> returns the name of the color from
the file. If the color does not appear in a system color
dictionary and <i>hexok</i> is true, <b>ppm_colorname()</b>
returns a hexadecimal color specification triple (#rrggbb).
If a system color dictionary is available but the color does
not appear in it and <i>hexok</i> is false,
<b>ppm_colorname()</b> returns the name of the closest
matching color in the color file. Finally, if there is no
system color dictionary available and <i>hexok</i> is false,
<b>ppm_colorname()</b> fails and
<a href="liberror.html#error">throws an error</a> .</p>

<p style="margin-left:11%; margin-top: 1em">The string
returned is in static libppm library storage which is
overwritten by every call to <b>ppm_colorname()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readcolornamefile</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readcolornamefile()</b>
reads the entire contents of the color dictionary in the
file named <i>fileName</i> into data structures you can use
to access it easily.</p>

<p style="margin-left:11%; margin-top: 1em">The function
returns all the color names as an array of null-terminated
strings. It mallocs the space for this array and returns its
address at <i>colornamesP</i>.
<b>(*colornamesP)[</b><i>i</i><b>]</b> is the address of the
first character in the null-terminated string that is the
name of the <i>i</i>th color in the dictionary.</p>

<p style="margin-left:11%; margin-top: 1em">The function
also returns a <b>colorhash_table</b> (see
<a href="#colorindex">COLOR INDEXING</a> ) that matches all
these color names up to the colors they represent. It
mallocs the space for the <b>colorhash_table</b> and returns
its address at <i>chtP</i>. The number that the
<b>colorhash_table</b> associates with each color is the
index into the color name array described above of the name
of that color.</p>

<p style="margin-left:11%; margin-top: 1em">You may specify
a null pointer for <i>fileName</i> to indicate the default
color dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><i>mustOpen</i>
is a boolean. If it is nonzero, the function fails and
aborts the program if it is unable to open the specified
color dictionary file. If it is zero, though, it simply
treats an unopenable color dictionary as an empty one. The
colorhash and color name array it returns contain no colors
or names.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_readcolornamefile()</b>
was new in Netpbm 10.15 (April 2003).</p>

<p style="margin-left:11%; margin-top: 1em"><b>COLOR
INDEXING</b> <br>
Sometimes in processing images, you want to associate a
value with a particular color. Most often, that&rsquo;s
because you&rsquo;re generating a color mapped graphics
format. In a color mapped graphics format, the raster
contains small numbers, and the file contains a color map
that tells what color each of those small numbers refers to.
If your image has only 256 colors, but each color takes 24
bits to describe, this can make your output file much
smaller than a straightforward RGB raster would.</p>

<p style="margin-left:11%; margin-top: 1em">So, continuing
the above example, say you have a <b>pixel</b> value for
chartreuse and in your output file and you are going to
represent chartreuse by the number 12. You need a data
structure that allows your program quickly to find out that
the number for a chartreuse <b>pixel</b> is 12.
Netpbm&rsquo;s color indexing data types and functions give
you that.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhash_table</b>
is a C data type that associates an integer with each of an
arbitrary number of colors. It is a hash table, so it uses
far less space than an array indexed by the color&rsquo;s
RGB values would.</p>

<p style="margin-left:11%; margin-top: 1em">The problem
with a <b>colorhash_table</b> is that you can only look
things up in it. You can&rsquo;t find out what colors are in
it. So Netpbm has another data type for representing the
same information, the poorly but historically named
<b>colorhist_vector</b>. A <b>colorhist_vector</b> is just
an array. Each entry represents a color and contains the
color&rsquo;s value (as a <b>pixel</b>) and the integer
value associated with it. The entries are filled in starting
with subscript 0 and going consecutively up for the number
of colors in the histogram.</p>

<p style="margin-left:11%; margin-top: 1em">(The reason the
name is poor is because a color histogram is only one of
many things that could be represented by it).</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhash_table
ppm_alloccolorhash()</b></p>

<p style="margin-left:11%; margin-top: 1em">This creates a
<b>colorhash_table</b> using dynamically allocated storage.
There are no colors in it. If there is not enough storage,
<a href="liberror.html#error">throws an error</a> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ppm_freecolorhash()</b></p>

<p style="margin-left:11%; margin-top: 1em">This destroys a
<b>ppm_freecolorhash</b> and frees all the storage
associated with it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ppm_addtocolorhash( colorhash_table cht, const pixel * const
colorP, const int value)</b></p>

<p style="margin-left:11%; margin-top: 1em">This adds the
specified color to the specified <b>colorhash_table</b> <br>
and associates the specified value with it.</p>

<p style="margin-left:11%; margin-top: 1em">You must ensure
that the color you are adding isn&rsquo;t already present in
the <b>colorhash_table</b>.</p>

<p style="margin-left:11%; margin-top: 1em">There is no way
to update an entry or delete an entry from a
<b>colorhash_table</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ppm_lookupcolor( const colorhash_table cht, const pixel *
const colorP )</b></p>

<p style="margin-left:11%; margin-top: 1em">This looks up
the specified color in the specified <b>colorhash_table</b>.
It returns the integer value associated with that color.</p>

<p style="margin-left:11%; margin-top: 1em">If the
specified color is not in the hash table, the function
returns -1. (So if you assign the value -1 to a color, the
return value is ambiguous).</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhist_vector
ppm_colorhashtocolorhist( const colorhash_table cht,</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const int
ncolors )</b></p>

<p style="margin-left:11%; margin-top: 1em">This converts a
<b>colorhash_table</b> to a <b>colorhist_vector</b>. The
return value is a new <b>colorhist_vector</b> which you must
eventually free with <b>ppm_freecolorhist()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ncolors</b>
is the number of colors in <b>cht</b>. If it has more colors
than that, <b>ppm_colorhashtocolorhist</b> does not create a
<b>colorhist_vector</b> and returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhash_table
ppm_colorhisttocolorhash( const colorhist_vector chv, const
int ncolors )</b></p>

<p style="margin-left:11%; margin-top: 1em">This poorly
named function does <i>not</i> convert from a
<b>colorhist_vector</b> to a <b>colorhash_table</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It does create
a <b>colorhash_table</b> based on a <b>colorhist_vector</b>
input, but the integer value for a given color in the output
is not the same as the integer value for that same color in
the input. <b>ppm_colorhisttocolorhash()</b> ignores the
integer values in the input. In the output, the integer
value for a color is the index in the input
<b>colorhist_vector</b> for that color.</p>

<p style="margin-left:11%; margin-top: 1em">You can easily
create a color map for an image by running
<b>ppm_computecolorhist()</b> over the image, then
<b>ppm_colorhisttocolorhash()</b> over the result. Now you
can use <b>ppm_lookupcolor()</b> to find a unique color
index for any pixel in the input.</p>

<p style="margin-left:11%; margin-top: 1em">If the same
color appears twice in the input,
<b>ppm_colorhisttocolorhash()</b>
<a href="liberror.html#error">throws an error</a> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>ncolors</b>
is the number of colors in <b>chv</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is a new <b>colorhash_table</b> which you must
eventually free with <b>ppm_freecolorhash()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>COLOR
HISTOGRAMS</b> <br>
The Netpbm libraries give you functions to examine a Netpbm
image and determine what colors are in it and how many
pixels of each color are in it. This information is known as
a color histogram. Netpbm uses its <b>colorhash_table</b>
data type to represent a color histogram.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhash_table
ppm_computecolorhash( pixel ** const pixels, const int cols,
const int rows, const int maxcolors, int* const colorsP
)</b></p>

<p style="margin-left:11%; margin-top: 1em">This poorly but
historically named function generates a
<b>colorhash_table</b> whose value for each color is the
number of pixels in a specified image that have that color.
(I.e. a color histogram). As a bonus, it returns the number
of colors in the image.</p>

<p style="margin-left:11%; margin-top: 1em">(It&rsquo;s
poorly named because not all <b>colorhash_table</b>s are
color histograms, but that&rsquo;s all it generates).</p>

<p style="margin-left:11%; margin-top: 1em"><b>pixels</b>,
<b>cols</b>, and <b>rows</b> describe the input image.</p>


<p style="margin-left:11%; margin-top: 1em"><b>maxcolors</b>
is the maximum number of colors you want processed. If there
are more colors that that in the input image,
<b>ppm_computecolorhash()</b> returns NULL as its return
value and stops processing as soon as it discovers this.
This makes it run faster and use less memory. One use for
<b>maxcolors</b> is when you just want to find out whether
or not the image has more than N colors and don&rsquo;t want
to wait to generate a huge color table if so. If you
don&rsquo;t want any limit on the number of colors, specify
<b>maxcolors</b>=<b>0</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ppm_computecolorhash()</b>
returns the actual number of colors in the image as
<b>*colorsP</b>, but only if it is less than or equal to
<b>maxcolors</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhash_table
ppm_computecolorhash2( FILE * const ifp, const int cols,
const int rows, const pixval maxval, const int
format,</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>const int
maxcolors, int* const colorsP )</b></p>

<p style="margin-left:11%; margin-top: 1em">This is the
same as <b>ppm_computecolorhash()</b> except that instead of
feeding it an array of pixels in storage, you give it an
open file stream and it reads the image from the file. The
file must be positioned after the header, at the raster.
Upon return, the file is still open, but its position is
undefined.</p>

<p style="margin-left:11%; margin-top: 1em"><b>maxval</b>
and <b>format</b> are the values for the image (i.e.
information from the file&rsquo;s header).</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhist_vector
ppm_computecolorhist( pixel ** pixels, int cols, int rows,
int maxcolors, int * colorsP )</b></p>

<p style="margin-left:11%; margin-top: 1em">This is like
<b>ppm_computecolorhash()</b> except that it creates a
<b>colorhist_vector</b> instead of a
<b>colorhash_table</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If you supply a
nonzero <b>maxcolors</b> argument, that is the maximum
number of colors you expect to find in the input image. If
there are more colors than you say in the image,
<b>ppm_computecolorhist()</b> returns a null pointer as its
return value and nothing meaningful as <b>*colorsP</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If not, the
function returns the new <b>colorhist_vector</b> as its
return value and the actual number of colors in the image as
<b>*colorsP</b>. The returned array has space allocated for
the specified number of colors regardless of how many
actually exist. The extra space is at the high end of the
array and is available for your use in expanding the
<b>colorhist_vector</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If you specify
<b>maxcolors</b>=<b>0</b>, there is no limit on the number
of colors returned and the return array has space for 5
extra colors at the high end for your use in expanding the
<b>colorhist_vector</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorhist_vector
ppm_computecolorhist2( FILE * ifp, int cols, int rows, int
maxcolors, pixval maxval, int format, int * colorsP
)</b></p>

<p style="margin-left:11%; margin-top: 1em">This is the
same as <b>ppm_computecolorhist()</b> except that instead of
feeding it an array of pixels in storage, you give it an
open file stream and it reads the image from the file. The
file must be positioned after the header, at the raster.
Upon return, the file is still open, but its position is
undefined.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>pbm</b>(1) ,
<b>pgm</b>(1) , <b>libpbm</b>(1)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
1989, 1991 by Tony Hansen and Jef Poskanzer.</p>
<hr>
</body>
</html>
