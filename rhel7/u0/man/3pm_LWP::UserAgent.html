<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:05:32 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LWP::UserAgent</title>

</head>
<body>

<h1 align="center">LWP::UserAgent</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#CONSTRUCTOR METHODS">CONSTRUCTOR METHODS</a><br>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br>
<a href="#REQUEST METHODS">REQUEST METHODS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">LWP::UserAgent
&minus; Web user agent class</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> require LWP::UserAgent;
 my $ua = LWP::UserAgent&minus;&gt;new;
 $ua&minus;&gt;timeout(10);
 $ua&minus;&gt;env_proxy;
 my $response = $ua&minus;&gt;get('http://search.cpan.org/');
 if ($response&minus;&gt;is_success) {
     print $response&minus;&gt;decoded_content;  # or whatever
 }
 else {
     die $response&minus;&gt;status_line;
 }</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;LWP::UserAgent&quot;</tt> is a class implementing
a web user agent. <tt>&quot;LWP::UserAgent&quot;</tt>
objects can be used to dispatch web requests.</p>

<p style="margin-left:11%; margin-top: 1em">In normal use
the application creates an
<tt>&quot;LWP::UserAgent&quot;</tt> object, and then
configures it with values for timeouts, proxies, name, etc.
It then creates an instance of
<tt>&quot;HTTP::Request&quot;</tt> for the request that
needs to be performed. This request is then passed to one of
the request method the UserAgent, which dispatches it using
the relevant protocol, and returns a
<tt>&quot;HTTP::Response&quot;</tt> object. There are
convenience methods for sending the most common request
types: <i>get()</i>, <i>head()</i>, <i>post()</i>,
<i>put()</i> and <i>delete()</i>. When using these methods
then the creation of the request object is hidden as shown
in the synopsis above.</p>

<p style="margin-left:11%; margin-top: 1em">The basic
approach of the library is to use <small>HTTP</small> style
communication for all protocol schemes. This means that you
will construct <tt>&quot;HTTP::Request&quot;</tt> objects
and receive <tt>&quot;HTTP::Response&quot;</tt> objects even
for non-HTTP resources like <i>gopher</i> and <i>ftp</i>. In
order to achieve even more similarity to <small>HTTP</small>
style communications, gopher menus and file directories are
converted to <small>HTML</small> documents.</p>

<h2>CONSTRUCTOR METHODS
<a name="CONSTRUCTOR METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
constructor methods are available: <br>
$ua = LWP::UserAgent&minus;&gt;new( %options )</p>

<p style="margin-left:17%;">This method constructs a new
<tt>&quot;LWP::UserAgent&quot;</tt> object and returns it.
Key/value pair arguments may be provided to set up the
initial state. The following options correspond to attribute
methods described below:</p>

<pre style="margin-left:17%; margin-top: 1em">   KEY                     DEFAULT
   &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;             &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
   agent                   &quot;libwww&minus;perl/#.###&quot;
   from                    undef
   conn_cache              undef
   cookie_jar              undef
   default_headers         HTTP::Headers&minus;&gt;new
   local_address           undef
   ssl_opts                { verify_hostname =&gt; 1 }
   max_size                undef
   max_redirect            7
   parse_head              1
   protocols_allowed       undef
   protocols_forbidden     undef
   requests_redirectable   ['GET', 'HEAD']
   timeout                 180</pre>


<p style="margin-left:17%; margin-top: 1em">The following
additional options are also accepted: If the
<tt>&quot;env_proxy&quot;</tt> option is passed in with a
<small>TRUE</small> value, then proxy settings are read from
environment variables (see <i>env_proxy()</i> method below).
If <tt>&quot;env_proxy&quot;</tt> isn&rsquo;t provided the
<tt>&quot;PERL_LWP_ENV_PROXY&quot;</tt> environment variable
controls if <i>env_proxy()</i> is called during
initialization. If the <tt>&quot;keep_alive&quot;</tt>
option is passed in, then a
<tt>&quot;LWP::ConnCache&quot;</tt> is set up (see
<i>conn_cache()</i> method below). The
<tt>&quot;keep_alive&quot;</tt> value is passed on as the
<tt>&quot;total_capacity&quot;</tt> for the connection
cache.</p>

<p style="margin-left:11%;">$ua&minus;&gt;clone</p>

<p style="margin-left:17%;">Returns a copy of the
LWP::UserAgent object.</p>

<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The settings of
the configuration attributes modify the behaviour of the
<tt>&quot;LWP::UserAgent&quot;</tt> when it dispatches
requests. Most of these can also be initialized by options
passed to the constructor method.</p>

<p style="margin-left:11%; margin-top: 1em">The following
attribute methods are provided. The attribute value is left
unchanged if no argument is given. The return value from
each method is the old attribute value. <br>
$ua&minus;&gt;agent <br>
$ua&minus;&gt;agent( $product_id )</p>

<p style="margin-left:17%;">Get/set the product token that
is used to identify the user agent on the network. The agent
value is sent as the &quot;User-Agent&quot; header in the
requests. The default is the string returned by the
<i>_agent()</i> method (see below).</p>

<p style="margin-left:17%; margin-top: 1em">If the
<tt>$product_id</tt> ends with space then the
<i>_agent()</i> string is appended to it.</p>

<p style="margin-left:17%; margin-top: 1em">The user agent
string should be one or more simple product identifiers with
an optional version number separated by the &quot;/&quot;
character. Examples are:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ua&minus;&gt;agent('Checkbot/0.4 ' . $ua&minus;&gt;_agent);
  $ua&minus;&gt;agent('Checkbot/0.4 ');    # same as above
  $ua&minus;&gt;agent('Mozilla/5.0');
  $ua&minus;&gt;agent(&quot;&quot;);                 # don't identify</pre>


<p style="margin-left:11%;">$ua&minus;&gt;_agent</p>

<p style="margin-left:17%;">Returns the default agent
identifier. This is a string of the form
&quot;libwww&minus;perl/#.###&quot;, where &quot;#.###&quot;
is substituted with the version number of this library.</p>

<p style="margin-left:11%;">$ua&minus;&gt;from <br>
$ua&minus;&gt;from( $email_address )</p>

<p style="margin-left:17%;">Get/set the e&minus;mail
address for the human user who controls the requesting user
agent. The address should be machine-usable, as defined in
<small>RFC 822.</small> The <tt>&quot;from&quot;</tt> value
is send as the &quot;From&quot; header in the requests.
Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ua&minus;&gt;from('gaas@cpan.org');</pre>


<p style="margin-left:17%; margin-top: 1em">The default is
to not send a &quot;From&quot; header. See the
<i>default_headers()</i> method for the more general
interface that allow any header to be defaulted.</p>

<p style="margin-left:11%;">$ua&minus;&gt;cookie_jar <br>
$ua&minus;&gt;cookie_jar( $cookie_jar_obj )</p>

<p style="margin-left:17%;">Get/set the cookie jar object
to use. The only requirement is that the cookie jar object
must implement the extract_cookies($request) and
add_cookie_header($response) methods. These methods will
then be invoked by the user agent as requests are sent and
responses are received. Normally this will be a
<tt>&quot;HTTP::Cookies&quot;</tt> object or some
subclass.</p>

<p style="margin-left:17%; margin-top: 1em">The default is
to have no cookie_jar, i.e. never automatically add
&quot;Cookie&quot; headers to the requests.</p>

<p style="margin-left:17%; margin-top: 1em">Shortcut: If a
reference to a plain hash is passed in as the
<tt>$cookie_jar_object</tt>, then it is replaced with an
instance of <tt>&quot;HTTP::Cookies&quot;</tt> that is
initialized based on the hash. This form also automatically
loads the <tt>&quot;HTTP::Cookies&quot;</tt> module. It
means that:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ua&minus;&gt;cookie_jar({ file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot; });</pre>


<p style="margin-left:17%; margin-top: 1em">is really just
a shortcut for:</p>

<pre style="margin-left:17%; margin-top: 1em">  require HTTP::Cookies;
  $ua&minus;&gt;cookie_jar(HTTP::Cookies&minus;&gt;new(file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot;));</pre>


<p style="margin-left:11%;">$ua&minus;&gt;default_headers
<br>
$ua&minus;&gt;default_headers( $headers_obj )</p>

<p style="margin-left:17%;">Get/set the headers object that
will provide default header values for any requests sent. By
default this will be an empty
<tt>&quot;HTTP::Headers&quot;</tt> object.</p>

<p style="margin-left:11%;">$ua&minus;&gt;default_header(
$field ) <br>
$ua&minus;&gt;default_header( $field =&gt; $value )</p>

<p style="margin-left:17%;">This is just a short-cut for
<tt>$ua</tt>&minus;&gt;default_headers&minus;&gt;header(
<tt>$field</tt> =&gt; <tt>$value</tt> ). Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ua&minus;&gt;default_header('Accept&minus;Encoding' =&gt; scalar HTTP::Message::decodable());
  $ua&minus;&gt;default_header('Accept&minus;Language' =&gt; &quot;no, en&quot;);</pre>


<p style="margin-left:11%;">$ua&minus;&gt;conn_cache <br>
$ua&minus;&gt;conn_cache( $cache_obj )</p>

<p style="margin-left:17%;">Get/set the
<tt>&quot;LWP::ConnCache&quot;</tt> object to use. See
LWP::ConnCache for details.</p>

<p style="margin-left:11%;">$ua&minus;&gt;credentials(
$netloc, $realm ) <br>
$ua&minus;&gt;credentials( $netloc, $realm, $uname, $pass
)</p>

<p style="margin-left:17%;">Get/set the user name and
password to be used for a realm.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$netloc</tt> is a string of the form
&quot;&lt;host&gt;:&lt;port&gt;&quot;. The username and
password will only be passed to this server. Example:</p>

<pre style="margin-left:17%; margin-top: 1em">  $ua&minus;&gt;credentials(&quot;www.example.com:80&quot;, &quot;Some Realm&quot;, &quot;foo&quot;, &quot;secret&quot;);</pre>


<p style="margin-left:11%;">$ua&minus;&gt;local_address
<br>
$ua&minus;&gt;local_address( $address )</p>

<p style="margin-left:17%;">Get/set the local interface to
bind to for network connections. The interface can be
specified as a hostname or an <small>IP</small> address.
This value is passed as the <tt>&quot;LocalAddr&quot;</tt>
argument to IO::Socket::INET.</p>

<p style="margin-left:11%;">$ua&minus;&gt;max_size <br>
$ua&minus;&gt;max_size( $bytes )</p>

<p style="margin-left:17%;">Get/set the size limit for
response content. The default is <tt>&quot;undef&quot;</tt>,
which means that there is no limit. If the returned response
content is only partial, because the size limit was
exceeded, then a &quot;Client-Aborted&quot; header will be
added to the response. The content might end up longer than
<tt>&quot;max_size&quot;</tt> as we abort once appending a
chunk of data makes the length exceed the limit. The
&quot;Content-Length&quot; header, if present, will indicate
the length of the full content and will normally not be the
same as
<tt>&quot;length($res&minus;&gt;content)&quot;</tt>.</p>

<p style="margin-left:11%;">$ua&minus;&gt;max_redirect <br>
$ua&minus;&gt;max_redirect( $n )</p>

<p style="margin-left:17%;">This reads or sets the
object&rsquo;s limit of how many times it will obey
redirection responses in a given request cycle.</p>

<p style="margin-left:17%; margin-top: 1em">By default, the
value is 7. This means that if you call <i>request()</i>
method and the response is a redirect elsewhere which is in
turn a redirect, and so on seven times, then
<small>LWP</small> gives up after that seventh request.</p>

<p style="margin-left:11%;">$ua&minus;&gt;parse_head <br>
$ua&minus;&gt;parse_head( $boolean )</p>

<p style="margin-left:17%;">Get/set a value indicating
whether we should initialize response headers from the
&lt;head&gt; section of <small>HTML</small> documents. The
default is <small>TRUE.</small> Do not turn this off, unless
you know what you are doing.</p>


<p style="margin-left:11%;">$ua&minus;&gt;protocols_allowed
<br>
$ua&minus;&gt;protocols_allowed( \@protocols )</p>

<p style="margin-left:17%;">This reads (or sets) this user
agent&rsquo;s list of protocols that the request methods
will exclusively allow. The protocol names are case
insensitive.</p>

<p style="margin-left:17%; margin-top: 1em">For example:
<tt>&quot;$ua&minus;&gt;protocols_allowed( [ 'http',
'https'] );&quot;</tt> means that this user agent will
<i>allow only</i> those protocols, and attempts to use this
user agent to access URLs with any other schemes (like
&quot;ftp://...&quot;) will result in a 500 error.</p>

<p style="margin-left:17%; margin-top: 1em">To delete the
list, call:
<tt>&quot;$ua&minus;&gt;protocols_allowed(undef)&quot;</tt></p>

<p style="margin-left:17%; margin-top: 1em">By default, an
object has neither a <tt>&quot;protocols_allowed&quot;</tt>
list, nor a <tt>&quot;protocols_forbidden&quot;</tt>
list.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
having a <tt>&quot;protocols_allowed&quot;</tt> list causes
any <tt>&quot;protocols_forbidden&quot;</tt> list to be
ignored.</p>


<p style="margin-left:11%;">$ua&minus;&gt;protocols_forbidden
<br>
$ua&minus;&gt;protocols_forbidden( \@protocols )</p>

<p style="margin-left:17%;">This reads (or sets) this user
agent&rsquo;s list of protocols that the request method will
<i>not</i> allow. The protocol names are case
insensitive.</p>

<p style="margin-left:17%; margin-top: 1em">For example:
<tt>&quot;$ua&minus;&gt;protocols_forbidden( [ 'file',
'mailto'] );&quot;</tt> means that this user agent will
<i>not</i> allow those protocols, and attempts to use this
user agent to access URLs with those schemes will result in
a 500 error.</p>

<p style="margin-left:17%; margin-top: 1em">To delete the
list, call:
<tt>&quot;$ua&minus;&gt;protocols_forbidden(undef)&quot;</tt></p>


<p style="margin-left:11%;">$ua&minus;&gt;requests_redirectable
<br>
$ua&minus;&gt;requests_redirectable( \@requests )</p>

<p style="margin-left:17%;">This reads or sets the
object&rsquo;s list of request names that
<tt>&quot;$ua&minus;&gt;redirect_ok(...)&quot;</tt> will
allow redirection for. By default, this is <tt>&quot;['GET',
'HEAD']&quot;</tt>, as per <small>RFC 2616.</small> To
change to include &rsquo; <small>POST</small> &rsquo;,
consider:</p>

<pre style="margin-left:17%; margin-top: 1em">   push @{ $ua&minus;&gt;requests_redirectable }, 'POST';</pre>


<p style="margin-left:11%;">$ua&minus;&gt;show_progress
<br>
$ua&minus;&gt;show_progress( $boolean )</p>

<p style="margin-left:17%;">Get/set a value indicating
whether a progress bar should be displayed on on the
terminal as requests are processed. The default is
<small>FALSE.</small></p>

<p style="margin-left:11%;">$ua&minus;&gt;timeout <br>
$ua&minus;&gt;timeout( $secs )</p>

<p style="margin-left:17%;">Get/set the timeout value in
seconds. The default <i>timeout()</i> value is 180 seconds,
i.e. 3 minutes.</p>

<p style="margin-left:17%; margin-top: 1em">The requests is
aborted if no activity on the connection to the server is
observed for <tt>&quot;timeout&quot;</tt> seconds. This
means that the time it takes for the complete transaction
and the <i>request()</i> method to actually return might be
longer.</p>

<p style="margin-left:11%;">$ua&minus;&gt;ssl_opts <br>
$ua&minus;&gt;ssl_opts( $key ) <br>
$ua&minus;&gt;ssl_opts( $key =&gt; $value )</p>

<p style="margin-left:17%;">Get/set the options for
<small>SSL</small> connections. Without argument return the
list of options keys currently set. With a single argument
return the current value for the given option. With 2
arguments set the option value and return the old. Setting
an option to the value <tt>&quot;undef&quot;</tt> removes
this option.</p>

<p style="margin-left:17%; margin-top: 1em">The options
that <small>LWP</small> relates to are: <br>
&quot;verify_hostname&quot; =&gt; $bool</p>

<p style="margin-left:23%;">When <small>TRUE LWP</small>
will for secure protocol schemes ensure it connects to
servers that have a valid certificate matching the expected
hostname. If <small>FALSE</small> no checks are made and you
can&rsquo;t be sure that you communicate with the expected
peer. The no checks behaviour was the default for
libwww&minus;perl&minus;5.837 and earlier releases.</p>

<p style="margin-left:23%; margin-top: 1em">This option is
initialized from the
<small>PERL_LWP_SSL_VERIFY_HOSTNAME</small> environment
variable. If this environment variable isn&rsquo;t set; then
<tt>&quot;verify_hostname&quot;</tt> defaults to 1.</p>

<p style="margin-left:17%;">&quot;SSL_ca_file&quot; =&gt;
$path</p>

<p style="margin-left:23%;">The path to a file containing
Certificate Authority certificates. A default setting for
this option is provided by checking the environment
variables <tt>&quot;PERL_LWP_SSL_CA_FILE&quot;</tt> and
<tt>&quot;HTTPS_CA_FILE&quot;</tt> in order.</p>

<p style="margin-left:17%;">&quot;SSL_ca_path&quot; =&gt;
$path</p>

<p style="margin-left:23%;">The path to a directory
containing files containing Certificate Authority
certificates. A default setting for this option is provided
by checking the environment variables
<tt>&quot;PERL_LWP_SSL_CA_PATH&quot;</tt> and
<tt>&quot;HTTPS_CA_DIR&quot;</tt> in order.</p>

<p style="margin-left:17%; margin-top: 1em">Other options
can be set and are processed directly by the
<small>SSL</small> Socket implementation in use. See
IO::Socket::SSL or Net::SSL for details.</p>

<p style="margin-left:17%; margin-top: 1em">The libwww-perl
core no longer bundles protocol plugins for
<small>SSL.</small> You will need to install
LWP::Protocol::https separately to enable support for
processing https-URLs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Proxy
attributes</b> <br>
The following methods set up when requests should be passed
via a proxy server. <br>
$ua&minus;&gt;proxy(\@schemes, $proxy_url) <br>
$ua&minus;&gt;proxy($scheme, $proxy_url)</p>

<p style="margin-left:17%;">Set/retrieve proxy
<small>URL</small> for a scheme:</p>

<pre style="margin-left:17%; margin-top: 1em"> $ua&minus;&gt;proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
 $ua&minus;&gt;proxy('gopher', 'http://proxy.sn.no:8001/');</pre>


<p style="margin-left:17%; margin-top: 1em">The first form
specifies that the <small>URL</small> is to be used for
proxying of access methods listed in the list in the first
method argument, i.e. &rsquo;http&rsquo; and
&rsquo;ftp&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">The second form
shows a shorthand form for specifying proxy
<small>URL</small> for a single access scheme.</p>

<p style="margin-left:11%;">$ua&minus;&gt;no_proxy(
$domain, ... )</p>

<p style="margin-left:17%;">Do not proxy requests to the
given domains. Calling no_proxy without any domains clears
the list of domains. Eg:</p>

<pre style="margin-left:17%; margin-top: 1em"> $ua&minus;&gt;no_proxy('localhost', 'example.com');</pre>


<p style="margin-left:11%;">$ua&minus;&gt;env_proxy</p>

<p style="margin-left:17%;">Load proxy settings from
*_proxy environment variables. You might specify proxies
like this (sh-syntax):</p>

<pre style="margin-left:17%; margin-top: 1em">  gopher_proxy=http://proxy.my.place/
  wais_proxy=http://proxy.my.place/
  no_proxy=&quot;localhost,example.com&quot;
  export gopher_proxy wais_proxy no_proxy</pre>


<p style="margin-left:17%; margin-top: 1em">csh or tcsh
users should use the <tt>&quot;setenv&quot;</tt> command to
define these environment variables.</p>

<p style="margin-left:17%; margin-top: 1em">On systems with
case insensitive environment variables there exists a name
clash between the <small>CGI</small> environment variables
and the <tt>&quot;HTTP_PROXY&quot;</tt> environment variable
normally picked up by <i>env_proxy()</i>. Because of this
<tt>&quot;HTTP_PROXY&quot;</tt> is not honored for
<small>CGI</small> scripts. The
<tt>&quot;CGI_HTTP_PROXY&quot;</tt> environment variable can
be used instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Handlers</b>
<br>
Handlers are code that injected at various phases during the
processing of requests. The following methods are provided
to manage the active handlers: <br>
$ua&minus;&gt;add_handler( $phase =&gt; \&amp;cb, %matchspec
)</p>

<p style="margin-left:17%;">Add handler to be invoked in
the given processing phase. For how to specify
<tt>%matchspec</tt> see &quot;Matching&quot; in
HTTP::Config.</p>

<p style="margin-left:17%; margin-top: 1em">The possible
values <tt>$phase</tt> and the corresponding callback
signatures are: <br>
request_preprepare =&gt; sub { my($request, $ua, $h) = @_;
... }</p>

<p style="margin-left:23%;">The handler is called before
the <tt>&quot;request_prepare&quot;</tt> and other standard
initialization of of the request. This can be used to set up
headers and attributes that the
<tt>&quot;request_prepare&quot;</tt> handler depends on.
Proxy initialization should take place here; but in general
don&rsquo;t register handlers for this phase.</p>

<p style="margin-left:17%;">request_prepare =&gt; sub {
my($request, $ua, $h) = @_; ... }</p>

<p style="margin-left:23%;">The handler is called before
the request is sent and can modify the request any way it
see fit. This can for instance be used to add certain
headers to specific requests.</p>

<p style="margin-left:23%; margin-top: 1em">The method can
assign a new request object to <tt>$_</tt>[0] to replace the
request that is sent fully.</p>

<p style="margin-left:23%; margin-top: 1em">The return
value from the callback is ignored. If an exception is
raised it will abort the request and make the request method
return a &quot;400 Bad request&quot; response.</p>

<p style="margin-left:17%;">request_send =&gt; sub {
my($request, $ua, $h) = @_; ... }</p>

<p style="margin-left:23%;">This handler gets a chance of
handling requests before they&rsquo;re sent to the protocol
handlers. It should return an HTTP::Response object if it
wishes to terminate the processing; otherwise it should
return nothing.</p>

<p style="margin-left:23%; margin-top: 1em">The
<tt>&quot;response_header&quot;</tt> and
<tt>&quot;response_data&quot;</tt> handlers will not be
invoked for this response, but the
<tt>&quot;response_done&quot;</tt> will be.</p>

<p style="margin-left:17%;">response_header =&gt; sub {
my($response, $ua, $h) = @_; ... }</p>

<p style="margin-left:23%;">This handler is called right
after the response headers have been received, but before
any content data. The handler might set up handlers for data
and might croak to abort the request.</p>

<p style="margin-left:23%; margin-top: 1em">The handler
might set the
<tt>$response</tt>&minus;&gt;{default_add_content} value to
control if any received data should be added to the response
object directly. This will initially be false if the
<tt>$ua</tt>&minus;&gt;<i>request()</i> method was called
with a <tt>$content_file</tt> or <tt>$content_cb</tt>
argument; otherwise true.</p>

<p style="margin-left:17%;">response_data =&gt; sub {
my($response, $ua, $h, $data) = @_; ... }</p>

<p style="margin-left:23%;">This handler is called for each
chunk of data received for the response. The handler might
croak to abort the request.</p>

<p style="margin-left:23%; margin-top: 1em">This handler
needs to return a <small>TRUE</small> value to be called
again for subsequent chunks for the same request.</p>

<p style="margin-left:17%;">response_done =&gt; sub {
my($response, $ua, $h) = @_; ... }</p>

<p style="margin-left:23%;">The handler is called after the
response has been fully received, but before any redirect
handling is attempted. The handler can be used to extract
information or modify the response.</p>

<p style="margin-left:17%;">response_redirect =&gt; sub {
my($response, $ua, $h) = @_; ... }</p>

<p style="margin-left:23%;">The handler is called in
<tt>$ua</tt>&minus;&gt;request after
<tt>&quot;response_done&quot;</tt>. If the handler returns
an HTTP::Request object we&rsquo;ll start over with
processing this request instead.</p>

<p style="margin-left:11%;">$ua&minus;&gt;remove_handler(
undef, %matchspec ) <br>
$ua&minus;&gt;remove_handler( $phase, %matchspec )</p>

<p style="margin-left:17%;">Remove handlers that match the
given <tt>%matchspec</tt>. If <tt>$phase</tt> is not
provided remove handlers from all phases.</p>

<p style="margin-left:17%; margin-top: 1em">Be careful as
calling this function with <tt>%matchspec</tt> that is not
not specific enough can remove handlers not owned by you.
It&rsquo;s probably better to use the
<i>set_my_handler()</i> method instead.</p>

<p style="margin-left:17%; margin-top: 1em">The removed
handlers are returned.</p>

<p style="margin-left:11%;">$ua&minus;&gt;set_my_handler(
$phase, $cb, %matchspec )</p>

<p style="margin-left:17%;">Set handlers private to the
executing subroutine. Works by defaulting an
<tt>&quot;owner&quot;</tt> field to the <tt>%matchspec</tt>
that holds the name of the called subroutine. You might pass
an explicit <tt>&quot;owner&quot;</tt> to override this.</p>

<p style="margin-left:17%; margin-top: 1em">If <tt>$cb</tt>
is passed as <tt>&quot;undef&quot;</tt>, remove the
handler.</p>

<p style="margin-left:11%;">$ua&minus;&gt;get_my_handler(
$phase, %matchspec ) <br>
$ua&minus;&gt;get_my_handler( $phase, %matchspec, $init
)</p>

<p style="margin-left:17%;">Will retrieve the matching
handler as hash ref.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>$init</tt> is passed passed as a <small>TRUE</small>
value, create and add the handler if it&rsquo;s not found.
If <tt>$init</tt> is a subroutine reference, then it&rsquo;s
called with the created handler hash as argument. This sub
might populate the hash with extra fields; especially the
callback. If <tt>$init</tt> is a hash reference, merge the
hashes.</p>

<p style="margin-left:11%;">$ua&minus;&gt;handlers( $phase,
$request ) <br>
$ua&minus;&gt;handlers( $phase, $response )</p>

<p style="margin-left:17%;">Returns the handlers that apply
to the given request or response at the given processing
phase.</p>

<h2>REQUEST METHODS
<a name="REQUEST METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The methods
described in this section are used to dispatch requests via
the user agent. The following request methods are provided:
<br>
$ua&minus;&gt;get( $url ) <br>
$ua&minus;&gt;get( $url , $field_name =&gt; $value, ...
)</p>

<p style="margin-left:17%;">This method will dispatch a
<tt>&quot;GET&quot;</tt> request on the given <tt>$url</tt>.
Further arguments can be given to initialize the headers of
the request. These are given as separate name/value pairs.
The return value is a response object. See HTTP::Response
for a description of the interface it provides.</p>

<p style="margin-left:17%; margin-top: 1em">There will
still be a response object returned when <small>LWP</small>
can&rsquo;t connect to the server specified in the
<small>URL</small> or when other failures in protocol
handlers occur. These internal responses use the standard
<small>HTTP</small> status codes, so the responses
can&rsquo;t be differentiated by testing the response status
code alone. Error responses that <small>LWP</small>
generates internally will have the
&quot;Client-Warning&quot; header set to the value
&quot;Internal response&quot;. If you need to differentiate
these internal responses from responses that a remote server
actually generates, you need to test this header value.</p>

<p style="margin-left:17%; margin-top: 1em">Fields names
that start with &quot;:&quot; are special. These will not
initialize headers of the request but will determine how the
response content is treated. The following special field
names are recognized:</p>

<pre style="margin-left:17%; margin-top: 1em">    :content_file   =&gt; $filename
    :content_cb     =&gt; \&amp;callback
    :read_size_hint =&gt; $bytes</pre>


<p style="margin-left:17%; margin-top: 1em">If a
<tt>$filename</tt> is provided with the
<tt>&quot;:content_file&quot;</tt> option, then the response
content will be saved here instead of in the response
object. If a callback is provided with the
<tt>&quot;:content_cb&quot;</tt> option then this function
will be called for each chunk of the response content as it
is received from the server. If neither of these options are
given, then the response content will accumulate in the
response object itself. This might not be suitable for very
large response bodies. Only one of
<tt>&quot;:content_file&quot;</tt> or
<tt>&quot;:content_cb&quot;</tt> can be specified. The
content of unsuccessful responses will always accumulate in
the response object itself, regardless of the
<tt>&quot;:content_file&quot;</tt> or
<tt>&quot;:content_cb&quot;</tt> options passed in.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;:read_size_hint&quot;</tt> option is passed to the
protocol module which will try to read data from the server
in chunks of this size. A smaller value for the
<tt>&quot;:read_size_hint&quot;</tt> will result in a higher
number of callback invocations.</p>

<p style="margin-left:17%; margin-top: 1em">The callback
function is called with 3 arguments: a chunk of data, a
reference to the response object, and a reference to the
protocol object. The callback can abort the request by
invoking <i>die()</i>. The exception message will show up as
the &quot;X&minus;Died&quot; header field in the response
returned by the <i>get()</i> function.</p>

<p style="margin-left:11%;">$ua&minus;&gt;head( $url ) <br>
$ua&minus;&gt;head( $url , $field_name =&gt; $value, ...
)</p>

<p style="margin-left:17%;">This method will dispatch a
<tt>&quot;HEAD&quot;</tt> request on the given
<tt>$url</tt>. Otherwise it works like the <i>get()</i>
method described above.</p>

<p style="margin-left:11%;">$ua&minus;&gt;post( $url,
\%form ) <br>
$ua&minus;&gt;post( $url, \@form ) <br>
$ua&minus;&gt;post( $url, \%form, $field_name =&gt; $value,
... ) <br>
$ua&minus;&gt;post( $url, $field_name =&gt; $value,...
Content =&gt; \%form ) <br>
$ua&minus;&gt;post( $url, $field_name =&gt; $value,...
Content =&gt; \@form ) <br>
$ua&minus;&gt;post( $url, $field_name =&gt; $value,...
Content =&gt; $content )</p>

<p style="margin-left:17%;">This method will dispatch a
<tt>&quot;POST&quot;</tt> request on the given
<tt>$url</tt>, with <tt>%form</tt> or <tt>@form</tt>
providing the key/value pairs for the fill-in form content.
Additional headers and content options are the same as for
the <i>get()</i> method.</p>

<p style="margin-left:17%; margin-top: 1em">This method
will use the <i><small>POST</small> ()</i> function from
<tt>&quot;HTTP::Request::Common&quot;</tt> to build the
request. See HTTP::Request::Common for a details on how to
pass form content and other advanced features.</p>

<p style="margin-left:11%;">$ua&minus;&gt;put( $url, \%form
) <br>
$ua&minus;&gt;put( $url, \@form ) <br>
$ua&minus;&gt;put( $url, \%form, $field_name =&gt; $value,
... ) <br>
$ua&minus;&gt;put( $url, $field_name =&gt; $value,...
Content =&gt; \%form ) <br>
$ua&minus;&gt;put( $url, $field_name =&gt; $value,...
Content =&gt; \@form ) <br>
$ua&minus;&gt;put( $url, $field_name =&gt; $value,...
Content =&gt; $content )</p>

<p style="margin-left:17%;">This method will dispatch a
<tt>&quot;PUT&quot;</tt> request on the given <tt>$url</tt>,
with <tt>%form</tt> or <tt>@form</tt> providing the
key/value pairs for the fill-in form content. Additional
headers and content options are the same as for the
<i>get()</i> method.</p>

<p style="margin-left:17%; margin-top: 1em">This method
will use the <i><small>PUT</small> ()</i> function from
<tt>&quot;HTTP::Request::Common&quot;</tt> to build the
request. See HTTP::Request::Common for a details on how to
pass form content and other advanced features.</p>

<p style="margin-left:11%;">$ua&minus;&gt;delete( $url )
<br>
$ua&minus;&gt;delete( $url, $field_name =&gt; $value, ...
)</p>

<p style="margin-left:17%;">This method will dispatch a
<tt>&quot;DELETE&quot;</tt> request on the given
<tt>$url</tt>. Additional headers and content options are
the same as for the <i>get()</i> method.</p>

<p style="margin-left:17%; margin-top: 1em">This method
will use the <i><small>DELETE</small> ()</i> function from
<tt>&quot;HTTP::Request::Common&quot;</tt> to build the
request. See HTTP::Request::Common for a details on how to
pass form content and other advanced features.</p>

<p style="margin-left:11%;">$ua&minus;&gt;mirror( $url,
$filename )</p>

<p style="margin-left:17%;">This method will get the
document identified by <tt>$url</tt> and store it in file
called <tt>$filename</tt>. If the file already exists, then
the request will contain an &quot;If-Modified-Since&quot;
header matching the modification time of the file. If the
document on the server has not changed since this time, then
nothing happens. If the document has been updated, it will
be downloaded again. The modification time of the file will
be forced to match that of the server.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is the the response object.</p>

<p style="margin-left:11%;">$ua&minus;&gt;request( $request
) <br>
$ua&minus;&gt;request( $request, $content_file ) <br>
$ua&minus;&gt;request( $request, $content_cb ) <br>
$ua&minus;&gt;request( $request, $content_cb,
$read_size_hint )</p>

<p style="margin-left:17%;">This method will dispatch the
given <tt>$request</tt> object. Normally this will be an
instance of the <tt>&quot;HTTP::Request&quot;</tt> class,
but any object with a similar interface will do. The return
value is a response object. See HTTP::Request and
HTTP::Response for a description of the interface provided
by these classes.</p>

<p style="margin-left:17%; margin-top: 1em">The
<i>request()</i> method will process redirects and
authentication responses transparently. This means that it
may actually send several simple requests via the
<i>simple_request()</i> method described below.</p>

<p style="margin-left:17%; margin-top: 1em">The request
methods described above; <i>get()</i>, <i>head()</i>,
<i>post()</i> and <i>mirror()</i>, will all dispatch the
request they build via this method. They are convenience
methods that simply hides the creation of the request object
for you.</p>

<p style="margin-left:17%; margin-top: 1em">The
<tt>$content_file</tt>, <tt>$content_cb</tt> and
<tt>$read_size_hint</tt> all correspond to options described
with the <i>get()</i> method above.</p>

<p style="margin-left:17%; margin-top: 1em">You are allowed
to use a <small>CODE</small> reference as
<tt>&quot;content&quot;</tt> in the request object passed
in. The <tt>&quot;content&quot;</tt> function should return
the content when called. The content can be returned in
chunks. The content function will be invoked repeatedly
until it return an empty string to signal that there is no
more content.</p>

<p style="margin-left:11%;">$ua&minus;&gt;simple_request(
$request ) <br>
$ua&minus;&gt;simple_request( $request, $content_file ) <br>
$ua&minus;&gt;simple_request( $request, $content_cb ) <br>
$ua&minus;&gt;simple_request( $request, $content_cb,
$read_size_hint )</p>

<p style="margin-left:17%;">This method dispatches a single
request and returns the response received. Arguments are the
same as for <i>request()</i> described above.</p>

<p style="margin-left:17%; margin-top: 1em">The difference
from <i>request()</i> is that <i>simple_request()</i> will
not try to handle redirects or authentication responses. The
<i>request()</i> method will in fact invoke this method for
each simple request it sends.</p>

<p style="margin-left:11%;">$ua&minus;&gt;is_online</p>

<p style="margin-left:17%;">Tries to determine if you have
access to the Internet. Returns <small>TRUE</small> if the
built-in heuristics determine that the user agent is able to
access the Internet (over <small>HTTP</small> ). See also
LWP::Online.</p>


<p style="margin-left:11%;">$ua&minus;&gt;is_protocol_supported(
$scheme )</p>

<p style="margin-left:17%;">You can use this method to test
whether this user agent object supports the specified
<tt>&quot;scheme&quot;</tt>. (The
<tt>&quot;scheme&quot;</tt> might be a string (like
&rsquo;http&rsquo; or &rsquo;ftp&rsquo;) or it might be an
<small>URI</small> object reference.)</p>

<p style="margin-left:17%; margin-top: 1em">Whether a
scheme is supported, is determined by the user agent&rsquo;s
<tt>&quot;protocols_allowed&quot;</tt> or
<tt>&quot;protocols_forbidden&quot;</tt> lists (if any), and
by the capabilities of <small>LWP. I</small> .e., this will
return <small>TRUE</small> only if <small>LWP</small>
supports this protocol <i>and</i> it&rsquo;s permitted for
this particular object.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Callback
methods</b> <br>
The following methods will be invoked as requests are
processed. These methods are documented here because
subclasses of <tt>&quot;LWP::UserAgent&quot;</tt> might want
to override their behaviour. <br>
$ua&minus;&gt;prepare_request( $request )</p>

<p style="margin-left:17%;">This method is invoked by
<i>simple_request()</i>. Its task is to modify the given
<tt>$request</tt> object by setting up various headers based
on the attributes of the user agent. The return value should
normally be the <tt>$request</tt> object passed in. If a
different request object is returned it will be the one
actually processed.</p>

<p style="margin-left:17%; margin-top: 1em">The headers
affected by the base implementation are;
&quot;User-Agent&quot;, &quot;From&quot;, &quot;Range&quot;
and &quot;Cookie&quot;.</p>

<p style="margin-left:11%;">$ua&minus;&gt;redirect_ok(
$prospective_request, $response )</p>

<p style="margin-left:17%;">This method is called by
<i>request()</i> before it tries to follow a redirection to
the request in <tt>$response</tt>. This should return a
<small>TRUE</small> value if this redirection is
permissible. The <tt>$prospective_request</tt> will be the
request to be sent if this method returns
<small>TRUE.</small></p>

<p style="margin-left:17%; margin-top: 1em">The base
implementation will return <small>FALSE</small> unless the
method is in the object&rsquo;s
<tt>&quot;requests_redirectable&quot;</tt> list,
<small>FALSE</small> if the proposed redirection is to a
&quot;file://...&quot; <small>URL,</small> and
<small>TRUE</small> otherwise.</p>


<p style="margin-left:11%;">$ua&minus;&gt;get_basic_credentials(
$realm, $uri, $isproxy )</p>

<p style="margin-left:17%;">This is called by
<i>request()</i> to retrieve credentials for documents
protected by Basic or Digest Authentication. The arguments
passed in is the <tt>$realm</tt> provided by the server, the
<tt>$uri</tt> requested and a boolean flag to indicate if
this is authentication against a proxy server.</p>

<p style="margin-left:17%; margin-top: 1em">The method
should return a username and password. It should return an
empty list to abort the authentication resolution attempt.
Subclasses can override this method to prompt the user for
the information. An example of this can be found in
<tt>&quot;lwp&minus;request&quot;</tt> program distributed
with this library.</p>

<p style="margin-left:17%; margin-top: 1em">The base
implementation simply checks a set of pre-stored member
variables, set up with the <i>credentials()</i> method.</p>

<p style="margin-left:11%;">$ua&minus;&gt;progress(
$status, $request_or_response )</p>

<p style="margin-left:17%;">This is called frequently as
the response is received regardless of how the content is
processed. The method is called with <tt>$status</tt>
&quot;begin&quot; at the start of processing the request and
with <tt>$state</tt> &quot;end&quot; before the request
method returns. In between these <tt>$status</tt> will be
the fraction of the response currently received or the
string &quot;tick&quot; if the fraction can&rsquo;t be
calculated.</p>

<p style="margin-left:17%; margin-top: 1em">When
<tt>$status</tt> is &quot;begin&quot; the second argument is
the request object, otherwise it is the response object.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<small>LWP</small> for a complete overview of
libwww&minus;perl5. See lwpcook and the scripts
<i>lwp-request</i> and <i>lwp-download</i> for examples of
usage.</p>

<p style="margin-left:11%; margin-top: 1em">See
HTTP::Request and HTTP::Response for a description of the
message objects dispatched and received. See
HTTP::Request::Common and HTML::Form for other ways to build
request objects.</p>

<p style="margin-left:11%; margin-top: 1em">See
WWW::Mechanize and WWW::Search for examples of more
specialized user agents based on
<tt>&quot;LWP::UserAgent&quot;</tt>.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
1995&minus;2009 Gisle Aas.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
