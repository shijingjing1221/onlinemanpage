<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:29:17 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::codecvt&lt; _InternT, _ExternT, _StateT &gt;</title>

</head>
<body>

<h1 align="center">std::codecvt&lt; _InternT, _ExternT, _StateT &gt;</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Detailed Description">Detailed Description</a><br>
<a href="#Member Function Documentation">Member Function Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::codecvt&lt;
_InternT, _ExternT, _StateT &gt; &minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::__codecvt_abstract_base&lt; _InternT, _ExternT,
_StateT &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inherited by
<b>std::codecvt_byname&lt; _InternT, _ExternT, _StateT
&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _ExternT
<b>extern_type</b> <br>
typedef _InternT <b>intern_type</b> <br>
typedef codecvt_base::result <b>result</b> <br>
typedef _StateT <b>state_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>codecvt</b> (size_t
__refs=0) <b><br>
codecvt</b> (__c_locale __cloc, size_t __refs=0) <br>
bool <b>always_noconv</b> () const throw () <br>
int <b>encoding</b> () const throw () <br>
result <b>in</b> (state_type &amp;__state, const extern_type
*__from, const extern_type *__from_end, const extern_type
*&amp;__from_next, intern_type *__to, intern_type *__to_end,
intern_type *&amp;__to_next) const <br>
int <b>length</b> (state_type &amp;__state, const
extern_type *__from, const extern_type *__end, size_t __max)
const <br>
int <b>max_length</b> () const throw () <br>
result <b>out</b> (state_type &amp;__state, const
intern_type *__from, const intern_type *__from_end, const
intern_type *&amp;__from_next, extern_type *__to,
extern_type *__to_end, extern_type *&amp;__to_next) const
<br>
result <b>unshift</b> (state_type &amp;__state, extern_type
*__to, extern_type *__to_end, extern_type *&amp;__to_next)
const</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Attributes</b></p>

<p style="margin-left:17%;">static <b>locale::id id</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">virtual bool
<b>do_always_noconv</b> () const throw () <br>
virtual int <b>do_encoding</b> () const throw () <br>
virtual result <b>do_in</b> (state_type &amp;__state, const
extern_type *__from, const extern_type *__from_end, const
extern_type *&amp;__from_next, intern_type *__to,
intern_type *__to_end, intern_type *&amp;__to_next) const
<br>
virtual int <b>do_length</b> (state_type &amp;, const
extern_type *__from, const extern_type *__end, size_t __max)
const <br>
virtual int <b>do_max_length</b> () const throw () <br>
virtual result <b>do_out</b> (state_type &amp;__state, const
intern_type *__from, const intern_type *__from_end, const
intern_type *&amp;__from_next, extern_type *__to,
extern_type *__to_end, extern_type *&amp;__to_next) const
<br>
virtual result <b>do_unshift</b> (state_type &amp;__state,
extern_type *__to, extern_type *__to_end, extern_type
*&amp;__to_next) const</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static __c_locale
<b>_S_clone_c_locale</b> (__c_locale &amp;__cloc) throw ()
<br>
static void <b>_S_create_c_locale</b> (__c_locale
&amp;__cloc, const char *__s, __c_locale __old=0) <br>
static void <b>_S_destroy_c_locale</b> (__c_locale
&amp;__cloc) <br>
static __c_locale <b>_S_get_c_locale</b> () <br>
static const char * <b>_S_get_c_name</b> () throw () <br>
static __c_locale <b>_S_lc_ctype_c_locale</b> (__c_locale
__cloc, const char *__s)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">__c_locale
<b>_M_c_locale_codecvt</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InternT, typename _ExternT, typename _StateT&gt;class
std::codecvt&lt; _InternT, _ExternT, _StateT &gt;</b> <br>
Primary class template codecvt.</p>

<p style="margin-left:11%; margin-top: 1em">NB: Generic,
mostly useless implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 276 of file codecvt.h.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InternT , typename _ExternT , typename _StateT &gt; virtual
result std::codecvt&lt; _InternT, _ExternT, _StateT
&gt;::do_out (state_type &amp;__state, const intern_type
*__from, const intern_type *__from_end, const intern_type
*&amp;__from_next, extern_type *__to, extern_type *__to_end,
extern_type *&amp;__to_next) const</b>
<tt>[protected]</tt><b>,</b> <tt>[virtual]</tt> <br>
Convert from internal to external character set. Converts
input string of intern_type to output string of extern_type.
This function is a hook for derived classes to change the
value returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
Also:</b></p>

<p style="margin-left:17%;">out for more information.</p>

<p style="margin-left:11%; margin-top: 1em">Implements
<b>std::__codecvt_abstract_base&lt; _InternT, _ExternT,
_StateT &gt;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InternT, typename _ExternT, typename _StateT&gt; result
std::__codecvt_abstract_base&lt; _InternT, _ExternT, _StateT
&gt;::in (state_type &amp;__state, const extern_type
*__from, const extern_type *__from_end, const extern_type
*&amp;__from_next, intern_type *__to, intern_type *__to_end,
intern_type *&amp;__to_next) const</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Convert from external to internal character set. Converts
input string of extern_type to output string of intern_type.
This is analogous to mbsrtowcs. It does this by calling
codecvt::do_in.</p>

<p style="margin-left:11%; margin-top: 1em">The source and
destination character sets are determined by the
facet&rsquo;s locale, internal and external types.</p>

<p style="margin-left:11%; margin-top: 1em">The characters
in [from,from_end) are converted and written to [to,to_end).
from_next and to_next are set to point to the character
following the last successfully converted character,
respectively. If the result needed no conversion, from_next
and to_next are not affected.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>state</i> argument should be initialized if the input is
at the beginning and carried from a previous call if
continuing conversion. There are no guarantees about how
<i>state</i> is used.</p>

<p style="margin-left:11%; margin-top: 1em">The result
returned is a member of codecvt_base::result. If all the
input is converted, returns codecvt_base::ok. If no
conversion is necessary, returns codecvt_base::noconv. If
the input ends early or there is insufficient space in the
output, returns codecvt_base::partial. Otherwise the
conversion failed and codecvt_base::error is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__state</i> Persistent
conversion state data. <i><br>
__from</i> Start of input. <i><br>
__from_end</i> End of input. <i><br>
__from_next</i> Returns start of unconverted data. <i><br>
__to</i> Start of output buffer. <i><br>
__to_end</i> End of output buffer. <i><br>
__to_next</i> Returns start of unused output area.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">codecvt_base::result.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 196 of file codecvt.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InternT, typename _ExternT, typename _StateT&gt; result
std::__codecvt_abstract_base&lt; _InternT, _ExternT, _StateT
&gt;::out (state_type &amp;__state, const intern_type
*__from, const intern_type *__from_end, const intern_type
*&amp;__from_next, extern_type *__to, extern_type *__to_end,
extern_type *&amp;__to_next) const</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Convert from internal to external character set. Converts
input string of intern_type to output string of extern_type.
This is analogous to wcsrtombs. It does this by calling
codecvt::do_out.</p>

<p style="margin-left:11%; margin-top: 1em">The source and
destination character sets are determined by the
facet&rsquo;s locale, internal and external types.</p>

<p style="margin-left:11%; margin-top: 1em">The characters
in [from,from_end) are converted and written to [to,to_end).
from_next and to_next are set to point to the character
following the last successfully converted character,
respectively. If the result needed no conversion, from_next
and to_next are not affected.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>state</i> argument should be initialized if the input is
at the beginning and carried from a previous call if
continuing conversion. There are no guarantees about how
<i>state</i> is used.</p>

<p style="margin-left:11%; margin-top: 1em">The result
returned is a member of codecvt_base::result. If all the
input is converted, returns codecvt_base::ok. If no
conversion is necessary, returns codecvt_base::noconv. If
the input ends early or there is insufficient space in the
output, returns codecvt_base::partial. Otherwise the
conversion failed and codecvt_base::error is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__state</i> Persistent
conversion state data. <i><br>
__from</i> Start of input. <i><br>
__from_end</i> End of input. <i><br>
__from_next</i> Returns start of unconverted data. <i><br>
__to</i> Start of output buffer. <i><br>
__to_end</i> End of output buffer. <i><br>
__to_next</i> Returns start of unused output area.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">codecvt_base::result.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 116 of file codecvt.h.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InternT, typename _ExternT, typename _StateT&gt; result
std::__codecvt_abstract_base&lt; _InternT, _ExternT, _StateT
&gt;::unshift (state_type &amp;__state, extern_type *__to,
extern_type *__to_end, extern_type *&amp;__to_next)
const</b> <tt>[inline]</tt><b>,</b> <tt>[inherited]</tt>
<br>
Reset conversion state. Writes characters to output that
would restore <i>state</i> to initial conditions. The idea
is that if a partial conversion occurs, then the converting
the characters written by this function would leave the
state in initial conditions, rather than partial conversion
state. It does this by calling codecvt::do_unshift().</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
4 external characters always converted to 1 internal
character, and input to in() had 6 external characters with
state saved, this function would write two characters to the
output and set the state to initialized conditions.</p>

<p style="margin-left:11%; margin-top: 1em">The source and
destination character sets are determined by the
facet&rsquo;s locale, internal and external types.</p>

<p style="margin-left:11%; margin-top: 1em">The result
returned is a member of codecvt_base::result. If the state
could be reset and data written, returns codecvt_base::ok.
If no conversion is necessary, returns codecvt_base::noconv.
If the output has insufficient space, returns
codecvt_base::partial. Otherwise the reset failed and
codecvt_base::error is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>__state</i> Persistent
conversion state data. <i><br>
__to</i> Start of output buffer. <i><br>
__to_end</i> End of output buffer. <i><br>
__to_next</i> Returns start of unused output area.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns:</b></p>

<p style="margin-left:17%;">codecvt_base::result.</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 155 of file codecvt.h.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
