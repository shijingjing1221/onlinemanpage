<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:31:19 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Test::More</title>

</head>
<body>

<h1 align="center">Test::More</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#EXIT CODES">EXIT CODES</a><br>
<a href="#CAVEATS and NOTES">CAVEATS and NOTES</a><br>
<a href="#HISTORY">HISTORY</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#SOURCE">SOURCE</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Test::More
&minus; yet another framework for writing test scripts</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use Test::More tests =&gt; 23;
  # or
  use Test::More skip_all =&gt; $reason;
  # or
  use Test::More;   # see done_testing()
  BEGIN { use_ok( 'Some::Module' ); }
  require_ok( 'Some::Module' );
  # Various ways to say &quot;ok&quot;
  ok($got eq $expected, $test_name);
  is  ($got, $expected, $test_name);
  isnt($got, $expected, $test_name);
  # Rather than print STDERR &quot;# here's what went wrong\n&quot;
  diag(&quot;here's what went wrong&quot;);
  like  ($got, qr/expected/, $test_name);
  unlike($got, qr/expected/, $test_name);
  cmp_ok($got, '==', $expected, $test_name);
  is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  SKIP: {
      skip $why, $how_many unless $have_some_feature;
      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };
  TODO: {
      local $TODO = $why;
      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };
  can_ok($module, @methods);
  isa_ok($object, $class);
  pass($test_name);
  fail($test_name);
  BAIL_OUT($why);
  # UNIMPLEMENTED!!!
  my @status = Test::More::status;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>STOP</small>
!</b> If you&rsquo;re just getting started writing tests,
have a look at Test::Simple first. This is a drop in
replacement for Test::Simple which you can switch to once
you get the hang of basic testing.</p>

<p style="margin-left:11%; margin-top: 1em">The purpose of
this module is to provide a wide range of testing utilities.
Various ways to say &quot;ok&quot; with better diagnostics,
facilities to skip tests, test future features and compare
complicated data structures. While you can do almost
anything with a simple <tt>&quot;ok()&quot;</tt> function,
it doesn&rsquo;t provide good diagnostic output.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I love it
when a plan comes together</b> <br>
Before anything else, you need a testing plan. This
basically declares how many tests your script is going to
run to protect against premature failure.</p>

<p style="margin-left:11%; margin-top: 1em">The preferred
way to do this is to declare a plan when you <tt>&quot;use
Test::More&quot;</tt>.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More tests =&gt; 23;</pre>


<p style="margin-left:11%; margin-top: 1em">There are cases
when you will not know beforehand how many tests your script
is going to run. In this case, you can declare your tests at
the end.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More;
  ... run your tests ...
  done_testing( $number_of_tests_run );</pre>


<p style="margin-left:11%; margin-top: 1em">Sometimes you
really don&rsquo;t know how many tests were run, or
it&rsquo;s too difficult to calculate. In which case you can
leave off <tt>$number_of_tests_run</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In some cases,
you&rsquo;ll want to completely skip an entire testing
script.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More skip_all =&gt; $skip_reason;</pre>


<p style="margin-left:11%; margin-top: 1em">Your script
will declare a skip with the reason why you skipped and exit
immediately with a zero (success). See Test::Harness for
details.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
control what functions Test::More will export, you have to
use the &rsquo;import&rsquo; option. For example, to import
everything but &rsquo;fail&rsquo;, you&rsquo;d do:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More tests =&gt; 23, import =&gt; ['!fail'];</pre>


<p style="margin-left:11%; margin-top: 1em">Alternatively,
you can use the <i>plan()</i> function. Useful for when you
have to calculate the number of tests.</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More;
  plan tests =&gt; keys %Stuff * 3;</pre>


<p style="margin-left:11%; margin-top: 1em">or for deciding
between running the tests at all:</p>

<pre style="margin-left:11%; margin-top: 1em">  use Test::More;
  if( $^O eq 'MacOS' ) {
      plan skip_all =&gt; 'Test irrelevant on MacOS';
  }
  else {
      plan tests =&gt; 42;
  }</pre>


<p style="margin-left:11%;"><b>done_testing</b></p>

<pre style="margin-left:17%;">    done_testing();
    done_testing($number_of_tests);</pre>


<p style="margin-left:17%; margin-top: 1em">If you
don&rsquo;t know how many tests you&rsquo;re going to run,
you can issue the plan when you&rsquo;re done running
tests.</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$number_of_tests</tt>
is the same as <i>plan()</i>, it&rsquo;s the number of tests
you expected to run. You can omit this, in which case the
number of tests you ran doesn&rsquo;t matter, just the fact
that your tests ran to conclusion.</p>

<p style="margin-left:17%; margin-top: 1em">This is safer
than and replaces the &quot;no_plan&quot; plan.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Test
names</b> <br>
By convention, each test is assigned a number in order. This
is largely done automatically for you. However, it&rsquo;s
often very useful to assign a name to each test. Which would
you rather see:</p>

<pre style="margin-left:11%; margin-top: 1em">  ok 4
  not ok 5
  ok 6</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:11%; margin-top: 1em">  ok 4 &minus; basic multi&minus;variable
  not ok 5 &minus; simple exponential
  ok 6 &minus; force == mass * acceleration</pre>


<p style="margin-left:11%; margin-top: 1em">The later gives
you some idea of what failed. It also makes it easier to
find the test in your script, simply search for &quot;simple
exponential&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">All test
functions take a name argument. It&rsquo;s optional, but
highly suggested that you use it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I&rsquo;m
ok, you&rsquo;re not ok.</b> <br>
The basic purpose of this module is to print out either
&quot;ok #&quot; or &quot;not ok #&quot; depending on if a
given test succeeded or failed. Everything else is just
gravy.</p>

<p style="margin-left:11%; margin-top: 1em">All of the
following print &quot;ok&quot; or &quot;not ok&quot;
depending on if the test succeeded or failed. They all also
return true or false, respectively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>ok</b></p></td>
<td width="6%"></td>
<td width="52%">

<pre>  ok($got eq $expected, $test_name);</td>
<td width="28%">
</td></tr>
</table></pre>

<p style="margin-left:17%; margin-top: 1em">This simply
evaluates any expression (<tt>&quot;$got eq
$expected&quot;</tt> is just a simple example) and uses that
to determine if the test succeeded or failed. A true
expression passes, a false one fails. Very simple.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( $exp{9} == 81,                   'simple exponential' );
    ok( Film&minus;&gt;can('db_Main'),            'set_db()' );
    ok( $p&minus;&gt;tests == 4,                  'saw tests' );
    ok( !grep !defined $_, @items,       'items populated' );</pre>


<p style="margin-left:17%; margin-top: 1em">(Mnemonic:
&quot;This is ok.&quot;)</p>


<p style="margin-left:17%; margin-top: 1em"><tt>$test_name</tt>
is a very short description of the test that will be printed
out. It makes it very easy to find a test in your script
when it fails and gives others an idea of your intentions.
<tt>$test_name</tt> is optional, but we <b>very</b> strongly
encourage its use.</p>

<p style="margin-left:17%; margin-top: 1em">Should an
<i>ok()</i> fail, it will produce some diagnostics:</p>

<pre style="margin-left:17%; margin-top: 1em">    not ok 18 &minus; sufficient mucus
    #   Failed test 'sufficient mucus'
    #   in foo.t at line 42.</pre>


<p style="margin-left:17%; margin-top: 1em">This is the
same as Test::Simple&rsquo;s <i>ok()</i> routine.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>is</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>isnt</b></p>

<pre style="margin-left:17%;">  is  ( $got, $expected, $test_name );
  isnt( $got, $expected, $test_name );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>ok()</i>, <i>is()</i> and <i>isnt()</i> compare their two
arguments with <tt>&quot;eq&quot;</tt> and
<tt>&quot;ne&quot;</tt> respectively and use the result of
that to determine if the test succeeded or failed. So
these:</p>

<pre style="margin-left:17%; margin-top: 1em">    # Is the ultimate answer 42?
    is( ultimate_answer(), 42,          &quot;Meaning of Life&quot; );
    # $foo isn't empty
    isnt( $foo, '',     &quot;Got some foo&quot; );</pre>


<p style="margin-left:17%; margin-top: 1em">are similar to
these:</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( ultimate_answer() eq 42,        &quot;Meaning of Life&quot; );
    ok( $foo ne '',     &quot;Got some foo&quot; );</pre>



<p style="margin-left:17%; margin-top: 1em">&quot;undef&quot;
will only ever match <tt>&quot;undef&quot;</tt>. So you can
test a value agains <tt>&quot;undef&quot;</tt> like
this:</p>

<pre style="margin-left:17%; margin-top: 1em">    is($not_defined, undef, &quot;undefined as expected&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">(Mnemonic:
&quot;This is that.&quot; &quot;This isn&rsquo;t
that.&quot;)</p>

<p style="margin-left:17%; margin-top: 1em">So why use
these? They produce better diagnostics on failure.
<i>ok()</i> cannot know what you are testing for (beyond the
name), but <i>is()</i> and <i>isnt()</i> know what the test
was and why it failed. For example this test:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $foo = 'waffle';  my $bar = 'yarblokos';
    is( $foo, $bar,   'Is foo the same as bar?' );</pre>


<p style="margin-left:17%; margin-top: 1em">Will produce
something like this:</p>

<pre style="margin-left:17%; margin-top: 1em">    not ok 17 &minus; Is foo the same as bar?
    #   Failed test 'Is foo the same as bar?'
    #   in foo.t at line 139.
    #          got: 'waffle'
    #     expected: 'yarblokos'</pre>


<p style="margin-left:17%; margin-top: 1em">So you can
figure out what went wrong without rerunning the test.</p>

<p style="margin-left:17%; margin-top: 1em">You are
encouraged to use <i>is()</i> and <i>isnt()</i> over
<i>ok()</i> where possible, however do not be tempted to use
them to find out if something is true or false!</p>

<pre style="margin-left:17%; margin-top: 1em">  # XXX BAD!
  is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );</pre>


<p style="margin-left:17%; margin-top: 1em">This does not
check if <tt>&quot;exists $brooklyn{tree}&quot;</tt> is
true, it checks if it returns 1. Very different. Similar
caveats exist for false and 0. In these cases, use
<i>ok()</i>.</p>

<pre style="margin-left:17%; margin-top: 1em">  ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );</pre>


<p style="margin-left:17%; margin-top: 1em">A simple call
to <i>isnt()</i> usually does not provide a strong test but
there are cases when you cannot say much more about a value
than that it is different from some other value:</p>

<pre style="margin-left:17%; margin-top: 1em">  new_ok $obj, &quot;Foo&quot;;
  my $clone = $obj&minus;&gt;clone;
  isa_ok $obj, &quot;Foo&quot;, &quot;Foo&minus;&gt;clone&quot;;
  isnt $obj, $clone, &quot;clone() produces a different object&quot;;</pre>


<p style="margin-left:17%; margin-top: 1em">For those
grammatical pedants out there, there&rsquo;s an
<tt>&quot;isn't()&quot;</tt> function which is an alias of
<i>isnt()</i>.</p>

<p style="margin-left:11%;"><b>like</b></p>

<pre style="margin-left:17%;">  like( $got, qr/expected/, $test_name );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>ok()</i>, <i>like()</i> matches <tt>$got</tt> against the
regex <tt>&quot;qr/expected/&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">So this:</p>

<pre style="margin-left:17%; margin-top: 1em">    like($got, qr/expected/, 'this is like that');</pre>


<p style="margin-left:17%; margin-top: 1em">is similar
to:</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( $got =~ /expected/, 'this is like that');</pre>


<p style="margin-left:17%; margin-top: 1em">(Mnemonic
&quot;This is like that&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">The second
argument is a regular expression. It may be given as a regex
reference (i.e. <tt>&quot;qr//&quot;</tt>) or (for better
compatibility with older perls) as a string that looks like
a regex (alternative delimiters are currently not
supported):</p>

<pre style="margin-left:17%; margin-top: 1em">    like( $got, '/expected/', 'this is like that' );</pre>


<p style="margin-left:17%; margin-top: 1em">Regex options
may be placed on the end (<tt>'/expected/i'</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Its advantages
over <i>ok()</i> are similar to that of <i>is()</i> and
<i>isnt()</i>. Better diagnostics on failure.</p>

<p style="margin-left:11%;"><b>unlike</b></p>

<pre style="margin-left:17%;">  unlike( $got, qr/expected/, $test_name );</pre>


<p style="margin-left:17%; margin-top: 1em">Works exactly
as <i>like()</i>, only it checks if <tt>$got</tt> <b>does
not</b> match the given pattern.</p>

<p style="margin-left:11%;"><b>cmp_ok</b></p>

<pre style="margin-left:17%;">  cmp_ok( $got, $op, $expected, $test_name );</pre>


<p style="margin-left:17%; margin-top: 1em">Halfway between
<i>ok()</i> and <i>is()</i> lies <i>cmp_ok()</i>. This
allows you to compare two arguments using any binary perl
operator.</p>

<pre style="margin-left:17%; margin-top: 1em">    # ok( $got eq $expected );
    cmp_ok( $got, 'eq', $expected, 'this eq that' );
    # ok( $got == $expected );
    cmp_ok( $got, '==', $expected, 'this == that' );
    # ok( $got &amp;&amp; $expected );
    cmp_ok( $got, '&amp;&amp;', $expected, 'this &amp;&amp; that' );
    ...etc...</pre>


<p style="margin-left:17%; margin-top: 1em">Its advantage
over <i>ok()</i> is when the test fails you&rsquo;ll know
what <tt>$got</tt> and <tt>$expected</tt> were:</p>

<pre style="margin-left:17%; margin-top: 1em">    not ok 1
    #   Failed test in foo.t at line 12.
    #     '23'
    #         &amp;&amp;
    #     undef</pre>


<p style="margin-left:17%; margin-top: 1em">It&rsquo;s also
useful in those cases where you are comparing numbers and
<i>is()</i>&rsquo;s use of <tt>&quot;eq&quot;</tt> will
interfere:</p>

<pre style="margin-left:17%; margin-top: 1em">    cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );</pre>


<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
especially useful when comparing greater-than or
smaller-than relation between values:</p>

<pre style="margin-left:17%; margin-top: 1em">    cmp_ok( $some_value, '&lt;=', $upper_limit );</pre>


<p style="margin-left:11%;"><b>can_ok</b></p>

<pre style="margin-left:17%;">  can_ok($module, @methods);
  can_ok($object, @methods);</pre>


<p style="margin-left:17%; margin-top: 1em">Checks to make
sure the <tt>$module</tt> or <tt>$object</tt> can do these
<tt>@methods</tt> (works with functions, too).</p>

<pre style="margin-left:17%; margin-top: 1em">    can_ok('Foo', qw(this that whatever));</pre>


<p style="margin-left:17%; margin-top: 1em">is almost
exactly like saying:</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( Foo&minus;&gt;can('this') &amp;&amp;
        Foo&minus;&gt;can('that') &amp;&amp;
        Foo&minus;&gt;can('whatever')
      );</pre>


<p style="margin-left:17%; margin-top: 1em">only without
all the typing and with a better interface. Handy for
quickly testing an interface.</p>

<p style="margin-left:17%; margin-top: 1em">No matter how
many <tt>@methods</tt> you check, a single <i>can_ok()</i>
call counts as one test. If you desire otherwise, use:</p>

<pre style="margin-left:17%; margin-top: 1em">    foreach my $meth (@methods) {
        can_ok('Foo', $meth);
    }</pre>


<p style="margin-left:11%;"><b>isa_ok</b></p>

<pre style="margin-left:17%;">  isa_ok($object,   $class, $object_name);
  isa_ok($subclass, $class, $object_name);
  isa_ok($ref,      $type,  $ref_name);</pre>


<p style="margin-left:17%; margin-top: 1em">Checks to see
if the given
<tt>&quot;$object&minus;&gt;isa($class)&quot;</tt>. Also
checks to make sure the object was defined in the first
place. Handy for this sort of thing:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $obj = Some::Module&minus;&gt;new;
    isa_ok( $obj, 'Some::Module' );</pre>


<p style="margin-left:17%; margin-top: 1em">where
you&rsquo;d otherwise have to write</p>

<pre style="margin-left:17%; margin-top: 1em">    my $obj = Some::Module&minus;&gt;new;
    ok( defined $obj &amp;&amp; $obj&minus;&gt;isa('Some::Module') );</pre>


<p style="margin-left:17%; margin-top: 1em">to safeguard
against your test script blowing up.</p>

<p style="margin-left:17%; margin-top: 1em">You can also
test a class, to make sure that it has the right
ancestor:</p>

<pre style="margin-left:17%; margin-top: 1em">    isa_ok( 'Vole', 'Rodent' );</pre>


<p style="margin-left:17%; margin-top: 1em">It works on
references, too:</p>

<pre style="margin-left:17%; margin-top: 1em">    isa_ok( $array_ref, 'ARRAY' );</pre>


<p style="margin-left:17%; margin-top: 1em">The diagnostics
of this test normally just refer to &rsquo;the
object&rsquo;. If you&rsquo;d like them to be more specific,
you can supply an <tt>$object_name</tt> (for example
&rsquo;Test customer&rsquo;).</p>

<p style="margin-left:11%;"><b>new_ok</b></p>

<pre style="margin-left:17%;">  my $obj = new_ok( $class );
  my $obj = new_ok( $class =&gt; \@args );
  my $obj = new_ok( $class =&gt; \@args, $object_name );</pre>


<p style="margin-left:17%; margin-top: 1em">A convenience
function which combines creating an object and calling
<i>isa_ok()</i> on that object.</p>

<p style="margin-left:17%; margin-top: 1em">It is basically
equivalent to:</p>

<pre style="margin-left:17%; margin-top: 1em">    my $obj = $class&minus;&gt;new(@args);
    isa_ok $obj, $class, $object_name;</pre>


<p style="margin-left:17%; margin-top: 1em">If
<tt>@args</tt> is not given, an empty list will be used.</p>

<p style="margin-left:17%; margin-top: 1em">This function
only works on <i>new()</i> and it assumes <i>new()</i> will
return just a single object which isa <tt>$class</tt>.</p>

<p style="margin-left:11%;"><b>subtest</b></p>

<pre style="margin-left:17%;">    subtest $name =&gt; \&amp;code;</pre>



<p style="margin-left:17%; margin-top: 1em"><i>subtest()</i>
runs the &amp;code as its own little test with its own plan
and its own result. The main test counts this as a single
test using the result of the whole subtest to determine if
its ok or not ok.</p>

<p style="margin-left:17%; margin-top: 1em">For
example...</p>

<pre style="margin-left:17%; margin-top: 1em">  use Test::More tests =&gt; 3;
  pass(&quot;First test&quot;);
  subtest 'An example subtest' =&gt; sub {
      plan tests =&gt; 2;
      pass(&quot;This is a subtest&quot;);
      pass(&quot;So is this&quot;);
  };
  pass(&quot;Third test&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">This would
produce.</p>

<pre style="margin-left:17%; margin-top: 1em">  1..3
  ok 1 &minus; First test
      1..2
      ok 1 &minus; This is a subtest
      ok 2 &minus; So is this
  ok 2 &minus; An example subtest
  ok 3 &minus; Third test</pre>


<p style="margin-left:17%; margin-top: 1em">A subtest may
call &quot;skip_all&quot;. No tests will be run, but the
subtest is considered a skip.</p>

<pre style="margin-left:17%; margin-top: 1em">  subtest 'skippy' =&gt; sub {
      plan skip_all =&gt; 'cuz I said so';
      pass('this test will never be run');
  };</pre>


<p style="margin-left:17%; margin-top: 1em">Returns true if
the subtest passed, false otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">Due to how
subtests work, you may omit a plan if you desire. This adds
an implicit <tt>&quot;done_testing()&quot;</tt> to the end
of your subtest. The following two subtests are
equivalent:</p>

<pre style="margin-left:17%; margin-top: 1em">  subtest 'subtest with implicit done_testing()', sub {
      ok 1, 'subtests with an implicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
  };
  subtest 'subtest with explicit done_testing()', sub {
      ok 1, 'subtests with an explicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
      done_testing();
  };</pre>


<p style="margin-left:11%;"><b>pass <br>
fail</b></p>

<pre style="margin-left:17%;">  pass($test_name);
  fail($test_name);</pre>


<p style="margin-left:17%; margin-top: 1em">Sometimes you
just want to say that the tests have passed. Usually the
case is you&rsquo;ve got some complicated condition that is
difficult to wedge into an <i>ok()</i>. In this case, you
can simply use <i>pass()</i> (to declare the test ok) or
fail (for not ok). They are synonyms for <i>ok</i>(1) and
<i>ok</i>(0).</p>

<p style="margin-left:17%; margin-top: 1em">Use these very,
very, very sparingly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Module
tests</b> <br>
You usually want to test if the module you&rsquo;re testing
loads ok, rather than just vomiting if its load fails. For
such purposes we have <tt>&quot;use_ok&quot;</tt> and
<tt>&quot;require_ok&quot;</tt>. <b><br>
use_ok</b></p>

<pre style="margin-left:17%;">   BEGIN { use_ok($module); }
   BEGIN { use_ok($module, @imports); }</pre>


<p style="margin-left:17%; margin-top: 1em">These simply
use the given <tt>$module</tt> and test to make sure the
load happened ok. It&rsquo;s recommended that you run
<i>use_ok()</i> inside a <small>BEGIN</small> block so its
functions are exported at compile-time and prototypes are
properly honored.</p>

<p style="margin-left:17%; margin-top: 1em">If
<tt>@imports</tt> are given, they are passed through to the
use. So this:</p>

<pre style="margin-left:17%; margin-top: 1em">   BEGIN { use_ok('Some::Module', qw(foo bar)) }</pre>


<p style="margin-left:17%; margin-top: 1em">is like doing
this:</p>

<pre style="margin-left:17%; margin-top: 1em">   use Some::Module qw(foo bar);</pre>


<p style="margin-left:17%; margin-top: 1em">Version numbers
can be checked like so:</p>

<pre style="margin-left:17%; margin-top: 1em">   # Just like &quot;use Some::Module 1.02&quot;
   BEGIN { use_ok('Some::Module', 1.02) }</pre>


<p style="margin-left:17%; margin-top: 1em">Don&rsquo;t try
to do this:</p>

<pre style="margin-left:17%; margin-top: 1em">   BEGIN {
       use_ok('Some::Module');
       ...some code that depends on the use...
       ...happening at compile time...
   }</pre>


<p style="margin-left:17%; margin-top: 1em">because the
notion of &quot;compile-time&quot; is relative. Instead, you
want:</p>

<pre style="margin-left:17%; margin-top: 1em">  BEGIN { use_ok('Some::Module') }
  BEGIN { ...some code that depends on the use... }</pre>


<p style="margin-left:17%; margin-top: 1em">If you want the
equivalent of <tt>&quot;use Foo ()&quot;</tt>, use a module
but not import anything, use
<tt>&quot;require_ok&quot;</tt>.</p>

<pre style="margin-left:17%; margin-top: 1em">  BEGIN { require_ok &quot;Foo&quot; }</pre>


<p style="margin-left:11%;"><b>require_ok</b></p>

<pre style="margin-left:17%;">   require_ok($module);
   require_ok($file);</pre>


<p style="margin-left:17%; margin-top: 1em">Like
<i>use_ok()</i>, except it requires the <tt>$module</tt> or
<tt>$file</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Complex data
structures</b> <br>
Not everything is a simple eq check or regex. There are
times you need to see if two data structures are equivalent.
For these instances Test::More provides a handful of useful
functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
I&rsquo;m not quite sure what will happen with filehandles.
<b><br>
is_deeply</b></p>

<pre style="margin-left:17%;">  is_deeply( $got, $expected, $test_name );</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>is()</i>, except that if <tt>$got</tt> and
<tt>$expected</tt> are references, it does a deep comparison
walking each data structure to see if they are equivalent.
If the two structures are different, it will display the
place where they start differing.</p>


<p style="margin-left:17%; margin-top: 1em"><i>is_deeply()</i>
compares the dereferenced values of references, the
references themselves (except for their type) are ignored.
This means aspects such as blessing and ties are not
considered &quot;different&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><i>is_deeply()</i>
currently has very limited handling of function reference
and globs. It merely checks if they have the same referent.
This may improve in the future.</p>


<p style="margin-left:17%; margin-top: 1em">Test::Differences
and Test::Deep provide more in-depth functionality along
these lines.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Diagnostics</b>
<br>
If you pick the right test function, you&rsquo;ll usually
get a good idea of what went wrong when it failed. But
sometimes it doesn&rsquo;t work out that way. So here we
have ways for you to write your own diagnostic messages
which are safer than just <tt>&quot;print STDERR&quot;</tt>.
<b><br>
diag</b></p>

<pre style="margin-left:17%;">  diag(@diagnostic_message);</pre>


<p style="margin-left:17%; margin-top: 1em">Prints a
diagnostic message which is guaranteed not to interfere with
test output. Like <tt>&quot;print&quot;
@diagnostic_message</tt> is simply concatenated
together.</p>

<p style="margin-left:17%; margin-top: 1em">Returns false,
so as to preserve failure.</p>

<p style="margin-left:17%; margin-top: 1em">Handy for this
sort of thing:</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( grep(/foo/, @users), &quot;There's a foo user&quot; ) or
        diag(&quot;Since there's no foo, check that /etc/bar is set up right&quot;);</pre>


<p style="margin-left:17%; margin-top: 1em">which would
produce:</p>

<pre style="margin-left:17%; margin-top: 1em">    not ok 42 &minus; There's a foo user
    #   Failed test 'There's a foo user'
    #   in foo.t at line 52.
    # Since there's no foo, check that /etc/bar is set up right.</pre>


<p style="margin-left:17%; margin-top: 1em">You might
remember <tt>&quot;ok() or diag()&quot;</tt> with the
mnemonic <tt>&quot;open() or die()&quot;</tt>.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
The exact formatting of the diagnostic output is still
changing, but it is guaranteed that whatever you throw at it
it won&rsquo;t interfere with the test.</p>

<p style="margin-left:11%;"><b>note</b></p>

<pre style="margin-left:17%;">  note(@diagnostic_message);</pre>


<p style="margin-left:17%; margin-top: 1em">Like
<i>diag()</i>, except the message will not be seen when the
test is run in a harness. It will only be visible in the
verbose <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">Handy for
putting in notes which might be useful for debugging, but
don&rsquo;t indicate a problem.</p>

<pre style="margin-left:17%; margin-top: 1em">    note(&quot;Tempfile is $tempfile&quot;);</pre>


<p style="margin-left:11%;"><b>explain</b></p>

<pre style="margin-left:17%;">  my @dump = explain @diagnostic_message;</pre>


<p style="margin-left:17%; margin-top: 1em">Will dump the
contents of any references in a human readable format.
Usually you want to pass this into <tt>&quot;note&quot;</tt>
or <tt>&quot;diag&quot;</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">Handy for
things like...</p>

<pre style="margin-left:17%; margin-top: 1em">    is_deeply($have, $want) || diag explain $have;</pre>


<p style="margin-left:17%; margin-top: 1em">or</p>

<pre style="margin-left:17%; margin-top: 1em">    note explain \%args;
    Some::Class&minus;&gt;method(%args);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Conditional
tests</b> <br>
Sometimes running a test under certain conditions will cause
the test script to die. A certain function or method
isn&rsquo;t implemented (such as <i>fork()</i> on MacOS),
some resource isn&rsquo;t available (like a net connection)
or a module isn&rsquo;t available. In these cases it&rsquo;s
necessary to skip tests, or declare that they are supposed
to fail but will work in the future (a todo test).</p>

<p style="margin-left:11%; margin-top: 1em">For more
details on the mechanics of skip and todo tests see
Test::Harness.</p>

<p style="margin-left:11%; margin-top: 1em">The way
Test::More handles this is with a named block. Basically, a
block of tests which can be skipped over or made todo.
It&rsquo;s best if I just show you... <b><small><br>
SKIP: BLOCK</small></b></p>

<pre style="margin-left:17%;">  SKIP: {
      skip $why, $how_many if $condition;
      ...normal testing code goes here...
  }</pre>


<p style="margin-left:17%; margin-top: 1em">This declares a
block of tests that might be skipped, <tt>$how_many</tt>
tests there are, <tt>$why</tt> and under what
<tt>$condition</tt> to skip them. An example is the easiest
way to illustrate:</p>

<pre style="margin-left:17%; margin-top: 1em">    SKIP: {
        eval { require HTML::Lint };
        skip &quot;HTML::Lint not installed&quot;, 2 if $@;
        my $lint = new HTML::Lint;
        isa_ok( $lint, &quot;HTML::Lint&quot; );
        $lint&minus;&gt;parse( $html );
        is( $lint&minus;&gt;errors, 0, &quot;No errors found in HTML&quot; );
    }</pre>


<p style="margin-left:17%; margin-top: 1em">If the user
does not have HTML::Lint installed, the whole block of code
<i>won&rsquo;t be run at all</i>. Test::More will output
special ok&rsquo;s which Test::Harness interprets as
skipped, but passing, tests.</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
important that <tt>$how_many</tt> accurately reflects the
number of tests in the <small>SKIP</small> block so the # of
tests run will match up with your plan. If your plan is
<tt>&quot;no_plan&quot; $how_many</tt> is optional and will
default to 1.</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
perfectly safe to nest <small>SKIP</small> blocks. Each
<small>SKIP</small> block must have the label
<tt>&quot;SKIP&quot;</tt>, or Test::More can&rsquo;t work
its magic.</p>

<p style="margin-left:17%; margin-top: 1em">You don&rsquo;t
skip tests which are failing because there&rsquo;s a bug in
your program, or for which you don&rsquo;t yet have code
written. For that you use <small>TODO.</small> Read on.</p>

<p style="margin-left:11%;"><b><small>TODO:
BLOCK</small></b></p>

<pre style="margin-left:17%;">    TODO: {
        local $TODO = $why if $condition;
        ...normal testing code goes here...
    }</pre>


<p style="margin-left:17%; margin-top: 1em">Declares a
block of tests you expect to fail and <tt>$why</tt>. Perhaps
it&rsquo;s because you haven&rsquo;t fixed a bug or
haven&rsquo;t finished a new feature:</p>

<pre style="margin-left:17%; margin-top: 1em">    TODO: {
        local $TODO = &quot;URI::Geller not finished&quot;;
        my $card = &quot;Eight of clubs&quot;;
        is( URI::Geller&minus;&gt;your_card, $card, 'Is THIS your card?' );
        my $spoon;
        URI::Geller&minus;&gt;bend_spoon;
        is( $spoon, 'bent',    &quot;Spoon bending, that's original&quot; );
    }</pre>


<p style="margin-left:17%; margin-top: 1em">With a todo
block, the tests inside are expected to fail. Test::More
will run the tests normally, but print out special flags
indicating they are &quot;todo&quot;. Test::Harness will
interpret failures as being ok. Should anything succeed, it
will report it as an unexpected success. You then know the
thing you had todo is done and can remove the
<small>TODO</small> flag.</p>

<p style="margin-left:17%; margin-top: 1em">The nice part
about todo tests, as opposed to simply commenting out a
block of tests, is it&rsquo;s like having a programmatic
todo list. You know how much work is left to be done,
you&rsquo;re aware of what bugs there are, and you&rsquo;ll
know immediately when they&rsquo;re fixed.</p>

<p style="margin-left:17%; margin-top: 1em">Once a todo
test starts succeeding, simply move it outside the block.
When the block is empty, delete it.</p>

<p style="margin-left:11%;"><b>todo_skip</b></p>

<pre style="margin-left:17%;">    TODO: {
        todo_skip $why, $how_many if $condition;
        ...normal testing code...
    }</pre>


<p style="margin-left:17%; margin-top: 1em">With todo
tests, it&rsquo;s best to have the tests actually run. That
way you&rsquo;ll know when they start passing. Sometimes
this isn&rsquo;t possible. Often a failing test will cause
the whole program to die or hang, even inside an
<tt>&quot;eval BLOCK&quot;</tt> with and using
<tt>&quot;alarm&quot;</tt>. In these extreme cases you have
no choice but to skip over the broken tests entirely.</p>

<p style="margin-left:17%; margin-top: 1em">The syntax and
behavior is similar to a <tt>&quot;SKIP: BLOCK&quot;</tt>
except the tests will be marked as failing but todo.
Test::Harness will interpret them as passing.</p>

<p style="margin-left:11%;">When do I use
<small>SKIP</small> vs. <small>TODO</small> ?</p>

<p style="margin-left:17%;"><b>If it&rsquo;s something the
user might not be able to do</b>, use <small>SKIP.</small>
This includes optional modules that aren&rsquo;t installed,
running under an <small>OS</small> that doesn&rsquo;t have
some feature (like <i>fork()</i> or symlinks), or maybe you
need an Internet connection and one isn&rsquo;t
available.</p>

<p style="margin-left:17%; margin-top: 1em"><b>If
it&rsquo;s something the programmer hasn&rsquo;t done
yet</b>, use <small>TODO.</small> This is for any code you
haven&rsquo;t written yet, or bugs you have yet to fix, but
want to put tests in your testing script (always a good
idea).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Test control
<small><br>
BAIL_OUT</small></b></p>
<pre style="margin-left:17%;">    BAIL_OUT($reason);</pre>

<p style="margin-left:17%; margin-top: 1em">Indicates to
the harness that things are going so badly all testing
should terminate. This includes the running of any
additional test scripts.</p>

<p style="margin-left:17%; margin-top: 1em">This is
typically used when testing cannot continue such as a
critical module failing to compile or a necessary external
utility not being available such as a database connection
failing.</p>

<p style="margin-left:17%; margin-top: 1em">The test will
exit with 255.</p>

<p style="margin-left:17%; margin-top: 1em">For even better
control look at Test::Most.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Discouraged
comparison functions</b> <br>
The use of the following functions is discouraged as they
are not actually testing functions and produce no
diagnostics to help figure out what went wrong. They were
written before <i>is_deeply()</i> existed because I
couldn&rsquo;t figure out how to display a useful diff of
two arbitrary data structures.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
are usually used inside an <i>ok()</i>.</p>

<pre style="margin-left:11%; margin-top: 1em">    ok( eq_array(\@got, \@expected) );</pre>



<p style="margin-left:11%; margin-top: 1em">&quot;is_deeply()&quot;
can do that better and with diagnostics.</p>

<pre style="margin-left:11%; margin-top: 1em">    is_deeply( \@got, \@expected );</pre>


<p style="margin-left:11%; margin-top: 1em">They may be
deprecated in future versions. <b><br>
eq_array</b></p>

<pre style="margin-left:17%;">  my $is_eq = eq_array(\@got, \@expected);</pre>


<p style="margin-left:17%; margin-top: 1em">Checks if two
arrays are equivalent. This is a deep check, so multi-level
structures are handled correctly.</p>

<p style="margin-left:11%;"><b>eq_hash</b></p>

<pre style="margin-left:17%;">  my $is_eq = eq_hash(\%got, \%expected);</pre>


<p style="margin-left:17%; margin-top: 1em">Determines if
the two hashes contain the same keys and values. This is a
deep check.</p>

<p style="margin-left:11%;"><b>eq_set</b></p>

<pre style="margin-left:17%;">  my $is_eq = eq_set(\@got, \@expected);</pre>


<p style="margin-left:17%; margin-top: 1em">Similar to
<i>eq_array()</i>, except the order of the elements is
<b>not</b> important. This is a deep check, but the
irrelevancy of order only applies to the top level.</p>

<pre style="margin-left:17%; margin-top: 1em">    ok( eq_set(\@got, \@expected) );</pre>


<p style="margin-left:17%; margin-top: 1em">Is better
written:</p>

<pre style="margin-left:17%; margin-top: 1em">    is_deeply( [sort @got], [sort @expected] );</pre>



<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
By historical accident, this is not a true set comparison.
While the order of elements does not matter, duplicate
elements do.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE</small></b>
<i>eq_set()</i> does not know how to deal with references at
the top level. The following is an example of a comparison
which might not work:</p>

<pre style="margin-left:17%; margin-top: 1em">    eq_set([\1, \2], [\2, \1]);</pre>


<p style="margin-left:17%; margin-top: 1em">Test::Deep
contains much better set comparison functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extending
and Embedding Test::More</b> <br>
Sometimes the Test::More interface isn&rsquo;t quite enough.
Fortunately, Test::More is built on top of Test::Builder
which provides a single, unified backend for any test
library to use. This means two test libraries which both use
Test::Builder <b>can be used together in the same
program</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If you simply
want to do a little tweaking of how the tests behave, you
can access the underlying Test::Builder object like so:
<b><br>
builder</b></p>

<pre style="margin-left:17%;">    my $test_builder = Test::More&minus;&gt;builder;</pre>


<p style="margin-left:17%; margin-top: 1em">Returns the
Test::Builder object underlying Test::More for you to play
with.</p>

<h2>EXIT CODES
<a name="EXIT CODES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If all your
tests passed, Test::Builder will exit with zero (which is
normal). If anything failed it will exit with how many
failed. If you run less (or more) tests than you planned,
the missing (or extras) will be considered failures. If no
tests were ever run Test::Builder will throw a warning and
exit with 255. If the test died, even after having
successfully completed all its tests, it will still be
considered a failure and will exit with 255.</p>

<p style="margin-left:11%; margin-top: 1em">So the exit
codes are...</p>

<pre style="margin-left:11%; margin-top: 1em">    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)</pre>


<p style="margin-left:11%; margin-top: 1em">If you fail
more than 254 tests, it will be reported as 254.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
This behavior may go away in future versions.</p>

<h2>CAVEATS and NOTES
<a name="CAVEATS and NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Backwards
compatibility</p>

<p style="margin-left:17%;">Test::More works with Perls as
old as 5.6.0.</p>

<p style="margin-left:11%;">utf8 / &quot;Wide character in
print&quot;</p>

<p style="margin-left:17%;">If you use utf8 or other
non-ASCII characters with Test::More you might get a
&quot;Wide character in print&quot; warning. Using
<tt>&quot;binmode STDOUT, &quot;:utf8&quot;&quot;</tt> will
not fix it. Test::Builder (which powers Test::More)
duplicates <small>STDOUT</small> and <small>STDERR.</small>
So any changes to them, including changing their output
disciplines, will not be seem by Test::More.</p>

<p style="margin-left:17%; margin-top: 1em">The work around
is to change the filehandles used by Test::Builder
directly.</p>

<pre style="margin-left:17%; margin-top: 1em">    my $builder = Test::More&minus;&gt;builder;
    binmode $builder&minus;&gt;output,         &quot;:utf8&quot;;
    binmode $builder&minus;&gt;failure_output, &quot;:utf8&quot;;
    binmode $builder&minus;&gt;todo_output,    &quot;:utf8&quot;;</pre>


<p style="margin-left:11%;">Overloaded objects</p>

<p style="margin-left:17%;">String overloaded objects are
compared <b>as strings</b> (or in <i>cmp_ok()</i>&rsquo;s
case, strings or numbers as appropriate to the comparison
op). This prevents Test::More from piercing an
object&rsquo;s interface allowing better blackbox testing.
So if a function starts returning overloaded objects instead
of bare strings your tests won&rsquo;t notice the
difference. This is good.</p>

<p style="margin-left:17%; margin-top: 1em">However, it
does mean that functions like <i>is_deeply()</i> cannot be
used to test the internals of string overloaded objects. In
this case I would suggest Test::Deep which contains more
flexible testing functions for complex data structures.</p>

<p style="margin-left:11%;">Threads</p>

<p style="margin-left:17%;">Test::More will only be aware
of threads if &quot;use threads&quot; has been done
<i>before</i> Test::More is loaded. This is ok:</p>

<pre style="margin-left:17%; margin-top: 1em">    use threads;
    use Test::More;</pre>


<p style="margin-left:17%; margin-top: 1em">This may cause
problems:</p>

<pre style="margin-left:17%; margin-top: 1em">    use Test::More
    use threads;</pre>


<p style="margin-left:17%; margin-top: 1em">5.8.1 and above
are supported. Anything below that has too many bugs.</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is a case
of convergent evolution with Joshua Pritikin&rsquo;s Test
module. I was largely unaware of its existence when
I&rsquo;d first written my own <i>ok()</i> routines. This
module exists because I can&rsquo;t figure out how to easily
wedge test names into Test&rsquo;s interface (along with a
few other problems).</p>

<p style="margin-left:11%; margin-top: 1em">The goal here
is to have a testing utility that&rsquo;s simple to learn,
quick to use and difficult to trip yourself up with while
still providing more flexibility than the existing Test.pm.
As such, the names of the most common routines are kept
tiny, special cases and magic side-effects are kept to a
minimum. <small>WYSIWYG.</small></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Test::Simple if
all this confuses you and you just want to write some tests.
You can upgrade to Test::More later (it&rsquo;s forward
compatible).</p>

<p style="margin-left:11%; margin-top: 1em">Test::Harness
is the test runner and output interpreter for Perl.
It&rsquo;s the thing that powers <tt>&quot;make
test&quot;</tt> and where the <tt>&quot;prove&quot;</tt>
utility comes from.</p>

<p style="margin-left:11%; margin-top: 1em">Test::Legacy
tests written with Test.pm, the original testing module, do
not play well with other testing libraries. Test::Legacy
emulates the Test.pm interface and does play well with
others.</p>


<p style="margin-left:11%; margin-top: 1em">Test::Differences
for more ways to test complex data structures. And it plays
well with Test::More.</p>

<p style="margin-left:11%; margin-top: 1em">Test::Class is
like xUnit but more perlish.</p>

<p style="margin-left:11%; margin-top: 1em">Test::Deep
gives you more powerful complex data structure testing.</p>

<p style="margin-left:11%; margin-top: 1em">Test::Inline
shows the idea of embedded testing.</p>

<p style="margin-left:11%; margin-top: 1em">Bundle::Test
installs a whole bunch of useful test modules.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Michael G
Schwern &lt;schwern@pobox.com&gt; with much inspiration from
Joshua Pritikin&rsquo;s Test module and lots of help from
Barrie Slaymaker, Tony Bowden, blackstar.co.uk, chromatic,
Fergal Daly and the perl-qa gang.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<i>http://rt.cpan.org</i> to report and view bugs.</p>

<h2>SOURCE
<a name="SOURCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The source code
repository for Test::More can be found at
<i>http://github.com/schwern/test&minus;more/</i>.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2001&minus;2008 by Michael G Schwern
&lt;schwern@pobox.com&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">See
<i>http://www.perl.com/perl/misc/Artistic.html</i></p>
<hr>
</body>
</html>
