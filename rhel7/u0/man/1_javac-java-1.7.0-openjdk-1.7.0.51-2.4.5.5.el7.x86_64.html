<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:01:16 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>javac</title>

</head>
<body>

<h1 align="center">javac</h1>

<a href="#Name">Name</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#COMMAND LINE ARGUMENT FILES">COMMAND LINE ARGUMENT FILES</a><br>
<a href="#ANNOTATION PROCESSING">ANNOTATION PROCESSING</a><br>
<a href="#SEARCHING FOR TYPES">SEARCHING FOR TYPES</a><br>
<a href="#PROGRAMMATIC INTERFACE">PROGRAMMATIC INTERFACE</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>Name
<a name="Name"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">javac &minus;
Java programming language compiler</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>javac</b> [
options ] [ sourcefiles ] [ classes ] [ @argfiles ]</p>

<p style="margin-left:11%; margin-top: 1em">Arguments may
be in any order.</p>

<p style="margin-left:15%;">options</p>

<p style="margin-left:20%;">Command&minus;line options.</p>

<p style="margin-left:15%;">sourcefiles</p>

<p style="margin-left:20%;">One or more source files to be
compiled (such as MyClass.java).</p>

<p style="margin-left:15%;">classes</p>

<p style="margin-left:20%;">One or more classes to be
processed for annotations (such as MyPackage.MyClass).</p>

<p style="margin-left:15%;">@argfiles</p>

<p style="margin-left:20%;">One or more files that lists
options and source files. The <i>&minus;J</i> options are
not allowed in these files.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>javac</b> tool reads class and interface definitions,
written in the Java programming language, and compiles them
into bytecode class files. It can also process annotations
in Java source files and classes.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
ways to pass source code file names to <b>javac</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>For a small number of source files, simply list the file
names on the command line.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="82%">


<p>For a large number of source files, list the file names
in a file, separated by blanks or line breaks. Then use the
list file name on the <b>javac</b> command line, preceded by
an <b>@</b> character.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Source code
file names must have <i>.java</i> suffixes, class file names
must have <i>.class</i> suffixes, and both source and class
files must have root names that identify the class. For
example, a class called <i>MyClass</i> would be written in a
source file called <i>MyClass.java</i> and compiled into a
bytecode class file called <i>MyClass.class</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Inner class
definitions produce additional class files. These class
files have names combining the inner and outer class names,
such as <i>MyClass$MyInnerClass.class</i>.</p>

<p style="margin-left:11%; margin-top: 1em">You should
arrange source files in a directory tree that reflects their
package tree. For example, if you keep all your source files
in <b>/workspace</b>, the source code for
<i>com.mysoft.mypack.MyClass</i> should be in
<b>/workspace/com/mysoft/mypack/MyClass.java</b>.</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
compiler puts each class file in the same directory as its
source file. You can specify a separate destination
directory with <b>&minus;d</b> (see Options, below).</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The compiler
has a set of standard options that are supported on the
current development environment and will be supported in
future releases. An additional set of non&minus;standard
options are specific to the current virtual machine and
compiler implementations and are subject to change in the
future. Non&minus;standard options begin with
<b>&minus;X</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Standard
Options</b></p>

<p style="margin-left:15%;">&minus;Akey[=value]</p>

<p style="margin-left:20%;">Options to pass to annotation
processors. These are not interpreted by javac directly, but
are made available for use by individual processors.
<i>key</i> should be one or more identifiers separated by
&quot;.&quot;.</p>

<p style="margin-left:15%;">&minus;cp path or
&minus;classpath path</p>

<p style="margin-left:20%;">Specify where to find user
class files, and (optionally) annotation processors and
source files. This class path overrides the user class path
in the <b>CLASSPATH</b> environment variable. If neither
<b>CLASSPATH</b>, <b>&minus;cp</b> nor
<b>&minus;classpath</b> is specified, the user class path
consists of the current directory. See Setting the Class
Path for more details. <br>
&gt;If the <b>&minus;sourcepath</b> option is not specified,
the user class path is also searched for source files. <br>
If the <b>&minus;processorpath</b> option is not specified,
the class path is also searched for annotation
processors.</p>


<p style="margin-left:15%;">&minus;Djava.ext.dirs=directories</p>

<p style="margin-left:20%;">Override the location of
installed extensions.</p>


<p style="margin-left:15%;">&minus;Djava.endorsed.dirs=directories</p>

<p style="margin-left:20%;">Override the location of
endorsed standards path.</p>

<p style="margin-left:15%;">&minus;d directory</p>

<p style="margin-left:20%;">Set the destination directory
for class files. The directory must already exist;
<b>javac</b> will not create it. If a class is part of a
package, <b>javac</b> puts the class file in a subdirectory
reflecting the package name, creating directories as needed.
For example, if you specify <b>&minus;d /home/myclasses</b>
and the class is called <i>com.mypackage.MyClass</i>, then
the class file is called
<i>/home/myclasses/com/mypackage/MyClass.class</i>. <br>
If <b>&minus;d</b> is not specified, <b>javac</b> puts each
class files in the same directory as the source file from
which it was generated. <b><br>
Note:</b> The directory specified by <b>&minus;d</b> is not
automatically added to your user class path.</p>

<p style="margin-left:15%;">&minus;deprecation</p>

<p style="margin-left:20%;">Show a description of each use
or override of a deprecated member or class. Without
<b>&minus;deprecation</b>, <b>javac</b> shows a summary of
the source files that use or override deprecated members or
classes. <b>&minus;deprecation</b> is shorthand for
<b>&minus;Xlint:deprecation</b>.</p>

<p style="margin-left:15%;">&minus;encoding encoding</p>

<p style="margin-left:20%;">Set the source file encoding
name, such as <i>EUC&minus;JP and UTF&minus;8</i>. If
<b>&minus;encoding</b> is not specified, the platform
default converter is used.</p>

<p style="margin-left:15%;">&minus;endorseddirs
directories</p>

<p style="margin-left:20%;">Override the location of
endorsed standards path.</p>

<p style="margin-left:15%;">&minus;extdirs directories</p>

<p style="margin-left:20%;">Overrides the location of the
<i>ext</i> directory. The <i>directories</i> variable is a
colon&minus;separated list of directories. Each JAR archive
in the specified directories is searched for class files.
All JAR archives found are automatically part of the class
path. <br>
If you are cross&minus;compiling (compiling classes against
bootstrap and extension classes of a different Java platform
implementation), this option specifies the directories that
contain the extension classes. See Cross&minus;Compilation
Options for more information.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>&minus;g</p></td>
<td width="2%"></td>
<td width="80%">


<p>Generate all debugging information, including local
variables. By default, only line number and source file
information is generated.</p></td></tr>
</table>

<p style="margin-left:15%;">&minus;g:none</p>

<p style="margin-left:20%;">Do not generate any debugging
information.</p>

<p style="margin-left:15%;">&minus;g:{keyword list}</p>

<p style="margin-left:20%;">Generate only some kinds of
debugging information, specified by a comma separated list
of keywords. Valid keywords are: <br>
source</p>

<p style="margin-left:25%;">Source file debugging
information</p>

<p style="margin-left:20%;">lines</p>

<p style="margin-left:25%;">Line number debugging
information</p>

<p style="margin-left:20%;">vars</p>

<p style="margin-left:25%;">Local variable debugging
information</p>

<p style="margin-left:15%;">&minus;help</p>

<p style="margin-left:20%;">Print a synopsis of standard
options.</p>


<p style="margin-left:15%;">&minus;implicit:{class,none}</p>

<p style="margin-left:20%;">Controls the generation of
class files for implicitly loaded source files. To
automatically generate class files, use
<b>&minus;implicit:class</b>. To suppress class file
generation, use <b>&minus;implicit:none</b>. If this option
is not specified, the default is to automatically generate
class files. In this case, the compiler will issue a warning
if any such class files are generated when also doing
annotation processing. The warning will not be issued if
this option is set explicitly. See Searching For Types.</p>

<p style="margin-left:15%;">&minus;Joption</p>

<p style="margin-left:20%;">Pass <i>option</i> to the
<b>java</b> launcher called by <b>javac</b>. For example,
<b>&minus;J&minus;Xms48m</b> sets the startup memory to 48
megabytes. It is a common convention for <b>&minus;J</b> to
pass options to the underlying VM executing applications
written in Java. <b><br>
Note: CLASSPATH</b>, <b>&minus;classpath</b>,
<b>&minus;bootclasspath</b>, and <b>&minus;extdirs</b> do
<i>not</i> specify the classes used to run <b>javac</b>.
Fiddling with the implementation of the compiler in this way
is usually pointless and always risky. If you do need to do
this, use the <b>&minus;J</b> option to pass through options
to the underlying <b>java</b> launcher.</p>

<p style="margin-left:15%;">&minus;nowarn</p>

<p style="margin-left:20%;">Disable warning messages. This
has the same meaning as <b>&minus;Xlint:none</b>.</p>

<p style="margin-left:15%;">&minus;proc: {none,only}</p>

<p style="margin-left:20%;">Controls whether annotation
processing and/or compilation is done.
<b>&minus;proc:none</b> means that compilation takes place
without annotation processing. <b>&minus;proc:only</b> means
that only annotation processing is done, without any
subsequent compilation.</p>

<p style="margin-left:15%;">&minus;processor
class1[,class2,class3...]</p>

<p style="margin-left:20%;">Names of the annotation
processors to run. This bypasses the default discovery
process.</p>

<p style="margin-left:15%;">&minus;processorpath path</p>

<p style="margin-left:20%;">Specify where to find
annotation processors; if this option is not used, the class
path will be searched for processors.</p>

<p style="margin-left:15%;">&minus;s dir</p>

<p style="margin-left:20%;">Specify the directory where to
place generated source files. The directory must already
exist; <b>javac</b> will not create it. If a class is part
of a package, the compiler puts the source file in a
subdirectory reflecting the package name, creating
directories as needed. For example, if you specify
<b>&minus;s /home/mysrc</b> and the class is called
<i>com.mypackage.MyClass</i>, then the source file will be
placed in <i>/home/mysrc/com/mypackage/MyClass.java</i>.</p>

<p style="margin-left:15%;">&minus;source release</p>

<p style="margin-left:20%;">Specifies the version of source
code accepted. The following values for <i>release</i> are
allowed: <br>
1.3</p>

<p style="margin-left:25%;">The compiler does <i>not</i>
support assertions, generics, or other language features
introduced after Java SE 1.3.</p>

<p style="margin-left:20%;">1.4</p>

<p style="margin-left:25%;">The compiler accepts code
containing assertions, which were introduced in Java SE
1.4.</p>

<p style="margin-left:20%;">1.5</p>

<p style="margin-left:25%;">The compiler accepts code
containing generics and other language features introduced
in Java SE 5.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>5</p></td>
<td width="3%"></td>
<td width="24%">


<p>Synonym for 1.5.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:20%;">1.6</p>

<p style="margin-left:25%;">No language changes were
introduced in Java SE 6. However, encoding errors in source
files are now reported as errors instead of warnings as in
previous releases of Java SE.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>6</p></td>
<td width="3%"></td>
<td width="24%">


<p>Synonym for 1.6.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:20%;">1.7</p>

<p style="margin-left:25%;">This is the default value. The
compiler accepts code with features introduced in Java SE
7.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>7</p></td>
<td width="3%"></td>
<td width="24%">


<p>Synonym for 1.7.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:15%;">&minus;sourcepath
sourcepath</p>

<p style="margin-left:20%;">Specify the source code path to
search for class or interface definitions. As with the user
class path, source path entries are separated by colons
(<b>:</b>) and can be directories, JAR archives, or ZIP
archives. If packages are used, the local path name within
the directory or archive must reflect the package name.
<b><br>
Note:</b> Classes found through the class path may be
subject to automatic recompilation if their sources are also
found. See Searching For Types.</p>

<p style="margin-left:15%;">&minus;verbose</p>

<p style="margin-left:20%;">Verbose output. This includes
information about each class loaded and each source file
compiled.</p>

<p style="margin-left:15%;">&minus;version</p>

<p style="margin-left:20%;">Print version information.</p>

<p style="margin-left:15%;">&minus;Werror</p>

<p style="margin-left:20%;">Terminate compilation if
warnings occur.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="3%">


<p>&minus;X</p></td>
<td width="2%"></td>
<td width="80%">


<p>Display information about non&minus;standard options and
exit.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Cross&minus;Compilation
Options</b> <br>
By default, classes are compiled against the bootstrap and
extension classes of the platform that <b>javac</b> shipped
with. But <b>javac</b> also supports
<i>cross&minus;compiling</i>, where classes are compiled
against a bootstrap and extension classes of a different
Java platform implementation. It is important to use
<b>&minus;bootclasspath</b> and <b>&minus;extdirs</b> when
cross&minus;compiling; see Cross&minus;Compilation Example
below.</p>

<p style="margin-left:15%;">&minus;target version</p>

<p style="margin-left:20%;">Generate class files that
target a specified version of the VM. Class files will run
on the specified target and on later versions, but not on
earlier versions of the VM. Valid targets are <b>1.1</b>,
<b>1.2</b>, <b>1.3</b>, <b>1.4</b>, <b>1.5</b> (also
<b>5</b>), <b>1.6</b> (also <b>6</b>), and <b>1.7</b> (also
<b>7</b>).</p>

<p style="margin-left:15%; margin-top: 1em">The default for
<b>&minus;target</b> depends on the value of
<b>&minus;source</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>If &minus;source is <b>not specified</b>, the value of
&minus;target is <b>1.7</b></p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>If &minus;source is <b>1.2</b>, the value of
&minus;target is <b>1.4</b></p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>If &minus;source is <b>1.3</b>, the value of
&minus;target is <b>1.4</b></p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>If &minus;source is <b>1.5</b>, the value of
&minus;target is <b>1.7</b></p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>If &minus;source is <b>1.6</b>, the value of
&minus;target is <b>1.7</b></p></td></tr>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="77%">


<p>For <b>all other values</b> of &minus;source, the value
of <b>&minus;target</b> is the value of
<b>&minus;source</b>.</p> </td></tr>
</table>

<p style="margin-left:15%;">&minus;bootclasspath
bootclasspath</p>

<p style="margin-left:20%;">Cross&minus;compile against the
specified set of boot classes. As with the user class path,
boot class path entries are separated by colons (<b>:</b>)
and can be directories, JAR archives, or ZIP archives.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Non&minus;Standard
Options</b></p>


<p style="margin-left:15%;">&minus;Xbootclasspath/p:path</p>

<p style="margin-left:20%;">Prepend to the bootstrap class
path.</p>


<p style="margin-left:15%;">&minus;Xbootclasspath/a:path</p>

<p style="margin-left:20%;">Append to the bootstrap class
path.</p>


<p style="margin-left:15%;">&minus;Xbootclasspath/:path</p>

<p style="margin-left:20%;">Override location of bootstrap
class files.</p>

<p style="margin-left:15%;">&minus;Xlint</p>

<p style="margin-left:20%;">Enable all recommended
warnings. In this release, enabling all available warnings
is recommended.</p>

<p style="margin-left:15%;">&minus;Xlint:all</p>

<p style="margin-left:20%;">Enable all recommended
warnings. In this release, enabling all available warnings
is recommended.</p>

<p style="margin-left:15%;">&minus;Xlint:none</p>

<p style="margin-left:20%;">Disable all warnings.</p>

<p style="margin-left:15%;">&minus;Xlint:name</p>

<p style="margin-left:20%;">Enable warning <i>name</i>. See
the section Warnings That Can Be Enabled or Disabled with
&minus;Xlint Option for a list of warnings you can enable
with this option.</p>

<p style="margin-left:15%;">&minus;Xlint:&minus;name</p>

<p style="margin-left:20%;">Disable warning <i>name</i>.
See the section Warnings That Can Be Enabled or Disabled
with &minus;Xlint Option for a list of warnings you can
disable with this option.</p>

<p style="margin-left:15%;">&minus;Xmaxerrs number</p>

<p style="margin-left:20%;">Set the maximum number of
errors to print.</p>

<p style="margin-left:15%;">&minus;Xmaxwarns number</p>

<p style="margin-left:20%;">Set the maximum number of
warnings to print.</p>

<p style="margin-left:15%;">&minus;Xstdout filename</p>

<p style="margin-left:20%;">Send compiler messages to the
named file. By default, compiler messages go to
<i>System.err</i>.</p>


<p style="margin-left:15%;">&minus;Xprefer:{newer,source}</p>

<p style="margin-left:20%;">Specify which file to read when
both a source file and class file are found for a type. (See
Searching For Types). If <i>&minus;Xprefer:newer</i> is
used, it reads the newer of the source or class file for a
type (default). If the <i>&minus;Xprefer:source</i> option
is used, it reads source file. Use
<i>&minus;Xprefer:source</i> when you want to be sure that
any annotation processors can access annotations declared
with a retention policy of <i>SOURCE</i>.</p>


<p style="margin-left:15%;">&minus;Xpkginfo:{always,legacy,nonempty}</p>

<p style="margin-left:20%;">Specify handling of
package&minus;info files</p>

<p style="margin-left:15%;">&minus;Xprint</p>

<p style="margin-left:20%;">Print out textual
representation of specified types for debugging purposes;
perform neither annotation processing nor compilation. The
format of the output may change.</p>

<p style="margin-left:15%;">&minus;XprintProcessorInfo</p>

<p style="margin-left:20%;">Print information about which
annotations a processor is asked to process.</p>

<p style="margin-left:15%;">&minus;XprintRounds</p>

<p style="margin-left:20%;">Print information about initial
and subsequent annotation processing rounds.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Warnings
That Can Be Enabled or Disabled with &minus;Xlint Option</b>
<br>
Enable warning <i>name</i> with the option
<b>&minus;Xlint:</b><i>name</i>, where <i>name</i> is one of
the following warning names. Similarly, you can disable
warning <i>name</i> with the option
<b>&minus;Xlint:&minus;</b><i>name</i>:</p>

<p style="margin-left:15%;">cast</p>

<p style="margin-left:20%;">Warn about unnecessary and
redundant casts. For example: <b><br>
String s = (String)&quot;Hello!&quot;</b></p>

<p style="margin-left:15%;">classfile</p>

<p style="margin-left:20%;">Warn about issues related to
classfile contents.</p>

<p style="margin-left:15%;">deprecation</p>

<p style="margin-left:20%;">Warn about use of deprecated
items. For example: <b><br>
java.util.Date myDate = new java.util.Date(); <br>
int currentDay = myDate.getDay();</b> <br>
The method <i>java.util.Date.getDay</i> has been deprecated
since JDK 1.1.</p>

<p style="margin-left:15%;">dep&minus;ann</p>

<p style="margin-left:20%;">Warn about items that are
documented with an <i>@deprecated</i> Javadoc comment, but
do not have a <i>@Deprecated</i> annotation. For example:
<b><br>
/** <br>
* @deprecated As of Java SE 7, replaced by {@link
#newMethod()} <br>
*/</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>public
static void deprecatedMethood() { }</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>public
static void newMethod() { }</b></p>

<p style="margin-left:15%;">divzero</p>

<p style="margin-left:20%;">Warn about division by constant
integer 0. For example: <b><br>
int divideByZero = 42 / 0;</b></p>

<p style="margin-left:15%;">empty</p>

<p style="margin-left:20%;">Warn about empty statements
after <i>if</i> statements. For example: <b><br>
class E { <br>
void m() { <br>
if (true) ; <br>
} <br>
}</b></p>

<p style="margin-left:15%;">fallthrough</p>

<p style="margin-left:20%;">Check <i>switch</i> blocks for
fall&minus;through cases and provide a warning message for
any that are found. Fall&minus;through cases are cases in a
<i>switch</i> block, other than the last case in the block,
whose code does not include a <i>break</i> statement,
allowing code execution to &quot;fall through&quot; from
that case to the next case. For example, the code following
the <i>case 1</i> label in this <i>switch</i> block does not
end with a <i>break</i> statement: <b><br>
switch (x) { <br>
case 1: <br>
System.out.println(&quot;1&quot;); <br>
// No break statement here. <br>
case 2: <br>
System.out.println(&quot;2&quot;); <br>
}</b> <br>
If the <i>&minus;Xlint:fallthrough</i> flag were used when
compiling this code, the compiler would emit a warning about
&quot;possible fall&minus;through into case,&quot; along
with the line number of the case in question.</p>

<p style="margin-left:15%;">finally</p>

<p style="margin-left:20%;">Warn about <i>finally</i>
clauses that cannot complete normally. For example: <b><br>
public static int m() { <br>
try { <br>
throw new NullPointerException(); <br>
} catch (NullPointerException e) { <br>
System.err.println(&quot;Caught
NullPointerException.&quot;); <br>
return 1; <br>
} finally { <br>
return 0; <br>
} <br>
}</b> <br>
The compiler generates a warning for <i>finally</i> block in
this example. When this method is called, it returns a value
of <i>0</i>, not <i>1</i>. A <i>finally</i> block always
executes when the <i>try</i> block exits. In this example,
if control is transferred to the <i>catch</i>, then the
method exits. However, the <i>finally</i> block must be
executed, so it is executed, even though control has already
been transferred outside the method.</p>

<p style="margin-left:15%;">options</p>

<p style="margin-left:20%;">Warn about issues relating to
the use of command line options. See Cross&minus;Compilation
Example for an example of this kind of warning.</p>

<p style="margin-left:15%;">overrides</p>

<p style="margin-left:20%;">Warn about issues regarding
method overrides. For example, consider the following two
classes: <b><br>
public class ClassWithVarargsMethod { <br>
void varargsMethod(String... s) { } <br>
} <br>
public class ClassWithOverridingMethod extends
ClassWithVarargsMethod { <br>
@Override <br>
void varargsMethod(String[] s) { } <br>
}</b> <br>
The compiler generates a warning similar to the following:
<i><br>
warning: [override] varargsMethod(String[]) in
ClassWithOverridingMethod overrides varargsMethod(String...)
in ClassWithVarargsMethod; overriding method is missing
&rsquo;...&rsquo;</i> <br>
When the compiler encounters a varargs method, it translates
the varargs formal parameter into an array. In the method
<i>ClassWithVarargsMethod.varargsMethod</i>, the compiler
translates the varargs formal parameter <i>String... s</i>
to the formal parameter <i>String[] s</i>, an array, which
matches the formal parameter of the method
<i>ClassWithOverridingMethod.varargsMethod</i>.
Consequently, this example compiles.</p>

<p style="margin-left:15%;">path</p>

<p style="margin-left:20%;">Warn about invalid path
elements and nonexistent path directories on the command
line (with regards to the class path, the source path, and
other paths). Such warnings cannot be suppressed with the
<i>@SuppressWarnings</i> annotation. For example: <b><br>
javac &minus;Xlint:path &minus;classpath /nonexistentpath
Example.java</b></p>

<p style="margin-left:15%;">processing</p>

<p style="margin-left:20%;">Warn about issues regarding
annotation processing. The compiler generates this warning
if you have a class that has an annotation, and you use an
annotation processor that cannot handle that type of
exception. For example, the following is a simple annotation
processor: <b><br>
Source file</b> <b><i>AnnoProc.java</i></b>: <b><br>
import java.util.*; <br>
import javax.annotation.processing.*; <br>
import javax.lang.model.*; <br>
import javax.lang.model.element.*;</b></p>


<p style="margin-left:20%; margin-top: 1em"><b>@SupportedAnnotationTypes(&quot;NotAnno&quot;)
<br>
public class AnnoProc extends AbstractProcessor { <br>
public boolean process(Set&lt;? extends TypeElement&gt;
elems, RoundEnvironment renv) { <br>
return true; <br>
}</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>public
SourceVersion getSupportedSourceVersion() { <br>
return SourceVersion.latest(); <br>
} <br>
} <br>
Source file</b>
<b><i>AnnosWithoutProcessors.java</i></b><b>: <br>
@interface Anno { }</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>@Anno <br>
class AnnosWithoutProcessors { }</b> <br>
The following commands compile the annotation processor
<i>AnnoProc</i>, then run this annotation processor against
the source file <i>AnnosWithoutProcessors.java</i>: <b><br>
% javac AnnoProc.java</b> <br>
% <b>javac &minus;cp . &minus;Xlint:processing
&minus;processor AnnoProc &minus;proc:only
AnnosWithoutProcessors.java</b> <br>
When the compiler runs the annotation processor against the
source file <i>AnnosWithoutProcessors.java</i>, it generates
the following warning: <i><br>
warning: [processing] No processor claimed any of these
annotations: Anno</i> <br>
To resolve this issue, you can rename the annotation defined
and used in the class <i>AnnosWithoutProcessors</i> from
<i>Anno</i> to <i>NotAnno</i>.</p>

<p style="margin-left:15%;">rawtypes</p>

<p style="margin-left:20%;">Warn about unchecked operations
on raw types. The following statement generates a
<i>rawtypes</i> warning: <b><br>
void countElements(List l) { ... }</b> <br>
The following does not generate a <i>rawtypes</i> warning:
<b><br>
void countElements(List&lt;?&gt; l) { ... }</b> <i><br>
List</i> is a raw type. However, <i>List&lt;?&gt;</i> is a
unbounded wildcard parameterized type. Because <i>List</i>
is a parameterized interface, you should always specify its
type argument. In this example, the <i>List</i> formal
argument is specified with a unbounded wildcard (<i>?</i>)
as its formal type parameter, which means that the
<i>countElements</i> method can accept any instantiation of
the <i>List</i> interface.</p>

<p style="margin-left:15%;">serial</p>

<p style="margin-left:20%;">Warn about missing
<i>serialVersionUID</i> definitions on serializable classes.
For example: <b><br>
public class PersistentTime implements Serializable <br>
{ <br>
private Date time;</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>public
PersistentTime() { <br>
time = Calendar.getInstance().getTime(); <br>
}</b></p>

<p style="margin-left:20%; margin-top: 1em"><b>public Date
getTime() { <br>
return time; <br>
} <br>
}</b> <br>
The compiler generates the following warning: <i><br>
warning: [serial] serializable class PersistentTime has no
definition of serialVersionUID</i> <br>
If a serializable class does not explicitly declare a field
named <i>serialVersionUID</i>, then the serialization
runtime will calculate a default <i>serialVersionUID</i>
value for that class based on various aspects of the class,
as described in the Java Object Serialization Specification.
However, it is strongly recommended that all serializable
classes explicitly declare <i>serialVersionUID</i> values
because the default process of computing
<i>serialVersionUID</i> vales is highly sensitive to class
details that may vary depending on compiler implementations,
and can thus result in unexpected
<i>InvalidClassExceptions</i> during deserialization.
Therefore, to guarantee a consistent <i>serialVersionUID</i>
value across different Java compiler implementations, a
serializable class must declare an explicit
<i>serialVersionUID</i> value.</p>

<p style="margin-left:15%;">static</p>

<p style="margin-left:20%;">Warn about issues relating to
use of statics. For example: <b><br>
class XLintStatic { <br>
static void m1() { } <br>
void m2() { this.m1(); } <br>
}</b> <br>
The compiler generates the following warning: <b><br>
warning: [static] static method should be qualified by type
name, XLintStatic, instead of by an expression</b> <br>
To resolve this issue, you can call the static method
<i>m1</i> as follows: <b><br>
XLintStatic.m1();</b> <br>
Alternatively, you can remove the <i>static</i> keyword from
the declaration of the method <i>m1</i>.</p>

<p style="margin-left:15%;">try</p>

<p style="margin-left:20%;">Warn about issues relating to
use of <i>try</i> blocks, including
try&minus;with&minus;resources statements. For example, a
warning is generated for the following statement because the
resource <i>ac</i> declared in the <i>try</i> statement is
not used: <b><br>
try ( AutoCloseable ac = getResource() ) { <br>
// do nothing <br>
}</b></p>

<p style="margin-left:15%;">unchecked</p>

<p style="margin-left:20%;">Give more detail for unchecked
conversion warnings that are mandated by the Java Language
Specification. For example: <b><br>
List l = new ArrayList&lt;Number&gt;(); <br>
List&lt;String&gt; ls = l; // unchecked warning</b> <br>
During type erasure, the types
<i>ArrayList&lt;Number&gt;</i> and <i>List&lt;String&gt;</i>
become <i>ArrayList</i> and <i>List</i>, respectively. <br>
The variable <i>ls</i> has the parameterized type
<i>List&lt;String&gt;</i>. When the <i>List</i> referenced
by <i>l</i> is assigned to <i>ls</i>, the compiler generates
an unchecked warning; the compiler is unable to determine at
compile time, and moreover knows that the JVM will not be
able to determine at runtime, if <i>l</i> refers to a
<i>List&lt;String&gt;</i> type; it does not. Consequently,
heap pollution occurs. <br>
In detail, a heap pollution situation occurs when the
<i>List</i> object <i>l</i>, whose static type is
<i>List&lt;Number&gt;</i>, is assigned to another
<i>List</i> object, <i>ls</i>, that has a different static
type, <i>List&lt;String&gt;</i>. However, the compiler still
allows this assignment. It must allow this assignment to
preserve backwards compatibility with versions of Java SE
that do not support generics. Because of type erasure,
<i>List&lt;Number&gt;</i> and <i>List&lt;String&gt;</i> both
become <i>List</i>. Consequently, the compiler allows the
assignment of the object <i>l</i>, which has a raw type of
<i>List</i>, to the object <i>ls</i>.</p>

<p style="margin-left:15%;">varargs</p>

<p style="margin-left:20%;">Warn about unsafe usages of
variable arguments (varargs) methods, in particular, those
that contain non&minus;reifiable arguments. For example:
<b><br>
public class ArrayBuilder { <br>
public static &lt;T&gt; void addToList (List&lt;T&gt;
listArg, T... elements) { <br>
for (T x : elements) { <br>
listArg.add(x); <br>
} <br>
} <br>
}</b> <br>
The compiler generates the following warning for the
definition of the method <i>ArrayBuilder.addToList</i>:
<b><br>
warning: [varargs] Possible heap pollution from
parameterized vararg type T</b> <br>
When the compiler encounters a varargs method, it translates
the varargs formal parameter into an array. However, the
Java programming language does not permit the creation of
arrays of parameterized types. In the method
<i>ArrayBuilder.addToList</i>, the compiler translates the
varargs formal parameter <i>T... elements</i> to the formal
parameter <i>T[] elements</i>, an array. However, because of
type erasure, the compiler converts the varargs formal
parameter to <i>Object[] elements</i>. Consequently, there
is a possibility of heap pollution.</p>

<h2>COMMAND LINE ARGUMENT FILES
<a name="COMMAND LINE ARGUMENT FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To shorten or
simplify the javac command line, you can specify one or more
files that themselves contain arguments to the <i>javac</i>
command (except <i>&minus;J</i> options). This enables you
to create javac commands of any length on any operating
system.</p>

<p style="margin-left:11%; margin-top: 1em">An argument
file can include javac options and source filenames in any
combination. The arguments within a file can be
space&minus;separated or newline&minus;separated. If a
filename contains embedded spaces, put the whole filename in
double quotes.</p>

<p style="margin-left:11%; margin-top: 1em">Filenames
within an argument file are relative to the current
directory, not the location of the argument file. Wildcards
(*) are not allowed in these lists (such as for specifying
<i>*.java</i>). Use of the &rsquo;<i>@</i>&rsquo; character
to recursively interpret files is not supported. The
<i>&minus;J</i> options are not supported because they are
passed to the launcher, which does not support argument
files.</p>

<p style="margin-left:11%; margin-top: 1em">When executing
javac, pass in the path and name of each argument file with
the &rsquo;<i>@</i>&rsquo; leading character. When javac
encounters an argument beginning with the character
&lsquo;<i>@</i>&rsquo;, it expands the contents of that file
into the argument list.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
&minus; Single Arg File</b> <br>
You could use a single argument file named
&quot;<i>argfile</i>&quot; to hold all javac arguments:</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
@argfile</b></p>

<p style="margin-left:11%; margin-top: 1em">This argument
file could contain the contents of both files shown in the
next example.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
&minus; Two Arg Files</b> <br>
You can create two argument files &minus;&minus; one for the
javac options and the other for the source filenames:
(Notice the following lists have no line&minus;continuation
characters.)</p>

<p style="margin-left:11%; margin-top: 1em">Create a file
named &quot;<i>options</i>&quot; containing:</p>

<p style="margin-left:11%; margin-top: 1em"><b>&minus;d
classes <br>
&minus;g <br>
&minus;sourcepath
/java/pubs/ws/1.3/src/share/classes</b></p>

<p style="margin-left:11%; margin-top: 1em">Create a file
named &quot;<i>classes</i>&quot; containing:</p>


<p style="margin-left:11%; margin-top: 1em"><b>MyClass1.java
<br>
MyClass2.java <br>
MyClass3.java</b></p>

<p style="margin-left:11%; margin-top: 1em">You would then
run <b>javac</b> with:</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
@options @classes</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
&minus; Arg Files with Paths</b> <br>
The argument files can have paths, but any filenames inside
the files are relative to the current working directory (not
<i>path1</i> or <i>path2</i>):</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
@path1/options @path2/classes</b></p>

<h2>ANNOTATION PROCESSING
<a name="ANNOTATION PROCESSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>javac</b>
provides direct support for annotation processing,
superseding the need for the separate annotation processing
tool, <b>apt</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The API for
annotation processors is defined in the
<i>javax.annotation.processing</i> and
<i>javax.lang.model</i> packages and subpackages.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Overview of
annotation processing</b> <br>
Unless annotation processing is disabled with the
<b>&minus;proc:none</b> option, the compiler searches for
any annotation processors that are available. The search
path can be specified with the <b>&minus;processorpath</b>
option; if it is not given, the user class path is used.
Processors are located by means of service
provider&minus;configuration files named
<i>META&minus;INF/services/javax.annotation.processing.Processor</i>
on the search path. Such files should contain the names of
any annotation processors to be used, listed one per line.
Alternatively, processors can be specified explicitly, using
the <b>&minus;processor</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">After scanning
the source files and classes on the command line to
determine what annotations are present, the compiler queries
the processors to determine what annotations they process.
When a match is found, the processor will be invoked. A
processor may &quot;claim&quot; the annotations it
processes, in which case no further attempt is made to find
any processors for those annotations. Once all annotations
have been claimed, the compiler does not look for additional
processors.</p>

<p style="margin-left:11%; margin-top: 1em">If any
processors generate any new source files, another round of
annotation processing will occur: any newly generated source
files will be scanned, and the annotations processed as
before. Any processors invoked on previous rounds will also
be invoked on all subsequent rounds. This continues until no
new source files are generated.</p>

<p style="margin-left:11%; margin-top: 1em">After a round
occurs where no new source files are generated, the
annotation processors will be invoked one last time, to give
them a chance to complete any work they may need to do.
Finally, unless the <b>&minus;proc:only</b> option is used,
the compiler will compile the original and all the generated
source files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Implicitly
loaded source files</b> <br>
To compile a set of source files, the compiler may need to
implicitly load additional source files. (See Searching For
Types). Such files are currently not subject to annotation
processing. By default, the compiler will give a warning if
annotation processing has occurred and any implicitly loaded
source files are compiled. See the &minus;implicit option
for ways to suppress the warning.</p>

<h2>SEARCHING FOR TYPES
<a name="SEARCHING FOR TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When compiling
a source file, the compiler often needs information about a
type whose definition did not appear in the source files
given on the command line. The compiler needs type
information for every class or interface used, extended, or
implemented in the source file. This includes classes and
interfaces not explicitly mentioned in the source file but
which provide information through inheritance.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
when you subclass <b>java.applet.Applet</b>, you are also
using <b>Applet&rsquo;s</b> ancestor classes:
<b>java.awt.Panel</b>, <b>java.awt.Container</b>,
<b>java.awt.Component</b>, and <b>java.lang.Object</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When the
compiler needs type information, it looks for a source file
or class file which defines the type. The compiler searches
for class files first in the bootstrap and extension
classes, then in the user class path (which by default is
the current directory). The user class path is defined by
setting the <b>CLASSPATH</b> environment variable or by
using the <b>&minus;classpath</b> command line option. (For
details, see Setting the Class Path).</p>

<p style="margin-left:11%; margin-top: 1em">If you set the
&minus;sourcepath option, the compiler searches the
indicated path for source files; otherwise the compiler
searches the user class path for both class files and source
files.</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
different bootstrap or extension classes with the
<b>&minus;bootclasspath</b> and <b>&minus;extdirs</b>
options; see Cross&minus;Compilation Options below.</p>

<p style="margin-left:11%; margin-top: 1em">A successful
type search may produce a class file, a source file, or
both. If both are found, you can use the &minus;Xprefer
option to instruct the compiler which to use. If
<b>newer</b> is given, the compiler will use the newer of
the two files. If <b>source</b> is given, it will use the
source file. The default is <b>newer</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If a type
search finds a source file for a required type, either by
itself, or as a result of the setting for
<b>&minus;Xprefer</b>, the compiler will read the source
file to get the information it needs. In addition, it will
by default compile the source file as well. You can use the
&minus;implicit option to specify the behavior. If
<b>none</b> is given, no class files will be generated for
the source file. If <b>class</b> is given, class files will
be generated for the source file.</p>

<p style="margin-left:11%; margin-top: 1em">The compiler
may not discover the need for some type information until
after annotation processing is complete. If the type
information is found in a source file and no
<b>&minus;implicit</b> option is given, the compiler will
give a warning that the file is being compiled without being
subject to annotation processing. To disable the warning,
either specify the file on the command line (so that it will
be subject to annotation processing) or use the
<b>&minus;implicit</b> option to specify whether or not
class files should be generated for such source files.</p>

<h2>PROGRAMMATIC INTERFACE
<a name="PROGRAMMATIC INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>javac</b>
supports the new Java Compiler API defined by the classes
and interfaces in the <i>javax.tools</i> package.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
To perform a compilation using arguments as you would give
on the command line, you can use the following:</p>


<p style="margin-left:11%; margin-top: 1em"><b>JavaCompiler
javac = ToolProvider.getSystemJavaCompiler(); <br>
int rc = javac.run(null, null, null, args);</b></p>

<p style="margin-left:11%; margin-top: 1em">This will write
any diagnostics to the standard output stream, and return
the exit code that <b>javac</b> would give when invoked from
the command line.</p>

<p style="margin-left:11%; margin-top: 1em">You can use
other methods on the <i>javax.tools.JavaCompiler</i>
interface to handle diagnostics, control where files are
read from and written to, and so on.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Old
Interface <br>
Note:</b> This API is retained for backwards compatibility
only; all new code should use the Java Compiler API,
described above.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>com.sun.tools.javac.Main</i> class provides two static
methods to invoke the compiler from a program:</p>

<p style="margin-left:11%; margin-top: 1em"><b>public
static int compile(String[] args); <br>
public static int compile(String[] args, PrintWriter
out);</b></p>

<p style="margin-left:11%; margin-top: 1em">The <i>args</i>
parameter represents any of the command line arguments that
would normally be passed to the javac program and are
outlined in the above Synopsis section.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>out</i>
parameter indicates where the compiler&rsquo;s diagnostic
output is directed.</p>

<p style="margin-left:11%; margin-top: 1em">The return
value is equivalent to the exit value from <b>javac</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that all
<b>other</b> classes and methods found in a package whose
name starts with <i>com.sun.tools.javac</i> (informally
known as sub&minus;packages of <i>com.sun.tools.javac</i>)
are strictly internal and subject to change at any time.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Compiling a
Simple Program</b> <br>
One source file, <i>Hello.java</i>, defines a class called
<b>greetings.Hello</b>. The <i>greetings</i> directory is
the package directory both for the source file and the class
file and is off the current directory. This allows us to use
the default user class path. It also makes it unnecessary to
specify a separate destination directory with
<b>&minus;d</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% ls</b>
<br>
greetings/ <br>
% <b>ls greetings</b> <br>
Hello.java <br>
% <b>cat greetings/Hello.java</b> <br>
package greetings;</p>

<p style="margin-left:11%; margin-top: 1em">public class
Hello { <br>
public static void main(String[] args) { <br>
for (int i=0; i &lt; args.length; i++) { <br>
System.out.println(&quot;Hello &quot; + args[i]); <br>
} <br>
} <br>
} <br>
% <b>javac greetings/Hello.java</b> <br>
% <b>ls greetings</b> <br>
Hello.class Hello.java <br>
% <b>java greetings.Hello World Universe Everyone</b> <br>
Hello World <br>
Hello Universe <br>
Hello Everyone</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compiling
Multiple Source Files</b> <br>
This example compiles all the source files in the package
<i>greetings</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% ls</b>
<br>
greetings/ <br>
% <b>ls greetings</b> <br>
Aloha.java GutenTag.java Hello.java Hi.java <br>
% <b>javac greetings/*.java</b> <br>
% <b>ls greetings</b> <br>
Aloha.class GutenTag.class Hello.class Hi.class <br>
Aloha.java GutenTag.java Hello.java Hi.java</p>

<p style="margin-left:11%; margin-top: 1em"><b>Specifying a
User Class Path</b> <br>
Having changed one of the source files in the previous
example, we recompile it:</p>

<p style="margin-left:11%; margin-top: 1em"><b>% pwd</b>
<br>
/examples <br>
% <b>javac greetings/Hi.java</b></p>

<p style="margin-left:11%; margin-top: 1em">Since
<i>greetings.Hi</i> refers to other classes in the
<i>greetings</i> package, the compiler needs to find these
other classes. The example above works, because our default
user class path happens to be the directory containing the
package directory. But suppose we want to recompile this
file and not worry about which directory we&rsquo;re in?
Then we need to add <i>/examples</i> to the user class path.
We can do this by setting <b>CLASSPATH</b>, but here
we&rsquo;ll use the <b>&minus;classpath</b> option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
&minus;classpath /examples
/examples/greetings/Hi.java</b></p>

<p style="margin-left:11%; margin-top: 1em">If we change
<i>greetings.Hi</i> again, to use a banner utility, that
utility also needs to be accessible through the user class
path.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
&minus;classpath /examples:/lib/Banners.jar \ <br>
/examples/greetings/Hi.java</b></p>

<p style="margin-left:11%; margin-top: 1em">To execute a
class in <i>greetings</i>, we need access both to
<i>greetings</i> and to the classes it uses.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% java
&minus;classpath /examples:/lib/Banners.jar
greetings.Hi</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Separating
Source Files and Class Files</b> <br>
It often makes sense to keep source files and class files in
separate directories, especially on large projects. We use
<b>&minus;d</b> to indicate the separate class file
destination. Since the source files are not in the user
class path, we use <b>&minus;sourcepath</b> to help the
compiler find them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% ls</b>
<br>
classes/ lib/ src/ <br>
% <b>ls src</b> <br>
farewells/ <br>
% <b>ls src/farewells</b> <br>
Base.java GoodBye.java <br>
% <b>ls lib</b> <br>
Banners.jar <br>
% <b>ls classes</b> <br>
% <b>javac &minus;sourcepath src &minus;classpath
classes:lib/Banners.jar \ <br>
src/farewells/GoodBye.java &minus;d classes</b> <br>
% <b>ls classes</b> <br>
farewells/ <br>
% <b>ls classes/farewells</b> <br>
Base.class GoodBye.class</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
The compiler compiled <i>src/farewells/Base.java</i>, even
though we didn&rsquo;t specify it on the command line. To
trace automatic compiles, use the <b>&minus;verbose</b>
option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Cross&minus;Compilation
Example</b> <br>
The following example uses <b>javac</b> to compile code that
will run on a 1.6 VM.</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
&minus;source 1.6 &minus;target 1.6 &minus;bootclasspath
jdk1.6.0/lib/rt.jar \ <br>
&minus;extdirs &quot;&quot; OldCode.java</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<i>&minus;source 1.6</i> option specifies that version 1.6
(or 6) of the Java programming language be used to compile
<i>OldCode.java</i>. The option <b>&minus;target 1.6</b>
option ensures that the generated class files will be
compatible with 1.6 VMs. Note that in most cases, the value
of the <b>&minus;target</b> option is the value of the
<b>&minus;source</b> option; in this example, you can omit
the <b>&minus;target</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">You must
specify the <b>&minus;bootclasspath</b> option to specify
the correct version of the bootstrap classes (the
<i>rt.jar</i> library). If not, the compiler generates a
warning:</p>

<p style="margin-left:11%; margin-top: 1em"><b>% javac
&minus;source 1.6 OldCode.java</b> <br>
warning: [options] bootstrap class path not set in
conjunction with &minus;source 1.6</p>

<p style="margin-left:11%; margin-top: 1em">If you do not
specify the correct version of bootstrap classes, the
compiler will use the old language rules (in this example,
it will use version 1.6 of the Java programming language)
combined with the new bootstrap classes, which can result in
class files that do not work on the older platform (in this
case, Java SE 6) because reference to non&minus;existent
methods can get included.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="27%">


<p style="margin-top: 1em"><i>The javac Guide</i> @</p></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:18%;">http://docs.oracle.com/javase/7/docs/technotes/guides/javac/index.html</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">o</p></td>
<td width="1%"></td>
<td width="67%">


<p style="margin-top: 1em">java(1) &minus; the Java
Application Launcher</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p>jdb(1) &minus; Java Application Debugger</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p>javah(1) &minus; C Header and Stub File Generator</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p>javap(1) &minus; Class File Disassembler</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p>javadoc(1) &minus; API Documentation Generator</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p>jar(1) &minus; JAR Archive Tool</p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>o</p></td>
<td width="1%"></td>
<td width="67%">


<p><i>The Java Extensions Framework</i> @</p></td>
<td width="15%">
</td></tr>
</table>


<p style="margin-left:18%;">http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/index.html</p>
<hr>
</body>
</html>
