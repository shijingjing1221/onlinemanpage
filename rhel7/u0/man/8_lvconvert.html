<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:05:26 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LVCONVERT</title>

</head>
<body>

<h1 align="center">LVCONVERT</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#Examples">Examples</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvconvert
&minus; convert a logical volume from linear to mirror or
snapshot</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;m</b>|<b>&minus;&minus;mirrors</b> <i>Mirrors</i>
[<b>&minus;&minus;mirrorlog</b>
{<i>disk</i>|<i>core</i>|<i>mirrored</i>}]
[<b>&minus;&minus;corelog</b>]
[<b>&minus;R</b>|<b>&minus;&minus;regionsize</b>
<i>MirrorLogRegionSize</i>] [<b>&minus;&minus;type</b>
<i>SegmentType</i>]
[<b>&minus;A</b>|<b>&minus;&minus;alloc</b>
<i>AllocationPolicy</i>]
[<b>&minus;b</b>|<b>&minus;&minus;background</b>]
[<b>&minus;f</b>|<b>&minus;&minus;force</b>]
[<b>&minus;i</b>|<b>&minus;&minus;interval</b>
<i>Seconds</i>]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;&minus;stripes</b> <i>Stripes</i>
[<b>&minus;I</b>|<b>&minus;&minus;stripesize</b>
<i>StripeSize</i>]] [<b>&minus;&minus;noudevsync</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;y</b>|<b>&minus;&minus;yes</b>]
[<b>&minus;&minus;version</b>]
<i>LogicalVolume</i>[<i>Path</i>]
[<i>PhysicalVolume</i>[<i>Path</i>][<i>:PE</i>[<i>-PE</i>]]...]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors</b> <i>Images</i>
[<b>&minus;&minus;name</b> <i>SplitLogicalVolumeName</i>]
[<b>&minus;&minus;trackchanges</b>]
<i>MirrorLogicalVolume</i>[<i>Path</i>]
[<i>SplittablePhysicalVolume</i>[<i>Path</i>][<i>:PE</i>[<i>-PE</i>]]...]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitsnapshot</b>
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;&minus;noudevsync</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]
<i>SnapshotLogicalVolume</i>[<i>Path</i>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;s</b>|<b>&minus;&minus;snapshot</b>
[<b>&minus;c</b>|<b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<i>bBsSkK</i>]]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;&minus;noudevsync</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;Z</b>|<b>&minus;&minus;zero</b>
{<i>y</i>|<i>n</i>}] [<b>&minus;&minus;version</b>]
<i>OriginalLogicalVolume</i>[<i>Path</i>]
<i>SnapshotLogicalVolume</i>[<i>Path</i>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge</b>
[<b>&minus;b</b>|<b>&minus;&minus;background</b>]
[<b>&minus;i</b>|<b>&minus;&minus;interval</b>
<i>Seconds</i>]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]
<i>LogicalVolume</i>[<i>Path</i>]...</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;repair</b>
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;&minus;stripes</b> <i>Stripes</i>
[<b>&minus;I</b>|<b>&minus;&minus;stripesize</b>
<i>StripeSize</i>]]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]
<i>LogicalVolume</i>[<i>Path</i>]
[<i>PhysicalVolume</i>[<i>Path</i>]...]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;replace</b> <i>PhysicalVolume</i>
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]
<i>LogicalVolume</i>[<i>Path</i>]
[<i>PhysicalVolume</i>[<i>Path</i>]...]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;thinpool</b>
<i>ThinPoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
[<b>&minus;c</b>|<b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<i>bBsSkKmMgG</i>]]
[<b>&minus;&minus;discards</b>
{<i>ignore</i>|<i>nopassdown</i>|<i>passdown</i>}]
[{<b>&minus;&minus;poolmetadata</b>
<i>ThinPoolMetadataLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
| <b>&minus;&minus;poolmetadatasize</b>
<i>ThinPoolMetadataSize</i>[<i>bBsSkKmMgG</i>]}]
[<b>&minus;r</b>|<b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<i>auto</i>|<i>none</i>}]
[<b>&minus;&minus;stripes</b> <i>Stripes</i>
[<b>&minus;I</b>|<b>&minus;&minus;stripesize</b>
<i>StripeSize</i>]]]
[<b>&minus;Z</b>|<b>&minus;&minus;zero</b>
{<i>y</i>|<i>n</i>}]
[<b>&minus;T</b>|<b>&minus;&minus;thin</b>
<i>ExternalOriginLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
[<b>&minus;&minus;originname</b>
<i>NewExternalOriginVolumeName</i>]]
[<i>PhysicalVolume</i>[<i>Path</i>][<i>:PE</i>[<i>-PE</i>]]...]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type</b> <i>cache-pool</i>
[<b>&minus;c</b>|<b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<i>bBsSkKmMgG</i>]]
[<b>&minus;&minus;cachemode</b>
{<i>writeback</i>|<i>writethrough</i>}]
[{<b>&minus;&minus;poolmetadata</b>
<i>CachePoolMetadataLogicalVolume</i>{<i>Name</i>|<i>Path</i>}
| <b>&minus;&minus;poolmetadatasize</b>
<i>CachePoolMetadataSize</i>[<i>bBsSkKmMgG</i>]}]
<i>LogicalVolume</i>[<i>Path</i>]
[<i>PhysicalVolume</i>[<i>Path</i>][<i>:PE</i>[<i>-PE</i>]]...]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type</b> <i>cache</i>
<b>&minus;&minus;cachepool</b>
<i>CachePoolLV</i>{<i>Name</i>|<i>Path</i>}
<i>LogicalVolume</i>[<i>Path</i>]
[<b>&minus;h</b>|<b>&minus;?</b>|<b>&minus;&minus;help</b>]
[<b>&minus;v</b>|<b>&minus;&minus;verbose</b>]
[<b>&minus;&minus;version</b>]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lvconvert is
used to change the segment type (i.e. linear, mirror, etc)
or characteristics of a logical volume. For example, it can
add or remove the redundant images of a logical volume,
change the log type of a mirror, or designate a logical
volume as a snapshot repository. <br>
If the conversion requires allocation of physical extents
(for example, when converting from linear to mirror) and you
specify one or more PhysicalVolumes (optionally with ranges
of physical extents), allocation of physical extents will be
restricted to these physical extents. If the conversion
frees physical extents (for example, when converting from a
mirror to a linear, or reducing mirror legs) and you specify
one or more PhysicalVolumes, the freed extents come first
from the specified PhysicalVolumes.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b>lvm</b>(8) for common options. <br>
Exactly one of <b>&minus;&minus;merge</b>,
<b>&minus;&minus;mirrors</b>, <b>&minus;&minus;repair</b>,
<b>&minus;&minus;replace</b>,
<b>&minus;&minus;splitsnapshot</b>,
<b>&minus;&minus;snapshot</b>,
<b>&minus;&minus;splitmirrors</b> or
<b>&minus;&minus;thinpool</b> arguments is required. <b><br>
&minus;b</b>, <b>&minus;&minus;background</b></p>

<p style="margin-left:22%;">Run the daemon in the
background.</p>

<p style="margin-left:11%;"><b>&minus;&minus;cachepool</b>
<tt>achePoolLV</tt></p>

<p style="margin-left:22%;">This argument is necessary when
converting a logical volume to a cache LV. For more
information on cache pool LVs and cache LVs, see
<b>lvm</b>(8).</p>

<p style="margin-left:11%;"><b>&minus;m</b>,
<b>&minus;&minus;mirrors</b> <i>Mirrors</i></p>

<p style="margin-left:22%;">Specifies the degree of the
mirror you wish to create. For example, &quot;<b>-m
1</b>&quot; would convert the original logical volume to a
mirror volume with 2-sides; that is, a linear volume plus
one copy. There are two implementations of mirroring which
correspond to the &quot;raid1&quot; and &quot;mirror&quot;
segment types. The default mirroring segment type is
&quot;raid1&quot;. If the legacy &quot;mirror&quot; segment
type is desired, the <b>&minus;&minus;type</b> argument must
be used to explicitly select the desired type. The
<b>&minus;&minus;mirrorlog</b> and
<b>&minus;&minus;corelog</b> options below are only relevant
to the legacy &quot;mirror&quot; segment type.</p>

<p style="margin-left:11%;"><b>&minus;&minus;mirrorlog</b>
{<i>disk</i>|<i>core</i>|<i>mirrored</i>}</p>

<p style="margin-left:22%;">Specifies the type of log to
use. The default is <i>disk</i>, which is persistent and
requires a small amount of storage space, usually on a
separate device from the data being mirrored. <i>Core</i>
may be useful for short-lived mirrors: It means the mirror
is regenerated by copying the data from the first device
again every time the device is activated - perhaps, for
example, after every reboot. Using <i>mirrored</i> will
create a persistent log that is itself mirrored.</p>


<p style="margin-left:11%;"><b>&minus;&minus;corelog</b></p>

<p style="margin-left:22%;">The optional argument
<b>&minus;&minus;corelog</b> is the same as specifying
<b>&minus;&minus;mirrorlog</b> <i>core</i>.</p>

<p style="margin-left:11%;"><b>&minus;R</b>,
<b>&minus;&minus;regionsize</b>
<i>MirrorLogRegionSize</i></p>

<p style="margin-left:22%;">A mirror is divided into
regions of this size (in MB), and the mirror log uses this
granularity to track which regions are in sync.</p>

<p style="margin-left:11%;"><b>&minus;&minus;type</b>
<i>SegmentType</i></p>

<p style="margin-left:22%;">Used to convert a logical
volume to another segment type, like cache-pool, cache,
raid1, or thin-pool. When converting a logical volume to a
cache LV, the &minus;&minus;cachepool argument is
required.</p>

<p style="margin-left:11%;"><b>&minus;i</b>,
<b>&minus;&minus;interval</b> <i>Seconds</i></p>

<p style="margin-left:22%;">Report progress as a percentage
at regular intervals.</p>


<p style="margin-left:11%;"><b>&minus;&minus;noudevsync</b></p>

<p style="margin-left:22%;">Disables udev synchronisation.
The process will not wait for notification from udev. It
will continue irrespective of any possible udev processing
in the background. You should only use this if udev is not
running or has rules that ignore the devices LVM2
creates.</p>


<p style="margin-left:11%;"><b>&minus;&minus;splitmirrors</b>
<i>Images</i></p>

<p style="margin-left:22%;">The number of redundant Images
of a mirror to be split off and used to form a new logical
volume. A name must be supplied for the newly-split-off
logical volume using the <b>&minus;&minus;name</b> argument,
unless the <b>&minus;&minus;trackchanges</b> argument is
given.</p>

<p style="margin-left:11%;"><b>&minus;n</b>,
<b>&minus;&minus;name&nbsp;</b><i>Name</i></p>

<p style="margin-left:22%;">The name to apply to a logical
volume which has been split off from a mirror logical
volume.</p>


<p style="margin-left:11%;"><b>&minus;&minus;trackchanges</b></p>

<p style="margin-left:22%;">Used with
<b>&minus;&minus;splitmirrors</b> on a raid1 device, this
tracks changes so that the read-only detached image can be
merged efficiently back into the mirror later. Only the
regions of the detached device where the data changed get
resynchronized.</p>

<p style="margin-left:22%; margin-top: 1em">Please note
that this feature is only supported with the new md-based
mirror implementation and not with the original
device-mapper mirror implementation.</p>


<p style="margin-left:11%;"><b>&minus;&minus;splitsnapshot</b></p>

<p style="margin-left:22%;">Separates SnapshotLogicalVolume
from its origin. The volume that is split off contains the
chunks that differ from the origin along with the metadata
describing them. This volume can be wiped and then destroyed
with lvremove. The inverse of &minus;&minus;snapshot.</p>

<p style="margin-left:11%;"><b>&minus;s,
&minus;&minus;snapshot</b></p>

<p style="margin-left:22%;">Recreates a snapshot from
constituent logical volumes (or copies of them) after having
been separated using &minus;&minus;splitsnapshot. For this
to work correctly, no changes may be made to the contents of
either volume after the split.</p>

<p style="margin-left:11%;"><b>&minus;c</b>,
<b>&minus;&minus;chunksize</b>
<i>ChunkSize</i>[<i>bBsSkKmMgG</i>]</p>

<p style="margin-left:22%;">Gives the size of chunk for
snapshot and thin pool logical volumes. Default unit is in
kilobytes. <br>
For snapshots the value must be power of 2 between 4KiB and
512KiB and the default value is 4. <br>
For thin pools the value must be between 64KiB and 1GiB and
the default value starts with 64 and scales up to fit the
pool metadata size within 128MiB, if the pool metadata size
is not specified. The value must be a multiple of 64KiB.
(Early kernel support until thin target version 1.4 required
the value to be a power of 2. Discards weren&rsquo;t
supported for non-power of 2 values until thin target
version 1.5.) Default unit is in kilobytes.</p>

<p style="margin-left:11%;"><b>&minus;&minus;discards</b>
{<i>ignore</i>|<i>nopassdown</i>|<i>passdown</i>}</p>

<p style="margin-left:22%;">Specifies whether or not
discards will be processed by the thin layer in the kernel
and passed down to the Physical Volume. Default is
<i>passdown</i>.</p>

<p style="margin-left:11%;"><b>&minus;Z</b>,
<b>&minus;&minus;zero</b> {<i>y</i>|<i>n</i>}</p>

<p style="margin-left:22%;">Controls zeroing of the first
4KiB of data in the snapshot. If the volume is read-only the
snapshot will not be zeroed. For thin pool volumes it
controls zeroing of provisioned blocks. Note: Provisioning
of large zeroed chunks impacts performance.</p>

<p style="margin-left:11%;"><b>&minus;&minus;merge</b></p>

<p style="margin-left:22%;">Merges a snapshot into its
origin volume or merges a raid1 image that has been split
from its mirror with <b>&minus;&minus;trackchanges</b> back
into its mirror.</p>

<p style="margin-left:22%; margin-top: 1em">To check if
your kernel supports the snapshot merge feature, look for
&rsquo;snapshot-merge&rsquo; in the output of <b>dmsetup
targets</b>. If both the origin and snapshot volume are not
open the merge will start immediately. Otherwise, the merge
will start the first time either the origin or snapshot are
activated and both are closed. Merging a snapshot into an
origin that cannot be closed, for example a root filesystem,
is deferred until the next time the origin volume is
activated. When merging starts, the resulting logical volume
will have the origin&rsquo;s name, minor number and UUID.
While the merge is in progress, reads or writes to the
origin appear as they were directed to the snapshot being
merged. When the merge finishes, the merged snapshot is
removed. Multiple snapshots may be specified on the
commandline or a @tag may be used to specify multiple
snapshots be merged to their respective origin.</p>


<p style="margin-left:11%;"><b>&minus;&minus;originname</b>
<i>NewExternalOriginVolumeName</i></p>

<p style="margin-left:22%;">The new name for original
logical volume, which becomes external origin volume. <br>
Without this option a default names of &quot;lvol#&quot;
will be generated where # is the LVM internal number of the
logical volume. This volume will be read-only and cannot be
further modified as long, as it is being used as external
origin.</p>


<p style="margin-left:11%;"><b>&minus;&minus;poolmetadata</b>
<i>ThinPoolMetadataLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p>

<p style="margin-left:22%;">Specifies thin pool metadata
logical volume. The size should be in between 2MiB and
16GiB. Thin pool is specified with the option
<b>&minus;&minus;thinpool</b>. When the specified thin pool
already exists, the thin pool&rsquo;s metadata volume will
be swapped with the given LV. Properties of the thin pool
like chunk size, discards or zero are preserved by default
in this case. It can be useful for thin pool metadata repair
or its offline resize, since the content of metadata becomes
accessible for thin provisioning tools <b>thin_dump</b>(8)
and <b>thin_restore</b>(8).</p>


<p style="margin-left:11%;"><b>&minus;&minus;poolmetadatasize</b>
<i>ThinPoolMetadataSize</i>[<i>bBsSkKmMgG</i>]</p>

<p style="margin-left:22%;">Sets the size of thin
pool&rsquo;s metadata logical volume, if the pool metadata
volume is undefined. Thin pool is specified with the option
<b>&minus;&minus;thinpool</b>. Supported value is in the
range between 2MiB and 16GiB. The default value is estimated
with this formula (Pool_LV_size / Pool_LV_chunk_size * 64b).
Default unit is megabytes.</p>

<p style="margin-left:11%;"><b>&minus;r</b>,
<b>&minus;&minus;readahead</b>
{<i>ReadAheadSectors</i>|<i>auto</i>|<i>none</i>}</p>

<p style="margin-left:22%;">Sets read ahead sector count of
thin pool metadata logical volume. The default value is
&quot;auto&quot; which allows the kernel to choose a
suitable value automatically. &quot;None&quot; is equivalent
to specifying zero.</p>


<p style="margin-left:11%;"><b>&minus;&minus;repair</b></p>

<p style="margin-left:22%;">Repair a mirror after suffering
a disk failure or try to fix thin pool metadata.</p>

<p style="margin-left:22%; margin-top: 1em">The mirror will
be brought back into a consistent state. By default, the
original number of mirrors will be restored if possible.
Specify <b>&minus;y</b> on the command line to skip the
prompts. Use <b>&minus;f</b> if you do not want any
replacement. Additionally, you may use
<b>&minus;&minus;use&minus;policies</b> to use the device
replacement policy specified in <b>lvm.conf</b>(5), viz.
activation/mirror_log_fault_policy or
activation/mirror_device_fault_policy.</p>

<p style="margin-left:22%; margin-top: 1em">Thin pool
repair automates the use of <b>thin_repair</b>(8) tool. Only
inactive thin pool volumes can be repaired. There is no
validation of metadata between kernel and lvm2. This
requires further manual work. After successfull repair the
old unmodified metadata are still available in
<b>&lt;pool&gt;_tmeta&lt;n&gt;</b> LV.</p>

<p style="margin-left:11%;"><b>&minus;&minus;replace</b>
<i>PhysicalVolume</i></p>

<p style="margin-left:22%;">Remove the specified device
(<i>PhysicalVolume</i>) and replace it with one that is
available in the volume group or from the specific list
provided. This option is only available to RAID segment
types (e.g. &quot;raid1&quot;, &quot;raid5&quot;, etc).</p>

<p style="margin-left:11%;"><b>&minus;&minus;stripes</b>
<i>Stripes</i></p>

<p style="margin-left:22%;">Gives the number of stripes.
This is equal to the number of physical volumes to scatter
the logical volume. This does not apply to existing
allocated space, only newly allocated space can be
striped.</p>

<p style="margin-left:11%;"><b>&minus;I</b>,
<b>&minus;&minus;stripesize</b> <i>StripeSize</i></p>

<p style="margin-left:22%;">Gives the number of kilobytes
for the granularity of the stripes. <br>
StripeSize must be 2^n (n = 2 to 9) for metadata in LVM1
format. For metadata in LVM2 format, the stripe size may be
a larger power of 2 but must not exceed the physical extent
size.</p>

<p style="margin-left:11%;"><b>&minus;T</b>,
<b>&minus;&minus;thin</b>
<i>ExternalOriginLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p>

<p style="margin-left:22%;">Converts the logical volume
into a thin logical volume of the thin pool specified with
<b>&minus;&minus;thinpool</b>. The original logical volume
<i>ExternalOriginLogicalVolume</i> is renamed into a new
read-only logical volume. The non-default name for this
volume use <b>&minus;&minus;originname</b>. The volume
cannot be further modified as long as it is used as an
external origin volume for unprovisioned areas of any thin
logical volume.</p>

<p style="margin-left:11%;"><b>&minus;&minus;thinpool</b>
<i>ThinPoolLogicalVolume</i>{<i>Name</i>|<i>Path</i>}</p>

<p style="margin-left:22%;">Changes logical volume into a
thin pool volume. The volume will store the pool&rsquo;s
data. Thin pool metadata logical volume can be specified
with the option <b>&minus;&minus;poolmetadata</b> or
allocated with <b>&minus;&minus;poolmetadatasize</b>.</p>

<h2>Examples
<a name="Examples"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Converts the
linear logical volume &quot;vg00/lvol1&quot; to a two-way
mirror logical volume:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;m1 vg00/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts the
linear logical volume &quot;vg00/lvol1&quot; to a two-way
RAID1 logical volume:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type raid1 &minus;m1 vg00/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts a
mirror with a disk log to a mirror with an in-memory
log:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;mirrorlog core vg00/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts a
mirror with an in-memory log to a mirror with a disk
log:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;mirrorlog disk vg00/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts a
mirror logical volume to a linear logical volume:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;m0 vg00/lvol1</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts a
mirror logical volume to a RAID1 logical volume with the
same number of images:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type raid1 vg00/mirror_lv</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts
logical volume &quot;vg00/lvol2&quot; to snapshot of
original volume &quot;vg00/lvol1&quot;:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;s vg00/lvol1 vg00/lvol2</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts linear
logical volume &quot;vg00/lvol1&quot; to a two-way mirror,
using physical extents /dev/sda:0-15 and /dev/sdb:0-15 for
allocation of new extents:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;m1 vg00/lvol1 /dev/sda:0-15 /dev/sdb:0-15</b></p>

<p style="margin-left:11%; margin-top: 1em">Converts mirror
logical volume &quot;vg00/lvmirror1&quot; to linear, freeing
physical extents from /dev/sda:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;m0 vg00/lvmirror1 /dev/sda</b></p>

<p style="margin-left:11%; margin-top: 1em">Merges
&quot;vg00/lvol1_snap&quot; into its origin:</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge vg00/lvol1_snap</b></p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;vg00/lvol1&quot;, &quot;vg00/lvol2&quot; and
&quot;vg00/lvol3&quot; are all tagged with
&quot;some_tag&quot; each snapshot logical volume will be
merged serially, e.g.: &quot;vg00/lvol1&quot;, then
&quot;vg00/lvol2&quot;, then &quot;vg00/lvol3&quot;. If
&minus;&minus;background were used it would start all
snapshot logical volume merges in parallel.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge @some_tag</b></p>

<p style="margin-left:11%; margin-top: 1em">Extracts one
image from the mirror, making it a new logical volume named
&quot;lv_split&quot;. The mirror the image is extracted from
is reduced accordingly. If it was a 2-way mirror (created
with &rsquo;-m 1&rsquo;), then the resulting original volume
will be linear.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors 1 &minus;&minus;name lv_split
vg00/lvmirror1</b></p>

<p style="margin-left:11%; margin-top: 1em">A mirrored
logical volume created with &minus;&minus;type raid1 can use
the &minus;&minus;trackchanges argument when splitting off
an image. Detach one image from the mirrored logical volume
lv_raid1 as a separate read-only device and track the
changes made to the mirror while it is detached. The
split-off device has a name of the form lv_raid1_rimage_N,
where N is a number, and it cannot be renamed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;splitmirrors 1 &minus;&minus;trackchanges
vg00/lv_raid1</b></p>

<p style="margin-left:11%; margin-top: 1em">Merge an image
that was detached temporarily from its mirror with the
&minus;&minus;trackchanges argument back into its original
mirror and bring its contents back up-to-date.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;merge vg00/lv_raid1_rimage_1</b></p>

<p style="margin-left:11%; margin-top: 1em">Replaces the
physical volume &quot;/dev/sdb1&quot; in the RAID1 logical
volume &quot;my_raid1&quot; with the specified physical
volume &quot;/dev/sdf1&quot;. Had the argument
&quot;/dev/sdf1&quot; been left out, lvconvert would attempt
to find a suitable device from those available in the volume
group.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;replace /dev/sdb1 vg00/my_raid1
/dev/sdf1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert the
logical volume &quot;vg00/lvpool&quot; into a thin pool with
chunk size 128KiB and convert &quot;vg00/lv1&quot; into a
thin volume using this pool. Original &quot;vg00/lv1&quot;
is used as an external read-only origin, where all writes to
such volume are stored in the &quot;vg00/lvpool&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;thinpool vg00/lvpool -c 128 -T lv1</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert the
logical volume &quot;vg00/origin&quot; into a thin volume
from the thin pool &quot;vg00/lvpool&quot;. This thin volume
will use &quot;vg00/origin&quot; as an external origin
volume for unprovisioned areas in this volume. For the
read-only external origin use the new name
&quot;vg00/external&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;thinpool vg00/lvpool &minus;&minus;originname
external -T vg00/origin</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an
existing logical volume to a cache pool LV using the given
cache metadata LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
--type cache-pool --poolmetadata vg00/lvx_meta vg00/lvx_data
<br>
lvrename vg00/lvx_data vg00/lvx_cachepool</b></p>

<p style="margin-left:11%; margin-top: 1em">Convert an
existing logical volume to a cache LV using the given cache
pool LV.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lvconvert
&minus;&minus;type cache &minus;&minus;cachepool
vg00/lvx_cachepool vg00/lvx</b></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>lvm</b>(8),
<b>lvm.conf</b>(5), <b>lvdisplay</b>(8), <b>lvextend</b>(8),
<b>lvreduce</b>(8), <b>lvremove</b>(8), <b>lvrename</b>(8),
<b>lvscan</b>(8), <b>vgcreate</b>(8), <b>thin_dump</b>(8),
<b>thin_repair</b>(8) <b>thin_restore</b>(8)</p>
<hr>
</body>
</html>
