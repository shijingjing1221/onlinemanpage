<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:33:47 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>URI::file</title>

</head>
<body>

<h1 align="center">URI::file</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MAPPING NOTES">MAPPING NOTES</a><br>
<a href="#CONFIGURATION VARIABLES">CONFIGURATION VARIABLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">URI::file
&minus; URI that maps to local file names</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> use URI::file;
 $u1 = URI&minus;&gt;new(&quot;file:/foo/bar&quot;);
 $u2 = URI&minus;&gt;new(&quot;foo/bar&quot;, &quot;file&quot;);
 $u3 = URI::file&minus;&gt;new($path);
 $u4 = URI::file&minus;&gt;new(&quot;c:\\windows\\&quot;, &quot;win32&quot;);
 $u1&minus;&gt;file;
 $u1&minus;&gt;file(&quot;mac&quot;);</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;URI::file&quot;</tt> class supports
<tt>&quot;URI&quot;</tt> objects belonging to the
<i>file</i> <small>URI</small> scheme. This scheme allows us
to map the conventional file names found on various computer
systems to the <small>URI</small> name space. An old
specification of the <i>file</i> <small>URI</small> scheme
is found in <small>RFC 1738.</small> Some older background
information is also in <small>RFC 1630.</small> There are no
newer specifications as far as I know.</p>

<p style="margin-left:11%; margin-top: 1em">If you simply
want to construct <i>file</i> <small>URI</small> objects
from <small>URI</small> strings, use the normal
<tt>&quot;URI&quot;</tt> constructor. If you want to
construct <i>file</i> <small>URI</small> objects from the
actual file names used by various systems, then use one of
the following <tt>&quot;URI::file&quot;</tt> constructors:
<br>
$u = URI::file&minus;&gt;new( $filename, [$os] )</p>

<p style="margin-left:17%;">Maps a file name to the
<i>file:</i> <small>URI</small> name space, creates a
<small>URI</small> object and returns it. The
<tt>$filename</tt> is interpreted as belonging to the
indicated operating system ($os), which defaults to the
value of the $^O variable. The <tt>$filename</tt> can be
either absolute or relative, and the corresponding type of
<small>URI</small> object for <tt>$os</tt> is returned.</p>

<p style="margin-left:11%;">$u =
URI::file&minus;&gt;new_abs( $filename, [$os] )</p>

<p style="margin-left:17%;">Same as
URI::file&minus;&gt;new, but makes sure that the
<small>URI</small> returned represents an absolute file
name. If the <tt>$filename</tt> argument is relative, then
the name is resolved relative to the current directory, i.e.
this constructor is really the same as:</p>

<pre style="margin-left:17%; margin-top: 1em">  URI::file&minus;&gt;new($filename)&minus;&gt;abs(URI::file&minus;&gt;cwd);</pre>


<p style="margin-left:11%;">$u =
URI::file&minus;&gt;cwd</p>

<p style="margin-left:17%;">Returns a <i>file</i>
<small>URI</small> that represents the current working
directory. See Cwd.</p>

<p style="margin-left:11%; margin-top: 1em">The following
methods are supported for <i>file</i> <small>URI</small> (in
addition to the common and generic methods described in
<small>URI</small> ): <br>
$u&minus;&gt;file( [$os] )</p>

<p style="margin-left:17%;">Returns a file name. It maps
from the <small>URI</small> name space to the file name
space of the indicated operating system.</p>

<p style="margin-left:17%; margin-top: 1em">It might return
<tt>&quot;undef&quot;</tt> if the name can not be
represented in the indicated file system.</p>

<p style="margin-left:11%;">$u&minus;&gt;dir( [$os] )</p>

<p style="margin-left:17%;">Some systems use a different
form for names of directories than for plain files. Use this
method if you know you want to use the name for a
directory.</p>

<p style="margin-left:11%; margin-top: 1em">The
<tt>&quot;URI::file&quot;</tt> module can be used to map
generic file names to names suitable for the current system.
As such, it can work as a nice replacement for the
<tt>&quot;File::Spec&quot;</tt> module. For instance, the
following code translates the UNIX-style file name
<i>Foo/Bar.pm</i> to a name suitable for the local
system:</p>

<pre style="margin-left:11%; margin-top: 1em">  $file = URI::file&minus;&gt;new(&quot;Foo/Bar.pm&quot;, &quot;unix&quot;)&minus;&gt;file;
  die &quot;Can't map filename Foo/Bar.pm for $^O&quot; unless defined $file;
  open(FILE, $file) || die &quot;Can't open '$file': $!&quot;;
  # do something with FILE</pre>


<h2>MAPPING NOTES
<a name="MAPPING NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most computer
systems today have hierarchically organized file systems.
Mapping the names used in these systems to the generic
<small>URI</small> syntax allows us to work with relative
file URIs that behave as they should when resolved using the
generic algorithm for URIs (specified in <small>RFC
2396</small> ). Mapping a file name to the generic
<small>URI</small> syntax involves mapping the path
separator character to &quot;/&quot; and encoding any
reserved characters that appear in the path segments of the
file name. If path segments consisting of the strings
&quot;.&quot; or &quot;..&quot; have a different meaning
than what is specified for generic URIs, then these must be
encoded as well.</p>

<p style="margin-left:11%; margin-top: 1em">If the file
system has device, volume or drive specifications as the
root of the name space, then it makes sense to map them to
the authority field of the generic <small>URI</small>
syntax. This makes sure that relative URIs can not be
resolved &quot;above&quot; them, i.e. generally how relative
file names work in those systems.</p>

<p style="margin-left:11%; margin-top: 1em">Another common
use of the authority field is to encode the host on which
this file name is valid. The host name &quot;localhost&quot;
is special and generally has the same meaning as a missing
or empty authority field. This use is in conflict with using
it as a device specification, but can often be resolved for
device specifications having characters not legal in plain
host names.</p>

<p style="margin-left:11%; margin-top: 1em">File name to
<small>URI</small> mapping in normally not one-to-one. There
are usually many URIs that map to any given file name. For
instance, an authority of &quot;localhost&quot; maps the
same as a <small>URI</small> with a missing or empty
authority.</p>

<p style="margin-left:11%; margin-top: 1em">Example 1: The
Mac classic (Mac <small>OS 9</small> and earlier) used
&quot;:&quot; as path separator, but not in the same way as
a generic <small>URI.</small> &quot;:foo&quot; was a
relative name. &quot;foo:bar&quot; was an absolute name.
Also, path segments could contain the &quot;/&quot;
character as well as the literal &quot;.&quot; or
&quot;..&quot;. So the mapping looks like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  Mac classic           URI
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;            &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  :foo:bar     &lt;==&gt;     foo/bar
  :            &lt;==&gt;     ./
  ::foo:bar    &lt;==&gt;     ../foo/bar
  :::          &lt;==&gt;     ../../
  foo:bar      &lt;==&gt;     file:/foo/bar
  foo:bar:     &lt;==&gt;     file:/foo/bar/
  ..           &lt;==&gt;     %2E%2E
  &lt;undef&gt;      &lt;==      /
  foo/         &lt;==      file:/foo%2F
  ./foo.txt    &lt;==      file:/.%2Ffoo.txt</pre>


<p style="margin-left:11%; margin-top: 1em">Note that if
you want a relative <small>URL,</small> you *must* begin the
path with a :. Any path that begins with [^:] is treated as
absolute.</p>

<p style="margin-left:11%; margin-top: 1em">Example 2: The
<small>UNIX</small> file system is easy to map, as it uses
the same path separator as URIs, has a single root, and
segments of &quot;.&quot; and &quot;..&quot; have the same
meaning. URIs that have the character &quot;\0&quot; or
&quot;/&quot; as part of any path segment can not be turned
into valid <small>UNIX</small> file names.</p>

<pre style="margin-left:11%; margin-top: 1em">  UNIX                  URI
  &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;            &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
  foo/bar      &lt;==&gt;     foo/bar
  /foo/bar     &lt;==&gt;     file:/foo/bar
  /foo/bar     &lt;==      file://localhost/foo/bar
  file:         ==&gt;     ./file:
  &lt;undef&gt;      &lt;==      file:/fo%00/bar
  /            &lt;==&gt;     file:/</pre>


<h2>CONFIGURATION VARIABLES
<a name="CONFIGURATION VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
configuration variables influence how the class and its
methods behave: <br>
%URI::file::OS_CLASS</p>

<p style="margin-left:17%;">This hash maps
<small>OS</small> identifiers to implementation classes. You
might want to add or modify this if you want to plug in your
own file handler class. Normally the keys should match the
$^O values in use.</p>

<p style="margin-left:17%; margin-top: 1em">If there is no
mapping then the &quot;Unix&quot; implementation is
used.</p>


<p style="margin-left:11%;">$URI::file::DEFAULT_AUTHORITY</p>

<p style="margin-left:17%;">This determine what
&quot;authority&quot; string to include in absolute file
URIs. It defaults to &quot;&quot;. If you prefer verbose
URIs you might set it to be &quot;localhost&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Setting this
value to <tt>&quot;undef&quot;</tt> force behaviour
compatible to <small>URI</small> v1.31 and earlier. In this
mode host names in <small>UNC</small> paths and drive
letters are mapped to the authority component on Windows,
while we produce authority-less URIs on Unix.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>URI</small>
, File::Spec, perlport</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
1995&minus;1998,2004 Gisle Aas.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
