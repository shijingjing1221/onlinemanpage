<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:06:21 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MDADM</title>

</head>
<body>

<h1 align="center">MDADM</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MODES">MODES</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#Options for selecting a mode are:">Options for selecting a mode are:</a><br>
<a href="#Options that are not mode-specific are:">Options that are not mode-specific are:</a><br>
<a href="#For create, build, or grow:">For create, build, or grow:</a><br>
<a href="#For assemble:">For assemble:</a><br>
<a href="#For Manage mode:">For Manage mode:</a><br>
<a href="#For Misc mode:">For Misc mode:</a><br>
<a href="#For Incremental Assembly mode:">For Incremental Assembly mode:</a><br>
<a href="#For Monitor mode:">For Monitor mode:</a><br>
<a href="#ASSEMBLE MODE">ASSEMBLE MODE</a><br>
<a href="#BUILD MODE">BUILD MODE</a><br>
<a href="#CREATE MODE">CREATE MODE</a><br>
<a href="#MANAGE MODE">MANAGE MODE</a><br>
<a href="#MISC MODE">MISC MODE</a><br>
<a href="#MONITOR MODE">MONITOR MODE</a><br>
<a href="#GROW MODE">GROW MODE</a><br>
<a href="#INCREMENTAL MODE">INCREMENTAL MODE</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#FILES">FILES</a><br>
<a href="#DEVICE NAMES">DEVICE NAMES</a><br>
<a href="#NOTE">NOTE</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">mdadm &minus;
manage MD devices <i>aka</i> Linux Software RAID</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>mdadm</b>
<i>[mode] &lt;raiddevice&gt; [options]
&lt;component-devices&gt;</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">RAID devices
are virtual devices created from two or more real block
devices. This allows multiple devices (typically disk drives
or partitions thereof) to be combined into a single device
to hold (for example) a single filesystem. Some RAID levels
include redundancy and so can survive some degree of device
failure.</p>

<p style="margin-left:11%; margin-top: 1em">Linux Software
RAID devices are implemented through the md (Multiple
Devices) device driver.</p>

<p style="margin-left:11%; margin-top: 1em">Currently,
Linux supports <b>LINEAR</b> md devices, <b>RAID0</b>
(striping), <b>RAID1</b> (mirroring), <b>RAID4</b>,
<b>RAID5</b>, <b>RAID6</b>, <b>RAID10</b>, <b>MULTIPATH</b>,
<b>FAULTY</b>, and <b>CONTAINER</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>MULTIPATH</b>
is not a Software RAID mechanism, but does involve multiple
devices: each device is a path to one common physical
storage device. New installations should not use
md/multipath as it is not well supported and has no ongoing
development. Use the Device Mapper based multipath-tools
instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FAULTY</b>
is also not true RAID, and it only involves one device. It
provides a layer over a true device that can be used to
inject faults.</p>


<p style="margin-left:11%; margin-top: 1em"><b>CONTAINER</b>
is different again. A <b>CONTAINER</b> is a collection of
devices that are managed as a set. This is similar to the
set of devices connected to a hardware RAID controller. The
set of devices may contain a number of different RAID arrays
each utilising some (or all) of the blocks from a number of
the devices in the set. For example, two devices in a
5-device set might form a RAID1 using the whole devices. The
remaining three might have a RAID5 over the first half of
each device, and a RAID0 over the second half.</p>

<p style="margin-left:11%; margin-top: 1em">With a
<b>CONTAINER</b>, there is one set of metadata that
describes all of the arrays in the container. So when
<i>mdadm</i> creates a <b>CONTAINER</b> device, the device
just represents the metadata. Other normal arrays (RAID1
etc) can be created inside the container.</p>

<h2>MODES
<a name="MODES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">mdadm has
several major modes of operation: <b><br>
Assemble</b></p>

<p style="margin-left:22%;">Assemble the components of a
previously created array into an active array. Components
can be explicitly given or can be searched for. <i>mdadm</i>
checks that the components do form a bona fide array, and
can, on request, fiddle superblock information so as to
assemble a faulty array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Build</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Build an array that doesn&rsquo;t have per-device
metadata (superblocks). For these sorts of arrays,
<i>mdadm</i> cannot differentiate between initial creation
and subsequent assembly of an array. It also cannot perform
any checks that appropriate components have been requested.
Because of this, the <b>Build</b> mode should only be used
together with a complete understanding of what you are
doing.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Create</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Create a new array with per-device metadata
(superblocks). Appropriate metadata is written to each
device, and then the array comprising those devices is
activated. A &rsquo;resync&rsquo; process is started to make
sure that the array is consistent (e.g. both sides of a
mirror contain the same data) but the content of the device
is left otherwise untouched. The array can be used as soon
as it has been created. There is no need to wait for the
initial resync to finish.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>Follow or Monitor</b></p>

<p style="margin-left:22%;">Monitor one or more md devices
and act on any state changes. This is only meaningful for
RAID1, 4, 5, 6, 10 or multipath arrays, as only these have
interesting state. RAID0 or Linear never have missing,
spare, or failed drives, so there is nothing to monitor.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>Grow</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Grow (or shrink) an array, or otherwise reshape it in
some way. Currently supported growth options including
changing the active size of component devices and changing
the number of active devices in Linear and RAID levels
0/1/4/5/6, changing the RAID level between 0, 1, 5, and 6,
and between 0 and 10, changing the chunk size and layout for
RAID 0,4,5,6, as well as adding or removing a write-intent
bitmap.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>Incremental Assembly</b></p>

<p style="margin-left:22%;">Add a single device to an
appropriate array. If the addition of the device makes the
array runnable, the array will be started. This provides a
convenient interface to a <i>hot-plug</i> system. As each
device is detected, <i>mdadm</i> has a chance to include it
in some array as appropriate. Optionally, when the
<i>&minus;&minus;fail</i> flag is passed in we will remove
the device from any active array instead of adding it.</p>

<p style="margin-left:22%; margin-top: 1em">If a
<b>CONTAINER</b> is passed to <i>mdadm</i> in this mode,
then any arrays within that container will be assembled and
started.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Manage</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This is for doing things to specific components of an
array such as adding new spares and removing faulty
devices.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Misc</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This is an &rsquo;everything else&rsquo; mode that
supports operations on active arrays, operations on
component devices such as erasing old superblocks, and
information gathering operations.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>Auto-detect</b></p>

<p style="margin-left:22%;">This mode does not act on a
specific device or array, but rather it requests the Linux
Kernel to activate any auto-detected arrays.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<h2>Options for selecting a mode are:
<a name="Options for selecting a mode are:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;A</b>,
<b>&minus;&minus;assemble</b></p>

<p style="margin-left:22%;">Assemble a pre-existing
array.</p>

<p style="margin-left:11%;"><b>&minus;B</b>,
<b>&minus;&minus;build</b></p>

<p style="margin-left:22%;">Build a legacy array without
superblocks.</p>

<p style="margin-left:11%;"><b>&minus;C</b>,
<b>&minus;&minus;create</b></p>

<p style="margin-left:22%;">Create a new array.</p>

<p style="margin-left:11%;"><b>&minus;F</b>,
<b>&minus;&minus;follow</b>,
<b>&minus;&minus;monitor</b></p>

<p style="margin-left:22%;">Select <b>Monitor</b> mode.</p>

<p style="margin-left:11%;"><b>&minus;G</b>,
<b>&minus;&minus;grow</b></p>

<p style="margin-left:22%;">Change the size or shape of an
active array.</p>

<p style="margin-left:11%;"><b>&minus;I</b>,
<b>&minus;&minus;incremental</b></p>

<p style="margin-left:22%;">Add/remove a single device
to/from an appropriate array, and possibly start the
array.</p>


<p style="margin-left:11%;"><b>&minus;&minus;auto-detect</b></p>

<p style="margin-left:22%;">Request that the kernel starts
any auto-detected arrays. This can only work if <i>md</i> is
compiled into the kernel &mdash; not if it is a module.
Arrays can be auto-detected by the kernel if all the
components are in primary MS-DOS partitions with partition
type <b>FD</b>, and all use v0.90 metadata. In-kernel
autodetect is not recommended for new installations. Using
<i>mdadm</i> to detect and assemble arrays &mdash; possibly
in an <i>initrd</i> &mdash; is substantially more flexible
and should be preferred.</p>

<p style="margin-left:11%; margin-top: 1em">If a device is
given before any options, or if the first option is
<b>&minus;&minus;add</b>, <b>&minus;&minus;fail</b>, or
<b>&minus;&minus;remove</b>, then the MANAGE mode is
assumed. Anything other than these will cause the
<b>Misc</b> mode to be assumed.</p>

<h2>Options that are not mode-specific are:
<a name="Options that are not mode-specific are:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:22%;">Display general help message
or, after one of the above options, a mode-specific help
message.</p>


<p style="margin-left:11%;"><b>&minus;&minus;help&minus;options</b></p>

<p style="margin-left:22%;">Display more detailed help
about command line parsing and some commonly used
options.</p>

<p style="margin-left:11%;"><b>&minus;V</b>,
<b>&minus;&minus;version</b></p>

<p style="margin-left:22%;">Print version information for
mdadm.</p>

<p style="margin-left:11%;"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:22%;">Be more verbose about what is
happening. This can be used twice to be extra-verbose. The
extra verbosity currently only affects
<b>&minus;&minus;detail &minus;&minus;scan</b> and
<b>&minus;&minus;examine &minus;&minus;scan</b>.</p>

<p style="margin-left:11%;"><b>&minus;q</b>,
<b>&minus;&minus;quiet</b></p>

<p style="margin-left:22%;">Avoid printing purely
informative messages. With this, <i>mdadm</i> will be silent
unless there is something really important to report.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;force</b></p>

<p style="margin-left:22%;">Be more forceful about certain
operations. See the various modes for the exact meaning of
this option in different contexts.</p>

<p style="margin-left:11%;"><b>&minus;c</b>,
<b>&minus;&minus;config=</b></p>

<p style="margin-left:22%;">Specify the config file.
Default is to use <b>/etc/mdadm.conf</b>, or if that is
missing then <b>/etc/mdadm/mdadm.conf</b>. If the config
file given is <b>partitions</b> then nothing will be read,
but <i>mdadm</i> will act as though the config file
contained exactly <b>DEVICE partitions containers</b> and
will read <b>/proc/partitions</b> to find a list of devices
to scan, and <b>/proc/mdstat</b> to find a list of
containers to examine. If the word <b>none</b> is given for
the config file, then <i>mdadm</i> will act as though the
config file were empty.</p>

<p style="margin-left:11%;"><b>&minus;s</b>,
<b>&minus;&minus;scan</b></p>

<p style="margin-left:22%;">Scan config file or
<b>/proc/mdstat</b> for missing information. In general,
this option gives <i>mdadm</i> permission to get any missing
information (like component devices, array devices, array
identities, and alert destination) from the configuration
file (see previous option); one exception is MISC mode when
using <b>&minus;&minus;detail</b> or
<b>&minus;&minus;stop,</b> in which case
<b>&minus;&minus;scan</b> says to get a list of array
devices from <b>/proc/mdstat</b>.</p>

<p style="margin-left:11%;"><b>&minus;e</b>,
<b>&minus;&minus;metadata=</b></p>

<p style="margin-left:22%;">Declare the style of RAID
metadata (superblock) to be used. The default is 1.2 for
<b>&minus;&minus;create</b>, and to guess for other
operations. The default can be overridden by setting the
<b>metadata</b> value for the <b>CREATE</b> keyword in
<b>mdadm.conf</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Options are:
<br>
0, 0.90</p>

<p style="margin-left:32%;">Use the original 0.90 format
superblock. This format limits arrays to 28 component
devices and limits component devices of levels 1 and greater
to 2 terabytes. It is also possible for there to be
confusion about whether the superblock applies to a whole
device or just the last partition, if that partition starts
on a 64K boundary.</p>

<p style="margin-left:22%;">1, 1.0, 1.1, 1.2 default</p>

<p style="margin-left:32%;">Use the new version-1 format
superblock. This has fewer restrictions. It can easily be
moved between hosts with different endian-ness, and a
recovery operation can be checkpointed and restarted. The
different sub-versions store the superblock at different
locations on the device, either at the end (for 1.0), at the
start (for 1.1) or 4K from the start (for 1.2).
&quot;1&quot; is equivalent to &quot;1.2&quot; (the commonly
preferred 1.x format). &quot;default&quot; is equivalent to
&quot;1.2&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p>ddf</p></td>
<td width="4%"></td>
<td width="68%">


<p>Use the &quot;Industry Standard&quot; DDF (Disk Data
Format) format defined by SNIA. When creating a DDF array a
<b>CONTAINER</b> will be created, and normal arrays can be
created in that container.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p>imsm</p></td>
<td width="4%"></td>
<td width="68%">


<p>Use the Intel(R) Matrix Storage Manager metadata format.
This creates a <b>CONTAINER</b> which is managed in a
similar manner to DDF, and is supported by an option-rom on
some platforms:</p></td></tr>
</table>


<p style="margin-left:32%; margin-top: 1em"><b>http://www.intel.com/design/chipsets/matrixstorage_sb.htm</b></p>


<p style="margin-left:11%;"><b>&minus;&minus;homehost=</b></p>

<p style="margin-left:22%;">This will override any
<b>HOMEHOST</b> setting in the config file and provides the
identity of the host which should be considered the home for
any arrays.</p>

<p style="margin-left:22%; margin-top: 1em">When creating
an array, the <b>homehost</b> will be recorded in the
metadata. For version-1 superblocks, it will be prefixed to
the array name. For version-0.90 superblocks, part of the
SHA1 hash of the hostname will be stored in the later half
of the UUID.</p>

<p style="margin-left:22%; margin-top: 1em">When reporting
information about an array, any array which is tagged for
the given homehost will be reported as such.</p>

<p style="margin-left:22%; margin-top: 1em">When using
Auto-Assemble, only arrays tagged for the given homehost
will be allowed to use &rsquo;local&rsquo; names (i.e. not
ending in &rsquo;_&rsquo; followed by a digit string). See
below under <b>Auto Assembly</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;prefer=</b></p>

<p style="margin-left:22%;">When <i>mdadm</i> needs to
print the name for a device it normally finds the name in
<b>/dev</b> which refers to the device and is shortest. When
a path component is given with <b>&minus;&minus;prefer</b>
<i>mdadm</i> will prefer a longer name if it contains that
component. For example <b>&minus;&minus;prefer=by-uuid</b>
will prefer a name in a subdirectory of <b>/dev</b> called
<b>by-uuid</b>.</p>

<p style="margin-left:22%; margin-top: 1em">This
functionality is currently only provided by
<b>&minus;&minus;detail</b> and
<b>&minus;&minus;monitor</b>.</p>

<h2>For create, build, or grow:
<a name="For create, build, or grow:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;n</b>,
<b>&minus;&minus;raid&minus;devices=</b></p>

<p style="margin-left:22%;">Specify the number of active
devices in the array. This, plus the number of spare devices
(see below) must equal the number of
<i>component-devices</i> (including
&quot;<b>missing</b>&quot; devices) that are listed on the
command line for <b>&minus;&minus;create</b>. Setting a
value of 1 is probably a mistake and so requires that
<b>&minus;&minus;force</b> be specified first. A value of 1
will then be allowed for linear, multipath, RAID0 and RAID1.
It is never allowed for RAID4, RAID5 or RAID6. <br>
This number can only be changed using
<b>&minus;&minus;grow</b> for RAID1, RAID4, RAID5 and RAID6
arrays, and only on kernels which provide the necessary
support.</p>

<p style="margin-left:11%;"><b>&minus;x</b>,
<b>&minus;&minus;spare&minus;devices=</b></p>

<p style="margin-left:22%;">Specify the number of spare
(eXtra) devices in the initial array. Spares can also be
added and removed later. The number of component devices
listed on the command line must equal the number of RAID
devices plus the number of spare devices.</p>

<p style="margin-left:11%;"><b>&minus;z</b>,
<b>&minus;&minus;size=</b></p>

<p style="margin-left:22%;">Amount (in Kibibytes) of space
to use from each drive in RAID levels 1/4/5/6. This must be
a multiple of the chunk size, and must leave about 128Kb of
space at the end of the drive for the RAID superblock. If
this is not specified (as it normally is not) the smallest
drive (or partition) sets the size, though if there is a
variance among the drives of greater than 1%, a warning is
issued.</p>

<p style="margin-left:22%; margin-top: 1em">A suffix of
&rsquo;M&rsquo; or &rsquo;G&rsquo; can be given to indicate
Megabytes or Gigabytes respectively.</p>

<p style="margin-left:22%; margin-top: 1em">Sometimes a
replacement drive can be a little smaller than the original
drives though this should be minimised by IDEMA standards.
Such a replacement drive will be rejected by <i>md</i>. To
guard against this it can be useful to set the initial size
slightly smaller than the smaller device with the aim that
it will still be larger than any replacement.</p>

<p style="margin-left:22%; margin-top: 1em">This value can
be set with <b>&minus;&minus;grow</b> for RAID level 1/4/5/6
though <b>CONTAINER</b> based arrays such as those with IMSM
metadata may not be able to support this. If the array was
created with a size smaller than the currently active
drives, the extra space can be accessed using
<b>&minus;&minus;grow</b>. The size can be given as
<b>max</b> which means to choose the largest size that fits
on all current drives.</p>

<p style="margin-left:22%; margin-top: 1em">Before reducing
the size of the array (with <b>&minus;&minus;grow
&minus;&minus;size=</b>) you should make sure that space
isn&rsquo;t needed. If the device holds a filesystem, you
would need to resize the filesystem to use less space.</p>

<p style="margin-left:22%; margin-top: 1em">After reducing
the array size you should check that the data stored in the
device is still available. If the device holds a filesystem,
then an &rsquo;fsck&rsquo; of the filesystem is a minimum
requirement. If there are problems the array can be made
bigger again with no loss with another <b>&minus;&minus;grow
&minus;&minus;size=</b> command.</p>

<p style="margin-left:22%; margin-top: 1em">This value
cannot be used when creating a <b>CONTAINER</b> such as with
DDF and IMSM metadata, though it perfectly valid when
creating an array inside a container.</p>

<p style="margin-left:11%;"><b>&minus;Z</b>,
<b>&minus;&minus;array&minus;size=</b></p>

<p style="margin-left:22%;">This is only meaningful with
<b>&minus;&minus;grow</b> and its effect is not persistent:
when the array is stopped and restarted the default array
size will be restored.</p>

<p style="margin-left:22%; margin-top: 1em">Setting the
array-size causes the array to appear smaller to programs
that access the data. This is particularly needed before
reshaping an array so that it will be smaller. As the
reshape is not reversible, but setting the size with
<b>&minus;&minus;array-size</b> is, it is required that the
array size is reduced as appropriate before the number of
devices in the array is reduced.</p>

<p style="margin-left:22%; margin-top: 1em">Before reducing
the size of the array you should make sure that space
isn&rsquo;t needed. If the device holds a filesystem, you
would need to resize the filesystem to use less space.</p>

<p style="margin-left:22%; margin-top: 1em">After reducing
the array size you should check that the data stored in the
device is still available. If the device holds a filesystem,
then an &rsquo;fsck&rsquo; of the filesystem is a minimum
requirement. If there are problems the array can be made
bigger again with no loss with another <b>&minus;&minus;grow
&minus;&minus;array&minus;size=</b> command.</p>

<p style="margin-left:22%; margin-top: 1em">A suffix of
&rsquo;M&rsquo; or &rsquo;G&rsquo; can be given to indicate
Megabytes or Gigabytes respectively. A value of <b>max</b>
restores the apparent size of the array to be whatever the
real amount of available space is.</p>

<p style="margin-left:11%;"><b>&minus;c</b>,
<b>&minus;&minus;chunk=</b></p>

<p style="margin-left:22%;">Specify chunk size of
kibibytes. The default when creating an array is 512KB. To
ensure compatibility with earlier versions, the default when
Building and array with no persistent metadata is 64KB. This
is only meaningful for RAID0, RAID4, RAID5, RAID6, and
RAID10.</p>

<p style="margin-left:22%; margin-top: 1em">RAID4, RAID5,
RAID6, and RAID10 require the chunk size to be a power of 2.
In any case it must be a multiple of 4KB.</p>

<p style="margin-left:22%; margin-top: 1em">A suffix of
&rsquo;M&rsquo; or &rsquo;G&rsquo; can be given to indicate
Megabytes or Gigabytes respectively.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rounding=</b></p>

<p style="margin-left:22%;">Specify rounding factor for a
Linear array. The size of each component will be rounded
down to a multiple of this size. This is a synonym for
<b>&minus;&minus;chunk</b> but highlights the different
meaning for Linear as compared to other RAID levels. The
default is 64K if a kernel earlier than 2.6.16 is in use,
and is 0K (i.e. no rounding) in later kernels.</p>

<p style="margin-left:11%;"><b>&minus;l</b>,
<b>&minus;&minus;level=</b></p>

<p style="margin-left:22%;">Set RAID level. When used with
<b>&minus;&minus;create</b>, options are: linear, raid0, 0,
stripe, raid1, 1, mirror, raid4, 4, raid5, 5, raid6, 6,
raid10, 10, multipath, mp, faulty, container. Obviously some
of these are synonymous.</p>

<p style="margin-left:22%; margin-top: 1em">When a
<b>CONTAINER</b> metadata type is requested, only the
<b>container</b> level is permitted, and it does not need to
be explicitly given.</p>

<p style="margin-left:22%; margin-top: 1em">When used with
<b>&minus;&minus;build</b>, only linear, stripe, raid0, 0,
raid1, multipath, mp, and faulty are valid.</p>

<p style="margin-left:22%; margin-top: 1em">Can be used
with <b>&minus;&minus;grow</b> to change the RAID level in
some cases. See LEVEL CHANGES below.</p>

<p style="margin-left:11%;"><b>&minus;p</b>,
<b>&minus;&minus;layout=</b></p>

<p style="margin-left:22%;">This option configures the fine
details of data layout for RAID5, RAID6, and RAID10 arrays,
and controls the failure modes for <i>faulty</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The layout of
the RAID5 parity block can be one of
<b>left&minus;asymmetric</b>, <b>left&minus;symmetric</b>,
<b>right&minus;asymmetric</b>, <b>right&minus;symmetric</b>,
<b>la</b>, <b>ra</b>, <b>ls</b>, <b>rs</b>. The default is
<b>left&minus;symmetric</b>.</p>

<p style="margin-left:22%; margin-top: 1em">It is also
possible to cause RAID5 to use a RAID4-like layout by
choosing <b>parity&minus;first</b>, or
<b>parity&minus;last</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Finally for
RAID5 there are DDF&minus;compatible layouts,
<b>ddf&minus;zero&minus;restart</b>,
<b>ddf&minus;N&minus;restart</b>, and
<b>ddf&minus;N&minus;continue</b>.</p>

<p style="margin-left:22%; margin-top: 1em">These same
layouts are available for RAID6. There are also 4 layouts
that will provide an intermediate stage for converting
between RAID5 and RAID6. These provide a layout which is
identical to the corresponding RAID5 layout on the first
N&minus;1 devices, and has the &rsquo;Q&rsquo; syndrome (the
second &rsquo;parity&rsquo; block used by RAID6) on the last
device. These layouts are:
<b>left&minus;symmetric&minus;6</b>,
<b>right&minus;symmetric&minus;6</b>,
<b>left&minus;asymmetric&minus;6</b>,
<b>right&minus;asymmetric&minus;6</b>, and
<b>parity&minus;first&minus;6</b>.</p>

<p style="margin-left:22%; margin-top: 1em">When setting
the failure mode for level <i>faulty,</i> the options are:
<b>write&minus;transient</b>, <b>wt</b>,
<b>read&minus;transient</b>, <b>rt</b>,
<b>write&minus;persistent</b>, <b>wp</b>,
<b>read&minus;persistent</b>, <b>rp</b>,
<b>write&minus;all</b>, <b>read&minus;fixable</b>,
<b>rf</b>, <b>clear</b>, <b>flush</b>, <b>none</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Each failure
mode can be followed by a number, which is used as a period
between fault generation. Without a number, the fault is
generated once on the first relevant request. With a number,
the fault will be generated after that many requests, and
will continue to be generated every time the period
elapses.</p>

<p style="margin-left:22%; margin-top: 1em">Multiple
failure modes can be current simultaneously by using the
<b>&minus;&minus;grow</b> option to set subsequent failure
modes.</p>


<p style="margin-left:22%; margin-top: 1em">&quot;clear&quot;
or &quot;none&quot; will remove any pending or periodic
failure modes, and &quot;flush&quot; will clear any
persistent faults.</p>

<p style="margin-left:22%; margin-top: 1em">Finally, the
layout options for RAID10 are one of &rsquo;n&rsquo;,
&rsquo;o&rsquo; or &rsquo;f&rsquo; followed by a small
number. The default is &rsquo;n2&rsquo;. The supported
options are:</p>


<p style="margin-left:22%; margin-top: 1em"><i>&rsquo;n&rsquo;</i>
signals &rsquo;near&rsquo; copies. Multiple copies of one
data block are at similar offsets in different devices.</p>


<p style="margin-left:22%; margin-top: 1em"><i>&rsquo;o&rsquo;</i>
signals &rsquo;offset&rsquo; copies. Rather than the chunks
being duplicated within a stripe, whole stripes are
duplicated but are rotated by one device so duplicate blocks
are on different devices. Thus subsequent copies of a block
are in the next drive, and are one chunk further down.</p>


<p style="margin-left:22%; margin-top: 1em"><i>&rsquo;f&rsquo;</i>
signals &rsquo;far&rsquo; copies (multiple copies have very
different offsets). See md(4) for more detail about
&rsquo;near&rsquo;, &rsquo;offset&rsquo;, and
&rsquo;far&rsquo;.</p>

<p style="margin-left:22%; margin-top: 1em">The number is
the number of copies of each datablock. 2 is normal, 3 can
be useful. This number can be at most equal to the number of
devices in the array. It does not need to divide evenly into
that number (e.g. it is perfectly legal to have an
&rsquo;n2&rsquo; layout for an array with an odd number of
devices).</p>

<p style="margin-left:22%; margin-top: 1em">When an array
is converted between RAID5 and RAID6 an intermediate RAID6
layout is used in which the second parity block (Q) is
always on the last device. To convert a RAID5 to RAID6 and
leave it in this new layout (which does not require
re-striping) use <b>&minus;&minus;layout=preserve</b>. This
will try to avoid any restriping.</p>

<p style="margin-left:22%; margin-top: 1em">The converse of
this is <b>&minus;&minus;layout=normalise</b> which will
change a non-standard RAID6 layout into a more standard
arrangement.</p>


<p style="margin-left:11%;"><b>&minus;&minus;parity=</b></p>

<p style="margin-left:22%;">same as
<b>&minus;&minus;layout</b> (thus explaining the p of
<b>&minus;p</b>).</p>

<p style="margin-left:11%;"><b>&minus;b</b>,
<b>&minus;&minus;bitmap=</b></p>

<p style="margin-left:22%;">Specify a file to store a
write-intent bitmap in. The file should not exist unless
<b>&minus;&minus;force</b> is also given. The same file
should be provided when assembling the array. If the word
<b>internal</b> is given, then the bitmap is stored with the
metadata on the array, and so is replicated on all devices.
If the word <b>none</b> is given with
<b>&minus;&minus;grow</b> mode, then any bitmap that is
present is removed.</p>

<p style="margin-left:22%; margin-top: 1em">To help catch
typing errors, the filename must contain at least one slash
(&rsquo;/&rsquo;) if it is a real file (not
&rsquo;internal&rsquo; or &rsquo;none&rsquo;).</p>

<p style="margin-left:22%; margin-top: 1em">Note: external
bitmaps are only known to work on ext2 and ext3. Storing
bitmap files on other filesystems may result in serious
problems.</p>


<p style="margin-left:11%;"><b>&minus;&minus;bitmap&minus;chunk=</b></p>

<p style="margin-left:22%;">Set the chunksize of the
bitmap. Each bit corresponds to that many Kilobytes of
storage. When using a file based bitmap, the default is to
use the smallest size that is at-least 4 and requires no
more than 2^21 chunks. When using an <b>internal</b> bitmap,
the chunksize defaults to 64Meg, or larger if necessary to
fit the bitmap into the available space.</p>

<p style="margin-left:22%; margin-top: 1em">A suffix of
&rsquo;M&rsquo; or &rsquo;G&rsquo; can be given to indicate
Megabytes or Gigabytes respectively.</p>

<p style="margin-left:11%;"><b>&minus;W</b>,
<b>&minus;&minus;write&minus;mostly</b></p>

<p style="margin-left:22%;">subsequent devices listed in a
<b>&minus;&minus;build</b>, <b>&minus;&minus;create</b>, or
<b>&minus;&minus;add</b> command will be flagged as
&rsquo;write-mostly&rsquo;. This is valid for RAID1 only and
means that the &rsquo;md&rsquo; driver will avoid reading
from these devices if at all possible. This can be useful if
mirroring over a slow link.</p>


<p style="margin-left:11%;"><b>&minus;&minus;write&minus;behind=</b></p>

<p style="margin-left:22%;">Specify that write-behind mode
should be enabled (valid for RAID1 only). If an argument is
specified, it will set the maximum number of outstanding
writes allowed. The default value is 256. A write-intent
bitmap is required in order to use write-behind mode, and
write-behind is only attempted on drives marked as
<i>write-mostly</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;assume&minus;clean</b></p>

<p style="margin-left:22%;">Tell <i>mdadm</i> that the
array pre-existed and is known to be clean. It can be useful
when trying to recover from a major failure as you can be
sure that no data will be affected unless you actually write
to the array. It can also be used when creating a RAID1 or
RAID10 if you want to avoid the initial resync, however this
practice &mdash; while normally safe &mdash; is not
recommended. Use this only if you really know what you are
doing.</p>

<p style="margin-left:22%; margin-top: 1em">When the
devices that will be part of a new array were filled with
zeros before creation the operator knows the array is
actually clean. If that is the case, such as after running
badblocks, this argument can be used to tell mdadm the facts
the operator knows.</p>

<p style="margin-left:22%; margin-top: 1em">When an array
is resized to a larger size with <b>&minus;&minus;grow
&minus;&minus;size=</b> the new space is normally resynced
in that same way that the whole array is resynced at
creation. From Linux version 3.0,
<b>&minus;&minus;assume&minus;clean</b> can be used with
that command to avoid the automatic resync.</p>


<p style="margin-left:11%;"><b>&minus;&minus;backup&minus;file=</b></p>

<p style="margin-left:22%;">This is needed when
<b>&minus;&minus;grow</b> is used to increase the number of
raid-devices in a RAID5 or RAID6 if there are no spare
devices available, or to shrink, change RAID level or
layout. See the GROW MODE section below on
RAID&minus;DEVICES CHANGES. The file must be stored on a
separate device, not on the RAID array being reshaped.</p>


<p style="margin-left:11%;"><b>&minus;&minus;continue</b></p>

<p style="margin-left:22%;">This option is complementary to
the <b>&minus;&minus;freeze-reshape</b> option for assembly.
It is needed when <b>&minus;&minus;grow</b> operation is
interrupted and it is not restarted automatically due to
<b>&minus;&minus;freeze-reshape</b> usage during array
assembly. This option is used together with <b>&minus;G</b>
, ( <b>&minus;&minus;grow</b> ) command and device for a
pending reshape to be continued. All parameters required for
reshape continuation will be read from array metadata. If
initial <b>&minus;&minus;grow</b> command had required
<b>&minus;&minus;backup&minus;file=</b> option to be set,
continuation option will require to have exactly the same
backup file given as well.</p>

<p style="margin-left:22%; margin-top: 1em">Any other
parameter passed together with <b>&minus;&minus;continue</b>
option will be ignored.</p>

<p style="margin-left:11%;"><b>&minus;N</b>,
<b>&minus;&minus;name=</b></p>

<p style="margin-left:22%;">Set a <b>name</b> for the
array. This is currently only effective when creating an
array with a version-1 superblock, or an array in a DDF
container. The name is a simple textual string that can be
used to identify array components when assembling. If name
is needed but not specified, it is taken from the basename
of the device that is being created. e.g. when creating
<i>/dev/md/home</i> the <b>name</b> will default to
<i>home</i>.</p>

<p style="margin-left:11%;"><b>&minus;R</b>,
<b>&minus;&minus;run</b></p>

<p style="margin-left:22%;">Insist that <i>mdadm</i> run
the array, even if some of the components appear to be
active in another array or filesystem. Normally <i>mdadm</i>
will ask for confirmation before including such components
in an array. This option causes that question to be
suppressed.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;force</b></p>

<p style="margin-left:22%;">Insist that <i>mdadm</i> accept
the geometry and layout specified without question. Normally
<i>mdadm</i> will not allow creation of an array with only
one device, and will try to create a RAID5 array with one
missing drive (as this makes the initial resync work
faster). With <b>&minus;&minus;force</b>, <i>mdadm</i> will
not try to be so clever.</p>

<p style="margin-left:11%;"><b>&minus;a</b>,
<b>&minus;&minus;auto{=yes,md,mdp,part,p}{NN}</b></p>

<p style="margin-left:22%;">Instruct mdadm how to create
the device file if needed, possibly allocating an unused
minor number. &quot;md&quot; causes a non-partitionable
array to be used (though since Linux 2.6.28, these array
devices are in fact partitionable). &quot;mdp&quot;,
&quot;part&quot; or &quot;p&quot; causes a partitionable
array (2.6 and later) to be used. &quot;yes&quot; requires
the named md device to have a &rsquo;standard&rsquo; format,
and the type and minor number will be determined from this.
With mdadm 3.0, device creation is normally left up to
<i>udev</i> so this option is unlikely to be needed. See
DEVICE NAMES below.</p>

<p style="margin-left:22%; margin-top: 1em">The argument
can also come immediately after &quot;&minus;a&quot;. e.g.
&quot;&minus;ap&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>&minus;&minus;auto</b> is not given on the command line
or in the config file, then the default will be
<b>&minus;&minus;auto=yes</b>.</p>

<p style="margin-left:22%; margin-top: 1em">If
<b>&minus;&minus;scan</b> is also given, then any
<i>auto=</i> entries in the config file will override the
<b>&minus;&minus;auto</b> instruction given on the command
line.</p>

<p style="margin-left:22%; margin-top: 1em">For
partitionable arrays, <i>mdadm</i> will create the device
file for the whole array and for the first 4 partitions. A
different number of partitions can be specified at the end
of this option (e.g. <b>&minus;&minus;auto=p7</b>). If the
device name ends with a digit, the partition names add a
&rsquo;p&rsquo;, and a number, e.g. <i>/dev/md/home1p3</i>.
If there is no trailing digit, then the partition names just
have a number added, e.g. <i>/dev/md/scratch3</i>.</p>

<p style="margin-left:22%; margin-top: 1em">If the md
device name is in a &rsquo;standard&rsquo; format as
described in DEVICE NAMES, then it will be created, if
necessary, with the appropriate device number based on that
name. If the device name is not in one of these formats,
then a unused device number will be allocated. The device
number will be considered unused if there is no active array
for that number, and there is no entry in /dev for that
number and with a non-standard name. Names that are not in
&rsquo;standard&rsquo; format are only allowed in
&quot;/dev/md/&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">This is
meaningful with <b>&minus;&minus;create</b> or
<b>&minus;&minus;build</b>.</p>

<p style="margin-left:11%;"><b>&minus;a</b>,
<b>&minus;&minus;add</b></p>

<p style="margin-left:22%;">This option can be used in Grow
mode in two cases.</p>

<p style="margin-left:22%; margin-top: 1em">If the target
array is a Linear array, then <b>&minus;&minus;add</b> can
be used to add one or more devices to the array. They are
simply catenated on to the end of the array. Once added, the
devices cannot be removed.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>&minus;&minus;raid&minus;disks</b> option is being used
to increase the number of devices in an array, then
<b>&minus;&minus;add</b> can be used to add some extra
devices to be included in the array. In most cases this is
not needed as the extra devices can be added as spares
first, and then the number of raid-disks can be changed.
However for RAID0, it is not possible to add spares. So to
increase the number of devices in a RAID0, it is necessary
to set the new number of devices, and to add the new
devices, in the same command.</p>

<h2>For assemble:
<a name="For assemble:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;u</b>,
<b>&minus;&minus;uuid=</b></p>

<p style="margin-left:22%;">uuid of array to assemble.
Devices which don&rsquo;t have this uuid are excluded</p>

<p style="margin-left:11%;"><b>&minus;m</b>,
<b>&minus;&minus;super&minus;minor=</b></p>

<p style="margin-left:22%;">Minor number of device that
array was created for. Devices which don&rsquo;t have this
minor number are excluded. If you create an array as
/dev/md1, then all superblocks will contain the minor number
1, even if the array is later assembled as /dev/md2.</p>

<p style="margin-left:22%; margin-top: 1em">Giving the
literal word &quot;dev&quot; for
<b>&minus;&minus;super&minus;minor</b> will cause
<i>mdadm</i> to use the minor number of the md device that
is being assembled. e.g. when assembling <b>/dev/md0</b>,
<b>&minus;&minus;super&minus;minor=dev</b> will look for
super blocks with a minor number of 0.</p>


<p style="margin-left:22%; margin-top: 1em"><b>&minus;&minus;super&minus;minor</b>
is only relevant for v0.90 metadata, and should not normally
be used. Using <b>&minus;&minus;uuid</b> is much safer.</p>

<p style="margin-left:11%;"><b>&minus;N</b>,
<b>&minus;&minus;name=</b></p>

<p style="margin-left:22%;">Specify the name of the array
to assemble. This must be the name that was specified when
creating the array. It must either match the name stored in
the superblock exactly, or it must match with the current
<i>homehost</i> prefixed to the start of the given name.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;force</b></p>

<p style="margin-left:22%;">Assemble the array even if the
metadata on some devices appears to be out-of-date. If
<i>mdadm</i> cannot find enough working devices to start the
array, but can find some devices that are recorded as having
failed, then it will mark those devices as working so that
the array can be started. An array which requires
<b>&minus;&minus;force</b> to be started may contain data
corruption. Use it carefully.</p>

<p style="margin-left:11%;"><b>&minus;R</b>,
<b>&minus;&minus;run</b></p>

<p style="margin-left:22%;">Attempt to start the array even
if fewer drives were given than were present last time the
array was active. Normally if not all the expected drives
are found and <b>&minus;&minus;scan</b> is not used, then
the array will be assembled but not started. With
<b>&minus;&minus;run</b> an attempt will be made to start it
anyway.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;degraded</b></p>

<p style="margin-left:22%;">This is the reverse of
<b>&minus;&minus;run</b> in that it inhibits the startup of
array unless all expected drives are present. This is only
needed with <b>&minus;&minus;scan,</b> and can be used if
the physical connections to devices are not as reliable as
you would like.</p>

<p style="margin-left:11%;"><b>&minus;a</b>,
<b>&minus;&minus;auto{=no,yes,md,mdp,part}</b></p>

<p style="margin-left:22%;">See this option under Create
and Build options.</p>

<p style="margin-left:11%;"><b>&minus;b</b>,
<b>&minus;&minus;bitmap=</b></p>

<p style="margin-left:22%;">Specify the bitmap file that
was given when the array was created. If an array has an
<b>internal</b> bitmap, there is no need to specify this
when assembling the array.</p>


<p style="margin-left:11%;"><b>&minus;&minus;backup&minus;file=</b></p>

<p style="margin-left:22%;">If
<b>&minus;&minus;backup&minus;file</b> was used while
reshaping an array (e.g. changing number of devices or chunk
size) and the system crashed during the critical section,
then the same <b>&minus;&minus;backup&minus;file</b> must be
presented to <b>&minus;&minus;assemble</b> to allow possibly
corrupted data to be restored, and the reshape to be
completed.</p>


<p style="margin-left:11%;"><b>&minus;&minus;invalid&minus;backup</b></p>

<p style="margin-left:22%;">If the file needed for the
above option is not available for any reason an empty file
can be given together with this option to indicate that the
backup file is invalid. In this case the data that was being
rearranged at the time of the crash could be irrecoverably
lost, but the rest of the array may still be recoverable.
This option should only be used as a last resort if there is
no way to recover the backup file.</p>

<p style="margin-left:11%;"><b>&minus;U</b>,
<b>&minus;&minus;update=</b></p>

<p style="margin-left:22%;">Update the superblock on each
device while assembling the array. The argument given to
this flag can be one of <b>sparc2.2</b>, <b>summaries</b>,
<b>uuid</b>, <b>name</b>, <b>homehost</b>, <b>resync</b>,
<b>byteorder</b>, <b>devicesize</b>, <b>no&minus;bitmap</b>,
or <b>super&minus;minor</b>.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>sparc2.2</b> option will adjust the superblock of an
array what was created on a Sparc machine running a patched
2.2 Linux kernel. This kernel got the alignment of part of
the superblock wrong. You can use the
<b>&minus;&minus;examine &minus;&minus;sparc2.2</b> option
to <i>mdadm</i> to see what effect this would have.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>super&minus;minor</b> option will update the <b>preferred
minor</b> field on each superblock to match the minor number
of the array being assembled. This can be useful if
<b>&minus;&minus;examine</b> reports a different
&quot;Preferred Minor&quot; to <b>&minus;&minus;detail</b>.
In some cases this update will be performed automatically by
the kernel driver. In particular the update happens
automatically at the first write to an array with redundancy
(RAID level 1 or greater) on a 2.6 (or later) kernel.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>uuid</b>
option will change the uuid of the array. If a UUID is given
with the <b>&minus;&minus;uuid</b> option that UUID will be
used as a new UUID and will <b>NOT</b> be used to help
identify the devices in the array. If no
<b>&minus;&minus;uuid</b> is given, a random UUID is
chosen.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>name</b>
option will change the <i>name</i> of the array as stored in
the superblock. This is only supported for version-1
superblocks.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>homehost</b> option will change the <i>homehost</i> as
recorded in the superblock. For version-0 superblocks, this
is the same as updating the UUID. For version-1 superblocks,
this involves updating the name.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>resync</b> option will cause the array to be marked
<i>dirty</i> meaning that any redundancy in the array (e.g.
parity for RAID5, copies for RAID1) may be incorrect. This
will cause the RAID system to perform a &quot;resync&quot;
pass to make sure that all redundant information is
correct.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>byteorder</b> option allows arrays to be moved between
machines with different byte-order. When assembling such an
array for the first time after a move, giving
<b>&minus;&minus;update=byteorder</b> will cause
<i>mdadm</i> to expect superblocks to have their byteorder
reversed, and will correct that order before assembling the
array. This is only valid with original (Version 0.90)
superblocks.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>summaries</b> option will correct the summaries in the
superblock. That is the counts of total, working, active,
failed, and spare devices.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>devicesize</b> option will rarely be of use. It applies
to version 1.1 and 1.2 metadata only (where the metadata is
at the start of the device) and is only useful when the
component device has changed size (typically become larger).
The version 1 metadata records the amount of the device that
can be used to store data, so if a device in a version 1.1
or 1.2 array becomes larger, the metadata will still be
visible, but the extra space will not. In this case it might
be useful to assemble the array with
<b>&minus;&minus;update=devicesize</b>. This will cause
<i>mdadm</i> to determine the maximum usable amount of space
on each device and update the relevant field in the
metadata.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>no&minus;bitmap</b> option can be used when an array has
an internal bitmap which is corrupt in some way so that
assembling the array normally fails. It will cause any
internal bitmap to be ignored.</p>


<p style="margin-left:11%;"><b>&minus;&minus;freeze&minus;reshape</b></p>

<p style="margin-left:22%;">Option is intended to be used
in start-up scripts during initrd boot phase. When array
under reshape is assembled during initrd phase, this option
stops reshape after reshape critical section is being
restored. This happens before file system pivot operation
and avoids loss of file system context. Losing file system
context would cause reshape to be broken.</p>

<p style="margin-left:22%; margin-top: 1em">Reshape can be
continued later using the <b>&minus;&minus;continue</b>
option for the grow command.</p>

<h2>For Manage mode:
<a name="For Manage mode:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;test</b></p>

<p style="margin-left:22%;">Unless a more serious error
occurred, <i>mdadm</i> will exit with a status of 2 if no
changes were made to the array and 0 if at least one change
was made. This can be useful when an indirect specifier such
as <b>missing</b>, <b>detached</b> or <b>faulty</b> is used
in requesting an operation on the array.
<b>&minus;&minus;test</b> will report failure if these
specifiers didn&rsquo;t find any match.</p>

<p style="margin-left:11%;"><b>&minus;a</b>,
<b>&minus;&minus;add</b></p>

<p style="margin-left:22%;">hot-add listed devices. If a
device appears to have recently been part of the array
(possibly it failed or was removed) the device is
re&minus;added as described in the next point. If that fails
or the device was never part of the array, the device is
added as a hot-spare. If the array is degraded, it will
immediately start to rebuild data onto that spare.</p>

<p style="margin-left:22%; margin-top: 1em">Note that this
and the following options are only meaningful on array with
redundancy. They don&rsquo;t apply to RAID0 or Linear.</p>


<p style="margin-left:11%;"><b>&minus;&minus;re&minus;add</b></p>

<p style="margin-left:22%;">re&minus;add a device that was
previous removed from an array. If the metadata on the
device reports that it is a member of the array, and the
slot that it used is still vacant, then the device will be
added back to the array in the same position. This will
normally cause the data for that device to be recovered.
However based on the event count on the device, the recovery
may only require sections that are flagged a write-intent
bitmap to be recovered or may not require any recovery at
all.</p>

<p style="margin-left:22%; margin-top: 1em">When used on an
array that has no metadata (i.e. it was built with
<b>&minus;&minus;build)</b> it will be assumed that
bitmap-based recovery is enough to make the device fully
consistent with the array.</p>

<p style="margin-left:22%; margin-top: 1em">When
<b>&minus;&minus;re&minus;add</b> can be accompanied by
<b>&minus;&minus;update=devicesize</b>. See the description
of this option when used in Assemble mode for an explanation
of its use.</p>

<p style="margin-left:22%; margin-top: 1em">If the device
name given is <b>missing</b> then mdadm will try to find any
device that looks like it should be part of the array but
isn&rsquo;t and will try to re&minus;add all such
devices.</p>

<p style="margin-left:11%;"><b>&minus;r</b>,
<b>&minus;&minus;remove</b></p>

<p style="margin-left:22%;">remove listed devices. They
must not be active. i.e. they should be failed or spare
devices. As well as the name of a device file (e.g.
<b>/dev/sda1</b>) the words <b>failed</b> and
<b>detached</b> can be given to <b>&minus;&minus;remove</b>.
The first causes all failed device to be removed. The second
causes any device which is no longer connected to the system
(i.e an &rsquo;open&rsquo; returns <b>ENXIO</b>) to be
removed. This will only succeed for devices that are spares
or have already been marked as failed.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;fail</b></p>

<p style="margin-left:22%;">mark listed devices as faulty.
As well as the name of a device file, the word
<b>detached</b> can be given. This will cause any device
that has been detached from the system to be marked as
failed. It can then be removed.</p>


<p style="margin-left:11%;"><b>&minus;&minus;set&minus;faulty</b></p>

<p style="margin-left:22%;">same as
<b>&minus;&minus;fail</b>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;write&minus;mostly</b></p>

<p style="margin-left:22%;">Subsequent devices that are
added or re&minus;added will have the
&rsquo;write-mostly&rsquo; flag set. This is only valid for
RAID1 and means that the &rsquo;md&rsquo; driver will avoid
reading from these devices if possible.</p>


<p style="margin-left:11%;"><b>&minus;&minus;readwrite</b></p>

<p style="margin-left:22%;">Subsequent devices that are
added or re&minus;added will have the
&rsquo;write-mostly&rsquo; flag cleared.</p>

<p style="margin-left:11%; margin-top: 1em">Each of these
options requires that the first device listed is the array
to be acted upon, and the remainder are component devices to
be added, removed, marked as faulty, etc. Several different
operations can be specified for different devices, e.g.</p>

<p style="margin-left:18%;">mdadm /dev/md0
&minus;&minus;add /dev/sda1 &minus;&minus;fail /dev/sdb1
&minus;&minus;remove /dev/sdb1</p>

<p style="margin-left:11%;">Each operation applies to all
devices listed until the next operation.</p>

<p style="margin-left:11%; margin-top: 1em">If an array is
using a write-intent bitmap, then devices which have been
removed can be re&minus;added in a way that avoids a full
reconstruction but instead just updates the blocks that have
changed since the device was removed. For arrays with
persistent metadata (superblocks) this is done
automatically. For arrays created with
<b>&minus;&minus;build</b> mdadm needs to be told that this
device we removed recently with
<b>&minus;&minus;re&minus;add</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Devices can
only be removed from an array if they are not in active use,
i.e. that must be spares or failed devices. To remove an
active device, it must first be marked as <b>faulty.</b></p>

<h2>For Misc mode:
<a name="For Misc mode:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;Q</b>,
<b>&minus;&minus;query</b></p>

<p style="margin-left:22%;">Examine a device to see (1) if
it is an md device and (2) if it is a component of an md
array. Information about what is discovered is
presented.</p>

<p style="margin-left:11%;"><b>&minus;D</b>,
<b>&minus;&minus;detail</b></p>

<p style="margin-left:22%;">Print details of one or more md
devices.</p>


<p style="margin-left:11%;"><b>&minus;&minus;detail&minus;platform</b></p>

<p style="margin-left:22%;">Print details of the
platform&rsquo;s RAID capabilities (firmware / hardware
topology) for a given metadata format.</p>

<p style="margin-left:11%;"><b>&minus;Y</b>,
<b>&minus;&minus;export</b></p>

<p style="margin-left:22%;">When used with
<b>&minus;&minus;detail</b> or <b>&minus;&minus;examine</b>,
output will be formatted as <b>key=value</b> pairs for easy
import into the environment.</p>

<p style="margin-left:11%;"><b>&minus;E</b>,
<b>&minus;&minus;examine</b></p>

<p style="margin-left:22%;">Print contents of the metadata
stored on the named device(s). Note the contrast between
<b>&minus;&minus;examine</b> and
<b>&minus;&minus;detail</b>. <b>&minus;&minus;examine</b>
applies to devices which are components of an array, while
<b>&minus;&minus;detail</b> applies to a whole array which
is currently active.</p>


<p style="margin-left:11%;"><b>&minus;&minus;sparc2.2</b></p>

<p style="margin-left:22%;">If an array was created on a
SPARC machine with a 2.2 Linux kernel patched with RAID
support, the superblock will have been created incorrectly,
or at least incompatibly with 2.4 and later kernels. Using
the <b>&minus;&minus;sparc2.2</b> flag with
<b>&minus;&minus;examine</b> will fix the superblock before
displaying it. If this appears to do the right thing, then
the array can be successfully assembled using
<b>&minus;&minus;assemble
&minus;&minus;update=sparc2.2</b>.</p>

<p style="margin-left:11%;"><b>&minus;X</b>,
<b>&minus;&minus;examine&minus;bitmap</b></p>

<p style="margin-left:22%;">Report information about a
bitmap file. The argument is either an external bitmap file
or an array component in case of an internal bitmap. Note
that running this on an array device (e.g. <b>/dev/md0</b>)
does not report the bitmap for that array.</p>

<p style="margin-left:11%;"><b>&minus;R</b>,
<b>&minus;&minus;run</b></p>

<p style="margin-left:22%;">start a partially assembled
array. If <b>&minus;&minus;assemble</b> did not find enough
devices to fully start the array, it might leaving it
partially assembled. If you wish, you can then use
<b>&minus;&minus;run</b> to start the array in degraded
mode.</p>

<p style="margin-left:11%;"><b>&minus;S</b>,
<b>&minus;&minus;stop</b></p>

<p style="margin-left:22%;">deactivate array, releasing all
resources.</p>

<p style="margin-left:11%;"><b>&minus;o</b>,
<b>&minus;&minus;readonly</b></p>

<p style="margin-left:22%;">mark array as readonly.</p>

<p style="margin-left:11%;"><b>&minus;w</b>,
<b>&minus;&minus;readwrite</b></p>

<p style="margin-left:22%;">mark array as readwrite.</p>


<p style="margin-left:11%;"><b>&minus;&minus;zero&minus;superblock</b></p>

<p style="margin-left:22%;">If the device contains a valid
md superblock, the block is overwritten with zeros. With
<b>&minus;&minus;force</b> the block where the superblock
would be is overwritten even if it doesn&rsquo;t appear to
be valid.</p>


<p style="margin-left:11%;"><b>&minus;&minus;kill&minus;subarray=</b></p>

<p style="margin-left:22%;">If the device is a container
and the argument to &minus;&minus;kill&minus;subarray
specifies an inactive subarray in the container, then the
subarray is deleted. Deleting all subarrays will leave an
&rsquo;empty-container&rsquo; or spare superblock on the
drives. See &minus;&minus;zero&minus;superblock for
completely removing a superblock. Note that some formats
depend on the subarray index for generating a UUID, this
command will fail if it would change the UUID of an active
subarray.</p>


<p style="margin-left:11%;"><b>&minus;&minus;update&minus;subarray=</b></p>

<p style="margin-left:22%;">If the device is a container
and the argument to &minus;&minus;update&minus;subarray
specifies a subarray in the container, then attempt to
update the given superblock field in the subarray. See below
in <b>MISC MODE</b> for details.</p>

<p style="margin-left:11%;"><b>&minus;t</b>,
<b>&minus;&minus;test</b></p>

<p style="margin-left:22%;">When used with
<b>&minus;&minus;detail</b>, the exit status of <i>mdadm</i>
is set to reflect the status of the device. See below in
<b>MISC MODE</b> for details.</p>

<p style="margin-left:11%;"><b>&minus;W</b>,
<b>&minus;&minus;wait</b></p>

<p style="margin-left:22%;">For each md device given, wait
for any resync, recovery, or reshape activity to finish
before returning. <i>mdadm</i> will return with success if
it actually waited for every device listed, otherwise it
will return failure.</p>


<p style="margin-left:11%;"><b>&minus;&minus;wait&minus;clean</b></p>

<p style="margin-left:22%;">For each md device given, or
each device in /proc/mdstat if <b>&minus;&minus;scan</b> is
given, arrange for the array to be marked clean as soon as
possible. <i>mdadm</i> will return with success if the array
uses external metadata and we successfully waited. For
native arrays this returns immediately as the kernel handles
dirty-clean transitions at shutdown. No action is taken if
safe-mode handling is disabled.</p>

<h2>For Incremental Assembly mode:
<a name="For Incremental Assembly mode:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;rebuild&minus;map</b>,
<b>&minus;r</b></p>

<p style="margin-left:22%;">Rebuild the map file
(<b>/run/mdadm/map</b>) that <i>mdadm</i> uses to help track
which arrays are currently being assembled.</p>

<p style="margin-left:11%;"><b>&minus;&minus;run</b>,
<b>&minus;R</b></p>

<p style="margin-left:22%;">Run any array assembled as soon
as a minimal number of devices are available, rather than
waiting until all expected devices are present.</p>

<p style="margin-left:11%;"><b>&minus;&minus;scan</b>,
<b>&minus;s</b></p>

<p style="margin-left:22%;">Only meaningful with
<b>&minus;R</b> this will scan the <b>map</b> file for
arrays that are being incrementally assembled and will try
to start any that are not already started. If any such array
is listed in <b>mdadm.conf</b> as requiring an external
bitmap, that bitmap will be attached first.</p>

<p style="margin-left:11%;"><b>&minus;&minus;fail</b>,
<b>&minus;f</b></p>

<p style="margin-left:22%;">This allows the hot-plug system
to remove devices that have fully disappeared from the
kernel. It will first fail and then remove the device from
any array it belongs to. The device name given should be a
kernel device name such as &quot;sda&quot;, not a name in
<i>/dev</i>.</p>

<p style="margin-left:11%;"><b>&minus;&minus;path=</b></p>

<p style="margin-left:22%;">Only used with
&minus;&minus;fail. The &rsquo;path&rsquo; given will be
recorded so that if a new device appears at the same
location it can be automatically added to the same array.
This allows the failed device to be automatically replaced
by a new device without metadata if it appears at specified
path. This option is normally only set by a <i>udev</i>
script.</p>

<h2>For Monitor mode:
<a name="For Monitor mode:"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;m</b>,
<b>&minus;&minus;mail</b></p>

<p style="margin-left:22%;">Give a mail address to send
alerts to.</p>

<p style="margin-left:11%;"><b>&minus;p</b>,
<b>&minus;&minus;program</b>, <b>&minus;&minus;alert</b></p>

<p style="margin-left:22%;">Give a program to be run
whenever an event is detected.</p>

<p style="margin-left:11%;"><b>&minus;y</b>,
<b>&minus;&minus;syslog</b></p>

<p style="margin-left:22%;">Cause all events to be reported
through &rsquo;syslog&rsquo;. The messages have facility of
&rsquo;daemon&rsquo; and varying priorities.</p>

<p style="margin-left:11%;"><b>&minus;d</b>,
<b>&minus;&minus;delay</b></p>

<p style="margin-left:22%;">Give a delay in seconds.
<i>mdadm</i> polls the md arrays and then waits this many
seconds before polling again. The default is 60 seconds.
Since 2.6.16, there is no need to reduce this as the kernel
alerts <i>mdadm</i> immediately when there is any
change.</p>

<p style="margin-left:11%;"><b>&minus;r</b>,
<b>&minus;&minus;increment</b></p>

<p style="margin-left:22%;">Give a percentage increment.
<i>mdadm</i> will generate RebuildNN events with the given
percentage increment.</p>

<p style="margin-left:11%;"><b>&minus;f</b>,
<b>&minus;&minus;daemonise</b></p>

<p style="margin-left:22%;">Tell <i>mdadm</i> to run as a
background daemon if it decides to monitor anything. This
causes it to fork and run in the child, and to disconnect
from the terminal. The process id of the child is written to
stdout. This is useful with <b>&minus;&minus;scan</b> which
will only continue monitoring if a mail address or alert
program is found in the config file.</p>

<p style="margin-left:11%;"><b>&minus;i</b>,
<b>&minus;&minus;pid&minus;file</b></p>

<p style="margin-left:22%;">When <i>mdadm</i> is running in
daemon mode, write the pid of the daemon process to the
specified file, instead of printing it on standard
output.</p>

<p style="margin-left:11%;"><b>&minus;1</b>,
<b>&minus;&minus;oneshot</b></p>

<p style="margin-left:22%;">Check arrays only once. This
will generate <b>NewArray</b> events and more significantly
<b>DegradedArray</b> and <b>SparesMissing</b> events.
Running</p>

<p style="margin-left:29%;"><b>mdadm &minus;&minus;monitor
&minus;&minus;scan &minus;1</b></p>

<p style="margin-left:22%;">from a cron script will ensure
regular notification of any degraded arrays.</p>

<p style="margin-left:11%;"><b>&minus;t</b>,
<b>&minus;&minus;test</b></p>

<p style="margin-left:22%;">Generate a <b>TestMessage</b>
alert for every array found at startup. This alert gets
mailed and passed to the alert program. This can be used for
testing that alert message do get through successfully.</p>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;sharing</b></p>

<p style="margin-left:22%;">This inhibits the functionality
for moving spares between arrays. Only one monitoring
process started with <b>&minus;&minus;scan</b> but without
this flag is allowed, otherwise the two could interfere with
each other.</p>

<h2>ASSEMBLE MODE
<a name="ASSEMBLE MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="35%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;assemble</b></p> </td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em"><i>md-device
options-and-component-devices...</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="46%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;assemble</b></p> </td>
<td width="1%"></td>
<td width="39%"></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;scan</b>
<i>md-devices-and-options...</i></p>

<p style="margin-left:11%; margin-top: 1em">Usage: <b>mdadm
&minus;&minus;assemble &minus;&minus;scan</b>
<i>options...</i></p>

<p style="margin-left:11%; margin-top: 1em">This usage
assembles one or more RAID arrays from pre-existing
components. For each array, mdadm needs to know the md
device, the identity of the array, and a number of
component-devices. These can be found in a number of
ways.</p>

<p style="margin-left:11%; margin-top: 1em">In the first
usage example (without the <b>&minus;&minus;scan</b>) the
first device given is the md device. In the second usage
example, all devices listed are treated as md devices and
assembly is attempted. In the third (where no devices are
listed) all md devices that are listed in the configuration
file are assembled. If no arrays are described by the
configuration file, then any arrays that can be found on
unused devices will be assembled.</p>

<p style="margin-left:11%; margin-top: 1em">If precisely
one device is listed, but <b>&minus;&minus;scan</b> is not
given, then <i>mdadm</i> acts as though
<b>&minus;&minus;scan</b> was given and identity information
is extracted from the configuration file.</p>

<p style="margin-left:11%; margin-top: 1em">The identity
can be given with the <b>&minus;&minus;uuid</b> option, the
<b>&minus;&minus;name</b> option, or the
<b>&minus;&minus;super&minus;minor</b> option, will be taken
from the md-device record in the config file, or will be
taken from the super block of the first component-device
listed on the command line.</p>

<p style="margin-left:11%; margin-top: 1em">Devices can be
given on the <b>&minus;&minus;assemble</b> command line or
in the config file. Only devices which have an md superblock
which contains the right identity will be considered for any
array.</p>

<p style="margin-left:11%; margin-top: 1em">The config file
is only used if explicitly named with
<b>&minus;&minus;config</b> or requested with (a possibly
implicit) <b>&minus;&minus;scan</b>. In the later case,
<b>/etc/mdadm.conf</b> or <b>/etc/mdadm/mdadm.conf</b> is
used.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>&minus;&minus;scan</b> is not given, then the config file
will only be used to find the identity of md arrays.</p>

<p style="margin-left:11%; margin-top: 1em">Normally the
array will be started after it is assembled. However if
<b>&minus;&minus;scan</b> is not given and not all expected
drives were listed, then the array is not started (to guard
against usage errors). To insist that the array be started
in this case (as may work for RAID1, 4, 5, 6, or 10), give
the <b>&minus;&minus;run</b> flag.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>udev</i>
is active, <i>mdadm</i> does not create any entries in
<b>/dev</b> but leaves that to <i>udev</i>. It does record
information in <b>/run/mdadm/map</b> which will allow
<i>udev</i> to choose the correct name.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>mdadm</i>
detects that udev is not configured, it will create the
devices in <b>/dev</b> itself.</p>

<p style="margin-left:11%; margin-top: 1em">In Linux
kernels prior to version 2.6.28 there were two distinctly
different types of md devices that could be created: one
that could be partitioned using standard partitioning tools
and one that could not. Since 2.6.28 that distinction is no
longer relevant as both type of devices can be partitioned.
<i>mdadm</i> will normally create the type that originally
could not be partitioned as it has a well defined major
number (9).</p>

<p style="margin-left:11%; margin-top: 1em">Prior to
2.6.28, it is important that mdadm chooses the correct type
of array device to use. This can be controlled with the
<b>&minus;&minus;auto</b> option. In particular, a value of
&quot;mdp&quot; or &quot;part&quot; or &quot;p&quot; tells
mdadm to use a partitionable device rather than the
default.</p>

<p style="margin-left:11%; margin-top: 1em">In the no-udev
case, the value given to <b>&minus;&minus;auto</b> can be
suffixed by a number. This tells <i>mdadm</i> to create that
number of partition devices rather than the default of
4.</p>

<p style="margin-left:11%; margin-top: 1em">The value given
to <b>&minus;&minus;auto</b> can also be given in the
configuration file as a word starting <b>auto=</b> on the
ARRAY line for the relevant array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Auto
Assembly</b> <br>
When <b>&minus;&minus;assemble</b> is used with
<b>&minus;&minus;scan</b> and no devices are listed,
<i>mdadm</i> will first attempt to assemble all the arrays
listed in the config file.</p>

<p style="margin-left:11%; margin-top: 1em">If no arrays
are listed in the config (other than those marked
<b>&lt;ignore&gt;</b>) it will look through the available
devices for possible arrays and will try to assemble
anything that it finds. Arrays which are tagged as belonging
to the given homehost will be assembled and started
normally. Arrays which do not obviously belong to this host
are given names that are expected not to conflict with
anything local, and are started &quot;read-auto&quot; so
that nothing is written to any device until the array is
written to. i.e. automatic resync etc is delayed.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>mdadm</i>
finds a consistent set of devices that look like they should
comprise an array, and if the superblock is tagged as
belonging to the given home host, it will automatically
choose a device name and try to assemble the array. If the
array uses version-0.90 metadata, then the <b>minor</b>
number as recorded in the superblock is used to create a
name in <b>/dev/md/</b> so for example <b>/dev/md/3</b>. If
the array uses version-1 metadata, then the <b>name</b> from
the superblock is used to similarly create a name in
<b>/dev/md/</b> (the name will have any &rsquo;host&rsquo;
prefix stripped first).</p>

<p style="margin-left:11%; margin-top: 1em">This behaviour
can be modified by the <i>AUTO</i> line in the
<i>mdadm.conf</i> configuration file. This line can indicate
that specific metadata type should, or should not, be
automatically assembled. If an array is found which is not
listed in <i>mdadm.conf</i> and has a metadata format that
is denied by the <i>AUTO</i> line, then it will not be
assembled. The <i>AUTO</i> line can also request that all
arrays identified as being for this homehost should be
assembled regardless of their metadata type. See
<i>mdadm.conf</i>(5) for further details.</p>

<p style="margin-left:11%; margin-top: 1em">Note: Auto
assembly cannot be used for assembling and activating some
arrays which are undergoing reshape. In particular as the
<b>backup&minus;file</b> cannot be given, any reshape which
requires a backup-file to continue cannot be started by auto
assembly. An array which is growing to more devices and has
passed the critical section can be assembled using
auto-assembly.</p>

<h2>BUILD MODE
<a name="BUILD MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="31%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;build</b></p> </td>
<td width="3%"></td>
<td width="55%">


<p style="margin-top: 1em"><i>md-device</i>
<b>&minus;&minus;chunk=</b><i>X</i>
<b>&minus;&minus;level=</b><i>Y</i>
<b>&minus;&minus;raid&minus;devices=</b><i>Z</i></p> </td></tr>
</table>

<p style="margin-left:11%;"><i>devices</i></p>

<p style="margin-left:11%; margin-top: 1em">This usage is
similar to <b>&minus;&minus;create</b>. The difference is
that it creates an array without a superblock. With these
arrays there is no difference between initially creating the
array and subsequently assembling the array, except that
hopefully there is useful data there in the second case.</p>

<p style="margin-left:11%; margin-top: 1em">The level may
raid0, linear, raid1, raid10, multipath, or faulty, or one
of their synonyms. All devices must be listed and the array
will be started once complete. It will often be appropriate
to use <b>&minus;&minus;assume&minus;clean</b> with levels
raid1 or raid10.</p>

<h2>CREATE MODE
<a name="CREATE MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="32%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;create</b></p> </td>
<td width="2%"></td>
<td width="44%">


<p style="margin-top: 1em"><i>md-device</i>
<b>&minus;&minus;chunk=</b><i>X</i>
<b>&minus;&minus;level=</b><i>Y</i></p> </td>
<td width="11%">
</td></tr>
</table>


<p style="margin-left:29%;"><b>&minus;&minus;raid&minus;devices=</b><i>Z
devices</i></p>

<p style="margin-left:11%; margin-top: 1em">This usage will
initialise a new md array, associate some devices with it,
and activate the array.</p>

<p style="margin-left:11%; margin-top: 1em">The named
device will normally not exist when <i>mdadm
&minus;&minus;create</i> is run, but will be created by
<i>udev</i> once the array becomes active.</p>

<p style="margin-left:11%; margin-top: 1em">As devices are
added, they are checked to see if they contain RAID
superblocks or filesystems. They are also checked to see if
the variance in device size exceeds 1%.</p>

<p style="margin-left:11%; margin-top: 1em">If any
discrepancy is found, the array will not automatically be
run, though the presence of a <b>&minus;&minus;run</b> can
override this caution.</p>

<p style="margin-left:11%; margin-top: 1em">To create a
&quot;degraded&quot; array in which some devices are
missing, simply give the word &quot;<b>missing</b>&quot; in
place of a device name. This will cause <i>mdadm</i> to
leave the corresponding slot in the array empty. For a RAID4
or RAID5 array at most one slot can be
&quot;<b>missing</b>&quot;; for a RAID6 array at most two
slots. For a RAID1 array, only one real device needs to be
given. All of the others can be
&quot;<b>missing</b>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">When creating a
RAID5 array, <i>mdadm</i> will automatically create a
degraded array with an extra spare drive. This is because
building the spare into a degraded array is in general
faster than resyncing the parity on a non-degraded, but not
clean, array. This feature can be overridden with the
<b>&minus;&minus;force</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">When creating
an array with version-1 metadata a name for the array is
required. If this is not given with the
<b>&minus;&minus;name</b> option, <i>mdadm</i> will choose a
name based on the last component of the name of the device
being created. So if <b>/dev/md3</b> is being created, then
the name <b>3</b> will be chosen. If <b>/dev/md/home</b> is
being created, then the name <b>home</b> will be used.</p>

<p style="margin-left:11%; margin-top: 1em">When creating a
partition based array, using <i>mdadm</i> with version-1.x
metadata, the partition type should be set to <b>0xDA</b>
(non fs-data). This type selection allows for greater
precision since using any other [RAID auto-detect (0xFD) or
a GNU/Linux partition (0x83)], might create problems in the
event of array recovery through a live cdrom.</p>

<p style="margin-left:11%; margin-top: 1em">A new array
will normally get a randomly assigned 128bit UUID which is
very likely to be unique. If you have a specific need, you
can choose a UUID for the array by giving the
<b>&minus;&minus;uuid=</b> option. Be warned that creating
two arrays with the same UUID is a recipe for disaster.
Also, using <b>&minus;&minus;uuid=</b> when creating a v0.90
array will silently override any
<b>&minus;&minus;homehost=</b> setting.</p>

<p style="margin-left:11%; margin-top: 1em">When creating
an array within a <b>CONTAINER</b> <i>mdadm</i> can be given
either the list of devices to use, or simply the name of the
container. The former case gives control over which devices
in the container will be used for the array. The latter case
allows <i>mdadm</i> to automatically choose which devices to
use based on how much spare space is available.</p>

<p style="margin-left:11%; margin-top: 1em">The General
Management options that are valid with
<b>&minus;&minus;create</b> are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;run</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>insist on running the array even if some devices look
like they might be in use.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;readonly</b></p>

<p style="margin-left:22%;">start the array readonly
&mdash; not supported yet.</p>

<h2>MANAGE MODE
<a name="MANAGE MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em">Usage: <b>mdadm</b></p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><i>device options...
devices...</i></p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This usage will
allow individual devices in an array to be failed, removed
or added. It is possible to perform multiple operations with
on command. For example: <b><br>
mdadm /dev/md0 &minus;f /dev/hda1 &minus;r /dev/hda1
&minus;a /dev/hda1</b> <br>
will firstly mark <b>/dev/hda1</b> as faulty in
<b>/dev/md0</b> and will then remove it from the array and
finally add it back in as a spare. However only one md array
can be affected by a single command.</p>

<p style="margin-left:11%; margin-top: 1em">When a device
is added to an active array, mdadm checks to see if it has
metadata on it which suggests that it was recently a member
of the array. If it does, it tries to
&quot;re&minus;add&quot; the device. If there have been no
changes since the device was removed, or if the array has a
write-intent bitmap which has recorded whatever changes
there were, then the device will immediately become a full
member of the array and those differences recorded in the
bitmap will be resolved.</p>

<h2>MISC MODE
<a name="MISC MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em">Usage: <b>mdadm</b></p></td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><i>options ... devices
...</i></p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">MISC mode
includes a number of distinct operations that operate on
distinct devices. The operations are: <b><br>
&minus;&minus;query</b></p>

<p style="margin-left:22%;">The device is examined to see
if it is (1) an active md array, or (2) a component of an md
array. The information discovered is reported.</p>


<p style="margin-left:11%;"><b>&minus;&minus;detail</b></p>

<p style="margin-left:22%;">The device should be an active
md device. <b>mdadm</b> will display a detailed description
of the array. <b>&minus;&minus;brief</b> or
<b>&minus;&minus;scan</b> will cause the output to be less
detailed and the format to be suitable for inclusion in
<b>mdadm.conf</b>. The exit status of <i>mdadm</i> will
normally be 0 unless <i>mdadm</i> failed to get useful
information about the device(s); however, if the
<b>&minus;&minus;test</b> option is given, then the exit
status will be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>0</p></td>
<td width="9%"></td>
<td width="68%">


<p>The array is functioning normally.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>1</p></td>
<td width="9%"></td>
<td width="68%">


<p>The array has at least one failed device.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>2</p></td>
<td width="9%"></td>
<td width="68%">


<p>The array has multiple failed devices such that it is
unusable.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>4</p></td>
<td width="9%"></td>
<td width="68%">


<p>There was an error while trying to get information about
the device.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;detail&minus;platform</b></p>

<p style="margin-left:22%;">Print detail of the
platform&rsquo;s RAID capabilities (firmware / hardware
topology). If the metadata is specified with <b>&minus;e</b>
or <b>&minus;&minus;metadata=</b> then the return status
will be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>0</p></td>
<td width="9%"></td>
<td width="68%">


<p>metadata successfully enumerated its platform components
on this system</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>1</p></td>
<td width="9%"></td>
<td width="68%">


<p>metadata is platform independent</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>2</p></td>
<td width="9%"></td>
<td width="68%">


<p>metadata failed to find its platform components on this
system</p> </td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;update&minus;subarray=</b></p>

<p style="margin-left:22%;">If the device is a container
and the argument to &minus;&minus;update&minus;subarray
specifies a subarray in the container, then attempt to
update the given superblock field in the subarray. Similar
to updating an array in &quot;assemble&quot; mode, the field
to update is selected by <b>&minus;U</b> or
<b>&minus;&minus;update=</b> option. Currently only
<b>name</b> is supported.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>name</b>
option updates the subarray name in the metadata, it may not
affect the device node name or the device node symlink until
the subarray is re&minus;assembled. If updating <b>name</b>
would change the UUID of an active subarray this operation
is blocked, and the command will end in an error.</p>


<p style="margin-left:11%;"><b>&minus;&minus;examine</b></p>

<p style="margin-left:22%;">The device should be a
component of an md array. <i>mdadm</i> will read the md
superblock of the device and display the contents. If
<b>&minus;&minus;brief</b> or <b>&minus;&minus;scan</b> is
given, then multiple devices that are components of the one
array are grouped together and reported in a single entry
suitable for inclusion in <b>mdadm.conf</b>.</p>

<p style="margin-left:22%; margin-top: 1em">Having
<b>&minus;&minus;scan</b> without listing any devices will
cause all devices listed in the config file to be
examined.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;stop</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The devices should be active md arrays which will be
deactivated, as long as they are not currently in use.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;run</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This will fully activate a partially assembled md
array.</p> </td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;readonly</b></p>

<p style="margin-left:22%;">This will mark an active array
as read-only, providing that it is not currently being
used.</p>


<p style="margin-left:11%;"><b>&minus;&minus;readwrite</b></p>

<p style="margin-left:22%;">This will change a
<b>readonly</b> array back to being read/write.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;scan</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>For all operations except <b>&minus;&minus;examine</b>,
<b>&minus;&minus;scan</b> will cause the operation to be
applied to all arrays listed in <b>/proc/mdstat</b>. For
<b>&minus;&minus;examine, &minus;&minus;scan</b> causes all
devices listed in the config file to be examined.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;b</b>,
<b>&minus;&minus;brief</b></p>

<p style="margin-left:22%;">Be less verbose. This is used
with <b>&minus;&minus;detail</b> and
<b>&minus;&minus;examine</b>. Using
<b>&minus;&minus;brief</b> with <b>&minus;&minus;verbose</b>
gives an intermediate level of verbosity.</p>

<h2>MONITOR MODE
<a name="MONITOR MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="34%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;monitor</b></p> </td>
<td width="1%"></td>
<td width="32%">


<p style="margin-top: 1em"><i>options... devices...</i></p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This usage
causes <i>mdadm</i> to periodically poll a number of md
arrays and to report on any events noticed. <i>mdadm</i>
will never exit once it decides that there are arrays to be
checked, so it should normally be run in the background.</p>

<p style="margin-left:11%; margin-top: 1em">As well as
reporting events, <i>mdadm</i> may move a spare drive from
one array to another if they are in the same
<b>spare-group</b> or <b>domain</b> and if the destination
array has a failed drive but no spares.</p>

<p style="margin-left:11%; margin-top: 1em">If any devices
are listed on the command line, <i>mdadm</i> will only
monitor those devices. Otherwise all arrays listed in the
configuration file will be monitored. Further, if
<b>&minus;&minus;scan</b> is given, then any other md
devices that appear in <b>/proc/mdstat</b> will also be
monitored.</p>

<p style="margin-left:11%; margin-top: 1em">The result of
monitoring the arrays is the generation of events. These
events are passed to a separate program (if specified) and
may be mailed to a given E-mail address.</p>

<p style="margin-left:11%; margin-top: 1em">When passing
events to a program, the program is run once for each event,
and is given 2 or 3 command-line arguments: the first is the
name of the event (see below), the second is the name of the
md device which is affected, and the third is the name of a
related device if relevant (such as a component device that
has failed).</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>&minus;&minus;scan</b> is given, then a program or an
E-mail address must be specified on the command line or in
the config file. If neither are available, then <i>mdadm</i>
will not monitor anything. Without
<b>&minus;&minus;scan,</b> <i>mdadm</i> will continue
monitoring as long as something was found to monitor. If no
program or email is given, then each event is reported to
<b>stdout</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The different
events are:</p>

<p style="margin-left:17%;"><b>DeviceDisappeared</b></p>

<p style="margin-left:28%;">An md array which previously
was configured appears to no longer be configured. (syslog
priority: Critical)</p>

<p style="margin-left:28%; margin-top: 1em">If <i>mdadm</i>
was told to monitor an array which is RAID0 or Linear, then
it will report <b>DeviceDisappeared</b> with the extra
information <b>Wrong-Level</b>. This is because RAID0 and
Linear do not support the device-failed, hot-spare and
resync operations which are monitored.</p>

<p style="margin-left:17%;"><b>RebuildStarted</b></p>

<p style="margin-left:28%;">An md array started
reconstruction. (syslog priority: Warning)</p>

<p style="margin-left:17%;"><b>Rebuild</b><i>NN</i></p>

<p style="margin-left:28%;">Where <i>NN</i> is a two-digit
number (ie. 05, 48). This indicates that rebuild has passed
that many percent of the total. The events are generated
with fixed increment since 0. Increment size may be
specified with a commandline option (default is 20). (syslog
priority: Warning)</p>

<p style="margin-left:17%;"><b>RebuildFinished</b></p>

<p style="margin-left:28%;">An md array that was
rebuilding, isn&rsquo;t any more, either because it finished
normally or was aborted. (syslog priority: Warning)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="6%">


<p><b>Fail</b></p></td>
<td width="5%"></td>
<td width="72%">


<p>An active component device of an array has been marked
as faulty. (syslog priority: Critical)</p></td></tr>
</table>

<p style="margin-left:17%;"><b>FailSpare</b></p>

<p style="margin-left:28%;">A spare component device which
was being rebuilt to replace a faulty device has failed.
(syslog priority: Critical)</p>

<p style="margin-left:17%;"><b>SpareActive</b></p>

<p style="margin-left:28%;">A spare component device which
was being rebuilt to replace a faulty device has been
successfully rebuilt and has been made active. (syslog
priority: Info)</p>

<p style="margin-left:17%;"><b>NewArray</b></p>

<p style="margin-left:28%;">A new md array has been
detected in the <b>/proc/mdstat</b> file. (syslog priority:
Info)</p>

<p style="margin-left:17%;"><b>DegradedArray</b></p>

<p style="margin-left:28%;">A newly noticed array appears
to be degraded. This message is not generated when
<i>mdadm</i> notices a drive failure which causes
degradation, but only when <i>mdadm</i> notices that an
array is degraded when it first sees the array. (syslog
priority: Critical)</p>

<p style="margin-left:17%;"><b>MoveSpare</b></p>

<p style="margin-left:28%;">A spare drive has been moved
from one array in a <b>spare-group</b> or <b>domain</b> to
another to allow a failed drive to be replaced. (syslog
priority: Info)</p>

<p style="margin-left:17%;"><b>SparesMissing</b></p>

<p style="margin-left:28%;">If <i>mdadm</i> has been told,
via the config file, that an array should have a certain
number of spare devices, and <i>mdadm</i> detects that it
has fewer than this number when it first sees the array, it
will report a <b>SparesMissing</b> message. (syslog
priority: Warning)</p>

<p style="margin-left:17%;"><b>TestMessage</b></p>

<p style="margin-left:28%;">An array was found at startup,
and the <b>&minus;&minus;test</b> flag was given. (syslog
priority: Info)</p>

<p style="margin-left:11%; margin-top: 1em">Only <b>Fail,
FailSpare, DegradedArray, SparesMissing</b> and
<b>TestMessage</b> cause Email to be sent. All events cause
the program to be run. The program is run with two or three
arguments: the event name, the array device and possibly a
second device.</p>

<p style="margin-left:11%; margin-top: 1em">Each event has
an associated array device (e.g. <b>/dev/md1</b>) and
possibly a second device. For <b>Fail</b>, <b>FailSpare</b>,
and <b>SpareActive</b> the second device is the relevant
component device. For <b>MoveSpare</b> the second device is
the array that the spare was moved from.</p>

<p style="margin-left:11%; margin-top: 1em">For
<i>mdadm</i> to move spares from one array to another, the
different arrays need to be labeled with the same
<b>spare-group</b> or the spares must be allowed to migrate
through matching POLICY domains in the configuration file.
The <b>spare-group</b> name can be any string; it is only
necessary that different spare groups use different
names.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>mdadm</i> detects that an array in a spare group has
fewer active devices than necessary for the complete array,
and has no spare devices, it will look for another array in
the same spare group that has a full complement of working
drive and a spare. It will then attempt to remove the spare
from the second drive and add it to the first. If the
removal succeeds but the adding fails, then it is added back
to the original array.</p>

<p style="margin-left:11%; margin-top: 1em">If the spare
group for a degraded array is not defined, <i>mdadm</i> will
look at the rules of spare migration specified by POLICY
lines in <b>mdadm.conf</b> and then follow similar steps as
above if a matching spare is found.</p>

<h2>GROW MODE
<a name="GROW MODE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The GROW mode
is used for changing the size or shape of an active array.
For this to work, the kernel must support the necessary
change. Various types of growth are being added during 2.6
development.</p>

<p style="margin-left:11%; margin-top: 1em">Currently the
supported changes include</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>change the &quot;size&quot; attribute for RAID1, RAID4,
RAID5 and RAID6.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>increase or decrease the &quot;raid&minus;devices&quot;
attribute of RAID0, RAID1, RAID4, RAID5, and RAID6.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>change the chunk-size and layout of RAID0, RAID4, RAID5
and RAID6.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>convert between RAID1 and RAID5, between RAID5 and
RAID6, between RAID0, RAID4, and RAID5, and between RAID0
and RAID10 (in the near-2 mode).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>add a write-intent bitmap to any array which supports
these bitmaps, or remove a write-intent bitmap from such an
array.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Using GROW on
containers is currently supported only for Intel&rsquo;s
IMSM container format. The number of devices in a container
can be increased - which affects all arrays in the container
- or an array in a container can be converted between levels
where those levels are supported by the container, and the
conversion is on of those listed above. Resizing arrays in
an IMSM container with <b>--grow --size</b> is not yet
supported.</p>

<p style="margin-left:11%; margin-top: 1em">Grow
functionality (e.g. expand a number of raid devices) for
Intel&rsquo;s IMSM container format has an experimental
status. It is guarded by the <b>MDADM_EXPERIMENTAL</b>
environment variable which must be set to &rsquo;1&rsquo;
for a GROW command to succeed. This is for the following
reasons:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Intel&rsquo;s native IMSM
check-pointing is not fully tested yet. This can causes IMSM
incompatibility during the grow process: an array which is
growing cannot roam between Microsoft Windows(R) and Linux
systems.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="8%"></td>
<td width="78%">


<p>Interrupting a grow operation is not recommended,
because it has not been fully tested for Intel&rsquo;s IMSM
container format yet.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note:
Intel&rsquo;s native checkpointing doesn&rsquo;t use
<b>--backup-file</b> option and it is transparent for
assembly feature.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIZE
CHANGES</b> <br>
Normally when an array is built the &quot;size&quot; is
taken from the smallest of the drives. If all the small
drives in an arrays are, one at a time, removed and replaced
with larger drives, then you could have an array of large
drives with only a small amount used. In this situation,
changing the &quot;size&quot; with &quot;GROW&quot; mode
will allow the extra space to start being used. If the size
is increased in this way, a &quot;resync&quot; process will
start to make sure the new parts of the array are
synchronised.</p>

<p style="margin-left:11%; margin-top: 1em">Note that when
an array changes size, any filesystem that may be stored in
the array will not automatically grow or shrink to use or
vacate the space. The filesystem will need to be explicitly
told to use the extra space after growing, or to reduce its
size <b>prior</b> to shrinking the array.</p>

<p style="margin-left:11%; margin-top: 1em">Also the size
of an array cannot be changed while it has an active bitmap.
If an array has a bitmap, it must be removed before the size
can be changed. Once the change is complete a new bitmap can
be created.</p>


<p style="margin-left:11%; margin-top: 1em"><b>RAID&minus;DEVICES
CHANGES</b> <br>
A RAID1 array can work with any number of devices from 1
upwards (though 1 is not very useful). There may be times
which you want to increase or decrease the number of active
devices. Note that this is different to hot-add or
hot-remove which changes the number of inactive devices.</p>

<p style="margin-left:11%; margin-top: 1em">When reducing
the number of devices in a RAID1 array, the slots which are
to be removed from the array must already be vacant. That
is, the devices which were in those slots must be failed and
removed.</p>

<p style="margin-left:11%; margin-top: 1em">When the number
of devices is increased, any hot spares that are present
will be activated immediately.</p>

<p style="margin-left:11%; margin-top: 1em">Changing the
number of active devices in a RAID5 or RAID6 is much more
effort. Every block in the array will need to be read and
written back to a new location. From 2.6.17, the Linux
Kernel is able to increase the number of devices in a RAID5
safely, including restarting an interrupted
&quot;reshape&quot;. From 2.6.31, the Linux Kernel is able
to increase or decrease the number of devices in a RAID5 or
RAID6.</p>

<p style="margin-left:11%; margin-top: 1em">From 2.6.35,
the Linux Kernel is able to convert a RAID0 in to a RAID4 or
RAID5. <i>mdadm</i> uses this functionality and the ability
to add devices to a RAID4 to allow devices to be added to a
RAID0. When requested to do this, <i>mdadm</i> will convert
the RAID0 to a RAID4, add the necessary disks and make the
reshape happen, and then convert the RAID4 back to
RAID0.</p>

<p style="margin-left:11%; margin-top: 1em">When decreasing
the number of devices, the size of the array will also
decrease. If there was data in the array, it could get
destroyed and this is not reversible, so you should firstly
shrink the filesystem on the array to fit within the new
size. To help prevent accidents, <i>mdadm</i> requires that
the size of the array be decreased first with <b>mdadm
--grow --array-size</b>. This is a reversible change which
simply makes the end of the array inaccessible. The
integrity of any data can then be checked before the
non-reversible reduction in the number of devices is
request.</p>

<p style="margin-left:11%; margin-top: 1em">When relocating
the first few stripes on a RAID5 or RAID6, it is not
possible to keep the data on disk completely consistent and
crash-proof. To provide the required safety, mdadm disables
writes to the array while this &quot;critical section&quot;
is reshaped, and takes a backup of the data that is in that
section. For grows, this backup may be stored in any spare
devices that the array has, however it can also be stored in
a separate file specified with the
<b>&minus;&minus;backup&minus;file</b> option, and is
required to be specified for shrinks, RAID level changes and
layout changes. If this option is used, and the system does
crash during the critical period, the same file must be
passed to <b>&minus;&minus;assemble</b> to restore the
backup and reassemble the array. When shrinking rather than
growing the array, the reshape is done from the end towards
the beginning, so the &quot;critical section&quot; is at the
end of the reshape.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LEVEL
CHANGES</b> <br>
Changing the RAID level of any array happens
instantaneously. However in the RAID5 to RAID6 case this
requires a non-standard layout of the RAID6 data, and in the
RAID6 to RAID5 case that non-standard layout is required
before the change can be accomplished. So while the level
change is instant, the accompanying layout change can take
quite a long time. A <b>&minus;&minus;backup&minus;file</b>
is required. If the array is not simultaneously being grown
or shrunk, so that the array size will remain the same - for
example, reshaping a 3-drive RAID5 into a 4-drive RAID6 -
the backup file will be used not just for a &quot;cricital
section&quot; but throughout the reshape operation, as
described below under LAYOUT CHANGES.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CHUNK-SIZE
AND LAYOUT CHANGES</b> <br>
Changing the chunk-size of layout without also changing the
number of devices as the same time will involve re-writing
all blocks in-place. To ensure against data loss in the case
of a crash, a <b>--backup-file</b> must be provided for
these changes. Small sections of the array will be copied to
the backup file while they are being rearranged. This means
that all the data is copied twice, once to the backup and
once to the new layout on the array, so this type of reshape
will go very slowly.</p>

<p style="margin-left:11%; margin-top: 1em">If the reshape
is interrupted for any reason, this backup file must be made
available to <b>mdadm --assemble</b> so the array can be
reassembled. Consequently the file cannot be stored on the
device being reshaped.</p>

<p style="margin-left:11%; margin-top: 1em"><b>BITMAP
CHANGES</b> <br>
A write-intent bitmap can be added to, or removed from, an
active array. Either internal bitmaps, or bitmaps stored in
a separate file, can be added. Note that if you add a bitmap
stored in a file which is in a filesystem that is on the
RAID array being affected, the system will deadlock. The
bitmap must be on a separate filesystem.</p>

<h2>INCREMENTAL MODE
<a name="INCREMENTAL MODE"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="40%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;incremental</b></p> </td>
<td width="1%"></td>
<td width="48%">


<p style="margin-top: 1em">[<b>&minus;&minus;run</b>]
[<b>&minus;&minus;quiet</b>] <i>component-device</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="40%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;incremental</b></p> </td>
<td width="12%"></td>
<td width="25%"></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;&minus;fail</b>
<i>component-device</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="60%">


<p style="margin-top: 1em">Usage: <b>mdadm
&minus;&minus;incremental</b></p> </td>
<td width="29%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;rebuild&minus;map</b></p>

<p style="margin-left:11%; margin-top: 1em">Usage: <b>mdadm
&minus;&minus;incremental &minus;&minus;run
&minus;&minus;scan</b></p>

<p style="margin-left:11%; margin-top: 1em">This mode is
designed to be used in conjunction with a device discovery
system. As devices are found in a system, they can be passed
to <b>mdadm &minus;&minus;incremental</b> to be
conditionally added to an appropriate array.</p>

<p style="margin-left:11%; margin-top: 1em">Conversely, it
can also be used with the <b>&minus;&minus;fail</b> flag to
do just the opposite and find whatever array a particular
device is part of and remove the device from that array.</p>

<p style="margin-left:11%; margin-top: 1em">If the device
passed is a <b>CONTAINER</b> device created by a previous
call to <i>mdadm</i>, then rather than trying to add that
device to an array, all the arrays described by the metadata
of the container will be started.</p>

<p style="margin-left:11%; margin-top: 1em"><i>mdadm</i>
performs a number of tests to determine if the device is
part of an array, and which array it should be part of. If
an appropriate array is found, or can be created,
<i>mdadm</i> adds the device to the array and conditionally
starts the array.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<i>mdadm</i> will normally only add devices to an array
which were previously working (active or spare) parts of
that array. The support for automatic inclusion of a new
drive as a spare in some array requires a configuration
through POLICY in config file.</p>

<p style="margin-left:11%; margin-top: 1em">The tests that
<i>mdadm</i> makes are as follow:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">+</p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">Is the device permitted by
<b>mdadm.conf</b>? That is, is it listed in a <b>DEVICES</b>
line in that file. If <b>DEVICES</b> is absent then the
default it to allow any device. Similar if <b>DEVICES</b>
contains the special word <b>partitions</b> then any device
is allowed. Otherwise the device name given to <i>mdadm</i>
must match one of the names or patterns in a <b>DEVICES</b>
line.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>+</p></td>
<td width="10%"></td>
<td width="78%">


<p>Does the device have a valid md superblock? If a
specific metadata version is requested with
<b>&minus;&minus;metadata</b> or <b>&minus;e</b> then only
that style of metadata is accepted, otherwise <i>mdadm</i>
finds any known version of metadata. If no <i>md</i>
metadata is found, the device may be still added to an array
as a spare if POLICY allows.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>mdadm</i>
keeps a list of arrays that it has partially assembled in
<b>/run/mdadm/map</b>. If no array exists which matches the
metadata on the new device, <i>mdadm</i> must choose a
device name and unit number. It does this based on any name
given in <b>mdadm.conf</b> or any name information stored in
the metadata. If this name suggests a unit number, that
number will be used, otherwise a free unit number will be
chosen. Normally <i>mdadm</i> will prefer to create a
partitionable array, however if the <b>CREATE</b> line in
<b>mdadm.conf</b> suggests that a non-partitionable array is
preferred, that will be honoured.</p>

<p style="margin-left:11%; margin-top: 1em">If the array is
not found in the config file and its metadata does not
identify it as belonging to the &quot;homehost&quot;, then
<i>mdadm</i> will choose a name for the array which is
certain not to conflict with any array which does belong to
this host. It does this be adding an underscore and a small
number to the name preferred by the metadata.</p>

<p style="margin-left:11%; margin-top: 1em">Once an
appropriate array is found or created and the device is
added, <i>mdadm</i> must decide if the array is ready to be
started. It will normally compare the number of available
(non-spare) devices to the number of devices that the
metadata suggests need to be active. If there are at least
that many, the array will be started. This means that if any
devices are missing the array will not be restarted.</p>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, <b>&minus;&minus;run</b> may be passed to
<i>mdadm</i> in which case the array will be run as soon as
there are enough devices present for the data to be
accessible. For a RAID1, that means one device will start
the array. For a clean RAID5, the array will be started as
soon as all but one drive is present.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
neither of these approaches is really ideal. If it can be
known that all device discovery has completed, then <b><br>
mdadm &minus;IRs</b> <br>
can be run which will try to start all arrays that are being
incrementally assembled. They are started in
&quot;read-auto&quot; mode in which they are read-only until
the first write request. This means that no metadata updates
are made and no attempt at resync or recovery happens.
Further devices that are found before the first write can
still be added safely.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
describes environment variables that affect how mdadm
operates. <b><br>
MDADM_NO_MDMON</b></p>

<p style="margin-left:22%;">Setting this value to 1 will
prevent mdadm from automatically launching mdmon. This
variable is intended primarily for debugging
mdadm/mdmon.</p>

<p style="margin-left:11%;"><b>MDADM_NO_UDEV</b></p>

<p style="margin-left:22%;">Normally, <i>mdadm</i> does not
create any device nodes in /dev, but leaves that task to
<i>udev</i>. If <i>udev</i> appears not to be configured, or
if this environment variable is set to &rsquo;1&rsquo;, the
<i>mdadm</i> will create and devices that are needed.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;query /dev/name-of-device</b> <br>
This will find out if a given device is a RAID array, or is
part of one, and will provide brief information about the
device.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;assemble &minus;&minus;scan</b> <br>
This will assemble and start all arrays listed in the
standard config file. This command will typically go in a
system startup file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;stop &minus;&minus;scan</b> <br>
This will shut down all arrays that can be shut down (i.e.
are not currently in use). This will typically go in a
system shutdown script.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;follow &minus;&minus;scan
&minus;&minus;delay=120</b> <br>
If (and only if) there is an Email address or program given
in the standard config file, then monitor the status of all
arrays listed in that file by polling them ever 2
minutes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;create /dev/md0 &minus;&minus;level=1
&minus;&minus;raid&minus;devices=2 /dev/hd[ac]1</b> <br>
Create /dev/md0 as a RAID1 array consisting of /dev/hda1 and
/dev/hdc1.</p>

<p style="margin-left:11%; margin-top: 1em"><b>echo
&rsquo;DEVICE /dev/hd*[0&minus;9] /dev/sd*[0&minus;9]&rsquo;
&gt; mdadm.conf <br>
mdadm &minus;&minus;detail &minus;&minus;scan &gt;&gt;
mdadm.conf</b> <br>
This will create a prototype config file that describes
currently active arrays that are known to be made from
partitions of IDE or SCSI drives. This file should be
reviewed before being used as it may contain unwanted
detail.</p>

<p style="margin-left:11%; margin-top: 1em"><b>echo
&rsquo;DEVICE /dev/hd[a&minus;z] /dev/sd*[a&minus;z]&rsquo;
&gt; mdadm.conf <br>
mdadm &minus;&minus;examine &minus;&minus;scan
&minus;&minus;config=mdadm.conf &gt;&gt; mdadm.conf</b> <br>
This will find arrays which could be assembled from existing
IDE and SCSI whole drives (not partitions), and store the
information in the format of a config file. This file is
very likely to contain unwanted detail, particularly the
<b>devices=</b> entries. It should be reviewed and edited
before being used as an actual config file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;examine &minus;&minus;brief &minus;&minus;scan
&minus;&minus;config=partitions <br>
mdadm &minus;Ebsc partitions</b> <br>
Create a list of devices by reading <b>/proc/partitions</b>,
scan these for RAID superblocks, and printout a brief
listing of all that were found.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;Ac partitions &minus;m 0 /dev/md0</b> <br>
Scan all partitions and devices listed in
<b>/proc/partitions</b> and assemble <b>/dev/md0</b> out of
all such devices with a RAID superblock with a minor number
of 0.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;monitor &minus;&minus;scan
&minus;&minus;daemonise &gt; /run/mdadm/mon.pid</b> <br>
If config file contains a mail address or alert program, run
mdadm in the background in monitor mode monitoring all md
devices. Also write pid of mdadm daemon to
<b>/run/mdadm/mon.pid</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;Iq /dev/somedevice</b> <br>
Try to incorporate newly discovered device into some array
as appropriate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;incremental &minus;&minus;rebuild&minus;map
&minus;&minus;run &minus;&minus;scan</b> <br>
Rebuild the array map from any current arrays, and then
start any that can be started.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
/dev/md4 --fail detached --remove detached</b> <br>
Any devices which are components of /dev/md4 will be marked
as faulty and then remove from the array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm --grow
/dev/md4 --level=6 --backup-file=/root/backup-md4</b> <br>
The array <b>/dev/md4</b> which is currently a RAID5 array
will be converted to RAID6. There should normally already be
a spare drive attached to the array as a RAID6 needs one
more drive than a matching RAID5.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
--create /dev/md/ddf --metadata=ddf --raid-disks 6
/dev/sd[a-f]</b> <br>
Create a DDF array over 6 devices.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
--create /dev/md/home -n3 -l5 -z 30000000 /dev/md/ddf</b>
<br>
Create a RAID5 array over any 3 devices in the given DDF
set. Use only 30 gigabytes of each device.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm -A
/dev/md/ddf1 /dev/sd[a-f]</b> <br>
Assemble a pre-exist ddf array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm -I
/dev/md/ddf1</b> <br>
Assemble all arrays contained in the ddf array, assigning
names as appropriate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;create &minus;&minus;help</b> <br>
Provide help about the Create mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;config &minus;&minus;help</b> <br>
Provide help about the format of the config file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>mdadm
&minus;&minus;help</b> <br>
Provide general help.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>/proc/mdstat</b>
<br>
If you&rsquo;re using the <b>/proc</b> filesystem,
<b>/proc/mdstat</b> lists all active md devices with
information about them. <i>mdadm</i> uses this to find
arrays when <b>&minus;&minus;scan</b> is given in Misc mode,
and to monitor array reconstruction on Monitor mode.</p>


<p style="margin-left:11%; margin-top: 1em"><b>/etc/mdadm.conf</b>
<br>
The config file lists which devices may be scanned to see if
they contain MD super block, and gives identifying
information (e.g. UUID) about known MD arrays. See
<b>mdadm.conf</b>(5) for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>/run/mdadm/map</b>
<br>
When <b>&minus;&minus;incremental</b> mode is used, this
file gets a list of arrays currently being created.</p>

<h2>DEVICE NAMES
<a name="DEVICE NAMES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>mdadm</i>
understand two sorts of names for array devices.</p>

<p style="margin-left:11%; margin-top: 1em">The first is
the so-called &rsquo;standard&rsquo; format name, which
matches the names used by the kernel and which appear in
<i>/proc/mdstat</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The second sort
can be freely chosen, but must reside in <i>/dev/md/</i>.
When giving a device name to <i>mdadm</i> to create or
assemble an array, either full path name such as
<i>/dev/md0</i> or <i>/dev/md/home</i> can be given, or just
the suffix of the second sort of name, such as <i>home</i>
can be given.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>mdadm</i> chooses device names during auto-assembly or
incremental assembly, it will sometimes add a small sequence
number to the end of the name to avoid conflicted between
multiple arrays that have the same name. If <i>mdadm</i> can
reasonably determine that the array really is meant for this
host, either by a hostname in the metadata, or by the
presence of the array in <b>mdadm.conf</b>, then it will
leave off the suffix if possible. Also if the homehost is
specified as <b>&lt;ignore&gt;</b> <i>mdadm</i> will only
use a suffix if a different array of the same name already
exists or is listed in the config file.</p>

<p style="margin-left:11%; margin-top: 1em">The standard
names for non-partitioned arrays (the only sort of md array
available in 2.4 and earlier) are of the form</p>

<p style="margin-left:22%; margin-top: 1em">/dev/mdNN</p>

<p style="margin-left:11%; margin-top: 1em">where NN is a
number. The standard names for partitionable arrays (as
available from 2.6 onwards) are of the form</p>


<p style="margin-left:22%; margin-top: 1em">/dev/md_dNN</p>

<p style="margin-left:11%; margin-top: 1em">Partition
numbers should be indicated by added &quot;pMM&quot; to
these, thus &quot;/dev/md/d1p2&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">From kernel
version, 2.6.28 the &quot;non-partitioned array&quot; can
actually be partitioned. So the &quot;md_dNN&quot; names are
no longer needed, and partitions such as
&quot;/dev/mdNNpXX&quot; are possible.</p>

<h2>NOTE
<a name="NOTE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>mdadm</i>
was previously known as <i>mdctl</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>mdadm</i> is
completely separate from the <i>raidtools</i> package, and
does not use the <i>/etc/raidtab</i> configuration file at
all.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For further
information on mdadm usage, MD and the various levels of
RAID, see:</p>


<p style="margin-left:22%; margin-top: 1em"><b>http://raid.wiki.kernel.org/</b></p>

<p style="margin-left:11%; margin-top: 1em">(based upon
Jakob &Oslash;stergaard&rsquo;s
Software&minus;RAID.HOWTO)</p>

<p style="margin-left:11%; margin-top: 1em">The latest
version of <i>mdadm</i> should always be available from</p>


<p style="margin-left:22%; margin-top: 1em"><b>http://www.kernel.org/pub/linux/utils/raid/mdadm/</b></p>

<p style="margin-left:11%; margin-top: 1em">Related man
pages:</p>


<p style="margin-left:11%; margin-top: 1em"><i>mdmon</i>(8),
<i>mdadm.conf</i>(5), <i>md</i>(4).</p>


<p style="margin-left:11%; margin-top: 1em"><i>raidtab</i>(5),
<i>raid0run</i>(8), <i>raidstop</i>(8),
<i>mkraid</i>(8).</p>
<hr>
</body>
</html>
