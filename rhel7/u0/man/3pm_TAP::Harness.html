<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:29:05 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TAP::Harness</title>

</head>
<body>

<h1 align="center">TAP::Harness</h1>

<a href="#NAME">NAME</a><br>
<a href="#VERSION">VERSION</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#METHODS">METHODS</a><br>
<a href="#CONFIGURING">CONFIGURING</a><br>
<a href="#WRITING PLUGINS">WRITING PLUGINS</a><br>
<a href="#SUBCLASSING">SUBCLASSING</a><br>
<a href="#REPLACING">REPLACING</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">TAP::Harness
&minus; Run test scripts with statistics</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Version
3.28</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is a
simple test harness which allows tests to be run and results
automatically aggregated and output to
<small>STDOUT.</small></p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em"> use TAP::Harness;
 my $harness = TAP::Harness&minus;&gt;new( \%args );
 $harness&minus;&gt;runtests(@tests);</pre>


<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Class
Methods</b> <i><br>
&quot;new&quot;</i></p>

<pre style="margin-left:11%; margin-top: 1em"> my %args = (
    verbosity =&gt; 1,
    lib     =&gt; [ 'lib', 'blib/lib', 'blib/arch' ],
 )
 my $harness = TAP::Harness&minus;&gt;new( \%args );</pre>


<p style="margin-left:11%; margin-top: 1em">The constructor
returns a new <tt>&quot;TAP::Harness&quot;</tt> object. It
accepts an optional hashref whose allowed keys are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p><tt>&quot;verbosity&quot;</tt></p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Set the
verbosity level:</p>

<pre style="margin-left:17%; margin-top: 1em">     1   verbose        Print individual test results to STDOUT.
     0   normal
    &minus;1   quiet          Suppress some test output (mostly failures
                        while tests are running).
    &minus;2   really quiet   Suppress everything but the tests summary.
    &minus;3   silent         Suppress everything.</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;timer&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Append run time
for each test to output. Uses Time::HiRes if available.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;failures&quot;</tt></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Show test
failures (this is a no-op if <tt>&quot;verbose&quot;</tt> is
selected).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;comments&quot;</tt></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Show test
comments (this is a no-op if <tt>&quot;verbose&quot;</tt> is
selected).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">



<p style="margin-top: 1em"><tt>&quot;show_count&quot;</tt></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Update the
running test count during testing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><tt>&quot;normalize&quot;</tt></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Set to a true
value to normalize the <small>TAP</small> that is emitted in
verbose modes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><tt>&quot;lib&quot;</tt></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Accepts a
scalar value or array ref of scalar values indicating which
paths to allowed libraries should be included if Perl tests
are executed. Naturally, this only makes sense in the
context of tests written in Perl.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">



<p style="margin-top: 1em"><tt>&quot;switches&quot;</tt></p> </td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Accepts a
scalar value or array ref of scalar values indicating which
switches should be included if Perl tests are executed.
Naturally, this only makes sense in the context of tests
written in Perl.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><tt>&quot;test_args&quot;</tt></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A reference to
an <tt>@INC</tt> style array of arguments to be passed to
each test program.</p>

<pre style="margin-left:17%; margin-top: 1em">  test_args =&gt; ['foo', 'bar'],</pre>


<p style="margin-left:17%; margin-top: 1em">if you want to
pass different arguments to each test then you should pass a
hash of arrays, keyed by the alias for each test:</p>

<pre style="margin-left:17%; margin-top: 1em">  test_args =&gt; {
    my_test    =&gt; ['foo', 'bar'],
    other_test =&gt; ['baz'],
  }</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;color&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Attempt to
produce color output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;exec&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Typically, Perl
tests are run through this. However, anything which spits
out <small>TAP</small> is fine. You can use this argument to
specify the name of the program (and optional switches) to
run your tests with:</p>

<pre style="margin-left:17%; margin-top: 1em">  exec =&gt; ['/usr/bin/ruby', '&minus;w']</pre>


<p style="margin-left:17%; margin-top: 1em">You can also
pass a subroutine reference in order to determine and return
the proper program to run based on a given test script. The
subroutine reference should expect the TAP::Harness object
itself as the first argument, and the file name as the
second argument. It should return an array reference
containing the command to be run and including the test file
name. It can also simply return <tt>&quot;undef&quot;</tt>,
in which case TAP::Harness will fall back on executing the
test script in Perl:</p>

<pre style="margin-left:17%; margin-top: 1em">    exec =&gt; sub {
        my ( $harness, $test_file ) = @_;
        # Let Perl tests run.
        return undef if $test_file =~ /[.]t$/;
        return [ qw( /usr/bin/ruby &minus;w ), $test_file ]
          if $test_file =~ /[.]rb$/;
      }</pre>


<p style="margin-left:17%; margin-top: 1em">If the
subroutine returns a scalar with a newline or a filehandle,
it will be interpreted as raw <small>TAP</small> or as a
<small>TAP</small> stream, respectively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;merge&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If
<tt>&quot;merge&quot;</tt> is true the harness will create
parsers that merge <small>STDOUT</small> and
<small>STDERR</small> together for any processes they
start.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;sources&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>NEW</small>
to 3.18</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If set,
<tt>&quot;sources&quot;</tt> must be a hashref containing
the names of the TAP::Parser::SourceHandlers to load and/or
configure. The values are a hash of configuration that will
be accessible to to the source handlers via
&quot;config_for&quot; in TAP::Parser::Source.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<pre style="margin-left:17%; margin-top: 1em">  sources =&gt; {
    Perl =&gt; { exec =&gt; '/path/to/custom/perl' },
    File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },
    MyCustom =&gt; { some =&gt; 'config' },
  }</pre>


<p style="margin-left:17%; margin-top: 1em">The
<tt>&quot;sources&quot;</tt> parameter affects how
<tt>&quot;source&quot;</tt>, <tt>&quot;tap&quot;</tt> and
<tt>&quot;exec&quot;</tt> parameters are handled.</p>

<p style="margin-left:17%; margin-top: 1em">For more
details, see the <tt>&quot;sources&quot;</tt> parameter in
&quot;new&quot; in TAP::Parser, TAP::Parser::Source, and
TAP::Parser::IteratorFactory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">



<p style="margin-top: 1em"><tt>&quot;aggregator_class&quot;</tt></p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The name of the
class to use to aggregate test results. The default is
TAP::Parser::Aggregator.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><tt>&quot;version&quot;</tt></p> </td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>NEW</small>
to 3.22</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Assume this
<small>TAP</small> version for TAP::Parser instead of
default <small>TAP</small> version 12.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">



<p style="margin-top: 1em"><tt>&quot;formatter_class&quot;</tt></p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The name of the
class to use to format output. The default is
TAP::Formatter::Console, or TAP::Formatter::File if the
output isn&rsquo;t a <small>TTY.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="29%">



<p style="margin-top: 1em"><tt>&quot;multiplexer_class&quot;</tt></p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The name of the
class to use to multiplex tests during parallel testing. The
default is TAP::Parser::Multiplexer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">



<p style="margin-top: 1em"><tt>&quot;parser_class&quot;</tt></p> </td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The name of the
class to use to parse <small>TAP.</small> The default is
TAP::Parser.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">



<p style="margin-top: 1em"><tt>&quot;scheduler_class&quot;</tt></p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The name of the
class to use to schedule test execution. The default is
TAP::Parser::Scheduler.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><tt>&quot;formatter&quot;</tt></p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If set
<tt>&quot;formatter&quot;</tt> must be an object that is
capable of formatting the <small>TAP</small> output. See
TAP::Formatter::Console for an example.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p style="margin-top: 1em"><tt>&quot;errors&quot;</tt></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If parse errors
are found in the <small>TAP</small> output, a note of this
will be made in the summary report. To see all of the parse
errors, set this argument to true:</p>

<pre style="margin-left:17%; margin-top: 1em">  errors =&gt; 1</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">



<p style="margin-top: 1em"><tt>&quot;directives&quot;</tt></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If set to a
true value, only test results with directives will be
displayed. This overrides other settings such as
<tt>&quot;verbose&quot;</tt> or
<tt>&quot;failures&quot;</tt>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="20%">



<p style="margin-top: 1em"><tt>&quot;ignore_exit&quot;</tt></p> </td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If set to a
true value instruct <tt>&quot;TAP::Parser&quot;</tt> to
ignore exit and wait status from test scripts.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;jobs&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The maximum
number of parallel tests to run at any time. Which tests can
be run in parallel is controlled by
<tt>&quot;rules&quot;</tt>. The default is to run only one
test at a time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><tt>&quot;rules&quot;</tt></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A reference to
a hash of rules that control which tests may be executed in
parallel. If no rules are declared, all tests are eligible
for being run in parallel. Here some simple examples. For
the full details of the data structure and the related
glob-style pattern matching, see &quot;Rules data
structure&quot; in TAP::Parser::Scheduler.</p>

<pre style="margin-left:17%; margin-top: 1em">    # Run all tests in sequence, except those starting with &quot;p&quot;
    $harness&minus;&gt;rules({
        par =&gt; 't/p*.t'
    });
    # Run all tests in parallel, except those starting with &quot;p&quot;
    $harness&minus;&gt;rules({
        seq =&gt; [
                  { seq =&gt; 't/p*.t' },
                  { par =&gt; '**'     },
               ],
    });
    # Run some  startup tests in sequence, then some parallel tests than some
    # teardown tests in sequence.
    $harness&minus;&gt;rules({
        seq =&gt; [
            { seq =&gt; 't/startup/*.t' },
            { par =&gt; ['t/a/*.t','t/b/*.t','t/c/*.t'], }
            { seq =&gt; 't/shutdown/*.t' },
        ],
    });</pre>


<p style="margin-left:17%; margin-top: 1em">This is an
experimental feature and the interface may change.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p style="margin-top: 1em"><tt>&quot;stdout&quot;</tt></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A filehandle
for catching standard output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><tt>&quot;trap&quot;</tt></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Attempt to
print summary information if run is interrupted by
<small>SIGINT</small> (Ctrl-C).</p>

<p style="margin-left:11%; margin-top: 1em">Any keys for
which the value is <tt>&quot;undef&quot;</tt> will be
ignored.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Instance
Methods</b> <i><br>
&quot;runtests&quot;</i></p>

<pre style="margin-left:11%; margin-top: 1em">    $harness&minus;&gt;runtests(@tests);</pre>


<p style="margin-left:11%; margin-top: 1em">Accepts an
array of <tt>@tests</tt> to be run. This should generally be
the names of test files, but this is not required. Each
element in <tt>@tests</tt> will be passed to
<tt>&quot;TAP::Parser::new()&quot;</tt> as a
<tt>&quot;source&quot;</tt>. See TAP::Parser for more
information.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to provide aliases that will be displayed in place of the
test name by supplying the test as a reference to an array
containing <tt>&quot;[ $test, $alias ]&quot;</tt>:</p>

<pre style="margin-left:11%; margin-top: 1em">    $harness&minus;&gt;runtests( [ 't/foo.t', 'Foo Once' ],
                        [ 't/foo.t', 'Foo Twice' ] );</pre>


<p style="margin-left:11%; margin-top: 1em">Normally it is
an error to attempt to run the same test twice. Aliases
allow you to overcome this limitation by giving each run of
the test a unique name.</p>

<p style="margin-left:11%; margin-top: 1em">Tests will be
run in the order found.</p>

<p style="margin-left:11%; margin-top: 1em">If the
environment variable
<tt>&quot;PERL_TEST_HARNESS_DUMP_TAP&quot;</tt> is defined
it should name a directory into which a copy of the raw
<small>TAP</small> for each test will be written.
<small>TAP</small> is written to files named for each test.
Subdirectories will be created as needed.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
TAP::Parser::Aggregator containing the test results.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;summary&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $harness&minus;&gt;summary( $aggregator );</pre>


<p style="margin-left:11%; margin-top: 1em">Output the
summary for a TAP::Parser::Aggregator.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;aggregate_tests&quot;</i></p>


<pre style="margin-left:11%; margin-top: 1em">  $harness&minus;&gt;aggregate_tests( $aggregate, @tests );</pre>


<p style="margin-left:11%; margin-top: 1em">Run the named
tests and display a summary of result. Tests will be run in
the order found.</p>

<p style="margin-left:11%; margin-top: 1em">Test results
will be added to the supplied TAP::Parser::Aggregator.
<tt>&quot;aggregate_tests&quot;</tt> may be called multiple
times to run several sets of tests. Multiple
<tt>&quot;Test::Harness&quot;</tt> instances may be used to
pass results to a single aggregator so that different parts
of a complex test suite may be run using different
<tt>&quot;TAP::Harness&quot;</tt> settings. This is useful,
for example, in the case where some tests should run in
parallel but others are unsuitable for parallel
execution.</p>

<pre style="margin-left:11%; margin-top: 1em">    my $formatter   = TAP::Formatter::Console&minus;&gt;new;
    my $ser_harness = TAP::Harness&minus;&gt;new( { formatter =&gt; $formatter } );
    my $par_harness = TAP::Harness&minus;&gt;new(
        {   formatter =&gt; $formatter,
            jobs      =&gt; 9
        }
    );
    my $aggregator = TAP::Parser::Aggregator&minus;&gt;new;
    $aggregator&minus;&gt;start();
    $ser_harness&minus;&gt;aggregate_tests( $aggregator, @ser_tests );
    $par_harness&minus;&gt;aggregate_tests( $aggregator, @par_tests );
    $aggregator&minus;&gt;stop();
    $formatter&minus;&gt;summary($aggregator);</pre>


<p style="margin-left:11%; margin-top: 1em">Note that for
simpler testing requirements it will often be possible to
replace the above code with a single call to
<tt>&quot;runtests&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">Each element of
the <tt>@tests</tt> array is either:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="80%">


<p style="margin-top: 1em">the source name of a test to
run</p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="80%">


<p>a reference to a [ source name, display name ] array</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the case of
a perl test suite, typically <i>source names</i> are simply
the file names of the test scripts to run.</p>

<p style="margin-left:11%; margin-top: 1em">When you supply
a separate display name it becomes possible to run a test
more than once; the display name is effectively the alias by
which the test is known inside the harness. The harness
doesn&rsquo;t care if it runs the same test more than once
when each invocation uses a different name.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_scheduler&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Called by the
harness when it needs to create a TAP::Parser::Scheduler.
Override in a subclass to provide an alternative scheduler.
<tt>&quot;make_scheduler&quot;</tt> is passed the list of
tests that was passed to
<tt>&quot;aggregate_tests&quot;</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;jobs&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Gets or sets
the number of concurrent test runs the harness is handling.
By default, this value is 1 -- for parallel testing, this
should be set higher.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_parser&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Make a new
parser and display formatter session. Typically used and/or
overridden in subclasses.</p>

<pre style="margin-left:11%; margin-top: 1em">    my ( $parser, $session ) = $harness&minus;&gt;make_parser;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>&quot;finish_parser&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Terminate use
of a parser. Typically used and/or overridden in subclasses.
The parser isn&rsquo;t destroyed as a result of this.</p>

<h2>CONFIGURING
<a name="CONFIGURING"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><tt>&quot;TAP::Harness&quot;</tt>
is designed to be easy to configure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Plugins</b>
<tt><br>
&quot;TAP::Parser&quot;</tt> plugins let you change the way
<small>TAP</small> is <i>input</i> to and <i>output</i> from
the parser.</p>


<p style="margin-left:11%; margin-top: 1em">TAP::Parser::SourceHandlers
handle <small>TAP</small> <i>input</i>. You can configure
them and load custom handlers using the
<tt>&quot;sources&quot;</tt> parameter to
&quot;new&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">TAP::Formatters
handle <small>TAP</small> <i>output</i>. You can load custom
formatters by using the <tt>&quot;formatter_class&quot;</tt>
parameter to &quot;new&quot;. To configure a formatter, you
currently need to instantiate it outside of TAP::Harness and
pass it in with the <tt>&quot;formatter&quot;</tt> parameter
to &quot;new&quot;. This <i>may</i> be addressed by adding a
<i>formatters</i> parameter to &quot;new&quot; in the
future.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;Module::Build&quot;</b>
<br>
Module::Build version <tt>0.30</tt> supports
<tt>&quot;TAP::Harness&quot;</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">To load
<tt>&quot;TAP::Harness&quot;</tt> plugins, you&rsquo;ll need
to use the <tt>&quot;tap_harness_args&quot;</tt> parameter
to <tt>&quot;new&quot;</tt>, typically from your
<tt>&quot;Build.PL&quot;</tt>. For example:</p>

<pre style="margin-left:11%; margin-top: 1em">  Module::Build&minus;&gt;new(
      module_name        =&gt; 'MyApp',
      test_file_exts     =&gt; [qw(.t .tap .txt)],
      use_tap_harness    =&gt; 1,
      tap_harness_args   =&gt; {
          sources =&gt; {
              MyCustom =&gt; {},
              File =&gt; {
                  extensions =&gt; ['.tap', '.txt'],
              },
          },
          formatter_class =&gt; 'TAP::Formatter::HTML',
      },
      build_requires     =&gt; {
          'Module::Build' =&gt; '0.30',
          'TAP::Harness'  =&gt; '3.18',
      },
  )&minus;&gt;create_build_script;</pre>


<p style="margin-left:11%; margin-top: 1em">See
&quot;new&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ExtUtils::MakeMaker&quot;</b>
<br>
ExtUtils::MakeMaker does not support TAP::Harness
out-of-the-box.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;prove&quot;</b>
<br>
prove supports <tt>&quot;TAP::Harness&quot;</tt> plugins,
and has a plugin system of its own. See &quot;
<small>FORMATTERS&quot;</small> in prove, &quot;
<small>SOURCE HANDLERS&quot;</small> in prove and App::Prove
for more details.</p>

<h2>WRITING PLUGINS
<a name="WRITING PLUGINS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you
can&rsquo;t configure <tt>&quot;TAP::Harness&quot;</tt> to
do what you want, and you can&rsquo;t find an existing
plugin, consider writing one.</p>

<p style="margin-left:11%; margin-top: 1em">The two primary
use cases supported by TAP::Harness for plugins are
<i>input</i> and <i>output</i>: <br>
Customize how <small>TAP</small> gets into the parser</p>

<p style="margin-left:14%;">To do this, you can either
extend an existing TAP::Parser::SourceHandler, or write your
own. It&rsquo;s a pretty simple <small>API,</small> and they
can be loaded and configured using the
<tt>&quot;sources&quot;</tt> parameter to
&quot;new&quot;.</p>

<p style="margin-left:11%;">Customize how
<small>TAP</small> results are output from the parser</p>

<p style="margin-left:14%;">To do this, you can either
extend an existing TAP::Formatter, or write your own.
Writing formatters are a bit more involved than writing a
<i>SourceHandler</i>, as you&rsquo;ll need to understand the
TAP::Parser <small>API. A</small> good place to start is by
understanding how &quot;aggregate_tests&quot; works.</p>

<p style="margin-left:14%; margin-top: 1em">Custom
formatters can be loaded configured using the
<tt>&quot;formatter_class&quot;</tt> parameter to
&quot;new&quot;.</p>

<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you
can&rsquo;t configure <tt>&quot;TAP::Harness&quot;</tt> to
do exactly what you want, and writing a plugin isn&rsquo;t
an option, consider extending it. It is designed to be
(mostly) easy to subclass, though the cases when
sub-classing is necessary should be few and far between.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Methods</b>
<br>
The following methods are ones you may wish to override if
you want to subclass <tt>&quot;TAP::Harness&quot;</tt>. <br>
&quot;new&quot; <br>
&quot;runtests&quot; <br>
&quot;summary&quot;</p>

<h2>REPLACING
<a name="REPLACING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you like the
<tt>&quot;prove&quot;</tt> utility and TAP::Parser but you
want your own harness, all you need to do is write one and
provide <tt>&quot;new&quot;</tt> and
<tt>&quot;runtests&quot;</tt> methods. Then you can use the
<tt>&quot;prove&quot;</tt> utility like so:</p>

<pre style="margin-left:11%; margin-top: 1em"> prove &minus;&minus;harness My::Test::Harness</pre>


<p style="margin-left:11%; margin-top: 1em">Note that while
<tt>&quot;prove&quot;</tt> accepts a list of tests (or
things to be tested), <tt>&quot;new&quot;</tt> has a fairly
rich set of arguments. You&rsquo;ll probably want to read
over this code carefully to see how all of them are being
used.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Test::Harness</p>
<hr>
</body>
</html>
