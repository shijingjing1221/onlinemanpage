<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:05:30 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LWP</title>

</head>
<body>

<h1 align="center">LWP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#HTTP STYLE COMMUNICATION">HTTP STYLE COMMUNICATION</a><br>
<a href="#NETWORK SUPPORT">NETWORK SUPPORT</a><br>
<a href="#OVERVIEW OF CLASSES AND PACKAGES">OVERVIEW OF CLASSES AND PACKAGES</a><br>
<a href="#MORE DOCUMENTATION">MORE DOCUMENTATION</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#AVAILABILITY">AVAILABILITY</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">LWP &minus; The
World&minus;Wide Web library for Perl</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  use LWP;
  print &quot;This is libwww&minus;perl&minus;$LWP::VERSION\n&quot;;</pre>


<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The libwww-perl
collection is a set of Perl modules which provides a simple
and consistent application programming interface (
<small>API</small> ) to the World-Wide Web. The main focus
of the library is to provide classes and functions that
allow you to write <small>WWW</small> clients. The library
also contain modules that are of more general use and even
classes that help you implement simple <small>HTTP</small>
servers.</p>

<p style="margin-left:11%; margin-top: 1em">Most modules in
this library provide an object oriented <small>API.</small>
The user agent, requests sent and responses received from
the <small>WWW</small> server are all represented by
objects. This makes a simple and powerful interface to these
services. The interface is easy to extend and customize for
your own needs.</p>

<p style="margin-left:11%; margin-top: 1em">The main
features of the library are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Contains various reusable components (modules) that can
be used separately or together.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Provides an object oriented model of HTTP-style
communication. Within this framework we currently support
access to http, https, gopher, ftp, news, file, and mailto
resources.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Provides a full object oriented interface or a very
simple procedural interface.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Supports the basic and digest authorization schemes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Supports transparent redirect handling.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Supports access through proxy servers.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Provides parser for <i>robots.txt</i> files and a
framework for constructing robots.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Supports parsing of <small>HTML</small> forms.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Implements <small>HTTP</small> content negotiation
algorithm that can be used both in protocol modules and in
server scripts (like <small>CGI</small> scripts).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Supports <small>HTTP</small> cookies.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>Some simple command line clients, for instance
<tt>&quot;lwp&minus;request&quot;</tt> and
<tt>&quot;lwp&minus;download&quot;</tt>.</p> </td></tr>
</table>

<h2>HTTP STYLE COMMUNICATION
<a name="HTTP STYLE COMMUNICATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The libwww-perl
library is based on <small>HTTP</small> style communication.
This section tries to describe what that means.</p>

<p style="margin-left:11%; margin-top: 1em">Let us start
with this quote from the <small>HTTP</small> specification
document &lt;URL:http://www.w3.org/Protocols/&gt;:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">The <small>HTTP</small> protocol
is based on a request/response paradigm. A client
establishes a connection with a server and sends a request
to the server in the form of a request method,
<small>URI,</small> and protocol version, followed by a
MIME-like message containing request modifiers, client
information, and possible body content. The server responds
with a status line, including the message&rsquo;s protocol
version and a success or error code, followed by a MIME-like
message containing server information, entity
meta-information, and possible body content.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">What this means
to libwww-perl is that communication always take place
through these steps: First a <i>request</i> object is
created and configured. This object is then passed to a
server and we get a <i>response</i> object in return that we
can examine. A request is always independent of any previous
requests, i.e. the service is stateless. The same simple
model is used for any kind of service we want to access.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
we want to fetch a document from a remote file server, then
we send it a request that contains a name for that document
and the response will contain the document itself. If we
access a search engine, then the content of the request will
contain the query parameters and the response will contain
the query result. If we want to send a mail message to
somebody then we send a request object which contains our
message to the mail server and the response object will
contain an acknowledgment that tells us that the message has
been accepted and will be forwarded to the recipient(s).</p>

<p style="margin-left:11%; margin-top: 1em">It is as simple
as that!</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Request
Object</b> <br>
The libwww-perl request object has the class name
<tt>&quot;HTTP::Request&quot;</tt>. The fact that the class
name uses <tt>&quot;HTTP::&quot;</tt> as a prefix only
implies that we use the <small>HTTP</small> model of
communication. It does not limit the kind of services we can
try to pass this <i>request</i> to. For instance, we will
send <tt>&quot;HTTP::Request&quot;</tt>s both to ftp and
gopher servers, as well as to the local file system.</p>

<p style="margin-left:11%; margin-top: 1em">The main
attributes of the request objects are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>method</b> is a short string
that tells what kind of request this is. The most common
methods are <b><small>GET</small></b> ,
<b><small>PUT</small></b> , <b><small>POST</small></b> and
<b><small>HEAD</small></b> .</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>uri</b> is a string denoting the protocol, server and
the name of the &quot;document&quot; we want to access. The
<b>uri</b> might also encode various other parameters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>headers</b> contains additional information about the
request and can also used to describe the content. The
headers are a set of keyword/value pairs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>content</b> is an arbitrary amount of data.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>The Response
Object</b> <br>
The libwww-perl response object has the class name
<tt>&quot;HTTP::Response&quot;</tt>. The main attributes of
objects of this class are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>code</b> is a numerical value
that indicates the overall outcome of the request.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>message</b> is a short, human readable string that
corresponds to the <i>code</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>headers</b> contains additional information about the
response and describe the content.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>content</b> is an arbitrary amount of data.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Since we
don&rsquo;t want to handle all possible <i>code</i> values
directly in our programs, a libwww-perl response object has
methods that can be used to query what kind of response this
is. The most commonly used response classification methods
are: <i><br>
is_success()</i></p>

<p style="margin-left:15%;">The request was successfully
received, understood or accepted.</p>

<p style="margin-left:11%;"><i>is_error()</i></p>

<p style="margin-left:15%;">The request failed. The server
or the resource might not be available, access to the
resource might be denied or other things might have failed
for some reason.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The User
Agent</b> <br>
Let us assume that we have created a <i>request</i> object.
What do we actually do with it in order to receive a
<i>response</i>?</p>

<p style="margin-left:11%; margin-top: 1em">The answer is
that you pass it to a <i>user agent</i> object and this
object takes care of all the things that need to be done
(like low-level communication and error handling) and
returns a <i>response</i> object. The user agent represents
your application on the network and provides you with an
interface that can accept <i>requests</i> and return
<i>responses</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The user agent
is an interface layer between your application code and the
network. Through this interface you are able to access the
various servers on the network.</p>

<p style="margin-left:11%; margin-top: 1em">The class name
for the user agent is <tt>&quot;LWP::UserAgent&quot;</tt>.
Every libwww-perl application that wants to communicate
should create at least one object of this class. The main
method provided by this object is <i>request()</i>. This
method takes an <tt>&quot;HTTP::Request&quot;</tt> object as
argument and (eventually) returns a
<tt>&quot;HTTP::Response&quot;</tt> object.</p>

<p style="margin-left:11%; margin-top: 1em">The user agent
has many other attributes that let you configure how it will
interact with the network and with your application.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>timeout</b> specifies how much time we give remote
servers to respond before the library disconnects and
creates an internal <i>timeout</i> response.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>agent</b> specifies the name that your application
uses when it presents itself on the network.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>from</b> can be set to the e&minus;mail address of
the person responsible for running the application. If this
is set, then the address will be sent to the servers with
every request.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>parse_head</b> specifies whether we should initialize
response headers from the &lt;head&gt; section of
<small>HTML</small> documents.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>proxy</b> and <b>no_proxy</b> specify if and when to
go through a proxy server.
&lt;URL:http://www.w3.org/History/1994/WWW/Proxies/&gt;</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>credentials</b> provides a way to set up user names
and passwords needed to access certain services.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Many
applications want even more control over how they interact
with the network and they get this by sub-classing
<tt>&quot;LWP::UserAgent&quot;</tt>. The library includes a
sub-class, <tt>&quot;LWP::RobotUA&quot;</tt>, for robot
applications.</p>

<p style="margin-left:11%; margin-top: 1em"><b>An
Example</b> <br>
This example shows how the user agent, a request and a
response are represented in actual perl code:</p>

<pre style="margin-left:11%; margin-top: 1em">  # Create a user agent object
  use LWP::UserAgent;
  my $ua = LWP::UserAgent&minus;&gt;new;
  $ua&minus;&gt;agent(&quot;MyApp/0.1 &quot;);
  # Create a request
  my $req = HTTP::Request&minus;&gt;new(POST =&gt; 'http://search.cpan.org/search');
  $req&minus;&gt;content_type('application/x&minus;www&minus;form&minus;urlencoded');
  $req&minus;&gt;content('query=libwww&minus;perl&amp;mode=dist');
  # Pass request to the user agent and get a response back
  my $res = $ua&minus;&gt;request($req);
  # Check the outcome of the response
  if ($res&minus;&gt;is_success) {
      print $res&minus;&gt;content;
  }
  else {
      print $res&minus;&gt;status_line, &quot;\n&quot;;
  }</pre>


<p style="margin-left:11%; margin-top: 1em">The
<tt>$ua</tt> is created once when the application starts up.
New request objects should normally created for each request
sent.</p>

<h2>NETWORK SUPPORT
<a name="NETWORK SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
discusses the various protocol schemes and the
<small>HTTP</small> style methods that headers may be used
for each.</p>

<p style="margin-left:11%; margin-top: 1em">For all
requests, a &quot;User-Agent&quot; header is added and
initialized from the <tt>$ua</tt>&minus;&gt;agent attribute
before the request is handed to the network layer. In the
same way, a &quot;From&quot; header is initialized from the
<tt>$ua</tt>&minus;&gt;from attribute.</p>

<p style="margin-left:11%; margin-top: 1em">For all
responses, the library adds a header called
&quot;Client-Date&quot;. This header holds the time when the
response was received by your application. The format and
semantics of the header are the same as the server created
&quot;Date&quot; header. You may also encounter other
&quot;Client-XXX&quot; headers. They are all generated by
the library internally and are not received from the
servers.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>HTTP</small>
Requests</b> <small><br>
HTTP</small> requests are just handed off to an
<small>HTTP</small> server and it decides what happens. Few
servers implement methods beside the usual &quot;
<small>GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;</small>
and &quot; <small>PUT&quot;,</small> but CGI-scripts may
implement any method they like.</p>

<p style="margin-left:11%; margin-top: 1em">If the server
is not available then the library will generate an internal
error response.</p>

<p style="margin-left:11%; margin-top: 1em">The library
automatically adds a &quot;Host&quot; and a
&quot;Content-Length&quot; header to the <small>HTTP</small>
request before it is sent over the network.</p>

<p style="margin-left:11%; margin-top: 1em">For a
<small>GET</small> request you might want to add a
&quot;If-Modified-Since&quot; or &quot;If-None-Match&quot;
header to make the request conditional.</p>

<p style="margin-left:11%; margin-top: 1em">For a
<small>POST</small> request you should add the
&quot;Content-Type&quot; header. When you try to emulate
<small>HTML</small> &lt; <small>FORM</small> &gt; handling
you should usually let the value of the
&quot;Content-Type&quot; header be
&quot;application/x&minus;www&minus;form&minus;urlencoded&quot;.
See lwpcook for examples of this.</p>

<p style="margin-left:11%; margin-top: 1em">The libwww-perl
<small>HTTP</small> implementation currently support the
<small>HTTP/1.1</small> and <small>HTTP/1.0</small>
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The library
allows you to access proxy server through
<small>HTTP.</small> This means that you can set up the
library to forward all types of request through the
<small>HTTP</small> protocol module. See LWP::UserAgent for
documentation of this.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>HTTPS</small>
Requests</b> <small><br>
HTTPS</small> requests are <small>HTTP</small> requests over
an encrypted network connection using the <small>SSL</small>
protocol developed by Netscape. Everything about
<small>HTTP</small> requests above also apply to
<small>HTTPS</small> requests. In addition the library will
add the headers &quot;Client-SSL-Cipher&quot;,
&quot;Client-SSL-Cert-Subject&quot; and
&quot;Client-SSL-Cert-Issuer&quot; to the response. These
headers denote the encryption method used and the name of
the server owner.</p>

<p style="margin-left:11%; margin-top: 1em">The request can
contain the header &quot;If-SSL-Cert-Subject&quot; in order
to make the request conditional on the content of the server
certificate. If the certificate subject does not match, no
request is sent to the server and an internally generated
error response is returned. The value of the
&quot;If-SSL-Cert-Subject&quot; header is interpreted as a
Perl regular expression.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>FTP</small>
Requests</b> <br>
The library currently supports <small>GET, HEAD</small> and
<small>PUT</small> requests. <small>GET</small> retrieves a
file or a directory listing from an <small>FTP</small>
server. <small>PUT</small> stores a file on a ftp
server.</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
a ftp account for servers that want this in addition to user
name and password. This is specified by including an
&quot;Account&quot; header in the request.</p>

<p style="margin-left:11%; margin-top: 1em">User
name/password can be specified using basic authorization or
be encoded in the <small>URL.</small> Failed logins return
an <small>UNAUTHORIZED</small> response with
&quot;WWW-Authenticate: Basic&quot; and can be treated like
basic authorization for <small>HTTP.</small></p>

<p style="margin-left:11%; margin-top: 1em">The library
supports ftp <small>ASCII</small> transfer mode by
specifying the &quot;type=a&quot; parameter in the
<small>URL.</small> It also supports transfer of ranges for
<small>FTP</small> transfers using the &quot;Range&quot;
header.</p>

<p style="margin-left:11%; margin-top: 1em">Directory
listings are by default returned unprocessed (as returned
from the ftp server) with the content media type reported to
be &quot;text/ftp&minus;dir&minus;listing&quot;. The
<tt>&quot;File::Listing&quot;</tt> module provides methods
for parsing of these directory listing.</p>

<p style="margin-left:11%; margin-top: 1em">The ftp module
is also able to convert directory listings to
<small>HTML</small> and this can be requested via the
standard <small>HTTP</small> content negotiation mechanisms
(add an &quot;Accept: text/html&quot; header in the request
if you want this).</p>

<p style="margin-left:11%; margin-top: 1em">For normal file
retrievals, the &quot;Content-Type&quot; is guessed based on
the file name suffix. See LWP::MediaTypes.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;If-Modified-Since&quot; request header works for
servers that implement the <small>MDTM</small> command. It
will probably not work for directory listings though.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(GET =&gt; 'ftp://me:passwd@ftp.some.where.com/');
  $req&minus;&gt;header(Accept =&gt; &quot;text/html, */*;q=0.1&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>News
Requests</b> <br>
Access to the <small>USENET</small> News system is
implemented through the <small>NNTP</small> protocol. The
name of the news server is obtained from the
<small>NNTP_SERVER</small> environment variable and defaults
to &quot;news&quot;. It is not possible to specify the
hostname of the <small>NNTP</small> server in news:
URLs.</p>

<p style="margin-left:11%; margin-top: 1em">The library
supports <small>GET</small> and <small>HEAD</small> to
retrieve news articles through the <small>NNTP</small>
protocol. You can also post articles to newsgroups by using
(surprise!) the <small>POST</small> method.</p>


<p style="margin-left:11%; margin-top: 1em"><small>GET</small>
on newsgroups is not implemented yet.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(GET =&gt; 'news:abc1234@a.sn.no');
  $req = HTTP::Request&minus;&gt;new(POST =&gt; 'news:comp.lang.perl.test');
  $req&minus;&gt;header(Subject =&gt; 'This is a test',
               From    =&gt; 'me@some.where.org');
  $req&minus;&gt;content(&lt;&lt;EOT);
  This is the content of the message that we are sending to
  the world.
  EOT</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Gopher
Request</b> <br>
The library supports the <small>GET</small> and
<small>HEAD</small> methods for gopher requests. All request
header values are ignored. <small>HEAD</small> cheats and
returns a response without even talking to server.</p>

<p style="margin-left:11%; margin-top: 1em">Gopher menus
are always converted to <small>HTML.</small></p>

<p style="margin-left:11%; margin-top: 1em">The response
&quot;Content-Type&quot; is generated from the document type
encoded (as the first letter) in the request
<small>URL</small> path itself.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(GET =&gt; 'gopher://gopher.sn.no/');</pre>


<p style="margin-left:11%; margin-top: 1em"><b>File
Request</b> <br>
The library supports <small>GET</small> and
<small>HEAD</small> methods for file requests. The
&quot;If-Modified-Since&quot; header is supported. All other
headers are ignored. The <i>host</i> component of the file
<small>URL</small> must be empty or set to
&quot;localhost&quot;. Any other <i>host</i> value will be
treated as an error.</p>

<p style="margin-left:11%; margin-top: 1em">Directories are
always converted to an <small>HTML</small> document. For
normal files, the &quot;Content-Type&quot; and
&quot;Content-Encoding&quot; in the response are guessed
based on the file suffix.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(GET =&gt; 'file:/etc/passwd');</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Mailto
Request</b> <br>
You can send (aka &quot; <small>POST&quot;</small> ) mail
messages using the library. All headers specified for the
request are passed on to the mail system. The &quot;To&quot;
header is initialized from the mail address in the
<small>URL.</small></p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(POST =&gt; 'mailto:libwww@perl.org');
  $req&minus;&gt;header(Subject =&gt; &quot;subscribe&quot;);
  $req&minus;&gt;content(&quot;Please subscribe me to the libwww&minus;perl mailing list!\n&quot;);</pre>



<p style="margin-left:11%; margin-top: 1em"><b><small>CPAN</small>
Requests</b> <br>
URLs with scheme <tt>&quot;cpan:&quot;</tt> are redirected
to the a suitable <small>CPAN</small> mirror. If you have
your own local mirror of <small>CPAN</small> you might tell
<small>LWP</small> to use it for <tt>&quot;cpan:&quot;</tt>
URLs by an assignment like this:</p>

<pre style="margin-left:11%; margin-top: 1em">  $LWP::Protocol::cpan::CPAN = &quot;file:/local/CPAN/&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Suitable
<small>CPAN</small> mirrors are also picked up from the
configuration for the <small>CPAN</small> .pm, so if you
have used that module a suitable mirror should be picked
automatically. If neither of these apply, then a redirect to
the generic <small>CPAN</small> http location is issued.</p>

<p style="margin-left:11%; margin-top: 1em">Example request
to download the newest perl:</p>

<pre style="margin-left:11%; margin-top: 1em">  $req = HTTP::Request&minus;&gt;new(GET =&gt; &quot;cpan:src/latest.tar.gz&quot;);</pre>


<h2>OVERVIEW OF CLASSES AND PACKAGES
<a name="OVERVIEW OF CLASSES AND PACKAGES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This table
should give you a quick overview of the classes provided by
the library. Indentation shows class inheritance.</p>

<pre style="margin-left:11%; margin-top: 1em"> LWP::MemberMixin   &minus;&minus; Access to member variables of Perl5 classes
   LWP::UserAgent   &minus;&minus; WWW user agent class
     LWP::RobotUA   &minus;&minus; When developing a robot applications
   LWP::Protocol          &minus;&minus; Interface to various protocol schemes
     LWP::Protocol::http  &minus;&minus; http:// access
     LWP::Protocol::file  &minus;&minus; file:// access
     LWP::Protocol::ftp   &minus;&minus; ftp:// access
     ...
 LWP::Authen::Basic &minus;&minus; Handle 401 and 407 responses
 LWP::Authen::Digest
 HTTP::Headers      &minus;&minus; MIME/RFC822 style header (used by HTTP::Message)
 HTTP::Message      &minus;&minus; HTTP style message
   HTTP::Request    &minus;&minus; HTTP request
   HTTP::Response   &minus;&minus; HTTP response
 HTTP::Daemon       &minus;&minus; A HTTP server class
 WWW::RobotRules    &minus;&minus; Parse robots.txt files
   WWW::RobotRules::AnyDBM_File &minus;&minus; Persistent RobotRules
 Net::HTTP          &minus;&minus; Low level HTTP client</pre>


<p style="margin-left:11%; margin-top: 1em">The following
modules provide various functions and definitions.</p>

<pre style="margin-left:11%; margin-top: 1em"> LWP                &minus;&minus; This file.  Library version number and documentation.
 LWP::MediaTypes    &minus;&minus; MIME types configuration (text/html etc.)
 LWP::Simple        &minus;&minus; Simplified procedural interface for common functions
 HTTP::Status       &minus;&minus; HTTP status code (200 OK etc)
 HTTP::Date         &minus;&minus; Date parsing module for HTTP date formats
 HTTP::Negotiate    &minus;&minus; HTTP content negotiation calculation
 File::Listing      &minus;&minus; Parse directory listings
 HTML::Form         &minus;&minus; Processing for &lt;form&gt;s in HTML documents</pre>


<h2>MORE DOCUMENTATION
<a name="MORE DOCUMENTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All modules
contain detailed information on the interfaces they provide.
The lwpcook manpage is the libwww-perl cookbook that contain
examples of typical usage of the library. You might want to
take a look at how the scripts lwp-request, lwp-download,
lwp-dump and lwp-mirror are implemented.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
environment variables are used by <small>LWP: <br>
HOME</small></p>

<p style="margin-left:17%;">The
<tt>&quot;LWP::MediaTypes&quot;</tt> functions will look for
the <i>.media.types</i> and <i>.mime.types</i> files
relative to you home directory.</p>

<p style="margin-left:11%;">http_proxy <br>
ftp_proxy <br>
xxx_proxy <br>
no_proxy</p>

<p style="margin-left:17%;">These environment variables can
be set to enable communication through a proxy server. See
the description of the <tt>&quot;env_proxy&quot;</tt> method
in LWP::UserAgent.</p>


<p style="margin-left:11%;"><small>PERL_LWP_ENV_PROXY</small></p>

<p style="margin-left:17%;">If set to a <small>TRUE</small>
value, then the <tt>&quot;LWP::UserAgent&quot;</tt> will by
default call <tt>&quot;env_proxy&quot;</tt> during
initialization. This makes <small>LWP</small> honor the
proxy variables described above.</p>


<p style="margin-left:11%;"><small>PERL_LWP_SSL_VERIFY_HOSTNAME</small></p>

<p style="margin-left:17%;">The default
<tt>&quot;verify_hostname&quot;</tt> setting for
<tt>&quot;LWP::UserAgent&quot;</tt>. If not set the default
will be 1. Set it as 0 to disable hostname verification (the
default prior to libwww-perl 5.840.</p>

<p style="margin-left:11%;"><small>PERL_LWP_SSL_CA_FILE
<br>
PERL_LWP_SSL_CA_PATH</small></p>

<p style="margin-left:17%;">The file and/or directory where
the trusted Certificate Authority certificates is located.
See LWP::UserAgent for details.</p>


<p style="margin-left:11%;"><small>PERL_HTTP_URI_CLASS</small></p>

<p style="margin-left:17%;">Used to decide what
<small>URI</small> objects to instantiate. The default is
<tt>&quot;URI&quot;</tt>. You might want to set it to
<tt>&quot;URI::URL&quot;</tt> for compatibility with old
times.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>LWP</small>
was made possible by contributions from Adam Newby, Albert
Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas
Koenig, Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin
Low, Ben Low, Ben Tilly, Blair Zajac, Bob Dalgleish, BooK,
Brad Hughes, Brian J. Murrell, Brian McCauley, Charles C.
Fu, Charles Lane, Chris Nandor, Christian Gilmore, Chris W.
Unger, Craig Macdonald, Dale Couch, Dan Kubb, Dave Dunkin,
Dave W. Smith, David Coppit, David Dick, David D. Kilzer,
Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg,
Harry Bochner, Hugo, Ilya Zakharevich, <small>INOUE</small>
Yoshinari, Ivan Panchenko, Jack Shirazi, James Tillman, Jan
Dubois, Jared Rhine, Jim Stern, Joao Lopes, John Klar,
Johnny Lee, Josh Kronengold, Josh Rai, Joshua Chamas, Joshua
Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken Williams,
<small>KONISHI</small> Katsuhiro, Lee T Lindley, Liam Quinn,
Marc Hedlund, Marc Langheinrich, Mark D. Anderson, Marko
Asplund, Mark Stosberg, Markus B Krueger, Markus Laker,
Martijn Koster, Martin Thurn, Matthew Eldridge,
Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky,
Nathan Torkington, Nicolai Langfeldt, Norton Allen, Olly
Betts, Paul J. Schinder, peterm, Philip GuentherDaniel
Buenzli, Pon Hwa Lin, Radoslaw Zielinski, Radu Greab, Randal
L. Schwartz, Richard Chen, Robin Barker, Roy Fielding,
Sander van Zoest, Sean M. Burke, shildreth, Slaven Rezic,
Steve A Fink, Steve Hay, Steven Butler, Steve_Kilbane,
Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes, Tony
Finch, Ville Skyttae, Ward Vandewege, William York, Yale
Huang, and Yitzchak Scott-Thoennes.</p>


<p style="margin-left:11%; margin-top: 1em"><small>LWP</small>
owes a lot in motivation, design, and code, to the
libwww-perl library for Perl4 by Roy Fielding, which
included work from Alberto Accomazzi, James Casey, Brooks
Cutter, Martijn Koster, Oscar Nierstrasz, Mel Melchner,
Gertjan van Oosten, Jared Rhine, Jack Shirazi, Gene
Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see
the libwww&minus;perl&minus;0.40 library for details.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<pre style="margin-left:11%; margin-top: 1em">  Copyright 1995&minus;2009, Gisle Aas
  Copyright 1995, Martijn Koster</pre>


<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The latest
version of this library is likely to be available from
<small>CPAN</small> as well as:</p>

<pre style="margin-left:11%; margin-top: 1em">  http://github.com/libwww&minus;perl/libwww&minus;perl</pre>


<p style="margin-left:11%; margin-top: 1em">The best place
to discuss this code is on the &lt;libwww@perl.org&gt;
mailing list.</p>
<hr>
</body>
</html>
