<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:35:13 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>cla_syrfsx_extended.f</title>

</head>
<body>

<h1 align="center">cla_syrfsx_extended.f</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#Function/Subroutine Documentation">Function/Subroutine Documentation</a><br>
<a href="#Author">Author</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">cla_syrfsx_extended.f
&minus;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Functions/Subroutines</b></p>

<p style="margin-left:17%;">subroutine
<b>cla_syrfsx_extended</b> (PREC_TYPE, UPLO, N, NRHS, A,
LDA, AF, LDAF, IPIV, COLEQU, C, B, LDB, Y, LDY, BERR_OUT,
N_NORMS, ERR_BNDS_NORM, ERR_BNDS_COMP, RES, AYB, DY, Y_TAIL,
RCOND, ITHRESH, RTHRESH, DZ_UB, IGNORE_CWISE, INFO) <b><br>
CLA_SYRFSX_EXTENDED</b> <i>improves the computed solution to
a system of linear equations for symmetric indefinite
matrices by performing extra-precise iterative refinement
and provides error bounds and backward error estimates for
the solution.</i></p>

<h2>Function/Subroutine Documentation
<a name="Function/Subroutine Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>subroutine
cla_syrfsx_extended (integerPREC_TYPE, characterUPLO,
integerN, integerNRHS, complex, dimension( lda, * )A,
integerLDA, complex, dimension( ldaf, * )AF, integerLDAF,
integer, dimension( * )IPIV, logicalCOLEQU, real, dimension(
* )C, complex, dimension( ldb, * )B, integerLDB, complex,
dimension( ldy, * )Y, integerLDY, real, dimension( *
)BERR_OUT, integerN_NORMS, real, dimension( nrhs, *
)ERR_BNDS_NORM, real, dimension( nrhs, * )ERR_BNDS_COMP,
complex, dimension( * )RES, real, dimension( * )AYB,
complex, dimension( * )DY, complex, dimension( * )Y_TAIL,
realRCOND, integerITHRESH, realRTHRESH, realDZ_UB,
logicalIGNORE_CWISE, integerINFO) <br>
CLA_SYRFSX_EXTENDED</b></i> improves the computed solution
to a system of linear equations for symmetric indefinite
matrices by performing extra-precise iterative refinement
and provides error bounds and backward error estimates for
the solution.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Purpose:</b></p>


<p style="margin-left:17%; margin-top: 1em">CLA_SYRFSX_EXTENDED
improves the computed solution to a system of <br>
linear equations by performing extra-precise iterative
refinement <br>
and provides error bounds and backward error estimates for
the solution. <br>
This subroutine is called by CSYRFSX to perform iterative
refinement. <br>
In addition to normwise error bound, the code provides
maximum <br>
componentwise error bound if possible. See comments for
ERR_BNDS_NORM <br>
and ERR_BNDS_COMP for details of the error bounds. Note that
this <br>
subroutine is only resonsible for setting the second fields
of <br>
ERR_BNDS_NORM and ERR_BNDS_COMP.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters:</b></p>

<p style="margin-left:17%;"><i>PREC_TYPE</i></p>

<p style="margin-left:17%; margin-top: 1em">PREC_TYPE is
INTEGER <br>
Specifies the intermediate precision to be used in
refinement. <br>
The value is defined by ILAPREC(P) where P is a CHARACTER
and <br>
P = &rsquo;S&rsquo;: Single <br>
= &rsquo;D&rsquo;: Double <br>
= &rsquo;I&rsquo;: Indigenous <br>
= &rsquo;X&rsquo;, &rsquo;E&rsquo;: Extra</p>


<p style="margin-left:17%; margin-top: 1em"><i>UPLO</i></p>

<p style="margin-left:17%; margin-top: 1em">UPLO is
CHARACTER*1 <br>
= &rsquo;U&rsquo;: Upper triangle of A is stored; <br>
= &rsquo;L&rsquo;: Lower triangle of A is stored.</p>

<p style="margin-left:17%; margin-top: 1em"><i>N</i></p>

<p style="margin-left:17%; margin-top: 1em">N is INTEGER
<br>
The number of linear equations, i.e., the order of the <br>
matrix A. N &gt;= 0.</p>


<p style="margin-left:17%; margin-top: 1em"><i>NRHS</i></p>

<p style="margin-left:17%; margin-top: 1em">NRHS is INTEGER
<br>
The number of right-hand-sides, i.e., the number of columns
of the <br>
matrix B.</p>

<p style="margin-left:17%; margin-top: 1em"><i>A</i></p>

<p style="margin-left:17%; margin-top: 1em">A is COMPLEX
array, dimension (LDA,N) <br>
On entry, the N-by-N matrix A.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDA</i></p>

<p style="margin-left:17%; margin-top: 1em">LDA is INTEGER
<br>
The leading dimension of the array A. LDA &gt;=
max(1,N).</p>

<p style="margin-left:17%; margin-top: 1em"><i>AF</i></p>

<p style="margin-left:17%; margin-top: 1em">AF is COMPLEX
array, dimension (LDAF,N) <br>
The block diagonal matrix D and the multipliers used to <br>
obtain the factor U or L as computed by CSYTRF.</p>


<p style="margin-left:17%; margin-top: 1em"><i>LDAF</i></p>

<p style="margin-left:17%; margin-top: 1em">LDAF is INTEGER
<br>
The leading dimension of the array AF. LDAF &gt;=
max(1,N).</p>


<p style="margin-left:17%; margin-top: 1em"><i>IPIV</i></p>

<p style="margin-left:17%; margin-top: 1em">IPIV is INTEGER
array, dimension (N) <br>
Details of the interchanges and the block structure of D
<br>
as determined by CSYTRF.</p>


<p style="margin-left:17%; margin-top: 1em"><i>COLEQU</i></p>

<p style="margin-left:17%; margin-top: 1em">COLEQU is
LOGICAL <br>
If .TRUE. then column equilibration was done to A before
calling <br>
this routine. This is needed to compute the solution and
error <br>
bounds correctly.</p>

<p style="margin-left:17%; margin-top: 1em"><i>C</i></p>

<p style="margin-left:17%; margin-top: 1em">C is REAL
array, dimension (N) <br>
The column scale factors for A. If COLEQU = .FALSE., C <br>
is not accessed. If C is input, each element of C should be
a power <br>
of the radix to ensure a reliable solution and error
estimates. <br>
Scaling by powers of the radix does not cause rounding
errors unless <br>
the result underflows or overflows. Rounding errors during
scaling <br>
lead to refining with a matrix that is not equivalent to the
<br>
input matrix, producing error estimates that may not be <br>
reliable.</p>

<p style="margin-left:17%; margin-top: 1em"><i>B</i></p>

<p style="margin-left:17%; margin-top: 1em">B is COMPLEX
array, dimension (LDB,NRHS) <br>
The right-hand-side matrix B.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDB</i></p>

<p style="margin-left:17%; margin-top: 1em">LDB is INTEGER
<br>
The leading dimension of the array B. LDB &gt;=
max(1,N).</p>

<p style="margin-left:17%; margin-top: 1em"><i>Y</i></p>

<p style="margin-left:17%; margin-top: 1em">Y is COMPLEX
array, dimension <br>
(LDY,NRHS) <br>
On entry, the solution matrix X, as computed by CSYTRS. <br>
On exit, the improved solution matrix Y.</p>

<p style="margin-left:17%; margin-top: 1em"><i>LDY</i></p>

<p style="margin-left:17%; margin-top: 1em">LDY is INTEGER
<br>
The leading dimension of the array Y. LDY &gt;=
max(1,N).</p>


<p style="margin-left:17%; margin-top: 1em"><i>BERR_OUT</i></p>

<p style="margin-left:17%; margin-top: 1em">BERR_OUT is
REAL array, dimension (NRHS) <br>
On exit, BERR_OUT(j) contains the componentwise relative
backward <br>
error for right-hand-side j from the formula <br>
max(i) ( abs(RES(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i)
) <br>
where abs(Z) is the componentwise absolute value of the
matrix <br>
or vector Z. This is computed by CLA_LIN_BERR.</p>


<p style="margin-left:17%; margin-top: 1em"><i>N_NORMS</i></p>

<p style="margin-left:17%; margin-top: 1em">N_NORMS is
INTEGER <br>
Determines which error bounds to return (see ERR_BNDS_NORM
<br>
and ERR_BNDS_COMP). <br>
If N_NORMS &gt;= 1 return normwise error bounds. <br>
If N_NORMS &gt;= 2 return componentwise error bounds.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ERR_BNDS_NORM</i></p>

<p style="margin-left:17%; margin-top: 1em">ERR_BNDS_NORM
is REAL array, dimension <br>
(NRHS, N_ERR_BNDS) <br>
For each right-hand side, this array contains information
about <br>
various error bounds and condition numbers corresponding to
the <br>
normwise relative error, which is defined as follows:</p>

<p style="margin-left:17%; margin-top: 1em">Normwise
relative error in the ith solution vector: <br>
max_j (abs(XTRUE(j,i) - X(j,i))) <br>
------------------------------ <br>
max_j abs(X(j,i))</p>

<p style="margin-left:17%; margin-top: 1em">The array is
indexed by the type of error information as described <br>
below. There currently are up to three pieces of information
<br>
returned.</p>

<p style="margin-left:17%; margin-top: 1em">The first index
in ERR_BNDS_NORM(i,:) corresponds to the ith <br>
right-hand side.</p>

<p style="margin-left:17%; margin-top: 1em">The second
index in ERR_BNDS_NORM(:,err) contains the following <br>
three fields: <br>
err = 1 &quot;Trust/don&rsquo;t trust&quot; boolean. Trust
the answer if the <br>
reciprocal condition number is less than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;).</p>

<p style="margin-left:17%; margin-top: 1em">err = 2
&quot;Guaranteed&quot; error bound: The estimated forward
error, <br>
almost certainly within a factor of 10 of the true error
<br>
so long as the next entry is greater than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;). This error bound
should only <br>
be trusted if the previous boolean is true.</p>

<p style="margin-left:17%; margin-top: 1em">err = 3
Reciprocal condition number: Estimated normwise <br>
reciprocal condition number. Compared with the threshold
<br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;) to determine if the
error <br>
estimate is &quot;guaranteed&quot;. These reciprocal
condition <br>
numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
<br>
appropriately scaled matrix Z. <br>
Let Z = S*A, where S scales each row by a power of the <br>
radix so all absolute row sums of Z are approximately 1.</p>

<p style="margin-left:17%; margin-top: 1em">This subroutine
is only responsible for setting the second field <br>
above. <br>
See Lapack Working Note 165 for further details and extra
<br>
cautions.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ERR_BNDS_COMP</i></p>

<p style="margin-left:17%; margin-top: 1em">ERR_BNDS_COMP
is REAL array, dimension <br>
(NRHS, N_ERR_BNDS) <br>
For each right-hand side, this array contains information
about <br>
various error bounds and condition numbers corresponding to
the <br>
componentwise relative error, which is defined as
follows:</p>

<p style="margin-left:17%; margin-top: 1em">Componentwise
relative error in the ith solution vector: <br>
abs(XTRUE(j,i) - X(j,i)) <br>
max_j ---------------------- <br>
abs(X(j,i))</p>

<p style="margin-left:17%; margin-top: 1em">The array is
indexed by the right-hand side i (on which the <br>
componentwise relative error depends), and the type of error
<br>
information as described below. There currently are up to
three <br>
pieces of information returned for each right-hand side. If
<br>
componentwise accuracy is not requested (PARAMS(3) = 0.0),
then <br>
ERR_BNDS_COMP is not accessed. If N_ERR_BNDS .LT. 3, then at
most <br>
the first (:,N_ERR_BNDS) entries are returned.</p>

<p style="margin-left:17%; margin-top: 1em">The first index
in ERR_BNDS_COMP(i,:) corresponds to the ith <br>
right-hand side.</p>

<p style="margin-left:17%; margin-top: 1em">The second
index in ERR_BNDS_COMP(:,err) contains the following <br>
three fields: <br>
err = 1 &quot;Trust/don&rsquo;t trust&quot; boolean. Trust
the answer if the <br>
reciprocal condition number is less than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;).</p>

<p style="margin-left:17%; margin-top: 1em">err = 2
&quot;Guaranteed&quot; error bound: The estimated forward
error, <br>
almost certainly within a factor of 10 of the true error
<br>
so long as the next entry is greater than the threshold <br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;). This error bound
should only <br>
be trusted if the previous boolean is true.</p>

<p style="margin-left:17%; margin-top: 1em">err = 3
Reciprocal condition number: Estimated componentwise <br>
reciprocal condition number. Compared with the threshold
<br>
sqrt(n) * slamch(&rsquo;Epsilon&rsquo;) to determine if the
error <br>
estimate is &quot;guaranteed&quot;. These reciprocal
condition <br>
numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some
<br>
appropriately scaled matrix Z. <br>
Let Z = S*(A*diag(x)), where x is the solution for the <br>
current right-hand side and S scales each row of <br>
A*diag(x) by a power of the radix so all absolute row <br>
sums of Z are approximately 1.</p>

<p style="margin-left:17%; margin-top: 1em">This subroutine
is only responsible for setting the second field <br>
above. <br>
See Lapack Working Note 165 for further details and extra
<br>
cautions.</p>

<p style="margin-left:17%; margin-top: 1em"><i>RES</i></p>

<p style="margin-left:17%; margin-top: 1em">RES is COMPLEX
array, dimension (N) <br>
Workspace to hold the intermediate residual.</p>

<p style="margin-left:17%; margin-top: 1em"><i>AYB</i></p>

<p style="margin-left:17%; margin-top: 1em">AYB is REAL
array, dimension (N) <br>
Workspace.</p>

<p style="margin-left:17%; margin-top: 1em"><i>DY</i></p>

<p style="margin-left:17%; margin-top: 1em">DY is COMPLEX
array, dimension (N) <br>
Workspace to hold the intermediate solution.</p>


<p style="margin-left:17%; margin-top: 1em"><i>Y_TAIL</i></p>

<p style="margin-left:17%; margin-top: 1em">Y_TAIL is
COMPLEX array, dimension (N) <br>
Workspace to hold the trailing bits of the intermediate
solution.</p>


<p style="margin-left:17%; margin-top: 1em"><i>RCOND</i></p>

<p style="margin-left:17%; margin-top: 1em">RCOND is REAL
<br>
Reciprocal scaled condition number. This is an estimate of
the <br>
reciprocal Skeel condition number of the matrix A after <br>
equilibration (if done). If this is less than the machine
<br>
precision (in particular, if it is zero), the matrix is
singular <br>
to working precision. Note that the error may still be small
even <br>
if this number is very small and the matrix appears ill-
<br>
conditioned.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ITHRESH</i></p>

<p style="margin-left:17%; margin-top: 1em">ITHRESH is
INTEGER <br>
The maximum number of residual computations allowed for <br>
refinement. The default is 10. For &rsquo;aggressive&rsquo;
set to 100 to <br>
permit convergence using approximate factorizations or <br>
factorizations other than LU. If the factorization uses a
<br>
technique other than Gaussian elimination, the guarantees in
<br>
ERR_BNDS_NORM and ERR_BNDS_COMP may no longer be
trustworthy.</p>


<p style="margin-left:17%; margin-top: 1em"><i>RTHRESH</i></p>

<p style="margin-left:17%; margin-top: 1em">RTHRESH is REAL
<br>
Determines when to stop refinement if the error estimate
stops <br>
decreasing. Refinement will stop when the next solution no
longer <br>
satisfies norm(dx_{i+1}) &lt; RTHRESH * norm(dx_i) where
norm(Z) is <br>
the infinity norm of Z. RTHRESH satisfies 0 &lt; RTHRESH
&lt;= 1. The <br>
default value is 0.5. For &rsquo;aggressive&rsquo; set to
0.9 to permit <br>
convergence on extremely ill-conditioned matrices. See LAWN
165 <br>
for more details.</p>


<p style="margin-left:17%; margin-top: 1em"><i>DZ_UB</i></p>

<p style="margin-left:17%; margin-top: 1em">DZ_UB is REAL
<br>
Determines when to start considering componentwise
convergence. <br>
Componentwise convergence is only considered after each
component <br>
of the solution Y is stable, which we definte as the
relative <br>
change in each component being less than DZ_UB. The default
value <br>
is 0.25, requiring the first bit to be stable. See LAWN 165
for <br>
more details.</p>


<p style="margin-left:17%; margin-top: 1em"><i>IGNORE_CWISE</i></p>

<p style="margin-left:17%; margin-top: 1em">IGNORE_CWISE is
LOGICAL <br>
If .TRUE. then ignore componentwise convergence. Default
value <br>
is .FALSE..</p>


<p style="margin-left:17%; margin-top: 1em"><i>INFO</i></p>

<p style="margin-left:17%; margin-top: 1em">INFO is INTEGER
<br>
= 0: Successful exit. <br>
&lt; 0: if INFO = -i, the ith argument to
CLA_SYRFSX_EXTENDED had an illegal <br>
value</p>


<p style="margin-left:11%; margin-top: 1em"><b>Author:</b></p>

<p style="margin-left:17%;">Univ. of Tennessee</p>

<p style="margin-left:17%; margin-top: 1em">Univ. of
California Berkeley</p>

<p style="margin-left:17%; margin-top: 1em">Univ. of
Colorado Denver</p>

<p style="margin-left:17%; margin-top: 1em">NAG Ltd.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Date:</b></p>

<p style="margin-left:17%;">September 2012</p>

<p style="margin-left:11%; margin-top: 1em">Definition at
line 393 of file cla_syrfsx_extended.f.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for LAPACK from the source
code.</p>
<hr>
</body>
</html>
