<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 01:31:46 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>bc</title>

</head>
<body>

<h1 align="center">bc</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNTAX">SYNTAX</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br>
<a href="#BUGS">BUGS</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">bc - An
arbitrary precision calculator language</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>bc</b> [
<b>-hlwsqv</b> ] [long-options] [ <i>file ...</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>bc</b> is a
language that supports arbitrary precision numbers with
interactive execution of statements. There are some
similarities in the syntax to the C programming language. A
standard math library is available by command line option.
If requested, the math library is defined before processing
any files. <b>bc</b> starts by processing code from all the
files listed on the command line in the order listed. After
all files have been processed, <b>bc</b> reads from the
standard input. All code is executed as it is read. (If a
file contains a command to halt the processor, <b>bc</b>
will never read from the standard input.)</p>

<p style="margin-left:11%; margin-top: 1em">This version of
<b>bc</b> contains several extensions beyond traditional
<b>bc</b> implementations and the POSIX draft standard.
Command line options can cause these extensions to print a
warning or to be rejected. This document describes the
language accepted by this processor. Extensions will be
identified as such.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OPTIONS</b>
<br>
-h, --help</p>

<p style="margin-left:22%;">Print the usage and exit.</p>

<p style="margin-left:11%;">-i, --interactive</p>

<p style="margin-left:22%;">Force interactive mode.</p>

<p style="margin-left:11%;">-l, --mathlib</p>

<p style="margin-left:22%;">Define the standard math
library.</p>

<p style="margin-left:11%;">-w, --warn</p>

<p style="margin-left:22%;">Give warnings for extensions to
POSIX <b>bc</b>.</p>

<p style="margin-left:11%;">-s, --standard</p>

<p style="margin-left:22%;">Process exactly the POSIX
<b>bc</b> language.</p>

<p style="margin-left:11%;">-q, --quiet</p>

<p style="margin-left:22%;">Do not print the normal GNU bc
welcome.</p>

<p style="margin-left:11%;">-v, --version</p>

<p style="margin-left:22%;">Print the version number and
copyright and quit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NUMBERS</b>
<br>
The most basic element in <b>bc</b> is the number. Numbers
are arbitrary precision numbers. This precision is both in
the integer part and the fractional part. All numbers are
represented internally in decimal and all computation is
done in decimal. (This version truncates results from divide
and multiply operations.) There are two attributes of
numbers, the length and the scale. The length is the total
number of significant decimal digits in a number and the
scale is the total number of decimal digits after the
decimal point. For example:</p>

<p style="margin-left:22%;">.000001 has a length of 6 and
scale of 6. <br>
1935.000 has a length of 7 and a scale of 3.</p>


<p style="margin-left:11%; margin-top: 1em"><b>VARIABLES</b>
<br>
Numbers are stored in two types of variables, simple
variables and arrays. Both simple variables and array
variables are named. Names begin with a letter followed by
any number of letters, digits and underscores. All letters
must be lower case. (Full alpha-numeric names are an
extension. In POSIX <b>bc</b> all names are a single lower
case letter.) The type of variable is clear by the context
because all array variable names will be followed by
brackets ([]).</p>

<p style="margin-left:11%; margin-top: 1em">There are four
special variables, <b>scale, ibase, obase,</b> and
<b>last</b>. <b>scale</b> defines how some operations use
digits after the decimal point. The default value of
<b>scale</b> is 0. <b>ibase</b> and <b>obase</b> define the
conversion base for input and output numbers. The default
for both input and output is base 10. <b>last</b> (an
extension) is a variable that has the value of the last
printed number. These will be discussed in further detail
where appropriate. All of these variables may have values
assigned to them as well as used in expressions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>COMMENTS</b>
<br>
Comments in <b>bc</b> start with the characters <b>/*</b>
and end with the characters <b>*/</b>. Comments may start
anywhere and appear as a single space in the input. (This
causes comments to delimit other input items. For example, a
comment can not be found in the middle of a variable name.)
Comments include any newlines (end of line) between the
start and the end of the comment.</p>

<p style="margin-left:11%; margin-top: 1em">To support the
use of scripts for <b>bc</b>, a single line comment has been
added as an extension. A single line comment starts at a
<b>#</b> character and continues to the next end of the
line. The end of line character is not part of the comment
and is processed normally.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EXPRESSIONS</b>
<br>
The numbers are manipulated by expressions and statements.
Since the language was designed to be interactive,
statements and expressions are executed as soon as possible.
There is no &quot;main&quot; program. Instead, code is
executed as it is encountered. (Functions, discussed in
detail later, are defined when encountered.)</p>

<p style="margin-left:11%; margin-top: 1em">A simple
expression is just a constant. <b>bc</b> converts constants
into internal decimal numbers using the current input base,
specified by the variable <b>ibase</b>. (There is an
exception in functions.) The legal values of <b>ibase</b>
are 2 through 16. Assigning a value outside this range to
<b>ibase</b> will result in a value of 2 or 16. Input
numbers may contain the characters 0-9 and A-F. (Note: They
must be capitals. Lower case letters are variable names.)
Single digit numbers always have the value of the digit
regardless of the value of <b>ibase</b>. (i.e. A = 10.) For
multi-digit numbers, <b>bc</b> changes all input digits
greater or equal to ibase to the value of <b>ibase</b>-1.
This makes the number <b>FFF</b> always be the largest 3
digit number of the input base.</p>

<p style="margin-left:11%; margin-top: 1em">Full
expressions are similar to many other high level languages.
Since there is only one kind of number, there are no rules
for mixing types. Instead, there are rules on the scale of
expressions. Every expression has a scale. This is derived
from the scale of original numbers, the operation performed
and in many cases, the value of the variable <b>scale</b>.
Legal values of the variable <b>scale</b> are 0 to the
maximum number representable by a C integer.</p>

<p style="margin-left:11%; margin-top: 1em">In the
following descriptions of legal expressions,
&quot;expr&quot; refers to a complete expression and
&quot;var&quot; refers to a simple or an array variable. A
simple variable is just a</p>

<p style="margin-left:22%;"><i>name</i></p>

<p style="margin-left:11%;">and an array variable is
specified as</p>

<p style="margin-left:22%;"><i>name</i>[<i>expr</i>]</p>

<p style="margin-left:11%;">Unless specifically mentioned
the scale of the result is the maximum scale of the
expressions involved.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>- expr</p></td>
<td width="2%"></td>
<td width="78%">


<p>The result is the negation of the expression.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>++ var</p></td>
<td width="2%"></td>
<td width="78%">


<p>The variable is incremented by one and the new value is
the result of the expression.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>-- var</p></td>
<td width="2%"></td>
<td width="78%">


<p>The variable is decremented by one and the new value is
the result of the expression.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>var ++</p></td>
<td width="2%"></td>
<td width="78%">


<p>The result of the expression is the value of the
variable and then the variable is incremented by one.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>var --</p></td>
<td width="2%"></td>
<td width="78%">


<p>The result of the expression is the value of the
variable and then the variable is decremented by one.</p></td></tr>
</table>

<p style="margin-left:11%;">expr + expr</p>

<p style="margin-left:22%;">The result of the expression is
the sum of the two expressions.</p>

<p style="margin-left:11%;">expr - expr</p>

<p style="margin-left:22%;">The result of the expression is
the difference of the two expressions.</p>

<p style="margin-left:11%;">expr * expr</p>

<p style="margin-left:22%;">The result of the expression is
the product of the two expressions. If a and b are the
scales of the two expressions, then the scale of the result
is: min(a+b,max(scale,a,b))</p>

<p style="margin-left:11%;">expr / expr</p>

<p style="margin-left:22%;">The result of the expression is
the quotient of the two expressions. The scale of the result
is the value of the variable <b>scale</b>.</p>

<p style="margin-left:11%;">expr % expr</p>

<p style="margin-left:22%;">The result of the expression is
the &quot;remainder&quot; and it is computed in the
following way. To compute a%b, first a/b is computed to
<b>scale</b> digits. That result is used to compute
a-(a/b)*b to the scale of the maximum of
<b>scale</b>+scale(b) and scale(a). If <b>scale</b> is set
to zero and both expressions are integers this expression is
the integer remainder function.</p>

<p style="margin-left:11%;">expr ^ expr</p>

<p style="margin-left:22%;">The result of the expression is
the value of the first raised to the second. The second
expression must be an integer. (If the second expression is
not an integer, a warning is generated and the expression is
truncated to get an integer value.) The scale of the result
is <b>scale</b> if the exponent is negative. If the exponent
is positive the scale of the result is the minimum of the
scale of the first expression times the value of the
exponent and the maximum of <b>scale</b> and the scale of
the first expression. (e.g. scale(a^b) = min(scale(a)*b,
max( <b>scale,</b> scale(a))).) It should be noted that
expr^0 will always return the value of 1.</p>

<p style="margin-left:11%;">( expr )</p>

<p style="margin-left:22%;">This alters the standard
precedence to force the evaluation of the expression.</p>

<p style="margin-left:11%;">var = expr</p>

<p style="margin-left:22%;">The variable is assigned the
value of the expression.</p>

<p style="margin-left:11%;">var &lt;op&gt;= expr</p>

<p style="margin-left:22%;">This is equivalent to &quot;var
= var &lt;op&gt; expr&quot; with the exception that the
&quot;var&quot; part is evaluated only once. This can make a
difference if &quot;var&quot; is an array.</p>

<p style="margin-left:11%; margin-top: 1em">Relational
expressions are a special kind of expression that always
evaluate to 0 or 1, 0 if the relation is false and 1 if the
relation is true. These may appear in any legal expression.
(POSIX bc requires that relational expressions are used only
in if, while, and for statements and that only one
relational test may be done in them.) The relational
operators are <br>
expr1 &lt; expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is
strictly less than expr2.</p>

<p style="margin-left:11%;">expr1 &lt;= expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is
less than or equal to expr2.</p>

<p style="margin-left:11%;">expr1 &gt; expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is
strictly greater than expr2.</p>

<p style="margin-left:11%;">expr1 &gt;= expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is
greater than or equal to expr2.</p>

<p style="margin-left:11%;">expr1 == expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is
equal to expr2.</p>

<p style="margin-left:11%;">expr1 != expr2</p>

<p style="margin-left:22%;">The result is 1 if expr1 is not
equal to expr2.</p>

<p style="margin-left:11%; margin-top: 1em">Boolean
operations are also legal. (POSIX <b>bc</b> does NOT have
boolean operations). The result of all boolean operations
are 0 and 1 (for false and true) as in relational
expressions. The boolean operators are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>!expr</p></td>
<td width="4%"></td>
<td width="44%">


<p>The result is 1 if expr is 0.</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%;">expr &amp;&amp; expr</p>

<p style="margin-left:22%;">The result is 1 if both
expressions are non-zero.</p>

<p style="margin-left:11%;">expr || expr</p>

<p style="margin-left:22%;">The result is 1 if either
expression is non-zero.</p>

<p style="margin-left:11%; margin-top: 1em">The expression
precedence is as follows: (lowest to highest)</p>

<p style="margin-left:22%;">|| operator, left associative
<br>
&amp;&amp; operator, left associative <br>
! operator, nonassociative <br>
Relational operators, left associative <br>
Assignment operator, right associative <br>
+ and - operators, left associative <br>
*, / and % operators, left associative <br>
^ operator, right associative <br>
unary - operator, nonassociative <br>
++ and -- operators, nonassociative</p>

<p style="margin-left:11%; margin-top: 1em">This precedence
was chosen so that POSIX compliant <b>bc</b> programs will
run correctly. This will cause the use of the relational and
logical operators to have some unusual behavior when used
with assignment expressions. Consider the expression:</p>

<p style="margin-left:22%;">a = 3 &lt; 5</p>

<p style="margin-left:11%; margin-top: 1em">Most C
programmers would assume this would assign the result of
&quot;3 &lt; 5&quot; (the value 1) to the variable
&quot;a&quot;. What this does in <b>bc</b> is assign the
value 3 to the variable &quot;a&quot; and then compare 3 to
5. It is best to use parenthesis when using relational and
logical operators with the assignment operators.</p>

<p style="margin-left:11%; margin-top: 1em">There are a few
more special expressions that are provided in <b>bc</b>.
These have to do with user defined functions and standard
functions. They all appear as
&quot;<i>name</i><b>(</b><i>parameters</i><b>)</b>&quot;.
See the section on functions for user defined functions. The
standard functions are: <br>
length ( expression )</p>

<p style="margin-left:22%;">The value of the length
function is the number of significant digits in the
expression.</p>

<p style="margin-left:11%;">read ( )</p>

<p style="margin-left:22%;">The read function (an
extension) will read a number from the standard input,
regardless of where the function occurs. Beware, this can
cause problems with the mixing of data and program in the
standard input. The best use for this function is in a
previously written program that needs input from the user,
but never allows program code to be input from the user. The
value of the read function is the number read from the
standard input using the current value of the variable
<b>ibase</b> for the conversion base.</p>

<p style="margin-left:11%;">scale ( expression )</p>

<p style="margin-left:22%;">The value of the scale function
is the number of digits after the decimal point in the
expression.</p>

<p style="margin-left:11%;">sqrt ( expression )</p>

<p style="margin-left:22%;">The value of the sqrt function
is the square root of the expression. If the expression is
negative, a run time error is generated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>STATEMENTS</b>
<br>
Statements (as in most algebraic languages) provide the
sequencing of expression evaluation. In <b>bc</b> statements
are executed &quot;as soon as possible.&quot; Execution
happens when a newline in encountered and there is one or
more complete statements. Due to this immediate execution,
newlines are very important in <b>bc</b>. In fact, both a
semicolon and a newline are used as statement separators. An
improperly placed newline will cause a syntax error. Because
newlines are statement separators, it is possible to hide a
newline by using the backslash character. The sequence
&quot;\&lt;nl&gt;&quot;, where &lt;nl&gt; is the newline
appears to <b>bc</b> as whitespace instead of a newline. A
statement list is a series of statements separated by
semicolons and newlines. The following is a list of
<b>bc</b> statements and what they do: (Things enclosed in
brackets ([]) are optional parts of the statement.) <br>
expression</p>

<p style="margin-left:22%;">This statement does one of two
things. If the expression starts with &quot;&lt;variable&gt;
&lt;assignment&gt; ...&quot;, it is considered to be an
assignment statement. If the expression is not an assignment
statement, the expression is evaluated and printed to the
output. After the number is printed, a newline is printed.
For example, &quot;a=1&quot; is an assignment statement and
&quot;(a=1)&quot; is an expression that has an embedded
assignment. All numbers that are printed are printed in the
base specified by the variable <b>obase</b>. The legal
values for <b>obase</b> are 2 through BC_BASE_MAX. (See the
section LIMITS.) For bases 2 through 16, the usual method of
writing numbers is used. For bases greater than 16,
<b>bc</b> uses a multi-character digit method of printing
the numbers where each higher base digit is printed as a
base 10 number. The multi-character digits are separated by
spaces. Each digit contains the number of characters
required to represent the base ten value of
&quot;obase-1&quot;. Since numbers are of arbitrary
precision, some numbers may not be printable on a single
output line. These long numbers will be split across lines
using the &quot;\&quot; as the last character on a line. The
maximum number of characters printed per line is 70. Due to
the interactive nature of <b>bc</b>, printing a number
causes the side effect of assigning the printed value to the
special variable <b>last</b>. This allows the user to
recover the last value printed without having to retype the
expression that printed the number. Assigning to <b>last</b>
is legal and will overwrite the last printed value with the
assigned value. The newly assigned value will remain until
the next number is printed or another value is assigned to
<b>last</b>. (Some installations may allow the use of a
single period (.) which is not part of a number as a short
hand notation for for <b>last</b>.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>string</p></td>
<td width="2%"></td>
<td width="78%">


<p>The string is printed to the output. Strings start with
a double quote character and contain all characters until
the next double quote character. All characters are take
literally, including any newline. No newline character is
printed after the string.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>print</b> list</p>

<p style="margin-left:22%;">The print statement (an
extension) provides another method of output. The
&quot;list&quot; is a list of strings and expressions
separated by commas. Each string or expression is printed in
the order of the list. No terminating newline is printed.
Expressions are evaluated and their value is printed and
assigned to the variable <b>last</b>. Strings in the print
statement are printed to the output and may contain special
characters. Special characters start with the backslash
character (\). The special characters recognized by
<b>bc</b> are &quot;a&quot; (alert or bell), &quot;b&quot;
(backspace), &quot;f&quot; (form feed), &quot;n&quot;
(newline), &quot;r&quot; (carriage return), &quot;q&quot;
(double quote), &quot;t&quot; (tab), and &quot;\&quot;
(backslash). Any other character following the backslash
will be ignored.</p>

<p style="margin-left:11%;">{ statement_list }</p>

<p style="margin-left:22%;">This is the compound statement.
It allows multiple statements to be grouped together for
execution.</p>

<p style="margin-left:11%;"><b>if</b> ( expression )
statement1 [<b>else</b> statement2]</p>

<p style="margin-left:22%;">The if statement evaluates the
expression and executes statement1 or statement2 depending
on the value of the expression. If the expression is
non-zero, statement1 is executed. If statement2 is present
and the value of the expression is 0, then statement2 is
executed. (The else clause is an extension.)</p>

<p style="margin-left:11%;"><b>while</b> ( expression )
statement</p>

<p style="margin-left:22%;">The while statement will
execute the statement while the expression is non-zero. It
evaluates the expression before each execution of the
statement. Termination of the loop is caused by a zero
expression value or the execution of a break statement.</p>

<p style="margin-left:11%;"><b>for</b> ( [expression1] ;
[expression2] ; [expression3] ) statement</p>

<p style="margin-left:22%;">The for statement controls
repeated execution of the statement. Expression1 is
evaluated before the loop. Expression2 is evaluated before
each execution of the statement. If it is non-zero, the
statement is evaluated. If it is zero, the loop is
terminated. After each execution of the statement,
expression3 is evaluated before the reevaluation of
expression2. If expression1 or expression3 are missing,
nothing is evaluated at the point they would be evaluated.
If expression2 is missing, it is the same as substituting
the value 1 for expression2. (The optional expressions are
an extension. POSIX <b>bc</b> requires all three
expressions.) The following is equivalent code for the for
statement: <br>
expression1; <br>
while (expression2) { <br>
statement; <br>
expression3; <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>break</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>This statement causes a forced exit of the most recent
enclosing while statement or for statement.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>continue</b></p>

<p style="margin-left:22%;">The continue statement (an
extension) causes the most recent enclosing for statement to
start the next iteration.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>halt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The halt statement (an extension) is an executed
statement that causes the <b>bc</b> processor to quit only
when it is executed. For example, &quot;if (0 == 1)
halt&quot; will not cause <b>bc</b> to terminate because the
halt is not executed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>return</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Return the value 0 from a function. (See the section on
functions.)</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>return</b> ( expression
)</p>

<p style="margin-left:22%;">Return the value of the
expression from a function. (See the section on functions.)
As an extension, the parenthesis are not required.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PSEUDO
STATEMENTS</b> <br>
These statements are not statements in the traditional
sense. They are not executed statements. Their function is
performed at &quot;compile&quot; time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>limits</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print the local limits enforced by the local version of
<b>bc</b>. This is an extension.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>quit</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>When the quit statement is read, the <b>bc</b> processor
is terminated, regardless of where the quit statement is
found. For example, &quot;if (0 == 1) quit&quot; will cause
<b>bc</b> to terminate.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>warranty</b></p>

<p style="margin-left:22%;">Print a longer warranty notice.
This is an extension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>FUNCTIONS</b>
<br>
Functions provide a method of defining a computation that
can be executed later. Functions in <b>bc</b> always compute
a value and return it to the caller. Function definitions
are &quot;dynamic&quot; in the sense that a function is
undefined until a definition is encountered in the input.
That definition is then used until another definition
function for the same name is encountered. The new
definition then replaces the older definition. A function is
defined as follows:</p>

<p style="margin-left:22%;"><b>define</b> <i>name</i>
<b>(</b> <i>parameters</i> <b>) {</b> <i>newline <br>
auto_list statement_list</i> <b>}</b></p>

<p style="margin-left:11%;">A function call is just an
expression of the form
&quot;<i>name</i><b>(</b><i>parameters</i><b>)</b>&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Parameters are
numbers or arrays (an extension). In the function
definition, zero or more parameters are defined by listing
their names separated by commas. All parameters are call by
value parameters. Arrays are specified in the parameter
definition by the notation &quot;<i>name</i><b>[]</b>&quot;.
In the function call, actual parameters are full expressions
for number parameters. The same notation is used for passing
arrays as for defining array parameters. The named array is
passed by value to the function. Since function definitions
are dynamic, parameter numbers and types are checked when a
function is called. Any mismatch in number or types of
parameters will cause a runtime error. A runtime error will
also occur for the call to an undefined function.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>auto_list</i> is an optional list of variables that are
for &quot;local&quot; use. The syntax of the auto list (if
present) is &quot;<b>auto</b> <i>name</i>, ... ;&quot;. (The
semicolon is optional.) Each <i>name</i> is the name of an
auto variable. Arrays may be specified by using the same
notation as used in parameters. These variables have their
values pushed onto a stack at the start of the function. The
variables are then initialized to zero and used throughout
the execution of the function. At function exit, these
variables are popped so that the original value (at the time
of the function call) of these variables are restored. The
parameters are really auto variables that are initialized to
a value provided in the function call. Auto variables are
different than traditional local variables because if
function A calls function B, B may access function A&rsquo;s
auto variables by just using the same name, unless function
B has called them auto variables. Due to the fact that auto
variables and parameters are pushed onto a stack, <b>bc</b>
supports recursive functions.</p>

<p style="margin-left:11%; margin-top: 1em">The function
body is a list of <b>bc</b> statements. Again, statements
are separated by semicolons or newlines. Return statements
cause the termination of a function and the return of a
value. There are two versions of the return statement. The
first form, &quot;<b>return</b>&quot;, returns the value 0
to the calling expression. The second form, &quot;<b>return
(</b> <i>expression</i> <b>)</b>&quot;, computes the value
of the expression and returns that value to the calling
expression. There is an implied &quot;<b>return
(0)</b>&quot; at the end of every function. This allows a
function to terminate and return 0 without an explicit
return statement.</p>

<p style="margin-left:11%; margin-top: 1em">Functions also
change the usage of the variable <b>ibase</b>. All constants
in the function body will be converted using the value of
<b>ibase</b> at the time of the function call. Changes of
<b>ibase</b> will be ignored during the execution of the
function except for the standard function <b>read</b>, which
will always use the current value of <b>ibase</b> for
conversion of numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Several
extensions have been added to functions. First, the format
of the definition has been slightly relaxed. The standard
requires the opening brace be on the same line as the
<b>define</b> keyword and all other parts must be on
following lines. This version of <b>bc</b> will allow any
number of newlines before and after the opening brace of the
function. For example, the following definitions are
legal.</p>

<pre style="margin-left:22%;">define d (n) { return (2*n); }
define d (n)
  { return (2*n); }</pre>


<p style="margin-left:11%; margin-top: 1em">Functions may
be defined as <b>void</b>. A void funtion returns no value
and thus may not be used in any place that needs a value. A
void function does not produce any output when called by
itself on an input line. The key word <b>void</b> is placed
between the key word <b>define</b> and the function name.
For example, consider the following session.</p>

<pre style="margin-left:22%;">define py (y) { print &quot;---&gt;&quot;, y, &quot;&lt;---&quot;, &quot;0; }
define void px (x) { print &quot;---&gt;&quot;, x, &quot;&lt;---&quot;, &quot;0; }
py(1)
---&gt;1&lt;---
0
px(1)
---&gt;1&lt;---</pre>


<p style="margin-left:11%;">Since <b>py</b> is not a void
function, the call of <b>py(1)</b> prints the desired output
and then prints a second line that is the value of the
function. Since the value of a function that is not given an
explicit return statement is zero, the zero is printed. For
<b>px(1)</b>, no zero is printed because the function is a
void function.</p>

<p style="margin-left:11%; margin-top: 1em">Also, call by
variable for arrays was added. To declare a call by variable
array, the declaration of the array parameter in the
function definition looks like
&quot;<i>*name</i><b>[]</b>&quot;. The call to the function
remains the same as call by value arrays.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MATH
LIBRARY</b> <br>
If <b>bc</b> is invoked with the <b>-l</b> option, a math
library is preloaded and the default scale is set to 20. The
math functions will calculate their results to the scale set
at the time of their call. The math library defines the
following functions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>s (<i>x</i>)</p></td>
<td width="4%"></td>
<td width="78%">


<p>The sine of x, x is in radians.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>c (<i>x</i>)</p></td>
<td width="4%"></td>
<td width="78%">


<p>The cosine of x, x is in radians.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>a (<i>x</i>)</p></td>
<td width="4%"></td>
<td width="78%">


<p>The arctangent of x, arctangent returns radians.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>l (<i>x</i>)</p></td>
<td width="4%"></td>
<td width="78%">


<p>The natural logarithm of x.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>e (<i>x</i>)</p></td>
<td width="4%"></td>
<td width="78%">


<p>The exponential function of raising e to the value
x.</p> </td></tr>
</table>

<p style="margin-left:11%;">j (<i>n,x</i>)</p>

<p style="margin-left:22%;">The Bessel function of integer
order n of x.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EXAMPLES</b>
<br>
In /bin/sh, the following will assign the value of
&quot;pi&quot; to the shell variable <b>pi</b>.</p>

<p style="margin-left:22%;"><tt>pi=$(echo &quot;scale=10;
4*a(1)&quot; | bc -l)</tt></p>

<p style="margin-left:11%; margin-top: 1em">The following
is the definition of the exponential function used in the
math library. This function is written in POSIX
<b>bc</b>.</p>
<pre style="margin-left:22%;">scale = 20

/* Uses the fact that e^x = (e^(x/2))^2
   When x is small enough, we use the series:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) {
  auto  a, d, e, f, i, m, v, z

  /* Check the sign of x. */
  if (x&lt;0) {
    m = 1
    x = -x
  }

  /* Precondition x. */
  z = scale;
  scale = 4 + z + .44*x;
  while (x &gt; 1) {
    f += 1;
    x /= 2;
  }

  /* Initialize the variables. */
  v = 1+x
  a = x
  d = 1


  for (i=2; 1; i++) {
    e = (a *= x) / (d *= i)
    if (e == 0) {
      if (f&gt;0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    }
    v += e
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">The following
is code that uses the extended features of <b>bc</b> to
implement a simple program for calculating checkbook
balances. This program is best kept in a file so that it can
be used many times without having to retype it at every
use.</p>
<pre style="margin-left:22%;">scale=2
print &quot;\nCheck book program!\n&quot;
print &quot;  Remember, deposits are negative transactions.\n&quot;
print &quot;  Exit by a 0 transaction.\n\n&quot;


print &quot;Initial balance? &quot;; bal = read()
bal /= 1
print &quot;\n&quot;
while (1) {
  &quot;current balance = &quot;; bal
  &quot;transaction? &quot;; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
}
quit</pre>


<p style="margin-left:11%; margin-top: 1em">The following
is the definition of the recursive factorial function.</p>

<pre style="margin-left:22%;">define f (x) {
  if (x &lt;= 1) return (1);
  return (f(x-1) * x);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>READLINE AND
LIBEDIT OPTIONS</b> <br>
GNU <b>bc</b> can be compiled (via a configure option) to
use the GNU <b>readline</b> input editor library or the BSD
<b>libedit</b> library. This allows the user to do editing
of lines before sending them to <b>bc</b>. It also allows
for a history of previous lines typed. When this option is
selected, <b>bc</b> has one more special variable. This
special variable, <b>history</b> is the number of lines of
history retained. For <b>readline</b>, a value of -1 means
that an unlimited number of history lines are retained.
Setting the value of <b>history</b> to a positive number
restricts the number of history lines to the number given.
The value of 0 disables the history feature. The default
value is 100. For more information, read the user manuals
for the GNU <b>readline</b>, <b>history</b> and BSD
<b>libedit</b> libraries. One can not enable both
<b>readline</b> and <b>libedit</b> at the same time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DIFFERENCES</b>
<br>
This version of <b>bc</b> was implemented from the POSIX
P1003.2/D11 draft and contains several differences and
extensions relative to the draft and traditional
implementations. It is not implemented in the traditional
way using <i>dc(1).</i> This version is a single process
which parses and runs a byte code translation of the
program. There is an &quot;undocumented&quot; option (-c)
that causes the program to output the byte code to the
standard output instead of running it. It was mainly used
for debugging the parser and preparing the math library.</p>

<p style="margin-left:11%; margin-top: 1em">A major source
of differences is extensions, where a feature is extended to
add more functionality and additions, where new features are
added. The following is the list of differences and
extensions. <br>
LANG environment</p>

<p style="margin-left:22%;">This version does not conform
to the POSIX standard in the processing of the LANG
environment variable and all environment variables starting
with LC_.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p>names</p></td>
<td width="4%"></td>
<td width="78%">


<p>Traditional and POSIX <b>bc</b> have single letter names
for functions, variables and arrays. They have been extended
to be multi-character names that start with a letter and may
contain letters, numbers and the underscore character.</p></td></tr>
</table>

<p style="margin-left:11%;">Strings</p>

<p style="margin-left:22%;">Strings are not allowed to
contain NUL characters. POSIX says all characters must be
included in strings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>last</p></td>
<td width="5%"></td>
<td width="78%">


<p>POSIX <b>bc</b> does not have a <b>last</b> variable.
Some implementations of <b>bc</b> use the period (.) in a
similar way.</p></td></tr>
</table>

<p style="margin-left:11%;">comparisons</p>

<p style="margin-left:22%;">POSIX <b>bc</b> allows
comparisons only in the if statement, the while statement,
and the second expression of the for statement. Also, only
one relational operation is allowed in each of those
statements.</p>

<p style="margin-left:11%;">if statement, else clause</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not have
an else clause.</p>

<p style="margin-left:11%;">for statement</p>

<p style="margin-left:22%;">POSIX <b>bc</b> requires all
expressions to be present in the for statement.</p>

<p style="margin-left:11%;">&amp;&amp;, ||, !</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not have
the logical operators.</p>

<p style="margin-left:11%;">read function</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not have a
read function.</p>

<p style="margin-left:11%;">print statement</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not have a
print statement .</p>

<p style="margin-left:11%;">continue statement</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not have a
continue statement.</p>

<p style="margin-left:11%;">return statement</p>

<p style="margin-left:22%;">POSIX <b>bc</b> requires
parentheses around the return expression.</p>

<p style="margin-left:11%;">array parameters</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not
(currently) support array parameters in full. The POSIX
grammar allows for arrays in function definitions, but does
not provide a method to specify an array as an actual
parameter. (This is most likely an oversight in the
grammar.) Traditional implementations of <b>bc</b> have only
call by value array parameters.</p>

<p style="margin-left:11%;">function format</p>

<p style="margin-left:22%;">POSIX <b>bc</b> requires the
opening brace on the same line as the <b>define</b> key word
and the <b>auto</b> statement on the next line.</p>

<p style="margin-left:11%;">=+, =-, =*, =/, =%, =^</p>

<p style="margin-left:22%;">POSIX <b>bc</b> does not
require these &quot;old style&quot; assignment operators to
be defined. This version may allow these &quot;old
style&quot; assignments. Use the limits statement to see if
the installed version supports them. If it does support the
&quot;old style&quot; assignment operators, the statement
&quot;a =- 1&quot; will decrement <b>a</b> by 1 instead of
setting <b>a</b> to the value -1.</p>

<p style="margin-left:11%;">spaces in numbers</p>

<p style="margin-left:22%;">Other implementations of
<b>bc</b> allow spaces in numbers. For example, &quot;x=1
3&quot; would assign the value 13 to the variable x. The
same statement would cause a syntax error in this version of
<b>bc</b>.</p>

<p style="margin-left:11%;">errors and execution</p>

<p style="margin-left:22%;">This implementation varies from
other implementations in terms of what code will be executed
when syntax and other errors are found in the program. If a
syntax error is found in a function definition, error
recovery tries to find the beginning of a statement and
continue to parse the function. Once a syntax error is found
in the function, the function will not be callable and
becomes undefined. Syntax errors in the interactive
execution code will invalidate the current execution block.
The execution block is terminated by an end of line that
appears after a complete sequence of statements. For
example, <br>
a = 1 <br>
b = 2</p>

<p style="margin-left:11%;">has two execution blocks
and</p>

<p style="margin-left:22%;">{ a = 1 <br>
b = 2 }</p>

<p style="margin-left:11%;">has one execution block. Any
runtime error will terminate the execution of the current
execution block. A runtime warning will not terminate the
current execution block. <br>
Interrupts</p>

<p style="margin-left:22%;">During an interactive session,
the SIGINT signal (usually generated by the control-C
character from the terminal) will cause execution of the
current execution block to be interrupted. It will display a
&quot;runtime&quot; error indicating which function was
interrupted. After all runtime structures have been cleaned
up, a message will be printed to notify the user that
<b>bc</b> is ready for more input. All previously defined
functions remain defined and the value of all non-auto
variables are the value at the point of interruption. All
auto variables and function parameters are removed during
the clean up process. During a non-interactive session, the
SIGINT signal will terminate the entire run of
<b>bc</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIMITS</b>
<br>
The following are the limits currently in place for this
<b>bc</b> processor. Some of them may have been changed by
an installation. Use the limits statement to see the actual
values. <br>
BC_BASE_MAX</p>

<p style="margin-left:22%;">The maximum output base is
currently set at 999. The maximum input base is 16.</p>

<p style="margin-left:11%;">BC_DIM_MAX</p>

<p style="margin-left:22%;">This is currently an arbitrary
limit of 65535 as distributed. Your installation may be
different.</p>

<p style="margin-left:11%;">BC_SCALE_MAX</p>

<p style="margin-left:22%;">The number of digits after the
decimal point is limited to INT_MAX digits. Also, the number
of digits before the decimal point is limited to INT_MAX
digits.</p>

<p style="margin-left:11%;">BC_STRING_MAX</p>

<p style="margin-left:22%;">The limit on the number of
characters in a string is INT_MAX characters.</p>

<p style="margin-left:11%;">exponent</p>

<p style="margin-left:22%;">The value of the exponent in
the raise operation (^) is limited to LONG_MAX.</p>

<p style="margin-left:11%;">variable names</p>

<p style="margin-left:22%;">The current limit on the number
of unique names is 32767 for each of simple variables,
arrays and functions.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
environment variables are processed by <b>bc</b>: <br>
POSIXLY_CORRECT</p>

<p style="margin-left:22%;">This is the same as the
<b>-s</b> option.</p>

<p style="margin-left:11%;">BC_ENV_ARGS</p>

<p style="margin-left:22%;">This is another mechanism to
get arguments to <b>bc</b>. The format is the same as the
command line arguments. These arguments are processed first,
so any files listed in the environment arguments are
processed before any command line argument files. This
allows the user to set up &quot;standard&quot; options and
files to be processed at every invocation of <b>bc</b>. The
files in the environment variables would typically contain
function definitions for functions the user wants defined
every time <b>bc</b> is run.</p>

<p style="margin-left:11%;">BC_LINE_LENGTH</p>

<p style="margin-left:22%;">This should be an integer
specifying the number of characters in an output line for
numbers. This includes the backslash and newline characters
for long numbers. As an extension, the value of zero
disables the multi-line feature. Any other value of this
variable that is less than 3 sets the line length to 70.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If any file on
the command line can not be opened, <b>bc</b> will report
that the file is unavailable and terminate. Also, there are
compile and run time diagnostics that should be
self-explanatory.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Error recovery
is not very good yet.</p>

<p style="margin-left:11%; margin-top: 1em">Email bug
reports to <b>bug-bc@gnu.org</b>. Be sure to include the
word &lsquo;&lsquo;bc&rsquo;&rsquo; somewhere in the
&lsquo;&lsquo;Subject:&rsquo;&rsquo; field.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Philip A.
Nelson <br>
philnelson@acm.org</p>

<h2>ACKNOWLEDGEMENTS
<a name="ACKNOWLEDGEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The author
would like to thank Steve Sommars (Steve.Sommars@att.com)
for his extensive help in testing the implementation. Many
great suggestions were given. This is a much better product
due to his involvement.</p>
<hr>
</body>
</html>
