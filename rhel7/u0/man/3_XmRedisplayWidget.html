<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Sat Nov 12 02:44:08 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XmRedisplayWidget</title>

</head>
<body>

<h1 align="center">XmRedisplayWidget</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#ERRORS/WARNINGS">ERRORS/WARNINGS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XmRedisplayWidget</b>
&mdash; Synchronously activates the <b>expose</b> method of
a widget to draw its content</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;Xm/Xm.h&gt; <b><br>
voidXmRedisplayWidget</b>( <b><br>
Widgetwidget</b>);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This function
is a convenience routine that hides the details of the Xt
internals to the application programmer by calling the
<b>expose</b> method of the given widget with a well formed
<b>Expose</b> event and <b>Region</b> corresponding to the
total area of the widget. If the widget doesn&rsquo;t have
an <b>Expose</b> method, the function does nothing.</p>

<p style="margin-left:11%; margin-top: 1em">This is
primarily used in the context of X Printing if the
programming model chosen by the application is
<i>synchronous</i>; that is, it doesn&rsquo;t rely of X
Print events for the driving of page layout but wants to
completely control the sequence of rendering requests.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XmRedisplayWidget</b>
doesn&rsquo;t clear the widget window prior to calling the
<b>expose</b> method, since this is handled by calls to
<b>XpStartPage</b> .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><i>widget</i></p></td>
<td width="6%"></td>
<td width="37%">


<p>The widget to redisplay.</p></td>
<td width="37%">
</td></tr>
</table>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">None.</p>

<h2>ERRORS/WARNINGS
<a name="ERRORS/WARNINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Not
applicable</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In the
following, a simple application wants to print the content
of a multi-page text widget (similar to <b>dtpad</b>).</p>
<pre style="margin-left:11%; margin-top: 1em">PrintOKCallback(print_dialog...)
/*-------------*/
{
    pshell = XmPrintSetup (print_dialog, pbs-&gt;print_screen,
                                   &quot;Print&quot;, NULL, 0);

    XpStartJob(XtDisplay(pshell), XPSpool);

    /**** here I realize the shell, get its size, create my widget
     hierarchy: a bulletin board, and then a text widget,
     that I stuff with the video text widget buffer */

    /* get the total number of pages to print */
    XtVaGetValues(ptext, XmNrows, &amp;prows,
                         XmNtotalLines, n_lines, NULL);
    n_pages = n_lines / prows;

    /***** now print the pages in a loop */

    for (cur_page=0; cur_page != n_pages; cur_page++) {

               XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
               XmRedisplayWidget(ptext);  /* do the drawing */
               XpEndPage(XtDisplay(pshell));

        XmTextScroll(ptext, prows);  /* get ready for next page */
    }

    /***** I&rsquo;m done */
    XpEndJob(XtDisplay(pshell));

}</pre>

<p style="margin-left:11%; margin-top: 1em">Of course, one
could change the above code to include it in a <b>fork()</b>
branch so that the main program is not blocked while
printing is going on. Another way to achieve a
&quot;print-in-the-background&quot; effect is to use an Xt
workproc. Using the same sample application, that gives
us:</p>
<pre style="margin-left:11%; margin-top: 1em">Boolean
PrintOnePageWP(XtPointer npages) /* workproc */
/*-------------*/
{
    static int cur_page = 0;
    cur_page++;

    XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
    XmRedisplayWidget(ptext);  /* do the drawing */
    XpEndPage(XtDisplay(pshell));

    XmTextScroll(ptext, prows);  /*  get ready for next page */

    if (cur_page == n_pages) { /***** I&rsquo;m done */
        XpEndJob(XtDisplay(pshell));

        XtDestroyWidget(pshell);
        XtCloseDisplay(XtDisplay(pshell));
    }

    return (cur_page == n_pages);
}

PrintOKCallback(...)
/*-------------*/
{
    pshell = XmPrintSetup (widget, pbs-&gt;print_screen,
                                   &quot;Print&quot;, NULL, 0);

    XpStartJob(XtDisplay(pshell), XPSpool);

    /**** here I get the size of the shell, create my widget
          hierarchy: a bulletin board, and then a text widget,
                  that I stuff with the video text widget buffer */

    /* get the total number of pages to print */
    /* ... same code as above example */


    /***** print the pages in the background */
    XtAppAddWorkProc(app_context, PrintOnePageWP, n_pages);
}</pre>


<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XmPrintSetup</b>(3),
<b>XmPrintShell</b>(3)</p>
<hr>
</body>
</html>
